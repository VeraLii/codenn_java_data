[{
	"Path": "java.lang.AbstractStringBuilder.charAt",
	"Comment": "returns the char value in this sequence at the specified index.the first char value is at index 0, the next at index1, and so on, as in array indexing.the index argument must be greater than or equal to0, and less than the length of this sequence.if the char value specified by the index is asurrogate, the surrogatevalue is returned.",
	"Method": "char charAt(int index){\r\n    if ((index < 0) || (index >= count))\r\n        throw new StringIndexOutOfBoundsException(index);\r\n    return value[index];\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.TestUtilities.deeplyEnclosedJavaTestFiles",
	"Comment": "returns all the java files that are descendants of the given directory.",
	"Method": "List<File> deeplyEnclosedJavaTestFiles(File directory){\r\n    if (!directory.exists()) {\r\n        throw new IllegalArgumentException(\"directory does not exist: \" + directory + \" \" + directory.getAbsolutePath());\r\n    }\r\n    if (!directory.isDirectory()) {\r\n        throw new IllegalArgumentException(\"found file instead of directory: \" + directory);\r\n    }\r\n    List<File> javaFiles = new ArrayList();\r\n    File[] in = directory.listFiles();\r\n    Arrays.sort(in, new Comparator<File>() {\r\n        @Override\r\n        public int compare(File o1, File o2) {\r\n            return o1.getName().compareTo(o2.getName());\r\n        }\r\n    });\r\n    for (File file : in) {\r\n        if (file.isDirectory()) {\r\n            javaFiles.addAll(deeplyEnclosedJavaTestFiles(file));\r\n        } else if (isJavaTestFile(file)) {\r\n            javaFiles.add(file);\r\n        }\r\n    }\r\n    return javaFiles;\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.TestUtilities.deeplyEnclosedJavaTestFiles",
	"Comment": "returns all the java files that are descendants of the given directory.",
	"Method": "List<File> deeplyEnclosedJavaTestFiles(File directory){\r\n    return o1.getName().compareTo(o2.getName());\r\n}"
}, {
	"Path": "java.io.DataInputStream.readLine",
	"Comment": "see the general contract of the readlinemethod of datainput.bytesfor this operation are read from the containedinput stream.",
	"Method": "String readLine(){\r\n    char[] buf = lineBuffer;\r\n    if (buf == null) {\r\n        buf = lineBuffer = new char[128];\r\n    }\r\n    int room = buf.length;\r\n    int offset = 0;\r\n    int c;\r\n    loop: while (true) {\r\n        switch(c = in.read()) {\r\n            case -1:\r\n            case '\\n':\r\n                break loop;\r\n            case '\\r':\r\n                int c2 = in.read();\r\n                if ((c2 != '\\n') && (c2 != -1)) {\r\n                    if (!(in instanceof PushbackInputStream)) {\r\n                        this.in = new PushbackInputStream(in);\r\n                    }\r\n                    ((PushbackInputStream) in).unread(c2);\r\n                }\r\n                break loop;\r\n            default:\r\n                if (--room < 0) {\r\n                    buf = new char[offset + 128];\r\n                    room = buf.length - offset - 1;\r\n                    System.arraycopy(lineBuffer, 0, buf, 0, offset);\r\n                    lineBuffer = buf;\r\n                }\r\n                buf[offset++] = (char) c;\r\n                break;\r\n        }\r\n    }\r\n    if ((c == -1) && (offset == 0)) {\r\n        return null;\r\n    }\r\n    return String.copyValueOf(buf, 0, offset);\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeMirror.hasEffectiveAnnotation",
	"Comment": "a version of hasannotation that considers annotations on the upper bound of wildcards andtype variables.",
	"Method": "boolean hasEffectiveAnnotation(Class<? extends Annotation> a,boolean hasEffectiveAnnotation,AnnotationMirror a){\r\n    return AnnotationUtils.containsSame(getEffectiveAnnotations(), a);\r\n}"
}, {
	"Path": "org.checkerframework.checker.guieffect.GuiEffectTypeFactory.getComputedEffectAtCallsite",
	"Comment": "get the effect of a method call at its callsite, acknowledging polymorphic instantiationusing type use annotations.",
	"Method": "Effect getComputedEffectAtCallsite(MethodInvocationTree node,AnnotatedTypeMirror.AnnotatedDeclaredType callerReceiver,ExecutableElement methodElt){\r\n    Effect targetEffect = getDeclaredEffect(methodElt);\r\n    if (targetEffect.isPoly()) {\r\n        AnnotatedTypeMirror srcType = null;\r\n        if (node.getMethodSelect().getKind() == Tree.Kind.MEMBER_SELECT) {\r\n            ExpressionTree src = ((MemberSelectTree) node.getMethodSelect()).getExpression();\r\n            srcType = getAnnotatedType(src);\r\n        } else if (node.getMethodSelect().getKind() == Tree.Kind.IDENTIFIER) {\r\n            if (callerReceiver == null) {\r\n                return targetEffect;\r\n            }\r\n            srcType = callerReceiver;\r\n        } else {\r\n            throw new BugInCF(\"Unexpected getMethodSelect() kind at callsite \" + node);\r\n        }\r\n        if (srcType.hasAnnotation(AlwaysSafe.class)) {\r\n            targetEffect = new Effect(SafeEffect.class);\r\n        } else if (srcType.hasAnnotation(UI.class)) {\r\n            targetEffect = new Effect(UIEffect.class);\r\n        }\r\n    }\r\n    return targetEffect;\r\n}"
}, {
	"Path": "java.io.PrintStream.format",
	"Comment": "writes a formatted string to this output stream using the specifiedformat string and arguments.",
	"Method": "PrintStream format(String format,Object args,PrintStream format,Locale l,String format,Object args){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.TimSort.ensureCapacity",
	"Comment": "ensures that the external array tmp has at least the specifiednumber of elements, increasing its size if necessary.the sizeincreases exponentially to ensure amortized linear time complexity.",
	"Method": "T[] ensureCapacity(int minCapacity){\r\n    if (tmpLen < minCapacity) {\r\n        int newSize = minCapacity;\r\n        newSize |= newSize >> 1;\r\n        newSize |= newSize >> 2;\r\n        newSize |= newSize >> 4;\r\n        newSize |= newSize >> 8;\r\n        newSize |= newSize >> 16;\r\n        newSize++;\r\n        if (newSize < 0)\r\n            newSize = minCapacity;\r\n        else\r\n            newSize = Math.min(newSize, a.length >>> 1);\r\n        @SuppressWarnings({ \"unchecked\", \"UnnecessaryLocalVariable\" })\r\n        T[] newArray = (T[]) java.lang.reflect.Array.newInstance(a.getClass().getComponentType(), newSize);\r\n        tmp = newArray;\r\n        tmpLen = newSize;\r\n        tmpBase = 0;\r\n    }\r\n    return tmp;\r\n}"
}, {
	"Path": "java.util.UUID.compareTo",
	"Comment": "compares this uuid with the specified uuid. the first of two uuids is greater than the second if the mostsignificant field in which the uuids differ is greater for the firstuuid.",
	"Method": "int compareTo(UUID val){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.checker.lock.LockTreeAnnotator.isBinaryComparisonOrInstanceOfOperator",
	"Comment": "indicates that the result of the operation is a boolean value.",
	"Method": "boolean isBinaryComparisonOrInstanceOfOperator(Kind opKind){\r\n    switch(opKind) {\r\n        case EQUAL_TO:\r\n        case NOT_EQUAL_TO:\r\n        case LESS_THAN:\r\n        case LESS_THAN_EQUAL:\r\n        case GREATER_THAN:\r\n        case GREATER_THAN_EQUAL:\r\n        case INSTANCE_OF:\r\n            return true;\r\n        default:\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.DefaultTypeArgumentInference.inferFromAssignment",
	"Comment": "the second half of step 6. use the assignment context to infer a result.",
	"Method": "InferenceResult inferFromAssignment(AnnotatedTypeMirror assignedTo,AnnotatedTypeMirror boxedReturnType,AnnotatedExecutableType methodType,Set<AFConstraint> afArgumentConstraints,InferenceResult inferredArgs,Set<TypeVariable> targets,AnnotatedTypeFactory typeFactory){\r\n    ConstraintMap assignmentConstraints = createAssignmentConstraints(assignedTo, boxedReturnType, methodType, afArgumentConstraints, inferredArgs.toAtmMap(), targets, typeFactory);\r\n    InferenceResult equalitiesResult = equalitiesSolver.solveEqualities(targets, assignmentConstraints, typeFactory);\r\n    Set<TypeVariable> remainingTargets = equalitiesResult.getRemainingTargets(targets, true);\r\n    InferenceResult subtypesResult = subtypesSolver.solveFromSubtypes(remainingTargets, assignmentConstraints, typeFactory);\r\n    equalitiesResult.mergeSubordinate(subtypesResult);\r\n    return equalitiesResult;\r\n}"
}, {
	"Path": "java.io.PushbackReader.mark",
	"Comment": "marks the present position in the stream. the markfor class pushbackreader always throws an exception.",
	"Method": "void mark(int readAheadLimit){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.RegularEnumSet.containsAll",
	"Comment": "returns true if this set contains all of the elementsin the specified collection.",
	"Method": "boolean containsAll(Collection<?> c){\r\n    if (!(c instanceof RegularEnumSet))\r\n        return super.containsAll(c);\r\n    RegularEnumSet es = (RegularEnumSet) c;\r\n    if (es.elementType != elementType)\r\n        return es.isEmpty();\r\n    return (es.elements & ~elements) == 0;\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.StubParser.parseStubUnit",
	"Comment": "delegate to the stub parser to parse the stub file to an ast. subsequently, all work uses theast.",
	"Method": "void parseStubUnit(InputStream inputStream){\r\n    if (debugStubParser) {\r\n        stubDebug(String.format(\"parsing stub file %s\", filename));\r\n    }\r\n    stubUnit = JavaParser.parseStubUnit(inputStream);\r\n    allStubAnnotations = getAllStubAnnotations();\r\n    if (allStubAnnotations.isEmpty()) {\r\n        stubWarnNotFound(String.format(\"No supported annotations found! This likely means stub file %s doesn't import them correctly.\", filename));\r\n    }\r\n}"
}, {
	"Path": "java.security.MessageDigest.getInstance",
	"Comment": "returns a messagedigest object that implements the specified digestalgorithm. a new messagedigest object encapsulating themessagedigestspi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "MessageDigest getInstance(String algorithm,MessageDigest getInstance,String algorithm,String provider,MessageDigest getInstance,String algorithm,Provider provider){\r\n    if (provider == null)\r\n        throw new IllegalArgumentException(\"missing provider\");\r\n    Object[] objs = Security.getImpl(algorithm, \"MessageDigest\", provider);\r\n    if (objs[0] instanceof MessageDigest) {\r\n        MessageDigest md = (MessageDigest) objs[0];\r\n        md.provider = (Provider) objs[1];\r\n        return md;\r\n    } else {\r\n        MessageDigest delegate = new Delegate((MessageDigestSpi) objs[0], algorithm);\r\n        delegate.provider = (Provider) objs[1];\r\n        return delegate;\r\n    }\r\n}"
}, {
	"Path": "java.util.AbstractCollection.finishToArray",
	"Comment": "reallocates the array being used within toarray when the iteratorreturned more elements than expected, and finishes filling it fromthe iterator.",
	"Method": "T[] finishToArray(T[] r,Iterator<?> it){\r\n    int i = r.length;\r\n    while (it.hasNext()) {\r\n        int cap = r.length;\r\n        if (i == cap) {\r\n            int newCap = cap + (cap >> 1) + 1;\r\n            if (newCap - MAX_ARRAY_SIZE > 0)\r\n                newCap = hugeCapacity(cap + 1);\r\n            r = Arrays.copyOf(r, newCap);\r\n        }\r\n        r[i++] = (T) it.next();\r\n    }\r\n    return (i == r.length) ? r : Arrays.copyOf(r, i);\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.trees.TreeBuilder.buildVariableDecl",
	"Comment": "builds an ast tree to declare and initialize a variable. the type of the variable isspecified by a tree.",
	"Method": "VariableTree buildVariableDecl(TypeMirror type,String name,Element owner,ExpressionTree initializer,VariableTree buildVariableDecl,Tree type,String name,Element owner,ExpressionTree initializer){\r\n    Type typeMirror = (Type) TreeUtils.typeOf(type);\r\n    DetachedVarSymbol sym = new DetachedVarSymbol(0, names.fromString(name), typeMirror, (Symbol) owner);\r\n    JCTree.JCModifiers mods = maker.Modifiers(0);\r\n    JCTree.JCVariableDecl decl = maker.VarDef(mods, sym.name, (JCTree.JCExpression) type, (JCTree.JCExpression) initializer);\r\n    decl.setType(typeMirror);\r\n    decl.sym = sym;\r\n    sym.setDeclaration(decl);\r\n    return decl;\r\n}"
}, {
	"Path": "javax.swing.table.AbstractTableModel.fireTableChanged",
	"Comment": "forwards the given notification event to alltablemodellisteners that registeredthemselves as listeners for this table model.",
	"Method": "void fireTableChanged(TableModelEvent e){\r\n    Object[] listeners = listenerList.getListenerList();\r\n    for (int i = listeners.length - 2; i >= 0; i -= 2) {\r\n        if (listeners[i] == TableModelListener.class) {\r\n            ((TableModelListener) listeners[i + 1]).tableChanged(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.element.ElementAnnotationUtil.contains",
	"Comment": "does expectedvalues contain enumvalue. this is just a linear search.",
	"Method": "boolean contains(Object enumValue,Object[] expectedValues){\r\n    for (final Object expected : expectedValues) {\r\n        if (enumValue.equals(expected)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.zip.ZipOutputStream.write",
	"Comment": "writes an array of bytes to the current zip entry data. this methodwill block until all the bytes are written.",
	"Method": "void write(byte[] b,int off,int len){\r\n    ensureOpen();\r\n    if (off < 0 || len < 0 || off > b.length - len) {\r\n        throw new IndexOutOfBoundsException();\r\n    } else if (len == 0) {\r\n        return;\r\n    }\r\n    if (current == null) {\r\n        throw new ZipException(\"no current ZIP entry\");\r\n    }\r\n    ZipEntry entry = current.entry;\r\n    switch(entry.method) {\r\n        case DEFLATED:\r\n            super.write(b, off, len);\r\n            break;\r\n        case STORED:\r\n            written += len;\r\n            if (written - locoff > entry.size) {\r\n                throw new ZipException(\"attempt to write past end of STORED entry\");\r\n            }\r\n            out.write(b, off, len);\r\n            break;\r\n        default:\r\n            throw new ZipException(\"invalid compression method\");\r\n    }\r\n    crc.update(b, off, len);\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceEntriesToInt",
	"Comment": "returns the result of accumulating the given transformationof all entries using the given reducer to combine values,and the given basis as an identity value.",
	"Method": "int reduceEntriesToInt(long parallelismThreshold,ToIntFunction<Map.Entry<K, V>> transformer,int basis,IntBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceEntriesToIntTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "org.checkerframework.common.reflection.MethodValAnnotatedTypeFactory.getMethodNamesFromStringArg",
	"Comment": "returns the string values for the argument passed. the string values are estimated using thevalue checker.",
	"Method": "List<String> getMethodNamesFromStringArg(ExpressionTree arg){\r\n    List<String> methodNames = new ArrayList();\r\n    ValueAnnotatedTypeFactory valueATF = getTypeFactoryOfSubchecker(ValueChecker.class);\r\n    AnnotatedTypeMirror valueAnno = valueATF.getAnnotatedType(arg);\r\n    AnnotationMirror annotation = valueAnno.getAnnotation(StringVal.class);\r\n    if (annotation != null) {\r\n        methodNames = AnnotationUtils.getElementValueArray(annotation, \"value\", String.class, true);\r\n    }\r\n    return methodNames;\r\n}"
}, {
	"Path": "java.io.LineNumberReader.readLine",
	"Comment": "read a line of text.whenever a line terminator isread the current line number is incremented.",
	"Method": "String readLine(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.getMethodSignature",
	"Comment": "returns jvm type signature for given list of parameters and return type.",
	"Method": "String getMethodSignature(Class<?>[] paramTypes,Class<?> retType){\r\n    StringBuilder sbuf = new StringBuilder();\r\n    sbuf.append('(');\r\n    for (int i = 0; i < paramTypes.length; i++) {\r\n        sbuf.append(getClassSignature(paramTypes[i]));\r\n    }\r\n    sbuf.append(')');\r\n    sbuf.append(getClassSignature(retType));\r\n    return sbuf.toString();\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.model.FileConfigurationLocation.detokenisePath",
	"Comment": "process a stored file path for any tokens, and resolve the nix style pathto the local filesystem path encoding.",
	"Method": "String detokenisePath(String path){\r\n    if (path == null) {\r\n        return null;\r\n    }\r\n    String detokenisedPath = replaceProjectToken(path, LEGACY_PROJECT_DIR);\r\n    if (detokenisedPath == null) {\r\n        detokenisedPath = replaceProjectToken(path, IDEA_PROJECT_DIR);\r\n    }\r\n    if (detokenisedPath == null) {\r\n        detokenisedPath = fromUnixPath(path);\r\n    }\r\n    return detokenisedPath;\r\n}"
}, {
	"Path": "org.checkerframework.common.wholeprograminference.WholeProgramInferenceScenes.getEnclosingClassSymbol",
	"Comment": "returns the classsymbol of the class encapsulating tree passed as parameter.",
	"Method": "ClassSymbol getEnclosingClassSymbol(ClassTree classTree,Node field,ClassSymbol getEnclosingClassSymbol,Tree tree){\r\n    Element symbol = TreeUtils.elementFromTree(tree);\r\n    if (symbol instanceof ClassSymbol) {\r\n        return (ClassSymbol) symbol;\r\n    } else if (symbol instanceof VarSymbol) {\r\n        return ((VarSymbol) symbol).asType().asElement().enclClass();\r\n    } else if (symbol instanceof MethodSymbol) {\r\n        return ((MethodSymbol) symbol).enclClass();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.util.TreeSet.iterator",
	"Comment": "returns an iterator over the elements in this set in ascending order.",
	"Method": "Iterator<E> iterator(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "com.mycompany.myapp.security.UserDetailsServiceImpl.loadUserByUsername",
	"Comment": "retrieve an account depending on its login this method is not case sensitive.",
	"Method": "UserDetails loadUserByUsername(String username){\r\n    if (username == null || username.trim().isEmpty()) {\r\n        throw new UsernameNotFoundException(\"Empty username\");\r\n    }\r\n    log.debug(\"Security verification for user '{}'\", username);\r\n    User account = userRepository.getByLogin(username);\r\n    if (account == null) {\r\n        log.info(\"User {} could not be found\", username);\r\n        throw new UsernameNotFoundException(\"user \" + username + \" could not be found\");\r\n    }\r\n    Collection<GrantedAuthority> grantedAuthorities = toGrantedAuthorities(account.getRoleNames());\r\n    String password = account.getPassword();\r\n    boolean enabled = account.getIsEnabled();\r\n    boolean accountNonExpired = true;\r\n    boolean credentialsNonExpired = true;\r\n    boolean accountNonLocked = true;\r\n    return new UserWithId(username, password, enabled, accountNonExpired, credentialsNonExpired, accountNonLocked, grantedAuthorities, account.getId());\r\n}"
}, {
	"Path": "java.util.EnumSet.allOf",
	"Comment": "creates an enum set containing all of the elements in the specifiedelement type.",
	"Method": "EnumSet<E> allOf(Class<E> elementType){\r\n    EnumSet<E> result = noneOf(elementType);\r\n    result.addAll();\r\n    return result;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceKeys",
	"Comment": "returns the result of accumulating the given transformationof all keys using the given reducer to combine values, ornull if none.",
	"Method": "K reduceKeys(long parallelismThreshold,BiFunction<? super K, ? super K, ? extends K> reducer,U reduceKeys,long parallelismThreshold,Function<? super K, ? extends U> transformer,BiFunction<? super U, ? super U, ? extends U> reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceKeysTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, reducer).invoke();\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TypeAnnotationUtils.createCompoundFromAnnotationMirror",
	"Comment": "returns a newly created attribute.compound corresponding to an argument annotationmirror.",
	"Method": "Attribute.Compound createCompoundFromAnnotationMirror(AnnotationMirror am,ProcessingEnvironment env){\r\n    List<Pair<Symbol.MethodSymbol, Attribute>> values = List.nil();\r\n    for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : am.getElementValues().entrySet()) {\r\n        Attribute attribute = attributeFromAnnotationValue(entry.getKey(), entry.getValue(), env);\r\n        values = values.append(new Pair((Symbol.MethodSymbol) entry.getKey(), attribute));\r\n    }\r\n    return new Attribute.Compound((Type.ClassType) am.getAnnotationType(), values);\r\n}"
}, {
	"Path": "java.io.PipedInputStream.read",
	"Comment": "reads the next byte of data from this piped input stream. thevalue byte is returned as an int in the range0 to 255.this method blocks until input data is available, the end of thestream is detected, or an exception is thrown.",
	"Method": "int read(int read,byte b,int off,int len){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.LinkedList.addFirst",
	"Comment": "inserts the specified element at the beginning of this list.",
	"Method": "void addFirst(E e){\r\n    linkFirst(e);\r\n}"
}, {
	"Path": "java.util.TreeMap.predecessor",
	"Comment": "returns the predecessor of the specified entry, or null if no such.",
	"Method": "Entry<K, V> predecessor(Entry<K, V> t){\r\n    if (t == null)\r\n        return null;\r\n    else if (t.left != null) {\r\n        Entry<K, V> p = t.left;\r\n        while (p.right != null) p = p.right;\r\n        return p;\r\n    } else {\r\n        Entry<K, V> p = t.parent;\r\n        Entry<K, V> ch = t;\r\n        while (p != null && ch == p.left) {\r\n            ch = p;\r\n            p = p.parent;\r\n        }\r\n        return p;\r\n    }\r\n}"
}, {
	"Path": "java.io.PushbackInputStream.reset",
	"Comment": "repositions this stream to the position at the time themark method was last called on this input stream. the method reset for classpushbackinputstream does nothing except throw anioexception.",
	"Method": "void reset(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.lang.ref.ReferenceQueue.poll",
	"Comment": "polls this queue to see if a reference object is available.if one isavailable without further delay then it is removed from the queue andreturned.otherwise this method immediately returns null.",
	"Method": "Reference<? extends T> poll(){\r\n    if (head == null)\r\n        return null;\r\n    synchronized (lock) {\r\n        return reallyPoll();\r\n    }\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.PassportDTOService.toEntity",
	"Comment": "converts the passed dto to a passport.convenient for query by example.",
	"Method": "Passport toEntity(PassportDTO dto,Passport toEntity,PassportDTO dto,int depth){\r\n    if (dto == null) {\r\n        return null;\r\n    }\r\n    Passport passport = new Passport();\r\n    passport.setId(dto.id);\r\n    passport.setPassportNumber(dto.passportNumber);\r\n    passport.setExpirationDate(dto.expirationDate);\r\n    if (depth-- > 0) {\r\n        passport.setHolder(userDTOService.toEntity(dto.holder, depth));\r\n    }\r\n    return passport;\r\n}"
}, {
	"Path": "java.util.Hashtable.equals",
	"Comment": "compares the specified object with this map for equality,as per the definition in the map interface.",
	"Method": "boolean equals(Object o,boolean equals,Object o){\r\n    if (o == this)\r\n        return true;\r\n    if (!(o instanceof Map))\r\n        return false;\r\n    Map<?, ?> t = (Map<?, ?>) o;\r\n    if (t.size() != size())\r\n        return false;\r\n    try {\r\n        Iterator<Map.Entry<K, V>> i = entrySet().iterator();\r\n        while (i.hasNext()) {\r\n            Map.Entry<K, V> e = i.next();\r\n            K key = e.getKey();\r\n            V value = e.getValue();\r\n            if (value == null) {\r\n                if (!(t.get(key) == null && t.containsKey(key)))\r\n                    return false;\r\n            } else {\r\n                if (!value.equals(t.get(key)))\r\n                    return false;\r\n            }\r\n        }\r\n    } catch (ClassCastException unused) {\r\n        return false;\r\n    } catch (NullPointerException unused) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "java.io.InputStream.markSupported",
	"Comment": "tests if this input stream supports the mark andreset methods. whether or not mark andreset are supported is an invariant property of aparticular input stream instance. the marksupported methodof inputstream returns false.",
	"Method": "boolean markSupported(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "sun.util.LocaleServiceProviderPool.getAllAvailableLocales",
	"Comment": "returns an array of available locales for all the provider classes.this array is a merged array of all the locales that are provided by eachprovider, including the jre.",
	"Method": "Locale[] getAllAvailableLocales(){\r\n    return AllAvailableLocales.allAvailableLocales.clone();\r\n}"
}, {
	"Path": "java.util.zip.Deflater.finished",
	"Comment": "returns true if the end of the compressed data output stream hasbeen reached.",
	"Method": "boolean finished(){\r\n    synchronized (zsRef) {\r\n        return finished;\r\n    }\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.UseCase3DTOService.save",
	"Comment": "save the passed dto as a new entity or update the corresponding entity if any.",
	"Method": "UseCase3DTO save(UseCase3DTO dto){\r\n    if (dto == null) {\r\n        return null;\r\n    }\r\n    final UseCase3 useCase3;\r\n    if (dto.isIdSet()) {\r\n        UseCase3 useCase3Tmp = useCase3Repository.findOne(dto.id);\r\n        if (useCase3Tmp != null) {\r\n            useCase3 = useCase3Tmp;\r\n        } else {\r\n            useCase3 = new UseCase3();\r\n            useCase3.setId(dto.id);\r\n        }\r\n    } else {\r\n        useCase3 = new UseCase3();\r\n    }\r\n    useCase3.setDummy(dto.dummy);\r\n    if (dto.id2 == null) {\r\n        useCase3.setId2(null);\r\n    } else {\r\n        UseCase2 id2 = useCase3.getId2();\r\n        if (id2 == null || (id2.getId().compareTo(dto.id2.id) != 0)) {\r\n            useCase3.setId2(useCase2Repository.findOne(dto.id2.id));\r\n        }\r\n    }\r\n    return toDTO(useCase3Repository.save(useCase3));\r\n}"
}, {
	"Path": "java.util.jar.Attributes.values",
	"Comment": "returns a collection view of the attribute values contained in this map.",
	"Method": "Collection<Object> values(){\r\n    return map.values();\r\n}"
}, {
	"Path": "java.text.BreakIterator.isBoundary",
	"Comment": "returns true if the specified character offset is a text boundary.",
	"Method": "boolean isBoundary(int offset){\r\n    if (offset == 0) {\r\n        return true;\r\n    }\r\n    int boundary = following(offset - 1);\r\n    if (boundary == DONE) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return boundary == offset;\r\n}"
}, {
	"Path": "com.mycompany.myapp.domain.User.getRoleNames",
	"Comment": "returns the granted authorities for this user. you may overridethis method to provide your own custom authorities.",
	"Method": "List<String> getRoleNames(){\r\n    List<String> roleNames = new ArrayList<String>();\r\n    for (Role role : getRoles()) {\r\n        roleNames.add(role.getRoleName());\r\n    }\r\n    return roleNames;\r\n}"
}, {
	"Path": "java.util.LinkedHashMap.containsValue",
	"Comment": "returns true if this map maps one or more keys to thespecified value.",
	"Method": "boolean containsValue(Object value){\r\n    for (LinkedHashMap.Entry<K, V> e = head; e != null; e = e.after) {\r\n        V v = e.value;\r\n        if (v == value || (value != null && value.equals(v)))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.beans.PropertyDescriptor.findPropertyType",
	"Comment": "returns the property type that corresponds to the read and write method.the type precedence is given to the readmethod.",
	"Method": "Class<?> findPropertyType(Method readMethod,Method writeMethod){\r\n    Class<?> propertyType = null;\r\n    try {\r\n        if (readMethod != null) {\r\n            Class<?>[] params = getParameterTypes(getClass0(), readMethod);\r\n            if (params.length != 0) {\r\n                throw new IntrospectionException(\"bad read method arg count: \" + readMethod);\r\n            }\r\n            propertyType = getReturnType(getClass0(), readMethod);\r\n            if (propertyType == Void.TYPE) {\r\n                throw new IntrospectionException(\"read method \" + readMethod.getName() + \" returns void\");\r\n            }\r\n        }\r\n        if (writeMethod != null) {\r\n            Class<?>[] params = getParameterTypes(getClass0(), writeMethod);\r\n            if (params.length != 1) {\r\n                throw new IntrospectionException(\"bad write method arg count: \" + writeMethod);\r\n            }\r\n            if (propertyType != null && !params[0].isAssignableFrom(propertyType)) {\r\n                throw new IntrospectionException(\"type mismatch between read and write methods\");\r\n            }\r\n            propertyType = params[0];\r\n        }\r\n    } catch (IntrospectionException ex) {\r\n        throw ex;\r\n    }\r\n    return propertyType;\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueTransfer.getArrayOrStringAnnotation",
	"Comment": "gets a value checker annotation relevant for an array or a string.",
	"Method": "AnnotationMirror getArrayOrStringAnnotation(Node arrayOrStringNode){\r\n    AnnotationMirror arrayOrStringAnno = atypefactory.getAnnotationMirror(arrayOrStringNode.getTree(), StringVal.class);\r\n    if (arrayOrStringAnno == null) {\r\n        arrayOrStringAnno = atypefactory.getAnnotationMirror(arrayOrStringNode.getTree(), ArrayLen.class);\r\n    }\r\n    if (arrayOrStringAnno == null) {\r\n        arrayOrStringAnno = atypefactory.getAnnotationMirror(arrayOrStringNode.getTree(), ArrayLenRange.class);\r\n    }\r\n    return arrayOrStringAnno;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.AtmLubVisitor.lub",
	"Comment": "returns an atm that is the least upper bound of type1 and type2 and whose java type islubjavatype. lubjavatype must be a super type or convertible to the java types of type1 andtype2.",
	"Method": "AnnotatedTypeMirror lub(AnnotatedTypeMirror type1,AnnotatedTypeMirror type2,TypeMirror lubJavaType){\r\n    AnnotatedTypeMirror lub = AnnotatedTypeMirror.createType(lubJavaType, atypeFactory, false);\r\n    if (type1.getKind() == TypeKind.NULL) {\r\n        return lubWithNull((AnnotatedNullType) type1, type2, lub);\r\n    }\r\n    if (type2.getKind() == TypeKind.NULL) {\r\n        return lubWithNull((AnnotatedNullType) type2, type1, lub);\r\n    }\r\n    AnnotatedTypeMirror type1AsLub = AnnotatedTypes.asSuper(atypeFactory, type1, lub);\r\n    AnnotatedTypeMirror type2AsLub = AnnotatedTypes.asSuper(atypeFactory, type2, lub);\r\n    visit(type1AsLub, type2AsLub, lub);\r\n    visited.clear();\r\n    return lub;\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.samelen.SameLenVisitor.commonAssignmentCheck",
	"Comment": "modifies the common assignment checks to ensure that samelen annotations are always merged.the check is not relaxed in any way.",
	"Method": "void commonAssignmentCheck(AnnotatedTypeMirror varType,AnnotatedTypeMirror valueType,Tree valueTree,String errorKey){\r\n    if (IndexUtil.isSequenceType(valueType.getUnderlyingType()) && TreeUtils.isExpressionTree(valueTree) && !(valueType.hasAnnotation(PolySameLen.class) && varType.hasAnnotation(PolySameLen.class))) {\r\n        AnnotationMirror am = valueType.getAnnotation(SameLen.class);\r\n        List<String> arraysInAnno = am == null ? new ArrayList() : IndexUtil.getValueOfAnnotationWithStringArgument(am);\r\n        Receiver rec = FlowExpressions.internalReprOf(atypeFactory, (ExpressionTree) valueTree);\r\n        if (rec != null && SameLenAnnotatedTypeFactory.shouldUseInAnnotation(rec)) {\r\n            List<String> names = new ArrayList();\r\n            names.add(rec.toString());\r\n            AnnotationMirror newSameLen = atypeFactory.getCombinedSameLen(arraysInAnno, names);\r\n            valueType.replaceAnnotation(newSameLen);\r\n        }\r\n    }\r\n    super.commonAssignmentCheck(varType, valueType, valueTree, errorKey);\r\n}"
}, {
	"Path": "java.util.Locale.createConstant",
	"Comment": "this method must be called only for creating the locale. constants due to making shortcuts.",
	"Method": "Locale createConstant(String lang,String country){\r\n    BaseLocale base = BaseLocale.createInstance(lang, country);\r\n    return getInstance(base, null);\r\n}"
}, {
	"Path": "java.util.logging.Logger.getResourceBundle",
	"Comment": "retrieve the localization resource bundle for thislogger for the current default locale.note that ifthe result is null, then the logger will use a resourcebundle inherited from its parent.",
	"Method": "ResourceBundle getResourceBundle(){\r\n    return findResourceBundle(getResourceBundleName());\r\n}"
}, {
	"Path": "org.checkerframework.framework.flow.CFAbstractTransfer.standardizeAnnotationFromContract",
	"Comment": "standardize a type qualifier annotation obtained from a contract.",
	"Method": "AnnotationMirror standardizeAnnotationFromContract(AnnotationMirror annoFromContract,FlowExpressionContext flowExprContext,TreePath path){\r\n    if (analysis.dependentTypesHelper != null) {\r\n        return analysis.dependentTypesHelper.standardizeAnnotation(flowExprContext, path, annoFromContract, false);\r\n    } else {\r\n        return annoFromContract;\r\n    }\r\n}"
}, {
	"Path": "java.util.zip.DeflaterOutputStream.close",
	"Comment": "writes remaining compressed data to the output stream and closes theunderlying stream.",
	"Method": "void close(){\r\n    if (!closed) {\r\n        finish();\r\n        if (usesDefaultDeflater)\r\n            def.end();\r\n        out.close();\r\n        closed = true;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.common.basetype.BaseTypeVisitor.shouldBeCaptureConverted",
	"Comment": "identifies cases that would not happen if capture conversion were implemented. these specialcases should be removed when capture conversion is implemented.",
	"Method": "boolean shouldBeCaptureConverted(AnnotatedTypeMirror typeArg,AnnotatedTypeParameterBounds bounds){\r\n    return typeArg.getKind() == TypeKind.WILDCARD && bounds.getUpperBound().getKind() == TypeKind.WILDCARD;\r\n}"
}, {
	"Path": "java.util.Locale.getInstance",
	"Comment": "returns a locale constructed from the givenlanguage, country andvariant. if the same locale instanceis available in the cache, then that instance isreturned. otherwise, a new locale instance iscreated and cached.",
	"Method": "Locale getInstance(String language,String country,String variant,Locale getInstance,String language,String script,String country,String variant,LocaleExtensions extensions,Locale getInstance,BaseLocale baseloc,LocaleExtensions extensions){\r\n    LocaleKey key = new LocaleKey(baseloc, extensions);\r\n    return LOCALECACHE.get(key);\r\n}"
}, {
	"Path": "java.net.URL.hashCode",
	"Comment": "creates an integer suitable for hash table indexing.the hash code is based upon all the url components relevant for urlcomparison. as such, this operation is a blocking operation.",
	"Method": "int hashCode(){\r\n    if (hashCode != -1)\r\n        return hashCode;\r\n    hashCode = handler.hashCode(this);\r\n    return hashCode;\r\n}"
}, {
	"Path": "java.io.FileInputStream.finalize",
	"Comment": "ensures that the close method of this file input stream iscalled when there are no more references to it.",
	"Method": "void finalize(){\r\n    if ((fd != null) && (fd != FileDescriptor.in)) {\r\n        close();\r\n    }\r\n}"
}, {
	"Path": "javax.swing.table.AbstractTableModel.getTableModelListeners",
	"Comment": "returns an array of all the table model listenersregistered on this model.",
	"Method": "TableModelListener[] getTableModelListeners(){\r\n    return listenerList.getListeners(TableModelListener.class);\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.HessianInput.init",
	"Comment": "initialize the hessian stream with the underlying input stream.",
	"Method": "void init(InputStream is){\r\n    _is = is;\r\n    _method = null;\r\n    _isLastChunk = true;\r\n    _chunkLength = 0;\r\n    _peek = -1;\r\n    _refs = null;\r\n    _replyFault = null;\r\n    if (_serializerFactory == null) {\r\n        _serializerFactory = new SerializerFactory();\r\n    }\r\n}"
}, {
	"Path": "java.util.ArrayDeque.clear",
	"Comment": "removes all of the elements from this deque.the deque will be empty after this call returns.",
	"Method": "void clear(){\r\n    int h = head;\r\n    int t = tail;\r\n    if (h != t) {\r\n        head = tail = 0;\r\n        int i = h;\r\n        int mask = elements.length - 1;\r\n        do {\r\n            elements[i] = null;\r\n            i = (i + 1) & mask;\r\n        } while (i != t);\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.LogManager.addLogger",
	"Comment": "add a named logger.this does nothing and returns false if a loggerwith the same name is already registered.the logger factory methods call this method to register eachnewly created logger.the application should retain its own reference to the loggerobject to avoid it being garbage collected.the logmanagermay only retain a weak reference.",
	"Method": "boolean addLogger(Logger logger){\r\n    final String name = logger.getName();\r\n    if (name == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    drainLoggerRefQueueBounded();\r\n    LoggerWeakRef ref = namedLoggers.get(name);\r\n    if (ref != null) {\r\n        if (ref.get() == null) {\r\n            namedLoggers.remove(name);\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    ref = new LoggerWeakRef(logger);\r\n    namedLoggers.put(name, ref);\r\n    Level level = getLevelProperty(name + \".level\", null);\r\n    if (level != null) {\r\n        doSetLevel(logger, level);\r\n    }\r\n    loadLoggerHandlers(logger, name, name + \".handlers\");\r\n    processParentHandlers(logger, name);\r\n    LogNode node = findNode(name);\r\n    node.loggerRef = ref;\r\n    Logger parent = null;\r\n    LogNode nodep = node.parent;\r\n    while (nodep != null) {\r\n        LoggerWeakRef nodeRef = nodep.loggerRef;\r\n        if (nodeRef != null) {\r\n            parent = nodeRef.get();\r\n            if (parent != null) {\r\n                break;\r\n            }\r\n        }\r\n        nodep = nodep.parent;\r\n    }\r\n    if (parent != null) {\r\n        doSetParent(logger, parent);\r\n    }\r\n    node.walkAndSetParent(logger);\r\n    ref.setNode(node);\r\n    return true;\r\n}"
}, {
	"Path": "java.text.MessageFormat.getFormatsByArgumentIndex",
	"Comment": "gets the formats used for the values passed intoformat methods or returned from parsemethods. the indices of elements in the returned arraycorrespond to the argument indices used in the previously setpattern string.the order of formats in the returned array thus corresponds tothe order of elements in the arguments array passedto the format methods or the result array returnedby the parse methods.if an argument index is used for more than one format elementin the pattern string, then the format used for the last suchformat element is returned in the array. if an argument indexis not used for any format element in the pattern string, thennull is returned in the array.",
	"Method": "Format[] getFormatsByArgumentIndex(){\r\n    int maximumArgumentNumber = -1;\r\n    for (int i = 0; i <= maxOffset; i++) {\r\n        if (argumentNumbers[i] > maximumArgumentNumber) {\r\n            maximumArgumentNumber = argumentNumbers[i];\r\n        }\r\n    }\r\n    Format[] resultArray = new Format[maximumArgumentNumber + 1];\r\n    for (int i = 0; i <= maxOffset; i++) {\r\n        resultArray[argumentNumbers[i]] = formats[i];\r\n    }\r\n    return resultArray;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.CheckerMain.unshorthandProcessorName",
	"Comment": "given a processor name, tries to expand it to a checker in the fullyqualifiedcheckernameslist. returns that expansion, or the argument itself if the expansion fails.",
	"Method": "String unshorthandProcessorName(String processor,List<String> fullyQualifiedCheckerNames,boolean allowSubcheckers){\r\n    for (final String name : fullyQualifiedCheckerNames) {\r\n        boolean tryMatch = false;\r\n        String[] checkerPath = name.substring(0, name.length() - \"Checker\".length()).split(\"\\\\.\");\r\n        String checkerNameShort = checkerPath[checkerPath.length - 1];\r\n        String checkerName = checkerNameShort + \"Checker\";\r\n        if (name.endsWith(\"Checker\")) {\r\n            checkerPath = name.substring(0, name.length() - \"Checker\".length()).split(\"\\\\.\");\r\n            checkerNameShort = checkerPath[checkerPath.length - 1];\r\n            checkerName = checkerNameShort + \"Checker\";\r\n            tryMatch = true;\r\n        } else if (allowSubcheckers && name.endsWith(\"Subchecker\")) {\r\n            checkerPath = name.substring(0, name.length() - \"Subchecker\".length()).split(\"\\\\.\");\r\n            checkerNameShort = checkerPath[checkerPath.length - 1];\r\n            checkerName = checkerNameShort + \"Subchecker\";\r\n            tryMatch = true;\r\n        }\r\n        if (tryMatch) {\r\n            if (processor.equalsIgnoreCase(checkerName) || processor.equalsIgnoreCase(checkerNameShort)) {\r\n                return name;\r\n            }\r\n        }\r\n    }\r\n    return processor;\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TypesUtils.isClass",
	"Comment": "checks if the type represents a java.lang.class declared type.",
	"Method": "boolean isClass(TypeMirror type){\r\n    return isDeclaredOfName(type, \"java.lang.Class\");\r\n}"
}, {
	"Path": "org.checkerframework.common.wholeprograminference.WholeProgramInferenceScenesHelper.updateAnnotationSetInScene",
	"Comment": "updates the set of annotations in a location of a scene.if there was no previous annotation for that location, then the updated set will be theannotations in newatm.if there was a previous annotation, the updated set will be the lub between theprevious annotation and newatm.",
	"Method": "void updateAnnotationSetInScene(ATypeElement type,AnnotatedTypeFactory atf,String jaifPath,AnnotatedTypeMirror rhsATM,AnnotatedTypeMirror lhsATM,TypeUseLocation defLoc){\r\n    if (rhsATM instanceof AnnotatedNullType && ignoreNullAssignments) {\r\n        return;\r\n    }\r\n    AnnotatedTypeMirror atmFromJaif = AnnotatedTypeMirror.createType(rhsATM.getUnderlyingType(), atf, false);\r\n    typeElementToATM(atmFromJaif, type, atf);\r\n    updatesATMWithLUB(atf, rhsATM, atmFromJaif);\r\n    if (lhsATM instanceof AnnotatedTypeVariable) {\r\n        Set<AnnotationMirror> upperAnnos = ((AnnotatedTypeVariable) lhsATM).getUpperBound().getEffectiveAnnotations();\r\n        if (upperAnnos.size() == rhsATM.getAnnotations().size() && atf.getQualifierHierarchy().isSubtype(rhsATM.getAnnotations(), upperAnnos)) {\r\n            return;\r\n        }\r\n    }\r\n    updateTypeElementFromATM(rhsATM, lhsATM, atf, type, 1, defLoc);\r\n    modifiedScenes.add(jaifPath);\r\n}"
}, {
	"Path": "com.mycompany.myapp.domain.UseCase3Pk.isEmpty",
	"Comment": "helper method to determine if this instance is considered empty, that is,if all the non primary key columns are null.",
	"Method": "boolean isEmpty(){\r\n    return !isId1Set() && !isId2Set();\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.StructuralEqualityComparer.arePrimeAnnosEqual",
	"Comment": "return true if type1 and type2 have the same set of annotations.",
	"Method": "boolean arePrimeAnnosEqual(AnnotatedTypeMirror type1,AnnotatedTypeMirror type2){\r\n    if (currentTop != null) {\r\n        return AnnotationUtils.areSame(type1.getAnnotationInHierarchy(currentTop), type2.getAnnotationInHierarchy(currentTop));\r\n    } else {\r\n        throw new BugInCF(\"currentTop null\");\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.common.basetype.BaseTypeVisitor.visitAnnotation",
	"Comment": "ensure that the annotation arguments comply to their declarations. this needs some specialcasing, as annotation arguments form special trees.",
	"Method": "Void visitAnnotation(AnnotationTree node,Void p){\r\n    List<? extends ExpressionTree> args = node.getArguments();\r\n    if (args.isEmpty()) {\r\n        return null;\r\n    }\r\n    TypeElement anno = (TypeElement) TreeInfo.symbol((JCTree) node.getAnnotationType());\r\n    Name annoName = anno.getQualifiedName();\r\n    if (annoName.contentEquals(DefaultQualifier.class.getName()) || annoName.contentEquals(SuppressWarnings.class.getName())) {\r\n        return null;\r\n    }\r\n    Map<String, AnnotatedTypeMirror> annoTypes = new HashMap();\r\n    for (Element encl : ElementFilter.methodsIn(anno.getEnclosedElements())) {\r\n        AnnotatedExecutableType exeatm = (AnnotatedExecutableType) atypeFactory.getAnnotatedType(encl);\r\n        AnnotatedTypeMirror retty = exeatm.getReturnType();\r\n        annoTypes.put(encl.getSimpleName().toString(), retty);\r\n    }\r\n    for (ExpressionTree arg : args) {\r\n        if (!(arg instanceof AssignmentTree)) {\r\n            continue;\r\n        }\r\n        AssignmentTree at = (AssignmentTree) arg;\r\n        if (at.getExpression().getKind() == Tree.Kind.ANNOTATION) {\r\n            visitAnnotation((AnnotationTree) at.getExpression(), p);\r\n            continue;\r\n        }\r\n        if (at.getExpression().getKind() == Tree.Kind.NEW_ARRAY) {\r\n            NewArrayTree nat = (NewArrayTree) at.getExpression();\r\n            boolean isAnno = false;\r\n            for (ExpressionTree init : nat.getInitializers()) {\r\n                if (init.getKind() == Tree.Kind.ANNOTATION) {\r\n                    visitAnnotation((AnnotationTree) init, p);\r\n                    isAnno = true;\r\n                }\r\n            }\r\n            if (isAnno) {\r\n                continue;\r\n            }\r\n        }\r\n        AnnotatedTypeMirror expected = annoTypes.get(at.getVariable().toString());\r\n        Pair<Tree, AnnotatedTypeMirror> preAssCtxt = visitorState.getAssignmentContext();\r\n        {\r\n            ExpressionTree var = at.getVariable();\r\n            assert var instanceof IdentifierTree : \"Expected IdentifierTree as context. Found: \" + var;\r\n            AnnotatedTypeMirror meth = atypeFactory.getAnnotatedType(var);\r\n            assert meth instanceof AnnotatedExecutableType : \"Expected AnnotatedExecutableType as context. Found: \" + meth;\r\n            AnnotatedTypeMirror newctx = ((AnnotatedExecutableType) meth).getReturnType();\r\n            visitorState.setAssignmentContext(Pair.of((Tree) null, newctx));\r\n        }\r\n        try {\r\n            AnnotatedTypeMirror actual = atypeFactory.getAnnotatedType(at.getExpression());\r\n            if (expected.getKind() != TypeKind.ARRAY) {\r\n                commonAssignmentCheck(expected, actual, at.getExpression(), \"annotation.type.incompatible\");\r\n            } else {\r\n                if (actual.getKind() == TypeKind.ARRAY) {\r\n                    commonAssignmentCheck(expected, actual, at.getExpression(), \"annotation.type.incompatible\");\r\n                } else {\r\n                    commonAssignmentCheck(((AnnotatedArrayType) expected).getComponentType(), actual, at.getExpression(), \"annotation.type.incompatible\");\r\n                }\r\n            }\r\n        } finally {\r\n            visitorState.setAssignmentContext(preAssCtxt);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.util.TreeMap.successor",
	"Comment": "returns the successor of the specified entry, or null if no such.",
	"Method": "TreeMap.Entry<K, V> successor(Entry<K, V> t){\r\n    if (t == null)\r\n        return null;\r\n    else if (t.right != null) {\r\n        Entry<K, V> p = t.right;\r\n        while (p.left != null) p = p.left;\r\n        return p;\r\n    } else {\r\n        Entry<K, V> p = t.parent;\r\n        Entry<K, V> ch = t;\r\n        while (p != null && ch == p.right) {\r\n            ch = p;\r\n            p = p.parent;\r\n        }\r\n        return p;\r\n    }\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.toolwindow.CheckStyleToolWindowPanel.isScrollToSource",
	"Comment": "should we scroll to the selected error in the editor automatically?",
	"Method": "boolean isScrollToSource(){\r\n    return scrollToSource;\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.TypecheckExecutor.readDiagnostics",
	"Comment": "added in case a subclass wishes to filter out errors or add new expected errors. this methodis called immediately before results are checked.",
	"Method": "List<TestDiagnostic> readDiagnostics(TestConfiguration config,CompilationResult compilationResult){\r\n    List<TestDiagnostic> expectedDiagnostics;\r\n    if (config.getDiagnosticFiles() == null || config.getDiagnosticFiles().isEmpty()) {\r\n        expectedDiagnostics = JavaDiagnosticReader.readJavaSourceFiles(compilationResult.getJavaFileObjects());\r\n    } else {\r\n        expectedDiagnostics = JavaDiagnosticReader.readDiagnosticFiles(config.getDiagnosticFiles());\r\n    }\r\n    return expectedDiagnostics;\r\n}"
}, {
	"Path": "java.lang.StringBuffer.writeObject",
	"Comment": "readobject is called to restore the state of the stringbuffer froma stream.",
	"Method": "void writeObject(java.io.ObjectOutputStream s){\r\n    java.io.ObjectOutputStream.PutField fields = s.putFields();\r\n    fields.put(\"value\", value);\r\n    fields.put(\"count\", count);\r\n    fields.put(\"shared\", false);\r\n    s.writeFields();\r\n}"
}, {
	"Path": "java.util.ArrayList.removeAll",
	"Comment": "removes from this list all of its elements that are contained in thespecified collection.",
	"Method": "boolean removeAll(Collection<?> c){\r\n    return batchRemove(c, false);\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TypeAnnotationUtils.createTypeCompoundFromAnnotationMirror",
	"Comment": "returns a newly created attribute.typecompound corresponding to an argument annotationmirror.",
	"Method": "Attribute.TypeCompound createTypeCompoundFromAnnotationMirror(AnnotationMirror am,TypeAnnotationPosition tapos,ProcessingEnvironment env){\r\n    List<Pair<Symbol.MethodSymbol, Attribute>> values = List.nil();\r\n    for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> entry : am.getElementValues().entrySet()) {\r\n        Attribute attribute = attributeFromAnnotationValue(entry.getKey(), entry.getValue(), env);\r\n        values = values.append(new Pair((Symbol.MethodSymbol) entry.getKey(), attribute));\r\n    }\r\n    return new Attribute.TypeCompound((Type.ClassType) am.getAnnotationType(), values, tapos);\r\n}"
}, {
	"Path": "com.alibaba.citrus.generictype.codegen.asm.Type.getObjectType",
	"Comment": "returns the java type corresponding to the given internal name.",
	"Method": "Type getObjectType(String internalName){\r\n    char[] buf = internalName.toCharArray();\r\n    return new Type(buf[0] == '[' ? ARRAY : OBJECT, buf, 0, buf.length);\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.HessianInput.readReply",
	"Comment": "reads a reply as an object.if the reply has a fault, throws the exception.",
	"Method": "Object readReply(Class expectedClass){\r\n    int tag = read();\r\n    if (tag != 'r') {\r\n        error(\"expected hessian reply at \" + codeName(tag));\r\n    }\r\n    int major = read();\r\n    int minor = read();\r\n    tag = read();\r\n    if (tag == 'f') {\r\n        throw prepareFault();\r\n    } else {\r\n        _peek = tag;\r\n        Object value = readObject(expectedClass);\r\n        completeValueReply();\r\n        return value;\r\n    }\r\n}"
}, {
	"Path": "java.lang.Class.getEnumConstants",
	"Comment": "returns the elements of this enum class or null if thisclass object does not represent an enum type.",
	"Method": "T[] getEnumConstants(){\r\n    T[] values = getEnumConstantsShared();\r\n    return (values != null) ? values.clone() : null;\r\n}"
}, {
	"Path": "org.checkerframework.framework.source.SourceChecker.fullMessageOf",
	"Comment": "returns the localized long message corresponding for this key, and returns the defvalue if nolocalized message is found.",
	"Method": "String fullMessageOf(String messageKey,String defValue){\r\n    String key = messageKey;\r\n    do {\r\n        if (messages.containsKey(key)) {\r\n            return messages.getProperty(key);\r\n        }\r\n        int dot = key.indexOf('.');\r\n        if (dot < 0) {\r\n            return defValue;\r\n        }\r\n        key = key.substring(dot + 1);\r\n    } while (true);\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TreeUtils.isStringCompoundConcatenation",
	"Comment": "returns true if the compound assignment tree is a string concatenation.",
	"Method": "boolean isStringCompoundConcatenation(CompoundAssignmentTree tree){\r\n    return (tree.getKind() == Tree.Kind.PLUS_ASSIGNMENT && TypesUtils.isString(TreeUtils.typeOf(tree)));\r\n}"
}, {
	"Path": "java.util.logging.LogRecord.getResourceBundle",
	"Comment": "get the localization resource bundlethis is the resourcebundle that should be used to localizethe message string before formatting it.the result maybe null if the message is not localizable, or if no suitableresourcebundle is available.",
	"Method": "ResourceBundle getResourceBundle(){\r\n    return resourceBundle;\r\n}"
}, {
	"Path": "java.io.FileOutputStream.finalize",
	"Comment": "cleans up the connection to the file, and ensures that theclose method of this file output stream iscalled when there are no more references to this stream.",
	"Method": "void finalize(){\r\n    if (fd != null) {\r\n        if (fd == FileDescriptor.out || fd == FileDescriptor.err) {\r\n            flush();\r\n        } else {\r\n            close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sun.util.resources.LocaleData.createLocaleList",
	"Comment": "this method gets the locale string list from localedatametainfo class andthen contructs the locale array based on the locale string returned above.",
	"Method": "Locale[] createLocaleList(){\r\n    String supportedLocaleString = LocaleDataMetaInfo.getSupportedLocaleString(\"sun.text.resources.FormatData\");\r\n    if (supportedLocaleString.length() == 0) {\r\n        return null;\r\n    }\r\n    int barIndex = supportedLocaleString.indexOf(\"|\");\r\n    StringTokenizer localeStringTokenizer = null;\r\n    if (isNonEuroLangSupported()) {\r\n        localeStringTokenizer = new StringTokenizer(supportedLocaleString.substring(0, barIndex) + supportedLocaleString.substring(barIndex + 1));\r\n    } else {\r\n        localeStringTokenizer = new StringTokenizer(supportedLocaleString.substring(0, barIndex));\r\n    }\r\n    Locale[] locales = new Locale[localeStringTokenizer.countTokens()];\r\n    for (int i = 0; i < locales.length; i++) {\r\n        String currentToken = localeStringTokenizer.nextToken().replace('_', '-');\r\n        if (currentToken.equals(\"ja-JP-JP\")) {\r\n            currentToken = \"ja-JP-u-ca-japanese-x-lvariant-JP\";\r\n        } else if (currentToken.equals(\"th-TH-TH\")) {\r\n            currentToken = \"th-TH-u-nu-thai-x-lvariant-TH\";\r\n        } else if (currentToken.equals(\"no-NO-NY\")) {\r\n            currentToken = \"no-NO-x-lvariant-NY\";\r\n        }\r\n        locales[i] = Locale.forLanguageTag(currentToken);\r\n    }\r\n    return locales;\r\n}"
}, {
	"Path": "java.util.LinkedHashMap.transfer",
	"Comment": "transfers all entries to new table array.this method is calledby superclass resize.it is overridden for performance, as it isfaster to iterate using our linked list.",
	"Method": "void transfer(HashMap.Entry[] newTable){\r\n    int newCapacity = newTable.length;\r\n    for (Entry<K, V> e = header.after; e != header; e = e.after) {\r\n        int index = indexFor(e.hash, newCapacity);\r\n        e.next = newTable[index];\r\n        newTable[index] = e;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.solver.ConstraintMap.addTargetEquality",
	"Comment": "add a constraint indicating that the equivalent is equal to target in the given qualifierhierarchies.",
	"Method": "void addTargetEquality(TypeVariable target,TypeVariable equivalent,AnnotationMirrorSet hierarchies){\r\n    final Equalities equalities = targetToRecords.get(target).equalities;\r\n    final AnnotationMirrorSet equivalentTops = equalities.targets.get(equivalent);\r\n    if (equivalentTops == null) {\r\n        equalities.targets.put(equivalent, new AnnotationMirrorSet(hierarchies));\r\n    } else {\r\n        equivalentTops.addAll(hierarchies);\r\n    }\r\n}"
}, {
	"Path": "java.io.DataOutputStream.writeBytes",
	"Comment": "writes out the string to the underlying output stream as asequence of bytes. each character in the string is written out, insequence, by discarding its high eight bits. if no exception isthrown, the counter written is incremented by thelength of s.",
	"Method": "void writeBytes(String s){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.io.FileInputStream.getFD",
	"Comment": "returns the filedescriptorobjectthat represents the connection tothe actual file in the file system beingused by this fileinputstream.",
	"Method": "FileDescriptor getFD(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.TreeMap.putAll",
	"Comment": "copies all of the mappings from the specified map to this map.these mappings replace any mappings that this map had for anyof the keys currently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> map){\r\n    int mapSize = map.size();\r\n    if (size == 0 && mapSize != 0 && map instanceof SortedMap) {\r\n        Comparator c = ((SortedMap) map).comparator();\r\n        if (c == comparator || (c != null && c.equals(comparator))) {\r\n            ++modCount;\r\n            try {\r\n                buildFromSorted(mapSize, map.entrySet().iterator(), null, null);\r\n            } catch (java.io.IOException cannotHappen) {\r\n            } catch (ClassNotFoundException cannotHappen) {\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    super.putAll(map);\r\n}"
}, {
	"Path": "com.alibaba.citrus.generictype.codegen.asm.Type.getArgumentTypes",
	"Comment": "returns the java types corresponding to the argument types of the givenmethod.",
	"Method": "Type[] getArgumentTypes(String methodDescriptor,Type[] getArgumentTypes,Method method){\r\n    Class[] classes = method.getParameterTypes();\r\n    Type[] types = new Type[classes.length];\r\n    for (int i = classes.length - 1; i >= 0; --i) {\r\n        types[i] = getType(classes[i]);\r\n    }\r\n    return types;\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.InternalUtils.getJavacContext",
	"Comment": "helper function to extract the javac context from the javac processing environment.",
	"Method": "Context getJavacContext(ProcessingEnvironment env){\r\n    return ((JavacProcessingEnvironment) env).getContext();\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.GenericAnnotatedTypeFactory.getAnnotatedTypeVarargsArray",
	"Comment": "returns the type of a varargs array of a method invocation or a constructor invocation.",
	"Method": "AnnotatedTypeMirror getAnnotatedTypeVarargsArray(Tree tree){\r\n    if (!useFlow) {\r\n        return null;\r\n    }\r\n    List<Node> args;\r\n    switch(tree.getKind()) {\r\n        case METHOD_INVOCATION:\r\n            args = getFirstNodeOfKindForTree(tree, MethodInvocationNode.class).getArguments();\r\n            break;\r\n        case NEW_CLASS:\r\n            args = getFirstNodeOfKindForTree(tree, ObjectCreationNode.class).getArguments();\r\n            break;\r\n        default:\r\n            throw new BugInCF(\"Unexpected kind of tree: \" + tree);\r\n    }\r\n    assert !args.isEmpty() : \"Arguments are empty\";\r\n    Node varargsArray = args.get(args.size() - 1);\r\n    AnnotatedTypeMirror varargtype = getAnnotatedType(varargsArray.getTree());\r\n    return varargtype;\r\n}"
}, {
	"Path": "org.checkerframework.checker.lock.LockVisitor.checkOverride",
	"Comment": "ensures that subclass methods are annotated with a stronger or equally strong side effectannotation than the parent class method.",
	"Method": "boolean checkOverride(MethodTree overriderTree,AnnotatedDeclaredType enclosingType,AnnotatedExecutableType overridden,AnnotatedDeclaredType overriddenType){\r\n    boolean isValid = true;\r\n    SideEffectAnnotation seaOfOverriderMethod = atypeFactory.methodSideEffectAnnotation(TreeUtils.elementFromDeclaration(overriderTree), false);\r\n    SideEffectAnnotation seaOfOverridenMethod = atypeFactory.methodSideEffectAnnotation(overridden.getElement(), false);\r\n    if (seaOfOverriderMethod.isWeakerThan(seaOfOverridenMethod)) {\r\n        isValid = false;\r\n        reportFailure(\"override.sideeffect.invalid\", overriderTree, enclosingType, overridden, overriddenType, null, null);\r\n    }\r\n    return super.checkOverride(overriderTree, enclosingType, overridden, overriddenType) && isValid;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeCopier.makeOrReturnCopy",
	"Comment": "for any given object in the type being copied, we only want to generate one copy of thatobject. when that object is encountered again, using the previously generated copy willpreserve the structure of the original annotatedtypemirror.makeorreturncopy first checks to see if an object has been encountered before. if so, itreturns the previously generated duplicate of that object if not, it creates a duplicate ofthe object and stores it in the history, originaltocopy",
	"Method": "T makeOrReturnCopy(T original,IdentityHashMap<AnnotatedTypeMirror, AnnotatedTypeMirror> originalToCopy){\r\n    if (originalToCopy.containsKey(original)) {\r\n        return (T) originalToCopy.get(original);\r\n    }\r\n    final T copy = makeCopy(original);\r\n    originalToCopy.put(original, copy);\r\n    return copy;\r\n}"
}, {
	"Path": "com.alibaba.citrus.generictype.codegen.asm.Type.getElementType",
	"Comment": "returns the type of the elements of this array type. this method shouldonly be used for an array type.",
	"Method": "Type getElementType(){\r\n    return getType(buf, off + getDimensions());\r\n}"
}, {
	"Path": "qual.FrequencyRelations.division",
	"Comment": "division of a scalar by seconds yields hertz. division of a scalar by milliseconds yieldskilohertz. other divisions yield an unannotated value.",
	"Method": "AnnotationMirror division(AnnotatedTypeMirror lht,AnnotatedTypeMirror rht){\r\n    if (UnitsRelationsTools.hasNoUnits(lht)) {\r\n        if (UnitsRelationsTools.hasSpecificUnit(rht, millisecond)) {\r\n            return kilohertz;\r\n        } else if (UnitsRelationsTools.hasSpecificUnit(rht, second)) {\r\n            return hertz;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.util.logging.Logger.config",
	"Comment": "log a config message.if the logger is currently enabled for the config messagelevel then the given message is forwarded to all theregistered output handler objects.",
	"Method": "void config(String msg){\r\n    if (Level.CONFIG.intValue() < levelValue) {\r\n        return;\r\n    }\r\n    log(Level.CONFIG, msg);\r\n}"
}, {
	"Path": "org.checkerframework.checker.units.UnitsRelationsTools.removePrefix",
	"Comment": "removes the prefix value from an annotated type, by constructing and returning a copy of theannotated type without the prefix.",
	"Method": "AnnotationMirror removePrefix(Elements elements,AnnotationMirror unitsAnnotation,AnnotatedTypeMirror removePrefix,Elements elements,AnnotatedTypeMirror annoType){\r\n    AnnotatedTypeMirror result = annoType.deepCopy(false);\r\n    Set<AnnotationMirror> annos = annoType.getAnnotations();\r\n    for (AnnotationMirror anno : annos) {\r\n        AnnotationMirror cleanedMirror = removePrefix(elements, anno);\r\n        if (cleanedMirror != null) {\r\n            result.addAnnotation(cleanedMirror);\r\n        } else {\r\n            result.addAnnotation(anno);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "java.util.regex.Pattern.readObject",
	"Comment": "recompile the pattern instance from a stream.the original patternstring is read in and the object tree is recompiled from it.",
	"Method": "void readObject(java.io.ObjectInputStream s){\r\n    s.defaultReadObject();\r\n    capturingGroupCount = 1;\r\n    localCount = 0;\r\n    compiled = false;\r\n    if (pattern.length() == 0) {\r\n        root = new Start(lastAccept);\r\n        matchRoot = lastAccept;\r\n        compiled = true;\r\n    }\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.Hessian2Input.readHeader",
	"Comment": "reads a header, returning null if there are no headers.h b16 b8 value",
	"Method": "String readHeader(){\r\n    return null;\r\n}"
}, {
	"Path": "java.lang.Character.reverseBytes",
	"Comment": "returns the value obtained by reversing the order of the bytes in thespecified char value.",
	"Method": "char reverseBytes(char ch){\r\n    return (char) (((ch & 0xFF00) >> 8) | (ch << 8));\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.element.ElementAnnotationUtil.getTypeAtLocation",
	"Comment": "given a typepath into a type, return the component type that is located at the end of thetypepath.",
	"Method": "AnnotatedTypeMirror getTypeAtLocation(AnnotatedTypeMirror type,List<TypeAnnotationPosition.TypePathEntry> location){\r\n    if (location.isEmpty() && type.getKind() != TypeKind.DECLARED) {\r\n        return type;\r\n    }\r\n    switch(type.getKind()) {\r\n        case NULL:\r\n            return getLocationTypeANT((AnnotatedNullType) type, location);\r\n        case DECLARED:\r\n            return getLocationTypeADT((AnnotatedDeclaredType) type, location);\r\n        case WILDCARD:\r\n            return getLocationTypeAWT((AnnotatedWildcardType) type, location);\r\n        case TYPEVAR:\r\n            if (TypesUtils.isCaptured((TypeVariable) type.getUnderlyingType())) {\r\n                return type;\r\n            }\r\n            break;\r\n        case ARRAY:\r\n            return getLocationTypeAAT((AnnotatedArrayType) type, location);\r\n        case UNION:\r\n            return getLocationTypeAUT((AnnotatedUnionType) type, location);\r\n        case INTERSECTION:\r\n            return getLocationTypeAIT((AnnotatedIntersectionType) type, location);\r\n        default:\r\n    }\r\n    throw new BugInCF(\"ElementAnnotationUtil.getTypeAtLocation: unexpected annotation with location found for type: \" + type + \" (kind: \" + type.getKind() + \") location: \" + location);\r\n}"
}, {
	"Path": "java.io.PushbackReader.reset",
	"Comment": "resets the stream. the reset method ofpushbackreader always throws an exception.",
	"Method": "void reset(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.util.HessianFreeList.free",
	"Comment": "frees the object.if the free list is full, the object will be garbagecollected.",
	"Method": "boolean free(T obj){\r\n    int top = _top.get();\r\n    if (top < _freeStack.length()) {\r\n        boolean isFree = _freeStack.compareAndSet(top, null, obj);\r\n        _top.compareAndSet(top, top + 1);\r\n        return isFree;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.xml.sax.InputSource.getSystemId",
	"Comment": "get the system identifier for this input source.the getencoding method will return the character encodingof the object pointed to, or null if unknown.if the system id is a url, it will be fully resolved.",
	"Method": "String getSystemId(){\r\n    return systemId;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.visitor.AbstractAtmComboVisitor.defaultAction",
	"Comment": "called by the default implementation of every abstractatmcombovisitor visit method. thismethodns issues a runtime exception by default. in general, it should handle the case where avisit method has been called with a pair of type mirrors that should never be passed to thisparticular visitor.",
	"Method": "RETURN_TYPE defaultAction(AnnotatedTypeMirror type1,AnnotatedTypeMirror type2,PARAM param){\r\n    throw new BugInCF(defaultErrorMessage(type1, type2, param));\r\n}"
}, {
	"Path": "java.io.DataOutputStream.writeInt",
	"Comment": "writes an int to the underlying output stream as fourbytes, high byte first. if no exception is thrown, the counterwritten is incremented by 4.",
	"Method": "void writeInt(int v){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.checker.formatter.FormatUtil.tryFormatSatisfiability",
	"Comment": "throws an exception if the format is not syntactically valid.",
	"Method": "void tryFormatSatisfiability(String format){\r\n    @SuppressWarnings(\"unused\")\r\n    String unused = String.format(format, (Object[]) null);\r\n}"
}, {
	"Path": "java.util.logging.Logger.addHandler",
	"Comment": "add a log handler to receive logging messages.by default, loggers also send their output to their parent logger.typically the root logger is configured with a set of handlersthat essentially act as default handlers for all loggers.",
	"Method": "void addHandler(Handler handler){\r\n    handler.getClass();\r\n    checkAccess();\r\n    handlers.add(handler);\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.ElementUtils.isElementFromByteCode",
	"Comment": "returns true if the element is declared in bytecode. always return false if elt is a package.",
	"Method": "boolean isElementFromByteCode(Element elt,boolean isElementFromByteCode,Element elt,Element orig){\r\n    if (elt == null) {\r\n        return false;\r\n    }\r\n    if (elt instanceof Symbol.ClassSymbol) {\r\n        Symbol.ClassSymbol clss = (Symbol.ClassSymbol) elt;\r\n        if (null != clss.classfile) {\r\n            return (clss.classfile.getName().endsWith(\".class\") || clss.classfile.getName().endsWith(\".class)\") || clss.classfile.getName().endsWith(\".class)]\"));\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    return isElementFromByteCode(elt.getEnclosingElement(), elt);\r\n}"
}, {
	"Path": "java.util.Date.getYear",
	"Comment": "returns a value that is the result of subtracting 1900 from theyear that contains or begins with the instant in time representedby this date object, as interpreted in the localtime zone.",
	"Method": "int getYear(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.solver.ConstraintMap.addTypeSupertype",
	"Comment": "add a constraint indicating that target is a supertype of subtype in the given qualifierhierarchies.",
	"Method": "void addTypeSupertype(TypeVariable target,AnnotatedTypeMirror subtype,AnnotationMirrorSet hierarchies){\r\n    final Supertypes supertypes = targetToRecords.get(target).supertypes;\r\n    final AnnotationMirrorSet supertypeTops = supertypes.types.get(subtype);\r\n    if (supertypeTops == null) {\r\n        supertypes.types.put(subtype, new AnnotationMirrorSet(hierarchies));\r\n    } else {\r\n        supertypeTops.addAll(hierarchies);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.common.subtyping.SubtypingAnnotatedTypeFactory.addCheckedCodeDefaults",
	"Comment": "if necessary, make unqualified the default qualifier. keep most logic in sync with super.",
	"Method": "void addCheckedCodeDefaults(QualifierDefaults defs){\r\n    boolean foundOtherwise = false;\r\n    for (Class<? extends Annotation> qual : getSupportedTypeQualifiers()) {\r\n        DefaultFor defaultFor = qual.getAnnotation(DefaultFor.class);\r\n        if (defaultFor != null) {\r\n            final TypeUseLocation[] locations = defaultFor.value();\r\n            defs.addCheckedCodeDefaults(AnnotationBuilder.fromClass(elements, qual), locations);\r\n            foundOtherwise = foundOtherwise || Arrays.asList(locations).contains(TypeUseLocation.OTHERWISE);\r\n        }\r\n        if (qual.getAnnotation(DefaultQualifierInHierarchy.class) != null) {\r\n            defs.addCheckedCodeDefault(AnnotationBuilder.fromClass(elements, qual), TypeUseLocation.OTHERWISE);\r\n            foundOtherwise = true;\r\n        }\r\n    }\r\n    AnnotationMirror unqualified = AnnotationBuilder.fromClass(elements, Unqualified.class);\r\n    if (!foundOtherwise && this.isSupportedQualifier(unqualified)) {\r\n        defs.addCheckedCodeDefault(unqualified, TypeUseLocation.OTHERWISE);\r\n    }\r\n}"
}, {
	"Path": "java.io.PipedInputStream.receivedLast",
	"Comment": "notifies all waiting threads that the last byte of data has beenreceived.",
	"Method": "void receivedLast(){\r\n    closedByWriter = true;\r\n    notifyAll();\r\n}"
}, {
	"Path": "java.io.RandomAccessFile.readFloat",
	"Comment": "reads a float from this file. this method reads anint value, starting at the current file pointer,as if by the readint methodand then converts that int to a floatusing the intbitstofloat method in classfloat.this method blocks until the four bytes are read, the end of thestream is detected, or an exception is thrown.",
	"Method": "float readFloat(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.logging.LogManager.removePropertyChangeListener",
	"Comment": "removes an event listener for property change events.if the same listener instance has been added to the listener tablethrough multiple invocations of addpropertychangelistener,then an equivalent number ofremovepropertychangelistener invocations are required to removeall instances of that listener from the listener table.returns silently if the given listener is not found.",
	"Method": "void removePropertyChangeListener(PropertyChangeListener l){\r\n    checkAccess();\r\n    changes.removePropertyChangeListener(l);\r\n}"
}, {
	"Path": "java.io.DataOutputStream.flush",
	"Comment": "flushes this data output stream. this forces any buffered outputbytes to be written out to the stream.the flush method of dataoutputstreamcalls the flush method of its underlying output stream.",
	"Method": "void flush(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.MultiGraphQualifierHierarchy.isPolymorphicQualifier",
	"Comment": "sees if a particular annotation mirror is a polymorphic qualifier.",
	"Method": "boolean isPolymorphicQualifier(AnnotationMirror qual){\r\n    return AnnotationUtils.containsSame(polyQualifiers.values(), qual);\r\n}"
}, {
	"Path": "java.text.BreakIterator.getSentenceInstance",
	"Comment": "returns a new breakiterator instancefor sentence breaksfor the given locale.",
	"Method": "BreakIterator getSentenceInstance(BreakIterator getSentenceInstance,Locale locale){\r\n    return getBreakInstance(locale, SENTENCE_INDEX);\r\n}"
}, {
	"Path": "java.io.FilterOutputStream.close",
	"Comment": "closes this output stream and releases any system resourcesassociated with the stream.the close method of filteroutputstreamcalls its flush method, and then calls theclose method of its underlying output stream.",
	"Method": "void close(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.security.MessageDigest.toString",
	"Comment": "returns a string representation of this message digest object.",
	"Method": "String toString(){\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    PrintStream p = new PrintStream(baos);\r\n    p.print(algorithm + \" Message Digest from \" + provider.getName() + \", \");\r\n    switch(state) {\r\n        case INITIAL:\r\n            p.print(\"<initialized>\");\r\n            break;\r\n        case IN_PROGRESS:\r\n            p.print(\"<in progress>\");\r\n            break;\r\n    }\r\n    p.println();\r\n    return (baos.toString());\r\n}"
}, {
	"Path": "java.io.File.canWrite",
	"Comment": "tests whether the application can modify the file denoted by thisabstract pathname.",
	"Method": "boolean canWrite(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "sun.util.resources.LocaleData.getNumberFormatData",
	"Comment": "gets a number format data resource bundle, using privilegesto allow accessing a sun. package.",
	"Method": "ResourceBundle getNumberFormatData(Locale locale){\r\n    return getBundle(\"sun.text.resources.FormatData\", locale);\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.getVisitorState",
	"Comment": "returns the visitorstate instance used by the factory to infer types.",
	"Method": "VisitorState getVisitorState(){\r\n    return this.visitorState;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.createTypeVariableSubstitutor",
	"Comment": "typevariablesubstitutor provides a method to replace type parameters with their arguments.",
	"Method": "TypeVariableSubstitutor createTypeVariableSubstitutor(){\r\n    return new TypeVariableSubstitutor();\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeMirror.getEffectiveAnnotation",
	"Comment": "returns the actual effective annotation mirror used to annotate this type, whose class equalsthe passed annoclass if one exists, null otherwise.",
	"Method": "AnnotationMirror getEffectiveAnnotation(Class<? extends Annotation> annoClass){\r\n    for (AnnotationMirror annoMirror : getEffectiveAnnotations()) {\r\n        if (AnnotationUtils.areSameByClass(annoMirror, annoClass)) {\r\n            return annoMirror;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.util.Collections.singletonMap",
	"Comment": "returns an immutable map, mapping only the specified key to thespecified value.the returned map is serializable.",
	"Method": "Map<K, V> singletonMap(K key,V value){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.security.MessageDigest.getDigestLength",
	"Comment": "returns the length of the digest in bytes, or 0 if this operation isnot supported by the provider and the implementation is not cloneable.",
	"Method": "int getDigestLength(){\r\n    int digestLen = engineGetDigestLength();\r\n    if (digestLen == 0) {\r\n        try {\r\n            MessageDigest md = (MessageDigest) clone();\r\n            byte[] digest = md.digest();\r\n            return digest.length;\r\n        } catch (CloneNotSupportedException e) {\r\n            return digestLen;\r\n        }\r\n    }\r\n    return digestLen;\r\n}"
}, {
	"Path": "com.alibaba.citrus.generictype.codegen.asm.Type.getType",
	"Comment": "returns the java type corresponding to the given type descriptor.",
	"Method": "Type getType(String typeDescriptor,Type getType,Class c,Type getType,char[] buf,int off){\r\n    int len;\r\n    switch(buf[off]) {\r\n        case 'V':\r\n            return VOID_TYPE;\r\n        case 'Z':\r\n            return BOOLEAN_TYPE;\r\n        case 'C':\r\n            return CHAR_TYPE;\r\n        case 'B':\r\n            return BYTE_TYPE;\r\n        case 'S':\r\n            return SHORT_TYPE;\r\n        case 'I':\r\n            return INT_TYPE;\r\n        case 'F':\r\n            return FLOAT_TYPE;\r\n        case 'J':\r\n            return LONG_TYPE;\r\n        case 'D':\r\n            return DOUBLE_TYPE;\r\n        case '[':\r\n            len = 1;\r\n            while (buf[off + len] == '[') {\r\n                ++len;\r\n            }\r\n            if (buf[off + len] == 'L') {\r\n                ++len;\r\n                while (buf[off + len] != ';') {\r\n                    ++len;\r\n                }\r\n            }\r\n            return new Type(ARRAY, buf, off, len + 1);\r\n        default:\r\n            len = 1;\r\n            while (buf[off + len] != ';') {\r\n                ++len;\r\n            }\r\n            return new Type(OBJECT, buf, off + 1, len - 1);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.typeannotator.PropagationTypeAnnotator.visitDeclared",
	"Comment": "sometimes the underlying type parameters of annotatedwildcardtypes are not available on thewildcards themselves. instead, record enclosing class to find the type parameter to use as abackup in visitwildcards.",
	"Method": "Void visitDeclared(AnnotatedDeclaredType declaredType,Void aVoid){\r\n    if (pause) {\r\n        return null;\r\n    }\r\n    parents.addFirst(declaredType);\r\n    super.visitDeclared(declaredType, aVoid);\r\n    parents.removeFirst();\r\n    return null;\r\n}"
}, {
	"Path": "java.util.TreeSet.addAll",
	"Comment": "adds all of the elements in the specified collection to this set.",
	"Method": "boolean addAll(Collection<? extends E> c){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.TreeMap.put",
	"Comment": "associates the specified value with the specified key in this map.if the map previously contained a mapping for the key, the oldvalue is replaced.",
	"Method": "V put(K key,V value,V put,K key,V value){\r\n    Entry<K, V> t = root;\r\n    if (t == null) {\r\n        compare(key, key);\r\n        root = new Entry(key, value, null);\r\n        size = 1;\r\n        modCount++;\r\n        return null;\r\n    }\r\n    int cmp;\r\n    Entry<K, V> parent;\r\n    Comparator<? super K> cpr = comparator;\r\n    if (cpr != null) {\r\n        do {\r\n            parent = t;\r\n            cmp = cpr.compare(key, t.key);\r\n            if (cmp < 0)\r\n                t = t.left;\r\n            else if (cmp > 0)\r\n                t = t.right;\r\n            else\r\n                return t.setValue(value);\r\n        } while (t != null);\r\n    } else {\r\n        if (key == null)\r\n            throw new NullPointerException();\r\n        Comparable<? super K> k = (Comparable<? super K>) key;\r\n        do {\r\n            parent = t;\r\n            cmp = k.compareTo(t.key);\r\n            if (cmp < 0)\r\n                t = t.left;\r\n            else if (cmp > 0)\r\n                t = t.right;\r\n            else\r\n                return t.setValue(value);\r\n        } while (t != null);\r\n    }\r\n    Entry<K, V> e = new Entry(key, value, parent);\r\n    if (cmp < 0)\r\n        parent.left = e;\r\n    else\r\n        parent.right = e;\r\n    fixAfterInsertion(e);\r\n    size++;\r\n    modCount++;\r\n    return null;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.StructuralEqualityComparer.visitDeclared_Array",
	"Comment": "a declared type is equal to an array type if the main qualifiers match.",
	"Method": "Boolean visitDeclared_Array(AnnotatedDeclaredType type1,AnnotatedArrayType type2,Void p){\r\n    return arePrimeAnnosEqual(type1, type2);\r\n}"
}, {
	"Path": "java.util.Vector.toString",
	"Comment": "returns a string representation of this vector, containingthe string representation of each element.",
	"Method": "String toString(){\r\n    return super.toString();\r\n}"
}, {
	"Path": "java.util.regex.Pattern.matcher",
	"Comment": "creates a matcher that will match the given input against this pattern.",
	"Method": "Matcher matcher(CharSequence input){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.containsKey",
	"Comment": "tests whether the specified object reference is a key in this identityhash map.",
	"Method": "boolean containsKey(Object key){\r\n    Object k = maskNull(key);\r\n    Object[] tab = table;\r\n    int len = tab.length;\r\n    int i = hash(k, len);\r\n    while (true) {\r\n        Object item = tab[i];\r\n        if (item == k)\r\n            return true;\r\n        if (item == null)\r\n            return false;\r\n        i = nextKeyIndex(i, len);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.QualifierHierarchy.greatestLowerBounds",
	"Comment": "returns the greatest lower bound of two types. each type is represented as a set of typequalifiers, as is the result.annos1 and annos2 must have the same size, and each annotation in them must be from adifferent type hierarchy.",
	"Method": "Set<? extends AnnotationMirror> greatestLowerBounds(Collection<? extends AnnotationMirror> annos1,Collection<? extends AnnotationMirror> annos2,Set<? extends AnnotationMirror> greatestLowerBounds,AnnotatedTypeMirror type1,AnnotatedTypeMirror type2,Collection<? extends AnnotationMirror> annos1,Collection<AnnotationMirror> annos2){\r\n    if (canHaveEmptyAnnotationSet(type1) || canHaveEmptyAnnotationSet(type2)) {\r\n        return greatestLowerBoundsTypeVariable(annos1, annos2);\r\n    } else {\r\n        return greatestLowerBounds(annos1, annos2);\r\n    }\r\n}"
}, {
	"Path": "java.util.Collections.eq",
	"Comment": "returns true if the specified arguments are equal, or both null.",
	"Method": "boolean eq(Object o1,Object o2){\r\n    return o1 == null ? o2 == null : o1.equals(o2);\r\n}"
}, {
	"Path": "java.io.StringWriter.close",
	"Comment": "closing a stringwriter has no effect. the methods in thisclass can be called after the stream has been closed without generatingan ioexception.",
	"Method": "void close(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.defaults.QualifierDefaults.applyDefaultsElement",
	"Comment": "applies default annotations to a type. conservative defaults are applied first asappropriate, followed by source code defaults.for a discussion on the rules for application of source code and conservative defaults,please see the linked manual sections.",
	"Method": "void applyDefaultsElement(Element annotationScope,AnnotatedTypeMirror type){\r\n    DefaultSet defaults = defaultsAt(annotationScope);\r\n    DefaultApplierElement applier = createDefaultApplierElement(atypeFactory, annotationScope, type, applyToTypeVar);\r\n    for (Default def : defaults) {\r\n        applier.applyDefault(def);\r\n    }\r\n    if (applyUncheckedCodeDefaults(annotationScope)) {\r\n        for (Default def : uncheckedCodeDefaults) {\r\n            applier.applyDefault(def);\r\n        }\r\n    }\r\n    for (Default def : checkedCodeDefaults) {\r\n        applier.applyDefault(def);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.common.basetype.BaseTypeVisitor.checkMethodReferenceInference",
	"Comment": "check if method reference type argument inference is required. issue an error if it is.",
	"Method": "boolean checkMethodReferenceInference(MemberReferenceTree memberReferenceTree,AnnotatedExecutableType invocationType,AnnotatedTypeMirror type){\r\n    boolean requiresInference = false;\r\n    if (invocationType.getTypeVariables().size() > 0 && (memberReferenceTree.getTypeArguments() == null || memberReferenceTree.getTypeArguments().isEmpty())) {\r\n        requiresInference = true;\r\n    } else if (memberReferenceTree.getMode() == ReferenceMode.NEW) {\r\n        if (type.getKind() == TypeKind.DECLARED && ((AnnotatedDeclaredType) type).wasRaw()) {\r\n            requiresInference = true;\r\n        }\r\n    }\r\n    if (requiresInference) {\r\n        if (checker.hasOption(\"conservativeUninferredTypeArguments\")) {\r\n            checker.report(Result.warning(\"methodref.inference.unimplemented\"), memberReferenceTree);\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.AnnotatedTypes.findEffectiveLowerBoundAnnotations",
	"Comment": "when comparing types against the bounds of a type variable, we may encounter other typevariables, wildcards, and intersections in those bounds. this method traverses the lowerbounds until it finds a concrete type from which it can pull an annotation. this occurs forevery hierarchy in qualifierhierarchy",
	"Method": "Set<AnnotationMirror> findEffectiveLowerBoundAnnotations(QualifierHierarchy qualifierHierarchy,AnnotatedTypeMirror toSearch){\r\n    AnnotatedTypeMirror source = toSearch;\r\n    TypeKind kind = source.getKind();\r\n    while (kind == TypeKind.TYPEVAR || kind == TypeKind.WILDCARD || kind == TypeKind.INTERSECTION) {\r\n        switch(source.getKind()) {\r\n            case TYPEVAR:\r\n                source = ((AnnotatedTypeVariable) source).getLowerBound();\r\n                break;\r\n            case WILDCARD:\r\n                source = ((AnnotatedWildcardType) source).getSuperBound();\r\n                break;\r\n            case INTERSECTION:\r\n                final Set<AnnotationMirror> glb = glbOfBounds((AnnotatedIntersectionType) source, qualifierHierarchy);\r\n                return glb;\r\n            default:\r\n                throw new BugInCF(\"Unexpected AnnotatedTypeMirror with no primary annotation;\" + \" toSearch=\" + toSearch + \" source=\" + source);\r\n        }\r\n        kind = source.getKind();\r\n    }\r\n    return source.getAnnotations();\r\n}"
}, {
	"Path": "java.util.zip.InflaterOutputStream.flush",
	"Comment": "flushes this output stream, forcing any pending buffered output bytes to bewritten.",
	"Method": "void flush(){\r\n    ensureOpen();\r\n    if (!inf.finished()) {\r\n        try {\r\n            while (!inf.finished() && !inf.needsInput()) {\r\n                int n;\r\n                n = inf.inflate(buf, 0, buf.length);\r\n                if (n < 1) {\r\n                    break;\r\n                }\r\n                out.write(buf, 0, n);\r\n            }\r\n            super.flush();\r\n        } catch (DataFormatException ex) {\r\n            String msg = ex.getMessage();\r\n            if (msg == null) {\r\n                msg = \"Invalid ZLIB data format\";\r\n            }\r\n            throw new ZipException(msg);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueTransfer.getIntRangeStringLengthRange",
	"Comment": "returns a range of possible lengths for an integer from a range, as casted to a string.",
	"Method": "Range getIntRangeStringLengthRange(Node subNode,TransferInput<CFValue, CFStore> p){\r\n    Range valueRange = getIntRange(subNode, p);\r\n    int fromLength = Long.toString(valueRange.from).length();\r\n    int toLength = Long.toString(valueRange.to).length();\r\n    int lowerLength = Math.min(fromLength, toLength);\r\n    if (valueRange.contains(0)) {\r\n        lowerLength = 1;\r\n    }\r\n    int upperLength = Math.max(fromLength, toLength);\r\n    return new Range(lowerLength, upperLength);\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.AnnotationUtils.containsSame",
	"Comment": "checks that the collection contains the annotation. using collection.contains does not alwayswork, because it does not use aresame for comparison.",
	"Method": "boolean containsSame(Collection<? extends AnnotationMirror> c,AnnotationMirror anno){\r\n    return getSame(c, anno) != null;\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TypesUtils.substituteMethodReturnType",
	"Comment": "returns the return type of a method, given the receiver of the method call.",
	"Method": "TypeMirror substituteMethodReturnType(Element methodElement,TypeMirror substitutedReceiverType,ProcessingEnvironment env){\r\n    com.sun.tools.javac.code.Types types = com.sun.tools.javac.code.Types.instance(InternalUtils.getJavacContext(env));\r\n    Type substitutedMethodType = types.memberType((Type) substitutedReceiverType, (Symbol) methodElement);\r\n    return substitutedMethodType.getReturnType();\r\n}"
}, {
	"Path": "java.util.logging.Logger.info",
	"Comment": "log an info message.if the logger is currently enabled for the info messagelevel then the given message is forwarded to all theregistered output handler objects.",
	"Method": "void info(String msg){\r\n    if (Level.INFO.intValue() < levelValue) {\r\n        return;\r\n    }\r\n    log(Level.INFO, msg);\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.decodeRules",
	"Comment": "given a set of encoded rules in startday and startdayofmonth, decodethem and set the startmode appropriately.do the same for endday andenddayofmonth.upon entry, the day of week variables may be zero ornegative, in order to indicate special modes.the day of monthvariables may also be negative.upon exit, the mode variables will beset, and the day of week and day of month variables will be positive.this method also recognizes a startday or endday of zero as indicatingno dst.",
	"Method": "void decodeRules(){\r\n    decodeStartRule();\r\n    decodeEndRule();\r\n}"
}, {
	"Path": "java.util.zip.GZIPOutputStream.write",
	"Comment": "writes array of bytes to the compressed output stream. this methodwill block until all the bytes are written.",
	"Method": "void write(byte[] buf,int off,int len){\r\n    super.write(buf, off, len);\r\n    crc.update(buf, off, len);\r\n}"
}, {
	"Path": "java.util.Hashtable.putAll",
	"Comment": "copies all of the mappings from the specified map to this hashtable.these mappings will replace any mappings that this hashtable had for anyof the keys currently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> t){\r\n    for (Map.Entry<? extends K, ? extends V> e : t.entrySet()) put(e.getKey(), e.getValue());\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.diagnostics.JavaDiagnosticReader.readDiagnosticLines",
	"Comment": "reads the entire input file using the given codec and returns the resulting line.",
	"Method": "List<TestDiagnosticLine> readDiagnosticLines(Iterable<JavaDiagnosticReader> readers,List<TestDiagnosticLine> readDiagnosticLines,JavaDiagnosticReader reader){\r\n    List<TestDiagnosticLine> diagnosticLines = new ArrayList();\r\n    while (reader.hasNext()) {\r\n        TestDiagnosticLine line = reader.next();\r\n        if (line.hasDiagnostics()) {\r\n            diagnosticLines.add(line);\r\n        }\r\n    }\r\n    reader.close();\r\n    return diagnosticLines;\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.checks.JavadocPackageCheck.parsePackageInfoLegacy",
	"Comment": "retrieve the allowlegacy flag as a string for handling javadoc package info from a checkstyle configuration.",
	"Method": "String parsePackageInfoLegacy(CheckstyleInternalObject config){\r\n    if (config == null) {\r\n        return null;\r\n    }\r\n    final AtomicReference<String> value = new AtomicReference();\r\n    checkstyleProjectService.getCheckstyleInstance().peruseConfiguration(config, module -> {\r\n        if (MODULE_NAME.equals(module.getName()) || CHECK_PACKAGE_INFO.equals(module.getName())) {\r\n            value.set(module.getProperties().get(\"allowLegacy\"));\r\n        }\r\n    });\r\n    return value.get();\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.computeDefaultSUID",
	"Comment": "computes the default serial version uid value for the given class.",
	"Method": "long computeDefaultSUID(Class<?> cl){\r\n    if (!Serializable.class.isAssignableFrom(cl) || Proxy.isProxyClass(cl)) {\r\n        return 0L;\r\n    }\r\n    try {\r\n        ByteArrayOutputStream bout = new ByteArrayOutputStream();\r\n        DataOutputStream dout = new DataOutputStream(bout);\r\n        dout.writeUTF(cl.getName());\r\n        int classMods = cl.getModifiers() & (Modifier.PUBLIC | Modifier.FINAL | Modifier.INTERFACE | Modifier.ABSTRACT);\r\n        Method[] methods = cl.getDeclaredMethods();\r\n        if ((classMods & Modifier.INTERFACE) != 0) {\r\n            classMods = (methods.length > 0) ? (classMods | Modifier.ABSTRACT) : (classMods & ~Modifier.ABSTRACT);\r\n        }\r\n        dout.writeInt(classMods);\r\n        if (!cl.isArray()) {\r\n            Class<?>[] interfaces = cl.getInterfaces();\r\n            String[] ifaceNames = new String[interfaces.length];\r\n            for (int i = 0; i < interfaces.length; i++) {\r\n                ifaceNames[i] = interfaces[i].getName();\r\n            }\r\n            Arrays.sort(ifaceNames);\r\n            for (int i = 0; i < ifaceNames.length; i++) {\r\n                dout.writeUTF(ifaceNames[i]);\r\n            }\r\n        }\r\n        Field[] fields = cl.getDeclaredFields();\r\n        MemberSignature[] fieldSigs = new MemberSignature[fields.length];\r\n        for (int i = 0; i < fields.length; i++) {\r\n            fieldSigs[i] = new MemberSignature(fields[i]);\r\n        }\r\n        Arrays.sort(fieldSigs, new Comparator<MemberSignature>() {\r\n            public int compare(MemberSignature ms1, MemberSignature ms2) {\r\n                return ms1.name.compareTo(ms2.name);\r\n            }\r\n        });\r\n        for (int i = 0; i < fieldSigs.length; i++) {\r\n            MemberSignature sig = fieldSigs[i];\r\n            int mods = sig.member.getModifiers() & (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED | Modifier.STATIC | Modifier.FINAL | Modifier.VOLATILE | Modifier.TRANSIENT);\r\n            if (((mods & Modifier.PRIVATE) == 0) || ((mods & (Modifier.STATIC | Modifier.TRANSIENT)) == 0)) {\r\n                dout.writeUTF(sig.name);\r\n                dout.writeInt(mods);\r\n                dout.writeUTF(sig.signature);\r\n            }\r\n        }\r\n        if (hasStaticInitializer(cl)) {\r\n            dout.writeUTF(\"<clinit>\");\r\n            dout.writeInt(Modifier.STATIC);\r\n            dout.writeUTF(\"()V\");\r\n        }\r\n        Constructor[] cons = cl.getDeclaredConstructors();\r\n        MemberSignature[] consSigs = new MemberSignature[cons.length];\r\n        for (int i = 0; i < cons.length; i++) {\r\n            consSigs[i] = new MemberSignature(cons[i]);\r\n        }\r\n        Arrays.sort(consSigs, new Comparator<MemberSignature>() {\r\n            public int compare(MemberSignature ms1, MemberSignature ms2) {\r\n                return ms1.signature.compareTo(ms2.signature);\r\n            }\r\n        });\r\n        for (int i = 0; i < consSigs.length; i++) {\r\n            MemberSignature sig = consSigs[i];\r\n            int mods = sig.member.getModifiers() & (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED | Modifier.STATIC | Modifier.FINAL | Modifier.SYNCHRONIZED | Modifier.NATIVE | Modifier.ABSTRACT | Modifier.STRICT);\r\n            if ((mods & Modifier.PRIVATE) == 0) {\r\n                dout.writeUTF(\"<init>\");\r\n                dout.writeInt(mods);\r\n                dout.writeUTF(sig.signature.replace('/', '.'));\r\n            }\r\n        }\r\n        MemberSignature[] methSigs = new MemberSignature[methods.length];\r\n        for (int i = 0; i < methods.length; i++) {\r\n            methSigs[i] = new MemberSignature(methods[i]);\r\n        }\r\n        Arrays.sort(methSigs, new Comparator<MemberSignature>() {\r\n            public int compare(MemberSignature ms1, MemberSignature ms2) {\r\n                int comp = ms1.name.compareTo(ms2.name);\r\n                if (comp == 0) {\r\n                    comp = ms1.signature.compareTo(ms2.signature);\r\n                }\r\n                return comp;\r\n            }\r\n        });\r\n        for (int i = 0; i < methSigs.length; i++) {\r\n            MemberSignature sig = methSigs[i];\r\n            int mods = sig.member.getModifiers() & (Modifier.PUBLIC | Modifier.PRIVATE | Modifier.PROTECTED | Modifier.STATIC | Modifier.FINAL | Modifier.SYNCHRONIZED | Modifier.NATIVE | Modifier.ABSTRACT | Modifier.STRICT);\r\n            if ((mods & Modifier.PRIVATE) == 0) {\r\n                dout.writeUTF(sig.name);\r\n                dout.writeInt(mods);\r\n                dout.writeUTF(sig.signature.replace('/', '.'));\r\n            }\r\n        }\r\n        dout.flush();\r\n        MessageDigest md = MessageDigest.getInstance(\"SHA\");\r\n        byte[] hashBytes = md.digest(bout.toByteArray());\r\n        long hash = 0;\r\n        for (int i = Math.min(hashBytes.length, 8) - 1; i >= 0; i--) {\r\n            hash = (hash << 8) | (hashBytes[i] & 0xFF);\r\n        }\r\n        return hash;\r\n    } catch (IOException ex) {\r\n        throw new InternalError();\r\n    } catch (NoSuchAlgorithmException ex) {\r\n        throw new SecurityException(ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.computeDefaultSUID",
	"Comment": "computes the default serial version uid value for the given class.",
	"Method": "long computeDefaultSUID(Class<?> cl){\r\n    return ms1.name.compareTo(ms2.name);\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.computeDefaultSUID",
	"Comment": "computes the default serial version uid value for the given class.",
	"Method": "long computeDefaultSUID(Class<?> cl){\r\n    return ms1.signature.compareTo(ms2.signature);\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.computeDefaultSUID",
	"Comment": "computes the default serial version uid value for the given class.",
	"Method": "long computeDefaultSUID(Class<?> cl){\r\n    int comp = ms1.name.compareTo(ms2.name);\r\n    if (comp == 0) {\r\n        comp = ms1.signature.compareTo(ms2.signature);\r\n    }\r\n    return comp;\r\n}"
}, {
	"Path": "java.lang.String.indexOf",
	"Comment": "code shared by string and stringbuffer to do searches. thesource is the character array being searched, and the targetis the string being searched for.",
	"Method": "int indexOf(int ch,int indexOf,int ch,int fromIndex,int indexOf,String str,int indexOf,String str,int fromIndex,int indexOf,char[] source,int sourceOffset,int sourceCount,String target,int fromIndex,int indexOf,char[] source,int sourceOffset,int sourceCount,char[] target,int targetOffset,int targetCount,int fromIndex){\r\n    if (fromIndex >= sourceCount) {\r\n        return (targetCount == 0 ? sourceCount : -1);\r\n    }\r\n    if (fromIndex < 0) {\r\n        fromIndex = 0;\r\n    }\r\n    if (targetCount == 0) {\r\n        return fromIndex;\r\n    }\r\n    char first = target[targetOffset];\r\n    int max = sourceOffset + (sourceCount - targetCount);\r\n    for (int i = sourceOffset + fromIndex; i <= max; i++) {\r\n        if (source[i] != first) {\r\n            while (++i <= max && source[i] != first) ;\r\n        }\r\n        if (i <= max) {\r\n            int j = i + 1;\r\n            int end = j + targetCount - 1;\r\n            for (int k = targetOffset + 1; j < end && source[j] == target[k]; j++, k++) ;\r\n            if (j == end) {\r\n                return i - sourceOffset;\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.mycompany.myapp.domain.Passport.toString",
	"Comment": "construct a readable string representation for this passport instance.",
	"Method": "String toString(){\r\n    return // \r\n    MoreObjects.toStringHelper(this).add(\"id\", // \r\n    getId()).add(\"passportNumber\", // \r\n    getPassportNumber()).add(\"expirationDate\", getExpirationDate()).toString();\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.getFunctionalInterfaceType",
	"Comment": "get the annotateddeclaredtype for the functionalinterface from assignment context of themethod reference or lambda expression which may be a variable assignment, a method call, or acast.the assignment context is not always correct, so we must search up the ast. it willrecursively search for lambdas nested in lambdas.",
	"Method": "AnnotatedDeclaredType getFunctionalInterfaceType(Tree tree){\r\n    Tree parentTree = getPath(tree).getParentPath().getLeaf();\r\n    switch(parentTree.getKind()) {\r\n        case PARENTHESIZED:\r\n            return getFunctionalInterfaceType(parentTree);\r\n        case TYPE_CAST:\r\n            TypeCastTree cast = (TypeCastTree) parentTree;\r\n            assert isFunctionalInterface(trees.getTypeMirror(getPath(cast.getType())), parentTree, tree);\r\n            AnnotatedTypeMirror castATM = getAnnotatedType(cast.getType());\r\n            if (castATM.getKind() == TypeKind.INTERSECTION) {\r\n                AnnotatedIntersectionType itype = (AnnotatedIntersectionType) castATM;\r\n                for (AnnotatedTypeMirror t : itype.directSuperTypes()) {\r\n                    if (TypesUtils.isFunctionalInterface(t.getUnderlyingType(), getProcessingEnv())) {\r\n                        return (AnnotatedDeclaredType) t;\r\n                    }\r\n                }\r\n                throw new BugInCF(String.format(\"Expected the type of a cast tree in an assignment context to contain a functional interface bound. \" + \"Found type: %s for tree: %s in lambda tree: %s\", castATM, cast, tree));\r\n            }\r\n            return (AnnotatedDeclaredType) castATM;\r\n        case NEW_CLASS:\r\n            NewClassTree newClass = (NewClassTree) parentTree;\r\n            int indexOfLambda = newClass.getArguments().indexOf(tree);\r\n            ParameterizedMethodType con = this.constructorFromUse(newClass);\r\n            AnnotatedTypeMirror constructorParam = AnnotatedTypes.getAnnotatedTypeMirrorOfParameter(con.methodType, indexOfLambda);\r\n            assert isFunctionalInterface(constructorParam.getUnderlyingType(), parentTree, tree);\r\n            return (AnnotatedDeclaredType) constructorParam;\r\n        case NEW_ARRAY:\r\n            NewArrayTree newArray = (NewArrayTree) parentTree;\r\n            AnnotatedArrayType newArrayATM = getAnnotatedType(newArray);\r\n            AnnotatedTypeMirror elementATM = newArrayATM.getComponentType();\r\n            assert isFunctionalInterface(elementATM.getUnderlyingType(), parentTree, tree);\r\n            return (AnnotatedDeclaredType) elementATM;\r\n        case METHOD_INVOCATION:\r\n            MethodInvocationTree method = (MethodInvocationTree) parentTree;\r\n            int index = method.getArguments().indexOf(tree);\r\n            ParameterizedMethodType exe = this.methodFromUse(method);\r\n            AnnotatedTypeMirror param = AnnotatedTypes.getAnnotatedTypeMirrorOfParameter(exe.methodType, index);\r\n            if (param.getKind() == TypeKind.WILDCARD) {\r\n                TypeMirror typeMirror = TreeUtils.typeOf(tree);\r\n                param = AnnotatedTypeMirror.createType(typeMirror, this, false);\r\n                addDefaultAnnotations(param);\r\n            }\r\n            assert isFunctionalInterface(param.getUnderlyingType(), parentTree, tree);\r\n            return (AnnotatedDeclaredType) param;\r\n        case VARIABLE:\r\n            VariableTree varTree = (VariableTree) parentTree;\r\n            assert isFunctionalInterface(TreeUtils.typeOf(varTree), parentTree, tree);\r\n            return (AnnotatedDeclaredType) getAnnotatedType(varTree.getType());\r\n        case ASSIGNMENT:\r\n            AssignmentTree assignmentTree = (AssignmentTree) parentTree;\r\n            assert isFunctionalInterface(TreeUtils.typeOf(assignmentTree), parentTree, tree);\r\n            return (AnnotatedDeclaredType) getAnnotatedType(assignmentTree.getVariable());\r\n        case RETURN:\r\n            Tree enclosing = TreeUtils.enclosingOfKind(getPath(parentTree), new HashSet(Arrays.asList(Tree.Kind.METHOD, Tree.Kind.LAMBDA_EXPRESSION)));\r\n            if (enclosing.getKind() == Tree.Kind.METHOD) {\r\n                MethodTree enclosingMethod = (MethodTree) enclosing;\r\n                return (AnnotatedDeclaredType) getAnnotatedType(enclosingMethod.getReturnType());\r\n            } else {\r\n                LambdaExpressionTree enclosingLambda = (LambdaExpressionTree) enclosing;\r\n                Pair<AnnotatedDeclaredType, AnnotatedExecutableType> result = getFnInterfaceFromTree(enclosingLambda);\r\n                AnnotatedExecutableType methodExe = result.second;\r\n                return (AnnotatedDeclaredType) methodExe.getReturnType();\r\n            }\r\n        case LAMBDA_EXPRESSION:\r\n            LambdaExpressionTree enclosingLambda = (LambdaExpressionTree) parentTree;\r\n            Pair<AnnotatedDeclaredType, AnnotatedExecutableType> result = getFnInterfaceFromTree(enclosingLambda);\r\n            AnnotatedExecutableType methodExe = result.second;\r\n            return (AnnotatedDeclaredType) methodExe.getReturnType();\r\n        case CONDITIONAL_EXPRESSION:\r\n            ConditionalExpressionTree conditionalExpressionTree = (ConditionalExpressionTree) parentTree;\r\n            final AnnotatedTypeMirror falseType = getAnnotatedType(conditionalExpressionTree.getFalseExpression());\r\n            final AnnotatedTypeMirror trueType = getAnnotatedType(conditionalExpressionTree.getTrueExpression());\r\n            AnnotatedTypeMirror conditionalType = AnnotatedTypes.leastUpperBound(this, trueType, falseType);\r\n            assert isFunctionalInterface(conditionalType.getUnderlyingType(), parentTree, tree);\r\n            return (AnnotatedDeclaredType) conditionalType;\r\n        default:\r\n            throw new BugInCF(\"Could not find functional interface from assignment context. \" + \"Unexpected tree type: \" + parentTree.getKind() + \" For lambda tree: \" + tree);\r\n    }\r\n}"
}, {
	"Path": "java.io.StringBufferInputStream.skip",
	"Comment": "skips n bytes of input from this input stream. fewerbytes might be skipped if the end of the input stream is reached.",
	"Method": "long skip(long n){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.zip.ZipOutputStream.finish",
	"Comment": "finishes writing the contents of the zip output stream without closingthe underlying stream. use this method when applying multiple filtersin succession to the same output stream.",
	"Method": "void finish(){\r\n    ensureOpen();\r\n    if (finished) {\r\n        return;\r\n    }\r\n    if (current != null) {\r\n        closeEntry();\r\n    }\r\n    long off = written;\r\n    for (XEntry xentry : xentries) writeCEN(xentry);\r\n    writeEND(off, written - off);\r\n    finished = true;\r\n}"
}, {
	"Path": "java.util.ArrayDeque.doubleCapacity",
	"Comment": "double the capacity of this deque.call only when full, i.e.,when head and tail have wrapped around to become equal.",
	"Method": "void doubleCapacity(){\r\n    assert head == tail;\r\n    int p = head;\r\n    int n = elements.length;\r\n    int r = n - p;\r\n    int newCapacity = n << 1;\r\n    if (newCapacity < 0)\r\n        throw new IllegalStateException(\"Sorry, deque too big\");\r\n    Object[] a = new Object[newCapacity];\r\n    System.arraycopy(elements, p, a, 0, r);\r\n    System.arraycopy(elements, 0, a, r, p);\r\n    elements = (E[]) a;\r\n    head = 0;\r\n    tail = n;\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueTransfer.calculateLengthRangeAddition",
	"Comment": "calculates a range of possible lengths of a result of string concatenation of strings withknown ranges of lengths.",
	"Method": "Range calculateLengthRangeAddition(Range leftLengths,Range rightLengths){\r\n    return leftLengths.plus(rightLengths).intersect(Range.INT_EVERYTHING);\r\n}"
}, {
	"Path": "java.util.zip.ZipFile.getEntry",
	"Comment": "returns the zip file entry for the specified name, or nullif not found.",
	"Method": "ZipEntry getEntry(String name,long getEntry,long jzfile,byte[] name,boolean addSlash){\r\n    if (name == null) {\r\n        throw new NullPointerException(\"name\");\r\n    }\r\n    long jzentry = 0;\r\n    synchronized (this) {\r\n        ensureOpen();\r\n        jzentry = getEntry(jzfile, zc.getBytes(name), true);\r\n        if (jzentry != 0) {\r\n            ZipEntry ze = getZipEntry(name, jzentry);\r\n            freeEntry(jzfile, jzentry);\r\n            return ze;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.DefaultTypeArgumentInference.handleUninferredTypeVariables",
	"Comment": "for any types we have not inferred, use a wildcard with the bounds from the original typeparameter.",
	"Method": "void handleUninferredTypeVariables(AnnotatedTypeFactory typeFactory,AnnotatedExecutableType methodType,Set<TypeVariable> targets,Map<TypeVariable, AnnotatedTypeMirror> inferredArgs){\r\n    for (AnnotatedTypeVariable atv : methodType.getTypeVariables()) {\r\n        final TypeVariable typeVar = atv.getUnderlyingType();\r\n        if (targets.contains((TypeVariable) TypeAnnotationUtils.unannotatedType(typeVar))) {\r\n            final AnnotatedTypeMirror inferredType = inferredArgs.get(typeVar);\r\n            if (inferredType == null || TypeArgInferenceUtil.containsTypeParameter(inferredType, targets)) {\r\n                AnnotatedTypeMirror dummy = typeFactory.getUninferredWildcardType(atv);\r\n                inferredArgs.put(atv.getUnderlyingType(), dummy);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.getBoxedType",
	"Comment": "returns the annotated boxed type of the given primitive type. the returned type would onlyhave the annotations on the given type.subclasses may override this method safely to override this behavior.",
	"Method": "AnnotatedDeclaredType getBoxedType(AnnotatedPrimitiveType type){\r\n    TypeElement typeElt = types.boxedClass(type.getUnderlyingType());\r\n    AnnotatedDeclaredType dt = fromElement(typeElt);\r\n    dt.addAnnotations(type.getAnnotations());\r\n    return dt;\r\n}"
}, {
	"Path": "java.lang.Enum.equals",
	"Comment": "returns true if the specified object is equal to thisenum constant.",
	"Method": "boolean equals(Object other){\r\n    return this == other;\r\n}"
}, {
	"Path": "java.util.TreeSet.descendingIterator",
	"Comment": "returns an iterator over the elements in this set in descending order.",
	"Method": "Iterator<E> descendingIterator(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.dataflow.analysis.FlowExpressions.internalReprOf",
	"Comment": "we ignore operations such as widening and narrowing when computing the internalrepresentation.",
	"Method": "Receiver internalReprOf(AnnotationProvider provider,Node receiverNode,Receiver internalReprOf,AnnotationProvider provider,Node receiverNode,boolean allowNonDeterministic,Receiver internalReprOf,AnnotationProvider provider,ExpressionTree receiverTree,Receiver internalReprOf,AnnotationProvider provider,ExpressionTree receiverTree,boolean allowNonDeterministic){\r\n    Receiver receiver;\r\n    switch(receiverTree.getKind()) {\r\n        case ARRAY_ACCESS:\r\n            ArrayAccessTree a = (ArrayAccessTree) receiverTree;\r\n            Receiver arrayAccessExpression = internalReprOf(provider, a.getExpression());\r\n            Receiver index = internalReprOf(provider, a.getIndex());\r\n            receiver = new ArrayAccess(TreeUtils.typeOf(a), arrayAccessExpression, index);\r\n            break;\r\n        case BOOLEAN_LITERAL:\r\n        case CHAR_LITERAL:\r\n        case DOUBLE_LITERAL:\r\n        case FLOAT_LITERAL:\r\n        case INT_LITERAL:\r\n        case LONG_LITERAL:\r\n        case NULL_LITERAL:\r\n        case STRING_LITERAL:\r\n            LiteralTree vn = (LiteralTree) receiverTree;\r\n            receiver = new ValueLiteral(TreeUtils.typeOf(receiverTree), vn.getValue());\r\n            break;\r\n        case NEW_ARRAY:\r\n            NewArrayTree newArrayTree = (NewArrayTree) receiverTree;\r\n            List<Receiver> dimensions = new ArrayList();\r\n            if (newArrayTree.getDimensions() != null) {\r\n                for (ExpressionTree dimension : newArrayTree.getDimensions()) {\r\n                    dimensions.add(internalReprOf(provider, dimension, allowNonDeterministic));\r\n                }\r\n            }\r\n            List<Receiver> initializers = new ArrayList();\r\n            if (newArrayTree.getInitializers() != null) {\r\n                for (ExpressionTree initializer : newArrayTree.getInitializers()) {\r\n                    initializers.add(internalReprOf(provider, initializer, allowNonDeterministic));\r\n                }\r\n            }\r\n            receiver = new ArrayCreation(TreeUtils.typeOf(receiverTree), dimensions, initializers);\r\n            break;\r\n        case METHOD_INVOCATION:\r\n            MethodInvocationTree mn = (MethodInvocationTree) receiverTree;\r\n            ExecutableElement invokedMethod = TreeUtils.elementFromUse(mn);\r\n            if (PurityUtils.isDeterministic(provider, invokedMethod) || allowNonDeterministic) {\r\n                List<Receiver> parameters = new ArrayList();\r\n                for (ExpressionTree p : mn.getArguments()) {\r\n                    parameters.add(internalReprOf(provider, p));\r\n                }\r\n                Receiver methodReceiver;\r\n                if (ElementUtils.isStatic(invokedMethod)) {\r\n                    methodReceiver = new ClassName(TreeUtils.typeOf(mn.getMethodSelect()));\r\n                } else {\r\n                    ExpressionTree methodReceiverTree = TreeUtils.getReceiverTree(mn);\r\n                    if (methodReceiverTree != null) {\r\n                        methodReceiver = internalReprOf(provider, methodReceiverTree);\r\n                    } else {\r\n                        methodReceiver = internalReprOfImplicitReceiver(invokedMethod);\r\n                    }\r\n                }\r\n                TypeMirror type = TreeUtils.typeOf(mn);\r\n                receiver = new MethodCall(type, invokedMethod, methodReceiver, parameters);\r\n            } else {\r\n                receiver = null;\r\n            }\r\n            break;\r\n        case MEMBER_SELECT:\r\n            receiver = internalReprOfMemberSelect(provider, (MemberSelectTree) receiverTree);\r\n            break;\r\n        case IDENTIFIER:\r\n            IdentifierTree identifierTree = (IdentifierTree) receiverTree;\r\n            TypeMirror typeOfId = TreeUtils.typeOf(identifierTree);\r\n            if (identifierTree.getName().contentEquals(\"this\") || identifierTree.getName().contentEquals(\"super\")) {\r\n                receiver = new ThisReference(typeOfId);\r\n                break;\r\n            }\r\n            Element ele = TreeUtils.elementFromUse(identifierTree);\r\n            switch(ele.getKind()) {\r\n                case LOCAL_VARIABLE:\r\n                case RESOURCE_VARIABLE:\r\n                case EXCEPTION_PARAMETER:\r\n                case PARAMETER:\r\n                    receiver = new LocalVariable(ele);\r\n                    break;\r\n                case FIELD:\r\n                    Receiver fieldAccessExpression;\r\n                    TypeMirror enclosingType = ElementUtils.enclosingClass(ele).asType();\r\n                    if (ElementUtils.isStatic(ele)) {\r\n                        fieldAccessExpression = new ClassName(enclosingType);\r\n                    } else {\r\n                        fieldAccessExpression = new ThisReference(enclosingType);\r\n                    }\r\n                    receiver = new FieldAccess(fieldAccessExpression, typeOfId, (VariableElement) ele);\r\n                    break;\r\n                case CLASS:\r\n                case ENUM:\r\n                case ANNOTATION_TYPE:\r\n                case INTERFACE:\r\n                    receiver = new ClassName(ele.asType());\r\n                    break;\r\n                default:\r\n                    receiver = null;\r\n            }\r\n            break;\r\n        default:\r\n            receiver = null;\r\n    }\r\n    if (receiver == null) {\r\n        receiver = new Unknown(TreeUtils.typeOf(receiverTree));\r\n    }\r\n    return receiver;\r\n}"
}, {
	"Path": "java.io.File.mkdirs",
	"Comment": "creates the directory named by this abstract pathname, including anynecessary but nonexistent parent directories.note that if thisoperation fails it may have succeeded in creating some of the necessaryparent directories.",
	"Method": "boolean mkdirs(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.ElementUtils.enclosingClass",
	"Comment": "returns the innermost type element enclosing the given element.",
	"Method": "TypeElement enclosingClass(Element elem){\r\n    Element result = elem;\r\n    while (result != null && !result.getKind().isClass() && !result.getKind().isInterface()) {\r\n        @Nullable\r\n        Element encl = result.getEnclosingElement();\r\n        result = encl;\r\n    }\r\n    return (TypeElement) result;\r\n}"
}, {
	"Path": "java.util.jar.JarFile.getJarEntry",
	"Comment": "returns the jarentry for the given entry name ornull if not found.",
	"Method": "JarEntry getJarEntry(String name){\r\n    return (JarEntry) getEntry(name);\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.FlowExpressionParseUtil.parseMemberSelect",
	"Comment": "matches a field access. first of returned pair is object and second is field.",
	"Method": "Pair<String, String> parseMemberSelect(String s,Receiver parseMemberSelect,String s,ProcessingEnvironment env,FlowExpressionContext context,TreePath path){\r\n    Pair<String, String> select = parseMemberSelect(s);\r\n    assert select != null : \"isMemberSelect must be called first\";\r\n    Receiver receiver;\r\n    String memberSelected;\r\n    Resolver resolver = new Resolver(env);\r\n    Pair<ClassName, String> classAndRemainingString = matchPackageAndClassNameWithinExpression(s, resolver, path);\r\n    if (classAndRemainingString != null) {\r\n        receiver = classAndRemainingString.first;\r\n        memberSelected = classAndRemainingString.second;\r\n        if (memberSelected == null) {\r\n            throw constructParserException(s, \"a class cannot terminate a flow expression string\");\r\n        }\r\n    } else {\r\n        String receiverString = select.first;\r\n        memberSelected = select.second;\r\n        receiver = parseHelper(receiverString, context, path);\r\n    }\r\n    if (memberSelected.equals(\"class\")) {\r\n        if (receiver instanceof FlowExpressions.ClassName && !context.parsingMember) {\r\n            return receiver;\r\n        } else {\r\n            throw constructParserException(s, \"class is not a legal identifier\");\r\n        }\r\n    }\r\n    FlowExpressionContext newContext = context.copyChangeToParsingMemberOfReceiver(receiver);\r\n    return parseHelper(memberSelected, newContext, path);\r\n}"
}, {
	"Path": "java.util.ArrayList.retainAll",
	"Comment": "retains only the elements in this list that are contained in thespecified collection.in other words, removes from this list allof its elements that are not contained in the specified collection.",
	"Method": "boolean retainAll(Collection<?> c){\r\n    return batchRemove(c, true);\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueAnnotatedTypeFactory.getMinLenFromString",
	"Comment": "returns the minimum length of an array expression or 0 if the min length is unknown.",
	"Method": "int getMinLenFromString(String sequenceExpression,Tree tree,TreePath currentPath){\r\n    AnnotationMirror lengthAnno = null;\r\n    try {\r\n        FlowExpressions.Receiver expressionObj = getReceiverFromJavaExpressionString(sequenceExpression, currentPath);\r\n        if (expressionObj instanceof FlowExpressions.ValueLiteral) {\r\n            FlowExpressions.ValueLiteral sequenceLiteral = (FlowExpressions.ValueLiteral) expressionObj;\r\n            Object sequenceLiteralValue = sequenceLiteral.getValue();\r\n            if (sequenceLiteralValue instanceof String) {\r\n                return ((String) sequenceLiteralValue).length();\r\n            }\r\n        }\r\n        lengthAnno = getAnnotationFromReceiver(expressionObj, tree, ArrayLenRange.class);\r\n        if (lengthAnno == null) {\r\n            lengthAnno = getAnnotationFromReceiver(expressionObj, tree, ArrayLen.class);\r\n        }\r\n        if (lengthAnno == null) {\r\n            lengthAnno = getAnnotationFromReceiver(expressionObj, tree, StringVal.class);\r\n        }\r\n    } catch (FlowExpressionParseException e) {\r\n    }\r\n    if (lengthAnno == null) {\r\n        return 0;\r\n    }\r\n    return getMinLenValue(lengthAnno);\r\n}"
}, {
	"Path": "java.util.zip.ZipInputStream.available",
	"Comment": "returns 0 after eof has reached for the current entry data,otherwise always return 1.programs should not count on this method to return the actual numberof bytes that could be read without blocking.",
	"Method": "int available(){\r\n    ensureOpen();\r\n    if (entryEOF) {\r\n        return 0;\r\n    } else {\r\n        return 1;\r\n    }\r\n}"
}, {
	"Path": "java.io.PrintStream.close",
	"Comment": "closes the stream.this is done by flushing the stream and then closingthe underlying output stream.",
	"Method": "void close(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.checker.lock.LockVisitor.isTreeSymbolEffectivelyFinalOrUnmodifiable",
	"Comment": "returns true if the symbol for the given tree is final or effectively final. package, classand method symbols are unmodifiable and therefore considered final.",
	"Method": "boolean isTreeSymbolEffectivelyFinalOrUnmodifiable(Tree tree){\r\n    Element elem = TreeUtils.elementFromTree(tree);\r\n    ElementKind ek = elem.getKind();\r\n    return ek == ElementKind.PACKAGE || ek == ElementKind.CLASS || ek == ElementKind.METHOD || ElementUtils.isEffectivelyFinal(elem);\r\n}"
}, {
	"Path": "java.util.WeakHashMap.containsKey",
	"Comment": "returns true if this map contains a mapping for thespecified key.",
	"Method": "boolean containsKey(Object key){\r\n    return getEntry(key) != null;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.DefaultTypeHierarchy.visitUnionSubtype",
	"Comment": "a union type is a subtype if all of its alternatives are subtypes of supertype.",
	"Method": "Boolean visitUnionSubtype(AnnotatedUnionType subtype,AnnotatedTypeMirror supertype){\r\n    return areAllSubtypes(subtype.getAlternatives(), supertype);\r\n}"
}, {
	"Path": "java.io.FileOutputStream.close",
	"Comment": "closes this file output stream and releases any system resourcesassociated with this stream. this file output stream may no longerbe used for writing bytes. if this stream has an associated channel then the channel is closedas well.",
	"Method": "void close(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.AbstractMap.eq",
	"Comment": "utility method for simpleentry and simpleimmutableentry.test for equality, checking for nulls.",
	"Method": "boolean eq(Object o1,Object o2){\r\n    return o1 == null ? o2 == null : o1.equals(o2);\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.OffsetEquation.createOffsetForInt",
	"Comment": "creates an offset equation that is only the int value specified.",
	"Method": "OffsetEquation createOffsetForInt(int value){\r\n    OffsetEquation equation = new OffsetEquation();\r\n    equation.intValue = value;\r\n    return equation;\r\n}"
}, {
	"Path": "java.lang.ClassLoader.getClassLoadingLock",
	"Comment": "returns the lock object for class loading operations.for backward compatibility, the default implementation of this methodbehaves as follows. if this classloader object is registered asparallel capable, the method returns a dedicated object associatedwith the specified class name. otherwise, the method returns thisclassloader object.",
	"Method": "Object getClassLoadingLock(String className){\r\n    Object lock = this;\r\n    if (parallelLockMap != null) {\r\n        Object newLock = new Object();\r\n        lock = parallelLockMap.putIfAbsent(className, newLock);\r\n        if (lock == null) {\r\n            lock = newLock;\r\n        }\r\n    }\r\n    return lock;\r\n}"
}, {
	"Path": "org.checkerframework.common.reflection.DefaultReflectionResolver.resolveReflectiveConstructor",
	"Comment": "resolves a reflective constructor call and returns all possible corresponding constructorcalls.",
	"Method": "List<JCNewClass> resolveReflectiveConstructor(MethodInvocationTree tree,AnnotatedTypeFactory reflectionFactory){\r\n    assert isReflectiveMethodInvocation(tree);\r\n    JCMethodInvocation methodInvocation = (JCMethodInvocation) tree;\r\n    Context context = ((JavacProcessingEnvironment) processingEnv).getContext();\r\n    TreeMaker make = TreeMaker.instance(context);\r\n    TreePath path = reflectionFactory.getPath(tree);\r\n    JavacScope scope = (JavacScope) trees.getScope(path);\r\n    Env<AttrContext> env = scope.getEnv();\r\n    List<JCNewClass> constructors = new ArrayList();\r\n    AnnotationMirror estimate = getMethodVal(tree);\r\n    if (estimate == null) {\r\n        debugReflection(\"MethodVal is unknown for: \" + tree);\r\n        debugReflection(\"UnknownMethod annotation: \" + isUnknownMethod(tree));\r\n        return constructors;\r\n    }\r\n    debugReflection(\"MethodVal type system annotations: \" + estimate);\r\n    List<String> listClassNames = AnnotationUtils.getElementValueArray(estimate, \"className\", String.class, true);\r\n    List<Integer> listParamLenghts = AnnotationUtils.getElementValueArray(estimate, \"params\", Integer.class, true);\r\n    assert listClassNames.size() == listParamLenghts.size();\r\n    for (int i = 0; i < listClassNames.size(); ++i) {\r\n        String className = listClassNames.get(i);\r\n        int paramLength = listParamLenghts.get(i);\r\n        for (Symbol symbol : getConstructorSymbolsfor(className, paramLength, env)) {\r\n            debugReflection(\"Resolved constructor: \" + symbol.owner + \".\" + symbol);\r\n            JCNewClass syntTree = (JCNewClass) make.Create(symbol, methodInvocation.args);\r\n            constructors.add(syntTree);\r\n        }\r\n    }\r\n    return constructors;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.DefaultInferredTypesApplier.applyInferredType",
	"Comment": "for each top in qualifier hierarchy, traverse inferred and copy the required annotations overto type.",
	"Method": "void applyInferredType(AnnotatedTypeMirror type,Set<AnnotationMirror> inferredSet,TypeMirror inferredTypeMirror){\r\n    if (inferredSet == null) {\r\n        return;\r\n    }\r\n    if (inferredTypeMirror.getKind() == TypeKind.WILDCARD) {\r\n        while (inferredTypeMirror.getKind() == TypeKind.WILDCARD && (((WildcardType) inferredTypeMirror).getExtendsBound() != null)) {\r\n            inferredTypeMirror = ((WildcardType) inferredTypeMirror).getExtendsBound();\r\n        }\r\n    }\r\n    for (final AnnotationMirror top : hierarchy.getTopAnnotations()) {\r\n        AnnotationMirror inferred = hierarchy.findAnnotationInHierarchy(inferredSet, top);\r\n        apply(type, inferred, inferredTypeMirror, top);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.DefaultTypeArgumentInference.reduceAfConstraints",
	"Comment": "given a set of afconstraints, remove all constraints that are not relevant to inference andreturn a set of afconstraints in which the f is a use of one of the type parameters to infer.",
	"Method": "void reduceAfConstraints(AnnotatedTypeFactory typeFactory,Set<AFConstraint> outgoing,Queue<AFConstraint> toProcess,Set<TypeVariable> targets){\r\n    final Set<AFConstraint> visited = new HashSet();\r\n    List<AFReducer> reducers = new ArrayList();\r\n    reducers.add(new A2FReducer(typeFactory));\r\n    reducers.add(new F2AReducer(typeFactory));\r\n    reducers.add(new FIsAReducer(typeFactory));\r\n    Set<AFConstraint> newConstraints = new HashSet(10);\r\n    while (!toProcess.isEmpty()) {\r\n        newConstraints.clear();\r\n        AFConstraint constraint = toProcess.remove();\r\n        if (!visited.contains(constraint)) {\r\n            if (constraint.isIrreducible(targets)) {\r\n                outgoing.add(constraint);\r\n            } else {\r\n                final Iterator<AFReducer> reducerIterator = reducers.iterator();\r\n                boolean handled = false;\r\n                while (!handled && reducerIterator.hasNext()) {\r\n                    handled = reducerIterator.next().reduce(constraint, newConstraints);\r\n                }\r\n                if (!handled) {\r\n                    throw new BugInCF(\"Unhandled constraint type: \" + constraint.toString());\r\n                }\r\n                toProcess.addAll(newConstraints);\r\n            }\r\n            visited.add(constraint);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.ui.CheckStyleModuleConfigPanel.getActiveLocation",
	"Comment": "get the configuration to use, or null to use the project configuration.",
	"Method": "ConfigurationLocation getActiveLocation(){\r\n    if (useProjectConfigurationRadio.isSelected() || excludeRadio.isSelected()) {\r\n        return null;\r\n    }\r\n    return (ConfigurationLocation) configurationFilesModel.getSelectedItem();\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotationClassLoader.getBundledAnnotationNamesFromJar",
	"Comment": "retrieves the annotation class file names from the qual directory contained inside a jar.",
	"Method": "Set<String> getBundledAnnotationNamesFromJar(JarFile jar){\r\n    Set<String> annos = new LinkedHashSet();\r\n    Enumeration<JarEntry> jarEntries = jar.entries();\r\n    while (jarEntries.hasMoreElements()) {\r\n        JarEntry je = jarEntries.nextElement();\r\n        if (je.isDirectory() || !je.getName().endsWith(CLASS_SUFFIX)) {\r\n            continue;\r\n        }\r\n        String className = je.getName().substring(0, je.getName().lastIndexOf('.'));\r\n        className = className.replace(SLASH, DOT);\r\n        if (className.startsWith(packageName)) {\r\n            annos.add(className);\r\n        }\r\n    }\r\n    return annos;\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.ui.CheckStyleModuleConfigPanel.setActiveLocation",
	"Comment": "set the configuration to use, or null to use the project configuration.",
	"Method": "void setActiveLocation(ConfigurationLocation activeLocation){\r\n    this.activeLocation = activeLocation;\r\n    if (activeLocation != null) {\r\n        configurationFilesCombo.setSelectedItem(activeLocation);\r\n    } else if (configurationFilesModel.getSize() > 0) {\r\n        configurationFilesCombo.setSelectedItem(configurationFilesModel.getElementAt(0));\r\n    }\r\n    if (activeLocation != null) {\r\n        useModuleConfigurationRadio.setSelected(true);\r\n    } else if (!excluded) {\r\n        useProjectConfigurationRadio.setSelected(true);\r\n    }\r\n    new RadioListener().actionPerformed(null);\r\n}"
}, {
	"Path": "java.io.CharArrayWriter.writeTo",
	"Comment": "writes the contents of the buffer to another character stream.",
	"Method": "void writeTo(Writer out){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.hashCode",
	"Comment": "generates the hash code for this gregoriancalendar object.",
	"Method": "int hashCode(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.visitor.SimpleAnnotatedTypeScanner.defaultAction",
	"Comment": "called by default for any visit method that is not overridden.",
	"Method": "R defaultAction(AnnotatedTypeMirror type,P p){\r\n    return null;\r\n}"
}, {
	"Path": "com.mycompany.myapp.security.UserContext.getRoles",
	"Comment": "return the current roles bound to the current thread by spring security.",
	"Method": "List<String> getRoles(){\r\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\r\n    if (auth != null) {\r\n        return toStringList(auth.getAuthorities());\r\n    }\r\n    return emptyList();\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TypesUtils.areSamePrimitiveTypes",
	"Comment": "returns true iff the arguments are both the same primitive types.",
	"Method": "boolean areSamePrimitiveTypes(TypeMirror left,TypeMirror right){\r\n    if (!isPrimitive(left) || !isPrimitive(right)) {\r\n        return false;\r\n    }\r\n    return (left.getKind() == right.getKind());\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeCopier.maybeCopyPrimaryAnnotations",
	"Comment": "this method is called in any location in which a primary annotation would be copied fromsource to dest. note, this method obeys the copyannotations field. subclasses ofannotatedtypecopier can use this method to customize annotations before copying.",
	"Method": "void maybeCopyPrimaryAnnotations(AnnotatedTypeMirror source,AnnotatedTypeMirror dest){\r\n    if (copyAnnotations) {\r\n        dest.addAnnotations(source.getAnnotationsField());\r\n    }\r\n}"
}, {
	"Path": "java.io.DataInputStream.readByte",
	"Comment": "see the general contract of the readbytemethod of datainput.bytesfor this operation are read from the containedinput stream.",
	"Method": "byte readByte(){\r\n    int ch = in.read();\r\n    if (ch < 0)\r\n        throw new EOFException();\r\n    return (byte) (ch);\r\n}"
}, {
	"Path": "java.util.Date.setDate",
	"Comment": "sets the day of the month of this date object to thespecified value. this date object is modified so thatit represents a point in time within the specified day of themonth, with the year, month, hour, minute, and second the sameas before, as interpreted in the local time zone. if the datewas april 30, for example, and the date is set to 31, then itwill be treated as if it were on may 1, because april has only30 days.",
	"Method": "void setDate(int date){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "sun.util.LocaleServiceProviderPool.findProvider",
	"Comment": "returns a locale service provider instance that supportsthe specified locale.",
	"Method": "LocaleServiceProvider findProvider(Locale locale){\r\n    if (!hasProviders()) {\r\n        return null;\r\n    }\r\n    if (providersCache.containsKey(locale)) {\r\n        LocaleServiceProvider provider = providersCache.get(locale);\r\n        if (provider != NullProvider.INSTANCE) {\r\n            return provider;\r\n        }\r\n    } else {\r\n        for (LocaleServiceProvider lsp : providers) {\r\n            Locale[] locales = lsp.getAvailableLocales();\r\n            for (Locale available : locales) {\r\n                available = getLookupLocale(available);\r\n                if (locale.equals(available)) {\r\n                    LocaleServiceProvider providerInCache = providersCache.put(locale, lsp);\r\n                    return (providerInCache != null ? providerInCache : lsp);\r\n                }\r\n            }\r\n        }\r\n        providersCache.put(locale, NullProvider.INSTANCE);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.checkerframework.checker.units.UnitsRelationsDefault.havePairOfUnitsIgnoringOrder",
	"Comment": "checks to see if lht and rht have the pair of units u1 and u2 regardless of order.",
	"Method": "boolean havePairOfUnitsIgnoringOrder(AnnotatedTypeMirror lht,AnnotationMirror u1,AnnotatedTypeMirror rht,AnnotationMirror u2){\r\n    return havePairOfUnits(lht, u1, rht, u2) || havePairOfUnits(lht, u2, rht, u1);\r\n}"
}, {
	"Path": "java.util.Vector.retainAll",
	"Comment": "retains only the elements in this vector that are contained in thespecified collection.in other words, removes from this vector allof its elements that are not contained in the specified collection.",
	"Method": "boolean retainAll(Collection<?> c){\r\n    return super.retainAll(c);\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.OffsetEquation.addTerm",
	"Comment": "adds the term to this equation. if string is an integer, then it is added or subtracted,depending on operator, from the int value of this equation. otherwise, the term is placed inthe added or subtracted terms set, depending on operator.",
	"Method": "void addTerm(char operator,String term){\r\n    term = term.trim();\r\n    if (isInt(term)) {\r\n        int literal = parseInt(term);\r\n        addInt(operator == '-' ? -1 * literal : literal);\r\n        return;\r\n    }\r\n    if (operator == '-') {\r\n        if (addedTerms.contains(term)) {\r\n            addedTerms.remove(term);\r\n        } else {\r\n            subtractedTerms.add(term);\r\n        }\r\n    } else if (operator == '+') {\r\n        if (subtractedTerms.contains(term)) {\r\n            subtractedTerms.remove(term);\r\n        } else {\r\n            addedTerms.add(term);\r\n        }\r\n    } else {\r\n        assert false;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.source.SourceChecker.addOptions",
	"Comment": "add additional active options. use of this method should be limited to the aggregatechecker,who needs to set the active options to the union of all subcheckers.",
	"Method": "void addOptions(Map<String, String> moreopts){\r\n    Map<String, String> activeOpts = new HashMap(getOptions());\r\n    activeOpts.putAll(moreopts);\r\n    activeOptions = Collections.unmodifiableMap(activeOpts);\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentSkipListSet.descendingIterator",
	"Comment": "returns an iterator over the elements in this set in descending order.",
	"Method": "Iterator<E> descendingIterator(){\r\n    return m.descendingKeySet().iterator();\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.element.MethodApplier.applyThrowsAnnotations",
	"Comment": "for each thrown type, collect all the annotations for that type and apply them.",
	"Method": "void applyThrowsAnnotations(List<Attribute.TypeCompound> annos){\r\n    final List<AnnotatedTypeMirror> thrown = methodType.getThrownTypes();\r\n    if (thrown.isEmpty()) {\r\n        return;\r\n    }\r\n    Map<AnnotatedTypeMirror, List<TypeCompound>> typeToAnnos = new LinkedHashMap();\r\n    for (final AnnotatedTypeMirror thrownType : thrown) {\r\n        typeToAnnos.put(thrownType, new ArrayList());\r\n    }\r\n    for (TypeCompound anno : annos) {\r\n        final TypeAnnotationPosition annoPos = anno.position;\r\n        if (annoPos.type_index >= 0 && annoPos.type_index < thrown.size()) {\r\n            final AnnotatedTypeMirror thrownType = thrown.get(annoPos.type_index);\r\n            typeToAnnos.get(thrownType).add(anno);\r\n        } else {\r\n            throw new BugInCF(\"MethodApplier.applyThrowsAnnotation: \" + \"invalid throws index \" + annoPos.type_index + \" for annotation: \" + anno + \" for element: \" + ElementUtils.getVerboseName(element));\r\n        }\r\n    }\r\n    for (final Entry<AnnotatedTypeMirror, List<TypeCompound>> typeToAnno : typeToAnnos.entrySet()) {\r\n        ElementAnnotationUtil.annotateViaTypeAnnoPosition(typeToAnno.getKey(), typeToAnno.getValue());\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.checker.nullness.NullnessVisitor.checkForNullability",
	"Comment": "issues the error message if an expression with this type may be null.",
	"Method": "boolean checkForNullability(ExpressionTree tree,String errMsg,boolean checkForNullability,AnnotatedTypeMirror type,Tree tree,String errMsg){\r\n    if (!type.hasEffectiveAnnotation(NONNULL)) {\r\n        checker.report(Result.failure(errMsg, tree), tree);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueTransfer.calculateLengthAddition",
	"Comment": "calculates possible lengths of a result of string concatenation of strings with knownlengths.",
	"Method": "List<Integer> calculateLengthAddition(List<Integer> leftLengths,List<Integer> rightLengths){\r\n    ArrayList<Integer> result = new ArrayList();\r\n    for (int left : leftLengths) {\r\n        for (int right : rightLengths) {\r\n            long resultLength = (long) left + right;\r\n            if (resultLength <= Integer.MAX_VALUE) {\r\n                result.add((int) resultLength);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "java.util.zip.ZipOutputStream.setMethod",
	"Comment": "sets the default compression method for subsequent entries. thisdefault will be used whenever the compression method is not specifiedfor an individual zip file entry, and is initially set to deflated.",
	"Method": "void setMethod(int method){\r\n    if (method != DEFLATED && method != STORED) {\r\n        throw new IllegalArgumentException(\"invalid compression method\");\r\n    }\r\n    this.method = method;\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.RoleDTOService.save",
	"Comment": "save the passed dto as a new entity or update the corresponding entity if any.",
	"Method": "RoleDTO save(RoleDTO dto){\r\n    if (dto == null) {\r\n        return null;\r\n    }\r\n    final Role role;\r\n    if (dto.isIdSet()) {\r\n        Role roleTmp = roleRepository.findOne(dto.id);\r\n        if (roleTmp != null) {\r\n            role = roleTmp;\r\n        } else {\r\n            role = new Role();\r\n            role.setId(dto.id);\r\n        }\r\n    } else {\r\n        role = new Role();\r\n    }\r\n    role.setRoleName(dto.roleName);\r\n    return toDTO(roleRepository.save(role));\r\n}"
}, {
	"Path": "java.util.JumboEnumSet.addAll",
	"Comment": "adds all of the elements in the specified collection to this set.",
	"Method": "void addAll(boolean addAll,Collection<? extends E> c){\r\n    if (!(c instanceof JumboEnumSet))\r\n        return super.addAll(c);\r\n    JumboEnumSet es = (JumboEnumSet) c;\r\n    if (es.elementType != elementType) {\r\n        if (es.isEmpty())\r\n            return false;\r\n        else\r\n            throw new ClassCastException(es.elementType + \" != \" + elementType);\r\n    }\r\n    for (int i = 0; i < elements.length; i++) elements[i] |= es.elements[i];\r\n    return recalculateSize();\r\n}"
}, {
	"Path": "java.util.zip.ZipFile.getInputStream",
	"Comment": "returns an input stream for reading the contents of the specifiedzip file entry. closing this zip file will, in turn, close all inputstreams that have been returned by invocations of this method.",
	"Method": "InputStream getInputStream(ZipEntry entry){\r\n    if (entry == null) {\r\n        throw new NullPointerException(\"entry\");\r\n    }\r\n    long jzentry = 0;\r\n    ZipFileInputStream in = null;\r\n    synchronized (this) {\r\n        ensureOpen();\r\n        if (!zc.isUTF8() && (entry.flag & EFS) != 0) {\r\n            jzentry = getEntry(jzfile, zc.getBytesUTF8(entry.name), false);\r\n        } else {\r\n            jzentry = getEntry(jzfile, zc.getBytes(entry.name), false);\r\n        }\r\n        if (jzentry == 0) {\r\n            return null;\r\n        }\r\n        in = new ZipFileInputStream(jzentry);\r\n        switch(getEntryMethod(jzentry)) {\r\n            case STORED:\r\n                synchronized (streams) {\r\n                    streams.put(in, null);\r\n                }\r\n                return in;\r\n            case DEFLATED:\r\n                long size = getEntrySize(jzentry) + 2;\r\n                if (size > 65536)\r\n                    size = 8192;\r\n                if (size <= 0)\r\n                    size = 4096;\r\n                Inflater inf = getInflater();\r\n                InputStream is = new ZipFileInflaterInputStream(in, inf, (int) size);\r\n                synchronized (streams) {\r\n                    streams.put(is, inf);\r\n                }\r\n                return is;\r\n            default:\r\n                throw new ZipException(\"invalid compression method\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.ToIndexFileConverter.convert",
	"Comment": "augment given scene with information from stubfile, reading stubs from input stream andwriting jaif to output stream.",
	"Method": "void convert(AScene scene,InputStream in,OutputStream out){\r\n    StubUnit iu;\r\n    try {\r\n        iu = JavaParser.parseStubUnit(in);\r\n    } catch (ParseProblemException e) {\r\n        iu = null;\r\n        throw new BugInCF(\"ToIndexFileConverter: exception from JavaParser.parseStubUnit for InputStream.\" + System.lineSeparator() + \"Problem message with problems encountered: \" + e.getMessage());\r\n    }\r\n    extractScene(iu, scene);\r\n    try (Writer w = new BufferedWriter(new OutputStreamWriter(out))) {\r\n        IndexFileWriter.write(scene, w);\r\n    }\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.monthLength",
	"Comment": "returns the length of the specified month in the specifiedyear. the year number must be normalized.",
	"Method": "int monthLength(int month,int year,int monthLength,int month){\r\n    int year = internalGet(YEAR);\r\n    if (internalGetEra() == BCE) {\r\n        year = 1 - year;\r\n    }\r\n    return monthLength(month, year);\r\n}"
}, {
	"Path": "java.util.Hashtable.elements",
	"Comment": "returns an enumeration of the values in this hashtable.use the enumeration methods on the returned object to fetch the elementssequentially.",
	"Method": "Enumeration<V> elements(){\r\n    return this.<V>getEnumeration(VALUES);\r\n}"
}, {
	"Path": "org.checkerframework.common.basetype.BaseTypeVisitor.createOverrideChecker",
	"Comment": "create an overridechecker.this exists so that subclasses can subclass overridechecker and use their subclass insteadof using overridechecker itself.",
	"Method": "OverrideChecker createOverrideChecker(Tree overriderTree,AnnotatedExecutableType overrider,AnnotatedTypeMirror overridingType,AnnotatedTypeMirror overridingReturnType,AnnotatedExecutableType overridden,AnnotatedDeclaredType overriddenType,AnnotatedTypeMirror overriddenReturnType){\r\n    return new OverrideChecker(overriderTree, overrider, overridingType, overridingReturnType, overridden, overriddenType, overriddenReturnType);\r\n}"
}, {
	"Path": "java.io.InputStream.close",
	"Comment": "closes this input stream and releases any system resources associatedwith the stream. the close method of inputstream doesnothing.",
	"Method": "void close(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.checker.interning.InterningVisitor.overrides",
	"Comment": "determines whether or not the given element overrides the named method in the named class.",
	"Method": "boolean overrides(ExecutableElement e,Class<?> clazz,String method){\r\n    TypeElement clazzElt = elements.getTypeElement(clazz.getCanonicalName());\r\n    assert clazzElt != null;\r\n    for (ExecutableElement elt : ElementFilter.methodsIn(clazzElt.getEnclosedElements())) {\r\n        if (elt.getSimpleName().contentEquals(method) && elements.overrides(e, elt, clazzElt)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.ComparableTimSort.mergeForceCollapse",
	"Comment": "merges all runs on the stack until only one remains.this method iscalled once, to complete the sort.",
	"Method": "void mergeForceCollapse(){\r\n    while (stackSize > 1) {\r\n        int n = stackSize - 2;\r\n        if (n > 0 && runLen[n - 1] < runLen[n + 1])\r\n            n--;\r\n        mergeAt(n);\r\n    }\r\n}"
}, {
	"Path": "java.io.ByteArrayOutputStream.toByteArray",
	"Comment": "creates a newly allocated byte array. its size is the currentsize of this output stream and the valid contents of the bufferhave been copied into it.",
	"Method": "byte toByteArray(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.lang.Class.privateGetDeclaredConstructors",
	"Comment": "instead be copied via reflectionfactory.copyconstructor.",
	"Method": "Constructor<T>[] privateGetDeclaredConstructors(boolean publicOnly){\r\n    checkInitted();\r\n    Constructor<T>[] res = null;\r\n    if (useCaches) {\r\n        clearCachesOnClassRedefinition();\r\n        if (publicOnly) {\r\n            if (publicConstructors != null) {\r\n                res = publicConstructors.get();\r\n            }\r\n        } else {\r\n            if (declaredConstructors != null) {\r\n                res = declaredConstructors.get();\r\n            }\r\n        }\r\n        if (res != null)\r\n            return res;\r\n    }\r\n    if (isInterface()) {\r\n        res = new Constructor[0];\r\n    } else {\r\n        res = getDeclaredConstructors0(publicOnly);\r\n    }\r\n    if (useCaches) {\r\n        if (publicOnly) {\r\n            publicConstructors = new SoftReference(res);\r\n        } else {\r\n            declaredConstructors = new SoftReference(res);\r\n        }\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "java.io.Console.flush",
	"Comment": "flushes the console and forces any buffered output to be writtenimmediately .",
	"Method": "void flush(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "com.mycompany.myapp.domain.Book.toString",
	"Comment": "construct a readable string representation for this book instance.",
	"Method": "String toString(){\r\n    return // \r\n    MoreObjects.toStringHelper(this).add(\"id\", // \r\n    getId()).add(\"title\", // \r\n    getTitle()).add(\"summary\", // \r\n    getSummary()).add(\"extractBinary\", // \r\n    getExtractBinary()).add(\"extractFileName\", // \r\n    getExtractFileName()).add(\"extractContentType\", // \r\n    getExtractContentType()).add(\"extractSize\", // \r\n    getExtractSize()).add(\"publicationDate\", // \r\n    getPublicationDate()).add(\"bestSeller\", // \r\n    getBestSeller()).add(\"price\", getPrice()).toString();\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TreeUtils.isDiamondTree",
	"Comment": "returns true if the tree is of a diamond type. in contrast to the implementation in treeinfo,this version works on trees.",
	"Method": "boolean isDiamondTree(Tree tree){\r\n    switch(tree.getKind()) {\r\n        case ANNOTATED_TYPE:\r\n            return isDiamondTree(((AnnotatedTypeTree) tree).getUnderlyingType());\r\n        case PARAMETERIZED_TYPE:\r\n            return ((ParameterizedTypeTree) tree).getTypeArguments().isEmpty();\r\n        case NEW_CLASS:\r\n            return isDiamondTree(((NewClassTree) tree).getIdentifier());\r\n        default:\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "javax.swing.table.DefaultTableCellRenderer.isOpaque",
	"Comment": "overridden for performance reasons.see the implementation notefor more information.",
	"Method": "boolean isOpaque(){\r\n    Color back = getBackground();\r\n    Component p = getParent();\r\n    if (p != null) {\r\n        p = p.getParent();\r\n    }\r\n    boolean colorMatch = (back != null) && (p != null) && back.equals(p.getBackground()) && p.isOpaque();\r\n    return !colorMatch && super.isOpaque();\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.MapSerializer.getSendJavaType",
	"Comment": "return true if the java type of the collection should be sent.",
	"Method": "boolean getSendJavaType(){\r\n    return _isSendJavaType;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.TypeArgInferenceUtil.leastUpperBound",
	"Comment": "successively calls least upper bound on the elements of types. unlike leastupperbound, thismethod will box primitives if necessary",
	"Method": "AnnotatedTypeMirror leastUpperBound(AnnotatedTypeFactory typeFactory,Iterable<AnnotatedTypeMirror> types){\r\n    final Iterator<AnnotatedTypeMirror> typesIter = types.iterator();\r\n    if (!typesIter.hasNext()) {\r\n        throw new BugInCF(\"Calling LUB on empty list\");\r\n    }\r\n    AnnotatedTypeMirror lubType = typesIter.next();\r\n    AnnotatedTypeMirror nextType = null;\r\n    while (typesIter.hasNext()) {\r\n        nextType = typesIter.next();\r\n        if (lubType.getKind().isPrimitive()) {\r\n            if (!nextType.getKind().isPrimitive()) {\r\n                lubType = typeFactory.getBoxedType((AnnotatedPrimitiveType) lubType);\r\n            }\r\n        } else if (nextType.getKind().isPrimitive()) {\r\n            if (!lubType.getKind().isPrimitive()) {\r\n                nextType = typeFactory.getBoxedType((AnnotatedPrimitiveType) nextType);\r\n            }\r\n        }\r\n        lubType = AnnotatedTypes.leastUpperBound(typeFactory, lubType, nextType);\r\n    }\r\n    return lubType;\r\n}"
}, {
	"Path": "sun.util.resources.LocaleData.getCollationData",
	"Comment": "gets a collation data resource bundle, using privilegesto allow accessing a sun. package.",
	"Method": "ResourceBundle getCollationData(Locale locale){\r\n    return getBundle(\"sun.text.resources.CollationData\", locale);\r\n}"
}, {
	"Path": "java.util.Vector.toArray",
	"Comment": "returns an array containing all of the elements in this vectorin the correct order.",
	"Method": "Object[] toArray(T[] toArray,T[] a){\r\n    if (a.length < elementCount)\r\n        return (T[]) Arrays.copyOf(elementData, elementCount, a.getClass());\r\n    System.arraycopy(elementData, 0, a, 0, elementCount);\r\n    if (a.length > elementCount)\r\n        a[elementCount] = null;\r\n    return a;\r\n}"
}, {
	"Path": "com.mycompany.myapp.domain.UseCase3Pk.areFieldsSet",
	"Comment": "helper to determine if this composite primary key is fully set.",
	"Method": "boolean areFieldsSet(){\r\n    return isId1Set() && isId2Set();\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.toolwindow.CheckStyleToolWindowPanel.scrollToError",
	"Comment": "scroll to the error specified by the given tree path, or do nothingif no error is specified.",
	"Method": "void scrollToError(TreePath treePath){\r\n    final DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode) treePath.getLastPathComponent();\r\n    if (treeNode == null || !(treeNode.getUserObject() instanceof ResultTreeNode)) {\r\n        return;\r\n    }\r\n    final ResultTreeNode nodeInfo = (ResultTreeNode) treeNode.getUserObject();\r\n    if (nodeInfo.getFile() == null || nodeInfo.getProblem() == null) {\r\n        return;\r\n    }\r\n    final VirtualFile virtualFile = nodeInfo.getFile().getVirtualFile();\r\n    if (virtualFile == null || !virtualFile.exists()) {\r\n        return;\r\n    }\r\n    final FileEditorManager fileEditorManager = FileEditorManager.getInstance(project);\r\n    final FileEditor[] editor = fileEditorManager.openFile(virtualFile, true);\r\n    if (editor.length > 0 && editor[0] instanceof TextEditor) {\r\n        final LogicalPosition problemPos = new LogicalPosition(Math.max(lineFor(nodeInfo) - 1, 0), Math.max(columnFor(nodeInfo), 0));\r\n        final Editor textEditor = ((TextEditor) editor[0]).getEditor();\r\n        textEditor.getCaretModel().moveToLogicalPosition(problemPos);\r\n        textEditor.getScrollingModel().scrollToCaret(ScrollType.CENTER);\r\n    }\r\n}"
}, {
	"Path": "java.io.LineNumberInputStream.read",
	"Comment": "reads up to len bytes of data from this input streaminto an array of bytes. this method blocks until some input is available.the read method oflinenumberinputstream repeatedly calls theread method of zero arguments to fill in the byte array.",
	"Method": "int read(int read,byte b,int off,int len){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.Date.setMonth",
	"Comment": "sets the month of this date to the specified value. thisdate object is modified so that it represents a pointin time within the specified month, with the year, date, hour,minute, and second the same as before, as interpreted in thelocal time zone. if the date was october 31, for example, andthe month is set to june, then the new date will be treated asif it were on july 1, because june has only 30 days.",
	"Method": "void setMonth(int month){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.jar.Attributes.equals",
	"Comment": "compares the specified attributes object with this map for equality.returns true if the given object is also an instance of attributesand the two attributes objects represent the same mappings.",
	"Method": "boolean equals(Object o,boolean equals,Object o){\r\n    return map.equals(o);\r\n}"
}, {
	"Path": "java.util.TreeSet.clear",
	"Comment": "removes all of the elements from this set.the set will be empty after this call returns.",
	"Method": "void clear(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.HashSet.clear",
	"Comment": "removes all of the elements from this set.the set will be empty after this call returns.",
	"Method": "void clear(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.Date.getSeconds",
	"Comment": "returns the number of seconds past the minute represented by this date.the value returned is between 0 and 61. thevalues 60 and 61 can only occur on thosejava virtual machines that take leap seconds into account.",
	"Method": "int getSeconds(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotationClassLoader.loadExternalAnnotationClass",
	"Comment": "this method takes as input the canonical name of an external annotation class and loads andreturns that class via the class loader. this method returns null if the external annotationclass was loaded successfully but was deemed not supported by a checker. errors are issued ifthe external class is not an annotation, or if it could not be loaded successfully.",
	"Method": "Class<? extends Annotation> loadExternalAnnotationClass(String annoName){\r\n    return loadAnnotationClass(annoName, true);\r\n}"
}, {
	"Path": "org.xml.sax.InputSource.setByteStream",
	"Comment": "set the byte stream for this input source.the sax parser will ignore this if there is also a characterstream specified, but it will use a byte stream in preferenceto opening a uri connection itself.if the application knows the character encoding of thebyte stream, it should set it with the setencoding method.",
	"Method": "void setByteStream(InputStream byteStream){\r\n    this.byteStream = byteStream;\r\n}"
}, {
	"Path": "org.checkerframework.checker.nullness.KeyForPropagationTreeAnnotator.visitNewClass",
	"Comment": "transfers annotations to type if the left hand side is a variable declaration.",
	"Method": "Void visitNewClass(NewClassTree node,AnnotatedTypeMirror type){\r\n    keyForPropagator.propagateNewClassTree(node, type, (KeyForAnnotatedTypeFactory) atypeFactory);\r\n    return super.visitNewClass(node, type);\r\n}"
}, {
	"Path": "java.util.Observable.deleteObservers",
	"Comment": "clears the observer list so that this object no longer has any observers.",
	"Method": "void deleteObservers(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "com.mycompany.myapp.domain.Project.toString",
	"Comment": "construct a readable string representation for this project instance.",
	"Method": "String toString(){\r\n    return // \r\n    MoreObjects.toStringHelper(this).add(\"id\", // \r\n    getId()).add(\"name\", // \r\n    getName()).add(\"url\", // \r\n    getUrl()).add(\"openSource\", getOpenSource()).toString();\r\n}"
}, {
	"Path": "java.util.RegularEnumSet.remove",
	"Comment": "removes the specified element from this set if it is present.",
	"Method": "void remove(boolean remove,Object e){\r\n    if (e == null)\r\n        return false;\r\n    Class eClass = e.getClass();\r\n    if (eClass != elementType && eClass.getSuperclass() != elementType)\r\n        return false;\r\n    long oldElements = elements;\r\n    elements &= ~(1L << ((Enum) e).ordinal());\r\n    return elements != oldElements;\r\n}"
}, {
	"Path": "java.util.Collections.get",
	"Comment": "gets the ith element from the given list by repositioning the specifiedlist listiterator.",
	"Method": "T get(ListIterator<? extends T> i,int index,E get,int index,V get,Object key,E get,int index,V get,Object key,E get,int index,V get,Object key,E get,int index,V get,Object key,E get,int index,V get,Object key,E get,int index){\r\n    T obj = null;\r\n    int pos = i.nextIndex();\r\n    if (pos <= index) {\r\n        do {\r\n            obj = i.next();\r\n        } while (pos++ < index);\r\n    } else {\r\n        do {\r\n            obj = i.previous();\r\n        } while (--pos > index);\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "java.util.zip.ZipInputStream.readEnd",
	"Comment": "reads end of deflated entry as well as ext descriptor if present.",
	"Method": "void readEnd(ZipEntry e){\r\n    int n = inf.getRemaining();\r\n    if (n > 0) {\r\n        ((PushbackInputStream) in).unread(buf, len - n, n);\r\n    }\r\n    if ((flag & 8) == 8) {\r\n        if (inf.getBytesWritten() > ZIP64_MAGICVAL || inf.getBytesRead() > ZIP64_MAGICVAL) {\r\n            readFully(tmpbuf, 0, ZIP64_EXTHDR);\r\n            long sig = get32(tmpbuf, 0);\r\n            if (sig != EXTSIG) {\r\n                e.crc = sig;\r\n                e.csize = get64(tmpbuf, ZIP64_EXTSIZ - ZIP64_EXTCRC);\r\n                e.size = get64(tmpbuf, ZIP64_EXTLEN - ZIP64_EXTCRC);\r\n                ((PushbackInputStream) in).unread(tmpbuf, ZIP64_EXTHDR - ZIP64_EXTCRC - 1, ZIP64_EXTCRC);\r\n            } else {\r\n                e.crc = get32(tmpbuf, ZIP64_EXTCRC);\r\n                e.csize = get64(tmpbuf, ZIP64_EXTSIZ);\r\n                e.size = get64(tmpbuf, ZIP64_EXTLEN);\r\n            }\r\n        } else {\r\n            readFully(tmpbuf, 0, EXTHDR);\r\n            long sig = get32(tmpbuf, 0);\r\n            if (sig != EXTSIG) {\r\n                e.crc = sig;\r\n                e.csize = get32(tmpbuf, EXTSIZ - EXTCRC);\r\n                e.size = get32(tmpbuf, EXTLEN - EXTCRC);\r\n                ((PushbackInputStream) in).unread(tmpbuf, EXTHDR - EXTCRC - 1, EXTCRC);\r\n            } else {\r\n                e.crc = get32(tmpbuf, EXTCRC);\r\n                e.csize = get32(tmpbuf, EXTSIZ);\r\n                e.size = get32(tmpbuf, EXTLEN);\r\n            }\r\n        }\r\n    }\r\n    if (e.size != inf.getBytesWritten()) {\r\n        throw new ZipException(\"invalid entry size (expected \" + e.size + \" but got \" + inf.getBytesWritten() + \" bytes)\");\r\n    }\r\n    if (e.csize != inf.getBytesRead()) {\r\n        throw new ZipException(\"invalid entry compressed size (expected \" + e.csize + \" but got \" + inf.getBytesRead() + \" bytes)\");\r\n    }\r\n    if (e.crc != crc.getValue()) {\r\n        throw new ZipException(\"invalid entry CRC (expected 0x\" + Long.toHexString(e.crc) + \" but got 0x\" + Long.toHexString(crc.getValue()) + \")\");\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.LogRecord.setThreadID",
	"Comment": "set an identifier for the thread where the message originated.",
	"Method": "void setThreadID(int threadID){\r\n    this.threadID = threadID;\r\n}"
}, {
	"Path": "java.util.Calendar.isExternallySet",
	"Comment": "returns whether the value of the specified calendar field has been setexternally by calling one of the setter methods rather than by theinternal time calculation.",
	"Method": "boolean isExternallySet(int field){\r\n    return stamp[field] >= MINIMUM_USER_STAMP;\r\n}"
}, {
	"Path": "java.util.logging.Logger.getUseParentHandlers",
	"Comment": "discover whether or not this logger is sending its outputto its parent logger.",
	"Method": "boolean getUseParentHandlers(){\r\n    return useParentHandlers;\r\n}"
}, {
	"Path": "com.mycompany.myapp.domain.UseCase1Pk.isEmpty",
	"Comment": "helper method to determine if this instance is considered empty, that is,if all the non primary key columns are null.",
	"Method": "boolean isEmpty(){\r\n    return !isId1Set() && !isId2Set();\r\n}"
}, {
	"Path": "org.checkerframework.checker.signedness.SignednessUtil.toUnsignedString",
	"Comment": "produces a string representation of the unsigned byte b in base radix.",
	"Method": "String toUnsignedString(long l,String toUnsignedString,long l,int radix,String toUnsignedString,int i,String toUnsignedString,int i,int radix,String toUnsignedString,short s,String toUnsignedString,short s,int radix,String toUnsignedString,byte b,String toUnsignedString,byte b,int radix){\r\n    return Long.toString(toUnsignedLong(b), radix);\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.toolwindow.CheckStyleToolWindowPanel.expandNode",
	"Comment": "expand the given tree to the given level, starting from the given nodeand path.",
	"Method": "void expandNode(JTree tree,TreeNode node,TreePath path,int level){\r\n    if (level <= 0) {\r\n        return;\r\n    }\r\n    tree.expandPath(path);\r\n    for (int i = 0; i < node.getChildCount(); ++i) {\r\n        final TreeNode childNode = node.getChildAt(i);\r\n        expandNode(tree, childNode, path.pathByAddingChild(childNode), level - 1);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TypeAnnotationUtils.attributeFromAnnotationValue",
	"Comment": "returns a newly created attribute corresponding to an argument annotationvalue.",
	"Method": "Attribute attributeFromAnnotationValue(ExecutableElement meth,AnnotationValue av,ProcessingEnvironment env){\r\n    return av.accept(new AttributeCreator(env, meth), null);\r\n}"
}, {
	"Path": "java.util.Scanner.delimiter",
	"Comment": "returns the pattern this scanner is currentlyusing to match delimiters.",
	"Method": "Pattern delimiter(){\r\n    return delimPattern;\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.HessianOutput.writeNull",
	"Comment": "writes a null value to the stream.the null will be written with the following syntax",
	"Method": "void writeNull(){\r\n    os.write('N');\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.HessianOutput.writeHeader",
	"Comment": "writes a header name.the header value must immediately follow.h b16 b8 foo value",
	"Method": "void writeHeader(String name){\r\n    int len = name.length();\r\n    os.write('H');\r\n    os.write(len >> 8);\r\n    os.write(len);\r\n    printString(name);\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.getYearOffsetInMillis",
	"Comment": "returns the millisecond offset from the beginning of thisyear. this calendar object must have been normalized.",
	"Method": "long getYearOffsetInMillis(){\r\n    long t = (internalGet(DAY_OF_YEAR) - 1) * 24;\r\n    t += internalGet(HOUR_OF_DAY);\r\n    t *= 60;\r\n    t += internalGet(MINUTE);\r\n    t *= 60;\r\n    t += internalGet(SECOND);\r\n    t *= 1000;\r\n    return t + internalGet(MILLISECOND) - (internalGet(ZONE_OFFSET) + internalGet(DST_OFFSET));\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.QualifierHierarchy.isSubtype",
	"Comment": "tests whether there is any annotation in lhs that is a super qualifier of some annotation inrhs. lhs and rhs contain only the annotations, not the java type.",
	"Method": "boolean isSubtype(AnnotationMirror rhs,AnnotationMirror lhs,boolean isSubtype,Collection<? extends AnnotationMirror> rhs,Collection<? extends AnnotationMirror> lhs,boolean isSubtype,AnnotatedTypeMirror subType,AnnotatedTypeMirror superType,AnnotationMirror subAnno,AnnotationMirror superAnno,boolean isSubtype,AnnotatedTypeMirror subType,AnnotatedTypeMirror superType,Collection<? extends AnnotationMirror> subs,Collection<AnnotationMirror> supers){\r\n    if (canHaveEmptyAnnotationSet(subType) || canHaveEmptyAnnotationSet(superType)) {\r\n        return isSubtypeTypeVariable(subs, supers);\r\n    } else {\r\n        return isSubtype(subs, supers);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.MultiGraphQualifierHierarchy.findTops",
	"Comment": "not static to allow adaptation in subclasses. only parameters should be modified.",
	"Method": "Set<AnnotationMirror> findTops(Map<AnnotationMirror, Set<AnnotationMirror>> supertypes){\r\n    Set<AnnotationMirror> possibleTops = AnnotationUtils.createAnnotationSet();\r\n    for (AnnotationMirror anno : supertypes.keySet()) {\r\n        if (supertypes.get(anno).isEmpty()) {\r\n            possibleTops.add(anno);\r\n        }\r\n    }\r\n    return possibleTops;\r\n}"
}, {
	"Path": "java.lang.StringBuffer.readObject",
	"Comment": "readobject is called to restore the state of the stringbuffer froma stream.",
	"Method": "void readObject(java.io.ObjectInputStream s){\r\n    java.io.ObjectInputStream.GetField fields = s.readFields();\r\n    value = (char[]) fields.get(\"value\", null);\r\n    count = fields.get(\"count\", 0);\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.ui.PropertiesPanel.getConfigurationLocation",
	"Comment": "get the configuration location entered in the dialogue, or null if no valid location was entered.",
	"Method": "ConfigurationLocation getConfigurationLocation(){\r\n    commitCellEdits();\r\n    configurationLocation.setProperties(propertiesModel.getProperties());\r\n    return configurationLocation;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.ElementAnnotationApplier.annotateSupers",
	"Comment": "annotate the list of supertypes using the annotations on the typeelement representing a classor interface.",
	"Method": "void annotateSupers(List<AnnotatedDeclaredType> supertypes,TypeElement subtypeElement){\r\n    SuperTypeApplier.annotateSupers(supertypes, subtypeElement);\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.getCutoverCalendarSystem",
	"Comment": "returns the calendar system for dates before the cutover datein the cutover year. if the cutover date is january 1, themethod returns gregorian. otherwise, julian.",
	"Method": "BaseCalendar getCutoverCalendarSystem(){\r\n    if (gregorianCutoverYearJulian < gregorianCutoverYear) {\r\n        return gcal;\r\n    }\r\n    return getJulianCalendarSystem();\r\n}"
}, {
	"Path": "javax.management.openmbean.CompositeType.getDescription",
	"Comment": "returns the description of the item whose name is itemname,or null if this compositetype instance does not define any itemwhose name is itemname.",
	"Method": "String getDescription(String itemName){\r\n    if (itemName == null) {\r\n        return null;\r\n    }\r\n    return nameToDescription.get(itemName);\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.getVariantFor",
	"Comment": "if given class is the same as the class associated with this classdescriptor, returns reference to this class descriptor.otherwise,returns variant of this class descriptor bound to given class.",
	"Method": "ObjectStreamClass getVariantFor(Class<?> cl){\r\n    if (this.cl == cl) {\r\n        return this;\r\n    }\r\n    ObjectStreamClass desc = new ObjectStreamClass();\r\n    if (isProxy) {\r\n        desc.initProxy(cl, null, superDesc);\r\n    } else {\r\n        desc.initNonProxy(this, cl, null, superDesc);\r\n    }\r\n    return desc;\r\n}"
}, {
	"Path": "java.nio.ByteBuffer.equals",
	"Comment": "tells whether or not this buffer is equal to another object. two byte buffers are equal if, and only if, they have the same element type, they have the same number of remaining elements, and the two sequences of remaining elements, consideredindependently of their starting positions, are pointwise equal. a byte buffer is not equal to any other type of object.",
	"Method": "boolean equals(Object ob,boolean equals,byte x,byte y){\r\n    return x == y;\r\n}"
}, {
	"Path": "java.io.PrintWriter.close",
	"Comment": "closes the stream and releases any system resources associatedwith it. closing a previously closed stream has no effect.",
	"Method": "void close(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.lang.Class.getPackage",
	"Comment": "gets the package for this class.the class loader of this class is usedto find the package.if the class was loaded by the bootstrap classloader the set of packages loaded from classpath is searched to find thepackage of the class. null is returned if no package object was createdby the class loader of this class. packages have attributes for versions and specifications only if theinformation was defined in the manifests that accompany the classes, andif the class loader created the package instance with the attributesfrom the manifest.",
	"Method": "Package getPackage(){\r\n    return Package.getPackage(this);\r\n}"
}, {
	"Path": "java.net.URLClassLoader.findResources",
	"Comment": "returns an enumeration of urls representing all of the resourceson the url search path having the specified name.",
	"Method": "Enumeration<URL> findResources(String name){\r\n    final Enumeration<URL> e = ucp.findResources(name, true);\r\n    return new Enumeration<URL>() {\r\n        @Nullable\r\n        private URL url = null;\r\n        @EnsuresNonNullIf(expression = \"url\", result = true)\r\n        private boolean next() {\r\n            if (url != null) {\r\n                return true;\r\n            }\r\n            do {\r\n                URL u = AccessController.doPrivileged(new PrivilegedAction<@Nullable URL>() {\r\n                    @Nullable\r\n                    public URL run() {\r\n                        if (!e.hasMoreElements())\r\n                            return null;\r\n                        return e.nextElement();\r\n                    }\r\n                }, acc);\r\n                if (u == null)\r\n                    break;\r\n                url = ucp.checkURL(u);\r\n            } while (url == null);\r\n            return url != null;\r\n        }\r\n        public URL nextElement() {\r\n            if (!next()) {\r\n                throw new NoSuchElementException();\r\n            }\r\n            URL u = url;\r\n            url = null;\r\n            return u;\r\n        }\r\n        public boolean hasMoreElements() {\r\n            return next();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "java.net.URLClassLoader.findResources",
	"Comment": "returns an enumeration of urls representing all of the resourceson the url search path having the specified name.",
	"Method": "Enumeration<URL> findResources(String name){\r\n    if (url != null) {\r\n        return true;\r\n    }\r\n    do {\r\n        URL u = AccessController.doPrivileged(new PrivilegedAction<@Nullable URL>() {\r\n            @Nullable\r\n            public URL run() {\r\n                if (!e.hasMoreElements())\r\n                    return null;\r\n                return e.nextElement();\r\n            }\r\n        }, acc);\r\n        if (u == null)\r\n            break;\r\n        url = ucp.checkURL(u);\r\n    } while (url == null);\r\n    return url != null;\r\n}"
}, {
	"Path": "java.net.URLClassLoader.findResources",
	"Comment": "returns an enumeration of urls representing all of the resourceson the url search path having the specified name.",
	"Method": "Enumeration<URL> findResources(String name){\r\n    if (!e.hasMoreElements())\r\n        return null;\r\n    return e.nextElement();\r\n}"
}, {
	"Path": "java.net.URLClassLoader.findResources",
	"Comment": "returns an enumeration of urls representing all of the resourceson the url search path having the specified name.",
	"Method": "Enumeration<URL> findResources(String name){\r\n    if (!next()) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    URL u = url;\r\n    url = null;\r\n    return u;\r\n}"
}, {
	"Path": "java.net.URLClassLoader.findResources",
	"Comment": "returns an enumeration of urls representing all of the resourceson the url search path having the specified name.",
	"Method": "Enumeration<URL> findResources(String name){\r\n    return next();\r\n}"
}, {
	"Path": "java.util.EnumMap.put",
	"Comment": "associates the specified value with the specified key in this map.if the map previously contained a mapping for this key, the oldvalue is replaced.",
	"Method": "V put(K key,V value){\r\n    typeCheck(key);\r\n    int index = key.ordinal();\r\n    Object oldValue = vals[index];\r\n    vals[index] = maskNull(value);\r\n    if (oldValue == null)\r\n        size++;\r\n    return unmaskNull(oldValue);\r\n}"
}, {
	"Path": "sun.util.LocaleServiceProviderPool.getAvailableLocales",
	"Comment": "returns an array of available locales.this array is amerged array of all the locales that are provided by eachprovider, including the jre.",
	"Method": "Locale[] getAvailableLocales(Locale[] getAvailableLocales){\r\n    if (availableLocales == null) {\r\n        availableLocales = new HashSet<Locale>(getJRELocales());\r\n        if (hasProviders()) {\r\n            availableLocales.addAll(getProviderLocales());\r\n        }\r\n    }\r\n    Locale[] tmp = new Locale[availableLocales.size()];\r\n    availableLocales.toArray(tmp);\r\n    return tmp;\r\n}"
}, {
	"Path": "java.util.logging.Logger.fine",
	"Comment": "log a fine message.if the logger is currently enabled for the fine messagelevel then the given message is forwarded to all theregistered output handler objects.",
	"Method": "void fine(String msg){\r\n    if (Level.FINE.intValue() < levelValue) {\r\n        return;\r\n    }\r\n    log(Level.FINE, msg);\r\n}"
}, {
	"Path": "java.text.DateFormatSymbols.writeObject",
	"Comment": "write out the default serializable data, after ensuring thezonestrings field is initialized in order to makesure the backward compatibility.",
	"Method": "void writeObject(ObjectOutputStream stream){\r\n    if (zoneStrings == null) {\r\n        zoneStrings = TimeZoneNameUtility.getZoneStrings(locale);\r\n    }\r\n    stream.defaultWriteObject();\r\n}"
}, {
	"Path": "org.checkerframework.checker.units.UnitsRelationsDefault.bothHaveSpecificPrefix",
	"Comment": "checks to see if both lhtprefix and rhtprefix have the same prefix as specificprefix.",
	"Method": "boolean bothHaveSpecificPrefix(Prefix lhtPrefix,Prefix rhtPrefix,Prefix specificPrefix){\r\n    if (lhtPrefix == null || rhtPrefix == null || specificPrefix == null) {\r\n        return false;\r\n    }\r\n    return (lhtPrefix.equals(rhtPrefix) && rhtPrefix.equals(specificPrefix));\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.createAnnotatedTypeFormatter",
	"Comment": "creates the annotatedtypeformatter used by this type factory and all annotatedtypemirrors itcreates. the annotatedtypeformatter is used in annotatedtypemirror.tostring and will affectthe error messages printed for checkers that use this type factory.",
	"Method": "AnnotatedTypeFormatter createAnnotatedTypeFormatter(){\r\n    boolean printVerboseGenerics = checker.hasOption(\"printVerboseGenerics\");\r\n    return new // -AprintVerboseGenerics implies -AprintAllQualifiers\r\n    DefaultAnnotatedTypeFormatter(printVerboseGenerics, printVerboseGenerics || checker.hasOption(\"printAllQualifiers\"));\r\n}"
}, {
	"Path": "java.awt.image.ColorModel.equals",
	"Comment": "tests if the specified object is an instance ofcolormodel and if it equals thiscolormodel.",
	"Method": "boolean equals(Object obj){\r\n    if (!(obj instanceof ColorModel)) {\r\n        return false;\r\n    }\r\n    ColorModel cm = (ColorModel) obj;\r\n    if (this == cm) {\r\n        return true;\r\n    }\r\n    if (supportsAlpha != cm.hasAlpha() || isAlphaPremultiplied != cm.isAlphaPremultiplied() || pixel_bits != cm.getPixelSize() || transparency != cm.getTransparency() || numComponents != cm.getNumComponents()) {\r\n        return false;\r\n    }\r\n    int[] nb = cm.getComponentSize();\r\n    if ((nBits != null) && (nb != null)) {\r\n        for (int i = 0; i < numComponents; i++) {\r\n            if (nBits[i] != nb[i]) {\r\n                return false;\r\n            }\r\n        }\r\n    } else {\r\n        return ((nBits == null) && (nb == null));\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.checkerframework.dataflow.analysis.AnalysisResult.mergeTreeLookup",
	"Comment": "merge all entries from othertreelookup into treelookup. merge sets if already present.",
	"Method": "void mergeTreeLookup(IdentityHashMap<Tree, Set<Node>> treeLookup,IdentityHashMap<Tree, Set<Node>> otherTreeLookup){\r\n    for (Entry<Tree, Set<Node>> entry : otherTreeLookup.entrySet()) {\r\n        Set<Node> hit = treeLookup.get(entry.getKey());\r\n        if (hit == null) {\r\n            treeLookup.put(entry.getKey(), entry.getValue());\r\n        } else {\r\n            hit.addAll(entry.getValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.constraint.AFReducingVisitor.visitNull_Array",
	"Comment": "null types only have primary annotations. a type parameter could only appear as a componentof the parameter type and therefore has no relationship to these primary annotations",
	"Method": "Void visitNull_Array(AnnotatedNullType argument,AnnotatedArrayType parameter,Set<AFConstraint> constraints){\r\n    return null;\r\n}"
}, {
	"Path": "java.awt.image.ColorModel.getAlpha",
	"Comment": "returns the alpha component for the specified pixel, scaledfrom 0 to 255.the pixel value is specified as an int.an illegalargumentexception is thrown if pixelvalues for this colormodel are not convenientlyrepresentable as a single int.",
	"Method": "int getAlpha(int pixel,int getAlpha,Object inData){\r\n    int pixel = 0, length = 0;\r\n    switch(transferType) {\r\n        case DataBuffer.TYPE_BYTE:\r\n            byte[] bdata = (byte[]) inData;\r\n            pixel = bdata[0] & 0xff;\r\n            length = bdata.length;\r\n            break;\r\n        case DataBuffer.TYPE_USHORT:\r\n            short[] sdata = (short[]) inData;\r\n            pixel = sdata[0] & 0xffff;\r\n            length = sdata.length;\r\n            break;\r\n        case DataBuffer.TYPE_INT:\r\n            int[] idata = (int[]) inData;\r\n            pixel = idata[0];\r\n            length = idata.length;\r\n            break;\r\n        default:\r\n            throw new UnsupportedOperationException(\"This method has not been \" + \"implemented for transferType \" + transferType);\r\n    }\r\n    if (length == 1) {\r\n        return getAlpha(pixel);\r\n    } else {\r\n        throw new UnsupportedOperationException(\"This method is not supported by this color model\");\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.checker.units.UnitsRelationsTools.buildAnnoMirrorWithSpecificPrefix",
	"Comment": "creates an annotationmirror representing a unit defined by annoclass, with the specificprefix p.",
	"Method": "AnnotationMirror buildAnnoMirrorWithSpecificPrefix(ProcessingEnvironment env,Class<? extends Annotation> annoClass,Prefix p){\r\n    if (env == null || annoClass == null || p == null) {\r\n        return null;\r\n    }\r\n    AnnotationBuilder builder = new AnnotationBuilder(env, annoClass);\r\n    builder.setValue(\"value\", p);\r\n    return builder.build();\r\n}"
}, {
	"Path": "java.util.zip.ZipOutputStream.closeEntry",
	"Comment": "closes the current zip entry and positions the stream for writingthe next entry.",
	"Method": "void closeEntry(){\r\n    ensureOpen();\r\n    if (current != null) {\r\n        ZipEntry e = current.entry;\r\n        switch(e.method) {\r\n            case DEFLATED:\r\n                def.finish();\r\n                while (!def.finished()) {\r\n                    deflate();\r\n                }\r\n                if ((e.flag & 8) == 0) {\r\n                    if (e.size != def.getBytesRead()) {\r\n                        throw new ZipException(\"invalid entry size (expected \" + e.size + \" but got \" + def.getBytesRead() + \" bytes)\");\r\n                    }\r\n                    if (e.csize != def.getBytesWritten()) {\r\n                        throw new ZipException(\"invalid entry compressed size (expected \" + e.csize + \" but got \" + def.getBytesWritten() + \" bytes)\");\r\n                    }\r\n                    if (e.crc != crc.getValue()) {\r\n                        throw new ZipException(\"invalid entry CRC-32 (expected 0x\" + Long.toHexString(e.crc) + \" but got 0x\" + Long.toHexString(crc.getValue()) + \")\");\r\n                    }\r\n                } else {\r\n                    e.size = def.getBytesRead();\r\n                    e.csize = def.getBytesWritten();\r\n                    e.crc = crc.getValue();\r\n                    writeEXT(e);\r\n                }\r\n                def.reset();\r\n                written += e.csize;\r\n                break;\r\n            case STORED:\r\n                if (e.size != written - locoff) {\r\n                    throw new ZipException(\"invalid entry size (expected \" + e.size + \" but got \" + (written - locoff) + \" bytes)\");\r\n                }\r\n                if (e.crc != crc.getValue()) {\r\n                    throw new ZipException(\"invalid entry crc-32 (expected 0x\" + Long.toHexString(e.crc) + \" but got 0x\" + Long.toHexString(crc.getValue()) + \")\");\r\n                }\r\n                break;\r\n            default:\r\n                throw new ZipException(\"invalid compression method\");\r\n        }\r\n        crc.reset();\r\n        current = null;\r\n    }\r\n}"
}, {
	"Path": "java.util.zip.DeflaterInputStream.available",
	"Comment": "returns 0 after eof has been reached, otherwise always return 1.programs should not count on this method to return the actual numberof bytes that could be read without blocking",
	"Method": "int available(){\r\n    ensureOpen();\r\n    if (reachEOF) {\r\n        return 0;\r\n    }\r\n    return 1;\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.containsValue",
	"Comment": "tests whether the specified object reference is a value in this identityhash map.",
	"Method": "boolean containsValue(Object value){\r\n    Object[] tab = table;\r\n    for (int i = 1; i < tab.length; i += 2) if (tab[i] == value && tab[i - 1] != null)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "java.util.regex.Matcher.match",
	"Comment": "initiates a search for an anchored match to a pattern within the givenbounds. the groups are filled with default values and the match of theroot of the state machine is called. the state machine will hold thestate of the match as it proceeds in this matcher.",
	"Method": "boolean match(int from,int anchor){\r\n    this.hitEnd = false;\r\n    this.requireEnd = false;\r\n    from = from < 0 ? 0 : from;\r\n    this.first = from;\r\n    this.oldLast = oldLast < 0 ? from : oldLast;\r\n    for (int i = 0; i < groups.length; i++) groups[i] = -1;\r\n    acceptMode = anchor;\r\n    boolean result = parentPattern.matchRoot.match(this, from, text);\r\n    if (!result)\r\n        this.first = -1;\r\n    this.oldLast = this.last;\r\n    return result;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.constraint.AFReducingVisitor.visitNull_Primitive",
	"Comment": "primitive parameter types tell us nothing about the type parameters",
	"Method": "Void visitNull_Primitive(AnnotatedNullType argument,AnnotatedPrimitiveType parameter,Set<AFConstraint> constraints){\r\n    return null;\r\n}"
}, {
	"Path": "java.net.URLClassLoader.findResource",
	"Comment": "finds the resource with the specified name on the url search path.",
	"Method": "URL findResource(String name){\r\n    URL url = AccessController.doPrivileged(new PrivilegedAction<URL>() {\r\n        public URL run() {\r\n            return ucp.findResource(name, true);\r\n        }\r\n    }, acc);\r\n    return url != null ? ucp.checkURL(url) : null;\r\n}"
}, {
	"Path": "java.net.URLClassLoader.findResource",
	"Comment": "finds the resource with the specified name on the url search path.",
	"Method": "URL findResource(String name){\r\n    return ucp.findResource(name, true);\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.StubUtil.standarizeType",
	"Comment": "a helper method that standarize type by printing simple names instead of fully qualifiednames.this eliminates the need for imports.",
	"Method": "String standarizeType(TypeMirror type){\r\n    switch(type.getKind()) {\r\n        case ARRAY:\r\n            return standarizeType(((ArrayType) type).getComponentType()) + \"[]\";\r\n        case TYPEVAR:\r\n            return ((TypeVariable) type).asElement().getSimpleName().toString();\r\n        case DECLARED:\r\n            {\r\n                return ((DeclaredType) type).asElement().getSimpleName().toString();\r\n            }\r\n        default:\r\n            if (type.getKind().isPrimitive()) {\r\n                return type.toString();\r\n            }\r\n    }\r\n    throw new BugInCF(\"StubUtil: unhandled type: \" + type);\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.typeannotator.PropagationTypeAnnotator.applyAnnosFromBound",
	"Comment": "take the primary annotations from typeparambound and place them as primary annotations onwildcard bound.",
	"Method": "void applyAnnosFromBound(AnnotatedTypeMirror wildcardBound,AnnotatedTypeMirror typeParamBound,Set<? extends AnnotationMirror> tops){\r\n    if (wildcardBound.getKind() == TypeKind.TYPEVAR || typeParamBound.getKind() == TypeKind.TYPEVAR) {\r\n        return;\r\n    }\r\n    for (final AnnotationMirror top : tops) {\r\n        if (wildcardBound.getAnnotationInHierarchy(top) == null) {\r\n            final AnnotationMirror typeParamAnno = typeParamBound.getAnnotationInHierarchy(top);\r\n            if (typeParamAnno == null) {\r\n                throw new BugInCF(\"Missing annotation on type parameter\\n\" + \"top=\" + top + \"\\n\" + \"wildcardBound=\" + wildcardBound + \"\\n\" + \"typeParamBound=\" + typeParamBound + \"\\n\");\r\n            }\r\n            wildcardBound.addAnnotation(typeParamAnno);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.HashMap.removeEntryForKey",
	"Comment": "removes and returns the entry associated with the specified keyin the hashmap.returns null if the hashmap contains no mappingfor this key.",
	"Method": "Entry<K, V> removeEntryForKey(Object key){\r\n    int hash = (key == null) ? 0 : hash(key.hashCode());\r\n    int i = indexFor(hash, table.length);\r\n    Entry<K, V> prev = table[i];\r\n    Entry<K, V> e = prev;\r\n    while (e != null) {\r\n        Entry<K, V> next = e.next;\r\n        Object k;\r\n        if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k)))) {\r\n            modCount++;\r\n            size--;\r\n            if (prev == e)\r\n                table[i] = next;\r\n            else\r\n                prev.next = next;\r\n            e.recordRemoval(this);\r\n            return e;\r\n        }\r\n        prev = e;\r\n        e = next;\r\n    }\r\n    return e;\r\n}"
}, {
	"Path": "com.mycompany.myapp.domain.Author.toString",
	"Comment": "construct a readable string representation for this author instance.",
	"Method": "String toString(){\r\n    return // \r\n    MoreObjects.toStringHelper(this).add(\"id\", // \r\n    getId()).add(\"civility\", // \r\n    getCivility()).add(\"lastName\", // \r\n    getLastName()).add(\"firstName\", // \r\n    getFirstName()).add(\"email\", // \r\n    getEmail()).add(\"birthDate\", // \r\n    getBirthDate()).add(\"birthDateTime\", getBirthDateTime()).toString();\r\n}"
}, {
	"Path": "java.lang.NumberFormatException.forInputString",
	"Comment": "factory method for making a numberformatexceptiongiven the specified input which caused the error.",
	"Method": "NumberFormatException forInputString(String s){\r\n    return new NumberFormatException(\"For input string: \\\"\" + s + \"\\\"\");\r\n}"
}, {
	"Path": "java.lang.AbstractStringBuilder.capacity",
	"Comment": "returns the current capacity. the capacity is the amount of storageavailable for newly inserted characters, beyond which an allocationwill occur.",
	"Method": "int capacity(){\r\n    return value.length;\r\n}"
}, {
	"Path": "java.util.regex.Matcher.hitEnd",
	"Comment": "returns true if the end of input was hit by the search engine inthe last match operation performed by this matcher.when this method returns true, then it is possible that more inputwould have changed the result of the last search.",
	"Method": "boolean hitEnd(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.Locale.hashCode",
	"Comment": "override hashcode.since locales are often used in hashtables, caches the valuefor speed.",
	"Method": "int hashCode(int hashCode){\r\n    int hc = hashCodeValue;\r\n    if (hc == 0) {\r\n        hc = baseLocale.hashCode();\r\n        if (localeExtensions != null) {\r\n            hc ^= localeExtensions.hashCode();\r\n        }\r\n        hashCodeValue = hc;\r\n    }\r\n    return hc;\r\n}"
}, {
	"Path": "java.util.regex.Pattern.normalize",
	"Comment": "the pattern is converted to normalizedd form and then a pure groupis constructed to match canonical equivalences of the characters.",
	"Method": "void normalize(){\r\n    boolean inCharClass = false;\r\n    int lastCodePoint = -1;\r\n    normalizedPattern = Normalizer.normalize(pattern, Normalizer.Form.NFD);\r\n    patternLength = normalizedPattern.length();\r\n    StringBuilder newPattern = new StringBuilder(patternLength);\r\n    for (int i = 0; i < patternLength; ) {\r\n        int c = normalizedPattern.codePointAt(i);\r\n        StringBuilder sequenceBuffer;\r\n        if ((Character.getType(c) == Character.NON_SPACING_MARK) && (lastCodePoint != -1)) {\r\n            sequenceBuffer = new StringBuilder();\r\n            sequenceBuffer.appendCodePoint(lastCodePoint);\r\n            sequenceBuffer.appendCodePoint(c);\r\n            while (Character.getType(c) == Character.NON_SPACING_MARK) {\r\n                i += Character.charCount(c);\r\n                if (i >= patternLength)\r\n                    break;\r\n                c = normalizedPattern.codePointAt(i);\r\n                sequenceBuffer.appendCodePoint(c);\r\n            }\r\n            String ea = produceEquivalentAlternation(sequenceBuffer.toString());\r\n            newPattern.setLength(newPattern.length() - Character.charCount(lastCodePoint));\r\n            newPattern.append(\"(?:\").append(ea).append(\")\");\r\n        } else if (c == '[' && lastCodePoint != '\\\\') {\r\n            i = normalizeCharClass(newPattern, i);\r\n        } else {\r\n            newPattern.appendCodePoint(c);\r\n        }\r\n        lastCodePoint = c;\r\n        i += Character.charCount(c);\r\n    }\r\n    normalizedPattern = newPattern.toString();\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueCheckerUtils.getValuesCastedToType",
	"Comment": "get a list of values of annotation, and then cast them to a given type.",
	"Method": "List<?> getValuesCastedToType(AnnotationMirror anno,TypeMirror castTo){\r\n    Class<?> castType = ValueCheckerUtils.getClassFromType(castTo);\r\n    List<?> values = null;\r\n    if (AnnotationUtils.areSameByClass(anno, DoubleVal.class)) {\r\n        values = convertDoubleVal(anno, castType, castTo);\r\n    } else if (AnnotationUtils.areSameByClass(anno, IntVal.class)) {\r\n        List<Long> longs = ValueAnnotatedTypeFactory.getIntValues(anno);\r\n        values = convertIntVal(longs, castType, castTo);\r\n    } else if (AnnotationUtils.areSameByClass(anno, IntRange.class)) {\r\n        Range range = ValueAnnotatedTypeFactory.getRange(anno);\r\n        List<Long> longs = getValuesFromRange(range, Long.class);\r\n        values = convertIntVal(longs, castType, castTo);\r\n    } else if (AnnotationUtils.areSameByClass(anno, StringVal.class)) {\r\n        values = convertStringVal(anno, castType);\r\n    } else if (AnnotationUtils.areSameByClass(anno, BoolVal.class)) {\r\n        values = convertBoolVal(anno, castType);\r\n    } else if (AnnotationUtils.areSameByClass(anno, BottomVal.class)) {\r\n        values = new ArrayList();\r\n    } else if (AnnotationUtils.areSameByClass(anno, UnknownVal.class)) {\r\n        values = null;\r\n    } else if (AnnotationUtils.areSameByClass(anno, ArrayLen.class)) {\r\n        values = new ArrayList();\r\n    }\r\n    return values;\r\n}"
}, {
	"Path": "java.lang.System.initializeSystemClass",
	"Comment": "initialize the system class.called after thread initialization.",
	"Method": "void initializeSystemClass(){\r\n    props = new Properties();\r\n    initProperties(props);\r\n    sun.misc.VM.saveAndRemoveProperties(props);\r\n    lineSeparator = props.getProperty(\"line.separator\");\r\n    sun.misc.Version.init();\r\n    FileInputStream fdIn = new FileInputStream(FileDescriptor.in);\r\n    FileOutputStream fdOut = new FileOutputStream(FileDescriptor.out);\r\n    FileOutputStream fdErr = new FileOutputStream(FileDescriptor.err);\r\n    setIn0(new BufferedInputStream(fdIn));\r\n    setOut0(new PrintStream(new BufferedOutputStream(fdOut, 128), true));\r\n    setErr0(new PrintStream(new BufferedOutputStream(fdErr, 128), true));\r\n    loadLibrary(\"zip\");\r\n    Terminator.setup();\r\n    sun.misc.VM.initializeOSEnvironment();\r\n    sun.misc.VM.booted();\r\n    Thread current = Thread.currentThread();\r\n    current.getThreadGroup().add(current);\r\n    setJavaLangAccess();\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.ProjectDTOService.toDTO",
	"Comment": "converts the passed project to a dto. the depth is used to control theamount of association you want. it also prevents potential infinite serialization cycles.",
	"Method": "ProjectDTO toDTO(Project project,ProjectDTO toDTO,Project project,int depth){\r\n    if (project == null) {\r\n        return null;\r\n    }\r\n    ProjectDTO dto = new ProjectDTO();\r\n    dto.id = project.getId();\r\n    dto.name = project.getName();\r\n    dto.url = project.getUrl();\r\n    dto.openSource = project.getOpenSource();\r\n    if (depth-- > 0) {\r\n        dto.author = authorDTOService.toDTO(project.getAuthor(), depth);\r\n    }\r\n    return dto;\r\n}"
}, {
	"Path": "sun.util.resources.LocaleData.getLocaleNames",
	"Comment": "gets a locale names resource bundle, using privilegesto allow accessing a sun. package.",
	"Method": "OpenListResourceBundle getLocaleNames(Locale locale){\r\n    return (OpenListResourceBundle) getBundle(\"sun.util.resources.LocaleNames\", locale);\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.StubParser.addEnclosingTypesToImportedTypes",
	"Comment": "if a member is imported, then consider every containing class to also be imported.",
	"Method": "void addEnclosingTypesToImportedTypes(Element element){\r\n    for (Element enclosedEle : element.getEnclosedElements()) {\r\n        if (enclosedEle.getKind().isClass()) {\r\n            importedTypes.put(enclosedEle.getSimpleName().toString(), (TypeElement) enclosedEle);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.element.MethodApplier.applyTypeVarUseOnReturnType",
	"Comment": "if the return type is a use of a type variable first apply the bound annotations from thetype variables declaration.",
	"Method": "void applyTypeVarUseOnReturnType(){\r\n    new TypeVarUseApplier(methodType.getReturnType(), methodSymbol, typeFactory).extractAndApply();\r\n}"
}, {
	"Path": "java.lang.ClassLoader.setSigners",
	"Comment": "sets the signers of a class.this should be invoked after defining aclass.",
	"Method": "void setSigners(Class<?> c,Object[] signers){\r\n    c.setSigners(signers);\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.RoleDTOService.toDTO",
	"Comment": "converts the passed role to a dto. the depth is used to control theamount of association you want. it also prevents potential infinite serialization cycles.",
	"Method": "RoleDTO toDTO(Role role,RoleDTO toDTO,Role role,int depth){\r\n    if (role == null) {\r\n        return null;\r\n    }\r\n    RoleDTO dto = new RoleDTO();\r\n    dto.id = role.getId();\r\n    dto.roleName = role.getRoleName();\r\n    if (depth-- > 0) {\r\n    }\r\n    return dto;\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.checkDeserialize",
	"Comment": "throws an invalidclassexception if object instances referencing thisclass descriptor should not be allowed to deserialize.this method doesnot apply to deserialization of enum constants.",
	"Method": "void checkDeserialize(){\r\n    if (deserializeEx != null) {\r\n        throw deserializeEx.newInvalidClassException();\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.checker.signedness.SignednessUtil.shortFromDouble",
	"Comment": "returns an unsigned short representing the same value as the double.",
	"Method": "short shortFromDouble(double d){\r\n    assert d >= 0;\r\n    return (short) d;\r\n}"
}, {
	"Path": "java.io.FileInputStream.read",
	"Comment": "reads up to b.length bytes of data from this inputstream into an array of bytes. this method blocks until some inputis available.",
	"Method": "int read(int read,byte b,int read,byte b,int off,int len){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.StubParser.findFieldElement",
	"Comment": "looks for a field element in the typeelt and returns it if the element has the same name asprovided. in case field element is not found it returns null.",
	"Method": "VariableElement findFieldElement(TypeElement typeElt,String fieldName){\r\n    for (VariableElement field : ElementUtils.getAllFieldsIn(typeElt, elements)) {\r\n        if (fieldName.equals(field.getSimpleName().toString())) {\r\n            return field;\r\n        }\r\n    }\r\n    stubWarnNotFound(\"Field \" + fieldName + \" not found in type \" + typeElt);\r\n    if (debugStubParser) {\r\n        for (VariableElement field : ElementFilter.fieldsIn(typeElt.getEnclosedElements())) {\r\n            stubDebug(String.format(\"  %s\", field));\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.HessianInput.readObject",
	"Comment": "reads an arbitrary object from the input stream when the typeis unknown.",
	"Method": "Object readObject(Class cl,Object readObject){\r\n    int tag = read();\r\n    switch(tag) {\r\n        case 'N':\r\n            return null;\r\n        case 'T':\r\n            return Boolean.valueOf(true);\r\n        case 'F':\r\n            return Boolean.valueOf(false);\r\n        case 'I':\r\n            return Integer.valueOf(parseInt());\r\n        case 'L':\r\n            return Long.valueOf(parseLong());\r\n        case 'D':\r\n            return Double.valueOf(parseDouble());\r\n        case 'd':\r\n            return new Date(parseLong());\r\n        case 'x':\r\n        case 'X':\r\n            {\r\n                _isLastChunk = tag == 'X';\r\n                _chunkLength = (read() << 8) + read();\r\n                return parseXML();\r\n            }\r\n        case 's':\r\n        case 'S':\r\n            {\r\n                _isLastChunk = tag == 'S';\r\n                _chunkLength = (read() << 8) + read();\r\n                int data;\r\n                _sbuf.setLength(0);\r\n                while ((data = parseChar()) >= 0) {\r\n                    _sbuf.append((char) data);\r\n                }\r\n                return _sbuf.toString();\r\n            }\r\n        case 'b':\r\n        case 'B':\r\n            {\r\n                _isLastChunk = tag == 'B';\r\n                _chunkLength = (read() << 8) + read();\r\n                int data;\r\n                ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n                while ((data = parseByte()) >= 0) {\r\n                    bos.write(data);\r\n                }\r\n                return bos.toByteArray();\r\n            }\r\n        case 'V':\r\n            {\r\n                String type = readType();\r\n                int length = readLength();\r\n                return _serializerFactory.readList(this, length, type);\r\n            }\r\n        case 'M':\r\n            {\r\n                String type = readType();\r\n                return _serializerFactory.readMap(this, type);\r\n            }\r\n        case 'R':\r\n            {\r\n                int ref = parseInt();\r\n                return _refs.get(ref);\r\n            }\r\n        case 'r':\r\n            {\r\n                String type = readType();\r\n                String url = readString();\r\n                return resolveRemote(type, url);\r\n            }\r\n        default:\r\n            throw error(\"unknown code for readObject at \" + codeName(tag));\r\n    }\r\n}"
}, {
	"Path": "java.io.DataInputStream.readDouble",
	"Comment": "see the general contract of the readdoublemethod of datainput.bytesfor this operation are read from the containedinput stream.",
	"Method": "double readDouble(){\r\n    return Double.longBitsToDouble(readLong());\r\n}"
}, {
	"Path": "java.util.Calendar.internalGet",
	"Comment": "returns the value of the given calendar field. this method doesnot involve normalization or validation of the field value.",
	"Method": "int internalGet(int field){\r\n    return fields[field];\r\n}"
}, {
	"Path": "java.util.StringTokenizer.scanToken",
	"Comment": "skips ahead from startpos and returns the index of the next delimitercharacter encountered, or maxposition if no such delimiter is found.",
	"Method": "int scanToken(int startPos){\r\n    int position = startPos;\r\n    while (position < maxPosition) {\r\n        if (!hasSurrogates) {\r\n            char c = str.charAt(position);\r\n            if ((c <= maxDelimCodePoint) && (delimiters.indexOf(c) >= 0))\r\n                break;\r\n            position++;\r\n        } else {\r\n            int c = str.codePointAt(position);\r\n            if ((c <= maxDelimCodePoint) && isDelimiter(c))\r\n                break;\r\n            position += Character.charCount(c);\r\n        }\r\n    }\r\n    if (retDelims && (startPos == position)) {\r\n        if (!hasSurrogates) {\r\n            char c = str.charAt(position);\r\n            if ((c <= maxDelimCodePoint) && (delimiters.indexOf(c) >= 0))\r\n                position++;\r\n        } else {\r\n            int c = str.codePointAt(position);\r\n            if ((c <= maxDelimCodePoint) && isDelimiter(c))\r\n                position += Character.charCount(c);\r\n        }\r\n    }\r\n    return position;\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TreeUtils.pathTillClass",
	"Comment": "gets path to the first enclosing class tree, where class is defined by the classtreekindsmethod.",
	"Method": "TreePath pathTillClass(TreePath path){\r\n    return pathTillOfKind(path, classTreeKinds());\r\n}"
}, {
	"Path": "org.checkerframework.checker.signedness.SignednessUtil.longFromDouble",
	"Comment": "returns an unsigned long representing the same value as the double.",
	"Method": "long longFromDouble(double d){\r\n    assert d >= 0;\r\n    return (long) d;\r\n}"
}, {
	"Path": "java.util.PriorityQueue.removeEq",
	"Comment": "version of remove using reference equality, not equals.needed by iterator.remove.",
	"Method": "boolean removeEq(Object o){\r\n    for (int i = 0; i < size; i++) {\r\n        if (o == queue[i]) {\r\n            removeAt(i);\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.TypeArgInferenceUtil.isArgument",
	"Comment": "returns whether argumenttree is the tree at the leaf of path. if tree is a conditionalexpression, isargument is called recursively on the true and false expressions.",
	"Method": "boolean isArgument(TreePath path,ExpressionTree argumentTree){\r\n    argumentTree = TreeUtils.skipParens(argumentTree);\r\n    if (argumentTree == path.getLeaf()) {\r\n        return true;\r\n    } else if (argumentTree.getKind() == Kind.CONDITIONAL_EXPRESSION) {\r\n        ConditionalExpressionTree conditionalExpressionTree = (ConditionalExpressionTree) argumentTree;\r\n        return isArgument(path, conditionalExpressionTree.getTrueExpression()) || isArgument(path, conditionalExpressionTree.getFalseExpression());\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.checkerframework.checker.guieffect.GuiEffectTypeFactory.constrainLambdaToUI",
	"Comment": "force the given lambda expression to have uieffect.used by guieffectvisitor to mark as uieffect all lambdas that perform uieffect callsinside their bodies.",
	"Method": "void constrainLambdaToUI(LambdaExpressionTree lambdaExpressionTree){\r\n    uiLambdas.add(lambdaExpressionTree);\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentSkipListSet.iterator",
	"Comment": "returns an iterator over the elements in this set in ascending order.",
	"Method": "Iterator<E> iterator(){\r\n    return m.navigableKeySet().iterator();\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.diagnostics.TestDiagnosticUtils.fromDiagnosticFileLine",
	"Comment": "convert a line in a diagnosticfile to a testdiagnosticline.",
	"Method": "TestDiagnosticLine fromDiagnosticFileLine(String diagnosticLine){\r\n    final String trimmedLine = diagnosticLine.trim();\r\n    if (trimmedLine.startsWith(\"#\") || trimmedLine.isEmpty()) {\r\n        return new TestDiagnosticLine(\"\", -1, diagnosticLine, EMPTY);\r\n    }\r\n    TestDiagnostic diagnostic = fromDiagnosticFileString(diagnosticLine);\r\n    return new TestDiagnosticLine(\"\", diagnostic.getLineNumber(), diagnosticLine, Arrays.asList(diagnostic));\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.AnnotationBuilder.copyRenameElementValuesFromAnnotation",
	"Comment": "copies the specified element values from the given annotation, using the specified renamingmap. each value in the map must be an element name in the annotation being built. if anelement from the given annotation is not a key in the map, it is ignored.",
	"Method": "void copyRenameElementValuesFromAnnotation(AnnotationMirror valueHolder,Map<String, String> elementNameRenaming){\r\n    for (Map.Entry<? extends ExecutableElement, ? extends AnnotationValue> eltValToCopy : valueHolder.getElementValues().entrySet()) {\r\n        String sourceName = eltValToCopy.getKey().getSimpleName().toString();\r\n        String targetName = elementNameRenaming.get(sourceName);\r\n        if (targetName == null) {\r\n            continue;\r\n        }\r\n        elementValues.put(findElement(targetName), eltValToCopy.getValue());\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.common.wholeprograminference.WholeProgramInferenceScenesHelper.getJaifPath",
	"Comment": "returns the string representing the .jaif path of a class given its name.",
	"Method": "String getJaifPath(String className){\r\n    String jaifPath = JAIF_FILES_PATH + className + \".jaif\";\r\n    return jaifPath;\r\n}"
}, {
	"Path": "java.util.EnumMap.putAll",
	"Comment": "copies all of the mappings from the specified map to this map.these mappings will replace any mappings that this map had forany of the keys currently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> m){\r\n    if (m instanceof EnumMap) {\r\n        EnumMap<? extends K, ? extends V> em = (EnumMap<? extends K, ? extends V>) m;\r\n        if (em.keyType != keyType) {\r\n            if (em.isEmpty())\r\n                return;\r\n            throw new ClassCastException(em.keyType + \" != \" + keyType);\r\n        }\r\n        for (int i = 0; i < keyUniverse.length; i++) {\r\n            Object emValue = em.vals[i];\r\n            if (emValue != null) {\r\n                if (vals[i] == null)\r\n                    size++;\r\n                vals[i] = emValue;\r\n            }\r\n        }\r\n    } else {\r\n        super.putAll(m);\r\n    }\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.HessianOutput.writeListBegin",
	"Comment": "writes the list header to the stream.list writers will callwritelistbegin followed by the list contents and thencall writelistend.t b16 b8 typel b32 b24 b16 b8",
	"Method": "boolean writeListBegin(int length,String type){\r\n    os.write('V');\r\n    if (type != null) {\r\n        os.write('t');\r\n        printLenString(type);\r\n    }\r\n    if (length >= 0) {\r\n        os.write('l');\r\n        os.write(length >> 24);\r\n        os.write(length >> 16);\r\n        os.write(length >> 8);\r\n        os.write(length);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "java.awt.image.ColorModel.createCompatibleSampleModel",
	"Comment": "creates a samplemodel with the specified width andheight that has a data layout compatible with thiscolormodel.since colormodel is an abstract class,any instance is an instance of a subclass.subclasses mustoverride this method since the implementation in this abstractclass throws an unsupportedoperationexception.",
	"Method": "SampleModel createCompatibleSampleModel(int w,int h){\r\n    throw new UnsupportedOperationException(\"This method is not supported by this color model\");\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.toolwindow.CheckStyleToolWindowPanel.setScrollToSource",
	"Comment": "should we scroll to the selected error in the editor automatically?",
	"Method": "void setScrollToSource(boolean scrollToSource){\r\n    this.scrollToSource = scrollToSource;\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.getCurrentFixedDate",
	"Comment": "returns the fixed date value of this object. the time value andcalendar fields must be in synch.",
	"Method": "long getCurrentFixedDate(){\r\n    return (calsys == gcal) ? cachedFixedDate : calsys.getFixedDate(cdate);\r\n}"
}, {
	"Path": "java.text.DateFormatSymbols.getInstanceRef",
	"Comment": "returns a dateformatsymbols provided by a provider or found inthe cache. note that this method returns a cached instance,not its clone. therefore, the instance should never be given toan application.",
	"Method": "DateFormatSymbols getInstanceRef(Locale locale){\r\n    DateFormatSymbols dfs = getProviderInstance(locale);\r\n    if (dfs != null) {\r\n        return dfs;\r\n    }\r\n    throw new RuntimeException(\"DateFormatSymbols instance creation failed.\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.ToIndexFileConverter.main",
	"Comment": "parse stub files and write out equivalent jaifs. note that the results do not includeannotation definitions, for which stubfiles do not generally provide complete information.",
	"Method": "void main(String[] args){\r\n    if (args.length < 1) {\r\n        System.err.println(\"usage: java ToIndexFileConverter myfile.jaif [stubfile...]\");\r\n        System.err.println(\"(myfile.jaif contains needed annotation definitions)\");\r\n        System.exit(1);\r\n    }\r\n    AScene scene = new AScene();\r\n    try {\r\n        IndexFileParser.parseFile(args[0], scene);\r\n        if (args.length == 1) {\r\n            convert(scene, System.in, System.out);\r\n            return;\r\n        }\r\n        for (int i = 1; i < args.length; i++) {\r\n            String f0 = args[i];\r\n            String f1 = (f0.endsWith(\".astub\") ? f0.substring(0, f0.length() - 6) : f0) + \".jaif\";\r\n            try (InputStream in = new FileInputStream(f0);\r\n                OutputStream out = new FileOutputStream(f1)) {\r\n                convert(new AScene(scene), in, out);\r\n            }\r\n        }\r\n    } catch (Throwable e) {\r\n        e.printStackTrace();\r\n        System.exit(1);\r\n    }\r\n}"
}, {
	"Path": "java.util.ArrayList.ensureCapacity",
	"Comment": "increases the capacity of this arraylist instance, ifnecessary, to ensure that it can hold at least the number of elementsspecified by the minimum capacity argument.",
	"Method": "void ensureCapacity(int minCapacity){\r\n    if (minCapacity > 0)\r\n        ensureCapacityInternal(minCapacity);\r\n}"
}, {
	"Path": "javax.net.ssl.SSLContext.getInstance",
	"Comment": "returns a sslcontext object that implements thespecified secure socket protocol. a new sslcontext object encapsulating thesslcontextspi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "SSLContext getInstance(String protocol,SSLContext getInstance,String protocol,String provider,SSLContext getInstance,String protocol,Provider provider){\r\n    GetInstance.Instance instance = GetInstance.getInstance(\"SSLContext\", SSLContextSpi.class, protocol, provider);\r\n    return new SSLContext((SSLContextSpi) instance.impl, instance.provider, protocol);\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.util.HessianFreeList.freeCareful",
	"Comment": "frees the object.if the free list is full, the object will be garbagecollected.",
	"Method": "void freeCareful(T obj){\r\n    if (checkDuplicate(obj)) {\r\n        throw new IllegalStateException(\"tried to free object twice: \" + obj);\r\n    }\r\n    free(obj);\r\n}"
}, {
	"Path": "java.util.zip.GZIPOutputStream.finish",
	"Comment": "finishes writing compressed data to the output stream without closingthe underlying stream. use this method when applying multiple filtersin succession to the same output stream.",
	"Method": "void finish(){\r\n    if (!def.finished()) {\r\n        def.finish();\r\n        while (!def.finished()) {\r\n            int len = def.deflate(buf, 0, buf.length);\r\n            if (def.finished() && len <= buf.length - TRAILER_SIZE) {\r\n                writeTrailer(buf, len);\r\n                len = len + TRAILER_SIZE;\r\n                out.write(buf, 0, len);\r\n                return;\r\n            }\r\n            if (len > 0)\r\n                out.write(buf, 0, len);\r\n        }\r\n        byte[] trailer = new byte[TRAILER_SIZE];\r\n        writeTrailer(trailer, 0);\r\n        out.write(trailer);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.defaults.QualifierDefaults.hasDefaultsForCheckedCode",
	"Comment": "check that a default with typeuselocation otherwise or all is specified.",
	"Method": "boolean hasDefaultsForCheckedCode(){\r\n    for (Default def : checkedCodeDefaults) {\r\n        if (def.location == TypeUseLocation.OTHERWISE || def.location == TypeUseLocation.ALL) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.beans.PropertyDescriptor.getReadMethod",
	"Comment": "gets the method that should be used to read the property value.",
	"Method": "Method getReadMethod(){\r\n    Method readMethod = this.readMethodRef.get();\r\n    if (readMethod == null) {\r\n        Class<?> cls = getClass0();\r\n        if (cls == null || (readMethodName == null && !this.readMethodRef.isSet())) {\r\n            return null;\r\n        }\r\n        String nextMethodName = Introspector.GET_PREFIX + getBaseName();\r\n        if (readMethodName == null) {\r\n            Class<?> type = getPropertyType0();\r\n            if (type == boolean.class || type == null) {\r\n                readMethodName = Introspector.IS_PREFIX + getBaseName();\r\n            } else {\r\n                readMethodName = nextMethodName;\r\n            }\r\n        }\r\n        readMethod = Introspector.findMethod(cls, readMethodName, 0);\r\n        if ((readMethod == null) && !readMethodName.equals(nextMethodName)) {\r\n            readMethodName = nextMethodName;\r\n            readMethod = Introspector.findMethod(cls, readMethodName, 0);\r\n        }\r\n        try {\r\n            setReadMethod(readMethod);\r\n        } catch (IntrospectionException ex) {\r\n        }\r\n    }\r\n    return readMethod;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotationClassLoader.loadAnnotationClass",
	"Comment": "loads the class indicated by the fullyqualifiedclassname, and checks to see if it is anannotation that is supported by a checker.",
	"Method": "Class<? extends Annotation> loadAnnotationClass(String fullyQualifiedClassName,boolean issueError){\r\n    if (classLoader == null) {\r\n        throw new UserError(checker.getClass().getSimpleName() + \": no classloaders are available for use to load annotation class \" + fullyQualifiedClassName + \".\");\r\n    }\r\n    Class<?> cls = null;\r\n    try {\r\n        cls = Class.forName(fullyQualifiedClassName, true, classLoader);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new UserError(checker.getClass().getSimpleName() + \": could not load class for annotation: \" + fullyQualifiedClassName + \". Ensure that it is a type annotation\" + \" and your classpath is correct.\");\r\n    }\r\n    if (!cls.isAnnotation()) {\r\n        if (issueError) {\r\n            throw new UserError(checker.getClass().getSimpleName() + \": the loaded class: \" + cls.getCanonicalName() + \" is not a type annotation.\");\r\n        }\r\n        return null;\r\n    }\r\n    Class<? extends Annotation> annoClass = cls.asSubclass(Annotation.class);\r\n    if (hasWellDefinedTargetMetaAnnotation(annoClass)) {\r\n        return isSupportedAnnotationClass(annoClass) ? annoClass : null;\r\n    } else if (issueError) {\r\n        throw new UserError(checker.getClass().getSimpleName() + \": the loaded annotation: \" + annoClass.getCanonicalName() + \" is not a type annotation.\" + \" Check its @Target meta-annotation.\");\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "java.util.zip.ZipFile.releaseInflater",
	"Comment": "releases the specified inflater to the list of available inflaters.",
	"Method": "void releaseInflater(Inflater inf){\r\n    if (false == inf.ended()) {\r\n        inf.reset();\r\n        synchronized (inflaterCache) {\r\n            inflaterCache.add(inf);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.lang.Class.isEnum",
	"Comment": "returns true if and only if this class was declared as an enum in thesource code.",
	"Method": "boolean isEnum(){\r\n    return (this.getModifiers() & ENUM) != 0 && this.getSuperclass() == java.lang.Enum.class;\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.checks.JavadocPackageCheck.configure",
	"Comment": "retrieve the allowlegacy flag for handling javadoc package info from a checkstyle configuration.",
	"Method": "void configure(CheckstyleInternalObject config){\r\n    final String stringValue = parsePackageInfoLegacy(config);\r\n    usingLegacyPackage = null != stringValue && Boolean.parseBoolean(stringValue);\r\n}"
}, {
	"Path": "java.lang.Long.remainderUnsigned",
	"Comment": "returns the unsigned remainder from dividing the first argumentby the second where each argument and the result is interpretedas an unsigned value.",
	"Method": "long remainderUnsigned(long dividend,long divisor){\r\n    if (dividend > 0 && divisor > 0) {\r\n        return dividend % divisor;\r\n    } else {\r\n        if (compareUnsigned(dividend, divisor) < 0)\r\n            return dividend;\r\n        else\r\n            return toUnsignedBigInteger(dividend).remainder(toUnsignedBigInteger(divisor)).longValue();\r\n    }\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.available",
	"Comment": "returns the number of bytes that can be read without blocking.",
	"Method": "int available(int available,int available){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.DefaultAnnotationFormatter.formatAnnotationString",
	"Comment": "creates a string of each annotation in annos separated by a single space character andterminated by a space character, obeying the printinvisible parameter.",
	"Method": "String formatAnnotationString(Collection<? extends AnnotationMirror> annos,boolean printInvisible){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (AnnotationMirror obj : annos) {\r\n        if (obj == null) {\r\n            throw new BugInCF(\"AnnotatedTypeMirror.formatAnnotationString: found null AnnotationMirror\");\r\n        }\r\n        if (isInvisibleQualified(obj) && !printInvisible) {\r\n            continue;\r\n        }\r\n        formatAnnotationMirror(obj, sb);\r\n        sb.append(\" \");\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "java.util.WeakHashMap.getEntry",
	"Comment": "returns the entry associated with the specified key in this map.returns null if the map contains no mapping for this key.",
	"Method": "Entry<K, V> getEntry(Object key){\r\n    Object k = maskNull(key);\r\n    int h = hash(k);\r\n    Entry<K, V>[] tab = getTable();\r\n    int index = indexFor(h, tab.length);\r\n    Entry<K, V> e = tab[index];\r\n    while (e != null && !(e.hash == h && eq(k, e.get()))) e = e.next;\r\n    return e;\r\n}"
}, {
	"Path": "java.text.MessageFormat.toPattern",
	"Comment": "returns a pattern representing the current state of the message format.the string is constructed from internal information and thereforedoes not necessarily equal the previously applied pattern.",
	"Method": "String toPattern(){\r\n    int lastOffset = 0;\r\n    StringBuilder result = new StringBuilder();\r\n    for (int i = 0; i <= maxOffset; ++i) {\r\n        copyAndFixQuotes(pattern, lastOffset, offsets[i], result);\r\n        lastOffset = offsets[i];\r\n        result.append('{').append(argumentNumbers[i]);\r\n        Format fmt = formats[i];\r\n        if (fmt == null) {\r\n        } else if (fmt instanceof NumberFormat) {\r\n            if (fmt.equals(NumberFormat.getInstance(locale))) {\r\n                result.append(\",number\");\r\n            } else if (fmt.equals(NumberFormat.getCurrencyInstance(locale))) {\r\n                result.append(\",number,currency\");\r\n            } else if (fmt.equals(NumberFormat.getPercentInstance(locale))) {\r\n                result.append(\",number,percent\");\r\n            } else if (fmt.equals(NumberFormat.getIntegerInstance(locale))) {\r\n                result.append(\",number,integer\");\r\n            } else {\r\n                if (fmt instanceof DecimalFormat) {\r\n                    result.append(\",number,\").append(((DecimalFormat) fmt).toPattern());\r\n                } else if (fmt instanceof ChoiceFormat) {\r\n                    result.append(\",choice,\").append(((ChoiceFormat) fmt).toPattern());\r\n                } else {\r\n                }\r\n            }\r\n        } else if (fmt instanceof DateFormat) {\r\n            int index;\r\n            for (index = MODIFIER_DEFAULT; index < DATE_TIME_MODIFIERS.length; index++) {\r\n                DateFormat df = DateFormat.getDateInstance(DATE_TIME_MODIFIERS[index], locale);\r\n                if (fmt.equals(df)) {\r\n                    result.append(\",date\");\r\n                    break;\r\n                }\r\n                df = DateFormat.getTimeInstance(DATE_TIME_MODIFIERS[index], locale);\r\n                if (fmt.equals(df)) {\r\n                    result.append(\",time\");\r\n                    break;\r\n                }\r\n            }\r\n            if (index >= DATE_TIME_MODIFIERS.length) {\r\n                if (fmt instanceof SimpleDateFormat) {\r\n                    result.append(\",date,\").append(((SimpleDateFormat) fmt).toPattern());\r\n                } else {\r\n                }\r\n            } else if (index != MODIFIER_DEFAULT) {\r\n                result.append(',').append(DATE_TIME_MODIFIER_KEYWORDS[index]);\r\n            }\r\n        } else {\r\n        }\r\n        result.append('}');\r\n    }\r\n    copyAndFixQuotes(pattern, lastOffset, pattern.length(), result);\r\n    return result.toString();\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.createQualifierHierarchy",
	"Comment": "factory method to easily change what qualifierhierarchy is created. needs to be public onlybecause the graphfactory must be able to call this method. no external use of this method isnecessary.",
	"Method": "QualifierHierarchy createQualifierHierarchy(MultiGraphFactory factory,QualifierHierarchy createQualifierHierarchy,QualifierHierarchy createQualifierHierarchy,Elements elements,Set<Class<? extends Annotation>> supportedTypeQualifiers,MultiGraphFactory factory){\r\n    for (Class<? extends Annotation> typeQualifier : supportedTypeQualifiers) {\r\n        AnnotationMirror typeQualifierAnno = AnnotationBuilder.fromClass(elements, typeQualifier);\r\n        if (typeQualifierAnno == null) {\r\n            throw new BugInCF(\"Cannot load annotation \" + typeQualifier);\r\n        }\r\n        factory.addQualifier(typeQualifierAnno);\r\n        if (typeQualifier.getAnnotation(PolymorphicQualifier.class) != null) {\r\n            if (typeQualifier.getAnnotation(SubtypeOf.class) != null) {\r\n                throw new BugInCF(\"AnnotatedTypeFactory: \" + typeQualifier + \" is polymorphic and specifies super qualifiers. \" + \"Remove the @org.checkerframework.framework.qual.SubtypeOf or @org.checkerframework.framework.qual.PolymorphicQualifier annotation from it.\");\r\n            }\r\n            continue;\r\n        }\r\n        if (typeQualifier.getAnnotation(SubtypeOf.class) == null) {\r\n            throw new BugInCF(\"AnnotatedTypeFactory: \" + typeQualifier + \" does not specify its super qualifiers. \" + \"Add an @org.checkerframework.framework.qual.SubtypeOf annotation to it.\");\r\n        }\r\n        Class<? extends Annotation>[] superQualifiers = typeQualifier.getAnnotation(SubtypeOf.class).value();\r\n        for (Class<? extends Annotation> superQualifier : superQualifiers) {\r\n            if (!supportedTypeQualifiers.contains(superQualifier)) {\r\n                continue;\r\n            }\r\n            AnnotationMirror superAnno = AnnotationBuilder.fromClass(elements, superQualifier);\r\n            factory.addSubtype(typeQualifierAnno, superAnno);\r\n        }\r\n    }\r\n    QualifierHierarchy hierarchy = factory.build();\r\n    if (!hierarchy.isValid()) {\r\n        throw new BugInCF(\"AnnotatedTypeFactory: invalid qualifier hierarchy: \" + hierarchy.getClass() + \" \" + hierarchy);\r\n    }\r\n    return hierarchy;\r\n}"
}, {
	"Path": "java.util.logging.Logger.removeHandler",
	"Comment": "remove a log handler.returns silently if the given handler is not found or is null",
	"Method": "void removeHandler(Handler handler){\r\n    checkAccess();\r\n    if (handler == null) {\r\n        return;\r\n    }\r\n    handlers.remove(handler);\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TreeUtils.isClassTree",
	"Comment": "is the given tree kind a class, i.e. a class, enum, interface, or annotation type.",
	"Method": "boolean isClassTree(Tree tree){\r\n    return classTreeKinds().contains(tree.getKind());\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.EqualityAtmComparer.arePrimeAnnosEqual",
	"Comment": "return true if type1 and type2 have equivalent sets of annotations.",
	"Method": "boolean arePrimeAnnosEqual(AnnotatedTypeMirror type1,AnnotatedTypeMirror type2){\r\n    return AnnotationUtils.areSame(type1.getAnnotations(), type2.getAnnotations());\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.writeStreamHeader",
	"Comment": "the writestreamheader method is provided so subclasses can append orprepend their own header to the stream.it writes the magic number andversion to the stream.",
	"Method": "void writeStreamHeader(){\r\n    bout.writeShort(STREAM_MAGIC);\r\n    bout.writeShort(STREAM_VERSION);\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.AuthorDTOService.save",
	"Comment": "save the passed dto as a new entity or update the corresponding entity if any.",
	"Method": "AuthorDTO save(AuthorDTO dto){\r\n    if (dto == null) {\r\n        return null;\r\n    }\r\n    final Author author;\r\n    if (dto.isIdSet()) {\r\n        Author authorTmp = authorRepository.findOne(dto.id);\r\n        if (authorTmp != null) {\r\n            author = authorTmp;\r\n        } else {\r\n            author = new Author();\r\n            author.setId(dto.id);\r\n        }\r\n    } else {\r\n        author = new Author();\r\n    }\r\n    author.setCivility(dto.civility);\r\n    author.setLastName(dto.lastName);\r\n    author.setFirstName(dto.firstName);\r\n    author.setEmail(dto.email);\r\n    author.setBirthDate(dto.birthDate);\r\n    author.setBirthDateTime(dto.birthDateTime);\r\n    if (dto.favoriteAuthor == null) {\r\n        author.setFavoriteAuthor(null);\r\n    } else {\r\n        Author favoriteAuthor = author.getFavoriteAuthor();\r\n        if (favoriteAuthor == null || (favoriteAuthor.getId().compareTo(dto.favoriteAuthor.id) != 0)) {\r\n            author.setFavoriteAuthor(authorRepository.findOne(dto.favoriteAuthor.id));\r\n        }\r\n    }\r\n    return toDTO(authorRepository.save(author));\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.SerializerFactory.setSendCollectionType",
	"Comment": "set true if the collection serializer should send the java type.",
	"Method": "void setSendCollectionType(boolean isSendType){\r\n    if (_collectionSerializer == null) {\r\n        _collectionSerializer = new CollectionSerializer();\r\n    }\r\n    _collectionSerializer.setSendJavaType(isSendType);\r\n    if (_mapSerializer == null) {\r\n        _mapSerializer = new MapSerializer();\r\n    }\r\n    _mapSerializer.setSendJavaType(isSendType);\r\n}"
}, {
	"Path": "java.io.DataInputStream.skipBytes",
	"Comment": "see the general contract of the skipbytesmethod of datainput.bytes for this operation are read from the containedinput stream.",
	"Method": "int skipBytes(int n){\r\n    int total = 0;\r\n    int cur = 0;\r\n    while ((total < n) && ((cur = (int) in.skip(n - total)) > 0)) {\r\n        total += cur;\r\n    }\r\n    return total;\r\n}"
}, {
	"Path": "java.util.Calendar.isSet",
	"Comment": "determines if the given calendar field has a value set,including cases that the value has been set by internal fieldscalculations triggered by a get method call.",
	"Method": "boolean isSet(int field){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.solver.SupertypesSolver.groundMissingHierarchies",
	"Comment": "for each type in typetohierarchies, if that type does not have a corresponding annotation fora given hierarchy replace it with the corresponding value in lowerboundannos.",
	"Method": "AnnotatedTypeMirror groundMissingHierarchies(Entry<AnnotatedTypeMirror, AnnotationMirrorSet> typeToHierarchies,AnnotationMirrorMap<AnnotationMirror> lowerBoundAnnos){\r\n    final AnnotationMirrorSet presentHierarchies = typeToHierarchies.getValue();\r\n    final AnnotationMirrorSet missingAnnos = new AnnotationMirrorSet();\r\n    for (AnnotationMirror top : lowerBoundAnnos.keySet()) {\r\n        if (!presentHierarchies.contains(top)) {\r\n            missingAnnos.add(lowerBoundAnnos.get(top));\r\n        }\r\n    }\r\n    if (!missingAnnos.isEmpty()) {\r\n        AnnotatedTypeMirror copy = typeToHierarchies.getKey().deepCopy();\r\n        copy.replaceAnnotations(missingAnnos);\r\n        return copy;\r\n    }\r\n    return typeToHierarchies.getKey();\r\n}"
}, {
	"Path": "java.util.zip.GZIPInputStream.readHeader",
	"Comment": "reads gzip member header and returns the total byte numberof this member header.",
	"Method": "int readHeader(InputStream this_in){\r\n    CheckedInputStream in = new CheckedInputStream(this_in, crc);\r\n    crc.reset();\r\n    if (readUShort(in) != GZIP_MAGIC) {\r\n        throw new ZipException(\"Not in GZIP format\");\r\n    }\r\n    if (readUByte(in) != 8) {\r\n        throw new ZipException(\"Unsupported compression method\");\r\n    }\r\n    int flg = readUByte(in);\r\n    skipBytes(in, 6);\r\n    int n = 2 + 2 + 6;\r\n    if ((flg & FEXTRA) == FEXTRA) {\r\n        int m = readUShort(in);\r\n        skipBytes(in, m);\r\n        n += m + 2;\r\n    }\r\n    if ((flg & FNAME) == FNAME) {\r\n        do {\r\n            n++;\r\n        } while (readUByte(in) != 0);\r\n    }\r\n    if ((flg & FCOMMENT) == FCOMMENT) {\r\n        do {\r\n            n++;\r\n        } while (readUByte(in) != 0);\r\n    }\r\n    if ((flg & FHCRC) == FHCRC) {\r\n        int v = (int) crc.getValue() & 0xffff;\r\n        if (readUShort(in) != v) {\r\n            throw new ZipException(\"Corrupt GZIP header\");\r\n        }\r\n        n += 2;\r\n    }\r\n    crc.reset();\r\n    return n;\r\n}"
}, {
	"Path": "java.lang.ClassLoader.getPackage",
	"Comment": "returns a package that has been defined by this class loaderor any of its ancestors.",
	"Method": "Package getPackage(String name){\r\n    Package pkg;\r\n    synchronized (packages) {\r\n        pkg = packages.get(name);\r\n    }\r\n    if (pkg == null) {\r\n        if (parent != null) {\r\n            pkg = parent.getPackage(name);\r\n        } else {\r\n            pkg = Package.getSystemPackage(name);\r\n        }\r\n        if (pkg != null) {\r\n            synchronized (packages) {\r\n                Package pkg2 = packages.get(name);\r\n                if (pkg2 == null) {\r\n                    packages.put(name, pkg);\r\n                } else {\r\n                    pkg = pkg2;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return pkg;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.element.TypeParamElementAnnotationApplier.applyLowerBounds",
	"Comment": "in the event of multiple annotations on an annotatednulltype lower bound we want to preservethe multiple annotations so that an type.invalid exception is raised later.",
	"Method": "void applyLowerBounds(List<? extends AnnotationMirror> annos){\r\n    if (!annos.isEmpty()) {\r\n        final AnnotatedTypeMirror lowerBound = typeParam.getLowerBound();\r\n        for (AnnotationMirror anno : annos) {\r\n            lowerBound.addAnnotation(anno);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.trees.TreeParser.parseTree",
	"Comment": "parses the snippet in the string as an internal javac ast expression node.",
	"Method": "ExpressionTree parseTree(String s){\r\n    tokenizer = new StringTokenizer(s, DELIMS, true);\r\n    token = tokenizer.nextToken();\r\n    try {\r\n        return parseExpression();\r\n    } catch (Exception e) {\r\n        throw new ParseError(e);\r\n    } finally {\r\n        tokenizer = null;\r\n        token = null;\r\n    }\r\n}"
}, {
	"Path": "java.util.regex.Pattern.pattern",
	"Comment": "returns the regular expression from which this pattern was compiled.",
	"Method": "String pattern(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.DeclarationsIntoElements.storeMethod",
	"Comment": "add inherited declaration annotations from overridden methods into the corresponding elementsso they are written into bytecode.",
	"Method": "void storeMethod(ProcessingEnvironment env,AnnotatedTypeFactory atypeFactory,MethodTree meth){\r\n    ExecutableElement element = TreeUtils.elementFromDeclaration(meth);\r\n    MethodSymbol sym = (MethodSymbol) element;\r\n    java.util.List<? extends AnnotationMirror> elementAnnos = element.getAnnotationMirrors();\r\n    Set<AnnotationMirror> declAnnotations = atypeFactory.getDeclAnnotations(sym);\r\n    List<Compound> tcs = List.nil();\r\n    for (AnnotationMirror anno : declAnnotations) {\r\n        if (!AnnotationUtils.containsSame(elementAnnos, anno)) {\r\n            tcs = tcs.append(TypeAnnotationUtils.createCompoundFromAnnotationMirror(anno, env));\r\n        }\r\n    }\r\n    sym.appendAttributes(tcs);\r\n}"
}, {
	"Path": "org.checkerframework.checker.units.UnitsRelationsDefault.havePairOfUnits",
	"Comment": "checks to see if lht has the unit ul and if rht has the unit ur all at the same time.",
	"Method": "boolean havePairOfUnits(AnnotatedTypeMirror lht,AnnotationMirror ul,AnnotatedTypeMirror rht,AnnotationMirror ur){\r\n    return UnitsRelationsTools.hasSpecificUnit(lht, ul) && UnitsRelationsTools.hasSpecificUnit(rht, ur);\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.ui.LocationDialogue.getConfigurationLocation",
	"Comment": "get the configuration location entered in the dialogue, or null if no valid location was entered.",
	"Method": "ConfigurationLocation getConfigurationLocation(){\r\n    return configurationLocation;\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TreeUtils.hasExplicitConstructor",
	"Comment": "determine whether the given class contains an explicit constructor.",
	"Method": "boolean hasExplicitConstructor(ClassTree node){\r\n    TypeElement elem = TreeUtils.elementFromDeclaration(node);\r\n    for (ExecutableElement ee : ElementFilter.constructorsIn(elem.getEnclosedElements())) {\r\n        MethodSymbol ms = (MethodSymbol) ee;\r\n        long mod = ms.flags();\r\n        if ((mod & Flags.SYNTHETIC) == 0) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.cfg4j.source.system.EnvironmentVariablesConfigurationSource.convertToPropertiesKey",
	"Comment": "convert the environment variable name to the expected properties key formatting",
	"Method": "String convertToPropertiesKey(String environmentVariableKey,String environmentContext){\r\n    return environmentVariableKey.substring(environmentContext.length()).replace(ENV_DELIMITER, PROPERTIES_DELIMITER);\r\n}"
}, {
	"Path": "java.text.BreakIterator.getCharacterInstance",
	"Comment": "returns a new breakiterator instancefor character breaksfor the given locale.",
	"Method": "BreakIterator getCharacterInstance(BreakIterator getCharacterInstance,Locale locale){\r\n    return getBreakInstance(locale, CHARACTER_INDEX);\r\n}"
}, {
	"Path": "org.checkerframework.common.value.util.Range.unaryMinus",
	"Comment": "returns the range of a variable that falls within this range after applying the unary minusoperation.",
	"Method": "Range unaryMinus(){\r\n    if (this.isNothing()) {\r\n        return NOTHING;\r\n    }\r\n    if (from == Long.MIN_VALUE && from != to) {\r\n        return EVERYTHING;\r\n    }\r\n    return new Range(-to, -from);\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueTransfer.calculateRangeUnaryOp",
	"Comment": "calculate the result range after a unary operation of a numerical type node.",
	"Method": "Range calculateRangeUnaryOp(Node operand,NumericalUnaryOps op,TransferInput<CFValue, CFStore> p){\r\n    if (TypesUtils.isIntegral(operand.getType())) {\r\n        Range range = getIntRange(operand, p);\r\n        Range resultRange;\r\n        switch(op) {\r\n            case PLUS:\r\n                resultRange = range.unaryPlus();\r\n                break;\r\n            case MINUS:\r\n                resultRange = range.unaryMinus();\r\n                break;\r\n            case BITWISE_COMPLEMENT:\r\n                resultRange = range.bitwiseComplement();\r\n                break;\r\n            default:\r\n                throw new BugInCF(\"ValueTransfer: unsupported operation: \" + op);\r\n        }\r\n        return operand.getType().getKind() == TypeKind.LONG ? resultRange : resultRange.intRange();\r\n    } else {\r\n        return Range.EVERYTHING;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.GenericAnnotatedTypeFactory.getReceiverFromJavaExpressionString",
	"Comment": "produces the receiver associated with expression on currentpath.",
	"Method": "Receiver getReceiverFromJavaExpressionString(String expression,TreePath currentPath){\r\n    TypeMirror enclosingClass = TreeUtils.typeOf(TreeUtils.enclosingClass(currentPath));\r\n    Receiver r = FlowExpressions.internalReprOfPseudoReceiver(currentPath, enclosingClass);\r\n    FlowExpressionParseUtil.FlowExpressionContext context = new FlowExpressionParseUtil.FlowExpressionContext(r, FlowExpressions.getParametersOfEnclosingMethod(this, currentPath), this.getContext());\r\n    return FlowExpressionParseUtil.parse(expression, context, currentPath, true);\r\n}"
}, {
	"Path": "java.io.BufferedInputStream.read1",
	"Comment": "read characters into a portion of an array, reading from the underlyingstream at most once if necessary.",
	"Method": "int read1(byte[] b,int off,int len){\r\n    int avail = count - pos;\r\n    if (avail <= 0) {\r\n        if (len >= getBufIfOpen().length && markpos < 0) {\r\n            return getInIfOpen().read(b, off, len);\r\n        }\r\n        fill();\r\n        avail = count - pos;\r\n        if (avail <= 0)\r\n            return -1;\r\n    }\r\n    int cnt = (avail < len) ? avail : len;\r\n    System.arraycopy(getBufIfOpen(), pos, b, off, cnt);\r\n    pos += cnt;\r\n    return cnt;\r\n}"
}, {
	"Path": "org.checkerframework.checker.signedness.SignednessUtil.toUnsignedInt",
	"Comment": "returns an unsigned int representing the same value as an unsigned char.",
	"Method": "int toUnsignedInt(short s,int toUnsignedInt,byte b,int toUnsignedInt,char c){\r\n    return ((int) c) & 0xff;\r\n}"
}, {
	"Path": "com.mycompany.myapp.domain.UseCase3.isIdSet",
	"Comment": "tells whether or not this instance has a non empty composite primary key set.",
	"Method": "boolean isIdSet(){\r\n    return getId() != null && getId().areFieldsSet();\r\n}"
}, {
	"Path": "org.checkerframework.checker.signedness.SignednessUtil.byteFromDouble",
	"Comment": "returns an unsigned byte representing the same value as the double.",
	"Method": "byte byteFromDouble(double d){\r\n    assert d >= 0;\r\n    return (byte) d;\r\n}"
}, {
	"Path": "java.io.BufferedReader.read1",
	"Comment": "reads characters into a portion of an array, reading from the underlyingstream if necessary.",
	"Method": "int read1(char[] cbuf,int off,int len){\r\n    if (nextChar >= nChars) {\r\n        if (len >= cb.length && markedChar <= UNMARKED && !skipLF) {\r\n            return in.read(cbuf, off, len);\r\n        }\r\n        fill();\r\n    }\r\n    if (nextChar >= nChars)\r\n        return -1;\r\n    if (skipLF) {\r\n        skipLF = false;\r\n        if (cb[nextChar] == '\\n') {\r\n            nextChar++;\r\n            if (nextChar >= nChars)\r\n                fill();\r\n            if (nextChar >= nChars)\r\n                return -1;\r\n        }\r\n    }\r\n    int n = Math.min(len, nChars - nextChar);\r\n    System.arraycopy(cb, nextChar, cbuf, off, n);\r\n    nextChar += n;\r\n    return n;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeMirror.createType",
	"Comment": "creates the appropriate annotatedtypemirror specific wrapper for the provided type.",
	"Method": "AnnotatedTypeMirror createType(TypeMirror type,AnnotatedTypeFactory atypeFactory,boolean isDeclaration){\r\n    if (type == null) {\r\n        throw new BugInCF(\"AnnotatedTypeMirror.createType: input type must not be null\");\r\n    }\r\n    AnnotatedTypeMirror result;\r\n    switch(type.getKind()) {\r\n        case ARRAY:\r\n            result = new AnnotatedArrayType((ArrayType) type, atypeFactory);\r\n            break;\r\n        case DECLARED:\r\n            result = new AnnotatedDeclaredType((DeclaredType) type, atypeFactory, isDeclaration);\r\n            break;\r\n        case ERROR:\r\n            throw new BugInCF(\"AnnotatedTypeMirror.createType: input should type-check already. Found error type: \" + type);\r\n        case EXECUTABLE:\r\n            result = new AnnotatedExecutableType((ExecutableType) type, atypeFactory);\r\n            break;\r\n        case VOID:\r\n        case PACKAGE:\r\n        case NONE:\r\n            result = new AnnotatedNoType((NoType) type, atypeFactory);\r\n            break;\r\n        case NULL:\r\n            result = new AnnotatedNullType((NullType) type, atypeFactory);\r\n            break;\r\n        case TYPEVAR:\r\n            result = new AnnotatedTypeVariable((TypeVariable) type, atypeFactory, isDeclaration);\r\n            break;\r\n        case WILDCARD:\r\n            result = new AnnotatedWildcardType((WildcardType) type, atypeFactory);\r\n            break;\r\n        case INTERSECTION:\r\n            result = new AnnotatedIntersectionType((IntersectionType) type, atypeFactory);\r\n            break;\r\n        case UNION:\r\n            result = new AnnotatedUnionType((UnionType) type, atypeFactory);\r\n            break;\r\n        default:\r\n            if (type.getKind().isPrimitive()) {\r\n                result = new AnnotatedPrimitiveType((PrimitiveType) type, atypeFactory);\r\n                break;\r\n            }\r\n            throw new BugInCF(\"AnnotatedTypeMirror.createType: unidentified type \" + type + \" (\" + type.getKind() + \")\");\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.dependenttypes.DependentTypesHelper.createDependentTypesTreeAnnotator",
	"Comment": "creates a treeannotator that standardizes dependent type annotations.",
	"Method": "TreeAnnotator createDependentTypesTreeAnnotator(AnnotatedTypeFactory factory){\r\n    return new DependentTypesTreeAnnotator(factory, this);\r\n}"
}, {
	"Path": "org.checkerframework.common.basetype.BaseTypeVisitor.checkMethodReferenceAsOverride",
	"Comment": "check that a method reference is allowed. using the overridechecker class.",
	"Method": "boolean checkMethodReferenceAsOverride(MemberReferenceTree memberReferenceTree,Void p){\r\n    Pair<AnnotatedDeclaredType, AnnotatedExecutableType> result = atypeFactory.getFnInterfaceFromTree(memberReferenceTree);\r\n    AnnotatedDeclaredType functionalInterface = result.first;\r\n    AnnotatedExecutableType functionType = result.second;\r\n    final ExpressionTree qualifierExpression = memberReferenceTree.getQualifierExpression();\r\n    final ReferenceKind memRefKind = ((JCMemberReference) memberReferenceTree).kind;\r\n    AnnotatedTypeMirror enclosingType;\r\n    if (memberReferenceTree.getMode() == ReferenceMode.NEW || memRefKind == ReferenceKind.UNBOUND || memRefKind == ReferenceKind.STATIC) {\r\n        enclosingType = atypeFactory.getAnnotatedTypeFromTypeTree(qualifierExpression);\r\n    } else {\r\n        enclosingType = atypeFactory.getAnnotatedType(qualifierExpression);\r\n    }\r\n    ExecutableElement compileTimeDeclaration = (ExecutableElement) TreeUtils.elementFromTree(memberReferenceTree);\r\n    if (enclosingType.getKind() == TypeKind.DECLARED && ((AnnotatedDeclaredType) enclosingType).wasRaw()) {\r\n        if (memRefKind == ReferenceKind.UNBOUND) {\r\n            AnnotatedTypeMirror p1 = functionType.getParameterTypes().get(0);\r\n            TypeMirror asSuper = TypesUtils.asSuper(p1.getUnderlyingType(), enclosingType.getUnderlyingType(), atypeFactory.getProcessingEnv());\r\n            if (asSuper != null) {\r\n                enclosingType = AnnotatedTypes.asSuper(atypeFactory, p1, enclosingType);\r\n            }\r\n        }\r\n    }\r\n    AnnotatedExecutableType invocationType = atypeFactory.methodFromUse(memberReferenceTree, compileTimeDeclaration, enclosingType).methodType;\r\n    if (checkMethodReferenceInference(memberReferenceTree, invocationType, enclosingType)) {\r\n        return true;\r\n    }\r\n    if (invocationType.getTypeVariables().isEmpty() && !functionType.getTypeVariables().isEmpty()) {\r\n        functionType = functionType.getErased();\r\n    }\r\n    QualifierPolymorphism poly = atypeFactory.getQualifierPolymorphism();\r\n    poly.annotate(functionType, invocationType);\r\n    AnnotatedTypeMirror invocationReturnType;\r\n    if (compileTimeDeclaration.getKind() == ElementKind.CONSTRUCTOR) {\r\n        if (enclosingType.getKind() == TypeKind.ARRAY) {\r\n            invocationReturnType = enclosingType;\r\n        } else {\r\n            invocationReturnType = atypeFactory.getResultingTypeOfConstructorMemberReference(memberReferenceTree, invocationType);\r\n        }\r\n    } else {\r\n        invocationReturnType = invocationType.getReturnType();\r\n    }\r\n    AnnotatedTypeMirror functionTypeReturnType = functionType.getReturnType();\r\n    if (functionTypeReturnType.getKind() == TypeKind.VOID) {\r\n        functionTypeReturnType = invocationReturnType;\r\n    }\r\n    OverrideChecker overrideChecker = createOverrideChecker(memberReferenceTree, invocationType, enclosingType, invocationReturnType, functionType, functionalInterface, functionTypeReturnType);\r\n    return overrideChecker.checkOverride();\r\n}"
}, {
	"Path": "org.checkerframework.checker.signedness.SignednessUtil.intFromDouble",
	"Comment": "returns an unsigned int representing the same value as the double.",
	"Method": "int intFromDouble(double d){\r\n    assert d >= 0;\r\n    return (int) d;\r\n}"
}, {
	"Path": "java.io.PipedWriter.close",
	"Comment": "closes this piped output stream and releases any system resourcesassociated with this stream. this stream may no longer be used forwriting characters.",
	"Method": "void close(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.regex.Matcher.matches",
	"Comment": "attempts to match the entire region against the pattern. if the match succeeds then more information can be obtained via thestart, end, and group methods.",
	"Method": "boolean matches(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.MultiGraphQualifierHierarchy.addPolyRelations",
	"Comment": "we want to allow subclasses to adapt the behavior and therefore make it an instance method.",
	"Method": "void addPolyRelations(QualifierHierarchy qualHierarchy,Map<AnnotationMirror, Set<AnnotationMirror>> fullMap,Map<AnnotationMirror, AnnotationMirror> polyQualifiers,Set<AnnotationMirror> tops,Set<AnnotationMirror> bottoms){\r\n    if (polyQualifiers.isEmpty()) {\r\n        return;\r\n    }\r\n    for (Map.Entry<AnnotationMirror, AnnotationMirror> kv : polyQualifiers.entrySet()) {\r\n        AnnotationMirror declTop = kv.getKey();\r\n        AnnotationMirror polyQualifier = kv.getValue();\r\n        if (declTop == null || AnnotationUtils.areSame(declTop, polymorphicQualifier)) {\r\n            if (declTop == null || tops.size() == 1) {\r\n                AnnotationUtils.updateMappingToImmutableSet(fullMap, polyQualifier, tops);\r\n                for (AnnotationMirror bottom : bottoms) {\r\n                    AnnotationUtils.updateMappingToImmutableSet(fullMap, bottom, Collections.singleton(polyQualifier));\r\n                }\r\n                if (declTop == null) {\r\n                    for (Map.Entry<AnnotationMirror, AnnotationMirror> otherpolyKV : polyQualifiers.entrySet()) {\r\n                        AnnotationMirror otherTop = otherpolyKV.getKey();\r\n                        AnnotationMirror otherPoly = otherpolyKV.getValue();\r\n                        if (otherTop != null) {\r\n                            AnnotationUtils.updateMappingToImmutableSet(fullMap, otherPoly, Collections.singleton(polyQualifier));\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                throw new BugInCF(\"MultiGraphQualifierHierarchy.addPolyRelations: \" + \"incorrect or missing top qualifier given in polymorphic qualifier \" + polyQualifier + \"; declTop = \" + declTop + \"; possible top qualifiers: \" + tops);\r\n            }\r\n        } else {\r\n            Set<AnnotationMirror> declSupers = fullMap.get(declTop);\r\n            AnnotationMirror polyTop = null;\r\n            if (declSupers.isEmpty()) {\r\n                polyTop = declTop;\r\n            } else {\r\n                for (AnnotationMirror ds : declSupers) {\r\n                    if (AnnotationUtils.containsSameIgnoringValues(tops, ds)) {\r\n                        polyTop = ds;\r\n                    }\r\n                }\r\n            }\r\n            boolean found = (polyTop != null);\r\n            if (found) {\r\n                AnnotationUtils.updateMappingToImmutableSet(fullMap, polyQualifier, Collections.singleton(polyTop));\r\n            } else {\r\n                throw new BugInCF(\"MultiGraphQualifierHierarchy.addPolyRelations: \" + \"incorrect top qualifier given in polymorphic qualifier: \" + polyQualifier + \" could not find: \" + polyTop);\r\n            }\r\n            found = false;\r\n            AnnotationMirror bottom = null;\r\n            outer: for (AnnotationMirror btm : bottoms) {\r\n                for (AnnotationMirror btmsuper : fullMap.get(btm)) {\r\n                    if (AnnotationUtils.areSameIgnoringValues(btmsuper, polyTop)) {\r\n                        found = true;\r\n                        bottom = btm;\r\n                        break outer;\r\n                    }\r\n                }\r\n            }\r\n            if (found) {\r\n                AnnotationUtils.updateMappingToImmutableSet(fullMap, bottom, Collections.singleton(polyQualifier));\r\n            } else {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.io.FilePermission.equals",
	"Comment": "checks two filepermission objects for equality. checks that obj isa filepermission, and has the same pathname and actions as this object.",
	"Method": "boolean equals(Object obj){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.Date.setSeconds",
	"Comment": "sets the seconds of this date to the specified value.this date object is modified so that it represents apoint in time within the specified second of the minute, withthe year, month, date, hour, and minute the same as before, asinterpreted in the local time zone.",
	"Method": "void setSeconds(int seconds){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "com.alibaba.citrus.generictype.codegen.asm.Method.getReturnType",
	"Comment": "returns the return type of the method described by this object.",
	"Method": "Type getReturnType(){\r\n    return Type.getReturnType(desc);\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.constraint.AFReducingVisitor.visitNull_Declared",
	"Comment": "null types only have primary annotations. a type parameter could only appear as a componentof the parameter type and therefore has no relationship to these primary annotations",
	"Method": "Void visitNull_Declared(AnnotatedNullType argument,AnnotatedDeclaredType parameter,Set<AFConstraint> constraints){\r\n    return null;\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.IndexUtil.getValueOfAnnotationWithStringArgument",
	"Comment": "gets the value field of an annotation with a list of strings in its value field. null isreturned if the annotation has no value field.for the index checker, this will get a list of array names from an upper bound or samelenannotation. making this safe to call on any upper bound or samelen annotation.",
	"Method": "List<String> getValueOfAnnotationWithStringArgument(AnnotationMirror anno){\r\n    if (!AnnotationUtils.hasElementValue(anno, \"value\")) {\r\n        return null;\r\n    }\r\n    return AnnotationUtils.getElementValueArray(anno, \"value\", String.class, true);\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.solver.ConstraintMap.getConstraints",
	"Comment": "gets the equality, subtypes, and supertypes constraints for a particular target.",
	"Method": "TargetConstraints getConstraints(TypeVariable target){\r\n    return targetToRecords.get(target);\r\n}"
}, {
	"Path": "java.util.logging.Formatter.getTail",
	"Comment": "return the tail string for a set of formatted records.this base class returns an empty string, but this may beoverridden by subclasses.",
	"Method": "String getTail(Handler h){\r\n    return \"\";\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ReflectiveEvaluator.normalizeVararg",
	"Comment": "this method normalizes an array of arguments to a varargs method by changing the argumentsassociated with the varargs parameter into an array.",
	"Method": "Object[] normalizeVararg(Object[] arguments,int numberOfParameters){\r\n    if (arguments == null) {\r\n        arguments = new Object[] {};\r\n    }\r\n    Object[] newArgs = new Object[numberOfParameters];\r\n    Object[] varArgsArray;\r\n    int numOfVarArgs = arguments.length - numberOfParameters + 1;\r\n    if (numOfVarArgs > 0) {\r\n        System.arraycopy(arguments, 0, newArgs, 0, numberOfParameters - 1);\r\n        varArgsArray = new Object[numOfVarArgs];\r\n        System.arraycopy(arguments, numberOfParameters - 1, varArgsArray, 0, numOfVarArgs);\r\n    } else {\r\n        System.arraycopy(arguments, 0, newArgs, 0, numberOfParameters - 1);\r\n        varArgsArray = new Object[] {};\r\n    }\r\n    newArgs[numberOfParameters - 1] = varArgsArray;\r\n    return newArgs;\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.UpperBoundAnnotatedTypeFactory.getMethodIdentifier",
	"Comment": "gets a helper object that holds references to methods with special handling.",
	"Method": "IndexMethodIdentifier getMethodIdentifier(){\r\n    return imf;\r\n}"
}, {
	"Path": "java.io.PrintStream.requireNonNull",
	"Comment": "requirenonnull is explicitly declared here so as not to create an extradependency on java.util.objects.requirenonnull. printstream is loadedearly during system initialization.",
	"Method": "T requireNonNull(T obj,String message){\r\n    if (obj == null)\r\n        throw new NullPointerException(message);\r\n    return obj;\r\n}"
}, {
	"Path": "java.util.Hashtable.put",
	"Comment": "maps the specified key to the specifiedvalue in this hashtable. neither the key nor thevalue can be null. the value can be retrieved by calling the get methodwith a key that is equal to the original key.",
	"Method": "V put(K key,V value){\r\n    if (value == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    Entry<?, ?>[] tab = table;\r\n    int hash = key.hashCode();\r\n    int index = (hash & 0x7FFFFFFF) % tab.length;\r\n    @SuppressWarnings(\"unchecked\")\r\n    Entry<K, V> entry = (Entry<K, V>) tab[index];\r\n    for (; entry != null; entry = entry.next) {\r\n        if ((entry.hash == hash) && entry.key.equals(key)) {\r\n            V old = entry.value;\r\n            entry.value = value;\r\n            return old;\r\n        }\r\n    }\r\n    addEntry(hash, key, value, index);\r\n    return null;\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.OffsetEquation.copyAdd",
	"Comment": "adds or subtracts the other equation to a copy of this one.if subtraction is specified, then every term in other is subtracted.",
	"Method": "OffsetEquation copyAdd(char op,OffsetEquation other){\r\n    assert op == '-' || op == '+';\r\n    OffsetEquation copy = new OffsetEquation(this);\r\n    if (op == '+') {\r\n        copy.plus(other);\r\n    } else {\r\n        copy.minus(other);\r\n    }\r\n    return copy;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.tableSizeFor",
	"Comment": "returns a power of two table size for the given desired capacity.see hackers delight, sec 3.2",
	"Method": "int tableSizeFor(int c){\r\n    int n = c - 1;\r\n    n |= n >>> 1;\r\n    n |= n >>> 2;\r\n    n |= n >>> 4;\r\n    n |= n >>> 8;\r\n    n |= n >>> 16;\r\n    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\r\n}"
}, {
	"Path": "sun.util.resources.LocaleData.getAvailableLocales",
	"Comment": "returns a list of the installed locales. currently, this simply returnsthe list of locales for which a sun.text.resources.formatdata bundleexists. this bundle family happens to be the one with the broadestlocale coverage in the jre.",
	"Method": "Locale[] getAvailableLocales(){\r\n    return AvailableLocales.localeList.clone();\r\n}"
}, {
	"Path": "java.util.jar.Attributes.get",
	"Comment": "returns the value of the specified attribute name, or null if theattribute name was not found.",
	"Method": "Object get(Object name){\r\n    return map.get(name);\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.CheckerMain.findPathTo",
	"Comment": "find the jar file or directory containing the .class file from which cls was loaded.",
	"Method": "String findPathTo(Class<?> cls,boolean errIfFromDirectory){\r\n    if (cls == null) {\r\n        cls = CheckerMain.class;\r\n    }\r\n    String name = cls.getName();\r\n    String classFileName;\r\n    {\r\n        int idx = name.lastIndexOf('.');\r\n        classFileName = (idx == -1 ? name : name.substring(idx + 1)) + \".class\";\r\n    }\r\n    String uri = cls.getResource(classFileName).toString();\r\n    if (uri.startsWith(\"file:\")) {\r\n        if (errIfFromDirectory) {\r\n            return uri;\r\n        } else {\r\n            throw new IllegalStateException(\"This class has been loaded from a directory and not from a jar file.\");\r\n        }\r\n    }\r\n    if (!uri.startsWith(\"jar:file:\")) {\r\n        int idx = uri.indexOf(':');\r\n        String protocol = idx == -1 ? \"(unknown)\" : uri.substring(0, idx);\r\n        throw new IllegalStateException(\"This class has been loaded remotely via the \" + protocol + \" protocol. Only loading from a jar on the local file system is supported.\");\r\n    }\r\n    int idx = uri.indexOf('!');\r\n    if (idx == -1) {\r\n        throw new IllegalStateException(\"You appear to have loaded this class from a local jar file, but I can't make sense of the URL!\");\r\n    }\r\n    try {\r\n        String fileName = URLDecoder.decode(uri.substring(\"jar:file:\".length(), idx), Charset.defaultCharset().name());\r\n        return new File(fileName).getAbsolutePath();\r\n    } catch (UnsupportedEncodingException e) {\r\n        throw new BugInCF(\"Default charset doesn't exist. Your VM is borked.\");\r\n    }\r\n}"
}, {
	"Path": "java.util.Calendar.isPartiallyNormalized",
	"Comment": "returns whether the calendar fields are partially in sync with the timevalue or fully in sync but not stamp values are not normalized yet.",
	"Method": "boolean isPartiallyNormalized(){\r\n    return areFieldsSet && !areAllFieldsSet;\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.TestConfigurationBuilder.validateThenBuild",
	"Comment": "creates a testconfiguration using the settings in this builder. the settings are firstvalidated and a runtime exception is thrown if any errors are found",
	"Method": "TestConfiguration validateThenBuild(boolean requireProcessors){\r\n    List<String> errors = validate(requireProcessors);\r\n    if (errors.isEmpty()) {\r\n        return build();\r\n    }\r\n    throw new RuntimeException(\"Attempted to build invalid test configuration:\\n\" + \"Errors:\\n\" + String.join(\"\\n\", errors) + \"\\n\" + this.toString() + \"\\n\");\r\n}"
}, {
	"Path": "java.util.HashMap.put",
	"Comment": "associates the specified value with the specified key in this map.if the map previously contained a mapping for the key, the oldvalue is replaced.",
	"Method": "V put(K key,V value){\r\n    return putVal(hash(key), key, value, false, true);\r\n}"
}, {
	"Path": "java.util.HashMap.putAll",
	"Comment": "copies all of the mappings from the specified map to this map.these mappings will replace any mappings that this map had forany of the keys currently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> m){\r\n    putMapEntries(m, true);\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.IndexUtil.getMinLenFromTree",
	"Comment": "looks up the minlen of a member select tree. the tree must be an access to a sequence length.",
	"Method": "Integer getMinLenFromTree(Tree tree,ValueAnnotatedTypeFactory valueATF){\r\n    AnnotatedTypeMirror minLenType = valueATF.getAnnotatedType(tree);\r\n    Long min = valueATF.getMinimumIntegralValue(minLenType);\r\n    if (min == null) {\r\n        return null;\r\n    }\r\n    if (min < 0 || min > Integer.MAX_VALUE) {\r\n        min = 0L;\r\n    }\r\n    return min.intValue();\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.constraint.AFReducingVisitor.visitPrimitive_Primitive",
	"Comment": "primitive parameter types tell us nothing about the type parameters",
	"Method": "Void visitPrimitive_Primitive(AnnotatedPrimitiveType subtype,AnnotatedPrimitiveType supertype,Set<AFConstraint> constraints){\r\n    return null;\r\n}"
}, {
	"Path": "java.util.TimSort.gallopRight",
	"Comment": "like gallopleft, except that if the range contains an element equal tokey, gallopright returns the index after the rightmost equal element.",
	"Method": "int gallopRight(T key,T[] a,int base,int len,int hint,Comparator<? super T> c){\r\n    assert len > 0 && hint >= 0 && hint < len;\r\n    int ofs = 1;\r\n    int lastOfs = 0;\r\n    if (c.compare(key, a[base + hint]) < 0) {\r\n        int maxOfs = hint + 1;\r\n        while (ofs < maxOfs && c.compare(key, a[base + hint - ofs]) < 0) {\r\n            lastOfs = ofs;\r\n            ofs = (ofs << 1) + 1;\r\n            if (ofs <= 0)\r\n                ofs = maxOfs;\r\n        }\r\n        if (ofs > maxOfs)\r\n            ofs = maxOfs;\r\n        int tmp = lastOfs;\r\n        lastOfs = hint - ofs;\r\n        ofs = hint - tmp;\r\n    } else {\r\n        int maxOfs = len - hint;\r\n        while (ofs < maxOfs && c.compare(key, a[base + hint + ofs]) >= 0) {\r\n            lastOfs = ofs;\r\n            ofs = (ofs << 1) + 1;\r\n            if (ofs <= 0)\r\n                ofs = maxOfs;\r\n        }\r\n        if (ofs > maxOfs)\r\n            ofs = maxOfs;\r\n        lastOfs += hint;\r\n        ofs += hint;\r\n    }\r\n    assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;\r\n    lastOfs++;\r\n    while (lastOfs < ofs) {\r\n        int m = lastOfs + ((ofs - lastOfs) >>> 1);\r\n        if (c.compare(key, a[base + m]) < 0)\r\n            ofs = m;\r\n        else\r\n            lastOfs = m + 1;\r\n    }\r\n    assert lastOfs == ofs;\r\n    return ofs;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.QualifierHierarchy.greatestLowerBound",
	"Comment": "returns the greatest lower bound for the qualifiers a1 and a2.the two qualifiers have to be from the same qualifier hierarchy. otherwise, null will bereturned.",
	"Method": "AnnotationMirror greatestLowerBound(AnnotationMirror a1,AnnotationMirror a2,AnnotationMirror greatestLowerBound,AnnotatedTypeMirror type1,AnnotatedTypeMirror type2,AnnotationMirror a1,AnnotationMirror a2){\r\n    if (canHaveEmptyAnnotationSet(type1) || canHaveEmptyAnnotationSet(type2)) {\r\n        return greatestLowerBoundTypeVariable(a1, a2);\r\n    } else {\r\n        return greatestLowerBound(a1, a2);\r\n    }\r\n}"
}, {
	"Path": "java.io.BufferedReader.ready",
	"Comment": "tells whether this stream is ready to be read.a buffered characterstream is ready if the buffer is not empty, or if the underlyingcharacter stream is ready.",
	"Method": "boolean ready(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.put",
	"Comment": "associates the specified value with the specified key in this identityhash map.if the map previously contained a mapping for the key, theold value is replaced.",
	"Method": "V put(K key,V value){\r\n    Object k = maskNull(key);\r\n    Object[] tab = table;\r\n    int len = tab.length;\r\n    int i = hash(k, len);\r\n    Object item;\r\n    while ((item = tab[i]) != null) {\r\n        if (item == k) {\r\n            @SuppressWarnings(\"unchecked\")\r\n            V oldValue = (V) tab[i + 1];\r\n            tab[i + 1] = value;\r\n            return oldValue;\r\n        }\r\n        i = nextKeyIndex(i, len);\r\n    }\r\n    modCount++;\r\n    tab[i] = k;\r\n    tab[i + 1] = value;\r\n    if (++size >= threshold)\r\n        resize(len);\r\n    return null;\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.UBQualifier.isLessThanLengthOfAny",
	"Comment": "is the value with this qualifier less than the length of any of the sequences?",
	"Method": "boolean isLessThanLengthOfAny(List<String> sequences,boolean isLessThanLengthOfAny,List<String> sequences){\r\n    return false;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.MultiGraphQualifierHierarchy.findBottoms",
	"Comment": "not static to allow adaptation in subclasses. only parameters should be modified.",
	"Method": "Set<AnnotationMirror> findBottoms(Map<AnnotationMirror, Set<AnnotationMirror>> supertypes){\r\n    Set<AnnotationMirror> possibleBottoms = AnnotationUtils.createAnnotationSet();\r\n    possibleBottoms.addAll(supertypes.keySet());\r\n    for (Set<AnnotationMirror> supers : supertypes.values()) {\r\n        possibleBottoms.removeAll(supers);\r\n    }\r\n    return possibleBottoms;\r\n}"
}, {
	"Path": "java.io.OutputStream.close",
	"Comment": "closes this output stream and releases any system resourcesassociated with this stream. the general contract of closeis that it closes the output stream. a closed stream cannot performoutput operations and cannot be reopened.the close method of outputstream does nothing.",
	"Method": "void close(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.Iterator.forEachRemaining",
	"Comment": "performs the given action for each remaining element until all elementshave been processed or the action throws an exception.actions areperformed in the order of iteration, if that order is specified.exceptions thrown by the action are relayed to the caller.",
	"Method": "void forEachRemaining(Consumer<? super E> action){\r\n    Objects.requireNonNull(action);\r\n    while (hasNext()) action.accept(next());\r\n}"
}, {
	"Path": "org.checkerframework.framework.source.SourceChecker.useUncheckedCodeDefault",
	"Comment": "should unchecked code defaults be used for the kind of code indicated by the parameter.",
	"Method": "boolean useUncheckedCodeDefault(String kindOfCode){\r\n    final boolean useUncheckedDefaultsForSource = false;\r\n    final boolean useUncheckedDefaultsForByteCode = false;\r\n    String option = this.getOption(\"useDefaultsForUncheckedCode\");\r\n    String[] args = option != null ? option.split(\",\") : new String[0];\r\n    for (String arg : args) {\r\n        boolean value = arg.indexOf(\"-\") != 0;\r\n        arg = value ? arg : arg.substring(1);\r\n        if (arg.equals(kindOfCode)) {\r\n            return value;\r\n        }\r\n    }\r\n    if (kindOfCode.equals(\"source\")) {\r\n        return useUncheckedDefaultsForSource;\r\n    } else if (kindOfCode.equals(\"bytecode\")) {\r\n        return useUncheckedDefaultsForByteCode;\r\n    } else {\r\n        throw new UserError(\"SourceChecker: unexpected argument to useUncheckedCodeDefault: \" + kindOfCode);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.samelen.SameLenAnnotatedTypeFactory.getSameLensFromString",
	"Comment": "find all the sequences that are members of the samelen annotation associated with thesequence named in sequenceexpression along the current path.",
	"Method": "List<String> getSameLensFromString(String sequenceExpression,Tree tree,TreePath currentPath){\r\n    AnnotationMirror sameLenAnno = null;\r\n    try {\r\n        sameLenAnno = getAnnotationFromJavaExpressionString(sequenceExpression, tree, currentPath, SameLen.class);\r\n    } catch (FlowExpressionParseUtil.FlowExpressionParseException e) {\r\n    }\r\n    if (sameLenAnno == null) {\r\n        return new ArrayList();\r\n    }\r\n    return getValueOfAnnotationWithStringArgument(sameLenAnno);\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.samelen.SameLenTransfer.propagateCombinedSameLen",
	"Comment": "insert combinedsamelen into the store as the samelen type of each array listed incombinedsamelen.",
	"Method": "void propagateCombinedSameLen(AnnotationMirror combinedSameLen,Node node,CFStore store){\r\n    TreePath currentPath = aTypeFactory.getPath(node.getTree());\r\n    if (currentPath == null) {\r\n        return;\r\n    }\r\n    for (String s : IndexUtil.getValueOfAnnotationWithStringArgument(combinedSameLen)) {\r\n        Receiver recS;\r\n        try {\r\n            recS = aTypeFactory.getReceiverFromJavaExpressionString(s, currentPath);\r\n        } catch (FlowExpressionParseUtil.FlowExpressionParseException e) {\r\n            continue;\r\n        }\r\n        store.clearValue(recS);\r\n        store.insertValue(recS, combinedSameLen);\r\n    }\r\n}"
}, {
	"Path": "java.io.StringReader.reset",
	"Comment": "resets the stream to the most recent mark, or to the beginning of thestring if it has never been marked.",
	"Method": "void reset(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotationClassLoader.checkJarForPackage",
	"Comment": "checks to see if the jar file contains the qual package of a specific checker.",
	"Method": "boolean checkJarForPackage(JarFile jar){\r\n    Enumeration<JarEntry> jarEntries = jar.entries();\r\n    while (jarEntries.hasMoreElements()) {\r\n        JarEntry je = jarEntries.nextElement();\r\n        String entryName = je.getName();\r\n        if (entryName.startsWith(packageNameWithSlashes)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.checkerframework.checker.signedness.SignednessUtil.toDouble",
	"Comment": "returns a double representing the same value as the unsigned long.",
	"Method": "double toDouble(byte b,double toDouble,short s,double toDouble,int i,double toDouble,long l){\r\n    return toUnsignedBigInteger(l).doubleValue();\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.TestUtilities.getJavaFilesAsArgumentList",
	"Comment": "traverses the directories listed looking for java test files.",
	"Method": "List<File> getJavaFilesAsArgumentList(File dirs){\r\n    List<File> arguments = new ArrayList();\r\n    for (File dir : dirs) {\r\n        List<File> javaFiles = deeplyEnclosedJavaTestFiles(dir);\r\n        for (File javaFile : javaFiles) {\r\n            arguments.add(javaFile);\r\n        }\r\n    }\r\n    return arguments;\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.AnnotationUtils.containsSameByName",
	"Comment": "checks that the collection contains the annotation. using collection.contains does not alwayswork, because it does not use aresame for comparison.",
	"Method": "boolean containsSameByName(Collection<? extends AnnotationMirror> c,String anno){\r\n    return getAnnotationByName(c, anno) != null;\r\n}"
}, {
	"Path": "java.beans.PropertyDescriptor.createPropertyEditor",
	"Comment": "constructs an instance of a property editor using the currentproperty editor class.if the property editor class has a public constructor that takes anobject argument then it will be invoked using the bean parameteras the argument. otherwise, the default constructor will be invoked.",
	"Method": "PropertyEditor createPropertyEditor(Object bean){\r\n    Object editor = null;\r\n    final Class<?> cls = getPropertyEditorClass();\r\n    if (cls != null && PropertyEditor.class.isAssignableFrom(cls) && ReflectUtil.isPackageAccessible(cls)) {\r\n        Constructor<?> ctor = null;\r\n        if (bean != null) {\r\n            try {\r\n                ctor = cls.getConstructor(new Class<?>[] { Object.class });\r\n            } catch (Exception ex) {\r\n            }\r\n        }\r\n        try {\r\n            if (ctor == null) {\r\n                editor = cls.newInstance();\r\n            } else {\r\n                editor = ctor.newInstance(new Object[] { bean });\r\n            }\r\n        } catch (Exception ex) {\r\n        }\r\n    }\r\n    return (PropertyEditor) editor;\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueTransfer.getNumericalValues",
	"Comment": "returns a list of possible values, or null if no estimate is available and any value ispossible.",
	"Method": "List<? extends Number> getNumericalValues(Node subNode,TransferInput<CFValue, CFStore> p,List<? extends Number> getNumericalValues,Node subNode,AnnotationMirror valueAnno){\r\n    if (valueAnno == null || AnnotationUtils.areSameByClass(valueAnno, UnknownVal.class)) {\r\n        return null;\r\n    } else if (AnnotationUtils.areSameByClass(valueAnno, BottomVal.class)) {\r\n        return new ArrayList();\r\n    }\r\n    List<? extends Number> values;\r\n    if (AnnotationUtils.areSameByClass(valueAnno, IntVal.class)) {\r\n        values = ValueAnnotatedTypeFactory.getIntValues(valueAnno);\r\n    } else if (AnnotationUtils.areSameByClass(valueAnno, DoubleVal.class)) {\r\n        values = ValueAnnotatedTypeFactory.getDoubleValues(valueAnno);\r\n    } else {\r\n        return null;\r\n    }\r\n    return NumberUtils.castNumbers(subNode.getType(), values);\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.TreePathCacher.scan",
	"Comment": "scan a single node. the current path is updated for the duration of the scan.",
	"Method": "TreePath scan(Tree tree,Tree target){\r\n    TreePath prev = path;\r\n    if (tree != null && foundPaths.get(tree) == null) {\r\n        TreePath current = new TreePath(path, tree);\r\n        foundPaths.put(tree, current);\r\n        path = current;\r\n    } else {\r\n        this.path = foundPaths.get(tree);\r\n    }\r\n    if (tree == target) {\r\n        throw new Result(path);\r\n    }\r\n    try {\r\n        return super.scan(tree, target);\r\n    } finally {\r\n        this.path = prev;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.AbstractTypeProcessor.process",
	"Comment": "the use of this method is obsolete in type processors. the method is called duringdeclaration annotation processing phase only. it registers the names of elements to process.",
	"Method": "boolean process(Set<? extends TypeElement> annotations,RoundEnvironment roundEnv){\r\n    for (TypeElement elem : ElementFilter.typesIn(roundEnv.getRootElements())) {\r\n        elements.add(elem.getQualifiedName());\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.io.DataInputStream.readUnsignedByte",
	"Comment": "see the general contract of the readunsignedbytemethod of datainput.bytesfor this operation are read from the containedinput stream.",
	"Method": "int readUnsignedByte(){\r\n    int ch = in.read();\r\n    if (ch < 0)\r\n        throw new EOFException();\r\n    return ch;\r\n}"
}, {
	"Path": "java.util.Locale.getUnicodeLocaleKeys",
	"Comment": "returns the set of unicode locale keys defined by this locale, or the empty set ifthis locale has none.the returned set is immutable.keys are all lower case.",
	"Method": "Set<String> getUnicodeLocaleKeys(){\r\n    if (localeExtensions == null) {\r\n        return Collections.emptySet();\r\n    }\r\n    return localeExtensions.getUnicodeLocaleKeys();\r\n}"
}, {
	"Path": "org.checkerframework.checker.i18nformatter.I18nFormatUtil.hasFormat",
	"Comment": "todo introduce more such functions, see regexutil for examples",
	"Method": "boolean hasFormat(String format,I18nConversionCategory cc){\r\n    I18nConversionCategory[] fcc = formatParameterCategories(format);\r\n    if (fcc.length != cc.length) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < cc.length; i++) {\r\n        if (!I18nConversionCategory.isSubsetOf(cc[i], fcc[i])) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "java.util.logging.Logger.isLoggable",
	"Comment": "check if a message of the given level would actually be loggedby this logger.this check is based on the loggers effective level,which may be inherited from its parent.",
	"Method": "boolean isLoggable(Level level){\r\n    if (level.intValue() < levelValue || levelValue == offValue) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotationClassLoader.loadBundledAnnotationClasses",
	"Comment": "loads the set of annotation classes in the qual directory of a checker shipped with thechecker framework.",
	"Method": "void loadBundledAnnotationClasses(){\r\n    if (resourceURL == null) {\r\n        return;\r\n    }\r\n    Set<String> annotationNames;\r\n    if (resourceURL.getProtocol().contentEquals(\"jar\")) {\r\n        JarURLConnection connection;\r\n        try {\r\n            connection = (JarURLConnection) resourceURL.openConnection();\r\n            connection.setDefaultUseCaches(false);\r\n            connection.setUseCaches(false);\r\n            connection.connect();\r\n        } catch (IOException e) {\r\n            throw new BugInCF(\"AnnotationClassLoader: cannot open a connection to the Jar file \" + resourceURL.getFile());\r\n        }\r\n        try (JarFile jarFile = connection.getJarFile()) {\r\n            annotationNames = getBundledAnnotationNamesFromJar(jarFile);\r\n        } catch (IOException e) {\r\n            throw new BugInCF(\"AnnotationClassLoader: cannot open the Jar file \" + resourceURL.getFile());\r\n        }\r\n    } else if (resourceURL.getProtocol().contentEquals(\"file\")) {\r\n        File packageDir = new File(resourceURL.getFile());\r\n        annotationNames = getAnnotationNamesFromDirectory(packageName + DOT, packageDir, packageDir);\r\n    } else {\r\n        annotationNames = Collections.emptySet();\r\n    }\r\n    supportedBundledAnnotationClasses.addAll(loadAnnotationClasses(annotationNames));\r\n}"
}, {
	"Path": "java.util.Locale.writeObject",
	"Comment": "serializes this locale to the specified objectoutputstream.",
	"Method": "void writeObject(ObjectOutputStream out){\r\n    ObjectOutputStream.PutField fields = out.putFields();\r\n    fields.put(\"language\", baseLocale.getLanguage());\r\n    fields.put(\"script\", baseLocale.getScript());\r\n    fields.put(\"country\", baseLocale.getRegion());\r\n    fields.put(\"variant\", baseLocale.getVariant());\r\n    fields.put(\"extensions\", localeExtensions == null ? \"\" : localeExtensions.getID());\r\n    fields.put(\"hashcode\", -1);\r\n    out.writeFields();\r\n}"
}, {
	"Path": "java.lang.AbstractStringBuilder.offsetByCodePoints",
	"Comment": "returns the index within this sequence that is offset from thegiven index by codepointoffset codepoints. unpaired surrogates within the text range given byindex and codepointoffset count asone code point each.",
	"Method": "int offsetByCodePoints(int index,int codePointOffset){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.io.RandomAccessFile.getFD",
	"Comment": "returns the opaque file descriptor object associated with thisstream.",
	"Method": "FileDescriptor getFD(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.CollectionSerializer.getSendJavaType",
	"Comment": "return true if the java type of the collection should be sent.",
	"Method": "boolean getSendJavaType(){\r\n    return _sendJavaType;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeMirror.replaceAnnotations",
	"Comment": "adds multiple annotations to this type, removing any existing annotations from the samequalifier hierarchy first.",
	"Method": "void replaceAnnotations(Iterable<? extends AnnotationMirror> replAnnos){\r\n    for (AnnotationMirror a : replAnnos) {\r\n        this.replaceAnnotation(a);\r\n    }\r\n}"
}, {
	"Path": "sun.util.resources.LocaleData.getCalendarData",
	"Comment": "gets a calendar data resource bundle, using privilegesto allow accessing a sun. package.",
	"Method": "ResourceBundle getCalendarData(Locale locale){\r\n    return getBundle(\"sun.util.resources.CalendarData\", locale);\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.CheckerMain.main",
	"Comment": "any exception thrown by the checker framework escapes to the command line.",
	"Method": "void main(String[] args){\r\n    final File pathToThisJar = new File(findPathTo(CheckerMain.class, false));\r\n    ArrayList<String> alargs = new ArrayList(args.length);\r\n    alargs.addAll(Arrays.asList(args));\r\n    final CheckerMain program = new CheckerMain(pathToThisJar, alargs);\r\n    final int exitStatus = program.invokeCompiler();\r\n    System.exit(exitStatus);\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.defaults.QualifierDefaults.addClimbStandardDefaults",
	"Comment": "add standard climb defaults that do not conflict with previously added defaults.",
	"Method": "void addClimbStandardDefaults(){\r\n    QualifierHierarchy qualHierarchy = this.atypeFactory.getQualifierHierarchy();\r\n    Set<? extends AnnotationMirror> tops = qualHierarchy.getTopAnnotations();\r\n    Set<? extends AnnotationMirror> bottoms = qualHierarchy.getBottomAnnotations();\r\n    for (TypeUseLocation loc : STANDARD_CLIMB_DEFAULTS_TOP) {\r\n        for (AnnotationMirror top : tops) {\r\n            if (!conflictsWithExistingDefaults(checkedCodeDefaults, top, loc)) {\r\n                addCheckedCodeDefault(top, loc);\r\n            }\r\n        }\r\n    }\r\n    for (TypeUseLocation loc : STANDARD_CLIMB_DEFAULTS_BOTTOM) {\r\n        for (AnnotationMirror bottom : bottoms) {\r\n            if (!conflictsWithExistingDefaults(checkedCodeDefaults, bottom, loc)) {\r\n                addCheckedCodeDefault(bottom, loc);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.Date.equals",
	"Comment": "compares two dates for equality.the result is true if and only if the argument isnot null and is a date object thatrepresents the same point in time, to the millisecond, as this object.thus, two date objects are equal if and only if thegettime method returns the same longvalue for both.",
	"Method": "boolean equals(Object obj){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.ui.PropertiesDialogue.getConfigurationLocation",
	"Comment": "get the configuration location entered in the dialogue, or null if no valid location was entered.",
	"Method": "ConfigurationLocation getConfigurationLocation(){\r\n    return propertiesPanel.getConfigurationLocation();\r\n}"
}, {
	"Path": "java.awt.image.ColorModel.coerceData",
	"Comment": "forces the raster data to match the state specified in theisalphapremultiplied variable, assuming the data iscurrently correctly described by this colormodel.itmay multiply or divide the color raster data by alpha, or donothing if the data is in the correct state.if the data needs tobe coerced, this method will also return an instance of thiscolormodel with the isalphapremultipliedflag set appropriately.this method will throw aunsupportedoperationexception if it is not supportedby this colormodel.since colormodel is an abstract class,any instance is an instance of a subclass.subclasses mustoverride this method since the implementation in this abstractclass throws an unsupportedoperationexception.",
	"Method": "ColorModel coerceData(WritableRaster raster,boolean isAlphaPremultiplied){\r\n    throw new UnsupportedOperationException(\"This method is not supported by this color model\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.createTypeArgumentInference",
	"Comment": "typeargumentinference infers the method type arguments when they are not explicitly written.",
	"Method": "TypeArgumentInference createTypeArgumentInference(){\r\n    return new DefaultTypeArgumentInference(this);\r\n}"
}, {
	"Path": "java.io.FileInputStream.close",
	"Comment": "closes this file input stream and releases any system resourcesassociated with the stream. if this stream has an associated channel then the channel is closedas well.",
	"Method": "void close(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.hasWriteReplaceMethod",
	"Comment": "returns true if represented class is serializable or externalizable anddefines a conformant writereplace method.otherwise, returns false.",
	"Method": "boolean hasWriteReplaceMethod(){\r\n    return (writeReplaceMethod != null);\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.GenericAnnotatedTypeFactory.addCheckedStandardDefaults",
	"Comment": "adds the standard climb defaults that do not conflict with previously added defaults.",
	"Method": "void addCheckedStandardDefaults(QualifierDefaults defs){\r\n    if (this.everUseFlow) {\r\n        defs.addClimbStandardDefaults();\r\n    }\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.UseCase3DTOService.toDTO",
	"Comment": "converts the passed usecase3 to a dto. the depth is used to control theamount of association you want. it also prevents potential infinite serialization cycles.",
	"Method": "UseCase3DTO toDTO(UseCase3 useCase3,UseCase3DTO toDTO,UseCase3 useCase3,int depth){\r\n    if (useCase3 == null) {\r\n        return null;\r\n    }\r\n    UseCase3DTO dto = new UseCase3DTO();\r\n    dto.id = useCase3.getId();\r\n    dto.dummy = useCase3.getDummy();\r\n    if (depth-- > 0) {\r\n        dto.id2 = useCase2DTOService.toDTO(useCase3.getId2(), depth);\r\n    }\r\n    return dto;\r\n}"
}, {
	"Path": "java.io.ByteArrayOutputStream.ensureCapacity",
	"Comment": "increases the capacity if necessary to ensure that it can holdat least the number of elements specified by the minimumcapacity argument.",
	"Method": "void ensureCapacity(int minCapacity){\r\n    if (minCapacity - buf.length > 0)\r\n        grow(minCapacity);\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.DefaultTypeHierarchy.castedAsSuper",
	"Comment": "calls assuper and casts the result to the same type as the input supertype.",
	"Method": "T castedAsSuper(AnnotatedTypeMirror subtype,T supertype){\r\n    final Types types = subtype.atypeFactory.getProcessingEnv().getTypeUtils();\r\n    final Elements elements = subtype.atypeFactory.getProcessingEnv().getElementUtils();\r\n    if (subtype.getKind() == TypeKind.NULL) {\r\n        T copy = (T) supertype.deepCopy();\r\n        copy.replaceAnnotations(subtype.getAnnotations());\r\n        return copy;\r\n    }\r\n    final T asSuperType = AnnotatedTypes.asSuper(subtype.atypeFactory, subtype, supertype);\r\n    fixUpRawTypes(subtype, asSuperType, supertype, types);\r\n    if (asSuperType != null && AnnotatedTypes.isEnum(asSuperType) && AnnotatedTypes.isDeclarationOfJavaLangEnum(types, elements, supertype)) {\r\n        final AnnotatedDeclaredType resultAtd = ((AnnotatedDeclaredType) supertype).deepCopy();\r\n        resultAtd.clearAnnotations();\r\n        resultAtd.addAnnotations(asSuperType.getAnnotations());\r\n        final AnnotatedDeclaredType asSuperAdt = (AnnotatedDeclaredType) asSuperType;\r\n        if (resultAtd.getTypeArguments().size() > 0 && asSuperAdt.getTypeArguments().size() > 0) {\r\n            final AnnotatedTypeMirror sourceTypeArg = asSuperAdt.getTypeArguments().get(0);\r\n            final AnnotatedTypeMirror resultTypeArg = resultAtd.getTypeArguments().get(0);\r\n            resultTypeArg.clearAnnotations();\r\n            if (resultTypeArg.getKind() == TypeKind.TYPEVAR) {\r\n                AnnotatedTypeVariable resultTypeArgTV = (AnnotatedTypeVariable) resultTypeArg;\r\n                resultTypeArgTV.getUpperBound().addAnnotations(sourceTypeArg.getAnnotations());\r\n            } else {\r\n                resultTypeArg.addAnnotations(sourceTypeArg.getAnnotations());\r\n            }\r\n            return (T) resultAtd;\r\n        }\r\n    }\r\n    return asSuperType;\r\n}"
}, {
	"Path": "java.util.Vector.containsAll",
	"Comment": "returns true if this vector contains all of the elements in thespecified collection.",
	"Method": "boolean containsAll(Collection<?> c){\r\n    return super.containsAll(c);\r\n}"
}, {
	"Path": "java.util.Collections.singletonList",
	"Comment": "returns an immutable list containing only the specified object.the returned list is serializable.",
	"Method": "List<T> singletonList(T o){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.io.PipedReader.receivedLast",
	"Comment": "notifies all waiting threads that the last character of data has beenreceived.",
	"Method": "void receivedLast(){\r\n    closedByWriter = true;\r\n    notifyAll();\r\n}"
}, {
	"Path": "java.util.LinkedHashMap.clear",
	"Comment": "removes all of the mappings from this map.the map will be empty after this call returns.",
	"Method": "void clear(){\r\n    super.clear();\r\n    head = tail = null;\r\n}"
}, {
	"Path": "java.lang.ClassLoader.checkName",
	"Comment": "true if the name is null or has the potential to be a valid binary name",
	"Method": "boolean checkName(String name){\r\n    if ((name == null) || (name.length() == 0))\r\n        return true;\r\n    if ((name.indexOf('/') != -1) || (!VM.allowArraySyntax() && (name.charAt(0) == '[')))\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "java.io.SequenceInputStream.close",
	"Comment": "closes this input stream and releases any system resourcesassociated with the stream.a closed sequenceinputstreamcannotperform input operations and cannotbe reopened.if this stream was createdfrom an enumeration, all remaining elementsare requested from the enumeration and closedbefore the close method returns.",
	"Method": "void close(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.zip.GZIPOutputStream.writeShort",
	"Comment": "writes short integer in intel byte order to a byte array, startingat a given offset",
	"Method": "void writeShort(int s,byte[] buf,int offset){\r\n    buf[offset] = (byte) (s & 0xff);\r\n    buf[offset + 1] = (byte) ((s >> 8) & 0xff);\r\n}"
}, {
	"Path": "java.util.Calendar.getInstance",
	"Comment": "gets a calendar with the specified time zone and locale.the calendar returned is based on the current timein the given time zone with the given locale.",
	"Method": "Calendar getInstance(Calendar getInstance,TimeZone zone,Calendar getInstance,Locale aLocale,Calendar getInstance,TimeZone zone,Locale aLocale){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.Vector.get",
	"Comment": "returns the element at the specified position in this vector.",
	"Method": "E get(int index){\r\n    if (index >= elementCount)\r\n        throw new ArrayIndexOutOfBoundsException(index);\r\n    return elementData(index);\r\n}"
}, {
	"Path": "org.checkerframework.framework.source.SourceChecker.processArg",
	"Comment": "process an argument to an error message before it is passed to string.format.",
	"Method": "Object processArg(Object arg){\r\n    return messages.getProperty(arg.toString(), arg.toString());\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.treeannotator.ImplicitsTreeAnnotator.addStringPattern",
	"Comment": "added an implicit rule for all string literals that match the given pattern.",
	"Method": "void addStringPattern(String pattern,AnnotationMirror theQual){\r\n    boolean res = qualHierarchy.updateMappingToMutableSet(stringPatterns, Pattern.compile(pattern), theQual);\r\n    if (!res) {\r\n        throw new BugInCF(\"PropagationTreeAnnotator: invalid update of stringPatterns \" + stringPatterns + \" at \" + pattern + \" with \" + theQual);\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceValuesToInt",
	"Comment": "returns the result of accumulating the given transformationof all values using the given reducer to combine values,and the given basis as an identity value.",
	"Method": "int reduceValuesToInt(long parallelismThreshold,ToIntFunction<? super V> transformer,int basis,IntBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceValuesToIntTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "java.text.MessageFormat.append",
	"Comment": "convenience method to append all the characters initerator to the stringbuffer result.",
	"Method": "void append(StringBuffer result,CharacterIterator iterator){\r\n    if (iterator.first() != CharacterIterator.DONE) {\r\n        char aChar;\r\n        result.append(iterator.first());\r\n        while ((aChar = iterator.next()) != CharacterIterator.DONE) {\r\n            result.append(aChar);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.SimpleOptionMap.addToPathOption",
	"Comment": "a method to easily add strings to an option that takes a filepath as an argument.",
	"Method": "void addToPathOption(String key,String toAppend){\r\n    if (toAppend == null) {\r\n        throw new IllegalArgumentException(\"Null string appended to sourcePath.\");\r\n    }\r\n    String path = options.get(key);\r\n    if (toAppend.startsWith(File.pathSeparator)) {\r\n        if (path == null || path.isEmpty()) {\r\n            path = toAppend.substring(1, toAppend.length());\r\n        } else {\r\n            path += toAppend;\r\n        }\r\n    } else {\r\n        if (path == null || path.isEmpty()) {\r\n            path = toAppend;\r\n        } else {\r\n            path += File.pathSeparator + toAppend;\r\n        }\r\n    }\r\n    addOption(key, path);\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.defaults.QualifierDefaults.addUncheckedStandardDefaults",
	"Comment": "add standard unchecked defaults that do not conflict with previously added defaults.",
	"Method": "void addUncheckedStandardDefaults(){\r\n    QualifierHierarchy qualHierarchy = this.atypeFactory.getQualifierHierarchy();\r\n    Set<? extends AnnotationMirror> tops = qualHierarchy.getTopAnnotations();\r\n    Set<? extends AnnotationMirror> bottoms = qualHierarchy.getBottomAnnotations();\r\n    for (TypeUseLocation loc : STANDARD_UNCHECKED_DEFAULTS_TOP) {\r\n        for (AnnotationMirror top : tops) {\r\n            if (!conflictsWithExistingDefaults(uncheckedCodeDefaults, top, loc)) {\r\n                addUncheckedCodeDefault(top, loc);\r\n            }\r\n        }\r\n    }\r\n    for (TypeUseLocation loc : STANDARD_UNCHECKED_DEFAULTS_BOTTOM) {\r\n        for (AnnotationMirror bottom : bottoms) {\r\n            if (!conflictsWithExistingDefaults(uncheckedCodeDefaults, bottom, loc)) {\r\n                addUncheckedCodeDefault(bottom, loc);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.StubParser.putOrAddToMap",
	"Comment": "if the key is already in the map, then add the annos to the list. otherwise put the key andthe annos in the map",
	"Method": "void putOrAddToMap(Map<String, Set<AnnotationMirror>> map,String key,Set<AnnotationMirror> annos){\r\n    if (map.containsKey(key)) {\r\n        map.get(key).addAll(annos);\r\n    } else {\r\n        map.put(key, annos);\r\n    }\r\n}"
}, {
	"Path": "java.util.HashMap.containsKey",
	"Comment": "returns true if this map contains a mapping for thespecified key.",
	"Method": "boolean containsKey(Object key){\r\n    return getNode(hash(key), key) != null;\r\n}"
}, {
	"Path": "java.util.Optional.ifPresent",
	"Comment": "if a value is present, invoke the specified consumer with the value,otherwise do nothing.",
	"Method": "void ifPresent(Consumer<? super T> consumer){\r\n    if (value != null)\r\n        consumer.accept(value);\r\n}"
}, {
	"Path": "java.util.zip.InflaterOutputStream.finish",
	"Comment": "finishes writing uncompressed data to the output stream without closingthe underlying stream.use this method when applying multiple filters insuccession to the same output stream.",
	"Method": "void finish(){\r\n    ensureOpen();\r\n    flush();\r\n    if (usesDefaultInflater) {\r\n        inf.end();\r\n    }\r\n}"
}, {
	"Path": "java.io.RandomAccessFile.close",
	"Comment": "closes this random access file stream and releases any systemresources associated with the stream. a closed random accessfile cannot perform input or output operations and cannot bereopened. if this file has an associated channel then the channel is closedas well.",
	"Method": "void close(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.shouldTakeFromReceiver",
	"Comment": "determine whether we should take annotations from the given method receiver.",
	"Method": "boolean shouldTakeFromReceiver(AnnotatedDeclaredType methodReceiver){\r\n    return methodReceiver != null;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.addCount",
	"Comment": "adds to count, and if table is too small and not alreadyresizing, initiates transfer. if already resizing, helpsperform transfer if work is available.rechecks occupancyafter a transfer to see if another resize is already neededbecause resizings are lagging additions.",
	"Method": "void addCount(long x,int check){\r\n    CounterCell[] as;\r\n    long b, s;\r\n    if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {\r\n        CounterCell a;\r\n        long v;\r\n        int m;\r\n        boolean uncontended = true;\r\n        if (as == null || (m = as.length - 1) < 0 || (a = as[ThreadLocalRandom.getProbe() & m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {\r\n            fullAddCount(x, uncontended);\r\n            return;\r\n        }\r\n        if (check <= 1)\r\n            return;\r\n        s = sumCount();\r\n    }\r\n    if (check >= 0) {\r\n        Node<K, V>[] tab, nt;\r\n        int n, sc;\r\n        while (s >= (long) (sc = sizeCtl) && (tab = table) != null && (n = tab.length) < MAXIMUM_CAPACITY) {\r\n            int rs = resizeStamp(n);\r\n            if (sc < 0) {\r\n                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex <= 0)\r\n                    break;\r\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\r\n                    transfer(tab, nt);\r\n            } else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs << RESIZE_STAMP_SHIFT) + 2))\r\n                transfer(tab, null);\r\n            s = sumCount();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.solver.SupertypesSolver.mergeLubAnnosWithEqualities",
	"Comment": "we previously found a type that is equal to target but not in all hierarchies. use theprimary annotations from the lub annos to fill in the missing annotations in this type. usethat type as the inferred argument.if we failed to infer any annotation for a given hierarchy, either previously fromequalities or from the lub, return null.",
	"Method": "InferredType mergeLubAnnosWithEqualities(TypeVariable target,AnnotationMirrorMap<AnnotationMirror> lubAnnos,ConstraintMap constraintMap,AnnotatedTypeFactory typeFactory){\r\n    final Equalities equalities = constraintMap.getConstraints(target).equalities;\r\n    final AnnotationMirrorSet tops = new AnnotationMirrorSet(typeFactory.getQualifierHierarchy().getTopAnnotations());\r\n    if (!equalities.types.isEmpty()) {\r\n        final Entry<AnnotatedTypeMirror, AnnotationMirrorSet> eqEntry = equalities.types.entrySet().iterator().next();\r\n        final AnnotatedTypeMirror equalityType = eqEntry.getKey();\r\n        final AnnotationMirrorSet equalityAnnos = eqEntry.getValue();\r\n        boolean failed = false;\r\n        for (final AnnotationMirror top : tops) {\r\n            if (!equalityAnnos.contains(top)) {\r\n                final AnnotationMirror lubAnno = lubAnnos.get(top);\r\n                if (lubAnno == null) {\r\n                    failed = true;\r\n                } else {\r\n                    equalityType.replaceAnnotation(lubAnno);\r\n                    equalityAnnos.add(top);\r\n                }\r\n            }\r\n        }\r\n        if (!failed) {\r\n            return new InferredType(equalityType);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.io.ByteArrayOutputStream.grow",
	"Comment": "increases the capacity to ensure that it can hold at least thenumber of elements specified by the minimum capacity argument.",
	"Method": "void grow(int minCapacity){\r\n    int oldCapacity = buf.length;\r\n    int newCapacity = oldCapacity << 1;\r\n    if (newCapacity - minCapacity < 0)\r\n        newCapacity = minCapacity;\r\n    if (newCapacity < 0) {\r\n        if (minCapacity < 0)\r\n            throw new OutOfMemoryError();\r\n        newCapacity = Integer.MAX_VALUE;\r\n    }\r\n    buf = Arrays.copyOf(buf, newCapacity);\r\n}"
}, {
	"Path": "org.checkerframework.dataflow.analysis.FlowExpressions.internalReprOfPseudoReceiver",
	"Comment": "returns either a new classname or thisreference receiver object for the enclosingtype.the tree should be an expression or a statement that does not have a receiver or animplicit receiver. for example, a local variable declaration.",
	"Method": "Receiver internalReprOfPseudoReceiver(TreePath path,TypeMirror enclosingType){\r\n    if (TreeUtils.isTreeInStaticScope(path)) {\r\n        return new ClassName(enclosingType);\r\n    } else {\r\n        return new ThisReference(enclosingType);\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.computeIfPresent",
	"Comment": "if the value for the specified key is present, attempts tocompute a new mapping given the key and its current mappedvalue.the entire method invocation is performed atomically.some attempted update operations on this map by other threadsmay be blocked while computation is in progress, so thecomputation should be short and simple, and must not attempt toupdate any other mappings of this map.",
	"Method": "V computeIfPresent(K key,BiFunction<? super K, ? super V, ? extends @PolyNull V> remappingFunction){\r\n    if (key == null || remappingFunction == null)\r\n        throw new NullPointerException();\r\n    int h = spread(key.hashCode());\r\n    V val = null;\r\n    int delta = 0;\r\n    int binCount = 0;\r\n    for (Node<K, V>[] tab = table; ; ) {\r\n        Node<K, V> f;\r\n        int n, i, fh;\r\n        if (tab == null || (n = tab.length) == 0)\r\n            tab = initTable();\r\n        else if ((f = tabAt(tab, i = (n - 1) & h)) == null)\r\n            break;\r\n        else if ((fh = f.hash) == MOVED)\r\n            tab = helpTransfer(tab, f);\r\n        else {\r\n            synchronized (f) {\r\n                if (tabAt(tab, i) == f) {\r\n                    if (fh >= 0) {\r\n                        binCount = 1;\r\n                        for (Node<K, V> e = f, pred = null; ; ++binCount) {\r\n                            K ek;\r\n                            if (e.hash == h && ((ek = e.key) == key || (ek != null && key.equals(ek)))) {\r\n                                val = remappingFunction.apply(key, e.val);\r\n                                if (val != null)\r\n                                    e.val = val;\r\n                                else {\r\n                                    delta = -1;\r\n                                    Node<K, V> en = e.next;\r\n                                    if (pred != null)\r\n                                        pred.next = en;\r\n                                    else\r\n                                        setTabAt(tab, i, en);\r\n                                }\r\n                                break;\r\n                            }\r\n                            pred = e;\r\n                            if ((e = e.next) == null)\r\n                                break;\r\n                        }\r\n                    } else if (f instanceof TreeBin) {\r\n                        binCount = 2;\r\n                        TreeBin<K, V> t = (TreeBin<K, V>) f;\r\n                        TreeNode<K, V> r, p;\r\n                        if ((r = t.root) != null && (p = r.findTreeNode(h, key, null)) != null) {\r\n                            val = remappingFunction.apply(key, p.val);\r\n                            if (val != null)\r\n                                p.val = val;\r\n                            else {\r\n                                delta = -1;\r\n                                if (t.removeTreeNode(p))\r\n                                    setTabAt(tab, i, untreeify(t.first));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            if (binCount != 0)\r\n                break;\r\n        }\r\n    }\r\n    if (delta != 0)\r\n        addCount((long) delta, binCount);\r\n    return val;\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.Subsequence.getContextFromReceiver",
	"Comment": "if the passed receiver is a fieldaccess, returns the context associated with it. otherwisereturns null.used to standardize and viewpoint adapt arguments to hassubsequence annotations.",
	"Method": "FlowExpressionContext getContextFromReceiver(Receiver rec,BaseContext checker){\r\n    if (rec == null) {\r\n        return null;\r\n    }\r\n    if (rec instanceof FlowExpressions.FieldAccess) {\r\n        FieldAccess fa = (FlowExpressions.FieldAccess) rec;\r\n        return new FlowExpressionParseUtil.FlowExpressionContext(fa.getReceiver(), null, checker);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.lowerbound.LowerBoundAnnotatedTypeFactory.getLowerBoundAnnotationFromValueType",
	"Comment": "returns the type in the lower bound hierarchy that a value checker type corresponds to.",
	"Method": "AnnotationMirror getLowerBoundAnnotationFromValueType(AnnotatedTypeMirror valueType){\r\n    Range possibleValues = getPossibleValues(valueType, getValueAnnotatedTypeFactory());\r\n    if (possibleValues == null) {\r\n        if (AnnotationUtils.containsSameByClass(valueType.getAnnotations(), BottomVal.class)) {\r\n            return BOTTOM;\r\n        }\r\n        return UNKNOWN;\r\n    }\r\n    long lvalMin = possibleValues.from;\r\n    int valMin = (int) Math.max(Math.min(Integer.MAX_VALUE, lvalMin), Integer.MIN_VALUE);\r\n    return anmFromVal(valMin);\r\n}"
}, {
	"Path": "java.util.PriorityQueue.clear",
	"Comment": "removes all of the elements from this priority queue.the queue will be empty after this call returns.",
	"Method": "void clear(){\r\n    modCount++;\r\n    for (int i = 0; i < size; i++) queue[i] = null;\r\n    size = 0;\r\n}"
}, {
	"Path": "java.lang.ClassLoader.definePackage",
	"Comment": "defines a package by name in this classloader.this allowsclass loaders to define the packages for their classes. packages mustbe created before the class is defined, and package names must beunique within a class loader and cannot be redefined or changed oncecreated.",
	"Method": "Package definePackage(String name,String specTitle,String specVersion,String specVendor,String implTitle,String implVersion,String implVendor,URL sealBase){\r\n    synchronized (packages) {\r\n        Package pkg = getPackage(name);\r\n        if (pkg != null) {\r\n            throw new IllegalArgumentException(name);\r\n        }\r\n        pkg = new Package(name, specTitle, specVersion, specVendor, implTitle, implVersion, implVendor, sealBase, this);\r\n        packages.put(name, pkg);\r\n        return pkg;\r\n    }\r\n}"
}, {
	"Path": "java.text.MessageFormat.setFormatByArgumentIndex",
	"Comment": "sets the format to use for the format elements within thepreviously set pattern string that use the given argumentindex.the argument index is part of the format element definition andrepresents an index into the arguments array passedto the format methods or the result array returnedby the parse methods.if the argument index is used for more than one format elementin the pattern string, then the new format is used for all suchformat elements. if the argument index is not used for any formatelement in the pattern string, then the new format is ignored.",
	"Method": "void setFormatByArgumentIndex(int argumentIndex,Format newFormat){\r\n    for (int j = 0; j <= maxOffset; j++) {\r\n        if (argumentNumbers[j] == argumentIndex) {\r\n            formats[j] = newFormat;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.lang.ref.ReferenceQueue.remove",
	"Comment": "removes the next reference object in this queue, blocking until onebecomes available.",
	"Method": "Reference<? extends T> remove(long timeout,Reference<? extends T> remove){\r\n    return remove(0);\r\n}"
}, {
	"Path": "java.util.zip.DeflaterOutputStream.finish",
	"Comment": "finishes writing compressed data to the output stream without closingthe underlying stream. use this method when applying multiple filtersin succession to the same output stream.",
	"Method": "void finish(){\r\n    if (!def.finished()) {\r\n        def.finish();\r\n        while (!def.finished()) {\r\n            deflate();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.AnnotatedTypes.asOuterSuper",
	"Comment": "return the base type of type or any of its outer types that starts with the given type. ifnone exists, return null.",
	"Method": "AnnotatedTypeMirror asOuterSuper(Types types,AnnotatedTypeFactory atypeFactory,AnnotatedTypeMirror type,AnnotatedTypeMirror superType){\r\n    if (type.getKind() == TypeKind.DECLARED) {\r\n        AnnotatedDeclaredType dt = (AnnotatedDeclaredType) type;\r\n        AnnotatedDeclaredType enclosingType = dt;\r\n        TypeMirror superTypeMirror = types.erasure(superType.getUnderlyingType());\r\n        while (enclosingType != null) {\r\n            TypeMirror enclosingTypeMirror = types.erasure(enclosingType.getUnderlyingType());\r\n            if (types.isSubtype(enclosingTypeMirror, superTypeMirror)) {\r\n                dt = enclosingType;\r\n                break;\r\n            }\r\n            enclosingType = enclosingType.getEnclosingType();\r\n        }\r\n        if (enclosingType == null) {\r\n            return superType;\r\n        }\r\n        return asSuper(atypeFactory, dt, superType);\r\n    }\r\n    return asSuper(atypeFactory, type, superType);\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.trees.TreeBuilder.buildArrayLengthAccess",
	"Comment": "builds an ast tree to dereference the length field of an array.",
	"Method": "MemberSelectTree buildArrayLengthAccess(ExpressionTree expression){\r\n    return (JCTree.JCFieldAccess) maker.Select((JCTree.JCExpression) expression, symtab.lengthVar);\r\n}"
}, {
	"Path": "org.checkerframework.checker.units.UnitsRelationsTools.buildAnnoMirrorWithNoPrefix",
	"Comment": "creates an annotationmirror representing a unit defined by annoclass, with no prefix.",
	"Method": "AnnotationMirror buildAnnoMirrorWithNoPrefix(ProcessingEnvironment env,Class<? extends Annotation> annoClass){\r\n    if (env == null || annoClass == null) {\r\n        return null;\r\n    }\r\n    return AnnotationBuilder.fromClass(env.getElementUtils(), annoClass);\r\n}"
}, {
	"Path": "java.io.PushbackInputStream.mark",
	"Comment": "marks the current position in this input stream. the mark method of pushbackinputstreamdoes nothing.",
	"Method": "void mark(int readlimit){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "javax.net.ssl.SSLContext.getProtocol",
	"Comment": "returns the protocol name of this sslcontext object.this is the same name that was specified in one of thegetinstance calls that created thissslcontext object.",
	"Method": "String getProtocol(){\r\n    return this.protocol;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.AnnotatedTypes.containsModifierImpl",
	"Comment": "for type variables we might hit the same type again. we keep a list of visited types.",
	"Method": "boolean containsModifierImpl(AnnotatedTypeMirror type,AnnotationMirror modifier,List<AnnotatedTypeMirror> visited){\r\n    boolean found = type.hasAnnotation(modifier);\r\n    boolean vis = visited.contains(type);\r\n    visited.add(type);\r\n    if (!found && !vis) {\r\n        if (type.getKind() == TypeKind.DECLARED) {\r\n            AnnotatedDeclaredType declaredType = (AnnotatedDeclaredType) type;\r\n            for (AnnotatedTypeMirror typeMirror : declaredType.getTypeArguments()) {\r\n                found |= containsModifierImpl(typeMirror, modifier, visited);\r\n                if (found) {\r\n                    break;\r\n                }\r\n            }\r\n        } else if (type.getKind() == TypeKind.ARRAY) {\r\n            AnnotatedArrayType arrayType = (AnnotatedArrayType) type;\r\n            found = containsModifierImpl(arrayType.getComponentType(), modifier, visited);\r\n        } else if (type.getKind() == TypeKind.TYPEVAR) {\r\n            AnnotatedTypeVariable atv = (AnnotatedTypeVariable) type;\r\n            if (atv.getUpperBound() != null) {\r\n                found = containsModifierImpl(atv.getUpperBound(), modifier, visited);\r\n            }\r\n            if (!found && atv.getLowerBound() != null) {\r\n                found = containsModifierImpl(atv.getLowerBound(), modifier, visited);\r\n            }\r\n        } else if (type.getKind() == TypeKind.WILDCARD) {\r\n            AnnotatedWildcardType awc = (AnnotatedWildcardType) type;\r\n            if (awc.getExtendsBound() != null) {\r\n                found = containsModifierImpl(awc.getExtendsBound(), modifier, visited);\r\n            }\r\n            if (!found && awc.getSuperBound() != null) {\r\n                found = containsModifierImpl(awc.getSuperBound(), modifier, visited);\r\n            }\r\n        }\r\n    }\r\n    return found;\r\n}"
}, {
	"Path": "java.util.ListResourceBundle.handleKeySet",
	"Comment": "returns a set of the keys containedonly in this resourcebundle.",
	"Method": "Set<String> handleKeySet(){\r\n    if (lookup == null) {\r\n        loadLookup();\r\n    }\r\n    return lookup.keySet();\r\n}"
}, {
	"Path": "java.util.Calendar.toString",
	"Comment": "return a string representation of this calendar. this methodis intended to be used only for debugging purposes, and theformat of the returned string may vary between implementations.the returned string may be empty but may not be null.",
	"Method": "String toString(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.UpperBoundVisitor.testSameLen",
	"Comment": "tests whether replacing any of the arrays in samelenarrays with arrayname makes expqualequivalent to varqual.",
	"Method": "boolean testSameLen(UBQualifier expQual,LessThanLengthOf varQual,List<String> sameLenArrays,String arrayName){\r\n    if (!expQual.isLessThanLengthQualifier()) {\r\n        return false;\r\n    }\r\n    for (String sameLenArrayName : sameLenArrays) {\r\n        if (varQual.isValidReplacement(arrayName, sameLenArrayName, (LessThanLengthOf) expQual)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.forClass",
	"Comment": "return the class in the local vm that this version is mapped to.nullis returned if there is no corresponding local class.",
	"Method": "Class<?> forClass(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.io.File.canRead",
	"Comment": "tests whether the application can read the file denoted by thisabstract pathname.",
	"Method": "boolean canRead(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.visitor.AnnotatedTypeMerger.resolvePrimaries",
	"Comment": "for type variables and wildcards, the absence of a primary annotations has an implied meaningon substitution. therefore, in these cases we remove the primary annotation and rely on thefact that the bounds are also merged into the type to.",
	"Method": "void resolvePrimaries(AnnotatedTypeMirror from,AnnotatedTypeMirror to){\r\n    if (from.getKind() == TypeKind.WILDCARD || from.getKind() == TypeKind.TYPEVAR) {\r\n        if (top != null) {\r\n            if (from.getAnnotationInHierarchy(top) == null) {\r\n                to.removeAnnotationInHierarchy(top);\r\n            }\r\n        } else {\r\n            for (final AnnotationMirror toPrimaryAnno : to.getAnnotations()) {\r\n                if (from.getAnnotationInHierarchy(toPrimaryAnno) == null) {\r\n                    to.removeAnnotation(toPrimaryAnno);\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        throw new BugInCF(\"ResolvePrimaries' from argument should be a type variable OR wildcard\\n\" + \"from=\" + from.toString(true) + \"\\n\" + \"to=\" + to.toString(true));\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeMirror.removeAnnotationInHierarchy",
	"Comment": "remove any annotation that is in the same qualifier hierarchy as the parameter.",
	"Method": "boolean removeAnnotationInHierarchy(AnnotationMirror a){\r\n    AnnotationMirror prev = this.getAnnotationInHierarchy(a);\r\n    if (prev != null) {\r\n        return this.removeAnnotation(prev);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.getGregorianCutoverDate",
	"Comment": "returns the gregorian cutover date as a basecalendar.date. thedate is a gregorian date.",
	"Method": "BaseCalendar.Date getGregorianCutoverDate(){\r\n    return getCalendarDate(gregorianCutoverDate);\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotationClassLoader.loadExternalAnnotationClassesFromDirectory",
	"Comment": "this method takes as input a fully qualified path to a directory, and loads and returns theset of all supported annotation classes from that directory.",
	"Method": "Set<Class<? extends Annotation>> loadExternalAnnotationClassesFromDirectory(String dirName){\r\n    File rootDirectory = new File(dirName);\r\n    Set<String> annoNames = getAnnotationNamesFromDirectory(\"\", rootDirectory, rootDirectory);\r\n    return loadAnnotationClasses(annoNames);\r\n}"
}, {
	"Path": "org.checkerframework.checker.units.UnitsAnnotatedTypeFactory.addUnitToExternalQualMap",
	"Comment": "adds the annotation class to the external qualifier map if it is not an alias annotation.",
	"Method": "void addUnitToExternalQualMap(Class<? extends Annotation> annoClass){\r\n    AnnotationMirror mirror = UnitsRelationsTools.buildAnnoMirrorWithNoPrefix(processingEnv, annoClass);\r\n    if (!isAliasedAnnotation(mirror)) {\r\n        String unitClassName = annoClass.getCanonicalName();\r\n        if (!externalQualsMap.containsKey(unitClassName)) {\r\n            externalQualsMap.put(unitClassName, annoClass);\r\n        }\r\n    } else {\r\n        Class<? extends Annotation> baseUnitClass = getBaseUnitAnnoClass(mirror);\r\n        if (baseUnitClass != null) {\r\n            String baseUnitClassName = baseUnitClass.getCanonicalName();\r\n            if (!externalQualsMap.containsKey(baseUnitClassName)) {\r\n                loadExternalUnit(baseUnitClassName);\r\n            }\r\n            aliasedAnnotation(mirror);\r\n        } else {\r\n        }\r\n    }\r\n    addUnitsRelations(annoClass);\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeMirror.getUnderlyingType",
	"Comment": "returns the underlying unannotated java type, which this wraps.",
	"Method": "TypeMirror getUnderlyingType(DeclaredType getUnderlyingType,ExecutableType getUnderlyingType,ArrayType getUnderlyingType,TypeVariable getUnderlyingType,NoType getUnderlyingType,NullType getUnderlyingType,PrimitiveType getUnderlyingType,WildcardType getUnderlyingType){\r\n    return actualType;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.element.ElementAnnotationUtil.partitionByTargetType",
	"Comment": "use a map to partition annotations with the given targettypes into lists, where each targettype is a key in the output map. any annotation that does not have one of these target typeswill be added to unmatched",
	"Method": "Map<TargetType, List<TypeCompound>> partitionByTargetType(Collection<TypeCompound> annos,List<TypeCompound> unmatched,TargetType targetTypes){\r\n    final Map<TargetType, List<TypeCompound>> targetTypeToAnnos = new HashMap();\r\n    for (TargetType targetType : targetTypes) {\r\n        targetTypeToAnnos.put(targetType, new ArrayList(10));\r\n    }\r\n    for (final TypeCompound anno : annos) {\r\n        final List<TypeCompound> annoSet = targetTypeToAnnos.get(anno.getPosition().type);\r\n        if (annoSet != null) {\r\n            annoSet.add(anno);\r\n        } else if (unmatched != null) {\r\n            unmatched.add(anno);\r\n        }\r\n    }\r\n    return targetTypeToAnnos;\r\n}"
}, {
	"Path": "javax.net.ssl.TrustManagerFactory.getAlgorithm",
	"Comment": "returns the algorithm name of this trustmanagerfactoryobject.this is the same name that was specified in one of thegetinstance calls that created thistrustmanagerfactory object.",
	"Method": "String getAlgorithm(){\r\n    return this.algorithm;\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.CheckStylePlugin.isScanInProgress",
	"Comment": "is a scan in progress?this is only expected to be called from the event thread.",
	"Method": "boolean isScanInProgress(){\r\n    synchronized (checksInProgress) {\r\n        return !checksInProgress.isEmpty();\r\n    }\r\n}"
}, {
	"Path": "java.util.EnumSet.complementOf",
	"Comment": "creates an enum set with the same element type as the specified enumset, initially containing all the elements of this type that arenot contained in the specified set.",
	"Method": "EnumSet<E> complementOf(EnumSet<E> s){\r\n    EnumSet<E> result = copyOf(s);\r\n    result.complement();\r\n    return result;\r\n}"
}, {
	"Path": "org.checkerframework.common.reflection.DefaultReflectionResolver.debugReflection",
	"Comment": "reports debug information about the reflection resolution iff the corresponding debug flag isset.",
	"Method": "void debugReflection(String msg){\r\n    if (debug) {\r\n        checker.message(javax.tools.Diagnostic.Kind.NOTE, MSG_PREFEX_REFLECTION + msg);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.StubGenerator.stubFromPackage",
	"Comment": "generate the stub file for all the classes within the provided package.",
	"Method": "void stubFromPackage(PackageElement packageElement){\r\n    currentPackage = packageElement.getQualifiedName().toString();\r\n    indent();\r\n    out.print(\"package \");\r\n    out.print(currentPackage);\r\n    out.println(\";\");\r\n    for (TypeElement element : ElementFilter.typesIn(packageElement.getEnclosedElements())) {\r\n        if (isPublicOrProtected(element)) {\r\n            out.println();\r\n            printClass(element);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.lang.ClassLoader.findLoadedClass",
	"Comment": "returns the class with the given binary name if thisloader has been recorded by the java virtual machine as an initiatingloader of a class with that binary name.otherwisenull is returned.",
	"Method": "Class<?> findLoadedClass(String name){\r\n    if (!checkName(name))\r\n        return null;\r\n    return findLoadedClass0(name);\r\n}"
}, {
	"Path": "java.util.JumboEnumSet.removeAll",
	"Comment": "removes from this set all of its elements that are contained inthe specified collection.",
	"Method": "boolean removeAll(Collection<?> c){\r\n    if (!(c instanceof JumboEnumSet))\r\n        return super.removeAll(c);\r\n    JumboEnumSet es = (JumboEnumSet) c;\r\n    if (es.elementType != elementType)\r\n        return false;\r\n    for (int i = 0; i < elements.length; i++) elements[i] &= ~es.elements[i];\r\n    return recalculateSize();\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.writeClassDesc",
	"Comment": "writes representation of given class descriptor to stream.",
	"Method": "void writeClassDesc(ObjectStreamClass desc,boolean unshared){\r\n    int handle;\r\n    if (desc == null) {\r\n        writeNull();\r\n    } else if (!unshared && (handle = handles.lookup(desc)) != -1) {\r\n        writeHandle(handle);\r\n    } else if (desc.isProxy()) {\r\n        writeProxyDesc(desc, unshared);\r\n    } else {\r\n        writeNonProxyDesc(desc, unshared);\r\n    }\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceKeysToInt",
	"Comment": "returns the result of accumulating the given transformationof all keys using the given reducer to combine values, andthe given basis as an identity value.",
	"Method": "int reduceKeysToInt(long parallelismThreshold,ToIntFunction<? super K> transformer,int basis,IntBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceKeysToIntTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.HessianInput.readHeader",
	"Comment": "reads a header, returning null if there are no headers.h b16 b8 value",
	"Method": "String readHeader(){\r\n    int tag = read();\r\n    if (tag == 'H') {\r\n        _isLastChunk = true;\r\n        _chunkLength = (read() << 8) + read();\r\n        _sbuf.setLength(0);\r\n        int ch;\r\n        while ((ch = parseChar()) >= 0) {\r\n            _sbuf.append((char) ch);\r\n        }\r\n        return _sbuf.toString();\r\n    }\r\n    _peek = tag;\r\n    return null;\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.util.IntMap.get",
	"Comment": "puts a new value in the property table with the appropriate flags",
	"Method": "int get(Object key){\r\n    int prime = _prime;\r\n    int hash = hashCode(key) % prime;\r\n    final Object[] keys = _keys;\r\n    while (true) {\r\n        Object mapKey = keys[hash];\r\n        if (mapKey == null) {\r\n            return NULL;\r\n        } else if (mapKey == key) {\r\n            return _values[hash];\r\n        }\r\n        hash = (hash + 1) % prime;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.common.value.util.Range.intersect",
	"Comment": "returns the smallest range that includes all values contained in both of the two ranges. wecall this the intersection of two ranges. if there is no overlap between the two ranges,returns an empty range.",
	"Method": "Range intersect(Range right){\r\n    if (this.isNothing() || right.isNothing()) {\r\n        return NOTHING;\r\n    }\r\n    long resultFrom = Math.max(from, right.from);\r\n    long resultTo = Math.min(to, right.to);\r\n    return createRangeOrNothing(resultFrom, resultTo);\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.packTimes",
	"Comment": "pack the start and end times into an array of bytes.this is requiredas of serial version 2.",
	"Method": "int[] packTimes(){\r\n    int[] times = new int[2];\r\n    times[0] = startTime;\r\n    times[1] = endTime;\r\n    return times;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.DefaultTypeArgumentInference.inferFromAssignmentEqualities",
	"Comment": "step 3. infer type arguments from the equality constraints of the assignment context.",
	"Method": "InferenceResult inferFromAssignmentEqualities(AnnotatedTypeMirror assignedTo,AnnotatedTypeMirror boxedReturnType,Set<TypeVariable> targets,AnnotatedTypeFactory typeFactory){\r\n    Set<FIsA> afInitialAssignmentConstraints = createInitialAssignmentConstraints(assignedTo, boxedReturnType, typeFactory, targets);\r\n    Set<TUConstraint> tuInitialAssignmentConstraints = afToTuConstraints(afInitialAssignmentConstraints, targets);\r\n    ConstraintMap initialAssignmentConstraints = constraintMapBuilder.build(targets, tuInitialAssignmentConstraints, typeFactory);\r\n    return equalitiesSolver.solveEqualities(targets, initialAssignmentConstraints, typeFactory);\r\n}"
}, {
	"Path": "com.mycompany.myapp.domain.UseCase3.toString",
	"Comment": "construct a readable string representation for this usecase3 instance.",
	"Method": "String toString(){\r\n    return // \r\n    MoreObjects.toStringHelper(this).add(\"dummy\", getDummy()).toString();\r\n}"
}, {
	"Path": "java.util.UUID.digits",
	"Comment": "returns val represented by the specified number of hex digits.",
	"Method": "String digits(long val,int digits){\r\n    long hi = 1L << (digits * 4);\r\n    return Long.toHexString(hi | (val & (hi - 1))).substring(1);\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.AnnotatedTypes.getAnnotatedTypes",
	"Comment": "return a list of the annotatedtypemirror of the passed expression trees, in the same order asthe trees.",
	"Method": "List<AnnotatedTypeMirror> getAnnotatedTypes(AnnotatedTypeFactory atypeFactory,List<AnnotatedTypeMirror> paramTypes,List<? extends ExpressionTree> trees){\r\n    assert paramTypes.size() == trees.size() : \"AnnotatedTypes.getAnnotatedTypes: size mismatch! \" + \"Parameter types: \" + paramTypes + \" Arguments: \" + trees;\r\n    List<AnnotatedTypeMirror> types = new ArrayList();\r\n    Pair<Tree, AnnotatedTypeMirror> preAssCtxt = atypeFactory.getVisitorState().getAssignmentContext();\r\n    try {\r\n        for (int i = 0; i < trees.size(); ++i) {\r\n            AnnotatedTypeMirror param = paramTypes.get(i);\r\n            atypeFactory.getVisitorState().setAssignmentContext(Pair.of((Tree) null, param));\r\n            ExpressionTree arg = trees.get(i);\r\n            types.add(atypeFactory.getAnnotatedType(arg));\r\n        }\r\n    } finally {\r\n        atypeFactory.getVisitorState().setAssignmentContext(preAssCtxt);\r\n    }\r\n    return types;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.FlowExpressionParseUtil.parseMethodCall",
	"Comment": "parse a method call. first of returned pair is a pair of method name and arguments. second ofreturned pair is a remaining string.",
	"Method": "Pair<Pair<String, String>, String> parseMethodCall(String s,Receiver parseMethodCall,String s,FlowExpressionContext context,TreePath path,ProcessingEnvironment env){\r\n    Pair<Pair<String, String>, String> method = parseMethodCall(s);\r\n    if (method == null) {\r\n        return null;\r\n    }\r\n    String methodName = method.first.first;\r\n    String parameterList = method.first.second;\r\n    List<Receiver> parameters = ParameterListParser.parseParameterList(parameterList, true, context.copyAndUseOuterReceiver(), path);\r\n    List<TypeMirror> parameterTypes = new ArrayList();\r\n    for (Receiver p : parameters) {\r\n        parameterTypes.add(p.getType());\r\n    }\r\n    ExecutableElement methodElement = null;\r\n    try {\r\n        Element element = null;\r\n        Resolver resolver = new Resolver(env);\r\n        TypeMirror receiverType = context.receiver.getType();\r\n        if (receiverType.getKind() == TypeKind.ARRAY) {\r\n            element = resolver.findMethod(methodName, receiverType, path, parameterTypes);\r\n        }\r\n        while (receiverType.getKind() == TypeKind.DECLARED) {\r\n            element = resolver.findMethod(methodName, receiverType, path, parameterTypes);\r\n            if (element.getKind() == ElementKind.METHOD) {\r\n                break;\r\n            }\r\n            receiverType = getTypeOfEnclosingClass((DeclaredType) receiverType);\r\n        }\r\n        if (element == null) {\r\n            throw constructParserException(s, \"element==null\");\r\n        }\r\n        if (element.getKind() != ElementKind.METHOD) {\r\n            throw constructParserException(s, \"element.getKind()==\" + element.getKind());\r\n        }\r\n        methodElement = (ExecutableElement) element;\r\n        for (int i = 0; i < parameters.size(); i++) {\r\n            VariableElement formal = methodElement.getParameters().get(i);\r\n            TypeMirror formalType = formal.asType();\r\n            Receiver actual = parameters.get(i);\r\n            TypeMirror actualType = actual.getType();\r\n            if (TypesUtils.isBoxedPrimitive(formalType) && TypesUtils.isPrimitive(actualType)) {\r\n                MethodSymbol valueOfMethod = TreeBuilder.getValueOfMethod(env, formalType);\r\n                List<Receiver> p = new ArrayList();\r\n                p.add(actual);\r\n                Receiver boxedParam = new MethodCall(formalType, valueOfMethod, new ClassName(formalType), p);\r\n                parameters.set(i, boxedParam);\r\n            }\r\n        }\r\n    } catch (Throwable t) {\r\n        if (t.getMessage() == null) {\r\n            throw new Error(\"no detail message in \" + t.getClass(), t);\r\n        }\r\n        throw constructParserException(s, t.getMessage());\r\n    }\r\n    assert methodElement != null;\r\n    if (ElementUtils.isStatic(methodElement)) {\r\n        Element classElem = methodElement.getEnclosingElement();\r\n        Receiver staticClassReceiver = new ClassName(ElementUtils.getType(classElem));\r\n        return new MethodCall(ElementUtils.getType(methodElement), methodElement, staticClassReceiver, parameters);\r\n    } else {\r\n        if (context.receiver instanceof ClassName) {\r\n            throw constructParserException(s, \"a non-static method call cannot have a class name as a receiver.\");\r\n        }\r\n        TypeMirror methodType = TypesUtils.substituteMethodReturnType(methodElement, context.receiver.getType(), env);\r\n        return new MethodCall(methodType, methodElement, context.receiver, parameters);\r\n    }\r\n}"
}, {
	"Path": "java.util.zip.GZIPOutputStream.writeInt",
	"Comment": "writes integer in intel byte order to a byte array, starting at agiven offset.",
	"Method": "void writeInt(int i,byte[] buf,int offset){\r\n    writeShort(i & 0xffff, buf, offset);\r\n    writeShort((i >> 16) & 0xffff, buf, offset + 2);\r\n}"
}, {
	"Path": "org.xml.sax.InputSource.getByteStream",
	"Comment": "get the byte stream for this input source.the getencoding method will return the characterencoding for this byte stream, or null if unknown.",
	"Method": "InputStream getByteStream(){\r\n    return byteStream;\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TreeUtils.isUseOfElement",
	"Comment": "determine whether the given expressiontree has an underlying element.",
	"Method": "boolean isUseOfElement(ExpressionTree node){\r\n    node = TreeUtils.skipParens(node);\r\n    switch(node.getKind()) {\r\n        case IDENTIFIER:\r\n        case MEMBER_SELECT:\r\n        case METHOD_INVOCATION:\r\n        case NEW_CLASS:\r\n            return true;\r\n        default:\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.toolwindow.CheckStyleToolWindowPanel.displayErrorResult",
	"Comment": "clear the results and display notice to say an error occurred.",
	"Method": "void displayErrorResult(Throwable error){\r\n    String errorText = null;\r\n    if (error instanceof CheckstyleToolException && error.getCause() != null) {\r\n        for (final Map.Entry<Pattern, String> errorPatternEntry : CHECKSTYLE_ERROR_PATTERNS.entrySet()) {\r\n            final Matcher errorMatcher = errorPatternEntry.getKey().matcher(error.getCause().getMessage());\r\n            if (errorMatcher.find()) {\r\n                final Object[] args = new Object[errorMatcher.groupCount()];\r\n                for (int i = 0; i < errorMatcher.groupCount(); ++i) {\r\n                    args[i] = errorMatcher.group(i + 1);\r\n                }\r\n                errorText = message(errorPatternEntry.getValue(), args);\r\n            }\r\n        }\r\n    }\r\n    if (errorText == null) {\r\n        if (error instanceof CheckStylePluginParseException) {\r\n            errorText = message(\"plugin.results.unparseable\");\r\n        } else {\r\n            errorText = message(\"plugin.results.error\");\r\n        }\r\n    }\r\n    treeModel.clear();\r\n    treeModel.setRootText(errorText);\r\n    clearProgress();\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.packRules",
	"Comment": "pack the start and end rules into an array of bytes.only packdata which is not preserved by makerulescompatible.",
	"Method": "byte[] packRules(){\r\n    byte[] rules = new byte[6];\r\n    rules[0] = (byte) startDay;\r\n    rules[1] = (byte) startDayOfWeek;\r\n    rules[2] = (byte) endDay;\r\n    rules[3] = (byte) endDayOfWeek;\r\n    rules[4] = (byte) startTimeMode;\r\n    rules[5] = (byte) endTimeMode;\r\n    return rules;\r\n}"
}, {
	"Path": "java.util.Hashtable.hashCode",
	"Comment": "returns the hash code value for this map as per the definition in themap interface.",
	"Method": "int hashCode(int hashCode){\r\n    int h = 0;\r\n    if (count == 0 || loadFactor < 0)\r\n        return h;\r\n    loadFactor = -loadFactor;\r\n    Entry<?, ?>[] tab = table;\r\n    for (Entry<?, ?> entry : tab) {\r\n        while (entry != null) {\r\n            h += entry.hashCode();\r\n            entry = entry.next;\r\n        }\r\n    }\r\n    loadFactor = -loadFactor;\r\n    return h;\r\n}"
}, {
	"Path": "java.util.ResourceBundle.checkList",
	"Comment": "checks if the given list is not null, not empty,not having null in its elements.",
	"Method": "boolean checkList(List a){\r\n    boolean valid = (a != null && a.size() != 0);\r\n    if (valid) {\r\n        int size = a.size();\r\n        for (int i = 0; valid && i < size; i++) {\r\n            valid = (a.get(i) != null);\r\n        }\r\n    }\r\n    return valid;\r\n}"
}, {
	"Path": "org.checkerframework.common.value.util.Range.shiftLeft",
	"Comment": "returns a range that includes all possible values resulting from left shifting an arbitraryvalue in this range by an arbitrary number of bits in the specified range. we call this theleft shift of a range.",
	"Method": "Range shiftLeft(Range right){\r\n    if (this.isNothing() || right.isNothing()) {\r\n        return NOTHING;\r\n    }\r\n    if (right.isWithin(0, 31)) {\r\n        if (this.isWithinInteger()) {\r\n            long resultFrom = from << (from >= 0 ? right.from : right.to);\r\n            long resultTo = to << (to >= 0 ? right.to : right.from);\r\n            return new Range(resultFrom, resultTo);\r\n        } else {\r\n            BigInteger bigFrom = BigInteger.valueOf(from).shiftLeft(from >= 0 ? (int) right.from : (int) right.to);\r\n            BigInteger bigTo = BigInteger.valueOf(to).shiftLeft(to >= 0 ? (int) right.to : (int) right.from);\r\n            return bigRangeToLongRange(bigFrom, bigTo);\r\n        }\r\n    } else {\r\n        return EVERYTHING;\r\n    }\r\n}"
}, {
	"Path": "org.camunda.bpm.integrationtest.functional.spin.PaDataFormatConfiguratorTest.testExecutionVariableImplicitObjectValueUpdate",
	"Comment": "tests that an implicit object value update happens in the context of theprocess application.",
	"Method": "void testExecutionVariableImplicitObjectValueUpdate(){\r\n    ProcessInstance pi = runtimeService.startProcessInstanceByKey(\"implicitProcessVariableUpdate\");\r\n    Date date = new Date(JsonSerializable.ONE_DAY_IN_MILLIS * 10);\r\n    JsonSerializable jsonSerializable = new JsonSerializable(date);\r\n    try {\r\n        ProcessApplicationContext.setCurrentProcessApplication(ReferenceStoringProcessApplication.INSTANCE);\r\n        runtimeService.setVariable(pi.getId(), ImplicitObjectValueUpdateHandler.VARIABLE_NAME, Variables.objectValue(jsonSerializable).serializationDataFormat(SerializationDataFormats.JSON).create());\r\n    } finally {\r\n        ProcessApplicationContext.clear();\r\n    }\r\n    Task task = taskService.createTaskQuery().processInstanceId(pi.getId()).singleResult();\r\n    taskService.complete(task.getId());\r\n    ObjectValue objectValue = runtimeService.getVariableTyped(pi.getId(), ImplicitObjectValueUpdateHandler.VARIABLE_NAME, false);\r\n    ImplicitObjectValueUpdateHandler.addADay(jsonSerializable);\r\n    String serializedValue = objectValue.getValueSerialized();\r\n    String expectedSerializedValue = jsonSerializable.toExpectedJsonString(JsonDataFormatConfigurator.DATE_FORMAT);\r\n    ObjectMapper objectMapper = new ObjectMapper();\r\n    JsonNode actualJsonTree = objectMapper.readTree(serializedValue);\r\n    JsonNode expectedJsonTree = objectMapper.readTree(expectedSerializedValue);\r\n    Assert.assertEquals(expectedJsonTree, actualJsonTree);\r\n    HistoricVariableInstance historicObjectValue = historyService.createHistoricVariableInstanceQuery().processInstanceId(pi.getId()).variableName(ImplicitObjectValueUpdateHandler.VARIABLE_NAME).disableCustomObjectDeserialization().singleResult();\r\n    serializedValue = ((ObjectValue) historicObjectValue.getTypedValue()).getValueSerialized();\r\n    actualJsonTree = objectMapper.readTree(serializedValue);\r\n    Assert.assertEquals(expectedJsonTree, actualJsonTree);\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.isSerializable",
	"Comment": "returns true if represented class implements serializable, falseotherwise.",
	"Method": "boolean isSerializable(){\r\n    return serializable;\r\n}"
}, {
	"Path": "java.beans.PropertyDescriptor.getWriteMethod",
	"Comment": "gets the method that should be used to write the property value.",
	"Method": "Method getWriteMethod(){\r\n    Method writeMethod = this.writeMethodRef.get();\r\n    if (writeMethod == null) {\r\n        Class<?> cls = getClass0();\r\n        if (cls == null || (writeMethodName == null && !this.writeMethodRef.isSet())) {\r\n            return null;\r\n        }\r\n        Class<?> type = getPropertyType0();\r\n        if (type == null) {\r\n            try {\r\n                type = findPropertyType(getReadMethod(), null);\r\n                setPropertyType(type);\r\n            } catch (IntrospectionException ex) {\r\n                return null;\r\n            }\r\n        }\r\n        if (writeMethodName == null) {\r\n            writeMethodName = Introspector.SET_PREFIX + getBaseName();\r\n        }\r\n        Class<?>[] args = (type == null) ? null : new Class<?>[] { type };\r\n        writeMethod = Introspector.findMethod(cls, writeMethodName, 1, args);\r\n        if (writeMethod != null) {\r\n            if (!writeMethod.getReturnType().equals(void.class)) {\r\n                writeMethod = null;\r\n            }\r\n        }\r\n        try {\r\n            setWriteMethod(writeMethod);\r\n        } catch (IntrospectionException ex) {\r\n        }\r\n    }\r\n    return writeMethod;\r\n}"
}, {
	"Path": "java.util.zip.InflaterInputStream.reset",
	"Comment": "repositions this stream to the position at the time themark method was last called on this input stream. the method reset for classinflaterinputstream does nothing except throw anioexception.",
	"Method": "void reset(){\r\n    throw new IOException(\"mark/reset not supported\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.AnnotatedTypes.findEffectiveAnnotationInHierarchy",
	"Comment": "when comparing types against the bounds of a type variable, we may encounter other typevariables, wildcards, and intersections in those bounds. this method traverses the boundsuntil it finds a concrete type from which it can pull an annotation.",
	"Method": "AnnotationMirror findEffectiveAnnotationInHierarchy(QualifierHierarchy qualifierHierarchy,AnnotatedTypeMirror toSearch,AnnotationMirror top,AnnotationMirror findEffectiveAnnotationInHierarchy,QualifierHierarchy qualifierHierarchy,AnnotatedTypeMirror toSearch,AnnotationMirror top,boolean canBeEmpty){\r\n    AnnotatedTypeMirror source = toSearch;\r\n    while (source.getAnnotationInHierarchy(top) == null) {\r\n        switch(source.getKind()) {\r\n            case TYPEVAR:\r\n                source = ((AnnotatedTypeVariable) source).getUpperBound();\r\n                break;\r\n            case WILDCARD:\r\n                source = ((AnnotatedWildcardType) source).getExtendsBound();\r\n                break;\r\n            case INTERSECTION:\r\n                final AnnotationMirror glb = glbOfBoundsInHierarchy((AnnotatedIntersectionType) source, top, qualifierHierarchy);\r\n                if (glb == null) {\r\n                    throw new BugInCF(\"AnnotatedIntersectionType has no annotation in hierarchy \" + \"on any of its supertypes.\\n\" + \"intersectionType=\" + source);\r\n                }\r\n                return glb;\r\n            default:\r\n                if (canBeEmpty) {\r\n                    return null;\r\n                }\r\n                throw new BugInCF(\"Unexpected AnnotatedTypeMirror with no primary annotation.\\n\" + \"toSearch=\" + toSearch + \"\\n\" + \"top=\" + top + \"\\n\" + \"source=\" + source);\r\n        }\r\n    }\r\n    return source.getAnnotationInHierarchy(top);\r\n}"
}, {
	"Path": "org.xml.sax.InputSource.getEncoding",
	"Comment": "get the character encoding for a byte stream or uri.this value will be ignored when the application provides acharacter stream.",
	"Method": "String getEncoding(){\r\n    return encoding;\r\n}"
}, {
	"Path": "java.util.RegularEnumSet.removeAll",
	"Comment": "removes from this set all of its elements that are contained inthe specified collection.",
	"Method": "boolean removeAll(Collection<?> c){\r\n    if (!(c instanceof RegularEnumSet))\r\n        return super.removeAll(c);\r\n    RegularEnumSet es = (RegularEnumSet) c;\r\n    if (es.elementType != elementType)\r\n        return false;\r\n    long oldElements = elements;\r\n    elements &= ~es.elements;\r\n    return elements != oldElements;\r\n}"
}, {
	"Path": "java.util.PriorityQueue.initFromCollection",
	"Comment": "initializes queue array with elements from the given collection.",
	"Method": "void initFromCollection(Collection<? extends E> c){\r\n    initElementsFromCollection(c);\r\n    heapify();\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.solver.ConstraintMap.addPrimaryEqualities",
	"Comment": "add a constraint indicating that target has primary annotations equal to the givenannotations.",
	"Method": "void addPrimaryEqualities(TypeVariable target,QualifierHierarchy qualHierarchy,AnnotationMirrorSet annos){\r\n    final Equalities equalities = targetToRecords.get(target).equalities;\r\n    for (final AnnotationMirror anno : annos) {\r\n        final AnnotationMirror top = qualHierarchy.getTopAnnotation(anno);\r\n        if (!equalities.primaries.containsKey(top)) {\r\n            equalities.primaries.put(top, anno);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.common.wholeprograminference.AnnotationConverter.getAnnotationFieldType",
	"Comment": "returns an annotationfieldtype given an executableelement or value.",
	"Method": "AnnotationFieldType getAnnotationFieldType(ExecutableElement ee,Object value){\r\n    if (value instanceof List<?>) {\r\n        AnnotationValue defaultValue = ee.getDefaultValue();\r\n        if (defaultValue == null || ((ArrayType) ((Array) defaultValue).type) == null) {\r\n            List<?> listV = (List<?>) value;\r\n            if (!listV.isEmpty()) {\r\n                ScalarAFT scalarAFT = (ScalarAFT) getAnnotationFieldType(ee, ((AnnotationValue) listV.get(0)).getValue());\r\n                if (scalarAFT != null) {\r\n                    return new ArrayAFT(scalarAFT);\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        Type elemType = ((ArrayType) ((Array) defaultValue).type).elemtype;\r\n        try {\r\n            return new ArrayAFT(BasicAFT.forType(Class.forName(elemType.toString())));\r\n        } catch (ClassNotFoundException e) {\r\n            throw new BugInCF(e.getMessage());\r\n        }\r\n    } else if (value instanceof Boolean) {\r\n        return BasicAFT.forType(boolean.class);\r\n    } else if (value instanceof Character) {\r\n        return BasicAFT.forType(char.class);\r\n    } else if (value instanceof Double) {\r\n        return BasicAFT.forType(double.class);\r\n    } else if (value instanceof Float) {\r\n        return BasicAFT.forType(float.class);\r\n    } else if (value instanceof Integer) {\r\n        return BasicAFT.forType(int.class);\r\n    } else if (value instanceof Long) {\r\n        return BasicAFT.forType(long.class);\r\n    } else if (value instanceof Short) {\r\n        return BasicAFT.forType(short.class);\r\n    } else if (value instanceof String) {\r\n        return BasicAFT.forType(String.class);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueTransfer.refineIntRanges",
	"Comment": "calculates the result of a binary comparison on a pair of intrange annotations, and refinesannotations appropriately.",
	"Method": "List<Boolean> refineIntRanges(Node leftNode,AnnotationMirror leftAnno,Node rightNode,AnnotationMirror rightAnno,ComparisonOperators op,CFStore thenStore,CFStore elseStore){\r\n    Range leftRange = getIntRangeFromAnnotation(leftNode, leftAnno);\r\n    Range rightRange = getIntRangeFromAnnotation(rightNode, rightAnno);\r\n    final Range thenRightRange;\r\n    final Range thenLeftRange;\r\n    final Range elseRightRange;\r\n    final Range elseLeftRange;\r\n    switch(op) {\r\n        case EQUAL:\r\n            thenRightRange = rightRange.refineEqualTo(leftRange);\r\n            thenLeftRange = thenRightRange;\r\n            elseRightRange = rightRange.refineNotEqualTo(leftRange);\r\n            elseLeftRange = leftRange.refineNotEqualTo(rightRange);\r\n            break;\r\n        case GREATER_THAN:\r\n            thenLeftRange = leftRange.refineGreaterThan(rightRange);\r\n            thenRightRange = rightRange.refineLessThan(leftRange);\r\n            elseRightRange = rightRange.refineGreaterThanEq(leftRange);\r\n            elseLeftRange = leftRange.refineLessThanEq(rightRange);\r\n            break;\r\n        case GREATER_THAN_EQ:\r\n            thenRightRange = rightRange.refineLessThanEq(leftRange);\r\n            thenLeftRange = leftRange.refineGreaterThanEq(rightRange);\r\n            elseLeftRange = leftRange.refineLessThan(rightRange);\r\n            elseRightRange = rightRange.refineGreaterThan(leftRange);\r\n            break;\r\n        case LESS_THAN:\r\n            thenLeftRange = leftRange.refineLessThan(rightRange);\r\n            thenRightRange = rightRange.refineGreaterThan(leftRange);\r\n            elseRightRange = rightRange.refineLessThanEq(leftRange);\r\n            elseLeftRange = leftRange.refineGreaterThanEq(rightRange);\r\n            break;\r\n        case LESS_THAN_EQ:\r\n            thenRightRange = rightRange.refineGreaterThanEq(leftRange);\r\n            thenLeftRange = leftRange.refineLessThanEq(rightRange);\r\n            elseLeftRange = leftRange.refineGreaterThan(rightRange);\r\n            elseRightRange = rightRange.refineLessThan(leftRange);\r\n            break;\r\n        case NOT_EQUAL:\r\n            thenRightRange = rightRange.refineNotEqualTo(leftRange);\r\n            thenLeftRange = leftRange.refineNotEqualTo(rightRange);\r\n            elseRightRange = rightRange.refineEqualTo(leftRange);\r\n            elseLeftRange = elseRightRange;\r\n            break;\r\n        default:\r\n            throw new BugInCF(\"ValueTransfer: unsupported operation: \" + op);\r\n    }\r\n    createAnnotationFromRangeAndAddToStore(thenStore, thenRightRange, rightNode);\r\n    createAnnotationFromRangeAndAddToStore(thenStore, thenLeftRange, leftNode);\r\n    createAnnotationFromRangeAndAddToStore(elseStore, elseRightRange, rightNode);\r\n    createAnnotationFromRangeAndAddToStore(elseStore, elseLeftRange, leftNode);\r\n    return null;\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.UBQualifier.isLessThanLengthOf",
	"Comment": "is the value with this qualifier less than the length of sequence?",
	"Method": "boolean isLessThanLengthOf(String sequence,boolean isLessThanLengthOf,String sequence){\r\n    return false;\r\n}"
}, {
	"Path": "org.checkerframework.framework.flow.CFAbstractTransfer.visitLocalVariable",
	"Comment": "use the most specific type information available according to the store.",
	"Method": "TransferResult<V, S> visitLocalVariable(LocalVariableNode n,TransferInput<V, S> in){\r\n    S store = in.getRegularStore();\r\n    V valueFromStore = store.getValue(n);\r\n    V valueFromFactory = getValueFromFactory(n.getTree(), n);\r\n    V value = moreSpecificValue(valueFromFactory, valueFromStore);\r\n    return new RegularTransferResult(finishValue(value, store), store);\r\n}"
}, {
	"Path": "java.io.PushbackInputStream.skip",
	"Comment": "skips over and discards n bytes of data from thisinput stream. the skip method may, for a variety ofreasons, end up skipping over some smaller number of bytes,possibly zero.if n is negative, no bytes are skipped. the skip method of pushbackinputstreamfirst skips over the bytes in the pushback buffer, if any.it thencalls the skip method of the underlying input stream ifmore bytes need to be skipped.the actual number of bytes skippedis returned.",
	"Method": "long skip(long n){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.TypeArgInferenceUtil.methodTypeToTargets",
	"Comment": "given an annotatedexecutabletype return a set of type variables that represents the generictype parameters of that method.",
	"Method": "Set<TypeVariable> methodTypeToTargets(AnnotatedExecutableType methodType){\r\n    final List<AnnotatedTypeVariable> annotatedTypeVars = methodType.getTypeVariables();\r\n    final Set<TypeVariable> targets = new LinkedHashSet(annotatedTypeVars.size());\r\n    for (final AnnotatedTypeVariable atv : annotatedTypeVars) {\r\n        targets.add((TypeVariable) TypeAnnotationUtils.unannotatedType(atv.getUnderlyingType()));\r\n    }\r\n    return targets;\r\n}"
}, {
	"Path": "java.io.DataOutputStream.writeLong",
	"Comment": "writes a long to the underlying output stream as eightbytes, high byte first. in no exception is thrown, the counterwritten is incremented by 8.",
	"Method": "void writeLong(long v){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.BookDTOService.toDTO",
	"Comment": "converts the passed book to a dto. the depth is used to control theamount of association you want. it also prevents potential infinite serialization cycles.",
	"Method": "BookDTO toDTO(Book book,BookDTO toDTO,Book book,int depth){\r\n    if (book == null) {\r\n        return null;\r\n    }\r\n    BookDTO dto = new BookDTO();\r\n    dto.id = book.getId();\r\n    dto.title = book.getTitle();\r\n    dto.summary = book.getSummary();\r\n    dto.extractFileName = book.getExtractFileName();\r\n    dto.extractContentType = book.getExtractContentType();\r\n    dto.extractSize = book.getExtractSize();\r\n    dto.publicationDate = book.getPublicationDate();\r\n    dto.bestSeller = book.getBestSeller();\r\n    dto.price = book.getPrice();\r\n    if (depth-- > 0) {\r\n        dto.author = authorDTOService.toDTO(book.getAuthor(), depth);\r\n        dto.coAuthor = authorDTOService.toDTO(book.getCoAuthor(), depth);\r\n    }\r\n    return dto;\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.UpperBoundVisitor.negateString",
	"Comment": "given a java expression, returns the additive inverse, as a string. assumes thatflowexpressions do not contain multiplication.",
	"Method": "String negateString(String s,FlowExpressionContext context){\r\n    return Subsequence.negateString(s, getCurrentPath(), context);\r\n}"
}, {
	"Path": "java.util.zip.ZipInputStream.getNextEntry",
	"Comment": "reads the next zip file entry and positions the stream at thebeginning of the entry data.",
	"Method": "ZipEntry getNextEntry(){\r\n    ensureOpen();\r\n    if (entry != null) {\r\n        closeEntry();\r\n    }\r\n    crc.reset();\r\n    inf.reset();\r\n    if ((entry = readLOC()) == null) {\r\n        return null;\r\n    }\r\n    if (entry.method == STORED) {\r\n        remaining = entry.size;\r\n    }\r\n    entryEOF = false;\r\n    return entry;\r\n}"
}, {
	"Path": "java.util.regex.Matcher.toString",
	"Comment": "returns the string representation of this matcher. thestring representation of a matcher contains informationthat may be useful for debugging. the exact format is unspecified.",
	"Method": "String toString(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.jar.JarInputStream.getNextEntry",
	"Comment": "reads the next zip file entry and positions the stream at thebeginning of the entry data. if verification has been enabled,any invalid signature detected while positioning the stream forthe next entry will result in an exception.",
	"Method": "ZipEntry getNextEntry(){\r\n    JarEntry e;\r\n    if (first == null) {\r\n        e = (JarEntry) super.getNextEntry();\r\n        if (tryManifest) {\r\n            e = checkManifest(e);\r\n            tryManifest = false;\r\n        }\r\n    } else {\r\n        e = first;\r\n        if (first.getName().equalsIgnoreCase(JarIndex.INDEX_NAME))\r\n            tryManifest = true;\r\n        first = null;\r\n    }\r\n    if (jv != null && e != null) {\r\n        if (jv.nothingToVerify() == true) {\r\n            jv = null;\r\n            mev = null;\r\n        } else {\r\n            jv.beginEntry(e, mev);\r\n        }\r\n    }\r\n    return e;\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.ProjectDTOService.toEntity",
	"Comment": "converts the passed dto to a project.convenient for query by example.",
	"Method": "Project toEntity(ProjectDTO dto,Project toEntity,ProjectDTO dto,int depth){\r\n    if (dto == null) {\r\n        return null;\r\n    }\r\n    Project project = new Project();\r\n    project.setId(dto.id);\r\n    project.setName(dto.name);\r\n    project.setUrl(dto.url);\r\n    project.setOpenSource(dto.openSource);\r\n    if (depth-- > 0) {\r\n        project.setAuthor(authorDTOService.toEntity(dto.author, depth));\r\n    }\r\n    return project;\r\n}"
}, {
	"Path": "java.util.StringTokenizer.nextElement",
	"Comment": "returns the same value as the nexttoken method,except that its declared return value is object rather thanstring. it exists so that this class can implement theenumeration interface.",
	"Method": "Object nextElement(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.Vector.removeAll",
	"Comment": "removes from this vector all of its elements that are contained in thespecified collection.",
	"Method": "boolean removeAll(Collection<?> c){\r\n    return super.removeAll(c);\r\n}"
}, {
	"Path": "java.util.zip.InflaterInputStream.close",
	"Comment": "closes this input stream and releases any system resources associatedwith the stream.",
	"Method": "void close(){\r\n    if (!closed) {\r\n        if (usesDefaultInflater)\r\n            inf.end();\r\n        in.close();\r\n        closed = true;\r\n    }\r\n}"
}, {
	"Path": "java.beans.PropertyDescriptor.setReadMethod",
	"Comment": "sets the method that should be used to read the property value.",
	"Method": "void setReadMethod(Method readMethod){\r\n    this.readMethodRef.set(readMethod);\r\n    if (readMethod == null) {\r\n        readMethodName = null;\r\n        return;\r\n    }\r\n    setPropertyType(findPropertyType(readMethod, this.writeMethodRef.get()));\r\n    setClass0(readMethod.getDeclaringClass());\r\n    readMethodName = readMethod.getName();\r\n    setTransient(readMethod.getAnnotation(Transient.class));\r\n}"
}, {
	"Path": "java.awt.image.ColorModel.getTransferType",
	"Comment": "returns the transfer type of this colormodel.the transfer type is the type of primitive array used to representpixel values as arrays.",
	"Method": "int getTransferType(){\r\n    return transferType;\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueTransfer.calculateValuesUnaryOp",
	"Comment": "calculate the possible values after a unary operation of a numerical type node.",
	"Method": "List<Number> calculateValuesUnaryOp(Node operand,NumericalUnaryOps op,TransferInput<CFValue, CFStore> p){\r\n    List<? extends Number> lefts = getNumericalValues(operand, p);\r\n    if (lefts == null) {\r\n        return null;\r\n    }\r\n    List<Number> resultValues = new ArrayList();\r\n    for (Number left : lefts) {\r\n        NumberMath<?> nmLeft = NumberMath.getNumberMath(left);\r\n        switch(op) {\r\n            case PLUS:\r\n                resultValues.add(nmLeft.unaryPlus());\r\n                break;\r\n            case MINUS:\r\n                resultValues.add(nmLeft.unaryMinus());\r\n                break;\r\n            case BITWISE_COMPLEMENT:\r\n                resultValues.add(nmLeft.bitwiseComplement());\r\n                break;\r\n            default:\r\n                throw new BugInCF(\"ValueTransfer: unsupported operation: \" + op);\r\n        }\r\n    }\r\n    return resultValues;\r\n}"
}, {
	"Path": "javax.net.ssl.TrustManagerFactory.getInstance",
	"Comment": "returns a trustmanagerfactory object that acts as afactory for trust managers. a new trustmanagerfactory object encapsulating thetrustmanagerfactoryspi implementation from the specified providerobject is returned.note that the specified provider objectdoes not have to be registered in the provider list.",
	"Method": "TrustManagerFactory getInstance(String algorithm,TrustManagerFactory getInstance,String algorithm,String provider,TrustManagerFactory getInstance,String algorithm,Provider provider){\r\n    GetInstance.Instance instance = GetInstance.getInstance(\"TrustManagerFactory\", TrustManagerFactorySpi.class, algorithm, provider);\r\n    return new TrustManagerFactory((TrustManagerFactorySpi) instance.impl, instance.provider, algorithm);\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.GenericAnnotatedTypeFactory.performFlowAnalysis",
	"Comment": "perform a org.checkerframework.dataflow analysis over a single class tree and its nestedclasses.",
	"Method": "void performFlowAnalysis(ClassTree classTree){\r\n    if (flowResult == null) {\r\n        regularExitStores = new IdentityHashMap();\r\n        returnStatementStores = new IdentityHashMap();\r\n        flowResult = new AnalysisResult(flowResultAnalysisCaches);\r\n    }\r\n    if (classTree.getKind() == Kind.ANNOTATION_TYPE) {\r\n        scannedClasses.put(classTree, ScanState.FINISHED);\r\n        return;\r\n    }\r\n    Queue<Pair<ClassTree, Store>> queue = new ArrayDeque();\r\n    List<Pair<VariableElement, Value>> fieldValues = new ArrayList();\r\n    queue.add(Pair.of(classTree, null));\r\n    while (!queue.isEmpty()) {\r\n        final Pair<ClassTree, Store> qel = queue.remove();\r\n        final ClassTree ct = qel.first;\r\n        final Store capturedStore = qel.second;\r\n        scannedClasses.put(ct, ScanState.IN_PROGRESS);\r\n        TreePath preTreePath = visitorState.getPath();\r\n        AnnotatedDeclaredType preClassType = visitorState.getClassType();\r\n        ClassTree preClassTree = visitorState.getClassTree();\r\n        AnnotatedDeclaredType preAMT = visitorState.getMethodReceiver();\r\n        MethodTree preMT = visitorState.getMethodTree();\r\n        visitorState.setPath(TreePath.getPath(this.root, ct));\r\n        visitorState.setClassType(getAnnotatedType(TreeUtils.elementFromDeclaration(ct)));\r\n        visitorState.setClassTree(ct);\r\n        visitorState.setMethodReceiver(null);\r\n        visitorState.setMethodTree(null);\r\n        initializationStaticStore = capturedStore;\r\n        initializationStore = capturedStore;\r\n        Queue<Pair<LambdaExpressionTree, Store>> lambdaQueue = new ArrayDeque();\r\n        try {\r\n            List<CFGMethod> methods = new ArrayList();\r\n            for (Tree m : ct.getMembers()) {\r\n                switch(m.getKind()) {\r\n                    case METHOD:\r\n                        MethodTree mt = (MethodTree) m;\r\n                        Set<Modifier> flags = mt.getModifiers().getFlags();\r\n                        if (flags.contains(Modifier.ABSTRACT) || flags.contains(Modifier.NATIVE)) {\r\n                            break;\r\n                        }\r\n                        if (mt.getBody() == null) {\r\n                            break;\r\n                        }\r\n                        CFGMethod met = new CFGMethod(mt, ct);\r\n                        methods.add(met);\r\n                        break;\r\n                    case VARIABLE:\r\n                        VariableTree vt = (VariableTree) m;\r\n                        ExpressionTree initializer = vt.getInitializer();\r\n                        if (initializer != null) {\r\n                            boolean isStatic = vt.getModifiers().getFlags().contains(Modifier.STATIC);\r\n                            analyze(queue, lambdaQueue, new CFGStatement(vt, ct), fieldValues, classTree, true, true, isStatic, capturedStore);\r\n                            Value value = flowResult.getValue(initializer);\r\n                            if (vt.getModifiers().getFlags().contains(Modifier.FINAL) && value != null) {\r\n                                VariableElement element = TreeUtils.elementFromDeclaration(vt);\r\n                                fieldValues.add(Pair.of(element, value));\r\n                            }\r\n                        }\r\n                        break;\r\n                    case CLASS:\r\n                    case ANNOTATION_TYPE:\r\n                    case INTERFACE:\r\n                    case ENUM:\r\n                        queue.add(Pair.of((ClassTree) m, capturedStore));\r\n                        break;\r\n                    case BLOCK:\r\n                        BlockTree b = (BlockTree) m;\r\n                        analyze(queue, lambdaQueue, new CFGStatement(b, ct), fieldValues, ct, true, true, b.isStatic(), capturedStore);\r\n                        break;\r\n                    default:\r\n                        assert false : \"Unexpected member: \" + m.getKind();\r\n                        break;\r\n                }\r\n            }\r\n            for (CFGMethod met : methods) {\r\n                analyze(queue, lambdaQueue, met, fieldValues, classTree, TreeUtils.isConstructor(met.getMethod()), false, false, capturedStore);\r\n            }\r\n            while (!lambdaQueue.isEmpty()) {\r\n                Pair<LambdaExpressionTree, Store> lambdaPair = lambdaQueue.poll();\r\n                analyze(queue, lambdaQueue, new CFGLambda(lambdaPair.first), fieldValues, classTree, false, false, false, lambdaPair.second);\r\n            }\r\n            if (initializationStaticStore == null) {\r\n                regularExitStores.put(ct, emptyStore);\r\n            } else {\r\n                regularExitStores.put(ct, initializationStaticStore);\r\n            }\r\n        } finally {\r\n            visitorState.setPath(preTreePath);\r\n            visitorState.setClassType(preClassType);\r\n            visitorState.setClassTree(preClassTree);\r\n            visitorState.setMethodReceiver(preAMT);\r\n            visitorState.setMethodTree(preMT);\r\n        }\r\n        scannedClasses.put(ct, ScanState.FINISHED);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.QualifierHierarchy.replacePolyAll",
	"Comment": "returns a new set that is the passed set, but polyall has been replaced by a polymorphicqualifiers, for hierarchies that do not have an annotation in the set.",
	"Method": "Collection<? extends AnnotationMirror> replacePolyAll(Collection<? extends AnnotationMirror> annos){\r\n    Set<AnnotationMirror> returnAnnos = AnnotationUtils.createAnnotationSet();\r\n    for (AnnotationMirror top : getTopAnnotations()) {\r\n        AnnotationMirror annotationInHierarchy = findAnnotationInHierarchy(annos, top);\r\n        if (annotationInHierarchy != null) {\r\n            returnAnnos.add(annotationInHierarchy);\r\n        }\r\n    }\r\n    return returnAnnos;\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.UBQualifier.hasSequenceWithOffset",
	"Comment": "returns whether or not this qualifier has sequence with the specified offset.",
	"Method": "boolean hasSequenceWithOffset(String sequence,int offset,boolean hasSequenceWithOffset,String sequence,String offset,boolean hasSequenceWithOffset,String sequence,int offset,boolean hasSequenceWithOffset,String sequence,String offset){\r\n    return false;\r\n}"
}, {
	"Path": "java.io.LineNumberInputStream.skip",
	"Comment": "skips over and discards n bytes of data from thisinput stream. the skip method may, for a variety ofreasons, end up skipping over some smaller number of bytes,possibly 0. the actual number of bytes skipped isreturned.if n is negative, no bytes are skipped.the skip method of linenumberinputstream createsa byte array and then repeatedly reads into it untiln bytes have been read or the end of the stream hasbeen reached.",
	"Method": "long skip(long n){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.cfg4j.source.git.TempConfigurationGitRepo.remove",
	"Comment": "remove this repository. silently fails if repo already removed.",
	"Method": "void remove(){\r\n    try {\r\n        repo.close();\r\n        super.remove();\r\n    } catch (IOException e) {\r\n    }\r\n}"
}, {
	"Path": "java.io.File.writeObject",
	"Comment": "writeobject is called to save this filename.the separator character is saved also so it can be replacedin case the path is reconstituted on a different host type.",
	"Method": "void writeObject(java.io.ObjectOutputStream s){\r\n    s.defaultWriteObject();\r\n    s.writeChar(this.separatorChar);\r\n}"
}, {
	"Path": "java.util.Observable.addObserver",
	"Comment": "adds an observer to the set of observers for this object, providedthat it is not the same as some observer already in the set.the order in which notifications will be delivered to multipleobservers is not specified. see the class comment.",
	"Method": "void addObserver(Observer o){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.lang.ClassLoader.findResource",
	"Comment": "finds the resource with the given name. class loader implementationsshould override this method to specify where to find resources.",
	"Method": "URL findResource(String name){\r\n    return null;\r\n}"
}, {
	"Path": "sun.util.resources.LocaleData.getDateFormatData",
	"Comment": "gets a date format data resource bundle, using privilegesto allow accessing a sun. package.",
	"Method": "ResourceBundle getDateFormatData(Locale locale){\r\n    return getBundle(\"sun.text.resources.FormatData\", locale);\r\n}"
}, {
	"Path": "java.util.regex.Pattern.range",
	"Comment": "parse a single character or a character range in a character classand return its representative node.",
	"Method": "CharProperty range(BitClass bits){\r\n    int ch = peek();\r\n    if (ch == '\\\\') {\r\n        ch = nextEscaped();\r\n        if (ch == 'p' || ch == 'P') {\r\n            boolean comp = (ch == 'P');\r\n            boolean oneLetter = true;\r\n            ch = next();\r\n            if (ch != '{')\r\n                unread();\r\n            else\r\n                oneLetter = false;\r\n            return family(oneLetter, comp);\r\n        } else {\r\n            unread();\r\n            ch = escape(true, true);\r\n            if (ch == -1)\r\n                return (CharProperty) root;\r\n        }\r\n    } else {\r\n        ch = single();\r\n    }\r\n    if (ch >= 0) {\r\n        if (peek() == '-') {\r\n            int endRange = temp[cursor + 1];\r\n            if (endRange == '[') {\r\n                return bitsOrSingle(bits, ch);\r\n            }\r\n            if (endRange != ']') {\r\n                next();\r\n                int m = single();\r\n                if (m < ch)\r\n                    throw error(\"Illegal character range\");\r\n                if (has(CASE_INSENSITIVE))\r\n                    return caseInsensitiveRangeFor(ch, m);\r\n                else\r\n                    return rangeFor(ch, m);\r\n            }\r\n        }\r\n        return bitsOrSingle(bits, ch);\r\n    }\r\n    throw error(\"Unexpected character '\" + ((char) ch) + \"'\");\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.ProjectDTOService.save",
	"Comment": "save the passed dto as a new entity or update the corresponding entity if any.",
	"Method": "ProjectDTO save(ProjectDTO dto){\r\n    if (dto == null) {\r\n        return null;\r\n    }\r\n    final Project project;\r\n    if (dto.isIdSet()) {\r\n        Project projectTmp = projectRepository.findOne(dto.id);\r\n        if (projectTmp != null) {\r\n            project = projectTmp;\r\n        } else {\r\n            project = new Project();\r\n            project.setId(dto.id);\r\n        }\r\n    } else {\r\n        project = new Project();\r\n    }\r\n    project.setName(dto.name);\r\n    project.setUrl(dto.url);\r\n    project.setOpenSource(dto.openSource);\r\n    if (dto.author == null) {\r\n        project.setAuthor(null);\r\n    } else {\r\n        Author author = project.getAuthor();\r\n        if (author == null || (author.getId().compareTo(dto.author.id) != 0)) {\r\n            project.setAuthor(authorRepository.findOne(dto.author.id));\r\n        }\r\n    }\r\n    return toDTO(projectRepository.save(project));\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.UserDTOService.save",
	"Comment": "save the passed dto as a new entity or update the corresponding entity if any.",
	"Method": "UserDTO save(UserDTO dto){\r\n    if (dto == null) {\r\n        return null;\r\n    }\r\n    final User user;\r\n    if (dto.isIdSet()) {\r\n        User userTmp = userRepository.findOne(dto.id);\r\n        if (userTmp != null) {\r\n            user = userTmp;\r\n        } else {\r\n            user = new User();\r\n            user.setId(dto.id);\r\n        }\r\n    } else {\r\n        user = new User();\r\n    }\r\n    user.setLogin(dto.login);\r\n    user.setPassword(dto.password);\r\n    user.setEmail(dto.email);\r\n    user.setIsEnabled(dto.isEnabled);\r\n    user.setCivility(dto.civility);\r\n    user.setCountryCode(dto.countryCode);\r\n    user.setFirstName(dto.firstName);\r\n    user.setLastName(dto.lastName);\r\n    user.setCreationDate(dto.creationDate);\r\n    user.setCreationAuthor(dto.creationAuthor);\r\n    user.setLastModificationDate(dto.lastModificationDate);\r\n    user.setLastModificationAuthor(dto.lastModificationAuthor);\r\n    user.setVersion(dto.version);\r\n    user.getRoles().clear();\r\n    if (dto.roles != null) {\r\n        dto.roles.stream().forEach(role -> user.addRole(roleRepository.findOne(role.id)));\r\n    }\r\n    return toDTO(userRepository.save(user));\r\n}"
}, {
	"Path": "sun.util.resources.LocaleData.isNonEuroLangSupported",
	"Comment": "returns true if the non european resources jar file exists in jreextension directory.",
	"Method": "boolean isNonEuroLangSupported(){\r\n    final String sep = File.separator;\r\n    String localeDataJar = java.security.AccessController.doPrivileged(new sun.security.action.GetPropertyAction(\"java.home\")) + sep + \"lib\" + sep + \"ext\" + sep + localeDataJarName;\r\n    final File f = new File(localeDataJar);\r\n    boolean isNonEuroResJarExist = AccessController.doPrivileged(new PrivilegedAction<Boolean>() {\r\n        public Boolean run() {\r\n            return Boolean.valueOf(f.exists());\r\n        }\r\n    }).booleanValue();\r\n    return isNonEuroResJarExist;\r\n}"
}, {
	"Path": "sun.util.resources.LocaleData.isNonEuroLangSupported",
	"Comment": "returns true if the non european resources jar file exists in jreextension directory.",
	"Method": "boolean isNonEuroLangSupported(){\r\n    return Boolean.valueOf(f.exists());\r\n}"
}, {
	"Path": "java.util.Vector.ensureCapacityHelper",
	"Comment": "this implements the unsynchronized semantics of ensurecapacity.synchronized methods in this class can internally call thismethod for ensuring capacity without incurring the cost of anextra synchronization.",
	"Method": "void ensureCapacityHelper(int minCapacity){\r\n    if (minCapacity - elementData.length > 0)\r\n        grow(minCapacity);\r\n}"
}, {
	"Path": "java.util.Collections.reverse",
	"Comment": "reverses the order of the elements in the specified list.this method runs in linear time.",
	"Method": "void reverse(List<?> list){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.ComparableTimSort.gallopRight",
	"Comment": "like gallopleft, except that if the range contains an element equal tokey, gallopright returns the index after the rightmost equal element.",
	"Method": "int gallopRight(Comparable<Object> key,Object[] a,int base,int len,int hint){\r\n    assert len > 0 && hint >= 0 && hint < len;\r\n    int ofs = 1;\r\n    int lastOfs = 0;\r\n    if (key.compareTo(a[base + hint]) < 0) {\r\n        int maxOfs = hint + 1;\r\n        while (ofs < maxOfs && key.compareTo(a[base + hint - ofs]) < 0) {\r\n            lastOfs = ofs;\r\n            ofs = (ofs << 1) + 1;\r\n            if (ofs <= 0)\r\n                ofs = maxOfs;\r\n        }\r\n        if (ofs > maxOfs)\r\n            ofs = maxOfs;\r\n        int tmp = lastOfs;\r\n        lastOfs = hint - ofs;\r\n        ofs = hint - tmp;\r\n    } else {\r\n        int maxOfs = len - hint;\r\n        while (ofs < maxOfs && key.compareTo(a[base + hint + ofs]) >= 0) {\r\n            lastOfs = ofs;\r\n            ofs = (ofs << 1) + 1;\r\n            if (ofs <= 0)\r\n                ofs = maxOfs;\r\n        }\r\n        if (ofs > maxOfs)\r\n            ofs = maxOfs;\r\n        lastOfs += hint;\r\n        ofs += hint;\r\n    }\r\n    assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;\r\n    lastOfs++;\r\n    while (lastOfs < ofs) {\r\n        int m = lastOfs + ((ofs - lastOfs) >>> 1);\r\n        if (key.compareTo(a[base + m]) < 0)\r\n            ofs = m;\r\n        else\r\n            lastOfs = m + 1;\r\n    }\r\n    assert lastOfs == ofs;\r\n    return ofs;\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.TypecheckExecutor.interpretResults",
	"Comment": "reads the expected diagnostics for the given configuration and creates a typecheckresultwhich contains all of the missing and expected diagnostics",
	"Method": "TypecheckResult interpretResults(TestConfiguration config,CompilationResult compilationResult){\r\n    List<TestDiagnostic> expectedDiagnostics = readDiagnostics(config, compilationResult);\r\n    return TypecheckResult.fromCompilationResults(config, compilationResult, expectedDiagnostics);\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.ToIndexFileConverter.resolve",
	"Comment": "finds the fully qualified name of the class with the given name.",
	"Method": "String resolve(String className){\r\n    String qualifiedName;\r\n    Class<?> resolved = null;\r\n    if (pkgName.isEmpty()) {\r\n        qualifiedName = className;\r\n        resolved = loadClass(qualifiedName);\r\n        if (resolved == null) {\r\n            qualifiedName = \"java.lang.\" + className;\r\n            resolved = loadClass(qualifiedName);\r\n        }\r\n    } else {\r\n        qualifiedName = pkgName + \".\" + className;\r\n        resolved = loadClass(qualifiedName);\r\n        if (resolved == null) {\r\n            qualifiedName = className;\r\n            resolved = loadClass(qualifiedName);\r\n        }\r\n    }\r\n    if (resolved == null) {\r\n        for (String declName : imports) {\r\n            qualifiedName = mergeImport(declName, className);\r\n            if (qualifiedName != null) {\r\n                return qualifiedName;\r\n            }\r\n        }\r\n        return className;\r\n    }\r\n    return qualifiedName;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.putAll",
	"Comment": "copies all of the mappings from the specified map to this one.these mappings replace any mappings that this map had for any of thekeys currently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> m){\r\n    tryPresize(m.size());\r\n    for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) putVal(e.getKey(), e.getValue(), false);\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueTransfer.calculateNumericalUnaryOp",
	"Comment": "get the refined annotation after a numerical unary operation.",
	"Method": "AnnotationMirror calculateNumericalUnaryOp(Node operand,NumericalUnaryOps op,TransferInput<CFValue, CFStore> p){\r\n    if (!isIntRange(operand, p)) {\r\n        List<Number> resultValues = calculateValuesUnaryOp(operand, op, p);\r\n        return atypefactory.createNumberAnnotationMirror(resultValues);\r\n    } else {\r\n        Range resultRange = calculateRangeUnaryOp(operand, op, p);\r\n        return atypefactory.createIntRangeAnnotation(resultRange);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.trees.TreeBuilder.buildMethodInvocation",
	"Comment": "builds an ast tree to call a method designated by methodexpr, with one argument designated byargexpr.",
	"Method": "MethodInvocationTree buildMethodInvocation(ExpressionTree methodExpr,MethodInvocationTree buildMethodInvocation,ExpressionTree methodExpr,ExpressionTree argExpr){\r\n    return maker.App((JCTree.JCExpression) methodExpr, com.sun.tools.javac.util.List.of((JCTree.JCExpression) argExpr));\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.DefaultTypeHierarchy.isPrimarySubtype",
	"Comment": "compare the primary annotations of subtype and supertype. neither type can be missingannotations.",
	"Method": "boolean isPrimarySubtype(AnnotatedTypeMirror subtype,AnnotatedTypeMirror supertype,boolean isPrimarySubtype,AnnotatedTypeMirror subtype,AnnotatedTypeMirror supertype,boolean annosCanBeEmtpy){\r\n    final AnnotationMirror subtypeAnno = subtype.getAnnotationInHierarchy(currentTop);\r\n    final AnnotationMirror supertypeAnno = supertype.getAnnotationInHierarchy(currentTop);\r\n    return isAnnoSubtype(subtypeAnno, supertypeAnno, annosCanBeEmtpy);\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.UpperBoundVisitor.visitAnnotation",
	"Comment": "warns about ltlengthof annotations with arguments whose lengths do not match.",
	"Method": "Void visitAnnotation(AnnotationTree node,Void p){\r\n    AnnotationMirror anno = TreeUtils.annotationFromAnnotationTree(node);\r\n    if (AnnotationUtils.areSameByClass(anno, LTLengthOf.class)) {\r\n        List<? extends ExpressionTree> args = node.getArguments();\r\n        if (args.size() == 2) {\r\n            List<String> sequences = AnnotationUtils.getElementValueArray(anno, \"value\", String.class, true);\r\n            List<String> offsets = AnnotationUtils.getElementValueArray(anno, \"offset\", String.class, true);\r\n            if (sequences.size() != offsets.size() && offsets.size() > 0) {\r\n                checker.report(Result.failure(\"different.length.sequences.offsets\", sequences.size(), offsets.size()), node);\r\n                return null;\r\n            }\r\n        }\r\n    } else if (AnnotationUtils.areSameByClass(anno, HasSubsequence.class)) {\r\n        String seq = AnnotationUtils.getElementValue(anno, \"value\", String.class, true);\r\n        String from = AnnotationUtils.getElementValue(anno, \"from\", String.class, true);\r\n        String to = AnnotationUtils.getElementValue(anno, \"to\", String.class, true);\r\n        ClassTree enclosingClass = TreeUtils.enclosingClass(getCurrentPath());\r\n        FlowExpressionContext context = FlowExpressionContext.buildContextForClassDeclaration(enclosingClass, checker);\r\n        checkEffectivelyFinalAndParsable(seq, context, node);\r\n        checkEffectivelyFinalAndParsable(from, context, node);\r\n        checkEffectivelyFinalAndParsable(to, context, node);\r\n    }\r\n    return super.visitAnnotation(node, p);\r\n}"
}, {
	"Path": "org.camunda.bpm.qa.performance.engine.sqlstatementlog.StatementLogSqlSession.startLogging",
	"Comment": "starts logging any statements executed by the calling thread.",
	"Method": "void startLogging(){\r\n    threadStatementLog.set(new ArrayList<StatementLogSqlSession.SqlStatementLog>());\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TreeUtils.isTreeInStaticScope",
	"Comment": "returns whether or not the leaf of the tree path is in a static scope.",
	"Method": "boolean isTreeInStaticScope(TreePath path){\r\n    MethodTree enclosingMethod = TreeUtils.enclosingMethod(path);\r\n    if (enclosingMethod != null) {\r\n        return enclosingMethod.getModifiers().getFlags().contains(Modifier.STATIC);\r\n    }\r\n    BlockTree block = enclosingTopLevelBlock(path);\r\n    if (block != null) {\r\n        return block.isStatic();\r\n    }\r\n    Tree t = enclosingVariable(path);\r\n    if (t != null) {\r\n        return ((VariableTree) t).getModifiers().getFlags().contains(Modifier.STATIC);\r\n    }\r\n    ClassTree classTree = enclosingClass(path);\r\n    if (classTree != null) {\r\n        return classTree.getModifiers().getFlags().contains(Modifier.STATIC);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.QualifierHierarchy.getWidth",
	"Comment": "returns the width of this hierarchy, i.e. the expected number of annotations on any validtype.",
	"Method": "int getWidth(){\r\n    return getTopAnnotations().size();\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.QualifierHierarchy.updateMappingToMutableSet",
	"Comment": "update a mapping from some key to a set of annotationmirrors. if the key already exists inthe mapping and the new qualifier is in the same qualifier hierarchy as any of the existingqualifiers, do nothing and return false. if the key already exists in the mapping and the newqualifier is not in the same qualifier hierarchy as any of the existing qualifiers, add thequalifier to the existing set and return true. if the key does not exist in the mapping, addthe new qualifier as a singleton set and return true.",
	"Method": "boolean updateMappingToMutableSet(Map<T, Set<AnnotationMirror>> map,T key,AnnotationMirror newQual){\r\n    if (!map.containsKey(key)) {\r\n        Set<AnnotationMirror> set = AnnotationUtils.createAnnotationSet();\r\n        set.add(newQual);\r\n        map.put(key, set);\r\n    } else {\r\n        Set<AnnotationMirror> prevs = map.get(key);\r\n        for (AnnotationMirror p : prevs) {\r\n            if (AnnotationUtils.areSame(getTopAnnotation(p), getTopAnnotation(newQual))) {\r\n                return false;\r\n            }\r\n        }\r\n        prevs.add(newQual);\r\n        map.put(key, prevs);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "java.net.URL.writeObject",
	"Comment": "writeobject is called to save the state of the url to anobjectoutputstream. the handler is not saved since it isspecific to this system.",
	"Method": "void writeObject(java.io.ObjectOutputStream s){\r\n    s.defaultWriteObject();\r\n}"
}, {
	"Path": "java.io.CharArrayReader.reset",
	"Comment": "resets the stream to the most recent mark, or to the beginning if it hasnever been marked.",
	"Method": "void reset(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.BitSet.checkRange",
	"Comment": "checks that fromindex ... toindex is a valid range of bit indices.",
	"Method": "void checkRange(int fromIndex,int toIndex){\r\n    if (fromIndex < 0)\r\n        throw new IndexOutOfBoundsException(\"fromIndex < 0: \" + fromIndex);\r\n    if (toIndex < 0)\r\n        throw new IndexOutOfBoundsException(\"toIndex < 0: \" + toIndex);\r\n    if (fromIndex > toIndex)\r\n        throw new IndexOutOfBoundsException(\"fromIndex: \" + fromIndex + \" > toIndex: \" + toIndex);\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.model.ConfigurationLocationFactory.create",
	"Comment": "create a new location from a serialized string representation. for example when reading the plugin configurationxml.",
	"Method": "ConfigurationLocation create(Project project,ConfigurationType type,String location,String description,ConfigurationLocation create,Project project,String stringRepresentation,BundledConfigurationLocation create,BundledConfig bundledConfig,Project project){\r\n    return new BundledConfigurationLocation(bundledConfig, project);\r\n}"
}, {
	"Path": "org.checkerframework.common.util.debug.TypeOutputtingChecker.printClassType",
	"Comment": "prints the types of the class and all of its enclosing fields, methods, and inner classes.",
	"Method": "void printClassType(TypeElement typeElt,AnnotatedTypeFactory atypeFactory){\r\n    assert typeElt != null;\r\n    String simpleName = typeElt.getSimpleName().toString();\r\n    AnnotatedDeclaredType type = atypeFactory.fromElement(typeElt);\r\n    System.out.println(simpleName + \"\\t\" + type + \"\\t\" + type.directSuperTypes());\r\n    for (Element enclosedElt : typeElt.getEnclosedElements()) {\r\n        if (enclosedElt instanceof TypeElement) {\r\n            printClassType((TypeElement) enclosedElt, atypeFactory);\r\n        }\r\n        if (!enclosedElt.getKind().isField() && !(enclosedElt instanceof ExecutableElement)) {\r\n            continue;\r\n        }\r\n        AnnotatedTypeMirror memberType = atypeFactory.fromElement(enclosedElt);\r\n        System.out.println(simpleName + \".\" + enclosedElt + \"\\t\\t\" + memberType);\r\n    }\r\n}"
}, {
	"Path": "java.util.zip.InflaterInputStream.available",
	"Comment": "returns 0 after eof has been reached, otherwise always return 1.programs should not count on this method to return the actual numberof bytes that could be read without blocking.",
	"Method": "int available(){\r\n    ensureOpen();\r\n    if (reachEOF) {\r\n        return 0;\r\n    } else {\r\n        return 1;\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.LogManager.doSetParent",
	"Comment": "if necessary, we raise privilege before doing the setparent call.",
	"Method": "void doSetParent(Logger logger,Logger parent){\r\n    SecurityManager sm = System.getSecurityManager();\r\n    if (sm == null) {\r\n        logger.setParent(parent);\r\n        return;\r\n    }\r\n    AccessController.doPrivileged(new PrivilegedAction<Object>() {\r\n        public Object run() {\r\n            logger.setParent(parent);\r\n            return null;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "java.util.logging.LogManager.doSetParent",
	"Comment": "if necessary, we raise privilege before doing the setparent call.",
	"Method": "void doSetParent(Logger logger,Logger parent){\r\n    logger.setParent(parent);\r\n    return null;\r\n}"
}, {
	"Path": "org.checkerframework.checker.signedness.SignednessUtil.shortFromFloat",
	"Comment": "returns an unsigned short representing the same value as the float.",
	"Method": "short shortFromFloat(float f){\r\n    assert f >= 0;\r\n    return (short) f;\r\n}"
}, {
	"Path": "org.checkerframework.framework.flow.CFAbstractValue.getEffectTypeVar",
	"Comment": "returns the annotatedtypevariable associated with the given typemirror or null.if typemirror is a type variable, then the annotatedtypevariable return is the declarationof that typemirror. if the typemirror is a wildcard that extends a type variable, theannotatedtypevariable return is the declaration of that type variable. otherwise, null isreturned.",
	"Method": "AnnotatedTypeVariable getEffectTypeVar(TypeMirror typeMirror){\r\n    if (typeMirror == null) {\r\n        return null;\r\n    } else if (typeMirror.getKind() == TypeKind.WILDCARD) {\r\n        return getEffectTypeVar(((WildcardType) typeMirror).getExtendsBound());\r\n    } else if (typeMirror.getKind() == TypeKind.TYPEVAR) {\r\n        TypeVariable typevar = ((TypeVariable) typeMirror);\r\n        AnnotatedTypeMirror atm = analysis.getTypeFactory().getAnnotatedType(typevar.asElement());\r\n        return (AnnotatedTypeVariable) atm;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "java.util.jar.JarFile.entries2",
	"Comment": "returns an enumeration of the zip file entriesexcluding internal jar mechanism entries and includingsigned entries missing from the zip directory.",
	"Method": "Enumeration<JarEntry> entries2(){\r\n    ensureInitialization();\r\n    if (jv != null) {\r\n        return jv.entries2(this, super.entries());\r\n    }\r\n    final Enumeration enum_ = super.entries();\r\n    return new Enumeration<JarEntry>() {\r\n        ZipEntry entry;\r\n        public boolean hasMoreElements() {\r\n            if (entry != null) {\r\n                return true;\r\n            }\r\n            while (enum_.hasMoreElements()) {\r\n                ZipEntry ze = (ZipEntry) enum_.nextElement();\r\n                if (JarVerifier.isSigningRelated(ze.getName())) {\r\n                    continue;\r\n                }\r\n                entry = ze;\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n        public JarFileEntry nextElement() {\r\n            if (hasMoreElements()) {\r\n                ZipEntry ze = entry;\r\n                entry = null;\r\n                return new JarFileEntry(ze);\r\n            }\r\n            throw new NoSuchElementException();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "java.util.jar.JarFile.entries2",
	"Comment": "returns an enumeration of the zip file entriesexcluding internal jar mechanism entries and includingsigned entries missing from the zip directory.",
	"Method": "Enumeration<JarEntry> entries2(){\r\n    if (entry != null) {\r\n        return true;\r\n    }\r\n    while (enum_.hasMoreElements()) {\r\n        ZipEntry ze = (ZipEntry) enum_.nextElement();\r\n        if (JarVerifier.isSigningRelated(ze.getName())) {\r\n            continue;\r\n        }\r\n        entry = ze;\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.jar.JarFile.entries2",
	"Comment": "returns an enumeration of the zip file entriesexcluding internal jar mechanism entries and includingsigned entries missing from the zip directory.",
	"Method": "Enumeration<JarEntry> entries2(){\r\n    if (hasMoreElements()) {\r\n        ZipEntry ze = entry;\r\n        entry = null;\r\n        return new JarFileEntry(ze);\r\n    }\r\n    throw new NoSuchElementException();\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.CheckerMain.extractOptWithPattern",
	"Comment": "find all args that match the given pattern and extract their index 1 group. add all the index1 groups to the returned list. remove all matching args from the input args list.",
	"Method": "List<String> extractOptWithPattern(Pattern pattern,boolean allowEmpties,List<String> args){\r\n    final List<String> matchedArgs = new ArrayList();\r\n    int i = 0;\r\n    while (i < args.size()) {\r\n        final Matcher matcher = pattern.matcher(args.get(i));\r\n        if (matcher.matches()) {\r\n            final String arg = matcher.group(1).trim();\r\n            if (!arg.isEmpty() || allowEmpties) {\r\n                matchedArgs.add(arg);\r\n            }\r\n            args.remove(i);\r\n        } else {\r\n            i++;\r\n        }\r\n    }\r\n    return matchedArgs;\r\n}"
}, {
	"Path": "sun.nio.ch.Util.releaseTemporaryDirectBuffer",
	"Comment": "releases a temporary buffer by returning to the cache or freeing it.",
	"Method": "void releaseTemporaryDirectBuffer(ByteBuffer buf){\r\n    offerFirstTemporaryDirectBuffer(buf);\r\n}"
}, {
	"Path": "java.beans.PropertyDescriptor.setPropertyEditorClass",
	"Comment": "normally propertyeditors will be found using the propertyeditormanager.however if for some reason you want to associate a particularpropertyeditor with a given property, then you can do it withthis method.",
	"Method": "void setPropertyEditorClass(Class<?> propertyEditorClass){\r\n    this.propertyEditorClassRef = getWeakReference(propertyEditorClass);\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeMirror.addMissingAnnotations",
	"Comment": "adds those annotations to the current type, for which no annotation from the same qualifierhierarchy is present.",
	"Method": "void addMissingAnnotations(Iterable<? extends AnnotationMirror> annotations){\r\n    for (AnnotationMirror a : annotations) {\r\n        if (!this.isAnnotatedInHierarchy(a)) {\r\n            this.addAnnotation(a);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.PriorityQueue.siftDown",
	"Comment": "inserts item x at position k, maintaining heap invariant bydemoting x down the tree repeatedly until it is less than orequal to its children or is a leaf.",
	"Method": "void siftDown(int k,E x){\r\n    if (comparator != null)\r\n        siftDownUsingComparator(k, x);\r\n    else\r\n        siftDownComparable(k, x);\r\n}"
}, {
	"Path": "java.util.jar.JarFile.getEntry",
	"Comment": "returns the zipentry for the given entry name ornull if not found.",
	"Method": "ZipEntry getEntry(String name){\r\n    ZipEntry ze = super.getEntry(name);\r\n    if (ze != null) {\r\n        return new JarFileEntry(ze);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.util.logging.Logger.getResourceBundleName",
	"Comment": "retrieve the localization resource bundle name for thislogger.note that if the result is null, then the loggerwill use a resource bundle name inherited from its parent.",
	"Method": "String getResourceBundleName(){\r\n    return resourceBundleName;\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TypesUtils.isErasedSubtype",
	"Comment": "returns true if the erased type of subtype is a subtype of the erased type of supertype.",
	"Method": "boolean isErasedSubtype(TypeMirror subtype,TypeMirror supertype,Types types){\r\n    return types.isSubtype(types.erasure(subtype), types.erasure(supertype));\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.AnnotatedTypes.glbOfBounds",
	"Comment": "gets the lowest primary annotation of all bounds in the intersection.",
	"Method": "Set<AnnotationMirror> glbOfBounds(AnnotatedIntersectionType isect,QualifierHierarchy qualifierHierarchy){\r\n    Set<AnnotationMirror> result = AnnotationUtils.createAnnotationSet();\r\n    for (final AnnotationMirror top : qualifierHierarchy.getTopAnnotations()) {\r\n        final AnnotationMirror glbAnno = glbOfBoundsInHierarchy(isect, top, qualifierHierarchy);\r\n        if (glbAnno != null) {\r\n            result.add(glbAnno);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "java.util.TimSort.mergeForceCollapse",
	"Comment": "merges all runs on the stack until only one remains.this method iscalled once, to complete the sort.",
	"Method": "void mergeForceCollapse(){\r\n    while (stackSize > 1) {\r\n        int n = stackSize - 2;\r\n        if (n > 0 && runLen[n - 1] < runLen[n + 1])\r\n            n--;\r\n        mergeAt(n);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.element.TypeVarUseApplier.getAnnotations",
	"Comment": "depending on what element type the annotations are stored on, the relevant annotations mightbe stored with different annotation positions. getannotations finds the correct annotationsby annotation position and element kind and returns them",
	"Method": "List<Attribute.TypeCompound> getAnnotations(Element useElem,Element declarationElem){\r\n    final List<Attribute.TypeCompound> annotations;\r\n    switch(useElem.getKind()) {\r\n        case METHOD:\r\n            annotations = getReturnAnnos(useElem);\r\n            break;\r\n        case PARAMETER:\r\n            annotations = getParameterAnnos(useElem);\r\n            break;\r\n        case FIELD:\r\n        case LOCAL_VARIABLE:\r\n        case RESOURCE_VARIABLE:\r\n            annotations = getVariableAnnos(useElem);\r\n            break;\r\n        default:\r\n            throw new BugInCF(\"TypeVarUseApplier::extractAndApply : \" + \"Unhandled element kind \" + useElem.getKind() + \"useElem ( \" + useElem + \" ) \" + \"declarationElem ( \" + declarationElem + \" ) \");\r\n    }\r\n    return annotations;\r\n}"
}, {
	"Path": "java.io.File.getTotalSpace",
	"Comment": "returns the size of the partition named by thisabstract pathname.",
	"Method": "long getTotalSpace(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceEntriesToLong",
	"Comment": "returns the result of accumulating the given transformationof all entries using the given reducer to combine values,and the given basis as an identity value.",
	"Method": "long reduceEntriesToLong(long parallelismThreshold,ToLongFunction<Map.Entry<K, V>> transformer,long basis,LongBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceEntriesToLongTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "org.checkerframework.common.reflection.DefaultReflectionResolver.resolveReflectiveMethod",
	"Comment": "resolves a reflective method call and returns all possible corresponding method calls.",
	"Method": "List<MethodInvocationTree> resolveReflectiveMethod(MethodInvocationTree tree,AnnotatedTypeFactory reflectionFactory){\r\n    assert isReflectiveMethodInvocation(tree);\r\n    JCMethodInvocation methodInvocation = (JCMethodInvocation) tree;\r\n    Context context = ((JavacProcessingEnvironment) processingEnv).getContext();\r\n    TreeMaker make = TreeMaker.instance(context);\r\n    TreePath path = reflectionFactory.getPath(tree);\r\n    JavacScope scope = (JavacScope) trees.getScope(path);\r\n    Env<AttrContext> env = scope.getEnv();\r\n    List<MethodInvocationTree> methods = new ArrayList();\r\n    boolean unknown = isUnknownMethod(tree);\r\n    AnnotationMirror estimate = getMethodVal(tree);\r\n    if (estimate == null) {\r\n        debugReflection(\"MethodVal is unknown for: \" + tree);\r\n        debugReflection(\"UnknownMethod annotation: \" + unknown);\r\n        return methods;\r\n    }\r\n    debugReflection(\"MethodVal type system annotations: \" + estimate);\r\n    List<String> listClassNames = AnnotationUtils.getElementValueArray(estimate, \"className\", String.class, true);\r\n    List<String> listMethodNames = AnnotationUtils.getElementValueArray(estimate, \"methodName\", String.class, true);\r\n    List<Integer> listParamLenghts = AnnotationUtils.getElementValueArray(estimate, \"params\", Integer.class, true);\r\n    assert listClassNames.size() == listMethodNames.size() && listClassNames.size() == listParamLenghts.size();\r\n    for (int i = 0; i < listClassNames.size(); ++i) {\r\n        String className = listClassNames.get(i);\r\n        String methodName = listMethodNames.get(i);\r\n        int paramLength = listParamLenghts.get(i);\r\n        JCExpression receiver = methodInvocation.args.head;\r\n        com.sun.tools.javac.util.List<JCExpression> args = methodInvocation.args.tail;\r\n        for (Symbol symbol : getMethodSymbolsfor(className, methodName, paramLength, env)) {\r\n            if (!processingEnv.getTypeUtils().isSubtype(receiver.type, symbol.owner.type)) {\r\n                continue;\r\n            }\r\n            if ((symbol.flags() & Flags.PUBLIC) > 0) {\r\n                debugReflection(\"Resolved public method: \" + symbol.owner + \".\" + symbol);\r\n            } else {\r\n                debugReflection(\"Resolved non-public method: \" + symbol.owner + \".\" + symbol);\r\n            }\r\n            JCExpression method = make.Select(receiver, symbol);\r\n            args = getCorrectedArgs(symbol, args);\r\n            JCMethodInvocation syntTree = paramLength > 0 ? make.App(method, args) : make.App(method);\r\n            methods.add(syntTree);\r\n        }\r\n    }\r\n    return methods;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.element.ElementAnnotationUtil.addAnnotationsFromElement",
	"Comment": "when a declaration annotation is an alias for a type annotation, then the checker frameworkmay move the annotation before replacing it by the canonical version.if the annotation is one of the checker framework compatibility annotations, for exampleorg.checkerframework.checker.nullness.compatqual.nonnulldecl, then it is interpreted as atype annotation in the same location.",
	"Method": "void addAnnotationsFromElement(AnnotatedTypeMirror type,List<? extends AnnotationMirror> annotations){\r\n    AnnotatedTypeMirror innerType = AnnotatedTypes.innerMostType(type);\r\n    if (innerType != type) {\r\n        for (AnnotationMirror annotation : annotations) {\r\n            if (AnnotationUtils.annotationName(annotation).startsWith(\"org.checkerframework\")) {\r\n                innerType.addAnnotation(annotation);\r\n            } else {\r\n                type.addAnnotation(annotation);\r\n            }\r\n        }\r\n    } else {\r\n        type.addAnnotations(annotations);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.solver.SupertypesSolver.lubPrimaries",
	"Comment": "for each qualifier hierarchy in tops, take the lub of the annos in subtypeannos thatcorrespond to that hierarchy place the lub in lubofprimaries.",
	"Method": "void lubPrimaries(AnnotationMirrorMap<AnnotationMirror> lubOfPrimaries,AnnotationMirrorMap<AnnotationMirrorSet> subtypeAnnos,AnnotationMirrorSet tops,QualifierHierarchy qualifierHierarchy){\r\n    lubOfPrimaries.clear();\r\n    for (final AnnotationMirror top : tops) {\r\n        final AnnotationMirrorSet annosInHierarchy = subtypeAnnos.get(top);\r\n        if (annosInHierarchy != null && !annosInHierarchy.isEmpty()) {\r\n            lubOfPrimaries.put(top, leastUpperBound(annosInHierarchy, qualifierHierarchy));\r\n        } else {\r\n            lubOfPrimaries.put(top, qualifierHierarchy.getBottomAnnotation(top));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.LogRecord.getResourceBundleName",
	"Comment": "get the localization resource bundle namethis is the name for the resourcebundle that should beused to localize the message string before formatting it.the result may be null if the message is not localizable.",
	"Method": "String getResourceBundleName(){\r\n    return resourceBundleName;\r\n}"
}, {
	"Path": "java.io.DataOutputStream.writeChars",
	"Comment": "writes a string to the underlying output stream as a sequence ofcharacters. each character is written to the data output stream asif by the writechar method. if no exception isthrown, the counter written is incremented by twicethe length of s.",
	"Method": "void writeChars(String s){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.AuthorDTOService.toEntity",
	"Comment": "converts the passed dto to a author.convenient for query by example.",
	"Method": "Author toEntity(AuthorDTO dto,Author toEntity,AuthorDTO dto,int depth){\r\n    if (dto == null) {\r\n        return null;\r\n    }\r\n    Author author = new Author();\r\n    author.setId(dto.id);\r\n    author.setCivility(dto.civility);\r\n    author.setLastName(dto.lastName);\r\n    author.setFirstName(dto.firstName);\r\n    author.setEmail(dto.email);\r\n    author.setBirthDate(dto.birthDate);\r\n    author.setBirthDateTime(dto.birthDateTime);\r\n    if (depth-- > 0) {\r\n        author.setFavoriteAuthor(toEntity(dto.favoriteAuthor, depth));\r\n    }\r\n    return author;\r\n}"
}, {
	"Path": "java.util.zip.Inflater.needsDictionary",
	"Comment": "returns true if a preset dictionary is needed for decompression.",
	"Method": "boolean needsDictionary(){\r\n    synchronized (zsRef) {\r\n        return needDict;\r\n    }\r\n}"
}, {
	"Path": "java.awt.image.ColorModel.isCompatibleRaster",
	"Comment": "returns true if raster is compatible with this colormodel and false if it is not. since colormodel is an abstract class, any instance is an instance of a subclass.subclasses must override this method since the implementation in this abstract class throws an unsupportedoperationexception.",
	"Method": "boolean isCompatibleRaster(Raster raster){\r\n    throw new UnsupportedOperationException(\"This method has not been implemented for this ColorModel.\");\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.classNamesEqual",
	"Comment": "compares class names for equality, ignoring package names.returns trueif class names equal, false otherwise.",
	"Method": "boolean classNamesEqual(String name1,String name2){\r\n    name1 = name1.substring(name1.lastIndexOf('.') + 1);\r\n    name2 = name2.substring(name2.lastIndexOf('.') + 1);\r\n    return name1.equals(name2);\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.UpperBoundAnnotatedTypeFactory.hasLowerBoundTypeByClass",
	"Comment": "returns true iff the given node has the passed lower bound qualifier according to the lbc.the last argument should be positive.class, nonnegative.class, or gtenegativeone.class.",
	"Method": "boolean hasLowerBoundTypeByClass(Node node,Class<? extends Annotation> classOfType){\r\n    return AnnotationUtils.areSameByClass(getLowerBoundAnnotatedTypeFactory().getAnnotatedType(node.getTree()).getAnnotationInHierarchy(getLowerBoundAnnotatedTypeFactory().UNKNOWN), classOfType);\r\n}"
}, {
	"Path": "org.checkerframework.common.basetype.BaseTypeVisitor.shouldPrintVerbose",
	"Comment": "return whether or not the verbose tostring should be used when printing the two annotatedtypes.",
	"Method": "boolean shouldPrintVerbose(AnnotatedTypeMirror atm1,AnnotatedTypeMirror atm2){\r\n    String atm1ToString = atm1.toString();\r\n    String atm2ToString = atm2.toString();\r\n    if (atm2ToString.equals(atm1ToString) || (!atm2ToString.contains(\"@\") && !atm1ToString.contains(\"@\"))) {\r\n        return true;\r\n    }\r\n    SimpleAnnotatedTypeScanner<Boolean, Void> checkForMismatchedToStrings = new SimpleAnnotatedTypeScanner<Boolean, Void>() {\r\n        Map<String, String> map = new HashMap();\r\n        @Override\r\n        protected Boolean reduce(Boolean r1, Boolean r2) {\r\n            r1 = r1 == null ? false : r1;\r\n            r2 = r2 == null ? false : r2;\r\n            return r1 || r2;\r\n        }\r\n        @Override\r\n        protected Boolean defaultAction(AnnotatedTypeMirror type, Void avoid) {\r\n            if (type == null) {\r\n                return false;\r\n            }\r\n            String simple = type.toString();\r\n            String verbose = map.get(simple);\r\n            if (verbose == null) {\r\n                map.put(simple, type.toString(true));\r\n                return false;\r\n            } else {\r\n                return !verbose.equals(type.toString(true));\r\n            }\r\n        }\r\n    };\r\n    Boolean r1 = checkForMismatchedToStrings.visit(atm1);\r\n    if (r1 != null && r1) {\r\n        return true;\r\n    }\r\n    checkForMismatchedToStrings.reset();\r\n    Boolean r2 = checkForMismatchedToStrings.visit(atm2);\r\n    return r2 == null ? false : r2;\r\n}"
}, {
	"Path": "org.checkerframework.common.basetype.BaseTypeVisitor.shouldPrintVerbose",
	"Comment": "return whether or not the verbose tostring should be used when printing the two annotatedtypes.",
	"Method": "boolean shouldPrintVerbose(AnnotatedTypeMirror atm1,AnnotatedTypeMirror atm2){\r\n    r1 = r1 == null ? false : r1;\r\n    r2 = r2 == null ? false : r2;\r\n    return r1 || r2;\r\n}"
}, {
	"Path": "org.checkerframework.common.basetype.BaseTypeVisitor.shouldPrintVerbose",
	"Comment": "return whether or not the verbose tostring should be used when printing the two annotatedtypes.",
	"Method": "boolean shouldPrintVerbose(AnnotatedTypeMirror atm1,AnnotatedTypeMirror atm2){\r\n    if (type == null) {\r\n        return false;\r\n    }\r\n    String simple = type.toString();\r\n    String verbose = map.get(simple);\r\n    if (verbose == null) {\r\n        map.put(simple, type.toString(true));\r\n        return false;\r\n    } else {\r\n        return !verbose.equals(type.toString(true));\r\n    }\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.unpackTimes",
	"Comment": "unpack the start and end times from an array of bytes.this is requiredas of serial version 2.",
	"Method": "void unpackTimes(int[] times){\r\n    startTime = times[0];\r\n    endTime = times[1];\r\n}"
}, {
	"Path": "java.lang.ClassLoader.getPackages",
	"Comment": "returns all of the packages defined by this class loader andits ancestors.",
	"Method": "Package[] getPackages(){\r\n    Map<String, Package> map;\r\n    synchronized (packages) {\r\n        map = new HashMap(packages);\r\n    }\r\n    Package[] pkgs;\r\n    if (parent != null) {\r\n        pkgs = parent.getPackages();\r\n    } else {\r\n        pkgs = Package.getSystemPackages();\r\n    }\r\n    if (pkgs != null) {\r\n        for (int i = 0; i < pkgs.length; i++) {\r\n            String pkgName = pkgs[i].getName();\r\n            if (map.get(pkgName) == null) {\r\n                map.put(pkgName, pkgs[i]);\r\n            }\r\n        }\r\n    }\r\n    return map.values().toArray(new Package[map.size()]);\r\n}"
}, {
	"Path": "sun.misc.FormattedFloatingDecimal.getExponentRounded",
	"Comment": "returns the exponent after rounding has been done by applyprecision",
	"Method": "int getExponentRounded(){\r\n    return decExponentRounded - 1;\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.CalendarSerializer.writeReplace",
	"Comment": "java.util.calendar serializes to com.alibaba.citrus.hessian.io.calendarhandle",
	"Method": "Object writeReplace(Object obj){\r\n    Calendar cal = (Calendar) obj;\r\n    return new CalendarHandle(cal.getClass(), cal.getTimeInMillis());\r\n}"
}, {
	"Path": "java.io.ByteArrayOutputStream.close",
	"Comment": "closing a bytearrayoutputstream has no effect. the methods inthis class can be called after the stream has been closed withoutgenerating an ioexception.",
	"Method": "void close(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.getDSTSavings",
	"Comment": "returns the amount of time in milliseconds that the clock isadvanced during daylight saving time.",
	"Method": "int getDSTSavings(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueTransfer.createAnnotationFromRangeAndAddToStore",
	"Comment": "takes a range and creates the appropriate annotation from it, then combines that annotationwith the existing annotation on the node. the resulting annotation is inserted into thestore.",
	"Method": "void createAnnotationFromRangeAndAddToStore(CFStore store,Range range,Node node){\r\n    AnnotationMirror anno = atypefactory.createIntRangeAnnotation(range);\r\n    addAnnotationToStore(store, anno, node);\r\n}"
}, {
	"Path": "com.mycompany.myapp.domain.UseCase1Pk.areFieldsSet",
	"Comment": "helper to determine if this composite primary key is fully set.",
	"Method": "boolean areFieldsSet(){\r\n    return isId1Set() && isId2Set();\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.solver.ConstraintMap.addTargetSubtype",
	"Comment": "add a constraint indicating that target is a subtype of supertype in the given qualifierhierarchies.",
	"Method": "void addTargetSubtype(TypeVariable target,TypeVariable supertype,AnnotationMirrorSet hierarchies){\r\n    final Subtypes subtypes = targetToRecords.get(target).subtypes;\r\n    final AnnotationMirrorSet subtypesTops = subtypes.targets.get(supertype);\r\n    if (subtypesTops == null) {\r\n        subtypes.targets.put(supertype, new AnnotationMirrorSet(hierarchies));\r\n    } else {\r\n        subtypesTops.addAll(hierarchies);\r\n    }\r\n}"
}, {
	"Path": "java.lang.AbstractStringBuilder.substring",
	"Comment": "returns a new string that contains a subsequence ofcharacters currently contained in this character sequence. thesubstring begins at the specified index and extends to the end ofthis sequence.",
	"Method": "String substring(int start,String substring,int start,int end){\r\n    if (start < 0)\r\n        throw new StringIndexOutOfBoundsException(start);\r\n    if (end > count)\r\n        throw new StringIndexOutOfBoundsException(end);\r\n    if (start > end)\r\n        throw new StringIndexOutOfBoundsException(end - start);\r\n    return new String(value, start, end - start);\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.TypeArgInferenceUtil.assignedTo",
	"Comment": "returns the annotated type that the leaf of path is assigned to, if it is within anassignment context. returns the annotated type that the method invocation at the leaf isassigned to. if the result is a primitive, return the boxed version.",
	"Method": "AnnotatedTypeMirror assignedTo(AnnotatedTypeFactory atypeFactory,TreePath path){\r\n    Tree assignmentContext = TreeUtils.getAssignmentContext(path);\r\n    AnnotatedTypeMirror res;\r\n    if (assignmentContext == null) {\r\n        res = null;\r\n    } else if (assignmentContext instanceof AssignmentTree) {\r\n        ExpressionTree variable = ((AssignmentTree) assignmentContext).getVariable();\r\n        res = atypeFactory.getAnnotatedType(variable);\r\n    } else if (assignmentContext instanceof CompoundAssignmentTree) {\r\n        ExpressionTree variable = ((CompoundAssignmentTree) assignmentContext).getVariable();\r\n        res = atypeFactory.getAnnotatedType(variable);\r\n    } else if (assignmentContext instanceof MethodInvocationTree) {\r\n        MethodInvocationTree methodInvocation = (MethodInvocationTree) assignmentContext;\r\n        if (methodInvocation.getMethodSelect() instanceof MemberSelectTree && ((MemberSelectTree) methodInvocation.getMethodSelect()).getExpression() == path.getLeaf()) {\r\n            return null;\r\n        }\r\n        ExecutableElement methodElt = TreeUtils.elementFromUse(methodInvocation);\r\n        AnnotatedTypeMirror receiver = atypeFactory.getReceiverType(methodInvocation);\r\n        res = assignedToExecutable(atypeFactory, path, methodElt, receiver, methodInvocation.getArguments());\r\n    } else if (assignmentContext instanceof NewArrayTree) {\r\n        res = null;\r\n    } else if (assignmentContext instanceof NewClassTree) {\r\n        NewClassTree newClassTree = (NewClassTree) assignmentContext;\r\n        ExecutableElement constructorElt = TreeUtils.constructor(newClassTree);\r\n        AnnotatedTypeMirror receiver = atypeFactory.fromNewClass(newClassTree);\r\n        res = assignedToExecutable(atypeFactory, path, constructorElt, receiver, newClassTree.getArguments());\r\n    } else if (assignmentContext instanceof ReturnTree) {\r\n        HashSet<Kind> kinds = new HashSet(Arrays.asList(Kind.LAMBDA_EXPRESSION, Kind.METHOD));\r\n        Tree enclosing = TreeUtils.enclosingOfKind(path, kinds);\r\n        if (enclosing.getKind() == Kind.METHOD) {\r\n            res = atypeFactory.getAnnotatedType((MethodTree) enclosing).getReturnType();\r\n        } else {\r\n            Pair<AnnotatedDeclaredType, AnnotatedExecutableType> fninf = atypeFactory.getFnInterfaceFromTree((LambdaExpressionTree) enclosing);\r\n            res = fninf.second.getReturnType();\r\n        }\r\n    } else if (assignmentContext instanceof VariableTree) {\r\n        res = assignedToVariable(atypeFactory, assignmentContext);\r\n    } else {\r\n        throw new BugInCF(\"AnnotatedTypes.assignedTo: shouldn't be here\");\r\n    }\r\n    if (res != null && TypesUtils.isPrimitive(res.getUnderlyingType())) {\r\n        return atypeFactory.getBoxedType((AnnotatedPrimitiveType) res);\r\n    } else {\r\n        return res;\r\n    }\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.util.IdentityIntMap.put",
	"Comment": "puts a new value in the property table with the appropriate flags",
	"Method": "int put(Object key,int value,boolean isReplace){\r\n    int prime = _prime;\r\n    int hash = System.identityHashCode(key) % prime;\r\n    Object[] keys = _keys;\r\n    while (true) {\r\n        Object testKey = keys[hash];\r\n        if (testKey == null) {\r\n            keys[hash] = key;\r\n            _values[hash] = value;\r\n            _size++;\r\n            if (keys.length <= 4 * _size) {\r\n                resize(4 * keys.length);\r\n            }\r\n            return value;\r\n        } else if (key != testKey) {\r\n            hash = (hash + 1) % prime;\r\n            continue;\r\n        } else if (isReplace) {\r\n            int old = _values[hash];\r\n            _values[hash] = value;\r\n            return old;\r\n        } else {\r\n            return _values[hash];\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.net.URLClassLoader.findClass",
	"Comment": "finds and loads the class with the specified name from the url searchpath. any urls referring to jar files are loaded and opened as neededuntil the class is found.",
	"Method": "Class<?> findClass(String name){\r\n    try {\r\n        return AccessController.doPrivileged(new PrivilegedExceptionAction<Class<?>>() {\r\n            public Class<?> run() throws ClassNotFoundException {\r\n                String path = name.replace('.', '/').concat(\".class\");\r\n                Resource res = ucp.getResource(path, false);\r\n                if (res != null) {\r\n                    try {\r\n                        return defineClass(name, res);\r\n                    } catch (IOException e) {\r\n                        throw new ClassNotFoundException(name, e);\r\n                    }\r\n                } else {\r\n                    throw new ClassNotFoundException(name);\r\n                }\r\n            }\r\n        }, acc);\r\n    } catch (java.security.PrivilegedActionException pae) {\r\n        throw (ClassNotFoundException) pae.getException();\r\n    }\r\n}"
}, {
	"Path": "java.net.URLClassLoader.findClass",
	"Comment": "finds and loads the class with the specified name from the url searchpath. any urls referring to jar files are loaded and opened as neededuntil the class is found.",
	"Method": "Class<?> findClass(String name){\r\n    String path = name.replace('.', '/').concat(\".class\");\r\n    Resource res = ucp.getResource(path, false);\r\n    if (res != null) {\r\n        try {\r\n            return defineClass(name, res);\r\n        } catch (IOException e) {\r\n            throw new ClassNotFoundException(name, e);\r\n        }\r\n    } else {\r\n        throw new ClassNotFoundException(name);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.checker.signedness.SignednessUtil.intFromFloat",
	"Comment": "returns an unsigned int representing the same value as the float.",
	"Method": "int intFromFloat(float f){\r\n    assert f >= 0;\r\n    return (int) f;\r\n}"
}, {
	"Path": "com.alibaba.citrus.generictype.codegen.asm.Type.getReturnType",
	"Comment": "returns the java type corresponding to the return type of the givenmethod.",
	"Method": "Type getReturnType(String methodDescriptor,Type getReturnType,Method method){\r\n    return getType(method.getReturnType());\r\n}"
}, {
	"Path": "java.util.ArrayList.fastRemove",
	"Comment": "private remove method that skips bounds checking and does notreturn the value removed.",
	"Method": "void fastRemove(int index){\r\n    modCount++;\r\n    int numMoved = size - index - 1;\r\n    if (numMoved > 0)\r\n        System.arraycopy(elementData, index + 1, elementData, index, numMoved);\r\n    elementData[--size] = null;\r\n}"
}, {
	"Path": "org.camunda.bpm.integrationtest.functional.database.PurgeDatabaseTest.assertAndEnsureCleanDb",
	"Comment": "ensures that the database is clean after the test. this means the test has to removeall resources it entered to the database.if the db is not clean, it is cleaned by performing a create a drop.",
	"Method": "void assertAndEnsureCleanDb(ProcessEngine processEngine){\r\n    ProcessEngineConfigurationImpl processEngineConfiguration = ((ProcessEngineImpl) processEngine).getProcessEngineConfiguration();\r\n    String databaseTablePrefix = processEngineConfiguration.getDatabaseTablePrefix().trim();\r\n    Map<String, Long> tableCounts = processEngine.getManagementService().getTableCount();\r\n    StringBuilder outputMessage = new StringBuilder();\r\n    for (String tableName : tableCounts.keySet()) {\r\n        String tableNameWithoutPrefix = tableName.replace(databaseTablePrefix, \"\");\r\n        if (!TABLENAMES_EXCLUDED_FROM_DB_CLEAN_CHECK.contains(tableNameWithoutPrefix)) {\r\n            Long count = tableCounts.get(tableName);\r\n            if (count != 0L) {\r\n                outputMessage.append(\"\\t\").append(tableName).append(\": \").append(count).append(\" record(s)\\n\");\r\n            }\r\n        }\r\n    }\r\n    if (outputMessage.length() > 0) {\r\n        outputMessage.insert(0, \"DB NOT CLEAN: \\n\");\r\n        if (databaseTablePrefix.isEmpty()) {\r\n            processEngineConfiguration.getCommandExecutorSchemaOperations().execute(new Command<Object>() {\r\n                public Object execute(CommandContext commandContext) {\r\n                    PersistenceSession persistenceSession = commandContext.getSession(PersistenceSession.class);\r\n                    persistenceSession.dbSchemaDrop();\r\n                    persistenceSession.dbSchemaCreate();\r\n                    HistoryLevelSetupCommand.dbCreateHistoryLevel(commandContext);\r\n                    return null;\r\n                }\r\n            });\r\n        }\r\n        Assert.fail(outputMessage.toString());\r\n    }\r\n}"
}, {
	"Path": "org.camunda.bpm.integrationtest.functional.database.PurgeDatabaseTest.assertAndEnsureCleanDb",
	"Comment": "ensures that the database is clean after the test. this means the test has to removeall resources it entered to the database.if the db is not clean, it is cleaned by performing a create a drop.",
	"Method": "void assertAndEnsureCleanDb(ProcessEngine processEngine){\r\n    PersistenceSession persistenceSession = commandContext.getSession(PersistenceSession.class);\r\n    persistenceSession.dbSchemaDrop();\r\n    persistenceSession.dbSchemaCreate();\r\n    HistoryLevelSetupCommand.dbCreateHistoryLevel(commandContext);\r\n    return null;\r\n}"
}, {
	"Path": "java.util.logging.LogManager.parseClassNames",
	"Comment": "get a list of whitespace separated classnames from a property.",
	"Method": "String[] parseClassNames(String propertyName){\r\n    String hands = getProperty(propertyName);\r\n    if (hands == null) {\r\n        return new String[0];\r\n    }\r\n    hands = hands.trim();\r\n    int ix = 0;\r\n    Vector<String> result = new Vector();\r\n    while (ix < hands.length()) {\r\n        int end = ix;\r\n        while (end < hands.length()) {\r\n            if (Character.isWhitespace(hands.charAt(end))) {\r\n                break;\r\n            }\r\n            if (hands.charAt(end) == ',') {\r\n                break;\r\n            }\r\n            end++;\r\n        }\r\n        String word = hands.substring(ix, end);\r\n        ix = end + 1;\r\n        word = word.trim();\r\n        if (word.length() == 0) {\r\n            continue;\r\n        }\r\n        result.add(word);\r\n    }\r\n    return result.toArray(new String[result.size()]);\r\n}"
}, {
	"Path": "org.checkerframework.common.basetype.BaseTypeChecker.printMessage",
	"Comment": "if this is a compound checker or a subchecker of a compound checker, then the message isstored until all messages from all checkers for the compilation unit are issued.otherwise, it prints the message.",
	"Method": "void printMessage(Diagnostic.Kind kind,String message,Tree source,CompilationUnitTree root){\r\n    assert this.currentRoot == root;\r\n    if (messageStore == null) {\r\n        super.printMessage(kind, message, source, root);\r\n    } else {\r\n        CheckerMessage checkerMessage = new CheckerMessage(kind, message, source, this);\r\n        messageStore.add(checkerMessage);\r\n    }\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.writeSerialData",
	"Comment": "writes instance data for each serializable class of given object, fromsuperclass to subclass.",
	"Method": "void writeSerialData(Object obj,ObjectStreamClass desc){\r\n    ObjectStreamClass.ClassDataSlot[] slots = desc.getClassDataLayout();\r\n    for (int i = 0; i < slots.length; i++) {\r\n        ObjectStreamClass slotDesc = slots[i].desc;\r\n        if (slotDesc.hasWriteObjectMethod()) {\r\n            PutFieldImpl oldPut = curPut;\r\n            curPut = null;\r\n            SerialCallbackContext oldContext = curContext;\r\n            if (extendedDebugInfo) {\r\n                debugInfoStack.push(\"custom writeObject data (class \\\"\" + slotDesc.getName() + \"\\\")\");\r\n            }\r\n            try {\r\n                curContext = new SerialCallbackContext(obj, slotDesc);\r\n                bout.setBlockDataMode(true);\r\n                slotDesc.invokeWriteObject(obj, this);\r\n                bout.setBlockDataMode(false);\r\n                bout.writeByte(TC_ENDBLOCKDATA);\r\n            } finally {\r\n                curContext.setUsed();\r\n                curContext = oldContext;\r\n                if (extendedDebugInfo) {\r\n                    debugInfoStack.pop();\r\n                }\r\n            }\r\n            curPut = oldPut;\r\n        } else {\r\n            defaultWriteFields(obj, slotDesc);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.getQualifierHierarchy",
	"Comment": "returns the type qualifier hierarchy graph to be used by this processor.",
	"Method": "QualifierHierarchy getQualifierHierarchy(){\r\n    return qualHierarchy;\r\n}"
}, {
	"Path": "org.xml.sax.InputSource.setCharacterStream",
	"Comment": "set the character stream for this input source.if there is a character stream specified, the sax parserwill ignore any byte stream and will not attempt to opena uri connection to the system identifier.",
	"Method": "void setCharacterStream(Reader characterStream){\r\n    this.characterStream = characterStream;\r\n}"
}, {
	"Path": "java.io.Console.readPassword",
	"Comment": "reads a password or passphrase from the console with echoing disabled",
	"Method": "char[] readPassword(String fmt,Object args,char[] readPassword){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.computeFieldOffsets",
	"Comment": "calculates and sets serializable field offsets, as well as primitivedata size and object field count totals.throws invalidclassexceptionif fields are illegally ordered.",
	"Method": "void computeFieldOffsets(){\r\n    primDataSize = 0;\r\n    numObjFields = 0;\r\n    int firstObjIndex = -1;\r\n    for (int i = 0; i < fields.length; i++) {\r\n        ObjectStreamField f = fields[i];\r\n        switch(f.getTypeCode()) {\r\n            case 'Z':\r\n            case 'B':\r\n                f.setOffset(primDataSize++);\r\n                break;\r\n            case 'C':\r\n            case 'S':\r\n                f.setOffset(primDataSize);\r\n                primDataSize += 2;\r\n                break;\r\n            case 'I':\r\n            case 'F':\r\n                f.setOffset(primDataSize);\r\n                primDataSize += 4;\r\n                break;\r\n            case 'J':\r\n            case 'D':\r\n                f.setOffset(primDataSize);\r\n                primDataSize += 8;\r\n                break;\r\n            case '[':\r\n            case 'L':\r\n                f.setOffset(numObjFields++);\r\n                if (firstObjIndex == -1) {\r\n                    firstObjIndex = i;\r\n                }\r\n                break;\r\n            default:\r\n                throw new InternalError();\r\n        }\r\n    }\r\n    if (firstObjIndex != -1 && firstObjIndex + numObjFields != fields.length) {\r\n        throw new InvalidClassException(name, \"illegal field order\");\r\n    }\r\n}"
}, {
	"Path": "java.io.DataInputStream.readInt",
	"Comment": "see the general contract of the readintmethod of datainput.bytesfor this operation are read from the containedinput stream.",
	"Method": "int readInt(){\r\n    int ch1 = in.read();\r\n    int ch2 = in.read();\r\n    int ch3 = in.read();\r\n    int ch4 = in.read();\r\n    if ((ch1 | ch2 | ch3 | ch4) < 0)\r\n        throw new EOFException();\r\n    return ((ch1 << 24) + (ch2 << 16) + (ch3 << 8) + (ch4 << 0));\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.MultiGraphQualifierHierarchy.calculateGlbs",
	"Comment": "returns a map from each possible pair of annotations to their glb.",
	"Method": "Map<AnnotationPair, AnnotationMirror> calculateGlbs(){\r\n    Map<AnnotationPair, AnnotationMirror> newglbs = new HashMap();\r\n    for (AnnotationMirror a1 : typeQualifiers) {\r\n        for (AnnotationMirror a2 : typeQualifiers) {\r\n            if (AnnotationUtils.areSameIgnoringValues(a1, a2)) {\r\n                continue;\r\n            }\r\n            if (!AnnotationUtils.areSame(getTopAnnotation(a1), getTopAnnotation(a2))) {\r\n                continue;\r\n            }\r\n            AnnotationPair pair = new AnnotationPair(a1, a2);\r\n            if (newglbs.containsKey(pair)) {\r\n                continue;\r\n            }\r\n            AnnotationMirror glb = findGlb(a1, a2);\r\n            newglbs.put(pair, glb);\r\n        }\r\n    }\r\n    return newglbs;\r\n}"
}, {
	"Path": "java.lang.AbstractStringBuilder.setCharAt",
	"Comment": "the character at the specified index is set to ch. thissequence is altered to represent a new character sequence that isidentical to the old character sequence, except that it contains thecharacter ch at position index.the index argument must be greater than or equal to0, and less than the length of this sequence.",
	"Method": "void setCharAt(int index,char ch){\r\n    if ((index < 0) || (index >= count))\r\n        throw new StringIndexOutOfBoundsException(index);\r\n    value[index] = ch;\r\n}"
}, {
	"Path": "java.net.URL.readObject",
	"Comment": "readobject is called to restore the state of the url from thestream.it reads the components of the url and finds the localstream handler.",
	"Method": "void readObject(java.io.ObjectInputStream s){\r\n    GetField gf = s.readFields();\r\n    String protocol = (String) gf.get(\"protocol\", null);\r\n    if (getURLStreamHandler(protocol) == null) {\r\n        throw new IOException(\"unknown protocol: \" + protocol);\r\n    }\r\n    String host = (String) gf.get(\"host\", null);\r\n    int port = gf.get(\"port\", -1);\r\n    String authority = (String) gf.get(\"authority\", null);\r\n    String file = (String) gf.get(\"file\", null);\r\n    String ref = (String) gf.get(\"ref\", null);\r\n    int hashCode = gf.get(\"hashCode\", -1);\r\n    if (authority == null && ((host != null && host.length() > 0) || port != -1)) {\r\n        if (host == null)\r\n            host = \"\";\r\n        authority = (port == -1) ? host : host + \":\" + port;\r\n    }\r\n    tempState = new UrlDeserializedState(protocol, host, port, authority, file, ref, hashCode);\r\n}"
}, {
	"Path": "java.lang.ClassLoader.loadClassInternal",
	"Comment": "this method is invoked by the virtual machine to load a class.",
	"Method": "Class loadClassInternal(String name){\r\n    if (parallelLockMap == null) {\r\n        synchronized (this) {\r\n            return loadClass(name);\r\n        }\r\n    } else {\r\n        return loadClass(name);\r\n    }\r\n}"
}, {
	"Path": "java.util.TreeMap.compare",
	"Comment": "compares two keys using the correct comparison method for this treemap.",
	"Method": "int compare(Object k1,Object k2){\r\n    return comparator == null ? ((Comparable<? super K>) k1).compareTo((K) k2) : comparator.compare((K) k1, (K) k2);\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.BookDTOService.toEntity",
	"Comment": "converts the passed dto to a book.convenient for query by example.",
	"Method": "Book toEntity(BookDTO dto,Book toEntity,BookDTO dto,int depth){\r\n    if (dto == null) {\r\n        return null;\r\n    }\r\n    Book book = new Book();\r\n    book.setId(dto.id);\r\n    book.setTitle(dto.title);\r\n    book.setSummary(dto.summary);\r\n    book.setPublicationDate(dto.publicationDate);\r\n    book.setBestSeller(dto.bestSeller);\r\n    book.setPrice(dto.price);\r\n    if (depth-- > 0) {\r\n        book.setAuthor(authorDTOService.toEntity(dto.author, depth));\r\n        book.setCoAuthor(authorDTOService.toEntity(dto.coAuthor, depth));\r\n    }\r\n    return book;\r\n}"
}, {
	"Path": "sun.util.resources.OpenListResourceBundle.loadLookup",
	"Comment": "we lazily load the lookup hashtable.this function does theloading.",
	"Method": "void loadLookup(){\r\n    if (lookup != null)\r\n        return;\r\n    Object[][] contents = getContents();\r\n    Map temp = createMap(contents.length);\r\n    for (int i = 0; i < contents.length; ++i) {\r\n        String key = (String) contents[i][0];\r\n        Object value = contents[i][1];\r\n        if (key == null || value == null) {\r\n            throw new NullPointerException();\r\n        }\r\n        temp.put(key, value);\r\n    }\r\n    lookup = temp;\r\n}"
}, {
	"Path": "java.util.Collections.enumeration",
	"Comment": "returns an enumeration over the specified collection.this providesinteroperability with legacy apis that require an enumerationas input.",
	"Method": "Enumeration<T> enumeration(Collection<T> c){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.setDSTSavings",
	"Comment": "sets the amount of time in milliseconds that the clock is advancedduring daylight saving time.",
	"Method": "void setDSTSavings(int millisSavedDuringDST){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.io.DataInputStream.readBoolean",
	"Comment": "see the general contract of the readbooleanmethod of datainput.bytes for this operation are read from the containedinput stream.",
	"Method": "boolean readBoolean(){\r\n    int ch = in.read();\r\n    if (ch < 0)\r\n        throw new EOFException();\r\n    return (ch != 0);\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TreeUtils.getReceiverTree",
	"Comment": "returns the receiver tree of a field access or a method invocation.",
	"Method": "ExpressionTree getReceiverTree(ExpressionTree expression){\r\n    ExpressionTree receiver = TreeUtils.skipParens(expression);\r\n    if (!(receiver.getKind() == Tree.Kind.METHOD_INVOCATION || receiver.getKind() == Tree.Kind.MEMBER_SELECT || receiver.getKind() == Tree.Kind.IDENTIFIER || receiver.getKind() == Tree.Kind.ARRAY_ACCESS)) {\r\n        return null;\r\n    }\r\n    if (receiver.getKind() == Tree.Kind.METHOD_INVOCATION) {\r\n        receiver = ((MethodInvocationTree) receiver).getMethodSelect();\r\n        if (receiver.getKind() == Tree.Kind.IDENTIFIER) {\r\n            return null;\r\n        } else if (receiver.getKind() == Tree.Kind.MEMBER_SELECT) {\r\n            receiver = ((MemberSelectTree) receiver).getExpression();\r\n        } else {\r\n        }\r\n    } else if (receiver.getKind() == Tree.Kind.IDENTIFIER) {\r\n        return null;\r\n    } else if (receiver.getKind() == Tree.Kind.ARRAY_ACCESS) {\r\n        return TreeUtils.skipParens(((ArrayAccessTree) receiver).getExpression());\r\n    } else if (receiver.getKind() == Tree.Kind.MEMBER_SELECT) {\r\n        receiver = ((MemberSelectTree) receiver).getExpression();\r\n        if (receiver instanceof PrimitiveTypeTree) {\r\n            return null;\r\n        }\r\n    }\r\n    return TreeUtils.skipParens(receiver);\r\n}"
}, {
	"Path": "java.util.EnumSet.range",
	"Comment": "creates an enum set initially containing all of the elements in therange defined by the two specified endpoints.the returned set willcontain the endpoints themselves, which may be identical but must notbe out of order.",
	"Method": "EnumSet<E> range(E from,E to){\r\n    if (from.compareTo(to) > 0)\r\n        throw new IllegalArgumentException(from + \" > \" + to);\r\n    EnumSet<E> result = noneOf(from.getDeclaringClass());\r\n    result.addRange(from, to);\r\n    return result;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.ElementAnnotationApplier.getParamAndLambdaTree",
	"Comment": "helper method to get the lambda tree for paramapplier. ideally, this method would be locatedin elementannotationutil but since annotatedtypefactory.declarationfromelement is protected,it has been placed here.",
	"Method": "Pair<VariableTree, LambdaExpressionTree> getParamAndLambdaTree(VariableElement varEle,AnnotatedTypeFactory typeFactory){\r\n    VariableTree paramDecl = (VariableTree) typeFactory.declarationFromElement(varEle);\r\n    if (paramDecl != null) {\r\n        final Tree parentTree = typeFactory.getPath(paramDecl).getParentPath().getLeaf();\r\n        if (parentTree != null && parentTree.getKind() == Kind.LAMBDA_EXPRESSION) {\r\n            return Pair.of(paramDecl, (LambdaExpressionTree) parentTree);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.io.ByteArrayInputStream.close",
	"Comment": "closing a bytearrayinputstream has no effect. the methods inthis class can be called after the stream has been closed withoutgenerating an ioexception.",
	"Method": "void close(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.GenericAnnotatedTypeFactory.getCFGVisualizer",
	"Comment": "the cfgvisualizer to be used by all cfabstractanalysis instances.",
	"Method": "CFGVisualizer<Value, Store, TransferFunction> getCFGVisualizer(){\r\n    return cfgVisualizer;\r\n}"
}, {
	"Path": "java.util.LinkedList.isPositionIndex",
	"Comment": "tells if the argument is the index of a valid position for aniterator or an add operation.",
	"Method": "boolean isPositionIndex(int index){\r\n    return index >= 0 && index <= size;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.solver.ConstraintMap.addTypeSubtype",
	"Comment": "add a constraint indicating that target is a subtype of supertype in the given qualifierhierarchies.",
	"Method": "void addTypeSubtype(TypeVariable target,AnnotatedTypeMirror supertype,AnnotationMirrorSet hierarchies){\r\n    final Subtypes subtypes = targetToRecords.get(target).subtypes;\r\n    final AnnotationMirrorSet subtypesTops = subtypes.types.get(supertype);\r\n    if (subtypesTops == null) {\r\n        subtypes.types.put(supertype, new AnnotationMirrorSet(hierarchies));\r\n    } else {\r\n        subtypesTops.addAll(hierarchies);\r\n    }\r\n}"
}, {
	"Path": "java.util.Observable.deleteObserver",
	"Comment": "deletes an observer from the set of observers of this object.passing null to this method will have no effect.",
	"Method": "void deleteObserver(Observer o){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.tryPresize",
	"Comment": "tries to presize table to accommodate the given number of elements.",
	"Method": "void tryPresize(int size){\r\n    int c = (size >= (MAXIMUM_CAPACITY >>> 1)) ? MAXIMUM_CAPACITY : tableSizeFor(size + (size >>> 1) + 1);\r\n    int sc;\r\n    while ((sc = sizeCtl) >= 0) {\r\n        Node<K, V>[] tab = table;\r\n        int n;\r\n        if (tab == null || (n = tab.length) == 0) {\r\n            n = (sc > c) ? sc : c;\r\n            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {\r\n                try {\r\n                    if (table == tab) {\r\n                        @SuppressWarnings(\"unchecked\")\r\n                        Node<K, V>[] nt = (Node<K, V>[]) new Node<?, ?>[n];\r\n                        table = nt;\r\n                        sc = n - (n >>> 2);\r\n                    }\r\n                } finally {\r\n                    sizeCtl = sc;\r\n                }\r\n            }\r\n        } else if (c <= sc || n >= MAXIMUM_CAPACITY)\r\n            break;\r\n        else if (tab == table) {\r\n            int rs = resizeStamp(n);\r\n            if (sc < 0) {\r\n                Node<K, V>[] nt;\r\n                if ((sc >>> RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex <= 0)\r\n                    break;\r\n                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))\r\n                    transfer(tab, nt);\r\n            } else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs << RESIZE_STAMP_SHIFT) + 2))\r\n                transfer(tab, null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.OffsetEquation.evalConstantTerm",
	"Comment": "evaluates an offset term. if the term is an integer constant, returns its value. otherwise,returns null.",
	"Method": "Integer evalConstantTerm(Receiver termReceiver){\r\n    if (termReceiver instanceof FlowExpressions.ValueLiteral) {\r\n        Object value = ((FlowExpressions.ValueLiteral) termReceiver).getValue();\r\n        if (value instanceof Integer) {\r\n            return (Integer) value;\r\n        }\r\n    } else if (termReceiver instanceof FlowExpressions.MethodCall) {\r\n        FlowExpressions.MethodCall call = (FlowExpressions.MethodCall) termReceiver;\r\n        if (call.getElement().getSimpleName().toString().equals(\"length\")) {\r\n            Receiver callReceiver = call.getReceiver();\r\n            if (callReceiver instanceof FlowExpressions.ValueLiteral) {\r\n                Object value = ((FlowExpressions.ValueLiteral) callReceiver).getValue();\r\n                if (value instanceof String) {\r\n                    return ((String) value).length();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.writeFatalException",
	"Comment": "attempts to write to stream fatal ioexception that has causedserialization to abort.",
	"Method": "void writeFatalException(IOException ex){\r\n    clear();\r\n    boolean oldMode = bout.setBlockDataMode(false);\r\n    try {\r\n        bout.writeByte(TC_EXCEPTION);\r\n        writeObject0(ex, false);\r\n        clear();\r\n    } finally {\r\n        bout.setBlockDataMode(oldMode);\r\n    }\r\n}"
}, {
	"Path": "java.util.ComparableTimSort.ensureCapacity",
	"Comment": "ensures that the external array tmp has at least the specifiednumber of elements, increasing its size if necessary.the sizeincreases exponentially to ensure amortized linear time complexity.",
	"Method": "Object[] ensureCapacity(int minCapacity){\r\n    if (tmpLen < minCapacity) {\r\n        int newSize = minCapacity;\r\n        newSize |= newSize >> 1;\r\n        newSize |= newSize >> 2;\r\n        newSize |= newSize >> 4;\r\n        newSize |= newSize >> 8;\r\n        newSize |= newSize >> 16;\r\n        newSize++;\r\n        if (newSize < 0)\r\n            newSize = minCapacity;\r\n        else\r\n            newSize = Math.min(newSize, a.length >>> 1);\r\n        @SuppressWarnings({ \"unchecked\", \"UnnecessaryLocalVariable\" })\r\n        Object[] newArray = new Object[newSize];\r\n        tmp = newArray;\r\n        tmpLen = newSize;\r\n        tmpBase = 0;\r\n    }\r\n    return tmp;\r\n}"
}, {
	"Path": "java.io.DataInputStream.readShort",
	"Comment": "see the general contract of the readshortmethod of datainput.bytesfor this operation are read from the containedinput stream.",
	"Method": "short readShort(){\r\n    int ch1 = in.read();\r\n    int ch2 = in.read();\r\n    if ((ch1 | ch2) < 0)\r\n        throw new EOFException();\r\n    return (short) ((ch1 << 8) + (ch2 << 0));\r\n}"
}, {
	"Path": "sun.misc.FloatingDecimal.getHexDigit",
	"Comment": "extract a hexadecimal digit from position positionof string s.",
	"Method": "int getHexDigit(String s,int position){\r\n    int value = Character.digit(s.charAt(position), 16);\r\n    if (value <= -1 || value >= 16) {\r\n        throw new AssertionError(\"Unexpected failure of digit conversion of \" + s.charAt(position));\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "com.mycompany.myapp.domain.UseCase1.toString",
	"Comment": "construct a readable string representation for this usecase1 instance.",
	"Method": "String toString(){\r\n    return // \r\n    MoreObjects.toStringHelper(this).add(\"dummy\", getDummy()).toString();\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.AnnotatedTypes.findTypeArguments",
	"Comment": "given a method or constructor invocation, return a mapping of the type variables to theirtype arguments, if any exist.it uses the method or constructor invocation type arguments if they were specified andotherwise it infers them based on the passed arguments or the return type context, accordingto jls 15.12.2.",
	"Method": "Map<TypeVariable, AnnotatedTypeMirror> findTypeArguments(ProcessingEnvironment processingEnv,AnnotatedTypeFactory atypeFactory,ExpressionTree expr,ExecutableElement elt,AnnotatedExecutableType preType){\r\n    if (elt.getTypeParameters().isEmpty()) {\r\n        return Collections.emptyMap();\r\n    }\r\n    List<? extends Tree> targs;\r\n    if (expr instanceof MethodInvocationTree) {\r\n        targs = ((MethodInvocationTree) expr).getTypeArguments();\r\n    } else if (expr instanceof NewClassTree) {\r\n        targs = ((NewClassTree) expr).getTypeArguments();\r\n    } else if (expr instanceof MemberReferenceTree) {\r\n        targs = ((MemberReferenceTree) expr).getTypeArguments();\r\n        if (targs == null) {\r\n            return new HashMap();\r\n        }\r\n    } else {\r\n        throw new BugInCF(\"AnnotatedTypes.findTypeArguments: unexpected tree: \" + expr);\r\n    }\r\n    if (!targs.isEmpty()) {\r\n        List<? extends AnnotatedTypeVariable> tvars = preType.getTypeVariables();\r\n        Map<TypeVariable, AnnotatedTypeMirror> typeArguments = new HashMap();\r\n        for (int i = 0; i < elt.getTypeParameters().size(); ++i) {\r\n            AnnotatedTypeVariable typeVar = tvars.get(i);\r\n            AnnotatedTypeMirror typeArg = atypeFactory.getAnnotatedTypeFromTypeTree(targs.get(i));\r\n            typeArguments.put(typeVar.getUnderlyingType(), typeArg);\r\n        }\r\n        return typeArguments;\r\n    } else {\r\n        return atypeFactory.getTypeArgumentInference().inferTypeArgs(atypeFactory, expr, elt, preType);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.common.wholeprograminference.WholeProgramInferenceScenes.updateInferredMethodReturnType",
	"Comment": "updates the return type of the method methodtree in the scene of the class with symbolclasssymbol.if the scene does not contain an annotated return type for the method methodtree, then thetype of the value passed to the return expression will be added to the return type of thatmethod in the scene. if the scene previously contained an annotated return type for themethod methodtree, its new type will be the lub between the previous type and the type of thevalue passed to the return expression.",
	"Method": "void updateInferredMethodReturnType(ReturnNode retNode,ClassSymbol classSymbol,MethodTree methodTree,AnnotatedTypeFactory atf){\r\n    if (classSymbol == null) {\r\n        return;\r\n    }\r\n    String className = classSymbol.flatname.toString();\r\n    String jaifPath = helper.getJaifPath(className);\r\n    AClass clazz = helper.getAClass(className, jaifPath);\r\n    AMethod method = clazz.methods.vivify(JVMNames.getJVMMethodName(methodTree));\r\n    AnnotatedTypeMirror lhsATM = atf.getAnnotatedType(methodTree).getReturnType();\r\n    AnnotatedTypeMirror rhsATM = atf.getAnnotatedType(retNode.getTree().getExpression());\r\n    helper.updateAnnotationSetInScene(method.returnType, atf, jaifPath, rhsATM, lhsATM, TypeUseLocation.RETURN);\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.readStreamHeader",
	"Comment": "the readstreamheader method is provided to allow subclasses to read andverify their own stream headers. it reads and verifies the magic numberand version number.",
	"Method": "void readStreamHeader(){\r\n    short s0 = bin.readShort();\r\n    short s1 = bin.readShort();\r\n    if (s0 != STREAM_MAGIC || s1 != STREAM_VERSION) {\r\n        throw new StreamCorruptedException(String.format(\"invalid stream header: XX\", s0, s1));\r\n    }\r\n}"
}, {
	"Path": "testlib.util.FactoryTestChecker.canonizeTypeString",
	"Comment": "a method to canonize type string representation. it removes any unnecessary white spaces andfinds the type simple name instead of the fully qualified name.",
	"Method": "String canonizeTypeString(String str){\r\n    String canon = str.trim();\r\n    canon = canon.replaceAll(\"\\\\s+\", \" \");\r\n    canon = canon.replaceAll(\"\\\\[\\\\s+\", \"[\");\r\n    canon = canon.replaceAll(\"\\\\s+\\\\]\", \"]\");\r\n    canon = canon.replaceAll(\"<\\\\s+\", \"<\");\r\n    canon = canon.replaceAll(\"\\\\s+>\", \">\");\r\n    canon = canon.replaceAll(\"[^\\\\<]*\\\\.(?=\\\\w)\", \"\");\r\n    return canon;\r\n}"
}, {
	"Path": "java.lang.ref.Reference.isEnqueued",
	"Comment": "tells whether or not this reference object has been enqueued, either bythe program or by the garbage collector.if this reference object wasnot registered with a queue when it was created, then this method willalways return false.",
	"Method": "boolean isEnqueued(){\r\n    synchronized (this) {\r\n        return (this.next != null && this.queue == ReferenceQueue.ENQUEUED);\r\n    }\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.writeProxyDesc",
	"Comment": "writes class descriptor representing a dynamic proxy class to stream.",
	"Method": "void writeProxyDesc(ObjectStreamClass desc,boolean unshared){\r\n    bout.writeByte(TC_PROXYCLASSDESC);\r\n    handles.assign(unshared ? null : desc);\r\n    Class cl = desc.forClass();\r\n    Class[] ifaces = cl.getInterfaces();\r\n    bout.writeInt(ifaces.length);\r\n    for (int i = 0; i < ifaces.length; i++) {\r\n        bout.writeUTF(ifaces[i].getName());\r\n    }\r\n    bout.setBlockDataMode(true);\r\n    annotateProxyClass(cl);\r\n    bout.setBlockDataMode(false);\r\n    bout.writeByte(TC_ENDBLOCKDATA);\r\n    writeClassDesc(desc.getSuperDesc(), false);\r\n}"
}, {
	"Path": "java.util.Date.setHours",
	"Comment": "sets the hour of this date object to the specified value.this date object is modified so that it represents a pointin time within the specified hour of the day, with the year, month,date, minute, and second the same as before, as interpreted in thelocal time zone.",
	"Method": "void setHours(int hours){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.TestConfigurationBuilder.getDefaultConfigurationBuilder",
	"Comment": "this creates a builder for the default configuration used by checker framework junit tests.",
	"Method": "TestConfigurationBuilder getDefaultConfigurationBuilder(String testSourcePath,File outputClassDirectory,String classPath,Iterable<File> testSourceFiles,Iterable<String> processors,List<String> options,boolean shouldEmitDebugInfo){\r\n    TestConfigurationBuilder configBuilder = // use short javac diagnostics\r\n    new TestConfigurationBuilder().setShouldEmitDebugInfo(shouldEmitDebugInfo).addProcessors(processors).addOption(\"-Xmaxerrs\", \"9999\").addOption(\"-g\").addOption(\"-Xlint:unchecked\").addOption(\"-XDrawDiagnostics\").addSourceFiles(testSourceFiles);\r\n    if (outputClassDirectory != null) {\r\n        configBuilder.addOption(\"-d\", outputClassDirectory.getAbsolutePath());\r\n    }\r\n    String jdkJarPath = getJdkJarPathFromProperty();\r\n    if (notNullOrEmpty(jdkJarPath)) {\r\n        configBuilder.addOption(\"-Xbootclasspath/p:\" + jdkJarPath);\r\n    }\r\n    configBuilder.addOptionIfValueNonEmpty(\"-sourcepath\", testSourcePath).addOption(\"-implicit:class\").addOption(\"-classpath\", classPath);\r\n    configBuilder.addOptions(options);\r\n    return configBuilder;\r\n}"
}, {
	"Path": "java.util.jar.JarInputStream.getNextJarEntry",
	"Comment": "reads the next jar file entry and positions the stream at thebeginning of the entry data. if verification has been enabled,any invalid signature detected while positioning the stream forthe next entry will result in an exception.",
	"Method": "JarEntry getNextJarEntry(){\r\n    return (JarEntry) getNextEntry();\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TypesUtils.isCaptured",
	"Comment": "returns whether a typevariable represents a captured type.",
	"Method": "boolean isCaptured(TypeMirror typeVar){\r\n    if (typeVar.getKind() != TypeKind.TYPEVAR) {\r\n        return false;\r\n    }\r\n    return ((Type.TypeVar) TypeAnnotationUtils.unannotatedType(typeVar)).isCaptured();\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.UseCase2DTOService.toDTO",
	"Comment": "converts the passed usecase2 to a dto. the depth is used to control theamount of association you want. it also prevents potential infinite serialization cycles.",
	"Method": "UseCase2DTO toDTO(UseCase2 useCase2,UseCase2DTO toDTO,UseCase2 useCase2,int depth){\r\n    if (useCase2 == null) {\r\n        return null;\r\n    }\r\n    UseCase2DTO dto = new UseCase2DTO();\r\n    dto.id = useCase2.getId();\r\n    dto.dummy = useCase2.getDummy();\r\n    if (depth-- > 0) {\r\n    }\r\n    return dto;\r\n}"
}, {
	"Path": "java.util.Observable.clearChanged",
	"Comment": "indicates that this object has no longer changed, or that it hasalready notified all of its observers of its most recent change,so that the haschanged method will now return false.this method is called automatically by thenotifyobservers methods.",
	"Method": "void clearChanged(){\r\n    changed = false;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.dependenttypes.DependentTypesHelper.getExpressionElementNames",
	"Comment": "returns a list of the names of elements in the annotation class that should be interpreted asjava expressions.",
	"Method": "List<String> getExpressionElementNames(Class<? extends Annotation> clazz){\r\n    Method[] methods = clazz.getMethods();\r\n    if (methods == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    List<String> elements = new ArrayList();\r\n    for (Method method : methods) {\r\n        JavaExpression javaExpression = method.getAnnotation(JavaExpression.class);\r\n        if (javaExpression != null) {\r\n            elements.add(method.getName());\r\n        }\r\n    }\r\n    return elements;\r\n}"
}, {
	"Path": "java.io.File.canExecute",
	"Comment": "tests whether the application can execute the file denoted by thisabstract pathname.",
	"Method": "boolean canExecute(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.logging.LogManager.getProperty",
	"Comment": "get the value of a logging property.the method returns null if the property is not found.",
	"Method": "String getProperty(String name){\r\n    return props.getProperty(name);\r\n}"
}, {
	"Path": "java.io.RandomAccessFile.readDouble",
	"Comment": "reads a double from this file. this method reads along value, starting at the current file pointer,as if by the readlong methodand then converts that long to a doubleusing the longbitstodouble method inclass double.this method blocks until the eight bytes are read, the end of thestream is detected, or an exception is thrown.",
	"Method": "double readDouble(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.text.DateFormatSymbols.copyMembers",
	"Comment": "clones all the data members from the source dateformatsymbols tothe target dateformatsymbols. this is only for subclasses.",
	"Method": "void copyMembers(DateFormatSymbols src,DateFormatSymbols dst){\r\n    dst.eras = Arrays.copyOf(src.eras, src.eras.length);\r\n    dst.months = Arrays.copyOf(src.months, src.months.length);\r\n    dst.shortMonths = Arrays.copyOf(src.shortMonths, src.shortMonths.length);\r\n    dst.weekdays = Arrays.copyOf(src.weekdays, src.weekdays.length);\r\n    dst.shortWeekdays = Arrays.copyOf(src.shortWeekdays, src.shortWeekdays.length);\r\n    dst.ampms = Arrays.copyOf(src.ampms, src.ampms.length);\r\n    if (src.zoneStrings != null) {\r\n        dst.zoneStrings = src.getZoneStringsImpl(true);\r\n    } else {\r\n        dst.zoneStrings = null;\r\n    }\r\n    dst.localPatternChars = src.localPatternChars;\r\n    dst.cachedHashCode = 0;\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.HessianSerializerOutput.writeObjectImpl",
	"Comment": "applications which override this can do custom serialization.",
	"Method": "void writeObjectImpl(Object obj){\r\n    Class cl = obj.getClass();\r\n    try {\r\n        Method method = cl.getMethod(\"writeReplace\", new Class[0]);\r\n        Object repl = method.invoke(obj, new Object[0]);\r\n        writeObject(repl);\r\n        return;\r\n    } catch (Exception e) {\r\n    }\r\n    try {\r\n        writeMapBegin(cl.getName());\r\n        for (; cl != null; cl = cl.getSuperclass()) {\r\n            Field[] fields = cl.getDeclaredFields();\r\n            for (int i = 0; i < fields.length; i++) {\r\n                Field field = fields[i];\r\n                if (Modifier.isTransient(field.getModifiers()) || Modifier.isStatic(field.getModifiers())) {\r\n                    continue;\r\n                }\r\n                field.setAccessible(true);\r\n                writeString(field.getName());\r\n                writeObject(field.get(obj));\r\n            }\r\n        }\r\n        writeMapEnd();\r\n    } catch (IllegalAccessException e) {\r\n        throw new IOExceptionWrapper(e);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.dataflow.analysis.FlowExpressions.getParametersOfEnclosingMethod",
	"Comment": "returns receiver objects for the formal parameters of the method in which path is enclosed.",
	"Method": "List<Receiver> getParametersOfEnclosingMethod(AnnotationProvider annotationProvider,TreePath path){\r\n    MethodTree methodTree = TreeUtils.enclosingMethod(path);\r\n    if (methodTree == null) {\r\n        return null;\r\n    }\r\n    List<Receiver> internalArguments = new ArrayList();\r\n    for (VariableTree arg : methodTree.getParameters()) {\r\n        internalArguments.add(internalReprOf(annotationProvider, new LocalVariableNode(arg)));\r\n    }\r\n    return internalArguments;\r\n}"
}, {
	"Path": "org.checkerframework.common.basetype.BaseTypeVisitor.isValidUse",
	"Comment": "tests that the qualifiers present on the primitive type are valid.the default implementation always returns true. subclasses should override this method tolimit what annotations are allowed on primitive types.",
	"Method": "boolean isValidUse(AnnotatedDeclaredType declarationType,AnnotatedDeclaredType useType,Tree tree,boolean isValidUse,AnnotatedPrimitiveType type,Tree tree,boolean isValidUse,AnnotatedArrayType type,Tree tree){\r\n    return true;\r\n}"
}, {
	"Path": "java.util.EnumSet.getUniverse",
	"Comment": "returns all of the values comprising e.the result is uncloned, cached, and shared by all callers.",
	"Method": "E[] getUniverse(Class<E> elementType){\r\n    return SharedSecrets.getJavaLangAccess().getEnumConstantsShared(elementType);\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.lookup",
	"Comment": "find the descriptor for a class that can be serialized.creates anobjectstreamclass instance if one does not exist yet for class. null isreturned if the specified class does not implement java.io.serializableor java.io.externalizable.",
	"Method": "ObjectStreamClass lookup(Class<?> cl,ObjectStreamClass lookup,Class<?> cl,boolean all){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.constraint.AFReducingVisitor.visitIntersection_Null",
	"Comment": "provides no information as the annotatednulltype cannot refer to a type parameter",
	"Method": "Void visitIntersection_Null(AnnotatedIntersectionType argument,AnnotatedNullType parameter,Set<AFConstraint> constraints){\r\n    return null;\r\n}"
}, {
	"Path": "java.util.zip.GZIPOutputStream.writeTrailer",
	"Comment": "writes gzip member trailer to a byte array, starting at a givenoffset.",
	"Method": "void writeTrailer(byte[] buf,int offset){\r\n    writeInt((int) crc.getValue(), buf, offset);\r\n    writeInt(def.getTotalIn(), buf, offset + 4);\r\n}"
}, {
	"Path": "java.text.DateFormatSymbols.hashCode",
	"Comment": "override hashcode.generates a hash code for the dateformatsymbols object.",
	"Method": "int hashCode(){\r\n    int hashCode = cachedHashCode;\r\n    if (hashCode == 0) {\r\n        hashCode = 5;\r\n        hashCode = 11 * hashCode + Arrays.hashCode(eras);\r\n        hashCode = 11 * hashCode + Arrays.hashCode(months);\r\n        hashCode = 11 * hashCode + Arrays.hashCode(shortMonths);\r\n        hashCode = 11 * hashCode + Arrays.hashCode(weekdays);\r\n        hashCode = 11 * hashCode + Arrays.hashCode(shortWeekdays);\r\n        hashCode = 11 * hashCode + Arrays.hashCode(ampms);\r\n        hashCode = 11 * hashCode + Arrays.deepHashCode(getZoneStringsWrapper());\r\n        hashCode = 11 * hashCode + Objects.hashCode(localPatternChars);\r\n        cachedHashCode = hashCode;\r\n    }\r\n    return hashCode;\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.UserDTOService.toDTO",
	"Comment": "converts the passed user to a dto. the depth is used to control theamount of association you want. it also prevents potential infinite serialization cycles.",
	"Method": "UserDTO toDTO(User user,UserDTO toDTO,User user,int depth){\r\n    if (user == null) {\r\n        return null;\r\n    }\r\n    UserDTO dto = new UserDTO();\r\n    dto.id = user.getId();\r\n    dto.login = user.getLogin();\r\n    dto.password = user.getPassword();\r\n    dto.email = user.getEmail();\r\n    dto.isEnabled = user.getIsEnabled();\r\n    dto.civility = user.getCivility();\r\n    dto.countryCode = user.getCountryCode();\r\n    dto.firstName = user.getFirstName();\r\n    dto.lastName = user.getLastName();\r\n    dto.creationDate = user.getCreationDate();\r\n    dto.creationAuthor = user.getCreationAuthor();\r\n    dto.lastModificationDate = user.getLastModificationDate();\r\n    dto.lastModificationAuthor = user.getLastModificationAuthor();\r\n    dto.version = user.getVersion();\r\n    if (depth-- > 0) {\r\n        dto.passport = passportDTOService.toDTO(user.getPassport(), depth);\r\n        final int fdepth = depth;\r\n        dto.roles = user.getRoles().stream().map(role -> roleDTOService.toDTO(role, fdepth)).collect(Collectors.toList());\r\n    }\r\n    return dto;\r\n}"
}, {
	"Path": "java.util.JumboEnumSet.add",
	"Comment": "adds the specified element to this set if it is not already present.",
	"Method": "boolean add(E e){\r\n    typeCheck(e);\r\n    int eOrdinal = e.ordinal();\r\n    int eWordNum = eOrdinal >>> 6;\r\n    long oldElements = elements[eWordNum];\r\n    elements[eWordNum] |= (1L << eOrdinal);\r\n    boolean result = (elements[eWordNum] != oldElements);\r\n    if (result)\r\n        size++;\r\n    return result;\r\n}"
}, {
	"Path": "com.alibaba.citrus.generictype.codegen.asm.Type.getMethodDescriptor",
	"Comment": "returns the descriptor corresponding to the given argument and returntypes.",
	"Method": "String getMethodDescriptor(Type returnType,Type[] argumentTypes,String getMethodDescriptor,Method m){\r\n    Class[] parameters = m.getParameterTypes();\r\n    StringBuilder buf = new StringBuilder();\r\n    buf.append('(');\r\n    for (int i = 0; i < parameters.length; ++i) {\r\n        getDescriptor(buf, parameters[i]);\r\n    }\r\n    buf.append(')');\r\n    getDescriptor(buf, m.getReturnType());\r\n    return buf.toString();\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotationClassLoader.loadAnnotationClasses",
	"Comment": "loads a set of annotations indicated by fullyqualifiedannonames.",
	"Method": "Set<Class<? extends Annotation>> loadAnnotationClasses(Set<String> fullyQualifiedAnnoNames){\r\n    Set<Class<? extends Annotation>> loadedClasses = new LinkedHashSet();\r\n    if (fullyQualifiedAnnoNames != null && !fullyQualifiedAnnoNames.isEmpty()) {\r\n        for (String fullyQualifiedAnnoName : fullyQualifiedAnnoNames) {\r\n            Class<? extends Annotation> annoClass = loadAnnotationClass(fullyQualifiedAnnoName, false);\r\n            if (annoClass != null) {\r\n                loadedClasses.add(annoClass);\r\n            }\r\n        }\r\n    }\r\n    return loadedClasses;\r\n}"
}, {
	"Path": "javax.management.openmbean.CompositeType.getType",
	"Comment": "returns the open type of the item whose name is itemname,or null if this compositetype instance does not define any itemwhose name is itemname.",
	"Method": "OpenType<?> getType(String itemName){\r\n    if (itemName == null) {\r\n        return null;\r\n    }\r\n    return (OpenType<?>) nameToType.get(itemName);\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.checkSerialize",
	"Comment": "throws an invalidclassexception if objects whose class is represented bythis descriptor should not be allowed to serialize.this method doesnot apply to serialization of enum constants.",
	"Method": "void checkSerialize(){\r\n    if (serializeEx != null) {\r\n        throw serializeEx.newInvalidClassException();\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.checker.units.UnitsAnnotatedTypeFactory.loadExternalDirectory",
	"Comment": "loads and processes the units qualifiers from a single external directory.",
	"Method": "void loadExternalDirectory(String directoryName){\r\n    Set<Class<? extends Annotation>> annoClassSet = loader.loadExternalAnnotationClassesFromDirectory(directoryName);\r\n    for (Class<? extends Annotation> annoClass : annoClassSet) {\r\n        addUnitToExternalQualMap(annoClass);\r\n    }\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.UseCase1DTOService.save",
	"Comment": "save the passed dto as a new entity or update the corresponding entity if any.",
	"Method": "UseCase1DTO save(UseCase1DTO dto){\r\n    if (dto == null) {\r\n        return null;\r\n    }\r\n    final UseCase1 useCase1;\r\n    if (dto.isIdSet()) {\r\n        UseCase1 useCase1Tmp = useCase1Repository.findOne(dto.id);\r\n        if (useCase1Tmp != null) {\r\n            useCase1 = useCase1Tmp;\r\n        } else {\r\n            useCase1 = new UseCase1();\r\n            useCase1.setId(dto.id);\r\n        }\r\n    } else {\r\n        useCase1 = new UseCase1();\r\n    }\r\n    useCase1.setDummy(dto.dummy);\r\n    return toDTO(useCase1Repository.save(useCase1));\r\n}"
}, {
	"Path": "java.lang.Character.codePointAtImpl",
	"Comment": "throws arrayindexoutofboundsexception if index out of bounds",
	"Method": "int codePointAtImpl(char[] a,int index,int limit){\r\n    char c1 = a[index];\r\n    if (isHighSurrogate(c1) && ++index < limit) {\r\n        char c2 = a[index];\r\n        if (isLowSurrogate(c2)) {\r\n            return toCodePoint(c1, c2);\r\n        }\r\n    }\r\n    return c1;\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.StubGenerator.stubFromType",
	"Comment": "generate the stub file for provided class. the generated file includes the package name.",
	"Method": "void stubFromType(TypeElement typeElement){\r\n    if (typeElement.getKind() != ElementKind.CLASS && typeElement.getKind() != ElementKind.INTERFACE) {\r\n        return;\r\n    }\r\n    String newPackageName = ElementUtils.getVerboseName(ElementUtils.enclosingPackage(typeElement));\r\n    boolean newPackage = !newPackageName.equals(currentPackage);\r\n    currentPackage = newPackageName;\r\n    if (newPackage) {\r\n        indent();\r\n        out.print(\"package \");\r\n        out.print(currentPackage);\r\n        out.println(\";\");\r\n        out.println();\r\n    }\r\n    String fullClassName = ElementUtils.getQualifiedClassName(typeElement).toString();\r\n    String className = fullClassName.substring(fullClassName.indexOf(currentPackage) + currentPackage.length() + 1);\r\n    int index = className.lastIndexOf('.');\r\n    if (index == -1) {\r\n        printClass(typeElement);\r\n    } else {\r\n        String outer = className.substring(0, index);\r\n        printClass(typeElement, outer.replace('.', '$'));\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.UpperBoundTransfer.refineEq",
	"Comment": "refines the type of the left and right node to glb of the left and right annotation.",
	"Method": "void refineEq(Node left,AnnotationMirror leftAnno,Node right,AnnotationMirror rightAnno,CFStore store){\r\n    UBQualifier leftQualifier = UBQualifier.createUBQualifier(leftAnno);\r\n    UBQualifier rightQualifier = UBQualifier.createUBQualifier(rightAnno);\r\n    UBQualifier glb = rightQualifier.glb(leftQualifier);\r\n    AnnotationMirror glbAnno = atypeFactory.convertUBQualifierToAnnotation(glb);\r\n    List<Node> internalsRight = splitAssignments(right);\r\n    for (Node internal : internalsRight) {\r\n        Receiver rightRec = FlowExpressions.internalReprOf(analysis.getTypeFactory(), internal);\r\n        store.insertValue(rightRec, glbAnno);\r\n    }\r\n    List<Node> internalsLeft = splitAssignments(left);\r\n    for (Node internal : internalsLeft) {\r\n        Receiver leftRec = FlowExpressions.internalReprOf(analysis.getTypeFactory(), internal);\r\n        store.insertValue(leftRec, glbAnno);\r\n    }\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.writeString",
	"Comment": "writes given string to stream, using standard or long utf formatdepending on string length.",
	"Method": "void writeString(String str,boolean unshared){\r\n    handles.assign(unshared ? null : str);\r\n    long utflen = bout.getUTFLength(str);\r\n    if (utflen <= 0xFFFF) {\r\n        bout.writeByte(TC_STRING);\r\n        bout.writeUTF(str, utflen);\r\n    } else {\r\n        bout.writeByte(TC_LONGSTRING);\r\n        bout.writeLongUTF(str, utflen);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.source.SourceChecker.getOption",
	"Comment": "determines the value of the lint option with the given name and returns the default value ifnothing is specified.",
	"Method": "String getOption(String name,String getOption,String name,String defaultValue){\r\n    if (!this.getSupportedOptions().contains(name)) {\r\n        throw new UserError(\"Illegal option: \" + name);\r\n    }\r\n    if (activeOptions == null) {\r\n        activeOptions = createActiveOptions(processingEnv.getOptions());\r\n    }\r\n    if (activeOptions.isEmpty()) {\r\n        return defaultValue;\r\n    }\r\n    if (activeOptions.containsKey(name)) {\r\n        return activeOptions.get(name);\r\n    } else {\r\n        return defaultValue;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.UpperBoundTransfer.getUBQualifierForAddition",
	"Comment": "returns the ubqualifier for a node, with additional refinement useful specifically forinteger addition, based on the information from subcheckers of the index checker.",
	"Method": "UBQualifier getUBQualifierForAddition(Node n,TransferInput<CFValue, CFStore> in){\r\n    UBQualifier ubQualifier = getUBQualifier(n, in);\r\n    Tree nodeTree = n.getTree();\r\n    AnnotatedTypeMirror substringIndexType = atypeFactory.getSubstringIndexAnnotatedTypeFactory().getAnnotatedType(nodeTree);\r\n    AnnotationMirror substringIndexAnno = substringIndexType.getAnnotation(SubstringIndexFor.class);\r\n    AnnotatedTypeMirror lowerBoundType = atypeFactory.getLowerBoundAnnotatedTypeFactory().getAnnotatedType(nodeTree);\r\n    if (substringIndexAnno != null && (lowerBoundType.hasAnnotation(NonNegative.class) || lowerBoundType.hasAnnotation(Positive.class))) {\r\n        UBQualifier substringIndexQualifier = UBQualifier.createUBQualifier(substringIndexAnno);\r\n        ubQualifier = ubQualifier.glb(substringIndexQualifier);\r\n    }\r\n    return ubQualifier;\r\n}"
}, {
	"Path": "java.util.ArrayList.grow",
	"Comment": "increases the capacity to ensure that it can hold at least thenumber of elements specified by the minimum capacity argument.",
	"Method": "void grow(int minCapacity){\r\n    int oldCapacity = elementData.length;\r\n    int newCapacity = oldCapacity + (oldCapacity >> 1);\r\n    if (newCapacity - minCapacity < 0)\r\n        newCapacity = minCapacity;\r\n    if (newCapacity - MAX_ARRAY_SIZE > 0)\r\n        newCapacity = hugeCapacity(minCapacity);\r\n    elementData = Arrays.copyOf(elementData, newCapacity);\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.treeifyBin",
	"Comment": "replaces all linked nodes in bin at given index unless table istoo small, in which case resizes instead.",
	"Method": "void treeifyBin(Node<K, V>[] tab,int index){\r\n    Node<K, V> b;\r\n    int n, sc;\r\n    if (tab != null) {\r\n        if ((n = tab.length) < MIN_TREEIFY_CAPACITY)\r\n            tryPresize(n << 1);\r\n        else if ((b = tabAt(tab, index)) != null && b.hash >= 0) {\r\n            synchronized (b) {\r\n                if (tabAt(tab, index) == b) {\r\n                    TreeNode<K, V> hd = null, tl = null;\r\n                    for (Node<K, V> e = b; e != null; e = e.next) {\r\n                        TreeNode<K, V> p = new TreeNode<K, V>(e.hash, e.key, e.val, null, null);\r\n                        if ((p.prev = tl) == null)\r\n                            hd = p;\r\n                        else\r\n                            tl.next = p;\r\n                        tl = p;\r\n                    }\r\n                    setTabAt(tab, index, new TreeBin<K, V>(hd));\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.WeakHashMap.unmaskNull",
	"Comment": "returns internal representation of null key back to caller as null.",
	"Method": "Object unmaskNull(Object key){\r\n    return (key == NULL_KEY) ? null : key;\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TypesUtils.isDeclaredOfName",
	"Comment": "check if the type represents a declared type of the given qualified name.",
	"Method": "boolean isDeclaredOfName(TypeMirror type,CharSequence qualifiedName){\r\n    return type.getKind() == TypeKind.DECLARED && getQualifiedName((DeclaredType) type).contentEquals(qualifiedName);\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueTransfer.createAnnotationForStringConcatenation",
	"Comment": "creates an annotation for a result of string concatenation.",
	"Method": "AnnotationMirror createAnnotationForStringConcatenation(Node leftOperand,Node rightOperand,TransferInput<CFValue, CFStore> p){\r\n    List<String> leftValues = getStringValues(leftOperand, p);\r\n    List<String> rightValues = getStringValues(rightOperand, p);\r\n    if (leftValues != null && rightValues != null) {\r\n        List<String> concatValues = new ArrayList();\r\n        if (leftValues.isEmpty()) {\r\n            leftValues = Collections.singletonList(\"null\");\r\n        }\r\n        if (rightValues.isEmpty()) {\r\n            rightValues = Collections.singletonList(\"null\");\r\n        }\r\n        for (String left : leftValues) {\r\n            for (String right : rightValues) {\r\n                concatValues.add(left + right);\r\n            }\r\n        }\r\n        return atypefactory.createStringAnnotation(concatValues);\r\n    }\r\n    List<Integer> leftLengths = leftValues != null ? ValueCheckerUtils.getLengthsForStringValues(leftValues) : getStringLengths(leftOperand, p);\r\n    List<Integer> rightLengths = rightValues != null ? ValueCheckerUtils.getLengthsForStringValues(rightValues) : getStringLengths(rightOperand, p);\r\n    if (leftLengths != null && rightLengths != null) {\r\n        List<Integer> concatLengths = calculateLengthAddition(leftLengths, rightLengths);\r\n        return atypefactory.createArrayLenAnnotation(concatLengths);\r\n    }\r\n    Range leftLengthRange = leftLengths != null ? ValueCheckerUtils.getRangeFromValues(leftLengths) : getStringLengthRange(leftOperand, p);\r\n    Range rightLengthRange = rightLengths != null ? ValueCheckerUtils.getRangeFromValues(rightLengths) : getStringLengthRange(rightOperand, p);\r\n    if (leftLengthRange != null && rightLengthRange != null) {\r\n        Range concatLengthRange = calculateLengthRangeAddition(leftLengthRange, rightLengthRange);\r\n        return atypefactory.createArrayLenRangeAnnotation(concatLengthRange);\r\n    }\r\n    return atypefactory.UNKNOWNVAL;\r\n}"
}, {
	"Path": "com.alibaba.citrus.util.internal.apache.lang.EqualsBuilder.isEquals",
	"Comment": "returns true if the fields that have been checked are allequal.",
	"Method": "boolean isEquals(){\r\n    return this.isEquals;\r\n}"
}, {
	"Path": "java.util.Calendar.internalSet",
	"Comment": "sets the value of the given calendar field. this method doesnot affect any setting state of the field in thiscalendar instance.",
	"Method": "void internalSet(int field,int value){\r\n    fields[field] = value;\r\n}"
}, {
	"Path": "java.util.EnumSet.of",
	"Comment": "creates an enum set initially containing the specified elements.this factory, whose parameter list uses the varargs feature, maybe used to create an enum set initially containing an arbitrarynumber of elements, but it is likely to run slower than the overloadingsthat do not use varargs.",
	"Method": "EnumSet<E> of(E e,EnumSet<E> of,E e1,E e2,EnumSet<E> of,E e1,E e2,E e3,EnumSet<E> of,E e1,E e2,E e3,E e4,EnumSet<E> of,E e1,E e2,E e3,E e4,E e5,EnumSet<E> of,E first,E rest){\r\n    EnumSet<E> result = noneOf(first.getDeclaringClass());\r\n    result.add(first);\r\n    for (E e : rest) result.add(e);\r\n    return result;\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TreeUtils.getMethodList",
	"Comment": "returns all executableelements for method declarations of methodname, in class typename, withparams formal parameters.",
	"Method": "List<ExecutableElement> getMethodList(String typeName,String methodName,int params,ProcessingEnvironment env){\r\n    List<ExecutableElement> methods = new ArrayList(1);\r\n    TypeElement typeElt = env.getElementUtils().getTypeElement(typeName);\r\n    for (ExecutableElement exec : ElementFilter.methodsIn(typeElt.getEnclosedElements())) {\r\n        if (exec.getSimpleName().contentEquals(methodName) && exec.getParameters().size() == params) {\r\n            methods.add(exec);\r\n        }\r\n    }\r\n    return methods;\r\n}"
}, {
	"Path": "java.io.DataInputStream.readUnsignedShort",
	"Comment": "see the general contract of the readunsignedshortmethod of datainput.bytesfor this operation are read from the containedinput stream.",
	"Method": "int readUnsignedShort(){\r\n    int ch1 = in.read();\r\n    int ch2 = in.read();\r\n    if ((ch1 | ch2) < 0)\r\n        throw new EOFException();\r\n    return (ch1 << 8) + (ch2 << 0);\r\n}"
}, {
	"Path": "org.checkerframework.common.reflection.MethodValAnnotatedTypeFactory.getClassNamesFromClassValChecker",
	"Comment": "returns a list of class names for the given tree using the class val checker.",
	"Method": "List<String> getClassNamesFromClassValChecker(ExpressionTree tree,boolean mustBeExact){\r\n    ClassValAnnotatedTypeFactory classValATF = getTypeFactoryOfSubchecker(ClassValChecker.class);\r\n    AnnotatedTypeMirror classAnno = classValATF.getAnnotatedType(tree);\r\n    List<String> classNames = new ArrayList();\r\n    AnnotationMirror annotation = classAnno.getAnnotation(ClassVal.class);\r\n    if (annotation != null) {\r\n        classNames = AnnotationUtils.getElementValueArray(annotation, \"value\", String.class, true);\r\n    } else if (!mustBeExact) {\r\n        annotation = classAnno.getAnnotation(ClassBound.class);\r\n        if (annotation != null) {\r\n            classNames = AnnotationUtils.getElementValueArray(annotation, \"value\", String.class, true);\r\n        }\r\n    }\r\n    return classNames;\r\n}"
}, {
	"Path": "java.util.logging.Logger.warning",
	"Comment": "log a warning message.if the logger is currently enabled for the warning messagelevel then the given message is forwarded to all theregistered output handler objects.",
	"Method": "void warning(String msg){\r\n    if (Level.WARNING.intValue() < levelValue) {\r\n        return;\r\n    }\r\n    log(Level.WARNING, msg);\r\n}"
}, {
	"Path": "java.util.Locale.equals",
	"Comment": "returns true if this locale is equal to another object.a locale isdeemed equal to another locale with identical language, script, country,variant and extensions, and unequal to all other objects.",
	"Method": "boolean equals(Object obj,boolean equals,Object obj){\r\n    if (this == obj)\r\n        return true;\r\n    if (!(obj instanceof Locale))\r\n        return false;\r\n    BaseLocale otherBase = ((Locale) obj).baseLocale;\r\n    if (!baseLocale.equals(otherBase)) {\r\n        return false;\r\n    }\r\n    if (localeExtensions == null) {\r\n        return ((Locale) obj).localeExtensions == null;\r\n    }\r\n    return localeExtensions.equals(((Locale) obj).localeExtensions);\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.Hessian2Output.startMessage",
	"Comment": "starts a packeta message contains several objects encapsulated by a lengthp x02 x00",
	"Method": "void startMessage(){\r\n    flushIfFull();\r\n    _buffer[_offset++] = (byte) 'p';\r\n    _buffer[_offset++] = (byte) 2;\r\n    _buffer[_offset++] = (byte) 0;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.FlowExpressionParseUtil.parseArray",
	"Comment": "parse a array access. first of returned pair is a pair of an array to be accessed and anindex. second of returned pair is a remaining string.",
	"Method": "Pair<Pair<String, String>, String> parseArray(String s,Receiver parseArray,String s,FlowExpressionContext context,TreePath path){\r\n    Pair<Pair<String, String>, String> array = parseArray(s);\r\n    if (array == null) {\r\n        return null;\r\n    }\r\n    String receiverStr = array.first.first;\r\n    String indexStr = array.first.second;\r\n    Receiver receiver = parseHelper(receiverStr, context, path);\r\n    FlowExpressionContext contextForIndex = context.copyAndUseOuterReceiver();\r\n    Receiver index = parseHelper(indexStr, contextForIndex, path);\r\n    TypeMirror receiverType = receiver.getType();\r\n    if (!(receiverType instanceof ArrayType)) {\r\n        throw constructParserException(s, String.format(\"receiver not an array: %s : %s\", receiver, receiverType));\r\n    }\r\n    TypeMirror componentType = ((ArrayType) receiverType).getComponentType();\r\n    ArrayAccess result = new ArrayAccess(componentType, receiver, index);\r\n    return result;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentSkipListSet.removeAll",
	"Comment": "removes from this set all of its elements that are contained inthe specified collection.if the specified collection is alsoa set, this operation effectively modifies this set so that itsvalue is the asymmetric set difference of the two sets.",
	"Method": "boolean removeAll(Collection<?> c){\r\n    boolean modified = false;\r\n    for (Object e : c) if (remove(e))\r\n        modified = true;\r\n    return modified;\r\n}"
}, {
	"Path": "java.lang.Math.toRadians",
	"Comment": "converts an angle measured in degrees to an approximatelyequivalent angle measured in radians.the conversion fromdegrees to radians is generally inexact.",
	"Method": "double toRadians(double angdeg){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.lang.String.lastIndexOf",
	"Comment": "code shared by string and stringbuffer to do searches. thesource is the character array being searched, and the targetis the string being searched for.",
	"Method": "int lastIndexOf(int ch,int lastIndexOf,int ch,int fromIndex,int lastIndexOf,String str,int lastIndexOf,String str,int fromIndex,int lastIndexOf,char[] source,int sourceOffset,int sourceCount,String target,int fromIndex,int lastIndexOf,char[] source,int sourceOffset,int sourceCount,char[] target,int targetOffset,int targetCount,int fromIndex){\r\n    int rightIndex = sourceCount - targetCount;\r\n    if (fromIndex < 0) {\r\n        return -1;\r\n    }\r\n    if (fromIndex > rightIndex) {\r\n        fromIndex = rightIndex;\r\n    }\r\n    if (targetCount == 0) {\r\n        return fromIndex;\r\n    }\r\n    int strLastIndex = targetOffset + targetCount - 1;\r\n    char strLastChar = target[strLastIndex];\r\n    int min = sourceOffset + targetCount - 1;\r\n    int i = min + fromIndex;\r\n    startSearchForLastChar: while (true) {\r\n        while (i >= min && source[i] != strLastChar) {\r\n            i--;\r\n        }\r\n        if (i < min) {\r\n            return -1;\r\n        }\r\n        int j = i - 1;\r\n        int start = j - (targetCount - 1);\r\n        int k = strLastIndex - 1;\r\n        while (j > start) {\r\n            if (source[j--] != target[k--]) {\r\n                i--;\r\n                continue startSearchForLastChar;\r\n            }\r\n        }\r\n        return start - sourceOffset + 1;\r\n    }\r\n}"
}, {
	"Path": "java.util.Hashtable.reconstitutionPut",
	"Comment": "the put method used by readobject. this is provided because putis overridable and should not be called in readobject since thesubclass will not yet be initialized.this differs from the regular put method in several ways. nochecking for rehashing is necessary since the number of elementsinitially in the table is known. the modcount is not incrementedbecause we are creating a new instance. also, no return valueis needed.",
	"Method": "void reconstitutionPut(Entry[] tab,K key,V value){\r\n    if (value == null) {\r\n        throw new java.io.StreamCorruptedException();\r\n    }\r\n    int hash = key.hashCode();\r\n    int index = (hash & 0x7FFFFFFF) % tab.length;\r\n    for (Entry<?, ?> e = tab[index]; e != null; e = e.next) {\r\n        if ((e.hash == hash) && e.key.equals(key)) {\r\n            throw new java.io.StreamCorruptedException();\r\n        }\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    Entry<K, V> e = (Entry<K, V>) tab[index];\r\n    tab[index] = new Entry(hash, key, value, e);\r\n    count++;\r\n}"
}, {
	"Path": "com.mycompany.myapp.security.UserContext.getUserDetails",
	"Comment": "retrieve the current userdetails bound to the current thread by spring security, if any.",
	"Method": "UserDetails getUserDetails(){\r\n    Authentication auth = SecurityContextHolder.getContext().getAuthentication();\r\n    if (auth != null && auth.getPrincipal() instanceof UserDetails) {\r\n        return ((UserDetails) auth.getPrincipal());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.TypeArgInferenceUtil.isATarget",
	"Comment": "given a set of type variables for which we are inferring a type, returns true if type is ause of a type variable in the list of targettypevars.",
	"Method": "boolean isATarget(AnnotatedTypeMirror type,Set<TypeVariable> targetTypeVars){\r\n    return type.getKind() == TypeKind.TYPEVAR && targetTypeVars.contains((TypeVariable) TypeAnnotationUtils.unannotatedType(type.getUnderlyingType()));\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.getDeclaredSUID",
	"Comment": "returns explicit serial version uid value declared by given class, ornull if none.",
	"Method": "Long getDeclaredSUID(Class<?> cl){\r\n    try {\r\n        Field f = cl.getDeclaredField(\"serialVersionUID\");\r\n        int mask = Modifier.STATIC | Modifier.FINAL;\r\n        if ((f.getModifiers() & mask) == mask) {\r\n            f.setAccessible(true);\r\n            return Long.valueOf(f.getLong(null));\r\n        }\r\n    } catch (Exception ex) {\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.lang.ClassLoader.addClass",
	"Comment": "invoked by the vm to record every loaded class with this loader.",
	"Method": "void addClass(Class c){\r\n    classes.addElement(c);\r\n}"
}, {
	"Path": "java.util.logging.Logger.finer",
	"Comment": "log a finer message.if the logger is currently enabled for the finer messagelevel then the given message is forwarded to all theregistered output handler objects.",
	"Method": "void finer(String msg){\r\n    if (Level.FINER.intValue() < levelValue) {\r\n        return;\r\n    }\r\n    log(Level.FINER, msg);\r\n}"
}, {
	"Path": "java.util.Calendar.setFieldsComputed",
	"Comment": "sets the state of the specified calendar fields tocomputed. this state means that the specified calendar fieldshave valid values that have been set by internal time calculationrather than by calling one of the setter methods.",
	"Method": "void setFieldsComputed(int fieldMask){\r\n    if (fieldMask == ALL_FIELDS) {\r\n        for (int i = 0; i < fields.length; i++) {\r\n            stamp[i] = COMPUTED;\r\n            isSet[i] = true;\r\n        }\r\n        areFieldsSet = areAllFieldsSet = true;\r\n    } else {\r\n        for (int i = 0; i < fields.length; i++) {\r\n            if ((fieldMask & 1) == 1) {\r\n                stamp[i] = COMPUTED;\r\n                isSet[i] = true;\r\n            } else {\r\n                if (areAllFieldsSet && !isSet[i]) {\r\n                    areAllFieldsSet = false;\r\n                }\r\n            }\r\n            fieldMask >>>= 1;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.RoleDTOService.toEntity",
	"Comment": "converts the passed dto to a role.convenient for query by example.",
	"Method": "Role toEntity(RoleDTO dto,Role toEntity,RoleDTO dto,int depth){\r\n    if (dto == null) {\r\n        return null;\r\n    }\r\n    Role role = new Role();\r\n    role.setId(dto.id);\r\n    role.setRoleName(dto.roleName);\r\n    if (depth-- > 0) {\r\n    }\r\n    return role;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.TypeArgumentMapper.recursiveDepthFirstSearch",
	"Comment": "computes one level for depthfirstsearchforsupertype then recurses.",
	"Method": "List<TypeRecord> recursiveDepthFirstSearch(Stack<TypeRecord> pathFromRoot,TypeElement target,Types types){\r\n    if (pathFromRoot.isEmpty()) {\r\n        return null;\r\n    }\r\n    final TypeRecord currentRecord = pathFromRoot.peek();\r\n    final TypeElement currentElement = currentRecord.element;\r\n    if (currentElement.equals(target)) {\r\n        return new ArrayList(pathFromRoot);\r\n    }\r\n    final Iterator<? extends TypeMirror> interfaces = currentElement.getInterfaces().iterator();\r\n    final TypeMirror superclassType = currentElement.getSuperclass();\r\n    List<TypeRecord> path = null;\r\n    while (path == null && interfaces.hasNext()) {\r\n        final TypeMirror intface = interfaces.next();\r\n        if (intface.getKind() != TypeKind.NONE) {\r\n            DeclaredType interfaceDeclared = (DeclaredType) intface;\r\n            pathFromRoot.push(new TypeRecord((TypeElement) types.asElement(interfaceDeclared), interfaceDeclared));\r\n            path = recursiveDepthFirstSearch(pathFromRoot, target, types);\r\n            pathFromRoot.pop();\r\n        }\r\n    }\r\n    if (path == null && superclassType.getKind() != TypeKind.NONE) {\r\n        final DeclaredType superclass = (DeclaredType) superclassType;\r\n        pathFromRoot.push(new TypeRecord((TypeElement) types.asElement(superclass), superclass));\r\n        path = recursiveDepthFirstSearch(pathFromRoot, target, types);\r\n        pathFromRoot.pop();\r\n    }\r\n    return path;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.dependenttypes.DependentTypesError.isExpressionError",
	"Comment": "returns whether or not the given expression string is an error. that is, whether it is astring that was generated by this class.",
	"Method": "boolean isExpressionError(String expression){\r\n    return expression.startsWith(\"[error\");\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.setRawOffset",
	"Comment": "sets the base time zone offset to gmt.this is the offset to add to utc to get local time.",
	"Method": "void setRawOffset(int offsetMillis){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.Hessian2Output.writeNull",
	"Comment": "writes a null value to the stream.the null will be written with the following syntax",
	"Method": "void writeNull(){\r\n    int offset = _offset;\r\n    byte[] buffer = _buffer;\r\n    if (SIZE <= offset + 16) {\r\n        flushBuffer();\r\n        offset = _offset;\r\n    }\r\n    buffer[offset++] = 'N';\r\n    _offset = offset;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.HashcodeAtmVisitor.reduce",
	"Comment": "used to combine the hashcodes of component types or a type and its component types.",
	"Method": "Integer reduce(Integer hashcode1,Integer hashcode2){\r\n    if (hashcode1 == null) {\r\n        return hashcode2;\r\n    }\r\n    if (hashcode2 == null) {\r\n        return hashcode1;\r\n    }\r\n    return hashcode1 + hashcode2;\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.UpperBoundAnnotatedTypeFactory.getSubstringIndexAnnotatedTypeFactory",
	"Comment": "gets the annotated type factory of the substring index checker running along with the upperbound checker, allowing it to refine the upper bounds of expressions annotated by substringindex checker annotations.",
	"Method": "SubstringIndexAnnotatedTypeFactory getSubstringIndexAnnotatedTypeFactory(){\r\n    return getTypeFactoryOfSubchecker(SubstringIndexChecker.class);\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.GlbUtil.createBottom",
	"Comment": "returns an annotatednulltype with the given annotations as primaries.",
	"Method": "AnnotatedNullType createBottom(AnnotatedTypeFactory typeFactory,Set<? extends AnnotationMirror> annos){\r\n    return typeFactory.getAnnotatedNullType(annos);\r\n}"
}, {
	"Path": "org.checkerframework.common.value.util.Range.signedShiftRight",
	"Comment": "returns a range that includes all possible values resulting from signed right shifting anarbitrary value in this range by an arbitrary number of bits in the specified range. we callthis the signed right shift operation of a range.",
	"Method": "Range signedShiftRight(Range right){\r\n    if (this.isNothing() || right.isNothing()) {\r\n        return NOTHING;\r\n    }\r\n    if (this.isWithinInteger() && right.isWithin(0, 31)) {\r\n        long resultFrom = from >> (from >= 0 ? right.to : right.from);\r\n        long resultTo = to >> (to >= 0 ? right.from : right.to);\r\n        return new Range(resultFrom, resultTo);\r\n    } else {\r\n        return EVERYTHING;\r\n    }\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.HessianInput.startCall",
	"Comment": "starts reading the call, including the headers.the call expects the following protocol datac major minorm b16 b8 method",
	"Method": "void startCall(){\r\n    readCall();\r\n    while (readHeader() != null) {\r\n        readObject();\r\n    }\r\n    readMethod();\r\n}"
}, {
	"Path": "java.beans.PropertyDescriptor.getPropertyEditorClass",
	"Comment": "gets any explicit propertyeditor class that has been registeredfor this property.",
	"Method": "Class<?> getPropertyEditorClass(){\r\n    return (this.propertyEditorClassRef != null) ? this.propertyEditorClassRef.get() : null;\r\n}"
}, {
	"Path": "org.checkerframework.checker.lock.LockStore.changeLockAnnoToTop",
	"Comment": "makes a new cfvalue with the same annotations as currentvalue except that the annotation inthe lockpossiblyheld hierarchy is set to lockpossiblyheld. if currentvalue is null, then anew value is created where the annotation set is lockpossiblyheld and guardedbyunknown",
	"Method": "CFValue changeLockAnnoToTop(Receiver r,CFValue currentValue){\r\n    if (currentValue == null) {\r\n        Set<AnnotationMirror> set = AnnotationUtils.createAnnotationSet();\r\n        set.add(atypeFactory.GUARDEDBYUNKNOWN);\r\n        set.add(atypeFactory.LOCKPOSSIBLYHELD);\r\n        return analysis.createAbstractValue(set, r.getType());\r\n    }\r\n    QualifierHierarchy hierarchy = atypeFactory.getQualifierHierarchy();\r\n    Set<AnnotationMirror> currentSet = currentValue.getAnnotations();\r\n    AnnotationMirror gb = hierarchy.findAnnotationInHierarchy(currentSet, atypeFactory.GUARDEDBYUNKNOWN);\r\n    Set<AnnotationMirror> newSet = AnnotationUtils.createAnnotationSet();\r\n    newSet.add(atypeFactory.LOCKPOSSIBLYHELD);\r\n    if (gb != null) {\r\n        newSet.add(gb);\r\n    }\r\n    return analysis.createAbstractValue(newSet, currentValue.getUnderlyingType());\r\n}"
}, {
	"Path": "java.util.Scanner.hasTokenInBuffer",
	"Comment": "means that there will be another token with or without more input.",
	"Method": "boolean hasTokenInBuffer(){\r\n    matchValid = false;\r\n    matcher.usePattern(delimPattern);\r\n    matcher.region(position, buf.limit());\r\n    if (matcher.lookingAt())\r\n        position = matcher.end();\r\n    if (position == buf.limit())\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.CheckerMain.concatenatePaths",
	"Comment": "given a list of paths, concatenate them to form a single path. also expand wildcards.",
	"Method": "String concatenatePaths(List<String> paths){\r\n    List<String> elements = new ArrayList();\r\n    for (String path : paths) {\r\n        for (String element : path.split(File.pathSeparator)) {\r\n            elements.addAll(expandWildcards(element));\r\n        }\r\n    }\r\n    return String.join(File.pathSeparator, elements);\r\n}"
}, {
	"Path": "java.awt.image.ColorModel.hasAlpha",
	"Comment": "returns whether or not alpha is supported in thiscolormodel.",
	"Method": "boolean hasAlpha(){\r\n    return supportsAlpha;\r\n}"
}, {
	"Path": "java.nio.Buffer.remaining",
	"Comment": "returns the number of elements between the current position and thelimit.",
	"Method": "int remaining(){\r\n    return limit - position;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeMirror.hasEffectiveAnnotationRelaxed",
	"Comment": "a version of hasannotationrelaxed that considers annotations on the upper bound of wildcardsand type variables.",
	"Method": "boolean hasEffectiveAnnotationRelaxed(AnnotationMirror a){\r\n    return AnnotationUtils.containsSameIgnoringValues(getEffectiveAnnotations(), a);\r\n}"
}, {
	"Path": "sun.util.LocaleServiceProviderPool.hasProviders",
	"Comment": "returns whether any provider for this locale sensitiveservice is available or not.",
	"Method": "boolean hasProviders(){\r\n    return !providers.isEmpty();\r\n}"
}, {
	"Path": "java.net.Socket.sendUrgentData",
	"Comment": "send one byte of urgent data on the socket. the byte to be sent is the lowest eightbits of the data parameter. the urgent byte issent after any preceding writes to the socket outputstreamand before any future writes to the outputstream.",
	"Method": "void sendUrgentData(int data){\r\n    if (!getImpl().supportsUrgentData()) {\r\n        throw new SocketException(\"Urgent data not supported\");\r\n    }\r\n    getImpl().sendUrgentData(data);\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.Hessian2Input.readObject",
	"Comment": "reads an arbitrary object from the input stream when the typeis unknown.",
	"Method": "Object readObject(Class cl,Object readObject){\r\n    int tag = _offset < _length ? (_buffer[_offset++] & 0xff) : read();\r\n    switch(tag) {\r\n        case 'N':\r\n            return null;\r\n        case 'T':\r\n            return Boolean.valueOf(true);\r\n        case 'F':\r\n            return Boolean.valueOf(false);\r\n        case 0x80:\r\n        case 0x81:\r\n        case 0x82:\r\n        case 0x83:\r\n        case 0x84:\r\n        case 0x85:\r\n        case 0x86:\r\n        case 0x87:\r\n        case 0x88:\r\n        case 0x89:\r\n        case 0x8a:\r\n        case 0x8b:\r\n        case 0x8c:\r\n        case 0x8d:\r\n        case 0x8e:\r\n        case 0x8f:\r\n        case 0x90:\r\n        case 0x91:\r\n        case 0x92:\r\n        case 0x93:\r\n        case 0x94:\r\n        case 0x95:\r\n        case 0x96:\r\n        case 0x97:\r\n        case 0x98:\r\n        case 0x99:\r\n        case 0x9a:\r\n        case 0x9b:\r\n        case 0x9c:\r\n        case 0x9d:\r\n        case 0x9e:\r\n        case 0x9f:\r\n        case 0xa0:\r\n        case 0xa1:\r\n        case 0xa2:\r\n        case 0xa3:\r\n        case 0xa4:\r\n        case 0xa5:\r\n        case 0xa6:\r\n        case 0xa7:\r\n        case 0xa8:\r\n        case 0xa9:\r\n        case 0xaa:\r\n        case 0xab:\r\n        case 0xac:\r\n        case 0xad:\r\n        case 0xae:\r\n        case 0xaf:\r\n        case 0xb0:\r\n        case 0xb1:\r\n        case 0xb2:\r\n        case 0xb3:\r\n        case 0xb4:\r\n        case 0xb5:\r\n        case 0xb6:\r\n        case 0xb7:\r\n        case 0xb8:\r\n        case 0xb9:\r\n        case 0xba:\r\n        case 0xbb:\r\n        case 0xbc:\r\n        case 0xbd:\r\n        case 0xbe:\r\n        case 0xbf:\r\n            return Integer.valueOf(tag - BC_INT_ZERO);\r\n        case 0xc0:\r\n        case 0xc1:\r\n        case 0xc2:\r\n        case 0xc3:\r\n        case 0xc4:\r\n        case 0xc5:\r\n        case 0xc6:\r\n        case 0xc7:\r\n        case 0xc8:\r\n        case 0xc9:\r\n        case 0xca:\r\n        case 0xcb:\r\n        case 0xcc:\r\n        case 0xcd:\r\n        case 0xce:\r\n        case 0xcf:\r\n            return Integer.valueOf(((tag - BC_INT_BYTE_ZERO) << 8) + read());\r\n        case 0xd0:\r\n        case 0xd1:\r\n        case 0xd2:\r\n        case 0xd3:\r\n        case 0xd4:\r\n        case 0xd5:\r\n        case 0xd6:\r\n        case 0xd7:\r\n            return Integer.valueOf(((tag - BC_INT_SHORT_ZERO) << 16) + 256 * read() + read());\r\n        case 'I':\r\n            return Integer.valueOf(parseInt());\r\n        case 0xd8:\r\n        case 0xd9:\r\n        case 0xda:\r\n        case 0xdb:\r\n        case 0xdc:\r\n        case 0xdd:\r\n        case 0xde:\r\n        case 0xdf:\r\n        case 0xe0:\r\n        case 0xe1:\r\n        case 0xe2:\r\n        case 0xe3:\r\n        case 0xe4:\r\n        case 0xe5:\r\n        case 0xe6:\r\n        case 0xe7:\r\n        case 0xe8:\r\n        case 0xe9:\r\n        case 0xea:\r\n        case 0xeb:\r\n        case 0xec:\r\n        case 0xed:\r\n        case 0xee:\r\n        case 0xef:\r\n            return Long.valueOf(tag - BC_LONG_ZERO);\r\n        case 0xf0:\r\n        case 0xf1:\r\n        case 0xf2:\r\n        case 0xf3:\r\n        case 0xf4:\r\n        case 0xf5:\r\n        case 0xf6:\r\n        case 0xf7:\r\n        case 0xf8:\r\n        case 0xf9:\r\n        case 0xfa:\r\n        case 0xfb:\r\n        case 0xfc:\r\n        case 0xfd:\r\n        case 0xfe:\r\n        case 0xff:\r\n            return Long.valueOf(((tag - BC_LONG_BYTE_ZERO) << 8) + read());\r\n        case 0x38:\r\n        case 0x39:\r\n        case 0x3a:\r\n        case 0x3b:\r\n        case 0x3c:\r\n        case 0x3d:\r\n        case 0x3e:\r\n        case 0x3f:\r\n            return Long.valueOf(((tag - BC_LONG_SHORT_ZERO) << 16) + 256 * read() + read());\r\n        case BC_LONG_INT:\r\n            return Long.valueOf(parseInt());\r\n        case 'L':\r\n            return Long.valueOf(parseLong());\r\n        case BC_DOUBLE_ZERO:\r\n            return Double.valueOf(0);\r\n        case BC_DOUBLE_ONE:\r\n            return Double.valueOf(1);\r\n        case BC_DOUBLE_BYTE:\r\n            return Double.valueOf((byte) read());\r\n        case BC_DOUBLE_SHORT:\r\n            return Double.valueOf((short) (256 * read() + read()));\r\n        case BC_DOUBLE_MILL:\r\n            {\r\n                int mills = parseInt();\r\n                return Double.valueOf(0.001 * mills);\r\n            }\r\n        case 'D':\r\n            return Double.valueOf(parseDouble());\r\n        case BC_DATE:\r\n            return new Date(parseLong());\r\n        case BC_DATE_MINUTE:\r\n            return new Date(parseInt() * 60000L);\r\n        case BC_STRING_CHUNK:\r\n        case 'S':\r\n            {\r\n                _isLastChunk = tag == 'S';\r\n                _chunkLength = (read() << 8) + read();\r\n                int data;\r\n                _sbuf.setLength(0);\r\n                while ((data = parseChar()) >= 0) {\r\n                    _sbuf.append((char) data);\r\n                }\r\n                return _sbuf.toString();\r\n            }\r\n        case 0x00:\r\n        case 0x01:\r\n        case 0x02:\r\n        case 0x03:\r\n        case 0x04:\r\n        case 0x05:\r\n        case 0x06:\r\n        case 0x07:\r\n        case 0x08:\r\n        case 0x09:\r\n        case 0x0a:\r\n        case 0x0b:\r\n        case 0x0c:\r\n        case 0x0d:\r\n        case 0x0e:\r\n        case 0x0f:\r\n        case 0x10:\r\n        case 0x11:\r\n        case 0x12:\r\n        case 0x13:\r\n        case 0x14:\r\n        case 0x15:\r\n        case 0x16:\r\n        case 0x17:\r\n        case 0x18:\r\n        case 0x19:\r\n        case 0x1a:\r\n        case 0x1b:\r\n        case 0x1c:\r\n        case 0x1d:\r\n        case 0x1e:\r\n        case 0x1f:\r\n            {\r\n                _isLastChunk = true;\r\n                _chunkLength = tag - 0x00;\r\n                int data;\r\n                _sbuf.setLength(0);\r\n                while ((data = parseChar()) >= 0) {\r\n                    _sbuf.append((char) data);\r\n                }\r\n                return _sbuf.toString();\r\n            }\r\n        case 0x30:\r\n        case 0x31:\r\n        case 0x32:\r\n        case 0x33:\r\n            {\r\n                _isLastChunk = true;\r\n                _chunkLength = (tag - 0x30) * 256 + read();\r\n                _sbuf.setLength(0);\r\n                int ch;\r\n                while ((ch = parseChar()) >= 0) {\r\n                    _sbuf.append((char) ch);\r\n                }\r\n                return _sbuf.toString();\r\n            }\r\n        case BC_BINARY_CHUNK:\r\n        case 'B':\r\n            {\r\n                _isLastChunk = tag == 'B';\r\n                _chunkLength = (read() << 8) + read();\r\n                int data;\r\n                ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n                while ((data = parseByte()) >= 0) {\r\n                    bos.write(data);\r\n                }\r\n                return bos.toByteArray();\r\n            }\r\n        case 0x20:\r\n        case 0x21:\r\n        case 0x22:\r\n        case 0x23:\r\n        case 0x24:\r\n        case 0x25:\r\n        case 0x26:\r\n        case 0x27:\r\n        case 0x28:\r\n        case 0x29:\r\n        case 0x2a:\r\n        case 0x2b:\r\n        case 0x2c:\r\n        case 0x2d:\r\n        case 0x2e:\r\n        case 0x2f:\r\n            {\r\n                _isLastChunk = true;\r\n                int len = tag - 0x20;\r\n                _chunkLength = 0;\r\n                byte[] data = new byte[len];\r\n                for (int i = 0; i < len; i++) {\r\n                    data[i] = (byte) read();\r\n                }\r\n                return data;\r\n            }\r\n        case 0x34:\r\n        case 0x35:\r\n        case 0x36:\r\n        case 0x37:\r\n            {\r\n                _isLastChunk = true;\r\n                int len = (tag - 0x34) * 256 + read();\r\n                _chunkLength = 0;\r\n                byte[] buffer = new byte[len];\r\n                for (int i = 0; i < len; i++) {\r\n                    buffer[i] = (byte) read();\r\n                }\r\n                return buffer;\r\n            }\r\n        case BC_LIST_VARIABLE:\r\n            {\r\n                String type = readType();\r\n                return findSerializerFactory().readList(this, -1, type);\r\n            }\r\n        case BC_LIST_VARIABLE_UNTYPED:\r\n            {\r\n                return findSerializerFactory().readList(this, -1, null);\r\n            }\r\n        case BC_LIST_FIXED:\r\n            {\r\n                String type = readType();\r\n                int length = readInt();\r\n                Deserializer reader;\r\n                reader = findSerializerFactory().getListDeserializer(type, null);\r\n                return reader.readLengthList(this, length);\r\n            }\r\n        case BC_LIST_FIXED_UNTYPED:\r\n            {\r\n                int length = readInt();\r\n                Deserializer reader;\r\n                reader = findSerializerFactory().getListDeserializer(null, null);\r\n                return reader.readLengthList(this, length);\r\n            }\r\n        case 0x70:\r\n        case 0x71:\r\n        case 0x72:\r\n        case 0x73:\r\n        case 0x74:\r\n        case 0x75:\r\n        case 0x76:\r\n        case 0x77:\r\n            {\r\n                String type = readType();\r\n                int length = tag - 0x70;\r\n                Deserializer reader;\r\n                reader = findSerializerFactory().getListDeserializer(type, null);\r\n                return reader.readLengthList(this, length);\r\n            }\r\n        case 0x78:\r\n        case 0x79:\r\n        case 0x7a:\r\n        case 0x7b:\r\n        case 0x7c:\r\n        case 0x7d:\r\n        case 0x7e:\r\n        case 0x7f:\r\n            {\r\n                int length = tag - 0x78;\r\n                Deserializer reader;\r\n                reader = findSerializerFactory().getListDeserializer(null, null);\r\n                return reader.readLengthList(this, length);\r\n            }\r\n        case 'H':\r\n            {\r\n                return findSerializerFactory().readMap(this, null);\r\n            }\r\n        case 'M':\r\n            {\r\n                String type = readType();\r\n                return findSerializerFactory().readMap(this, type);\r\n            }\r\n        case 'C':\r\n            {\r\n                readObjectDefinition(null);\r\n                return readObject();\r\n            }\r\n        case 0x60:\r\n        case 0x61:\r\n        case 0x62:\r\n        case 0x63:\r\n        case 0x64:\r\n        case 0x65:\r\n        case 0x66:\r\n        case 0x67:\r\n        case 0x68:\r\n        case 0x69:\r\n        case 0x6a:\r\n        case 0x6b:\r\n        case 0x6c:\r\n        case 0x6d:\r\n        case 0x6e:\r\n        case 0x6f:\r\n            {\r\n                int ref = tag - 0x60;\r\n                if (_classDefs.size() <= ref) {\r\n                    throw error(\"No classes defined at reference '\" + Integer.toHexString(tag) + \"'\");\r\n                }\r\n                ObjectDefinition def = _classDefs.get(ref);\r\n                return readObjectInstance(null, def);\r\n            }\r\n        case 'O':\r\n            {\r\n                int ref = readInt();\r\n                if (_classDefs.size() <= ref) {\r\n                    throw error(\"Illegal object reference #\" + ref);\r\n                }\r\n                ObjectDefinition def = _classDefs.get(ref);\r\n                return readObjectInstance(null, def);\r\n            }\r\n        case BC_REF:\r\n            {\r\n                int ref = readInt();\r\n                return _refs.get(ref);\r\n            }\r\n        default:\r\n            if (tag < 0) {\r\n                throw new EOFException(\"readObject: unexpected end of file\");\r\n            } else {\r\n                throw error(\"readObject: unknown code \" + codeName(tag));\r\n            }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.UpperBoundVisitor.checkMinLen",
	"Comment": "queries the value checker to determine if the maximum possible value of indextree is less than the minimum possible length of arrtree, and returns true if so.",
	"Method": "boolean checkMinLen(ExpressionTree indexTree,ExpressionTree arrTree){\r\n    int minLen = IndexUtil.getMinLen(arrTree, atypeFactory.getValueAnnotatedTypeFactory());\r\n    Long valMax = IndexUtil.getMaxValue(indexTree, atypeFactory.getValueAnnotatedTypeFactory());\r\n    if (valMax != null && valMax < minLen) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.getOrDefault",
	"Comment": "returns the value to which the specified key is mapped, or thegiven default value if this map contains no mapping for thekey.",
	"Method": "V getOrDefault(Object key,V defaultValue){\r\n    V v;\r\n    return (v = get(key)) == null ? defaultValue : v;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.DefaultTypeArgumentInference.combineSupertypeAndAssignmentResults",
	"Comment": "step 4. combine the results from using the supertype constraints the equality constraintsfrom the assignment context.",
	"Method": "InferenceResult combineSupertypeAndAssignmentResults(Set<TypeVariable> targets,AnnotatedTypeFactory typeFactory,InferenceResult equalityResult,InferenceResult supertypeResult){\r\n    final TypeHierarchy typeHierarchy = typeFactory.getTypeHierarchy();\r\n    final InferenceResult result = new InferenceResult();\r\n    for (final TypeVariable target : targets) {\r\n        final InferredValue equalityInferred = equalityResult.get(target);\r\n        final InferredValue supertypeInferred = supertypeResult.get(target);\r\n        final InferredValue outputValue;\r\n        if (equalityInferred != null && equalityInferred instanceof InferredType) {\r\n            if (supertypeInferred != null && supertypeInferred instanceof InferredType) {\r\n                AnnotatedTypeMirror superATM = ((InferredType) supertypeInferred).type;\r\n                AnnotatedTypeMirror equalityATM = ((InferredType) equalityInferred).type;\r\n                if (TypesUtils.isErasedSubtype(equalityATM.getUnderlyingType(), superATM.getUnderlyingType(), typeFactory.getContext().getTypeUtils())) {\r\n                    equalityATM = AnnotatedTypes.asSuper(typeFactory, equalityATM, superATM);\r\n                }\r\n                if (typeHierarchy.isSubtype(superATM, equalityATM)) {\r\n                    outputValue = equalityInferred;\r\n                } else {\r\n                    outputValue = supertypeInferred;\r\n                }\r\n            } else {\r\n                outputValue = equalityInferred;\r\n            }\r\n        } else {\r\n            if (supertypeInferred != null) {\r\n                outputValue = supertypeInferred;\r\n            } else {\r\n                outputValue = null;\r\n            }\r\n        }\r\n        if (outputValue != null) {\r\n            result.put(target, outputValue);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "java.util.HashMap.getEntry",
	"Comment": "returns the entry associated with the specified key in thehashmap.returns null if the hashmap contains no mappingfor the key.",
	"Method": "Entry<K, V> getEntry(Object key){\r\n    int hash = (key == null) ? 0 : hash(key.hashCode());\r\n    for (Entry<K, V> e = table[indexFor(hash, table.length)]; e != null; e = e.next) {\r\n        Object k;\r\n        if (e.hash == hash && ((k = e.key) == key || (key != null && key.equals(k))))\r\n            return e;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.beans.PropertyDescriptor.compareMethods",
	"Comment": "package private helper method for descriptor .equals methods.",
	"Method": "boolean compareMethods(Method a,Method b){\r\n    if ((a == null) != (b == null)) {\r\n        return false;\r\n    }\r\n    if (a != null && b != null) {\r\n        if (!a.equals(b)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.checkerframework.checker.signedness.SignednessAnnotatedTypeFactory.addUnknownSignednessToSomeLocals",
	"Comment": "if the tree is a local variable and the type is a byte, short, int or long, then it adds theunknownsignedness annotation so that data flow can refine it.",
	"Method": "void addUnknownSignednessToSomeLocals(Tree tree,AnnotatedTypeMirror type){\r\n    switch(type.getKind()) {\r\n        case BYTE:\r\n        case SHORT:\r\n        case INT:\r\n        case LONG:\r\n        case FLOAT:\r\n        case DOUBLE:\r\n        case CHAR:\r\n            QualifierDefaults defaults = new QualifierDefaults(elements, this);\r\n            defaults.addCheckedCodeDefault(UNKNOWN_SIGNEDNESS, TypeUseLocation.LOCAL_VARIABLE);\r\n            defaults.annotate(tree, type);\r\n            break;\r\n        default:\r\n    }\r\n}"
}, {
	"Path": "java.util.RegularEnumSet.equals",
	"Comment": "compares the specified object with this set for equality.returnstrue if the given object is also a set, the two sets havethe same size, and every member of the given set is contained inthis set.",
	"Method": "boolean equals(Object o){\r\n    if (!(o instanceof RegularEnumSet))\r\n        return super.equals(o);\r\n    RegularEnumSet es = (RegularEnumSet) o;\r\n    if (es.elementType != elementType)\r\n        return elements == 0 && es.elements == 0;\r\n    return es.elements == elements;\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.read",
	"Comment": "reads a byte of data. this method will block if no input is available.",
	"Method": "int read(int read,byte[] buf,int off,int len,int read,int read,byte[] b,int off,int len,int read,int read,byte[] b,int off,int len,int read,byte[] b,int off,int len,boolean copy){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.Calendar.getActualMaximum",
	"Comment": "returns the maximum value that the specified calendar fieldcould have, given the time value of thiscalendar. for example, the actual maximum value ofthe month field is 12 in some years, and 13 inother years in the hebrew calendar system.the default implementation of this method uses an iterativealgorithm to determine the actual maximum value for thecalendar field. subclasses should, if possible, override thiswith a more efficient implementation.",
	"Method": "int getActualMaximum(int field){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.io.BufferedInputStream.markSupported",
	"Comment": "tests if this input stream supports the markand reset methods. the marksupportedmethod of bufferedinputstream returnstrue.",
	"Method": "boolean markSupported(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.solver.InferenceResult.mergeTarget",
	"Comment": "performs a merge for a specific target, we keep only results that lead to a concrete type.",
	"Method": "InferredType mergeTarget(TypeVariable target,InferenceResult subordinate){\r\n    final InferredValue inferred = this.get(target);\r\n    if (inferred instanceof InferredTarget) {\r\n        InferredType newType = mergeTarget(((InferredTarget) inferred).target, subordinate);\r\n        if (newType == null) {\r\n            final InferredValue subValue = subordinate.get(target);\r\n            if (subValue != null && subValue instanceof InferredType) {\r\n                this.put(target, subValue);\r\n                return null;\r\n            }\r\n        } else {\r\n            if (newType.type.getKind() == TypeKind.NULL) {\r\n                final InferredValue subValue = subordinate.get(target);\r\n                if (subValue != null && subValue instanceof InferredType) {\r\n                    AnnotatedTypeMirror copy = ((InferredType) subValue).type.deepCopy();\r\n                    copy.replaceAnnotations(newType.type.getAnnotations());\r\n                    newType = new InferredType(copy);\r\n                }\r\n            }\r\n            this.put(target, newType);\r\n            return newType;\r\n        }\r\n        return null;\r\n    }\r\n    return (InferredType) inferred;\r\n}"
}, {
	"Path": "java.util.zip.Inflater.getRemaining",
	"Comment": "returns the total number of bytes remaining in the input buffer.this can be used to find out what bytes still remain in the inputbuffer after decompression has finished.",
	"Method": "int getRemaining(){\r\n    synchronized (zsRef) {\r\n        return len;\r\n    }\r\n}"
}, {
	"Path": "java.lang.Integer.remainderUnsigned",
	"Comment": "returns the unsigned remainder from dividing the first argumentby the second where each argument and the result is interpretedas an unsigned value.",
	"Method": "int remainderUnsigned(int dividend,int divisor){\r\n    return (int) (toUnsignedLong(dividend) % toUnsignedLong(divisor));\r\n}"
}, {
	"Path": "java.io.ByteArrayOutputStream.reset",
	"Comment": "resets the count field of this byte array outputstream to zero, so that all currently accumulated output in theoutput stream is discarded. the output stream can be used again,reusing the already allocated buffer space.",
	"Method": "void reset(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.io.StringBufferInputStream.available",
	"Comment": "returns the number of bytes that can be read from the inputstream without blocking.",
	"Method": "int available(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.logging.Logger.setParent",
	"Comment": "set the parent for this logger.this method is used bythe logmanager to update a logger when the namespace changes.it should not be called from application code.",
	"Method": "void setParent(Logger parent){\r\n    if (parent == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    manager.checkAccess();\r\n    doSetParent(parent);\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.UBQualifier.isLessThanOrEqualTo",
	"Comment": "is the value with this qualifier less than or equal to the length of sequence?",
	"Method": "boolean isLessThanOrEqualTo(String sequence,boolean isLessThanOrEqualTo,String sequence){\r\n    return false;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.getCacheSize",
	"Comment": "returns the int supplied to the checker via the atfcachesize option or the default cachesize.",
	"Method": "int getCacheSize(){\r\n    String option = checker.getOption(\"atfCacheSize\");\r\n    if (option == null) {\r\n        return DEFAULT_CACHE_SIZE;\r\n    }\r\n    try {\r\n        return Integer.valueOf(option);\r\n    } catch (NumberFormatException ex) {\r\n        throw new UserError(\"atfCacheSize was not an integer: \" + option);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.diagnostics.TestDiagnosticUtils.isJavaDiagnosticLineStart",
	"Comment": "return true if this line in a java file indicates an expected diagnostic.",
	"Method": "boolean isJavaDiagnosticLineStart(String originalLine){\r\n    final String trimmedLine = originalLine.trim();\r\n    return trimmedLine.startsWith(\"// ::\") || trimmedLine.startsWith(\"// warning:\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.diagnostics.JavaDiagnosticReader.getDiagnostics",
	"Comment": "converts a list of testdiagnosticline into a list of testdiagnostic.",
	"Method": "List<TestDiagnostic> getDiagnostics(List<TestDiagnosticLine> lines){\r\n    List<TestDiagnostic> result = new ArrayList((int) (lines.size() * 1.1));\r\n    for (TestDiagnosticLine line : lines) {\r\n        result.addAll(line.getDiagnostics());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.writeTypeString",
	"Comment": "writes string without allowing it to be replaced in stream.used byobjectstreamclass to write class descriptor type strings.",
	"Method": "void writeTypeString(String str){\r\n    int handle;\r\n    if (str == null) {\r\n        writeNull();\r\n    } else if ((handle = handles.lookup(str)) != -1) {\r\n        writeHandle(handle);\r\n    } else {\r\n        writeString(str, false);\r\n    }\r\n}"
}, {
	"Path": "com.alibaba.citrus.generictype.codegen.asm.Method.getDescriptor",
	"Comment": "returns the descriptor of the method described by this object.",
	"Method": "String getDescriptor(){\r\n    return desc;\r\n}"
}, {
	"Path": "org.checkerframework.common.wholeprograminference.WholeProgramInferenceScenes.updateInferredExecutableParameterTypes",
	"Comment": "helper method for updating parameter types based on calls to a method or constructor.",
	"Method": "void updateInferredExecutableParameterTypes(ExecutableElement methodElt,AnnotatedTypeFactory atf,String jaifPath,AMethod method,List<Node> arguments){\r\n    for (int i = 0; i < arguments.size(); i++) {\r\n        VariableElement ve = methodElt.getParameters().get(i);\r\n        AnnotatedTypeMirror paramATM = atf.getAnnotatedType(ve);\r\n        Node arg = arguments.get(i);\r\n        Tree treeNode = arg.getTree();\r\n        if (treeNode == null) {\r\n            continue;\r\n        }\r\n        AnnotatedTypeMirror argATM = atf.getAnnotatedType(treeNode);\r\n        AField param = method.parameters.vivify(i);\r\n        helper.updateAnnotationSetInScene(param.type, atf, jaifPath, argATM, paramATM, TypeUseLocation.PARAMETER);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.GenericAnnotatedTypeFactory.getAnnotationFromJavaExpressionString",
	"Comment": "returns the primary annotation on expression if it were evaluated at path.",
	"Method": "AnnotationMirror getAnnotationFromJavaExpressionString(String expression,Tree tree,TreePath path,Class<? extends Annotation> clazz){\r\n    Receiver expressionObj = getReceiverFromJavaExpressionString(expression, path);\r\n    return getAnnotationFromReceiver(expressionObj, tree, clazz);\r\n}"
}, {
	"Path": "org.checkerframework.framework.flow.CFAbstractTransfer.isNotFullyInitializedReceiver",
	"Comment": "returns true if the receiver of a method might not yet be fully initialized.",
	"Method": "boolean isNotFullyInitializedReceiver(MethodTree methodTree){\r\n    return TreeUtils.isConstructor(methodTree);\r\n}"
}, {
	"Path": "java.io.PipedWriter.flush",
	"Comment": "flushes this output stream and forces any buffered output charactersto be written out.this will notify any readers that characters are waiting in the pipe.",
	"Method": "void flush(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.Collections.fill",
	"Comment": "replaces all of the elements of the specified list with the specifiedelement. this method runs in linear time.",
	"Method": "void fill(List<? super T> list,T obj){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.common.value.util.Range.isWithinInteger",
	"Comment": "determines if this range is completely contained in the scope of the integer type.",
	"Method": "boolean isWithinInteger(){\r\n    return isWithin(Integer.MIN_VALUE, Integer.MAX_VALUE);\r\n}"
}, {
	"Path": "com.mycompany.myapp.domain.Role.toString",
	"Comment": "construct a readable string representation for this role instance.",
	"Method": "String toString(){\r\n    return // \r\n    MoreObjects.toStringHelper(this).add(\"id\", // \r\n    getId()).add(\"roleName\", getRoleName()).toString();\r\n}"
}, {
	"Path": "java.util.EnumMap.containsKey",
	"Comment": "returns true if this map contains a mapping for the specifiedkey.",
	"Method": "boolean containsKey(Object key){\r\n    return isValidKey(key) && vals[((Enum) key).ordinal()] != null;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.GenericAnnotatedTypeFactory.getResultingTypeOfConstructorMemberReference",
	"Comment": "gets the type of the resulting constructor call of a memberreferencetree.",
	"Method": "AnnotatedTypeMirror getResultingTypeOfConstructorMemberReference(MemberReferenceTree memberReferenceTree,AnnotatedExecutableType constructorType){\r\n    assert memberReferenceTree.getMode() == MemberReferenceTree.ReferenceMode.NEW;\r\n    AnnotatedDeclaredType constructorReturnType = (AnnotatedDeclaredType) fromTypeTree(memberReferenceTree.getQualifierExpression());\r\n    AnnotatedTypes.copyOnlyExplicitConstructorAnnotations(this, constructorReturnType, constructorType);\r\n    addComputedTypeAnnotations(memberReferenceTree.getQualifierExpression(), constructorReturnType);\r\n    return constructorReturnType;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.QualifierHierarchy.findAnnotationInSameHierarchy",
	"Comment": "returns the annotation in annos that is in the same hierarchy as annotationmirror.if the annotation in the hierarchy is polyall, then the polymorphic qualifier in thehierarchy is returned instead of polyall.",
	"Method": "AnnotationMirror findAnnotationInSameHierarchy(Collection<? extends AnnotationMirror> annos,AnnotationMirror annotationMirror){\r\n    AnnotationMirror top = this.getTopAnnotation(annotationMirror);\r\n    return findAnnotationInHierarchy(annos, top);\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.defaults.QualifierDefaults.validLocationsForUncheckedCodeDefaults",
	"Comment": "returns an array of locations that are valid for the unchecked value defaults. these aresimply by syntax, since an entire file is typechecked, it is not possible for local variablesto be unchecked.",
	"Method": "TypeUseLocation[] validLocationsForUncheckedCodeDefaults(){\r\n    return validUncheckedCodeDefaultLocations;\r\n}"
}, {
	"Path": "org.checkerframework.framework.flow.CFAbstractStore.updateForLocalVariableAssignment",
	"Comment": "set the abstract value of a local variable in the store. overwrites any value that might havebeen available previously.",
	"Method": "void updateForLocalVariableAssignment(LocalVariable receiver,V val){\r\n    removeConflicting(receiver);\r\n    if (val != null) {\r\n        localVariableValues.put(receiver, val);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeMirror.getAnnotation",
	"Comment": "returns the actual annotation mirror used to annotate this type, whose class equals thepassed annoclass if one exists, null otherwise.",
	"Method": "AnnotationMirror getAnnotation(Class<? extends Annotation> annoClass){\r\n    for (AnnotationMirror annoMirror : annotations) {\r\n        if (AnnotationUtils.areSameByClass(annoMirror, annoClass)) {\r\n            return annoMirror;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.SimpleOptionMap.setOptions",
	"Comment": "clears the current set of options and copies the input options to this map.",
	"Method": "void setOptions(Map<String, String> options){\r\n    this.options.clear();\r\n    this.options.putAll(options);\r\n}"
}, {
	"Path": "java.text.MessageFormat.setFormatsByArgumentIndex",
	"Comment": "sets the formats to use for the values passed intoformat methods or returned from parsemethods. the indices of elements in newformatscorrespond to the argument indices used in the previously setpattern string.the order of formats in newformats thus corresponds tothe order of elements in the arguments array passedto the format methods or the result array returnedby the parse methods.if an argument index is used for more than one format elementin the pattern string, then the corresponding new format is usedfor all such format elements. if an argument index is not usedfor any format element in the pattern string, then thecorresponding new format is ignored. if fewer formats are providedthan needed, then only the formats for argument indices lessthan newformats.length are replaced.",
	"Method": "void setFormatsByArgumentIndex(Format[] newFormats){\r\n    for (int i = 0; i <= maxOffset; i++) {\r\n        int j = argumentNumbers[i];\r\n        if (j < newFormats.length) {\r\n            formats[i] = newFormats[j];\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.StubGenerator.stubFromMethod",
	"Comment": "generate the stub file for all the classes within the provided package.",
	"Method": "void stubFromMethod(Element elt){\r\n    if (!(elt.getKind() == ElementKind.CONSTRUCTOR || elt.getKind() == ElementKind.METHOD)) {\r\n        return;\r\n    }\r\n    String newPackage = ElementUtils.getVerboseName(ElementUtils.enclosingPackage(elt));\r\n    if (!newPackage.equals(\"\")) {\r\n        currentPackage = newPackage;\r\n        currentIndention = \"    \";\r\n        indent();\r\n    }\r\n    ExecutableElement method = (ExecutableElement) elt;\r\n    printMethodDecl(method);\r\n}"
}, {
	"Path": "java.util.RegularEnumSet.add",
	"Comment": "adds the specified element to this set if it is not already present.",
	"Method": "boolean add(E e){\r\n    typeCheck(e);\r\n    long oldElements = elements;\r\n    elements |= (1L << ((Enum) e).ordinal());\r\n    return elements != oldElements;\r\n}"
}, {
	"Path": "org.checkerframework.common.value.RangeOrListOfValues.convertToRange",
	"Comment": "transforms this into a range. fails if there are no values in the list. has no effect if thisis already a range.",
	"Method": "void convertToRange(){\r\n    if (!isRange) {\r\n        isRange = true;\r\n        range = new Range(Collections.min(values), Collections.max(values));\r\n        values = null;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.common.wholeprograminference.WholeProgramInferenceScenesHelper.getAClass",
	"Comment": "returns the aclass in an ascene, given a classname and a jaifpath.",
	"Method": "AClass getAClass(String className,String jaifPath){\r\n    AScene scene = getScene(jaifPath);\r\n    return scene.classes.vivify(className);\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.trees.TreeBuilder.buildAssignment",
	"Comment": "builds an ast tree to assign an rhs expression to an lhs expression.",
	"Method": "StatementTree buildAssignment(VariableTree variable,ExpressionTree expr,AssignmentTree buildAssignment,ExpressionTree lhs,ExpressionTree rhs){\r\n    JCTree.JCAssign assign = maker.Assign((JCTree.JCExpression) lhs, (JCTree.JCExpression) rhs);\r\n    assign.setType((Type) TreeUtils.typeOf(lhs));\r\n    return assign;\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.util.IntMap.put",
	"Comment": "puts a new value in the property table with the appropriate flags",
	"Method": "int put(Object key,int value,boolean isReplace){\r\n    int prime = _prime;\r\n    int hash = hashCode(key) % prime;\r\n    Object[] keys = _keys;\r\n    while (true) {\r\n        Object testKey = keys[hash];\r\n        if (testKey == null) {\r\n            keys[hash] = key;\r\n            _values[hash] = value;\r\n            _size++;\r\n            if (keys.length <= 4 * _size) {\r\n                resize(4 * keys.length);\r\n            }\r\n            return NULL;\r\n        } else if (key != testKey) {\r\n            hash = (hash + 1) % prime;\r\n            continue;\r\n        } else if (isReplace) {\r\n            int old = _values[hash];\r\n            _values[hash] = value;\r\n            return old;\r\n        } else {\r\n            return _values[hash];\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.VersionListReader.readSupportedVersions",
	"Comment": "read the supported checkstyle versions from the config properties file.",
	"Method": "SortedSet<String> readSupportedVersions(String propertyFile,Properties props){\r\n    final String javaVersion = System.getProperty(\"java.version\");\r\n    final SortedSet<String> theVersions = new TreeSet(new VersionComparator());\r\n    theVersions.addAll(readVersions(propertyFile, props, PROP_NAME_JAVA7));\r\n    if (!javaVersion.startsWith(\"1.7\")) {\r\n        theVersions.addAll(readVersions(propertyFile, props, PROP_NAME_JAVA8));\r\n    }\r\n    return Collections.unmodifiableSortedSet(theVersions);\r\n}"
}, {
	"Path": "java.util.ResourceBundle.hasValidParentChain",
	"Comment": "determines whether any of resource bundles in the parent chain,including the leaf, have expired.",
	"Method": "boolean hasValidParentChain(ResourceBundle bundle){\r\n    long now = System.currentTimeMillis();\r\n    while (bundle != null) {\r\n        if (bundle.expired) {\r\n            return false;\r\n        }\r\n        CacheKey key = bundle.cacheKey;\r\n        if (key != null) {\r\n            long expirationTime = key.expirationTime;\r\n            if (expirationTime >= 0 && expirationTime <= now) {\r\n                return false;\r\n            }\r\n        }\r\n        bundle = bundle.parent;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.alibaba.citrus.generictype.codegen.asm.Type.getDimensions",
	"Comment": "returns the number of dimensions of this array type. this method shouldonly be used for an array type.",
	"Method": "int getDimensions(){\r\n    int i = 1;\r\n    while (buf[off + i] == '[') {\r\n        ++i;\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.putAll",
	"Comment": "copies all of the mappings from the specified map to this map.these mappings will replace any mappings that this map had forany of the keys currently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> m){\r\n    int n = m.size();\r\n    if (n == 0)\r\n        return;\r\n    if (n > threshold)\r\n        resize(capacity(n));\r\n    for (Entry<? extends K, ? extends V> e : m.entrySet()) put(e.getKey(), e.getValue());\r\n}"
}, {
	"Path": "java.util.LinkedHashMap.addEntry",
	"Comment": "this override alters behavior of superclass put method. it causes newlyallocated entry to get inserted at the end of the linked list andremoves the eldest entry if appropriate.",
	"Method": "void addEntry(int hash,K key,V value,int bucketIndex){\r\n    createEntry(hash, key, value, bucketIndex);\r\n    Entry<K, V> eldest = header.after;\r\n    if (removeEldestEntry(eldest)) {\r\n        removeEntryForKey(eldest.key);\r\n    } else {\r\n        if (size >= threshold)\r\n            resize(2 * table.length);\r\n    }\r\n}"
}, {
	"Path": "java.io.PushbackInputStream.markSupported",
	"Comment": "tests if this input stream supports the mark andreset methods, which it does not.",
	"Method": "boolean markSupported(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.awt.image.ColorModel.isCompatibleSampleModel",
	"Comment": "checks if the samplemodel is compatible with thiscolormodel.since colormodel is an abstract class,any instance is an instance of a subclass.subclasses mustoverride this method since the implementation in this abstractclass throws an unsupportedoperationexception.",
	"Method": "boolean isCompatibleSampleModel(SampleModel sm){\r\n    throw new UnsupportedOperationException(\"This method is not supported by this color model\");\r\n}"
}, {
	"Path": "org.checkerframework.dataflow.analysis.FlowExpressions.internalReprOfImplicitReceiver",
	"Comment": "returns the implicit receiver of ele.returns either a new classname or a new thisreference depending on whether ele is staticor not. the passed element must be a field, method, or class.",
	"Method": "Receiver internalReprOfImplicitReceiver(Element ele){\r\n    TypeMirror enclosingType = ElementUtils.enclosingClass(ele).asType();\r\n    if (ElementUtils.isStatic(ele)) {\r\n        return new ClassName(enclosingType);\r\n    } else {\r\n        return new ThisReference(enclosingType);\r\n    }\r\n}"
}, {
	"Path": "java.util.regex.Pattern.quote",
	"Comment": "returns a literal pattern string for the specifiedstring.this method produces a string that can be used tocreate a pattern that would match the strings as if it were a literal pattern. metacharactersor escape sequences in the input sequence will be given no specialmeaning.",
	"Method": "String quote(String s){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueAnnotatedTypeFactory.getMethodIdentifier",
	"Comment": "gets a helper object that holds references to methods with special handling.",
	"Method": "ValueMethodIdentifier getMethodIdentifier(){\r\n    return methods;\r\n}"
}, {
	"Path": "java.util.EnumMap.hashCode",
	"Comment": "returns the hash code value for this map.the hash code of a map isdefined to be the sum of the hash codes of each entry in the map.",
	"Method": "int hashCode(int hashCode){\r\n    int h = 0;\r\n    for (int i = 0; i < keyUniverse.length; i++) {\r\n        if (null != vals[i]) {\r\n            h += entryHashCode(i);\r\n        }\r\n    }\r\n    return h;\r\n}"
}, {
	"Path": "java.io.RandomAccessFile.writeLong",
	"Comment": "writes a long to the file as eight bytes, high byte first.the write starts at the current position of the file pointer.",
	"Method": "void writeLong(long v){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.zip.InflaterOutputStream.close",
	"Comment": "writes any remaining uncompressed data to the output stream and closesthe underlying output stream.",
	"Method": "void close(){\r\n    if (!closed) {\r\n        try {\r\n            finish();\r\n        } finally {\r\n            out.close();\r\n            closed = true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.common.value.util.Range.minus",
	"Comment": "returns the smallest range that includes all possible values resulting from subtracting anarbitrary value in the specified range from an arbitrary value in this range. we call thisthe subtraction of two ranges.",
	"Method": "Range minus(Range right){\r\n    if (this.isNothing() || right.isNothing()) {\r\n        return NOTHING;\r\n    }\r\n    if (this.isWithinHalfLong() && right.isWithinHalfLong()) {\r\n        long resultFrom = from - right.to;\r\n        long resultTo = to - right.from;\r\n        return new Range(resultFrom, resultTo);\r\n    } else {\r\n        BigInteger bigFrom = BigInteger.valueOf(from).subtract(BigInteger.valueOf(right.to));\r\n        BigInteger bigTo = BigInteger.valueOf(to).subtract(BigInteger.valueOf(right.from));\r\n        return bigRangeToLongRange(bigFrom, bigTo);\r\n    }\r\n}"
}, {
	"Path": "java.util.jar.JarFile.initializeVerifier",
	"Comment": "initializes the verifier object by reading all the manifestentries and passing them to the verifier.",
	"Method": "void initializeVerifier(){\r\n    ManifestEntryVerifier mev = null;\r\n    try {\r\n        String[] names = getMetaInfEntryNames();\r\n        if (names != null) {\r\n            for (int i = 0; i < names.length; i++) {\r\n                JarEntry e = getJarEntry(names[i]);\r\n                if (!e.isDirectory()) {\r\n                    if (mev == null) {\r\n                        mev = new ManifestEntryVerifier(getManifestFromReference());\r\n                    }\r\n                    byte[] b = getBytes(e);\r\n                    if (b != null && b.length > 0) {\r\n                        jv.beginEntry(e, mev);\r\n                        jv.update(b.length, b, 0, b.length, mev);\r\n                        jv.update(-1, null, 0, 0, mev);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        jv = null;\r\n        verify = false;\r\n    }\r\n    if (jv != null) {\r\n        jv.doneWithMeta();\r\n        if (JarVerifier.debug != null) {\r\n            JarVerifier.debug.println(\"done with meta!\");\r\n        }\r\n        if (jv.nothingToVerify()) {\r\n            if (JarVerifier.debug != null) {\r\n                JarVerifier.debug.println(\"nothing to verify!\");\r\n            }\r\n            jv = null;\r\n            verify = false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.ElementUtils.hasReceiver",
	"Comment": "does the given element need a receiver for accesses? for example, an access to a localvariable does not require a receiver.",
	"Method": "boolean hasReceiver(Element element){\r\n    return (element.getKind().isField() || element.getKind() == ElementKind.METHOD || element.getKind() == ElementKind.CONSTRUCTOR) && !ElementUtils.isStatic(element);\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceValuesToLong",
	"Comment": "returns the result of accumulating the given transformationof all values using the given reducer to combine values,and the given basis as an identity value.",
	"Method": "long reduceValuesToLong(long parallelismThreshold,ToLongFunction<? super V> transformer,long basis,LongBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceValuesToLongTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "java.awt.image.ColorModel.isAlphaPremultiplied",
	"Comment": "returns whether or not the alpha has been premultiplied in thepixel values to be translated by this colormodel.if the boolean is true, this colormodelis to be used to interpret pixel values in which color and alphainformation are represented as separate spatial bands, and colorsamples are assumed to have been multiplied by thealpha sample.",
	"Method": "boolean isAlphaPremultiplied(){\r\n    return isAlphaPremultiplied;\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TypesUtils.isObject",
	"Comment": "checks if the type represents a java.lang.object declared type.",
	"Method": "boolean isObject(TypeMirror type){\r\n    return isDeclaredOfName(type, \"java.lang.Object\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.TestConfigurationBuilder.buildDefaultConfiguration",
	"Comment": "this is the default configuration used by checker framework junit tests.",
	"Method": "TestConfiguration buildDefaultConfiguration(String testSourcePath,Iterable<File> testSourceFiles,Iterable<String> processors,List<String> options,boolean shouldEmitDebugInfo,TestConfiguration buildDefaultConfiguration,String testSourcePath,File testFile,String checkerName,List<String> options,boolean shouldEmitDebugInfo){\r\n    List<File> javaFiles = Arrays.asList(testFile);\r\n    List<String> processors = Arrays.asList(checkerName);\r\n    return buildDefaultConfiguration(testSourcePath, javaFiles, processors, options, shouldEmitDebugInfo);\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.diagnostics.TestDiagnosticUtils.fromJavaxToolsDiagnostic",
	"Comment": "instantiate a diagnostic using a diagnostic from the java compiler. the resulting diagnosticis never fixable and always has parentheses",
	"Method": "TestDiagnostic fromJavaxToolsDiagnostic(String diagnosticString,boolean noMsgText){\r\n    Pair<String, String> trimmed = formatJavaxToolString(diagnosticString, noMsgText);\r\n    return fromPatternMatching(DIAGNOSTIC_PATTERN, DIAGNOSTIC_WARNING_PATTERN, trimmed.second, null, trimmed.first);\r\n}"
}, {
	"Path": "java.util.WeakHashMap.putAll",
	"Comment": "copies all of the mappings from the specified map to this map.these mappings will replace any mappings that this map had for anyof the keys currently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> m){\r\n    int numKeysToBeAdded = m.size();\r\n    if (numKeysToBeAdded == 0)\r\n        return;\r\n    if (numKeysToBeAdded > threshold) {\r\n        int targetCapacity = (int) (numKeysToBeAdded / loadFactor + 1);\r\n        if (targetCapacity > MAXIMUM_CAPACITY)\r\n            targetCapacity = MAXIMUM_CAPACITY;\r\n        int newCapacity = table.length;\r\n        while (newCapacity < targetCapacity) newCapacity <<= 1;\r\n        if (newCapacity > table.length)\r\n            resize(newCapacity);\r\n    }\r\n    for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) put(e.getKey(), e.getValue());\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceKeysToLong",
	"Comment": "returns the result of accumulating the given transformationof all keys using the given reducer to combine values, andthe given basis as an identity value.",
	"Method": "long reduceKeysToLong(long parallelismThreshold,ToLongFunction<? super K> transformer,long basis,LongBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceKeysToLongTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.ui.LocationPanel.getConfigurationLocation",
	"Comment": "get the configuration location entered in the dialogue, or null if no valid location was entered.",
	"Method": "ConfigurationLocation getConfigurationLocation(){\r\n    if (fileLocationField.isEnabled()) {\r\n        if (isNotBlank(fileLocation())) {\r\n            return configurationLocationFactory().create(project, typeOfFile(), fileLocation(), descriptionField.getText());\r\n        }\r\n    } else if (urlLocationField.isEnabled()) {\r\n        if (isNotBlank(urlLocation())) {\r\n            return configurationLocationFactory().create(project, typeOfUrl(), urlLocation(), descriptionField.getText());\r\n        }\r\n    } else if (classpathLocationField.isEnabled()) {\r\n        if (isNotBlank(classpathLocation())) {\r\n            return configurationLocationFactory().create(project, PLUGIN_CLASSPATH, classpathLocation(), descriptionField.getText());\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.util.Date.getMonth",
	"Comment": "returns a number representing the month that contains or beginswith the instant in time represented by this date object.the value returned is between 0 and 11,with the value 0 representing january.",
	"Method": "int getMonth(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.putFields",
	"Comment": "retrieve the object used to buffer persistent fields to be written tothe stream.the fields will be written to the stream when writefieldsmethod is called.",
	"Method": "ObjectOutputStream.PutField putFields(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.TypeArgInferenceUtil.substitute",
	"Comment": "replace all uses of typevariable with substitution in a copy of tomodify using the normalsubstitution rules. return the copy",
	"Method": "AnnotatedTypeMirror substitute(TypeVariable typeVariable,AnnotatedTypeMirror substitution,AnnotatedTypeMirror toModify,AnnotatedTypeMirror substitute,Map<TypeVariable, AnnotatedTypeMirror> substitutions,AnnotatedTypeMirror toModify){\r\n    final AnnotatedTypeMirror substitution;\r\n    if (toModify.getKind() == TypeKind.TYPEVAR) {\r\n        substitution = substitutions.get((TypeVariable) TypeAnnotationUtils.unannotatedType(toModify.getUnderlyingType()));\r\n    } else {\r\n        substitution = null;\r\n    }\r\n    if (substitution != null) {\r\n        return substitution.deepCopy();\r\n    }\r\n    final AnnotatedTypeMirror toModifyCopy = toModify.deepCopy();\r\n    substitutor.substitute(substitutions, toModifyCopy);\r\n    return toModifyCopy;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.validAnnotatedType",
	"Comment": "assert that the type is a type of valid type mirror, i.e. not an error or other type.",
	"Method": "boolean validAnnotatedType(AnnotatedTypeMirror type){\r\n    if (type == null) {\r\n        return false;\r\n    }\r\n    return validType(type.getUnderlyingType());\r\n}"
}, {
	"Path": "java.io.CharArrayWriter.reset",
	"Comment": "resets the buffer so that you can use it again withoutthrowing away the already allocated buffer.",
	"Method": "void reset(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.io.PipedInputStream.close",
	"Comment": "closes this piped input stream and releases any system resourcesassociated with the stream.",
	"Method": "void close(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.lowerbound.LowerBoundTransfer.createNewResult",
	"Comment": "create a new transfer result based on the original result and the new annotation.",
	"Method": "TransferResult<CFValue, CFStore> createNewResult(TransferResult<CFValue, CFStore> result,AnnotationMirror resultAnno){\r\n    CFValue newResultValue = analysis.createSingleAnnotationValue(resultAnno, result.getResultValue().getUnderlyingType());\r\n    return new RegularTransferResult(newResultValue, result.getRegularStore());\r\n}"
}, {
	"Path": "org.checkerframework.common.value.util.Range.times",
	"Comment": "returns the smallest range that includes all possible values resulting from multiplying anarbitrary value in the specified range by an arbitrary value in this range. we call this themultiplication of two ranges.",
	"Method": "Range times(Range right){\r\n    if (this.isNothing() || right.isNothing()) {\r\n        return NOTHING;\r\n    }\r\n    if (this.isWithinInteger() && right.isWithinInteger()) {\r\n        List<Long> possibleValues = Arrays.asList(from * right.from, from * right.to, to * right.from, to * right.to);\r\n        return new Range(Collections.min(possibleValues), Collections.max(possibleValues));\r\n    } else {\r\n        List<BigInteger> bigPossibleValues = Arrays.asList(BigInteger.valueOf(from).multiply(BigInteger.valueOf(right.from)), BigInteger.valueOf(from).multiply(BigInteger.valueOf(right.to)), BigInteger.valueOf(to).multiply(BigInteger.valueOf(right.from)), BigInteger.valueOf(to).multiply(BigInteger.valueOf(right.to)));\r\n        BigInteger bigFrom = Collections.min(bigPossibleValues);\r\n        BigInteger bigTo = Collections.max(bigPossibleValues);\r\n        return bigRangeToLongRange(bigFrom, bigTo);\r\n    }\r\n}"
}, {
	"Path": "java.util.jar.JarEntry.getAttributes",
	"Comment": "returns the manifest attributes for thisentry, or null if none.",
	"Method": "Attributes getAttributes(){\r\n    return attr;\r\n}"
}, {
	"Path": "java.lang.ClassLoader.getBootstrapClassPath",
	"Comment": "returns the urlclasspath that is used for finding system resources.",
	"Method": "URLClassPath getBootstrapClassPath(){\r\n    return sun.misc.Launcher.getBootstrapClassPath();\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.defaults.QualifierDefaults.addUncheckedCodeDefaults",
	"Comment": "sets the default annotation for unchecked elements, with specific locations.",
	"Method": "void addUncheckedCodeDefaults(AnnotationMirror absoluteDefaultAnno,TypeUseLocation[] locations){\r\n    for (TypeUseLocation location : locations) {\r\n        addUncheckedCodeDefault(absoluteDefaultAnno, location);\r\n    }\r\n}"
}, {
	"Path": "javax.swing.table.AbstractTableModel.findColumn",
	"Comment": "returns a column given its name.implementation is naive so this should be overridden ifthis method is to be called often. this method is notin the tablemodel interface and is not used by thejtable.",
	"Method": "int findColumn(String columnName){\r\n    for (int i = 0; i < getColumnCount(); i++) {\r\n        if (columnName.equals(getColumnName(i))) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "java.util.zip.Deflater.finish",
	"Comment": "when called, indicates that compression should end with the currentcontents of the input buffer.",
	"Method": "void finish(){\r\n    synchronized (zsRef) {\r\n        finish = true;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueAnnotatedTypeFactory.getMaxLenValue",
	"Comment": "used to find the maximum length of an array. returns null if there is no minimum lengthknown, or if the passed annotation is null.",
	"Method": "Integer getMaxLenValue(AnnotationMirror annotation){\r\n    if (annotation == null) {\r\n        return null;\r\n    }\r\n    if (AnnotationUtils.areSameByClass(annotation, ArrayLenRange.class)) {\r\n        return Long.valueOf(getRange(annotation).to).intValue();\r\n    } else if (AnnotationUtils.areSameByClass(annotation, ArrayLen.class)) {\r\n        return Collections.max(getArrayLength(annotation));\r\n    } else if (AnnotationUtils.areSameByClass(annotation, StringVal.class)) {\r\n        return Collections.max(ValueCheckerUtils.getLengthsForStringValues(getStringValues(annotation)));\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "java.util.Locale.getUnicodeLocaleAttributes",
	"Comment": "returns the set of unicode locale attributes associated withthis locale, or the empty set if it has no attributes. thereturned set is unmodifiable.",
	"Method": "Set<String> getUnicodeLocaleAttributes(){\r\n    if (!hasExtensions()) {\r\n        return Collections.emptySet();\r\n    }\r\n    return localeExtensions.getUnicodeLocaleAttributes();\r\n}"
}, {
	"Path": "java.security.MessageDigest.digest",
	"Comment": "completes the hash computation by performing final operationssuch as padding. the digest is reset after this call is made.",
	"Method": "byte[] digest(int digest,byte[] buf,int offset,int len,byte[] digest,byte[] input){\r\n    update(input);\r\n    return digest();\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.solver.ConstraintMap.addTypeEqualities",
	"Comment": "add a constraint indicating that target is equal to type in the given hierarchies.",
	"Method": "void addTypeEqualities(TypeVariable target,AnnotatedTypeMirror type,AnnotationMirrorSet hierarchies){\r\n    final Equalities equalities = targetToRecords.get(target).equalities;\r\n    final AnnotationMirrorSet equalityTops = equalities.types.get(type);\r\n    if (equalityTops == null) {\r\n        equalities.types.put(type, new AnnotationMirrorSet(hierarchies));\r\n    } else {\r\n        equalityTops.addAll(hierarchies);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.AnnotationUtils.containsSameIgnoringValues",
	"Comment": "checks that the collection contains the annotation ignoring values. using collection.containsdoes not always work, because it does not use aresameignoringvalues for comparison.",
	"Method": "boolean containsSameIgnoringValues(Collection<? extends AnnotationMirror> c,AnnotationMirror anno){\r\n    return getSameIgnoringValues(c, anno) != null;\r\n}"
}, {
	"Path": "org.checkerframework.common.wholeprograminference.WholeProgramInferenceScenesHelper.getScene",
	"Comment": "returns the scene stored in a .jaif file path passed as input. if the file does not exist, anempty scene is created.",
	"Method": "AScene getScene(String jaifPath){\r\n    AScene scene;\r\n    if (!scenes.containsKey(jaifPath)) {\r\n        File jaifFile = new File(jaifPath);\r\n        scene = new AScene();\r\n        if (jaifFile.exists()) {\r\n            try {\r\n                IndexFileParser.parseFile(jaifPath, scene);\r\n            } catch (IOException e) {\r\n                throw new BugInCF(\"Problem while reading file in: \" + jaifPath + \".\" + \" Exception message: \" + e.getMessage(), e);\r\n            }\r\n        }\r\n        scenes.put(jaifPath, scene);\r\n    } else {\r\n        scene = scenes.get(jaifPath);\r\n    }\r\n    return scene;\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.UseCase1DTOService.toDTO",
	"Comment": "converts the passed usecase1 to a dto. the depth is used to control theamount of association you want. it also prevents potential infinite serialization cycles.",
	"Method": "UseCase1DTO toDTO(UseCase1 useCase1,UseCase1DTO toDTO,UseCase1 useCase1,int depth){\r\n    if (useCase1 == null) {\r\n        return null;\r\n    }\r\n    UseCase1DTO dto = new UseCase1DTO();\r\n    dto.id = useCase1.getId();\r\n    dto.dummy = useCase1.getDummy();\r\n    if (depth-- > 0) {\r\n    }\r\n    return dto;\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TreeUtils.enclosingOfKind",
	"Comment": "gets the first enclosing tree in path, with any one of the specified kinds.",
	"Method": "Tree enclosingOfKind(TreePath path,Tree.Kind kind,Tree enclosingOfKind,TreePath path,Set<Tree.Kind> kinds){\r\n    TreePath p = path;\r\n    while (p != null) {\r\n        Tree leaf = p.getLeaf();\r\n        assert leaf != null;\r\n        if (kinds.contains(leaf.getKind())) {\r\n            return leaf;\r\n        }\r\n        p = p.getParentPath();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "sun.nio.ch.FileChannelImpl.getMappedBufferPool",
	"Comment": "invoked by sun.management.managementfactoryhelper to create the managementinterface for mapped buffers.",
	"Method": "sun.misc.JavaNioAccess.BufferPool getMappedBufferPool(){\r\n    return new sun.misc.JavaNioAccess.BufferPool() {\r\n        @Override\r\n        public String getName() {\r\n            return \"mapped\";\r\n        }\r\n        @Override\r\n        public long getCount() {\r\n            return Unmapper.count;\r\n        }\r\n        @Override\r\n        public long getTotalCapacity() {\r\n            return Unmapper.totalCapacity;\r\n        }\r\n        @Override\r\n        public long getMemoryUsed() {\r\n            return Unmapper.totalSize;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "sun.nio.ch.FileChannelImpl.getMappedBufferPool",
	"Comment": "invoked by sun.management.managementfactoryhelper to create the managementinterface for mapped buffers.",
	"Method": "sun.misc.JavaNioAccess.BufferPool getMappedBufferPool(){\r\n    return \"mapped\";\r\n}"
}, {
	"Path": "sun.nio.ch.FileChannelImpl.getMappedBufferPool",
	"Comment": "invoked by sun.management.managementfactoryhelper to create the managementinterface for mapped buffers.",
	"Method": "sun.misc.JavaNioAccess.BufferPool getMappedBufferPool(){\r\n    return Unmapper.count;\r\n}"
}, {
	"Path": "sun.nio.ch.FileChannelImpl.getMappedBufferPool",
	"Comment": "invoked by sun.management.managementfactoryhelper to create the managementinterface for mapped buffers.",
	"Method": "sun.misc.JavaNioAccess.BufferPool getMappedBufferPool(){\r\n    return Unmapper.totalCapacity;\r\n}"
}, {
	"Path": "sun.nio.ch.FileChannelImpl.getMappedBufferPool",
	"Comment": "invoked by sun.management.managementfactoryhelper to create the managementinterface for mapped buffers.",
	"Method": "sun.misc.JavaNioAccess.BufferPool getMappedBufferPool(){\r\n    return Unmapper.totalSize;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceEntries",
	"Comment": "returns the result of accumulating the given transformationof all entries using the given reducer to combine values,or null if none.",
	"Method": "Map.Entry<K, V> reduceEntries(long parallelismThreshold,BiFunction<Map.Entry<K, V>, Map.Entry<K, V>, ? extends Map.Entry<K, V>> reducer,U reduceEntries,long parallelismThreshold,Function<Map.Entry<K, V>, ? extends U> transformer,BiFunction<? super U, ? super U, ? extends U> reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceEntriesTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, reducer).invoke();\r\n}"
}, {
	"Path": "java.beans.PropertyDescriptor.equals",
	"Comment": "compares this propertydescriptor against the specified object.returns true if the objects are the same. two propertydescriptorsare the same if the read, write, property types, property editor andflagsare equivalent.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj) {\r\n        return true;\r\n    }\r\n    if (obj != null && obj instanceof PropertyDescriptor) {\r\n        PropertyDescriptor other = (PropertyDescriptor) obj;\r\n        Method otherReadMethod = other.getReadMethod();\r\n        Method otherWriteMethod = other.getWriteMethod();\r\n        if (!compareMethods(getReadMethod(), otherReadMethod)) {\r\n            return false;\r\n        }\r\n        if (!compareMethods(getWriteMethod(), otherWriteMethod)) {\r\n            return false;\r\n        }\r\n        if (getPropertyType() == other.getPropertyType() && getPropertyEditorClass() == other.getPropertyEditorClass() && bound == other.isBound() && constrained == other.isConstrained() && writeMethodName == other.writeMethodName && readMethodName == other.readMethodName) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.readHandle",
	"Comment": "reads in object handle, sets passhandle to the read handle, and returnsobject associated with the handle.",
	"Method": "Object readHandle(boolean unshared){\r\n    if (bin.readByte() != TC_REFERENCE) {\r\n        throw new InternalError();\r\n    }\r\n    passHandle = bin.readInt() - baseWireHandle;\r\n    if (passHandle < 0 || passHandle >= handles.size()) {\r\n        throw new StreamCorruptedException(String.format(\"invalid handle value: X\", passHandle + baseWireHandle));\r\n    }\r\n    if (unshared) {\r\n        throw new InvalidObjectException(\"cannot read back reference as unshared\");\r\n    }\r\n    Object obj = handles.lookupObject(passHandle);\r\n    if (obj == unsharedMarker) {\r\n        throw new InvalidObjectException(\"cannot read back reference to unshared object\");\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "java.util.logging.Logger.finest",
	"Comment": "log a finest message.if the logger is currently enabled for the finest messagelevel then the given message is forwarded to all theregistered output handler objects.",
	"Method": "void finest(String msg){\r\n    if (Level.FINEST.intValue() < levelValue) {\r\n        return;\r\n    }\r\n    log(Level.FINEST, msg);\r\n}"
}, {
	"Path": "java.util.zip.InflaterInputStream.markSupported",
	"Comment": "tests if this input stream supports the mark andreset methods. the marksupportedmethod of inflaterinputstream returnsfalse.",
	"Method": "boolean markSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.substringindex.SubstringIndexAnnotatedTypeFactory.createSupportedTypeQualifiers",
	"Comment": "returns a mutable set of annotation classes that are supported by the substring indexchecker.",
	"Method": "Set<Class<? extends Annotation>> createSupportedTypeQualifiers(){\r\n    return new LinkedHashSet(Arrays.asList(SubstringIndexUnknown.class, SubstringIndexFor.class, SubstringIndexBottom.class));\r\n}"
}, {
	"Path": "org.checkerframework.framework.source.SourceChecker.getStandardSuppressWarningsKeys",
	"Comment": "determine the standard set of suppress warning keys usable for any checker.",
	"Method": "Collection<String> getStandardSuppressWarningsKeys(){\r\n    SuppressWarningsKeys annotation = this.getClass().getAnnotation(SuppressWarningsKeys.class);\r\n    Set<String> result = new TreeSet();\r\n    result.add(SUPPRESS_ALL_KEY);\r\n    if (annotation != null) {\r\n        for (String key : annotation.value()) {\r\n            result.add(key);\r\n        }\r\n    } else {\r\n        String className = this.getClass().getSimpleName();\r\n        int indexOfChecker = className.lastIndexOf(\"Checker\");\r\n        if (indexOfChecker == -1) {\r\n            indexOfChecker = className.lastIndexOf(\"Subchecker\");\r\n        }\r\n        String key = (indexOfChecker == -1) ? className : className.substring(0, indexOfChecker);\r\n        result.add(key.trim().toLowerCase());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.checkerframework.framework.flow.CFAbstractTransfer.visitNode",
	"Comment": "the default visitor returns the input information unchanged, or in the case of conditionalinput information, merged.",
	"Method": "TransferResult<V, S> visitNode(Node n,TransferInput<V, S> in){\r\n    V value = null;\r\n    Tree tree = n.getTree();\r\n    if (tree != null) {\r\n        if (TreeUtils.canHaveTypeAnnotation(tree)) {\r\n            value = getValueFromFactory(tree, n);\r\n        }\r\n    }\r\n    if (in.containsTwoStores()) {\r\n        S thenStore = in.getThenStore();\r\n        S elseStore = in.getElseStore();\r\n        return new ConditionalTransferResult(finishValue(value, thenStore, elseStore), thenStore, elseStore);\r\n    } else {\r\n        S info = in.getRegularStore();\r\n        return new RegularTransferResult(finishValue(value, info), info);\r\n    }\r\n}"
}, {
	"Path": "java.util.jar.Attributes.read",
	"Comment": "reads attributes from the specified input stream.xxx need to handle utf8 values.",
	"Method": "void read(Manifest.FastInputStream is,byte[] lbuf){\r\n    String name = null, value = null;\r\n    byte[] lastline = null;\r\n    int len;\r\n    while ((len = is.readLine(lbuf)) != -1) {\r\n        boolean lineContinued = false;\r\n        if (lbuf[--len] != '\\n') {\r\n            throw new IOException(\"line too long\");\r\n        }\r\n        if (len > 0 && lbuf[len - 1] == '\\r') {\r\n            --len;\r\n        }\r\n        if (len == 0) {\r\n            break;\r\n        }\r\n        int i = 0;\r\n        if (lbuf[0] == ' ') {\r\n            if (name == null) {\r\n                throw new IOException(\"misplaced continuation line\");\r\n            }\r\n            lineContinued = true;\r\n            byte[] buf = new byte[lastline.length + len - 1];\r\n            System.arraycopy(lastline, 0, buf, 0, lastline.length);\r\n            System.arraycopy(lbuf, 1, buf, lastline.length, len - 1);\r\n            if (is.peek() == ' ') {\r\n                lastline = buf;\r\n                continue;\r\n            }\r\n            value = new String(buf, 0, buf.length, \"UTF8\");\r\n            lastline = null;\r\n        } else {\r\n            while (lbuf[i++] != ':') {\r\n                if (i >= len) {\r\n                    throw new IOException(\"invalid header field\");\r\n                }\r\n            }\r\n            if (lbuf[i++] != ' ') {\r\n                throw new IOException(\"invalid header field\");\r\n            }\r\n            name = new String(lbuf, 0, 0, i - 2);\r\n            if (is.peek() == ' ') {\r\n                lastline = new byte[len - i];\r\n                System.arraycopy(lbuf, i, lastline, 0, len - i);\r\n                continue;\r\n            }\r\n            value = new String(lbuf, i, len - i, \"UTF8\");\r\n        }\r\n        try {\r\n            if ((putValue(name, value) != null) && (!lineContinued)) {\r\n                PlatformLogger.getLogger(\"java.util.jar\").warning(\"Duplicate name in Manifest: \" + name + \".\\n\" + \"Ensure that the manifest does not \" + \"have duplicate entries, and\\n\" + \"that blank lines separate \" + \"individual sections in both your\\n\" + \"manifest and in the META-INF/MANIFEST.MF \" + \"entry in the jar file.\");\r\n            }\r\n        } catch (IllegalArgumentException e) {\r\n            throw new IOException(\"invalid header field name: \" + name);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.createQualifierHierarchyFactory",
	"Comment": "factory method to easily change what factory is used to create a qualifierhierarchy.",
	"Method": "MultiGraphQualifierHierarchy.MultiGraphFactory createQualifierHierarchyFactory(){\r\n    return new MultiGraphQualifierHierarchy.MultiGraphFactory(this);\r\n}"
}, {
	"Path": "java.util.Collections.singleton",
	"Comment": "returns an immutable set containing only the specified object.the returned set is serializable.",
	"Method": "Set<T> singleton(T o){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.Calendar.updateTime",
	"Comment": "recomputes the time and updates the status fields istimesetand arefieldsset.callers should check istimeset and onlycall this method if istimeset is false.",
	"Method": "void updateTime(){\r\n    computeTime();\r\n    isTimeSet = true;\r\n}"
}, {
	"Path": "java.util.zip.InflaterInputStream.read",
	"Comment": "reads a byte of uncompressed data. this method will block untilenough input is available for decompression.",
	"Method": "int read(int read,byte[] b,int off,int len){\r\n    ensureOpen();\r\n    if (b == null) {\r\n        throw new NullPointerException();\r\n    } else if (off < 0 || len < 0 || len > b.length - off) {\r\n        throw new IndexOutOfBoundsException();\r\n    } else if (len == 0) {\r\n        return 0;\r\n    }\r\n    try {\r\n        int n;\r\n        while ((n = inf.inflate(b, off, len)) == 0) {\r\n            if (inf.finished() || inf.needsDictionary()) {\r\n                reachEOF = true;\r\n                return -1;\r\n            }\r\n            if (inf.needsInput()) {\r\n                fill();\r\n            }\r\n        }\r\n        return n;\r\n    } catch (DataFormatException e) {\r\n        String s = e.getMessage();\r\n        throw new ZipException(s != null ? s : \"Invalid ZLIB data format\");\r\n    }\r\n}"
}, {
	"Path": "com.alibaba.citrus.generictype.codegen.asm.Type.getConstructorDescriptor",
	"Comment": "returns the descriptor corresponding to the given constructor.",
	"Method": "String getConstructorDescriptor(Constructor c){\r\n    Class[] parameters = c.getParameterTypes();\r\n    StringBuilder buf = new StringBuilder();\r\n    buf.append('(');\r\n    for (int i = 0; i < parameters.length; ++i) {\r\n        getDescriptor(buf, parameters[i]);\r\n    }\r\n    return buf.append(\")V\").toString();\r\n}"
}, {
	"Path": "java.util.PriorityQueue.iterator",
	"Comment": "returns an iterator over the elements in this queue. the iteratordoes not return the elements in any particular order.",
	"Method": "Iterator<E> iterator(){\r\n    return new Itr();\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.cloneArray",
	"Comment": "method for cloning arrays in case of using unsharing reading",
	"Method": "Object cloneArray(Object array){\r\n    if (array instanceof Object[]) {\r\n        return ((Object[]) array).clone();\r\n    } else if (array instanceof boolean[]) {\r\n        return ((boolean[]) array).clone();\r\n    } else if (array instanceof byte[]) {\r\n        return ((byte[]) array).clone();\r\n    } else if (array instanceof char[]) {\r\n        return ((char[]) array).clone();\r\n    } else if (array instanceof double[]) {\r\n        return ((double[]) array).clone();\r\n    } else if (array instanceof float[]) {\r\n        return ((float[]) array).clone();\r\n    } else if (array instanceof int[]) {\r\n        return ((int[]) array).clone();\r\n    } else if (array instanceof long[]) {\r\n        return ((long[]) array).clone();\r\n    } else if (array instanceof short[]) {\r\n        return ((short[]) array).clone();\r\n    } else {\r\n        throw new AssertionError();\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.element.ElementAnnotationUtil.getLocationTypeADT",
	"Comment": "given a typepath into a declared type, return the component type that is located at the endof the typepath.",
	"Method": "AnnotatedTypeMirror getLocationTypeADT(AnnotatedDeclaredType type,List<TypeAnnotationPosition.TypePathEntry> location){\r\n    ArrayDeque<AnnotatedDeclaredType> outerToInner = new ArrayDeque();\r\n    AnnotatedDeclaredType enclosing = type;\r\n    while (enclosing != null) {\r\n        outerToInner.addFirst(enclosing);\r\n        enclosing = enclosing.getEnclosingType();\r\n    }\r\n    @SuppressWarnings(\"JdkObsolete\")\r\n    LinkedList<TypePathEntry> tailOfLocations = new LinkedList(location);\r\n    boolean error = false;\r\n    while (!tailOfLocations.isEmpty()) {\r\n        TypePathEntry currentLocation = tailOfLocations.removeFirst();\r\n        switch(currentLocation.tag) {\r\n            case INNER_TYPE:\r\n                outerToInner.removeFirst();\r\n                break;\r\n            case TYPE_ARGUMENT:\r\n                AnnotatedDeclaredType innerType = outerToInner.getFirst();\r\n                if (currentLocation.arg < innerType.getTypeArguments().size()) {\r\n                    AnnotatedTypeMirror typeArg = innerType.getTypeArguments().get(currentLocation.arg);\r\n                    return getTypeAtLocation(typeArg, tailOfLocations);\r\n                } else {\r\n                    error = true;\r\n                    break;\r\n                }\r\n            default:\r\n                error = true;\r\n        }\r\n        if (error) {\r\n            break;\r\n        }\r\n    }\r\n    if (outerToInner.isEmpty() || error) {\r\n        throw new BugInCF(\"ElementAnnotationUtil.getLocationTypeADT: invalid location %s for type: %s\", location, type);\r\n    }\r\n    return outerToInner.getFirst();\r\n}"
}, {
	"Path": "org.checkerframework.common.value.util.Range.plus",
	"Comment": "returns the smallest range that includes all possible values resulting from adding anarbitrary value in the specified range to an arbitrary value in this range. we call this theaddition of two ranges.",
	"Method": "Range plus(Range right){\r\n    if (this.isNothing() || right.isNothing()) {\r\n        return NOTHING;\r\n    }\r\n    if (this.isWithinHalfLong() && right.isWithinHalfLong()) {\r\n        long resultFrom = from + right.from;\r\n        long resultTo = to + right.to;\r\n        if (from > to) {\r\n            return Range.EVERYTHING;\r\n        } else {\r\n            return new Range(resultFrom, resultTo);\r\n        }\r\n    } else {\r\n        BigInteger bigFrom = BigInteger.valueOf(from).add(BigInteger.valueOf(right.from));\r\n        BigInteger bigTo = BigInteger.valueOf(to).add(BigInteger.valueOf(right.to));\r\n        return bigRangeToLongRange(bigFrom, bigTo);\r\n    }\r\n}"
}, {
	"Path": "java.util.zip.ZipOutputStream.close",
	"Comment": "closes the zip output stream as well as the stream being filtered.",
	"Method": "void close(){\r\n    if (!closed) {\r\n        super.close();\r\n        closed = true;\r\n    }\r\n}"
}, {
	"Path": "com.mycompany.myapp.domain.UseCase1.isIdSet",
	"Comment": "tells whether or not this instance has a non empty composite primary key set.",
	"Method": "boolean isIdSet(){\r\n    return getId() != null && getId().areFieldsSet();\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.getEnclosingType",
	"Comment": "determine the type of the most enclosing class of the given tree that is a subtype of thegiven element. receiver type annotations of an enclosing method are considered, similarlyreturn type annotations of an enclosing constructor.",
	"Method": "AnnotatedDeclaredType getEnclosingType(TypeElement element,Tree tree){\r\n    Element enclosingElt = getMostInnerClassOrMethod(tree);\r\n    while (enclosingElt != null) {\r\n        if (enclosingElt instanceof ExecutableElement) {\r\n            ExecutableElement method = (ExecutableElement) enclosingElt;\r\n            if (method.asType() != null && isSubtype((TypeElement) method.getEnclosingElement(), element)) {\r\n                if (ElementUtils.isStatic(method)) {\r\n                } else if (method.getKind() == ElementKind.CONSTRUCTOR) {\r\n                    return (AnnotatedDeclaredType) getAnnotatedType(method).getReturnType();\r\n                } else {\r\n                    return getAnnotatedType(method).getReceiverType();\r\n                }\r\n            }\r\n        } else if (enclosingElt instanceof TypeElement) {\r\n            if (isSubtype((TypeElement) enclosingElt, element)) {\r\n                return (AnnotatedDeclaredType) getAnnotatedType(enclosingElt);\r\n            }\r\n        }\r\n        enclosingElt = enclosingElt.getEnclosingElement();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.IndexUtil.isSequenceType",
	"Comment": "determines whether the type is a sequence supported by this checker.",
	"Method": "boolean isSequenceType(TypeMirror type){\r\n    return type.getKind() == TypeKind.ARRAY || TypesUtils.isString(type);\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.trees.TreeBuilder.buildLiteral",
	"Comment": "builds an ast tree representing a literal value of primitive or string type.",
	"Method": "LiteralTree buildLiteral(Object value){\r\n    return maker.Literal(value);\r\n}"
}, {
	"Path": "org.checkerframework.common.value.util.Range.isWithinHalfLong",
	"Comment": "determines if this range is completely contained in the range that is of half length of thelong type and centered with 0.",
	"Method": "boolean isWithinHalfLong(){\r\n    return isWithin(Long.MIN_VALUE >> 1, Long.MAX_VALUE >> 1);\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.unmaskNull",
	"Comment": "returns internal representation of null key back to caller as null.",
	"Method": "Object unmaskNull(Object key){\r\n    return (key == NULL_KEY ? null : key);\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.UseCase3DTOService.toEntity",
	"Comment": "converts the passed dto to a usecase3.convenient for query by example.",
	"Method": "UseCase3 toEntity(UseCase3DTO dto,UseCase3 toEntity,UseCase3DTO dto,int depth){\r\n    if (dto == null) {\r\n        return null;\r\n    }\r\n    UseCase3 useCase3 = new UseCase3();\r\n    useCase3.setId(dto.id);\r\n    useCase3.setDummy(dto.dummy);\r\n    if (depth-- > 0) {\r\n        useCase3.setId2(useCase2DTOService.toEntity(dto.id2, depth));\r\n    }\r\n    return useCase3;\r\n}"
}, {
	"Path": "javax.management.openmbean.CompositeType.containsKey",
	"Comment": "returns true if this compositetype instance defines an itemwhose name is itemname.",
	"Method": "boolean containsKey(String itemName){\r\n    if (itemName == null) {\r\n        return false;\r\n    }\r\n    return nameToDescription.containsKey(itemName);\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.UserDTOService.toEntity",
	"Comment": "converts the passed dto to a user.convenient for query by example.",
	"Method": "User toEntity(UserDTO dto,User toEntity,UserDTO dto,int depth){\r\n    if (dto == null) {\r\n        return null;\r\n    }\r\n    User user = new User();\r\n    user.setId(dto.id);\r\n    user.setLogin(dto.login);\r\n    user.setPassword(dto.password);\r\n    user.setEmail(dto.email);\r\n    user.setIsEnabled(dto.isEnabled);\r\n    user.setCivility(dto.civility);\r\n    user.setCountryCode(dto.countryCode);\r\n    user.setFirstName(dto.firstName);\r\n    user.setLastName(dto.lastName);\r\n    user.setCreationDate(dto.creationDate);\r\n    user.setCreationAuthor(dto.creationAuthor);\r\n    user.setLastModificationDate(dto.lastModificationDate);\r\n    user.setLastModificationAuthor(dto.lastModificationAuthor);\r\n    user.setVersion(dto.version);\r\n    if (depth-- > 0) {\r\n        user.setPassport(passportDTOService.toEntity(dto.passport, depth));\r\n    }\r\n    return user;\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TypesUtils.getQualifiedName",
	"Comment": "gets the fully qualified name for a provided type. it returns an empty name if type is ananonymous type.",
	"Method": "Name getQualifiedName(DeclaredType type){\r\n    TypeElement element = (TypeElement) type.asElement();\r\n    return element.getQualifiedName();\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.getDeclAnnotation",
	"Comment": "returns the actual annotation mirror used to annotate this element, whose name equals thepassed annotation class, if one exists, or null otherwise.",
	"Method": "AnnotationMirror getDeclAnnotation(Element elt,Class<? extends Annotation> anno,AnnotationMirror getDeclAnnotation,Element elt,Class<? extends Annotation> annoClass,boolean checkAliases){\r\n    Set<AnnotationMirror> declAnnos = getDeclAnnotations(elt);\r\n    for (AnnotationMirror am : declAnnos) {\r\n        if (AnnotationUtils.areSameByClass(am, annoClass)) {\r\n            return am;\r\n        }\r\n    }\r\n    if (checkAliases) {\r\n        Pair<AnnotationMirror, Set<Class<? extends Annotation>>> aliases = declAliases.get(annoClass);\r\n        if (aliases != null) {\r\n            for (Class<? extends Annotation> alias : aliases.second) {\r\n                for (AnnotationMirror am : declAnnos) {\r\n                    if (AnnotationUtils.areSameByClass(am, alias)) {\r\n                        return aliases.first;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.checkerframework.common.value.util.Range.union",
	"Comment": "returns the smallest range that includes all values contained in either of the two ranges. wecall this the union of two ranges.",
	"Method": "Range union(Range right){\r\n    if (this.isNothing()) {\r\n        return right;\r\n    } else if (right.isNothing()) {\r\n        return this;\r\n    }\r\n    long resultFrom = Math.min(from, right.from);\r\n    long resultTo = Math.max(to, right.to);\r\n    return new Range(resultFrom, resultTo);\r\n}"
}, {
	"Path": "java.util.ListResourceBundle.loadLookup",
	"Comment": "we lazily load the lookup hashtable.this function does theloading.",
	"Method": "void loadLookup(){\r\n    if (lookup != null)\r\n        return;\r\n    Object[][] contents = getContents();\r\n    HashMap<String, Object> temp = new HashMap(contents.length);\r\n    for (int i = 0; i < contents.length; ++i) {\r\n        String key = (String) contents[i][0];\r\n        Object value = contents[i][1];\r\n        if (key == null || value == null) {\r\n            throw new NullPointerException();\r\n        }\r\n        temp.put(key, value);\r\n    }\r\n    lookup = temp;\r\n}"
}, {
	"Path": "java.io.DataInputStream.readFloat",
	"Comment": "see the general contract of the readfloatmethod of datainput.bytesfor this operation are read from the containedinput stream.",
	"Method": "float readFloat(){\r\n    return Float.intBitsToFloat(readInt());\r\n}"
}, {
	"Path": "org.checkerframework.common.wholeprograminference.WholeProgramInferenceScenesHelper.getSupportedAnnosInSet",
	"Comment": "returns a subset of annosset, consisting of the annotations supported by atf.",
	"Method": "Set<Annotation> getSupportedAnnosInSet(Set<Annotation> annosSet,AnnotatedTypeFactory atf){\r\n    Set<Annotation> output = new HashSet();\r\n    Set<Class<? extends java.lang.annotation.Annotation>> supportedAnnos = atf.getSupportedTypeQualifiers();\r\n    for (Annotation anno : annosSet) {\r\n        for (Class<? extends java.lang.annotation.Annotation> clazz : supportedAnnos) {\r\n            if (clazz.getName().equals(anno.def.name)) {\r\n                output.add(anno);\r\n            }\r\n        }\r\n    }\r\n    return output;\r\n}"
}, {
	"Path": "org.checkerframework.common.value.util.Range.isWithin",
	"Comment": "determines if this range is completely contained in the range specified by the given lowerbound and upper bound.",
	"Method": "boolean isWithin(long lb,long ub){\r\n    return from >= lb && to <= ub;\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.IndexUtil.getLengthSequenceTree",
	"Comment": "gets a sequence tree for a length access tree, or null if it is not a length access.",
	"Method": "ExpressionTree getLengthSequenceTree(Tree lengthTree,IndexMethodIdentifier imf,ProcessingEnvironment processingEnv){\r\n    if (TreeUtils.isArrayLengthAccess(lengthTree)) {\r\n        return ((MemberSelectTree) lengthTree).getExpression();\r\n    } else if (imf.isLengthOfMethodInvocation(lengthTree)) {\r\n        return TreeUtils.getReceiverTree((MethodInvocationTree) lengthTree);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.GenericAnnotatedTypeFactory.getShouldDefaultTypeVarLocals",
	"Comment": "should the local variable default annotation be applied to type variables?it is initialized to true if data flow is used by the checker. it is set to false whengetting the assignment context for type argument inference.",
	"Method": "boolean getShouldDefaultTypeVarLocals(){\r\n    return shouldDefaultTypeVarLocals;\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.util.HessianFreeList.allocate",
	"Comment": "try to get an object from the free list.returns null if the free listis empty.",
	"Method": "T allocate(){\r\n    int top = _top.get();\r\n    if (top > 0 && _top.compareAndSet(top, top - 1)) {\r\n        return _freeStack.getAndSet(top - 1, null);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.getFixedDate",
	"Comment": "computes the fixed date under either the gregorian or thejulian calendar, using the given year and the specified calendar fields.",
	"Method": "long getFixedDate(BaseCalendar cal,int year,int fieldMask){\r\n    int month = JANUARY;\r\n    if (isFieldSet(fieldMask, MONTH)) {\r\n        month = internalGet(MONTH);\r\n        if (month > DECEMBER) {\r\n            year += month / 12;\r\n            month %= 12;\r\n        } else if (month < JANUARY) {\r\n            int[] rem = new int[1];\r\n            year += CalendarUtils.floorDivide(month, 12, rem);\r\n            month = rem[0];\r\n        }\r\n    }\r\n    long fixedDate = cal.getFixedDate(year, month + 1, 1, cal == gcal ? gdate : null);\r\n    if (isFieldSet(fieldMask, MONTH)) {\r\n        if (isFieldSet(fieldMask, DAY_OF_MONTH)) {\r\n            if (isSet(DAY_OF_MONTH)) {\r\n                fixedDate += internalGet(DAY_OF_MONTH);\r\n                fixedDate--;\r\n            }\r\n        } else {\r\n            if (isFieldSet(fieldMask, WEEK_OF_MONTH)) {\r\n                long firstDayOfWeek = cal.getDayOfWeekDateOnOrBefore(fixedDate + 6, getFirstDayOfWeek());\r\n                if ((firstDayOfWeek - fixedDate) >= getMinimalDaysInFirstWeek()) {\r\n                    firstDayOfWeek -= 7;\r\n                }\r\n                if (isFieldSet(fieldMask, DAY_OF_WEEK)) {\r\n                    firstDayOfWeek = cal.getDayOfWeekDateOnOrBefore(firstDayOfWeek + 6, internalGet(DAY_OF_WEEK));\r\n                }\r\n                fixedDate = firstDayOfWeek + 7 * (internalGet(WEEK_OF_MONTH) - 1);\r\n            } else {\r\n                int dayOfWeek;\r\n                if (isFieldSet(fieldMask, DAY_OF_WEEK)) {\r\n                    dayOfWeek = internalGet(DAY_OF_WEEK);\r\n                } else {\r\n                    dayOfWeek = getFirstDayOfWeek();\r\n                }\r\n                int dowim;\r\n                if (isFieldSet(fieldMask, DAY_OF_WEEK_IN_MONTH)) {\r\n                    dowim = internalGet(DAY_OF_WEEK_IN_MONTH);\r\n                } else {\r\n                    dowim = 1;\r\n                }\r\n                if (dowim >= 0) {\r\n                    fixedDate = cal.getDayOfWeekDateOnOrBefore(fixedDate + (7 * dowim) - 1, dayOfWeek);\r\n                } else {\r\n                    int lastDate = monthLength(month, year) + (7 * (dowim + 1));\r\n                    fixedDate = cal.getDayOfWeekDateOnOrBefore(fixedDate + lastDate - 1, dayOfWeek);\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        if (year == gregorianCutoverYear && cal == gcal && fixedDate < gregorianCutoverDate && gregorianCutoverYear != gregorianCutoverYearJulian) {\r\n            fixedDate = gregorianCutoverDate;\r\n        }\r\n        if (isFieldSet(fieldMask, DAY_OF_YEAR)) {\r\n            fixedDate += internalGet(DAY_OF_YEAR);\r\n            fixedDate--;\r\n        } else {\r\n            long firstDayOfWeek = cal.getDayOfWeekDateOnOrBefore(fixedDate + 6, getFirstDayOfWeek());\r\n            if ((firstDayOfWeek - fixedDate) >= getMinimalDaysInFirstWeek()) {\r\n                firstDayOfWeek -= 7;\r\n            }\r\n            if (isFieldSet(fieldMask, DAY_OF_WEEK)) {\r\n                int dayOfWeek = internalGet(DAY_OF_WEEK);\r\n                if (dayOfWeek != getFirstDayOfWeek()) {\r\n                    firstDayOfWeek = cal.getDayOfWeekDateOnOrBefore(firstDayOfWeek + 6, dayOfWeek);\r\n                }\r\n            }\r\n            fixedDate = firstDayOfWeek + 7 * ((long) internalGet(WEEK_OF_YEAR) - 1);\r\n        }\r\n    }\r\n    return fixedDate;\r\n}"
}, {
	"Path": "org.checkerframework.common.basetype.BaseTypeVisitor.standardizeAnnotationFromContract",
	"Comment": "standardize a type qualifier annotation obtained from a contract.",
	"Method": "AnnotationMirror standardizeAnnotationFromContract(AnnotationMirror annoFromContract,FlowExpressionContext flowExprContext,TreePath path){\r\n    DependentTypesHelper dependentTypesHelper = atypeFactory.getDependentTypesHelper();\r\n    if (dependentTypesHelper != null) {\r\n        AnnotationMirror anno = dependentTypesHelper.standardizeAnnotation(flowExprContext, path, annoFromContract, false);\r\n        dependentTypesHelper.checkAnnotation(anno, path.getLeaf());\r\n        return anno;\r\n    } else {\r\n        return annoFromContract;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.StubParser.findElement",
	"Comment": "looks for a constructor element in the typeelt and returns it if the element has the samesignature as provided constructor declaration. in case constructor element is not found itreturns null.",
	"Method": "Element findElement(TypeElement typeElt,ClassOrInterfaceDeclaration ciDecl,Element findElement,TypeElement typeElt,EnumDeclaration enumDecl,ExecutableElement findElement,TypeElement typeElt,MethodDeclaration methodDecl,ExecutableElement findElement,TypeElement typeElt,ConstructorDeclaration constructorDecl,VariableElement findElement,TypeElement typeElt,VariableDeclarator variable){\r\n    final String fieldName = variable.getNameAsString();\r\n    return findFieldElement(typeElt, fieldName);\r\n}"
}, {
	"Path": "java.net.URLClassLoader.isSealed",
	"Comment": "returns true if the specified package name is sealed according to thegiven manifest.",
	"Method": "boolean isSealed(String name,Manifest man){\r\n    String path = name.replace('.', '/').concat(\"/\");\r\n    Attributes attr = man.getAttributes(path);\r\n    String sealed = null;\r\n    if (attr != null) {\r\n        sealed = attr.getValue(Name.SEALED);\r\n    }\r\n    if (sealed == null) {\r\n        if ((attr = man.getMainAttributes()) != null) {\r\n            sealed = attr.getValue(Name.SEALED);\r\n        }\r\n    }\r\n    return \"true\".equalsIgnoreCase(sealed);\r\n}"
}, {
	"Path": "java.io.DataOutputStream.writeShort",
	"Comment": "writes a short to the underlying output stream as twobytes, high byte first. if no exception is thrown, the counterwritten is incremented by 2.",
	"Method": "void writeShort(int v){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.lang.ClassLoader.loadLibrary",
	"Comment": "invoked in the java.lang.runtime class to implement load and loadlibrary.",
	"Method": "void loadLibrary(Class fromClass,String name,boolean isAbsolute){\r\n    ClassLoader loader = (fromClass == null) ? null : fromClass.getClassLoader();\r\n    if (sys_paths == null) {\r\n        usr_paths = initializePath(\"java.library.path\");\r\n        sys_paths = initializePath(\"sun.boot.library.path\");\r\n    }\r\n    if (isAbsolute) {\r\n        if (loadLibrary0(fromClass, new File(name))) {\r\n            return;\r\n        }\r\n        throw new UnsatisfiedLinkError(\"Can't load library: \" + name);\r\n    }\r\n    if (loader != null) {\r\n        String libfilename = loader.findLibrary(name);\r\n        if (libfilename != null) {\r\n            File libfile = new File(libfilename);\r\n            if (!libfile.isAbsolute()) {\r\n                throw new UnsatisfiedLinkError(\"ClassLoader.findLibrary failed to return an absolute path: \" + libfilename);\r\n            }\r\n            if (loadLibrary0(fromClass, libfile)) {\r\n                return;\r\n            }\r\n            throw new UnsatisfiedLinkError(\"Can't load \" + libfilename);\r\n        }\r\n    }\r\n    for (int i = 0; i < sys_paths.length; i++) {\r\n        File libfile = new File(sys_paths[i], System.mapLibraryName(name));\r\n        if (loadLibrary0(fromClass, libfile)) {\r\n            return;\r\n        }\r\n        libfile = ClassLoaderHelper.mapAlternativeName(libfile);\r\n        if (libfile != null && loadLibrary0(fromClass, libfile)) {\r\n            return;\r\n        }\r\n    }\r\n    if (loader != null) {\r\n        for (int i = 0; i < usr_paths.length; i++) {\r\n            File libfile = new File(usr_paths[i], System.mapLibraryName(name));\r\n            if (loadLibrary0(fromClass, libfile)) {\r\n                return;\r\n            }\r\n            libfile = ClassLoaderHelper.mapAlternativeName(libfile);\r\n            if (libfile != null && loadLibrary0(fromClass, libfile)) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    throw new UnsatisfiedLinkError(\"no \" + name + \" in java.library.path\");\r\n}"
}, {
	"Path": "java.util.ListResourceBundle.getKeys",
	"Comment": "returns an enumeration of the keys contained inthis resourcebundle and its parent bundles.",
	"Method": "Enumeration<String> getKeys(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.flow.CFAbstractTransfer.initialStore",
	"Comment": "the initial store maps method formal parameters to their currently most refined type.",
	"Method": "S initialStore(UnderlyingAST underlyingAST,List<LocalVariableNode> parameters){\r\n    if (underlyingAST.getKind() != Kind.LAMBDA && underlyingAST.getKind() != Kind.METHOD) {\r\n        if (fixedInitialStore != null) {\r\n            return fixedInitialStore;\r\n        } else {\r\n            return analysis.createEmptyStore(sequentialSemantics);\r\n        }\r\n    }\r\n    S info;\r\n    if (underlyingAST.getKind() == Kind.METHOD) {\r\n        if (fixedInitialStore != null) {\r\n            info = analysis.createCopiedStore(fixedInitialStore);\r\n        } else {\r\n            info = analysis.createEmptyStore(sequentialSemantics);\r\n        }\r\n        AnnotatedTypeFactory factory = analysis.getTypeFactory();\r\n        for (LocalVariableNode p : parameters) {\r\n            AnnotatedTypeMirror anno = factory.getAnnotatedType(p.getElement());\r\n            info.initializeMethodParameter(p, analysis.createAbstractValue(anno));\r\n        }\r\n        CFGMethod method = (CFGMethod) underlyingAST;\r\n        MethodTree methodTree = method.getMethod();\r\n        ExecutableElement methodElem = TreeUtils.elementFromDeclaration(methodTree);\r\n        addInformationFromPreconditions(info, factory, method, methodTree, methodElem);\r\n        final ClassTree classTree = method.getClassTree();\r\n        addFieldValues(info, factory, classTree, methodTree);\r\n        addFinalLocalValues(info, methodElem);\r\n        if (shouldPerformWholeProgramInference(methodTree, methodElem)) {\r\n            Map<AnnotatedDeclaredType, ExecutableElement> overriddenMethods = AnnotatedTypes.overriddenMethods(analysis.atypeFactory.getElementUtils(), analysis.atypeFactory, methodElem);\r\n            for (Map.Entry<AnnotatedDeclaredType, ExecutableElement> pair : overriddenMethods.entrySet()) {\r\n                AnnotatedExecutableType overriddenMethod = AnnotatedTypes.asMemberOf(analysis.atypeFactory.getProcessingEnv().getTypeUtils(), analysis.atypeFactory, pair.getKey(), pair.getValue());\r\n                analysis.atypeFactory.getWholeProgramInference().updateInferredMethodParameterTypes(methodTree, methodElem, overriddenMethod, analysis.getTypeFactory());\r\n                analysis.atypeFactory.getWholeProgramInference().updateInferredMethodReceiverType(methodTree, methodElem, overriddenMethod, analysis.getTypeFactory());\r\n            }\r\n        }\r\n    } else if (underlyingAST.getKind() == Kind.LAMBDA) {\r\n        info = analysis.createCopiedStore(fixedInitialStore);\r\n        info.classValues.clear();\r\n        info.arrayValues.clear();\r\n        info.methodValues.clear();\r\n        AnnotatedTypeFactory factory = analysis.getTypeFactory();\r\n        for (LocalVariableNode p : parameters) {\r\n            AnnotatedTypeMirror anno = factory.getAnnotatedType(p.getElement());\r\n            info.initializeMethodParameter(p, analysis.createAbstractValue(anno));\r\n        }\r\n        CFGLambda lambda = (CFGLambda) underlyingAST;\r\n        Tree enclosingTree = TreeUtils.enclosingOfKind(factory.getPath(lambda.getLambdaTree()), new HashSet(// Tree.Kind for which TreeUtils.isClassTree is true\r\n        Arrays.asList(Tree.Kind.METHOD, Tree.Kind.CLASS, Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE, Tree.Kind.ENUM)));\r\n        Element enclosingElement = null;\r\n        if (enclosingTree.getKind() == Tree.Kind.METHOD) {\r\n            enclosingElement = TreeUtils.elementFromTree(enclosingTree);\r\n        } else if (TreeUtils.isClassTree(enclosingTree)) {\r\n            TreePath loopTree = factory.getPath(lambda.getLambdaTree()).getParentPath();\r\n            Element anEnclosingElement = null;\r\n            while (loopTree.getLeaf() != enclosingTree) {\r\n                Element sym = TreeUtils.elementFromTree(loopTree.getLeaf());\r\n                if (sym != null) {\r\n                    anEnclosingElement = sym;\r\n                    break;\r\n                }\r\n                loopTree = loopTree.getParentPath();\r\n            }\r\n            while (anEnclosingElement != null && !anEnclosingElement.equals(TreeUtils.elementFromTree(enclosingTree))) {\r\n                if (anEnclosingElement.getKind() == ElementKind.INSTANCE_INIT || anEnclosingElement.getKind() == ElementKind.STATIC_INIT) {\r\n                    enclosingElement = anEnclosingElement;\r\n                    break;\r\n                }\r\n                anEnclosingElement = anEnclosingElement.getEnclosingElement();\r\n            }\r\n        }\r\n        if (enclosingElement != null) {\r\n            addFinalLocalValues(info, enclosingElement);\r\n        }\r\n        Map<FieldAccess, V> fieldValuesClone = new HashMap(info.fieldValues);\r\n        for (Entry<FieldAccess, V> fieldValue : fieldValuesClone.entrySet()) {\r\n            AnnotatedTypeMirror declaredType = factory.getAnnotatedType(fieldValue.getKey().getField());\r\n            V lubbedValue = analysis.createAbstractValue(declaredType).leastUpperBound(fieldValue.getValue());\r\n            info.fieldValues.put(fieldValue.getKey(), lubbedValue);\r\n        }\r\n    } else {\r\n        assert false : \"Unexpected tree: \" + underlyingAST;\r\n        info = null;\r\n    }\r\n    return info;\r\n}"
}, {
	"Path": "java.util.StringTokenizer.setMaxDelimCodePoint",
	"Comment": "set maxdelimcodepoint to the highest char in the delimiter set.",
	"Method": "void setMaxDelimCodePoint(){\r\n    if (delimiters == null) {\r\n        maxDelimCodePoint = 0;\r\n        return;\r\n    }\r\n    int m = 0;\r\n    int c;\r\n    int count = 0;\r\n    for (int i = 0; i < delimiters.length(); i += Character.charCount(c)) {\r\n        c = delimiters.charAt(i);\r\n        if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {\r\n            c = delimiters.codePointAt(i);\r\n            hasSurrogates = true;\r\n        }\r\n        if (m < c)\r\n            m = c;\r\n        count++;\r\n    }\r\n    maxDelimCodePoint = m;\r\n    if (hasSurrogates) {\r\n        delimiterCodePoints = new int[count];\r\n        for (int i = 0, j = 0; i < count; i++, j += Character.charCount(c)) {\r\n            c = delimiters.codePointAt(j);\r\n            delimiterCodePoints[i] = c;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.diagnostics.TestDiagnosticUtils.isJavaDiagnosticLineContinuation",
	"Comment": "return true if this line in a java file continues an expected diagnostic.",
	"Method": "boolean isJavaDiagnosticLineContinuation(String originalLine){\r\n    if (originalLine == null) {\r\n        return false;\r\n    }\r\n    final String trimmedLine = originalLine.trim();\r\n    return trimmedLine.startsWith(\"// \") && !trimmedLine.startsWith(\"// warning:\");\r\n}"
}, {
	"Path": "java.lang.AbstractStringBuilder.append",
	"Comment": "documentation in subclasses because of synchro difference",
	"Method": "AbstractStringBuilder append(Object obj,AbstractStringBuilder append,String str,AbstractStringBuilder append,StringBuffer sb,AbstractStringBuilder append,AbstractStringBuilder asb,AbstractStringBuilder append,CharSequence s,AbstractStringBuilder append,CharSequence s,int start,int end,AbstractStringBuilder append,char[] str,AbstractStringBuilder append,char str,int offset,int len,AbstractStringBuilder append,boolean b,AbstractStringBuilder append,char c,AbstractStringBuilder append,int i,AbstractStringBuilder append,long l,AbstractStringBuilder append,float f,AbstractStringBuilder append,double d){\r\n    throw new Error(\"skeleton file\");\r\n}"
}, {
	"Path": "java.util.jar.JarEntry.getCodeSigners",
	"Comment": "returns the codesigner objects for this entry, ornull if none. this method can only be called oncethe jarentry has been completely verified by readingfrom the entry input stream until the end of the stream has beenreached. otherwise, this method will return null.the returned array comprises all the code signers that have signedthis entry.",
	"Method": "CodeSigner @Nullable[] getCodeSigners(){\r\n    return signers == null ? null : signers.clone();\r\n}"
}, {
	"Path": "java.util.zip.ZipFile.getInflater",
	"Comment": "gets an inflater from the list of available inflaters or allocatesa new one.",
	"Method": "Inflater getInflater(){\r\n    Inflater inf;\r\n    synchronized (inflaterCache) {\r\n        while (null != (inf = inflaterCache.poll())) {\r\n            if (false == inf.ended()) {\r\n                return inf;\r\n            }\r\n        }\r\n    }\r\n    return new Inflater(true);\r\n}"
}, {
	"Path": "java.util.JumboEnumSet.equals",
	"Comment": "compares the specified object with this set for equality.returnstrue if the given object is also a set, the two sets havethe same size, and every member of the given set is contained inthis set.",
	"Method": "boolean equals(Object o){\r\n    if (!(o instanceof JumboEnumSet))\r\n        return super.equals(o);\r\n    JumboEnumSet es = (JumboEnumSet) o;\r\n    if (es.elementType != elementType)\r\n        return size == 0 && es.size == 0;\r\n    return Arrays.equals(es.elements, elements);\r\n}"
}, {
	"Path": "org.checkerframework.checker.i18nformatter.I18nFormatterTreeUtil.createFormatForCall",
	"Comment": "returns an i18nformatcall instance, only if formatfor is called. otherwise, returns null.",
	"Method": "I18nFormatCall createFormatForCall(MethodInvocationTree tree,MethodInvocationNode node,I18nFormatterAnnotatedTypeFactory atypeFactory){\r\n    ExecutableElement method = TreeUtils.elementFromUse(tree);\r\n    AnnotatedExecutableType methodAnno = atypeFactory.getAnnotatedType(method);\r\n    for (AnnotatedTypeMirror paramType : methodAnno.getParameterTypes()) {\r\n        if (paramType.getAnnotation(I18nFormatFor.class) != null) {\r\n            return atypeFactory.treeUtil.new I18nFormatCall(tree, node, atypeFactory);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.util.IdentityIntMap.get",
	"Comment": "puts a new value in the property table with the appropriate flags",
	"Method": "int get(Object key){\r\n    int prime = _prime;\r\n    int hash = System.identityHashCode(key) % prime;\r\n    final Object[] keys = _keys;\r\n    while (true) {\r\n        Object mapKey = keys[hash];\r\n        if (mapKey == null) {\r\n            return NULL;\r\n        } else if (mapKey == key) {\r\n            return _values[hash];\r\n        }\r\n        hash = (hash + 1) % prime;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.dependenttypes.DependentTypesHelper.hasDependentAnnotations",
	"Comment": "returns true if any qualifier in the type system is a dependent type annotation.",
	"Method": "boolean hasDependentAnnotations(){\r\n    return !annoToElements.isEmpty();\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.lowerbound.LowerBoundAnnotatedTypeFactory.anmFromVal",
	"Comment": "determine the annotation that should be associated with a literal.",
	"Method": "AnnotationMirror anmFromVal(long val){\r\n    if (val >= 1) {\r\n        return POS;\r\n    } else if (val >= 0) {\r\n        return NN;\r\n    } else if (val >= -1) {\r\n        return GTEN1;\r\n    } else {\r\n        return UNKNOWN;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.flow.CFAbstractTransfer.visitCase",
	"Comment": "a case produces no value, but it may imply some facts about the argument to the switchstatement.",
	"Method": "TransferResult<V, S> visitCase(CaseNode n,TransferInput<V, S> in){\r\n    S store = in.getRegularStore();\r\n    TransferResult<V, S> result = new ConditionalTransferResult(finishValue(null, store), in.getThenStore(), in.getElseStore(), false);\r\n    V caseValue = in.getValueOfSubNode(n.getCaseOperand());\r\n    AssignmentNode assign = (AssignmentNode) n.getSwitchOperand();\r\n    V switchValue = store.getValue(FlowExpressions.internalReprOf(analysis.getTypeFactory(), assign.getTarget()));\r\n    result = strengthenAnnotationOfEqualTo(result, n.getCaseOperand(), assign.getExpression(), caseValue, switchValue, false);\r\n    result = strengthenAnnotationOfEqualTo(result, n.getCaseOperand(), assign.getTarget(), caseValue, switchValue, false);\r\n    return result;\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.StubParser.putNew",
	"Comment": "just like map.put, but merges with any existing value for the given key, instead ef replacingit.",
	"Method": "void putNew(Map<Element, AnnotatedTypeMirror> m,Element key,AnnotatedTypeMirror value){\r\n    if (key == null) {\r\n        throw new BugInCF(\"StubParser: key is null\");\r\n    }\r\n    if (m.containsKey(key)) {\r\n        AnnotatedTypeMirror value2 = m.get(key);\r\n        AnnotatedTypeMerger.merge(value, value2);\r\n        m.put(key, value2);\r\n    } else {\r\n        m.put(key, value);\r\n    }\r\n}"
}, {
	"Path": "java.lang.String.contains",
	"Comment": "returns true if and only if this string contains the specifiedsequence of char values.",
	"Method": "boolean contains(CharSequence s){\r\n    return indexOf(s.toString()) > -1;\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.UpperBoundVisitor.checkEffectivelyFinalAndParsable",
	"Comment": "determines if the java expression named by s is effectively final at the current programlocation.",
	"Method": "void checkEffectivelyFinalAndParsable(String s,FlowExpressionContext context,Tree error){\r\n    Receiver rec;\r\n    try {\r\n        rec = FlowExpressionParseUtil.parse(s, context, getCurrentPath(), false);\r\n    } catch (FlowExpressionParseException e) {\r\n        checker.report(e.getResult(), error);\r\n        return;\r\n    }\r\n    Element element = null;\r\n    if (rec instanceof LocalVariable) {\r\n        element = ((LocalVariable) rec).getElement();\r\n    } else if (rec instanceof FieldAccess) {\r\n        element = ((FieldAccess) rec).getField();\r\n    } else if (rec instanceof ThisReference || rec instanceof ValueLiteral) {\r\n        return;\r\n    }\r\n    if (element == null || !ElementUtils.isEffectivelyFinal(element)) {\r\n        checker.report(Result.failure(NOT_FINAL, rec), error);\r\n    }\r\n}"
}, {
	"Path": "java.awt.image.ColorModel.getPixelSize",
	"Comment": "returns the number of bits per pixel described by thiscolormodel.",
	"Method": "int getPixelSize(){\r\n    return pixel_bits;\r\n}"
}, {
	"Path": "java.util.ResourceBundle.containsKey",
	"Comment": "determines whether the given key is contained inthis resourcebundle or its parent bundles.",
	"Method": "boolean containsKey(String key){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.zip.ZipInputStream.close",
	"Comment": "closes this input stream and releases any system resources associatedwith the stream.",
	"Method": "void close(){\r\n    if (!closed) {\r\n        super.close();\r\n        closed = true;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.getFnInterfaceFromTree",
	"Comment": "returns the functional interface and the function type that this lambda or member referencestargets.the function type is the type of the single method declared in the functional interfaceadapted as if it were invoked using the functional interface as the receiver expression.the target type of a lambda or a method reference is the type to which it is assigned orcasted.",
	"Method": "Pair<AnnotatedDeclaredType, AnnotatedExecutableType> getFnInterfaceFromTree(MemberReferenceTree tree,Pair<AnnotatedDeclaredType, AnnotatedExecutableType> getFnInterfaceFromTree,LambdaExpressionTree tree,Pair<AnnotatedDeclaredType, AnnotatedExecutableType> getFnInterfaceFromTree,Tree tree){\r\n    AnnotatedDeclaredType functionalInterfaceType = getFunctionalInterfaceType(tree);\r\n    makeGroundTargetType(functionalInterfaceType, (DeclaredType) TreeUtils.typeOf(tree));\r\n    Element fnElement = TreeUtils.findFunction(tree, processingEnv);\r\n    AnnotatedExecutableType functionType = (AnnotatedExecutableType) AnnotatedTypes.asMemberOf(types, this, functionalInterfaceType, fnElement);\r\n    return Pair.of(functionalInterfaceType, functionType);\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.dependenttypes.DependentTypesHelper.standardizeAnnotation",
	"Comment": "standardizes java expressions in an annotation. if the annotation is not a dependent typeannotation, returns the same annotation unchanged.",
	"Method": "AnnotationMirror standardizeAnnotation(FlowExpressionContext context,TreePath localScope,AnnotationMirror anno,boolean useLocalScope){\r\n    if (!isExpressionAnno(anno)) {\r\n        return anno;\r\n    }\r\n    return standardizeDependentTypeAnnotation(context, localScope, anno, useLocalScope);\r\n}"
}, {
	"Path": "com.mycompany.myapp.domain.UseCase2.toString",
	"Comment": "construct a readable string representation for this usecase2 instance.",
	"Method": "String toString(){\r\n    return // \r\n    MoreObjects.toStringHelper(this).add(\"id\", // \r\n    getId()).add(\"dummy\", getDummy()).toString();\r\n}"
}, {
	"Path": "java.io.PipedOutputStream.close",
	"Comment": "closes this piped output stream and releases any system resourcesassociated with this stream. this stream may no longer be used forwriting bytes.",
	"Method": "void close(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.solver.ConstraintMap.addTargetSupertype",
	"Comment": "add a constraint indicating that target is a supertype of subtype in the given qualifierhierarchies.",
	"Method": "void addTargetSupertype(TypeVariable target,TypeVariable subtype,AnnotationMirrorSet hierarchies){\r\n    final Supertypes supertypes = targetToRecords.get(target).supertypes;\r\n    final AnnotationMirrorSet supertypeTops = supertypes.targets.get(subtype);\r\n    if (supertypeTops == null) {\r\n        supertypes.targets.put(subtype, new AnnotationMirrorSet(hierarchies));\r\n    } else {\r\n        supertypeTops.addAll(hierarchies);\r\n    }\r\n}"
}, {
	"Path": "java.util.Collections.copy",
	"Comment": "copies all of the elements from one list into another.after theoperation, the index of each copied element in the destination listwill be identical to its index in the source list.the destinationlist must be at least as long as the source list.if it is longer, theremaining elements in the destination list are unaffected. this method runs in linear time.",
	"Method": "void copy(List<? super T> dest,List<? extends T> src){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "sun.util.resources.OpenListResourceBundle.createMap",
	"Comment": "lets subclasses provide specialized map implementations.default uses hashmap.",
	"Method": "Map createMap(int size){\r\n    return new HashMap(size);\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.GenericAnnotatedTypeFactory.createFlowTransferFunction",
	"Comment": "however, we ran into issues in callers of the method if we used that type.",
	"Method": "TransferFunction createFlowTransferFunction(CFAbstractAnalysis<Value, Store, TransferFunction> analysis){\r\n    Class<?> checkerClass = checker.getClass();\r\n    while (checkerClass != BaseTypeChecker.class) {\r\n        final String classToLoad = checkerClass.getName().replace(\"Checker\", \"Transfer\").replace(\"Subchecker\", \"Transfer\");\r\n        TransferFunction result = BaseTypeChecker.invokeConstructorFor(classToLoad, new Class<?>[] { analysis.getClass() }, new Object[] { analysis });\r\n        if (result != null) {\r\n            return result;\r\n        }\r\n        checkerClass = checkerClass.getSuperclass();\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    TransferFunction ret = (TransferFunction) new CFTransfer((CFAbstractAnalysis<CFValue, CFStore, CFTransfer>) analysis);\r\n    return ret;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeMirror.replaceAnnotation",
	"Comment": "adds an annotation to this type, removing any existing annotation from the same qualifierhierarchy first.",
	"Method": "void replaceAnnotation(AnnotationMirror a){\r\n    if (!AnnotationUtils.areSameByClass(a, PolyAll.class)) {\r\n        this.removeAnnotationInHierarchy(a);\r\n    }\r\n    this.addAnnotation(a);\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.TestConfigurationBuilder.build",
	"Comment": "creates a testconfiguration using the settings in this builder. the settings are notvalidated first.",
	"Method": "TestConfiguration build(){\r\n    return new ImmutableTestConfiguration(diagnosticFiles, testSourceFiles, new ArrayList(processors), options.getOptions(), shouldEmitDebugInfo);\r\n}"
}, {
	"Path": "java.io.DataInputStream.readChar",
	"Comment": "see the general contract of the readcharmethod of datainput.bytesfor this operation are read from the containedinput stream.",
	"Method": "char readChar(){\r\n    int ch1 = in.read();\r\n    int ch2 = in.read();\r\n    if ((ch1 | ch2) < 0)\r\n        throw new EOFException();\r\n    return (char) ((ch1 << 8) + (ch2 << 0));\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.registerValidation",
	"Comment": "register an object to be validated before the graph is returned.whilesimilar to resolveobject these validations are called after the entiregraph has been reconstituted.typically, a readobject method willregister the object with the stream so that when all of the objects arerestored a final set of validations can be performed.",
	"Method": "void registerValidation(ObjectInputValidation obj,int prio){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.TestUtilities.findJavaFilesPerDirectory",
	"Comment": "returns a list where each item is a list of java files, excluding any skip tests, for eachdirectory given by dirname and also a list for any subdirectory.",
	"Method": "List<List<File>> findJavaFilesPerDirectory(File parent,String dirNames){\r\n    List<List<File>> filesPerDirectory = new ArrayList();\r\n    for (String dirName : dirNames) {\r\n        File dir = new File(parent, dirName);\r\n        if (dir.isDirectory()) {\r\n            filesPerDirectory.addAll(findJavaTestFilesInDirectory(dir));\r\n        }\r\n    }\r\n    return filesPerDirectory;\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.isProxy",
	"Comment": "returns true if class descriptor represents a dynamic proxy class, falseotherwise.",
	"Method": "boolean isProxy(){\r\n    return isProxy;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.treeannotator.ImplicitsTreeAnnotator.visitLiteral",
	"Comment": "go through the string patterns and add the greatest lower bound of all matching patterns.",
	"Method": "Void visitLiteral(LiteralTree tree,AnnotatedTypeMirror type){\r\n    if (!stringPatterns.isEmpty() && tree.getKind() == Kind.STRING_LITERAL) {\r\n        List<Set<? extends AnnotationMirror>> matches = new ArrayList();\r\n        List<Set<? extends AnnotationMirror>> nonMatches = new ArrayList();\r\n        String string = (String) tree.getValue();\r\n        for (Pattern pattern : stringPatterns.keySet()) {\r\n            Set<AnnotationMirror> sam = stringPatterns.get(pattern);\r\n            if (pattern.matcher(string).matches()) {\r\n                matches.add(sam);\r\n            } else {\r\n                nonMatches.add(sam);\r\n            }\r\n        }\r\n        Set<? extends AnnotationMirror> res = null;\r\n        if (!matches.isEmpty()) {\r\n            res = matches.get(0);\r\n            for (Set<? extends AnnotationMirror> sam : matches) {\r\n                res = qualHierarchy.greatestLowerBounds(res, sam);\r\n            }\r\n            for (Set<? extends AnnotationMirror> sam : nonMatches) {\r\n                if (qualHierarchy.isSubtype(res, sam)) {\r\n                    throw new BugInCF(\"Bug in @ImplicitFor(stringpatterns=...) in type hierarchy definition: inferred type for \\\"\" + string + \"\\\" is \" + res + \" which is a subtype of \" + sam + \" but its pattern does not match the string.  matches = \" + matches + \"; nonMatches = \" + nonMatches);\r\n                }\r\n            }\r\n            type.addAnnotations(res);\r\n        }\r\n    }\r\n    return super.visitLiteral(tree, type);\r\n}"
}, {
	"Path": "java.text.MessageFormat.readObject",
	"Comment": "after reading an object from the input stream, do a simple verificationto maintain class invariants.",
	"Method": "void readObject(ObjectInputStream in){\r\n    in.defaultReadObject();\r\n    boolean isValid = maxOffset >= -1 && formats.length > maxOffset && offsets.length > maxOffset && argumentNumbers.length > maxOffset;\r\n    if (isValid) {\r\n        int lastOffset = pattern.length() + 1;\r\n        for (int i = maxOffset; i >= 0; --i) {\r\n            if ((offsets[i] < 0) || (offsets[i] > lastOffset)) {\r\n                isValid = false;\r\n                break;\r\n            } else {\r\n                lastOffset = offsets[i];\r\n            }\r\n        }\r\n    }\r\n    if (!isValid) {\r\n        throw new InvalidObjectException(\"Could not reconstruct MessageFormat from corrupt stream.\");\r\n    }\r\n}"
}, {
	"Path": "java.util.WeakHashMap.containsValue",
	"Comment": "returns true if this map maps one or more keys to thespecified value.",
	"Method": "boolean containsValue(Object value){\r\n    if (value == null)\r\n        return containsNullValue();\r\n    Entry<K, V>[] tab = getTable();\r\n    for (int i = tab.length; i-- > 0; ) for (Entry<K, V> e = tab[i]; e != null; e = e.next) if (value.equals(e.value))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "java.util.JumboEnumSet.retainAll",
	"Comment": "retains only the elements in this set that are contained in thespecified collection.",
	"Method": "boolean retainAll(Collection<?> c){\r\n    if (!(c instanceof JumboEnumSet))\r\n        return super.retainAll(c);\r\n    JumboEnumSet<?> es = (JumboEnumSet<?>) c;\r\n    if (es.elementType != elementType) {\r\n        boolean changed = (size != 0);\r\n        clear();\r\n        return changed;\r\n    }\r\n    for (int i = 0; i < elements.length; i++) elements[i] &= es.elements[i];\r\n    return recalculateSize();\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueCheckerUtils.getRangeFromValues",
	"Comment": "get the minimum and maximum of a list and return a range bounded by them.",
	"Method": "Range getRangeFromValues(List<? extends Number> values){\r\n    if (values == null) {\r\n        return null;\r\n    } else if (values.isEmpty()) {\r\n        return Range.NOTHING;\r\n    }\r\n    List<Long> longValues = new ArrayList();\r\n    for (Number value : values) {\r\n        longValues.add(value.longValue());\r\n    }\r\n    return new Range(Collections.min(longValues), Collections.max(longValues));\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.Hessian2Input.startCall",
	"Comment": "starts reading the call, including the headers.the call expects the following protocol datac major minorm b16 b8 method",
	"Method": "void startCall(){\r\n    readCall();\r\n    readMethod();\r\n}"
}, {
	"Path": "com.alibaba.citrus.util.internal.apache.lang.HashCodeBuilder.append",
	"Comment": "append a hashcode for a boolean.this adds iconstant1 to the hashcode and nota 1231 or 1237 as done in java.lang.boolean.this is in accordance with the effective java design.",
	"Method": "HashCodeBuilder append(boolean value,HashCodeBuilder append,boolean[] array,HashCodeBuilder append,byte value,HashCodeBuilder append,byte[] array,HashCodeBuilder append,char value,HashCodeBuilder append,char[] array,HashCodeBuilder append,double value,HashCodeBuilder append,double[] array,HashCodeBuilder append,float value,HashCodeBuilder append,float[] array,HashCodeBuilder append,int value,HashCodeBuilder append,int[] array,HashCodeBuilder append,long value,HashCodeBuilder append,long[] array,HashCodeBuilder append,Object object,HashCodeBuilder append,Object[] array,HashCodeBuilder append,short value,HashCodeBuilder append,short[] array){\r\n    if (array == null) {\r\n        iTotal = iTotal * iConstant;\r\n    } else {\r\n        for (short element : array) {\r\n            append(element);\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "java.awt.image.ColorModel.getNumComponents",
	"Comment": "returns the number of components, including alpha, in thiscolormodel.this is equal to the number of colorcomponents, optionally plus one, if there is an alpha component.",
	"Method": "int getNumComponents(){\r\n    return numComponents;\r\n}"
}, {
	"Path": "org.camunda.bpm.qa.performance.engine.sqlstatementlog.StatementLogSqlSession.stopLogging",
	"Comment": "stops logging statement executed by the current thread and returns the list of logged statements.",
	"Method": "List<SqlStatementLog> stopLogging(){\r\n    List<SqlStatementLog> log = threadStatementLog.get();\r\n    threadStatementLog.remove();\r\n    return log;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.treeannotator.TreeAnnotator.visitMethod",
	"Comment": "this method is not called when checking a method invocation against its declaration. so,instead of overriding this method, override typeannotator.visitexecutable.typeannotator.visitexecutable is called both when checking method declarations and methodinvocations.",
	"Method": "Void visitMethod(MethodTree node,AnnotatedTypeMirror p){\r\n    return super.visitMethod(node, p);\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueTransfer.createNewResult",
	"Comment": "create a new transfer result based on the original result and the new annotation.",
	"Method": "TransferResult<CFValue, CFStore> createNewResult(TransferResult<CFValue, CFStore> result,AnnotationMirror resultAnno){\r\n    CFValue newResultValue = analysis.createSingleAnnotationValue(resultAnno, result.getResultValue().getUnderlyingType());\r\n    return new RegularTransferResult(newResultValue, result.getRegularStore());\r\n}"
}, {
	"Path": "com.alibaba.citrus.generictype.codegen.asm.Method.getArgumentTypes",
	"Comment": "returns the argument types of the method described by this object.",
	"Method": "Type[] getArgumentTypes(){\r\n    return Type.getArgumentTypes(desc);\r\n}"
}, {
	"Path": "java.text.MessageFormat.applyPattern",
	"Comment": "sets the pattern used by this message format.the method parses the pattern and creates a list of subformatsfor the format elements contained in it.patterns and their interpretation are specified in theclass description.",
	"Method": "void applyPattern(String pattern){\r\n    StringBuilder[] segments = new StringBuilder[4];\r\n    segments[SEG_RAW] = new StringBuilder();\r\n    int part = SEG_RAW;\r\n    int formatNumber = 0;\r\n    boolean inQuote = false;\r\n    int braceStack = 0;\r\n    maxOffset = -1;\r\n    for (int i = 0; i < pattern.length(); ++i) {\r\n        char ch = pattern.charAt(i);\r\n        if (part == SEG_RAW) {\r\n            if (ch == '\\'') {\r\n                if (i + 1 < pattern.length() && pattern.charAt(i + 1) == '\\'') {\r\n                    segments[part].append(ch);\r\n                    ++i;\r\n                } else {\r\n                    inQuote = !inQuote;\r\n                }\r\n            } else if (ch == '{' && !inQuote) {\r\n                part = SEG_INDEX;\r\n                if (segments[SEG_INDEX] == null) {\r\n                    segments[SEG_INDEX] = new StringBuilder();\r\n                }\r\n            } else {\r\n                segments[part].append(ch);\r\n            }\r\n        } else {\r\n            if (inQuote) {\r\n                segments[part].append(ch);\r\n                if (ch == '\\'') {\r\n                    inQuote = false;\r\n                }\r\n            } else {\r\n                switch(ch) {\r\n                    case ',':\r\n                        if (part < SEG_MODIFIER) {\r\n                            if (segments[++part] == null) {\r\n                                segments[part] = new StringBuilder();\r\n                            }\r\n                        } else {\r\n                            segments[part].append(ch);\r\n                        }\r\n                        break;\r\n                    case '{':\r\n                        ++braceStack;\r\n                        segments[part].append(ch);\r\n                        break;\r\n                    case '}':\r\n                        if (braceStack == 0) {\r\n                            part = SEG_RAW;\r\n                            makeFormat(i, formatNumber, segments);\r\n                            formatNumber++;\r\n                            segments[SEG_INDEX] = null;\r\n                            segments[SEG_TYPE] = null;\r\n                            segments[SEG_MODIFIER] = null;\r\n                        } else {\r\n                            --braceStack;\r\n                            segments[part].append(ch);\r\n                        }\r\n                        break;\r\n                    case ' ':\r\n                        if (part != SEG_TYPE || segments[SEG_TYPE].length() > 0) {\r\n                            segments[part].append(ch);\r\n                        }\r\n                        break;\r\n                    case '\\'':\r\n                        inQuote = true;\r\n                    default:\r\n                        segments[part].append(ch);\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (braceStack == 0 && part != 0) {\r\n        maxOffset = -1;\r\n        throw new IllegalArgumentException(\"Unmatched braces in the pattern.\");\r\n    }\r\n    this.pattern = segments[0].toString();\r\n}"
}, {
	"Path": "org.checkerframework.common.basetype.BaseTypeChecker.getTypeFactoryOfSubchecker",
	"Comment": "returns the type factory used by a subchecker. returns null if no matching subchecker wasfound or if the type factory is null. the caller must know the exact checker class torequest.",
	"Method": "T getTypeFactoryOfSubchecker(Class<U> checkerClass){\r\n    BaseTypeChecker checker = getSubchecker(checkerClass);\r\n    if (checker != null) {\r\n        return (T) checker.getTypeFactory();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.io.ObjectOutputStream.reset",
	"Comment": "reset will disregard the state of any objects already written to thestream.the state is reset to be the same as a new objectoutputstream.the current point in the stream is marked as reset so the correspondingobjectinputstream will be reset at the same point.objects previouslywritten to the stream will not be refered to as already being in thestream.they will be written to the stream again.",
	"Method": "void reset(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.AbstractDeserializer.createField",
	"Comment": "creates a field value class. the defaultimplementation returns the string.",
	"Method": "Object createField(String name){\r\n    return name;\r\n}"
}, {
	"Path": "java.util.RegularEnumSet.addAll",
	"Comment": "adds all of the elements in the specified collection to this set.",
	"Method": "void addAll(boolean addAll,Collection<? extends E> c){\r\n    if (!(c instanceof RegularEnumSet))\r\n        return super.addAll(c);\r\n    RegularEnumSet es = (RegularEnumSet) c;\r\n    if (es.elementType != elementType) {\r\n        if (es.isEmpty())\r\n            return false;\r\n        else\r\n            throw new ClassCastException(es.elementType + \" != \" + elementType);\r\n    }\r\n    long oldElements = elements;\r\n    elements |= es.elements;\r\n    return elements != oldElements;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeMirror.getErased",
	"Comment": "returns the erasure type of the this type, according to jls specifications.",
	"Method": "AnnotatedTypeMirror getErased(AnnotatedDeclaredType getErased,AnnotatedExecutableType getErased,AnnotatedArrayType getErased,AnnotatedTypeMirror getErased,AnnotatedTypeMirror getErased){\r\n    return deepCopy();\r\n}"
}, {
	"Path": "java.lang.Enum.compareTo",
	"Comment": "compares this enum with the specified object for order.returns anegative integer, zero, or a positive integer as this object is lessthan, equal to, or greater than the specified object.enum constants are only comparable to other enum constants of thesame enum type.the natural order implemented by thismethod is the order in which the constants are declared.",
	"Method": "int compareTo(E o){\r\n    Enum<?> other = (Enum<?>) o;\r\n    Enum<E> self = this;\r\n    if (self.getClass() != other.getClass() && self.getDeclaringClass() != other.getDeclaringClass())\r\n        throw new ClassCastException();\r\n    return self.ordinal - other.ordinal;\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.OffsetEquation.lessThanOrEqual",
	"Comment": "returns whether or not this equation is known to be less than or equal to the other equation.",
	"Method": "boolean lessThanOrEqual(OffsetEquation other){\r\n    return (isInt() && other.isInt() && intValue <= other.getInt()) || this.equals(other);\r\n}"
}, {
	"Path": "java.net.URLClassLoader.definePackage",
	"Comment": "defines a new package by name in this classloader. the attributescontained in the specified manifest will be used to obtain packageversion and sealing information. for sealed packages, the additionalurl specifies the code source url from which the package was loaded.",
	"Method": "Package definePackage(String name,Manifest man,URL url){\r\n    String path = name.replace('.', '/').concat(\"/\");\r\n    String specTitle = null, specVersion = null, specVendor = null;\r\n    String implTitle = null, implVersion = null, implVendor = null;\r\n    String sealed = null;\r\n    URL sealBase = null;\r\n    Attributes attr = man.getAttributes(path);\r\n    if (attr != null) {\r\n        specTitle = attr.getValue(Name.SPECIFICATION_TITLE);\r\n        specVersion = attr.getValue(Name.SPECIFICATION_VERSION);\r\n        specVendor = attr.getValue(Name.SPECIFICATION_VENDOR);\r\n        implTitle = attr.getValue(Name.IMPLEMENTATION_TITLE);\r\n        implVersion = attr.getValue(Name.IMPLEMENTATION_VERSION);\r\n        implVendor = attr.getValue(Name.IMPLEMENTATION_VENDOR);\r\n        sealed = attr.getValue(Name.SEALED);\r\n    }\r\n    attr = man.getMainAttributes();\r\n    if (attr != null) {\r\n        if (specTitle == null) {\r\n            specTitle = attr.getValue(Name.SPECIFICATION_TITLE);\r\n        }\r\n        if (specVersion == null) {\r\n            specVersion = attr.getValue(Name.SPECIFICATION_VERSION);\r\n        }\r\n        if (specVendor == null) {\r\n            specVendor = attr.getValue(Name.SPECIFICATION_VENDOR);\r\n        }\r\n        if (implTitle == null) {\r\n            implTitle = attr.getValue(Name.IMPLEMENTATION_TITLE);\r\n        }\r\n        if (implVersion == null) {\r\n            implVersion = attr.getValue(Name.IMPLEMENTATION_VERSION);\r\n        }\r\n        if (implVendor == null) {\r\n            implVendor = attr.getValue(Name.IMPLEMENTATION_VENDOR);\r\n        }\r\n        if (sealed == null) {\r\n            sealed = attr.getValue(Name.SEALED);\r\n        }\r\n    }\r\n    if (\"true\".equalsIgnoreCase(sealed)) {\r\n        sealBase = url;\r\n    }\r\n    return definePackage(name, specTitle, specVersion, specVendor, implTitle, implVersion, implVendor, sealBase);\r\n}"
}, {
	"Path": "java.awt.image.ColorModel.toString",
	"Comment": "returns the string representation of the contents ofthis colormodelobject.",
	"Method": "String toString(){\r\n    return new String(\"ColorModel: #pixelBits = \" + pixel_bits + \" numComponents = \" + numComponents + \" color space = \" + colorSpace + \" transparency = \" + transparency + \" has alpha = \" + supportsAlpha + \" isAlphaPre = \" + isAlphaPremultiplied);\r\n}"
}, {
	"Path": "java.io.RandomAccessFile.writeShort",
	"Comment": "writes a short to the file as two bytes, high byte first.the write starts at the current position of the file pointer.",
	"Method": "void writeShort(int v){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueAnnotatedTypeFactory.createArrayLengthResultAnnotation",
	"Comment": "returns a constant value annotation for a length of an array or string type with a constantvalue annotation.",
	"Method": "AnnotationMirror createArrayLengthResultAnnotation(AnnotatedTypeMirror receiverType){\r\n    AnnotationMirror arrayAnno = receiverType.getAnnotationInHierarchy(UNKNOWNVAL);\r\n    if (AnnotationUtils.areSameByClass(arrayAnno, ArrayLen.class)) {\r\n        List<Integer> lengths = ValueAnnotatedTypeFactory.getArrayLength(arrayAnno);\r\n        return createNumberAnnotationMirror(new ArrayList(lengths));\r\n    }\r\n    if (AnnotationUtils.areSameByClass(arrayAnno, ArrayLenRange.class)) {\r\n        Range range = getRange(arrayAnno);\r\n        return createIntRangeAnnotation(range);\r\n    }\r\n    if (AnnotationUtils.areSameByClass(arrayAnno, StringVal.class)) {\r\n        List<String> strings = ValueAnnotatedTypeFactory.getStringValues(arrayAnno);\r\n        List<Integer> lengths = ValueCheckerUtils.getLengthsForStringValues(strings);\r\n        return createNumberAnnotationMirror(new ArrayList(lengths));\r\n    }\r\n    return createIntRangeAnnotation(0, Integer.MAX_VALUE);\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.putForCreate",
	"Comment": "the put method for readobject.it does not resize the table,update modcount, etc.",
	"Method": "void putForCreate(K key,V value){\r\n    Object k = maskNull(key);\r\n    Object[] tab = table;\r\n    int len = tab.length;\r\n    int i = hash(k, len);\r\n    Object item;\r\n    while ((item = tab[i]) != null) {\r\n        if (item == k)\r\n            throw new java.io.StreamCorruptedException();\r\n        i = nextKeyIndex(i, len);\r\n    }\r\n    tab[i] = k;\r\n    tab[i + 1] = value;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceValues",
	"Comment": "returns the result of accumulating the given transformationof all values using the given reducer to combine values, ornull if none.",
	"Method": "V reduceValues(long parallelismThreshold,BiFunction<? super V, ? super V, ? extends V> reducer,U reduceValues,long parallelismThreshold,Function<? super V, ? extends U> transformer,BiFunction<? super U, ? super U, ? extends U> reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceValuesTask<K, V, U>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, reducer).invoke();\r\n}"
}, {
	"Path": "java.util.LinkedList.clear",
	"Comment": "removes all of the elements from this list.the list will be empty after this call returns.",
	"Method": "void clear(){\r\n    for (Node<E> x = first; x != null; ) {\r\n        Node<E> next = x.next;\r\n        x.item = null;\r\n        x.next = null;\r\n        x.prev = null;\r\n        x = next;\r\n    }\r\n    first = last = null;\r\n    size = 0;\r\n    modCount++;\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.StubGenerator.stubFromField",
	"Comment": "generate the stub file for all the classes within the provided package.",
	"Method": "void stubFromField(Element elt){\r\n    if (!(elt.getKind() == ElementKind.FIELD)) {\r\n        return;\r\n    }\r\n    String pkg = ElementUtils.getVerboseName(ElementUtils.enclosingPackage(elt));\r\n    if (!\"\".equals(pkg)) {\r\n        currentPackage = pkg;\r\n        currentIndention = \"    \";\r\n        indent();\r\n    }\r\n    VariableElement field = (VariableElement) elt;\r\n    printFieldDecl(field);\r\n}"
}, {
	"Path": "java.io.ObjectInputStream.resolveObject",
	"Comment": "this method will allow trusted subclasses of objectinputstream tosubstitute one object for another during deserialization. replacingobjects is disabled until enableresolveobject is called. theenableresolveobject method checks that the stream requesting to resolveobject can be trusted. every reference to serializable objects is passedto resolveobject.to insure that the private state of objects is notunintentionally exposed only trusted streams may use resolveobject.this method is called after an object has been read but before it isreturned from readobject.the default resolveobject method just returnsthe same object.when a subclass is replacing objects it must insure that thesubstituted object is compatible with every field where the referencewill be stored.objects whose type is not a subclass of the type of thefield or array element abort the serialization by raising an exceptionand the object is not be stored.this method is called only once when each object is firstencountered.all subsequent references to the object will be redirectedto the new object.",
	"Method": "Object resolveObject(Object obj){\r\n    return obj;\r\n}"
}, {
	"Path": "org.checkerframework.common.value.util.Range.remainder",
	"Comment": "returns a range that includes all possible values of the remainder of dividing an arbitraryvalue in this range by an arbitrary value in the specified range.in the current implementation, the result might not be the smallest range that includesall the possible values.",
	"Method": "Range remainder(Range right){\r\n    if (this.isNothing() || right.isNothing()) {\r\n        return NOTHING;\r\n    }\r\n    if (right.from == 0 && right.to == 0) {\r\n        return NOTHING;\r\n    }\r\n    if (right.from == Long.MIN_VALUE) {\r\n        Range range;\r\n        if (from == Long.MIN_VALUE) {\r\n            if (to == Long.MIN_VALUE) {\r\n                range = new Range(0, 0);\r\n            } else {\r\n                range = new Range(from + 1, to).union(new Range(0, 0));\r\n            }\r\n        } else {\r\n            range = this;\r\n        }\r\n        if (right.to > Long.MIN_VALUE) {\r\n            Range rangeAdditional = this.remainder(new Range(right.from + 1, right.to));\r\n            range = range.union(rangeAdditional);\r\n        }\r\n        return range;\r\n    }\r\n    Range range1 = new Range(Math.max(Long.MIN_VALUE + 1, from), Math.max(Long.MIN_VALUE + 1, to)).union(new Range(0, 0));\r\n    long maxAbsolute = Math.max(Math.abs(right.from), Math.abs(right.to));\r\n    Range range2 = new Range(-maxAbsolute + 1, maxAbsolute - 1);\r\n    return range1.intersect(range2);\r\n}"
}, {
	"Path": "java.io.PipedReader.ready",
	"Comment": "tell whether this stream is ready to be read.a piped characterstream is ready if the circular buffer is not empty.",
	"Method": "boolean ready(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.io.BufferedReader.fill",
	"Comment": "fills the input buffer, taking the mark into account if it is valid.",
	"Method": "void fill(){\r\n    int dst;\r\n    if (markedChar <= UNMARKED) {\r\n        dst = 0;\r\n    } else {\r\n        int delta = nextChar - markedChar;\r\n        if (delta >= readAheadLimit) {\r\n            markedChar = INVALIDATED;\r\n            readAheadLimit = 0;\r\n            dst = 0;\r\n        } else {\r\n            if (readAheadLimit <= cb.length) {\r\n                System.arraycopy(cb, markedChar, cb, 0, delta);\r\n                markedChar = 0;\r\n                dst = delta;\r\n            } else {\r\n                char[] ncb = new char[readAheadLimit];\r\n                System.arraycopy(cb, markedChar, ncb, 0, delta);\r\n                cb = ncb;\r\n                markedChar = 0;\r\n                dst = delta;\r\n            }\r\n            nextChar = nChars = delta;\r\n        }\r\n    }\r\n    int n;\r\n    do {\r\n        n = in.read(cb, dst, cb.length - dst);\r\n    } while (n == 0);\r\n    if (n > 0) {\r\n        nChars = dst + n;\r\n        nextChar = dst;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.checker.signedness.SignednessUtil.byteFromFloat",
	"Comment": "returns an unsigned byte representing the same value as the float.",
	"Method": "byte byteFromFloat(float f){\r\n    assert f >= 0;\r\n    return (byte) f;\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TypeAnnotationUtils.isTypeCompoundContained",
	"Comment": "check whether a typecompound is contained in a list of typecompounds.",
	"Method": "boolean isTypeCompoundContained(List<TypeCompound> list,TypeCompound tc,Types types){\r\n    for (Attribute.TypeCompound rawat : list) {\r\n        if (contentEquals(rawat.type.tsym.name, tc.type.tsym.name) && rawat.values.equals(tc.values) && isSameTAPositionExceptTreePos(rawat.position, tc.position)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceEntriesToDouble",
	"Comment": "returns the result of accumulating the given transformationof all entries using the given reducer to combine values,and the given basis as an identity value.",
	"Method": "double reduceEntriesToDouble(long parallelismThreshold,ToDoubleFunction<Map.Entry<K, V>> transformer,double basis,DoubleBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceEntriesToDoubleTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.UseCase2DTOService.save",
	"Comment": "save the passed dto as a new entity or update the corresponding entity if any.",
	"Method": "UseCase2DTO save(UseCase2DTO dto){\r\n    if (dto == null) {\r\n        return null;\r\n    }\r\n    final UseCase2 useCase2;\r\n    if (dto.isIdSet()) {\r\n        UseCase2 useCase2Tmp = useCase2Repository.findOne(dto.id);\r\n        if (useCase2Tmp != null) {\r\n            useCase2 = useCase2Tmp;\r\n        } else {\r\n            useCase2 = new UseCase2();\r\n            useCase2.setId(dto.id);\r\n        }\r\n    } else {\r\n        useCase2 = new UseCase2();\r\n    }\r\n    useCase2.setDummy(dto.dummy);\r\n    return toDTO(useCase2Repository.save(useCase2));\r\n}"
}, {
	"Path": "java.util.logging.LogRecord.getThrown",
	"Comment": "get any throwable associated with the log record.if the event involved an exception, this will be theexception object. otherwise null.",
	"Method": "Throwable getThrown(){\r\n    return thrown;\r\n}"
}, {
	"Path": "java.io.Console.readLine",
	"Comment": "provides a formatted prompt, then reads a single line of text from the console.",
	"Method": "String readLine(String fmt,Object args,String readLine){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.io.BufferedOutputStream.flush",
	"Comment": "flushes this buffered output stream. this forces any bufferedoutput bytes to be written out to the underlying output stream.",
	"Method": "void flush(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.flow.CFAbstractAnalysis.visualizeCFG",
	"Comment": "perform a visualization of the cfg and analysis info for inspection.",
	"Method": "void visualizeCFG(){\r\n    atypeFactory.getCFGVisualizer().visualize(cfg, cfg.getEntryBlock(), this);\r\n}"
}, {
	"Path": "sun.security.action.LoadLibraryAction.run",
	"Comment": "loads the system library whose name was specified in the constructor.",
	"Method": "Void run(){\r\n    System.loadLibrary(theLib);\r\n    return null;\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.processQueue",
	"Comment": "removes from the specified map any keys that have been enqueuedon the specified reference queue.",
	"Method": "void processQueue(ReferenceQueue<Class<?>> queue,ConcurrentMap<? extends WeakReference<Class<?>>, ?> map){\r\n    Reference<? extends Class<?>> ref;\r\n    while ((ref = queue.poll()) != null) {\r\n        map.remove(ref);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.checker.signedness.SignednessUtil.toUnsignedLong",
	"Comment": "returns an unsigned long representing the same value as an unsigned char.",
	"Method": "long toUnsignedLong(int i,long toUnsignedLong,short s,long toUnsignedLong,byte b,long toUnsignedLong,char c){\r\n    return ((long) c) & 0xffL;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotationClassLoader.getDirectoryURL",
	"Comment": "given an absolute path to a directory, this method will return a url reference to thatdirectory.",
	"Method": "URL getDirectoryURL(String absolutePathToDirectory){\r\n    URL directoryURL = null;\r\n    try {\r\n        directoryURL = new File(absolutePathToDirectory).toURI().toURL();\r\n    } catch (MalformedURLException e) {\r\n        processingEnv.getMessager().printMessage(Kind.NOTE, \"Directory URL \" + absolutePathToDirectory + \" is malformed\");\r\n    }\r\n    return directoryURL;\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.trees.TreeBuilder.getValueOfMethod",
	"Comment": "returns the valueof method of a boxed type such as short or float.",
	"Method": "Symbol.MethodSymbol getValueOfMethod(ProcessingEnvironment env,TypeMirror boxedType){\r\n    Symbol.MethodSymbol valueOfMethod = null;\r\n    TypeMirror unboxedType = env.getTypeUtils().unboxedType(boxedType);\r\n    TypeElement boxedElement = (TypeElement) ((DeclaredType) boxedType).asElement();\r\n    for (ExecutableElement method : ElementFilter.methodsIn(env.getElementUtils().getAllMembers(boxedElement))) {\r\n        Name methodName = method.getSimpleName();\r\n        if (methodName.contentEquals(\"valueOf\")) {\r\n            List<? extends VariableElement> params = method.getParameters();\r\n            if (params.size() == 1 && env.getTypeUtils().isSameType(params.get(0).asType(), unboxedType)) {\r\n                valueOfMethod = (Symbol.MethodSymbol) method;\r\n            }\r\n        }\r\n    }\r\n    assert valueOfMethod != null : \"no valueOf method declared for boxed type\";\r\n    return valueOfMethod;\r\n}"
}, {
	"Path": "java.nio.Buffer.hasRemaining",
	"Comment": "tells whether there are any elements between the current position andthe limit.",
	"Method": "boolean hasRemaining(){\r\n    return position < limit;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.solver.InferenceResult.mergeSubordinate",
	"Comment": "merges values in subordinate into this result, keeping the results form any type argumentsthat were already contained by this inferenceresult.",
	"Method": "void mergeSubordinate(InferenceResult subordinate){\r\n    final LinkedHashSet<TypeVariable> previousKeySet = new LinkedHashSet(this.keySet());\r\n    final LinkedHashSet<TypeVariable> remainingSubKeys = new LinkedHashSet(subordinate.keySet());\r\n    remainingSubKeys.removeAll(keySet());\r\n    for (TypeVariable target : previousKeySet) {\r\n        mergeTarget(target, subordinate);\r\n    }\r\n    for (TypeVariable target : remainingSubKeys) {\r\n        this.put(target, subordinate.get(target));\r\n    }\r\n    resolveChainedTargets();\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.GenericAnnotatedTypeFactory.addUncheckedStandardDefaults",
	"Comment": "adds standard unchecked defaults that do not conflict with previously added defaults.",
	"Method": "void addUncheckedStandardDefaults(QualifierDefaults defs){\r\n    defs.addUncheckedStandardDefaults();\r\n}"
}, {
	"Path": "java.nio.file.FileSystemException.getReason",
	"Comment": "returns the string explaining why the file system operation failed.",
	"Method": "String getReason(){\r\n    return super.getMessage();\r\n}"
}, {
	"Path": "java.util.StringTokenizer.hasMoreElements",
	"Comment": "returns the same value as the hasmoretokensmethod. it exists so that this class can implement theenumeration interface.",
	"Method": "boolean hasMoreElements(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeReplacer.replace",
	"Comment": "return a copy of type after making the specified replacements.",
	"Method": "AnnotatedTypeMirror replace(AnnotatedTypeMirror type,Map<? extends AnnotatedTypeMirror, ? extends AnnotatedTypeMirror> replacementMap){\r\n    return new Visitor(replacementMap).visit(type);\r\n}"
}, {
	"Path": "sun.nio.ch.Util.offerFirstTemporaryDirectBuffer",
	"Comment": "releases a temporary buffer by returning to the cache or freeing it. ifreturning to the cache then insert it at the start so that it islikely to be returned by a subsequent call to gettemporarydirectbuffer.",
	"Method": "void offerFirstTemporaryDirectBuffer(ByteBuffer buf){\r\n    assert buf != null;\r\n    BufferCache cache = bufferCache.get();\r\n    if (!cache.offerFirst(buf)) {\r\n        free(buf);\r\n    }\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.getCalendarDate",
	"Comment": "returns a calendardate produced from the specified fixed date.",
	"Method": "BaseCalendar.Date getCalendarDate(long fd){\r\n    BaseCalendar cal = (fd >= gregorianCutoverDate) ? gcal : getJulianCalendarSystem();\r\n    BaseCalendar.Date d = (BaseCalendar.Date) cal.newCalendarDate(TimeZone.NO_TIMEZONE);\r\n    cal.getCalendarDateFromFixedDate(d, fd);\r\n    return d;\r\n}"
}, {
	"Path": "org.checkerframework.framework.flow.CFAbstractValue.canBeMissingAnnotations",
	"Comment": "returns whether or not the set of annotations can be missing an annotation for any hierarchy.",
	"Method": "boolean canBeMissingAnnotations(boolean canBeMissingAnnotations,TypeMirror typeMirror){\r\n    if (typeMirror == null) {\r\n        return false;\r\n    }\r\n    if (typeMirror.getKind() == TypeKind.VOID || typeMirror.getKind() == TypeKind.NONE || typeMirror.getKind() == TypeKind.PACKAGE) {\r\n        return true;\r\n    }\r\n    if (typeMirror.getKind() == TypeKind.WILDCARD) {\r\n        return canBeMissingAnnotations(((WildcardType) typeMirror).getExtendsBound());\r\n    }\r\n    return typeMirror.getKind() == TypeKind.TYPEVAR;\r\n}"
}, {
	"Path": "java.util.EnumMap.isValidKey",
	"Comment": "returns true if key is of the proper type to be a key in thisenum map.",
	"Method": "boolean isValidKey(Object key){\r\n    if (key == null)\r\n        return false;\r\n    Class keyClass = key.getClass();\r\n    return keyClass == keyType || keyClass.getSuperclass() == keyType;\r\n}"
}, {
	"Path": "java.net.URLClassLoader.defineClass",
	"Comment": "defines a class using the class bytes obtained from the specifiedresource. the resulting class must be resolved before it can beused.",
	"Method": "Class<?> defineClass(String name,Resource res){\r\n    long t0 = System.nanoTime();\r\n    int i = name.lastIndexOf('.');\r\n    URL url = res.getCodeSourceURL();\r\n    if (i != -1) {\r\n        String pkgname = name.substring(0, i);\r\n        Manifest man = res.getManifest();\r\n        if (getAndVerifyPackage(pkgname, man, url) == null) {\r\n            try {\r\n                if (man != null) {\r\n                    definePackage(pkgname, man, url);\r\n                } else {\r\n                    definePackage(pkgname, null, null, null, null, null, null, null);\r\n                }\r\n            } catch (IllegalArgumentException iae) {\r\n                if (getAndVerifyPackage(pkgname, man, url) == null) {\r\n                    throw new AssertionError(\"Cannot find package \" + pkgname);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    java.nio.ByteBuffer bb = res.getByteBuffer();\r\n    if (bb != null) {\r\n        CodeSigner[] signers = res.getCodeSigners();\r\n        CodeSource cs = new CodeSource(url, signers);\r\n        sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0);\r\n        return defineClass(name, bb, cs);\r\n    } else {\r\n        byte[] b = res.getBytes();\r\n        CodeSigner[] signers = res.getCodeSigners();\r\n        CodeSource cs = new CodeSource(url, signers);\r\n        sun.misc.PerfCounter.getReadClassBytesTime().addElapsedTimeFrom(t0);\r\n        return defineClass(name, b, 0, b.length, cs);\r\n    }\r\n}"
}, {
	"Path": "java.util.jar.JarFile.getInputStream",
	"Comment": "returns an input stream for reading the contents of the specifiedzip file entry.",
	"Method": "InputStream getInputStream(ZipEntry ze){\r\n    maybeInstantiateVerifier();\r\n    if (jv == null) {\r\n        return super.getInputStream(ze);\r\n    }\r\n    if (!jvInitialized) {\r\n        initializeVerifier();\r\n        jvInitialized = true;\r\n        if (jv == null)\r\n            return super.getInputStream(ze);\r\n    }\r\n    return new JarVerifier.VerifierStream(getManifestFromReference(), ze instanceof JarFileEntry ? (JarEntry) ze : getJarEntry(ze.getName()), super.getInputStream(ze), jv);\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.UseCase2DTOService.toEntity",
	"Comment": "converts the passed dto to a usecase2.convenient for query by example.",
	"Method": "UseCase2 toEntity(UseCase2DTO dto,UseCase2 toEntity,UseCase2DTO dto,int depth){\r\n    if (dto == null) {\r\n        return null;\r\n    }\r\n    UseCase2 useCase2 = new UseCase2();\r\n    useCase2.setId(dto.id);\r\n    useCase2.setDummy(dto.dummy);\r\n    if (depth-- > 0) {\r\n    }\r\n    return useCase2;\r\n}"
}, {
	"Path": "java.util.HashSet.iterator",
	"Comment": "returns an iterator over the elements in this set.the elementsare returned in no particular order.",
	"Method": "Iterator<E> iterator(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.CheckerMain.matchesFullyQualifiedProcessor",
	"Comment": "given a shorthand processor name, returns true if it can be expanded to a checker in thefullyqualifiedcheckernames list. does not match the subtyping checker.",
	"Method": "boolean matchesFullyQualifiedProcessor(String processor,List<String> fullyQualifiedCheckerNames,boolean allowSubcheckers){\r\n    return !processor.equals(unshorthandProcessorName(processor, fullyQualifiedCheckerNames, allowSubcheckers));\r\n}"
}, {
	"Path": "java.util.regex.Pattern.toString",
	"Comment": "returns the string representation of this pattern. thisis the regular expression from which this pattern wascompiled.",
	"Method": "String toString(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.source.SourceChecker.setProcessingEnvironment",
	"Comment": "this method is protected only to allow the aggregatechecker and basetypechecker to call it.",
	"Method": "void setProcessingEnvironment(ProcessingEnvironment env){\r\n    this.processingEnv = env;\r\n}"
}, {
	"Path": "java.util.Date.setMinutes",
	"Comment": "sets the minutes of this date object to the specified value.this date object is modified so that it represents a pointin time within the specified minute of the hour, with the year, month,date, hour, and second the same as before, as interpreted in thelocal time zone.",
	"Method": "void setMinutes(int minutes){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.zip.GZIPInputStream.close",
	"Comment": "closes this input stream and releases any system resources associatedwith the stream.",
	"Method": "void close(){\r\n    if (!closed) {\r\n        super.close();\r\n        eos = true;\r\n        closed = true;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueTransfer.calculateRangeBinaryOp",
	"Comment": "calculate the result range after a binary operation between two numerical type nodes.",
	"Method": "Range calculateRangeBinaryOp(Node leftNode,Node rightNode,NumericalBinaryOps op,TransferInput<CFValue, CFStore> p){\r\n    if (TypesUtils.isIntegral(leftNode.getType()) && TypesUtils.isIntegral(rightNode.getType())) {\r\n        Range leftRange = getIntRange(leftNode, p);\r\n        Range rightRange = getIntRange(rightNode, p);\r\n        Range resultRange;\r\n        switch(op) {\r\n            case ADDITION:\r\n                resultRange = leftRange.plus(rightRange);\r\n                break;\r\n            case SUBTRACTION:\r\n                resultRange = leftRange.minus(rightRange);\r\n                break;\r\n            case MULTIPLICATION:\r\n                resultRange = leftRange.times(rightRange);\r\n                break;\r\n            case DIVISION:\r\n                resultRange = leftRange.divide(rightRange);\r\n                break;\r\n            case REMAINDER:\r\n                resultRange = leftRange.remainder(rightRange);\r\n                break;\r\n            case SHIFT_LEFT:\r\n                resultRange = leftRange.shiftLeft(rightRange);\r\n                break;\r\n            case SIGNED_SHIFT_RIGHT:\r\n                resultRange = leftRange.signedShiftRight(rightRange);\r\n                break;\r\n            case UNSIGNED_SHIFT_RIGHT:\r\n                resultRange = leftRange.unsignedShiftRight(rightRange);\r\n                break;\r\n            case BITWISE_AND:\r\n                resultRange = leftRange.bitwiseAnd(rightRange);\r\n                break;\r\n            case BITWISE_OR:\r\n                resultRange = leftRange.bitwiseOr(rightRange);\r\n                break;\r\n            case BITWISE_XOR:\r\n                resultRange = leftRange.bitwiseXor(rightRange);\r\n                break;\r\n            default:\r\n                throw new BugInCF(\"ValueTransfer: unsupported operation: \" + op);\r\n        }\r\n        return leftNode.getType().getKind() == TypeKind.LONG || rightNode.getType().getKind() == TypeKind.LONG ? resultRange : resultRange.intRange();\r\n    } else {\r\n        return Range.EVERYTHING;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.OffsetEquation.removeSequenceLengths",
	"Comment": "makes a copy of this offset and removes any added terms that are accesses to the length ofthe listed sequences. if any terms were removed, then the copy is returned. otherwise, nullis returned.",
	"Method": "OffsetEquation removeSequenceLengths(List<String> sequences){\r\n    OffsetEquation copy = new OffsetEquation(this);\r\n    boolean simplified = false;\r\n    for (String sequence : sequences) {\r\n        String arrayLen = sequence + \".length\";\r\n        if (addedTerms.contains(arrayLen)) {\r\n            copy.addedTerms.remove(arrayLen);\r\n            simplified = true;\r\n        }\r\n        String stringLen = sequence + \".length()\";\r\n        if (addedTerms.contains(stringLen)) {\r\n            copy.addedTerms.remove(stringLen);\r\n            simplified = true;\r\n        }\r\n    }\r\n    return simplified ? copy : null;\r\n}"
}, {
	"Path": "org.checkerframework.common.value.util.Range.bitwiseComplement",
	"Comment": "returns the range of a variable that falls within this range after applying the bitwisecomplement operation.",
	"Method": "Range bitwiseComplement(){\r\n    if (this.isNothing()) {\r\n        return NOTHING;\r\n    }\r\n    return new Range(~to, ~from);\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.StubParser.getImportableMembers",
	"Comment": "get all members of a type that are importable in a stub file. currently these are values ofenums, or compile time constants.",
	"Method": "List<String> getImportableMembers(TypeElement typeElement){\r\n    List<String> result = new ArrayList();\r\n    List<VariableElement> memberElements = ElementFilter.fieldsIn(typeElement.getEnclosedElements());\r\n    for (VariableElement varElement : memberElements) {\r\n        if (varElement.getConstantValue() != null || varElement.getKind() == ElementKind.ENUM_CONSTANT) {\r\n            result.add(String.format(\"%s.%s\", typeElement.getQualifiedName().toString(), varElement.getSimpleName().toString()));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "java.util.zip.Inflater.getBytesWritten",
	"Comment": "returns the total number of uncompressed bytes output so far.",
	"Method": "long getBytesWritten(long getBytesWritten,long addr){\r\n    synchronized (zsRef) {\r\n        ensureOpen();\r\n        return getBytesWritten(zsRef.address());\r\n    }\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.packageEquals",
	"Comment": "returns true if classes are defined in the same runtime package, falseotherwise.",
	"Method": "boolean packageEquals(Class<?> cl1,Class<?> cl2){\r\n    return (cl1.getClassLoader() == cl2.getClassLoader() && getPackageName(cl1).equals(getPackageName(cl2)));\r\n}"
}, {
	"Path": "java.io.PrintWriter.format",
	"Comment": "writes a formatted string to this writer using the specified formatstring and arguments.if automatic flushing is enabled, calls to thismethod will flush the output buffer.",
	"Method": "PrintWriter format(String format,Object args,PrintWriter format,Locale l,String format,Object args){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.RegularEnumSet.retainAll",
	"Comment": "retains only the elements in this set that are contained in thespecified collection.",
	"Method": "boolean retainAll(Collection<?> c){\r\n    if (!(c instanceof RegularEnumSet))\r\n        return super.retainAll(c);\r\n    RegularEnumSet<?> es = (RegularEnumSet<?>) c;\r\n    if (es.elementType != elementType) {\r\n        boolean changed = (elements != 0);\r\n        elements = 0;\r\n        return changed;\r\n    }\r\n    long oldElements = elements;\r\n    elements &= es.elements;\r\n    return elements != oldElements;\r\n}"
}, {
	"Path": "testlib.nontopdefault.NTDVisitor.isValidUse",
	"Comment": "allows references to be declared using any ndt type except ntdbottom.",
	"Method": "boolean isValidUse(AnnotatedDeclaredType declarationType,AnnotatedDeclaredType useType,Tree tree){\r\n    if (declarationType.getEffectiveAnnotation(NTDMiddle.class) != null && useType.getEffectiveAnnotation(NTDBottom.class) == null) {\r\n        return true;\r\n    } else {\r\n        return super.isValidUse(declarationType, useType, tree);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.DefaultTypeHierarchy.visitIntersectionSupertype",
	"Comment": "an intersection is a supertype if all of its bounds are a supertype of subtype.",
	"Method": "boolean visitIntersectionSupertype(AnnotatedTypeMirror subtype,AnnotatedIntersectionType supertype){\r\n    if (visitHistory.contains(subtype, supertype, currentTop)) {\r\n        return true;\r\n    }\r\n    Boolean result = isSubtypeOfAll(subtype, supertype.directSuperTypes());\r\n    visitHistory.add(subtype, supertype, currentTop, result);\r\n    return result;\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.isExternalizable",
	"Comment": "returns true if represented class implements externalizable, falseotherwise.",
	"Method": "boolean isExternalizable(){\r\n    return externalizable;\r\n}"
}, {
	"Path": "java.io.PipedReader.close",
	"Comment": "closes this piped stream and releases any system resourcesassociated with the stream.",
	"Method": "void close(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.checker.signedness.SignednessUtil.toFloat",
	"Comment": "returns a float representing the same value as the unsigned long.",
	"Method": "float toFloat(byte b,float toFloat,short s,float toFloat,int i,float toFloat,long l){\r\n    return toUnsignedBigInteger(l).floatValue();\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.AnnotatedTypes.findEffectiveAnnotations",
	"Comment": "when comparing types against the bounds of a type variable, we may encounter other typevariables, wildcards, and intersections in those bounds. this method traverses the boundsuntil it finds a concrete type from which it can pull an annotation. this occurs for everyhierarchy in qualifierhierarchy",
	"Method": "Set<AnnotationMirror> findEffectiveAnnotations(QualifierHierarchy qualifierHierarchy,AnnotatedTypeMirror toSearch){\r\n    AnnotatedTypeMirror source = toSearch;\r\n    TypeKind kind = source.getKind();\r\n    while (kind == TypeKind.TYPEVAR || kind == TypeKind.WILDCARD || kind == TypeKind.INTERSECTION) {\r\n        switch(source.getKind()) {\r\n            case TYPEVAR:\r\n                source = ((AnnotatedTypeVariable) source).getUpperBound();\r\n                break;\r\n            case WILDCARD:\r\n                source = ((AnnotatedWildcardType) source).getExtendsBound();\r\n                break;\r\n            case INTERSECTION:\r\n                final Set<AnnotationMirror> glb = glbOfBounds((AnnotatedIntersectionType) source, qualifierHierarchy);\r\n                return glb;\r\n            default:\r\n                throw new BugInCF(\"Unexpected AnnotatedTypeMirror with no primary annotation;\" + \" toSearch=\" + toSearch + \" source=\" + source);\r\n        }\r\n        kind = source.getKind();\r\n    }\r\n    return source.getAnnotations();\r\n}"
}, {
	"Path": "java.util.HashMap.addEntry",
	"Comment": "adds a new entry with the specified key, value and hash code tothe specified bucket.it is the responsibility of thismethod to resize the table if appropriate.subclass overrides this to alter the behavior of put method.",
	"Method": "void addEntry(int hash,K key,V value,int bucketIndex){\r\n    Entry<K, V> e = table[bucketIndex];\r\n    table[bucketIndex] = new Entry(hash, key, value, e);\r\n    if (size++ >= threshold)\r\n        resize(2 * table.length);\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.getUnboxedType",
	"Comment": "returns the annotated primitive type of the given declared type if it is a boxed declaredtype. otherwise, it throws illegalargumentexception exception.the returned type would have the annotations on the given type and nothing else.",
	"Method": "AnnotatedPrimitiveType getUnboxedType(AnnotatedDeclaredType type){\r\n    PrimitiveType primitiveType = types.unboxedType(type.getUnderlyingType());\r\n    AnnotatedPrimitiveType pt = (AnnotatedPrimitiveType) AnnotatedTypeMirror.createType(primitiveType, this, false);\r\n    pt.addAnnotations(type.getAnnotations());\r\n    return pt;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.AnnotatedTypes.expandVarArgs",
	"Comment": "returns the method parameters for the invoked method, with the same number of argumentspassed in the methodinvocation tree.if the invoked method is not a vararg method or it is a vararg method but the invocationpasses an array to the vararg parameter, it would simply return the method parameters.otherwise, it would return the list of parameters as if the vararg is expanded to matchthe size of the passed arguments.",
	"Method": "List<AnnotatedTypeMirror> expandVarArgs(AnnotatedTypeFactory atypeFactory,AnnotatedExecutableType method,List<? extends ExpressionTree> args){\r\n    List<AnnotatedTypeMirror> parameters = method.getParameterTypes();\r\n    if (!method.getElement().isVarArgs()) {\r\n        return parameters;\r\n    }\r\n    AnnotatedArrayType varargs = (AnnotatedArrayType) parameters.get(parameters.size() - 1);\r\n    if (parameters.size() == args.size()) {\r\n        AnnotatedTypeMirror lastArg = atypeFactory.getAnnotatedType(args.get(args.size() - 1));\r\n        if (lastArg.getKind() == TypeKind.ARRAY && getArrayDepth(varargs) == getArrayDepth((AnnotatedArrayType) lastArg)) {\r\n            return parameters;\r\n        }\r\n    }\r\n    parameters = new ArrayList(parameters.subList(0, parameters.size() - 1));\r\n    for (int i = args.size() - parameters.size(); i > 0; --i) {\r\n        parameters.add(varargs.getComponentType().deepCopy());\r\n    }\r\n    return parameters;\r\n}"
}, {
	"Path": "java.util.zip.ZipOutputStream.putNextEntry",
	"Comment": "begins writing a new zip file entry and positions the stream to thestart of the entry data. closes the current entry if still active.the default compression method will be used if no compression methodwas specified for the entry, and the current time will be used ifthe entry has no set modification time.",
	"Method": "void putNextEntry(ZipEntry e){\r\n    ensureOpen();\r\n    if (current != null) {\r\n        closeEntry();\r\n    }\r\n    if (e.time == -1) {\r\n        e.setTime(System.currentTimeMillis());\r\n    }\r\n    if (e.method == -1) {\r\n        e.method = method;\r\n    }\r\n    e.flag = 0;\r\n    switch(e.method) {\r\n        case DEFLATED:\r\n            if (e.size == -1 || e.csize == -1 || e.crc == -1)\r\n                e.flag = 8;\r\n            break;\r\n        case STORED:\r\n            if (e.size == -1) {\r\n                e.size = e.csize;\r\n            } else if (e.csize == -1) {\r\n                e.csize = e.size;\r\n            } else if (e.size != e.csize) {\r\n                throw new ZipException(\"STORED entry where compressed != uncompressed size\");\r\n            }\r\n            if (e.size == -1 || e.crc == -1) {\r\n                throw new ZipException(\"STORED entry missing size, compressed size, or crc-32\");\r\n            }\r\n            break;\r\n        default:\r\n            throw new ZipException(\"unsupported compression method\");\r\n    }\r\n    if (!names.add(e.name)) {\r\n        throw new ZipException(\"duplicate entry: \" + e.name);\r\n    }\r\n    if (zc.isUTF8())\r\n        e.flag |= EFS;\r\n    current = new XEntry(e, written);\r\n    xentries.add(current);\r\n    writeLOC(current);\r\n}"
}, {
	"Path": "java.lang.StringBuilder.readObject",
	"Comment": "readobject is called to restore the state of the stringbuffer froma stream.",
	"Method": "void readObject(java.io.ObjectInputStream s){\r\n    s.defaultReadObject();\r\n    count = s.readInt();\r\n    value = (char[]) s.readObject();\r\n}"
}, {
	"Path": "java.beans.PropertyDescriptor.setWriteMethod",
	"Comment": "sets the method that should be used to write the property value.",
	"Method": "void setWriteMethod(Method writeMethod){\r\n    this.writeMethodRef.set(writeMethod);\r\n    if (writeMethod == null) {\r\n        writeMethodName = null;\r\n        return;\r\n    }\r\n    setPropertyType(findPropertyType(getReadMethod(), writeMethod));\r\n    setClass0(writeMethod.getDeclaringClass());\r\n    writeMethodName = writeMethod.getName();\r\n    setTransient(writeMethod.getAnnotation(Transient.class));\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.BookDTOService.save",
	"Comment": "save the passed dto as a new entity or update the corresponding entity if any.",
	"Method": "BookDTO save(BookDTO dto){\r\n    if (dto == null) {\r\n        return null;\r\n    }\r\n    final Book book;\r\n    if (dto.isIdSet()) {\r\n        Book bookTmp = bookRepository.findOne(dto.id);\r\n        if (bookTmp != null) {\r\n            book = bookTmp;\r\n        } else {\r\n            book = new Book();\r\n            book.setId(dto.id);\r\n        }\r\n    } else {\r\n        book = new Book();\r\n    }\r\n    book.setTitle(dto.title);\r\n    book.setSummary(dto.summary);\r\n    book.setPublicationDate(dto.publicationDate);\r\n    book.setBestSeller(dto.bestSeller);\r\n    book.setPrice(dto.price);\r\n    if (dto.author == null) {\r\n        book.setAuthor(null);\r\n    } else {\r\n        Author author = book.getAuthor();\r\n        if (author == null || (author.getId().compareTo(dto.author.id) != 0)) {\r\n            book.setAuthor(authorRepository.findOne(dto.author.id));\r\n        }\r\n    }\r\n    if (dto.coAuthor == null) {\r\n        book.setCoAuthor(null);\r\n    } else {\r\n        Author coAuthor = book.getCoAuthor();\r\n        if (coAuthor == null || (coAuthor.getId().compareTo(dto.coAuthor.id) != 0)) {\r\n            book.setCoAuthor(authorRepository.findOne(dto.coAuthor.id));\r\n        }\r\n    }\r\n    return toDTO(bookRepository.save(book));\r\n}"
}, {
	"Path": "java.util.IllformedLocaleException.getErrorIndex",
	"Comment": "returns the index where the error was found. a negative value indicateseither the error index is not applicable or unknown.",
	"Method": "int getErrorIndex(){\r\n    return _errIdx;\r\n}"
}, {
	"Path": "org.camunda.bpm.qa.rolling.update.scenarios.externalTask.ProcessWithExternalTaskScenario.deploy",
	"Comment": "deploy a process model, which contains an external task. the topic isgiven via parameter so the test cases are independent.",
	"Method": "void deploy(ProcessEngine engine,String topicName){\r\n    BpmnModelInstance instance = Bpmn.createExecutableProcess(PROCESS_DEF_KEY).startEvent().serviceTask(EXTERNAL_TASK).camundaType(EXTERNAL_TASK_TYPE).camundaTopic(topicName).endEvent().done();\r\n    engine.getRepositoryService().createDeployment().addModelInstance(ProcessWithExternalTaskScenario.class.getSimpleName() + \".startProcessWithFetch.bpmn20.xml\", instance).deploy();\r\n}"
}, {
	"Path": "java.util.Date.getCalendarSystem",
	"Comment": "returns the gregorian or julian calendar system to use with thegiven date. use gregorian from october 15, 1582.",
	"Method": "BaseCalendar getCalendarSystem(int year,BaseCalendar getCalendarSystem,long utc,BaseCalendar getCalendarSystem,BaseCalendar.Date cdate){\r\n    if (jcal == null) {\r\n        return gcal;\r\n    }\r\n    if (cdate.getEra() != null) {\r\n        return jcal;\r\n    }\r\n    return gcal;\r\n}"
}, {
	"Path": "org.checkerframework.dataflow.cfg.playground.ConstantPropagationPlayground.main",
	"Comment": "run constant propagation for a specific file and create a pdf of the cfg in the end.",
	"Method": "void main(String[] args){\r\n    String inputFile = \"cfg-input.java\";\r\n    String outputDir = \"cfg\";\r\n    String method = \"test\";\r\n    String clazz = \"Test\";\r\n    ConstantPropagationTransfer transfer = new ConstantPropagationTransfer();\r\n    Analysis<Constant, ConstantPropagationStore, ConstantPropagationTransfer> analysis = new Analysis(transfer, null);\r\n    JavaSource2CFGDOT.generateDOTofCFG(inputFile, outputDir, method, clazz, true, analysis);\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.AtmLubVisitor.castLub",
	"Comment": "casts lub to the type of type and issues an error if type and lub are not the same kind.",
	"Method": "T castLub(T type,AnnotatedTypeMirror lub){\r\n    if (type.getKind() != lub.getKind()) {\r\n        throw new BugInCF(\"AtmLubVisitor: unexpected type. Found: %s Required %s\", lub.getKind(), type.getKind());\r\n    }\r\n    @SuppressWarnings(\"unchecked\")\r\n    T castedLub = (T) lub;\r\n    return castedLub;\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.unpackRules",
	"Comment": "given an array of bytes produced by packrules, interpret themas the start and end rules.",
	"Method": "void unpackRules(byte[] rules){\r\n    startDay = rules[0];\r\n    startDayOfWeek = rules[1];\r\n    endDay = rules[2];\r\n    endDayOfWeek = rules[3];\r\n    if (rules.length >= 6) {\r\n        startTimeMode = rules[4];\r\n        endTimeMode = rules[5];\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.element.TypeParamElementAnnotationApplier.applyUpperBounds",
	"Comment": "applies a list of annotations to the upperbound of the type parameter. if the type of theupper bound is an intersection we must first find the correct location for each annotation.",
	"Method": "void applyUpperBounds(List<TypeCompound> upperBounds){\r\n    if (!upperBounds.isEmpty()) {\r\n        final AnnotatedTypeMirror upperBoundType = typeParam.getUpperBound();\r\n        if (upperBoundType.getKind() == TypeKind.INTERSECTION) {\r\n            final List<? extends AnnotatedTypeMirror> intersectionTypes = upperBoundType.directSuperTypes();\r\n            final int boundIndexOffset = ElementAnnotationUtil.getBoundIndexOffset(intersectionTypes);\r\n            for (final TypeCompound anno : upperBounds) {\r\n                final int boundIndex = anno.position.bound_index + boundIndexOffset;\r\n                if (boundIndex < 0 || boundIndex > intersectionTypes.size()) {\r\n                    throw new BugInCF(\"Invalid bound index on element annotation ( \" + anno + \" ) \" + \"for type ( \" + typeParam + \" ) with \" + \"upper bound ( \" + typeParam.getUpperBound() + \" ) \" + \"and boundIndex( \" + boundIndex + \" ) \");\r\n                }\r\n                intersectionTypes.get(boundIndex).replaceAnnotation(anno);\r\n            }\r\n        } else {\r\n            upperBoundType.addAnnotations(upperBounds);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.hasReadResolveMethod",
	"Comment": "returns true if represented class is serializable or externalizable anddefines a conformant readresolve method.otherwise, returns false.",
	"Method": "boolean hasReadResolveMethod(){\r\n    return (readResolveMethod != null);\r\n}"
}, {
	"Path": "java.awt.image.ColorModel.getTransparency",
	"Comment": "returns the transparency.returns either opaque, bitmask,or translucent.",
	"Method": "int getTransparency(){\r\n    return transparency;\r\n}"
}, {
	"Path": "java.util.Locale.composeList",
	"Comment": "given a list of strings, return a list shortened to three elements.shorten it by applying the given format to the first two elementsrecursively.",
	"Method": "String[] composeList(MessageFormat format,String[] list){\r\n    if (list.length <= 3)\r\n        return list;\r\n    String[] listItems = { list[0], list[1] };\r\n    String newItem = format.format(listItems);\r\n    String[] newList = new String[list.length - 1];\r\n    System.arraycopy(list, 2, newList, 1, newList.length - 1);\r\n    newList[0] = newItem;\r\n    return composeList(format, newList);\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.element.MethodApplier.handleTargeted",
	"Comment": "note that these are the only locations not handled elsewhere, otherwise we call apply",
	"Method": "void handleTargeted(List<Attribute.TypeCompound> targeted){\r\n    final List<TypeCompound> unmatched = new ArrayList();\r\n    final Map<TargetType, List<TypeCompound>> targetTypeToAnno = ElementAnnotationUtil.partitionByTargetType(targeted, unmatched, TargetType.METHOD_RECEIVER, TargetType.METHOD_RETURN, TargetType.THROWS);\r\n    ElementAnnotationUtil.annotateViaTypeAnnoPosition(methodType.getReceiverType(), targetTypeToAnno.get(TargetType.METHOD_RECEIVER));\r\n    ElementAnnotationUtil.annotateViaTypeAnnoPosition(methodType.getReturnType(), targetTypeToAnno.get(TargetType.METHOD_RETURN));\r\n    applyThrowsAnnotations(targetTypeToAnno.get(TargetType.THROWS));\r\n    if (unmatched.size() > 0) {\r\n        throw new BugInCF(\"Unexpected annotations ( \" + PluginUtil.join(\",\", unmatched) + \" ) for\" + \"type ( \" + type + \" ) and element ( \" + element + \" ) \");\r\n    }\r\n}"
}, {
	"Path": "java.util.PropertyPermission.equals",
	"Comment": "checks two propertypermission objects for equality. checks that obj isa propertypermission, and has the same name and actions as this object.",
	"Method": "boolean equals(Object obj){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "polyall.GetClassStubTest.context",
	"Comment": "see annotatedtypefactory.adaptgetclassreturntypetoreceiver",
	"Method": "void context(){\r\n    Integer i = 4;\r\n    Class<?> a = i.getClass();\r\n    Class<@H1Bot ? extends @H1S1 Object> succeed1 = i.getClass();\r\n    Class<@H1Bot ? extends @H1S1 Integer> succeed2 = i.getClass();\r\n    Class<@H1Bot ? extends @H1Bot Object> fail1 = i.getClass();\r\n    Class<@H1Bot ?> fail2 = i.getClass();\r\n}"
}, {
	"Path": "java.lang.Character.isValidCodePoint",
	"Comment": "determines whether the specified code point is a validunicode code point value.",
	"Method": "boolean isValidCodePoint(int codePoint){\r\n    int plane = codePoint >>> 16;\r\n    return plane < ((MAX_CODE_POINT + 1) >>> 16);\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.typeannotator.PropagationTypeAnnotator.visitWildcard",
	"Comment": "rather than defaulting the missing bounds of a wildcard, find the bound annotations on thetype parameter it replaced. place those annotations on the wildcard.",
	"Method": "Void visitWildcard(AnnotatedWildcardType wildcardAtm,Void aVoid){\r\n    if (visitedNodes.containsKey(wildcardAtm) || pause) {\r\n        return null;\r\n    }\r\n    visitedNodes.put(wildcardAtm, null);\r\n    final WildcardType wildcard = (WildcardType) wildcardAtm.getUnderlyingType();\r\n    Element typeParamElement = TypesUtils.wildcardToTypeParam(wildcard);\r\n    if (typeParamElement == null) {\r\n        typeParamElement = parents.isEmpty() ? null : getTypeParamFromEnclosingClass(wildcardAtm, parents.peekFirst());\r\n    }\r\n    if (typeParamElement != null) {\r\n        pause = true;\r\n        AnnotatedTypeVariable typeParam = (AnnotatedTypeVariable) typeFactory.getAnnotatedType(typeParamElement);\r\n        pause = false;\r\n        final Set<? extends AnnotationMirror> tops = typeFactory.getQualifierHierarchy().getTopAnnotations();\r\n        if (wildcard.isUnbound()) {\r\n            propagateExtendsBound(wildcardAtm, typeParam, tops);\r\n            propagateSuperBound(wildcardAtm, typeParam, tops);\r\n        } else if (wildcard.isExtendsBound()) {\r\n            propagateSuperBound(wildcardAtm, typeParam, tops);\r\n        } else {\r\n            propagateExtendsBound(wildcardAtm, typeParam, tops);\r\n        }\r\n    }\r\n    scan(wildcardAtm.getExtendsBound(), null);\r\n    scan(wildcardAtm.getSuperBound(), null);\r\n    return null;\r\n}"
}, {
	"Path": "java.util.Date.getDate",
	"Comment": "returns the day of the month represented by this date object.the value returned is between 1 and 31representing the day of the month that contains or begins with theinstant in time represented by this date object, asinterpreted in the local time zone.",
	"Method": "int getDate(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.ArrayList.clear",
	"Comment": "removes all of the elements from this list.the list willbe empty after this call returns.",
	"Method": "void clear(){\r\n    modCount++;\r\n    for (int i = 0; i < size; i++) elementData[i] = null;\r\n    size = 0;\r\n}"
}, {
	"Path": "java.util.logging.Logger.severe",
	"Comment": "log a severe message.if the logger is currently enabled for the severe messagelevel then the given message is forwarded to all theregistered output handler objects.",
	"Method": "void severe(String msg){\r\n    if (Level.SEVERE.intValue() < levelValue) {\r\n        return;\r\n    }\r\n    log(Level.SEVERE, msg);\r\n}"
}, {
	"Path": "java.util.logging.LogRecord.getThreadID",
	"Comment": "get an identifier for the thread where the message originated.this is a thread identifier within the java vm and may ormay not map to any operating system id.",
	"Method": "int getThreadID(){\r\n    return threadID;\r\n}"
}, {
	"Path": "org.checkerframework.common.reflection.DefaultReflectionResolver.getMethodSymbolsfor",
	"Comment": "get set of methodsymbols based on class name, method name, and parameter length.",
	"Method": "List<Symbol> getMethodSymbolsfor(String className,String methodName,int paramLength,Env<AttrContext> env){\r\n    Context context = ((JavacProcessingEnvironment) processingEnv).getContext();\r\n    Resolve resolve = Resolve.instance(context);\r\n    Names names = Names.instance(context);\r\n    List<Symbol> result = new ArrayList();\r\n    Symbol sym = getSymbol(className, env, names, resolve);\r\n    if (!sym.exists()) {\r\n        debugReflection(\"Unable to resolve class: \" + className);\r\n        return Collections.emptyList();\r\n    }\r\n    ClassSymbol classSym = (ClassSymbol) sym;\r\n    while (classSym != null) {\r\n        for (Symbol s : classSym.getEnclosedElements()) {\r\n            if (s.getKind() == ElementKind.METHOD) {\r\n                if (names.fromString(methodName).equals(s.name) && ((MethodSymbol) s).getParameters().size() == paramLength) {\r\n                    result.add(s);\r\n                }\r\n            }\r\n        }\r\n        if (!result.isEmpty()) {\r\n            break;\r\n        }\r\n        Type t = classSym.getSuperclass();\r\n        if (!t.hasTag(TypeTag.CLASS) || t.isErroneous()) {\r\n            break;\r\n        }\r\n        classSym = (ClassSymbol) t.tsym;\r\n    }\r\n    if (result.isEmpty()) {\r\n        debugReflection(\"Unable to resolve method: \" + className + \"@\" + methodName);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.solver.SupertypesSolver.leastUpperBound",
	"Comment": "successively calls least upper bound on the elements of types. unlikeannotatedtypes.leastupperbound, this method will box primitives if necessary",
	"Method": "AnnotatedTypeMirror leastUpperBound(TypeVariable target,AnnotatedTypeFactory typeFactory,Map<AnnotatedTypeMirror, AnnotationMirrorSet> types,AnnotationMirror leastUpperBound,Iterable<? extends AnnotationMirror> annos,QualifierHierarchy qualifierHierarchy){\r\n    Iterator<? extends AnnotationMirror> annoIter = annos.iterator();\r\n    AnnotationMirror lub = annoIter.next();\r\n    while (annoIter.hasNext()) {\r\n        lub = qualifierHierarchy.leastUpperBound(lub, annoIter.next());\r\n    }\r\n    return lub;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.EqualityAtmComparer.reduce",
	"Comment": "used to combine the results from component types or a type and its component types.",
	"Method": "Boolean reduce(Boolean r1,Boolean r2){\r\n    if (r1 == null) {\r\n        return r2;\r\n    } else if (r2 == null) {\r\n        return r1;\r\n    } else {\r\n        return r1 && r2;\r\n    }\r\n}"
}, {
	"Path": "java.util.zip.ZipEntry.setComment",
	"Comment": "sets the optional comment string for the entry.zip entry comments have maximum length of 0xffff. if the length of thespecified comment string is greater than 0xffff bytes after encoding, onlythe first 0xffff bytes are output to the zip file entry.",
	"Method": "void setComment(String comment){\r\n    this.comment = comment;\r\n}"
}, {
	"Path": "java.io.ObjectStreamClass.getSerialVersionUID",
	"Comment": "return the serialversionuid for this class.the serialversionuiddefines a set of classes all with the same name that have evolved from acommon root class and agree to be serialized and deserialized using acommon format.nonserializable classes have a serialversionuid of 0l.",
	"Method": "long getSerialVersionUID(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.ServiceLoader.load",
	"Comment": "creates a new service loader for the given service type and classloader.",
	"Method": "ServiceLoader<S> load(Class<S> service,ClassLoader loader,ServiceLoader<S> load,Class<S> service){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.CheckerMain.extractArg",
	"Comment": "remove the argument given by argumentname and the subsequent value from the list args ifpresent. return the subsequent value.",
	"Method": "String extractArg(String argumentName,String alternative,List<String> args){\r\n    int i = args.indexOf(argumentName);\r\n    if (i == -1) {\r\n        return alternative;\r\n    } else if (i == args.size() - 1) {\r\n        throw new BugInCF(\"Command line contains \" + argumentName + \" but no value following it\");\r\n    } else {\r\n        args.remove(i);\r\n        return args.remove(i);\r\n    }\r\n}"
}, {
	"Path": "java.util.ResourceBundle.keySet",
	"Comment": "returns a set of all keys contained in thisresourcebundle and its parent bundles.",
	"Method": "Set<String> keySet(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.Optional.orElseThrow",
	"Comment": "return the contained value, if present, otherwise throw an exceptionto be created by the provided supplier.",
	"Method": "T orElseThrow(Supplier<? extends X> exceptionSupplier){\r\n    if (value != null) {\r\n        return value;\r\n    } else {\r\n        throw exceptionSupplier.get();\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TreeUtils.isMethodInvocation",
	"Comment": "returns true if the given element is an invocation of the method, or of any method thatoverrides that one.",
	"Method": "boolean isMethodInvocation(Tree tree,ExecutableElement method,ProcessingEnvironment env){\r\n    if (!(tree instanceof MethodInvocationTree)) {\r\n        return false;\r\n    }\r\n    MethodInvocationTree methInvok = (MethodInvocationTree) tree;\r\n    ExecutableElement invoked = TreeUtils.elementFromUse(methInvok);\r\n    return ElementUtils.isMethod(invoked, method, env);\r\n}"
}, {
	"Path": "java.util.EnumMap.containsValue",
	"Comment": "returns true if this map maps one or more keys to thespecified value.",
	"Method": "boolean containsValue(Object value){\r\n    value = maskNull(value);\r\n    for (Object val : vals) if (value.equals(val))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.validType",
	"Comment": "used for asserting that a type is valid for converting to an annotated type.",
	"Method": "boolean validType(TypeMirror type){\r\n    if (type == null) {\r\n        return false;\r\n    }\r\n    switch(type.getKind()) {\r\n        case ERROR:\r\n        case OTHER:\r\n        case PACKAGE:\r\n            return false;\r\n        default:\r\n            return true;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.StubGenerator.printTypeMembers",
	"Comment": "helper method that outputs the public or protected inner members of a class.",
	"Method": "void printTypeMembers(List<? extends Element> members,List<TypeElement> innerClass){\r\n    for (Element element : members) {\r\n        if (isPublicOrProtected(element)) {\r\n            printMember(element, innerClass);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.jar.Attributes.write",
	"Comment": "writes the current attributes to the specified data output stream.xxx need to handle utf8 values and break up lines longer than 72 bytes",
	"Method": "void write(DataOutputStream os){\r\n    Iterator<Map.Entry<Object, Object>> it = entrySet().iterator();\r\n    while (it.hasNext()) {\r\n        Map.Entry<Object, Object> e = it.next();\r\n        StringBuffer buffer = new StringBuffer(((Name) e.getKey()).toString());\r\n        buffer.append(\": \");\r\n        String value = (String) e.getValue();\r\n        if (value != null) {\r\n            byte[] vb = value.getBytes(\"UTF8\");\r\n            value = new String(vb, 0, 0, vb.length);\r\n        }\r\n        buffer.append(value);\r\n        buffer.append(\"\\r\\n\");\r\n        Manifest.make72Safe(buffer);\r\n        os.writeBytes(buffer.toString());\r\n    }\r\n    os.writeBytes(\"\\r\\n\");\r\n}"
}, {
	"Path": "java.util.Collections.list",
	"Comment": "returns an array list containing the elements returned by thespecified enumeration in the order they are returned by theenumeration.this method provides interoperability betweenlegacy apis that return enumerations and new apis that requirecollections.",
	"Method": "ArrayList<T> list(Enumeration<T> e){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.source.SourceChecker.shutdownHook",
	"Comment": "method that gets called exactly once at shutdown time of the jvm. checkers can override thismethod to customize the behavior.",
	"Method": "void shutdownHook(){\r\n    if (hasOption(\"resourceStats\")) {\r\n        printStats();\r\n    }\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.PassportDTOService.toDTO",
	"Comment": "converts the passed passport to a dto. the depth is used to control theamount of association you want. it also prevents potential infinite serialization cycles.",
	"Method": "PassportDTO toDTO(Passport passport,PassportDTO toDTO,Passport passport,int depth){\r\n    if (passport == null) {\r\n        return null;\r\n    }\r\n    PassportDTO dto = new PassportDTO();\r\n    dto.id = passport.getId();\r\n    dto.passportNumber = passport.getPassportNumber();\r\n    dto.expirationDate = passport.getExpirationDate();\r\n    if (depth-- > 0) {\r\n        dto.holder = userDTOService.toDTO(passport.getHolder(), depth);\r\n    }\r\n    return dto;\r\n}"
}, {
	"Path": "java.util.EnumMap.typeCheck",
	"Comment": "throws an exception if e is not of the correct type for this enum set.",
	"Method": "void typeCheck(K key){\r\n    Class keyClass = key.getClass();\r\n    if (keyClass != keyType && keyClass.getSuperclass() != keyType)\r\n        throw new ClassCastException(keyClass + \" != \" + keyType);\r\n}"
}, {
	"Path": "java.util.Date.getMinutes",
	"Comment": "returns the number of minutes past the hour represented by this date,as interpreted in the local time zone.the value returned is between 0 and 59.",
	"Method": "int getMinutes(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceValuesToDouble",
	"Comment": "returns the result of accumulating the given transformationof all values using the given reducer to combine values,and the given basis as an identity value.",
	"Method": "double reduceValuesToDouble(long parallelismThreshold,ToDoubleFunction<? super V> transformer,double basis,DoubleBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceValuesToDoubleTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "java.util.Calendar.isFullyNormalized",
	"Comment": "returns whether the calendar fields are fully in sync with the timevalue.",
	"Method": "boolean isFullyNormalized(){\r\n    return areFieldsSet && areAllFieldsSet;\r\n}"
}, {
	"Path": "java.io.File.readObject",
	"Comment": "readobject is called to restore this filename.the original separator character is read.if it is differentthan the separator character on this system, then the old separatoris replaced by the local separator.",
	"Method": "void readObject(java.io.ObjectInputStream s){\r\n    ObjectInputStream.GetField fields = s.readFields();\r\n    String pathField = (String) fields.get(\"path\", null);\r\n    char sep = s.readChar();\r\n    if (sep != separatorChar)\r\n        pathField = pathField.replace(sep, separatorChar);\r\n    this.path = fs.normalize(pathField);\r\n    this.prefixLength = fs.prefixLength(this.path);\r\n}"
}, {
	"Path": "java.util.regex.Pattern.hasBaseCharacter",
	"Comment": "non spacing marks only count as word characters in bounds calculationsif they have a base character.",
	"Method": "boolean hasBaseCharacter(Matcher matcher,int i,CharSequence seq){\r\n    int start = (!matcher.transparentBounds) ? matcher.from : 0;\r\n    for (int x = i; x >= start; x--) {\r\n        int ch = Character.codePointAt(seq, x);\r\n        if (Character.isLetterOrDigit(ch))\r\n            return true;\r\n        if (Character.getType(ch) == Character.NON_SPACING_MARK)\r\n            continue;\r\n        return false;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.concurrent.ConcurrentHashMap.reduceKeysToDouble",
	"Comment": "returns the result of accumulating the given transformationof all keys using the given reducer to combine values, andthe given basis as an identity value.",
	"Method": "double reduceKeysToDouble(long parallelismThreshold,ToDoubleFunction<? super K> transformer,double basis,DoubleBinaryOperator reducer){\r\n    if (transformer == null || reducer == null)\r\n        throw new NullPointerException();\r\n    return new MapReduceKeysToDoubleTask<K, V>(null, batchFor(parallelismThreshold), 0, 0, table, null, transformer, basis, reducer).invoke();\r\n}"
}, {
	"Path": "java.io.DataInputStream.readLong",
	"Comment": "see the general contract of the readlongmethod of datainput.bytesfor this operation are read from the containedinput stream.",
	"Method": "long readLong(){\r\n    readFully(readBuffer, 0, 8);\r\n    return (((long) readBuffer[0] << 56) + ((long) (readBuffer[1] & 255) << 48) + ((long) (readBuffer[2] & 255) << 40) + ((long) (readBuffer[3] & 255) << 32) + ((long) (readBuffer[4] & 255) << 24) + ((readBuffer[5] & 255) << 16) + ((readBuffer[6] & 255) << 8) + ((readBuffer[7] & 255) << 0));\r\n}"
}, {
	"Path": "java.lang.Shutdown.add",
	"Comment": "add a new shutdown hook.checks the shutdown state and the hook itself,but does not do any security checks.the registershutdowninprogress parameter should be false exceptregistering the deleteonexithook since the first file maybe added to the delete on exit list by the application shutdownhooks.",
	"Method": "void add(int slot,boolean registerShutdownInProgress,Runnable hook){\r\n    synchronized (lock) {\r\n        if (hooks[slot] != null)\r\n            throw new InternalError(\"Shutdown hook at slot \" + slot + \" already registered\");\r\n        if (!registerShutdownInProgress) {\r\n            if (state > RUNNING)\r\n                throw new IllegalStateException(\"Shutdown in progress\");\r\n        } else {\r\n            if (state > HOOKS || (state == HOOKS && slot <= currentRunningHook))\r\n                throw new IllegalStateException(\"Shutdown in progress\");\r\n        }\r\n        hooks[slot] = hook;\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.source.SourceChecker.shouldSuppressWarnings",
	"Comment": "public so it can be called from initializationvisitor.checkerfieldsinitialized",
	"Method": "boolean shouldSuppressWarnings(Tree tree,String errKey,boolean shouldSuppressWarnings,Element elt,String errKey){\r\n    if (UNNEEDED_SUPPRESSION_KEY.equals(errKey)) {\r\n        return false;\r\n    }\r\n    if (elt == null) {\r\n        return false;\r\n    }\r\n    if (checkSuppressWarnings(elt.getAnnotation(SuppressWarnings.class), errKey)) {\r\n        if (hasOption(\"warnUnneededSuppressions\")) {\r\n            elementsWithSuppressedWarnings.add(elt);\r\n        }\r\n        return true;\r\n    }\r\n    if (isAnnotatedForThisCheckerOrUpstreamChecker(elt)) {\r\n        return false;\r\n    }\r\n    return shouldSuppressWarnings(elt.getEnclosingElement(), errKey);\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.samelen.SameLenAnnotatedTypeFactory.getMethodIdentifier",
	"Comment": "gets a helper object that holds references to methods with special handling.",
	"Method": "IndexMethodIdentifier getMethodIdentifier(){\r\n    return imf;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotationClassLoader.containsPackage",
	"Comment": "checks to see if the jar or directory referred by the url contains the qual package of aspecific checker.",
	"Method": "boolean containsPackage(URL url){\r\n    if (url.getProtocol().equals(\"jar\")) {\r\n        try {\r\n            JarURLConnection connection = (JarURLConnection) url.openConnection();\r\n            JarFile jarFile = connection.getJarFile();\r\n            return checkJarForPackage(jarFile);\r\n        } catch (IOException e) {\r\n        }\r\n    } else if (url.getProtocol().equals(\"file\")) {\r\n        File rootDir = new File(url.getFile());\r\n        return checkDirForPackage(rootDir, fullyQualifiedPackageNameSegments.iterator());\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.ToIndexFileConverter.extractAnnotation",
	"Comment": "builds simplified annotation from its declaration. only the name is included, becausestubfiles do not generally have access to the full definitions of annotations.",
	"Method": "Annotation extractAnnotation(AnnotationExpr expr){\r\n    String exprName = expr.toString().substring(1);\r\n    if (exprName.contains(\"+\")) {\r\n        return null;\r\n    }\r\n    AnnotationDef def = new AnnotationDef(exprName);\r\n    def.setFieldTypes(Collections.emptyMap());\r\n    return new Annotation(def, Collections.emptyMap());\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueTransfer.calculateValuesBinaryOp",
	"Comment": "calculate the possible values after a binary operation between two numerical type nodes.",
	"Method": "List<Number> calculateValuesBinaryOp(Node leftNode,Node rightNode,NumericalBinaryOps op,TransferInput<CFValue, CFStore> p){\r\n    List<? extends Number> lefts = getNumericalValues(leftNode, p);\r\n    List<? extends Number> rights = getNumericalValues(rightNode, p);\r\n    if (lefts == null || rights == null) {\r\n        return null;\r\n    }\r\n    List<Number> resultValues = new ArrayList();\r\n    for (Number left : lefts) {\r\n        NumberMath<?> nmLeft = NumberMath.getNumberMath(left);\r\n        for (Number right : rights) {\r\n            switch(op) {\r\n                case ADDITION:\r\n                    resultValues.add(nmLeft.plus(right));\r\n                    break;\r\n                case DIVISION:\r\n                    Number result = nmLeft.divide(right);\r\n                    if (result != null) {\r\n                        resultValues.add(result);\r\n                    }\r\n                    break;\r\n                case MULTIPLICATION:\r\n                    resultValues.add(nmLeft.times(right));\r\n                    break;\r\n                case REMAINDER:\r\n                    Number resultR = nmLeft.remainder(right);\r\n                    if (resultR != null) {\r\n                        resultValues.add(resultR);\r\n                    }\r\n                    break;\r\n                case SUBTRACTION:\r\n                    resultValues.add(nmLeft.minus(right));\r\n                    break;\r\n                case SHIFT_LEFT:\r\n                    resultValues.add(nmLeft.shiftLeft(right));\r\n                    break;\r\n                case SIGNED_SHIFT_RIGHT:\r\n                    resultValues.add(nmLeft.signedShiftRight(right));\r\n                    break;\r\n                case UNSIGNED_SHIFT_RIGHT:\r\n                    resultValues.add(nmLeft.unsignedShiftRight(right));\r\n                    break;\r\n                case BITWISE_AND:\r\n                    resultValues.add(nmLeft.bitwiseAnd(right));\r\n                    break;\r\n                case BITWISE_OR:\r\n                    resultValues.add(nmLeft.bitwiseOr(right));\r\n                    break;\r\n                case BITWISE_XOR:\r\n                    resultValues.add(nmLeft.bitwiseXor(right));\r\n                    break;\r\n                default:\r\n                    throw new BugInCF(\"ValueTransfer: unsupported operation: \" + op);\r\n            }\r\n        }\r\n    }\r\n    return resultValues;\r\n}"
}, {
	"Path": "org.checkerframework.framework.test.TypecheckExecutor.compile",
	"Comment": "using the settings from the input configuration, compile all source files in theconfiguration, and return place the result in a compilationresult",
	"Method": "CompilationResult compile(TestConfiguration configuration){\r\n    TestUtilities.ensureDirectoryExists(new File(configuration.getOptions().get(\"-d\")));\r\n    final StringWriter javacOutput = new StringWriter();\r\n    DiagnosticCollector<JavaFileObject> diagnostics = new DiagnosticCollector();\r\n    JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\r\n    StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);\r\n    Iterable<? extends JavaFileObject> javaFiles = fileManager.getJavaFileObjects(configuration.getTestSourceFiles().toArray(new File[] {}));\r\n    final List<String> options = new ArrayList();\r\n    options.add(\"-processor\");\r\n    options.add(String.join(\",\", configuration.getProcessors()));\r\n    List<String> nonJvmOptions = new ArrayList();\r\n    for (String option : configuration.getFlatOptions()) {\r\n        if (!option.startsWith(\"-J-\")) {\r\n            nonJvmOptions.add(option);\r\n        }\r\n    }\r\n    nonJvmOptions.add(\"-Xmaxerrs\");\r\n    nonJvmOptions.add(\"100000\");\r\n    nonJvmOptions.add(\"-Xmaxwarns\");\r\n    nonJvmOptions.add(\"100000\");\r\n    options.addAll(nonJvmOptions);\r\n    if (configuration.shouldEmitDebugInfo()) {\r\n        System.out.println(\"Running test using the following invocation:\");\r\n        System.out.println(\"javac \" + String.join(\" \", options) + \" \" + PluginUtil.join(\" \", configuration.getTestSourceFiles()));\r\n    }\r\n    JavaCompiler.CompilationTask task = compiler.getTask(javacOutput, fileManager, diagnostics, options, new ArrayList<String>(), javaFiles);\r\n    final Boolean compiledWithoutError = task.call();\r\n    javacOutput.flush();\r\n    return new CompilationResult(compiledWithoutError, javacOutput.toString(), javaFiles, diagnostics.getDiagnostics());\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.solver.SupertypesSolver.mergeLubTypeWithEqualities",
	"Comment": "we previously found a type that is equal to target but not in all hierarchies. use theprimary annotations from the lub type to fill in the missing annotations in this type. usethat type as the inferred argument.if we failed to infer any annotation for a given hierarchy, either previously fromequalities or from the lub, return null.",
	"Method": "InferredType mergeLubTypeWithEqualities(TypeVariable target,AnnotatedTypeMirror lub,ConstraintMap constraintMap,AnnotatedTypeFactory typeFactory){\r\n    final Equalities equalities = constraintMap.getConstraints(target).equalities;\r\n    final AnnotationMirrorSet tops = new AnnotationMirrorSet(typeFactory.getQualifierHierarchy().getTopAnnotations());\r\n    if (!equalities.types.isEmpty()) {\r\n        final Entry<AnnotatedTypeMirror, AnnotationMirrorSet> eqEntry = equalities.types.entrySet().iterator().next();\r\n        final AnnotatedTypeMirror equalityType = eqEntry.getKey();\r\n        final AnnotationMirrorSet equalityAnnos = eqEntry.getValue();\r\n        boolean failed = false;\r\n        for (final AnnotationMirror top : tops) {\r\n            if (!equalityAnnos.contains(top)) {\r\n                final AnnotationMirror lubAnno = lub.getAnnotationInHierarchy(top);\r\n                if (lubAnno == null) {\r\n                    if (lub.getKind() == TypeKind.TYPEVAR && equalityType.getUnderlyingType().equals(lub.getUnderlyingType())) {\r\n                        equalityAnnos.add(top);\r\n                    } else {\r\n                        failed = true;\r\n                    }\r\n                } else {\r\n                    equalityType.replaceAnnotation(lubAnno);\r\n                    equalityAnnos.add(top);\r\n                }\r\n            }\r\n        }\r\n        if (!failed) {\r\n            return new InferredType(equalityType);\r\n        }\r\n    }\r\n    return new InferredType(lub);\r\n}"
}, {
	"Path": "org.checkerframework.checker.signedness.SignednessUtil.longFromFloat",
	"Comment": "returns an unsigned long representing the same value as the float.",
	"Method": "long longFromFloat(float f){\r\n    assert f >= 0;\r\n    return (long) f;\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.DefaultTypeHierarchy.visitTypevarSupertype",
	"Comment": "a type variable is a supertype if its lower bound is above subtype.",
	"Method": "boolean visitTypevarSupertype(AnnotatedTypeMirror subtype,AnnotatedTypeVariable supertype){\r\n    return checkAndSubtype(subtype, supertype.getLowerBound());\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotatedTypeFactory.makeGroundTargetType",
	"Comment": "create the ground target type of the functional interface.basically, it replaces the wildcards with their bounds doing a capture conversion like glbfor extends bounds.",
	"Method": "void makeGroundTargetType(AnnotatedDeclaredType functionalType,DeclaredType groundTargetJavaType){\r\n    if (functionalType.getTypeArguments().isEmpty()) {\r\n        return;\r\n    }\r\n    List<AnnotatedTypeParameterBounds> bounds = this.typeVariablesFromUse(functionalType, (TypeElement) functionalType.getUnderlyingType().asElement());\r\n    List<AnnotatedTypeMirror> newTypeArguments = new ArrayList(functionalType.getTypeArguments());\r\n    boolean sizesDiffer = functionalType.getTypeArguments().size() != groundTargetJavaType.getTypeArguments().size();\r\n    for (int i = 0; i < functionalType.getTypeArguments().size(); i++) {\r\n        AnnotatedTypeMirror argType = functionalType.getTypeArguments().get(i);\r\n        if (argType.getKind() == TypeKind.WILDCARD) {\r\n            AnnotatedWildcardType wildcardType = (AnnotatedWildcardType) argType;\r\n            TypeMirror wildcardUbType = wildcardType.getExtendsBound().getUnderlyingType();\r\n            if (wildcardType.isUninferredTypeArgument()) {\r\n                newTypeArguments.set(i, wildcardType);\r\n            } else if (isExtendsWildcard(wildcardType)) {\r\n                TypeMirror correctArgType;\r\n                if (sizesDiffer) {\r\n                    TypeMirror typeParamUbType = bounds.get(i).getUpperBound().getUnderlyingType();\r\n                    correctArgType = TypesUtils.greatestLowerBound(typeParamUbType, wildcardUbType, this.checker.getProcessingEnvironment());\r\n                } else {\r\n                    correctArgType = groundTargetJavaType.getTypeArguments().get(i);\r\n                }\r\n                final AnnotatedTypeMirror newArg;\r\n                if (types.isSameType(wildcardUbType, correctArgType)) {\r\n                    newArg = wildcardType.getExtendsBound().deepCopy();\r\n                } else if (correctArgType.getKind() == TypeKind.TYPEVAR) {\r\n                    newArg = this.toAnnotatedType(correctArgType, false);\r\n                    AnnotatedTypeVariable newArgAsTypeVar = (AnnotatedTypeVariable) newArg;\r\n                    newArgAsTypeVar.getUpperBound().replaceAnnotations(wildcardType.getExtendsBound().getAnnotations());\r\n                    newArgAsTypeVar.getLowerBound().replaceAnnotations(wildcardType.getSuperBound().getAnnotations());\r\n                } else {\r\n                    newArg = this.toAnnotatedType(correctArgType, false);\r\n                    newArg.replaceAnnotations(wildcardType.getExtendsBound().getAnnotations());\r\n                }\r\n                newTypeArguments.set(i, newArg);\r\n            } else {\r\n                newTypeArguments.set(i, wildcardType.getSuperBound());\r\n            }\r\n        }\r\n    }\r\n    functionalType.setTypeArguments(newTypeArguments);\r\n    addDefaultAnnotations(functionalType);\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.toolwindow.CheckStyleToolWindowPanel.filterDisplayedResults",
	"Comment": "refresh the displayed results based on the current filter settings.",
	"Method": "void filterDisplayedResults(){\r\n    treeModel.filter(getDisplayedSeverities());\r\n}"
}, {
	"Path": "java.util.zip.DeflaterInputStream.read",
	"Comment": "reads compressed data into a byte array.this method will block until some input can be read and compressed.",
	"Method": "int read(int read,byte[] b,int off,int len){\r\n    ensureOpen();\r\n    if (b == null) {\r\n        throw new NullPointerException(\"Null buffer for read\");\r\n    } else if (off < 0 || len < 0 || len > b.length - off) {\r\n        throw new IndexOutOfBoundsException();\r\n    } else if (len == 0) {\r\n        return 0;\r\n    }\r\n    int cnt = 0;\r\n    while (len > 0 && !def.finished()) {\r\n        int n;\r\n        if (def.needsInput()) {\r\n            n = in.read(buf, 0, buf.length);\r\n            if (n < 0) {\r\n                def.finish();\r\n            } else if (n > 0) {\r\n                def.setInput(buf, 0, n);\r\n            }\r\n        }\r\n        n = def.deflate(b, off, len);\r\n        cnt += n;\r\n        off += n;\r\n        len -= n;\r\n    }\r\n    if (cnt == 0 && def.finished()) {\r\n        reachEOF = true;\r\n        cnt = -1;\r\n    }\r\n    return cnt;\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TreeUtils.enclosingOfClass",
	"Comment": "gets the first enclosing tree in path, of the specified class.",
	"Method": "T enclosingOfClass(TreePath path,Class<T> treeClass){\r\n    TreePath p = path;\r\n    while (p != null) {\r\n        Tree leaf = p.getLeaf();\r\n        if (treeClass.isInstance(leaf)) {\r\n            return treeClass.cast(leaf);\r\n        }\r\n        p = p.getParentPath();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.checkerframework.common.reflection.DefaultReflectionResolver.getConstructorSymbolsfor",
	"Comment": "get set of symbols for constructors based on class name and parameter length.",
	"Method": "List<Symbol> getConstructorSymbolsfor(String className,int paramLength,Env<AttrContext> env){\r\n    Context context = ((JavacProcessingEnvironment) processingEnv).getContext();\r\n    Resolve resolve = Resolve.instance(context);\r\n    Names names = Names.instance(context);\r\n    List<Symbol> result = new ArrayList();\r\n    Symbol symClass = getSymbol(className, env, names, resolve);\r\n    if (!symClass.exists()) {\r\n        debugReflection(\"Unable to resolve class: \" + className);\r\n        return Collections.emptyList();\r\n    }\r\n    ElementFilter.constructorsIn(symClass.getEnclosedElements());\r\n    for (Symbol s : symClass.getEnclosedElements()) {\r\n        if (s.getKind() == ElementKind.CONSTRUCTOR) {\r\n            if (((MethodSymbol) s).getParameters().size() == paramLength) {\r\n                result.add(s);\r\n            }\r\n        }\r\n    }\r\n    if (result.isEmpty()) {\r\n        debugReflection(\"Unable to resolve constructor!\");\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.checkerframework.framework.stub.StubParser.putNoOverride",
	"Comment": "just like map.put, but does not override any existing value in the map.",
	"Method": "void putNoOverride(Map<K, V> m,K key,V value){\r\n    if (key == null) {\r\n        throw new BugInCF(\"StubParser: key is null\");\r\n    }\r\n    if (!m.containsKey(key)) {\r\n        m.put(key, value);\r\n    }\r\n}"
}, {
	"Path": "java.util.Properties.setProperty",
	"Comment": "calls the hashtable method put. provided forparallelism with the getproperty method. enforces use ofstrings for property keys and values. the value returned is theresult of the hashtable call to put.",
	"Method": "Object setProperty(String key,String value){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.element.ElementAnnotationUtil.addWildcardToBoundMap",
	"Comment": "creates an entry in wildcardtoannos for wildcard if one does not already exists. adds anno tothe wildcardboundannos object for wildcard.",
	"Method": "void addWildcardToBoundMap(AnnotatedWildcardType wildcard,TypeCompound anno,Map<AnnotatedWildcardType, WildcardBoundAnnos> wildcardToAnnos){\r\n    WildcardBoundAnnos boundAnnos = wildcardToAnnos.get(wildcard);\r\n    if (boundAnnos == null) {\r\n        boundAnnos = new WildcardBoundAnnos(wildcard);\r\n        wildcardToAnnos.put(wildcard, boundAnnos);\r\n    }\r\n    boundAnnos.addAnnotation(anno);\r\n}"
}, {
	"Path": "java.io.DataInputStream.readUTF",
	"Comment": "see the general contract of the readutfmethod of datainput.bytesfor this operation are read from the containedinput stream.",
	"Method": "String readUTF(String readUTF,DataInput in){\r\n    int utflen = in.readUnsignedShort();\r\n    byte[] bytearr = null;\r\n    char[] chararr = null;\r\n    if (in instanceof DataInputStream) {\r\n        DataInputStream dis = (DataInputStream) in;\r\n        if (dis.bytearr.length < utflen) {\r\n            dis.bytearr = new byte[utflen * 2];\r\n            dis.chararr = new char[utflen * 2];\r\n        }\r\n        chararr = dis.chararr;\r\n        bytearr = dis.bytearr;\r\n    } else {\r\n        bytearr = new byte[utflen];\r\n        chararr = new char[utflen];\r\n    }\r\n    int c, char2, char3;\r\n    int count = 0;\r\n    int chararr_count = 0;\r\n    in.readFully(bytearr, 0, utflen);\r\n    while (count < utflen) {\r\n        c = (int) bytearr[count] & 0xff;\r\n        if (c > 127)\r\n            break;\r\n        count++;\r\n        chararr[chararr_count++] = (char) c;\r\n    }\r\n    while (count < utflen) {\r\n        c = (int) bytearr[count] & 0xff;\r\n        switch(c >> 4) {\r\n            case 0:\r\n            case 1:\r\n            case 2:\r\n            case 3:\r\n            case 4:\r\n            case 5:\r\n            case 6:\r\n            case 7:\r\n                count++;\r\n                chararr[chararr_count++] = (char) c;\r\n                break;\r\n            case 12:\r\n            case 13:\r\n                count += 2;\r\n                if (count > utflen)\r\n                    throw new UTFDataFormatException(\"malformed input: partial character at end\");\r\n                char2 = (int) bytearr[count - 1];\r\n                if ((char2 & 0xC0) != 0x80)\r\n                    throw new UTFDataFormatException(\"malformed input around byte \" + count);\r\n                chararr[chararr_count++] = (char) (((c & 0x1F) << 6) | (char2 & 0x3F));\r\n                break;\r\n            case 14:\r\n                count += 3;\r\n                if (count > utflen)\r\n                    throw new UTFDataFormatException(\"malformed input: partial character at end\");\r\n                char2 = (int) bytearr[count - 2];\r\n                char3 = (int) bytearr[count - 1];\r\n                if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80))\r\n                    throw new UTFDataFormatException(\"malformed input around byte \" + (count - 1));\r\n                chararr[chararr_count++] = (char) (((c & 0x0F) << 12) | ((char2 & 0x3F) << 6) | ((char3 & 0x3F) << 0));\r\n                break;\r\n            default:\r\n                throw new UTFDataFormatException(\"malformed input around byte \" + count);\r\n        }\r\n    }\r\n    return new String(chararr, 0, chararr_count);\r\n}"
}, {
	"Path": "java.io.RandomAccessFile.readBoolean",
	"Comment": "reads a boolean from this file. this method reads asingle byte from the file, starting at the current file pointer.a value of 0 representsfalse. any other value represents true.this method blocks until the byte is read, the end of the streamis detected, or an exception is thrown.",
	"Method": "boolean readBoolean(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.zip.GZIPInputStream.skipBytes",
	"Comment": "skips bytes of input data blocking until all bytes are skipped.does not assume that the input stream is capable of seeking.",
	"Method": "void skipBytes(InputStream in,int n){\r\n    while (n > 0) {\r\n        int len = in.read(tmpbuf, 0, n < tmpbuf.length ? n : tmpbuf.length);\r\n        if (len == -1) {\r\n            throw new EOFException();\r\n        }\r\n        n -= len;\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.LogManager.processParentHandlers",
	"Comment": "parents have levels or handlers defined, make sure they are instantiated.",
	"Method": "void processParentHandlers(Logger logger,String name){\r\n    int ix = 1;\r\n    for (; ; ) {\r\n        int ix2 = name.indexOf(\".\", ix);\r\n        if (ix2 < 0) {\r\n            break;\r\n        }\r\n        String pname = name.substring(0, ix2);\r\n        if (getProperty(pname + \".level\") != null || getProperty(pname + \".handlers\") != null) {\r\n            demandLogger(pname);\r\n        }\r\n        ix = ix2 + 1;\r\n    }\r\n}"
}, {
	"Path": "sun.util.resources.LocaleData.getTimeZoneNames",
	"Comment": "gets a time zone names resource bundle, using privilegesto allow accessing a sun. package.",
	"Method": "OpenListResourceBundle getTimeZoneNames(Locale locale){\r\n    return (OpenListResourceBundle) getBundle(\"sun.util.resources.TimeZoneNames\", locale);\r\n}"
}, {
	"Path": "java.util.zip.ZipInputStream.closeEntry",
	"Comment": "closes the current zip entry and positions the stream for reading thenext entry.",
	"Method": "void closeEntry(){\r\n    ensureOpen();\r\n    while (read(tmpbuf, 0, tmpbuf.length) != -1) ;\r\n    entryEOF = true;\r\n}"
}, {
	"Path": "java.util.logging.Formatter.getHead",
	"Comment": "return the header string for a set of formatted records.this base class returns an empty string, but this may beoverridden by subclasses.",
	"Method": "String getHead(Handler h){\r\n    return \"\";\r\n}"
}, {
	"Path": "com.mycompany.myapp.dto.AuthorDTOService.toDTO",
	"Comment": "converts the passed author to a dto. the depth is used to control theamount of association you want. it also prevents potential infinite serialization cycles.",
	"Method": "AuthorDTO toDTO(Author author,AuthorDTO toDTO,Author author,int depth){\r\n    if (author == null) {\r\n        return null;\r\n    }\r\n    AuthorDTO dto = new AuthorDTO();\r\n    dto.id = author.getId();\r\n    dto.civility = author.getCivility();\r\n    dto.lastName = author.getLastName();\r\n    dto.firstName = author.getFirstName();\r\n    dto.email = author.getEmail();\r\n    dto.birthDate = author.getBirthDate();\r\n    dto.birthDateTime = author.getBirthDateTime();\r\n    if (depth-- > 0) {\r\n        dto.favoriteAuthor = toDTO(author.getFavoriteAuthor(), depth);\r\n    }\r\n    return dto;\r\n}"
}, {
	"Path": "java.lang.ClassLoader.defineClass",
	"Comment": "converts an array of bytes into an instance of class class.before the class can be used it must be resolved.this methodis deprecated in favor of the version that takes a binary name as its first argument, and is more secure.",
	"Method": "Class<?> defineClass(byte[] b,int off,int len,Class<?> defineClass,String name,byte[] b,int off,int len,Class<?> defineClass,String name,byte[] b,int off,int len,ProtectionDomain protectionDomain,Class<?> defineClass,String name,java.nio.ByteBuffer b,ProtectionDomain protectionDomain){\r\n    int len = b.remaining();\r\n    if (!b.isDirect()) {\r\n        if (b.hasArray()) {\r\n            return defineClass(name, b.array(), b.position() + b.arrayOffset(), len, protectionDomain);\r\n        } else {\r\n            byte[] tb = new byte[len];\r\n            b.get(tb);\r\n            return defineClass(name, tb, 0, len, protectionDomain);\r\n        }\r\n    }\r\n    protectionDomain = preDefineClass(name, protectionDomain);\r\n    String source = defineClassSourceLocation(protectionDomain);\r\n    Class<?> c = defineClass2(name, b, b.position(), len, protectionDomain, source);\r\n    postDefineClass(c, protectionDomain);\r\n    return c;\r\n}"
}, {
	"Path": "java.util.logging.Level.intValue",
	"Comment": "get the integer value for this level.this integer valuecan be used for efficient ordering comparisons betweenlevel objects.",
	"Method": "int intValue(){\r\n    return value;\r\n}"
}, {
	"Path": "java.util.zip.Inflater.finished",
	"Comment": "returns true if the end of the compressed data stream has beenreached.",
	"Method": "boolean finished(){\r\n    synchronized (zsRef) {\r\n        return finished;\r\n    }\r\n}"
}, {
	"Path": "java.security.MessageDigest.isEqual",
	"Comment": "compares two digests for equality. does a simple byte compare.",
	"Method": "boolean isEqual(byte[] digesta,byte[] digestb){\r\n    if (digesta.length != digestb.length) {\r\n        return false;\r\n    }\r\n    int result = 0;\r\n    for (int i = 0; i < digesta.length; i++) {\r\n        result |= digesta[i] ^ digestb[i];\r\n    }\r\n    return result == 0;\r\n}"
}, {
	"Path": "sun.util.resources.LocaleData.getCurrencyNames",
	"Comment": "gets a currency names resource bundle, using privilegesto allow accessing a sun. package.",
	"Method": "OpenListResourceBundle getCurrencyNames(Locale locale){\r\n    return (OpenListResourceBundle) getBundle(\"sun.util.resources.CurrencyNames\", locale);\r\n}"
}, {
	"Path": "org.cfg4j.source.classpath.TempConfigurationClasspathRepo.close",
	"Comment": "close this repository and restore all modified files to their original form.",
	"Method": "void close(){\r\n    for (String propFilePath : originalContents.keySet()) {\r\n        writeToFile(propFilePath, originalContents.get(propFilePath));\r\n    }\r\n}"
}, {
	"Path": "java.io.ByteArrayInputStream.reset",
	"Comment": "resets the buffer to the marked position.the marked positionis 0 unless another position was marked or an offset was specifiedin the constructor.",
	"Method": "void reset(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.model.ConfigurationLocation.getBaseDir",
	"Comment": "get the base directory for this checkstyle file. if null then the project directory is assumed.",
	"Method": "File getBaseDir(){\r\n    return null;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.CheckerMain.extractFileArg",
	"Comment": "remove the argument given by argumentname and the subsequent value from the list args ifpresent. return the subsequent value wrapped as a file.",
	"Method": "File extractFileArg(String argumentName,File alternative,List<String> args){\r\n    final String filePath = extractArg(argumentName, null, args);\r\n    if (filePath == null) {\r\n        return alternative;\r\n    } else {\r\n        return new File(filePath);\r\n    }\r\n}"
}, {
	"Path": "java.io.File.exists",
	"Comment": "tests whether the file or directory denoted by this abstract pathnameexists.",
	"Method": "boolean exists(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TreeUtils.pathTillOfKind",
	"Comment": "gets path to the first enclosing tree with any one of the specified kinds.",
	"Method": "TreePath pathTillOfKind(TreePath path,Tree.Kind kind,TreePath pathTillOfKind,TreePath path,Set<Tree.Kind> kinds){\r\n    TreePath p = path;\r\n    while (p != null) {\r\n        Tree leaf = p.getLeaf();\r\n        assert leaf != null;\r\n        if (kinds.contains(leaf.getKind())) {\r\n            return p;\r\n        }\r\n        p = p.getParentPath();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.lang.System.getProperty",
	"Comment": "gets the system property indicated by the specified key.first, if there is a security manager, itscheckpropertyaccess method is called with thekey as its argument.if there is no current set of system properties, a set of systemproperties is first created and initialized in the same manner asfor the getproperties method.",
	"Method": "String getProperty(String key,String getProperty,String key,String def){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "com.mycompany.myapp.domain.User.toString",
	"Comment": "construct a readable string representation for this user instance.",
	"Method": "String toString(){\r\n    return // \r\n    MoreObjects.toStringHelper(this).add(\"id\", // \r\n    getId()).add(\"login\", // \r\n    getLogin()).add(\"password\", // \r\n    \"XXXX\").add(\"email\", // \r\n    getEmail()).add(\"isEnabled\", // \r\n    getIsEnabled()).add(\"civility\", // \r\n    getCivility()).add(\"countryCode\", // \r\n    getCountryCode()).add(\"firstName\", // \r\n    getFirstName()).add(\"lastName\", // \r\n    getLastName()).add(\"creationDate\", // \r\n    getCreationDate()).add(\"creationAuthor\", // \r\n    getCreationAuthor()).add(\"lastModificationDate\", // \r\n    getLastModificationDate()).add(\"lastModificationAuthor\", // \r\n    getLastModificationAuthor()).add(\"version\", getVersion()).toString();\r\n}"
}, {
	"Path": "java.lang.Long.toUnsignedBigInteger",
	"Comment": "return a biginteger equal to the unsigned value of theargument.",
	"Method": "BigInteger toUnsignedBigInteger(long i){\r\n    if (i >= 0L)\r\n        return BigInteger.valueOf(i);\r\n    else {\r\n        int upper = (int) (i >>> 32);\r\n        int lower = (int) i;\r\n        return (BigInteger.valueOf(Integer.toUnsignedLong(upper))).shiftLeft(32).add(BigInteger.valueOf(Integer.toUnsignedLong(lower)));\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.AnnotationClassLoader.getJarURL",
	"Comment": "given an absolute path to a jar file, this method will return a url reference to that jarfile.",
	"Method": "URL getJarURL(String absolutePathToJarFile){\r\n    URL jarURL = null;\r\n    try {\r\n        jarURL = new URL(\"jar:file:\" + absolutePathToJarFile + \"!/\");\r\n    } catch (MalformedURLException e) {\r\n        processingEnv.getMessager().printMessage(Kind.NOTE, \"Jar URL \" + absolutePathToJarFile + \" is malformed\");\r\n    }\r\n    return jarURL;\r\n}"
}, {
	"Path": "java.util.Date.getMillisOf",
	"Comment": "returns the millisecond value of this date objectwithout affecting its internal state.",
	"Method": "long getMillisOf(Date date){\r\n    if (date.cdate == null || date.cdate.isNormalized()) {\r\n        return date.fastTime;\r\n    }\r\n    BaseCalendar.Date d = (BaseCalendar.Date) date.cdate.clone();\r\n    return gcal.getTime(d);\r\n}"
}, {
	"Path": "org.checkerframework.framework.source.SourceChecker.getBooleanOption",
	"Comment": "determines the boolean value of the option with the given name. returns the given defaultvalue if the option is not set.",
	"Method": "boolean getBooleanOption(String name,boolean getBooleanOption,String name,boolean defaultValue){\r\n    String value = getOption(name);\r\n    if (value == null) {\r\n        return defaultValue;\r\n    }\r\n    if (value.equals(\"true\")) {\r\n        return true;\r\n    }\r\n    if (value.equals(\"false\")) {\r\n        return false;\r\n    }\r\n    throw new UserError(String.format(\"Value of %s option should be a boolean, but is \\\"%s\\\".\", name, value));\r\n}"
}, {
	"Path": "java.util.GregorianCalendar.getLastJulianDate",
	"Comment": "returns the day before the gregorian cutover date as abasecalendar.date. the date is a julian date.",
	"Method": "BaseCalendar.Date getLastJulianDate(){\r\n    return getCalendarDate(gregorianCutoverDate - 1);\r\n}"
}, {
	"Path": "org.checkerframework.checker.index.upperbound.UpperBoundAnnotatedTypeFactory.sameLenAnnotationFromTree",
	"Comment": "queries the samelen checker to return the type that the samelen checker associates with thegiven tree.",
	"Method": "AnnotationMirror sameLenAnnotationFromTree(Tree tree){\r\n    AnnotatedTypeMirror sameLenType = getSameLenAnnotatedTypeFactory().getAnnotatedType(tree);\r\n    return sameLenType.getAnnotation(SameLen.class);\r\n}"
}, {
	"Path": "java.io.InputStreamReader.ready",
	"Comment": "tells whether this stream is ready to be read.an inputstreamreader isready if its input buffer is not empty, or if bytes are available to beread from the underlying byte stream.",
	"Method": "boolean ready(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.zip.DeflaterInputStream.close",
	"Comment": "closes this input stream and its underlying input stream, discardingany pending uncompressed data.",
	"Method": "void close(){\r\n    if (in != null) {\r\n        try {\r\n            if (usesDefaultDeflater) {\r\n                def.end();\r\n            }\r\n            in.close();\r\n        } finally {\r\n            in = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.lang.String.length",
	"Comment": "returns the length of this string.the length is equal to the number of unicodecode units in the string.",
	"Method": "int length(){\r\n    return value.length;\r\n}"
}, {
	"Path": "org.checkerframework.checker.nullness.KeyForPropagationTreeAnnotator.visitVariable",
	"Comment": "transfers annotations to the variabletree if the right side is a call tojava.util.map.keyset.",
	"Method": "Void visitVariable(VariableTree variableTree,AnnotatedTypeMirror type){\r\n    super.visitVariable(variableTree, type);\r\n    if (type.getKind() == TypeKind.DECLARED) {\r\n        final ExpressionTree initializer = variableTree.getInitializer();\r\n        if (isCallToKeyset(initializer)) {\r\n            final AnnotatedDeclaredType variableType = (AnnotatedDeclaredType) type;\r\n            final AnnotatedTypeMirror initializerType = atypeFactory.getAnnotatedType(initializer);\r\n            if (variableType.getKind() == TypeKind.DECLARED) {\r\n                keyForPropagator.propagate((AnnotatedDeclaredType) initializerType, variableType, PropagationDirection.TO_SUPERTYPE, atypeFactory);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.io.PipedInputStream.available",
	"Comment": "returns the number of bytes that can be read from this inputstream without blocking.",
	"Method": "int available(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.Hessian2Input.readReply",
	"Comment": "reads a reply as an object.if the reply has a fault, throws the exception.",
	"Method": "Object readReply(Class expectedClass){\r\n    int tag = read();\r\n    if (tag == 'R') {\r\n        return readObject(expectedClass);\r\n    } else if (tag == 'F') {\r\n        HashMap map = (HashMap) readObject(HashMap.class);\r\n        throw prepareFault(map);\r\n    } else {\r\n        StringBuilder sb = new StringBuilder();\r\n        sb.append((char) tag);\r\n        try {\r\n            int ch;\r\n            while ((ch = read()) >= 0) {\r\n                sb.append((char) ch);\r\n            }\r\n        } catch (IOException e) {\r\n            log.log(Level.FINE, e.toString(), e);\r\n        }\r\n        throw error(\"expected hessian reply at \" + codeName(tag) + \"\\n\" + sb);\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.typeinference.constraint.AFReducingVisitor.defaultErrorMessage",
	"Comment": "called when we encounter an af constraint on a type combination that we did not think ispossible. this either implies that the type combination is possible, we accidentally createdan invalid a2f or f2a constraint, or we called the visit method on two annotatedtypemirrorsthat do not appear together in a constraint.",
	"Method": "String defaultErrorMessage(AnnotatedTypeMirror subtype,AnnotatedTypeMirror supertype,Set<AFConstraint> constraints){\r\n    return \"Unexpected \" + reducerType.getSimpleName() + \" + Combination:\\n\" + \"subtype=\" + subtype + \"\\n\" + \"supertype=\" + supertype + \"\\n\" + \"constraints=[\\n\" + PluginUtil.join(\", \", constraints) + \"\\n]\";\r\n}"
}, {
	"Path": "java.util.zip.Deflater.getBytesRead",
	"Comment": "returns the total number of uncompressed bytes input so far.",
	"Method": "long getBytesRead(long getBytesRead,long addr){\r\n    synchronized (zsRef) {\r\n        ensureOpen();\r\n        return getBytesRead(zsRef.address());\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.LogRecord.setSequenceNumber",
	"Comment": "set the sequence number.sequence numbers are normally assigned in the logrecord constructor,so it should not normally be necessary to use this method.",
	"Method": "void setSequenceNumber(long seq){\r\n    sequenceNumber = seq;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.element.TypeVarUseApplier.extractAndApply",
	"Comment": "applies the bound annotations from the declaration of the type parameter and then applies theexplicit annotations written on the type variable.",
	"Method": "void extractAndApply(){\r\n    ElementAnnotationUtil.addAnnotationsFromElement(typeVariable, useElem.getAnnotationMirrors());\r\n    ElementAnnotationApplier.apply(typeVariable, declarationElem, typeFactory);\r\n    final List<Attribute.TypeCompound> annotations = getAnnotations(useElem, declarationElem);\r\n    final List<Attribute.TypeCompound> typeVarAnnotations;\r\n    if (arrayType != null) {\r\n        typeVarAnnotations = removeComponentAnnotations(arrayType, annotations);\r\n        ElementAnnotationUtil.annotateViaTypeAnnoPosition(arrayType, annotations);\r\n    } else {\r\n        typeVarAnnotations = annotations;\r\n    }\r\n    for (final Attribute.TypeCompound annotation : typeVarAnnotations) {\r\n        typeVariable.removeAnnotationInHierarchy(annotation);\r\n        typeVariable.addAnnotation(annotation);\r\n        final List<? extends AnnotatedTypeMirror> upperBounds;\r\n        if (typeVariable.getUpperBound() instanceof AnnotatedIntersectionType) {\r\n            upperBounds = typeVariable.getUpperBound().directSuperTypes();\r\n        } else {\r\n            upperBounds = Arrays.asList(typeVariable.getUpperBound());\r\n        }\r\n        for (final AnnotatedTypeMirror bound : upperBounds) {\r\n            bound.removeAnnotationInHierarchy(annotation);\r\n            bound.addAnnotation(annotation);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.checkerframework.checker.signedness.SignednessUtil.toUnsignedShort",
	"Comment": "returns an unsigned short representing the same value as an unsigned char.",
	"Method": "short toUnsignedShort(byte b,short toUnsignedShort,char c){\r\n    return (short) (((int) c) & 0xff);\r\n}"
}, {
	"Path": "java.util.Hashtable.clone",
	"Comment": "creates a shallow copy of this hashtable. all the structure of thehashtable itself is copied, but the keys and values are not cloned.this is a relatively expensive operation.",
	"Method": "Object clone(Object clone){\r\n    try {\r\n        Hashtable<?, ?> t = (Hashtable<?, ?>) super.clone();\r\n        t.table = new Entry<?, ?>[table.length];\r\n        for (int i = table.length; i-- > 0; ) {\r\n            t.table[i] = (table[i] != null) ? (Entry<?, ?>) table[i].clone() : null;\r\n        }\r\n        t.keySet = null;\r\n        t.entrySet = null;\r\n        t.values = null;\r\n        t.modCount = 0;\r\n        return t;\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new InternalError(e);\r\n    }\r\n}"
}, {
	"Path": "java.io.RandomAccessFile.writeChars",
	"Comment": "writes a string to the file as a sequence of characters. eachcharacter is written to the data output stream as if by thewritechar method. the write starts at the currentposition of the file pointer.",
	"Method": "void writeChars(String s){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "java.util.JumboEnumSet.remove",
	"Comment": "removes the specified element from this set if it is present.",
	"Method": "void remove(boolean remove,Object e){\r\n    if (e == null)\r\n        return false;\r\n    Class eClass = e.getClass();\r\n    if (eClass != elementType && eClass.getSuperclass() != elementType)\r\n        return false;\r\n    int eOrdinal = ((Enum) e).ordinal();\r\n    int eWordNum = eOrdinal >>> 6;\r\n    long oldElements = elements[eWordNum];\r\n    elements[eWordNum] &= ~(1L << eOrdinal);\r\n    boolean result = (elements[eWordNum] != oldElements);\r\n    if (result)\r\n        size--;\r\n    return result;\r\n}"
}, {
	"Path": "com.alibaba.citrus.hessian.io.HessianSerializerInput.readObjectImpl",
	"Comment": "reads an object from the input stream.cl is known not to bea map.",
	"Method": "Object readObjectImpl(Class cl){\r\n    try {\r\n        Object obj = cl.newInstance();\r\n        if (_refs == null) {\r\n            _refs = new ArrayList();\r\n        }\r\n        _refs.add(obj);\r\n        HashMap fieldMap = getFieldMap(cl);\r\n        int code = read();\r\n        for (; code >= 0 && code != 'z'; code = read()) {\r\n            unread();\r\n            Object key = readObject();\r\n            Field field = (Field) fieldMap.get(key);\r\n            if (field != null) {\r\n                Object value = readObject(field.getType());\r\n                field.set(obj, value);\r\n            } else {\r\n                Object value = readObject();\r\n            }\r\n        }\r\n        if (code != 'z') {\r\n            throw expect(\"map\", code);\r\n        }\r\n        try {\r\n            Method method = cl.getMethod(\"readResolve\", new Class[0]);\r\n            return method.invoke(obj, new Object[0]);\r\n        } catch (Exception e) {\r\n        }\r\n        return obj;\r\n    } catch (IOException e) {\r\n        throw e;\r\n    } catch (Exception e) {\r\n        throw new IOExceptionWrapper(e);\r\n    }\r\n}"
}, {
	"Path": "java.io.FilterOutputStream.flush",
	"Comment": "flushes this output stream and forces any buffered output bytesto be written out to the stream.the flush method of filteroutputstreamcalls the flush method of its underlying output stream.",
	"Method": "void flush(){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.infernus.idea.checkstyle.model.ConfigurationLocation.extractProperties",
	"Comment": "extract all settable properties from the given configuration element.",
	"Method": "List<String> extractProperties(InputStream inputStream,ClassLoader checkstyleClassLoader,List<String> extractProperties,Element element){\r\n    final List<String> propertyNames = new ArrayList();\r\n    if (element != null) {\r\n        extractPropertyNames(element, propertyNames);\r\n        for (final Element child : element.getChildren()) {\r\n            propertyNames.addAll(extractProperties(child));\r\n        }\r\n    }\r\n    return propertyNames;\r\n}"
}, {
	"Path": "org.checkerframework.checker.propkey.PropertyKeyAnnotatedTypeFactory.createBasicTreeAnnotator",
	"Comment": "to allow subclasses access to createtreeannotator from the batf.",
	"Method": "TreeAnnotator createBasicTreeAnnotator(){\r\n    return super.createTreeAnnotator();\r\n}"
}, {
	"Path": "org.checkerframework.common.value.ValueTransfer.calculateNumericalBinaryOp",
	"Comment": "get the refined annotation after a numerical binary operation.",
	"Method": "AnnotationMirror calculateNumericalBinaryOp(Node leftNode,Node rightNode,NumericalBinaryOps op,TransferInput<CFValue, CFStore> p){\r\n    if (!isIntRangeOrIntegralUnknownVal(leftNode, p) && !isIntRangeOrIntegralUnknownVal(rightNode, p)) {\r\n        List<Number> resultValues = calculateValuesBinaryOp(leftNode, rightNode, op, p);\r\n        return atypefactory.createNumberAnnotationMirror(resultValues);\r\n    } else {\r\n        Range resultRange = calculateRangeBinaryOp(leftNode, rightNode, op, p);\r\n        return atypefactory.createIntRangeAnnotation(resultRange);\r\n    }\r\n}"
}, {
	"Path": "java.util.logging.LogRecord.getSequenceNumber",
	"Comment": "get the sequence number.sequence numbers are normally assigned in the logrecordconstructor, which assigns unique sequence numbers toeach new logrecord in increasing order.",
	"Method": "long getSequenceNumber(){\r\n    return sequenceNumber;\r\n}"
}, {
	"Path": "org.checkerframework.framework.util.AtmLubVisitor.lubPrimaryAnnotations",
	"Comment": "replaces the primary annotations of lub with the lub of the primary annotations of type1 andtype2.",
	"Method": "void lubPrimaryAnnotations(AnnotatedTypeMirror type1,AnnotatedTypeMirror type2,AnnotatedTypeMirror lub){\r\n    Set<? extends AnnotationMirror> lubSet;\r\n    if (type1.getAnnotations().isEmpty()) {\r\n        lubSet = type2.getAnnotations();\r\n    } else if (type2.getAnnotations().isEmpty()) {\r\n        lubSet = type1.getAnnotations();\r\n    } else {\r\n        lubSet = qualifierHierarchy.leastUpperBounds(type1.getAnnotations(), type2.getAnnotations());\r\n    }\r\n    lub.replaceAnnotations(lubSet);\r\n}"
}, {
	"Path": "java.util.HashMap.containsValue",
	"Comment": "returns true if this map maps one or more keys to thespecified value.",
	"Method": "boolean containsValue(Object value){\r\n    Node<K, V>[] tab;\r\n    V v;\r\n    if ((tab = table) != null && size > 0) {\r\n        for (int i = 0; i < tab.length; ++i) {\r\n            for (Node<K, V> e = tab[i]; e != null; e = e.next) {\r\n                if ((v = e.value) == value || (value != null && value.equals(v)))\r\n                    return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.getOffset",
	"Comment": "returns the offset of this time zone from utc at the giventime. if daylight saving time is in effect at the given time,the offset value is adjusted with the amount of daylightsaving.",
	"Method": "int getOffset(long date,int getOffset,int era,int year,int month,int day,int dayOfWeek,int millis,int getOffset,BaseCalendar cal,BaseCalendar.Date cdate,int year,long time){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.framework.type.GenericAnnotatedTypeFactory.getSupportedMonotonicTypeQualifiers",
	"Comment": "returns an immutable set of the monotonic type qualifiers supported by this checker.",
	"Method": "Set<Class<? extends Annotation>> getSupportedMonotonicTypeQualifiers(){\r\n    if (supportedMonotonicQuals == null) {\r\n        supportedMonotonicQuals = new HashSet();\r\n        for (Class<? extends Annotation> anno : getSupportedTypeQualifiers()) {\r\n            MonotonicQualifier mono = anno.getAnnotation(MonotonicQualifier.class);\r\n            if (mono != null) {\r\n                supportedMonotonicQuals.add(anno);\r\n            }\r\n        }\r\n    }\r\n    return supportedMonotonicQuals;\r\n}"
}, {
	"Path": "java.text.BreakIterator.getLineInstance",
	"Comment": "returns a new breakiterator instancefor line breaksfor the given locale.",
	"Method": "BreakIterator getLineInstance(BreakIterator getLineInstance,Locale locale){\r\n    return getBreakInstance(locale, LINE_INDEX);\r\n}"
}, {
	"Path": "org.checkerframework.javacutil.TreeUtils.elementFromDeclaration",
	"Comment": "gets the element for a variable corresponding to its declaration.",
	"Method": "TypeElement elementFromDeclaration(ClassTree node,ExecutableElement elementFromDeclaration,MethodTree node,VariableElement elementFromDeclaration,VariableTree node){\r\n    VariableElement elt = (VariableElement) TreeUtils.elementFromTree(node);\r\n    return elt;\r\n}"
}, {
	"Path": "org.checkerframework.common.basetype.BaseTypeChecker.getSubchecker",
	"Comment": "returns the requested subchecker. a checker of a given class can only be run once, so thisreturns the only such checker, or null if none was found. the caller must know the exactchecker class to request.",
	"Method": "T getSubchecker(Class<T> checkerClass){\r\n    for (BaseTypeChecker checker : immediateSubcheckers) {\r\n        if (checker.getClass().equals(checkerClass)) {\r\n            return (T) checker;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.io.LineNumberReader.read",
	"Comment": "read characters into a portion of an array.whenever a line terminator is read the current line number isincremented.",
	"Method": "int read(int read,char cbuf,int off,int len){\r\n    throw new RuntimeException(\"skeleton method\");\r\n}"
}, {
	"Path": "org.checkerframework.common.value.util.Range.isWiderThan",
	"Comment": "determines if the range is wider than a given value, i.e., if the number of possible valuesenclosed by this range is more than the given value.",
	"Method": "boolean isWiderThan(long value){\r\n    if (this.isWithin((Long.MIN_VALUE >> 1) + 1, Long.MAX_VALUE >> 1)) {\r\n        return to - from + 1 > value;\r\n    } else {\r\n        return BigInteger.valueOf(to).subtract(BigInteger.valueOf(from)).add(BigInteger.ONE).compareTo(BigInteger.valueOf(value)) == 1;\r\n    }\r\n}"
}, {
	"Path": "java.util.JumboEnumSet.containsAll",
	"Comment": "returns true if this set contains all of the elementsin the specified collection.",
	"Method": "boolean containsAll(Collection<?> c){\r\n    if (!(c instanceof JumboEnumSet))\r\n        return super.containsAll(c);\r\n    JumboEnumSet es = (JumboEnumSet) c;\r\n    if (es.elementType != elementType)\r\n        return es.isEmpty();\r\n    for (int i = 0; i < elements.length; i++) if ((es.elements[i] & ~elements[i]) != 0)\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "java.util.EnumMap.getKeyUniverse",
	"Comment": "returns all of the values comprising k.the result is uncloned, cached, and shared by all callers.",
	"Method": "K[] getKeyUniverse(Class<K> keyType){\r\n    return SharedSecrets.getJavaLangAccess().getEnumConstantsShared(keyType);\r\n}"
}]