[{
	"Path": "com.codename1.ui.Tabs.getTabIcon",
	"Comment": "returns the icon of the tab component. this method should be used when overridingcreatetab",
	"Method": "Image getTabIcon(Component tab,Image getTabIcon,int index){\r\n    checkIndex(index);\r\n    return getTabIcon(tabsContainer.getComponentAt(index));\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.addExceptionListener",
	"Comment": "adds a listener that would be notified on the codenameone thread of an exceptionin this connection request",
	"Method": "void addExceptionListener(ActionListener<NetworkEvent> a){\r\n    if (exceptionListeners == null) {\r\n        exceptionListeners = new EventDispatcher();\r\n        exceptionListeners.setBlocking(false);\r\n    }\r\n    exceptionListeners.addListener(a);\r\n}"
}, {
	"Path": "com.codename1.ui.Graphics.isAffineSupported",
	"Comment": "indicates whether the underlying implementation can draw using an affinetransform hence methods such as rotate, scale and shear would work",
	"Method": "boolean isAffineSupported(){\r\n    return impl.isAffineSupported();\r\n}"
}, {
	"Path": "com.codename1.maps.layers.PointsLayer.addActionListener",
	"Comment": "adds a listener to the points layer which will cause an event to dispatch on click the actionevent will contain the pressed pointlayer unprojected",
	"Method": "void addActionListener(ActionListener l){\r\n    dispatcher.addListener(l);\r\n}"
}, {
	"Path": "com.codename1.testing.TestReporting.setInstance",
	"Comment": "sets the test reporting instance to a subclass of this class.",
	"Method": "void setInstance(TestReporting i){\r\n    instance = i;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.setPollingFrequency",
	"Comment": "sets the frequency for polling the server in case of polling based push notification",
	"Method": "void setPollingFrequency(int freq){\r\n    pollingMillis = freq;\r\n    if (callback != null && pollingThreadRunning) {\r\n        synchronized (callback) {\r\n            callback.notify();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.List.setMinElementHeight",
	"Comment": "minimum number of elements shown in a list, this member is used to calculatethe list preferred size. if the number of elements in the model is smaller thanthis then this value is used in the calculations.",
	"Method": "void setMinElementHeight(int minElementHeight){\r\n    this.minElementHeight = minElementHeight;\r\n}"
}, {
	"Path": "com.codename1.ui.html.ResourceThreadQueue.toString",
	"Comment": "returns a printout of the threads queue, can be used for debugging",
	"Method": "String toString(){\r\n    String str = (\"---- Running ----\\n\");\r\n    int i = 1;\r\n    for (Enumeration e = running.elements(); e.hasMoreElements(); ) {\r\n        ResourceThread t = (ResourceThread) e.nextElement();\r\n        if (t.imageUrl != null) {\r\n            str += \"#\" + i + \": \" + t.imageUrl + \"\\n\";\r\n        } else {\r\n            str += \"#\" + i + \": CSS - \" + t.cssDocInfo.getUrl() + \"\\n\";\r\n        }\r\n        i++;\r\n    }\r\n    i = 1;\r\n    str += \"Queue:\\n\";\r\n    for (Enumeration e = queue.elements(); e.hasMoreElements(); ) {\r\n        ResourceThread t = (ResourceThread) e.nextElement();\r\n        if (t.imageUrl != null) {\r\n            str += \"#\" + i + \": \" + t.imageUrl + \"\\n\";\r\n        } else {\r\n            str += \"#\" + i + \": CSS - \" + t.cssDocInfo.getUrl() + \"\\n\";\r\n        }\r\n        i++;\r\n    }\r\n    str += \"---- count:\" + threadCount + \" ----\\n\";\r\n    return str;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLElement.verify",
	"Comment": "verifies that the specified string conforms with the specified restrictions.",
	"Method": "boolean verify(String value,int allowedMask,char[] allowedChars,boolean verify,String value,int allowedMask,char[] allowedChars,int minLength,int maxLength){\r\n    if ((minLength != -1) && (value.length() < minLength)) {\r\n        return false;\r\n    }\r\n    if ((maxLength != -1) && (value.length() > maxLength)) {\r\n        return false;\r\n    }\r\n    int i = 0;\r\n    while (i < value.length()) {\r\n        boolean found = false;\r\n        char ch = value.charAt(i);\r\n        if ((allowedMask & HEX) != 0) {\r\n            if (((ch >= '0') && (ch <= '9')) || ((ch >= 'A') && (ch <= 'F')) || ((ch >= 'a') && (ch <= 'f'))) {\r\n                found = true;\r\n            }\r\n        }\r\n        if ((allowedMask & DIGITS) != 0) {\r\n            if (((ch >= '0') && (ch <= '9'))) {\r\n                found = true;\r\n            } else if ((i == 0) && ((ch == '-') || (ch == '+'))) {\r\n                found = true;\r\n            }\r\n        }\r\n        if ((!found) && ((allowedMask & ABC) != 0)) {\r\n            if (((ch >= 'a') && (ch <= 'z')) || ((ch >= 'A') && (ch <= 'Z'))) {\r\n                found = true;\r\n            }\r\n        }\r\n        if ((!found) && (allowedChars != null)) {\r\n            int c = 0;\r\n            while ((!found) && (c < allowedChars.length)) {\r\n                if (ch == allowedChars[c]) {\r\n                    found = true;\r\n                } else {\r\n                    c++;\r\n                }\r\n            }\r\n        }\r\n        if (!found) {\r\n            return false;\r\n        }\r\n        i++;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.text.SimpleDateFormat.getDSTOffset",
	"Comment": "determine the number of minutes to adjust the date for local dst. this\tshould provide a historically correct value, also accounting for changes\tin gmt offset. see timezone javadoc for more details.",
	"Method": "int getDSTOffset(Calendar source){\r\n    TimeZone localTimezone = Calendar.getInstance().getTimeZone();\r\n    int rawOffset = localTimezone.getRawOffset() / MILLIS_TO_MINUTES;\r\n    return getOffsetInMinutes(source, localTimezone) - rawOffset;\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyIndex.setXmlTextElement",
	"Comment": "toggles whether a given property should act as a text element for this object",
	"Method": "void setXmlTextElement(PropertyBase p,boolean t){\r\n    if (t) {\r\n        p.putClientProperty(\"xmlTextElement\", Boolean.TRUE);\r\n    } else {\r\n        p.putClientProperty(\"xmlTextElement\", null);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.properties.MapProperty.asExplodedMap",
	"Comment": "returns a copy of the content as a new map but if the value is a propertybusinessobject it will be converted to a map",
	"Method": "Map<T1, Object> asExplodedMap(){\r\n    Map<T1, Object> m = new LinkedHashMap<T1, Object>();\r\n    for (T1 k : value.keySet()) {\r\n        T2 v = value.get(k);\r\n        if (v instanceof PropertyBusinessObject) {\r\n            m.put(k, ((PropertyBusinessObject) v).getPropertyIndex().toMapRepresentation());\r\n        } else {\r\n            m.put(k, v);\r\n        }\r\n    }\r\n    return m;\r\n}"
}, {
	"Path": "com.codename1.charts.transitions.XYSeriesTransition.getSeries",
	"Comment": "gets the series whose values are to be animated by this transition.",
	"Method": "XYSeries getSeries(){\r\n    return series;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.getEditOnShow",
	"Comment": "a text component that will receive focus and start editing immediately as the form is shown",
	"Method": "TextArea getEditOnShow(){\r\n    return editOnShow;\r\n}"
}, {
	"Path": "java.lang.Character.isSupplementaryCodePoint",
	"Comment": "a test for determining if the codepoint is within thesupplementary code point range.",
	"Method": "boolean isSupplementaryCodePoint(int codePoint){\r\n    return (MIN_SUPPLEMENTARY_CODE_POINT <= codePoint && MAX_CODE_POINT >= codePoint);\r\n}"
}, {
	"Path": "org.conscrypt.SSLUtils.calculateOutNetBufSize",
	"Comment": "calculates the minimum bytes required in the encrypted output buffer for the given number ofplaintext source bytes.",
	"Method": "int calculateOutNetBufSize(int pendingBytes){\r\n    return min(SSL3_RT_MAX_PACKET_SIZE, MAX_ENCRYPTION_OVERHEAD_LENGTH + min(MAX_ENCRYPTION_OVERHEAD_DIFF, pendingBytes));\r\n}"
}, {
	"Path": "com.codename1.testing.TestUtils.waitFor",
	"Comment": "waits for the given number of milliseconds even if the waiting is on the edt thread",
	"Method": "void waitFor(int millis){\r\n    if (verbose) {\r\n        log(\"waitFor(\" + millis + \")\");\r\n    }\r\n    if (Display.getInstance().isEdt()) {\r\n        Display.getInstance().invokeAndBlock(new Runnable() {\r\n            public void run() {\r\n                try {\r\n                    Thread.sleep(millis);\r\n                } catch (InterruptedException ex) {\r\n                }\r\n            }\r\n        });\r\n    } else {\r\n        try {\r\n            Thread.sleep(millis);\r\n        } catch (InterruptedException ex) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.testing.TestUtils.waitFor",
	"Comment": "waits for the given number of milliseconds even if the waiting is on the edt thread",
	"Method": "void waitFor(int millis){\r\n    try {\r\n        Thread.sleep(millis);\r\n    } catch (InterruptedException ex) {\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.setUseSoftkeys",
	"Comment": "when set to true softkeys are used to enable delete functionality",
	"Method": "void setUseSoftkeys(boolean useSoftkeys){\r\n    this.useSoftkeys = useSoftkeys;\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.createDay",
	"Comment": "this method creates the day button component for the month view",
	"Method": "Button createDay(){\r\n    Button day = new Button(\"\", \"CalendarDay\");\r\n    day.setAlignment(CENTER);\r\n    day.setEndsWith3Points(false);\r\n    day.setTickerEnabled(false);\r\n    return day;\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyBase.removeChangeListener",
	"Comment": "removes the property change listener from the list of listeners",
	"Method": "void removeChangeListener(PropertyChangeListener<T, K> pl){\r\n    if (listeners != null) {\r\n        listeners.remove(pl);\r\n        if (listeners.size() == 0) {\r\n            listeners = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Display.processSerialCalls",
	"Comment": "used by the edt to process all the calls submitted via call serially",
	"Method": "void processSerialCalls(){\r\n    processingSerialCalls = true;\r\n    int size = pendingSerialCalls.size();\r\n    if (size > 0) {\r\n        Runnable[] array = null;\r\n        synchronized (lock) {\r\n            size = pendingSerialCalls.size();\r\n            array = new Runnable[size];\r\n            pendingSerialCalls.toArray(array);\r\n            if (size == pendingSerialCalls.size()) {\r\n                pendingSerialCalls.clear();\r\n            } else {\r\n                for (int iter = 0; iter < size; iter++) {\r\n                    pendingSerialCalls.remove(0);\r\n                }\r\n            }\r\n        }\r\n        for (int iter = 0; iter < size; iter++) {\r\n            array[iter].run();\r\n        }\r\n        synchronized (lock) {\r\n            lock.notify();\r\n        }\r\n    }\r\n    processingSerialCalls = false;\r\n}"
}, {
	"Path": "android.support.v4.text.BidiFormatter.isRtlLocale",
	"Comment": "helper method to return true if the locale directionality is rtl.",
	"Method": "boolean isRtlLocale(Locale locale){\r\n    return (TextUtilsCompat.getLayoutDirectionFromLocale(locale) == ViewCompat.LAYOUT_DIRECTION_RTL);\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.setCustomCrashSegments",
	"Comment": "sets custom segments to be reported with crash reportsin custom segments you can provide any string key values to segments crashes by",
	"Method": "Countly setCustomCrashSegments(Map<String, String> segments){\r\n    if (Countly.sharedInstance().isLoggingEnabled()) {\r\n        Log.d(Countly.TAG, \"Setting custom crash segments\");\r\n    }\r\n    if (!getConsent(CountlyFeatureNames.crashes)) {\r\n        return this;\r\n    }\r\n    if (segments != null) {\r\n        CrashDetails.setCustomSegments(segments);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.conscrypt.ct.SignedCertificateTimestamp.encodeTBS",
	"Comment": "tls encode the signed part of the sct, as described by rfc6962 section 3.2.",
	"Method": "void encodeTBS(OutputStream output,CertificateEntry certEntry,byte[] encodeTBS,CertificateEntry certEntry){\r\n    ByteArrayOutputStream output = new ByteArrayOutputStream();\r\n    encodeTBS(output, certEntry);\r\n    return output.toByteArray();\r\n}"
}, {
	"Path": "ly.count.android.sdk.DeviceInfo.getOSVersion",
	"Comment": "returns the current operating system version as a displayable string.",
	"Method": "String getOSVersion(){\r\n    return android.os.Build.VERSION.RELEASE;\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.getUser",
	"Comment": "gets a user from a user idthis is a sync method it will block until a response it returned",
	"Method": "void getUser(String userId,User user,ActionListener callback,User getUser,String userId){\r\n    String id = userId;\r\n    if (id == null) {\r\n        id = \"me\";\r\n    }\r\n    final User user = new User();\r\n    final Vector err = new Vector();\r\n    addResponseCodeListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            NetworkEvent ne = (NetworkEvent) evt;\r\n            err.addElement(ne);\r\n            removeResponseCodeListener(this);\r\n        }\r\n    });\r\n    getFaceBookObject(id, new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            Vector v = (Vector) ((NetworkEvent) evt).getMetaData();\r\n            Hashtable t = (Hashtable) v.elementAt(0);\r\n            user.copy(t);\r\n        }\r\n    }, true, false);\r\n    if (err.size() > 0) {\r\n        throw new IOException(((NetworkEvent) err.elementAt(0)).getResponseCode() + \": \" + ((NetworkEvent) err.elementAt(0)).getMessage());\r\n    }\r\n    return user;\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.getUser",
	"Comment": "gets a user from a user idthis is a sync method it will block until a response it returned",
	"Method": "void getUser(String userId,User user,ActionListener callback,User getUser,String userId){\r\n    NetworkEvent ne = (NetworkEvent) evt;\r\n    err.addElement(ne);\r\n    removeResponseCodeListener(this);\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.getUser",
	"Comment": "gets a user from a user idthis is a sync method it will block until a response it returned",
	"Method": "void getUser(String userId,User user,ActionListener callback,User getUser,String userId){\r\n    Vector v = (Vector) ((NetworkEvent) evt).getMetaData();\r\n    Hashtable t = (Hashtable) v.elementAt(0);\r\n    user.copy(t);\r\n}"
}, {
	"Path": "com.codename1.io.Log.print",
	"Comment": "default log implementation prints to the console and the file connectorif applicable. also prepends the thread information and time before",
	"Method": "void print(String text,int level){\r\n    if (!initialized) {\r\n        initialized = true;\r\n        try {\r\n            InputStream is = Display.getInstance().getResourceAsStream(getClass(), \"/cn1-version-numbers\");\r\n            if (is != null) {\r\n                print(\"Codename One revisions: \" + Util.readToString(is), INFO);\r\n            }\r\n        } catch (IOException err) {\r\n            err.printStackTrace();\r\n        }\r\n    }\r\n    if (this.level > level) {\r\n        return;\r\n    }\r\n    logDirty = true;\r\n    text = getThreadAndTimeStamp() + \" - \" + text;\r\n    Util.getImplementation().systemOut(text);\r\n    try {\r\n        synchronized (this) {\r\n            Writer w = getWriter();\r\n            w.write(text + \"\\n\");\r\n            w.flush();\r\n        }\r\n    } catch (Throwable err) {\r\n        err.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isBadgingSupported",
	"Comment": "returns true if the underlying os supports numeric badges on icons. notice this is only available on iosand only when push notification is enabled",
	"Method": "boolean isBadgingSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Image.applyMask",
	"Comment": "applies the given alpha mask onto this image and returns the resulting imagesee the createmask method for indication on how to convert an image into an alphamask.",
	"Method": "Image applyMask(Object mask,int x,int y,Image applyMask,Object mask){\r\n    int[] rgb = getRGB();\r\n    byte[] maskData = ((IndexedImage) mask).getImageDataByte();\r\n    int mWidth = ((IndexedImage) mask).getWidth();\r\n    int mHeight = ((IndexedImage) mask).getHeight();\r\n    if (mWidth != getWidth() || mHeight != getHeight()) {\r\n        throw new IllegalArgumentException(\"Mask and image sizes don't match\");\r\n    }\r\n    int mdlen = maskData.length;\r\n    for (int iter = 0; iter < mdlen; iter++) {\r\n        int maskAlpha = maskData[iter] & 0xff;\r\n        maskAlpha = (maskAlpha << 24) & 0xff000000;\r\n        rgb[iter] = (rgb[iter] & 0xffffff) | maskAlpha;\r\n    }\r\n    return createImage(rgb, mWidth, mHeight);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getInlinePressedStyles",
	"Comment": "gets inline styles that are to be applied to the pressed state of this component.",
	"Method": "String getInlinePressedStyles(){\r\n    return this.inlinePressedStyles;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setBlockLead",
	"Comment": "prevent a lead component hierarchy from this specific component, this allows a component within thathierarchy to still act as a standalone component",
	"Method": "void setBlockLead(boolean blockLead){\r\n    this.blockLead = blockLead;\r\n    if (blockLead) {\r\n        hasLead = false;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.FileEncodedImageAsync.create",
	"Comment": "creates an encoded image that maps to a local file thus allowing toseamlessly fetch files as needed. this only works reasonably well for very smallfiles.",
	"Method": "FileEncodedImageAsync create(String fileName,byte[] placeholder,int width,int height,FileEncodedImageAsync create,String fileName,Image placeholder){\r\n    return new FileEncodedImageAsync(fileName, placeholder);\r\n}"
}, {
	"Path": "com.codename1.io.NetworkEvent.getResponseCode",
	"Comment": "indicates the response code sent by the response code listener",
	"Method": "int getResponseCode(){\r\n    return progressType;\r\n}"
}, {
	"Path": "com.codename1.ui.Command.isDisposesDialog",
	"Comment": "indicates whether this command causes the dialog to dispose implicitly, defaults to true",
	"Method": "boolean isDisposesDialog(){\r\n    return disposesDialog;\r\n}"
}, {
	"Path": "com.codename1.designer.ThemeEditor.getCurrentStyleModel",
	"Comment": "returns the currently editable table model on the tabbed pane selection",
	"Method": "ThemeModel getCurrentStyleModel(){\r\n    return (ThemeModel) getCurrentStyleTable().getModel();\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setPreferredSize",
	"Comment": "sets the component preferred size, there is no guarantee the component will be sized at its preferred size. the final size of the component may besmaller than its preferred size or even larger than the size.the layout manager can take this value into consideration, but there isno guarantee or requirement.",
	"Method": "void setPreferredSize(Dimension d){\r\n    if (d == null) {\r\n        sizeRequestedByUser = false;\r\n        preferredSize = null;\r\n        shouldCalcPreferredSize = true;\r\n        return;\r\n    }\r\n    Dimension dim = preferredSize();\r\n    dim.setWidth(d.getWidth());\r\n    dim.setHeight(d.getHeight());\r\n    sizeRequestedByUser = true;\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyIndex.asElement",
	"Comment": "returns an element object mapping to the current object hierarchy similarto the map object",
	"Method": "Element asElement(){\r\n    return new PropertyXMLElement(this);\r\n}"
}, {
	"Path": "com.codename1.designer.ThemeEditor.getCurrentStyleTable",
	"Comment": "returns the currently editable table based on the tabbed pane selection",
	"Method": "EditorTable getCurrentStyleTable(){\r\n    JScrollPane scroll = (JScrollPane) stylesTabbedPane.getSelectedComponent();\r\n    return (EditorTable) scroll.getViewport().getView();\r\n}"
}, {
	"Path": "com.codename1.ui.Form.setTransitionInAnimator",
	"Comment": "this property allows us to define a an animation that will draw the transition forentering this form. a transition is an animation that would occur when switching from one form to another.",
	"Method": "void setTransitionInAnimator(Transition transitionInAnimator){\r\n    this.transitionInAnimator = transitionInAnimator;\r\n}"
}, {
	"Path": "com.codename1.io.FileSystemStorage.getRoots",
	"Comment": "returns the filesystem roots from which the structure of the file systemcan be traversed",
	"Method": "String[] getRoots(){\r\n    return Util.getImplementation().listFilesystemRoots();\r\n}"
}, {
	"Path": "com.codename1.io.Storage.setNormalizeNames",
	"Comment": "indicates whether characters that are typically illegal in filesystems shouldbe sanitized and replaced with underscore",
	"Method": "void setNormalizeNames(boolean normalizeNames){\r\n    this.normalizeNames = normalizeNames;\r\n}"
}, {
	"Path": "com.codename1.ui.List.isIgnoreFocusComponentWhenUnfocused",
	"Comment": "indicates whether the list should not paint the focus component if the listitself has no focus.",
	"Method": "boolean isIgnoreFocusComponentWhenUnfocused(){\r\n    return ignoreFocusComponentWhenUnfocused;\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testEventsAfterLeaderKill",
	"Comment": "tests submitting a linearizable event that publishes to all sessions.",
	"Method": "void testEventsAfterLeaderKill(int nodes){\r\n    List<CopycatServer> servers = createServers(nodes);\r\n    CopycatClient client = createClient();\r\n    client.onEvent(\"test\", message -> {\r\n        threadAssertNotNull(message);\r\n        resume();\r\n    });\r\n    for (int i = 0; i < 10; i++) {\r\n        client.submit(new TestEvent(true)).thenAccept(result -> {\r\n            threadAssertNotNull(result);\r\n            resume();\r\n        });\r\n        await(30000, 2);\r\n    }\r\n    client.submit(new TestEvent(true)).thenAccept(result -> {\r\n        threadAssertNotNull(result);\r\n        resume();\r\n    });\r\n    CopycatServer leader = servers.stream().filter(s -> s.state() == CopycatServer.State.LEADER).findFirst().get();\r\n    leader.shutdown().get(10, TimeUnit.SECONDS);\r\n    await(30000, 2);\r\n    for (int i = 0; i < 10; i++) {\r\n        client.submit(new TestEvent(true)).thenAccept(result -> {\r\n            threadAssertNotNull(result);\r\n            resume();\r\n        });\r\n        await(30000, 2);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.compaction.MajorCompactionTask.isLive",
	"Comment": "returns a boolean value indicating whether the given index is release.",
	"Method": "boolean isLive(long index,Segment segment,OffsetPredicate predicate){\r\n    long offset = segment.offset(index);\r\n    return offset != -1 && predicate.test(offset);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.setCodenameOneGraphics",
	"Comment": "installs the codename one graphics object into the implementation",
	"Method": "void setCodenameOneGraphics(Graphics g){\r\n    codenameOneGraphics = g;\r\n}"
}, {
	"Path": "com.l2fprod.common.beans.BaseBeanInfo.getToolTipText",
	"Comment": "return a text describing the object. the text will be displayed in atooltip.",
	"Method": "String getToolTipText(Object value){\r\n    return getText(value);\r\n}"
}, {
	"Path": "com.codename1.testing.TestUtils.goBack",
	"Comment": "executes the back command for the current form, similarly to pressing the back button",
	"Method": "void goBack(){\r\n    if (verbose) {\r\n        log(\"goBack()\");\r\n    }\r\n    Form f = Display.getInstance().getCurrent();\r\n    Command c = f.getBackCommand();\r\n    assertBool(c != null, \"The current form doesn't have a back command at this moment! for form name \" + f.getName());\r\n    f.dispatchCommand(c, new ActionEvent(c, ActionEvent.Type.Command));\r\n    waitFor(20);\r\n}"
}, {
	"Path": "com.codename1.ui.util.EventDispatcher.fireDataChangeEvent",
	"Comment": "fires the event safely on the edt without risk of concurrency errors",
	"Method": "void fireDataChangeEvent(int index,int type){\r\n    if (listeners == null || listeners.size() == 0) {\r\n        return;\r\n    }\r\n    boolean isEdt = Display.getInstance().isEdt();\r\n    if (isEdt && listeners.size() == 1) {\r\n        DataChangedListener a = (DataChangedListener) listeners.get(0);\r\n        a.dataChanged(type, index);\r\n        return;\r\n    }\r\n    DataChangedListener[] array;\r\n    synchronized (this) {\r\n        array = new DataChangedListener[listeners.size()];\r\n        int alen = array.length;\r\n        for (int iter = 0; iter < alen; iter++) {\r\n            array[iter] = (DataChangedListener) listeners.get(iter);\r\n        }\r\n    }\r\n    if (isEdt) {\r\n        fireDataChangeSync(array, type, index);\r\n    } else {\r\n        dataChangeListenerArray = true;\r\n        Runnable cl = new CallbackClass(array, new int[] { type, index });\r\n        if (blocking) {\r\n            Display.getInstance().callSeriallyAndWait(cl);\r\n        } else {\r\n            Display.getInstance().callSerially(cl);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.setSuppressActionEvent",
	"Comment": "since the action event is triggered on the end of editing, and that may nothappen until a couple of edt cycles after the onfocus event, we want to be able to fire the action event in focus lost, and then suppress the normalaction event that would be fired on editing end.we use this flag tosuppress action events.",
	"Method": "void setSuppressActionEvent(boolean suppress){\r\n    suppressActionEvent = suppress;\r\n}"
}, {
	"Path": "java.lang.Character.isSurrogatePair",
	"Comment": "a test for determining if the char pair is a validsurrogate pair.",
	"Method": "boolean isSurrogatePair(char high,char low){\r\n    return (isHighSurrogate(high) && isLowSurrogate(low));\r\n}"
}, {
	"Path": "com.codename1.ui.list.FilterProxyListModel.check",
	"Comment": "checks whether the filter condition is matched, receives an uppercase version of the filter string to match against",
	"Method": "boolean check(Object o,String str){\r\n    if (o instanceof Map) {\r\n        Map h = (Map) o;\r\n        if (comp(h.get(\"name\"), str)) {\r\n            return true;\r\n        }\r\n    } else {\r\n        String element = o.toString();\r\n        if (startsWithMode) {\r\n            if (element.toUpperCase().startsWith(str)) {\r\n                return true;\r\n            }\r\n        } else {\r\n            if (element.toUpperCase().indexOf(str) > -1) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Command.setRolloverIcon",
	"Comment": "indicates the icon that is displayed on the button when the button is inrolled over state",
	"Method": "void setRolloverIcon(Image rolloverIcon){\r\n    this.rolloverIcon = rolloverIcon;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GridLayout.setFillLastRow",
	"Comment": "when set to true makes the grid layout fill the last row of the layoutentirely if the number of elements in that row is bigger.",
	"Method": "void setFillLastRow(boolean fillLastRow){\r\n    this.fillLastRow = fillLastRow;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.setDragStartPercentage",
	"Comment": "this method allows us to manipulate the drag started detection logic.if the pointer was dragged for more than this percentage of the display size itis safe to assume that a drag is in progress.",
	"Method": "void setDragStartPercentage(int dragStartPercentage){\r\n    getImplementation().setDragStartPercentage(dragStartPercentage);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GroupLayout.removeLayoutComponent",
	"Comment": "notification that a component has been removed fromthe parent container.you should not invoke this methoddirectly, instead invoke removecomponent on the parentcontainer.",
	"Method": "void removeLayoutComponent(Component component){\r\n    ComponentInfo info = (ComponentInfo) componentInfos.remove(component);\r\n    if (info != null) {\r\n        info.dispose();\r\n        springsChanged = true;\r\n        isValid = false;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.popNavigationStack",
	"Comment": "removes a navigation frame from the stack, this is useful in case youwant to go back to a form in the middle of the navigation stack.",
	"Method": "void popNavigationStack(){\r\n    if (baseFormNavigationStack != null && baseFormNavigationStack.size() > 0) {\r\n        baseFormNavigationStack.removeElementAt(baseFormNavigationStack.size() - 1);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.charts.transitions.XYValueSeriesTransition.getSeries",
	"Comment": "gets the series whose values are to be animated by this transition.",
	"Method": "XYValueSeries getSeries(){\r\n    return series;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isAltGraphKeyDown",
	"Comment": "checks if the altgraph key is currently down.only relevant for desktop ports.",
	"Method": "boolean isAltGraphKeyDown(){\r\n    return impl.isAltGraphKeyDown();\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isAnimation",
	"Comment": "animations should return true to allow the native image animation to update",
	"Method": "boolean isAnimation(Object nativeImage){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.addString",
	"Comment": "adds the given text to the container as a label or a link.the string given here does not need line breaking as this was calculated before in the calling method.",
	"Method": "Label addString(String str,int align){\r\n    Label lbl = null;\r\n    int color = textColor;\r\n    if ((curLine.getComponentCount() == 0) && (str.startsWith(\" \"))) {\r\n        str = str.substring(1);\r\n        if (str.length() == 0) {\r\n            return null;\r\n        }\r\n    }\r\n    if (link != null) {\r\n        lbl = new HTMLLink(str, link, this, mainLink, linkVisited);\r\n        color = linkColor;\r\n        if (linkVisited) {\r\n            color = COLOR_VISITED_LINKS;\r\n        }\r\n        lbl.getSelectedStyle().setFont(font.getFont());\r\n        ((HTMLLink) lbl).getPressedStyle().setFont(font.getFont());\r\n        if (mainLink == null) {\r\n            mainLink = (HTMLLink) lbl;\r\n        }\r\n        if (accesskey != '\\0') {\r\n            addAccessKey(accesskey, lbl, false);\r\n            accesskey = '\\0';\r\n        }\r\n        lbl.getSelectedStyle().setMargin(0, 0, 0, 0);\r\n        lbl.getSelectedStyle().setPadding(0, 0, 0, 0);\r\n        ((HTMLLink) lbl).getPressedStyle().setMargin(0, 0, 0, 0);\r\n        ((HTMLLink) lbl).getPressedStyle().setPadding(0, 0, 0, 0);\r\n        lbl.getSelectedStyle().setTextDecoration(textDecoration);\r\n        ((HTMLLink) lbl).getPressedStyle().setTextDecoration(textDecoration);\r\n    } else {\r\n        if (labelForID != null) {\r\n            lbl = new ForLabel(str, this, labelForID);\r\n            if (accesskey != '\\0') {\r\n                addAccessKey(accesskey, lbl, false);\r\n                accesskey = '\\0';\r\n            }\r\n            labelForID = null;\r\n        } else {\r\n            lbl = new Label(str);\r\n        }\r\n    }\r\n    lbl.getStyle().setMargin(0, 0, 0, 0);\r\n    lbl.getStyle().setPadding(0, 0, 0, 0);\r\n    if (superscript > 0) {\r\n        int margin = font.getHeight() * superscript / 2;\r\n        lbl.getStyle().setMargin(Component.BOTTOM, margin);\r\n        if (link != null) {\r\n            lbl.getSelectedStyle().setMargin(Component.BOTTOM, margin);\r\n            ((HTMLLink) lbl).getPressedStyle().setMargin(Component.BOTTOM, margin);\r\n        }\r\n        if (margin > maxSuperscript) {\r\n            maxSuperscript = margin;\r\n        }\r\n    } else if (superscript < 0) {\r\n        int margin = -font.getHeight() * superscript / 2;\r\n        lbl.getStyle().setMargin(Component.TOP, margin);\r\n        if (link != null) {\r\n            lbl.getSelectedStyle().setMargin(Component.TOP, margin);\r\n            ((HTMLLink) lbl).getPressedStyle().setMargin(Component.TOP, margin);\r\n        }\r\n    }\r\n    lbl.getUnselectedStyle().setFgColor(color);\r\n    lbl.getSelectedStyle().setFgColor(color);\r\n    lbl.getUnselectedStyle().setFont(font.getFont());\r\n    lbl.getUnselectedStyle().setBgTransparency(0);\r\n    lbl.setGap(0);\r\n    lbl.setTickerEnabled(false);\r\n    lbl.setEndsWith3Points(false);\r\n    lbl.getUnselectedStyle().setTextDecoration(textDecoration);\r\n    if (align != JUSTIFY) {\r\n        lbl.setAlignment(align);\r\n    }\r\n    curLine.addComponent(lbl);\r\n    if (anchor != null) {\r\n        anchors.put(anchor, lbl);\r\n    }\r\n    if (FIXED_WIDTH) {\r\n        if (align != Component.LEFT) {\r\n            if (align == JUSTIFY) {\r\n                Vector words = getWords(str, align, false);\r\n                if (words.size() > 1) {\r\n                    int spaceW = font.getFont().stringWidth(\" \");\r\n                    int spacesToAdd = (width - lbl.getPreferredW()) / spaceW;\r\n                    int spacesPerWord = spacesToAdd / (words.size() - 1);\r\n                    int addtlSpaces = spacesToAdd % (words.size() - 1);\r\n                    String newStr = (String) words.elementAt(0);\r\n                    for (int i = 1; i < words.size(); i++) {\r\n                        for (int j = 0; j < spacesPerWord; j++) {\r\n                            newStr += ' ';\r\n                        }\r\n                        if (i <= addtlSpaces) {\r\n                            newStr += ' ';\r\n                        }\r\n                        newStr += ' ' + (String) words.elementAt(i);\r\n                    }\r\n                    lbl.setText(newStr);\r\n                }\r\n            } else {\r\n                lbl.setPreferredW(width);\r\n            }\r\n            x = width;\r\n            newLine(align);\r\n        } else {\r\n            x += lbl.getPreferredW();\r\n        }\r\n    }\r\n    return lbl;\r\n}"
}, {
	"Path": "com.codename1.charts.models.XYSeries.getXYMap",
	"Comment": "returns the current values that are used for drawing the series.",
	"Method": "IndexXYMap<Double, Double> getXYMap(){\r\n    return mXY;\r\n}"
}, {
	"Path": "com.codename1.location.Location.createDistanceCompartor",
	"Comment": "creates a comparator for sorting locations in order of increasing distance from the currentlocation.",
	"Method": "Comparator<Location> createDistanceCompartor(){\r\n    return new Comparator<Location>() {\r\n        public int compare(Location o1, Location o2) {\r\n            double d1 = Location.this.getDistanceTo(o1);\r\n            double d2 = Location.this.getDistanceTo(o2);\r\n            return d1 < d2 ? -1 : d2 < d1 ? 1 : 0;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.codename1.location.Location.createDistanceCompartor",
	"Comment": "creates a comparator for sorting locations in order of increasing distance from the currentlocation.",
	"Method": "Comparator<Location> createDistanceCompartor(){\r\n    double d1 = Location.this.getDistanceTo(o1);\r\n    double d2 = Location.this.getDistanceTo(o2);\r\n    return d1 < d2 ? -1 : d2 < d1 ? 1 : 0;\r\n}"
}, {
	"Path": "com.codename1.components.OnOffSwitch.addActionListener",
	"Comment": "adds a listener to the switch which will cause an event to dispatch on click",
	"Method": "void addActionListener(ActionListener l){\r\n    dispatcher.addListener(l);\r\n}"
}, {
	"Path": "com.codename1.ui.events.ActionEvent.getDraggedComponent",
	"Comment": "set in the case of a drop listener, returns the component being dragged",
	"Method": "Component getDraggedComponent(){\r\n    return (Component) source;\r\n}"
}, {
	"Path": "com.codename1.ui.SwipeableContainer.openToRight",
	"Comment": "this method will open the top component to the right if there is a componentto expose on the left.",
	"Method": "void openToRight(){\r\n    if (open || openedToRight) {\r\n        return;\r\n    }\r\n    if (bottomLeftWrapper.getComponentCount() == 0) {\r\n        return;\r\n    }\r\n    Component bottom = bottomLeftWrapper.getComponentAt(0);\r\n    if (bottomRightWrapper.getComponentCount() > 0) {\r\n        bottomRightWrapper.setVisible(false);\r\n    }\r\n    bottomLeftWrapper.setVisible(true);\r\n    int topX = topWrapper.getX();\r\n    openCloseMotion = Motion.createSplineMotion(topX, bottom.getWidth(), 300);\r\n    getComponentForm().registerAnimated(this);\r\n    openCloseMotion.start();\r\n    openedToRight = true;\r\n    open = true;\r\n}"
}, {
	"Path": "io.prometheus.client.hibernate.HibernateStatisticsCollector.add",
	"Comment": "registers a hibernate sessionfactory with this collector.",
	"Method": "HibernateStatisticsCollector add(SessionFactory sessionFactory,String name){\r\n    sessionFactories.put(name, sessionFactory);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setSmoothScrolling",
	"Comment": "indicates that scrolling through the component should work as an animation",
	"Method": "void setSmoothScrolling(boolean smoothScrolling){\r\n    this.smoothScrolling = smoothScrolling;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.setFocusLead",
	"Comment": "recusively focuses components for the lead component functionality",
	"Method": "void setFocusLead(boolean f){\r\n    int count = getComponentCount();\r\n    for (int i = 0; i < count; i++) {\r\n        Component c = getComponentAt(i);\r\n        if (c instanceof Container) {\r\n            ((Container) c).setFocusLead(f);\r\n        }\r\n        c.setFocus(f);\r\n        if (f) {\r\n            c.fireFocusGained();\r\n        } else {\r\n            c.fireFocusLost();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.InfiniteProgress.isMaterialDesignMode",
	"Comment": "indicates whether this instance of infinite progress works in the materialdesign mode by default",
	"Method": "boolean isMaterialDesignMode(){\r\n    return materialDesignMode;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setNextFocusDown",
	"Comment": "allows us to determine which component will receive focus next when traversing with the down key",
	"Method": "void setNextFocusDown(Component nextFocusDown){\r\n    this.nextFocusDown = nextFocusDown;\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.resolveFunArgs",
	"Comment": "validates the arguments to a function and resolves the function.",
	"Method": "FunDef resolveFunArgs(Validator validator,FunDef funDef,Exp[] args,Exp[] newArgs,String name,Syntax syntax){\r\n    for (int i = 0; i < args.length; i++) {\r\n        newArgs[i] = validator.validate(args[i], false);\r\n    }\r\n    if (funDef == null || validator.alwaysResolveFunDef()) {\r\n        funDef = validator.getDef(newArgs, name, syntax);\r\n    }\r\n    checkNativeCompatible(validator, funDef, newArgs);\r\n    return funDef;\r\n}"
}, {
	"Path": "com.codename1.ui.Button.getRolloverPressedIcon",
	"Comment": "indicates the icon that is displayed on the button when the button is inpressed state and is selected. this is only applicable to toggle buttons",
	"Method": "Image getRolloverPressedIcon(){\r\n    return rolloverPressedIcon;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getInvisibleAreaUnderVKB",
	"Comment": "returns the area of this component that is currently hidden by the virtual keyboard.",
	"Method": "int getInvisibleAreaUnderVKB(){\r\n    Form f = getComponentForm();\r\n    if (f != null) {\r\n        int invisibleAreaUnderVKB = Form.getInvisibleAreaUnderVKB(f);\r\n        if (invisibleAreaUnderVKB == 0) {\r\n            return 0;\r\n        }\r\n        int bottomGap = f.getHeight() - getAbsoluteY() - getScrollY() - getHeight();\r\n        if (bottomGap < invisibleAreaUnderVKB) {\r\n            return invisibleAreaUnderVKB - bottomGap;\r\n        } else {\r\n            return 0;\r\n        }\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.l2fprod.common.swing.PercentLayout.getLayoutAlignmentX",
	"Comment": "returns the alignment along the x axis. this specifies how the componentwould like to be aligned relative to other components. the value should bea number between 0 and 1 where 0 represents alignment along the origin, 1is aligned the furthest away from the origin, 0.5 is centered, etc.",
	"Method": "float getLayoutAlignmentX(Container target){\r\n    return 1.0f / 2.0f;\r\n}"
}, {
	"Path": "com.codename1.io.CacheMap.getCachePrefix",
	"Comment": "a prefix prepended to storage entries to differentiate them",
	"Method": "String getCachePrefix(){\r\n    return cachePrefix;\r\n}"
}, {
	"Path": "com.codename1.io.rest.RequestBuilder.getAsJsonMap",
	"Comment": "executes the request asynchronously and writes the response to the providedcallback",
	"Method": "ConnectionRequest getAsJsonMap(SuccessCallback<Response<Map>> callback,ConnectionRequest getAsJsonMap,SuccessCallback<Response<Map>> callback,FailureCallback<? extends Object> onError,Response<Map> getAsJsonMap){\r\n    ConnectionRequest request = createRequest(true);\r\n    CN.addToQueueAndWait(request);\r\n    Map response = ((Connection) request).json;\r\n    return new Response(request.getResponseCode(), response, request.getResponseErrorMessage());\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.compaction.Compactor.snapshotIndex",
	"Comment": "returns the maximum index up to which snapshotted commands can be removed during compaction.",
	"Method": "Compactor snapshotIndex(long index,long snapshotIndex){\r\n    return snapshotIndex;\r\n}"
}, {
	"Path": "org.conscrypt.EngineWrapBenchmark.wrapAndUnwrap",
	"Comment": "simple benchmark that sends a single message from client to server.",
	"Method": "void wrapAndUnwrap(){\r\n    messageBuffer.position(0);\r\n    clientPacketBuffer.clear();\r\n    serverApplicationBuffer.clear();\r\n    doWrap(messageBuffer, clientPacketBuffer);\r\n    doUnwrap(clientPacketBuffer, serverApplicationBuffer);\r\n    assertEquals(messageBuffer.limit(), serverApplicationBuffer.limit());\r\n}"
}, {
	"Path": "com.codename1.ui.Display.dismissNotification",
	"Comment": "removes the notification previously posted with the notify status bar method",
	"Method": "void dismissNotification(Object o){\r\n    impl.dismissNotification(o);\r\n}"
}, {
	"Path": "com.l2fprod.common.swing.PercentLayout.getLayoutAlignmentY",
	"Comment": "returns the alignment along the y axis. this specifies how the componentwould like to be aligned relative to other components. the value should bea number between 0 and 1 where 0 represents alignment along the origin, 1is aligned the furthest away from the origin, 0.5 is centered, etc.",
	"Method": "float getLayoutAlignmentY(Container target){\r\n    return 1.0f / 2.0f;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.repaint",
	"Comment": "causes the given component to repaint, used internally by form",
	"Method": "void repaint(Animation cmp){\r\n    impl.repaint(cmp);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.elementAt",
	"Comment": "returns the element at the specified location in this vector.",
	"Method": "E elementAt(int location){\r\n    if (location < elementCount) {\r\n        return (E) elementData[location];\r\n    }\r\n    throw new ArrayIndexOutOfBoundsException(location);\r\n}"
}, {
	"Path": "com.l2fprod.common.swing.plaf.basic.BasicOutlookBarUI.createMouseListener",
	"Comment": "overriden to return an empty adapter, the default listener wasjust implementing the tab selection mechanism",
	"Method": "MouseListener createMouseListener(){\r\n    return new MouseAdapter() {\r\n    };\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setSameHeight",
	"Comment": "places all of these components in the same height group, to remove a component fromthe group invoke this method with that component only.",
	"Method": "void setSameHeight(Component c){\r\n    if (c.length == 1) {\r\n        if (c[0].sameHeight != null) {\r\n            ArrayList<Component> lst = new ArrayList<Component>(Arrays.asList(c[0].sameHeight));\r\n            lst.remove(c[0]);\r\n            if (lst.size() == 1) {\r\n                lst.get(0).sameHeight = null;\r\n            } else {\r\n                if (lst.size() > 0) {\r\n                    Component[] cmps = new Component[lst.size()];\r\n                    lst.toArray(cmps);\r\n                    setSameHeight(cmps);\r\n                }\r\n            }\r\n            c[0].sameHeight = null;\r\n        }\r\n    } else {\r\n        for (Component cc : c) {\r\n            cc.sameHeight = c;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setRippleEffect",
	"Comment": "indicates whether the component displays the material design ripple effect",
	"Method": "void setRippleEffect(boolean rippleEffect){\r\n    this.rippleEffect = rippleEffect;\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.Picker.setPreferredPopupWidth",
	"Comment": "the preferred width of the popup dialog for the picker.this will only be used on devices where the popup width and height are configurable, such as the ipad or tablets.on iphone, the picker always spans the width of the screen along the bottom.",
	"Method": "void setPreferredPopupWidth(int width){\r\n    this.preferredPopupWidth = width;\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AbstractQuerySpec.isOrdered",
	"Comment": "whether to add an order by clause to make results deterministic.necessary if query returns more than one row and results are forhuman consumption.",
	"Method": "boolean isOrdered(){\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.lang.Character_.codePointCount",
	"Comment": "counts the number of unicode code points in the subsequence of thecharsequence, as delineated by thebeginindex and endindex. any surrogatevalues with missing pair values will be counted as 1 code point.",
	"Method": "int codePointCount(net.sourceforge.retroweaver.harmony.runtime.java.lang.CharSequence seq,int beginIndex,int endIndex,int codePointCount,char[] seq,int offset,int count){\r\n    if (seq == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    int len = seq.length;\r\n    int endIndex = offset + count;\r\n    if (offset < 0 || count < 0 || endIndex > len) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    int result = 0;\r\n    for (int i = offset; i < endIndex; i++) {\r\n        char c = seq[i];\r\n        if (isHighSurrogate(c)) {\r\n            if (++i < endIndex) {\r\n                c = seq[i];\r\n                if (!isLowSurrogate(c)) {\r\n                    result++;\r\n                }\r\n            }\r\n        }\r\n        result++;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.codename1.ui.Font.isCreationByStringSupported",
	"Comment": "returns true if the underlying platform allows creating a font based on auser submitted string.",
	"Method": "boolean isCreationByStringSupported(){\r\n    return Display.impl.isLookupFontSupported();\r\n}"
}, {
	"Path": "com.codename1.ui.Component.hasInlinePressedStyle",
	"Comment": "checks to see if the component has any inline styles registered for its pressed state.",
	"Method": "boolean hasInlinePressedStyle(){\r\n    return getInlineStylesTheme() != null && (inlineAllStyles != null || inlinePressedStyles != null);\r\n}"
}, {
	"Path": "com.codename1.ui.Toolbar.showOverflowMenu",
	"Comment": "a overflow menu is implemented as a dialog, this method allows you to override the dialog display in order to customize the dialog menu in various ways",
	"Method": "Command showOverflowMenu(Dialog menu){\r\n    Form parent = sideMenu.getParentForm();\r\n    int height;\r\n    int marginLeft;\r\n    int marginRight = 0;\r\n    Container dialogContentPane = menu.getDialogComponent();\r\n    marginLeft = parent.getWidth() - (dialogContentPane.getPreferredW() + menu.getStyle().getHorizontalPadding());\r\n    marginLeft = Math.max(0, marginLeft);\r\n    if (parent.getSoftButtonCount() > 1) {\r\n        height = parent.getHeight() - parent.getSoftButton(0).getParent().getPreferredH() - dialogContentPane.getPreferredH();\r\n    } else {\r\n        height = parent.getHeight() - dialogContentPane.getPreferredH();\r\n    }\r\n    height = Math.max(0, height);\r\n    int th = getHeight();\r\n    Transition transitionIn;\r\n    Transition transitionOut;\r\n    UIManager manager = parent.getUIManager();\r\n    LookAndFeel lf = manager.getLookAndFeel();\r\n    if (lf.getDefaultMenuTransitionIn() != null || lf.getDefaultMenuTransitionOut() != null) {\r\n        transitionIn = lf.getDefaultMenuTransitionIn();\r\n        if (transitionIn instanceof BubbleTransition) {\r\n            ((BubbleTransition) transitionIn).setComponentName(\"OverflowButton\");\r\n        }\r\n        transitionOut = lf.getDefaultMenuTransitionOut();\r\n    } else {\r\n        transitionIn = CommonTransitions.createEmpty();\r\n        transitionOut = CommonTransitions.createEmpty();\r\n    }\r\n    menu.setTransitionInAnimator(transitionIn);\r\n    menu.setTransitionOutAnimator(transitionOut);\r\n    if (isRTL()) {\r\n        marginRight = marginLeft;\r\n        marginLeft = 0;\r\n    }\r\n    int tint = parent.getTintColor();\r\n    parent.setTintColor(0x00FFFFFF);\r\n    parent.tint = false;\r\n    boolean showBelowTitle = manager.isThemeConstant(\"showMenuBelowTitleBool\", true);\r\n    int topPadding = 0;\r\n    Component statusBar = ((BorderLayout) getLayout()).getNorth();\r\n    if (statusBar != null) {\r\n        topPadding = statusBar.getAbsoluteY() + statusBar.getHeight();\r\n    }\r\n    if (showBelowTitle) {\r\n        topPadding = th;\r\n    }\r\n    Command r = menu.show(topPadding, Math.max(topPadding, height - topPadding), marginLeft, marginRight, true);\r\n    parent.setTintColor(tint);\r\n    return r;\r\n}"
}, {
	"Path": "org.conscrypt.java.security.TestKeyStore.getPrivateKey",
	"Comment": "return the only private key in a testkeystore for the givenalgorithms. throws illegalstateexception if there are are moreor less than one.",
	"Method": "PrivateKeyEntry getPrivateKey(String keyAlgorithm,String signatureAlgorithm){\r\n    return privateKey(keyStore, keyPassword, keyAlgorithm, signatureAlgorithm);\r\n}"
}, {
	"Path": "com.codename1.ui.Form.getPreviousForm",
	"Comment": "allows the display to skip the menu dialog if that is the current form",
	"Method": "Form getPreviousForm(){\r\n    return previousForm;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.FollowerStateTest.testFollowerOverridesVoteForNewTerm",
	"Comment": "tests that a follower overrides a vote from a previous term when the term increases.",
	"Method": "void testFollowerOverridesVoteForNewTerm(){\r\n    runOnServer(() -> {\r\n        serverContext.setTerm(2).setLeader(0);\r\n        VoteRequest request1 = VoteRequest.builder().withTerm(2).withCandidate(members.get(1).hashCode()).withLogIndex(0).withLogTerm(0).build();\r\n        VoteResponse response1 = state.vote(request1).get();\r\n        threadAssertEquals(serverContext.getTerm(), 2L);\r\n        threadAssertEquals(serverContext.getLastVotedFor(), members.get(1).hashCode());\r\n        threadAssertEquals(response1.term(), 2L);\r\n        threadAssertTrue(response1.voted());\r\n        VoteRequest request2 = VoteRequest.builder().withTerm(3).withCandidate(members.get(2).hashCode()).withLogIndex(0).withLogTerm(0).build();\r\n        VoteResponse response2 = state.vote(request2).get();\r\n        threadAssertEquals(serverContext.getTerm(), 3L);\r\n        threadAssertEquals(serverContext.getLastVotedFor(), members.get(2).hashCode());\r\n        threadAssertEquals(response2.term(), 3L);\r\n        threadAssertTrue(response2.voted());\r\n    });\r\n}"
}, {
	"Path": "io.prometheus.client.guava.cache.CacheMetricsCollector.clear",
	"Comment": "remove all caches.any references to all caches are invalidated.",
	"Method": "void clear(){\r\n    children.clear();\r\n}"
}, {
	"Path": "com.codename1.processing.Result.get",
	"Comment": "get the object value from the requested path. this method may return amap, list, string, or null.",
	"Method": "Object get(String path){\r\n    Object o = _internalGet(path);\r\n    if (o instanceof StructuredContent) {\r\n        return ((StructuredContent) o).getNativeRoot();\r\n    }\r\n    return o;\r\n}"
}, {
	"Path": "java.lang.Thread.currentThread",
	"Comment": "returns a reference to the currently executing thread object.",
	"Method": "java.lang.Thread currentThread(){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.components.ButtonList.removeActionListener",
	"Comment": "remove a listener so that it no longer is notified when buttons in the list are pressed.",
	"Method": "void removeActionListener(ActionListener l){\r\n    actionListeners.removeListener(l);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.growPrio",
	"Comment": "grow priority for the component horizontally and optionally vertically.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC growPrio(int widthHeight){\r\n    switch(widthHeight.length) {\r\n        default:\r\n            throw new IllegalArgumentException(\"Illegal argument count: \" + widthHeight.length);\r\n        case 2:\r\n            growPrioY(widthHeight[1]);\r\n        case 1:\r\n            growPrioX(widthHeight[0]);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.util.TPrimality.consBigInteger",
	"Comment": "a random number is generated until a probable prime number is found.",
	"Method": "TBigInteger consBigInteger(int bitLength,int certainty,Random rnd){\r\n    if (bitLength <= 10) {\r\n        int[] rp = offsetPrimes[bitLength];\r\n        return BIprimes[rp[0] + rnd.nextInt(rp[1])];\r\n    }\r\n    int shiftCount = (-bitLength) & 31;\r\n    int last = (bitLength + 31) >> 5;\r\n    TBigInteger n = new TBigInteger(1, last, new int[last]);\r\n    last--;\r\n    do {\r\n        for (int i = 0; i < n.numberLength; i++) {\r\n            n.digits[i] = rnd.nextInt();\r\n        }\r\n        n.digits[last] |= 0x80000000;\r\n        n.digits[last] >>>= shiftCount;\r\n        n.digits[0] |= 1;\r\n    } while (!isProbablePrime(n, certainty));\r\n    return n;\r\n}"
}, {
	"Path": "org.conscrypt.java.security.cert.CertificateFactoryTest.generatePublicKeyDigest",
	"Comment": "generates a type 1 key identifier according to rfc 3280 4.2.1.2.",
	"Method": "byte[] generatePublicKeyDigest(PublicKey pubKey){\r\n    SubjectPublicKeyInfo spki = SubjectPublicKeyInfo.getInstance(pubKey.getEncoded());\r\n    MessageDigest sha1digest;\r\n    try {\r\n        sha1digest = MessageDigest.getInstance(\"SHA-1\");\r\n    } catch (NoSuchAlgorithmException e) {\r\n        throw new RuntimeException(\"SHA-1 not available\");\r\n    }\r\n    return sha1digest.digest(spki.getPublicKeyData().getBytes());\r\n}"
}, {
	"Path": "com.codename1.ui.Component.isHideInLandscape",
	"Comment": "indicates that this component and all its children should be hidden when the device is switched to landscape mode",
	"Method": "boolean isHideInLandscape(){\r\n    return hideInLandscape;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.processTag",
	"Comment": "processes the given tag. this is the main processing method that calls all others and uses itself in a recursive manner.",
	"Method": "void processTag(HTMLElement element,int align){\r\n    if ((cancelled) && (!cancelledCaught)) {\r\n        return;\r\n    }\r\n    int curAlign = align;\r\n    HTMLFont oldFont = font;\r\n    int oldFontColor = textColor;\r\n    for (int i = 0; i < element.getNumChildren(); i++) {\r\n        if ((cancelled) && (!cancelledCaught)) {\r\n            break;\r\n        }\r\n        HTMLElement child = (HTMLElement) element.getChildAt(i);\r\n        switch(child.getTagId()) {\r\n            case HTMLElement.TAG_TEXT:\r\n                String text = child.getText();\r\n                if ((curComboBox != null) && (optionTag)) {\r\n                    OptionItem oi = new OptionItem(text, optionValue);\r\n                    curComboBox.addItem(oi);\r\n                    if (optionSelected) {\r\n                        curComboBox.setSelectedItem(oi);\r\n                        if (curForm != null) {\r\n                            curForm.setDefaultValue(curComboBox, oi);\r\n                        }\r\n                    }\r\n                } else if (curTextArea != null) {\r\n                    curTextArea.setText(text);\r\n                    if (curForm != null) {\r\n                        curForm.setDefaultValue(curTextArea, text);\r\n                    }\r\n                } else if (element.getTagId() == HTMLElement.TAG_LEGEND) {\r\n                    if (fieldsets.size() > 0) {\r\n                        Container fset = (Container) fieldsets.lastElement();\r\n                        fset.getStyle().setBorder(Border.createLineBorder(1, text));\r\n                        fset.getStyle().setPadding(Component.TOP, fset.getStyle().getFont().getHeight() + 1);\r\n                    }\r\n                } else if ((curTable != null) && (element.getTagId() == HTMLElement.TAG_CAPTION)) {\r\n                    curTable.captionTextTag = child;\r\n                } else {\r\n                    Vector comps = null;\r\n                    if (preTagCount != 0) {\r\n                        comps = showPreTagText(text, curAlign);\r\n                    } else {\r\n                        if (FIXED_WIDTH) {\r\n                            comps = showTextFixedWidth(text, curAlign);\r\n                        } else {\r\n                            comps = showText(text, curAlign);\r\n                        }\r\n                    }\r\n                    if (loadCSS) {\r\n                        child.setAssociatedComponents(comps);\r\n                    }\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_A:\r\n                link = child.getAttributeById(HTMLElement.ATTR_HREF);\r\n                if ((link != null) && (docInfo == null) && (!DocumentInfo.isAbsoluteURL(link))) {\r\n                    if (htmlCallback != null) {\r\n                        htmlCallback.parsingError(HTMLCallback.ERROR_NO_BASE_URL, child.getTagName(), child.getAttributeName(new Integer(HTMLElement.ATTR_HREF)), link, \"Disabling relative link (\" + link + \"), since page was set by setBody/setHTML/setDOM so there's no way to access relative URLs\");\r\n                    }\r\n                    link = null;\r\n                }\r\n                if ((link != null) && (htmlCallback != null)) {\r\n                    int linkProps = htmlCallback.getLinkProperties(this, convertURL(link));\r\n                    if ((linkProps & HTMLCallback.LINK_FORBIDDEN) != 0) {\r\n                        link = null;\r\n                    } else if ((linkProps & HTMLCallback.LINK_VISTED) != 0) {\r\n                        linkVisited = true;\r\n                    }\r\n                }\r\n                anchor = child.getAttributeById(HTMLElement.ATTR_NAME);\r\n                if (link != null) {\r\n                    String aKey = child.getAttributeById(HTMLElement.ATTR_ACCESSKEY);\r\n                    if ((aKey != null) && (aKey.length() == 1)) {\r\n                        accesskey = aKey.charAt(0);\r\n                    }\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_H1:\r\n            case HTMLElement.TAG_H2:\r\n            case HTMLElement.TAG_H3:\r\n            case HTMLElement.TAG_H4:\r\n            case HTMLElement.TAG_H5:\r\n            case HTMLElement.TAG_H6:\r\n                font = (HTMLFont) fonts.get(child.getTagName());\r\n                if (font == null) {\r\n                    font = oldFont;\r\n                }\r\n            case HTMLElement.TAG_P:\r\n                curAlign = getHorizAlign(child.getAttributeById(HTMLElement.ATTR_ALIGN), align, true);\r\n                adjustAlignment(align, curAlign);\r\n                newLineIfNotEmpty(curAlign);\r\n                newLineIfLastWasNotEmpty(curAlign);\r\n                pushContainer(child);\r\n                break;\r\n            case HTMLElement.TAG_DIV:\r\n            case HTMLElement.TAG_CENTER:\r\n                curAlign = child.getTagId() == HTMLElement.TAG_DIV ? getHorizAlign(child.getAttributeById(HTMLElement.ATTR_ALIGN), align, true) : Component.CENTER;\r\n                adjustAlignment(align, curAlign);\r\n                newLineIfNotEmpty(curAlign);\r\n                pushContainer(child);\r\n                break;\r\n            case HTMLElement.TAG_FIELDSET:\r\n                newLineIfNotEmpty(curAlign);\r\n                Container newCont = new Container();\r\n                newCont.setUIID(\"HTMLFieldset\");\r\n                if (fieldsets.size() == 0) {\r\n                    newCont.getStyle().setMargin(Component.LEFT, 0);\r\n                }\r\n                newCont.setLayout(new BoxLayout(BoxLayout.Y_AXIS));\r\n                curContainer.addComponent(newCont);\r\n                fieldsets.addElement(newCont);\r\n                curContainer = newCont;\r\n                if (loadCSS) {\r\n                    child.setAssociatedComponents(newCont);\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_BR:\r\n                if (loadCSS) {\r\n                    child.setAssociatedComponents(curLine);\r\n                }\r\n                newLine(curAlign);\r\n                break;\r\n            case HTMLElement.TAG_DL:\r\n                newLineIfNotEmpty(curAlign);\r\n                newLine(curAlign);\r\n                pushContainer(child);\r\n                break;\r\n            case HTMLElement.TAG_DT:\r\n                newLineIfNotEmpty(curAlign);\r\n                pushContainer(child);\r\n                break;\r\n            case HTMLElement.TAG_UL:\r\n            case HTMLElement.TAG_DIR:\r\n            case HTMLElement.TAG_MENU:\r\n                newLineIfNotEmpty(curAlign);\r\n                ulLevel++;\r\n                listIndent += INDENT_UL;\r\n                if ((ulLevel == 1) && (olIndex == Integer.MIN_VALUE)) {\r\n                    newLine(curAlign);\r\n                } else {\r\n                    listIndent += INDENT_UL;\r\n                }\r\n                pushContainer(child);\r\n                break;\r\n            case HTMLElement.TAG_OL:\r\n                newLineIfNotEmpty(curAlign);\r\n                if (olIndex != Integer.MIN_VALUE) {\r\n                    String indexStr = ORDERED_LIST_TYPE_IDENTIFIERS[listType] + \"\" + olIndex;\r\n                    olUpperLevelIndex.addElement(indexStr);\r\n                }\r\n                olIndex = getInt(child.getAttributeById(HTMLElement.ATTR_START), 1);\r\n                listType = getOrderedListType(child);\r\n                if ((olUpperLevelIndex.size() == 0) && (ulLevel == 0)) {\r\n                    newLine(curAlign);\r\n                } else {\r\n                    listIndent += INDENT_OL;\r\n                }\r\n                pushContainer(child);\r\n                break;\r\n            case HTMLElement.TAG_LI:\r\n                Container listItemCont = new Container(new BorderLayout());\r\n                listItemCont.getStyle().setMargin(Component.LEFT, leftIndent + listIndent);\r\n                curContainer.addComponent(listItemCont);\r\n                containers.addElement(curContainer);\r\n                HTMLListItem bullet = null;\r\n                if (((HTMLElement) child.getParent()).getTagId() == HTMLElement.TAG_OL) {\r\n                    olIndex = getInt(child.getAttributeById(HTMLElement.ATTR_VALUE), olIndex);\r\n                    int itemListType = getOrderedListType(child, listType);\r\n                    HTMLListIndex listIndex = new HTMLListIndex(olIndex, itemListType);\r\n                    listIndex.getUnselectedStyle().setFgColor(textColor);\r\n                    listIndex.getSelectedStyle().setFgColor(textColor);\r\n                    listIndex.getUnselectedStyle().setFont(font.getFont());\r\n                    bullet = listIndex;\r\n                    bullet.getUnselectedStyle().setAlignment(Component.RIGHT);\r\n                    bullet.setPreferredW(font.getFont().stringWidth(\"8888. \"));\r\n                } else {\r\n                    bullet = new HTMLBullet(getUnorderedListType(child, ulLevel), font.getFont().getHeight(), textColor, this);\r\n                }\r\n                Container bulletCont = new Container(new BorderLayout());\r\n                bulletCont.addComponent(BorderLayout.NORTH, bullet);\r\n                listItemCont.addComponent(BorderLayout.WEST, bulletCont);\r\n                Container listItemText = new Container(new BoxLayout(BoxLayout.Y_AXIS));\r\n                listItemCont.addComponent(BorderLayout.CENTER, listItemText);\r\n                curContainer = listItemText;\r\n                if (loadCSS) {\r\n                    child.setAssociatedComponents(listItemText);\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_BLOCKQUOTE:\r\n                newLineIfNotEmpty(curAlign);\r\n                updateMargin(INDENT_BLOCKQUOTE);\r\n                newLine(curAlign);\r\n                pushContainer(child);\r\n                break;\r\n            case HTMLElement.TAG_DD:\r\n                newLineIfNotEmpty(curAlign);\r\n                updateMargin(INDENT_DD);\r\n                pushContainer(child);\r\n                break;\r\n            case HTMLElement.TAG_HR:\r\n                newLineIfNotEmpty(curAlign);\r\n                Label hr = new Label();\r\n                hr.setUIID(\"HTMLHR\");\r\n                int hrWidth = calcSize(width, child.getAttributeById(HTMLElement.ATTR_WIDTH), width, false);\r\n                int hrHeight = getInt(child.getAttributeById(HTMLElement.ATTR_SIZE), HR_THICKNESS);\r\n                hr.setPreferredW(hrWidth);\r\n                hr.setPreferredH(hrHeight);\r\n                curLine.addComponent(hr);\r\n                newLine(curAlign);\r\n                if (loadCSS) {\r\n                    child.setAssociatedComponents(hr);\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_STYLE:\r\n                break;\r\n            case HTMLElement.TAG_IMG:\r\n                handleImage(child, curAlign, null);\r\n                break;\r\n            case HTMLElement.TAG_PRE:\r\n                preTagCount++;\r\n                pushContainer(child);\r\n            case HTMLElement.TAG_EM:\r\n            case HTMLElement.TAG_STRONG:\r\n            case HTMLElement.TAG_DFN:\r\n            case HTMLElement.TAG_CODE:\r\n            case HTMLElement.TAG_SAMP:\r\n            case HTMLElement.TAG_KBD:\r\n            case HTMLElement.TAG_VAR:\r\n            case HTMLElement.TAG_CITE:\r\n            case HTMLElement.TAG_TT:\r\n                font = (HTMLFont) fonts.get(child.getTagName());\r\n                if (font == null) {\r\n                    font = oldFont;\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_B:\r\n            case HTMLElement.TAG_I:\r\n            case HTMLElement.TAG_BIG:\r\n            case HTMLElement.TAG_SMALL:\r\n                font = getCounterpartFont(child.getTagId(), font);\r\n                break;\r\n            case HTMLElement.TAG_FORM:\r\n                curForm = new HTMLForm(this, child.getAttributeById(HTMLElement.ATTR_ACTION), child.getAttributeById(HTMLElement.ATTR_METHOD), child.getAttributeById(HTMLElement.ATTR_ENCTYPE));\r\n                pushContainer(child);\r\n                break;\r\n            case HTMLElement.TAG_BUTTON:\r\n                handleInput(child, curAlign);\r\n                break;\r\n            case HTMLElement.TAG_INPUT:\r\n                handleInput(child, curAlign);\r\n                break;\r\n            case HTMLElement.TAG_SELECT:\r\n                String multi = child.getAttributeById(HTMLElement.ATTR_MULTIPLE);\r\n                if ((multi != null) || (child.getAttributeById(HTMLElement.ATTR_SIZE) != null)) {\r\n                    curComboBox = new MultiComboBox(multi != null);\r\n                    Container comboCont = new Container(new BorderLayout());\r\n                    curComboBox.setItemGap(0);\r\n                    comboCont.setUIID(\"ComboBox\");\r\n                    curComboBox.setUIID(\"List\");\r\n                    comboCont.addComponent(BorderLayout.CENTER, curComboBox);\r\n                } else {\r\n                    curComboBox = new HTMLComboBox();\r\n                }\r\n                String name = child.getAttributeById(HTMLElement.ATTR_NAME);\r\n                if (curForm != null) {\r\n                    curForm.addInput(name, curComboBox, null);\r\n                }\r\n                child.setAssociatedComponents(curComboBox);\r\n                if (eventsListener != null) {\r\n                    eventsListener.registerComponent(curComboBox, child);\r\n                }\r\n                if ((!PROCESS_HTML_MP1_ONLY) && (child.getAttributeById(HTMLElement.ATTR_DISABLED) != null)) {\r\n                    curComboBox.setEnabled(false);\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_OPTGROUP:\r\n                if (curComboBox != null) {\r\n                    String label = child.getAttributeById(HTMLElement.ATTR_LABEL);\r\n                    if (label != null) {\r\n                        curComboBox.addItem(label);\r\n                    }\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_OPTION:\r\n                optionTag = true;\r\n                optionValue = child.getAttributeById(HTMLElement.ATTR_VALUE);\r\n                if ((curComboBox != null) && (child.getAttributeById(HTMLElement.ATTR_SELECTED) != null)) {\r\n                    optionSelected = true;\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_TEXTAREA:\r\n                curTextArea = new TextArea(getInt(child.getAttributeById(HTMLElement.ATTR_ROWS), DEFAULT_TEXTAREA_ROWS), getInt(child.getAttributeById(HTMLElement.ATTR_COLS), DEFAULT_TEXTAREA_COLS));\r\n                if (!PROCESS_HTML_MP1_ONLY) {\r\n                    if (child.getAttributeById(HTMLElement.ATTR_DISABLED) != null) {\r\n                        curTextArea.setEnabled(false);\r\n                    }\r\n                    if (child.getAttributeById(HTMLElement.ATTR_READONLY) != null) {\r\n                        curTextArea.setEditable(false);\r\n                    }\r\n                }\r\n                addCmp(curTextArea, curAlign);\r\n                if (eventsListener != null) {\r\n                    eventsListener.registerComponent(curTextArea, child);\r\n                }\r\n                child.setAssociatedComponents(curTextArea);\r\n                String aKey = element.getAttributeById(HTMLElement.ATTR_ACCESSKEY);\r\n                if ((aKey != null) && (aKey.length() == 1)) {\r\n                    addAccessKey(aKey.charAt(0), curTextArea, false);\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_Q:\r\n                addQuote(child, curAlign, true);\r\n                quoteTagCount++;\r\n                break;\r\n            case HTMLElement.TAG_TABLE:\r\n                newLineIfNotEmpty(curAlign);\r\n                if (curTable != null) {\r\n                    tables.addElement(curTable);\r\n                    HTMLTableModel newTable = new HTMLTableModel();\r\n                    curTable = newTable;\r\n                } else {\r\n                    curTable = new HTMLTableModel();\r\n                }\r\n                width = width / 2;\r\n                break;\r\n            case HTMLElement.TAG_TR:\r\n                break;\r\n            case HTMLElement.TAG_TH:\r\n            case HTMLElement.TAG_TD:\r\n                if (curTable != null) {\r\n                    handleTableCell(child, curAlign);\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_LABEL:\r\n                labelForID = child.getAttributeById(HTMLElement.ATTR_FOR);\r\n                aKey = child.getAttributeById(HTMLElement.ATTR_ACCESSKEY);\r\n                if ((aKey != null) && (aKey.length() == 1)) {\r\n                    accesskey = aKey.charAt(0);\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_FONT:\r\n                textColor = HTMLElement.getColor(child.getAttributeById(HTMLElement.ATTR_COLOR), textColor);\r\n                String family = child.getAttributeById(HTMLElement.ATTR_FACE);\r\n                int size = getInt(child.getAttributeById(HTMLElement.ATTR_SIZE));\r\n                if ((family != null) || (size != 0)) {\r\n                    HTMLFont f = getClosestHTMLFont(family, size, 0, 0);\r\n                    if (f != null) {\r\n                        font = f;\r\n                    }\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_U:\r\n            case HTMLElement.TAG_INS:\r\n                if (underlineCount == 0) {\r\n                    textDecoration |= Style.TEXT_DECORATION_UNDERLINE;\r\n                }\r\n                underlineCount++;\r\n                break;\r\n            case HTMLElement.TAG_S:\r\n            case HTMLElement.TAG_STRIKE:\r\n            case HTMLElement.TAG_DEL:\r\n                if (strikethruCount == 0) {\r\n                    textDecoration |= Style.TEXT_DECORATION_STRIKETHRU;\r\n                }\r\n                strikethruCount++;\r\n                break;\r\n            case HTMLElement.TAG_MAP:\r\n                String mapName = child.getAttributeById(HTMLElement.ATTR_NAME);\r\n                curImageMap = new ImageMapData(mapName);\r\n                break;\r\n            case HTMLElement.TAG_AREA:\r\n                handleImageMapArea(child);\r\n                break;\r\n            case HTMLElement.TAG_SUP:\r\n                superscript++;\r\n                break;\r\n            case HTMLElement.TAG_SUB:\r\n                superscript--;\r\n                break;\r\n            case HTMLElement.TAG_TBODY:\r\n                if (curTable != null) {\r\n                    curTable.startSegment(HTMLTableModel.SEGMENT_TBODY);\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_THEAD:\r\n                if (curTable != null) {\r\n                    curTable.startSegment(HTMLTableModel.SEGMENT_THEAD);\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_TFOOT:\r\n                if (curTable != null) {\r\n                    curTable.startSegment(HTMLTableModel.SEGMENT_TFOOT);\r\n                }\r\n                break;\r\n        }\r\n        if (child.getNumChildren() > 0) {\r\n            processTag(child, curAlign);\r\n        }\r\n        switch(child.getTagId()) {\r\n            case HTMLElement.TAG_H1:\r\n            case HTMLElement.TAG_H2:\r\n            case HTMLElement.TAG_H3:\r\n            case HTMLElement.TAG_H4:\r\n            case HTMLElement.TAG_H5:\r\n            case HTMLElement.TAG_H6:\r\n                font = oldFont;\r\n            case HTMLElement.TAG_P:\r\n                curAlign = align;\r\n                newLineIfNotEmpty(curAlign);\r\n                popContainer();\r\n                newLine(curAlign);\r\n                break;\r\n            case HTMLElement.TAG_DIV:\r\n            case HTMLElement.TAG_CENTER:\r\n                curAlign = align;\r\n                newLineIfNotEmpty(curAlign);\r\n                popContainer();\r\n                break;\r\n            case HTMLElement.TAG_FIELDSET:\r\n                newLineIfNotEmpty(curAlign);\r\n                Container fieldsetContainer = (Container) fieldsets.lastElement();\r\n                curContainer = fieldsetContainer.getParent();\r\n                fieldsets.removeElement(fieldsetContainer);\r\n                break;\r\n            case HTMLElement.TAG_BLOCKQUOTE:\r\n                newLineIfNotEmpty(curAlign);\r\n                newLine(curAlign);\r\n                updateMargin(-INDENT_BLOCKQUOTE);\r\n                popContainer();\r\n                break;\r\n            case HTMLElement.TAG_DT:\r\n                popContainer();\r\n                break;\r\n            case HTMLElement.TAG_DD:\r\n                newLineIfNotEmpty(curAlign);\r\n                updateMargin(-INDENT_DD);\r\n                popContainer();\r\n                break;\r\n            case HTMLElement.TAG_DL:\r\n                newLine(curAlign);\r\n                popContainer();\r\n                break;\r\n            case HTMLElement.TAG_A:\r\n                link = null;\r\n                linkVisited = false;\r\n                mainLink = null;\r\n                anchor = null;\r\n                accesskey = '\\0';\r\n                break;\r\n            case HTMLElement.TAG_UL:\r\n            case HTMLElement.TAG_DIR:\r\n            case HTMLElement.TAG_MENU:\r\n                ulLevel--;\r\n                if ((ulLevel == 0) && (olIndex == Integer.MIN_VALUE)) {\r\n                    newLine(curAlign);\r\n                } else {\r\n                    listIndent -= INDENT_UL;\r\n                }\r\n                listIndent -= INDENT_UL;\r\n                popContainer();\r\n                break;\r\n            case HTMLElement.TAG_OL:\r\n                if (olUpperLevelIndex.size() != 0) {\r\n                    String indexStr = (String) olUpperLevelIndex.lastElement();\r\n                    olUpperLevelIndex.removeElementAt(olUpperLevelIndex.size() - 1);\r\n                    listType = getOrderedListType(indexStr.charAt(0), HTMLListIndex.LIST_NUMERIC);\r\n                    olIndex = getInt(indexStr.substring(1));\r\n                    listIndent -= INDENT_OL;\r\n                } else {\r\n                    olIndex = Integer.MIN_VALUE;\r\n                }\r\n                if ((olIndex == Integer.MIN_VALUE) && (ulLevel == 0)) {\r\n                    newLine(curAlign);\r\n                }\r\n                popContainer();\r\n                break;\r\n            case HTMLElement.TAG_LI:\r\n                if (olIndex != Integer.MIN_VALUE) {\r\n                    olIndex++;\r\n                }\r\n                newLineIfNotEmpty(curAlign);\r\n                Container prevContainer = (Container) containers.lastElement();\r\n                curContainer = prevContainer;\r\n                containers.removeElement(curContainer);\r\n                break;\r\n            case HTMLElement.TAG_PRE:\r\n                preTagCount--;\r\n                popContainer();\r\n            case HTMLElement.TAG_FONT:\r\n                textColor = oldFontColor;\r\n            case HTMLElement.TAG_EM:\r\n            case HTMLElement.TAG_STRONG:\r\n            case HTMLElement.TAG_DFN:\r\n            case HTMLElement.TAG_CODE:\r\n            case HTMLElement.TAG_SAMP:\r\n            case HTMLElement.TAG_KBD:\r\n            case HTMLElement.TAG_VAR:\r\n            case HTMLElement.TAG_CITE:\r\n            case HTMLElement.TAG_B:\r\n            case HTMLElement.TAG_I:\r\n            case HTMLElement.TAG_BIG:\r\n            case HTMLElement.TAG_SMALL:\r\n            case HTMLElement.TAG_TT:\r\n                font = oldFont;\r\n                break;\r\n            case HTMLElement.TAG_FORM:\r\n                if ((curForm != null) && (!curForm.hasSubmitButton) && (curForm.getNumFields() > 0)) {\r\n                    Button submitButton = new Button(curForm.createSubmitCommand(null, null));\r\n                    addCmp(submitButton, curAlign);\r\n                }\r\n                curForm = null;\r\n                popContainer();\r\n                break;\r\n            case HTMLElement.TAG_TEXTAREA:\r\n                String name = child.getAttributeById(HTMLElement.ATTR_NAME);\r\n                if (curForm != null) {\r\n                    curForm.addInput(name, curTextArea, null);\r\n                }\r\n                curTextArea = null;\r\n                break;\r\n            case HTMLElement.TAG_SELECT:\r\n                if (curComboBox instanceof MultiComboBox) {\r\n                    Container comboCont = curComboBox.getParent();\r\n                    int minSize = Math.min(MIN_MULTI_COMBOBOX_ITEMS, curComboBox.size());\r\n                    int maxSize = Math.min(curComboBox.size(), MAX_MULTI_COMBOBOX_ITEMS);\r\n                    int size = Math.min(maxSize, Math.max(getInt(child.getAttributeById(HTMLElement.ATTR_SIZE)), minSize));\r\n                    Component renderCmp = curComboBox.getRenderer().getListCellRendererComponent(curComboBox, \"X\", 0, false);\r\n                    comboCont.setPreferredH((renderCmp.getPreferredH() + renderCmp.getStyle().getMargin(Component.TOP) + renderCmp.getStyle().getMargin(Component.BOTTOM) + curComboBox.getItemGap()) * size + curComboBox.getStyle().getPadding(Component.TOP) + curComboBox.getStyle().getPadding(Component.BOTTOM));\r\n                    addCmp(comboCont, curAlign);\r\n                } else {\r\n                    addCmp(curComboBox, curAlign);\r\n                }\r\n                curComboBox = null;\r\n                break;\r\n            case HTMLElement.TAG_OPTION:\r\n                optionTag = false;\r\n                optionSelected = false;\r\n                optionValue = null;\r\n                break;\r\n            case HTMLElement.TAG_Q:\r\n                quoteTagCount--;\r\n                addQuote(child, curAlign, false);\r\n                break;\r\n            case HTMLElement.TAG_TABLE:\r\n                newLineIfNotEmpty(curAlign);\r\n                curTable.commitRowIfNotEmpty();\r\n                if (curTable.getRowCount() != 0) {\r\n                    HTMLTable table = new HTMLTable(curTable);\r\n                    table.getStyle().setBgTransparency(0);\r\n                    if (loadCSS) {\r\n                        child.setAssociatedComponents(table);\r\n                    }\r\n                    int borderSize = getInt(child.getAttributeById(HTMLElement.ATTR_BORDER));\r\n                    int[] borderPad = new int[4];\r\n                    if (borderSize > 0) {\r\n                        int frame = PROCESS_HTML_MP1_ONLY ? -1 : HTMLUtils.getStringVal(child.getAttributeById(HTMLElement.ATTR_FRAME), HTMLElement.ALLOWED_TABLE_FRAME_STRINGS);\r\n                        Border border = Border.createLineBorder(borderSize);\r\n                        if (frame == -1) {\r\n                            for (int s = 0; s < borderPad.length; s++) {\r\n                                borderPad[s] = borderSize;\r\n                            }\r\n                        } else {\r\n                            Border[] borders = new Border[4];\r\n                            for (int j = 0; j < HTMLElement.ALLOWED_TABLE_FRAME_VALS[frame].length; j++) {\r\n                                int side = HTMLElement.ALLOWED_TABLE_FRAME_VALS[frame][j];\r\n                                borders[side] = border;\r\n                                borderPad[side] = borderSize;\r\n                            }\r\n                            border = Border.createCompoundBorder(borders[Component.TOP], borders[Component.BOTTOM], borders[Component.LEFT], borders[Component.RIGHT]);\r\n                        }\r\n                        table.getUnselectedStyle().setBorder(border);\r\n                        table.getSelectedStyle().setBorder(border);\r\n                        table.getUnselectedStyle().setPadding(borderPad[Component.TOP], borderPad[Component.BOTTOM], borderPad[Component.LEFT], borderPad[Component.RIGHT]);\r\n                        table.getSelectedStyle().setPadding(borderPad[Component.TOP], borderPad[Component.BOTTOM], borderPad[Component.LEFT], borderPad[Component.RIGHT]);\r\n                    } else {\r\n                        table.getUnselectedStyle().setBorder(null);\r\n                        table.getSelectedStyle().setBorder(null);\r\n                        table.setDrawBorder(false);\r\n                    }\r\n                    if (!PROCESS_HTML_MP1_ONLY) {\r\n                        int rules = HTMLUtils.getStringVal(child.getAttributeById(HTMLElement.ATTR_RULES), HTMLElement.ALLOWED_TABLE_RULES_STRINGS, Table.INNER_BORDERS_ALL);\r\n                        table.setInnerBorderMode(rules);\r\n                        int spacing = getInt(child.getAttributeById(HTMLElement.ATTR_CELLSPACING), -1);\r\n                        if (spacing != -1) {\r\n                            table.setBorderSpacing(spacing, spacing);\r\n                        }\r\n                        int padding = getInt(child.getAttributeById(HTMLElement.ATTR_CELLPADDING), -1);\r\n                        if (padding != -1) {\r\n                            for (int r = 0; r < curTable.getRowCount(); r++) {\r\n                                for (int c = 0; c < curTable.getColumnCount(); c++) {\r\n                                    Component cmp = (Component) curTable.getValueAt(r, c);\r\n                                    if (cmp != null) {\r\n                                        cmp.getUnselectedStyle().setPadding(padding, padding, padding, padding);\r\n                                        cmp.getSelectedStyle().setPadding(padding, padding, padding, padding);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                    if (curTable.captionTextTag != null) {\r\n                        Container captionedTable = new Container(new BoxLayout(BoxLayout.Y_AXIS));\r\n                        TextArea caption = new TextArea(curTable.captionTextTag.getText());\r\n                        curTable.captionTextTag.setAssociatedComponents(caption);\r\n                        caption.setUIID(\"HTMLTableCaption\");\r\n                        caption.setEditable(false);\r\n                        caption.setFocusable(false);\r\n                        caption.getStyle().setBorder(null);\r\n                        caption.getStyle().setAlignment(Component.CENTER);\r\n                        captionedTable.addComponent(caption);\r\n                        captionedTable.addComponent(table);\r\n                        addCmp(captionedTable, curAlign);\r\n                    } else {\r\n                        addCmp(table, curAlign);\r\n                    }\r\n                    newLineIfNotEmpty(curAlign);\r\n                }\r\n                if (tables.size() == 0) {\r\n                    curTable = null;\r\n                } else {\r\n                    curTable = (HTMLTableModel) tables.lastElement();\r\n                    tables.removeElement(curTable);\r\n                }\r\n                width = width * 2;\r\n                if (width > displayWidth) {\r\n                    width = displayWidth;\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_TR:\r\n                if (curTable != null) {\r\n                    curTable.commitRow();\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_TH:\r\n            case HTMLElement.TAG_TD:\r\n                if (curTable != null) {\r\n                    newLineIfNotEmpty(curAlign);\r\n                    curContainer = (Container) tableCells.lastElement();\r\n                    tableCells.removeElement(curContainer);\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_LABEL:\r\n                labelForID = null;\r\n                accesskey = '\\0';\r\n                break;\r\n            case HTMLElement.TAG_U:\r\n            case HTMLElement.TAG_INS:\r\n                underlineCount--;\r\n                if (underlineCount == 0) {\r\n                    textDecoration -= Style.TEXT_DECORATION_UNDERLINE;\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_S:\r\n            case HTMLElement.TAG_STRIKE:\r\n            case HTMLElement.TAG_DEL:\r\n                strikethruCount--;\r\n                if (strikethruCount == 0) {\r\n                    textDecoration -= Style.TEXT_DECORATION_STRIKETHRU;\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_MAP:\r\n                if (curImageMap != null) {\r\n                    if (imageMapData == null) {\r\n                        imageMapData = new Hashtable();\r\n                    }\r\n                    imageMapData.put(curImageMap.name, curImageMap);\r\n                    if ((imageMapComponents != null) && (imageMapComponents.containsKey(curImageMap.name))) {\r\n                        HTMLImageMap imageMap = (HTMLImageMap) imageMapComponents.get(curImageMap.name);\r\n                        imageMap.mapData = curImageMap;\r\n                    }\r\n                    curImageMap = null;\r\n                }\r\n                break;\r\n            case HTMLElement.TAG_SUP:\r\n                superscript--;\r\n                break;\r\n            case HTMLElement.TAG_SUB:\r\n                superscript++;\r\n                break;\r\n            case HTMLElement.TAG_TBODY:\r\n            case HTMLElement.TAG_THEAD:\r\n            case HTMLElement.TAG_TFOOT:\r\n                if (curTable != null) {\r\n                    curTable.endSegment();\r\n                }\r\n                break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.newLineIfNotEmpty",
	"Comment": "same as newline, but only if the current line container is not empty",
	"Method": "void newLineIfNotEmpty(int align){\r\n    if (curLine.getComponentCount() > 0) {\r\n        newLine(align);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.list.GenericListCellRenderer.isFisheye",
	"Comment": "in fisheye rendering mode the renderer maintains selected component drawing",
	"Method": "boolean isFisheye(){\r\n    return fisheye;\r\n}"
}, {
	"Path": "com.codename1.ui.Tabs.setChangeTabContainerStyleOnFocus",
	"Comment": "indicates that the tabs container should have its style changed to the selected style when one of the tabs has focusthis allows incorporating it into the theme of the application",
	"Method": "void setChangeTabContainerStyleOnFocus(boolean changeTabContainerStyleOnFocus){\r\n    this.changeTabContainerStyleOnFocus = changeTabContainerStyleOnFocus;\r\n}"
}, {
	"Path": "com.codename1.components.ImageViewer.getSwipePlaceholder",
	"Comment": "this image is shown briefly during swiping while the full size image is loaded",
	"Method": "Image getSwipePlaceholder(){\r\n    return swipePlaceholder;\r\n}"
}, {
	"Path": "com.codename1.social.FacebookImpl.hasPublishPermissions",
	"Comment": "returns true if the current session already has publish permissions",
	"Method": "boolean hasPublishPermissions(){\r\n    return nativeInterface.hasPublishPermissions();\r\n}"
}, {
	"Path": "io.atomix.copycat.protocol.RegisterRequest.builder",
	"Comment": "returns a register client request builder for an existing request.",
	"Method": "Builder builder(Builder builder,RegisterRequest request){\r\n    return new Builder(request);\r\n}"
}, {
	"Path": "io.atomix.copycat.client.session.ClientSessionState.getResponseIndex",
	"Comment": "returns the highest index for which a response has been received.",
	"Method": "long getResponseIndex(){\r\n    return responseIndex;\r\n}"
}, {
	"Path": "com.codename1.io.BufferedInputStream.getTotalBytesRead",
	"Comment": "returns the total amount of bytes read from this stream so far",
	"Method": "int getTotalBytesRead(){\r\n    return totalBytesRead;\r\n}"
}, {
	"Path": "com.codename1.ui.validation.RegexConstraint.validURL",
	"Comment": "generates a valid url constraint by using a regular expression",
	"Method": "Constraint validURL(String errorMessage,Constraint validURL){\r\n    return new RegexConstraint(validURLRegex, \"Invalid URL\");\r\n}"
}, {
	"Path": "com.codename1.impl.ImplementationFactory.setInstance",
	"Comment": "install a new implementation factory this method is invoked by implementorsto replace a factory.",
	"Method": "void setInstance(ImplementationFactory i){\r\n    instance = i;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.lastIndexOf",
	"Comment": "searches in this vector for the index of the specified object. the searchfor the object starts at the specified location and moves towards thestart of this vector.",
	"Method": "int lastIndexOf(Object object,int lastIndexOf,Object object,int location){\r\n    if (location < elementCount) {\r\n        if (object != null) {\r\n            for (int i = location; i >= 0; i--) {\r\n                if (object.equals(elementData[i])) {\r\n                    return i;\r\n                }\r\n            }\r\n        } else {\r\n            for (int i = location; i >= 0; i--) {\r\n                if (elementData[i] == null) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    throw new ArrayIndexOutOfBoundsException(location);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.topOnlyMode",
	"Comment": "special mode where only the top of the round rectangle is rounded and the bottom is a regular rectangle",
	"Method": "RoundRectBorder topOnlyMode(boolean topOnlyMode){\r\n    if (topOnlyMode) {\r\n        this.topLeft = false;\r\n        this.topRight = false;\r\n        this.bottomLeft = true;\r\n        this.bottomRight = true;\r\n    } else {\r\n        this.topLeft = true;\r\n        this.topRight = true;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "java.util.TreeSet.tailSet",
	"Comment": "answers a sortedset of the specified portion of this treeset whichcontains elements greater or equal to the start element. the returnedsortedset is backed by this treeset so changes to one are reflected bythe other.",
	"Method": "NavigableSet<E> tailSet(E start,boolean startInclusive,SortedSet<E> tailSet,E start){\r\n    return tailSet(start, true);\r\n}"
}, {
	"Path": "com.codename1.ui.Label.isShouldLocalize",
	"Comment": "indicates if text should be localized when set to the label, by defaultall text is localized so this allows disabling automatic localization for a specific label.",
	"Method": "boolean isShouldLocalize(){\r\n    return shouldLocalize;\r\n}"
}, {
	"Path": "java.io.PushbackInputStream.close",
	"Comment": "closes this stream. this implementation closes the source streamand releases the pushback buffer.",
	"Method": "void close(){\r\n    if (in != null) {\r\n        in.close();\r\n        in = null;\r\n        buf = null;\r\n    }\r\n}"
}, {
	"Path": "android.support.v4.app.ActivityOptionsCompat.makeCustomAnimation",
	"Comment": "create an activityoptions specifying a custom animation to run when theactivity is displayed.",
	"Method": "ActivityOptionsCompat makeCustomAnimation(Context context,int enterResId,int exitResId){\r\n    if (Build.VERSION.SDK_INT >= 16) {\r\n        return new ActivityOptionsImplJB(ActivityOptionsCompatJB.makeCustomAnimation(context, enterResId, exitResId));\r\n    }\r\n    return new ActivityOptionsCompat();\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.getRootAncestor",
	"Comment": "returns either the parent form or the component below the embedded containerabove c.",
	"Method": "Container getRootAncestor(Component c){\r\n    while (c.getParent() != null && !(c.getParent() instanceof EmbeddedContainer)) {\r\n        c = c.getParent();\r\n    }\r\n    if (!(c instanceof Container)) {\r\n        return null;\r\n    }\r\n    return (Container) c;\r\n}"
}, {
	"Path": "org.conscrypt.java.security.TestKeyStore.getClientCertificate",
	"Comment": "return a client keystore with a matched rsa certificate andprivate key as well as a ca certificate.",
	"Method": "TestKeyStore getClientCertificate(){\r\n    initCerts();\r\n    return CLIENT_CERTIFICATE;\r\n}"
}, {
	"Path": "com.codename1.ui.Button.getActionListeners",
	"Comment": "returns a vector containing the action listeners for this button",
	"Method": "Vector getActionListeners(){\r\n    return dispatcher.getListenerVector();\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GroupLayout.getVerticalGroup",
	"Comment": "returns the parallelgroup that is responsible forlayout along the vertical axis.",
	"Method": "Group getVerticalGroup(){\r\n    int index = 0;\r\n    if (verticalGroup.springs.size() > 1) {\r\n        index = 1;\r\n    }\r\n    return (Group) verticalGroup.springs.get(index);\r\n}"
}, {
	"Path": "com.codename1.ui.table.TableLayout.getColumnPosition",
	"Comment": "returns the position of the given table column. a valid value is only returned after the layout occurred.",
	"Method": "int getColumnPosition(int col){\r\n    if (columnPositions != null && columnPositions.length > col) {\r\n        return columnPositions[col];\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.removeAllElements",
	"Comment": "removes all elements from this vector, leaving the size zero and thecapacity unchanged.",
	"Method": "void removeAllElements(){\r\n    for (int i = 0; i < elementCount; i++) {\r\n        elementData[i] = null;\r\n    }\r\n    modCount++;\r\n    elementCount = 0;\r\n}"
}, {
	"Path": "org.conscrypt.ActiveSession.checkPeerCertificatesPresent",
	"Comment": "throw sslpeerunverifiedexception on null or empty peercertificates array",
	"Method": "void checkPeerCertificatesPresent(){\r\n    if (peerCertificates == null || peerCertificates.length == 0) {\r\n        throw new SSLPeerUnverifiedException(\"No peer certificates\");\r\n    }\r\n}"
}, {
	"Path": "android.support.v4.app.TaskStackBuilder.create",
	"Comment": "return a new taskstackbuilder for launching a fresh task stack consistingof a series of activities.",
	"Method": "TaskStackBuilder create(Context context){\r\n    return new TaskStackBuilder(context);\r\n}"
}, {
	"Path": "org.commonmark.internal.InlineParserImpl.spnl",
	"Comment": "parse zero or more space characters, including at most one newline.",
	"Method": "boolean spnl(){\r\n    match(SPNL);\r\n    return true;\r\n}"
}, {
	"Path": "structures.LinkCutTreeLca.expose",
	"Comment": "makes node x the root of the virtual tree, and also x becomes the leftmost node in its splay tree",
	"Method": "Node expose(Node x){\r\n    Node last = null;\r\n    for (Node y = x; y != null; y = y.parent) {\r\n        splay(y);\r\n        y.left = last;\r\n        last = y;\r\n    }\r\n    splay(x);\r\n    return last;\r\n}"
}, {
	"Path": "com.codename1.io.JSONParser.isIncludeNulls",
	"Comment": "indicates that the parser will include null values in the parsed output",
	"Method": "boolean isIncludeNulls(){\r\n    return includeNullsDefault;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.ArrayList.remove",
	"Comment": "removes the object at the specified location from this list.",
	"Method": "E remove(int location,boolean remove,Object object){\r\n    int location = indexOf(object);\r\n    if (location >= 0) {\r\n        remove(location);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getScrollDimension",
	"Comment": "returns the components dimension in scrolling, this is very similar to thepreferred size aspect only it represents actual scrolling limits.",
	"Method": "Dimension getScrollDimension(){\r\n    if (!scrollSizeRequestedByUser && (scrollSize == null || shouldCalcScrollSize)) {\r\n        scrollSize = calcScrollSize();\r\n        shouldCalcScrollSize = false;\r\n    }\r\n    return scrollSize;\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.setQwertyInput",
	"Comment": "true is this is a qwerty device or a device that is currently inqwerty mode.",
	"Method": "void setQwertyInput(boolean qwerty){\r\n    this.qwerty = qwerty;\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.addComponentListener",
	"Comment": "adds a component listener that would be bound when a ui for this form is created.notice that this method is only effective before the form was created and would donothing for an existing form",
	"Method": "void addComponentListener(String formName,String componentName,Object listener){\r\n    if (localComponentListeners == null) {\r\n        localComponentListeners = new Hashtable();\r\n        Hashtable formListeners = new Hashtable();\r\n        formListeners.put(componentName, listener);\r\n        localComponentListeners.put(formName, formListeners);\r\n        return;\r\n    }\r\n    Hashtable formListeners = (Hashtable) localComponentListeners.get(formName);\r\n    if (formListeners == null) {\r\n        formListeners = new Hashtable();\r\n        formListeners.put(componentName, listener);\r\n        localComponentListeners.put(formName, formListeners);\r\n        return;\r\n    }\r\n    Object currentListeners = formListeners.get(componentName);\r\n    if (currentListeners == null) {\r\n        formListeners.put(componentName, listener);\r\n    } else {\r\n        if (currentListeners instanceof Vector) {\r\n            ((Vector) currentListeners).addElement(listener);\r\n        } else {\r\n            Vector v = new Vector();\r\n            v.addElement(currentListeners);\r\n            v.addElement(listener);\r\n            formListeners.put(componentName, v);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.BorderLayout.centerAbsoluteEastWest",
	"Comment": "convenience method that creates a border layout absolute center container and places the given component in the centereast and west respectively",
	"Method": "Container centerAbsoluteEastWest(Component center,Component east,Component west){\r\n    Container c;\r\n    if (center != null) {\r\n        c = centerAbsolute(center);\r\n    } else {\r\n        c = new Container(new BorderLayout(CENTER_BEHAVIOR_CENTER_ABSOLUTE));\r\n    }\r\n    if (east != null) {\r\n        c.add(BorderLayout.EAST, east);\r\n    }\r\n    if (west != null) {\r\n        c.add(BorderLayout.WEST, west);\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.growPrioY",
	"Comment": "the grow priority compared to other components in the same cell.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC growPrioY(int p){\r\n    ver.setGrowPriority(p);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.BorderLayout.getCenterBehavior",
	"Comment": "defines the behavior of the center component to one of the constants defined in this class",
	"Method": "int getCenterBehavior(){\r\n    return centerBehavior;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.SegmentDescriptor.index",
	"Comment": "returns the segment index.the index indicates the index at which the first entry should be written to the segment. indexes are monotonicallyincreasing thereafter.",
	"Method": "long index(){\r\n    return index;\r\n}"
}, {
	"Path": "com.codename1.properties.SQLMap.getColumnName",
	"Comment": "by default the column name matches the property name unless explicitly modified with this method",
	"Method": "String getColumnName(PropertyBase prop){\r\n    String val = (String) prop.getClientProperty(\"cn1$sqlColumn\");\r\n    if (val == null) {\r\n        return prop.getName();\r\n    }\r\n    return val;\r\n}"
}, {
	"Path": "com.codename1.ui.Font.getCharset",
	"Comment": "returns a string containing all the characters supported by this font.will return null for system fonts.",
	"Method": "String getCharset(){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.testing.TestUtils.screenshotTest",
	"Comment": "the screenshot test takes a screenshot of the screen and compares it toa prior screenshot, if both are 100% identical the test passes. if notthe test fails.if this is the first time the test is run then the screenshot is takenand saved under the given name in the devices storage. the test passesfor this case but a warning is printed to the console. the name will have.png appended to it so it will be identified.this test will only work on devices that support the imageio api with pngfile format.",
	"Method": "boolean screenshotTest(String screenshotName){\r\n    if (verbose) {\r\n        log(\"screenshotTest(\" + screenshotName + \")\");\r\n    }\r\n    try {\r\n        ImageIO io = ImageIO.getImageIO();\r\n        if (io == null || !io.isFormatSupported(ImageIO.FORMAT_PNG)) {\r\n            log(\"screenshot test skipped due to no image IO support for PNG format\");\r\n            return true;\r\n        }\r\n        Image mute = Image.createImage(Display.getInstance().getDisplayWidth(), Display.getInstance().getDisplayHeight());\r\n        Display.getInstance().getCurrent().paintComponent(mute.getGraphics(), true);\r\n        screenshotName = screenshotName + \".png\";\r\n        if (Storage.getInstance().exists(screenshotName)) {\r\n            int[] rgba = mute.getRGBCached();\r\n            Image orig = Image.createImage(Storage.getInstance().createInputStream(screenshotName));\r\n            int[] origRgba = orig.getRGBCached();\r\n            orig = null;\r\n            for (int iter = 0; iter < rgba.length; iter++) {\r\n                if (rgba[iter] != origRgba[iter]) {\r\n                    log(\"screenshots do not match at offset \" + iter + \" saving additional image under \" + screenshotName + \".fail\");\r\n                    io.save(mute, Storage.getInstance().createOutputStream(screenshotName + \".fail\"), ImageIO.FORMAT_PNG, 1);\r\n                    return false;\r\n                }\r\n            }\r\n        } else {\r\n            io.save(mute, Storage.getInstance().createOutputStream(screenshotName), ImageIO.FORMAT_PNG, 1);\r\n        }\r\n        return true;\r\n    } catch (IOException err) {\r\n        log(err);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.getDefaultMenuTransitionIn",
	"Comment": "allows us to define a default animation that will draw the transition forentering a menu",
	"Method": "Transition getDefaultMenuTransitionIn(){\r\n    return defaultMenuTransitionIn;\r\n}"
}, {
	"Path": "com.codename1.components.ReplaceableImage.create",
	"Comment": "creates an encoded image that can later be replaced with a different image",
	"Method": "ReplaceableImage create(EncodedImage placeholder){\r\n    return new ReplaceableImage(placeholder);\r\n}"
}, {
	"Path": "com.codename1.ui.Form.isSingleFocusMode",
	"Comment": "returns true if there is only one focusable member in this form. this is usefulso sethandlesinput would always be true for this case.",
	"Method": "boolean isSingleFocusMode(int isSingleFocusMode,int b,Container c){\r\n    int t = c.getComponentCount();\r\n    for (int iter = 0; iter < t; iter++) {\r\n        Component cmp = c.getComponentAt(iter);\r\n        if (cmp.isFocusable()) {\r\n            if (b > 0) {\r\n                return 2;\r\n            }\r\n            b = 1;\r\n        }\r\n        if (cmp instanceof Container) {\r\n            b = isSingleFocusMode(b, (Container) cmp);\r\n            if (b > 1) {\r\n                return b;\r\n            }\r\n        }\r\n    }\r\n    return b;\r\n}"
}, {
	"Path": "com.codename1.impl.ios.TextEditUtil.editNextTextArea",
	"Comment": "opens onscreenkeyboard for the next textfield. the method works in edt ifneeded.",
	"Method": "void editNextTextArea(){\r\n    Runnable task = new Runnable() {\r\n        public void run() {\r\n            Component next = getNextEditComponent();\r\n            if (next != null) {\r\n                if (!(next instanceof TextArea)) {\r\n                    IOSImplementation.foldKeyboard();\r\n                }\r\n                next.requestFocus();\r\n                next.startEditingAsync();\r\n            } else {\r\n                IOSImplementation.foldKeyboard();\r\n            }\r\n        }\r\n    };\r\n    Display.getInstance().callSerially(task);\r\n}"
}, {
	"Path": "com.codename1.impl.ios.TextEditUtil.editNextTextArea",
	"Comment": "opens onscreenkeyboard for the next textfield. the method works in edt ifneeded.",
	"Method": "void editNextTextArea(){\r\n    Component next = getNextEditComponent();\r\n    if (next != null) {\r\n        if (!(next instanceof TextArea)) {\r\n            IOSImplementation.foldKeyboard();\r\n        }\r\n        next.requestFocus();\r\n        next.startEditingAsync();\r\n    } else {\r\n        IOSImplementation.foldKeyboard();\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Arrays.find",
	"Comment": "finds the place of specified range of specified sorted array, where theelement should be inserted for getting sorted array. uses exponentialsearch algorithm.",
	"Method": "int find(Object[] arr,net.sourceforge.retroweaver.harmony.runtime.java.lang.Comparable val,int bnd,int l,int r,int find,Object[] arr,Object val,int bnd,int l,int r,Comparator c){\r\n    int m = l;\r\n    int d = 1;\r\n    while (m <= r) {\r\n        if (c.compare(val, arr[m]) > bnd) {\r\n            l = m + 1;\r\n        } else {\r\n            r = m - 1;\r\n            break;\r\n        }\r\n        m += d;\r\n        d <<= 1;\r\n    }\r\n    while (l <= r) {\r\n        m = (l + r) >>> 1;\r\n        if (c.compare(val, arr[m]) > bnd) {\r\n            l = m + 1;\r\n        } else {\r\n            r = m - 1;\r\n        }\r\n    }\r\n    return l - 1;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.growPrioX",
	"Comment": "the grow priority compared to other components in the same cell.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC growPrioX(int p){\r\n    hor.setGrowPriority(p);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.properties.SQLMap.setColumnName",
	"Comment": "by default the column name matches the property name unless explicitly modified with this method",
	"Method": "void setColumnName(PropertyBase prop,String name){\r\n    prop.putClientProperty(\"cn1$sqlColumn\", name);\r\n}"
}, {
	"Path": "android.support.v4.content.LocalBroadcastManager.registerReceiver",
	"Comment": "register a receive for any local broadcasts that match the given intentfilter.",
	"Method": "void registerReceiver(BroadcastReceiver receiver,IntentFilter filter){\r\n    synchronized (mReceivers) {\r\n        ReceiverRecord entry = new ReceiverRecord(filter, receiver);\r\n        ArrayList<IntentFilter> filters = mReceivers.get(receiver);\r\n        if (filters == null) {\r\n            filters = new ArrayList<IntentFilter>(1);\r\n            mReceivers.put(receiver, filters);\r\n        }\r\n        filters.add(filter);\r\n        for (int i = 0; i < filter.countActions(); i++) {\r\n            String action = filter.getAction(i);\r\n            ArrayList<ReceiverRecord> entries = mActions.get(action);\r\n            if (entries == null) {\r\n                entries = new ArrayList<ReceiverRecord>(1);\r\n                mActions.put(action, entries);\r\n            }\r\n            entries.add(entry);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.javascript.JavascriptContext.uninstall",
	"Comment": "uninstalls the context from the browser component.this just includesthe listeners that are registered with the browsercomponent so that the context is informed of navigation callbacks and script message listeners.",
	"Method": "void uninstall(){\r\n    browser.setBrowserNavigationCallback(previousNavigationCallback);\r\n    browser.removeWebEventListener(\"scriptMessageReceived\", scriptMessageListener);\r\n}"
}, {
	"Path": "com.codename1.components.MultiButton.setLinesTogetherMode",
	"Comment": "changes the layout so the lines of the button are grouped together",
	"Method": "void setLinesTogetherMode(boolean l){\r\n    if (l != isLinesTogetherMode()) {\r\n        if (l) {\r\n            firstRow.getParent().removeComponent(firstRow);\r\n            Container p = secondRow.getParent();\r\n            p.addComponent(0, firstRow);\r\n            Container pp = p.getParent();\r\n            pp.removeComponent(p);\r\n            pp.addComponent(BorderLayout.CENTER, p);\r\n        } else {\r\n            secondRow.getParent().removeComponent(secondRow);\r\n            thirdRow.getParent().addComponent(0, secondRow);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.support.v4.util.LongSparseArray.put",
	"Comment": "adds a mapping from the specified key to the specified value,replacing the previous mapping from the specified key if therewas one.",
	"Method": "void put(long key,E value){\r\n    int i = binarySearch(mKeys, 0, mSize, key);\r\n    if (i >= 0) {\r\n        mValues[i] = value;\r\n    } else {\r\n        i = ~i;\r\n        if (i < mSize && mValues[i] == DELETED) {\r\n            mKeys[i] = key;\r\n            mValues[i] = value;\r\n            return;\r\n        }\r\n        if (mGarbage && mSize >= mKeys.length) {\r\n            gc();\r\n            i = ~binarySearch(mKeys, 0, mSize, key);\r\n        }\r\n        if (mSize >= mKeys.length) {\r\n            int n = idealLongArraySize(mSize + 1);\r\n            long[] nkeys = new long[n];\r\n            Object[] nvalues = new Object[n];\r\n            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);\r\n            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);\r\n            mKeys = nkeys;\r\n            mValues = nvalues;\r\n        }\r\n        if (mSize - i != 0) {\r\n            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);\r\n            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);\r\n        }\r\n        mKeys[i] = key;\r\n        mValues[i] = value;\r\n        mSize++;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.BorderLayout.setCenterBehavior",
	"Comment": "defines the behavior of the center component to one of the constants defined in this class",
	"Method": "void setCenterBehavior(int centerBehavior){\r\n    this.centerBehavior = centerBehavior;\r\n}"
}, {
	"Path": "com.codename1.ui.ComboBox.showPopupDialog",
	"Comment": "shows the popup dialog for the combo box and returns the resulting command.this method can be overriden by subclasses to modify the behavior of the class.",
	"Method": "Command showPopupDialog(Dialog popupDialog,List l){\r\n    if (getUIManager().isThemeConstant(\"popupTitleBool\", false)) {\r\n        if (getLabelForComponent() != null) {\r\n            popupDialog.setTitle(getLabelForComponent().getText());\r\n        }\r\n    }\r\n    if (includeSelectCancel) {\r\n        popupDialog.setBackCommand(popupDialog.getMenuBar().getCancelMenuItem());\r\n        if (Display.getInstance().isTouchScreenDevice()) {\r\n            if (getUIManager().isThemeConstant(\"popupCancelBodyBool\", false)) {\r\n                popupDialog.placeButtonCommands(new Command[] { popupDialog.getMenuBar().getCancelMenuItem() });\r\n            }\r\n        } else {\r\n            if (Display.getInstance().isThirdSoftButton()) {\r\n                popupDialog.addCommand(popupDialog.getMenuBar().getSelectMenuItem());\r\n                popupDialog.addCommand(popupDialog.getMenuBar().getCancelMenuItem());\r\n            } else {\r\n                popupDialog.addCommand(popupDialog.getMenuBar().getCancelMenuItem());\r\n                popupDialog.addCommand(popupDialog.getMenuBar().getSelectMenuItem());\r\n            }\r\n        }\r\n    }\r\n    if (actAsSpinnerDialog) {\r\n        l.setFixedSelection(List.FIXED_CENTER);\r\n        l.setUIID(\"Spinner\");\r\n        l.spinnerOverlay = getUIManager().getComponentStyle(\"SpinnerOverlay\");\r\n        l.spinnerOverlay.setMargin(0, 0, 0, 0);\r\n        l.setAlwaysTensile(false);\r\n        l.installDefaultPainter(l.spinnerOverlay);\r\n        popupDialog.setDialogUIID(\"Container\");\r\n        popupDialog.setUIID(\"Container\");\r\n        popupDialog.getTitleComponent().setUIID(\"Container\");\r\n        popupDialog.setTransitionInAnimator(CommonTransitions.createSlide(CommonTransitions.SLIDE_VERTICAL, true, 200));\r\n        popupDialog.setTransitionOutAnimator(CommonTransitions.createSlide(CommonTransitions.SLIDE_VERTICAL, false, 200));\r\n        return popupDialog.show(Display.getInstance().getDisplayHeight() - popupDialog.getDialogComponent().getPreferredH(), 0, 0, 0, true, true);\r\n    }\r\n    if (getUIManager().isThemeConstant(\"centeredPopupBool\", false)) {\r\n        return popupDialog.showPacked(BorderLayout.CENTER, true);\r\n    } else {\r\n        int top, bottom, left, right;\r\n        Form parentForm = getComponentForm();\r\n        int listW = Math.max(getWidth(), l.getPreferredW());\r\n        listW = Math.min(listW + l.getSideGap(), parentForm.getContentPane().getWidth());\r\n        Component content = popupDialog.getDialogComponent();\r\n        Style contentStyle = content.getStyle();\r\n        int listH = content.getPreferredH() + contentStyle.getVerticalMargins();\r\n        Component title = popupDialog.getTitleArea();\r\n        listH += title.getPreferredH() + title.getStyle().getVerticalMargins();\r\n        bottom = 0;\r\n        top = getAbsoluteY();\r\n        int formHeight = parentForm.getHeight();\r\n        if (parentForm.getSoftButtonCount() > 1) {\r\n            Component c = parentForm.getSoftButton(0).getParent();\r\n            formHeight -= c.getHeight();\r\n            Style s = c.getStyle();\r\n            formHeight -= (s.getVerticalMargins());\r\n        }\r\n        if (listH < formHeight) {\r\n            if (top > formHeight / 2) {\r\n                bottom = formHeight - top;\r\n                top = top - listH;\r\n            } else {\r\n                top += getHeight();\r\n                bottom = formHeight - top - listH;\r\n            }\r\n        } else {\r\n            top = 0;\r\n        }\r\n        left = getAbsoluteX();\r\n        right = parentForm.getWidth() - left - listW;\r\n        if (right < 0) {\r\n            left += right;\r\n            right = 0;\r\n        }\r\n        popupDialog.setBackCommand(popupDialog.getMenuBar().getCancelMenuItem());\r\n        return popupDialog.show(Math.max(top, 0), Math.max(bottom, 0), Math.max(left, 0), Math.max(right, 0), false, true);\r\n    }\r\n}"
}, {
	"Path": "org.conscrypt.ConscryptFileDescriptorSocket.setHandshakeTimeout",
	"Comment": "set the handshake timeout on this socket.this timeout is specified inmilliseconds and will be used only during the handshake process.",
	"Method": "void setHandshakeTimeout(int handshakeTimeoutMilliseconds){\r\n    this.handshakeTimeoutMilliseconds = handshakeTimeoutMilliseconds;\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyBase.addChangeListener",
	"Comment": "fires a notification that a property value changed to the given listener",
	"Method": "void addChangeListener(PropertyChangeListener<T, K> pl){\r\n    if (listeners == null) {\r\n        listeners = new ArrayList<PropertyChangeListener<T, K>>();\r\n    }\r\n    listeners.add(pl);\r\n}"
}, {
	"Path": "org.conscrypt.OpenSSLServerSocketFactoryImpl.setUseEngineSocketByDefault",
	"Comment": "configures the default socket to be created for all instances.",
	"Method": "void setUseEngineSocketByDefault(boolean useEngineSocket){\r\n    useEngineSocketByDefault = useEngineSocket;\r\n}"
}, {
	"Path": "com.codename1.ui.html.ResourceThreadQueue.addBgImage",
	"Comment": "adds the image to the queue, to be used as a background image for a component",
	"Method": "void addBgImage(Component imgComp,String imageUrl,int styles){\r\n    if (HTMLComponent.SUPPORT_CSS) {\r\n        add(imgComp, imageUrl);\r\n        if ((styles & CSSEngine.STYLE_SELECTED) != 0) {\r\n            bgImageCompsSelected.addElement(imgComp);\r\n        }\r\n        if ((styles & CSSEngine.STYLE_UNSELECTED) != 0) {\r\n            bgImageCompsUnselected.addElement(imgComp);\r\n        }\r\n        if ((styles & CSSEngine.STYLE_PRESSED) != 0) {\r\n            bgImageCompsPressed.addElement(imgComp);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.conscrypt.javax.net.ssl.KeyManagerFactoryTest.nonEmpty",
	"Comment": "filters null or empty values from a string array and returns a new array with the results.",
	"Method": "String[] nonEmpty(String[] input){\r\n    String[] nonEmpty = new String[input.length];\r\n    int size = 0;\r\n    for (String keyType : input) {\r\n        if (keyType != null && !keyType.isEmpty()) {\r\n            nonEmpty[size++] = keyType;\r\n        }\r\n    }\r\n    return Arrays.copyOfRange(nonEmpty, 0, size);\r\n}"
}, {
	"Path": "org.conscrypt.ct.CTVerifier.getSCTsFromSCTList",
	"Comment": "parse an encoded signedcertificatetimestamplist into a list of signedcertificatetimestampinstances, as described by rfc6962.individual scts which fail to be parsed are skipped. if the data is null, or the encompassinglist fails to be parsed, an empty list is returned.",
	"Method": "List<SignedCertificateTimestamp> getSCTsFromSCTList(byte[] data,SignedCertificateTimestamp.Origin origin){\r\n    if (data == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    byte[][] sctList;\r\n    try {\r\n        sctList = Serialization.readList(data, CTConstants.SCT_LIST_LENGTH_BYTES, CTConstants.SERIALIZED_SCT_LENGTH_BYTES);\r\n    } catch (SerializationException e) {\r\n        return Collections.emptyList();\r\n    }\r\n    List<SignedCertificateTimestamp> scts = new ArrayList<SignedCertificateTimestamp>();\r\n    for (byte[] encodedSCT : sctList) {\r\n        try {\r\n            SignedCertificateTimestamp sct = SignedCertificateTimestamp.decode(encodedSCT, origin);\r\n            scts.add(sct);\r\n        } catch (SerializationException e) {\r\n        }\r\n    }\r\n    return scts;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLForm.reset",
	"Comment": "called when a form reset is needed and resets all the form fields to their default values.",
	"Method": "void reset(){\r\n    for (Enumeration e = defaultValues.keys(); e.hasMoreElements(); ) {\r\n        Object input = e.nextElement();\r\n        if (input instanceof TextArea) {\r\n            String defVal = (String) defaultValues.get(input);\r\n            if (defVal == null) {\r\n                defVal = \"\";\r\n            }\r\n            ((TextArea) input).setText(defVal);\r\n        } else if (input instanceof ComboBox) {\r\n            OptionItem defVal = (OptionItem) defaultValues.get(input);\r\n            ComboBox combo = ((ComboBox) input);\r\n            if (defVal != null) {\r\n                combo.setSelectedItem(defVal);\r\n            } else if (combo.size() > 0) {\r\n                combo.setSelectedIndex(0);\r\n            }\r\n        }\r\n    }\r\n    for (Enumeration e = defaultCheckedButtons.elements(); e.hasMoreElements(); ) {\r\n        Button b = (Button) e.nextElement();\r\n        if (!b.isSelected()) {\r\n            setButton(b, true);\r\n        }\r\n    }\r\n    for (Enumeration e = defaultUncheckedButtons.elements(); e.hasMoreElements(); ) {\r\n        Button b = (Button) e.nextElement();\r\n        if (b.isSelected()) {\r\n            setButton(b, false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.postInit",
	"Comment": "callback allowing the implementation to perform an operation on the init threadafter initialization was completed",
	"Method": "void postInit(){\r\n    initDefaultUserAgent();\r\n}"
}, {
	"Path": "com.codename1.components.Progress.setAutoShow",
	"Comment": "shows the progress automatically when the request processing is started",
	"Method": "void setAutoShow(boolean autoShow){\r\n    this.autoShow = autoShow;\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.setBlockAnalytics",
	"Comment": "enables blocking analytics in the uibuilder, this is useful for the designer tool.",
	"Method": "void setBlockAnalytics(boolean aBlockAnalytics){\r\n    blockAnalytics = aBlockAnalytics;\r\n}"
}, {
	"Path": "mondrian.olap.Util.lookupHierarchyLevel",
	"Comment": "finds a named level in this hierarchy. returns null if there is nosuch level.",
	"Method": "Level lookupHierarchyLevel(Hierarchy hierarchy,String s){\r\n    final Level[] levels = hierarchy.getLevels();\r\n    for (Level level : levels) {\r\n        if (level.getName().equalsIgnoreCase(s)) {\r\n            return level;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.entity.MapEntity.equals",
	"Comment": "returns true if the cached hashcodes of both objects are equal and the wrapped maps are equal.",
	"Method": "boolean equals(Object o){\r\n    if (this == o) {\r\n        return true;\r\n    }\r\n    if (!(o instanceof MapEntity)) {\r\n        return false;\r\n    }\r\n    MapEntity that = (MapEntity) o;\r\n    if (cachedHashCode != that.cachedHashCode) {\r\n        return false;\r\n    }\r\n    return this.wrappedMap.equals(that.wrappedMap);\r\n}"
}, {
	"Path": "java.lang.Double.toString",
	"Comment": "returns a string representation of this double object. the primitive double value represented by this object is converted to a string exactly as if by the method tostring of one argument.",
	"Method": "java.lang.String toString(java.lang.String toString,double d){\r\n    double m = Math.abs(d);\r\n    if (d == POSITIVE_INFINITY) {\r\n        return \"Infinity\";\r\n    } else if (d == NEGATIVE_INFINITY) {\r\n        return \"-Infinity\";\r\n    } else if (d == 0) {\r\n        return \"0.0\";\r\n    } else if (m >= 1e-3 && m < 1e7) {\r\n        String str = toStringImpl(d, false);\r\n        char[] chars = str.toCharArray();\r\n        int i = chars.length - 1;\r\n        char c;\r\n        while (i >= 0 && (c = chars[i]) == '0') {\r\n            i--;\r\n        }\r\n        if (i < 0 || str.indexOf('.') == -1) {\r\n            return str;\r\n        } else if (chars[i] == '.' || chars[i] == ',') {\r\n            i++;\r\n        }\r\n        return str.substring(0, i + 1);\r\n    } else {\r\n        return toStringImpl(d, true);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.setFontSizeMillimeters",
	"Comment": "sets the font size of all components in found set.in millimeters.",
	"Method": "ComponentSelector setFontSizeMillimeters(float sizeMM){\r\n    return setFontSize(dip2px(sizeMM));\r\n}"
}, {
	"Path": "com.codename1.maps.BoundingBox.create",
	"Comment": "create a smallest bounding box that contains all of the given coordinates",
	"Method": "BoundingBox create(Coord[] coords,BoundingBox create,Vector coords){\r\n    int length = coords.size();\r\n    if (length <= 0) {\r\n        throw new RuntimeException(\"There must be at least 1 coordinate.\");\r\n    }\r\n    Coord[] coordsArray = new Coord[length];\r\n    coords.copyInto(coordsArray);\r\n    return create(coordsArray);\r\n}"
}, {
	"Path": "com.codename1.ui.Graphics.drawChars",
	"Comment": "draw the given char array using the current font and color in the x,y coordinates. the font is drawnfrom the top position and not the baseline.",
	"Method": "void drawChars(char[] data,int offset,int length,int x,int y){\r\n    if (!(current instanceof CustomFont)) {\r\n        drawString(new String(data, offset, length), x, y);\r\n    } else {\r\n        CustomFont f = (CustomFont) current;\r\n        f.drawChars(this, data, offset, length, x, y);\r\n    }\r\n}"
}, {
	"Path": "com.l2fprod.common.swing.IconPool.get",
	"Comment": "gets the icon denoted by url.if url is relative, it is relative to the caller.",
	"Method": "Icon get(String url,Icon get,URL url){\r\n    if (url == null) {\r\n        return null;\r\n    }\r\n    Icon icon = (Icon) pool.get(url.toString());\r\n    if (icon == null) {\r\n        icon = new ImageIcon(url);\r\n        pool.put(url.toString(), icon);\r\n    }\r\n    return icon;\r\n}"
}, {
	"Path": "com.codename1.impl.ios.IOSImplementation.keyboardWillBeShown",
	"Comment": "callback for native.called when keyboard is shown.used for async editing with formbottompaddingeditingmode.",
	"Method": "void keyboardWillBeShown(){\r\n    if (nativeInstance.isAsyncEditMode()) {\r\n        final Form current = Display.getInstance().getCurrent();\r\n        if (current.isFormBottomPaddingEditingMode()) {\r\n            Display.getInstance().callSerially(new Runnable() {\r\n                public void run() {\r\n                    if (current != null) {\r\n                        getRootPane(current).getUnselectedStyle().setPaddingUnit(new byte[] { Style.UNIT_TYPE_PIXELS, Style.UNIT_TYPE_PIXELS, Style.UNIT_TYPE_PIXELS, Style.UNIT_TYPE_PIXELS });\r\n                        getRootPane(current).getUnselectedStyle().setPadding(Component.BOTTOM, nativeInstance.getVKBHeight());\r\n                        current.revalidate();\r\n                        Display.getInstance().callSerially(new Runnable() {\r\n                            public void run() {\r\n                                updateNativeTextEditorFrame();\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n        } else {\r\n            Display.getInstance().callSerially(new Runnable() {\r\n                public void run() {\r\n                    if (current != null) {\r\n                        if (instance.currentEditing != null) {\r\n                            instance.doNotHideTextEditorSemaphore++;\r\n                            try {\r\n                                instance.currentEditing.requestFocus();\r\n                            } finally {\r\n                                instance.doNotHideTextEditorSemaphore--;\r\n                            }\r\n                            current.revalidate();\r\n                            Display.getInstance().callSerially(new Runnable() {\r\n                                public void run() {\r\n                                    updateNativeTextEditorFrame();\r\n                                }\r\n                            });\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n        }\r\n    }\r\n    if (Display.getInstance().getVirtualKeyboardListener() != null) {\r\n        Display.getInstance().callSerially(new Runnable() {\r\n            public void run() {\r\n                ActionListener l = Display.getInstance().getVirtualKeyboardListener();\r\n                if (l != null) {\r\n                    l.actionPerformed(new ActionEvent(true));\r\n                }\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.ios.IOSImplementation.keyboardWillBeShown",
	"Comment": "callback for native.called when keyboard is shown.used for async editing with formbottompaddingeditingmode.",
	"Method": "void keyboardWillBeShown(){\r\n    if (current != null) {\r\n        getRootPane(current).getUnselectedStyle().setPaddingUnit(new byte[] { Style.UNIT_TYPE_PIXELS, Style.UNIT_TYPE_PIXELS, Style.UNIT_TYPE_PIXELS, Style.UNIT_TYPE_PIXELS });\r\n        getRootPane(current).getUnselectedStyle().setPadding(Component.BOTTOM, nativeInstance.getVKBHeight());\r\n        current.revalidate();\r\n        Display.getInstance().callSerially(new Runnable() {\r\n            public void run() {\r\n                updateNativeTextEditorFrame();\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.ios.IOSImplementation.keyboardWillBeShown",
	"Comment": "callback for native.called when keyboard is shown.used for async editing with formbottompaddingeditingmode.",
	"Method": "void keyboardWillBeShown(){\r\n    updateNativeTextEditorFrame();\r\n}"
}, {
	"Path": "com.codename1.impl.ios.IOSImplementation.keyboardWillBeShown",
	"Comment": "callback for native.called when keyboard is shown.used for async editing with formbottompaddingeditingmode.",
	"Method": "void keyboardWillBeShown(){\r\n    if (current != null) {\r\n        if (instance.currentEditing != null) {\r\n            instance.doNotHideTextEditorSemaphore++;\r\n            try {\r\n                instance.currentEditing.requestFocus();\r\n            } finally {\r\n                instance.doNotHideTextEditorSemaphore--;\r\n            }\r\n            current.revalidate();\r\n            Display.getInstance().callSerially(new Runnable() {\r\n                public void run() {\r\n                    updateNativeTextEditorFrame();\r\n                }\r\n            });\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.ios.IOSImplementation.keyboardWillBeShown",
	"Comment": "callback for native.called when keyboard is shown.used for async editing with formbottompaddingeditingmode.",
	"Method": "void keyboardWillBeShown(){\r\n    updateNativeTextEditorFrame();\r\n}"
}, {
	"Path": "com.codename1.impl.ios.IOSImplementation.keyboardWillBeShown",
	"Comment": "callback for native.called when keyboard is shown.used for async editing with formbottompaddingeditingmode.",
	"Method": "void keyboardWillBeShown(){\r\n    ActionListener l = Display.getInstance().getVirtualKeyboardListener();\r\n    if (l != null) {\r\n        l.actionPerformed(new ActionEvent(true));\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.ComboBox.createPopupDialog",
	"Comment": "subclasses can override this method to change the creation of the dialog",
	"Method": "Dialog createPopupDialog(List<T> l){\r\n    Dialog popupDialog = new Dialog(getUIID() + \"Popup\", getUIID() + \"PopupTitle\") {\r\n        void sizeChangedInternal(int w, int h) {\r\n            if (getWidth() == w && getHeight() != h) {\r\n                Form frm = getPreviousForm();\r\n                if (frm != null) {\r\n                    frm.sizeChangedInternal(w, h);\r\n                }\r\n                setSize(new Dimension(w, h));\r\n                repaint();\r\n            } else {\r\n                dispose();\r\n            }\r\n        }\r\n    };\r\n    popupDialog.setScrollable(false);\r\n    popupDialog.getContentPane().setAlwaysTensile(false);\r\n    popupDialog.setAlwaysTensile(false);\r\n    popupDialog.getContentPane().setUIID(\"PopupContentPane\");\r\n    popupDialog.setDisposeWhenPointerOutOfBounds(true);\r\n    popupDialog.setTransitionInAnimator(CommonTransitions.createEmpty());\r\n    popupDialog.setTransitionOutAnimator(CommonTransitions.createEmpty());\r\n    popupDialog.setLayout(new BorderLayout());\r\n    popupDialog.addComponent(BorderLayout.CENTER, l);\r\n    return popupDialog;\r\n}"
}, {
	"Path": "com.codename1.ui.ComboBox.createPopupDialog",
	"Comment": "subclasses can override this method to change the creation of the dialog",
	"Method": "Dialog createPopupDialog(List<T> l){\r\n    if (getWidth() == w && getHeight() != h) {\r\n        Form frm = getPreviousForm();\r\n        if (frm != null) {\r\n            frm.sizeChangedInternal(w, h);\r\n        }\r\n        setSize(new Dimension(w, h));\r\n        repaint();\r\n    } else {\r\n        dispose();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.setDuplicateSupported",
	"Comment": "indicates whether this connection request supports duplicate entries in the request queue",
	"Method": "void setDuplicateSupported(boolean duplicateSupported){\r\n    this.duplicateSupported = duplicateSupported;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.setEditOnShow",
	"Comment": "a text component that will receive focus and start editing immediately as the form is shown",
	"Method": "void setEditOnShow(TextArea editOnShow){\r\n    this.editOnShow = editOnShow;\r\n}"
}, {
	"Path": "java.lang.Character.codePointCount",
	"Comment": "counts the number of unicode code points in the subsequence of thecharsequence, as delineated by thebeginindex and endindex. any surrogatevalues with missing pair values will be counted as 1 code point.",
	"Method": "int codePointCount(CharSequence seq,int beginIndex,int endIndex,int codePointCount,char[] seq,int offset,int count){\r\n    if (seq == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    int len = seq.length;\r\n    int endIndex = offset + count;\r\n    if (offset < 0 || count < 0 || endIndex > len) {\r\n        throw new IndexOutOfBoundsException();\r\n    }\r\n    int result = 0;\r\n    for (int i = offset; i < endIndex; i++) {\r\n        char c = seq[i];\r\n        if (isHighSurrogate(c)) {\r\n            if (++i < endIndex) {\r\n                c = seq[i];\r\n                if (!isLowSurrogate(c)) {\r\n                    result++;\r\n                }\r\n            }\r\n        }\r\n        result++;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.AbstractAppender.buildAppendEmptyRequest",
	"Comment": "builds an empty appendentries request.empty append requests are used as heartbeats to followers.",
	"Method": "AppendRequest buildAppendEmptyRequest(MemberState member){\r\n    Entry prevEntry = getPrevEntry(member);\r\n    ServerMember leader = context.getLeader();\r\n    return AppendRequest.builder().withTerm(context.getTerm()).withLeader(leader != null ? leader.id() : 0).withLogIndex(prevEntry != null ? prevEntry.getIndex() : 0).withLogTerm(prevEntry != null ? prevEntry.getTerm() : 0).withEntries(Collections.EMPTY_LIST).withCommitIndex(context.getCommitIndex()).withGlobalIndex(context.getGlobalIndex()).build();\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSEngine.applyDecorationOnStyle",
	"Comment": "utility method to add a specific text decoration if it does not exist",
	"Method": "void applyDecorationOnStyle(Style style,int decoration){\r\n    int curDecoration = style.getTextDecoration();\r\n    if ((curDecoration & decoration) == 0) {\r\n        style.setTextDecoration(curDecoration | decoration);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.getInAppPurchase",
	"Comment": "returns the native os purchase implementation if applicable, if not thismethod will fallback to a cross platform purchase manager.",
	"Method": "Purchase getInAppPurchase(){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Motion.createEaseInOutMotion",
	"Comment": "equivalent to createcubicbeziermotion with 0, 0.42, 0.58, 1.0 as arguments.",
	"Method": "Motion createEaseInOutMotion(int sourceValue,int destinationValue,int duration){\r\n    return createCubicBezierMotion(sourceValue, destinationValue, duration, 0, 0.42f, 0.58f, 1);\r\n}"
}, {
	"Path": "com.codename1.ui.Label.isShowEvenIfBlank",
	"Comment": "by default labels and subclasses become 0 sized when they are blank even ignoring their paddingsetting this to true makes the padding take effect even in a blank field.",
	"Method": "boolean isShowEvenIfBlank(){\r\n    return showEvenIfBlank;\r\n}"
}, {
	"Path": "ly.count.android.sdk.CountlyStore.connections",
	"Comment": "returns an unsorted array of the current stored connections.",
	"Method": "String[] connections(){\r\n    final String joinedConnStr = preferences_.getString(CONNECTIONS_PREFERENCE, \"\");\r\n    return joinedConnStr.length() == 0 ? new String[0] : joinedConnStr.split(DELIMITER);\r\n}"
}, {
	"Path": "com.l2fprod.common.swing.plaf.LookAndFeelAddons.setTrackingLookAndFeelChanges",
	"Comment": "if true, everytime the swing look and feel is changed, the addon whichbest matches the current look and feel will be automatically selected.",
	"Method": "void setTrackingLookAndFeelChanges(boolean tracking){\r\n    if (trackingChanges != tracking) {\r\n        if (tracking) {\r\n            if (changeListener == null) {\r\n                changeListener = new UpdateAddon();\r\n            }\r\n            UIManager.addPropertyChangeListener(changeListener);\r\n        } else {\r\n            if (changeListener != null) {\r\n                UIManager.removePropertyChangeListener(changeListener);\r\n            }\r\n            changeListener = null;\r\n        }\r\n        trackingChanges = tracking;\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.client.ServerSelectionStrategiesTest.listsEqual",
	"Comment": "returns a boolean value indicating whether the servers in the first list match the servers in the second list.",
	"Method": "boolean listsEqual(Collection<Address> left,Collection<Address> right){\r\n    if (left.size() != right.size())\r\n        return false;\r\n    for (Address address : left) {\r\n        if (!right.contains(address)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.List.getActionListeners",
	"Comment": "this method allows extracting the action listeners from the current list",
	"Method": "Vector getActionListeners(){\r\n    return dispatcher.getListenerVector();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.ArrayDeque.peek",
	"Comment": "gets but not removes the head element of this deque. this method returnsnull if the deque is empty.",
	"Method": "E peek(){\r\n    return (status == DequeStatus.Empty) ? null : elements[front];\r\n}"
}, {
	"Path": "com.codename1.ui.FontImage.setBgTransparency",
	"Comment": "allows manipulating the background transparency value of the image",
	"Method": "void setBgTransparency(int t){\r\n    backgroundOpacity = (byte) t;\r\n}"
}, {
	"Path": "io.atomix.copycat.protocol.ResetRequest.builder",
	"Comment": "returns a publish response builder for an existing response.",
	"Method": "Builder builder(Builder builder,ResetRequest response){\r\n    return new Builder(response);\r\n}"
}, {
	"Path": "com.codename1.payments.v3.Inventory.hasPurchase",
	"Comment": "returns whether or not there exists a purchase of the given product.",
	"Method": "boolean hasPurchase(String sku){\r\n    return mPurchaseMap.containsKey(sku);\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.getVerticalAlignment",
	"Comment": "returns the vertical alignment of the text field, this only applies to single line text field",
	"Method": "int getVerticalAlignment(){\r\n    return valign;\r\n}"
}, {
	"Path": "com.codename1.impl.midp.codescan.CN1ImageLuminanceSource.getRow",
	"Comment": "alters the conversion. the difference is not significant for our purposes.",
	"Method": "byte[] getRow(int y,byte[] row,byte[] getRow,int y,byte[] row){\r\n    if (y < 0 || y >= getHeight()) {\r\n        throw new IllegalArgumentException(\"Requested row is outside the image: \" + y);\r\n    }\r\n    int width = getWidth();\r\n    if (row == null || row.length < width) {\r\n        row = new byte[width];\r\n    }\r\n    Image rowImg = image.subImage(0, y, width, 1, false);\r\n    rgbData = rowImg.getRGB();\r\n    for (int x = 0; x < width; x++) {\r\n        row[x] = toLuminance(rgbData[x]);\r\n    }\r\n    return row;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.index.sqlite.RequestScopeConnectionManager.close",
	"Comment": "commits the transactions on the open connections to all persistences, then closes the connections.",
	"Method": "void close(){\r\n    for (Iterator<Connection> iterator = openConnections.values().iterator(); iterator.hasNext(); ) {\r\n        Connection connection = iterator.next();\r\n        DBUtils.commit(connection);\r\n        DBUtils.closeQuietly(connection);\r\n        iterator.remove();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.File.listFiles",
	"Comment": "gets a list of child files of this directory, filtering them using the provided filter.",
	"Method": "File[] listFiles(File[] listFiles,FilenameFilter ff,File[] listFiles,FileFilter ff){\r\n    File[] arr = listFiles();\r\n    if (arr.length > 0) {\r\n        ArrayList<File> result = new ArrayList<File>();\r\n        for (File s : arr) {\r\n            if (ff.accept(s)) {\r\n                result.add(s);\r\n            }\r\n        }\r\n        File[] res = new File[result.size()];\r\n        result.toArray(res);\r\n        return res;\r\n    }\r\n    return arr;\r\n}"
}, {
	"Path": "com.codename1.ui.util.GlassTutorial.showOn",
	"Comment": "install the glass tutorial on a form and seamlessly dismiss it when no longer necessary",
	"Method": "void showOn(Form f){\r\n    Painter oldPane = f.getGlassPane();\r\n    f.setGlassPane(this);\r\n    Dialog dummy = new Dialog() {\r\n        public void keyReleased(int i) {\r\n            dispose();\r\n        }\r\n    };\r\n    int oldTint = f.getTintColor();\r\n    f.setTintColor(0);\r\n    dummy.getDialogStyle().setBgTransparency(0);\r\n    dummy.setDisposeWhenPointerOutOfBounds(true);\r\n    dummy.show(0, Display.getInstance().getDisplayHeight() - 2, 0, Display.getInstance().getDisplayWidth() - 2, true, true);\r\n    f.setTintColor(oldTint);\r\n    f.setGlassPane(oldPane);\r\n}"
}, {
	"Path": "com.codename1.ui.util.GlassTutorial.showOn",
	"Comment": "install the glass tutorial on a form and seamlessly dismiss it when no longer necessary",
	"Method": "void showOn(Form f){\r\n    dispose();\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.findLabelText",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "Label findLabelText(String text){\r\n    return TestUtils.findLabelText(text);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.promptInstallOnHomescreen",
	"Comment": "prompts the user to install this app on their homescreen.this is only relevant in the javascript port.",
	"Method": "boolean promptInstallOnHomescreen(){\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Collections.nCopies",
	"Comment": "returns a list containing the specified number of the specified element.the list cannot be modified. the list is serializable.",
	"Method": "List<T> nCopies(int length,T object){\r\n    return new CopiesList<T>(length, object);\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSEngine.applyCSS",
	"Comment": "a recursive method that tries to match all css selectors with the specified element",
	"Method": "void applyCSS(HTMLElement document,HTMLComponent htmlC,Vector externalCSS,Vector embeddedCSS,Vector applyCSS,HTMLElement element,HTMLComponent htmlC,CSSElement[] css,Vector nestedSelectors,Vector siblingSelectors){\r\n    String id = element.getAttributeById(HTMLElement.ATTR_ID);\r\n    String className = element.getAttributeById(HTMLElement.ATTR_CLASS);\r\n    Vector nextNestedSelectors = new Vector();\r\n    Vector nextSiblingSelectors = null;\r\n    if (!HTMLComponent.PROCESS_HTML_MP1_ONLY) {\r\n        nextSiblingSelectors = new Vector();\r\n    }\r\n    for (int e = 0; e < css.length; e++) {\r\n        CSSElement currentSelector = css[e];\r\n        checkSelector(currentSelector, element, htmlC, className, id, nextNestedSelectors, nextSiblingSelectors);\r\n    }\r\n    if (nestedSelectors != null) {\r\n        for (Enumeration e = nestedSelectors.elements(); e.hasMoreElements(); ) {\r\n            CSSElement currentSelector = (CSSElement) e.nextElement();\r\n            checkSelector(currentSelector, element, htmlC, className, id, nextNestedSelectors, nextSiblingSelectors);\r\n        }\r\n    }\r\n    if ((!HTMLComponent.PROCESS_HTML_MP1_ONLY) && (siblingSelectors != null)) {\r\n        for (Enumeration e = siblingSelectors.elements(); e.hasMoreElements(); ) {\r\n            CSSElement currentSelector = (CSSElement) e.nextElement();\r\n            checkSelector(currentSelector, element, htmlC, className, id, nextNestedSelectors, nextSiblingSelectors);\r\n        }\r\n    }\r\n    if (nextNestedSelectors.size() == 0) {\r\n        nextNestedSelectors = null;\r\n    }\r\n    if ((!HTMLComponent.PROCESS_HTML_MP1_ONLY) && (nextSiblingSelectors.size() == 0)) {\r\n        nextSiblingSelectors = null;\r\n    }\r\n    applyStyleAttribute(element, htmlC);\r\n    Vector curSiblingSelectors = null;\r\n    for (int i = 0; i < element.getNumChildren(); i++) {\r\n        HTMLElement child = (HTMLElement) element.getChildAt(i);\r\n        Vector v = applyCSS(child, htmlC, css, nextNestedSelectors, curSiblingSelectors);\r\n        if (!child.isTextElement()) {\r\n            curSiblingSelectors = v;\r\n        }\r\n    }\r\n    return nextSiblingSelectors;\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSEngine.setWrapText",
	"Comment": "replaces an unwrapped text with a wrapped version, while copying the style of the original text.",
	"Method": "void setWrapText(Label label,Vector words,HTMLElement element,HTMLComponent htmlC){\r\n    Style selectedStyle = label.getSelectedStyle();\r\n    Style unselectedStyle = label.getUnselectedStyle();\r\n    Vector ui = new Vector();\r\n    label.setText((String) words.elementAt(0) + ' ');\r\n    HTMLLink link = null;\r\n    if (label instanceof HTMLLink) {\r\n        link = (HTMLLink) label;\r\n    }\r\n    ui.addElement(label);\r\n    for (int i = 1; i < words.size(); i++) {\r\n        Label word = null;\r\n        if (link != null) {\r\n            word = new HTMLLink((String) words.elementAt(i) + ' ', link.link, htmlC, link, link.linkVisited);\r\n        } else {\r\n            word = new Label((String) words.elementAt(i) + ' ');\r\n        }\r\n        word.setSelectedStyle(selectedStyle);\r\n        word.setUnselectedStyle(unselectedStyle);\r\n        label.getParent().addComponent(word);\r\n        ui.addElement(word);\r\n    }\r\n    element.setAssociatedComponents(ui);\r\n    label.getParent().revalidate();\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.postShowImpl",
	"Comment": "this method allows binding an action that should occur immediately after showing the givenform",
	"Method": "void postShowImpl(Form f){\r\n    postShow(f);\r\n    analyticsCallback(f.getName(), getPreviousFormName(f));\r\n}"
}, {
	"Path": "io.atomix.copycat.server.protocol.LeaveResponse.builder",
	"Comment": "returns an leave response builder for an existing response.",
	"Method": "Builder builder(Builder builder,LeaveResponse response){\r\n    return new Builder(response);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.getCounterpartFontByAttribute",
	"Comment": "returns the counterpart font according to the given attribute and font",
	"Method": "HTMLFont getCounterpartFontByAttribute(int attribute,HTMLFont font){\r\n    HTMLFont cFont = font.getCounterpartFont(attribute);\r\n    if (cFont != null) {\r\n        return cFont;\r\n    }\r\n    HTMLFont bestFit = null;\r\n    Enumeration e = fonts.elements();\r\n    while (e.hasMoreElements()) {\r\n        HTMLFont hFont = (HTMLFont) e.nextElement();\r\n        if (hFont.isCounterpart(attribute, font)) {\r\n            if (attribute == HTMLFont.BIG) {\r\n                if ((bestFit == null) || (bestFit.getSize() > hFont.getSize())) {\r\n                    bestFit = hFont;\r\n                }\r\n            } else if (attribute == HTMLFont.SMALL) {\r\n                if ((bestFit == null) || (bestFit.getSize() < hFont.getSize())) {\r\n                    bestFit = hFont;\r\n                }\r\n            } else {\r\n                font.setCounterpartFont(attribute, hFont);\r\n                return hFont;\r\n            }\r\n        }\r\n    }\r\n    if (bestFit == null) {\r\n        bestFit = font;\r\n    }\r\n    font.setCounterpartFont(attribute, bestFit);\r\n    return bestFit;\r\n}"
}, {
	"Path": "com.codename1.ui.Image.drawImageArea",
	"Comment": "callback invoked internally by codename one to draw a portion of the image onto the display.image subclasses can override this method to perform drawing of custom image types.",
	"Method": "void drawImageArea(Graphics g,Object nativeGraphics,int x,int y,int imageX,int imageY,int imageWidth,int imageHeight){\r\n    Display.impl.drawImageArea(nativeGraphics, image, x, y, imageX, imageY, imageWidth, imageHeight);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.keyReleased",
	"Comment": "pushes a key release event with the given keycode into codename one",
	"Method": "void keyReleased(int keyCode){\r\n    keyRepeatCharged = false;\r\n    longPressCharged = false;\r\n    if (impl.getCurrentForm() == null) {\r\n        return;\r\n    }\r\n    if (!multiKeyMode) {\r\n        if (keyCode != lastKeyPressed) {\r\n            if (keyCode != previousKeyPressed) {\r\n                return;\r\n            } else {\r\n                previousKeyPressed = 0;\r\n            }\r\n        } else {\r\n            lastKeyPressed = 0;\r\n        }\r\n    }\r\n    addSingleArgumentEvent(KEY_RELEASED, keyCode);\r\n}"
}, {
	"Path": "com.codename1.ui.PickerComponent.createPickerInstance",
	"Comment": "allows developers to subclass the picker component instance to customizebehaviors of the subclass",
	"Method": "Picker createPickerInstance(){\r\n    return new Picker();\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isScreenSaverDisableSupported",
	"Comment": "checks if the device supports disabling the screen display from dimming, allowing the developer to keep the screen display on.",
	"Method": "boolean isScreenSaverDisableSupported(){\r\n    return impl.isScreenLockSupported();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.PriorityQueue.contains",
	"Comment": "answers if there is an element in this queue equals to the object.",
	"Method": "boolean contains(Object object){\r\n    if (object == null) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < size; i++) {\r\n        if (object.equals(elements[i])) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.io.JSONParser.parse",
	"Comment": "parses the given input stream into this object and returns the parse tree",
	"Method": "void parse(Reader i,JSONParseCallback callback,Hashtable<String, Object> parse,Reader i){\r\n    modern = false;\r\n    state = new Hashtable();\r\n    parseStack = new Vector();\r\n    currentKey = null;\r\n    parse(i, this);\r\n    return (Hashtable<String, Object>) state;\r\n}"
}, {
	"Path": "com.codename1.ui.util.UITimer.timer",
	"Comment": "convenience method to schedule a uitimer more easily on the current form",
	"Method": "UITimer timer(int timeMillis,boolean repeat,Form parent,Runnable r,UITimer timer,int timeMillis,boolean repeat,Runnable r){\r\n    UITimer uit = new UITimer(r);\r\n    uit.schedule(timeMillis, repeat, Display.getInstance().getCurrent());\r\n    return uit;\r\n}"
}, {
	"Path": "java.util.ArrayDeque.removeInternal",
	"Comment": "removes the element in the cursor position and shifts front elements tofill the gap if frontshift is true, shifts rear elements otherwise.",
	"Method": "void removeInternal(int current,boolean frontShift){\r\n    int cursor = current;\r\n    if (frontShift) {\r\n        while (cursor != front) {\r\n            int next = circularSmallerPos(cursor);\r\n            elements[cursor] = elements[next];\r\n            cursor = next;\r\n        }\r\n        front = circularBiggerPos(front);\r\n    } else {\r\n        while (cursor != rear) {\r\n            int next = circularBiggerPos(cursor);\r\n            elements[cursor] = elements[next];\r\n            cursor = next;\r\n        }\r\n        rear = circularSmallerPos(rear);\r\n    }\r\n    elements[cursor] = null;\r\n    resetStatus(false);\r\n}"
}, {
	"Path": "com.codename1.components.MultiButton.setShouldLocalize",
	"Comment": "indicates if text should be localized when set to the component, by defaultall text is localized so this allows disabling automatic localization for a specific component.",
	"Method": "void setShouldLocalize(boolean shouldLocalize){\r\n    firstRow.setShouldLocalize(shouldLocalize);\r\n    secondRow.setShouldLocalize(shouldLocalize);\r\n    thirdRow.setShouldLocalize(shouldLocalize);\r\n    forthRow.setShouldLocalize(shouldLocalize);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.UnitValue.getGlobalUnitConverters",
	"Comment": "returns the global converters currently registered. the platform converter will not be in this list.",
	"Method": "UnitConverter[] getGlobalUnitConverters(){\r\n    return CONVERTERS.toArray(new UnitConverter[CONVERTERS.size()]);\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.clickButtonByLabel",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "void clickButtonByLabel(String text){\r\n    TestUtils.clickButtonByLabel(text);\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.doLocationConsentSpecialErasure",
	"Comment": "actions needed to be done for the consent related location erasure",
	"Method": "void doLocationConsentSpecialErasure(){\r\n    resetLocationValues();\r\n    connectionQueue_.sendLocation();\r\n}"
}, {
	"Path": "com.codename1.ui.tree.Tree.setMultilineMode",
	"Comment": "toggles a mode where rows in the tree can be broken since span buttons willbe used instead of plain buttons.",
	"Method": "void setMultilineMode(boolean multilineMode){\r\n    this.multilineMode = multilineMode;\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testSequenceOperations",
	"Comment": "tests submitting a linearizable event that publishes to all sessions.",
	"Method": "void testSequenceOperations(int nodes,Query.ConsistencyLevel consistency){\r\n    createServers(nodes);\r\n    AtomicInteger counter = new AtomicInteger();\r\n    AtomicLong index = new AtomicLong();\r\n    CopycatClient client = createClient();\r\n    client.<Long>onEvent(\"test\", message -> {\r\n        threadAssertEquals(counter.incrementAndGet(), 3);\r\n        threadAssertTrue(message >= index.get());\r\n        index.set(message);\r\n        resume();\r\n    });\r\n    client.submit(new TestCommand()).thenAccept(result -> {\r\n        threadAssertNotNull(result);\r\n        threadAssertEquals(counter.incrementAndGet(), 1);\r\n        threadAssertTrue(index.compareAndSet(0, result));\r\n        resume();\r\n    });\r\n    client.submit(new TestEvent(true)).thenAccept(result -> {\r\n        threadAssertNotNull(result);\r\n        threadAssertEquals(counter.incrementAndGet(), 2);\r\n        threadAssertTrue(result > index.get());\r\n        index.set(result);\r\n        resume();\r\n    });\r\n    client.submit(new TestQuery(consistency)).thenAccept(result -> {\r\n        threadAssertNotNull(result);\r\n        threadAssertEquals(counter.incrementAndGet(), 4);\r\n        long i = index.get();\r\n        threadAssertTrue(result >= i);\r\n        resume();\r\n    });\r\n    await(30000, 4);\r\n}"
}, {
	"Path": "io.prometheus.client.cache.caffeine.CacheMetricsCollector.clear",
	"Comment": "remove all caches.any references to all caches are invalidated.",
	"Method": "void clear(){\r\n    children.clear();\r\n}"
}, {
	"Path": "com.codename1.components.SignatureComponent.fireActionEvent",
	"Comment": "fires an event to all listeners to notify them that the signature image hasbeen changed.",
	"Method": "void fireActionEvent(){\r\n    eventDispatcher.fireActionEvent(new ActionEvent(this));\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GroupLayout.getHonorsVisibility",
	"Comment": "returns whether component visibility is considered when sizing andpositioning components.",
	"Method": "boolean getHonorsVisibility(){\r\n    return honorsVisibility;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.isTouchMenus",
	"Comment": "indicates whether the menu ui should target a touch based device or astandard cell phone",
	"Method": "boolean isTouchMenus(){\r\n    int t = Display.getInstance().getCommandBehavior();\r\n    return t == Display.COMMAND_BEHAVIOR_TOUCH_MENU || (t == Display.COMMAND_BEHAVIOR_DEFAULT && Display.getInstance().isTouchScreenDevice());\r\n}"
}, {
	"Path": "com.codename1.ui.CN.updateNetworkThreadCount",
	"Comment": "sets the number of network threads and restarts the network threads",
	"Method": "void updateNetworkThreadCount(int threadCount){\r\n    NetworkManager.getInstance().updateThreadCount(threadCount);\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.setCursorBlinkTimeOn",
	"Comment": "the amount of time in milliseconds in which the cursor is visible",
	"Method": "void setCursorBlinkTimeOn(int time){\r\n    blinkOnTime = time;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getBottomGap",
	"Comment": "returns the gap to be left for the bottom scrollbar on the x axis. thismethod is used by layout managers to determine the room they shouldleave for the scrollbar",
	"Method": "int getBottomGap(){\r\n    if (isScrollableX() && isScrollVisible()) {\r\n        return getUIManager().getLookAndFeel().getHorizontalScrollHeight();\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.codename1.ui.events.ActionEvent.getDropTarget",
	"Comment": "set in the case of a drop listener, returns the component on which the drop occurs",
	"Method": "Component getDropTarget(){\r\n    return (Component) sourceComponent;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.removeCommandListener",
	"Comment": "a listener that is invoked when a command is clicked allowing multiple commandsto be handled by a single block",
	"Method": "void removeCommandListener(ActionListener l){\r\n    commandListener.removeListener(l);\r\n}"
}, {
	"Path": "com.codename1.charts.renderers.XYMultipleSeriesRenderer.getXLabelsAlign",
	"Comment": "returns the x axis labels alignment.one of component.center, component.left, component.right",
	"Method": "int getXLabelsAlign(){\r\n    return xLabelsAlign;\r\n}"
}, {
	"Path": "com.codename1.impl.android.AndroidGraphics.drawLabelString",
	"Comment": "implements the drawstring for the text component and adjust the valignassuming the icon is in one of the sides",
	"Method": "int drawLabelString(Object nativeFont,String text,int x,int y,int textSpaceW,boolean isTickerRunning,int tickerShiftText,int textDecoration,boolean rtl,boolean endsWith3Points,int textWidth,int fontHeight){\r\n    int cx = getClipX();\r\n    int cy = getClipY();\r\n    int cw = getClipWidth();\r\n    int ch = getClipHeight();\r\n    clipRect(x, cy, textSpaceW, ch);\r\n    int drawnW = drawLabelText(textDecoration, rtl, isTickerRunning, endsWith3Points, nativeFont, textWidth, textSpaceW, tickerShiftText, text, x, y, fontHeight);\r\n    setClip(cx, cy, cw, ch);\r\n    return drawnW;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.LC.isFillY",
	"Comment": "if the layout should always claim the whole bounds of the laid out container even if the preferred size is smaller.",
	"Method": "boolean isFillY(){\r\n    return fillY;\r\n}"
}, {
	"Path": "com.codename1.util.regex.StreamCharacterIterator.read",
	"Comment": "reads n characters from the stream and appends them to the buffer",
	"Method": "int read(int n){\r\n    if (closed) {\r\n        return 0;\r\n    }\r\n    int c;\r\n    int i = n;\r\n    while (--i >= 0) {\r\n        c = is.read();\r\n        if (c < 0) {\r\n            closed = true;\r\n            break;\r\n        }\r\n        buff.append((char) c);\r\n    }\r\n    return n - i;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.LC.isFillX",
	"Comment": "if the layout should always claim the whole bounds of the laid out container even if the preferred size is smaller.",
	"Method": "boolean isFillX(){\r\n    return fillX;\r\n}"
}, {
	"Path": "org.conscrypt.ClientSessionContext.getCachedSession",
	"Comment": "gets the suitable session reference from the session cache container.",
	"Method": "NativeSslSession getCachedSession(String hostName,int port,SSLParametersImpl sslParameters){\r\n    if (hostName == null) {\r\n        return null;\r\n    }\r\n    NativeSslSession session = getSession(hostName, port);\r\n    if (session == null) {\r\n        return null;\r\n    }\r\n    String protocol = session.getProtocol();\r\n    boolean protocolFound = false;\r\n    for (String enabledProtocol : sslParameters.enabledProtocols) {\r\n        if (protocol.equals(enabledProtocol)) {\r\n            protocolFound = true;\r\n            break;\r\n        }\r\n    }\r\n    if (!protocolFound) {\r\n        return null;\r\n    }\r\n    String cipherSuite = session.getCipherSuite();\r\n    boolean cipherSuiteFound = false;\r\n    for (String enabledCipherSuite : sslParameters.getEnabledCipherSuites()) {\r\n        if (cipherSuite.equals(enabledCipherSuite)) {\r\n            cipherSuiteFound = true;\r\n            break;\r\n        }\r\n    }\r\n    if (!cipherSuiteFound) {\r\n        return null;\r\n    }\r\n    if (session.isSingleUse()) {\r\n        removeSession(session);\r\n    }\r\n    return session;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getAnimationMotion",
	"Comment": "allows defining the physics for the animation motion behavior directly by plugging in an alternative motion object",
	"Method": "Motion getAnimationMotion(){\r\n    return animationMotion;\r\n}"
}, {
	"Path": "com.codename1.impl.ios.Lifecycle.shouldApplicationHandleURL",
	"Comment": "indicates whether the application should handle the given url, defaults to true",
	"Method": "boolean shouldApplicationHandleURL(String url,String caller){\r\n    return true;\r\n}"
}, {
	"Path": "android.support.v4.widget.SimpleCursorAdapter.setStringConversionColumn",
	"Comment": "defines the index of the column in the cursor used to get a stringrepresentation of that cursor. the column is used to convert thecursor to a string only when the current cursortostringconverteris null.",
	"Method": "void setStringConversionColumn(int stringConversionColumn){\r\n    mStringConversionColumn = stringConversionColumn;\r\n}"
}, {
	"Path": "com.codename1.ui.painter.PainterChain.addPainter",
	"Comment": "creates a new chain based on the existing chain with the new element addedat the end",
	"Method": "PainterChain addPainter(Painter p){\r\n    if (chain.length != 0) {\r\n        Painter[] newChain = new Painter[chain.length + 1];\r\n        System.arraycopy(chain, 0, newChain, 0, chain.length);\r\n        newChain[chain.length] = p;\r\n        return new PainterChain(newChain);\r\n    }\r\n    return new PainterChain(new Painter[] { p });\r\n}"
}, {
	"Path": "com.codename1.io.BufferedInputStream.getConnection",
	"Comment": "if applicable this member represents the connection object for the stream",
	"Method": "Object getConnection(){\r\n    return connection;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.setLeadComponent",
	"Comment": "sets the lead component for this container, a lead component takes over the entirecomponent hierarchy and receives all the events for the container hierarchy.",
	"Method": "void setLeadComponent(Component lead){\r\n    leadComponent = lead;\r\n    if (lead == null) {\r\n        setFocusable(false);\r\n        hasLead = false;\r\n        enableFocusAndDeinitLead(this);\r\n    } else {\r\n        if (isInitialized()) {\r\n            initLead();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.getEmpty",
	"Comment": "returns an empty border, this is mostly useful for overriding components thathave a border by default",
	"Method": "Border getEmpty(){\r\n    if (empty == null) {\r\n        empty = new Border();\r\n    }\r\n    return empty;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Timeline.getSize",
	"Comment": "returns the pixel based unscaled dimentions of this timeline",
	"Method": "Dimension getSize(){\r\n    return size;\r\n}"
}, {
	"Path": "com.codename1.ui.scene.Node.setRenderAsImage",
	"Comment": "sets the render as image flag.true to render this node as an image.",
	"Method": "void setRenderAsImage(boolean t){\r\n    renderAsImage = t;\r\n}"
}, {
	"Path": "io.atomix.copycat.client.session.ClientSessionState.setEventIndex",
	"Comment": "sets the highest index for which an event has been received in sequence.",
	"Method": "ClientSessionState setEventIndex(long eventIndex){\r\n    this.eventIndex = eventIndex;\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.getSelectMenuItem",
	"Comment": "this method returns the select menu item, when a menu is opened",
	"Method": "Command getSelectMenuItem(){\r\n    return selectMenuItem;\r\n}"
}, {
	"Path": "com.codename1.ui.Tabs.removeTabAt",
	"Comment": "removes the tab at index.after the component associated with index is removed,its visibility is reset to true to ensure it will be visibleif added to other containers.",
	"Method": "void removeTabAt(int index){\r\n    checkIndex(index);\r\n    int act = activeComponent - 1;\r\n    act = Math.max(act, 0);\r\n    setSelectedIndex(act);\r\n    Component key = tabsContainer.getComponentAt(index);\r\n    tabsContainer.removeComponent(key);\r\n    Component content = contentPane.getComponentAt(index);\r\n    contentPane.removeComponent(content);\r\n    setTabsLayout(tabPlacement);\r\n}"
}, {
	"Path": "com.codename1.components.InteractionDialog.disposeToTheLeft",
	"Comment": "removes the interaction dialog from view with an animation to the left",
	"Method": "void disposeToTheLeft(){\r\n    disposeTo(Component.LEFT);\r\n}"
}, {
	"Path": "org.conscrypt.Platform.wrapSocketFactoryIfNeeded",
	"Comment": "wrap the socketfactory with the platform wrapper if needed for compatability.",
	"Method": "SSLSocketFactory wrapSocketFactoryIfNeeded(OpenSSLSocketFactoryImpl factory){\r\n    return factory;\r\n}"
}, {
	"Path": "org.conscrypt.java.security.TestKeyStore.getClientEcEcCertificate",
	"Comment": "return a client keystore with a matched rsa certificate andprivate key as well as a ca certificate.",
	"Method": "TestKeyStore getClientEcEcCertificate(){\r\n    initCerts();\r\n    return CLIENT_EC_EC_CERTIFICATE;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the returned setdoes not support adding.",
	"Method": "Set<K> keySet(){\r\n    if (keySet == null) {\r\n        keySet = new AbstractSet<K>() {\r\n            @Override\r\n            public boolean contains(Object object) {\r\n                return containsKey(object);\r\n            }\r\n            @Override\r\n            public int size() {\r\n                return AbstractMap.this.size();\r\n            }\r\n            @Override\r\n            public Iterator<K> iterator() {\r\n                return new Iterator<K>() {\r\n                    Iterator<Map.Entry<K, V>> setIterator = entrySet().iterator();\r\n                    public boolean hasNext() {\r\n                        return setIterator.hasNext();\r\n                    }\r\n                    public K next() {\r\n                        return setIterator.next().getKey();\r\n                    }\r\n                    public void remove() {\r\n                        setIterator.remove();\r\n                    }\r\n                };\r\n            }\r\n        };\r\n    }\r\n    return keySet;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the returned setdoes not support adding.",
	"Method": "Set<K> keySet(){\r\n    return containsKey(object);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the returned setdoes not support adding.",
	"Method": "Set<K> keySet(){\r\n    return AbstractMap.this.size();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the returned setdoes not support adding.",
	"Method": "Set<K> keySet(){\r\n    return new Iterator<K>() {\r\n        Iterator<Map.Entry<K, V>> setIterator = entrySet().iterator();\r\n        public boolean hasNext() {\r\n            return setIterator.hasNext();\r\n        }\r\n        public K next() {\r\n            return setIterator.next().getKey();\r\n        }\r\n        public void remove() {\r\n            setIterator.remove();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the returned setdoes not support adding.",
	"Method": "Set<K> keySet(){\r\n    return setIterator.hasNext();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the returned setdoes not support adding.",
	"Method": "Set<K> keySet(){\r\n    return setIterator.next().getKey();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the returned setdoes not support adding.",
	"Method": "Set<K> keySet(){\r\n    setIterator.remove();\r\n}"
}, {
	"Path": "com.codename1.components.ReplaceableImage.replace",
	"Comment": "replaces the current image with the new image which must match the dimensionsetc. of the previous image.",
	"Method": "void replace(EncodedImage newImage){\r\n    data = newImage.getImageData();\r\n    super.resetCache();\r\n    replaced = true;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.getActualDisplayHeight",
	"Comment": "returns the display height ignoring manipulations performed by the vkb",
	"Method": "int getActualDisplayHeight(){\r\n    return getDisplayHeight();\r\n}"
}, {
	"Path": "com.codename1.maps.Tile.setTileLoadingText",
	"Comment": "sets a static text to paint.this will be used if the map if the tile image is not available yet andthe tileloadingimage is null",
	"Method": "void setTileLoadingText(String tileLoadingText){\r\n    Tile.tileLoadingText = tileLoadingText;\r\n}"
}, {
	"Path": "org.conscrypt.java.security.TestKeyStore.getClientEcRsaCertificate",
	"Comment": "return a client keystore with a matched rsa certificate andprivate key as well as a ca certificate.",
	"Method": "TestKeyStore getClientEcRsaCertificate(){\r\n    initCerts();\r\n    return CLIENT_EC_RSA_CERTIFICATE;\r\n}"
}, {
	"Path": "java.lang.Character.digit",
	"Comment": "returns the numeric value of the character ch in the specified radix.",
	"Method": "int digit(char ch,int radix){\r\n    if (radix < MIN_RADIX || radix > MAX_RADIX) {\r\n        return -1;\r\n    }\r\n    if (codePoint < 128) {\r\n        int result = -1;\r\n        if ('0' <= codePoint && codePoint <= '9') {\r\n            result = codePoint - '0';\r\n        } else if ('a' <= codePoint && codePoint <= 'z') {\r\n            result = 10 + (codePoint - 'a');\r\n        } else if ('A' <= codePoint && codePoint <= 'Z') {\r\n            result = 10 + (codePoint - 'A');\r\n        }\r\n        return result < radix ? result : -1;\r\n    }\r\n    return codePoint;\r\n}"
}, {
	"Path": "android.support.v4.view.ViewPager.addTouchables",
	"Comment": "we only want the current page that is being shown to be touchable.",
	"Method": "void addTouchables(ArrayList<View> views){\r\n    for (int i = 0; i < getChildCount(); i++) {\r\n        final View child = getChildAt(i);\r\n        if (child.getVisibility() == VISIBLE) {\r\n            ItemInfo ii = infoForChild(child);\r\n            if (ii != null && ii.position == mCurItem) {\r\n                child.addTouchables(views);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.ToastBar.showInfoMessage",
	"Comment": "simplifies a common use case of showing an information message with an info icon that fades out after a few seconds",
	"Method": "Status showInfoMessage(String msg){\r\n    return showMessage(msg, FontImage.MATERIAL_INFO, defaultMessageTimeout);\r\n}"
}, {
	"Path": "com.codename1.ui.BrowserComponent.fireWebEvent",
	"Comment": "used internally by the implementation to fire an event from the native browser widget",
	"Method": "void fireWebEvent(String type,ActionEvent ev){\r\n    if (onLoad.equals(type)) {\r\n        synchronized (readyLock) {\r\n            ready = true;\r\n            readyLock.notifyAll();\r\n        }\r\n    }\r\n    EventDispatcher e = getEventDispatcher(type, false);\r\n    if (e != null) {\r\n        e.fireActionEvent(ev);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.BufferedOutputStream.close",
	"Comment": "closes this output stream and releases any system resourcesassociated with the stream.the close method of filteroutputstreamcalls its flush method, and then calls theclose method of its underlying output stream.",
	"Method": "void close(){\r\n    if (!closed) {\r\n        streamCount--;\r\n        Util.getImplementation().closingOutput(out);\r\n        Util.getImplementation().logStreamClose(name, false, streamCount);\r\n        try {\r\n            flush();\r\n        } catch (Exception ignored) {\r\n        } finally {\r\n            Util.cleanup(out);\r\n        }\r\n        if (connection != null) {\r\n            Util.getImplementation().cleanup(connection);\r\n        }\r\n        closed = true;\r\n    } else {\r\n        Util.getImplementation().logStreamDoubleClose(name, false);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.bottomRightMode",
	"Comment": "true to draw the bottom right corner rounded, false to draw it as a corner",
	"Method": "RoundRectBorder bottomRightMode(boolean bottomRight){\r\n    this.bottomRight = bottomRight;\r\n    return this;\r\n}"
}, {
	"Path": "android.support.v4.widget.SlidingPaneLayout.smoothSlideTo",
	"Comment": "smoothly animate mdraggingpane to the target x position within its range.",
	"Method": "boolean smoothSlideTo(float slideOffset,int velocity){\r\n    if (!mCanSlide) {\r\n        return false;\r\n    }\r\n    final LayoutParams lp = (LayoutParams) mSlideableView.getLayoutParams();\r\n    final int leftBound = getPaddingLeft() + lp.leftMargin;\r\n    int x = (int) (leftBound + slideOffset * mSlideRange);\r\n    if (mDragHelper.smoothSlideViewTo(mSlideableView, x, mSlideableView.getTop())) {\r\n        setAllChildrenVisible();\r\n        ViewCompat.postInvalidateOnAnimation(this);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GroupLayout.createTopLevelGroup",
	"Comment": "wraps the user specified group in a sequential group.if container gaps should be generate the necessary springs areadded.",
	"Method": "Group createTopLevelGroup(Group specifiedGroup){\r\n    SequentialGroup group = createSequentialGroup();\r\n    if (getAutocreateContainerGaps()) {\r\n        group.addSpring(new ContainerAutopaddingSpring());\r\n        group.add(specifiedGroup);\r\n        group.addSpring(new ContainerAutopaddingSpring());\r\n    } else {\r\n        group.add(specifiedGroup);\r\n    }\r\n    return group;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GroupLayout.toString",
	"Comment": "returns a textual description of this grouplayout.the return valueis intended for debugging purposes only.",
	"Method": "String toString(String toString,String toString,String toString,ComponentSpring spring,String toString){\r\n    if (springsChanged) {\r\n        registerComponents(horizontalGroup, HORIZONTAL);\r\n        registerComponents(verticalGroup, VERTICAL);\r\n    }\r\n    StringBuffer buffer = new StringBuffer();\r\n    buffer.append(\"HORIZONTAL\\n\");\r\n    dump(buffer, horizontalGroup, \"  \", HORIZONTAL);\r\n    buffer.append(\"\\nVERTICAL\\n\");\r\n    dump(buffer, verticalGroup, \"  \", VERTICAL);\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "com.codename1.properties.PreferencesObject.setName",
	"Comment": "sets the name of the specific field not including the prefix, by default the property name is used",
	"Method": "PreferencesObject setName(PropertyBase pb,String name){\r\n    checkBind();\r\n    pb.putClientProperty(\"cn1-po-name\", name);\r\n    return this;\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.roundedSecondsSinceLastSessionDurationUpdate",
	"Comment": "calculates the unsent session duration in seconds, rounded to the nearest int.",
	"Method": "int roundedSecondsSinceLastSessionDurationUpdate(){\r\n    final long currentTimestampInNanoseconds = System.nanoTime();\r\n    final long unsentSessionLengthInNanoseconds = currentTimestampInNanoseconds - prevSessionDurationStartTime_;\r\n    prevSessionDurationStartTime_ = currentTimestampInNanoseconds;\r\n    return (int) Math.round(unsentSessionLengthInNanoseconds / 1000000000.0d);\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.Log.isClosed",
	"Comment": "returns a boolean value indicating whether the log is closed.",
	"Method": "boolean isClosed(){\r\n    return !open;\r\n}"
}, {
	"Path": "com.codename1.util.Base64.decode",
	"Comment": "decodes an array of bytes containing a base64 ascii string into binary data",
	"Method": "byte[] decode(byte[] in,byte[] decode,byte[] in,int len){\r\n    int length = len / 4 * 3;\r\n    if (length == 0) {\r\n        return new byte[0];\r\n    }\r\n    byte[] out = new byte[length];\r\n    int pad = 0;\r\n    byte chr;\r\n    for (; ; len--) {\r\n        chr = in[len - 1];\r\n        if ((chr == '\\n') || (chr == '\\r') || (chr == ' ') || (chr == '\\t')) {\r\n            continue;\r\n        }\r\n        if (chr == '=') {\r\n            pad++;\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    int out_index = 0;\r\n    int in_index = 0;\r\n    int bits = 0;\r\n    int quantum = 0;\r\n    for (int i = 0; i < len; i++) {\r\n        chr = in[i];\r\n        if (chr == '=') {\r\n            break;\r\n        }\r\n        if ((chr == '\\n') || (chr == '\\r') || (chr == ' ') || (chr == '\\t')) {\r\n            continue;\r\n        }\r\n        if ((chr >= 'A') && (chr <= 'Z')) {\r\n            bits = chr - 65;\r\n        } else if ((chr >= 'a') && (chr <= 'z')) {\r\n            bits = chr - 71;\r\n        } else if ((chr >= '0') && (chr <= '9')) {\r\n            bits = chr + 4;\r\n        } else if (chr == '+') {\r\n            bits = 62;\r\n        } else if (chr == '/') {\r\n            bits = 63;\r\n        } else {\r\n            return null;\r\n        }\r\n        quantum = (quantum << 6) | (byte) bits;\r\n        if (in_index % 4 == 3) {\r\n            out[out_index++] = (byte) ((quantum & 0x00FF0000) >> 16);\r\n            out[out_index++] = (byte) ((quantum & 0x0000FF00) >> 8);\r\n            out[out_index++] = (byte) (quantum & 0x000000FF);\r\n        }\r\n        in_index++;\r\n    }\r\n    if (pad > 0) {\r\n        quantum = quantum << (6 * pad);\r\n        out[out_index++] = (byte) ((quantum & 0x00FF0000) >> 16);\r\n        if (pad == 1) {\r\n            out[out_index++] = (byte) ((quantum & 0x0000FF00) >> 8);\r\n        }\r\n    }\r\n    byte[] result = new byte[out_index];\r\n    System.arraycopy(out, 0, result, 0, out_index);\r\n    return result;\r\n}"
}, {
	"Path": "com.codename1.util.AbstractStringBuilder.trimToSize",
	"Comment": "trims off any extra capacity beyond the current length. note, this methodis not guaranteed to change the capacity of this object.",
	"Method": "void trimToSize(){\r\n    if (count < value.length) {\r\n        char[] newValue = new char[count];\r\n        System.arraycopy(value, 0, newValue, 0, count);\r\n        value = newValue;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Image.scaledSmallerRatio",
	"Comment": "scales the image while maintaining the aspect ratio to the smaller size image",
	"Method": "Image scaledSmallerRatio(int width,int height){\r\n    float hRatio = ((float) height) / ((float) getHeight());\r\n    float wRatio = ((float) width) / ((float) getWidth());\r\n    if (hRatio < wRatio) {\r\n        return scaled((int) (getWidth() * hRatio), height);\r\n    } else {\r\n        return scaled(width, (int) (getHeight() * wRatio));\r\n    }\r\n}"
}, {
	"Path": "com.codename1.charts.renderers.SimpleSeriesRenderer.isShowLegendItem",
	"Comment": "returns if the legend item for this renderer should be visible.",
	"Method": "boolean isShowLegendItem(){\r\n    return mShowLegendItem;\r\n}"
}, {
	"Path": "com.codename1.io.tar.Octal.parseOctal",
	"Comment": "parse an octal string from a header buffer. this is used for the filepermission mode value.",
	"Method": "long parseOctal(byte[] header,int offset,int length){\r\n    long result = 0;\r\n    boolean stillPadding = true;\r\n    int end = offset + length;\r\n    for (int i = offset; i < end; ++i) {\r\n        if (header[i] == 0)\r\n            break;\r\n        if (header[i] == (byte) ' ' || header[i] == '0') {\r\n            if (stillPadding)\r\n                continue;\r\n            if (header[i] == (byte) ' ')\r\n                break;\r\n        }\r\n        stillPadding = false;\r\n        result = (result << 3) + (header[i] - '0');\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.codename1.util.EasyThread.runAndWait",
	"Comment": "invokes the given runnable on the thread and waits for its execution to complete",
	"Method": "void runAndWait(Runnable r){\r\n    final boolean[] flag = new boolean[1];\r\n    synchronized (LOCK) {\r\n        queue.add(new Runnable() {\r\n            public void run() {\r\n                r.run();\r\n                synchronized (flag) {\r\n                    flag[0] = true;\r\n                    flag.notify();\r\n                }\r\n            }\r\n        });\r\n        LOCK.notify();\r\n    }\r\n    Display.getInstance().invokeAndBlock(new Runnable() {\r\n        public void run() {\r\n            synchronized (flag) {\r\n                if (!flag[0]) {\r\n                    Util.wait(flag);\r\n                }\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.codename1.util.EasyThread.runAndWait",
	"Comment": "invokes the given runnable on the thread and waits for its execution to complete",
	"Method": "void runAndWait(Runnable r){\r\n    r.run();\r\n    synchronized (flag) {\r\n        flag[0] = true;\r\n        flag.notify();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.util.EasyThread.runAndWait",
	"Comment": "invokes the given runnable on the thread and waits for its execution to complete",
	"Method": "void runAndWait(Runnable r){\r\n    synchronized (flag) {\r\n        if (!flag[0]) {\r\n            Util.wait(flag);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLForm.setEmptyOK",
	"Comment": "sets whether the specified input field can be left empty or not",
	"Method": "void setEmptyOK(TextArea ta,boolean ok){\r\n    if (ok) {\r\n        emptyOk.addElement(ta);\r\n    } else {\r\n        emptyNotOk.addElement(ta);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayoutStyle.getContainerGap",
	"Comment": "returns the amount of space to position a component inside itsparent.",
	"Method": "int getContainerGap(Component component,int position,Container parent){\r\n    if (position != GroupLayout.NORTH && position != GroupLayout.SOUTH && position != GroupLayout.WEST && position != GroupLayout.EAST) {\r\n        throw new IllegalArgumentException(\"Invalid position\");\r\n    }\r\n    if (component == null) {\r\n        throw new IllegalArgumentException(\"Component must be non-null\");\r\n    }\r\n    return Display.getInstance().convertToPixels(2, true);\r\n}"
}, {
	"Path": "org.commonmark.internal.HeadingParser.getAtxHeading",
	"Comment": "must be preceded by a space and may be followed by spaces only.",
	"Method": "HeadingParser getAtxHeading(CharSequence line,int index){\r\n    int level = Parsing.skip('#', line, index, line.length()) - index;\r\n    if (level == 0 || level > 6) {\r\n        return null;\r\n    }\r\n    int start = index + level;\r\n    if (start >= line.length()) {\r\n        return new HeadingParser(level, \"\");\r\n    }\r\n    char next = line.charAt(start);\r\n    if (!(next == ' ' || next == '\\t')) {\r\n        return null;\r\n    }\r\n    int beforeSpace = Parsing.skipSpaceTabBackwards(line, line.length() - 1, start);\r\n    int beforeHash = Parsing.skipBackwards('#', line, beforeSpace, start);\r\n    int beforeTrailer = Parsing.skipSpaceTabBackwards(line, beforeHash, start);\r\n    if (beforeTrailer != beforeHash) {\r\n        return new HeadingParser(level, line.subSequence(start, beforeTrailer + 1).toString());\r\n    } else {\r\n        return new HeadingParser(level, line.subSequence(start, beforeSpace + 1).toString());\r\n    }\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.tasks.io.URLImageSource.getSource",
	"Comment": "returns the url from which the source image is retrieved from.",
	"Method": "URL getSource(){\r\n    return url;\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.reloadContainer",
	"Comment": "useful tool to refresh the current state of a container shown using show containerwithout pushing another instance to the back stack",
	"Method": "void reloadContainer(Component cnt){\r\n    Container newCnt = createContainer(fetchResourceFile(), cnt.getName(), (EmbeddedContainer) cnt.getParent());\r\n    beforeShowContainer(newCnt);\r\n    cnt.getParent().replace(cnt, newCnt, null);\r\n    postShowContainer(newCnt);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isGalleryTypeSupported",
	"Comment": "checks to see if the given gallery type is supported on the current platform.",
	"Method": "boolean isGalleryTypeSupported(int type){\r\n    return impl.isGalleryTypeSupported(type);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GroupLayout.replace",
	"Comment": "removes an existing component replacing it with the specified component.",
	"Method": "void replace(Component existingComponent,Component newComponent){\r\n    if (existingComponent == null || newComponent == null) {\r\n        throw new IllegalArgumentException(\"Components must be non-null\");\r\n    }\r\n    if (springsChanged) {\r\n        registerComponents(horizontalGroup, HORIZONTAL);\r\n        registerComponents(verticalGroup, VERTICAL);\r\n    }\r\n    ComponentInfo info = (ComponentInfo) componentInfos.remove(existingComponent);\r\n    if (info == null) {\r\n        throw new IllegalArgumentException(\"Component must already exist\");\r\n    }\r\n    host.removeComponent(existingComponent);\r\n    if (newComponent.getParent() != host) {\r\n        host.addComponent(newComponent);\r\n    }\r\n    info.setComponent(newComponent);\r\n    componentInfos.put(newComponent, info);\r\n    invalidateHost();\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isSimulator",
	"Comment": "allows detecting development mode so debugging code and special cases can be used to simplify flow",
	"Method": "boolean isSimulator(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.charts.views.PieMapper.areAllSegmentPresent",
	"Comment": "if we have all piechart config then there is no point in reloading it",
	"Method": "boolean areAllSegmentPresent(int datasetSize){\r\n    return mPieSegmentList.size() == datasetSize;\r\n}"
}, {
	"Path": "com.codename1.charts.views.TimeChart.setDateFormat",
	"Comment": "sets the date format pattern to be used for formatting the x axis labels.",
	"Method": "void setDateFormat(String format){\r\n    mDateFormat = format;\r\n}"
}, {
	"Path": "com.codename1.ui.List.setHintIcon",
	"Comment": "sets the textarea hint icon, the hint is displayed on the textareawhen there is no text in the textarea",
	"Method": "void setHintIcon(Image icon){\r\n    setHint(getHint(), icon);\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.removeDataChangeListener",
	"Comment": "allows tracking selection changes in the calendar in real time",
	"Method": "void removeDataChangeListener(DataChangedListener l){\r\n    mv.removeDataChangedListener(l);\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.getCachedData",
	"Comment": "this method should be overriden in cachemode.manual to provide offline caching. the defaultimplementation will work as expected in the cachemode.smart mode.",
	"Method": "InputStream getCachedData(){\r\n    if (destinationFile != null) {\r\n        if (FileSystemStorage.getInstance().exists(destinationFile)) {\r\n            return FileSystemStorage.getInstance().openInputStream(destinationFile);\r\n        }\r\n        return null;\r\n    }\r\n    if (destinationStorage != null) {\r\n        if (Storage.getInstance().exists(destinationFile)) {\r\n            return Storage.getInstance().createInputStream(destinationFile);\r\n        }\r\n        return null;\r\n    }\r\n    String s = getCacheFileName();\r\n    if (FileSystemStorage.getInstance().exists(s)) {\r\n        return FileSystemStorage.getInstance().openInputStream(s);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLParser.createNewTextElement",
	"Comment": "overrides xmlparser.createnewtextelement to return an htmlelement instance",
	"Method": "Element createNewTextElement(String text){\r\n    HTMLElement elem = new HTMLElement(text, true);\r\n    return elem;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.areMutableImagesFast",
	"Comment": "on most platforms it is quite fast to draw on a mutable image and then render thatimage, however some platforms have much slower mutable images in comparison to justdrawing on the screen. these platforms should return false here and codename one will tryto use less mutable image related optimizations in transitions and other operations.",
	"Method": "boolean areMutableImagesFast(){\r\n    return impl.areMutableImagesFast();\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.connectSocket",
	"Comment": "creates a socket to connect to the given host on the given port",
	"Method": "Object connectSocket(String host,int port){\r\n    throw new RuntimeException(\"Not supported\");\r\n}"
}, {
	"Path": "android.support.v4.view.ViewPager.setAdapter",
	"Comment": "set a pageradapter that will supply views for this pager as needed.",
	"Method": "void setAdapter(PagerAdapter adapter){\r\n    if (mAdapter != null) {\r\n        mAdapter.unregisterDataSetObserver(mObserver);\r\n        mAdapter.startUpdate(this);\r\n        for (int i = 0; i < mItems.size(); i++) {\r\n            final ItemInfo ii = mItems.get(i);\r\n            mAdapter.destroyItem(this, ii.position, ii.object);\r\n        }\r\n        mAdapter.finishUpdate(this);\r\n        mItems.clear();\r\n        removeNonDecorViews();\r\n        mCurItem = 0;\r\n        scrollTo(0, 0);\r\n    }\r\n    final PagerAdapter oldAdapter = mAdapter;\r\n    mAdapter = adapter;\r\n    mExpectedAdapterCount = 0;\r\n    if (mAdapter != null) {\r\n        if (mObserver == null) {\r\n            mObserver = new PagerObserver();\r\n        }\r\n        mAdapter.registerDataSetObserver(mObserver);\r\n        mPopulatePending = false;\r\n        final boolean wasFirstLayout = mFirstLayout;\r\n        mFirstLayout = true;\r\n        mExpectedAdapterCount = mAdapter.getCount();\r\n        if (mRestoredCurItem >= 0) {\r\n            mAdapter.restoreState(mRestoredAdapterState, mRestoredClassLoader);\r\n            setCurrentItemInternal(mRestoredCurItem, false, true);\r\n            mRestoredCurItem = -1;\r\n            mRestoredAdapterState = null;\r\n            mRestoredClassLoader = null;\r\n        } else if (!wasFirstLayout) {\r\n            populate();\r\n        } else {\r\n            requestLayout();\r\n        }\r\n    }\r\n    if (mAdapterChangeListener != null && oldAdapter != adapter) {\r\n        mAdapterChangeListener.onAdapterChanged(oldAdapter, adapter);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.SplitPane.setPreferredInset",
	"Comment": "sets the preferred inset of this split pane.the preferred inset will be automatically changed whenever the user explicitly moves the divider to a new position.",
	"Method": "void setPreferredInset(String inset){\r\n    getFixedInset(preferredInset).setValueAsString(inset);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Style.markAsRendererStyle",
	"Comment": "disables native os optimizations that might collide with cell renderers which do things like sharing styleobjects",
	"Method": "void markAsRendererStyle(){\r\n    renderer = true;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.deregisterPush",
	"Comment": "stop receiving push notifications to this client application",
	"Method": "void deregisterPush(){\r\n    Display.impl.deregisterPush();\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.PassiveState.checkGlobalIndex",
	"Comment": "checks whether the log needs to be truncated based on the globalindex.",
	"Method": "AppendResponse checkGlobalIndex(AppendRequest request){\r\n    long currentGlobalIndex = context.getGlobalIndex();\r\n    long nextGlobalIndex = request.globalIndex();\r\n    if (currentGlobalIndex > 0 && nextGlobalIndex > currentGlobalIndex && nextGlobalIndex > context.getLog().lastIndex()) {\r\n        context.setGlobalIndex(nextGlobalIndex);\r\n        context.reset();\r\n    }\r\n    if (request.logIndex() != 0) {\r\n        return checkPreviousEntry(request);\r\n    } else {\r\n        return appendEntries(request);\r\n    }\r\n}"
}, {
	"Path": "java.lang.Boolean.equals",
	"Comment": "returns true if and only if the argument is not null and is a boolean object that represents the same boolean value as this object.",
	"Method": "boolean equals(java.lang.Object obj){\r\n    return obj != null && obj.getClass() == getClass() && ((Boolean) obj).value == value;\r\n}"
}, {
	"Path": "java.util.HashMap.calculateCapacity",
	"Comment": "calculates the capacity of storage required for storing given number ofelements",
	"Method": "int calculateCapacity(int x){\r\n    if (x >= 1 << 30) {\r\n        return 1 << 30;\r\n    }\r\n    if (x == 0) {\r\n        return 16;\r\n    }\r\n    x = x - 1;\r\n    x |= x >> 1;\r\n    x |= x >> 2;\r\n    x |= x >> 4;\r\n    x |= x >> 8;\r\n    x |= x >> 16;\r\n    return x + 1;\r\n}"
}, {
	"Path": "com.codename1.io.FileSystemStorage.rename",
	"Comment": "renames a file to the given name, expects the new name to be relative to thecurrent directory",
	"Method": "void rename(String file,String newName){\r\n    if (newName.indexOf('/') > -1) {\r\n        throw new RuntimeException(\"Rename accepts only relative file names not full paths: \" + newName);\r\n    }\r\n    Util.getImplementation().rename(file, newName);\r\n}"
}, {
	"Path": "com.codename1.charts.views.XYChart.transform",
	"Comment": "transform the canvas such as it can handle both horizontal and verticalorientations.",
	"Method": "void transform(Canvas canvas,float angle,boolean inverse){\r\n    if (inverse) {\r\n        canvas.scale(1 / mScale, mScale);\r\n        canvas.translate(mTranslate, -mTranslate);\r\n        canvas.rotate(-angle, mCenter.getX(), mCenter.getY());\r\n    } else {\r\n        canvas.rotate(angle, mCenter.getX(), mCenter.getY());\r\n        canvas.translate(-mTranslate, mTranslate);\r\n        canvas.scale(mScale, 1 / mScale);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.charts.renderers.DefaultRenderer.getSeriesRendererCount",
	"Comment": "returns the simple renderers count in the multiple renderer list.",
	"Method": "int getSeriesRendererCount(){\r\n    return mRenderers.size();\r\n}"
}, {
	"Path": "com.codename1.xml.XMLParser.notifyError",
	"Comment": "a utility method used to notify an error to the parsercallback and throw an illegalargumentexception if parsingerror returned false",
	"Method": "void notifyError(int errorId,String tag,String attribute,String value,String description){\r\n    if (parserCallback != null) {\r\n        boolean cont = parserCallback.parsingError(errorId, tag, attribute, value, description);\r\n        if (!cont) {\r\n            throw new IllegalArgumentException(description);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setFlatten",
	"Comment": "makes the component effectively opaque by blending the backgrounds into an image in memory so the layer of underlying componentsis only drawn once when this component is repainted. this does have a significant memory overhead.",
	"Method": "void setFlatten(boolean flatten){\r\n    this.flatten = flatten;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getDragSpeed",
	"Comment": "this method returns the dragging speed based on the latest draggedevents",
	"Method": "float getDragSpeed(boolean vertical){\r\n    return Display.getInstance().getDragSpeed(vertical);\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.Log.contains",
	"Comment": "returns a boolean value indicating whether the log contains a live entry at the given index.",
	"Method": "boolean contains(long index){\r\n    if (!validIndex(index))\r\n        return false;\r\n    Segment segment = segments.segment(index);\r\n    return segment != null && segment.contains(index);\r\n}"
}, {
	"Path": "java.lang.StringBuffer.charAt",
	"Comment": "the specified character of the sequence currently represented by the string buffer, as indicated by the index argument, is returned. the first character of a string buffer is at index 0, the next at index 1, and so on, for array indexing.the index argument must be greater than or equal to 0, and less than the length of this string buffer.",
	"Method": "char charAt(int index){\r\n    return internal.charAt(index);\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.Thumbnails.of",
	"Comment": "indicate to make thumbnails for images with the specified filenames.",
	"Method": "Builder<File> of(String files,Builder<File> of,File files,Builder<URL> of,URL urls,Builder<? extends InputStream> of,InputStream inputStreams,Builder<BufferedImage> of,BufferedImage images){\r\n    checkForNull(images, \"Cannot specify null for images.\");\r\n    checkForEmpty(images, \"Cannot specify an empty array for images.\");\r\n    return Builder.ofBufferedImages(Arrays.asList(images));\r\n}"
}, {
	"Path": "com.codename1.charts.renderers.XYSeriesRenderer.addFillOutsideLine",
	"Comment": "sets if the line chart should be filled outside its line. filling outsidewith filloutsideline.integral the line transforms a line chart into an areachart.",
	"Method": "void addFillOutsideLine(FillOutsideLine fill){\r\n    mFillBelowLine.add(fill);\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.getToken",
	"Comment": "returns the facebook authorization token that can be used for api access",
	"Method": "String getToken(){\r\n    return token;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getComponentForm",
	"Comment": "returns the component form or null if this componentis not added yet to a form",
	"Method": "Form getComponentForm(){\r\n    Form retVal = null;\r\n    Component parent = getParent();\r\n    if (parent != null) {\r\n        retVal = parent.getComponentForm();\r\n    }\r\n    return retVal;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.getApplicationIconImage",
	"Comment": "returns an image representing the application icon, or null if not supported. this is used onandroid to support the title bar icon",
	"Method": "Image getApplicationIconImage(){\r\n    InputStream i = getResourceAsStream(getClass(), \"/icon.png\");\r\n    if (i != null) {\r\n        try {\r\n            return EncodedImage.create(i);\r\n        } catch (IOException ex) {\r\n            Log.e(ex);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.net.URI.parseIntOption",
	"Comment": "internal utility method to throw a syntax error if a value can not beparsed.",
	"Method": "int parseIntOption(String key,String value){\r\n    try {\r\n        return Integer.parseInt(value);\r\n    } catch (NumberFormatException nfe) {\r\n        throw new URISyntaxException(value, \"Invalid \" + key + \" value: \" + value);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.ImageViewer.setCycleLeft",
	"Comment": "by default the imageviewer cycles from the beginning to the end of the listwhen going to the left, setting this to false prevents this behaviour",
	"Method": "void setCycleLeft(boolean cycleLeft){\r\n    this.cycleLeft = cycleLeft;\r\n}"
}, {
	"Path": "android.support.v4.widget.DrawerLayout.setScrimColor",
	"Comment": "set a color to use for the scrim that obscures primary content while a drawer is open.",
	"Method": "void setScrimColor(int color){\r\n    mScrimColor = color;\r\n    invalidate();\r\n}"
}, {
	"Path": "com.codename1.impl.ios.IOSImplementation.keyboardWillBeHidden",
	"Comment": "callback for native.called when keyboard is hidden.used for async editing with formbottompaddingeditingmode.",
	"Method": "void keyboardWillBeHidden(){\r\n    Display.getInstance().callSerially(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            Form current = Display.getInstance().getCurrent();\r\n            if (current != null) {\r\n                instance.areaUnderVKBOverride = 0;\r\n                try {\r\n                    current.revalidate();\r\n                    Accessor.fixNegativeScrolls(current);\r\n                } finally {\r\n                    instance.areaUnderVKBOverride = -1;\r\n                }\r\n            }\r\n        }\r\n    });\r\n    if (Display.getInstance().getVirtualKeyboardListener() != null) {\r\n        Display.getInstance().callSerially(new Runnable() {\r\n            public void run() {\r\n                ActionListener l = Display.getInstance().getVirtualKeyboardListener();\r\n                if (l != null) {\r\n                    l.actionPerformed(new ActionEvent(false));\r\n                }\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.ios.IOSImplementation.keyboardWillBeHidden",
	"Comment": "callback for native.called when keyboard is hidden.used for async editing with formbottompaddingeditingmode.",
	"Method": "void keyboardWillBeHidden(){\r\n    Form current = Display.getInstance().getCurrent();\r\n    if (current != null) {\r\n        instance.areaUnderVKBOverride = 0;\r\n        try {\r\n            current.revalidate();\r\n            Accessor.fixNegativeScrolls(current);\r\n        } finally {\r\n            instance.areaUnderVKBOverride = -1;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.ios.IOSImplementation.keyboardWillBeHidden",
	"Comment": "callback for native.called when keyboard is hidden.used for async editing with formbottompaddingeditingmode.",
	"Method": "void keyboardWillBeHidden(){\r\n    ActionListener l = Display.getInstance().getVirtualKeyboardListener();\r\n    if (l != null) {\r\n        l.actionPerformed(new ActionEvent(false));\r\n    }\r\n}"
}, {
	"Path": "ly.count.android.sdk.ConnectionQueue.beginSession",
	"Comment": "records a session start event for the app and sends it to the server.",
	"Method": "void beginSession(){\r\n    checkInternalState();\r\n    boolean dataAvailable = false;\r\n    String data = prepareCommonRequestData();\r\n    if (Countly.sharedInstance().getConsent(Countly.CountlyFeatureNames.sessions)) {\r\n        data += \"&begin_session=1\" + \"&metrics=\" + DeviceInfo.getMetrics(context_);\r\n        dataAvailable = true;\r\n    }\r\n    CountlyStore cs = getCountlyStore();\r\n    String locationData = prepareLocationData(cs, false);\r\n    if (!locationData.isEmpty()) {\r\n        data += locationData;\r\n        dataAvailable = true;\r\n    }\r\n    if (Countly.sharedInstance().getConsent(Countly.CountlyFeatureNames.attribution)) {\r\n        if (Countly.sharedInstance().isAttributionEnabled) {\r\n            String cachedAdId = store_.getCachedAdvertisingId();\r\n            if (!cachedAdId.isEmpty()) {\r\n                data += \"&aid=\" + ConnectionProcessor.urlEncodeString(\"{\\\"adid\\\":\\\"\" + cachedAdId + \"\\\"}\");\r\n                dataAvailable = true;\r\n            }\r\n        }\r\n    }\r\n    Countly.sharedInstance().isBeginSessionSent = true;\r\n    if (dataAvailable) {\r\n        store_.addConnection(data);\r\n        tick();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.PeerComponent.generatePeerImage",
	"Comment": "the native implementation should implement this method to generate a native peerimage representing the component",
	"Method": "Image generatePeerImage(){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getCloudBoundProperty",
	"Comment": "indicates the property within this component that should be bound to the cloud object",
	"Method": "String getCloudBoundProperty(){\r\n    if (noBind && cloudBoundProperty == null) {\r\n        return null;\r\n    }\r\n    if (cloudBoundProperty == null) {\r\n        String[] props = getBindablePropertyNames();\r\n        if (props != null && props.length > 0) {\r\n            return props[0];\r\n        }\r\n    }\r\n    return cloudBoundProperty;\r\n}"
}, {
	"Path": "com.codename1.l10n.DateFormat.getDateInstance",
	"Comment": "get a dateformat instance that uses a given style for dates.",
	"Method": "DateFormat getDateInstance(DateFormat getDateInstance,int style){\r\n    return getDateTimeInstance(style, DEFAULT);\r\n}"
}, {
	"Path": "org.conscrypt.java.security.TestKeyStore.privateKey",
	"Comment": "return the only private key in a keystore for the givenalgorithms. throws illegalstateexception if there are are moreor less than one.",
	"Method": "PrivateKeyEntry privateKey(KeyStore keyStore,char[] keyPassword,String keyAlgorithm,String signatureAlgorithm){\r\n    try {\r\n        PrivateKeyEntry found = null;\r\n        PasswordProtection password = new PasswordProtection(keyPassword);\r\n        for (String alias : Collections.list(keyStore.aliases())) {\r\n            if (!keyStore.entryInstanceOf(alias, PrivateKeyEntry.class)) {\r\n                continue;\r\n            }\r\n            PrivateKeyEntry privateKey = (PrivateKeyEntry) keyStore.getEntry(alias, password);\r\n            if (!privateKey.getPrivateKey().getAlgorithm().equals(keyAlgorithm)) {\r\n                continue;\r\n            }\r\n            X509Certificate certificate = (X509Certificate) privateKey.getCertificate();\r\n            if (!certificate.getSigAlgName().contains(signatureAlgorithm)) {\r\n                continue;\r\n            }\r\n            if (found != null) {\r\n                throw new IllegalStateException(\"KeyStore has more than one private key for\" + \" keyAlgorithm: \" + keyAlgorithm + \" signatureAlgorithm: \" + signatureAlgorithm + \"\\nfirst: \" + found.getPrivateKey() + \"\\nsecond: \" + privateKey.getPrivateKey());\r\n            }\r\n            found = privateKey;\r\n        }\r\n        if (found == null) {\r\n            throw new IllegalStateException(\"KeyStore contained no private key for\" + \" keyAlgorithm: \" + keyAlgorithm + \" signatureAlgorithm: \" + signatureAlgorithm);\r\n        }\r\n        return found;\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(\"Problem getting key for \" + keyAlgorithm + \" and signature \" + signatureAlgorithm, e);\r\n    }\r\n}"
}, {
	"Path": "org.conscrypt.OpenSSLSocketFactoryImpl.setUseEngineSocketByDefault",
	"Comment": "configures the default socket to be created for all instances.",
	"Method": "void setUseEngineSocketByDefault(boolean useEngineSocket){\r\n    useEngineSocketByDefault = useEngineSocket;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.setAllowMinimizing",
	"Comment": "allows a codename one application to minimize without forcing it to the front whenevera new dialog is poped up",
	"Method": "void setAllowMinimizing(boolean allowMinimizing){\r\n    this.allowMinimizing = allowMinimizing;\r\n}"
}, {
	"Path": "org.commonmark.internal.ListBlockParser.listsMatch",
	"Comment": "returns true if the two list items are of the same type,with the same delimiter and bullet character. this is usedin agglomerating list items into lists.",
	"Method": "boolean listsMatch(ListBlock a,ListBlock b){\r\n    if (a instanceof BulletList && b instanceof BulletList) {\r\n        return equals(((BulletList) a).getBulletMarker(), ((BulletList) b).getBulletMarker());\r\n    } else if (a instanceof OrderedList && b instanceof OrderedList) {\r\n        return equals(((OrderedList) a).getDelimiter(), ((OrderedList) b).getDelimiter());\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getUnselectedStyle",
	"Comment": "returns the component style for the unselected mode allowing us to manipulatethe look of the component",
	"Method": "Style getUnselectedStyle(){\r\n    if (unSelectedStyle == null) {\r\n        initStyle();\r\n    }\r\n    return unSelectedStyle;\r\n}"
}, {
	"Path": "com.l2fprod.common.swing.UserPreferences.getFileChooser",
	"Comment": "gets the file chooser with the given id. its current directory will betracked and restored on subsequent calls.",
	"Method": "JFileChooser getFileChooser(String id){\r\n    JFileChooser chooser = new JFileChooser();\r\n    track(chooser, \"FileChooser.\" + id + \".path\");\r\n    return chooser;\r\n}"
}, {
	"Path": "com.codename1.impl.blackberry.TransportDetective.getAvailableTransportServices",
	"Comment": "gets available transports for which a service book is present.",
	"Method": "int getAvailableTransportServices(){\r\n    updateTransportServiceAvailability();\r\n    return _availableTransportServices;\r\n}"
}, {
	"Path": "com.codename1.charts.renderers.XYMultipleSeriesRenderer.setXLabelsAlign",
	"Comment": "sets the x axis labels alignment.one of component.center, component.left, component.right",
	"Method": "void setXLabelsAlign(int align){\r\n    xLabelsAlign = align;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.init",
	"Comment": "this is the internal display initialization method, it will be removed in future versions of the api.this method must be called before any form is shown",
	"Method": "void init(Object m){\r\n    if (!INSTANCE.codenameOneRunning) {\r\n        INSTANCE.codenameOneRunning = true;\r\n        INSTANCE.displayInitTime = System.currentTimeMillis();\r\n        int commandBehaviour = COMMAND_BEHAVIOR_DEFAULT;\r\n        if (INSTANCE.impl != null) {\r\n            commandBehaviour = INSTANCE.impl.getCommandBehavior();\r\n        }\r\n        INSTANCE.impl = (CodenameOneImplementation) ImplementationFactory.getInstance().createImplementation();\r\n        INSTANCE.impl.setDisplayLock(lock);\r\n        INSTANCE.impl.initImpl(m);\r\n        INSTANCE.codenameOneGraphics = new Graphics(INSTANCE.impl.getNativeGraphics());\r\n        INSTANCE.codenameOneGraphics.paintPeersBehind = INSTANCE.impl.paintNativePeersBehind();\r\n        INSTANCE.impl.setCodenameOneGraphics(INSTANCE.codenameOneGraphics);\r\n        if (INSTANCE.impl.isThirdSoftButton()) {\r\n            INSTANCE.thirdSoftButton = true;\r\n        }\r\n        if (INSTANCE.impl.getSoftkeyCount() > 0) {\r\n            MenuBar.leftSK = INSTANCE.impl.getSoftkeyCode(0)[0];\r\n            if (INSTANCE.impl.getSoftkeyCount() > 1) {\r\n                MenuBar.rightSK = INSTANCE.impl.getSoftkeyCode(1)[0];\r\n                if (INSTANCE.impl.getSoftkeyCode(1).length > 1) {\r\n                    MenuBar.rightSK2 = INSTANCE.impl.getSoftkeyCode(1)[1];\r\n                }\r\n            }\r\n        }\r\n        MenuBar.backSK = INSTANCE.impl.getBackKeyCode();\r\n        MenuBar.backspaceSK = INSTANCE.impl.getBackspaceKeyCode();\r\n        MenuBar.clearSK = INSTANCE.impl.getClearKeyCode();\r\n        INSTANCE.PATHLENGTH = INSTANCE.impl.getDragPathLength();\r\n        INSTANCE.dragPathX = new float[INSTANCE.PATHLENGTH];\r\n        INSTANCE.dragPathY = new float[INSTANCE.PATHLENGTH];\r\n        INSTANCE.dragPathTime = new long[INSTANCE.PATHLENGTH];\r\n        com.codename1.util.StringUtil.setImplementation(INSTANCE.impl);\r\n        com.codename1.io.Util.setImplementation(INSTANCE.impl);\r\n        if (INSTANCE.edt == null) {\r\n            INSTANCE.touchScreen = INSTANCE.impl.isTouchDevice();\r\n            INSTANCE.edt = new CodenameOneThread(new RunnableWrapper(null, 3), \"EDT\");\r\n            INSTANCE.impl.setThreadPriority(INSTANCE.edt, INSTANCE.impl.getEDTThreadPriority());\r\n            INSTANCE.edt.start();\r\n        }\r\n        INSTANCE.impl.postInit();\r\n        INSTANCE.setCommandBehavior(commandBehaviour);\r\n    } else {\r\n        INSTANCE.impl.confirmControlView();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Form.initGlobalToolbar",
	"Comment": "allows subclasses to disable the global toolbar for a specific form by overriding this method",
	"Method": "void initGlobalToolbar(){\r\n    if (Toolbar.isGlobalToolbar()) {\r\n        setToolbar(new Toolbar());\r\n    }\r\n}"
}, {
	"Path": "com.codename1.xml.XMLParser.eventParser",
	"Comment": "the event parser requires deriving this class and overriding callbackmethods to work effectively. to stop the event parser in mid way acallback can simply throw an ioexception on purpose.",
	"Method": "void eventParser(Reader r){\r\n    eventParser = true;\r\n    parseTagContent(null, r);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.addPullToRefresh",
	"Comment": "this method adds a refresh task to the component, the task will be executed if the user has pulled the scroll beyond a certain height.",
	"Method": "void addPullToRefresh(Runnable task){\r\n    this.refreshTask = task;\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.setDefaultValign",
	"Comment": "indicates the default vertical alignment for a text field, only applies to single line text fields",
	"Method": "void setDefaultValign(int aDefaultValign){\r\n    defaultValign = aDefaultValign;\r\n}"
}, {
	"Path": "com.codename1.maps.layers.ArrowLinesLayer.drawArrow",
	"Comment": "this method clones arrowhead object which represents arrow and translateit to position on the map.",
	"Method": "void drawArrow(Graphics g,Point s,Point e){\r\n    double aDir = MathUtil.atan2(e.getY() - s.getY(), e.getX() - s.getX());\r\n    if (aDir < -Math.PI / 2) {\r\n        aDir = MathUtil.atan2(s.getY() - e.getY(), s.getX() - e.getX());\r\n        aDir -= Math.PI;\r\n    }\r\n    aDir -= Math.PI / 2;\r\n    ArrowHead arrowHead = new ArrowHead(arrowHeight, arrowWidth);\r\n    arrowHead.rotate(aDir);\r\n    arrowHead.translate(s.getX() + ((e.getX() - s.getX()) / 2), s.getY() + ((e.getY() - s.getY()) / 2));\r\n    arrowHead.paint(g);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.platformUsesInputMode",
	"Comment": "checks if this platform uses input modes.no current platforms return true for this.it is a holdover from j2me.",
	"Method": "boolean platformUsesInputMode(){\r\n    return impl.platformUsesInputMode();\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getScrollAnimationSpeed",
	"Comment": "scroll animation speed in milliseconds allowing a developer to slow down or acceleratethe smooth animation mode",
	"Method": "int getScrollAnimationSpeed(){\r\n    return animationSpeed;\r\n}"
}, {
	"Path": "com.codename1.properties.UiBinding.bindInteger",
	"Comment": "changes to the text area are automatically reflected to the given property and visa versa",
	"Method": "void bindInteger(Property<Integer, ? extends Object> prop,TextArea ta){\r\n    bind(prop, ta);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.isBackgroundPainter",
	"Comment": "returns true if installing this border will override the painting of the component background",
	"Method": "boolean isBackgroundPainter(){\r\n    return type == TYPE_ROUNDED || type == TYPE_ROUNDED_PRESSED || type == TYPE_IMAGE || type == TYPE_IMAGE_HORIZONTAL || type == TYPE_IMAGE_VERTICAL || type == TYPE_IMAGE_SCALED;\r\n}"
}, {
	"Path": "com.codename1.ui.Toolbar.getMenuBar",
	"Comment": "returns the associated sidemenubar object of this toolbar.",
	"Method": "MenuBar getMenuBar(){\r\n    return sideMenu;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.addScrollListener",
	"Comment": "registers interest in receiving callbacks for scroll gained events, a scroll event is invoked when the component is scrolled.",
	"Method": "void addScrollListener(ScrollListener l){\r\n    if (scrollListeners == null) {\r\n        scrollListeners = new EventDispatcher();\r\n    }\r\n    scrollListeners.addListener(l);\r\n}"
}, {
	"Path": "java.util.Stack.peek",
	"Comment": "returns the element at the top of the stack without removing it.",
	"Method": "E peek(){\r\n    try {\r\n        return (E) elementData[elementCount - 1];\r\n    } catch (IndexOutOfBoundsException e) {\r\n        throw new EmptyStackException();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getBaseline",
	"Comment": "the baseline for the component text according to which it should be alignedwith other components for best visual look.",
	"Method": "int getBaseline(int width,int height){\r\n    return height - getStyle().getPaddingBottom();\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.handleException",
	"Comment": "handles an exception thrown when performing a network operation, the defaultimplementation shows a retry dialog.",
	"Method": "void handleException(Exception err){\r\n    if (exceptionListeners != null) {\r\n        if (!isKilled()) {\r\n            NetworkEvent n = new NetworkEvent(this, err);\r\n            exceptionListeners.fireActionEvent(n);\r\n        }\r\n        return;\r\n    }\r\n    if (killed || failSilently) {\r\n        failureException = err;\r\n        return;\r\n    }\r\n    Log.e(err);\r\n    if (silentRetryCount > 0) {\r\n        silentRetryCount--;\r\n        NetworkManager.getInstance().resetAPN();\r\n        retry();\r\n        return;\r\n    }\r\n    if (Display.isInitialized() && !Display.getInstance().isMinimized() && Dialog.show(\"Exception\", err.toString() + \": for URL \" + url + \"\\n\" + err.getMessage(), \"Retry\", \"Cancel\")) {\r\n        retry();\r\n    } else {\r\n        retrying = false;\r\n        killed = true;\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.server.protocol.AppendResponse.builder",
	"Comment": "returns an append response builder for an existing response.",
	"Method": "Builder builder(Builder builder,AppendResponse response){\r\n    return new Builder(response);\r\n}"
}, {
	"Path": "com.codename1.ui.ComboBox.isActAsSpinnerDialog",
	"Comment": "when this flag is active the combo box acts as a button that opens a dialog that looks like a spinnerthis allows creating user interfaces for touch devices where a spinner ui approach is more common thana combo box paradigm.",
	"Method": "boolean isActAsSpinnerDialog(){\r\n    return actAsSpinnerDialog;\r\n}"
}, {
	"Path": "com.codename1.ui.InputComponent.initInput",
	"Comment": "this method must be invoked by the constructor of the subclasses to initialize the ui",
	"Method": "void initInput(){\r\n    setUIID(\"TextComponent\");\r\n    getEditor().setLabelForComponent(lbl);\r\n    lbl.setFocusable(false);\r\n    String tuid = getUIManager().getThemeConstant(\"textComponentFieldUIID\", null);\r\n    if (tuid != null) {\r\n        getEditor().setUIID(tuid);\r\n    }\r\n    refreshForGuiBuilder();\r\n}"
}, {
	"Path": "com.codename1.ui.animations.ComponentAnimation.compoundAnimation",
	"Comment": "allows us to create an animation that compounds several separate animations so they appear as a single animation to the system and process in parallel",
	"Method": "ComponentAnimation compoundAnimation(ComponentAnimation anims){\r\n    return new CompoundAnimation(anims);\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.compaction.MajorCompactionManager.getCompactableGroups",
	"Comment": "returns a list of segments lists to compact, where segments are grouped according to how they will be merged duringcompaction.",
	"Method": "List<List<Segment>> getCompactableGroups(Storage storage,SegmentManager manager){\r\n    List<List<Segment>> compact = new ArrayList();\r\n    List<Segment> segments = null;\r\n    for (Segment segment : getCompactableSegments(manager)) {\r\n        if (segments == null) {\r\n            segments = new ArrayList();\r\n            segments.add(segment);\r\n        } else if (segments.stream().mapToLong(Segment::size).sum() + segment.size() <= storage.maxSegmentSize() && segments.stream().mapToLong(Segment::count).sum() + segment.count() <= storage.maxEntriesPerSegment()) {\r\n            segments.add(segment);\r\n        } else {\r\n            compact.add(segments);\r\n            segments = new ArrayList();\r\n            segments.add(segment);\r\n        }\r\n    }\r\n    if (segments != null) {\r\n        compact.add(segments);\r\n    }\r\n    return compact;\r\n}"
}, {
	"Path": "java.util.TimeZone.getDefault",
	"Comment": "gets the default timezone for this host. the source of the default timezone may vary with implementation.",
	"Method": "java.util.TimeZone getDefault(){\r\n    if (defaultTimeZone == null) {\r\n        final String tzone = getTimezoneId();\r\n        defaultTimeZone = new TimeZone() {\r\n            @Override\r\n            public int getOffset(int era, int year, int month, int day, int dayOfWeek, int timeOfDayMillis) {\r\n                return getTimezoneOffset(tzone, year, month + 1, day, timeOfDayMillis);\r\n            }\r\n            @Override\r\n            public int getRawOffset() {\r\n                return getTimezoneRawOffset(tzone);\r\n            }\r\n            boolean inDaylightTime(Date time) {\r\n                return isTimezoneDST(tzone, time.getTime());\r\n            }\r\n            @Override\r\n            public boolean useDaylightTime() {\r\n                return isTimezoneDST(tzone, getDec30()) != isTimezoneDST(tzone, getJuly1());\r\n            }\r\n        };\r\n        defaultTimeZone.ID = tzone;\r\n    }\r\n    return defaultTimeZone;\r\n}"
}, {
	"Path": "java.util.TimeZone.getDefault",
	"Comment": "gets the default timezone for this host. the source of the default timezone may vary with implementation.",
	"Method": "java.util.TimeZone getDefault(){\r\n    return getTimezoneOffset(tzone, year, month + 1, day, timeOfDayMillis);\r\n}"
}, {
	"Path": "java.util.TimeZone.getDefault",
	"Comment": "gets the default timezone for this host. the source of the default timezone may vary with implementation.",
	"Method": "java.util.TimeZone getDefault(){\r\n    return getTimezoneRawOffset(tzone);\r\n}"
}, {
	"Path": "java.util.TimeZone.getDefault",
	"Comment": "gets the default timezone for this host. the source of the default timezone may vary with implementation.",
	"Method": "java.util.TimeZone getDefault(){\r\n    return isTimezoneDST(tzone, time.getTime());\r\n}"
}, {
	"Path": "java.util.TimeZone.getDefault",
	"Comment": "gets the default timezone for this host. the source of the default timezone may vary with implementation.",
	"Method": "java.util.TimeZone getDefault(){\r\n    return isTimezoneDST(tzone, getDec30()) != isTimezoneDST(tzone, getJuly1());\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.snapshot.SnapshotDescriptor.locked",
	"Comment": "returns whether the snapshot has been locked by commitment.a snapshot will be locked once it has been fully written.",
	"Method": "boolean locked(){\r\n    return locked;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.hasInlineDisabledStyle",
	"Comment": "checks to see if the component has any inline styles registered for its disabled state.",
	"Method": "boolean hasInlineDisabledStyle(){\r\n    return getInlineStylesTheme() != null && (inlineAllStyles != null || inlineDisabledStyles != null);\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSEngine.setNowrapText",
	"Comment": "replaces a wrapped text with an unwrapped version.this in fact removes all the labels that contains a single word each, and replaces them with one label that contains the whole text.this way the label is not wrapped.",
	"Method": "void setNowrapText(Label label,Vector ui,String newText,HTMLElement element){\r\n    label.setText(newText);\r\n    for (int i = 1; i < ui.size(); i++) {\r\n        Component cmp = (Component) ui.elementAt(i);\r\n        cmp.getParent().removeComponent(cmp);\r\n    }\r\n    if (label instanceof HTMLLink) {\r\n        ((HTMLLink) label).childLinks = new Vector();\r\n    }\r\n    element.setAssociatedComponents(label);\r\n    label.getParent().revalidate();\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.isBlockAnalytics",
	"Comment": "enables blocking analytics in the uibuilder, this is useful for the designer tool.",
	"Method": "boolean isBlockAnalytics(){\r\n    return blockAnalytics;\r\n}"
}, {
	"Path": "android.support.v4.content.ModernAsyncTask.get",
	"Comment": "waits if necessary for at most the given time for the computationto complete, and then retrieves its result.",
	"Method": "Result get(Result get,long timeout,TimeUnit unit){\r\n    return mFuture.get(timeout, unit);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setUnselectedStyle",
	"Comment": "changes the component style by replacing the component style with the given style",
	"Method": "void setUnselectedStyle(Style style){\r\n    if (this.unSelectedStyle != null) {\r\n        this.unSelectedStyle.removeStyleListener(this);\r\n    }\r\n    this.unSelectedStyle = style;\r\n    this.unSelectedStyle.addStyleListener(this);\r\n    if (this.unSelectedStyle.getBgPainter() == null) {\r\n        this.unSelectedStyle.setBgPainter(new BGPainter());\r\n    }\r\n    setShouldCalcPreferredSize(true);\r\n    checkAnimation();\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.createImage",
	"Comment": "creates a native image from a file in the system jar or file system storage.",
	"Method": "Object createImage(int[] rgb,int width,int height,Object createImage,String path,Object createImage,InputStream i,Object createImage,byte[] bytes,int offset,int len,Image createImage,Shape shape,Stroke stroke,int color){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.Graphics.popClip",
	"Comment": "pops the top clip from the clip stack and sets it as the current clip.",
	"Method": "void popClip(){\r\n    impl.popClip(nativeGraphics);\r\n}"
}, {
	"Path": "android.support.v4.app.FragmentActivity.getSupportFragmentManager",
	"Comment": "return the fragmentmanager for interacting with fragments associatedwith this activity.",
	"Method": "FragmentManager getSupportFragmentManager(){\r\n    return mFragments;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.isEnabled",
	"Comment": "indicates whether component is enabled or disabled thus allowing us to preventa component from receiving input events and indicate so visually",
	"Method": "boolean isEnabled(){\r\n    return enabled;\r\n}"
}, {
	"Path": "com.codename1.ui.table.Table.getTitleAlignment",
	"Comment": "indicates the alignment of the title see label alignment for details",
	"Method": "int getTitleAlignment(){\r\n    return titleAlignment;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.isDefaultSmoothScrolling",
	"Comment": "indicates whether lists and containers should have smooth scrolling by default",
	"Method": "boolean isDefaultSmoothScrolling(){\r\n    return defaultSmoothScrolling;\r\n}"
}, {
	"Path": "org.conscrypt.Platform.wrapSSLSession",
	"Comment": "provides extended capabilities for the session if supported by the platform.",
	"Method": "SSLSession wrapSSLSession(ConscryptSession sslSession){\r\n    return new Java8ExtendedSSLSession(sslSession);\r\n}"
}, {
	"Path": "com.codename1.ui.table.Table.setTitleAlignment",
	"Comment": "indicates the alignment of the title see label alignment for details",
	"Method": "void setTitleAlignment(int titleAlignment){\r\n    this.titleAlignment = titleAlignment;\r\n    for (int iter = 0; iter < model.getColumnCount(); iter++) {\r\n        listener.dataChanged(-1, iter);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Command.getDisabledIcon",
	"Comment": "indicates the icon that is displayed on the button when the button is inthe disabled state",
	"Method": "Image getDisabledIcon(){\r\n    return disabledIcon;\r\n}"
}, {
	"Path": "com.codename1.payment.Purchase.synchronizeReceiptsSync",
	"Comment": "synchronize receipts and wait for the sync to complete before proceeding.",
	"Method": "boolean synchronizeReceiptsSync(long ifOlderThanMs){\r\n    final boolean[] complete = new boolean[1];\r\n    final boolean[] success = new boolean[1];\r\n    synchronizeReceipts(ifOlderThanMs, new SuccessCallback<Boolean>() {\r\n        public void onSucess(Boolean value) {\r\n            complete[0] = true;\r\n            success[0] = value;\r\n            synchronized (complete) {\r\n                complete.notifyAll();\r\n            }\r\n        }\r\n    });\r\n    if (!complete[0]) {\r\n        Display.getInstance().invokeAndBlock(new Runnable() {\r\n            public void run() {\r\n                while (!complete[0]) {\r\n                    synchronized (complete) {\r\n                        try {\r\n                            complete.wait();\r\n                        } catch (Exception ex) {\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return success[0];\r\n}"
}, {
	"Path": "com.codename1.payment.Purchase.synchronizeReceiptsSync",
	"Comment": "synchronize receipts and wait for the sync to complete before proceeding.",
	"Method": "boolean synchronizeReceiptsSync(long ifOlderThanMs){\r\n    complete[0] = true;\r\n    success[0] = value;\r\n    synchronized (complete) {\r\n        complete.notifyAll();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.payment.Purchase.synchronizeReceiptsSync",
	"Comment": "synchronize receipts and wait for the sync to complete before proceeding.",
	"Method": "boolean synchronizeReceiptsSync(long ifOlderThanMs){\r\n    while (!complete[0]) {\r\n        synchronized (complete) {\r\n            try {\r\n                complete.wait();\r\n            } catch (Exception ex) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.CN.canForceOrientation",
	"Comment": "returns true if the device allows forcing the orientation via code, feature phones do not allow thisalthough some include a jad property allowing for this feature",
	"Method": "boolean canForceOrientation(){\r\n    return Display.impl.canForceOrientation();\r\n}"
}, {
	"Path": "com.codename1.components.Ads.getAppID",
	"Comment": "simple getter of the unique identifier of the app on the ads service network.",
	"Method": "String getAppID(){\r\n    return appId;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.requestFocus",
	"Comment": "changes the current component to the focused component, will work onlyfor a component that belongs to a parent form.",
	"Method": "void requestFocus(){\r\n    Form rootForm = getComponentForm();\r\n    if (rootForm != null) {\r\n        Component.setDisableSmoothScrolling(true);\r\n        rootForm.requestFocus(this);\r\n        Component.setDisableSmoothScrolling(false);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testManyEvents",
	"Comment": "tests submitting a linearizable event that publishes to all sessions.",
	"Method": "void testManyEvents(int nodes){\r\n    createServers(nodes);\r\n    CopycatClient client = createClient();\r\n    client.onEvent(\"test\", message -> {\r\n        threadAssertNotNull(message);\r\n        resume();\r\n    });\r\n    for (int i = 0; i < 10; i++) {\r\n        client.submit(new TestEvent(true)).thenAccept(result -> {\r\n            threadAssertNotNull(result);\r\n            resume();\r\n        });\r\n        await(30000, 2);\r\n    }\r\n}"
}, {
	"Path": "ly.count.android.sdk.Event.toJSON",
	"Comment": "creates and returns a jsonobject containing the event data from this object.",
	"Method": "JSONObject toJSON(){\r\n    final JSONObject json = new JSONObject();\r\n    try {\r\n        json.put(KEY_KEY, key);\r\n        json.put(COUNT_KEY, count);\r\n        json.put(TIMESTAMP_KEY, timestamp);\r\n        json.put(HOUR, hour);\r\n        json.put(DAY_OF_WEEK, dow);\r\n        JSONObject jobj = new JSONObject();\r\n        if (segmentation != null) {\r\n            for (Map.Entry<String, String> pair : segmentation.entrySet()) {\r\n                jobj.put(pair.getKey(), pair.getValue());\r\n            }\r\n        }\r\n        if (segmentationInt != null) {\r\n            for (Map.Entry<String, Integer> pair : segmentationInt.entrySet()) {\r\n                jobj.put(pair.getKey(), pair.getValue());\r\n            }\r\n        }\r\n        if (segmentationDouble != null) {\r\n            for (Map.Entry<String, Double> pair : segmentationDouble.entrySet()) {\r\n                jobj.put(pair.getKey(), pair.getValue());\r\n            }\r\n        }\r\n        if (segmentation != null || segmentationInt != null || segmentationDouble != null) {\r\n            json.put(SEGMENTATION_KEY, jobj);\r\n        }\r\n        json.put(SUM_KEY, sum);\r\n        if (dur > 0) {\r\n            json.put(DUR_KEY, dur);\r\n        }\r\n    } catch (JSONException e) {\r\n        if (Countly.sharedInstance().isLoggingEnabled()) {\r\n            Log.w(Countly.TAG, \"Got exception converting an Event to JSON\", e);\r\n        }\r\n    }\r\n    return json;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Collections.disjoint",
	"Comment": "returns whether the specified collections have no elements in common.",
	"Method": "boolean disjoint(Collection<?> c1,Collection<?> c2){\r\n    if ((c1 instanceof Set) && !(c2 instanceof Set) || (c2.size()) > c1.size()) {\r\n        Collection<?> tmp = c1;\r\n        c1 = c2;\r\n        c2 = tmp;\r\n    }\r\n    Iterator<?> it = c1.iterator();\r\n    while (it.hasNext()) {\r\n        if (c2.contains(it.next())) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.ConstraintParser.parseComponentConstraint",
	"Comment": "parses one component constraint and returns the parsed value.",
	"Method": "CC parseComponentConstraint(String s){\r\n    CC cc = new CC();\r\n    if (s.length() == 0) {\r\n        return cc;\r\n    }\r\n    String[] parts = toTrimmedTokens(s, ',');\r\n    for (String part : parts) {\r\n        try {\r\n            if (part.length() == 0) {\r\n                continue;\r\n            }\r\n            int ix = -1;\r\n            char c = part.charAt(0);\r\n            if (c == 'n') {\r\n                if (part.equals(\"north\")) {\r\n                    cc.setDockSide(0);\r\n                    continue;\r\n                }\r\n                if (part.equals(\"newline\")) {\r\n                    cc.setNewline(true);\r\n                    continue;\r\n                }\r\n                if (part.startsWith(\"newline \")) {\r\n                    String gapSz = part.substring(7).trim();\r\n                    cc.setNewlineGapSize(parseBoundSize(gapSz, true, true));\r\n                    continue;\r\n                }\r\n            }\r\n            if (c == 'f' && (part.equals(\"flowy\") || part.equals(\"flowx\"))) {\r\n                cc.setFlowX(part.charAt(4) == 'x' ? Boolean.TRUE : Boolean.FALSE);\r\n                continue;\r\n            }\r\n            if (c == 's') {\r\n                ix = startsWithLenient(part, \"skip\", 4, true);\r\n                if (ix > -1) {\r\n                    String num = part.substring(ix).trim();\r\n                    cc.setSkip(num.length() != 0 ? Integer.parseInt(num) : 1);\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, \"split\", 5, true);\r\n                if (ix > -1) {\r\n                    String split = part.substring(ix).trim();\r\n                    cc.setSplit(split.length() > 0 ? Integer.parseInt(split) : LayoutUtil.INF);\r\n                    continue;\r\n                }\r\n                if (part.equals(\"south\")) {\r\n                    cc.setDockSide(2);\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, new String[] { \"spany\", \"sy\" }, new int[] { 5, 2 }, true);\r\n                if (ix > -1) {\r\n                    cc.setSpanY(parseSpan(part.substring(ix).trim()));\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, new String[] { \"spanx\", \"sx\" }, new int[] { 5, 2 }, true);\r\n                if (ix > -1) {\r\n                    cc.setSpanX(parseSpan(part.substring(ix).trim()));\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, \"span\", 4, true);\r\n                if (ix > -1) {\r\n                    String[] spans = toTrimmedTokens(part.substring(ix).trim(), ' ');\r\n                    cc.setSpanX(spans[0].length() > 0 ? Integer.parseInt(spans[0]) : LayoutUtil.INF);\r\n                    cc.setSpanY(spans.length > 1 ? Integer.parseInt(spans[1]) : 1);\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, \"shrinkx\", 7, true);\r\n                if (ix > -1) {\r\n                    cc.getHorizontal().setShrink(parseFloat(part.substring(ix).trim(), ResizeConstraint.WEIGHT_100));\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, \"shrinky\", 7, true);\r\n                if (ix > -1) {\r\n                    cc.getVertical().setShrink(parseFloat(part.substring(ix).trim(), ResizeConstraint.WEIGHT_100));\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, \"shrink\", 6, false);\r\n                if (ix > -1) {\r\n                    String[] shrinks = toTrimmedTokens(part.substring(ix).trim(), ' ');\r\n                    cc.getHorizontal().setShrink(parseFloat(part.substring(ix).trim(), ResizeConstraint.WEIGHT_100));\r\n                    if (shrinks.length > 1) {\r\n                        cc.getVertical().setShrink(parseFloat(part.substring(ix).trim(), ResizeConstraint.WEIGHT_100));\r\n                    }\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, new String[] { \"shrinkprio\", \"shp\" }, new int[] { 10, 3 }, true);\r\n                if (ix > -1) {\r\n                    String sp = part.substring(ix).trim();\r\n                    if (sp.startsWith(\"x\") || sp.startsWith(\"y\")) {\r\n                        (sp.startsWith(\"x\") ? cc.getHorizontal() : cc.getVertical()).setShrinkPriority(Integer.parseInt(sp.substring(2)));\r\n                    } else {\r\n                        String[] shrinks = toTrimmedTokens(sp, ' ');\r\n                        cc.getHorizontal().setShrinkPriority(Integer.parseInt(shrinks[0]));\r\n                        if (shrinks.length > 1) {\r\n                            cc.getVertical().setShrinkPriority(Integer.parseInt(shrinks[1]));\r\n                        }\r\n                    }\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, new String[] { \"sizegroupx\", \"sizegroupy\", \"sgx\", \"sgy\" }, new int[] { 9, 9, 2, 2 }, true);\r\n                if (ix > -1) {\r\n                    String sg = part.substring(ix).trim();\r\n                    char lc = part.charAt(ix - 1);\r\n                    if (lc != 'y') {\r\n                        cc.getHorizontal().setSizeGroup(sg);\r\n                    }\r\n                    if (lc != 'x') {\r\n                        cc.getVertical().setSizeGroup(sg);\r\n                    }\r\n                    continue;\r\n                }\r\n            }\r\n            if (c == 'g') {\r\n                ix = startsWithLenient(part, \"growx\", 5, true);\r\n                if (ix > -1) {\r\n                    cc.getHorizontal().setGrow(parseFloat(part.substring(ix).trim(), ResizeConstraint.WEIGHT_100));\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, \"growy\", 5, true);\r\n                if (ix > -1) {\r\n                    cc.getVertical().setGrow(parseFloat(part.substring(ix).trim(), ResizeConstraint.WEIGHT_100));\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, \"grow\", 4, false);\r\n                if (ix > -1) {\r\n                    String[] grows = toTrimmedTokens(part.substring(ix).trim(), ' ');\r\n                    cc.getHorizontal().setGrow(parseFloat(grows[0], ResizeConstraint.WEIGHT_100));\r\n                    cc.getVertical().setGrow(parseFloat(grows.length > 1 ? grows[1] : \"\", ResizeConstraint.WEIGHT_100));\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, new String[] { \"growprio\", \"gp\" }, new int[] { 8, 2 }, true);\r\n                if (ix > -1) {\r\n                    String gp = part.substring(ix).trim();\r\n                    char c0 = gp.length() > 0 ? gp.charAt(0) : ' ';\r\n                    if (c0 == 'x' || c0 == 'y') {\r\n                        (c0 == 'x' ? cc.getHorizontal() : cc.getVertical()).setGrowPriority(Integer.parseInt(gp.substring(2)));\r\n                    } else {\r\n                        String[] grows = toTrimmedTokens(gp, ' ');\r\n                        cc.getHorizontal().setGrowPriority(Integer.parseInt(grows[0]));\r\n                        if (grows.length > 1) {\r\n                            cc.getVertical().setGrowPriority(Integer.parseInt(grows[1]));\r\n                        }\r\n                    }\r\n                    continue;\r\n                }\r\n                if (part.startsWith(\"gap\")) {\r\n                    BoundSize[] gaps = parseGaps(part);\r\n                    if (gaps[0] != null) {\r\n                        cc.getVertical().setGapBefore(gaps[0]);\r\n                    }\r\n                    if (gaps[1] != null) {\r\n                        cc.getHorizontal().setGapBefore(gaps[1]);\r\n                    }\r\n                    if (gaps[2] != null) {\r\n                        cc.getVertical().setGapAfter(gaps[2]);\r\n                    }\r\n                    if (gaps[3] != null) {\r\n                        cc.getHorizontal().setGapAfter(gaps[3]);\r\n                    }\r\n                    continue;\r\n                }\r\n            }\r\n            if (c == 'a') {\r\n                ix = startsWithLenient(part, new String[] { \"aligny\", \"ay\" }, new int[] { 6, 2 }, true);\r\n                if (ix > -1) {\r\n                    cc.getVertical().setAlign(parseUnitValueOrAlign(part.substring(ix).trim(), false, null));\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, new String[] { \"alignx\", \"ax\" }, new int[] { 6, 2 }, true);\r\n                if (ix > -1) {\r\n                    cc.getHorizontal().setAlign(parseUnitValueOrAlign(part.substring(ix).trim(), true, null));\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, \"align\", 2, true);\r\n                if (ix > -1) {\r\n                    String[] gaps = toTrimmedTokens(part.substring(ix).trim(), ' ');\r\n                    cc.getHorizontal().setAlign(parseUnitValueOrAlign(gaps[0], true, null));\r\n                    if (gaps.length > 1) {\r\n                        cc.getVertical().setAlign(parseUnitValueOrAlign(gaps[1], false, null));\r\n                    }\r\n                    continue;\r\n                }\r\n            }\r\n            if ((c == 'x' || c == 'y') && part.length() > 2) {\r\n                char c2 = part.charAt(1);\r\n                if (c2 == ' ' || (c2 == '2' && part.charAt(2) == ' ')) {\r\n                    if (cc.getPos() == null) {\r\n                        cc.setPos(new UnitValue[4]);\r\n                    } else if (cc.isBoundsInGrid() == false) {\r\n                        throw new IllegalArgumentException(\"Cannot combine 'position' with 'x/y/x2/y2' keywords.\");\r\n                    }\r\n                    int edge = (c == 'x' ? 0 : 1) + (c2 == '2' ? 2 : 0);\r\n                    UnitValue[] pos = cc.getPos();\r\n                    pos[edge] = parseUnitValue(part.substring(2).trim(), null, c == 'x');\r\n                    cc.setPos(pos);\r\n                    cc.setBoundsInGrid(true);\r\n                    continue;\r\n                }\r\n            }\r\n            if (c == 'c') {\r\n                ix = startsWithLenient(part, \"cell\", 4, true);\r\n                if (ix > -1) {\r\n                    String[] grs = toTrimmedTokens(part.substring(ix).trim(), ' ');\r\n                    if (grs.length < 2) {\r\n                        throw new IllegalArgumentException(\"At least two integers must follow \" + part);\r\n                    }\r\n                    cc.setCellX(Integer.parseInt(grs[0]));\r\n                    cc.setCellY(Integer.parseInt(grs[1]));\r\n                    if (grs.length > 2) {\r\n                        cc.setSpanX(Integer.parseInt(grs[2]));\r\n                    }\r\n                    if (grs.length > 3) {\r\n                        cc.setSpanY(Integer.parseInt(grs[3]));\r\n                    }\r\n                    continue;\r\n                }\r\n            }\r\n            if (c == 'p') {\r\n                ix = startsWithLenient(part, \"pos\", 3, true);\r\n                if (ix > -1) {\r\n                    if (cc.getPos() != null && cc.isBoundsInGrid()) {\r\n                        throw new IllegalArgumentException(\"Can not combine 'pos' with 'x/y/x2/y2' keywords.\");\r\n                    }\r\n                    String[] pos = toTrimmedTokens(part.substring(ix).trim(), ' ');\r\n                    UnitValue[] bounds = new UnitValue[4];\r\n                    for (int j = 0; j < pos.length; j++) {\r\n                        bounds[j] = parseUnitValue(pos[j], null, j % 2 == 0);\r\n                    }\r\n                    if (bounds[0] == null && bounds[2] == null || bounds[1] == null && bounds[3] == null) {\r\n                        throw new IllegalArgumentException(\"Both x and x2 or y and y2 can not be null!\");\r\n                    }\r\n                    cc.setPos(bounds);\r\n                    cc.setBoundsInGrid(false);\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, \"pad\", 3, true);\r\n                if (ix > -1) {\r\n                    UnitValue[] p = parseInsets(part.substring(ix).trim(), false);\r\n                    cc.setPadding(new UnitValue[] { p[0], p.length > 1 ? p[1] : null, p.length > 2 ? p[2] : null, p.length > 3 ? p[3] : null });\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, \"pushx\", 5, true);\r\n                if (ix > -1) {\r\n                    cc.setPushX(parseFloat(part.substring(ix).trim(), ResizeConstraint.WEIGHT_100));\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, \"pushy\", 5, true);\r\n                if (ix > -1) {\r\n                    cc.setPushY(parseFloat(part.substring(ix).trim(), ResizeConstraint.WEIGHT_100));\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, \"push\", 4, false);\r\n                if (ix > -1) {\r\n                    String[] pushs = toTrimmedTokens(part.substring(ix).trim(), ' ');\r\n                    cc.setPushX(parseFloat(pushs[0], ResizeConstraint.WEIGHT_100));\r\n                    cc.setPushY(parseFloat(pushs.length > 1 ? pushs[1] : \"\", ResizeConstraint.WEIGHT_100));\r\n                    continue;\r\n                }\r\n            }\r\n            if (c == 't') {\r\n                ix = startsWithLenient(part, \"tag\", 3, true);\r\n                if (ix > -1) {\r\n                    cc.setTag(part.substring(ix).trim());\r\n                    continue;\r\n                }\r\n            }\r\n            if (c == 'w' || c == 'h') {\r\n                if (part.equals(\"wrap\")) {\r\n                    cc.setWrap(true);\r\n                    continue;\r\n                }\r\n                if (part.startsWith(\"wrap \")) {\r\n                    String gapSz = part.substring(5).trim();\r\n                    cc.setWrapGapSize(parseBoundSize(gapSz, true, true));\r\n                    continue;\r\n                }\r\n                boolean isHor = c == 'w';\r\n                if (isHor && (part.startsWith(\"w \") || part.startsWith(\"width \"))) {\r\n                    String uvStr = part.substring(part.charAt(1) == ' ' ? 2 : 6).trim();\r\n                    cc.getHorizontal().setSize(parseBoundSize(uvStr, false, true));\r\n                    continue;\r\n                }\r\n                if (!isHor && (part.startsWith(\"h \") || part.startsWith(\"height \"))) {\r\n                    String uvStr = part.substring(part.charAt(1) == ' ' ? 2 : 7).trim();\r\n                    cc.getVertical().setSize(parseBoundSize(uvStr, false, false));\r\n                    continue;\r\n                }\r\n                if (part.startsWith(\"wmin \") || part.startsWith(\"wmax \") || part.startsWith(\"hmin \") || part.startsWith(\"hmax \")) {\r\n                    String uvStr = part.substring(5).trim();\r\n                    if (uvStr.length() > 0) {\r\n                        UnitValue uv = parseUnitValue(uvStr, null, isHor);\r\n                        boolean isMin = part.charAt(3) == 'n';\r\n                        DimConstraint dc = isHor ? cc.getHorizontal() : cc.getVertical();\r\n                        dc.setSize(new BoundSize(isMin ? uv : dc.getSize().getMin(), dc.getSize().getPreferred(), isMin ? (dc.getSize().getMax()) : uv, uvStr));\r\n                        continue;\r\n                    }\r\n                }\r\n                if (part.equals(\"west\")) {\r\n                    cc.setDockSide(1);\r\n                    continue;\r\n                }\r\n                if (part.startsWith(\"hidemode \")) {\r\n                    cc.setHideMode(Integer.parseInt(part.substring(9)));\r\n                    continue;\r\n                }\r\n            }\r\n            if (c == 'i' && part.startsWith(\"id \")) {\r\n                cc.setId(part.substring(3).trim());\r\n                int dIx = cc.getId().indexOf('.');\r\n                if (dIx == 0 || dIx == cc.getId().length() - 1) {\r\n                    throw new IllegalArgumentException(\"Dot must not be first or last!\");\r\n                }\r\n                continue;\r\n            }\r\n            if (c == 'e') {\r\n                if (part.equals(\"east\")) {\r\n                    cc.setDockSide(3);\r\n                    continue;\r\n                }\r\n                if (part.equals(\"external\")) {\r\n                    cc.setExternal(true);\r\n                    continue;\r\n                }\r\n                ix = startsWithLenient(part, new String[] { \"endgroupx\", \"endgroupy\", \"egx\", \"egy\" }, new int[] { -1, -1, -1, -1 }, true);\r\n                if (ix > -1) {\r\n                    String sg = part.substring(ix).trim();\r\n                    char lc = part.charAt(ix - 1);\r\n                    DimConstraint dc = (lc == 'x' ? cc.getHorizontal() : cc.getVertical());\r\n                    dc.setEndGroup(sg);\r\n                    continue;\r\n                }\r\n            }\r\n            if (c == 'd') {\r\n                if (part.equals(\"dock north\")) {\r\n                    cc.setDockSide(0);\r\n                    continue;\r\n                }\r\n                if (part.equals(\"dock west\")) {\r\n                    cc.setDockSide(1);\r\n                    continue;\r\n                }\r\n                if (part.equals(\"dock south\")) {\r\n                    cc.setDockSide(2);\r\n                    continue;\r\n                }\r\n                if (part.equals(\"dock east\")) {\r\n                    cc.setDockSide(3);\r\n                    continue;\r\n                }\r\n                if (part.equals(\"dock center\")) {\r\n                    cc.getHorizontal().setGrow(new Float(100f));\r\n                    cc.getVertical().setGrow(new Float(100f));\r\n                    cc.setPushX(new Float(100f));\r\n                    cc.setPushY(new Float(100f));\r\n                    continue;\r\n                }\r\n            }\r\n            if (c == 'v') {\r\n                ix = startsWithLenient(part, new String[] { \"visualpadding\", \"vp\" }, new int[] { 3, 2 }, true);\r\n                if (ix > -1) {\r\n                    UnitValue[] p = parseInsets(part.substring(ix).trim(), false);\r\n                    cc.setVisualPadding(new UnitValue[] { p[0], p.length > 1 ? p[1] : null, p.length > 2 ? p[2] : null, p.length > 3 ? p[3] : null });\r\n                    continue;\r\n                }\r\n            }\r\n            UnitValue horAlign = parseAlignKeywords(part, true);\r\n            if (horAlign != null) {\r\n                cc.getHorizontal().setAlign(horAlign);\r\n                continue;\r\n            }\r\n            UnitValue verAlign = parseAlignKeywords(part, false);\r\n            if (verAlign != null) {\r\n                cc.getVertical().setAlign(verAlign);\r\n                continue;\r\n            }\r\n            throw new IllegalArgumentException(\"Unknown keyword.\");\r\n        } catch (Exception ex) {\r\n            Log.e(ex);\r\n            throw new IllegalArgumentException(\"Error parsing Constraint: '\" + part + \"'\");\r\n        }\r\n    }\r\n    return cc;\r\n}"
}, {
	"Path": "com.codename1.io.Log.getReportingLevel",
	"Comment": "indicates the level of log reporting, this allows developers to send device logs to the cloudthus tracking crashes or functionality in the device.",
	"Method": "int getReportingLevel(){\r\n    return instance.reporting;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.getSkip",
	"Comment": "returns how many cells in the grid that should be skipped before the component that this constraint belongs to.\tnote that only the first component will be checked for this property.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "int getSkip(){\r\n    return skip;\r\n}"
}, {
	"Path": "mondrian.olap.Util.replace",
	"Comment": "replaces all occurrences of a string in a buffer with another.",
	"Method": "String replace(String s,String find,String replace,StringBuilder replace,StringBuilder buf,int start,String find,String replace){\r\n    int findLength = find.length();\r\n    if (findLength == 0) {\r\n        for (int j = buf.length(); j >= 0; --j) {\r\n            buf.insert(j, replace);\r\n        }\r\n        return buf;\r\n    }\r\n    int k = buf.length();\r\n    while (k > 0) {\r\n        int i = buf.lastIndexOf(find, k);\r\n        if (i < start) {\r\n            break;\r\n        }\r\n        buf.replace(i, i + find.length(), replace);\r\n        k = i - findLength;\r\n    }\r\n    return buf;\r\n}"
}, {
	"Path": "java.lang.Thread.isAlive",
	"Comment": "tests if this thread is alive. a thread is alive if it has been started and has not yet died.",
	"Method": "boolean isAlive(){\r\n    return alive;\r\n}"
}, {
	"Path": "java.lang.Double.parseDouble",
	"Comment": "returns a new double initialized to the value represented by the specified string, as performed by the valueof method of class double.",
	"Method": "double parseDouble(java.lang.String s){\r\n    return StringToReal.parseDouble(s);\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.DefaultProperty.equals",
	"Comment": "compares two defaultproperty objects. two defaultproperty objects are equalif they are the same object or if their name, display name, shortdescription, category, type and editable property are the same. note theproperty value is not considered in the implementation.",
	"Method": "boolean equals(Object other){\r\n    if (other == null || getClass() != other.getClass()) {\r\n        return false;\r\n    }\r\n    if (other == this) {\r\n        return true;\r\n    }\r\n    DefaultProperty dp = (DefaultProperty) other;\r\n    return compare(name, dp.name) && compare(displayName, dp.displayName) && compare(shortDescription, dp.shortDescription) && compare(category, dp.category) && compare(type, dp.type) && editable == dp.editable;\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSEngine.setTextTransformRecursive",
	"Comment": "sets the specified text transform to the component and all its children",
	"Method": "void setTextTransformRecursive(Component cmp,int transformType){\r\n    if (cmp instanceof Container) {\r\n        Container cont = (Container) cmp;\r\n        for (int i = 0; i < cont.getComponentCount(); i++) {\r\n            setTextTransformRecursive(cont.getComponentAt(i), transformType);\r\n        }\r\n    } else if (cmp instanceof Label) {\r\n        Label label = (Label) cmp;\r\n        switch(transformType) {\r\n            case TEXT_TRANSFORM_UPPERCASE:\r\n                label.setText(label.getText().toUpperCase());\r\n                break;\r\n            case TEXT_TRANSFORM_LOWERCASE:\r\n                label.setText(label.getText().toLowerCase());\r\n                break;\r\n            case TEXT_TRANSFORM_CAPITALIZE:\r\n                String text = label.getText();\r\n                String newText = \"\";\r\n                boolean capNextLetter = true;\r\n                for (int i = 0; i < text.length(); i++) {\r\n                    char c = text.charAt(i);\r\n                    if (CSSParser.isWhiteSpace(c)) {\r\n                        capNextLetter = true;\r\n                    } else if (capNextLetter) {\r\n                        if ((c >= 'a') && (c <= 'z')) {\r\n                            c -= 32;\r\n                        }\r\n                        capNextLetter = false;\r\n                    }\r\n                    newText += c;\r\n                }\r\n                label.setText(newText);\r\n                break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.Log.isEmpty",
	"Comment": "returns a boolean value indicating whether the log is empty.",
	"Method": "boolean isEmpty(){\r\n    assertIsOpen();\r\n    return segments.firstSegment().isEmpty();\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.isEditingTrigger",
	"Comment": "indicates whether the given key code should be ignored or should triggerediting, by default fire or any numeric key should trigger editing implicitly.this method is only called when handles input is false.",
	"Method": "boolean isEditingTrigger(int keyCode){\r\n    if (!isEditable()) {\r\n        return false;\r\n    }\r\n    int gk = Display.getInstance().getGameAction(keyCode);\r\n    if (isQwertyInput()) {\r\n        return keyCode > 0 || (gk == Display.GAME_FIRE) || isClearKey(keyCode) || isEnterKey(keyCode) || (leftAndRightEditingTrigger && ((gk == Display.GAME_LEFT) || (gk == Display.GAME_RIGHT)));\r\n    }\r\n    return (keyCode >= '0' && keyCode <= '9') || isClearKey(keyCode) || (gk == Display.GAME_FIRE) || (leftAndRightEditingTrigger && ((gk == Display.GAME_LEFT) || (gk == Display.GAME_RIGHT)));\r\n}"
}, {
	"Path": "com.codename1.charts.views.LineChart.getPointsChart",
	"Comment": "returns the scatter chart to be used for drawing the data points.",
	"Method": "ScatterChart getPointsChart(){\r\n    return pointsChart;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.createMediaRecorder",
	"Comment": "creates a media recorder object which will record from the device mic toa file in the given path.",
	"Method": "Media createMediaRecorder(String path,Media createMediaRecorder,String path,String mimeType){\r\n    return impl.createMediaRecorder(path, mimeType);\r\n}"
}, {
	"Path": "com.codename1.ui.util.Resources.setPassword",
	"Comment": "sets the password to use for password protected resource files",
	"Method": "void setPassword(String password){\r\n    try {\r\n        if (password == null) {\r\n            key = null;\r\n            return;\r\n        }\r\n        key = password.getBytes(\"UTF-8\");\r\n    } catch (UnsupportedEncodingException ex) {\r\n        ex.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.util.regex.RE.matchAt",
	"Comment": "match the current regular expression program against the currentinput string, starting at index i of the input string.this methodis only meant for internal use.",
	"Method": "boolean matchAt(int i){\r\n    start0 = -1;\r\n    end0 = -1;\r\n    start1 = -1;\r\n    end1 = -1;\r\n    start2 = -1;\r\n    end2 = -1;\r\n    startn = null;\r\n    endn = null;\r\n    parenCount = 1;\r\n    setParenStart(0, i);\r\n    if ((program.flags & REProgram.OPT_HASBACKREFS) != 0) {\r\n        startBackref = new int[maxParen];\r\n        endBackref = new int[maxParen];\r\n    }\r\n    int idx;\r\n    if ((idx = matchNodes(0, maxNode, i)) != -1) {\r\n        setParenEnd(0, idx);\r\n        return true;\r\n    }\r\n    parenCount = 0;\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.io.BufferedInputStream.setYield",
	"Comment": "allows setting a yield duration for this stream which is useful for backgroundoperations to release cpu",
	"Method": "void setYield(int yield){\r\n    this.yield = yield;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.createDoubleBorder",
	"Comment": "creates a double border with the specified thickness and color",
	"Method": "Border createDoubleBorder(int thickness,int color,Border createDoubleBorder,int thickness){\r\n    return createCSSBorder(TYPE_DOUBLE, thickness);\r\n}"
}, {
	"Path": "com.codename1.ui.Label.shouldTickerStart",
	"Comment": "returns true if a ticker should be started since there is no room to showthe text in the label.",
	"Method": "boolean shouldTickerStart(){\r\n    if (!tickerEnabled) {\r\n        return false;\r\n    }\r\n    Style style = getStyle();\r\n    int txtW = style.getFont().stringWidth(getText());\r\n    int textSpaceW = getAvaliableSpaceForText();\r\n    return txtW > textSpaceW && textSpaceW > 0;\r\n}"
}, {
	"Path": "com.codename1.ui.html.ResourceThreadQueue.threadFinished",
	"Comment": "called by the resourcethread when it finishes downloading and setting the image.this in turns starts another thread if the queue is not empty",
	"Method": "void threadFinished(ResourceThread finishedThread,boolean success){\r\n    if (finishedThread.cssDocInfo != null) {\r\n        cssCount--;\r\n    }\r\n    if ((HTMLComponent.SUPPORT_CSS) && (cssCount == 0)) {\r\n        cssCount = -1;\r\n        htmlC.applyAllCSS();\r\n        htmlC.cssCompleted();\r\n    }\r\n    running.removeElement(finishedThread);\r\n    if (queue.size() > 0) {\r\n        ResourceThread t = (ResourceThread) queue.firstElement();\r\n        queue.removeElementAt(0);\r\n        running.addElement(t);\r\n        t.go();\r\n    } else {\r\n        threadCount--;\r\n    }\r\n    if (threadCount == 0) {\r\n        if (images.size() == 0) {\r\n            htmlC.setPageStatus(HTMLCallback.STATUS_COMPLETED);\r\n        } else {\r\n            startRunningImages();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.pinch",
	"Comment": "invoked by subclasses interested in handling pinch to zoom events, if true is returned other drag events will not be broadcast",
	"Method": "boolean pinch(float scale){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.animateHierarchy",
	"Comment": "animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation",
	"Method": "void animateHierarchy(int duration,ComponentAnimation animateHierarchy,int duration,boolean wait,int opacity,boolean add){\r\n    setShouldCalcPreferredSize(true);\r\n    enableLayoutOnPaint = false;\r\n    dontRecurseContainer = true;\r\n    Vector comps = new Vector();\r\n    findComponentsInHierachy(comps);\r\n    final int componentCount = comps.size();\r\n    int[] beforeX = new int[componentCount];\r\n    int[] beforeY = new int[componentCount];\r\n    int[] beforeW = new int[componentCount];\r\n    int[] beforeH = new int[componentCount];\r\n    final Motion[] xMotions = new Motion[componentCount];\r\n    final Motion[] yMotions = new Motion[componentCount];\r\n    final Motion[] wMotions = new Motion[componentCount];\r\n    final Motion[] hMotions = new Motion[componentCount];\r\n    for (int iter = 0; iter < componentCount; iter++) {\r\n        Component current = (Component) comps.elementAt(iter);\r\n        beforeX[iter] = current.getX();\r\n        beforeY[iter] = current.getY();\r\n        beforeW[iter] = current.getWidth();\r\n        beforeH[iter] = current.getHeight();\r\n    }\r\n    layoutContainer();\r\n    for (int iter = 0; iter < componentCount; iter++) {\r\n        Component current = (Component) comps.elementAt(iter);\r\n        xMotions[iter] = createAnimateMotion(beforeX[iter], current.getX(), duration);\r\n        yMotions[iter] = createAnimateMotion(beforeY[iter], current.getY(), duration);\r\n        wMotions[iter] = createAnimateMotion(beforeW[iter], current.getWidth(), duration);\r\n        hMotions[iter] = createAnimateMotion(beforeH[iter], current.getHeight(), duration);\r\n        xMotions[iter].start();\r\n        yMotions[iter].start();\r\n        wMotions[iter].start();\r\n        hMotions[iter].start();\r\n        current.setX(beforeX[iter]);\r\n        current.setY(beforeY[iter]);\r\n        current.setWidth(beforeW[iter]);\r\n        current.setHeight(beforeH[iter]);\r\n    }\r\n    MorphAnimation a = new MorphAnimation(this, duration, new Motion[][] { xMotions, yMotions, wMotions, hMotions });\r\n    setAnimOpacity(opacity, 255, a, componentCount, duration);\r\n    a.animatedComponents = comps;\r\n    if (add) {\r\n        if (wait) {\r\n            getAnimationManager().addAnimationAndBlock(a);\r\n        } else {\r\n            getAnimationManager().addAnimation(a);\r\n        }\r\n    }\r\n    return a;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.addArguments",
	"Comment": "add an argument to the request response as an array of elements, this willtrigger multiple request entries with the same key",
	"Method": "void addArguments(String key,String value){\r\n    if (value.length == 1) {\r\n        addArgument(key, value[0]);\r\n    } else {\r\n        addArgument(key, (String[]) value);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.PlatformDefaults.getModCount",
	"Comment": "returns how many times the defaults has been changed. this can be used as a light weight check to\tsee if layout caches needs to be refreshed.",
	"Method": "int getModCount(){\r\n    return MOD_COUNT;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.setDefaultFormTransitionOut",
	"Comment": "allows us to define a default animation that will draw the transition forexiting a form",
	"Method": "void setDefaultFormTransitionOut(Transition defaultFormTransitionOut){\r\n    this.defaultFormTransitionOut = defaultFormTransitionOut;\r\n}"
}, {
	"Path": "com.codename1.ui.validation.Validator.setValidationFailureHighlightMode",
	"Comment": "indicates the default mode in which validation failures are expressed",
	"Method": "void setValidationFailureHighlightMode(HighlightMode validationFailureHighlightMode){\r\n    this.validationFailureHighlightMode = validationFailureHighlightMode;\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testPassiveJoinLate",
	"Comment": "tests joining a server after many entries have been committed.",
	"Method": "void testPassiveJoinLate(){\r\n    testServerJoinLate(Member.Type.PASSIVE, CopycatServer.State.PASSIVE);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isNativeBrowserComponentSupported",
	"Comment": "an implementation can return true if it supports embedding a native browser widget",
	"Method": "boolean isNativeBrowserComponentSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.db.ThreadSafeDatabase.getThread",
	"Comment": "returns the underlying easy thread we can use to pipe tasks to the db thread",
	"Method": "EasyThread getThread(){\r\n    return et;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.getDefaultVirtualKeyboard",
	"Comment": "get the default virtual keyboard or null if the virtualkeyboard is disabled",
	"Method": "VirtualKeyboardInterface getDefaultVirtualKeyboard(){\r\n    if (selectedVirtualKeyboard == null) {\r\n        return null;\r\n    }\r\n    return (VirtualKeyboardInterface) virtualKeyboards.get(selectedVirtualKeyboard);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.removeDropListener",
	"Comment": "removes an action listener to drop events which are invoked when this component is dropped on a target",
	"Method": "void removeDropListener(ActionListener l){\r\n    if (dropListener == null) {\r\n        return;\r\n    }\r\n    dropListener.removeListener(l);\r\n    if (!dropListener.hasListeners()) {\r\n        dropListener = null;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSEngine.evalContentExpression",
	"Comment": "evaluates a css content property expression and returns the matching label component",
	"Method": "Label evalContentExpression(HTMLComponent htmlC,String exp,HTMLElement element,CSSElement selector){\r\n    if (exp.length() != 0) {\r\n        if (exp.startsWith(\"counter(\")) {\r\n            exp = exp.substring(8);\r\n            int index = exp.indexOf(\")\");\r\n            if (index != -1) {\r\n                return new Label(\"\" + htmlC.getCounterValue(exp.substring(0, index)));\r\n            }\r\n        } else if (exp.startsWith(\"attr(\")) {\r\n            exp = exp.substring(5);\r\n            int index = exp.indexOf(\")\");\r\n            if (index != -1) {\r\n                String attr = exp.substring(0, index);\r\n                String attrValue = element.getAttribute(attr);\r\n                return new Label(attrValue == null ? \"\" : attrValue);\r\n            }\r\n        } else if (exp.equals(\"open-quote\")) {\r\n            return getQuote(true);\r\n        } else if (exp.equals(\"close-quote\")) {\r\n            return getQuote(false);\r\n        } else if (exp.startsWith(\"url(\")) {\r\n            String url = getCSSUrl(exp);\r\n            Label imgLabel = new Label();\r\n            if (htmlC.showImages) {\r\n                if (htmlC.getDocumentInfo() != null) {\r\n                    htmlC.getThreadQueue().add(imgLabel, htmlC.convertURL(url));\r\n                } else {\r\n                    if (DocumentInfo.isAbsoluteURL(url)) {\r\n                        htmlC.getThreadQueue().add(imgLabel, url);\r\n                    } else {\r\n                        if (htmlC.getHTMLCallback() != null) {\r\n                            htmlC.getHTMLCallback().parsingError(HTMLCallback.ERROR_NO_BASE_URL, selector.getTagName(), selector.getAttributeName(new Integer(CSSElement.CSS_CONTENT)), url, \"Ignoring image file referred in a CSS file/segment (\" + url + \"), since page was set by setBody/setHTML/setDOM so there's no way to access relative URLs\");\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            return imgLabel;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.setDefaultSnapToGrid",
	"Comment": "indicates whether scrolling this component should jump to a specific locationin a grid",
	"Method": "void setDefaultSnapToGrid(boolean defaultSnapToGrid){\r\n    this.defaultSnapToGrid = defaultSnapToGrid;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.ServerSessionContext.getResult",
	"Comment": "returns the session response for the given sequence number.",
	"Method": "ServerStateMachine.Result getResult(long sequence){\r\n    return results.get(sequence);\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.setDate",
	"Comment": "sets the current date in the view and the selected date to be the same.",
	"Method": "void setDate(Date d){\r\n    mv.setSelectedDay(d.getTime());\r\n    mv.setCurrentDay(SELECTED_DAY, true);\r\n    componentChanged();\r\n}"
}, {
	"Path": "com.codename1.ui.Component.isSnapToGrid",
	"Comment": "indicates whether scrolling this component should jump to a specific locationin a grid",
	"Method": "boolean isSnapToGrid(){\r\n    return snapToGrid;\r\n}"
}, {
	"Path": "com.codename1.io.BufferedInputStream.isPrintInput",
	"Comment": "prints out all the data that passes through this stream to the console.this is a very useful debugging tool.",
	"Method": "boolean isPrintInput(){\r\n    return printInput;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.lock",
	"Comment": "this callback indicates that a component pointing at this border is initialized, thismethod is useful for image borders whose lock methods are implicitly invoked.this method may be invoked multiple times.",
	"Method": "void lock(){\r\n    if (images != null) {\r\n        int ilen = images.length;\r\n        for (int iter = 0; iter < ilen; iter++) {\r\n            if (images[iter] != null) {\r\n                images[iter].lock();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.HashMap.removeEntry",
	"Comment": "remove the given entry from the hashmap.assumes that the entry is in the map.",
	"Method": "void removeEntry(Entry<K, V> entry,Entry<K, V> removeEntry,Object key){\r\n    int index = 0;\r\n    Entry<K, V> entry;\r\n    Entry<K, V> last = null;\r\n    if (key != null) {\r\n        int hash = computeHashCode(key);\r\n        index = hash & (elementData.length - 1);\r\n        entry = elementData[index];\r\n        while (entry != null && !(entry.origKeyHash == hash && areEqualKeys(key, entry.key))) {\r\n            last = entry;\r\n            entry = entry.next;\r\n        }\r\n    } else {\r\n        entry = elementData[0];\r\n        while (entry != null && entry.key != null) {\r\n            last = entry;\r\n            entry = entry.next;\r\n        }\r\n    }\r\n    if (entry == null) {\r\n        return null;\r\n    }\r\n    if (last == null) {\r\n        elementData[index] = entry.next;\r\n    } else {\r\n        last.next = entry.next;\r\n    }\r\n    modCount++;\r\n    elementCount--;\r\n    return entry;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.shrink",
	"Comment": "shrink weight for the component horizontally and optionally vertically.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC shrink(float widthHeight){\r\n    switch(widthHeight.length) {\r\n        default:\r\n            throw new IllegalArgumentException(\"Illegal argument count: \" + widthHeight.length);\r\n        case 2:\r\n            shrinkY(widthHeight[1]);\r\n        case 1:\r\n            shrinkX(widthHeight[0]);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.snapshot.SnapshotDescriptor.builder",
	"Comment": "returns a descriptor builder for the given descriptor buffer.",
	"Method": "Builder builder(Builder builder,Buffer buffer){\r\n    return new Builder(buffer);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.setBoundsInGrid",
	"Comment": "sets if the absolute pos value should be corrections to the component that is in a normal cell. if false\tthe value of pos is truly absolute in that it will not affect the grid or have a default bounds in the grid.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "void setBoundsInGrid(boolean b){\r\n    this.boundsInGrid = b;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.createUndelineBorder",
	"Comment": "creates an underline border that uses the color of the component foreground for drawing",
	"Method": "Border createUndelineBorder(int thickness,Border createUndelineBorder,float thickness){\r\n    Border b = new Border();\r\n    b.type = TYPE_UNDERLINE;\r\n    b.themeColors = true;\r\n    b.thickness = thickness;\r\n    b.millimeters = true;\r\n    return b;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.getCodeScanner",
	"Comment": "returns the native implementation of the code scanner or null",
	"Method": "CodeScanner getCodeScanner(){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.maps.Tile.fireReady",
	"Comment": "inform the tilereadylistener that this tile is ready to be painted",
	"Method": "void fireReady(){\r\n    if (listener != null) {\r\n        listener.actionPerformed(null);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.JSONParser.isUseLongs",
	"Comment": "indicates that the parser will generate long objects and not just doubles for numeric values",
	"Method": "boolean isUseLongs(){\r\n    return useLongsDefault;\r\n}"
}, {
	"Path": "android.support.v4.app.LoaderManager.hasRunningLoaders",
	"Comment": "returns true if any loaders managed are currently running and have notreturned data to the application yet.",
	"Method": "boolean hasRunningLoaders(boolean hasRunningLoaders){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.messaging.Message.sendMessageViaCloud",
	"Comment": "send an email message using the codename one cloud to send the message, notice that this apiwill only work for pro accounts.",
	"Method": "void sendMessageViaCloud(String sender,String recipient,String recipientName,String subject,String plainTextBody){\r\n    NetworkManager.getInstance().addToQueue(createMessage(sender, recipient, recipientName, subject, plainTextBody));\r\n}"
}, {
	"Path": "com.codename1.ui.Button.addActionListener",
	"Comment": "adds a listener to the button which will cause an event to dispatch on click",
	"Method": "void addActionListener(ActionListener l){\r\n    dispatcher.addListener(l);\r\n}"
}, {
	"Path": "com.codename1.ui.Image.scaledWidth",
	"Comment": "scales the image to the given width while updating the height based on theaspect ratio of the width",
	"Method": "Image scaledWidth(int width){\r\n    float ratio = ((float) width) / ((float) getWidth());\r\n    return scaled(width, Math.max(1, (int) (getHeight() * ratio)));\r\n}"
}, {
	"Path": "com.codename1.ui.Component.deinitializeCustomStyle",
	"Comment": "allows components to create a style of their own, this method cleans upstate for the given style",
	"Method": "void deinitializeCustomStyle(Style s){\r\n    s.removeStyleListener(this);\r\n}"
}, {
	"Path": "com.codename1.ui.Form.getCommandCount",
	"Comment": "a helper method to check the amount of commands within the form menu",
	"Method": "int getCommandCount(){\r\n    return menuBar.getCommandCount();\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.createOutsetBorder",
	"Comment": "creates an outset border with the specified thickness and color",
	"Method": "Border createOutsetBorder(int thickness,Border createOutsetBorder,int thickness,int color){\r\n    return createCSSBorder(TYPE_OUTSET, thickness, color);\r\n}"
}, {
	"Path": "android.support.v4.util.AtomicFile.getBaseFile",
	"Comment": "return the path to the base file.you should not generally use this,as the data at that path may not be valid.",
	"Method": "File getBaseFile(){\r\n    return mBaseName;\r\n}"
}, {
	"Path": "java.net.URI.relativize",
	"Comment": "create a relative uri object against this uri, given the uri parameter.",
	"Method": "URI relativize(URI uri){\r\n    if (isOpaque() || uri.isOpaque()) {\r\n        return uri;\r\n    }\r\n    if (getScheme() == null || uri.getScheme() == null || getScheme().equals(uri.getScheme()) == false) {\r\n        return uri;\r\n    }\r\n    String thisAuthority = null;\r\n    String thatAuthority = null;\r\n    String thisPath = null;\r\n    String thatPath = null;\r\n    if ((thisAuthority = getAuthority()) == null || (thatAuthority = uri.getAuthority()) == null || thisAuthority.equals(thatAuthority) == false) {\r\n        return uri;\r\n    }\r\n    if ((thisPath = getPath()) == null || (thatPath = uri.getPath()) == null || thatPath.startsWith(thisPath + PATH_SEPARATOR) == false) {\r\n        return uri;\r\n    }\r\n    try {\r\n        return new URI(null, null, thatPath.substring(thisPath.length() + 1), uri.getQuery(), uri.getFragment());\r\n    } catch (URISyntaxException e) {\r\n        throw new IllegalArgumentException(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.codename1.util.DateUtil.inDaylightTime",
	"Comment": "checks whether the given date is in daylight savings time for the given date.",
	"Method": "boolean inDaylightTime(Date date){\r\n    return tz.useDaylightTime() && getOffset(date.getTime()) != tz.getRawOffset();\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Motion.createDecelerationMotion",
	"Comment": "creates a deceleration motion starting from source value all the way to destination value",
	"Method": "Motion createDecelerationMotion(int sourceValue,int destinationValue,int duration){\r\n    Motion deceleration = new Motion(sourceValue, destinationValue, duration);\r\n    deceleration.motionType = DECELERATION;\r\n    return deceleration;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isRTLOrWhitespace",
	"Comment": "returns true if the given character is an rtl character or a spacecharacter",
	"Method": "boolean isRTLOrWhitespace(char c){\r\n    if (bidi) {\r\n        return isRTL(c) || isWhitespace(c);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.copyToClipboard",
	"Comment": "performs a clipboard copy operation, if the native clipboard is supported by the implementation it would be used",
	"Method": "void copyToClipboard(Object obj){\r\n    impl.copyToClipboard(obj);\r\n}"
}, {
	"Path": "org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.getSoWriteTimeout",
	"Comment": "note write timeouts are not part of the javax.net.ssl.sslsocket api",
	"Method": "int getSoWriteTimeout(){\r\n    throw new RuntimeException(\"Stub!\");\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.getDefaultFormTransitionIn",
	"Comment": "allows us to define a default animation that will draw the transition forentering a form",
	"Method": "Transition getDefaultFormTransitionIn(){\r\n    return defaultFormTransitionIn;\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudObject.getObject",
	"Comment": "allows us to extract an object from the cloud object without knowing its type in advanceor whether it exists",
	"Method": "Object getObject(String key){\r\n    Object o = values.get(key);\r\n    if (o == null) {\r\n        CustomProperty cp = custom.get(key);\r\n        if (cp != null) {\r\n            return cp.propertyValue(this, key);\r\n        }\r\n    }\r\n    return o;\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetTableModel.setToggleStates",
	"Comment": "sets the toggle states for the category views. note this must be called before setting any properties.",
	"Method": "void setToggleStates(Map toggleStates){\r\n    setRestoreToggleStates(true);\r\n    this.toggleStates.clear();\r\n    this.toggleStates.putAll(toggleStates);\r\n}"
}, {
	"Path": "org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.setSoWriteTimeout",
	"Comment": "note write timeouts are not part of the javax.net.ssl.sslsocket api",
	"Method": "void setSoWriteTimeout(int writeTimeoutMilliseconds){\r\n    throw new RuntimeException(\"Stub!\");\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.getDeviceIDType",
	"Comment": "returns the type of the device id used by countly for this device.",
	"Method": "DeviceId.Type getDeviceIDType(){\r\n    if (!isInitialized()) {\r\n        throw new IllegalStateException(\"init must be called before getDeviceID\");\r\n    }\r\n    return connectionQueue_.getDeviceId().getType();\r\n}"
}, {
	"Path": "com.codename1.util.regex.REProgram.getPrefix",
	"Comment": "returns a copy of the prefix of current regular expression programin a character array.if there is no prefix, or there is no programcompiled yet, getprefix will return null.",
	"Method": "char[] getPrefix(){\r\n    if (prefix != null) {\r\n        char[] ret = new char[prefix.length];\r\n        System.arraycopy(prefix, 0, ret, 0, prefix.length);\r\n        return ret;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.paintComponentBackground",
	"Comment": "paints the background of the component, invoked with the clipping regionand appropriate scroll translation.",
	"Method": "void paintComponentBackground(Graphics g){\r\n    if (isFlatten() || !opaque) {\r\n        return;\r\n    }\r\n    paintBackgroundImpl(g);\r\n}"
}, {
	"Path": "com.codename1.ui.animations.ComponentAnimation.isStepModeSupported",
	"Comment": "step mode allows stepping thru an animation one frame at a time, e.g. when scrolling down an animationmight change title elements then change them back as we scroll up.",
	"Method": "boolean isStepModeSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.components.SpanButton.isAutoRelease",
	"Comment": "returns if this is an auto released button. auto released buttons willare been disarmed when a drag is happening within the button.",
	"Method": "boolean isAutoRelease(){\r\n    return actualButton.isAutoRelease();\r\n}"
}, {
	"Path": "com.codename1.ui.util.Resources.getMinorVersion",
	"Comment": "returns the minor version number for this resource filethis value relates to the value from the header defined by the resource filespecification.",
	"Method": "int getMinorVersion(){\r\n    return minorVersion;\r\n}"
}, {
	"Path": "java.io.PrintStream.checkError",
	"Comment": "flush the stream and check its error state. the internal error state is set to true when the underlying output stream throws an ioexception, and when the seterror method is invoked.",
	"Method": "boolean checkError(){\r\n    OutputStream delegate = out;\r\n    if (delegate == null) {\r\n        return ioError;\r\n    }\r\n    flush();\r\n    return ioError;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.updateActivity",
	"Comment": "this method prevents a manual timeout from occurring when invoked at a frequency fasterthan the timeout.",
	"Method": "void updateActivity(){\r\n    timeSinceLastUpdate = System.currentTimeMillis();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.TreeSet.headSet",
	"Comment": "answers a sortedset of the specified portion of this treeset whichcontains elements less than the end element. the returned sortedset isbacked by this treeset so changes to one are reflected by the other.",
	"Method": "NavigableSet<E> headSet(E end,boolean endInclusive,SortedSet<E> headSet,E end){\r\n    return headSet(end, false);\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.calcPreferredSize",
	"Comment": "prevents scaling down of the menu when there is no text on the menu bar",
	"Method": "Dimension calcPreferredSize(){\r\n    if (soft.length > 1) {\r\n        Dimension d = super.calcPreferredSize();\r\n        if ((soft[0].getText() == null || soft[0].getText().equals(\"\")) && (soft[1].getText() == null || soft[1].getText().equals(\"\")) && soft[0].getIcon() == null && soft[1].getIcon() == null && (soft.length < 3 || ((soft[2].getText() == null || soft[2].getText().equals(\"\")) && soft[2].getIcon() == null))) {\r\n            d.setHeight(0);\r\n        }\r\n        return d;\r\n    }\r\n    return super.calcPreferredSize();\r\n}"
}, {
	"Path": "com.codename1.io.Util.downloadUrlToStorage",
	"Comment": "blocking method that will download the given url to storage and return when the operation completes",
	"Method": "boolean downloadUrlToStorage(String url,String fileName,boolean showProgress){\r\n    return downloadUrlTo(url, fileName, showProgress, false, true, null);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.paintGlassImpl",
	"Comment": "this method can be overriden by a component to draw on top of itself or its childrenafter the component or the children finished drawing in a similar way to the glasspane but more refined per component",
	"Method": "void paintGlassImpl(Graphics g){\r\n    if (parent != null) {\r\n        parent.paintGlassImpl(g);\r\n    }\r\n    paintTensile(g);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.isBottomOnlyMode",
	"Comment": "special mode where only the bottom of the round rectangle is rounded and the top is a regular rectangle",
	"Method": "boolean isBottomOnlyMode(){\r\n    return (!topLeft) && (!topRight) && bottomLeft && bottomRight;\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.currentHour",
	"Comment": "utility method to return a current hour of the day that can be used in the count.ly api.",
	"Method": "int currentHour(){\r\n    return Calendar.getInstance().get(Calendar.HOUR_OF_DAY);\r\n}"
}, {
	"Path": "android.support.v4.util.LruCache.trimToSize",
	"Comment": "remove the eldest entries until the total of remaining entries is at orbelow the requested size.",
	"Method": "void trimToSize(int maxSize){\r\n    while (true) {\r\n        K key;\r\n        V value;\r\n        synchronized (this) {\r\n            if (size < 0 || (map.isEmpty() && size != 0)) {\r\n                throw new IllegalStateException(getClass().getName() + \".sizeOf() is reporting inconsistent results!\");\r\n            }\r\n            if (size <= maxSize || map.isEmpty()) {\r\n                break;\r\n            }\r\n            Map.Entry<K, V> toEvict = map.entrySet().iterator().next();\r\n            key = toEvict.getKey();\r\n            value = toEvict.getValue();\r\n            map.remove(key);\r\n            size -= safeSizeOf(key, value);\r\n            evictionCount++;\r\n        }\r\n        entryRemoved(true, key, value, null);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.SegmentFile.isSegmentFile",
	"Comment": "returns a boolean value indicating whether the given file appears to be a parsable segment file.",
	"Method": "boolean isSegmentFile(String name,File file){\r\n    Assert.notNull(name, \"name\");\r\n    Assert.notNull(file, \"file\");\r\n    String fileName = file.getName();\r\n    if (fileName.lastIndexOf(EXTENSION_SEPARATOR) == -1 || fileName.lastIndexOf(PART_SEPARATOR) == -1 || fileName.lastIndexOf(EXTENSION_SEPARATOR) < fileName.lastIndexOf(PART_SEPARATOR) || !fileName.endsWith(EXTENSION))\r\n        return false;\r\n    for (int i = fileName.lastIndexOf(PART_SEPARATOR) + 1; i < fileName.lastIndexOf(EXTENSION_SEPARATOR); i++) {\r\n        if (!Character.isDigit(fileName.charAt(i))) {\r\n            return false;\r\n        }\r\n    }\r\n    if (fileName.lastIndexOf(PART_SEPARATOR, fileName.lastIndexOf(PART_SEPARATOR) - 1) == -1)\r\n        return false;\r\n    for (int i = fileName.lastIndexOf(PART_SEPARATOR, fileName.lastIndexOf(PART_SEPARATOR) - 1) + 1; i < fileName.lastIndexOf(PART_SEPARATOR); i++) {\r\n        if (!Character.isDigit(fileName.charAt(i))) {\r\n            return false;\r\n        }\r\n    }\r\n    return fileName.substring(0, fileName.lastIndexOf(PART_SEPARATOR, fileName.lastIndexOf(PART_SEPARATOR) - 1)).equals(name);\r\n}"
}, {
	"Path": "com.googlecode.cqengine.persistence.disk.DiskPersistence.createTempFile",
	"Comment": "creates a new unique temp file in the jvm temp directory which can be used for persistence.",
	"Method": "File createTempFile(){\r\n    File tempFile;\r\n    try {\r\n        tempFile = File.createTempFile(\"cqengine_\", \".db\");\r\n    } catch (Exception e) {\r\n        throw new IllegalStateException(\"Failed to create temp file for CQEngine disk persistence\", e);\r\n    }\r\n    return tempFile;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setAnimationMotion",
	"Comment": "allows defining the physics for the animation motion behavior directly by plugging in an alternative motion object",
	"Method": "void setAnimationMotion(Motion motion){\r\n    animationMotion = motion;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setCellRenderer",
	"Comment": "used as an optimization to mark that this component is currently beingused as a cell renderer",
	"Method": "void setCellRenderer(boolean cellRenderer){\r\n    this.cellRenderer = cellRenderer;\r\n    if (cellRenderer) {\r\n        getUnselectedStyle().markAsRendererStyle();\r\n        getSelectedStyle().markAsRendererStyle();\r\n        getDisabledStyle().markAsRendererStyle();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.l10n.DateFormat.getTimeInstance",
	"Comment": "get a dateformat instance that uses a given style for times.",
	"Method": "DateFormat getTimeInstance(DateFormat getTimeInstance,int style){\r\n    return getDateTimeInstance(DEFAULT, style);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLTable.createCellConstraint",
	"Comment": "this method is overriden to fetch the constraints from the associated htmltablemodel and converts it to tablelayout.constraint",
	"Method": "Constraint createCellConstraint(Object value,int row,int column){\r\n    CellConstraint cConstraint = ((HTMLTableModel) getModel()).getConstraint(value);\r\n    if (cConstraint == null) {\r\n        return super.createCellConstraint(value, row, column);\r\n    }\r\n    Constraint constraint = new Constraint();\r\n    constraint.setHorizontalAlign(cConstraint.align);\r\n    constraint.setVerticalAlign(cConstraint.valign);\r\n    constraint.setHorizontalSpan(cConstraint.spanHorizontal);\r\n    constraint.setVerticalSpan(cConstraint.spanVertical);\r\n    constraint.setWidthPercentage(cConstraint.width);\r\n    constraint.setHeightPercentage(cConstraint.height);\r\n    return constraint;\r\n}"
}, {
	"Path": "com.codename1.io.Log.setReportingLevel",
	"Comment": "indicates the level of log reporting, this allows developers to send device logs to the cloudthus tracking crashes or functionality in the device.",
	"Method": "void setReportingLevel(int level){\r\n    instance.reporting = level;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.MigLayout.addLayoutCallback",
	"Comment": "adds the callback function that will be called at different stages of thelayout cylce.",
	"Method": "void addLayoutCallback(LayoutCallback callback){\r\n    if (callback == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    if (callbackList == null) {\r\n        callbackList = new ArrayList<LayoutCallback>(1);\r\n    }\r\n    callbackList.add(callback);\r\n    grid = null;\r\n}"
}, {
	"Path": "java.util.PriorityQueue.contains",
	"Comment": "answers if there is an element in this queue equals to the object.",
	"Method": "boolean contains(Object object){\r\n    if (object == null) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < size; i++) {\r\n        if (object.equals(elements[i])) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.components.ButtonList.addActionListener",
	"Comment": "add a listener to be notified when any of the buttons in the list are pressed.",
	"Method": "void addActionListener(ActionListener l){\r\n    actionListeners.addListener(l);\r\n}"
}, {
	"Path": "com.codename1.properties.SQLMap.setTableName",
	"Comment": "by default the table name matches the property index name unless explicitly modified with this method",
	"Method": "void setTableName(PropertyBusinessObject cmp,String name){\r\n    cmp.getPropertyIndex().putMetaDataOfClass(\"cn1$tableName\", name);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.streamReady",
	"Comment": "this method should be called only by asyncdocumentrequesthandler implementations after an async fetch of a document",
	"Method": "void streamReady(InputStream is,DocumentInfo docInfo){\r\n    InputStreamReader isr = null;\r\n    try {\r\n        if (is != null) {\r\n            isr = new InputStreamReader(is, docInfo.getEncoding());\r\n        }\r\n    } catch (Exception uee) {\r\n        boolean cont = true;\r\n        if (htmlCallback != null) {\r\n            cont = htmlCallback.parsingError(HTMLCallback.ERROR_ENCODING, null, null, null, \"Page encoding \" + docInfo.getEncoding() + \" failed: \" + uee.getMessage());\r\n        }\r\n        if (cont) {\r\n            try {\r\n                isr = new InputStreamReader(is);\r\n            } catch (Exception e) {\r\n                htmlCallback.parsingError(HTMLCallback.ERROR_ENCODING, null, null, null, \"Page loading failed, probably due to wrong encoding. \" + e.getMessage());\r\n                isr = getStream(\"Page loading failed, probably due to encoding mismatch.\", null);\r\n                setPageStatus(HTMLCallback.STATUS_ERROR);\r\n            }\r\n        } else {\r\n            isr = getStream(\"Page encoding not supported\", null);\r\n            setPageStatus(HTMLCallback.STATUS_ERROR);\r\n        }\r\n    }\r\n    if (cancelled) {\r\n        isr = getStream(\"Page loading cancelled by user\", null);\r\n    }\r\n    if (isr == null) {\r\n        if (htmlCallback != null) {\r\n            htmlCallback.parsingError(HTMLCallback.ERROR_CONNECTING, null, null, null, \"Error connecting to stream\");\r\n        }\r\n        setPageStatus(HTMLCallback.STATUS_ERROR);\r\n        isr = getStream(\"Error connecting to stream\", null);\r\n    } else {\r\n        setPageStatus(HTMLCallback.STATUS_CONNECTED);\r\n    }\r\n    HTMLElement newDoc = null;\r\n    try {\r\n        newDoc = parser.parseHTML(isr);\r\n    } catch (IllegalArgumentException iae) {\r\n        iae.printStackTrace();\r\n        setPageStatus(HTMLCallback.STATUS_ERROR);\r\n        isr = getStream(\"Parsing error \" + iae.getMessage(), null);\r\n        newDoc = parser.parseHTML(isr);\r\n    }\r\n    if (cancelled) {\r\n        isr = getStream(\"Page loading cancelled by user\", null);\r\n        newDoc = parser.parseHTML(isr);\r\n    }\r\n    setPageStatus(HTMLCallback.STATUS_PARSED);\r\n    documentReady(docInfo, newDoc);\r\n}"
}, {
	"Path": "org.conscrypt.OAEPParameters.readHash",
	"Comment": "shared with pssparameters, since they share some of their encoded form",
	"Method": "String readHash(long seqRef){\r\n    if (NativeCrypto.asn1_read_next_tag_is(seqRef, 0)) {\r\n        long hashRef = 0;\r\n        try {\r\n            hashRef = NativeCrypto.asn1_read_tagged(seqRef);\r\n            return getHashName(hashRef);\r\n        } finally {\r\n            NativeCrypto.asn1_read_free(hashRef);\r\n        }\r\n    }\r\n    return \"SHA-1\";\r\n}"
}, {
	"Path": "com.codename1.ui.Component.initCustomStyle",
	"Comment": "allows components to create a style of their own, this method binds the listenerto the style and installs a bg painter",
	"Method": "void initCustomStyle(Style s){\r\n    s.addStyleListener(this);\r\n    if (s.getBgPainter() == null) {\r\n        s.setBgPainter(new BGPainter());\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.Log.getLogContent",
	"Comment": "returns the contents of the log as a single long string to be displayed bythe application any way it sees fit",
	"Method": "String getLogContent(){\r\n    try {\r\n        String text = \"\";\r\n        if (instance.isFileWriteEnabled()) {\r\n            if (instance.getFileURL() == null) {\r\n                instance.setFileURL(\"file:///\" + FileSystemStorage.getInstance().getRoots()[0] + \"/codenameOne.log\");\r\n            }\r\n            Reader r = new InputStreamReader(FileSystemStorage.getInstance().openInputStream(instance.getFileURL()));\r\n            char[] buffer = new char[1024];\r\n            int size = r.read(buffer);\r\n            while (size > -1) {\r\n                text += new String(buffer, 0, size);\r\n                size = r.read(buffer);\r\n            }\r\n            r.close();\r\n        }\r\n        return text;\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.setDisposeWhenPointerOutOfBounds",
	"Comment": "this flag indicates if the dialog should be disposed if a pointer released event occurred out of the dialog content.",
	"Method": "void setDisposeWhenPointerOutOfBounds(boolean disposeWhenPointerOutOfBounds){\r\n    this.disposeWhenPointerOutOfBounds = disposeWhenPointerOutOfBounds;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Style.isRaised3DText",
	"Comment": "returns true if the 3d text decoration is on, false otherwise",
	"Method": "boolean isRaised3DText(){\r\n    return ((textDecoration & TEXT_DECORATION_3D) != 0);\r\n}"
}, {
	"Path": "com.codename1.ui.Container.createAnimateHierarchyFade",
	"Comment": "animates a pending hierarchy of components into place, this effectively replaces revalidate with a more visual form of animation.",
	"Method": "ComponentAnimation createAnimateHierarchyFade(int duration,int startingOpacity){\r\n    return animateHierarchy(duration, false, startingOpacity, false);\r\n}"
}, {
	"Path": "com.codename1.ui.Form.registerMediaComponent",
	"Comment": "registering media component to this form, that like to receive animation events",
	"Method": "void registerMediaComponent(Component mediaCmp){\r\n    if (mediaComponents == null) {\r\n        mediaComponents = new ArrayList<Component>();\r\n    }\r\n    if (!mediaComponents.contains(mediaCmp)) {\r\n        mediaComponents.add(mediaCmp);\r\n    }\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.tasks.io.FileImageSink.isMatchingFormat",
	"Comment": "determines whether an specified format name and file extension are\tfor the same format.",
	"Method": "boolean isMatchingFormat(String formatName,String fileExtension){\r\n    if (formatName == null || fileExtension == null) {\r\n        return false;\r\n    }\r\n    ImageWriter iw;\r\n    try {\r\n        iw = ImageIO.getImageWritersByFormatName(formatName).next();\r\n    } catch (NoSuchElementException e) {\r\n        return false;\r\n    }\r\n    String[] suffixes = iw.getOriginatingProvider().getFileSuffixes();\r\n    for (String suffix : suffixes) {\r\n        if (fileExtension.equalsIgnoreCase(suffix)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.TreeMap.comparator",
	"Comment": "returns the comparator used to compare elements in this map.",
	"Method": "Comparator<? super K> comparator(Comparator comparator,Comparator comparator,Comparator<? super K> comparator,Comparator<? super K> comparator,Comparator<? super K> comparator,Comparator<? super K> comparator,Comparator<? super K> comparator){\r\n    return comparator;\r\n}"
}, {
	"Path": "java.util.SimpleTimeZone.hashCode",
	"Comment": "returns an integer hash code for the receiver. objects which are equalreturn the same value for this method.",
	"Method": "int hashCode(){\r\n    int hashCode = getID().hashCode() + rawOffset;\r\n    if (useDaylight) {\r\n        hashCode += startYear + startMonth + startDay + startDayOfWeek + startTime + startMode + endMonth + endDay + endDayOfWeek + endTime + endMode + dstSavings;\r\n    }\r\n    return hashCode;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.getSelectedStyle",
	"Comment": "returns a proxy style for all of the selected styles of the components in this set.",
	"Method": "Style getSelectedStyle(){\r\n    ArrayList<Style> styles = new ArrayList<Style>();\r\n    for (Component c : this) {\r\n        styles.add(c.getSelectedStyle());\r\n    }\r\n    return Style.createProxyStyle(styles.toArray(new Style[styles.size()]));\r\n}"
}, {
	"Path": "com.codename1.ui.Image.isSVGSupported",
	"Comment": "indicates whether the underlying platform supports creating an svg image",
	"Method": "boolean isSVGSupported(){\r\n    return Display.impl.isSVGSupported();\r\n}"
}, {
	"Path": "com.codename1.components.SplitPane.getTopOrLeftComponent",
	"Comment": "gets the component that is currently placed in the top or left of the split pane.",
	"Method": "Component getTopOrLeftComponent(){\r\n    for (Component c : bottomOrRight) {\r\n        return c;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.Toolbar.showSearchBar",
	"Comment": "shows the search bar manually which is useful for use cases of popping up search from code",
	"Method": "void showSearchBar(ActionListener callback){\r\n    SearchBar s = new SearchBar(Toolbar.this, searchIconSize) {\r\n        @Override\r\n        public void onSearch(String text) {\r\n            callback.actionPerformed(new ActionEvent(text));\r\n        }\r\n    };\r\n    Form f = (Form) Toolbar.this.getComponentForm();\r\n    setHidden(true);\r\n    f.removeComponentFromForm(Toolbar.this);\r\n    f.setToolbar(s);\r\n    s.initSearchBar();\r\n    if (f == Display.INSTANCE.getCurrent()) {\r\n        f.animateLayout(100);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Toolbar.showSearchBar",
	"Comment": "shows the search bar manually which is useful for use cases of popping up search from code",
	"Method": "void showSearchBar(ActionListener callback){\r\n    callback.actionPerformed(new ActionEvent(text));\r\n}"
}, {
	"Path": "com.codename1.charts.views.XYChart.isRenderPoints",
	"Comment": "returns if the chart should display the points as a certain shape.",
	"Method": "boolean isRenderPoints(SimpleSeriesRenderer renderer){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.getComponentStyle",
	"Comment": "returns the style of the component with the given id or a new instance of the defaultstyle.this method will always return a new style instance to prevent modification of the globalstyle object.",
	"Method": "Style getComponentStyle(String id){\r\n    return getComponentStyleImpl(id, false, \"\");\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.Segment.isOpen",
	"Comment": "returns a boolean value indicating whether the segment is open.",
	"Method": "boolean isOpen(){\r\n    return open;\r\n}"
}, {
	"Path": "com.codename1.io.services.ImageDownloadService.setDownloadToStyles",
	"Comment": "downloads the image to the style objects associated with this component, effectively sets the bgimage property on all the styles for the component instead of invoking seticon",
	"Method": "void setDownloadToStyles(boolean downloadToStyles){\r\n    this.downloadToStyles = downloadToStyles;\r\n}"
}, {
	"Path": "com.codename1.properties.ListProperty.addAll",
	"Comment": "adds a all properties value to the list and fires a change event",
	"Method": "K addAll(Collection<? extends T> v){\r\n    if (value.addAll(v)) {\r\n        firePropertyChanged();\r\n    }\r\n    return (K) parent.parent;\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.Picker.setRenderingPrototype",
	"Comment": "when using a lightweight spinner this will be used as the rendering prototype",
	"Method": "void setRenderingPrototype(Object renderingPrototype){\r\n    this.renderingPrototype = renderingPrototype;\r\n}"
}, {
	"Path": "com.codename1.charts.views.TimeChart.getDSTOffset",
	"Comment": "determine the number of minutes to adjust the date for local dst. thisshould provide a historically correct value, also accounting for changesin gmt offset. see timezone javadoc for more details.",
	"Method": "int getDSTOffset(Calendar source){\r\n    TimeZone localTimezone = Calendar.getInstance().getTimeZone();\r\n    int rawOffset = localTimezone.getRawOffset() / MILLIS_TO_MINUTES;\r\n    return getOffsetInMinutes(source, localTimezone) - rawOffset;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Style.isOverline",
	"Comment": "returns true if the overline text decoration is on, false otherwise",
	"Method": "boolean isOverline(){\r\n    return ((textDecoration & TEXT_DECORATION_OVERLINE) != 0);\r\n}"
}, {
	"Path": "java.lang.String.equals",
	"Comment": "compares this string to the specified object. the result is true if and only if the argument is not null and is a string object that represents the same sequence of characters as this object.",
	"Method": "boolean equals(java.lang.Object anObject){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.io.MultipartRequest.setCanFlushStream",
	"Comment": "sending large files requires flushing the writer once in a while to preventout of memory errors, some j2me implementation are not able to flush the streams causing the upload to fail.this method can indicate to the upload to not use the flushing mechanism.",
	"Method": "void setCanFlushStream(boolean flush){\r\n    canFlushStream = flush;\r\n}"
}, {
	"Path": "android.support.v4.widget.ViewDragHelper.getMinVelocity",
	"Comment": "return the currently configured minimum velocity. any flings with a magnitude lessthan this value in pixels per second. callback methods accepting a velocity will receivezero as a velocity value if the real detected velocity was below this threshold.",
	"Method": "float getMinVelocity(){\r\n    return mMinVelocity;\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.isSymbolDialogKey",
	"Comment": "returns true if this keycode is the one mapping to the symbol dialog popup",
	"Method": "boolean isSymbolDialogKey(int keyCode){\r\n    return keyCode == defaultSymbolDialogKey;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Collections.newSetFromMap",
	"Comment": "answers a set backed by a map. and the map must be empty when this methodis called.",
	"Method": "Set<E> newSetFromMap(Map<E, Boolean> map){\r\n    if (map.isEmpty()) {\r\n        return new SetFromMap<E>(map);\r\n    }\r\n    throw new IllegalArgumentException();\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.evaluateTuples",
	"Comment": "for each tuple in a list, evaluates an expression and creates a mapfrom tuples to values.",
	"Method": "Map<List<Member>, Object> evaluateTuples(Evaluator evaluator,Calc exp,TupleList tuples){\r\n    final int savepoint = evaluator.savepoint();\r\n    try {\r\n        assert exp.getType() instanceof ScalarType;\r\n        final Map<List<Member>, Object> mapMemberToValue = new HashMap<List<Member>, Object>();\r\n        for (int i = 0, count = tuples.size(); i < count; i++) {\r\n            List<Member> tuple = tuples.get(i);\r\n            evaluator.setContext(tuple);\r\n            Object result = exp.evaluate(evaluator);\r\n            if (result == null) {\r\n                result = Util.nullValue;\r\n            }\r\n            mapMemberToValue.put(tuple, result);\r\n        }\r\n        return mapMemberToValue;\r\n    } finally {\r\n        evaluator.restore(savepoint);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.analytics.AnalyticsService.isEnabled",
	"Comment": "indicates whether analytics is enabled for this application",
	"Method": "boolean isEnabled(){\r\n    return instance != null && instance.isAnalyticsEnabled();\r\n}"
}, {
	"Path": "com.codename1.io.Preferences.setPreferencesLocation",
	"Comment": "sets the location within the storage of the preferences file to an arbitrary name. this is useful in a caseof encryption where we would want preferences to use a different file name.",
	"Method": "void setPreferencesLocation(String storageFileName){\r\n    preferencesLocation = storageFileName;\r\n    p = null;\r\n}"
}, {
	"Path": "ly.count.android.sdk.CountlyStarRating.setStarRatingInitConfig",
	"Comment": "setting things that would be provided during initial config",
	"Method": "void setStarRatingInitConfig(Context context,int limit,String starRatingTextTitle,String starRatingTextMessage,String starRatingTextDismiss){\r\n    StarRatingPreferences srp = loadStarRatingPreferences(context);\r\n    if (limit >= 0) {\r\n        srp.sessionLimit = limit;\r\n    }\r\n    if (starRatingTextTitle != null) {\r\n        srp.dialogTextTitle = starRatingTextTitle;\r\n    }\r\n    if (starRatingTextMessage != null) {\r\n        srp.dialogTextMessage = starRatingTextMessage;\r\n    }\r\n    if (starRatingTextDismiss != null) {\r\n        srp.dialogTextDismiss = starRatingTextDismiss;\r\n    }\r\n    saveStarRatingPreferences(context, srp);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayeredLayout.setReferenceComponentTop",
	"Comment": "sets the reference component for the top inset of the given component.",
	"Method": "LayeredLayout setReferenceComponentTop(Component cmp,Component referenceComponent,LayeredLayout setReferenceComponentTop,Component cmp,Component referenceComponent,float position){\r\n    getOrCreateConstraint(cmp).top().referenceComponent(referenceComponent).referencePosition(position);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.PlatformDefaults.setPanelInsets",
	"Comment": "sets the default insets for a dialog. values that are null will not be changed.",
	"Method": "void setPanelInsets(UnitValue top,UnitValue left,UnitValue bottom,UnitValue right){\r\n    if (top != null)\r\n        PANEL_INS[0] = top;\r\n    if (left != null)\r\n        PANEL_INS[1] = left;\r\n    if (bottom != null)\r\n        PANEL_INS[2] = bottom;\r\n    if (right != null)\r\n        PANEL_INS[3] = right;\r\n    MOD_COUNT++;\r\n}"
}, {
	"Path": "com.codename1.components.Switch.addActionListener",
	"Comment": "adds a listener to the switch which will cause an event to dispatch onclick",
	"Method": "void addActionListener(ActionListener l){\r\n    dispatcher.addListener(l);\r\n}"
}, {
	"Path": "com.codename1.ui.Container.moveScrollTowards",
	"Comment": "this method scrolls the container if scrollable towards the given component based on the given direction.",
	"Method": "boolean moveScrollTowards(int direction,Component next){\r\n    if (isScrollable()) {\r\n        Component current = null;\r\n        Form f = getComponentForm();\r\n        current = f.getFocused();\r\n        boolean cyclic = f.isCyclicFocus();\r\n        f.setCyclicFocus(false);\r\n        boolean edge = false;\r\n        boolean currentLarge = false;\r\n        boolean scrollOutOfBounds = false;\r\n        int x = getScrollX();\r\n        int y = getScrollY();\r\n        int w = getWidth();\r\n        int h = getHeight();\r\n        switch(direction) {\r\n            case Display.GAME_UP:\r\n                if (!cyclic && getScrollY() == 0) {\r\n                    return true;\r\n                }\r\n                y = getScrollY() - scrollIncrement;\r\n                edge = f.findNextFocusUp() == null;\r\n                currentLarge = (current != null && current.getVisibleBounds().getSize().getHeight() > getHeight());\r\n                scrollOutOfBounds = y < 0;\r\n                if (scrollOutOfBounds) {\r\n                    y = 0;\r\n                }\r\n                break;\r\n            case Display.GAME_DOWN:\r\n                y = getScrollY() + scrollIncrement;\r\n                edge = f.findNextFocusDown() == null;\r\n                currentLarge = (current != null && current.getVisibleBounds().getSize().getHeight() > getHeight());\r\n                scrollOutOfBounds = y > getScrollDimension().getHeight() - getHeight();\r\n                if (scrollOutOfBounds) {\r\n                    y = getScrollDimension().getHeight() - getHeight();\r\n                }\r\n                break;\r\n            case Display.GAME_RIGHT:\r\n                x = getScrollX() + scrollIncrement;\r\n                edge = f.findNextFocusRight() == null;\r\n                currentLarge = (current != null && current.getVisibleBounds().getSize().getWidth() > getWidth());\r\n                scrollOutOfBounds = x > getScrollDimension().getWidth() - getWidth();\r\n                if (scrollOutOfBounds) {\r\n                    x = getScrollDimension().getWidth() - getWidth();\r\n                }\r\n                break;\r\n            case Display.GAME_LEFT:\r\n                x = getScrollX() - scrollIncrement;\r\n                edge = f.findNextFocusLeft() == null;\r\n                currentLarge = (current != null && current.getVisibleBounds().getSize().getWidth() > getWidth());\r\n                scrollOutOfBounds = x < 0;\r\n                if (scrollOutOfBounds) {\r\n                    x = 0;\r\n                }\r\n                break;\r\n        }\r\n        f.setCyclicFocus(cyclic);\r\n        if (next == null || next == this) {\r\n            scrollRectToVisible(x, y, w, h, this);\r\n            return false;\r\n        }\r\n        if (!cyclic && direction == Display.GAME_DOWN && edge) {\r\n            scrollRectToVisible(x, y, w, h, this);\r\n            return false;\r\n        }\r\n        boolean nextIntersects = contains(next) && Rectangle.intersects(next.getAbsoluteX(), next.getAbsoluteY(), next.getWidth(), next.getHeight(), getAbsoluteX() + x, getAbsoluteY() + y, w, h);\r\n        if ((nextIntersects && !currentLarge && !edge) || (Rectangle.contains(getAbsoluteX() + getScrollX(), getAbsoluteY() + getScrollY(), w, h, next.getAbsoluteX(), next.getAbsoluteY(), next.getWidth(), next.getHeight()))) {\r\n            return true;\r\n        } else {\r\n            if (!scrollOutOfBounds) {\r\n                scrollRectToVisible(x, y, w, h, this);\r\n                if (nextIntersects && !Rectangle.intersects(current.getAbsoluteX(), current.getAbsoluteY(), current.getWidth(), current.getHeight(), getAbsoluteX() + x, getAbsoluteY() + y, w, h)) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            } else {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.components.Switch.getListeners",
	"Comment": "returns a collection containing the action listeners for this button",
	"Method": "Collection getListeners(){\r\n    return dispatcher.getListenerCollection();\r\n}"
}, {
	"Path": "com.codename1.components.InfiniteProgress.setAnimation",
	"Comment": "allows setting the image that will be rotated as part of this effect",
	"Method": "void setAnimation(Image animation){\r\n    this.animation = animation;\r\n    cache.clear();\r\n}"
}, {
	"Path": "java.lang.Math.toDegrees",
	"Comment": "converts an angle measured in radians to the equivalent angle measured in degrees.",
	"Method": "double toDegrees(double angrad){\r\n    return angrad * 57.2957795;\r\n}"
}, {
	"Path": "com.codename1.share.ShareService.finish",
	"Comment": "once the share service has finished sharing it should call the finish method",
	"Method": "void finish(){\r\n    original.showBack();\r\n}"
}, {
	"Path": "android.support.v4.widget.CursorAdapter.getFilterQueryProvider",
	"Comment": "returns the query filter provider used for filtering. when theprovider is null, no filtering occurs.",
	"Method": "FilterQueryProvider getFilterQueryProvider(){\r\n    return mFilterQueryProvider;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLFont.isSameFamily",
	"Comment": "utility method that first checks that neither font family is null and then compares them",
	"Method": "boolean isSameFamily(HTMLFont font){\r\n    return ((family != null) && (font.getFamily() != null) && (family.equals(font.getFamily())));\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getSelectedStyle",
	"Comment": "returns the component style for the selected state allowing us to manipulatethe look of the component when it owns focus",
	"Method": "Style getSelectedStyle(){\r\n    if (selectedStyle == null) {\r\n        if (hasInlineSelectedStyle()) {\r\n            selectedStyle = getUIManager().parseComponentSelectedStyle(getInlineStylesTheme(), getUIID(), getInlineStylesUIID(), getInlineSelectedStyleStrings());\r\n        } else {\r\n            selectedStyle = getUIManager().getComponentSelectedStyle(getUIID());\r\n        }\r\n        selectedStyle.addStyleListener(this);\r\n        if (selectedStyle.getBgPainter() == null) {\r\n            selectedStyle.setBgPainter(new BGPainter());\r\n        }\r\n        if (cellRenderer) {\r\n            selectedStyle.markAsRendererStyle();\r\n        }\r\n    }\r\n    return selectedStyle;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.purgeCache",
	"Comment": "deletes the cache file if it exists, notice that this will not work for download files",
	"Method": "void purgeCache(){\r\n    FileSystemStorage.getInstance().delete(getCacheFileName());\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.setDefaultDisposeWhenPointerOutOfBounds",
	"Comment": "the default pointer out of bounds dispose behavior, notice thatthis only applies to dialogs and not popup dialogs where this isalways true by default",
	"Method": "void setDefaultDisposeWhenPointerOutOfBounds(boolean aDefaultDisposeWhenPointerOutOfBounds){\r\n    defaultDisposeWhenPointerOutOfBounds = aDefaultDisposeWhenPointerOutOfBounds;\r\n}"
}, {
	"Path": "com.codename1.processing.AbstractEvaluator.evaluateLeftContainsRight",
	"Comment": "override this element to handle testing a predicate expression wherelvalue % rvalue.",
	"Method": "Object evaluateLeftContainsRight(List elements,String lvalue,String rvalue,Object evaluateLeftContainsRight,StructuredContent element,String lvalue,String rvalue){\r\n    return null;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.index.OffsetIndex.size",
	"Comment": "returns the count of the index for the given number of entries.",
	"Method": "long size(int maxEntries,int size){\r\n    return (long) maxEntries * 12 + 16;\r\n}"
}, {
	"Path": "com.codename1.ui.Graphics.tileImage",
	"Comment": "allows an implementation to optimize image tiling rendering logic",
	"Method": "void tileImage(Image img,int x,int y,int w,int h){\r\n    if (img.requiresDrawImage()) {\r\n        int iW = img.getWidth();\r\n        int iH = img.getHeight();\r\n        int clipX = getClipX();\r\n        int clipW = getClipWidth();\r\n        int clipY = getClipY();\r\n        int clipH = getClipHeight();\r\n        clipRect(x, y, w, h);\r\n        for (int xPos = 0; xPos <= w; xPos += iW) {\r\n            for (int yPos = 0; yPos < h; yPos += iH) {\r\n                int actualX = xPos + x;\r\n                int actualY = yPos + y;\r\n                if (actualX > clipX + clipW) {\r\n                    continue;\r\n                }\r\n                if (actualX + iW < clipX) {\r\n                    continue;\r\n                }\r\n                if (actualY > clipY + clipH) {\r\n                    continue;\r\n                }\r\n                if (actualY + iH < clipY) {\r\n                    continue;\r\n                }\r\n                drawImage(img, actualX, actualY);\r\n            }\r\n        }\r\n        setClip(clipX, clipY, clipW, clipH);\r\n    } else {\r\n        impl.tileImage(nativeGraphics, img.getImage(), x + xTranslate, y + yTranslate, w, h);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Image.getImage",
	"Comment": "returns the platform specific image implementation, warning theimplementation class can change between revisions of codename one and platforms.",
	"Method": "Object getImage(){\r\n    return image;\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.isQwertyAutoDetect",
	"Comment": "indicates whether the text field should try to auto detect qwerty and switch the qwerty device flag implicitly",
	"Method": "boolean isQwertyAutoDetect(){\r\n    return qwertyAutoDetect;\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.anonymousLogin",
	"Comment": "some simple queries for public data can work just fine with anonymous login without requiring the wholeoauth process, they still need a facebook application though",
	"Method": "void anonymousLogin(String appid,String clientSecret){\r\n    ConnectionRequest req = new ConnectionRequest();\r\n    req.setPost(false);\r\n    req.setUrl(\"https://graph.facebook.com/oauth/access_token\");\r\n    req.addArgument(\"client_id\", appid);\r\n    req.addArgument(\"client_secret\", clientSecret);\r\n    req.addArgument(\"grant_type\", \"client_credentials\");\r\n    NetworkManager.getInstance().addToQueueAndWait(req);\r\n    if (req.getResponseData() != null) {\r\n        token = new String(req.getResponseData());\r\n        token = token.substring(token.indexOf('=') + 1);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Motion.getValue",
	"Comment": "returns the value for the motion for the current clock time. the value is dependent on the motion type.",
	"Method": "int getValue(){\r\n    if (currentMotionTime > -1 && startTime > getCurrentMotionTime()) {\r\n        return sourceValue;\r\n    }\r\n    previousLastReturnedValue[0] = previousLastReturnedValue[1];\r\n    previousLastReturnedValue[1] = previousLastReturnedValue[2];\r\n    previousLastReturnedValue[2] = lastReturnedValue;\r\n    switch(motionType) {\r\n        case SPLINE:\r\n            lastReturnedValue = getSplineValue();\r\n            break;\r\n        case CUBIC:\r\n            lastReturnedValue = getCubicValue();\r\n            break;\r\n        case FRICTION:\r\n            lastReturnedValue = getFriction();\r\n            break;\r\n        case DECELERATION:\r\n            lastReturnedValue = getRubber();\r\n            break;\r\n        case COLOR_LINEAR:\r\n            lastReturnedValue = getColorLinear();\r\n            break;\r\n        case EXPONENTIAL_DECAY:\r\n            lastReturnedValue = getExponentialDecay();\r\n            break;\r\n        default:\r\n            lastReturnedValue = getLinear();\r\n            break;\r\n    }\r\n    return lastReturnedValue;\r\n}"
}, {
	"Path": "com.codename1.ui.List.setIgnoreFocusComponentWhenUnfocused",
	"Comment": "indicates whether the list should not paint the focus component if the listitself has no focus.",
	"Method": "void setIgnoreFocusComponentWhenUnfocused(boolean ignoreFocusComponentWhenUnfocused){\r\n    this.ignoreFocusComponentWhenUnfocused = ignoreFocusComponentWhenUnfocused;\r\n}"
}, {
	"Path": "org.conscrypt.ct.Serialization.readNumber",
	"Comment": "read a number in big endian format from the input stream.this methods only supports a width of up to 4 bytes.",
	"Method": "int readNumber(InputStream input,int width){\r\n    if (width > 4 || width < 0) {\r\n        throw new SerializationException(\"Invalid width: \" + width);\r\n    }\r\n    int result = 0;\r\n    for (int i = 0; i < width; i++) {\r\n        result = (result << 8) | (readByte(input) & 0xFF);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.getDayText",
	"Comment": "since a day may be any component type, developers should override thismethod to add support for removing the click listener from the givencomponent.",
	"Method": "String getDayText(Component cmp){\r\n    if (cmp instanceof Button) {\r\n        return ((Button) cmp).getText();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.protocol.InstallRequest.builder",
	"Comment": "returns an install request builder for an existing request.",
	"Method": "Builder builder(Builder builder,InstallRequest request){\r\n    return new Builder(request);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.getDimConstraint",
	"Comment": "returns the vertical or horizontal dim constraint.\tnote! if any changes is to be made it must be made direct when the object is returned. it is not allowed to save the\tconstraint for later use.",
	"Method": "DimConstraint getDimConstraint(boolean isHor){\r\n    return isHor ? hor : ver;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.filter",
	"Comment": "creates a new set of components formed by filtering the current set using a filter function.",
	"Method": "boolean filter(Component c,ComponentSelector filter,Filter filter){\r\n    HashSet<Component> out = new HashSet<Component>();\r\n    for (Component c : this) {\r\n        boolean res = filter.filter(c);\r\n        if (res) {\r\n            out.add(c);\r\n        }\r\n    }\r\n    return new ComponentSelector(out);\r\n}"
}, {
	"Path": "android.support.v4.widget.SlidingPaneLayout.setSliderFadeColor",
	"Comment": "set the color used to fade the sliding pane out when it is slid most of the way offscreen.",
	"Method": "void setSliderFadeColor(int color){\r\n    mSliderFadeColor = color;\r\n}"
}, {
	"Path": "com.android.org.conscrypt.OpenSSLSocketImpl.setHandshakeTimeout",
	"Comment": "set the handshake timeout on this socket.this timeout is specified inmilliseconds and will be used only during the handshake process.",
	"Method": "void setHandshakeTimeout(int handshakeTimeoutMilliseconds){\r\n    throw new RuntimeException(\"Stub!\");\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.drawLabelString",
	"Comment": "implements the drawstring for the text component and adjust the valignassuming the icon is in one of the sides",
	"Method": "int drawLabelString(Object nativeGraphics,Object nativeFont,String text,int x,int y,int textSpaceW,boolean isTickerRunning,int tickerShiftText,int textDecoration,boolean rtl,boolean endsWith3Points,int textWidth,int fontHeight){\r\n    int cx = getClipX(nativeGraphics);\r\n    int cy = getClipY(nativeGraphics);\r\n    int cw = getClipWidth(nativeGraphics);\r\n    int ch = getClipHeight(nativeGraphics);\r\n    clipRect(nativeGraphics, x, cy, textSpaceW, ch);\r\n    int drawnW = drawLabelText(nativeGraphics, textDecoration, rtl, isTickerRunning, endsWith3Points, nativeFont, textWidth, textSpaceW, tickerShiftText, text, x, y, fontHeight);\r\n    setClip(nativeGraphics, cx, cy, cw, ch);\r\n    return drawnW;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.OffsetIndexTest.testIndexContainsCommitted",
	"Comment": "tests indexing an offset and checking whether the index contains the offset.",
	"Method": "void testIndexContainsCommitted(){\r\n    OffsetIndex index = new DelegatingOffsetIndex(HeapBuffer.allocate(1024 * 8));\r\n    assertFalse(index.contains(10));\r\n    index.index(10, 1234);\r\n    assertTrue(index.contains(10));\r\n    assertFalse(index.contains(9));\r\n    assertFalse(index.contains(11));\r\n}"
}, {
	"Path": "com.codename1.components.MultiButton.setEmblemPosition",
	"Comment": "sets the emblem position based on border layout constraints",
	"Method": "void setEmblemPosition(String t){\r\n    String ip = getIconPosition();\r\n    if (ip != null && ip.equals(t)) {\r\n        String ep = getEmblemPosition();\r\n        removeComponent(emblem.getParent());\r\n        setIconPosition(ep);\r\n    } else {\r\n        removeComponent(emblem.getParent());\r\n    }\r\n    addComponent(t, emblem.getParent());\r\n    revalidate();\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.showPackedImpl",
	"Comment": "convenience method to show a dialog sized to match its content.",
	"Method": "Command showPackedImpl(String position,boolean modal,boolean stretch){\r\n    if (getTitle() == null) {\r\n        setTitle(\"\");\r\n    }\r\n    this.position = position;\r\n    int height = Display.getInstance().getDisplayHeight();\r\n    int width = Display.getInstance().getDisplayWidth();\r\n    if (top > -1) {\r\n        refreshTheme();\r\n    }\r\n    Component contentPane = super.getContentPane();\r\n    if (dialogTitle != null && getUIManager().isThemeConstant(\"hideEmptyTitleBool\", false)) {\r\n        boolean b = getTitle().length() > 0;\r\n        getTitleArea().setVisible(b);\r\n        getTitleComponent().setVisible(b);\r\n    }\r\n    Style contentPaneStyle = contentPane.getStyle();\r\n    revalidate();\r\n    int prefHeight = contentPane.getPreferredH();\r\n    int prefWidth = contentPane.getPreferredW();\r\n    prefWidth = Math.min(prefWidth, width);\r\n    if (contentPaneStyle.getBorder() != null) {\r\n        prefWidth = Math.max(contentPaneStyle.getBorder().getMinimumWidth(), prefWidth);\r\n        prefHeight = Math.max(contentPaneStyle.getBorder().getMinimumHeight(), prefHeight);\r\n    }\r\n    int topBottom = Math.max(0, (height - prefHeight) / 2);\r\n    int leftRight = Math.max(0, (width - prefWidth) / 2);\r\n    if (position.equals(BorderLayout.CENTER)) {\r\n        show(topBottom, topBottom, leftRight, leftRight, true, modal);\r\n        return lastCommandPressed;\r\n    }\r\n    if (position.equals(BorderLayout.EAST)) {\r\n        if (stretch) {\r\n            show(0, 0, Math.max(0, width - prefWidth), 0, true, modal);\r\n        } else {\r\n            show(topBottom, topBottom, Math.max(0, width - prefWidth), 0, true, modal);\r\n        }\r\n        return lastCommandPressed;\r\n    }\r\n    if (position.equals(BorderLayout.WEST)) {\r\n        if (stretch) {\r\n            show(0, 0, 0, Math.max(0, width - prefWidth), true, modal);\r\n        } else {\r\n            show(topBottom, topBottom, 0, Math.max(0, width - prefWidth), true, modal);\r\n        }\r\n        return lastCommandPressed;\r\n    }\r\n    if (position.equals(BorderLayout.NORTH)) {\r\n        if (stretch) {\r\n            show(0, Math.max(0, height - prefHeight), 0, 0, true, modal);\r\n        } else {\r\n            show(0, Math.max(0, height - prefHeight), leftRight, leftRight, true, modal);\r\n        }\r\n        return lastCommandPressed;\r\n    }\r\n    if (position.equals(BorderLayout.SOUTH)) {\r\n        if (stretch) {\r\n            show(Math.max(0, height - prefHeight), 0, 0, 0, true, modal);\r\n        } else {\r\n            show(Math.max(0, height - prefHeight), 0, leftRight, leftRight, true, modal);\r\n        }\r\n        return lastCommandPressed;\r\n    }\r\n    throw new IllegalArgumentException(\"Unknown position: \" + position);\r\n}"
}, {
	"Path": "java.util.Collections.synchronizedSet",
	"Comment": "returns a wrapper on the specified set which synchronizes all access tothe set.",
	"Method": "Set<E> synchronizedSet(Set<E> set){\r\n    if (set == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    return new SynchronizedSet<E>(set);\r\n}"
}, {
	"Path": "java.util.Collections.synchronizedSortedSet",
	"Comment": "returns a wrapper on the specified sorted set which synchronizes allaccess to the sorted set.",
	"Method": "SortedSet<E> synchronizedSortedSet(SortedSet<E> set){\r\n    if (set == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    return new SynchronizedSortedSet<E>(set);\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.Spinner.createTime",
	"Comment": "creates a new time spinner instance, time is an integer represented in secondssince mindnight",
	"Method": "Spinner createTime(int min,int max,int currentValue,int step,boolean twentyFourHours,boolean showSeconds){\r\n    Spinner s = new Spinner(new SpinnerNumberModel(min, max, currentValue, step), DateTimeRenderer.createTimeRenderer(twentyFourHours, showSeconds));\r\n    return s;\r\n}"
}, {
	"Path": "com.codename1.impl.javase.JavaSEPort.transformScale",
	"Comment": "scales the provided transform by the provide scale factors.",
	"Method": "void transformScale(Object nativeTransform,float x,float y,float z){\r\n    ((AffineTransform) nativeTransform).scale(x, y);\r\n    clamp((AffineTransform) nativeTransform);\r\n}"
}, {
	"Path": "com.codename1.components.MultiButton.getEmblemPosition",
	"Comment": "returns the emblem position based on border layout constraints",
	"Method": "String getEmblemPosition(){\r\n    return (String) getLayout().getComponentConstraint(emblem.getParent());\r\n}"
}, {
	"Path": "com.codename1.ui.Display.flashBacklight",
	"Comment": "flash the backlight of the device for the given length of time",
	"Method": "void flashBacklight(int duration){\r\n    impl.flashBacklight(duration);\r\n}"
}, {
	"Path": "com.codename1.ui.Label.isLegacyRenderer",
	"Comment": "fallback to the old default look and feel renderer for cases where compatibility is essential",
	"Method": "boolean isLegacyRenderer(){\r\n    return legacyRenderer;\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.setDayText",
	"Comment": "since a day may be any component type, developers should override thismethod to add support for setting the displayed string.",
	"Method": "void setDayText(Component cmp,String text){\r\n    if (cmp instanceof Button) {\r\n        ((Button) cmp).setText(text);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.Oauth2.isBackToParent",
	"Comment": "enables going back to the parent form after login is completed",
	"Method": "boolean isBackToParent(){\r\n    return backToParent;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isUseNativeCookieStore",
	"Comment": "uses the native cookie store if applicable, this might break simulator compatibility",
	"Method": "boolean isUseNativeCookieStore(){\r\n    return useNativeCookieStore;\r\n}"
}, {
	"Path": "com.codename1.ui.table.Table.createCellConstraint",
	"Comment": "creates the table cell constraint for the given cell, this method can be overriden forthe purposes of modifying the table constraints.",
	"Method": "TableLayout.Constraint createCellConstraint(Object value,int row,int column){\r\n    if (includeHeader) {\r\n        row++;\r\n    }\r\n    TableLayout t = (TableLayout) getLayout();\r\n    return t.createConstraint(row, column);\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.getPressedStyle",
	"Comment": "returns a proxy style for all of the pressed styles of the components in this set.",
	"Method": "Style getPressedStyle(){\r\n    ArrayList<Style> styles = new ArrayList<Style>();\r\n    for (Component c : this) {\r\n        styles.add(c.getPressedStyle());\r\n    }\r\n    return Style.createProxyStyle(styles.toArray(new Style[styles.size()]));\r\n}"
}, {
	"Path": "cognitivej.vision.face.persongroup.PersonGroupBuilder.deleteGroup",
	"Comment": "delete an existing person group. persisted face images of all people in the person group will also be deleted.",
	"Method": "DeletePersonGroupAction deleteGroup(String personGroupId){\r\n    Validation.validate(personGroupId, \"^[a-z0-9_-]{1,64}$\", new ParameterValidationException(\"personGroupId\", \"Person group ID is invalid. Valid format should be a string composed by numbers, english letters in lower case, '-', '_', and no longer than 64 characters.\"));\r\n    return new DeletePersonGroupAction(cognitiveContext, personGroupId);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.pointerReleased",
	"Comment": "pushes a pointer release event with the given coordinates into codename one",
	"Method": "void pointerReleased(int[] x,int[] y){\r\n    longPointerCharged = false;\r\n    if (impl.getCurrentForm() == null) {\r\n        return;\r\n    }\r\n    if (x.length == 1) {\r\n        addPointerEvent(POINTER_RELEASED, x[0], y[0]);\r\n    } else {\r\n        addPointerEvent(POINTER_RELEASED_MULTI, x, y);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLFont.getSizeInPixels",
	"Comment": "returns the font size in pixels. for system fonts an estimation is made.",
	"Method": "int getSizeInPixels(){\r\n    if (systemFont) {\r\n        return font.getHeight() - 2;\r\n    } else {\r\n        return size;\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.compaction.Compactor.majorIndex",
	"Comment": "returns the maximum compaction index for major compaction.",
	"Method": "Compactor majorIndex(long index,long majorIndex){\r\n    return majorIndex;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.LayoutUtil.setDesignTimeEmptySize",
	"Comment": "the size of an empty row or columns in a grid during design time.",
	"Method": "void setDesignTimeEmptySize(int pixels){\r\n    eSz = pixels;\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyIndex.get",
	"Comment": "allows us to get an individual property within the object instance",
	"Method": "PropertyBase get(String name,PropertyBase get,int i){\r\n    return properties[i];\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.getDisposeOnCompletion",
	"Comment": "a dialog that will be seamlessly disposed once the given request has been completed",
	"Method": "Dialog getDisposeOnCompletion(){\r\n    return disposeOnCompletion;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.isPaintOuterBorderFirst",
	"Comment": "allows toggling the order in which the outer and inner borders are painted for the outer border type",
	"Method": "boolean isPaintOuterBorderFirst(){\r\n    return paintOuterBorderFirst;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.system.Configuration.term",
	"Comment": "returns the configuration term.the term is the term of the leader at the time the configuration change was committed.",
	"Method": "long term(){\r\n    return term;\r\n}"
}, {
	"Path": "com.codename1.ui.RGBImage.isOpaque",
	"Comment": "indicates if an image should be treated as opaque, this can improve supportfor fast drawing of rgb images without alpha support.",
	"Method": "boolean isOpaque(){\r\n    return opaque;\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.handlesKeycode",
	"Comment": "this method returns true if the menubar should handle the given keycode.",
	"Method": "boolean handlesKeycode(int keyCode){\r\n    if (keyCode == 0) {\r\n        return false;\r\n    }\r\n    int game = Display.getInstance().getGameAction(keyCode);\r\n    if (isLSK(keyCode) || isRSK(keyCode) || keyCode == backSK || (keyCode == clearSK && clearCommand != null) || (keyCode == backspaceSK && clearCommand != null) || (thirdSoftButton && game == Display.GAME_FIRE)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.Arrays.copySwap",
	"Comment": "copies object from one array to another array with reverse of objectsorder. source and destination arrays may be the same.",
	"Method": "void copySwap(Object[] src,int from,Object[] dst,int to,int len){\r\n    if (src == dst && from + len > to) {\r\n        int new_to = to + len - 1;\r\n        for (; from < to; from++, new_to--, len--) {\r\n            dst[new_to] = src[from];\r\n        }\r\n        for (; len > 1; from++, new_to--, len -= 2) {\r\n            swap(from, new_to, dst);\r\n        }\r\n    } else {\r\n        to = to + len - 1;\r\n        for (; len > 0; from++, to--, len--) {\r\n            dst[to] = src[from];\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.containsAll",
	"Comment": "searches this vector for all objects in the specified collection.",
	"Method": "boolean containsAll(Collection<?> collection){\r\n    return super.containsAll(collection);\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.setSilentRetryCount",
	"Comment": "indicates the number of times to silently retry a connection that failedbefore prompting",
	"Method": "void setSilentRetryCount(int silentRetryCount){\r\n    this.silentRetryCount = silentRetryCount;\r\n}"
}, {
	"Path": "com.codename1.location.Geofence.getRadius",
	"Comment": "gets the radius of the geofence in metres.note that the actual radius will varyon an actual device depending on the hardware and os.typical android and ios devices have a minimum radius of 100m.",
	"Method": "int getRadius(){\r\n    return radius;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentGroup.isForceGroup",
	"Comment": "component grouping can be an element from the theme but can be forced manuallyfor a specific group",
	"Method": "boolean isForceGroup(){\r\n    return forceGroup;\r\n}"
}, {
	"Path": "com.codename1.xml.XMLParser.createNewElement",
	"Comment": "creates a new element. this should be overriden by parsers that use a subclass of element.",
	"Method": "Element createNewElement(String name){\r\n    Element e = new Element(name);\r\n    e.caseSensitive = caseSensitive;\r\n    return e;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.snapshot.SnapshotFile.createSnapshotFile",
	"Comment": "creates a snapshot file for the given directory, log name, and snapshot index.",
	"Method": "File createSnapshotFile(String name,File directory,long index,long timestamp){\r\n    return new File(directory, String.format(\"%s-%d-%s.snapshot\", Assert.notNull(name, \"name\"), index, TIMESTAMP_FORMAT.format(new Date(timestamp))));\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.addAccessKey",
	"Comment": "adds the given access key to make it focus on the given component",
	"Method": "void addAccessKey(int accessKey,Component cmp,boolean override){\r\n    if ((override) && (accessKeys.contains(cmp))) {\r\n        Hashtable newAccessKeys = new Hashtable();\r\n        for (Enumeration e = accessKeys.keys(); e.hasMoreElements(); ) {\r\n            Object key = e.nextElement();\r\n            Component c = (Component) accessKeys.get(key);\r\n            if (c != cmp) {\r\n                newAccessKeys.put(key, c);\r\n            }\r\n        }\r\n        accessKeys = newAccessKeys;\r\n    }\r\n    accessKeys.put(new Integer(accessKey), cmp);\r\n    Form form = getComponentForm();\r\n    if (form != null) {\r\n        form.addKeyListener(accessKey, this);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.getPadding",
	"Comment": "returns the absolute resizing in the last stage of the layout cycle. may be null and elements may be null.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "UnitValue[] getPadding(){\r\n    return padding != null ? new UnitValue[] { padding[0], padding[1], padding[2], padding[3] } : null;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getName",
	"Comment": "a component name allows us to easily identify the component within a dynamicui.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.hashCode",
	"Comment": "returns an integer hash code for the receiver. objects which are equalreturn the same value for this method.",
	"Method": "int hashCode(){\r\n    int result = 1;\r\n    for (int i = 0; i < elementCount; i++) {\r\n        result = (31 * result) + (elementData[i] == null ? 0 : elementData[i].hashCode());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.clickMenuItem",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "void clickMenuItem(String name){\r\n    TestUtils.clickMenuItem(name);\r\n}"
}, {
	"Path": "ly.count.android.sdk.UserData.pushUniqueValue",
	"Comment": "create array property, if property does not exist and add value to array, only if value is not yet in the arrayyou can only use it on array properties or properties that do not exist yet",
	"Method": "void pushUniqueValue(String key,String value){\r\n    UserData.modifyCustomData(key, value, \"$addToSet\");\r\n}"
}, {
	"Path": "com.codename1.ui.Display.setCrashReporter",
	"Comment": "the crash reporter gets invoked when an uncaught exception is intercepted",
	"Method": "void setCrashReporter(CrashReport crashReporter){\r\n    this.crashReporter = crashReporter;\r\n}"
}, {
	"Path": "com.codename1.designer.css.CSSTheme.isModified",
	"Comment": "checks if the given element id has been modified since the last cache",
	"Method": "boolean isModified(String id){\r\n    if (selectorCacheStatus != null) {\r\n        CacheStatus status = selectorCacheStatus.get(id);\r\n        if (status == null) {\r\n            return true;\r\n        }\r\n        switch(status) {\r\n            case MODIFIED:\r\n            case ADDED:\r\n                return true;\r\n        }\r\n        Element el = elements.get(id);\r\n        String derive = el.getThemeDerive(el.getFlattenedStyle(), \"\");\r\n        String unselectedDerive = el.getThemeDerive(el.getFlattenedUnselectedStyle(), \"\");\r\n        String selectedDerive = el.getThemeDerive(el.getFlattenedSelectedStyle(), \"\");\r\n        String pressedDerive = el.getThemeDerive(el.getFlattenedPressedStyle(), \"\");\r\n        String disabledDerive = el.getThemeDerive(el.getFlattenedDisabledStyle(), \"\");\r\n        if (derive != null && isModified(derive)) {\r\n            return true;\r\n        }\r\n        if (unselectedDerive != null && isModified(unselectedDerive)) {\r\n            return true;\r\n        }\r\n        if (selectedDerive != null && isModified(selectedDerive)) {\r\n            return true;\r\n        }\r\n        if (pressedDerive != null && isModified(pressedDerive)) {\r\n            return true;\r\n        }\r\n        if (disabledDerive != null && isModified(disabledDerive)) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.getGameAction",
	"Comment": "returns the game action code matching the given key combination",
	"Method": "int getGameAction(int keyCode){\r\n    return impl.getGameAction(keyCode);\r\n}"
}, {
	"Path": "com.codename1.ui.list.FilterProxyListModel.isStartsWithMode",
	"Comment": "when enabled this makes the filter check that the string starts with rather than within the index",
	"Method": "boolean isStartsWithMode(){\r\n    return startsWithMode;\r\n}"
}, {
	"Path": "android.support.v4.view.ViewPager.addFocusables",
	"Comment": "we only want the current page that is being shown to be focusable.",
	"Method": "void addFocusables(ArrayList<View> views,int direction,int focusableMode){\r\n    final int focusableCount = views.size();\r\n    final int descendantFocusability = getDescendantFocusability();\r\n    if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {\r\n        for (int i = 0; i < getChildCount(); i++) {\r\n            final View child = getChildAt(i);\r\n            if (child.getVisibility() == VISIBLE) {\r\n                ItemInfo ii = infoForChild(child);\r\n                if (ii != null && ii.position == mCurItem) {\r\n                    child.addFocusables(views, direction, focusableMode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (descendantFocusability != FOCUS_AFTER_DESCENDANTS || (focusableCount == views.size())) {\r\n        if (!isFocusable()) {\r\n            return;\r\n        }\r\n        if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && isInTouchMode() && !isFocusableInTouchMode()) {\r\n            return;\r\n        }\r\n        if (views != null) {\r\n            views.add(this);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.push.Push.getDeviceKey",
	"Comment": "returns the push device key if the device was previously successfully registered for pushotherwise returns null",
	"Method": "String getDeviceKey(){\r\n    long l = Preferences.get(\"push_id\", (long) -1);\r\n    if (l == -1) {\r\n        return null;\r\n    }\r\n    return \"\" + l;\r\n}"
}, {
	"Path": "com.codename1.ui.Graphics.setColor",
	"Comment": "sets the current rgb color while ignoring any potential alpha component withinsaid color value.",
	"Method": "void setColor(int RGB){\r\n    color = 0xffffff & RGB;\r\n    impl.setColor(nativeGraphics, color);\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.handleRuntimeException",
	"Comment": "handles an exception thrown when performing a network operation",
	"Method": "void handleRuntimeException(RuntimeException err){\r\n    handleException(err);\r\n}"
}, {
	"Path": "com.codename1.util.CStringBuilder.replace",
	"Comment": "replaces the specified subsequence in this builder with the specifiedstring.",
	"Method": "CStringBuilder replace(int start,int end,String str){\r\n    replace0(start, end, str);\r\n    return this;\r\n}"
}, {
	"Path": "android.support.v4.view.accessibility.AccessibilityNodeInfoCompat.getMovementGranularities",
	"Comment": "gets the movement granularities for traversing the text of this node.",
	"Method": "int getMovementGranularities(Object info,int getMovementGranularities,Object info,int getMovementGranularities,Object info,int getMovementGranularities){\r\n    return IMPL.getMovementGranularities(mInfo);\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AbstractQuerySpec.getPredicateList",
	"Comment": "returns a list of predicates not associated with a particular column.",
	"Method": "List<StarPredicate> getPredicateList(){\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudObject.isOwner",
	"Comment": "returns true if this object is owned by me or is world writeable",
	"Method": "boolean isOwner(){\r\n    return owner;\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.registerAsInputDevice",
	"Comment": "registers this textarea as the current input device for the current form.",
	"Method": "void registerAsInputDevice(){\r\n    final TextArea cmp = this;\r\n    Form f = this.getComponentForm();\r\n    if (f != null && Display.impl.getEditingText() != this) {\r\n        try {\r\n            TextAreaInputDevice previousInput = null;\r\n            if (f.getCurrentInputDevice() instanceof TextAreaInputDevice) {\r\n                previousInput = (TextAreaInputDevice) f.getCurrentInputDevice();\r\n                if (previousInput.editedTextArea == this) {\r\n                    previousInput.enabled = false;\r\n                }\r\n            }\r\n            if (previousInput != null) {\r\n                previousInput.deferStopEditingToNativeLayer = true;\r\n            }\r\n            TextAreaInputDevice currInput = new TextAreaInputDevice(this);\r\n            f.setCurrentInputDevice(currInput);\r\n        } catch (Exception ex) {\r\n            Log.e(ex);\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.FollowerStateTest.testFollowerRejectsVoteRequestWithLesserTerm",
	"Comment": "tests that a follower rejects a vote request with a lesser term.",
	"Method": "void testFollowerRejectsVoteRequestWithLesserTerm(){\r\n    runOnServer(() -> {\r\n        serverContext.setTerm(2);\r\n        VoteRequest request = VoteRequest.builder().withTerm(1).withCandidate(members.get(1).hashCode()).withLogIndex(0).withLogTerm(0).build();\r\n        VoteResponse response = state.vote(request).get();\r\n        threadAssertEquals(serverContext.getTerm(), 2L);\r\n        threadAssertEquals(response.term(), 2L);\r\n        threadAssertFalse(response.voted());\r\n    });\r\n}"
}, {
	"Path": "com.codename1.ui.Display.pointerDragged",
	"Comment": "pushes a pointer drag event with the given coordinates into codename one",
	"Method": "void pointerDragged(int[] x,int[] y){\r\n    if (impl.getCurrentForm() == null) {\r\n        return;\r\n    }\r\n    longPointerCharged = false;\r\n    if (x.length == 1) {\r\n        addPointerDragEventWithTimestamp(x[0], y[0]);\r\n    } else {\r\n        addPointerEvent(POINTER_DRAGGED_MULTI, x, y);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.PlatformDefaults.invalidate",
	"Comment": "tells all layout manager instances to revalidate and recalculated everything.",
	"Method": "void invalidate(){\r\n    MOD_COUNT++;\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.createContainer",
	"Comment": "creates the container defined under the given name in the res file",
	"Method": "Container createContainer(String resPath,String resourceName,Container createContainer,Resources res,String resourceName,Container createContainer,Resources res,String resourceName,EmbeddedContainer parentContainer){\r\n    onCreateRoot(resourceName);\r\n    InputStream source = res.getUi(resourceName);\r\n    if (source == null) {\r\n        throw new RuntimeException(\"Resource doesn't exist within the current resource object: \" + resourceName);\r\n    }\r\n    DataInputStream in = new DataInputStream(source);\r\n    try {\r\n        Hashtable h = null;\r\n        if (localComponentListeners != null) {\r\n            h = (Hashtable) localComponentListeners.get(resourceName);\r\n        }\r\n        Container c = (Container) createComponent(in, null, null, res, h, parentContainer);\r\n        c.setName(resourceName);\r\n        postCreateComponents(in, c, res);\r\n        if (homeForm == null) {\r\n            if (c instanceof Form) {\r\n                String nextForm = (String) c.getClientProperty(\"%next_form%\");\r\n                if (nextForm != null) {\r\n                    homeForm = nextForm;\r\n                } else {\r\n                    homeForm = resourceName;\r\n                }\r\n            }\r\n        }\r\n        return c;\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.location.GeofenceManager.asSortedList",
	"Comment": "returns all geofences sorted by distance from the current location.",
	"Method": "List<Geofence> asSortedList(){\r\n    List<Geofence> l = asList();\r\n    Location curr = LocationManager.getLocationManager().getLastKnownLocation();\r\n    if (curr != null) {\r\n        Collections.sort(l, Geofence.createDistanceComparator(curr));\r\n    }\r\n    return l;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLFont.getCounterpartFont",
	"Comment": "returns the counterpart font for this font in the given attribute.this method either creates it or fetches it if it was already set. it handles both system and bitmap fonts.note that a counterpart font can be the font itself if no other suitable font was found.",
	"Method": "HTMLFont getCounterpartFont(int attribute){\r\n    if ((systemFont) && (counterpartFonts[attribute] == null)) {\r\n        switch(attribute) {\r\n            case BOLD:\r\n                counterpartFonts[attribute] = new HTMLFont(null, Font.createSystemFont(font.getFace(), style + Font.STYLE_BOLD, size));\r\n                break;\r\n            case ITALIC:\r\n                counterpartFonts[attribute] = new HTMLFont(null, Font.createSystemFont(font.getFace(), style + Font.STYLE_ITALIC, size));\r\n                break;\r\n            case BIG:\r\n                int counterpartSize = (size == Font.SIZE_SMALL) ? Font.SIZE_MEDIUM : Font.SIZE_LARGE;\r\n                counterpartFonts[attribute] = new HTMLFont(null, Font.createSystemFont(font.getFace(), style, counterpartSize));\r\n                break;\r\n            case SMALL:\r\n                counterpartSize = (size == Font.SIZE_LARGE) ? Font.SIZE_MEDIUM : Font.SIZE_SMALL;\r\n                counterpartFonts[attribute] = new HTMLFont(null, Font.createSystemFont(font.getFace(), style, counterpartSize));\r\n                break;\r\n        }\r\n    }\r\n    return counterpartFonts[attribute];\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayeredLayout.setReferenceComponentBottom",
	"Comment": "sets the reference component for the bottom inset of the given component.",
	"Method": "LayeredLayout setReferenceComponentBottom(Component cmp,Component referenceComponent,LayeredLayout setReferenceComponentBottom,Component cmp,Component referenceComponent,float position){\r\n    getOrCreateConstraint(cmp).bottom().referenceComponent(referenceComponent).referencePosition(position);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.setCommandBehavior",
	"Comment": "indicates the way commands should be added to a form as one of the ocmmand constants definedin this class",
	"Method": "void setCommandBehavior(int commandBehavior){\r\n    if (commandBehavior == Display.COMMAND_BEHAVIOR_SIDE_NAVIGATION) {\r\n        String message = \"WARNING: Display.setCommandBehavior() is deprecated, Using it may result in unexpected behaviour. In particular, using COMMAND_BEHAVIOR_SIDE_NAVIGATION in conjunction with Toolbar.setOnTopSideMenu(true) may result in runtime errors.\";\r\n        Log.p(message, Log.WARNING);\r\n    }\r\n    impl.setCommandBehavior(commandBehavior);\r\n}"
}, {
	"Path": "com.codename1.processing.Result._internalGetAsArray",
	"Comment": "internal function, do not use. this version does not convert thestructured content nodes in the array, so not to be called by end user.",
	"Method": "List _internalGetAsArray(String path){\r\n    final List tokens = new ResultTokenizer(path).tokenize(namespaceAliases);\r\n    if (tokens.isEmpty()) {\r\n        return tokens;\r\n    }\r\n    final StructuredContent obj = apply(root, tokens, 0);\r\n    if (obj == null) {\r\n        return new Vector();\r\n    }\r\n    String key = (String) tokens.get(tokens.size() - 1);\r\n    if ((tokens.size() > 1) && SELECT_GLOB.equals(tokens.get(tokens.size() - 2))) {\r\n        return obj.getDescendants(key);\r\n    }\r\n    if (key.startsWith(\"@\")) {\r\n        key = key.substring(1);\r\n        String v = obj.getAttribute(key);\r\n        List array = new Vector();\r\n        if (v != null) {\r\n            array.add(new MapContent(v, obj));\r\n        }\r\n        return array;\r\n    } else if (key.charAt(0) == Result.ARRAY_END && tokens.size() >= 4) {\r\n        List array = new Vector();\r\n        array.add(obj);\r\n        return array;\r\n    }\r\n    return obj.getChildren(key);\r\n}"
}, {
	"Path": "org.commonmark.internal.ThematicBreakParser.isThematicBreak",
	"Comment": "characters, each followed optionally by any number of spaces, forms a thematic break.",
	"Method": "boolean isThematicBreak(CharSequence line,int index){\r\n    int dashes = 0;\r\n    int underscores = 0;\r\n    int asterisks = 0;\r\n    int length = line.length();\r\n    for (int i = index; i < length; i++) {\r\n        switch(line.charAt(i)) {\r\n            case '-':\r\n                dashes++;\r\n                break;\r\n            case '_':\r\n                underscores++;\r\n                break;\r\n            case '*':\r\n                asterisks++;\r\n                break;\r\n            case ' ':\r\n            case '\\t':\r\n                break;\r\n            default:\r\n                return false;\r\n        }\r\n    }\r\n    return ((dashes >= 3 && underscores == 0 && asterisks == 0) || (underscores >= 3 && dashes == 0 && asterisks == 0) || (asterisks >= 3 && dashes == 0 && underscores == 0));\r\n}"
}, {
	"Path": "com.codename1.ui.Button.isButtonRippleEffectDefault",
	"Comment": "default value for the button ripple effect, this can be set with the theme constant buttonripplebool",
	"Method": "boolean isButtonRippleEffectDefault(){\r\n    return buttonRippleEffectDefault;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.addAll",
	"Comment": "adds the objects in the specified collection to the end of this vector.",
	"Method": "boolean addAll(int location,Collection<? extends E> collection,boolean addAll,Collection<? extends E> collection){\r\n    return addAll(elementCount, collection);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.getDefaultFormTintColor",
	"Comment": "tint color is set when a form is partially covered be it by a menu or by a dialog. a look and feel can override this default value.",
	"Method": "int getDefaultFormTintColor(){\r\n    return defaultFormTintColor;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Stack.peek",
	"Comment": "returns the element at the top of the stack without removing it.",
	"Method": "E peek(){\r\n    try {\r\n        return (E) elementData[elementCount - 1];\r\n    } catch (IndexOutOfBoundsException e) {\r\n        throw new EmptyStackException();\r\n    }\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetTable.initDefaultColors",
	"Comment": "initializes the default set of colors used by the propertysheettable.",
	"Method": "void initDefaultColors(){\r\n    this.categoryBackground = UIManager.getColor(PANEL_BACKGROUND_COLOR_KEY);\r\n    this.categoryForeground = UIManager.getColor(TABLE_FOREGROUND_COLOR_KEY).darker().darker().darker();\r\n    this.selectedCategoryBackground = categoryBackground.darker();\r\n    this.selectedCategoryForeground = categoryForeground;\r\n    this.propertyBackground = UIManager.getColor(TABLE_BACKGROUND_COLOR_KEY);\r\n    this.propertyForeground = UIManager.getColor(TABLE_FOREGROUND_COLOR_KEY);\r\n    this.selectedPropertyBackground = UIManager.getColor(TABLE_SELECTED_BACKGROUND_COLOR_KEY);\r\n    this.selectedPropertyForeground = UIManager.getColor(TABLE_SELECTED_FOREGROUND_COLOR_KEY);\r\n    setGridColor(categoryBackground);\r\n}"
}, {
	"Path": "com.codename1.components.Accordion.getCurrentlyExpanded",
	"Comment": "returns the body component of the currently expanded accordion element or null if none is expanded",
	"Method": "Component getCurrentlyExpanded(){\r\n    for (Component cc : this) {\r\n        AccordionContent c = (AccordionContent) cc;\r\n        if (!c.isClosed()) {\r\n            return c.body;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.conscrypt.ct.CTVerifier.getSCTsFromX509Extension",
	"Comment": "extract a list of signedcertificatetimestamp embedded in an x509 certificate.if the certificate does not contain any sct extension, or the encompassing encoded list failsto be parsed, an empty list is returned. individual scts which fail to be parsed are ignored.",
	"Method": "List<SignedCertificateTimestamp> getSCTsFromX509Extension(OpenSSLX509Certificate leaf){\r\n    byte[] extData = leaf.getExtensionValue(CTConstants.X509_SCT_LIST_OID);\r\n    if (extData == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    try {\r\n        return getSCTsFromSCTList(Serialization.readDEROctetString(Serialization.readDEROctetString(extData)), SignedCertificateTimestamp.Origin.EMBEDDED);\r\n    } catch (SerializationException e) {\r\n        return Collections.emptyList();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.createEtchedRaised",
	"Comment": "creates a lowered etched border with default colors, highlight is derivedfrom the component and shadow is a plain dark color",
	"Method": "Border createEtchedRaised(Border createEtchedRaised,int highlight,int shadow){\r\n    Border b = new Border();\r\n    b.type = TYPE_ETCHED_RAISED;\r\n    b.themeColors = false;\r\n    b.colorA = highlight;\r\n    b.colorB = shadow;\r\n    b.thickness = 2;\r\n    return b;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.CommonTransitions.getMotion",
	"Comment": "motion represents the physical movement within a transition, it canbe replaced by the user to provide a more appropriate physical feel",
	"Method": "Motion getMotion(){\r\n    return motion;\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.setSelectedDaysUIID",
	"Comment": "sets the selecteddays uiid to the given uiid. being considered.",
	"Method": "void setSelectedDaysUIID(String uiid){\r\n    this.selectedDaysUIID = uiid;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.getScrollableParent",
	"Comment": "returns a parent container that is scrollable or null if no parent is scrollable.",
	"Method": "Container getScrollableParent(){\r\n    Container parent = getParent();\r\n    while (parent != null) {\r\n        if (parent.isScrollable()) {\r\n            return parent;\r\n        }\r\n        parent = parent.getParent();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.events.ActionEvent.getY",
	"Comment": "the y position if this is a pointer event otherwise undefined",
	"Method": "int getY(){\r\n    return y;\r\n}"
}, {
	"Path": "com.codename1.ui.events.ActionEvent.getX",
	"Comment": "the x position if this is a pointer event otherwise undefined",
	"Method": "int getX(){\r\n    return keyEvent;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.isObscuredByChildren",
	"Comment": "invoked internally to indicate if child components are hiding this containerthus removing the need to invoke its own paint methods",
	"Method": "boolean isObscuredByChildren(){\r\n    if (!blockOverdraw) {\r\n        return false;\r\n    }\r\n    if (!getLayout().obscuresPotential(this)) {\r\n        return false;\r\n    }\r\n    Style s = getStyle();\r\n    if (s.getPaddingTop() != 0 || s.getPaddingLeftNoRTL() != 0 || s.getPaddingRightNoRTL() != 0 || s.getPaddingBottom() != 0) {\r\n        return false;\r\n    }\r\n    int size = components.size();\r\n    for (int iter = 0; iter < size; iter++) {\r\n        Component cmp = components.get(iter);\r\n        s = cmp.getStyle();\r\n        if (cmp.getWidth() == 0 || cmp.getHeight() == 0) {\r\n            continue;\r\n        }\r\n        if (cmp instanceof Container) {\r\n            if (!((Container) cmp).getLayout().obscuresPotential(this)) {\r\n                return false;\r\n            }\r\n            if (s.getOpacity() != 0xff || s.getMarginTop() != 0 || s.getMarginLeftNoRTL() != 0 || s.getMarginRightNoRTL() != 0 || s.getMarginBottom() != 0) {\r\n                return false;\r\n            }\r\n            if ((s.getBgTransparency() & 0xff) != 0xff && !((Container) cmp).isObscuredByChildren()) {\r\n                return false;\r\n            }\r\n        } else {\r\n            if ((s.getBgTransparency() & 0xff) != 0xff || s.getOpacity() != 0xff || s.getMarginTop() != 0 || s.getMarginLeftNoRTL() != 0 || s.getMarginRightNoRTL() != 0 || s.getMarginBottom() != 0) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "java.lang.Object.getClass",
	"Comment": "returns the runtime class of an object. that class object is the object that is locked by static synchronized methods of the represented class.",
	"Method": "java.lang.Class getClass(){\r\n    return getClassImpl();\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLUtils.convertHTMLCharEntity",
	"Comment": "converts an html char entity to the matching character or string.this is a convenience method that uses convertcharentity with true for lookuphtmlentities and a null userdefinedcharentities",
	"Method": "String convertHTMLCharEntity(String charEntity){\r\n    return convertCharEntity(charEntity, true, null);\r\n}"
}, {
	"Path": "java.util.Arrays.binarySearch",
	"Comment": "performs a binary search for the specified element in a part of thespecified sorted array.",
	"Method": "int binarySearch(byte[] array,byte value,int binarySearch,char[] array,char value,int binarySearch,double[] array,double value,int binarySearch,float[] array,float value,int binarySearch,int[] array,int value,int binarySearch,long[] array,long value,int binarySearch,Object[] array,Object object,int binarySearch,T[] array,T object,Comparator<? super T> comparator,int binarySearch,short[] array,short value,int binarySearch,byte[] array,int startIndex,int endIndex,byte value,int binarySearch,char[] array,int startIndex,int endIndex,char value,int binarySearch,double[] array,int startIndex,int endIndex,double value,int binarySearch,float[] array,int startIndex,int endIndex,float value,int binarySearch,int[] array,int startIndex,int endIndex,int value,int binarySearch,long[] array,int startIndex,int endIndex,long value,int binarySearch,Object[] array,int startIndex,int endIndex,Object object,int binarySearch,T[] array,int startIndex,int endIndex,T object,Comparator<? super T> comparator,int binarySearch,short[] array,int startIndex,int endIndex,short value){\r\n    checkIndexForBinarySearch(array.length, startIndex, endIndex);\r\n    int low = startIndex, mid = -1, high = endIndex - 1;\r\n    while (low <= high) {\r\n        mid = (low + high) >>> 1;\r\n        if (value > array[mid]) {\r\n            low = mid + 1;\r\n        } else if (value == array[mid]) {\r\n            return mid;\r\n        } else {\r\n            high = mid - 1;\r\n        }\r\n    }\r\n    if (mid < 0) {\r\n        int insertPoint = endIndex;\r\n        for (int index = startIndex; index < endIndex; index++) {\r\n            if (value < array[index]) {\r\n                insertPoint = index;\r\n            }\r\n        }\r\n        return -insertPoint - 1;\r\n    }\r\n    return -mid - (value < array[mid] ? 1 : 2);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getNativeOverlay",
	"Comment": "gets the native overlay for this component.may be null. native overlays are used in the javascriptport to assist with user interaction on touch devices.text fields use native overlays to positionan invisible native text field above themselves so that the keyboard will be activated properly whenthe user taps the text field.",
	"Method": "Object getNativeOverlay(){\r\n    return nativeOverlay;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.getOrderedListType",
	"Comment": "figures out the appropriate list type for the given list type identifier",
	"Method": "int getOrderedListType(HTMLElement element,int getOrderedListType,HTMLElement element,int defaultListType,int getOrderedListType,char c,int defaultListType){\r\n    for (int j = 0; j < ORDERED_LIST_TYPE_IDENTIFIERS.length; j++) {\r\n        if (c == ORDERED_LIST_TYPE_IDENTIFIERS[j]) {\r\n            return j;\r\n        }\r\n    }\r\n    return defaultListType;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isBuiltinSoundAvailable",
	"Comment": "indicates whether a user installed or system sound is available",
	"Method": "boolean isBuiltinSoundAvailable(String soundIdentifier){\r\n    return impl.isBuiltinSoundAvailable(soundIdentifier);\r\n}"
}, {
	"Path": "io.atomix.copycat.client.session.ClientSessionState.getEventIndex",
	"Comment": "returns the highest index for which an event has been received in sequence.",
	"Method": "long getEventIndex(){\r\n    return eventIndex;\r\n}"
}, {
	"Path": "io.atomix.copycat.client.session.ClientSequencerTest.testSequenceMissingEvent",
	"Comment": "tests sequencing responses with a missing publishrequest.",
	"Method": "void testSequenceMissingEvent(){\r\n    ClientSessionState state = new ClientSessionState(UUID.randomUUID().toString());\r\n    state.setSessionId(1).setCommandRequest(2).setResponseIndex(15).setEventIndex(5);\r\n    AtomicInteger run = new AtomicInteger();\r\n    ClientSequencer sequencer = new ClientSequencer(state);\r\n    sequencer.requestSequence = 2;\r\n    sequencer.responseSequence = 1;\r\n    sequencer.eventIndex = 5;\r\n    CommandResponse commandResponse = CommandResponse.builder().withStatus(Response.Status.OK).withIndex(20).withEventIndex(10).build();\r\n    sequencer.sequenceResponse(2, commandResponse, () -> assertEquals(run.getAndIncrement(), 0));\r\n    PublishRequest publishRequest = PublishRequest.builder().withSession(1).withEventIndex(25).withPreviousIndex(5).build();\r\n    sequencer.sequenceEvent(publishRequest, () -> assertEquals(run.getAndIncrement(), 1));\r\n    assertEquals(run.get(), 2);\r\n}"
}, {
	"Path": "com.codename1.payments.v3.IabHelper.getResponseCodeFromBundle",
	"Comment": "workaround to bug where sometimes response codes come as long instead of integer",
	"Method": "int getResponseCodeFromBundle(Bundle b){\r\n    Object o = b.get(RESPONSE_CODE);\r\n    if (o == null) {\r\n        logDebug(\"Bundle with null response code, assuming OK (known issue)\");\r\n        return BILLING_RESPONSE_RESULT_OK;\r\n    } else if (o instanceof Integer)\r\n        return ((Integer) o).intValue();\r\n    else if (o instanceof Long)\r\n        return (int) ((Long) o).longValue();\r\n    else {\r\n        logError(\"Unexpected type for bundle response code.\");\r\n        logError(o.getClass().getName());\r\n        throw new RuntimeException(\"Unexpected type for bundle response code: \" + o.getClass().getName());\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.parseComponentCustomStyle",
	"Comment": "returns the selected style of the component with the given basestyle or a new instance of the defaultstyle, but overrides styles based on the directives in the stylestrings.this method will always return a new style instance to prevent modification of the globalstyle object.",
	"Method": "Style parseComponentCustomStyle(Resources theme,String baseStyle,String id,String type,String styleString){\r\n    return parseStyle(theme, id, type + \"#\", baseStyle, false, styleString);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isNativeShareSupported",
	"Comment": "indicates if the underlying platform supports sharing capabilities",
	"Method": "boolean isNativeShareSupported(){\r\n    return impl.isNativeShareSupported();\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.$",
	"Comment": "creates a new componentselector with the components matched by the provided selector.the current formis used as the root for searches.will throw a runtime exception if there is no current form.",
	"Method": "ComponentSelector $(Component cmps,ComponentSelector $,ActionEvent e,ComponentSelector $,Runnable r,ComponentSelector $,Set<Component> cmps,ComponentSelector $,String selector,ComponentSelector $,String selector,Component roots,ComponentSelector $,String selector,Collection<Component> roots){\r\n    return new ComponentSelector(selector, roots);\r\n}"
}, {
	"Path": "com.codename1.io.CacheMap.setCachePrefix",
	"Comment": "a prefix prepended to storage entries to differentiate them",
	"Method": "void setCachePrefix(String cachePrefix){\r\n    this.cachePrefix = cachePrefix;\r\n}"
}, {
	"Path": "com.codename1.messaging.Message.setCloudMessageFailSilently",
	"Comment": "indicates whether the cloud message should produce an error dialog if sending failed",
	"Method": "void setCloudMessageFailSilently(boolean cloudMessageFailSilently){\r\n    this.cloudMessageFailSilently = cloudMessageFailSilently;\r\n}"
}, {
	"Path": "android.support.v4.view.accessibility.AccessibilityRecordCompat.getText",
	"Comment": "gets the text of the event. the index in the list represents the priorityof the text. specifically, the lower the index the higher the priority.",
	"Method": "List<CharSequence> getText(Object record,List<CharSequence> getText,Object record,List<CharSequence> getText,Object record,List<CharSequence> getText){\r\n    return IMPL.getText(mRecord);\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudStorage.refresh",
	"Comment": "refresh the given objects with data from the server if they were modified on the server.this operation executes immeditely without waiting for commit.",
	"Method": "void refresh(CloudObject[] objects,CloudResponse<Integer> response,int refresh,CloudObject[] objects){\r\n    return refreshImpl(objects, null);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.convertToPixels",
	"Comment": "converts the dips count to pixels, dips are roughly 1mm in length. this is a very rough estimate and notto be relied upon. this version of the method assumes square pixels which is pretty much the norm.",
	"Method": "int convertToPixels(int dipCount,boolean horizontal,int convertToPixels,float dipCount){\r\n    return Math.round(impl.convertToPixels((int) (dipCount * 1000), true) / 1000.0f);\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.setCustomUserData",
	"Comment": "sets custom properties.in custom properties you can provide any string key values to be stored with user",
	"Method": "Countly setCustomUserData(Map<String, String> customdata){\r\n    if (Countly.sharedInstance().isLoggingEnabled()) {\r\n        Log.d(Countly.TAG, \"Setting custom user data\");\r\n    }\r\n    if (customdata != null)\r\n        UserData.setCustomData(customdata);\r\n    connectionQueue_.sendUserData();\r\n    UserData.clear();\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundBorder.getUIID",
	"Comment": "true is we use the background of the component setting to draw",
	"Method": "boolean getUIID(){\r\n    return uiid;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.removeEdtErrorHandler",
	"Comment": "an error handler will receive an action event with the source exception from the edtonce an error handler is installed the default codename one error dialog will no longer appear",
	"Method": "void removeEdtErrorHandler(ActionListener e){\r\n    Display.INSTANCE.removeEdtErrorHandler(e);\r\n}"
}, {
	"Path": "com.codename1.social.FacebookConnect.hasPublishPermissions",
	"Comment": "returns true if the current session already has publish permissions",
	"Method": "boolean hasPublishPermissions(){\r\n    throw new RuntimeException(\"Native facebook unsupported\");\r\n}"
}, {
	"Path": "com.codename1.components.InfiniteScrollAdapter.getInfiniteProgress",
	"Comment": "lets us manipulate the infinite progress object e.g. set the animation image etc.",
	"Method": "InfiniteProgress getInfiniteProgress(){\r\n    return progress;\r\n}"
}, {
	"Path": "com.codename1.components.SplitPane.changeInsets",
	"Comment": "changes the minimum, preferred, and maximum insets of the split pane.this will alsoupdate the current divider position to the supplied preferred inset.",
	"Method": "void changeInsets(String minInset,String preferredInset,String maxInset){\r\n    LayeredLayout l = (LayeredLayout) getLayout();\r\n    initDividerInset(l.createConstraint(), preferredInset).copyTo(this.preferredInset);\r\n    initDividerInset(l.createConstraint(), minInset).copyTo(this.minInset);\r\n    initDividerInset(l.createConstraint(), maxInset).copyTo(this.maxInset);\r\n    l.setInsets(this.topOrLeft, \"0 0 0 0\").setInsets(this.topOrLeft, \"0 0 0 0\");\r\n    this.preferredInset.copyTo(l.getOrCreateConstraint(divider));\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.get",
	"Comment": "returns the element at the specified location in this vector.",
	"Method": "E get(int location){\r\n    return elementAt(location);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.numColors",
	"Comment": "returns the number of colors applicable on the device, note that the apidoes not support gray scale devices.",
	"Method": "int numColors(){\r\n    return impl.numColors();\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.getAlbumPhotos",
	"Comment": "this method returns a list model of photos that automatically fetches additional images as necessary",
	"Method": "void getAlbumPhotos(String albumId,DefaultListModel photos,int offset,int limit,ActionListener callback,ListModel getAlbumPhotos,Component targetList,String albumId,int photoCount,Image placeholder){\r\n    if (!isAuthenticated()) {\r\n        return null;\r\n    }\r\n    Hashtable[] h = new Hashtable[photoCount];\r\n    int hlen = h.length;\r\n    for (int iter = 0; iter < hlen; iter++) {\r\n        h[iter] = new Hashtable();\r\n        h[iter].put(\"photo\", placeholder);\r\n        if (iter < 30) {\r\n            h[iter].put(\"fetching\", Boolean.TRUE);\r\n        }\r\n    }\r\n    DefaultListModel dl = new DefaultListModel((Object[]) h) {\r\n        public Object getItem(int offset) {\r\n            Hashtable hash = (Hashtable) super.getItemAt(offset);\r\n            if (!hash.containsKey(\"fetching\")) {\r\n                int limit = Math.min(30, photoCount - offset);\r\n                for (int iter = 0; iter < limit; iter++) {\r\n                    Hashtable current = (Hashtable) super.getItemAt(iter + offset);\r\n                    if (current.containsKey(\"fetching\")) {\r\n                        break;\r\n                    }\r\n                    current.put(\"fetching\", Boolean.TRUE);\r\n                }\r\n                FacebookRESTService con = new FacebookRESTService(token, albumId, FacebookRESTService.PHOTOS, false);\r\n                con.setResponseDestination(this);\r\n                con.setResponseOffset(0);\r\n                con.addArgument(\"limit\", \"\" + limit);\r\n                con.addArgument(\"offset\", \"\" + offset);\r\n                for (int i = 0; i < responseCodeListeners.size(); i++) {\r\n                    con.addResponseCodeListener((ActionListener) responseCodeListeners.elementAt(i));\r\n                }\r\n                NetworkManager.getInstance().addToQueueAndWait(con);\r\n                for (int iter = 0; iter < limit; iter++) {\r\n                    Hashtable current = (Hashtable) getItemAt(iter + offset);\r\n                    ImageDownloadService.createImageToStorage((String) current.get(\"photo\"), targetList, iter + offset, \"photo\", ((String) current.get(\"id\")) + placeholder.getHeight(), placeholder, ConnectionRequest.PRIORITY_NORMAL);\r\n                }\r\n            }\r\n            return hash;\r\n        }\r\n    };\r\n    FacebookRESTService con = new FacebookRESTService(token, albumId, FacebookRESTService.PHOTOS, false);\r\n    con.setResponseDestination(dl);\r\n    con.setResponseOffset(0);\r\n    con.addArgument(\"limit\", \"30\");\r\n    con.addArgument(\"offset\", \"0\");\r\n    for (int i = 0; i < responseCodeListeners.size(); i++) {\r\n        con.addResponseCodeListener((ActionListener) responseCodeListeners.elementAt(i));\r\n    }\r\n    NetworkManager.getInstance().addToQueueAndWait(con);\r\n    for (int iter = 0; iter < Math.min(30, photoCount); iter++) {\r\n        Hashtable hash = (Hashtable) dl.getItemAt(iter);\r\n        ImageDownloadService.createImageToStorage((String) hash.get(\"photo\"), targetList, iter, \"photo\", ((String) hash.get(\"id\")) + placeholder.getHeight(), placeholder, ConnectionRequest.PRIORITY_NORMAL);\r\n    }\r\n    return dl;\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.getAlbumPhotos",
	"Comment": "this method returns a list model of photos that automatically fetches additional images as necessary",
	"Method": "void getAlbumPhotos(String albumId,DefaultListModel photos,int offset,int limit,ActionListener callback,ListModel getAlbumPhotos,Component targetList,String albumId,int photoCount,Image placeholder){\r\n    Hashtable hash = (Hashtable) super.getItemAt(offset);\r\n    if (!hash.containsKey(\"fetching\")) {\r\n        int limit = Math.min(30, photoCount - offset);\r\n        for (int iter = 0; iter < limit; iter++) {\r\n            Hashtable current = (Hashtable) super.getItemAt(iter + offset);\r\n            if (current.containsKey(\"fetching\")) {\r\n                break;\r\n            }\r\n            current.put(\"fetching\", Boolean.TRUE);\r\n        }\r\n        FacebookRESTService con = new FacebookRESTService(token, albumId, FacebookRESTService.PHOTOS, false);\r\n        con.setResponseDestination(this);\r\n        con.setResponseOffset(0);\r\n        con.addArgument(\"limit\", \"\" + limit);\r\n        con.addArgument(\"offset\", \"\" + offset);\r\n        for (int i = 0; i < responseCodeListeners.size(); i++) {\r\n            con.addResponseCodeListener((ActionListener) responseCodeListeners.elementAt(i));\r\n        }\r\n        NetworkManager.getInstance().addToQueueAndWait(con);\r\n        for (int iter = 0; iter < limit; iter++) {\r\n            Hashtable current = (Hashtable) getItemAt(iter + offset);\r\n            ImageDownloadService.createImageToStorage((String) current.get(\"photo\"), targetList, iter + offset, \"photo\", ((String) current.get(\"id\")) + placeholder.getHeight(), placeholder, ConnectionRequest.PRIORITY_NORMAL);\r\n        }\r\n    }\r\n    return hash;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.setInputFormat",
	"Comment": "sets input format validation for a textarea or textfieldthis is called from the cssengine, and since it is done after the textarea has been added it is a bit more complicated",
	"Method": "TextArea setInputFormat(TextArea inputField,String inputFormat){\r\n    TextArea returnInputField = inputField;\r\n    if (SUPPORT_INPUT_FORMAT) {\r\n        HTMLForm form = (HTMLForm) textfieldsToForms.get(inputField);\r\n        if (form != null) {\r\n            HTMLInputFormat format = HTMLInputFormat.getInputFormat(inputFormat);\r\n            if (format != null) {\r\n                form.setInputFormat(inputField, format);\r\n                final TextArea newInputField = format.applyConstraints(inputField);\r\n                returnInputField = newInputField;\r\n                if (Display.getInstance().getCurrent() != inputField.getComponentForm()) {\r\n                    inputField.getParent().replace(inputField, newInputField, null);\r\n                } else {\r\n                    Display.getInstance().callSerially(new Runnable() {\r\n                        public void run() {\r\n                            inputField.getParent().replace(inputField, newInputField, null);\r\n                        }\r\n                    });\r\n                }\r\n                if (firstFocusable == inputField) {\r\n                    firstFocusable = newInputField;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return returnInputField;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.setInputFormat",
	"Comment": "sets input format validation for a textarea or textfieldthis is called from the cssengine, and since it is done after the textarea has been added it is a bit more complicated",
	"Method": "TextArea setInputFormat(TextArea inputField,String inputFormat){\r\n    inputField.getParent().replace(inputField, newInputField, null);\r\n}"
}, {
	"Path": "mondrian.olap.Util.addDatabaseTime",
	"Comment": "adds to the cumulative amount of time spent accessing the database.",
	"Method": "void addDatabaseTime(long millis){\r\n    databaseMillis += millis;\r\n}"
}, {
	"Path": "com.codename1.io.gzip.ZStream.end",
	"Comment": "those methods are expected to be override by inflater and deflater.in the future, they will become abstract methods.",
	"Method": "int end(){\r\n    return Z_OK;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.animateLayoutAndWait",
	"Comment": "animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation. this methodwaits until the operation is completed before returning",
	"Method": "void animateLayoutAndWait(int duration){\r\n    animateLayout(duration, true, 255, true);\r\n}"
}, {
	"Path": "org.conscrypt.java.security.TestKeyStore.issuer",
	"Comment": "return the issuing ca certificate of the givencertificate. throws illegalstateexception if there are are moreor less than one.",
	"Method": "Certificate issuer(KeyStore keyStore,Certificate c){\r\n    if (!(c instanceof X509Certificate)) {\r\n        throw new IllegalStateException(\"issuer requires an X509Certificate, found \" + c);\r\n    }\r\n    X509Certificate cert = (X509Certificate) c;\r\n    Certificate found = null;\r\n    for (String alias : Collections.list(keyStore.aliases())) {\r\n        if (!keyStore.entryInstanceOf(alias, TrustedCertificateEntry.class)) {\r\n            continue;\r\n        }\r\n        TrustedCertificateEntry certificateEntry = (TrustedCertificateEntry) keyStore.getEntry(alias, null);\r\n        Certificate certificate = certificateEntry.getTrustedCertificate();\r\n        if (!(certificate instanceof X509Certificate)) {\r\n            continue;\r\n        }\r\n        X509Certificate x = (X509Certificate) certificate;\r\n        if (!cert.getIssuerDN().equals(x.getSubjectDN())) {\r\n            continue;\r\n        }\r\n        if (found != null) {\r\n            throw new IllegalStateException(\"KeyStore has more than one issuing CA for \" + cert + \"\\nfirst: \" + found + \"\\nsecond: \" + certificate);\r\n        }\r\n        found = certificate;\r\n    }\r\n    if (found == null) {\r\n        throw new IllegalStateException(\"KeyStore contained no issuing CA for \" + cert);\r\n    }\r\n    return found;\r\n}"
}, {
	"Path": "com.codename1.javascript.JSObject.call",
	"Comment": "calls a method on the underlying javascript object synchronously with no arguments.",
	"Method": "Object call(String key,Object[] params,Object call,String key,Object call,Object params){\r\n    JSObject window = (JSObject) context.get(\"window\");\r\n    return context.call(this, window, params);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.getHorizAlign",
	"Comment": "converts a textual horizontal alignment description to a codename one alignment constant",
	"Method": "int getHorizAlign(String alignment,int defaultAlign,boolean allowJustify){\r\n    if (alignment != null) {\r\n        if (alignment.equals(\"left\")) {\r\n            return Component.LEFT;\r\n        } else if (alignment.equals(\"right\")) {\r\n            return Component.RIGHT;\r\n        } else if ((alignment.equals(\"center\")) || (alignment.equals(\"middle\"))) {\r\n            return Component.CENTER;\r\n        } else if (alignment.equals(\"justify\")) {\r\n            return ((allowJustify) && (FIXED_WIDTH)) ? JUSTIFY : Component.CENTER;\r\n        }\r\n    }\r\n    return defaultAlign;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Timeline.getDuration",
	"Comment": "returns the duration of the entire timeline in milliseconds",
	"Method": "int getDuration(){\r\n    return duration;\r\n}"
}, {
	"Path": "com.codename1.ui.table.TableLayout.isTruncateHorizontally",
	"Comment": "indicates whether the table should be truncated if it do not have enough available horizontal space to display all its content. if not, will shrink",
	"Method": "boolean isTruncateHorizontally(){\r\n    return truncateHorizontally;\r\n}"
}, {
	"Path": "com.codename1.ui.BrowserComponent.createJSProxy",
	"Comment": "creates a proxy for a javascript object that makes it easier to call methods, retrieve,and manipulate properties on the object.",
	"Method": "JSProxy createJSProxy(String javascriptExpression){\r\n    return new JSProxy(javascriptExpression);\r\n}"
}, {
	"Path": "android.support.v4.util.SparseArrayCompat.delete",
	"Comment": "removes the mapping from the specified key, if there was any.",
	"Method": "void delete(int key){\r\n    int i = binarySearch(mKeys, 0, mSize, key);\r\n    if (i >= 0) {\r\n        if (mValues[i] != DELETED) {\r\n            mValues[i] = DELETED;\r\n            mGarbage = true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.xml.Element.hasTextChild",
	"Comment": "determines whether or not this element has any text children.",
	"Method": "boolean hasTextChild(){\r\n    if (children != null) {\r\n        for (int iter = 0; iter < children.size(); iter++) {\r\n            Object child = children.get(iter);\r\n            if (child instanceof Element && ((Element) child).isTextElement()) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetPanel.readFromObject",
	"Comment": "initializes the propertysheet from the given object. if any, it cancelspending edit before proceeding with properties.",
	"Method": "void readFromObject(Object data){\r\n    try {\r\n        getTable().cancelEditing();\r\n        setBeanInfo(Introspector.getBeanInfo(data.getClass()));\r\n        Property[] properties = model.getProperties();\r\n        for (int i = 0, c = properties.length; i < c; i++) {\r\n            properties[i].readFromObject(data);\r\n        }\r\n        repaint();\r\n    } catch (IntrospectionException ex) {\r\n        ex.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLForm.addInput",
	"Comment": "adds an input field to the form, note that unlike adding to a codename one form here the components are added logically only to query them for their value on submit.",
	"Method": "void addInput(String key,Object input,String defaultValue){\r\n    if (defaultValue != null) {\r\n        defaultValues.put(input, defaultValue);\r\n    }\r\n    if (key == null) {\r\n        return;\r\n    }\r\n    comps.put(key, input);\r\n    if ((htmlC.getHTMLCallback() != null) && (input instanceof TextArea)) {\r\n        String autoVal = htmlC.getHTMLCallback().getAutoComplete(htmlC, action, key);\r\n        if (autoVal != null) {\r\n            ((TextArea) input).setText(autoVal);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.events.ActionEvent.getEventType",
	"Comment": "returns the type of the given event allowing us to have more generic event handling code and usefulfor debugging",
	"Method": "Type getEventType(){\r\n    return (trigger);\r\n}"
}, {
	"Path": "com.codename1.impl.ios.IOSImplementation.capturePhoto",
	"Comment": "captures a photo and notifies with the image data when available",
	"Method": "void capturePhoto(ActionListener response){\r\n    if (!nativeInstance.checkCameraUsage()) {\r\n        throw new RuntimeException(\"Please add the ios.NSCameraUsageDescription build hint\");\r\n    }\r\n    gallerySelectMultiple = false;\r\n    captureCallback = new EventDispatcher();\r\n    captureCallback.addListener(response);\r\n    nativeInstance.captureCamera(false);\r\n    dropEvents = true;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.util.ThumbnailatorUtils.isSupportedOutputFormatType",
	"Comment": "returns whether a specified format type is supported for a specified\toutput format.",
	"Method": "boolean isSupportedOutputFormatType(String format,String type){\r\n    if (!isSupportedOutputFormat(format)) {\r\n        return false;\r\n    }\r\n    if (format == ThumbnailParameter.ORIGINAL_FORMAT && type == ThumbnailParameter.DEFAULT_FORMAT_TYPE) {\r\n        return true;\r\n    } else if (format == ThumbnailParameter.ORIGINAL_FORMAT && type != ThumbnailParameter.DEFAULT_FORMAT_TYPE) {\r\n        return false;\r\n    } else if (type == ThumbnailParameter.DEFAULT_FORMAT_TYPE) {\r\n        return true;\r\n    }\r\n    for (String supportedType : getSupportedOutputFormatTypes(format)) {\r\n        if (supportedType.equals(type)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.table.TableLayout.isGrowHorizontally",
	"Comment": "indicates whether the table layout should grow horizontally to take up available space by stretching the last column",
	"Method": "boolean isGrowHorizontally(){\r\n    return growHorizontally;\r\n}"
}, {
	"Path": "com.codename1.ui.Toolbar.getSideMenuCommands",
	"Comment": "returns the commands within the left side menu which can be useful forthings like unit testing. notice that you should not mutate the commandsor the iteratable set in any way!",
	"Method": "Iterable<Command> getSideMenuCommands(){\r\n    ArrayList<Command> cmds = new ArrayList<Command>();\r\n    if (permanentSideMenu || onTopSideMenu) {\r\n        if (permanentSideMenuContainer != null) {\r\n            findAllCommands(permanentSideMenuContainer, cmds);\r\n        }\r\n        return cmds;\r\n    }\r\n    Form f = getComponentForm();\r\n    int commands = f.getCommandCount();\r\n    for (int iter = 0; iter < commands; iter++) {\r\n        cmds.add(f.getCommand(iter));\r\n    }\r\n    return cmds;\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testResize",
	"Comment": "tests joining and leaving the cluster, resizing the quorum.",
	"Method": "void testResize(){\r\n    CopycatServer server = createServers(1).get(0);\r\n    CopycatServer joiner = createServer(nextMember(Member.Type.ACTIVE));\r\n    joiner.join(members.stream().map(Member::serverAddress).collect(Collectors.toList())).thenRun(this::resume);\r\n    await(10000);\r\n    server.leave().thenRun(this::resume);\r\n    await(10000);\r\n    joiner.leave().thenRun(this::resume);\r\n}"
}, {
	"Path": "com.codename1.ui.FontImage.rotateAnimation",
	"Comment": "creates a copy of this image that rotates itself in an animation",
	"Method": "FontImage rotateAnimation(){\r\n    FontImage newImage = (FontImage) rotate(0);\r\n    newImage.rotationMotion = Motion.createLinearMotion(0, 360, 1500);\r\n    newImage.rotationMotion.start();\r\n    return newImage;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.CommonTransitions.isDefaultLinearMotion",
	"Comment": "indicates whether the motion associated with these transitions by default is linear or spline motion",
	"Method": "boolean isDefaultLinearMotion(){\r\n    return defaultLinearMotion;\r\n}"
}, {
	"Path": "android.support.v4.view.ViewCompat.getLabelFor",
	"Comment": "gets the id of a view for which a given view serves as a label foraccessibility purposes.",
	"Method": "int getLabelFor(View view,int getLabelFor,View view,int getLabelFor,View view,int getLabelFor,View view){\r\n    return IMPL.getLabelFor(view);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.LinkHandler.clearWeakReferencesNow",
	"Comment": "this method clear any weak references right away instead of waiting for the gc. this might be advantageous\tif lots of layout are created and disposed of quickly to keep memory consumption down.",
	"Method": "void clearWeakReferencesNow(){\r\n    LAYOUTS.clear();\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isAlphaMutableImageSupported",
	"Comment": "indicates whether mutable images respect alpha values when constructed",
	"Method": "boolean isAlphaMutableImageSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.xml.XMLParser.setCaseSensitive",
	"Comment": "sets the parser to be case sensitive and retain case, otherwise it will convert all data to lower case",
	"Method": "void setCaseSensitive(boolean caseSensitive){\r\n    this.caseSensitive = caseSensitive;\r\n}"
}, {
	"Path": "com.codename1.charts.views.XYChart.drawXTextLabels",
	"Comment": "the graphical representation of the text labels on the x axis.",
	"Method": "void drawXTextLabels(Double[] xTextLabelLocations,Canvas canvas,Paint paint,boolean showLabels,int left,int top,int bottom,double xPixelsPerUnit,double minX,double maxX){\r\n    boolean showCustomTextGridX = mRenderer.isShowCustomTextGridX();\r\n    boolean showTickMarks = mRenderer.isShowTickMarks();\r\n    if (showLabels) {\r\n        paint.setColor(mRenderer.getXLabelsColor());\r\n        for (Double location : xTextLabelLocations) {\r\n            if (minX <= location && location <= maxX) {\r\n                float xLabel = (float) (left + xPixelsPerUnit * (location.doubleValue() - minX));\r\n                paint.setColor(mRenderer.getXLabelsColor());\r\n                if (showTickMarks) {\r\n                    canvas.drawLine(xLabel, bottom, xLabel, bottom + mRenderer.getLabelsTextSize() / 3, paint);\r\n                }\r\n                drawText(canvas, mRenderer.getXTextLabel(location), xLabel, bottom + mRenderer.getLabelsTextSize() * 4 / 3 + mRenderer.getXLabelsPadding(), paint, mRenderer.getXLabelsAngle());\r\n                if (showCustomTextGridX) {\r\n                    paint.setColor(mRenderer.getGridColor(0));\r\n                    canvas.drawLine(xLabel, bottom, xLabel, top, paint);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.social.Login.createOauth2",
	"Comment": "creates the oauth2 to be used to login in case no native login is available for this service.",
	"Method": "Oauth2 createOauth2(){\r\n    Oauth2 auth = new Oauth2(oauth2URL, clientId, redirectURI, scope);\r\n    return auth;\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetPanel.setRestoreToggleStates",
	"Comment": "set wether or not toggle states are restored when new properties areapplied.",
	"Method": "void setRestoreToggleStates(boolean value){\r\n    model.setRestoreToggleStates(value);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setInlineDisabledStyles",
	"Comment": "registers inline styles that should be applied to the disabled state of the component.",
	"Method": "void setInlineDisabledStyles(String styles){\r\n    if (styles != null && styles.trim().length() == 0) {\r\n        styles = null;\r\n    }\r\n    if (styles == null ? inlineDisabledStyles != null : !styles.equals(inlineDisabledStyles)) {\r\n        this.inlineDisabledStyles = styles;\r\n        unSelectedStyle = null;\r\n        selectedStyle = null;\r\n        disabledStyle = null;\r\n        pressedStyle = null;\r\n        allStyles = null;\r\n        if (!sizeRequestedByUser) {\r\n            preferredSize = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.setCurrentDate",
	"Comment": "sets the calendar view on the given date, only the the month and year arebeing considered.",
	"Method": "void setCurrentDate(Date d){\r\n    mv.setCurrentDay(d.getTime(), true);\r\n    componentChanged();\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.addActionListener",
	"Comment": "adds action listener to applicable components in found set.currently this will apply to buttons, lists, sliders, textareas, onoffswitches, spanbuttons, and subclasses thereof.",
	"Method": "ComponentSelector addActionListener(ActionListener l){\r\n    for (Component c : this) {\r\n        if (c instanceof Button) {\r\n            ((Button) c).addActionListener(l);\r\n        } else if (c instanceof com.codename1.ui.List) {\r\n            ((com.codename1.ui.List) c).addActionListener(l);\r\n        } else if (c instanceof Slider) {\r\n            ((Slider) c).addActionListener(l);\r\n        } else if (c instanceof TextArea) {\r\n            ((TextArea) c).addActionListener(l);\r\n        } else if (c instanceof OnOffSwitch) {\r\n            ((OnOffSwitch) c).addActionListener(l);\r\n        } else if (c instanceof SpanButton) {\r\n            ((SpanButton) c).addActionListener(l);\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.isDefaultDisposeWhenPointerOutOfBounds",
	"Comment": "the default pointer out of bounds dispose behavior, notice thatthis only applies to dialogs and not popup dialogs where this isalways true by default",
	"Method": "boolean isDefaultDisposeWhenPointerOutOfBounds(){\r\n    return defaultDisposeWhenPointerOutOfBounds;\r\n}"
}, {
	"Path": "com.codename1.ui.InfiniteContainer.getInfiniteProgress",
	"Comment": "lets us manipulate the infinite progress object e.g. set the animation image etc.",
	"Method": "InfiniteProgress getInfiniteProgress(){\r\n    return adapter.getInfiniteProgress();\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.util.exif.IfdStructure.getCount",
	"Comment": "returns the count element in the ifd structure, indicating the number\tof values the value field..",
	"Method": "int getCount(){\r\n    return count;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isSimulator",
	"Comment": "allows detecting development mode so debugging code and special cases can be used to simplify flow",
	"Method": "boolean isSimulator(){\r\n    return impl.isSimulator();\r\n}"
}, {
	"Path": "com.codename1.media.MediaManager.createMediaRecorder",
	"Comment": "creates a media recorder object which will record from the device mic toa file in the given path.",
	"Method": "Media createMediaRecorder(String path,Media createMediaRecorder,String path,String mimeType){\r\n    boolean supportedMime = false;\r\n    String[] supported = getAvailableRecordingMimeTypes();\r\n    int slen = supported.length;\r\n    for (int i = 0; i < slen; i++) {\r\n        String mime = supported[i];\r\n        if (mime.equals(mimeType)) {\r\n            supportedMime = true;\r\n            break;\r\n        }\r\n    }\r\n    if (!supportedMime) {\r\n        throw new IllegalArgumentException(\"Mime type \" + mimeType + \" is not supported on this platform use \" + \"getAvailableRecordingMimeTypes()\");\r\n    }\r\n    return Display.getInstance().createMediaRecorder(path, mimeType);\r\n}"
}, {
	"Path": "android.support.v4.view.ViewCompat.getImportantForAccessibility",
	"Comment": "gets the mode for determining whether this view is important for accessibilitywhich is if it fires accessibility events and if it is reported toaccessibility services that query the screen.",
	"Method": "int getImportantForAccessibility(View view,int getImportantForAccessibility,View view,int getImportantForAccessibility,View view,int getImportantForAccessibility,View view){\r\n    return IMPL.getImportantForAccessibility(view);\r\n}"
}, {
	"Path": "com.codename1.impl.android.IntentIntegrator.shareText",
	"Comment": "shares the given text by encoding it as a barcode, such that another usercan scan the text off the screen of the device.",
	"Method": "boolean shareText(CharSequence text,boolean shareText,CharSequence text,CharSequence type){\r\n    Intent intent = new Intent();\r\n    intent.addCategory(Intent.CATEGORY_DEFAULT);\r\n    intent.setAction(BS_PACKAGE + \".ENCODE\");\r\n    intent.putExtra(\"ENCODE_TYPE\", type);\r\n    intent.putExtra(\"ENCODE_DATA\", text);\r\n    String targetAppPackage = findTargetAppPackage(intent);\r\n    if (targetAppPackage == null) {\r\n        showDownloadDialog();\r\n        return false;\r\n    }\r\n    intent.setPackage(targetAppPackage);\r\n    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\r\n    intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_WHEN_TASK_RESET);\r\n    attachMoreExtras(intent);\r\n    activity.startActivity(intent);\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.browserExecute",
	"Comment": "executes the given javascript string within the current context",
	"Method": "void browserExecute(PeerComponent browserPeer,String javaScript){\r\n    setBrowserURL(browserPeer, \"javascript:(function(){\" + javaScript + \"})()\");\r\n}"
}, {
	"Path": "com.codename1.charts.renderers.DefaultRenderer.setScale",
	"Comment": "sets the value to be used for scaling the chart. it works on some chartslike pie, doughnut, dial.",
	"Method": "void setScale(float scale){\r\n    mScale = scale;\r\n}"
}, {
	"Path": "java.lang.Character.equals",
	"Comment": "compares this object against the specified object. the result is true if and only if the argument is not null and is a character object that represents the same char value as this object.",
	"Method": "boolean equals(java.lang.Object obj){\r\n    return obj != null && obj.getClass() == getClass() && ((Character) obj).value == value;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.name.ConsecutivelyNumberedFilenames.iterator",
	"Comment": "returns an iterator which generates file names according to the rules\tspecified by this object.",
	"Method": "Iterator<File> iterator(){\r\n    return iter;\r\n}"
}, {
	"Path": "com.codename1.ui.Button.setReleaseRadius",
	"Comment": "indicates a radius in which a pointer release will still have effect. notice that this only applies topointer release events and not to pointer press events",
	"Method": "void setReleaseRadius(int releaseRadius){\r\n    this.releaseRadius = releaseRadius;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.fadeOutAndWait",
	"Comment": "hide the matched elements by fading them to transparent. blocks thread until animation is complete.",
	"Method": "ComponentSelector fadeOutAndWait(int duration){\r\n    final String placeholderProperty = \"com.codename1.ui.ComponentSelector#fadeOutPlaceholder\";\r\n    AnimationManager mgr = null;\r\n    ArrayList<ComponentAnimation> animations = new ArrayList<ComponentAnimation>();\r\n    final ArrayList<Component> animatingComponents = new ArrayList<Component>();\r\n    for (Component c : this) {\r\n        Container parent = c.getParent();\r\n        if (parent != null) {\r\n            AnimationManager cmgr = c.getAnimationManager();\r\n            if (cmgr != null) {\r\n                mgr = cmgr;\r\n                Container placeholder = new Container();\r\n                c.putClientProperty(placeholderProperty, placeholder);\r\n                Component.setSameHeight(placeholder, c);\r\n                Component.setSameWidth(placeholder, c);\r\n                $(placeholder).setMargin(c.getStyle().getMarginTop(), c.getStyle().getMarginRight(false), c.getStyle().getMarginBottom(), c.getStyle().getMarginLeft(false)).setPadding(c.getStyle().getPaddingTop(), c.getStyle().getPaddingRight(false), c.getStyle().getPaddingBottom(), c.getStyle().getPaddingLeft(false));\r\n                ComponentAnimation a = parent.createReplaceTransition(c, placeholder, CommonTransitions.createFade(duration));\r\n                animations.add(a);\r\n                animatingComponents.add(c);\r\n            }\r\n        }\r\n    }\r\n    if (mgr != null) {\r\n        mgr.addAnimationAndBlock(ComponentAnimation.compoundAnimation(animations.toArray(new ComponentAnimation[animations.size()])));\r\n        for (final Component c : animatingComponents) {\r\n            c.setVisible(false);\r\n            final Container placeholder = (Container) c.getClientProperty(placeholderProperty);\r\n            c.putClientProperty(placeholderProperty, null);\r\n            if (placeholder != null) {\r\n                Container parent = placeholder.getParent();\r\n                if (parent != null) {\r\n                    parent.replace(placeholder, c, CommonTransitions.createEmpty());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.removeCommands",
	"Comment": "removes the clear and t9 commands from the parent form, this method canbe overriden to provide device specific placement for these commands",
	"Method": "void removeCommands(Command clear,Command t9,Command originalClear){\r\n    Form f = getComponentForm();\r\n    if (f != null) {\r\n        f.removeCommand(clear);\r\n        f.removeCommand(t9);\r\n        if (selectCommand != null) {\r\n            f.removeCommand(selectCommand);\r\n        }\r\n        f.setClearCommand(originalClearCommand);\r\n        if (replaceMenu && originalCommands != null) {\r\n            int olen = originalCommands.length;\r\n            for (int iter = olen - 1; iter >= 0; iter--) {\r\n                f.addCommand(originalCommands[iter]);\r\n            }\r\n            originalCommands = null;\r\n        }\r\n        f.revalidate();\r\n    }\r\n}"
}, {
	"Path": "org.conscrypt.BufferAllocator.unpooled",
	"Comment": "returns an unpooled buffer allocator, which will create a new buffer for each request.",
	"Method": "BufferAllocator unpooled(){\r\n    return UNPOOLED;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.getPressedInstance",
	"Comment": "returns the pressed version of the border if one is set by the user",
	"Method": "Border getPressedInstance(){\r\n    if (pressedBorder != null) {\r\n        return pressedBorder;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.runtime.java.lang.Integer_.valueOf",
	"Comment": "returns a integer instance for the intvalue passed. this method is preferred over the constructor, as thismethod may maintain a cache of instances.",
	"Method": "Integer valueOf(int i){\r\n    if (i < -128 || i > 127) {\r\n        return new Integer(i);\r\n    }\r\n    return valueOfCache.CACHE[i + 128];\r\n}"
}, {
	"Path": "com.alibaba.citrus.service.upload.impl.cfu.AbstractFileItem.getFieldName",
	"Comment": "returns the name of the field in the multipart form corresponding to thisfile item.",
	"Method": "String getFieldName(){\r\n    return fieldName;\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.getCursorBlinkTimeOff",
	"Comment": "the amount of time in milliseconds in which the cursor is invisible",
	"Method": "int getCursorBlinkTimeOff(){\r\n    return blinkOffTime;\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.doPushConsentSpecialAction",
	"Comment": "special things needed to be done during setting push consent",
	"Method": "void doPushConsentSpecialAction(boolean consentValue){\r\n    if (isLoggingEnabled()) {\r\n        Log.d(TAG, \"Doing push consent special action: [\" + consentValue + \"]\");\r\n    }\r\n    connectionQueue_.getCountlyStore().setConsentPush(consentValue);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.BorderLayout.getLandscapeSwap",
	"Comment": "returns the landscape swap destination for the given border layout element if sucha destination is defined.",
	"Method": "String getLandscapeSwap(String portraitPosition){\r\n    if (landscapeSwap == null) {\r\n        return null;\r\n    }\r\n    return (String) landscapeSwap.get(portraitPosition);\r\n}"
}, {
	"Path": "com.codename1.io.Log.sendLogLegacy",
	"Comment": "sends the current log to the cloud regardless of the reporting level",
	"Method": "void sendLogLegacy(){\r\n    try {\r\n        if (!Display.isInitialized()) {\r\n            return;\r\n        }\r\n        if (!instance.logDirty) {\r\n            return;\r\n        }\r\n        instance.logDirty = false;\r\n        long devId = getUniqueDeviceId();\r\n        if (devId < 0) {\r\n            Dialog.show(\"Send Log Error\", \"Device Not Registered: Sending a log from an unregistered device is impossible\", \"OK\", null);\r\n            return;\r\n        }\r\n        ConnectionRequest r = new ConnectionRequest();\r\n        r.setPost(false);\r\n        r.setUrl(Display.getInstance().getProperty(\"cloudServerURL\", \"https://codename-one.appspot.com/\") + \"uploadLogRequest\");\r\n        r.setFailSilently(true);\r\n        NetworkManager.getInstance().addToQueueAndWait(r);\r\n        String url = new String(r.getResponseData());\r\n        MultipartRequest m = new MultipartRequest();\r\n        m.setUrl(url);\r\n        byte[] read = Util.readInputStream(Storage.getInstance().createInputStream(\"CN1Log__$\"));\r\n        m.addArgument(\"i\", \"\" + devId);\r\n        m.addArgument(\"by\", Display.getInstance().getProperty(\"built_by_user\", \"\"));\r\n        m.addArgument(\"p\", Display.getInstance().getProperty(\"package_name\", \"\"));\r\n        m.addArgument(\"v\", Display.getInstance().getProperty(\"AppVersion\", \"0.1\"));\r\n        m.addData(\"log\", read, \"text/plain\");\r\n        m.setFailSilently(true);\r\n        NetworkManager.getInstance().addToQueueAndWait(m);\r\n    } catch (Throwable ex) {\r\n        ex.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.NetworkManager.enumurateQueue",
	"Comment": "this method returns all pending connectiorequest connections.",
	"Method": "Enumeration enumurateQueue(){\r\n    Vector elements = new Vector();\r\n    synchronized (LOCK) {\r\n        Enumeration e = pending.elements();\r\n        while (e.hasMoreElements()) {\r\n            elements.addElement(e.nextElement());\r\n        }\r\n    }\r\n    return elements.elements();\r\n}"
}, {
	"Path": "android.support.v4.widget.ViewDragHelper.getEdgeSize",
	"Comment": "return the size of an edge. this is the range in pixels along the edges of this viewthat will actively detect edge touches or drags if edge tracking is enabled.",
	"Method": "int getEdgeSize(){\r\n    return mEdgeSize;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.slideDownAndWait",
	"Comment": "display the matched elements with a sliding motion. blocks until animation is complete.",
	"Method": "ComponentSelector slideDownAndWait(int duration){\r\n    final ArrayList<Component> animatedComponents = new ArrayList<Component>();\r\n    for (Component c : this) {\r\n        c.setHeight(0);\r\n        c.setVisible(true);\r\n        animatedComponents.add(c);\r\n    }\r\n    getParent().animateLayoutAndWait(duration);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Transition.getSource",
	"Comment": "returns the source form which is the form from which the animation is starting.this may be null for the first form in the application",
	"Method": "Component getSource(){\r\n    return source;\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.getDialogPreferredSize",
	"Comment": "returns the preferred size of the dialog, this allows developers to position a dialogmanually in arbitrary positions.",
	"Method": "Dimension getDialogPreferredSize(){\r\n    Component contentPane = super.getContentPane();\r\n    Style contentPaneStyle = getDialogStyle();\r\n    int width = Display.getInstance().getDisplayWidth();\r\n    int prefHeight = contentPane.getPreferredH();\r\n    int prefWidth = contentPane.getPreferredW();\r\n    prefWidth = Math.min(prefWidth, width);\r\n    if (contentPaneStyle.getBorder() != null) {\r\n        prefWidth = Math.max(contentPaneStyle.getBorder().getMinimumWidth(), prefWidth);\r\n        prefHeight = Math.max(contentPaneStyle.getBorder().getMinimumHeight(), prefHeight);\r\n    }\r\n    return new Dimension(prefWidth, prefHeight);\r\n}"
}, {
	"Path": "com.codename1.ui.geom.Rectangle2D.contains",
	"Comment": "checks wheather the 2nd rectangle is contained in the first rectangle",
	"Method": "boolean contains(Rectangle2D rect,boolean contains,double rX,double rY,double rWidth,double rHeight,boolean contains,double x1,double y1,double w1,double h1,double x2,double y2,double w2,double h2,boolean contains,double rX,double rY,boolean contains,int x,int y){\r\n    return contains((double) x, (double) y);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayoutStyle.getSharedInstance",
	"Comment": "factory methods for obtaining the current layoutstyleobject appropriate for the current look and feel.",
	"Method": "LayoutStyle getSharedInstance(){\r\n    return layoutStyle;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.isNativeShareSupported",
	"Comment": "indicates if the underlying platform supports sharing capabilities",
	"Method": "boolean isNativeShareSupported(){\r\n    return Display.impl.isNativeShareSupported();\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.ServerSessionContext.references",
	"Comment": "returns the number of open command references for the session.",
	"Method": "long references(){\r\n    return references;\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.showDialog",
	"Comment": "shows a modal dialog and returns the command pressed within the modal dialog",
	"Method": "Command showDialog(){\r\n    lastCommandPressed = null;\r\n    show();\r\n    return lastCommandPressed;\r\n}"
}, {
	"Path": "com.codename1.ui.Image.scaledHeight",
	"Comment": "scales the image to the given height while updating the width based on theaspect ratio of the height",
	"Method": "Image scaledHeight(int height){\r\n    float ratio = ((float) height) / ((float) getHeight());\r\n    return scaled(Math.max(1, (int) (getWidth() * ratio)), height);\r\n}"
}, {
	"Path": "com.codename1.impl.javase.TextEditUtil.editNextTextArea",
	"Comment": "opens onscreenkeyboard for the next textfield. the method works in edt ifneeded.",
	"Method": "void editNextTextArea(){\r\n    Runnable task = new Runnable() {\r\n        public void run() {\r\n            Component next = getNextEditComponent();\r\n            if (next != null) {\r\n                if (next.isFocusable()) {\r\n                    next.requestFocus();\r\n                    next.startEditingAsync();\r\n                }\r\n            }\r\n        }\r\n    };\r\n    Display.getInstance().callSerially(task);\r\n}"
}, {
	"Path": "com.codename1.impl.javase.TextEditUtil.editNextTextArea",
	"Comment": "opens onscreenkeyboard for the next textfield. the method works in edt ifneeded.",
	"Method": "void editNextTextArea(){\r\n    Component next = getNextEditComponent();\r\n    if (next != null) {\r\n        if (next.isFocusable()) {\r\n            next.requestFocus();\r\n            next.startEditingAsync();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.CN.renameFile",
	"Comment": "renames a file to the given name, expects the new name to be relative to thecurrent directory",
	"Method": "void renameFile(String file,String newName){\r\n    FileSystemStorage.getInstance().rename(file, newName);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.getCommandBehavior",
	"Comment": "indicates the way commands should be added to a form as one of the ocmmand constants definedin this class",
	"Method": "int getCommandBehavior(){\r\n    return impl.getCommandBehavior();\r\n}"
}, {
	"Path": "com.codename1.payment.Receipt.getCancellationDate",
	"Comment": "cancellation date of the receipt, if it has been cancelled.a cancelledreceipt should be treated as if the purchase had never been made in the first place.",
	"Method": "Date getCancellationDate(){\r\n    return cancellationDate;\r\n}"
}, {
	"Path": "com.codename1.io.NetworkEvent.getProgressPercentage",
	"Comment": "returns the percentage of progress for a download operation assuming length is known",
	"Method": "int getProgressPercentage(){\r\n    if (length > 0) {\r\n        return (int) (((float) received) / ((float) length) * 100.0f);\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.conscrypt.SSLParametersImpl.getUseClientMode",
	"Comment": "returns the value indicating if the parameters configured to workin client mode.",
	"Method": "boolean getUseClientMode(){\r\n    return client_mode;\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.showModeless",
	"Comment": "shows a modeless dialog which is useful for some simpler use cases such asprogress indication etc...",
	"Method": "void showModeless(){\r\n    modal = false;\r\n    setDisposed(false);\r\n    if (top > -1) {\r\n        show(top, bottom, left, right, includeTitle, false);\r\n    } else {\r\n        if (getDialogPosition() == null) {\r\n            showDialog(false, false);\r\n        } else {\r\n            showPacked(getDialogPosition(), false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.events.ActionEvent.getSource",
	"Comment": "the element that triggered the action event, useful for decoupling eventhandling code",
	"Method": "Object getSource(){\r\n    return source;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.LogTest.testAppendAndGetEntries",
	"Comment": "asserts that appending and getting entries works as expected across segments, with indexes set as expected.",
	"Method": "void testAppendAndGetEntries(){\r\n    List<Long> indexes = appendEntries(entriesPerSegment * 3);\r\n    assertFalse(log.isEmpty());\r\n    assertFalse(log.contains(0));\r\n    indexes.stream().forEach(i -> assertEquals(log.get(i).getIndex(), i.longValue()));\r\n    assertFalse(log.contains(indexes.size() + 1));\r\n    List<Long> moreIndexes = appendEntries(entriesPerSegment * 2);\r\n    moreIndexes.stream().forEach(i -> assertEquals(log.get(i).getIndex(), i.longValue()));\r\n    assertFalse(log.contains(indexes.size() + moreIndexes.size() + 1));\r\n    for (long index = 3; index <= entriesPerSegment * 3 + 2; index++) {\r\n        assertEquals(log.get(index).getIndex(), index);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.payments.v3.IabHelper.getResponseCodeFromIntent",
	"Comment": "workaround to bug where sometimes response codes come as long instead of integer",
	"Method": "int getResponseCodeFromIntent(Intent i){\r\n    Object o = i.getExtras().get(RESPONSE_CODE);\r\n    if (o == null) {\r\n        logError(\"Intent with no response code, assuming OK (known issue)\");\r\n        return BILLING_RESPONSE_RESULT_OK;\r\n    } else if (o instanceof Integer)\r\n        return ((Integer) o).intValue();\r\n    else if (o instanceof Long)\r\n        return (int) ((Long) o).longValue();\r\n    else {\r\n        logError(\"Unexpected type for intent response code.\");\r\n        logError(o.getClass().getName());\r\n        throw new RuntimeException(\"Unexpected type for intent response code: \" + o.getClass().getName());\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLFont.setCounterpartFont",
	"Comment": "sets the specified font as the counterpart of this font in the given attribute",
	"Method": "void setCounterpartFont(int attribute,HTMLFont counterpartFont){\r\n    counterpartFonts[attribute] = counterpartFont;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.BoundSize.getSize",
	"Comment": "returns the minimum, preferred or maximum size for this bounded size.",
	"Method": "UnitValue getSize(int sizeType){\r\n    switch(sizeType) {\r\n        case LayoutUtil.MIN:\r\n            return min;\r\n        case LayoutUtil.PREF:\r\n            return pref;\r\n        case LayoutUtil.MAX:\r\n            return max;\r\n        default:\r\n            throw new IllegalArgumentException(\"Unknown size: \" + sizeType);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.client.session.ClientSequencerTest.testSequenceMultipleMissingEvents",
	"Comment": "tests sequencing multiple responses that indicate missing events.",
	"Method": "void testSequenceMultipleMissingEvents(){\r\n    ClientSessionState state = new ClientSessionState(UUID.randomUUID().toString());\r\n    state.setSessionId(1).setCommandRequest(2).setResponseIndex(15).setEventIndex(5);\r\n    AtomicInteger run = new AtomicInteger();\r\n    ClientSequencer sequencer = new ClientSequencer(state);\r\n    sequencer.requestSequence = 3;\r\n    sequencer.responseSequence = 1;\r\n    sequencer.eventIndex = 5;\r\n    CommandResponse commandResponse2 = CommandResponse.builder().withStatus(Response.Status.OK).withIndex(20).withEventIndex(10).build();\r\n    sequencer.sequenceResponse(3, commandResponse2, () -> assertEquals(run.getAndIncrement(), 1));\r\n    CommandResponse commandResponse1 = CommandResponse.builder().withStatus(Response.Status.OK).withIndex(18).withEventIndex(8).build();\r\n    sequencer.sequenceResponse(2, commandResponse1, () -> assertEquals(run.getAndIncrement(), 0));\r\n    PublishRequest publishRequest1 = PublishRequest.builder().withSession(1).withEventIndex(25).withPreviousIndex(5).build();\r\n    sequencer.sequenceEvent(publishRequest1, () -> assertEquals(run.getAndIncrement(), 2));\r\n    PublishRequest publishRequest2 = PublishRequest.builder().withSession(1).withEventIndex(28).withPreviousIndex(8).build();\r\n    sequencer.sequenceEvent(publishRequest2, () -> assertEquals(run.getAndIncrement(), 3));\r\n    assertEquals(run.get(), 4);\r\n}"
}, {
	"Path": "com.codename1.xml.XMLParser.isLegalCharEntityCharacter",
	"Comment": "checks if this character is a legal character for char entities",
	"Method": "boolean isLegalCharEntityCharacter(char c){\r\n    return (((c >= 'a') && (c <= 'z')) || ((c >= 'A') && (c <= 'Z')) || ((c >= '0') && (c <= '9')) || (c == '#'));\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.MigLayout.setComponentConstraints",
	"Comment": "sets the component constraint for the component that already must behandled by this layout manager.see the class javadocs for information on how this string is formatted.",
	"Method": "void setComponentConstraints(Component comp,Object constr){\r\n    setComponentConstraintsImpl(comp, constr, false);\r\n}"
}, {
	"Path": "android.support.v4.util.LruCache.snapshot",
	"Comment": "returns a copy of the current contents of the cache, ordered from leastrecently accessed to most recently accessed.",
	"Method": "Map<K, V> snapshot(){\r\n    return new LinkedHashMap<K, V>(map);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GridLayout.isFillLastRow",
	"Comment": "when set to true makes the grid layout fill the last row of the layoutentirely if the number of elements in that row is bigger.",
	"Method": "boolean isFillLastRow(){\r\n    return fillLastRow;\r\n}"
}, {
	"Path": "com.codename1.io.services.RSSService.getResults",
	"Comment": "the results are presented as a vector of hashtables easily presentable in codename one",
	"Method": "Vector getResults(){\r\n    return results;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.pointerHoverPressed",
	"Comment": "pushes a pointer hover release event with the given coordinates into codename one",
	"Method": "void pointerHoverPressed(int[] x,int[] y){\r\n    if (impl.getCurrentForm() == null) {\r\n        return;\r\n    }\r\n    addPointerEvent(POINTER_HOVER_PRESSED, x[0], y[0]);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isURLWithCustomHeadersSupported",
	"Comment": "returns true if setbrowserurl with custom headers is supported",
	"Method": "boolean isURLWithCustomHeadersSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.components.RadioButtonList.isAllowMultipleSelection",
	"Comment": "returns false for radiobuttonlist since only one radio button can be selected at a time.",
	"Method": "boolean isAllowMultipleSelection(){\r\n    return false;\r\n}"
}, {
	"Path": "com.alibaba.citrus.service.upload.impl.cfu.AbstractFileItem.delete",
	"Comment": "deletes the underlying storage for a file item, including deleting anyassociated temporary disk file. although this storage will be deletedautomatically when the fileitem instance is garbagecollected, this method can be used to ensure that this is done at anearlier time, thus preserving system resources.",
	"Method": "void delete(){\r\n    cachedContent = null;\r\n    File outputFile = getStoreLocation();\r\n    if (outputFile != null && outputFile.exists()) {\r\n        outputFile.delete();\r\n    }\r\n}"
}, {
	"Path": "java.util.Collections.newSetFromMap",
	"Comment": "answers a set backed by a map. and the map must be empty when this methodis called.",
	"Method": "Set<E> newSetFromMap(Map<E, Boolean> map){\r\n    if (map.isEmpty()) {\r\n        return new SetFromMap<E>(map);\r\n    }\r\n    throw new IllegalArgumentException();\r\n}"
}, {
	"Path": "com.codename1.ui.Display.setNativeCommands",
	"Comment": "indicates whether codename one commands should be mapped to the native menus",
	"Method": "void setNativeCommands(boolean nativeCommands){\r\n    setCommandBehavior(COMMAND_BEHAVIOR_NATIVE);\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.setLoggingEnabled",
	"Comment": "sets whether debug logging is turned on or off. logging is disabled by default.",
	"Method": "Countly setLoggingEnabled(boolean enableLogging){\r\n    if (Countly.sharedInstance().isLoggingEnabled()) {\r\n        Log.d(Countly.TAG, \"Enabling logging\");\r\n    }\r\n    enableLogging_ = enableLogging;\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.io.rest.RequestBuilder.fetchAsProperties",
	"Comment": "executes the request asynchronously and writes the response to the providedcallback. this fetches json data and parses it into a properties business object",
	"Method": "ConnectionRequest fetchAsProperties(OnComplete<Response<PropertyBusinessObject>> callback,Class type){\r\n    ConnectionRequest request = createRequest(true);\r\n    request.addResponseListener(new ActionListener<NetworkEvent>() {\r\n        @Override\r\n        public void actionPerformed(NetworkEvent evt) {\r\n            Response res = null;\r\n            Map response = (Map) evt.getMetaData();\r\n            try {\r\n                PropertyBusinessObject pb = (PropertyBusinessObject) type.newInstance();\r\n                pb.getPropertyIndex().populateFromMap(response);\r\n                res = new Response(evt.getResponseCode(), pb, evt.getMessage());\r\n                callback.completed(res);\r\n            } catch (Exception err) {\r\n                Log.e(err);\r\n                throw new RuntimeException(err.toString());\r\n            }\r\n        }\r\n    });\r\n    CN.addToQueue(request);\r\n    return request;\r\n}"
}, {
	"Path": "com.codename1.io.rest.RequestBuilder.fetchAsProperties",
	"Comment": "executes the request asynchronously and writes the response to the providedcallback. this fetches json data and parses it into a properties business object",
	"Method": "ConnectionRequest fetchAsProperties(OnComplete<Response<PropertyBusinessObject>> callback,Class type){\r\n    Response res = null;\r\n    Map response = (Map) evt.getMetaData();\r\n    try {\r\n        PropertyBusinessObject pb = (PropertyBusinessObject) type.newInstance();\r\n        pb.getPropertyIndex().populateFromMap(response);\r\n        res = new Response(evt.getResponseCode(), pb, evt.getMessage());\r\n        callback.completed(res);\r\n    } catch (Exception err) {\r\n        Log.e(err);\r\n        throw new RuntimeException(err.toString());\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Display.hideNotify",
	"Comment": "broadcasts hide notify into codename one, this method is invoked by the codename one implementationto notify codename one of hidenotify events",
	"Method": "void hideNotify(){\r\n    keyRepeatCharged = false;\r\n    longPressCharged = false;\r\n    longPointerCharged = false;\r\n    pointerPressedAndNotReleasedOrDragged = false;\r\n    addNotifyEvent(HIDE_NOTIFY);\r\n}"
}, {
	"Path": "com.codename1.io.Util.downloadUrlToFile",
	"Comment": "blocking method that will download the given url to the file system storage and return when the operation completes",
	"Method": "boolean downloadUrlToFile(String url,String fileName,boolean showProgress){\r\n    return downloadUrlTo(url, fileName, showProgress, false, false, null);\r\n}"
}, {
	"Path": "com.codename1.components.MultiButton.getIconComponent",
	"Comment": "allows us to gain direct access to the icon component so we can set it directly without goingvia the other methods, this is especially useful for classes such as the imagedownloadservicewhich can then update the icon seamlessly.",
	"Method": "Label getIconComponent(){\r\n    return icon;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.setTransitionYield",
	"Comment": "indicates whether a delay should exist between calls to flush graphics duringtransition. in some devices flushgraphics is asynchronious causing it to bevery slow with our background thread. the solution is to add a short wait allowingthe implementation time to paint the screen. this value is set automatically by defaultbut can be overriden for some devices.",
	"Method": "void setTransitionYield(int transitionD){\r\n    transitionDelay = transitionD;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.protocol.ConfigureRequest.builder",
	"Comment": "returns an configuration request builder for an existing request.",
	"Method": "Builder builder(Builder builder,ConfigureRequest request){\r\n    return new Builder(request);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.setUseNativeCookieStore",
	"Comment": "uses the native cookie store if applicable, this might break simulator compatibility",
	"Method": "void setUseNativeCookieStore(boolean useNativeCookieStore){\r\n    this.useNativeCookieStore = useNativeCookieStore;\r\n}"
}, {
	"Path": "com.codename1.util.TDivision.divideLongByInt",
	"Comment": "divides an unsigned long a by an unsigned int b. it is supposed that themost significant bit of b is set to 1, i.e. b0",
	"Method": "long divideLongByInt(long a,int b){\r\n    long quot;\r\n    long rem;\r\n    long bLong = b & 0xffffffffL;\r\n    if (a >= 0) {\r\n        quot = (a / bLong);\r\n        rem = (a % bLong);\r\n    } else {\r\n        long aPos = a >>> 1;\r\n        long bPos = b >>> 1;\r\n        quot = aPos / bPos;\r\n        rem = aPos % bPos;\r\n        rem = (rem << 1) + (a & 1);\r\n        if ((b & 1) != 0) {\r\n            if (quot <= rem) {\r\n                rem -= quot;\r\n            } else {\r\n                if (quot - rem <= bLong) {\r\n                    rem += bLong - quot;\r\n                    quot -= 1;\r\n                } else {\r\n                    rem += (bLong << 1) - quot;\r\n                    quot -= 2;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return (rem << 32) | (quot & 0xffffffffL);\r\n}"
}, {
	"Path": "org.conscrypt.ConscryptServerSocket.isChannelIdEnabled",
	"Comment": "checks whether the tls channel id extension is enabled for this server socket.",
	"Method": "boolean isChannelIdEnabled(){\r\n    return channelIdEnabled;\r\n}"
}, {
	"Path": "com.codename1.ui.util.Resources.getMajorVersion",
	"Comment": "returns the version number for this resource file. this value relates to the value from the header defined by the resource filespecification. 0 is returned for legacy versions of the resource file format.",
	"Method": "int getMajorVersion(){\r\n    return majorVersion;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.AbstractLogTest.fullSegmentSize",
	"Comment": "returns the size of a full segment given the entrysize, entriespersegment, and segmentdescriptor.",
	"Method": "int fullSegmentSize(){\r\n    return entriesPerSegment * entrySize() + SegmentDescriptor.BYTES;\r\n}"
}, {
	"Path": "com.codename1.ui.SideMenuBar.isShowing",
	"Comment": "returns true if a side menu is currently controlling the screen",
	"Method": "boolean isShowing(){\r\n    Form f = Display.getInstance().getCurrent();\r\n    return f.getClientProperty(\"cn1$sideMenuParent\") != null;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.callSeriallyOnIdle",
	"Comment": "causes the runnable to be invoked on the event dispatch thread when the event dispatch thread is idle. this method returns immediately and will not wait for the serial call to occur. notice this method is identical to call serially but will perform the runnable only whenthe edt is idle",
	"Method": "void callSeriallyOnIdle(Runnable r){\r\n    if (codenameOneRunning) {\r\n        synchronized (lock) {\r\n            pendingIdleSerialCalls.add(r);\r\n            lock.notifyAll();\r\n        }\r\n    } else {\r\n        r.run();\r\n    }\r\n}"
}, {
	"Path": "org.conscrypt.Conscrypt.maxSealOverhead",
	"Comment": "returns the maximum overhead, in bytes, of sealing a record with ssl.",
	"Method": "int maxSealOverhead(SSLEngine engine){\r\n    return toConscrypt(engine).maxSealOverhead();\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundBorder.shadowBlur",
	"Comment": "the blur on the shadow this is the standard gaussian blur radius",
	"Method": "RoundBorder shadowBlur(float shadowBlur){\r\n    this.shadowBlur = shadowBlur;\r\n    modificationTime = System.currentTimeMillis();\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.Graphics.lighterColor",
	"Comment": "makes the current color slightly lighter, this is useful for many visual effects",
	"Method": "void lighterColor(int factor){\r\n    int color = getColor();\r\n    int r = color >> 16 & 0xff;\r\n    int g = color >> 8 & 0xff;\r\n    int b = color & 0xff;\r\n    r = Math.min(0xff, r + factor);\r\n    g = Math.min(0xff, g + factor);\r\n    b = Math.min(0xff, b + factor);\r\n    setColor(((r << 16) & 0xff0000) | ((g << 8) & 0xff00) | (b & 0xff));\r\n}"
}, {
	"Path": "com.codename1.impl.android.AndroidNativeUtil.checkForPermission",
	"Comment": "check for a dangerous permission, if the permission is already granted return true, otherwise ask the user for the permission.this method is blocking until a response is returned",
	"Method": "boolean checkForPermission(String permission,String description){\r\n    return AndroidImplementation.checkForPermission(permission, description, false);\r\n}"
}, {
	"Path": "android.support.v4.widget.ViewDragHelper.canScroll",
	"Comment": "tests scrollability within child views of v given a delta of dx.",
	"Method": "boolean canScroll(View v,boolean checkV,int dx,int dy,int x,int y){\r\n    if (v instanceof ViewGroup) {\r\n        final ViewGroup group = (ViewGroup) v;\r\n        final int scrollX = v.getScrollX();\r\n        final int scrollY = v.getScrollY();\r\n        final int count = group.getChildCount();\r\n        for (int i = count - 1; i >= 0; i--) {\r\n            final View child = group.getChildAt(i);\r\n            if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && canScroll(child, true, dx, dy, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return checkV && (ViewCompat.canScrollHorizontally(v, -dx) || ViewCompat.canScrollVertically(v, -dy));\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testServerJoinLate",
	"Comment": "tests joining a server after many entries have been committed.",
	"Method": "void testServerJoinLate(Member.Type type,CopycatServer.State state){\r\n    createServers(3);\r\n    CopycatClient client = createClient();\r\n    submit(client, 0, 1000);\r\n    await(30000);\r\n    CopycatServer joiner = createServer(nextMember(type));\r\n    joiner.onStateChange(s -> {\r\n        if (s == state)\r\n            resume();\r\n    });\r\n    joiner.join(members.stream().map(Member::serverAddress).collect(Collectors.toList())).thenRun(this::resume);\r\n    await(30000, 2);\r\n}"
}, {
	"Path": "com.codename1.ui.html.DefaultDocumentRequestHandler.visitingURL",
	"Comment": "this method can be invoked to indicate a url was visited fro tracking",
	"Method": "void visitingURL(String url){\r\n    if (trackVisitedURLs) {\r\n        if (visitedURLs == null) {\r\n            visitedURLs = new Vector();\r\n        }\r\n        if (!visitedURLs.contains(url)) {\r\n            visitedURLs.addElement(url);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.FileEncodedImage.create",
	"Comment": "creates an encoded image that maps to a local file thus allowing toseamlessly fetch files as needed. this only works reasonably well for very smallfiles.",
	"Method": "FileEncodedImage create(String fileName,int width,int height,FileEncodedImage create,String fileName,InputStream i,int width,int height,FileEncodedImage create,String fileName,int width,int height,boolean keep){\r\n    return new FileEncodedImage(fileName, width, height, keep);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setWidth",
	"Comment": "sets the component width, this method is exposed for the purpose of external layout managers and should not be invoked directly.if a user wishes to effect the component size setpreferredsize shouldbe used.",
	"Method": "void setWidth(int width){\r\n    bounds.getSize().setWidth(width);\r\n}"
}, {
	"Path": "com.codename1.ui.validation.Validator.getValidationFailedEmblem",
	"Comment": "the emblem that will be drawn on top of the component to indicate the validation failure",
	"Method": "Image getValidationFailedEmblem(){\r\n    return validationFailedEmblem;\r\n}"
}, {
	"Path": "java.lang.Character.isUpperCase",
	"Comment": "indicates whether the specified code point is an upper case letter.",
	"Method": "boolean isUpperCase(char ch){\r\n    if ('A' <= codePoint && codePoint <= 'Z') {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.components.SplitPane.toggleCollapsePreferred",
	"Comment": "toggles the split pane between collapsed state and preferred state.e.g. if the inset is currentlynot collapsed, it will collapse it.if it is collapsed, it will open to the last position that the userselected.",
	"Method": "void toggleCollapsePreferred(){\r\n    if (isCollapsed) {\r\n        expand();\r\n    } else if (isExpanded) {\r\n        collapse(true);\r\n    } else {\r\n        collapse();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.Grid.addDockingCell",
	"Comment": "adds a docking cell. that cell is outside the normal cell indexes.",
	"Method": "void addDockingCell(int[] dockInsets,int side,CompWrap cw){\r\n    int r, c, spanx = 1, spany = 1;\r\n    switch(side) {\r\n        case 0:\r\n        case 2:\r\n            r = side == 0 ? dockInsets[0]++ : dockInsets[2]--;\r\n            c = dockInsets[1];\r\n            spanx = dockInsets[3] - dockInsets[1] + 1;\r\n            colIndexes.add(new Integer(dockInsets[3]));\r\n            break;\r\n        case 1:\r\n        case 3:\r\n            c = side == 1 ? dockInsets[1]++ : dockInsets[3]--;\r\n            r = dockInsets[0];\r\n            spany = dockInsets[2] - dockInsets[0] + 1;\r\n            rowIndexes.add(new Integer(dockInsets[2]));\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"Internal error 123.\");\r\n    }\r\n    rowIndexes.add(new Integer(r));\r\n    colIndexes.add(new Integer(c));\r\n    grid.put(new Integer((r << 16) + c), new Cell(cw, spanx, spany, spanx > 1));\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isShiftKeyDown",
	"Comment": "checks if shift key is currently down.only relevant for desktop ports.",
	"Method": "boolean isShiftKeyDown(){\r\n    return impl.isShiftKeyDown();\r\n}"
}, {
	"Path": "com.codename1.ui.Display.sizeChanged",
	"Comment": "notifies codename one of display size changes, this method is invoked by the implementationclass and is for internal use",
	"Method": "void sizeChanged(int w,int h){\r\n    Form current = impl.getCurrentForm();\r\n    if (current == null) {\r\n        return;\r\n    }\r\n    if (w == current.getWidth() && h == current.getHeight()) {\r\n        if (lastSizeChangeEventWH == -1 || lastSizeChangeEventWH == current.getWidth() + current.getHeight()) {\r\n            return;\r\n        }\r\n    }\r\n    lastSizeChangeEventWH = w + h;\r\n    addSizeChangeEvent(SIZE_CHANGED, w, h);\r\n}"
}, {
	"Path": "com.codename1.components.Ads.setAppID",
	"Comment": "simple setter of the unique identifier of the app on the ads service network, no need to manually use this the createadsservice uses this.",
	"Method": "void setAppID(String appId){\r\n    this.appId = appId;\r\n    if (service == null) {\r\n        service = AdsService.createAdsService();\r\n        if (isInitialized()) {\r\n            initComponent();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Button.setDisabledIcon",
	"Comment": "indicates the icon that is displayed on the button when the button is inthe disabled state",
	"Method": "void setDisabledIcon(Image disabledIcon){\r\n    this.disabledIcon = disabledIcon;\r\n    setShouldCalcPreferredSize(true);\r\n    checkAnimation();\r\n    repaint();\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.showStretched",
	"Comment": "convenience method to show a dialog stretched to one of the sides",
	"Method": "Command showStretched(String position,boolean modal){\r\n    return showPackedImpl(position, modal, true);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundBorder.getStrokeThickness",
	"Comment": "the thickness of the edge of the border if applicable, 0 if no stroke is needed",
	"Method": "float getStrokeThickness(){\r\n    return strokeThickness;\r\n}"
}, {
	"Path": "com.codename1.ui.RGBImage.rotate",
	"Comment": "unsupported in the current version, this method will be implemented in a future release",
	"Method": "Image rotate(int degrees){\r\n    throw new RuntimeException(\"The rotate method is not supported by RGB images at the moment\");\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.unlock",
	"Comment": "this callback indicates that a component pointing at this border is now deinitilizedthis method may be invoked multiple times.",
	"Method": "void unlock(){\r\n    if (images != null) {\r\n        int ilen = images.length;\r\n        for (int iter = 0; iter < ilen; iter++) {\r\n            if (images[iter] != null) {\r\n                images[iter].unlock();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.Collections.addAll",
	"Comment": "adds all the specified elements to the specified collection.",
	"Method": "boolean addAll(Collection<? extends E> collection,boolean addAll,int location,Collection<? extends E> collection,boolean addAll,Collection<? extends E> collection,boolean addAll,int location,Collection<? extends E> collection,boolean addAll,Collection<? super T> c,T a,boolean addAll,Collection<? extends E> c1){\r\n    boolean modified = false;\r\n    for (int i = 0; i < a.length; i++) {\r\n        modified |= c.add(a[i]);\r\n    }\r\n    return modified;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.dispatchCommand",
	"Comment": "dispatches a command via the standard form mechanism of firing a command event",
	"Method": "void dispatchCommand(Command cmd,ActionEvent ev){\r\n    cmd.actionPerformed(ev);\r\n    if (!ev.isConsumed()) {\r\n        actionCommandImpl(cmd, ev);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractSet.removeAll",
	"Comment": "removes all occurrences in this collection which are contained in thespecified collection.",
	"Method": "boolean removeAll(Collection<?> collection){\r\n    boolean result = false;\r\n    if (size() <= collection.size()) {\r\n        Iterator<?> it = iterator();\r\n        while (it.hasNext()) {\r\n            if (collection.contains(it.next())) {\r\n                it.remove();\r\n                result = true;\r\n            }\r\n        }\r\n    } else {\r\n        Iterator<?> it = collection.iterator();\r\n        while (it.hasNext()) {\r\n            result = remove(it.next()) || result;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.findByName",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "Component findByName(String componentName){\r\n    return TestUtils.findByName(componentName);\r\n}"
}, {
	"Path": "com.codename1.maps.Mercator.fromWGS84",
	"Comment": "create a projected mercator coord from the given coordinate",
	"Method": "Coord fromWGS84(Coord wgs84){\r\n    if (wgs84.isProjected()) {\r\n        return wgs84;\r\n    }\r\n    return forwardMercator(wgs84.getLatitude(), wgs84.getLongitude());\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLInputFormat.verifyChar",
	"Comment": "verifies the given character. this method is used by verifystring on each char",
	"Method": "boolean verifyChar(char c,int constraint){\r\n    if (((constraint & FormatConstraint.TYPE_ANY) != 0) || (((constraint & FormatConstraint.TYPE_NUMERIC) != 0) && (c >= '0') && (c <= '9')) || (((constraint & FormatConstraint.TYPE_UPPERCASE) != 0) && (c >= 'A') && (c <= 'Z')) || (((constraint & FormatConstraint.TYPE_LOWERCASE) != 0) && (c >= 'a') && (c <= 'z'))) {\r\n        return true;\r\n    }\r\n    if ((constraint & FormatConstraint.TYPE_SYMBOL) != 0) {\r\n        char[] symbols = TextField.getSymbolTable();\r\n        for (int i = 0; i < symbols.length; i++) {\r\n            if (symbols[i] == c) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.io.File.exists",
	"Comment": "checks if the file described by this object exists on the file system.",
	"Method": "boolean exists(){\r\n    return FileSystemStorage.getInstance().exists(path);\r\n}"
}, {
	"Path": "org.conscrypt.SSLParametersImpl.setNeedClientAuth",
	"Comment": "tunes the peer holding this parameters to require client authentication",
	"Method": "void setNeedClientAuth(boolean need){\r\n    need_client_auth = need;\r\n    want_client_auth = false;\r\n}"
}, {
	"Path": "com.codename1.io.NetworkManager.isAPSupported",
	"Comment": "indicates whether looking up an access point is supported by this device",
	"Method": "boolean isAPSupported(){\r\n    return Util.getImplementation().isAPSupported();\r\n}"
}, {
	"Path": "android.support.v4.app.DialogFragment.dismiss",
	"Comment": "dismiss the fragment and its dialog.if the fragment was added to theback stack, all back stack state up to and including this entry willbe popped.otherwise, a new transaction will be committed to removethe fragment.",
	"Method": "void dismiss(){\r\n    dismissInternal(false);\r\n}"
}, {
	"Path": "com.codename1.io.CharArrayReader.close",
	"Comment": "this method closes this chararrayreader. once it is closed, you can nolonger read from it. only the first invocation of this method has anyeffect.",
	"Method": "void close(){\r\n    synchronized (lock) {\r\n        if (isOpen()) {\r\n            buf = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.l2fprod.common.beans.BaseBeanInfo.getDescription",
	"Comment": "return a text describing briefly the object. the text will be usedwhereever a explanation is needed to give to the user",
	"Method": "String getDescription(Object value){\r\n    return getText(value);\r\n}"
}, {
	"Path": "java.lang.StringBuffer.setCharAt",
	"Comment": "the character at the specified index of this string buffer is set to ch. the string buffer is altered to represent a new character sequence that is identical to the old character sequence, except that it contains the character ch at position index.the offset argument must be greater than or equal to 0, and less than the length of this string buffer.",
	"Method": "void setCharAt(int index,char ch){\r\n    internal.setCharAt(index, ch);\r\n}"
}, {
	"Path": "com.codename1.io.CacheMap.getKeysInCache",
	"Comment": "returns the keys for all the objects currently in cache, this is usefulto traverse all the objects and refresh them without actually deletingthe cache and fetching them from scratch.important this vector is a copy of a current state, keys might not exist anymore or might change, others might be added in the interim.",
	"Method": "Vector getKeysInCache(){\r\n    Vector r = new Vector();\r\n    Enumeration en = memoryCache.keys();\r\n    while (en.hasMoreElements()) {\r\n        r.addElement(en.nextElement());\r\n    }\r\n    Vector storageCacheContent = getStorageCacheContent();\r\n    for (int iter = 0; iter < storageCacheContent.size(); iter++) {\r\n        Object[] o = (Object[]) storageCacheContent.elementAt(iter);\r\n        if (!r.contains(o[1])) {\r\n            r.addElement(o[1]);\r\n        }\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.getPriority",
	"Comment": "the priority of this connection based on the constants in this class",
	"Method": "byte getPriority(){\r\n    return priority;\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.bindListenerToComponent",
	"Comment": "binds the given listener object to the component, this works seamlessly for common codename one events but might be an issue with custom components and customlistener types so this method can be overloaded to add support for such cases.",
	"Method": "void bindListenerToComponent(Component cmp,Object listener){\r\n    if (cmp instanceof Container) {\r\n        cmp = ((Container) cmp).getLeadComponent();\r\n    }\r\n    if (listener instanceof FocusListener) {\r\n        cmp.addFocusListener((FocusListener) listener);\r\n        return;\r\n    }\r\n    if (listener instanceof ActionListener) {\r\n        if (cmp instanceof Button) {\r\n            ((Button) cmp).addActionListener((ActionListener) listener);\r\n            return;\r\n        }\r\n        if (cmp instanceof List) {\r\n            ((List) cmp).addActionListener((ActionListener) listener);\r\n            return;\r\n        }\r\n        if (cmp instanceof ContainerList) {\r\n            ((ContainerList) cmp).addActionListener((ActionListener) listener);\r\n            return;\r\n        }\r\n        if (cmp instanceof com.codename1.ui.Calendar) {\r\n            ((com.codename1.ui.Calendar) cmp).addActionListener((ActionListener) listener);\r\n            return;\r\n        }\r\n        ((TextArea) cmp).addActionListener((ActionListener) listener);\r\n        return;\r\n    }\r\n    if (listener instanceof DataChangedListener) {\r\n        if (cmp instanceof TextField) {\r\n            ((TextField) cmp).addDataChangedListener((DataChangedListener) listener);\r\n            return;\r\n        }\r\n        ((Slider) cmp).addDataChangedListener((DataChangedListener) listener);\r\n        return;\r\n    }\r\n    if (listener instanceof SelectionListener) {\r\n        if (cmp instanceof List) {\r\n            ((List) cmp).addSelectionListener((SelectionListener) listener);\r\n            return;\r\n        }\r\n        ((Slider) cmp).addDataChangedListener((DataChangedListener) listener);\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudPersona.logout",
	"Comment": "logs out the current user, notice that with an anonymous user this will effectively kill allthe data in the cloud!",
	"Method": "void logout(){\r\n    if (Preferences.get(\"CN1PersonaAnonymous\", false)) {\r\n        throw new RuntimeException(\"Anonymous personas can't be logged out!\");\r\n    }\r\n    Preferences.delete(\"CN1Persona\");\r\n}"
}, {
	"Path": "com.codename1.util.TBitLevel.shiftLeftOneBit",
	"Comment": "shifts the source digits left one bit, creating a value whose magnitudeis doubled.",
	"Method": "void shiftLeftOneBit(int result,int source,int srcLen,TBigInteger shiftLeftOneBit,TBigInteger source){\r\n    int srcLen = source.numberLength;\r\n    int resLen = srcLen + 1;\r\n    int[] resDigits = new int[resLen];\r\n    shiftLeftOneBit(resDigits, source.digits, srcLen);\r\n    TBigInteger result = new TBigInteger(source.sign, resLen, resDigits);\r\n    result.cutOffLeadingZeroes();\r\n    return result;\r\n}"
}, {
	"Path": "com.codename1.ui.SideMenuBar.addComponentToSideMenu",
	"Comment": "this method responsible to add a component to the side navigation panel.",
	"Method": "void addComponentToSideMenu(Container menu,Component cmp){\r\n    addComponentToSideMenuImpl(menu, cmp);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.isCellRenderer",
	"Comment": "used as an optimization to mark that this component is currently beingused as a cell renderer",
	"Method": "boolean isCellRenderer(){\r\n    return cellRenderer;\r\n}"
}, {
	"Path": "android.support.v4.database.DatabaseUtilsCompat.appendSelectionArgs",
	"Comment": "appends one set of selection args to another. this is useful when adding a selectionargument to a user provided set.",
	"Method": "String[] appendSelectionArgs(String[] originalValues,String[] newValues){\r\n    if (originalValues == null || originalValues.length == 0) {\r\n        return newValues;\r\n    }\r\n    String[] result = new String[originalValues.length + newValues.length];\r\n    System.arraycopy(originalValues, 0, result, 0, originalValues.length);\r\n    System.arraycopy(newValues, 0, result, originalValues.length, newValues.length);\r\n    return result;\r\n}"
}, {
	"Path": "java.io.ByteArrayInputStream.mark",
	"Comment": "set the current marked position in the stream. bytearrayinputstream objects are marked at position zero by default when constructed. they may be marked at another position within the buffer by this method.",
	"Method": "void mark(int readAheadLimit){\r\n    mark = pos;\r\n}"
}, {
	"Path": "com.codename1.messaging.Message.sendMessageViaCloudSync",
	"Comment": "send an email message using the codename one cloud to send the message, notice that this apiwill only work for pro accounts.",
	"Method": "boolean sendMessageViaCloudSync(String sender,String recipient,String recipientName,String subject,String plainTextBody){\r\n    ConnectionRequest r = createMessage(sender, recipient, recipientName, subject, plainTextBody);\r\n    r.setFailSilently(true);\r\n    NetworkManager.getInstance().addToQueueAndWait(r);\r\n    return r.getResposeCode() == 200;\r\n}"
}, {
	"Path": "com.codename1.properties.ListProperty.add",
	"Comment": "adds a property value to the end of the list and fires a change event",
	"Method": "K add(int offset,T v,K add,T v){\r\n    value.add(v);\r\n    firePropertyChanged();\r\n    return (K) parent.parent;\r\n}"
}, {
	"Path": "android.support.v4.widget.ViewDragHelper.setMinVelocity",
	"Comment": "set the minimum velocity that will be detected as having a magnitude greater than zeroin pixels per second. callback methods accepting a velocity will be clamped appropriately.",
	"Method": "void setMinVelocity(float minVel){\r\n    mMinVelocity = minVel;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.paintScrollbarY",
	"Comment": "paints the ui for the scrollbar on the y axis, this method allows componentsubclasses to customize the look of a scrollbar",
	"Method": "void paintScrollbarY(Graphics g){\r\n    float scrollH = getScrollDimension().getHeight();\r\n    float block = ((float) getHeight()) / scrollH;\r\n    float offset;\r\n    if (getScrollY() + getHeight() == scrollH) {\r\n        offset = 1 - block;\r\n    } else {\r\n        offset = (((float) getScrollY() + getHeight()) / scrollH) - block;\r\n    }\r\n    getUIManager().getLookAndFeel().drawVerticalScroll(g, this, offset, block);\r\n}"
}, {
	"Path": "com.codename1.xml.XMLParser.createNewTextElement",
	"Comment": "creates a new text element. this should be overriden by parsers that use a subclass of element.",
	"Method": "Element createNewTextElement(String text){\r\n    Element e = new Element(text, true);\r\n    e.caseSensitive = caseSensitive;\r\n    return e;\r\n}"
}, {
	"Path": "android.support.v4.view.accessibility.AccessibilityRecordCompat.obtain",
	"Comment": "returns a cached instance if such is available or a new one isinstantiated.",
	"Method": "Object obtain(Object obtain,Object record,Object obtain,Object obtain,Object record,Object obtain,Object obtain,Object record,AccessibilityRecordCompat obtain,AccessibilityRecordCompat record,AccessibilityRecordCompat obtain){\r\n    return new AccessibilityRecordCompat(IMPL.obtain());\r\n}"
}, {
	"Path": "com.codename1.ui.Container.createAnimateLayoutFade",
	"Comment": "animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation",
	"Method": "ComponentAnimation createAnimateLayoutFade(int duration,int startingOpacity){\r\n    return animateLayout(duration, false, startingOpacity, false);\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.builders.ThumbnailParameterBuilder.keepAspectRatio",
	"Comment": "sets whether or not the thumbnail is to maintain the aspect ratio of\tthe original image.",
	"Method": "ThumbnailParameterBuilder keepAspectRatio(boolean keep){\r\n    this.keepAspectRatio = keep;\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.addFocusListener",
	"Comment": "registers interest in receiving callbacks for focus gained events, a focus event is invoked when the component accepts the focus. a special case exists for theform which sends a focus even for every selection within the form.",
	"Method": "void addFocusListener(FocusListener l){\r\n    if (focusListeners == null) {\r\n        focusListeners = new EventDispatcher();\r\n    }\r\n    focusListeners.addListener(l);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.paintScrollbarX",
	"Comment": "paints the ui for the scrollbar on the x axis, this method allows componentsubclasses to customize the look of a scrollbar",
	"Method": "void paintScrollbarX(Graphics g){\r\n    float scrollW = getScrollDimension().getWidth();\r\n    float block = ((float) getWidth()) / scrollW;\r\n    float offset;\r\n    if (getScrollX() + getWidth() == scrollW) {\r\n        offset = 1 - block;\r\n    } else {\r\n        offset = (((float) getScrollX() + getWidth()) / scrollW) - block;\r\n    }\r\n    getUIManager().getLookAndFeel().drawHorizontalScroll(g, this, offset, block);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getNextFocusLeft",
	"Comment": "allows us to determine which component will receive focus next when traversing with the left key.",
	"Method": "Component getNextFocusLeft(){\r\n    return nextFocusLeft;\r\n}"
}, {
	"Path": "com.codename1.components.SignatureComponent.setSignatureImage",
	"Comment": "sets the signature image for this field.this will also scale the image and show it as the icon for the button.",
	"Method": "void setSignatureImage(Image img){\r\n    if (img != signatureImage) {\r\n        signatureImage = img;\r\n        lead.setText(\"\");\r\n        if (img != null) {\r\n            int maxW = lead.getWidth() - lead.getStyle().getPaddingLeftNoRTL() - lead.getStyle().getPaddingRightNoRTL();\r\n            int maxH = lead.getHeight() - lead.getStyle().getPaddingTop() - lead.getStyle().getPaddingBottom();\r\n            Image icon = img;\r\n            if (icon.getWidth() > maxW || icon.getHeight() > maxH) {\r\n                icon = icon.scaledSmallerRatio(maxW, maxH);\r\n            }\r\n            lead.setIcon(icon);\r\n        } else {\r\n            lead.setText(localize(\"SignatureComponent.LeadText\", \"Press to sign\"));\r\n            lead.setIcon(null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getPreferredW",
	"Comment": "helper method to retrieve the preferred width of the component.",
	"Method": "int getPreferredW(){\r\n    return getPreferredSize().getWidth();\r\n}"
}, {
	"Path": "mondrian.olap.Util.appendArrays",
	"Comment": "concatenates one or more arrays.resulting array has same element type as first array. each arrays maybe empty, but must not be null.",
	"Method": "T[] appendArrays(T[] a0,T[] as){\r\n    int n = a0.length;\r\n    for (T[] a : as) {\r\n        n += a.length;\r\n    }\r\n    T[] copy = Util.copyOf(a0, n);\r\n    n = a0.length;\r\n    for (T[] a : as) {\r\n        System.arraycopy(a, 0, copy, n, a.length);\r\n        n += a.length;\r\n    }\r\n    return copy;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.isSmoothScrolling",
	"Comment": "indicates that scrolling through the component should work as an animation",
	"Method": "boolean isSmoothScrolling(){\r\n    return smoothScrolling && !disableSmoothScrolling;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractQueue.element",
	"Comment": "returns but does not remove the element at the head of the queue.",
	"Method": "E element(){\r\n    E o = peek();\r\n    if (null == o) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    return o;\r\n}"
}, {
	"Path": "android.support.v4.widget.CursorAdapter.convertToString",
	"Comment": "converts the cursor into a charsequence. subclasses should override thismethod to convert their results. the default implementation returns anempty string for null values or the default string representation ofthe value.",
	"Method": "CharSequence convertToString(Cursor cursor){\r\n    return cursor == null ? \"\" : cursor.toString();\r\n}"
}, {
	"Path": "mondrian.rolap.SqlStatement.execute",
	"Comment": "executes the current statement, and handles any sqlexception.",
	"Method": "void execute(){\r\n    assert state == State.FRESH : \"cannot re-execute\";\r\n    state = State.ACTIVE;\r\n    Counters.SQL_STATEMENT_EXECUTE_COUNT.incrementAndGet();\r\n    Counters.SQL_STATEMENT_EXECUTING_IDS.add(id);\r\n    String status = \"failed\";\r\n    Statement statement = null;\r\n    try {\r\n        locus.execution.checkCancelOrTimeout();\r\n        this.jdbcConnection = dataSource.getConnection();\r\n        querySemaphore.acquire();\r\n        haveSemaphore = true;\r\n        if (RolapUtil.SQL_LOGGER.isDebugEnabled()) {\r\n            StringBuilder sqllog = new StringBuilder();\r\n            sqllog.append(id).append(\": \").append(locus.component).append(\": executing sql [\");\r\n            if (sql.indexOf('\\n') >= 0) {\r\n                sqllog.append(\"\\n\");\r\n            }\r\n            sqllog.append(sql);\r\n            sqllog.append(']');\r\n            RolapUtil.SQL_LOGGER.debug(sqllog.toString());\r\n        }\r\n        RolapUtil.ExecuteQueryHook hook = RolapUtil.getHook();\r\n        if (hook != null) {\r\n            hook.onExecuteQuery(sql);\r\n        }\r\n        locus.execution.checkCancelOrTimeout();\r\n        startTimeNanos = System.nanoTime();\r\n        startTimeMillis = System.currentTimeMillis();\r\n        if (resultSetType < 0 || resultSetConcurrency < 0) {\r\n            statement = jdbcConnection.createStatement();\r\n        } else {\r\n            statement = jdbcConnection.createStatement(resultSetType, resultSetConcurrency);\r\n        }\r\n        if (maxRows > 0) {\r\n            statement.setMaxRows(maxRows);\r\n        }\r\n        if (getPurpose() != Purpose.CELL_SEGMENT) {\r\n            locus.execution.registerStatement(locus, statement);\r\n        } else {\r\n            if (callback != null) {\r\n                callback.apply(statement);\r\n            }\r\n        }\r\n        locus.getServer().getMonitor().sendEvent(new SqlStatementStartEvent(startTimeMillis, id, locus, sql, getPurpose(), getCellRequestCount()));\r\n        this.resultSet = statement.executeQuery(sql.replaceAll(\"\\\"\", \"\"));\r\n        this.state = State.ACTIVE;\r\n        if (firstRowOrdinal > 0) {\r\n            if (resultSetType == ResultSet.TYPE_FORWARD_ONLY) {\r\n                for (int i = 0; i < firstRowOrdinal; ++i) {\r\n                    if (!this.resultSet.next()) {\r\n                        this.state = State.DONE;\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                if (!this.resultSet.absolute(firstRowOrdinal)) {\r\n                    this.state = State.DONE;\r\n                }\r\n            }\r\n        }\r\n        long timeMillis = System.currentTimeMillis();\r\n        long timeNanos = System.nanoTime();\r\n        final long executeNanos = timeNanos - startTimeNanos;\r\n        final long executeMillis = executeNanos / 1000000;\r\n        Util.addDatabaseTime(executeMillis);\r\n        status = \", exec \" + executeMillis + \" ms\";\r\n        locus.getServer().getMonitor().sendEvent(new SqlStatementExecuteEvent(timeMillis, id, locus, sql, getPurpose(), executeNanos));\r\n        accessors.clear();\r\n        for (Type type : guessTypes()) {\r\n            accessors.add(createAccessor(accessors.size(), type));\r\n        }\r\n    } catch (Throwable e) {\r\n        status = \", failed (\" + e + \")\";\r\n        Util.close(null, statement, null);\r\n        throw handle(e);\r\n    } finally {\r\n        RolapUtil.SQL_LOGGER.debug(id + \": \" + status);\r\n        if (RolapUtil.LOGGER.isDebugEnabled()) {\r\n            RolapUtil.LOGGER.debug(locus.component + \": executing sql [\" + sql + \"]\" + status);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLFont.isCounterpart",
	"Comment": "checks if the given font is the counterpart of the current form in the sense of the given attribute",
	"Method": "boolean isCounterpart(int attribute,HTMLFont font){\r\n    switch(attribute) {\r\n        case BOLD:\r\n            return isBoldCounterpart(font);\r\n        case ITALIC:\r\n            return isItalicCounterpart(font);\r\n        case BIG:\r\n            return isBigCounterpart(font);\r\n        case SMALL:\r\n            return isSmallCounterpart(font);\r\n        default:\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Button.setButtonRippleEffectDefault",
	"Comment": "default value for the button ripple effect, this can be set with the theme constant buttonripplebool",
	"Method": "void setButtonRippleEffectDefault(boolean aButtonRippleEffectDefault){\r\n    buttonRippleEffectDefault = aButtonRippleEffectDefault;\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSParser.isWhiteSpace",
	"Comment": "checks if the specified character is a white space or not.exposed to packaage since used by htmlcomponent as well",
	"Method": "boolean isWhiteSpace(char ch){\r\n    return ((ch == ' ') || (ch == '\\n') || (ch == '\\t') || (ch == 10) || (ch == 13));\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.Storage.entryBufferSize",
	"Comment": "returns the entry buffer size.the entry buffer size dictates the number of entries that will be held in memory for read operationsat the tail of the log.",
	"Method": "int entryBufferSize(){\r\n    return entryBufferSize;\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.getDefaultDialogPosition",
	"Comment": "default screen orientation position for the upcoming dialog. by defaultthe dialog will be shown at hardcoded coordinates, this method allows us to pack the dialog appropriately in one of the border layout based locationssee borderlayout for futher details.",
	"Method": "String getDefaultDialogPosition(){\r\n    return defaultDialogPosition;\r\n}"
}, {
	"Path": "com.codename1.io.Util.setImplementation",
	"Comment": "invoked internally from display, this method is for internal use only",
	"Method": "void setImplementation(CodenameOneImplementation impl){\r\n    implInstance = impl;\r\n}"
}, {
	"Path": "android.support.v4.media.TransportMediator.stopPlaying",
	"Comment": "move the controller into the stopped state.this updates the remote controlclient to indicate it is stopped, and removes audio focus from the app.",
	"Method": "void stopPlaying(){\r\n    if (mController != null) {\r\n        mController.stopPlaying();\r\n    }\r\n    mCallbacks.onStop();\r\n    pushControllerState();\r\n    reportPlayingChanged();\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.ServerSessionContext.clearResults",
	"Comment": "clears command results up to the given sequence number.command output is removed from memory up to the given sequence number. additionally, since we know theclient received a response for all commands up to the given sequence number, command futures are removedfrom memory as well.",
	"Method": "ServerSessionContext clearResults(long sequence){\r\n    if (sequence > commandLowWaterMark) {\r\n        for (long i = commandLowWaterMark + 1; i <= sequence; i++) {\r\n            results.remove(i);\r\n            commandLowWaterMark = i;\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayeredLayout.setReferencePositionRight",
	"Comment": "sets the right inset reference position.only applicable if the top inset has a referencecomponent specified.",
	"Method": "LayeredLayout setReferencePositionRight(Component cmp,float position){\r\n    getOrCreateConstraint(cmp).right().referencePosition(position);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.calculateTouchCommandGridColumns",
	"Comment": "calculates the amount of columns to give to the touch commands within the grid",
	"Method": "int calculateTouchCommandGridColumns(Container grid){\r\n    int count = grid.getComponentCount();\r\n    int maxWidth = 10;\r\n    for (int iter = 0; iter < count; iter++) {\r\n        Component c = grid.getComponentAt(iter);\r\n        Style s = c.getUnselectedStyle();\r\n        maxWidth = Math.max(maxWidth, c.getPreferredW() + s.getHorizontalMargins());\r\n    }\r\n    return Math.max(2, Display.getInstance().getDisplayWidth() / maxWidth);\r\n}"
}, {
	"Path": "com.alibaba.citrus.service.requestcontext.parser.filter.HTMLInputFilter.filter",
	"Comment": "given a user submitted input string, filter out any invalid or restrictedhtml.",
	"Method": "String filter(String input,String filter,String input,boolean isHtml,String filter,String input,boolean isHtml){\r\n    return new FilterRunner(this).filter(input, isHtml);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getPreferredH",
	"Comment": "helper method to retrieve the preferred height of the component.",
	"Method": "int getPreferredH(){\r\n    return getPreferredSize().getHeight();\r\n}"
}, {
	"Path": "com.codename1.ui.Label.getShiftMillimeters",
	"Comment": "returns the number of millimeters that should be shifted in tickering",
	"Method": "int getShiftMillimeters(){\r\n    return shiftMillimeters;\r\n}"
}, {
	"Path": "java.io.FilterInputStream.close",
	"Comment": "closes this stream. this implementation closes the filtered stream.",
	"Method": "void close(){\r\n    in.close();\r\n}"
}, {
	"Path": "com.codename1.ui.Container.createAnimateLayoutFadeAndWait",
	"Comment": "animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation. this methodwaits until the operation is completed before returning",
	"Method": "ComponentAnimation createAnimateLayoutFadeAndWait(int duration,int startingOpacity){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.geom.GeneralPath.checkBuf",
	"Comment": "checks points and types buffer size to add pointcount points. ifnecessary realloc buffers to enlarge size.",
	"Method": "void checkBuf(int pointCount,boolean checkMove){\r\n    if (checkMove && typeSize == 0) {\r\n        throw new IndexOutOfBoundsException(\"First segment must be a moveto\");\r\n    }\r\n    if (typeSize == types.length) {\r\n        byte[] tmp = new byte[typeSize + BUFFER_CAPACITY];\r\n        System.arraycopy(types, 0, tmp, 0, typeSize);\r\n        types = tmp;\r\n    }\r\n    if (pointSize + pointCount > points.length) {\r\n        float[] tmp = new float[pointSize + Math.max(BUFFER_CAPACITY * 2, pointCount)];\r\n        System.arraycopy(points, 0, tmp, 0, pointSize);\r\n        points = tmp;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.payment.Receipt.getInternalId",
	"Comment": "an internal id that may be optionally used to link the receipt to an internalorder id.",
	"Method": "String getInternalId(){\r\n    return internalId;\r\n}"
}, {
	"Path": "com.codename1.ui.html.ResourceThreadQueue.incCSSCount",
	"Comment": "incereases the internal count of the number of pending css documents",
	"Method": "void incCSSCount(){\r\n    if (cssCount == -1) {\r\n        cssCount++;\r\n    }\r\n    cssCount++;\r\n}"
}, {
	"Path": "com.codename1.ads.AdsService.requestAd",
	"Comment": "schedule this service on the network thread and executes the request",
	"Method": "void requestAd(){\r\n    NetworkManager.getInstance().addToQueue(this);\r\n}"
}, {
	"Path": "org.conscrypt.CryptoUpcalls.getExternalProviders",
	"Comment": "finds providers that are not us that provide the requested algorithms.",
	"Method": "ArrayList<Provider> getExternalProviders(String algorithm){\r\n    ArrayList<Provider> providers = new ArrayList<Provider>(1);\r\n    for (Provider p : Security.getProviders(algorithm)) {\r\n        if (!Conscrypt.isConscrypt(p)) {\r\n            providers.add(p);\r\n        }\r\n    }\r\n    if (providers.isEmpty()) {\r\n        logger.warning(\"Could not find external provider for algorithm: \" + algorithm);\r\n    }\r\n    return providers;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.setTouchScreenDevice",
	"Comment": "indicates if this is a touch screen device that will return pen events,defaults to true if the device has pen events but can be overriden bythe developer.",
	"Method": "void setTouchScreenDevice(boolean touchScreen){\r\n    this.touchScreen = touchScreen;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.MigLayout.checkCache",
	"Comment": "check if something has changed and if so recreate it to the cachedobjects.",
	"Method": "void checkCache(Container parent){\r\n    if (parent == null) {\r\n        return;\r\n    }\r\n    if (dirty) {\r\n        grid = null;\r\n    }\r\n    cleanConstraintMaps(parent);\r\n    int mc = PlatformDefaults.getModCount();\r\n    if (lastModCount != mc) {\r\n        grid = null;\r\n        lastModCount = mc;\r\n    }\r\n    if (!lastWasInvalid) {\r\n        lastWasInvalid = true;\r\n        int hash = 0;\r\n        boolean resetLastInvalidOnParent = false;\r\n        for (ComponentWrapper wrapper : ccMap.keySet()) {\r\n            Object component = wrapper.getComponent();\r\n            if (component instanceof TextArea) {\r\n                resetLastInvalidOnParent = true;\r\n            }\r\n            hash ^= wrapper.getLayoutHashCode();\r\n            hash += 285134905;\r\n        }\r\n        if (resetLastInvalidOnParent) {\r\n            resetLastInvalidOnParent(parent);\r\n        }\r\n        if (hash != lastHash) {\r\n            grid = null;\r\n            lastHash = hash;\r\n        }\r\n        Dimension ps = new Dimension(parent.getWidth(), parent.getHeight());\r\n        if (lastInvalidSize == null || !lastInvalidSize.equals(ps)) {\r\n            grid = null;\r\n            lastInvalidSize = ps;\r\n        }\r\n    }\r\n    ContainerWrapper par = checkParent(parent);\r\n    setDebug(par, getDebugMillis() > 0);\r\n    if (grid == null) {\r\n        grid = new Grid(par, lc, rowSpecs, colSpecs, ccMap, callbackList);\r\n    }\r\n    dirty = false;\r\n}"
}, {
	"Path": "com.codename1.processing.AbstractEvaluator._evaluateLeftEqualsRight",
	"Comment": "this internal method simply makes a type safe call the the properabstract method based on the type of element passed.",
	"Method": "Object _evaluateLeftEqualsRight(Object element,String lvalue,String rvalue){\r\n    if (element instanceof List) {\r\n        return evaluateLeftEqualsRight((List) element, lvalue, rvalue);\r\n    } else {\r\n        return evaluateLeftEqualsRight((StructuredContent) element, lvalue, rvalue);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.android.util.Base64.decode",
	"Comment": "decodes base64 content using the supplied decodabet and returnsthe decoded byte array.",
	"Method": "byte[] decode(String s,byte[] decode,byte[] source,byte[] decode,byte[] source,int off,int len,byte[] decode,byte[] source,int off,int len,byte[] decodabet){\r\n    int len34 = len * 3 / 4;\r\n    byte[] outBuff = new byte[2 + len34];\r\n    int outBuffPosn = 0;\r\n    byte[] b4 = new byte[4];\r\n    int b4Posn = 0;\r\n    int i = 0;\r\n    byte sbiCrop = 0;\r\n    byte sbiDecode = 0;\r\n    for (i = 0; i < len; i++) {\r\n        sbiCrop = (byte) (source[i + off] & 0x7f);\r\n        sbiDecode = decodabet[sbiCrop];\r\n        if (sbiDecode >= WHITE_SPACE_ENC) {\r\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\r\n                if (sbiCrop == EQUALS_SIGN) {\r\n                    int bytesLeft = len - i;\r\n                    byte lastByte = (byte) (source[len - 1 + off] & 0x7f);\r\n                    if (b4Posn == 0 || b4Posn == 1) {\r\n                        throw new Base64DecoderException(\"invalid padding byte '=' at byte offset \" + i);\r\n                    } else if ((b4Posn == 3 && bytesLeft > 2) || (b4Posn == 4 && bytesLeft > 1)) {\r\n                        throw new Base64DecoderException(\"padding byte '=' falsely signals end of encoded value \" + \"at offset \" + i);\r\n                    } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {\r\n                        throw new Base64DecoderException(\"encoded value has invalid trailing byte\");\r\n                    }\r\n                    break;\r\n                }\r\n                b4[b4Posn++] = sbiCrop;\r\n                if (b4Posn == 4) {\r\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);\r\n                    b4Posn = 0;\r\n                }\r\n            }\r\n        } else {\r\n            throw new Base64DecoderException(\"Bad Base64 input character at \" + i + \": \" + source[i + off] + \"(decimal)\");\r\n        }\r\n    }\r\n    if (b4Posn != 0) {\r\n        if (b4Posn == 1) {\r\n            throw new Base64DecoderException(\"single trailing character at offset \" + (len - 1));\r\n        }\r\n        b4[b4Posn++] = EQUALS_SIGN;\r\n        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);\r\n    }\r\n    byte[] out = new byte[outBuffPosn];\r\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\r\n    return out;\r\n}"
}, {
	"Path": "io.atomix.copycat.protocol.KeepAliveRequest.builder",
	"Comment": "returns a keep alive request builder for an existing request.",
	"Method": "Builder builder(Builder builder,KeepAliveRequest request){\r\n    return new Builder(request);\r\n}"
}, {
	"Path": "com.codename1.ui.Transform.getTranslateZ",
	"Comment": "gets the z translation of this transformation.this value is only reliableif the transform is a translation transform.",
	"Method": "float getTranslateZ(){\r\n    return translateZ;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.setBackgroundImageDetermineSize",
	"Comment": "indicates if the bg image of a style should determine the minimum preferred size according to the theme",
	"Method": "void setBackgroundImageDetermineSize(boolean backgroundImageDetermineSize){\r\n    this.backgroundImageDetermineSize = backgroundImageDetermineSize;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.getClosestComponentTo",
	"Comment": "very useful for touch events or drop events that need approximation more than accuracy",
	"Method": "Component getClosestComponentTo(int x,int y){\r\n    int count = getComponentCount();\r\n    if (count == 0) {\r\n        return null;\r\n    }\r\n    Component closest = getComponentAt(0);\r\n    if (closest.contains(x, y)) {\r\n        return closest;\r\n    }\r\n    int distance = distanceToComponent(closest, x, y);\r\n    for (int iter = 1; iter < count; iter++) {\r\n        Component current = getComponentAt(iter);\r\n        if (current.contains(x, y)) {\r\n            return current;\r\n        }\r\n        int cd = distanceToComponent(current, x, y);\r\n        if (cd < distance) {\r\n            closest = current;\r\n            distance = cd;\r\n        }\r\n    }\r\n    return closest;\r\n}"
}, {
	"Path": "java.util.Collections.synchronizedCollection",
	"Comment": "returns a wrapper on the specified collection which synchronizes allaccess to the collection.",
	"Method": "Collection<T> synchronizedCollection(Collection<T> collection){\r\n    if (collection == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    return new SynchronizedCollection<T>(collection);\r\n}"
}, {
	"Path": "com.codename1.ui.Transform.getTranslateY",
	"Comment": "gets the y translation of this transformation.this value is only reliableif the transform is a translation transform.",
	"Method": "float getTranslateY(){\r\n    return translateY;\r\n}"
}, {
	"Path": "com.codename1.ui.Transform.getTranslateX",
	"Comment": "gets the x translation of this transformation.this value is only reliableif the transform is a translation transform.",
	"Method": "float getTranslateX(){\r\n    return translateX;\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudListModel.refresh",
	"Comment": "refreshes the list from the server, this method blocks the edt untilcompletion.",
	"Method": "void refresh(){\r\n    Vector vec = cache.getKeysInCache();\r\n    int s = vec.size();\r\n    Vector cld = new Vector();\r\n    for (int iter = 0; iter < s; iter++) {\r\n        Object key = vec.elementAt(iter);\r\n        Object val = cache.get(key);\r\n        if (val != null && val instanceof CloudObject) {\r\n            cld.addElement((CloudObject) val);\r\n        }\r\n    }\r\n    if (cld.size() > 0) {\r\n        CloudObject[] obj = new CloudObject[cld.size()];\r\n        cld.toArray(obj);\r\n        int response = CloudStorage.getInstance().refresh(obj);\r\n        if (response != CloudStorage.RETURN_CODE_SUCCESS) {\r\n            onError(new CloudException(response));\r\n        } else {\r\n            for (int iter = 0; iter < obj.length; iter++) {\r\n                cache.put(obj[iter].getCloudId(), obj[iter]);\r\n            }\r\n            modelListener.fireDataChangeEvent(0, getSize());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.performOperation",
	"Comment": "performs the actual network request on behalf of the network manager",
	"Method": "void performOperation(){\r\n    if (shouldStop()) {\r\n        return;\r\n    }\r\n    if (cacheMode == CachingMode.OFFLINE) {\r\n        InputStream is = getCachedData();\r\n        if (is != null) {\r\n            readResponse(is);\r\n            Util.cleanup(is);\r\n        } else {\r\n            responseCode = 404;\r\n            throw new IOException(\"File unavilable in cache\");\r\n        }\r\n        return;\r\n    }\r\n    CodenameOneImplementation impl = Util.getImplementation();\r\n    Object connection = null;\r\n    input = null;\r\n    output = null;\r\n    redirecting = false;\r\n    try {\r\n        String actualUrl = createRequestURL();\r\n        if (timeout > 0) {\r\n            connection = impl.connect(actualUrl, isReadRequest(), isPost() || isWriteRequest(), timeout);\r\n        } else {\r\n            connection = impl.connect(actualUrl, isReadRequest(), isPost() || isWriteRequest());\r\n        }\r\n        if (shouldStop()) {\r\n            return;\r\n        }\r\n        initConnection(connection);\r\n        if (httpMethod != null) {\r\n            impl.setHttpMethod(connection, httpMethod);\r\n        }\r\n        if (isCookiesEnabled()) {\r\n            Vector v = impl.getCookiesForURL(actualUrl);\r\n            if (v != null) {\r\n                int c = v.size();\r\n                if (c > 0) {\r\n                    StringBuilder cookieStr = new StringBuilder();\r\n                    Cookie first = (Cookie) v.elementAt(0);\r\n                    cookieSent(first);\r\n                    cookieStr.append(first.getName());\r\n                    cookieStr.append(\"=\");\r\n                    cookieStr.append(first.getValue());\r\n                    for (int iter = 1; iter < c; iter++) {\r\n                        Cookie current = (Cookie) v.elementAt(iter);\r\n                        cookieStr.append(\";\");\r\n                        cookieStr.append(current.getName());\r\n                        cookieStr.append(\"=\");\r\n                        cookieStr.append(current.getValue());\r\n                        cookieSent(current);\r\n                    }\r\n                    impl.setHeader(connection, cookieHeader, initCookieHeader(cookieStr.toString()));\r\n                } else {\r\n                    String s = initCookieHeader(null);\r\n                    if (s != null) {\r\n                        impl.setHeader(connection, cookieHeader, s);\r\n                    }\r\n                }\r\n            } else {\r\n                String s = initCookieHeader(null);\r\n                if (s != null) {\r\n                    impl.setHeader(connection, cookieHeader, s);\r\n                }\r\n            }\r\n        }\r\n        if (checkSSLCertificates && canGetSSLCertificates()) {\r\n            sslCertificates = getSSLCertificatesImpl(connection, url);\r\n            checkSSLCertificates(sslCertificates);\r\n            if (shouldStop()) {\r\n                return;\r\n            }\r\n        }\r\n        if (isWriteRequest()) {\r\n            progress = NetworkEvent.PROGRESS_TYPE_OUTPUT;\r\n            output = impl.openOutputStream(connection);\r\n            if (shouldStop()) {\r\n                return;\r\n            }\r\n            if (NetworkManager.getInstance().hasProgressListeners() && output instanceof BufferedOutputStream) {\r\n                ((BufferedOutputStream) output).setProgressListener(this);\r\n            }\r\n            if (requestBody != null) {\r\n                if (shouldWriteUTFAsGetBytes()) {\r\n                    output.write(requestBody.getBytes(\"UTF-8\"));\r\n                } else {\r\n                    OutputStreamWriter w = new OutputStreamWriter(output, \"UTF-8\");\r\n                    w.write(requestBody);\r\n                }\r\n            } else {\r\n                buildRequestBody(output);\r\n            }\r\n            if (shouldStop()) {\r\n                return;\r\n            }\r\n            if (output instanceof BufferedOutputStream) {\r\n                ((BufferedOutputStream) output).flushBuffer();\r\n                if (shouldStop()) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        timeSinceLastUpdate = System.currentTimeMillis();\r\n        responseCode = impl.getResponseCode(connection);\r\n        if (isCookiesEnabled()) {\r\n            String[] cookies = impl.getHeaderFields(\"Set-Cookie\", connection);\r\n            if (cookies != null && cookies.length > 0) {\r\n                ArrayList cook = new ArrayList();\r\n                int clen = cookies.length;\r\n                for (int iter = 0; iter < clen; iter++) {\r\n                    Cookie coo = parseCookieHeader(cookies[iter]);\r\n                    if (coo != null) {\r\n                        cook.add(coo);\r\n                        cookieReceived(coo);\r\n                    }\r\n                }\r\n                impl.addCookie((Cookie[]) cook.toArray(new Cookie[cook.size()]));\r\n            }\r\n        }\r\n        if (responseCode == 304 && cacheMode != CachingMode.OFF) {\r\n            cacheUnmodified();\r\n            return;\r\n        }\r\n        if (responseCode - 200 < 0 || responseCode - 200 > 100) {\r\n            readErrorCodeHeaders(connection);\r\n            if (followRedirects && (responseCode == 301 || responseCode == 302 || responseCode == 303 || responseCode == 307)) {\r\n                String uri = impl.getHeaderField(\"location\", connection);\r\n                if (!(uri.startsWith(\"http://\") || uri.startsWith(\"https://\"))) {\r\n                    url = Util.relativeToAbsolute(url, uri);\r\n                } else {\r\n                    url = uri;\r\n                }\r\n                if (requestArguments != null && url.indexOf('?') > -1) {\r\n                    requestArguments.clear();\r\n                }\r\n                if ((responseCode == 302 || responseCode == 303)) {\r\n                    if (this.post && shouldConvertPostToGetOnRedirect()) {\r\n                        this.post = false;\r\n                        setWriteRequest(false);\r\n                    }\r\n                }\r\n                impl.cleanup(output);\r\n                impl.cleanup(connection);\r\n                connection = null;\r\n                output = null;\r\n                if (!onRedirect(url)) {\r\n                    redirecting = true;\r\n                    retry();\r\n                }\r\n                return;\r\n            }\r\n            responseErrorMessge = impl.getResponseMessage(connection);\r\n            handleErrorResponseCode(responseCode, responseErrorMessge);\r\n            if (!isReadResponseForErrors()) {\r\n                return;\r\n            }\r\n        }\r\n        responseContentType = getHeader(connection, \"Content-Type\");\r\n        if (cacheMode == CachingMode.SMART || cacheMode == CachingMode.MANUAL) {\r\n            String last = getHeader(connection, \"Last-Modified\");\r\n            String etag = getHeader(connection, \"ETag\");\r\n            Preferences.set(\"cn1MSince\" + createRequestURL(), last);\r\n            Preferences.set(\"cn1Etag\" + createRequestURL(), etag);\r\n        }\r\n        readHeaders(connection);\r\n        contentLength = impl.getContentLength(connection);\r\n        timeSinceLastUpdate = System.currentTimeMillis();\r\n        progress = NetworkEvent.PROGRESS_TYPE_INPUT;\r\n        if (isReadRequest()) {\r\n            input = impl.openInputStream(connection);\r\n            if (shouldStop()) {\r\n                return;\r\n            }\r\n            if (input instanceof BufferedInputStream) {\r\n                if (NetworkManager.getInstance().hasProgressListeners()) {\r\n                    ((BufferedInputStream) input).setProgressListener(this);\r\n                }\r\n                ((BufferedInputStream) input).setYield(getYield());\r\n            }\r\n            if (!post && cacheMode == CachingMode.SMART && destinationFile == null && destinationStorage == null) {\r\n                byte[] d = Util.readInputStream(input);\r\n                OutputStream os = FileSystemStorage.getInstance().openOutputStream(getCacheFileName());\r\n                os.write(d);\r\n                os.close();\r\n                readResponse(new ByteArrayInputStream(d));\r\n            } else {\r\n                readResponse(input);\r\n            }\r\n            if (shouldAutoCloseResponse()) {\r\n                input.close();\r\n            }\r\n            input = null;\r\n        }\r\n    } finally {\r\n        impl.cleanup(output);\r\n        impl.cleanup(input);\r\n        impl.cleanup(connection);\r\n        timeSinceLastUpdate = -1;\r\n        input = null;\r\n        output = null;\r\n        connection = null;\r\n    }\r\n    if (!isKilled()) {\r\n        Display.getInstance().callSerially(new Runnable() {\r\n            public void run() {\r\n                postResponse();\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.performOperation",
	"Comment": "performs the actual network request on behalf of the network manager",
	"Method": "void performOperation(){\r\n    postResponse();\r\n}"
}, {
	"Path": "com.codename1.ui.Font.getStyle",
	"Comment": "return optional operation returning the font style for system fonts",
	"Method": "int getStyle(){\r\n    return Display.impl.getStyle(font);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getDisabledStyle",
	"Comment": "returns the component style for the disabled state allowing us to manipulatethe look of the component when its disabled",
	"Method": "Style getDisabledStyle(){\r\n    if (disabledStyle == null) {\r\n        if (hasInlineDisabledStyle()) {\r\n            disabledStyle = getUIManager().parseComponentCustomStyle(getInlineStylesTheme(), getUIID(), getInlineStylesUIID(), \"dis\", getInlineDisabledStyleStrings());\r\n        } else {\r\n            disabledStyle = getUIManager().getComponentCustomStyle(getUIID(), \"dis\");\r\n        }\r\n        disabledStyle.addStyleListener(this);\r\n        if (disabledStyle.getBgPainter() == null) {\r\n            disabledStyle.setBgPainter(new BGPainter());\r\n        }\r\n    }\r\n    return disabledStyle;\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.createCommandComponent",
	"Comment": "creates the component containing the commands within the given vectorused for showing the menu dialog, this method calls the createcommandlistmethod by default however it allows more elaborate menu creation.",
	"Method": "Component createCommandComponent(Vector commands){\r\n    UIManager manager = parent.getUIManager();\r\n    if (manager.getLookAndFeel().isTouchMenus()) {\r\n        Container menu = new Container();\r\n        menu.setScrollableY(true);\r\n        for (int iter = 0; iter < commands.size(); iter++) {\r\n            Command c = (Command) commands.elementAt(iter);\r\n            menu.addComponent(createTouchCommandButton(c));\r\n        }\r\n        if (!manager.isThemeConstant(\"touchCommandFlowBool\", false)) {\r\n            int cols = calculateTouchCommandGridColumns(menu);\r\n            if (cols > getCommandCount()) {\r\n                cols = getCommandCount();\r\n            }\r\n            int rows = Math.max(1, getCommandCount() / cols + (getCommandCount() % cols != 0 ? 1 : 0));\r\n            if (rows > 1) {\r\n                int remainingColumns = (rows * cols) % getCommandCount();\r\n                int newCols = cols;\r\n                int newRows = rows;\r\n                while (remainingColumns != 0 && remainingColumns > 1 && newCols >= 2) {\r\n                    newCols--;\r\n                    newRows = Math.max(1, getCommandCount() / newCols + (getCommandCount() % newCols != 0 ? 1 : 0));\r\n                    if (newRows != rows) {\r\n                        break;\r\n                    }\r\n                    remainingColumns = (newRows * newCols) % getCommandCount();\r\n                }\r\n                if (newRows == rows) {\r\n                    cols = newCols;\r\n                    rows = newRows;\r\n                }\r\n            }\r\n            GridLayout g = new GridLayout(rows, cols);\r\n            g.setFillLastRow(manager.isThemeConstant(\"touchCommandFillBool\", true));\r\n            menu.setLayout(g);\r\n        } else {\r\n            ((FlowLayout) menu.getLayout()).setFillRows(true);\r\n        }\r\n        menu.setPreferredW(Display.getInstance().getDisplayWidth());\r\n        return menu;\r\n    }\r\n    return createCommandList(commands);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.PriorityQueue.iterator",
	"Comment": "gets the iterator of the priority queue, which will not return elementsin any specified ordering.",
	"Method": "Iterator<E> iterator(){\r\n    return new PriorityIterator();\r\n}"
}, {
	"Path": "com.codename1.processing.XMLContent._asStructuredContentArray",
	"Comment": "convert from an array of element objects to an array of structuredcontent objects.",
	"Method": "List _asStructuredContentArray(List array){\r\n    List children;\r\n    if (array instanceof Vector) {\r\n        children = new Vector();\r\n    } else {\r\n        children = new ArrayList();\r\n    }\r\n    for (Iterator elements = array.iterator(); elements.hasNext(); ) {\r\n        children.add(new XMLContent((Element) elements.next()));\r\n    }\r\n    return children;\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.findIndex",
	"Comment": "returns the index where the key is found at, or the index of the nextempty spot if the key is not found in this table.",
	"Method": "int findIndex(Object key,Object[] array){\r\n    int length = array.length;\r\n    int index = getModuloHash(key, length);\r\n    int last = (index + length - 2) % length;\r\n    while (index != last) {\r\n        if (array[index] == key || (array[index] == null)) {\r\n            break;\r\n        }\r\n        index = (index + 2) % length;\r\n    }\r\n    return index;\r\n}"
}, {
	"Path": "com.codename1.io.NetworkManager.getAPName",
	"Comment": "returns the user displayable name for the given access point",
	"Method": "String getAPName(String id){\r\n    return Util.getImplementation().getAPName(id);\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.getAlbum",
	"Comment": "gets a album from a albumidthis is a sync method it will block until a response it returned",
	"Method": "void getAlbum(String albumId,Album album,ActionListener callback,Album getAlbum,String albumId,boolean needAuth){\r\n    final Album album = new Album();\r\n    final Vector err = new Vector();\r\n    addResponseCodeListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            NetworkEvent ne = (NetworkEvent) evt;\r\n            err.addElement(ne);\r\n            removeResponseCodeListener(this);\r\n        }\r\n    });\r\n    getFaceBookObject(albumId, new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            Vector v = (Vector) ((NetworkEvent) evt).getMetaData();\r\n            Hashtable t = (Hashtable) v.elementAt(0);\r\n            album.copy(t);\r\n        }\r\n    }, needAuth, false);\r\n    if (err.size() > 0) {\r\n        throw new IOException(((NetworkEvent) err.elementAt(0)).getResponseCode() + \": \" + ((NetworkEvent) err.elementAt(0)).getMessage());\r\n    }\r\n    return album;\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.getAlbum",
	"Comment": "gets a album from a albumidthis is a sync method it will block until a response it returned",
	"Method": "void getAlbum(String albumId,Album album,ActionListener callback,Album getAlbum,String albumId,boolean needAuth){\r\n    NetworkEvent ne = (NetworkEvent) evt;\r\n    err.addElement(ne);\r\n    removeResponseCodeListener(this);\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.getAlbum",
	"Comment": "gets a album from a albumidthis is a sync method it will block until a response it returned",
	"Method": "void getAlbum(String albumId,Album album,ActionListener callback,Album getAlbum,String albumId,boolean needAuth){\r\n    Vector v = (Vector) ((NetworkEvent) evt).getMetaData();\r\n    Hashtable t = (Hashtable) v.elementAt(0);\r\n    album.copy(t);\r\n}"
}, {
	"Path": "com.codename1.processing.MapContent._asStructuredContentArray",
	"Comment": "copy an array of map elements to an array of structuredcontent nodes,also linking the parent.",
	"Method": "List _asStructuredContentArray(List array){\r\n    if (array == null) {\r\n        return null;\r\n    }\r\n    List children;\r\n    if (array instanceof java.util.Vector) {\r\n        children = new java.util.Vector();\r\n    } else {\r\n        children = new ArrayList();\r\n    }\r\n    for (Iterator elements = array.iterator(); elements.hasNext(); ) {\r\n        Object o = elements.next();\r\n        if (o instanceof Map) {\r\n            children.add(new MapContent((Map) o, this));\r\n        } else if (o instanceof String) {\r\n            children.add(new MapContent(o, this));\r\n        }\r\n    }\r\n    return children;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setLabelForComponent",
	"Comment": "allows us to indicate the label associated with this component thus providingvisual feedback related for this component e.g. starting the ticker when the component receives focus.",
	"Method": "void setLabelForComponent(Label componentLabel){\r\n    this.componentLabel = componentLabel;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isTablet",
	"Comment": "indicates whether the device is a tablet, notice that this is often a guess",
	"Method": "boolean isTablet(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.util.EventDispatcher.fireFocus",
	"Comment": "fires the event safely on the edt without risk of concurrency errors",
	"Method": "void fireFocus(Component c){\r\n    if (listeners == null || listeners.size() == 0) {\r\n        return;\r\n    }\r\n    boolean isEdt = Display.getInstance().isEdt();\r\n    if (isEdt && listeners.size() == 1) {\r\n        FocusListener a = (FocusListener) listeners.get(0);\r\n        if (c.hasFocus()) {\r\n            a.focusGained(c);\r\n        } else {\r\n            a.focusLost(c);\r\n        }\r\n        return;\r\n    }\r\n    FocusListener[] array;\r\n    synchronized (this) {\r\n        array = new FocusListener[listeners.size()];\r\n        int alen = array.length;\r\n        for (int iter = 0; iter < alen; iter++) {\r\n            array[iter] = (FocusListener) listeners.get(iter);\r\n        }\r\n    }\r\n    if (isEdt) {\r\n        fireFocusSync(array, c);\r\n    } else {\r\n        focusListenerArray = true;\r\n        Runnable cl = new CallbackClass(array, c);\r\n        if (blocking) {\r\n            Display.getInstance().callSeriallyAndWait(cl);\r\n        } else {\r\n            Display.getInstance().callSerially(cl);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.NetworkManager.shutdown",
	"Comment": "shuts down the network thread, this will trigger failures if you have network requests",
	"Method": "void shutdown(){\r\n    running = false;\r\n    if (networkThreads != null) {\r\n        for (NetworkThread n : networkThreads) {\r\n            n.stopped = true;\r\n        }\r\n    }\r\n    networkThreads = null;\r\n    synchronized (LOCK) {\r\n        LOCK.notifyAll();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Image.isSVG",
	"Comment": "indicates if this image represents an svg file or a bitmap file",
	"Method": "boolean isSVG(){\r\n    return svgData != null;\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.findTextAreaText",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "TextArea findTextAreaText(String text){\r\n    return TestUtils.findTextAreaText(text);\r\n}"
}, {
	"Path": "com.codename1.io.tar.TarEntry.isDirectory",
	"Comment": "checks if the org.xeustechnologies.jtar entry is a directory",
	"Method": "boolean isDirectory(){\r\n    if (this.file != null)\r\n        return FileSystemStorage.getInstance().isDirectory(this.file);\r\n    if (this.header != null) {\r\n        if (this.header.linkFlag == TarHeader.LF_DIR)\r\n            return true;\r\n        if (this.header.name.toString().endsWith(\"/\"))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.documentReady",
	"Comment": "called internally after both reading and parsing of the html document has completed",
	"Method": "void documentReady(DocumentInfo docInfo,HTMLElement newDocument){\r\n    this.pageURL = null;\r\n    if (docInfo != null) {\r\n        this.pageURL = docInfo.getUrl();\r\n    }\r\n    cleanup();\r\n    document = newDocument;\r\n    if (supressExceptions) {\r\n        try {\r\n            rebuildPage();\r\n        } catch (Throwable t) {\r\n            t.printStackTrace();\r\n            return;\r\n        }\r\n    } else {\r\n        rebuildPage();\r\n    }\r\n    if ((!cancelled) || (cancelledCaught)) {\r\n        Display.getInstance().callSerially(new Runnable() {\r\n            public void run() {\r\n                if (threadQueue.getCSSCount() == -1) {\r\n                    displayPage();\r\n                }\r\n                if (threadQueue.getQueueSize() == 0) {\r\n                    setPageStatus(HTMLCallback.STATUS_COMPLETED);\r\n                } else {\r\n                    threadQueue.startRunning();\r\n                }\r\n                if (pageURL != null) {\r\n                    int hash = pageURL.indexOf('#');\r\n                    if ((hash != -1) && (pageURL.length() > hash + 1)) {\r\n                        String anchorName = pageURL.substring(hash + 1);\r\n                        goToAnchor(anchorName);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    } else {\r\n        cancelled = false;\r\n        InputStreamReader isr = getStream(\"Page loading cancelled by user\", null);\r\n        HTMLElement newDoc = parser.parseHTML(isr);\r\n        documentReady(docInfo, newDoc);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.documentReady",
	"Comment": "called internally after both reading and parsing of the html document has completed",
	"Method": "void documentReady(DocumentInfo docInfo,HTMLElement newDocument){\r\n    if (threadQueue.getCSSCount() == -1) {\r\n        displayPage();\r\n    }\r\n    if (threadQueue.getQueueSize() == 0) {\r\n        setPageStatus(HTMLCallback.STATUS_COMPLETED);\r\n    } else {\r\n        threadQueue.startRunning();\r\n    }\r\n    if (pageURL != null) {\r\n        int hash = pageURL.indexOf('#');\r\n        if ((hash != -1) && (pageURL.length() > hash + 1)) {\r\n            String anchorName = pageURL.substring(hash + 1);\r\n            goToAnchor(anchorName);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.support.v4.widget.ViewDragHelper.clampMag",
	"Comment": "clamp the magnitude of value for absmin and absmax.if the value is below the minimum, it will be clamped to zero.if the value is above the maximum, it will be clamped to the maximum.",
	"Method": "int clampMag(int value,int absMin,int absMax,float clampMag,float value,float absMin,float absMax){\r\n    final float absValue = Math.abs(value);\r\n    if (absValue < absMin)\r\n        return 0;\r\n    if (absValue > absMax)\r\n        return value > 0 ? absMax : -absMax;\r\n    return value;\r\n}"
}, {
	"Path": "com.codename1.ui.validation.Validator.isShowErrorMessageForFocusedComponent",
	"Comment": "indicates whether an error message should be shown for the focused component",
	"Method": "boolean isShowErrorMessageForFocusedComponent(){\r\n    return showErrorMessageForFocusedComponent;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.drawLabelComponent",
	"Comment": "draws a label on the given graphics context, this method allows optimizing the very common drawing operationusing platform native code",
	"Method": "void drawLabelComponent(Object nativeGraphics,int cmpX,int cmpY,int cmpHeight,int cmpWidth,Style style,String text,Object icon,Object stateIcon,int preserveSpaceForState,int gap,boolean rtl,boolean isOppositeSide,int textPosition,int stringWidth,boolean isTickerRunning,int tickerShiftText,boolean endsWith3Points,int valign){\r\n    Font font = style.getFont();\r\n    Object nativeFont = font.getNativeFont();\r\n    setNativeFont(nativeGraphics, nativeFont);\r\n    setColor(nativeGraphics, style.getFgColor());\r\n    int iconWidth = 0;\r\n    int iconHeight = 0;\r\n    if (icon != null) {\r\n        iconWidth = getImageWidth(icon);\r\n        iconHeight = getImageHeight(icon);\r\n    }\r\n    int textDecoration = style.getTextDecoration();\r\n    int stateIconSize = 0;\r\n    int stateIconYPosition = 0;\r\n    int leftPadding = style.getPaddingLeft(rtl);\r\n    int rightPadding = style.getPaddingRight(rtl);\r\n    int topPadding = style.getPaddingTop();\r\n    int bottomPadding = style.getPaddingBottom();\r\n    int fontHeight = 0;\r\n    if (text == null) {\r\n        text = \"\";\r\n    }\r\n    if (text.length() > 0) {\r\n        fontHeight = font.getHeight();\r\n    }\r\n    if (stateIcon != null) {\r\n        stateIconSize = getImageWidth(stateIcon);\r\n        stateIconYPosition = cmpY + topPadding + (cmpHeight - topPadding - bottomPadding) / 2 - stateIconSize / 2;\r\n        int tX = cmpX;\r\n        if (isOppositeSide) {\r\n            if (rtl) {\r\n                tX += leftPadding;\r\n            } else {\r\n                tX = tX + cmpWidth - leftPadding - stateIconSize;\r\n            }\r\n            cmpWidth -= leftPadding - stateIconSize;\r\n        } else {\r\n            preserveSpaceForState = stateIconSize + gap;\r\n            if (rtl) {\r\n                tX = tX + cmpWidth - leftPadding - stateIconSize;\r\n            } else {\r\n                tX += leftPadding;\r\n            }\r\n        }\r\n        drawImage(nativeGraphics, stateIcon, tX, stateIconYPosition);\r\n    }\r\n    int x = cmpX + leftPadding + preserveSpaceForState;\r\n    int y = cmpY + topPadding;\r\n    int align = reverseAlignForBidi(rtl, style.getAlignment());\r\n    int textPos = reverseAlignForBidi(rtl, textPosition);\r\n    switch(align) {\r\n        case Component.LEFT:\r\n            switch(textPos) {\r\n                case Label.LEFT:\r\n                case Label.RIGHT:\r\n                    y = y + (cmpHeight - (topPadding + bottomPadding + Math.max(((icon != null) ? iconHeight : 0), fontHeight))) / 2;\r\n                    break;\r\n                case Label.BOTTOM:\r\n                case Label.TOP:\r\n                    y = y + (cmpHeight - (topPadding + bottomPadding + ((icon != null) ? iconHeight + gap : 0) + fontHeight)) / 2;\r\n                    break;\r\n            }\r\n            break;\r\n        case Component.CENTER:\r\n            switch(textPos) {\r\n                case Label.LEFT:\r\n                case Label.RIGHT:\r\n                    x = x + (cmpWidth - (preserveSpaceForState + leftPadding + rightPadding + ((icon != null) ? iconWidth + gap : 0) + stringWidth)) / 2;\r\n                    x = Math.max(x, cmpX + leftPadding + preserveSpaceForState);\r\n                    y = y + (cmpHeight - (topPadding + bottomPadding + Math.max(((icon != null) ? iconHeight : 0), fontHeight))) / 2;\r\n                    break;\r\n                case Label.BOTTOM:\r\n                case Label.TOP:\r\n                    x = x + (cmpWidth - (preserveSpaceForState + leftPadding + rightPadding + Math.max(((icon != null) ? iconWidth + gap : 0), stringWidth))) / 2;\r\n                    x = Math.max(x, cmpX + leftPadding + preserveSpaceForState);\r\n                    y = y + (cmpHeight - (topPadding + bottomPadding + ((icon != null) ? iconHeight + gap : 0) + fontHeight)) / 2;\r\n                    break;\r\n            }\r\n            break;\r\n        case Component.RIGHT:\r\n            switch(textPos) {\r\n                case Label.LEFT:\r\n                case Label.RIGHT:\r\n                    x = cmpX + cmpWidth - rightPadding - (((icon != null) ? (iconWidth + gap) : 0) + stringWidth);\r\n                    if (rtl) {\r\n                        x = Math.max(x - preserveSpaceForState, cmpX + leftPadding);\r\n                    } else {\r\n                        x = Math.max(x, cmpX + leftPadding + preserveSpaceForState);\r\n                    }\r\n                    y = y + (cmpHeight - (topPadding + bottomPadding + Math.max(((icon != null) ? iconHeight : 0), fontHeight))) / 2;\r\n                    break;\r\n                case Label.BOTTOM:\r\n                case Label.TOP:\r\n                    x = cmpX + cmpWidth - rightPadding - (Math.max(((icon != null) ? (iconWidth) : 0), stringWidth));\r\n                    x = Math.max(x, cmpX + leftPadding + preserveSpaceForState);\r\n                    y = y + (cmpHeight - (topPadding + bottomPadding + ((icon != null) ? iconHeight + gap : 0) + fontHeight)) / 2;\r\n                    break;\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    int textSpaceW = cmpWidth - rightPadding - leftPadding;\r\n    if (icon != null && (textPos == Label.RIGHT || textPos == Label.LEFT)) {\r\n        textSpaceW = textSpaceW - iconWidth;\r\n    }\r\n    if (stateIcon != null) {\r\n        textSpaceW = textSpaceW - stateIconSize;\r\n    } else {\r\n        textSpaceW = textSpaceW - preserveSpaceForState;\r\n    }\r\n    if (icon == null) {\r\n        drawLabelString(nativeGraphics, nativeFont, text, x, y, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, stringWidth, fontHeight);\r\n    } else {\r\n        int strWidth = stringWidth;\r\n        int iconStringWGap;\r\n        int iconStringHGap;\r\n        switch(textPos) {\r\n            case Label.LEFT:\r\n                if (iconHeight > fontHeight) {\r\n                    iconStringHGap = (iconHeight - fontHeight) / 2;\r\n                    strWidth = drawLabelStringValign(nativeGraphics, nativeFont, text, x, y, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, strWidth, iconStringHGap, iconHeight, fontHeight, valign);\r\n                    drawImage(nativeGraphics, icon, x + strWidth + gap, y);\r\n                } else {\r\n                    iconStringHGap = (fontHeight - iconHeight) / 2;\r\n                    strWidth = drawLabelString(nativeGraphics, nativeFont, text, x, y, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, strWidth, fontHeight);\r\n                    drawImage(nativeGraphics, icon, x + strWidth + gap, y + iconStringHGap);\r\n                }\r\n                break;\r\n            case Label.RIGHT:\r\n                if (iconHeight > fontHeight) {\r\n                    iconStringHGap = (iconHeight - fontHeight) / 2;\r\n                    drawImage(nativeGraphics, icon, x, y);\r\n                    drawLabelStringValign(nativeGraphics, nativeFont, text, x + iconWidth + gap, y, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, stringWidth, iconStringHGap, iconHeight, fontHeight, valign);\r\n                } else {\r\n                    iconStringHGap = (fontHeight - iconHeight) / 2;\r\n                    drawImage(nativeGraphics, icon, x, y + iconStringHGap);\r\n                    drawLabelString(nativeGraphics, nativeFont, text, x + iconWidth + gap, y, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, stringWidth, fontHeight);\r\n                }\r\n                break;\r\n            case Label.BOTTOM:\r\n                if (iconWidth > strWidth) {\r\n                    iconStringWGap = (iconWidth - strWidth) / 2;\r\n                    drawImage(nativeGraphics, icon, x, y);\r\n                    drawLabelString(nativeGraphics, nativeFont, text, x + iconStringWGap, y + iconHeight + gap, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, stringWidth, fontHeight);\r\n                } else {\r\n                    iconStringWGap = (Math.min(strWidth, textSpaceW) - iconWidth) / 2;\r\n                    drawImage(nativeGraphics, icon, x + iconStringWGap, y);\r\n                    drawLabelString(nativeGraphics, nativeFont, text, x, y + iconHeight + gap, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, stringWidth, fontHeight);\r\n                }\r\n                break;\r\n            case Label.TOP:\r\n                if (iconWidth > strWidth) {\r\n                    iconStringWGap = (iconWidth - strWidth) / 2;\r\n                    drawLabelString(nativeGraphics, nativeFont, text, x + iconStringWGap, y, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, stringWidth, fontHeight);\r\n                    drawImage(nativeGraphics, icon, x, y + fontHeight + gap);\r\n                } else {\r\n                    iconStringWGap = (Math.min(strWidth, textSpaceW) - iconWidth) / 2;\r\n                    drawLabelString(nativeGraphics, nativeFont, text, x, y, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, stringWidth, fontHeight);\r\n                    drawImage(nativeGraphics, icon, x + iconStringWGap, y + fontHeight + gap);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.Segment.validIndex",
	"Comment": "returns a boolean value indicating whether the given index is within the range of the segment.",
	"Method": "boolean validIndex(long index){\r\n    assertSegmentOpen();\r\n    return !isEmpty() && index >= firstIndex() && index <= lastIndex();\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.makers.FixedSizeThumbnailMaker.keepAspectRatio",
	"Comment": "sets whether or not the thumbnail is to maintain the aspect ratio of\tthe original image.",
	"Method": "FixedSizeThumbnailMaker keepAspectRatio(boolean keep){\r\n    if (ready.isSet(PARAM_KEEP_RATIO)) {\r\n        throw new IllegalStateException(\"Whether to keep the aspect ratio has already been set.\");\r\n    }\r\n    this.keepRatio = keep;\r\n    ready.set(PARAM_KEEP_RATIO);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.processing.AbstractEvaluator._evaluateLeftContainsRight",
	"Comment": "this internal method simply makes a type safe call the the properabstract method based on the type of element passed.",
	"Method": "Object _evaluateLeftContainsRight(Object element,String lvalue,String rvalue){\r\n    if (element instanceof List) {\r\n        return evaluateLeftContainsRight((List) element, lvalue, rvalue);\r\n    } else {\r\n        return evaluateLeftContainsRight((StructuredContent) element, lvalue, rvalue);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.properties.MapProperty.set",
	"Comment": "sets the property value and potentially fires a change event",
	"Method": "K set(T1 key,T2 v){\r\n    value.put(key, v);\r\n    firePropertyChanged();\r\n    return (K) parent.parent;\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSEngine.setWordSpacingRecursive",
	"Comment": "sets the given spacing to all words in this component and its children",
	"Method": "void setWordSpacingRecursive(Component cmp,int spacing){\r\n    if (cmp instanceof Container) {\r\n        Container cont = (Container) cmp;\r\n        for (int i = 0; i < cont.getComponentCount(); i++) {\r\n            setWordSpacingRecursive(cont.getComponentAt(i), spacing);\r\n        }\r\n    } else if ((cmp instanceof Label) && (cmp.getParent().getComponentIndex(cmp) < cmp.getParent().getComponentCount() - 1)) {\r\n        cmp.getUnselectedStyle().setPadding(Component.RIGHT, spacing);\r\n        if (cmp instanceof HTMLLink) {\r\n            cmp.getSelectedStyle().setPadding(Component.RIGHT, spacing);\r\n            ((HTMLLink) cmp).getPressedStyle().setPadding(Component.RIGHT, spacing);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GroupLayout.setLayoutStyle",
	"Comment": "sets the layoutstyle this grouplayout is to use. a value of null canbe used to indicate the shared instance of layoutstyle should be used.",
	"Method": "void setLayoutStyle(LayoutStyle layoutStyle){\r\n    this.layoutStyle = layoutStyle;\r\n    invalidateHost();\r\n}"
}, {
	"Path": "com.codename1.ui.util.EventDispatcher.hasListeners",
	"Comment": "returns true if the event dispatcher has registered listeners",
	"Method": "boolean hasListeners(){\r\n    return listeners != null && listeners.size() > 0;\r\n}"
}, {
	"Path": "com.codename1.social.FacebookConnect.isInviteFriendsSupported",
	"Comment": "returns true if invitefriends is implemented, it is supported on ios and android",
	"Method": "boolean isInviteFriendsSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setSize",
	"Comment": "sets the component size, this method is exposed for the purpose of external layout managers and should not be invoked directly.if a user wishes to effect the component size setpreferredsize shouldbe used.",
	"Method": "void setSize(Dimension d){\r\n    Dimension d2 = bounds.getSize();\r\n    d2.setWidth(d.getWidth());\r\n    d2.setHeight(d.getHeight());\r\n}"
}, {
	"Path": "com.codename1.l10n.DateFormatSymbols.addZoneMapping",
	"Comment": "adds a timezone mapping so that simpledateformat can recognize abbreviated timezones.",
	"Method": "void addZoneMapping(String zoneId,String longName,String longNameDST,String shortName,String shortNameDST){\r\n    Hashtable<String, String> h = getResourceBundle();\r\n    if (h == null) {\r\n        h = new Hashtable<String, String>();\r\n        setResourceBundle(h);\r\n    }\r\n    zoneId = zoneId.toUpperCase();\r\n    h.put(L10N_ZONE_LONGNAME + zoneId, longName);\r\n    h.put(L10N_ZONE_LONGNAME_DST + zoneId, longNameDST);\r\n    h.put(L10N_ZONE_SHORTNAME + zoneId, shortName);\r\n    h.put(L10N_ZONE_SHORTNAME_DST + zoneId, shortNameDST);\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.ServerStateMachineTest.testSessionLeaderReset",
	"Comment": "tests resetting session timeouts when a new leader is elected.",
	"Method": "void testSessionLeaderReset(){\r\n    callerContext.execute(() -> {\r\n        long index;\r\n        try (RegisterEntry entry = state.getLog().create(RegisterEntry.class)) {\r\n            entry.setTerm(1).setTimestamp(timestamp).setTimeout(500).setClient(UUID.randomUUID().toString());\r\n            index = state.getLog().append(entry);\r\n        }\r\n        state.getStateMachine().apply(index).whenComplete((result, error) -> {\r\n            threadAssertNull(error);\r\n            resume();\r\n        });\r\n    });\r\n    await();\r\n    ServerSessionContext session = state.getStateMachine().executor().context().sessions().getSession(1);\r\n    assertNotNull(session);\r\n    assertEquals(session.id(), 1);\r\n    assertEquals(session.getTimestamp(), timestamp);\r\n    callerContext.execute(() -> {\r\n        long index;\r\n        try (InitializeEntry entry = state.getLog().create(InitializeEntry.class)) {\r\n            entry.setTerm(1).setTimestamp(timestamp + 100);\r\n            index = state.getLog().append(entry);\r\n        }\r\n        state.getStateMachine().apply(index).whenComplete((result, error) -> {\r\n            threadAssertNull(error);\r\n            resume();\r\n        });\r\n    });\r\n    await();\r\n    assertEquals(session.getTimestamp(), timestamp + 100);\r\n}"
}, {
	"Path": "com.codename1.ui.Image.createSVG",
	"Comment": "creates an svg image from the given byte array data and the base url, this methodwill throw an exception if svg is unsupported.",
	"Method": "Image createSVG(String baseURL,boolean animated,byte[] data){\r\n    Image i = new Image(Display.impl.createSVGImage(baseURL, data));\r\n    i.animated = animated;\r\n    i.svgBaseURL = baseURL;\r\n    i.svgData = data;\r\n    return i;\r\n}"
}, {
	"Path": "com.codename1.payment.Purchase.getFirstReceiptExpiringAfter",
	"Comment": "gets the first receipt that expires after the specified date for the providedskus.",
	"Method": "Receipt getFirstReceiptExpiringAfter(Receipt[] receipts,Date publishDate,String skus,Receipt getFirstReceiptExpiringAfter,Date dt,String skus){\r\n    return getFirstReceiptExpiringAfter(getReceipts(skus), dt, skus);\r\n}"
}, {
	"Path": "org.conscrypt.ct.Serialization.readList",
	"Comment": "read a variable length vector of variable sized elements as described by rfc5246 section 4.3.the vector is prefixed by its total length, in bytes and in big endian format,so is each element contained in the vector.",
	"Method": "byte[][] readList(byte[] input,int listWidth,int elemWidth,byte[][] readList,InputStream input,int listWidth,int elemWidth){\r\n    ArrayList<byte[]> result = new ArrayList<byte[]>();\r\n    byte[] data = readVariableBytes(input, listWidth);\r\n    input = new ByteArrayInputStream(data);\r\n    try {\r\n        while (input.available() > 0) {\r\n            result.add(readVariableBytes(input, elemWidth));\r\n        }\r\n    } catch (IOException e) {\r\n        throw new SerializationException(e);\r\n    }\r\n    return result.toArray(new byte[result.size()][]);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.onEditingComplete",
	"Comment": "called by the underlying implementation to indicate that editing in the nativesystem has completed and changes should propagate into codename one",
	"Method": "void onEditingComplete(Component c,String text){\r\n    if (!isEdt() && codenameOneRunning) {\r\n        Display.getInstance().callSerially(new Runnable() {\r\n            public void run() {\r\n                onEditingComplete(c, text);\r\n            }\r\n        });\r\n        return;\r\n    }\r\n    c.onEditComplete(text);\r\n    c.fireActionEvent();\r\n}"
}, {
	"Path": "com.codename1.ui.Display.onEditingComplete",
	"Comment": "called by the underlying implementation to indicate that editing in the nativesystem has completed and changes should propagate into codename one",
	"Method": "void onEditingComplete(Component c,String text){\r\n    onEditingComplete(c, text);\r\n}"
}, {
	"Path": "com.codename1.ui.Image.getGraphics",
	"Comment": "if this is a mutable image a graphics object allowing us to draw on itis returned.",
	"Method": "Graphics getGraphics(){\r\n    Graphics g = new Graphics(Display.impl.getNativeGraphics(image));\r\n    rgbCache = null;\r\n    return g;\r\n}"
}, {
	"Path": "android.support.v4.view.accessibility.AccessibilityNodeInfoCompat.findFocus",
	"Comment": "find the view that has the specified focus type. the search starts fromthe view represented by this node info.",
	"Method": "Object findFocus(Object info,int focus,Object findFocus,Object info,int focus,Object findFocus,Object info,int focus,AccessibilityNodeInfoCompat findFocus,int focus){\r\n    return AccessibilityNodeInfoCompat.wrapNonNullInstance(IMPL.findFocus(mInfo, focus));\r\n}"
}, {
	"Path": "java.util.AbstractMap.hashCode",
	"Comment": "returns the hash code for this object. objects which are equal mustreturn the same value for this method.",
	"Method": "int hashCode(int hashCode,int hashCode){\r\n    int result = 0;\r\n    Iterator<Map.Entry<K, V>> it = entrySet().iterator();\r\n    while (it.hasNext()) {\r\n        result += it.next().hashCode();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLUtils.getStringVal",
	"Comment": "matches the given string to the given options and returns the matching value, or the default one if none found.",
	"Method": "int getStringVal(String str,String[] options,int getStringVal,String str,String[] options,int[] vals,int getStringVal,String str,String[] options,int defaultValue,int getStringVal,String str,String[] options,int[] vals,int defaultValue){\r\n    if (str != null) {\r\n        for (int i = 0; i < options.length; i++) {\r\n            if (str.equals(options[i])) {\r\n                if (vals != null) {\r\n                    return vals[i];\r\n                } else {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return defaultValue;\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetTableModel.setSortingProperties",
	"Comment": "set whether this model is currently sorting properties.if this changes the sorting, the model will be rebuilt.",
	"Method": "void setSortingProperties(boolean value){\r\n    boolean old = sortingProperties;\r\n    sortingProperties = value;\r\n    if (sortingProperties != old)\r\n        buildModel();\r\n}"
}, {
	"Path": "com.codename1.ui.URLImage.createToFileSystem",
	"Comment": "creates an image the will be downloaded on the fly as necessary",
	"Method": "URLImage createToFileSystem(EncodedImage placeholder,String file,String url,ImageAdapter adapter){\r\n    return new URLImage(placeholder, url.intern(), adapter, null, file.intern());\r\n}"
}, {
	"Path": "com.alibaba.citrus.service.upload.impl.cfu.AbstractFileItem.isFormField",
	"Comment": "determines whether or not a fileitem instance represents asimple form field.",
	"Method": "boolean isFormField(){\r\n    return isFormField;\r\n}"
}, {
	"Path": "java.lang.StringBuffer.insert",
	"Comment": "inserts the string representation of the object argument into this string buffer.the second argument is converted to a string as if by the method string.valueof, and the characters of that string are then inserted into this string buffer at the indicated offset.the offset argument must be greater than or equal to 0, and less than or equal to the length of this string buffer.",
	"Method": "java.lang.StringBuffer insert(int offset,boolean b,java.lang.StringBuffer insert,int offset,char c,java.lang.StringBuffer insert,int offset,char[] str,java.lang.StringBuffer insert,int offset,double d,java.lang.StringBuffer insert,int offset,float f,java.lang.StringBuffer insert,int offset,int i,java.lang.StringBuffer insert,int offset,long l,java.lang.StringBuffer insert,int offset,java.lang.Object obj,java.lang.StringBuffer insert,int offset,java.lang.String str,StringBuffer insert,int offset,java.lang.CharSequence cs,StringBuffer insert,int offset,CharSequence cs,int start,int end){\r\n    internal.insert(offset, cs, start, end);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyIndex.getIgnoreCase",
	"Comment": "returns a property by its name regardless of case sensitivity for the name",
	"Method": "PropertyBase getIgnoreCase(String name){\r\n    for (PropertyBase p : properties) {\r\n        if (p.getName().equalsIgnoreCase(name)) {\r\n            return p;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.layoutContainer",
	"Comment": "performs the layout of the container if a layout is necessary",
	"Method": "void layoutContainer(){\r\n    if (shouldLayout) {\r\n        shouldLayout = false;\r\n        doLayout();\r\n    }\r\n}"
}, {
	"Path": "ly.count.android.sdk.CrashDetails.setCustomSegments",
	"Comment": "adds developer provided custom segments for crash,like versions of dependency libraries.",
	"Method": "void setCustomSegments(Map<String, String> segments){\r\n    customSegments = new HashMap();\r\n    customSegments.putAll(segments);\r\n}"
}, {
	"Path": "com.codename1.ui.Form.addCommandListener",
	"Comment": "a listener that is invoked when a command is clicked allowing multiple commandsto be handled by a single block",
	"Method": "void addCommandListener(ActionListener l){\r\n    if (commandListener == null) {\r\n        commandListener = new EventDispatcher();\r\n    }\r\n    commandListener.addListener(l);\r\n}"
}, {
	"Path": "com.codename1.components.ClearableTextField.wrap",
	"Comment": "wraps the given text field with a ui that will allow us to clear it",
	"Method": "ClearableTextField wrap(TextArea tf,float iconSize,ClearableTextField wrap,TextArea tf){\r\n    return wrap(tf, -1);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.mirrorBorder",
	"Comment": "if a border is a horizontal image border it can be mirrored which is useful for an rtl scenario",
	"Method": "Border mirrorBorder(){\r\n    if (type == TYPE_IMAGE_HORIZONTAL) {\r\n        return createHorizonalImageBorder(images[1].mirror(), images[0].mirror(), images[2].mirror());\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.fireDataChanged",
	"Comment": "alert the textfield listeners the text has been changed on the textfield",
	"Method": "void fireDataChanged(int type,int index){\r\n    if (listeners != null) {\r\n        listeners.fireDataChangeEvent(index, type);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Display.callSerially",
	"Comment": "causes the runnable to be invoked on the event dispatch thread. this methodreturns immediately and will not wait for the serial call to occur",
	"Method": "void callSerially(Runnable r){\r\n    if (codenameOneRunning) {\r\n        synchronized (lock) {\r\n            pendingSerialCalls.add(r);\r\n            lock.notifyAll();\r\n        }\r\n    } else {\r\n        r.run();\r\n    }\r\n}"
}, {
	"Path": "android.support.v4.widget.SlidingPaneLayout.setCoveredFadeColor",
	"Comment": "set the color used to fade the pane covered by the sliding pane out when the panewill become fully covered in the closed state.",
	"Method": "void setCoveredFadeColor(int color){\r\n    mCoveredFadeColor = color;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.Grid.getRowGaps",
	"Comment": "returns the row gaps in pixel sizes. one more than there arespecs sent in.",
	"Method": "int[][] getRowGaps(DimConstraint[] specs,int refSize,boolean isHor,boolean[] fillInPushGaps){\r\n    BoundSize defGap = isHor ? lc.getGridGapX() : lc.getGridGapY();\r\n    if (defGap == null) {\r\n        defGap = isHor ? PlatformDefaults.getGridGapX() : PlatformDefaults.getGridGapY();\r\n    }\r\n    int[] defGapArr = defGap.getPixelSizes(refSize, container, null);\r\n    boolean defIns = !hasDocks();\r\n    UnitValue firstGap = LayoutUtil.getInsets(lc, isHor ? 1 : 0, defIns);\r\n    UnitValue lastGap = LayoutUtil.getInsets(lc, isHor ? 3 : 2, defIns);\r\n    int[][] retValues = new int[specs.length + 1][];\r\n    for (int i = 0, wgIx = 0; i < retValues.length; i++) {\r\n        DimConstraint specBefore = i > 0 ? specs[i - 1] : null;\r\n        DimConstraint specAfter = i < specs.length ? specs[i] : null;\r\n        boolean edgeBefore = (specBefore == DOCK_DIM_CONSTRAINT || specBefore == null);\r\n        boolean edgeAfter = (specAfter == DOCK_DIM_CONSTRAINT || specAfter == null);\r\n        if (edgeBefore && edgeAfter) {\r\n            continue;\r\n        }\r\n        BoundSize wrapGapSize = (wrapGapMap == null || isHor == lc.isFlowX() ? null : wrapGapMap.get(new Integer(wgIx++)));\r\n        if (wrapGapSize == null) {\r\n            int[] gapBefore = specBefore != null ? specBefore.getRowGaps(container, null, refSize, false) : null;\r\n            int[] gapAfter = specAfter != null ? specAfter.getRowGaps(container, null, refSize, true) : null;\r\n            if (edgeBefore && gapAfter == null && firstGap != null) {\r\n                int bef = firstGap.getPixels(refSize, container, null);\r\n                retValues[i] = new int[] { bef, bef, bef };\r\n            } else if (edgeAfter && gapBefore == null && firstGap != null) {\r\n                int aft = lastGap.getPixels(refSize, container, null);\r\n                retValues[i] = new int[] { aft, aft, aft };\r\n            } else {\r\n                retValues[i] = gapAfter != gapBefore ? mergeSizes(gapAfter, gapBefore) : new int[] { defGapArr[0], defGapArr[1], defGapArr[2] };\r\n            }\r\n            if (specBefore != null && specBefore.isGapAfterPush() || specAfter != null && specAfter.isGapBeforePush()) {\r\n                fillInPushGaps[i] = true;\r\n            }\r\n        } else {\r\n            if (wrapGapSize.isUnset()) {\r\n                retValues[i] = new int[] { defGapArr[0], defGapArr[1], defGapArr[2] };\r\n            } else {\r\n                retValues[i] = wrapGapSize.getPixelSizes(refSize, container, null);\r\n            }\r\n            fillInPushGaps[i] = wrapGapSize.getGapPush();\r\n        }\r\n    }\r\n    return retValues;\r\n}"
}, {
	"Path": "java.io.FilterInputStream.reset",
	"Comment": "resets this stream to the last marked location. this implementationresets the target stream.",
	"Method": "void reset(){\r\n    in.reset();\r\n}"
}, {
	"Path": "com.codename1.ui.util.EventDispatcher.addListener",
	"Comment": "add a listener to the dispatcher that would receive the events when they occurs",
	"Method": "void addListener(Object listener){\r\n    if (listener != null) {\r\n        if (listeners == null) {\r\n            listeners = new ArrayList<Object>();\r\n        }\r\n        if (!listeners.contains(listener)) {\r\n            listeners.add(listener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSParser.addAttributeTo",
	"Comment": "adds the specified attribute and value pair to the specified selector",
	"Method": "int addAttributeTo(CSSElement selector,int attrId,String value,HTMLComponent htmlC,int addAttributeTo,CSSElement selector,String attributeName,String value,HTMLComponent htmlC){\r\n    int error = selector.setAttribute(attributeName, value);\r\n    reportAddAttributeError(error, selector, attributeName, value, htmlC);\r\n    return error;\r\n}"
}, {
	"Path": "com.codename1.ui.List.setDefaultIgnoreFocusComponentWhenUnfocused",
	"Comment": "indicates whether the list should not paint the focus component if the listitself has no focus.",
	"Method": "void setDefaultIgnoreFocusComponentWhenUnfocused(boolean aDefaultIgnoreFocusComponentWhenUnfocused){\r\n    defaultIgnoreFocusComponentWhenUnfocused = aDefaultIgnoreFocusComponentWhenUnfocused;\r\n}"
}, {
	"Path": "com.codename1.ui.Toolbar.getLeftBarCommands",
	"Comment": "returns the commands within the left bar section which can be useful forthings like unit testing. notice that you should not mutate the commandsor the iteratable set in any way!",
	"Method": "Iterable<Command> getLeftBarCommands(){\r\n    return getBarCommands(Boolean.TRUE);\r\n}"
}, {
	"Path": "com.googlecode.cqengine.codegen.AttributeBytecodeGenerator.generateMultiValueNullableAttribute",
	"Comment": "helper method for generating multivaluenullableattribute.",
	"Method": "R generateMultiValueNullableAttribute(Class<C> attributeSuperClass,Class<O> pojoClass,Class<A> attributeValueType,String attributeName,boolean componentValuesNullable,String target){\r\n    try {\r\n        ClassPool pool = new ClassPool(false);\r\n        pool.appendClassPath(new ClassClassPath(pojoClass));\r\n        CtClass attributeClass = pool.makeClass(pojoClass.getName() + \"$$CQEngine_\" + attributeSuperClass.getSimpleName() + \"_\" + attributeName);\r\n        attributeClass.setSuperclass(pool.get(attributeSuperClass.getName()));\r\n        SignatureAttribute.ClassType genericTypeOfAttribute = new SignatureAttribute.ClassType(attributeSuperClass.getName(), new SignatureAttribute.TypeArgument[] { new SignatureAttribute.TypeArgument(new SignatureAttribute.ClassType(pojoClass.getName())), new SignatureAttribute.TypeArgument(new SignatureAttribute.ClassType(attributeValueType.getName())) });\r\n        attributeClass.setGenericSignature(genericTypeOfAttribute.encode());\r\n        CtConstructor constructor = CtNewConstructor.make(\"public \" + attributeClass.getSimpleName() + \"() { \" + \"super(\\\"\" + attributeName + \"\\\", \" + componentValuesNullable + \");\" + \" }\", attributeClass);\r\n        attributeClass.addConstructor(constructor);\r\n        CtMethod getterMethod = CtMethod.make(\"public java.lang.Iterable getNullableValues(\" + pojoClass.getName() + \" object, \" + QueryOptions.class.getName() + \" queryOptions) { \" + \"return \" + GeneratedAttributeSupport.class.getName() + \".valueOf(\" + target + \");\" + \" }\", attributeClass);\r\n        getterMethod.setGenericSignature(new SignatureAttribute.MethodSignature(new SignatureAttribute.TypeParameter[0], new SignatureAttribute.Type[] { new SignatureAttribute.ClassType(pojoClass.getName()) }, new SignatureAttribute.ClassType(java.lang.Iterable.class.getName(), new SignatureAttribute.TypeArgument[] { new SignatureAttribute.TypeArgument(new SignatureAttribute.ClassType(attributeValueType.getName())) }), new SignatureAttribute.ObjectType[0]).encode());\r\n        attributeClass.addMethod(getterMethod);\r\n        CtMethod getterBridgeMethod = CtMethod.make(\"public java.lang.Iterable getNullableValues(java.lang.Object object, \" + QueryOptions.class.getName() + \" queryOptions) { \" + \"return getNullableValues((\" + pojoClass.getName() + \")object, queryOptions);\" + \" }\", attributeClass);\r\n        getterBridgeMethod.setModifiers(getterBridgeMethod.getModifiers() | AccessFlag.BRIDGE);\r\n        attributeClass.addMethod(getterBridgeMethod);\r\n        @SuppressWarnings(\"unchecked\")\r\n        R result = (R) attributeClass.toClass(pojoClass.getClassLoader(), pojoClass.getProtectionDomain());\r\n        attributeClass.detach();\r\n        return result;\r\n    } catch (Exception e) {\r\n        throw new IllegalStateException(getExceptionMessage(pojoClass, attributeValueType, attributeName), e);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.setTouchMenus",
	"Comment": "indicates whether the menu ui should target a touch based device or astandard cell phone",
	"Method": "void setTouchMenus(boolean touchMenus){\r\n    if (touchMenus) {\r\n        Display.getInstance().setCommandBehavior(Display.COMMAND_BEHAVIOR_TOUCH_MENU);\r\n    } else {\r\n        Display.getInstance().setCommandBehavior(Display.COMMAND_BEHAVIOR_SOFTKEY);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudStorage.deleteAllCloudFilesForUser",
	"Comment": "deletes all the cloud files under this user, notice that this methodis asynchronous and a background server process performs the actual deletion",
	"Method": "void deleteAllCloudFilesForUser(){\r\n    if (CloudPersona.getCurrentPersona().getToken() == null) {\r\n        return;\r\n    }\r\n    ConnectionRequest req = new ConnectionRequest();\r\n    req.setPost(false);\r\n    req.setFailSilently(true);\r\n    req.setUrl(SERVER_URL + \"/purgeCloudFiles\");\r\n    req.addArgument(\"own\", CloudPersona.getCurrentPersona().getToken());\r\n    req.addArgument(\"u\", Display.getInstance().getProperty(\"built_by_user\", \"\"));\r\n    NetworkManager.getInstance().addToQueue(req);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLEventsListener.deregisterAll",
	"Comment": "deregisters all the listeners, happens before a new page is loaded",
	"Method": "void deregisterAll(){\r\n    for (Enumeration e = comps.keys(); e.hasMoreElements(); ) {\r\n        Component cmp = (Component) e.nextElement();\r\n        cmp.removeFocusListener(this);\r\n        if (cmp instanceof Button) {\r\n            ((Button) cmp).removeActionListener(this);\r\n        } else if (cmp instanceof List) {\r\n            ((List) cmp).removeSelectionListener((SelectionListener) listeners.get(cmp));\r\n        } else if (cmp instanceof TextArea) {\r\n            ((TextArea) cmp).removeActionListener(this);\r\n            if (cmp instanceof TextField) {\r\n                ((TextField) cmp).removeDataChangeListener((DataChangedListener) listeners.get(cmp));\r\n            }\r\n        }\r\n    }\r\n    comps = new Hashtable();\r\n    listeners = new Hashtable();\r\n}"
}, {
	"Path": "com.codename1.maps.Projection.fromWGS84",
	"Comment": "converts a wgs84 bounding box to the projection system bounding box",
	"Method": "Coord fromWGS84(Coord wgs84,Coord[] fromWGS84,Coord[] coords,BoundingBox fromWGS84,BoundingBox bbox){\r\n    return new BoundingBox(fromWGS84(bbox.getSouthWest()), fromWGS84(bbox.getNorthEast()));\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.addAll",
	"Comment": "adds all components in the given collection to the result set.",
	"Method": "boolean addAll(Collection<? extends Component> c,ComponentSelector addAll,Collection<? extends Component> c,boolean chain){\r\n    addAll(c);\r\n    return this;\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.onStartHelper",
	"Comment": "called when the first activity is started. sends a begin session event to the serverand initializes application session tracking.",
	"Method": "void onStartHelper(){\r\n    prevSessionDurationStartTime_ = System.nanoTime();\r\n    connectionQueue_.beginSession();\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.LeaderState.configuring",
	"Comment": "returns a boolean value indicating whether a configuration is currently being committed.",
	"Method": "boolean configuring(){\r\n    return configuring > 0;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.PlatformDefaults.setDialogInsets",
	"Comment": "sets the default insets for a dialog. values that are null will not be changed.",
	"Method": "void setDialogInsets(UnitValue top,UnitValue left,UnitValue bottom,UnitValue right){\r\n    if (top != null)\r\n        DIALOG_INS[0] = top;\r\n    if (left != null)\r\n        DIALOG_INS[1] = left;\r\n    if (bottom != null)\r\n        DIALOG_INS[2] = bottom;\r\n    if (right != null)\r\n        DIALOG_INS[3] = right;\r\n    MOD_COUNT++;\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.currentTimestamp",
	"Comment": "utility method to return a current timestamp that can be used in the count.ly api.",
	"Method": "int currentTimestamp(){\r\n    return ((int) (System.currentTimeMillis() / 1000L));\r\n}"
}, {
	"Path": "com.codename1.components.FloatingActionButton.bindFabToContainer",
	"Comment": "this is a utility method to bind the fab to a given container, it will return a new container to add or willuse the layered pane if the container is a content pane.",
	"Method": "Container bindFabToContainer(Component cnt,Container bindFabToContainer,Component cnt,int orientation,int valign){\r\n    FlowLayout flow = new FlowLayout(orientation);\r\n    flow.setValign(valign);\r\n    Form f = cnt.getComponentForm();\r\n    if (f != null && (f.getContentPane() == cnt || f == cnt)) {\r\n        Container layers = f.getLayeredPane(getClass(), true);\r\n        layers.setLayout(flow);\r\n        layers.add(this);\r\n        return null;\r\n    }\r\n    Container conUpper = new Container(flow);\r\n    conUpper.add(this);\r\n    return LayeredLayout.encloseIn(cnt, conUpper);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.getLinkedContactIds",
	"Comment": "gets the ids of all contacts that are linked to the provided contact.",
	"Method": "String[] getLinkedContactIds(Contact c){\r\n    if (c == null || c.getId() == null) {\r\n        return new String[0];\r\n    }\r\n    return new String[] { c.getId() };\r\n}"
}, {
	"Path": "com.codename1.ui.Component.paintRippleOverlay",
	"Comment": "invoked to draw the ripple effect overlay in android where the finger of the user causes a growing circular overlay over time. this method is invoked after paintbackground and is invoked repeatedly untilthe users finger is removed, it will only be invoked if isrippleeffect returns true",
	"Method": "void paintRippleOverlay(Graphics g,int x,int y,int position){\r\n    int a = g.getAlpha();\r\n    int c = g.getColor();\r\n    g.setAlpha(20);\r\n    g.setColor(0);\r\n    if (position == 1000) {\r\n        g.fillRect(getX(), getY(), getWidth(), getHeight());\r\n    } else {\r\n        float ratio = ((float) position) / 1000.0f;\r\n        int w = (int) (((float) getWidth()) * ratio);\r\n        w = Math.max(w, Display.INSTANCE.convertToPixels(4));\r\n        g.fillArc(x - getParent().getAbsoluteX() - w / 2, y - getParent().getAbsoluteY() - w / 2, w, w, 0, 360);\r\n    }\r\n    g.setAlpha(a);\r\n    g.setColor(c);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.LC.maxWidth",
	"Comment": "the maximum width for the container. the value will override any value that is set on the container itself.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcontainers.com.",
	"Method": "LC maxWidth(String width){\r\n    setWidth(LayoutUtil.derive(getWidth(), null, null, ConstraintParser.parseUnitValue(width, true)));\r\n    return this;\r\n}"
}, {
	"Path": "java.lang.Integer.toString",
	"Comment": "returns a new string object representing the specified integer. the argument is converted to signed decimal representation and returned as a string, exactly as if the argument and radix 10 were given as arguments to themethod.",
	"Method": "java.lang.String toString(java.lang.String toString,int i,java.lang.String toString,int i,int radix){\r\n    return toString(value);\r\n}"
}, {
	"Path": "com.codename1.properties.InstantUI.getTextFieldConstraint",
	"Comment": "the text field constraint for the property. notice that some constraints are implicit unless set manually e.g. numeric for numbers or password for fields with password in the name",
	"Method": "int getTextFieldConstraint(PropertyBase p){\r\n    Integer v = (Integer) p.getClientProperty(\"cn1$tconstraint\");\r\n    if (v != null) {\r\n        return v;\r\n    }\r\n    Class t = p.getGenericType();\r\n    if (t != null) {\r\n        if (t == Integer.class || t == Long.class || t == Short.class || t == Byte.class) {\r\n            return TextArea.NUMERIC;\r\n        }\r\n        if (t == Double.class || t == Float.class) {\r\n            return TextArea.DECIMAL;\r\n        }\r\n    }\r\n    String n = p.getName().toLowerCase();\r\n    if (n.indexOf(\"password\") > -1) {\r\n        return TextArea.PASSWORD;\r\n    }\r\n    if (n.indexOf(\"url\") > -1 || n.indexOf(\"website\") > -1 || n.indexOf(\"blog\") > -1) {\r\n        return TextArea.URL;\r\n    }\r\n    if (n.indexOf(\"email\") > -1) {\r\n        return TextArea.EMAILADDR;\r\n    }\r\n    if (n.indexOf(\"phone\") > -1 || n.indexOf(\"mobile\") > -1) {\r\n        return TextArea.PHONENUMBER;\r\n    }\r\n    return TextArea.ANY;\r\n}"
}, {
	"Path": "com.codename1.push.PushActionCategory.getAllActions",
	"Comment": "convenience method to return all of the actions in the provided categories.",
	"Method": "PushAction[] getAllActions(PushActionCategory categories){\r\n    Set<PushAction> actions = new HashSet<PushAction>();\r\n    for (PushActionCategory cat : categories) {\r\n        actions.addAll(Arrays.asList(cat.getActions()));\r\n    }\r\n    return actions.toArray(new PushAction[actions.size()]);\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.removeCalculatedMembers",
	"Comment": "removes every tuple from a list which is calculated.the list must not be null, and must consist only of members.",
	"Method": "List<Member> removeCalculatedMembers(List<Member> memberList,TupleList removeCalculatedMembers,TupleList memberList){\r\n    if (memberList.getArity() == 1) {\r\n        return new UnaryTupleList(removeCalculatedMembers(memberList.slice(0)));\r\n    } else {\r\n        final TupleList clone = memberList.cloneList(memberList.size());\r\n        outer: for (List<Member> members : memberList) {\r\n            for (Member member : members) {\r\n                if (member.isCalculated()) {\r\n                    continue outer;\r\n                }\r\n            }\r\n            clone.add(members);\r\n        }\r\n        return clone;\r\n    }\r\n}"
}, {
	"Path": "java.lang.Float.hashCode",
	"Comment": "returns a hashcode for this float object. the result is the integer bit representation, exactly as produced by the method, of the primitive float value represented by this float object.",
	"Method": "int hashCode(){\r\n    int v = floatToIntBits(value);\r\n    return v ^ (v >>> 32);\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudStorage.save",
	"Comment": "adds the given object to the save queue, the operation will only take place once committed",
	"Method": "void save(CloudObject object){\r\n    if (storageQueue.contains(object)) {\r\n        storageQueue.remove(object);\r\n    }\r\n    storageQueue.addElement(object);\r\n    Storage.getInstance().writeObject(\"CN1StorageQueue\", storageQueue);\r\n    object.setStatus(CloudObject.STATUS_COMMIT_IN_PROGRESS);\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.checkNativeCompatible",
	"Comment": "functions that dynamically return one or more members of the measuresdimension prevent us from using native evaluation.",
	"Method": "void checkNativeCompatible(Validator validator,FunDef funDef,Exp[] args){\r\n    Query query = validator.getQuery();\r\n    if (!(funDef instanceof SetFunDef) && !(funDef instanceof ParenthesesFunDef) && query != null && query.nativeCrossJoinVirtualCube()) {\r\n        int[] paramCategories = funDef.getParameterCategories();\r\n        if (paramCategories.length > 0) {\r\n            final int cat0 = paramCategories[0];\r\n            final Exp arg0 = args[0];\r\n            switch(cat0) {\r\n                case Category.Dimension:\r\n                case Category.Hierarchy:\r\n                    if (arg0 instanceof DimensionExpr && ((DimensionExpr) arg0).getDimension().isMeasures() && !(funDef instanceof HierarchyCurrentMemberFunDef)) {\r\n                        query.setVirtualCubeNonNativeCrossJoin();\r\n                    }\r\n                    break;\r\n                case Category.Member:\r\n                    if (arg0 instanceof MemberExpr && ((MemberExpr) arg0).getMember().isMeasure() && isMemberOrSet(funDef.getReturnCategory())) {\r\n                        query.setVirtualCubeNonNativeCrossJoin();\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyBase.firePropertyChanged",
	"Comment": "delivers the property change event to listeners if applicable",
	"Method": "void firePropertyChanged(){\r\n    if (listeners != null) {\r\n        for (PropertyChangeListener pl : listeners) {\r\n            lastChangeListener = pl;\r\n            pl.propertyChanged(this);\r\n            lastChangeListener = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.setAutoDegradeMaxSize",
	"Comment": "indicates whether a high value for default maxsize will be reduced to a lowervalue if the underlying platform throws an exception.",
	"Method": "void setAutoDegradeMaxSize(boolean value){\r\n    autoDegradeMaxSize = value;\r\n}"
}, {
	"Path": "java.lang.StringToReal.parseDouble",
	"Comment": "returns the closest double value to the real number in the string.",
	"Method": "double parseDouble(String s){\r\n    s = s.trim();\r\n    int length = s.length();\r\n    if (length == 0) {\r\n        throw invalidReal(s, true);\r\n    }\r\n    char last = s.charAt(length - 1);\r\n    if (last == 'y' || last == 'N') {\r\n        return parseName(s, true);\r\n    }\r\n    StringExponentPair info = initialParse(s, length, true);\r\n    if (info.infinity || info.zero) {\r\n        return info.specialValue();\r\n    }\r\n    double result = parseDblImpl(info.s, (int) info.e);\r\n    if (Double.doubleToLongBits(result) == 0xffffffffffffffffL) {\r\n        throw invalidReal(s, true);\r\n    }\r\n    return info.negative ? -result : result;\r\n}"
}, {
	"Path": "com.codename1.javascript.JSObject.callString",
	"Comment": "calls a method on the underlying javascript object that returns a string. called synchronously with no arguments.",
	"Method": "String callString(String key){\r\n    return (String) call(key);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.cleanElementUI",
	"Comment": "cleans this element and its children of any associated ui components",
	"Method": "void cleanElementUI(HTMLElement element){\r\n    element.clearAssociatedComponents();\r\n    int children = element.getNumChildren();\r\n    for (int i = 0; i < children; i++) {\r\n        HTMLElement child = (HTMLElement) element.getChildAt(i);\r\n        cleanElementUI(child);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.Grid.layoutImpl",
	"Comment": "does the actual layout. uses many values calculated in the constructor.",
	"Method": "boolean layoutImpl(int[] bounds,UnitValue alignX,UnitValue alignY,boolean debug,boolean trialRun){\r\n    if (debug) {\r\n        debugRects = new ArrayList<int[]>();\r\n    }\r\n    if (colFlowSpecs == null) {\r\n        checkSizeCalcs(bounds[2], bounds[3]);\r\n    }\r\n    resetLinkValues(true, true);\r\n    layoutInOneDim(bounds[2], alignX, false, pushXs);\r\n    layoutInOneDim(bounds[3], alignY, true, pushYs);\r\n    HashMap<String, Integer> endGrpXMap = null, endGrpYMap = null;\r\n    int compCount = container.getComponentCount();\r\n    boolean addVisualPadding = lc.isVisualPadding();\r\n    boolean layoutAgain = false;\r\n    if (compCount > 0) {\r\n        for (int j = 0; j < (linkTargetIDs != null ? 2 : 1); j++) {\r\n            boolean doAgain;\r\n            int count = 0;\r\n            do {\r\n                doAgain = false;\r\n                for (Cell cell : grid.values()) {\r\n                    ArrayList<CompWrap> compWraps = cell.compWraps;\r\n                    for (CompWrap cw : compWraps) {\r\n                        if (j == 0) {\r\n                            doAgain |= doAbsoluteCorrections(cw, bounds);\r\n                            if (!doAgain) {\r\n                                if (cw.cc.getHorizontal().getEndGroup() != null) {\r\n                                    endGrpXMap = addToEndGroup(endGrpXMap, cw.cc.getHorizontal().getEndGroup(), cw.x + cw.w);\r\n                                }\r\n                                if (cw.cc.getVertical().getEndGroup() != null) {\r\n                                    endGrpYMap = addToEndGroup(endGrpYMap, cw.cc.getVertical().getEndGroup(), cw.y + cw.h);\r\n                                }\r\n                            }\r\n                            if (linkTargetIDs != null && (linkTargetIDs.containsKey(\"visual\") || linkTargetIDs.containsKey(\"container\"))) {\r\n                                layoutAgain = true;\r\n                            }\r\n                        }\r\n                        if (linkTargetIDs == null || j == 1) {\r\n                            if (cw.cc.getHorizontal().getEndGroup() != null) {\r\n                                cw.w = endGrpXMap.get(cw.cc.getHorizontal().getEndGroup()) - cw.x;\r\n                            }\r\n                            if (cw.cc.getVertical().getEndGroup() != null) {\r\n                                cw.h = endGrpYMap.get(cw.cc.getVertical().getEndGroup()) - cw.y;\r\n                            }\r\n                            cw.x += bounds[0];\r\n                            cw.y += bounds[1];\r\n                            if (!trialRun) {\r\n                                cw.transferBounds(addVisualPadding);\r\n                            }\r\n                            if (callbackList != null) {\r\n                                for (LayoutCallback callback : callbackList) {\r\n                                    callback.correctBounds(cw.comp);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                clearGroupLinkBounds();\r\n                if (++count > ((compCount << 3) + 10)) {\r\n                    System.err.println(\"Unstable cyclic dependency in absolute linked values!\");\r\n                    break;\r\n                }\r\n            } while (doAgain);\r\n        }\r\n    }\r\n    if (debug) {\r\n        for (Cell cell : grid.values()) {\r\n            ArrayList<CompWrap> compWraps = cell.compWraps;\r\n            for (CompWrap cw : compWraps) {\r\n                LinkedDimGroup hGrp = getGroupContaining(colGroupLists, cw);\r\n                LinkedDimGroup vGrp = getGroupContaining(rowGroupLists, cw);\r\n                if (hGrp != null && vGrp != null) {\r\n                    debugRects.add(new int[] { hGrp.lStart + bounds[0] - (hGrp.fromEnd ? hGrp.lSize : 0), vGrp.lStart + bounds[1] - (vGrp.fromEnd ? vGrp.lSize : 0), hGrp.lSize, vGrp.lSize });\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return layoutAgain;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.getDragSpeed",
	"Comment": "this method returns the dragging speed based on the latest draggedevents",
	"Method": "float getDragSpeed(boolean yAxis){\r\n    float speed;\r\n    if (yAxis) {\r\n        speed = impl.getDragSpeed(dragPathY, dragPathTime, dragPathOffset, dragPathLength);\r\n    } else {\r\n        speed = impl.getDragSpeed(dragPathX, dragPathTime, dragPathOffset, dragPathLength);\r\n    }\r\n    return speed;\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.setDialogPosition",
	"Comment": "screen orientation position for the upcoming dialog. by defaultthe dialog will be shown at hardcoded coordinates, this method allows usto pack the dialog appropriately in one of the border layout based locationssee borderlayout for futher details.",
	"Method": "void setDialogPosition(String dialogPosition){\r\n    this.dialogPosition = dialogPosition;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.setShowImages",
	"Comment": "sets whether this htmlcomponent will download and show linked images or not",
	"Method": "void setShowImages(boolean show){\r\n    showImages = show;\r\n}"
}, {
	"Path": "com.codename1.location.Geofence.getDistanceTo",
	"Comment": "gets the distance between the current region and the given region.",
	"Method": "double getDistanceTo(Geofence gf){\r\n    return Math.max(0, getLoc().getDistanceTo(gf.getLoc()) - gf.getRadius() - getRadius());\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Collections.singletonMap",
	"Comment": "returns a map containing the specified key and value. the map cannot bemodified. the map is serializable.",
	"Method": "Map<K, V> singletonMap(K key,V value){\r\n    return new SingletonMap<K, V>(key, value);\r\n}"
}, {
	"Path": "org.conscrypt.java.security.TestKeyStore.getIntermediateCa",
	"Comment": "return an intermediate ca that can be used to issue new certificates.",
	"Method": "TestKeyStore getIntermediateCa(){\r\n    initCerts();\r\n    return INTERMEDIATE_CA;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.setScrollIncrement",
	"Comment": "determines the scroll increment size of this container.this value is in use when the current foucs element within this containeris larger than this container size.",
	"Method": "void setScrollIncrement(int scrollIncrement){\r\n    this.scrollIncrement = scrollIncrement;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.resume",
	"Comment": "called when a previously paused operation now has the networking time to resume.assuming this method returns true, the network request will be resent to the serverand the operation can resume.",
	"Method": "boolean resume(){\r\n    paused = false;\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.getDestinationStorage",
	"Comment": "when set to a none null string saves the response to storage underthis file name",
	"Method": "String getDestinationStorage(){\r\n    return destinationStorage;\r\n}"
}, {
	"Path": "java.util.AbstractQueue.addAll",
	"Comment": "adds all the elements of a collection to the queue. if the collection isthe queue itself, then an illegalargumentexception will be thrown. ifduring the process, some runtime exception is thrown, then those elementsin the collection which have already successfully been added will remainin the queue. the result of the method is undefined if the collection ismodified during the process of the method.",
	"Method": "boolean addAll(Collection<? extends E> c){\r\n    if (null == c) {\r\n        throw new NullPointerException();\r\n    }\r\n    if (this == c) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return super.addAll(c);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.dial",
	"Comment": "opens the device dialer application with the given phone number",
	"Method": "void dial(String phoneNumber){\r\n    impl.dial(phoneNumber);\r\n}"
}, {
	"Path": "com.codename1.components.ToastBar.showErrorMessage",
	"Comment": "simplifies a common use case of showing an error message with an error icon that fades out after a few seconds",
	"Method": "void showErrorMessage(String msg,Status showErrorMessage,String msg,int timeout){\r\n    return showMessage(msg, FontImage.MATERIAL_ERROR, timeout);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.convertToPixels",
	"Comment": "converts the dips count to pixels, dips are roughly 1mm in length. this is a very rough estimate and notto be relied upon",
	"Method": "int convertToPixels(int dipCount,boolean horizontal){\r\n    switch(getDeviceDensity()) {\r\n        case Display.DENSITY_VERY_LOW:\r\n            return dipCount;\r\n        case Display.DENSITY_LOW:\r\n            return dipCount * 2;\r\n        case Display.DENSITY_MEDIUM:\r\n            return dipCount * 5;\r\n        case Display.DENSITY_HIGH:\r\n            return dipCount * 10;\r\n        case Display.DENSITY_VERY_HIGH:\r\n            return dipCount * 14;\r\n        case Display.DENSITY_HD:\r\n            return dipCount * 20;\r\n    }\r\n    return dipCount;\r\n}"
}, {
	"Path": "com.codename1.ui.Label.getMaskedIcon",
	"Comment": "if a mask is applied returns the icon with a mask, otherwise returns the icon",
	"Method": "Image getMaskedIcon(){\r\n    if (maskedIcon != null) {\r\n        return maskedIcon;\r\n    }\r\n    if (mask != null) {\r\n        if (icon != null) {\r\n            maskedIcon = icon.applyMaskAutoScale(mask);\r\n            return maskedIcon;\r\n        }\r\n    }\r\n    return icon;\r\n}"
}, {
	"Path": "android.support.v4.view.accessibility.AccessibilityRecordCompat.getCurrentItemIndex",
	"Comment": "gets the index of the source in the list of items the can be visited.",
	"Method": "int getCurrentItemIndex(Object record,int getCurrentItemIndex,Object record,int getCurrentItemIndex,Object record,int getCurrentItemIndex){\r\n    return IMPL.getCurrentItemIndex(mRecord);\r\n}"
}, {
	"Path": "com.codename1.ui.CN.flushStorageCache",
	"Comment": "flush the storage cache allowing implementations that cache storage objectsto store",
	"Method": "void flushStorageCache(){\r\n    Storage.getInstance().flushStorageCache();\r\n}"
}, {
	"Path": "com.codename1.ui.CN.setProperty",
	"Comment": "sets a local property to the application, this method has no effect on theimplementation code and only allows the user to override the logic of getpropertyfor internal application purposes.",
	"Method": "void setProperty(String key,String value){\r\n    Display.INSTANCE.setProperty(key, value);\r\n}"
}, {
	"Path": "com.codename1.tools.translator.bytecodes.Instruction.isComplexInstruction",
	"Comment": "indicates whether this is a complex instruction that blocks simplification of this method",
	"Method": "boolean isComplexInstruction(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.hasInlineSelectedStyle",
	"Comment": "checks to see if the component has any inline styles registered for its selected state.",
	"Method": "boolean hasInlineSelectedStyle(){\r\n    return getInlineStylesTheme() != null && (inlineAllStyles != null || inlineSelectedStyles != null);\r\n}"
}, {
	"Path": "java.util.ArrayList.removeRange",
	"Comment": "removes the objects in the specified range from the start to the end, butnot including the end index.",
	"Method": "void removeRange(int start,int end){\r\n    if (start < 0) {\r\n        throw new IndexOutOfBoundsException(\"\" + start);\r\n    } else if (end > size) {\r\n        throw new IndexOutOfBoundsException(\"\" + end + \" out of: \" + size);\r\n    } else if (start > end) {\r\n        throw new IndexOutOfBoundsException(\"\" + start + \" out of: \" + end);\r\n    }\r\n    if (start == end) {\r\n        return;\r\n    }\r\n    if (end == size) {\r\n        Arrays.fill(array, firstIndex + start, firstIndex + size, null);\r\n    } else if (start == 0) {\r\n        Arrays.fill(array, firstIndex, firstIndex + end, null);\r\n        firstIndex += end;\r\n    } else {\r\n        System.arraycopy(array, firstIndex + end, array, firstIndex + start, size - end);\r\n        int lastIndex = firstIndex + size;\r\n        int newLast = lastIndex + start - end;\r\n        Arrays.fill(array, newLast, lastIndex, null);\r\n    }\r\n    size -= end - start;\r\n    modCount++;\r\n}"
}, {
	"Path": "com.codename1.l10n.DateFormatSymbols.getZoneShortNameDST",
	"Comment": "gets the short name of a given timezone in daylight saving time.",
	"Method": "String getZoneShortNameDST(String zoneId,String defaultValue){\r\n    zoneId = zoneId.toUpperCase();\r\n    return getLocalizedValue(L10N_ZONE_SHORTNAME_DST + zoneId, defaultValue);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.makeTransformInverse",
	"Comment": "gets the inverse transformation for the provided transform.",
	"Method": "Object makeTransformInverse(Object nativeTransform){\r\n    throw new RuntimeException(\"Transforms not supported\");\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.ThumbnailParameter.useOriginalImageType",
	"Comment": "returns whether or not the original image type should be used for the\tthumbnail.",
	"Method": "boolean useOriginalImageType(){\r\n    return imageType == ORIGINAL_IMAGE_TYPE;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.isDropTarget",
	"Comment": "indicates whether this component can receive dropped components into it, notice that when dropping on a componentor container the parents will be checked recursively to find a valid drop target",
	"Method": "boolean isDropTarget(){\r\n    return dropTarget;\r\n}"
}, {
	"Path": "cognitivej.vision.face.facelist.FaceListBuilder.deleteFaceList",
	"Comment": "delete an existing face list according to face list id. persisted face images in the face list will also be deleted.",
	"Method": "DeleteFaceListAction deleteFaceList(String faceListId){\r\n    Validation.validate(faceListId, \"^[a-z0-9_-]{1,64}$\", new ParameterValidationException(\"faceListId\", \"Person group ID is invalid. Valid format should be a string composed by numbers, english letters in lower case, '-', '_', and no longer than 64 characters.\"));\r\n    return new DeleteFaceListAction(cognitiveContext, faceListId);\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.map",
	"Comment": "creates a new set based on the elements of the current set and a mapping functionwhich defines the elements that should be in the new set.",
	"Method": "Component map(Component c,ComponentSelector map,ComponentMapper mapper){\r\n    HashSet<Component> out = new HashSet<Component>();\r\n    for (Component c : this) {\r\n        Component res = mapper.map(c);\r\n        if (res != null) {\r\n            out.add(res);\r\n        }\r\n    }\r\n    return new ComponentSelector(out);\r\n}"
}, {
	"Path": "io.atomix.copycat.client.session.ClientSessionState.nextCommandRequest",
	"Comment": "returns the next command request sequence number for the session.",
	"Method": "long nextCommandRequest(){\r\n    return ++commandRequest;\r\n}"
}, {
	"Path": "ly.count.android.sdk.CountlyStore.getLocation",
	"Comment": "get location or empty string in case if no location is specified",
	"Method": "String getLocation(){\r\n    return preferences_.getString(LOCATION_PREFERENCE, \"\");\r\n}"
}, {
	"Path": "com.codename1.impl.android.AndroidNativeUtil.getActivationBundle",
	"Comment": "allows us to get the bundle that was used to create this activity",
	"Method": "Bundle getActivationBundle(){\r\n    return activationBundle;\r\n}"
}, {
	"Path": "org.conscrypt.ConscryptEngineSocket.setHostname",
	"Comment": "this method enables server name indication.if the hostname is not a valid sni hostname,the sni extension will be omitted from the handshake.",
	"Method": "void setHostname(String hostname){\r\n    engine.setHostname(hostname);\r\n    super.setHostname(hostname);\r\n}"
}, {
	"Path": "com.codename1.ui.geom.GeneralPath.closePath",
	"Comment": "closes the current subpath by drawing a line back to the point of thelast moveto, unless the path is already closed.",
	"Method": "void closePath(){\r\n    if (typeSize == 0 || types[typeSize - 1] != PathIterator.SEG_CLOSE) {\r\n        checkBuf(0, true);\r\n        types[typeSize++] = PathIterator.SEG_CLOSE;\r\n        dirty = true;\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.SegmentDescriptor.maxEntries",
	"Comment": "returns the maximum number of entries allowed in the segment.",
	"Method": "int maxEntries(){\r\n    return maxEntries;\r\n}"
}, {
	"Path": "com.codename1.l10n.L10NManager.getLanguage",
	"Comment": "returns the current locale language as an iso 639 two letter code",
	"Method": "String getLanguage(){\r\n    return language;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.CommonTransitions.createFade",
	"Comment": "creates a transition for fading a form in while fading out the original form",
	"Method": "CommonTransitions createFade(int duration){\r\n    CommonTransitions t = new CommonTransitions(TYPE_FADE);\r\n    t.speed = duration;\r\n    return t;\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.getWidestChar",
	"Comment": "indicates the widest character in the alphabet, this is useful for detectinglinebreaks internally. in cjk languages the widest char is different than whence this functionality is exposed to developers.",
	"Method": "char getWidestChar(){\r\n    return widestChar;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.ConstraintParser.toTrimmedTokens",
	"Comment": "parses a string and returns it in those parts of the string that areseparated with a sep character.separator characters within parentheses will not be counted or handled inany way, whatever the depth.a space separator will be a hit to one or more spaces and thus not returnempty strings.",
	"Method": "String[] toTrimmedTokens(String s,char sep){\r\n    int toks = 0, sSize = s.length();\r\n    boolean disregardDoubles = sep == ' ';\r\n    int p = 0;\r\n    for (int i = 0; i < sSize; i++) {\r\n        char c = s.charAt(i);\r\n        if (c == '(') {\r\n            p++;\r\n        } else if (c == ')') {\r\n            p--;\r\n        } else if (p == 0 && c == sep) {\r\n            toks++;\r\n            while (disregardDoubles && i < sSize - 1 && s.charAt(i + 1) == ' ') {\r\n                i++;\r\n            }\r\n        }\r\n        if (p < 0) {\r\n            throw new IllegalArgumentException(\"Unbalanced parentheses: '\" + s + \"'\");\r\n        }\r\n    }\r\n    if (p != 0) {\r\n        throw new IllegalArgumentException(\"Unbalanced parentheses: '\" + s + \"'\");\r\n    }\r\n    if (toks == 0) {\r\n        return new String[] { s.trim() };\r\n    }\r\n    String[] retArr = new String[toks + 1];\r\n    int st = 0, pNr = 0;\r\n    p = 0;\r\n    for (int i = 0; i < sSize; i++) {\r\n        char c = s.charAt(i);\r\n        if (c == '(') {\r\n            p++;\r\n        } else if (c == ')') {\r\n            p--;\r\n        } else if (p == 0 && c == sep) {\r\n            retArr[pNr++] = s.substring(st, i).trim();\r\n            st = i + 1;\r\n            while (disregardDoubles && i < sSize - 1 && s.charAt(i + 1) == ' ') {\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n    retArr[pNr++] = s.substring(st, sSize).trim();\r\n    return retArr;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLElement.addAssociatedComponent",
	"Comment": "adds the given component to be associated with this element.this is used internally to apply css styling.",
	"Method": "void addAssociatedComponent(Component cmp){\r\n    if (comps == null) {\r\n        comps = new Vector();\r\n    }\r\n    comps.addElement(cmp);\r\n}"
}, {
	"Path": "com.codename1.ui.List.setFireOnClick",
	"Comment": "this method determines if the list fires the action event when the pointerwas clicked on one of the items, or only if the item was the selected itemby default the value is true, this setting is only relevant for none fixedlists",
	"Method": "void setFireOnClick(boolean fireOnClick){\r\n    this.fireOnClick = fireOnClick;\r\n}"
}, {
	"Path": "com.codename1.util.Base64.encodeNoNewline",
	"Comment": "encodes the given array as a base64 string without breaking lines",
	"Method": "String encodeNoNewline(byte[] in){\r\n    int length = in.length * 4 / 3;\r\n    length += length / 76 + 3;\r\n    byte[] out = new byte[length];\r\n    int index = 0, i, end = in.length - in.length % 3;\r\n    for (i = 0; i < end; i += 3) {\r\n        out[index++] = map[(in[i] & 0xff) >> 2];\r\n        out[index++] = map[((in[i] & 0x03) << 4) | ((in[i + 1] & 0xff) >> 4)];\r\n        out[index++] = map[((in[i + 1] & 0x0f) << 2) | ((in[i + 2] & 0xff) >> 6)];\r\n        out[index++] = map[(in[i + 2] & 0x3f)];\r\n    }\r\n    switch(in.length % 3) {\r\n        case 1:\r\n            out[index++] = map[(in[end] & 0xff) >> 2];\r\n            out[index++] = map[(in[end] & 0x03) << 4];\r\n            out[index++] = '=';\r\n            out[index++] = '=';\r\n            break;\r\n        case 2:\r\n            out[index++] = map[(in[end] & 0xff) >> 2];\r\n            out[index++] = map[((in[end] & 0x03) << 4) | ((in[end + 1] & 0xff) >> 4)];\r\n            out[index++] = map[((in[end + 1] & 0x0f) << 2)];\r\n            out[index++] = '=';\r\n            break;\r\n    }\r\n    return new String(out, 0, index);\r\n}"
}, {
	"Path": "java.util.Vector.remove",
	"Comment": "removes the first occurrence, starting at the beginning and movingtowards the end, of the specified object from this vector. all elementswith an index bigger than the element that gets removed have their indexdecreased by 1.",
	"Method": "E remove(int location,boolean remove,Object object){\r\n    return removeElement(object);\r\n}"
}, {
	"Path": "com.codename1.ui.Graphics.drawArc",
	"Comment": "draws a circular or elliptical arc based on the given angles and bounding box",
	"Method": "void drawArc(int x,int y,int width,int height,int startAngle,int arcAngle){\r\n    impl.drawArc(nativeGraphics, xTranslate + x, yTranslate + y, width, height, startAngle, arcAngle);\r\n}"
}, {
	"Path": "com.codename1.impl.blackberry.TransportDetective.isTransportServiceAvailable",
	"Comment": "determines if a specific transport is available based on service book availability. in other words this method will return true onlyfor those available transports for which there is a service book present on the device. this does not guarantee connection capability.you also need sufficient coverage for a transport to work.",
	"Method": "boolean isTransportServiceAvailable(int transport){\r\n    int available = getAvailableTransportServices();\r\n    if ((available & transport) > 0)\r\n        return true;\r\n    else\r\n        return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Font.createBitmapFont",
	"Comment": "creates a bitmap font with the given arguments and places said font in the cache",
	"Method": "Font createBitmapFont(String name,Image bitmap,int[] cutOffsets,int[] charWidth,String charsets,Font createBitmapFont,Image bitmap,int[] cutOffsets,int[] charWidth,String charsets){\r\n    return new CustomFont(bitmap, cutOffsets, charWidth, charsets);\r\n}"
}, {
	"Path": "java.util.Vector.lastIndexOf",
	"Comment": "searches in this vector for the index of the specified object. the searchfor the object starts at the specified location and moves towards thestart of this vector.",
	"Method": "int lastIndexOf(Object object,int lastIndexOf,Object object,int location){\r\n    if (location < elementCount) {\r\n        if (object != null) {\r\n            for (int i = location; i >= 0; i--) {\r\n                if (object.equals(elementData[i])) {\r\n                    return i;\r\n                }\r\n            }\r\n        } else {\r\n            for (int i = location; i >= 0; i--) {\r\n                if (elementData[i] == null) {\r\n                    return i;\r\n                }\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n    throw new ArrayIndexOutOfBoundsException(location);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.HashMap.calculateCapacity",
	"Comment": "calculates the capacity of storage required for storing given number ofelements",
	"Method": "int calculateCapacity(int x){\r\n    if (x >= 1 << 30) {\r\n        return 1 << 30;\r\n    }\r\n    if (x == 0) {\r\n        return 16;\r\n    }\r\n    x = x - 1;\r\n    x |= x >> 1;\r\n    x |= x >> 2;\r\n    x |= x >> 4;\r\n    x |= x >> 8;\r\n    x |= x >> 16;\r\n    return x + 1;\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.getCancelMenuItem",
	"Comment": "this method returns the cancel menu item, when a menu is opened",
	"Method": "Command getCancelMenuItem(){\r\n    return cancelMenuItem;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.ArrayDeque.iterator",
	"Comment": "returns the iterator of the deque. the elements will be ordered from headto tail.",
	"Method": "Iterator<E> iterator(){\r\n    return new ArrayDequeIterator<E>();\r\n}"
}, {
	"Path": "com.codename1.io.rest.RequestBuilder.onErrorCodeBytes",
	"Comment": "in case of an error this method is invoked asynchronously to processthe error content with the byte array data",
	"Method": "RequestBuilder onErrorCodeBytes(ErrorCodeHandler<byte[]> err){\r\n    byteArrayErrorCallback = err;\r\n    return this;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.subList",
	"Comment": "returns a list of the specified portion of this vector from the startindex to one less than the end index. the returned list is backed by thisvector so changes to one are reflected by the other.",
	"Method": "List<E> subList(int start,int end){\r\n    return new Collections.SynchronizedRandomAccessList<E>(super.subList(start, end), this);\r\n}"
}, {
	"Path": "com.codename1.ui.list.DefaultListModel.getList",
	"Comment": "returns the internal list of items which makes traversal using iterators easier.",
	"Method": "java.util.List<T> getList(){\r\n    return items;\r\n}"
}, {
	"Path": "com.codename1.ui.Toolbar.getOverflowCommands",
	"Comment": "returns the commands within the overflow menu which can be useful forthings like unit testing. notice that you should not mutate the commandsor the iteratable set in any way!",
	"Method": "Iterable<Command> getOverflowCommands(){\r\n    return overflowCommands;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.promptInstallOnHomescreen",
	"Comment": "prompts the user to install this app on their homescreen.this is only relevant in the javascript port.",
	"Method": "boolean promptInstallOnHomescreen(){\r\n    return Display.impl.promptInstallOnHomescreen();\r\n}"
}, {
	"Path": "com.codename1.ui.html.ResourceThreadQueue.setMaxThreads",
	"Comment": "sets the maximum number of threads to use for image downloadif startrunning was already called, this will takes effect in the next page loaded.",
	"Method": "void setMaxThreads(int threadsNum){\r\n    maxThreads = threadsNum;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.query.logical.Not.matches",
	"Comment": "returns the inverse of whether the negated query matches the given object.",
	"Method": "boolean matches(O object,QueryOptions queryOptions){\r\n    return !negatedQuery.matches(object, queryOptions);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Stack.search",
	"Comment": "returns the index of the first occurrence of the object, starting fromthe top of the stack.",
	"Method": "int search(Object o){\r\n    final Object[] dumpArray = elementData;\r\n    final int size = elementCount;\r\n    if (o != null) {\r\n        for (int i = size - 1; i >= 0; i--) {\r\n            if (o.equals(dumpArray[i])) {\r\n                return size - i;\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = size - 1; i >= 0; i--) {\r\n            if (dumpArray[i] == null) {\r\n                return size - i;\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.transformPoint",
	"Comment": "transforms a point and stores the result in a provided array.",
	"Method": "void transformPoint(Object nativeTransform,float[] in,float[] out){\r\n    throw new RuntimeException(\"Transforms not supported\");\r\n}"
}, {
	"Path": "android.support.v4.app.FragmentActivity.onBackPressed",
	"Comment": "take care of popping the fragment back stack or finishing the activityas appropriate.",
	"Method": "void onBackPressed(){\r\n    if (!mFragments.popBackStackImmediate()) {\r\n        finish();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.addDataChangedListener",
	"Comment": "adds a listener for data change events it will be invoked for every changemade to the text field, notice most platforms will invoke only the datachangedlistener.changed event",
	"Method": "void addDataChangedListener(DataChangedListener d){\r\n    listeners.addListener(d);\r\n}"
}, {
	"Path": "com.codename1.ui.geom.GeneralPath.setRect",
	"Comment": "sets this path to be a rectangle with the provided bounds, but with the given transform applied to it.",
	"Method": "void setRect(Rectangle r,Transform t){\r\n    reset();\r\n    int x = r.getX();\r\n    int y = r.getY();\r\n    Dimension size = r.getSize();\r\n    int w = size.getWidth();\r\n    int h = size.getHeight();\r\n    if (t == null) {\r\n        moveTo(x, y);\r\n        lineTo(x + w, y);\r\n        lineTo(x + w, y + h);\r\n        lineTo(x, y + h);\r\n        closePath();\r\n    } else {\r\n        float[] pointBuffer = createFloatArrayFromPool(6);\r\n        try {\r\n            pointBuffer[0] = x;\r\n            pointBuffer[1] = y;\r\n            pointBuffer[2] = 0;\r\n            t.transformPoint(pointBuffer, pointBuffer);\r\n            moveTo(pointBuffer[0], pointBuffer[1]);\r\n            pointBuffer[0] = x + w;\r\n            pointBuffer[1] = y;\r\n            pointBuffer[2] = 0;\r\n            t.transformPoint(pointBuffer, pointBuffer);\r\n            lineTo(pointBuffer[0], pointBuffer[1]);\r\n            pointBuffer[0] = x + w;\r\n            pointBuffer[1] = y + h;\r\n            pointBuffer[2] = 0;\r\n            t.transformPoint(pointBuffer, pointBuffer);\r\n            lineTo(pointBuffer[0], pointBuffer[1]);\r\n            pointBuffer[0] = x;\r\n            pointBuffer[1] = y + h;\r\n            pointBuffer[2] = 0;\r\n            t.transformPoint(pointBuffer, pointBuffer);\r\n            lineTo(pointBuffer[0], pointBuffer[1]);\r\n            closePath();\r\n        } finally {\r\n            recycle(pointBuffer);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.WebBrowser.getInternal",
	"Comment": "since the internal component can be either an htmlcomponent or a browsercomponent one of themwill be returned. if you are targeting modern smartphones only you can rely on this method returning a browsercomponent instance.",
	"Method": "Component getInternal(){\r\n    return internal;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setDraggable",
	"Comment": "indicates whether this component can be dragged in a drag and drop operation rather than scroll the parent",
	"Method": "void setDraggable(boolean draggable){\r\n    this.draggable = draggable;\r\n}"
}, {
	"Path": "com.codename1.l10n.L10NManager.format",
	"Comment": "formats a number as a string with a fixed number of decimal places",
	"Method": "String format(int number,String format,double number,String format,double number,int decimalPlaces){\r\n    if (decimalPlaces == 0) {\r\n        return format((double) ((long) number));\r\n    }\r\n    double pos = 10;\r\n    for (int iter = 1; iter < decimalPlaces; iter++) {\r\n        pos *= 10;\r\n    }\r\n    long ln = Math.round(number * pos);\r\n    number = ((double) ln) / pos;\r\n    return format(number);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.showPreTagText",
	"Comment": "shows a text that has been marked with the html pre tag which means the text will be displayed as is without truncation of white spaces and new lines when reaching the end of the screen.",
	"Method": "Vector showPreTagText(String text,int align){\r\n    Vector comps = new Vector();\r\n    if ((text == null) || (text.equals(\"\"))) {\r\n        return comps;\r\n    }\r\n    String line = \"\";\r\n    for (int c = 0; c < text.length(); c++) {\r\n        char ch = text.charAt(c);\r\n        if ((ch == 10) || (ch == 13)) {\r\n            if (!line.equals(\"\")) {\r\n                comps.addElement(addString(line, align));\r\n                newLine(align);\r\n                line = \"\";\r\n            }\r\n        } else {\r\n            line += ch;\r\n        }\r\n    }\r\n    if (!line.equals(\"\")) {\r\n        comps.addElement(addString(line, align));\r\n        newLine(align);\r\n    }\r\n    return comps;\r\n}"
}, {
	"Path": "android.support.v4.view.accessibility.AccessibilityNodeInfoCompat.focusSearch",
	"Comment": "searches for the nearest view in the specified direction that can takeinput focus.",
	"Method": "Object focusSearch(Object info,int direction,Object focusSearch,Object info,int direction,Object focusSearch,Object info,int direction,AccessibilityNodeInfoCompat focusSearch,int direction){\r\n    return AccessibilityNodeInfoCompat.wrapNonNullInstance(IMPL.focusSearch(mInfo, direction));\r\n}"
}, {
	"Path": "mondrian.olap.Util.only",
	"Comment": "returns the sole item in a list.if the list has 0 or more than one element, throws.",
	"Method": "T only(List<T> list){\r\n    if (list.size() != 1) {\r\n        throw new IndexOutOfBoundsException(\"list \" + list + \" has \" + list.size() + \" elements, expected 1\");\r\n    }\r\n    return list.get(0);\r\n}"
}, {
	"Path": "com.codename1.ui.Container.createReplaceTransition",
	"Comment": "this method creates an animation component that replaces the current component with the next component.current component must be contained in this container.this method return immediately.",
	"Method": "ComponentAnimation createReplaceTransition(Component current,Component next,Transition t){\r\n    return replaceComponents(current, next, t, false, false, null, 0, 0, false);\r\n}"
}, {
	"Path": "io.atomix.copycat.test.PerformanceTest.runIteration",
	"Comment": "runs a single performance test iteration, returning the iteration run time.",
	"Method": "long runIteration(){\r\n    reset();\r\n    createServers(3);\r\n    CompletableFuture<Void>[] futures = new CompletableFuture[NUM_CLIENTS];\r\n    CopycatClient[] clients = new CopycatClient[NUM_CLIENTS];\r\n    for (int i = 0; i < NUM_CLIENTS; i++) {\r\n        CompletableFuture<Void> future = new CompletableFuture();\r\n        clients[i] = createClient(RecoveryStrategies.RECOVER);\r\n        futures[i] = future;\r\n    }\r\n    long startTime = System.currentTimeMillis();\r\n    for (int i = 0; i < clients.length; i++) {\r\n        runClient(clients[i], futures[i]);\r\n    }\r\n    CompletableFuture.allOf(futures).join();\r\n    long endTime = System.currentTimeMillis();\r\n    long runTime = endTime - startTime;\r\n    System.out.println(String.format(\"readCount: %d/%d, writeCount: %d/%d, runTime: %dms\", readCount.get(), (int) (TOTAL_OPERATIONS * (WRITE_RATIO / 10d)), writeCount.get(), (int) (TOTAL_OPERATIONS * (1 - (WRITE_RATIO / 10d))), runTime));\r\n    return runTime;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.getShowOnInit",
	"Comment": "this dialog will be shown when this request enters the network queue",
	"Method": "Dialog getShowOnInit(){\r\n    return showOnInit;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.create",
	"Comment": "creates a flat border with styles derived from the component uiid",
	"Method": "RoundRectBorder create(){\r\n    return new RoundRectBorder();\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setEnabled",
	"Comment": "indicates whether component is enabled or disabled thus allowing us to preventa component from receiving input events and indicate so visually",
	"Method": "void setEnabled(boolean enabled){\r\n    if (this.enabled == enabled) {\r\n        return;\r\n    }\r\n    this.enabled = enabled;\r\n    repaint();\r\n}"
}, {
	"Path": "java.lang.Float.isInfinite",
	"Comment": "indicates whether the specified float represents an infinite value.",
	"Method": "boolean isInfinite(boolean isInfinite,float v){\r\n    return (f == POSITIVE_INFINITY) || (f == NEGATIVE_INFINITY);\r\n}"
}, {
	"Path": "java.util.Collections.min",
	"Comment": "searches the specified collection for the minimum element using thespecified comparator.",
	"Method": "T min(Collection<? extends T> collection,T min,Collection<? extends T> collection,Comparator<? super T> comparator){\r\n    if (comparator == null) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        T result = (T) min((Collection<java.lang.Comparable>) collection);\r\n        return result;\r\n    }\r\n    Iterator<? extends T> it = collection.iterator();\r\n    T min = it.next();\r\n    while (it.hasNext()) {\r\n        T next = it.next();\r\n        if (comparator.compare(min, next) > 0) {\r\n            min = next;\r\n        }\r\n    }\r\n    return min;\r\n}"
}, {
	"Path": "java.util.AbstractList.iterator",
	"Comment": "returns an iterator on the elements of this list. the elements areiterated in the same order as they occur in the list.",
	"Method": "Iterator<E> iterator(Iterator<E> iterator){\r\n    return new SimpleListIterator();\r\n}"
}, {
	"Path": "io.atomix.copycat.client.session.ClientSequencerTest.testSequenceEventAbsentCommand",
	"Comment": "tests sequencing an event that arrives before a command response.",
	"Method": "void testSequenceEventAbsentCommand(){\r\n    ClientSequencer sequencer = new ClientSequencer(new ClientSessionState(UUID.randomUUID().toString()));\r\n    PublishRequest request1 = PublishRequest.builder().withSession(1).withEventIndex(2).withPreviousIndex(0).build();\r\n    PublishRequest request2 = PublishRequest.builder().withSession(1).withEventIndex(3).withPreviousIndex(2).build();\r\n    AtomicInteger run = new AtomicInteger();\r\n    sequencer.sequenceEvent(request1, () -> assertEquals(run.getAndIncrement(), 0));\r\n    sequencer.sequenceEvent(request2, () -> assertEquals(run.getAndIncrement(), 1));\r\n    assertEquals(run.get(), 2);\r\n}"
}, {
	"Path": "com.codename1.analytics.AnalyticsService.isAnalyticsEnabled",
	"Comment": "indicates if the analytics is enabled, subclasses must override this method to process their information",
	"Method": "boolean isAnalyticsEnabled(){\r\n    return agent != null;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.getDefaultDialogTransitionIn",
	"Comment": "allows us to define a default animation that will draw the transition forentering a dialog",
	"Method": "Transition getDefaultDialogTransitionIn(){\r\n    return defaultDialogTransitionIn;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.createMedia",
	"Comment": "plays the sound in the given uri which is partially platform specific.",
	"Method": "Media createMedia(String uri,boolean isVideo,Runnable onCompletion,Media createMedia,InputStream stream,String mimeType,Runnable onCompletion){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.tree.Tree.isMultilineMode",
	"Comment": "toggles a mode where rows in the tree can be broken since span buttons willbe used instead of plain buttons.",
	"Method": "boolean isMultilineMode(){\r\n    return multilineMode;\r\n}"
}, {
	"Path": "com.alibaba.citrus.service.upload.impl.cfu.AbstractFileItem.isInMemory",
	"Comment": "provides a hint as to whether or not the file contents will be read frommemory.",
	"Method": "boolean isInMemory(){\r\n    if (cachedContent != null) {\r\n        return true;\r\n    }\r\n    return dfos.isInMemory();\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.reloadForm",
	"Comment": "useful tool to refresh the current state of a form shown using show formwithout pushing another instance to the back stack",
	"Method": "void reloadForm(){\r\n    Form currentForm = Display.getInstance().getCurrent();\r\n    Command backCommand = currentForm.getBackCommand();\r\n    Form newForm = (Form) createContainer(fetchResourceFile(), currentForm.getName());\r\n    if (backCommand != null) {\r\n        setBackCommand(newForm, backCommand);\r\n        getFormListenerInstance(newForm, null);\r\n        for (int iter = 0; iter < currentForm.getCommandCount(); iter++) {\r\n            if (backCommand == currentForm.getCommand(iter)) {\r\n                newForm.addCommand(backCommand, newForm.getCommandCount());\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    beforeShow(newForm);\r\n    Transition tin = newForm.getTransitionInAnimator();\r\n    Transition tout = newForm.getTransitionOutAnimator();\r\n    currentForm.setTransitionInAnimator(CommonTransitions.createEmpty());\r\n    currentForm.setTransitionOutAnimator(CommonTransitions.createEmpty());\r\n    newForm.setTransitionInAnimator(CommonTransitions.createEmpty());\r\n    newForm.setTransitionOutAnimator(CommonTransitions.createEmpty());\r\n    newForm.layoutContainer();\r\n    newForm.show();\r\n    postShowImpl(newForm);\r\n    newForm.setTransitionInAnimator(tin);\r\n    newForm.setTransitionOutAnimator(tout);\r\n}"
}, {
	"Path": "java.util.Calendar.before",
	"Comment": "compares the time field records. equivalent to comparing result of conversion to utc.",
	"Method": "boolean before(java.lang.Object when){\r\n    if (!(calendar instanceof Calendar)) {\r\n        return false;\r\n    }\r\n    return getTimeInMillis() < ((Calendar) calendar).getTimeInMillis();\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.setDefaultDialogTransitionIn",
	"Comment": "allows us to define a default animation that will draw the transition forentering a dialog",
	"Method": "void setDefaultDialogTransitionIn(Transition defaultDialogTransitionIn){\r\n    this.defaultDialogTransitionIn = defaultDialogTransitionIn;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.lang.Character_.isSurrogatePair",
	"Comment": "a test for determining if the char pair is a validsurrogate pair.",
	"Method": "boolean isSurrogatePair(char high,char low){\r\n    return (isHighSurrogate(high) && isLowSurrogate(low));\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSEngine.processAccessKeys",
	"Comment": "tries to assign the given key string as an access key to the specified componentthe key string given here may consist of a multiple key assignment, i.e. several keys seperated with space",
	"Method": "boolean processAccessKeys(String keyStr,HTMLComponent htmlC,Component ui){\r\n    int index = keyStr.indexOf(' ');\r\n    boolean isFirstKey = true;\r\n    while (index != -1) {\r\n        String key = keyStr.substring(0, index).trim();\r\n        keyStr = keyStr.substring(index + 1);\r\n        if (!processAccessKey(key, htmlC, ui, isFirstKey)) {\r\n            return false;\r\n        }\r\n        isFirstKey = false;\r\n        index = keyStr.indexOf(' ');\r\n    }\r\n    return processAccessKey(keyStr, htmlC, ui, isFirstKey);\r\n}"
}, {
	"Path": "com.codename1.push.PushActionCategory.getActions",
	"Comment": "gets the actions in this category.these actions will be manifested as buttons in push notificationsdirected at this category.",
	"Method": "PushAction[] getActions(){\r\n    return actions.toArray(new PushAction[actions.size()]);\r\n}"
}, {
	"Path": "io.atomix.copycat.server.CopycatServer.isRunning",
	"Comment": "returns a boolean indicating whether the server is running.",
	"Method": "boolean isRunning(){\r\n    return started;\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.setDefaultDialogPosition",
	"Comment": "default screen orientation position for the upcoming dialog. by defaultthe dialog will be shown at hardcoded coordinates, this method allows us to pack the dialog appropriately in one of the border layout based locationssee borderlayout for futher details.",
	"Method": "void setDefaultDialogPosition(String p){\r\n    defaultDialogPosition = p;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapStar.lookupSegment",
	"Comment": "looks for an existing aggregation over a given set of columns, in thelocal segment cache, returning null if there is none.must be called from synchronized context.",
	"Method": "Aggregation lookupSegment(AggregationKey aggregationKey){\r\n    return localBars.get().aggregations.get(aggregationKey);\r\n}"
}, {
	"Path": "com.codename1.designer.TimelineEditor.selectFile",
	"Comment": "selects a gif file using a file chooser and converts it to a timeline",
	"Method": "void selectFile(ResourceEditorView view,EditableResources res,String timelineName){\r\n    File[] files = ResourceEditorView.showOpenFileChooser(\"Images\", \".gif\");\r\n    if (files != null) {\r\n        File sel = files[0];\r\n        if (timelineName == null) {\r\n            timelineName = sel.getName();\r\n        }\r\n        Preferences.userNodeForPackage(view.getClass()).put(\"lastDir\", sel.getParentFile().getAbsolutePath());\r\n        ImageReader iReader = ImageIO.getImageReadersBySuffix(\"gif\").next();\r\n        try {\r\n            iReader.setInput(ImageIO.createImageInputStream(new FileInputStream(sel)));\r\n            int frames = iReader.getNumImages(true);\r\n            AnimationObject[] anims = new AnimationObject[frames];\r\n            int currentTime = 0;\r\n            for (int frameIter = 0; frameIter < frames; frameIter++) {\r\n                BufferedImage currentImage = iReader.read(frameIter);\r\n                ByteArrayOutputStream bo = new ByteArrayOutputStream();\r\n                ImageIO.write(currentImage, \"png\", bo);\r\n                bo.close();\r\n                String label = sel.getName() + \" frame:\" + frameIter;\r\n                EncodedImage i = EncodedImage.create(bo.toByteArray());\r\n                res.setImage(label, i);\r\n                int duration = Math.max(40, AnimationImpl.getFrameTime(iReader, frameIter));\r\n                Point pos = AnimationImpl.getPixelOffsets(iReader, frameIter);\r\n                anims[frameIter] = AnimationObject.createAnimationImage(i, pos.x, pos.y);\r\n                anims[frameIter].setStartTime(currentTime);\r\n                anims[frameIter].setEndTime(100000000);\r\n                String disposeMethod = getDisposalMethod(iReader, frameIter);\r\n                if (disposeMethod != null) {\r\n                    if (\"restoreToBackgroundColor\".equals(disposeMethod)) {\r\n                        if (frameIter + 1 < frames) {\r\n                            int t = Math.max(40, AnimationImpl.getFrameTime(iReader, frameIter + 1));\r\n                            anims[frameIter].setEndTime(currentTime + t);\r\n                        } else {\r\n                            anims[frameIter].setEndTime(currentTime + duration);\r\n                        }\r\n                    }\r\n                }\r\n                currentTime += duration;\r\n            }\r\n            Timeline t = Timeline.createTimeline(currentTime, anims, new com.codename1.ui.geom.Dimension(iReader.getWidth(0), iReader.getHeight(0)));\r\n            res.setImage(timelineName, t);\r\n            view.setSelectedResource(timelineName);\r\n        } catch (IOException err) {\r\n            err.printStackTrace();\r\n            JOptionPane.showMessageDialog(JFrame.getFrames()[0], \"Error reading file \" + err, \"IO Error\", JOptionPane.ERROR_MESSAGE);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.tools.translator.Parser.addToConstantPool",
	"Comment": "adds the given string to the hardcoded constant pool strings returns the offset in the pool",
	"Method": "int addToConstantPool(String s){\r\n    int i = constantPool.indexOf(s);\r\n    if (i < 0) {\r\n        constantPool.add(s);\r\n        return constantPool.size() - 1;\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "com.codename1.ui.Image.applyMaskAutoScale",
	"Comment": "applies the given alpha mask onto this image and returns the resulting imagesee the createmask method for indication on how to convert an image into an alphamask. if the image is of a different size it will be scaled to mask size.",
	"Method": "Image applyMaskAutoScale(Object mask){\r\n    try {\r\n        int mWidth = ((IndexedImage) mask).getWidth();\r\n        int mHeight = ((IndexedImage) mask).getHeight();\r\n        if (mWidth != getWidth() || mHeight != getHeight()) {\r\n            return scaled(mWidth, mHeight).applyMask(mask);\r\n        }\r\n        return applyMask(mask);\r\n    } catch (Throwable t) {\r\n        Log.e(t);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.Slider.addActionListener",
	"Comment": "action listeners give a more coarse event only when the user lifts the finger from the slider",
	"Method": "void addActionListener(ActionListener l){\r\n    actionListeners.addListener(l);\r\n}"
}, {
	"Path": "com.codename1.components.InteractionDialog.disposeToTheRight",
	"Comment": "removes the interaction dialog from view with an animation to the right",
	"Method": "void disposeToTheRight(){\r\n    disposeTo(Component.RIGHT);\r\n}"
}, {
	"Path": "java.io.DataInputStream.read",
	"Comment": "see the general contract of the read method of datainput.bytes for this operation are read from the contained input stream.",
	"Method": "int read(int read,byte[] b,int read,byte[] b,int off,int len){\r\n    return 0;\r\n}"
}, {
	"Path": "com.codename1.push.Push.getPushKey",
	"Comment": "returns the push device key if the device was previously successfully registered for pushotherwise returns null",
	"Method": "String getPushKey(){\r\n    String key = Preferences.get(\"push_key\", null);\r\n    if (key != null) {\r\n        if (!key.startsWith(\"cn1-\")) {\r\n            String pushPrefix = Display.getInstance().getProperty(\"cn1_push_prefix\", null);\r\n            if (pushPrefix != null) {\r\n                return \"cn1-\" + pushPrefix + \"-\" + key;\r\n            }\r\n        } else {\r\n            return key;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.TreeSet.subSet",
	"Comment": "answers a sortedset of the specified portion of this treeset whichcontains elements greater or equal to the start element but less than theend element. the returned sortedset is backed by this treeset so changesto one are reflected by the other.",
	"Method": "NavigableSet<E> subSet(E start,boolean startInclusive,E end,boolean endInclusive,SortedSet<E> subSet,E start,E end){\r\n    return subSet(start, true, end, false);\r\n}"
}, {
	"Path": "java.util.AbstractSet.equals",
	"Comment": "compares the specified object to this set and returns true if they areequal. the object must be an instance of set and contain the sameobjects.",
	"Method": "boolean equals(Object object){\r\n    if (this == object) {\r\n        return true;\r\n    }\r\n    if (object instanceof Set) {\r\n        Set<?> s = (Set<?>) object;\r\n        try {\r\n            return size() == s.size() && containsAll(s);\r\n        } catch (NullPointerException ignored) {\r\n            return false;\r\n        } catch (ClassCastException ignored) {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.util.EasyThread.isThisIt",
	"Comment": "returns true if the current thread is the easy thread and false othewise similar to the isedt method",
	"Method": "boolean isThisIt(){\r\n    return t == Thread.currentThread();\r\n}"
}, {
	"Path": "com.codename1.xml.Element.getTextDescendants",
	"Comment": "returns all text descendants containing the specified text",
	"Method": "Vector getTextDescendants(String text,boolean caseSensitive,int depth,Vector getTextDescendants,String text,boolean caseSensitive){\r\n    return getTextDescendants(text, caseSensitive, DEPTH_INFINITE);\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Transition.getDestination",
	"Comment": "returns the destination form that should be set once animation is completed",
	"Method": "Component getDestination(){\r\n    return destination;\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.setVerboseMode",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "void setVerboseMode(boolean v){\r\n    TestUtils.setVerboseMode(v);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Style.isStrikeThru",
	"Comment": "returns true if the strike through text decoration is on, false otherwise",
	"Method": "boolean isStrikeThru(){\r\n    return ((textDecoration & TEXT_DECORATION_STRIKETHRU) != 0);\r\n}"
}, {
	"Path": "com.codename1.processing.AbstractEvaluator._evaluateSingle",
	"Comment": "this internal method simply makes a type safe call the the properabstract method based on the type of element passed.",
	"Method": "Object _evaluateSingle(Object element){\r\n    if (element instanceof List) {\r\n        return evaluateSingle((List) element, expr);\r\n    } else {\r\n        return evaluateSingle((StructuredContent) element, expr);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.indexOf",
	"Comment": "searches in this vector for the index of the specified object. the searchfor the object starts at the specified location and moves towards the endof this vector.",
	"Method": "int indexOf(Object object,int indexOf,Object object,int location){\r\n    if (object != null) {\r\n        for (int i = location; i < elementCount; i++) {\r\n            if (object.equals(elementData[i])) {\r\n                return i;\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = location; i < elementCount; i++) {\r\n            if (elementData[i] == null) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "java.lang.Class.isInterface",
	"Comment": "determines if the specified class object represents an interface type.",
	"Method": "boolean isInterface(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Image.scaledLargerRatio",
	"Comment": "scales the image while maintaining the aspect ratio to the larger size image",
	"Method": "Image scaledLargerRatio(int width,int height){\r\n    float hRatio = ((float) height) / ((float) getHeight());\r\n    float wRatio = ((float) width) / ((float) getWidth());\r\n    if (hRatio > wRatio) {\r\n        return scaled(Math.round(getWidth() * hRatio), height);\r\n    } else {\r\n        return scaled(width, Math.round(getHeight() * wRatio));\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.rest.RequestBuilder.getAsJsonMapAsync",
	"Comment": "executes the request asynchronously and writes the response to the providedcallback",
	"Method": "void getAsJsonMapAsync(Callback<Response<Map>> callback){\r\n    getAsJsonMap(callback, callback);\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetTableModel.setRestoreToggleStates",
	"Comment": "set whether or not this model will restore the toggle states when newproperties are applied.",
	"Method": "void setRestoreToggleStates(boolean value){\r\n    restoreToggleStates = value;\r\n    if (!restoreToggleStates) {\r\n        toggleStates.clear();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.SpanLabel.getIconPosition",
	"Comment": "returns the icon position based on border layout constraints",
	"Method": "String getIconPosition(){\r\n    return (String) getLayout().getComponentConstraint(icon);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.ArrayDeque.removeInternal",
	"Comment": "removes the element in the cursor position and shifts front elements tofill the gap if frontshift is true, shifts rear elements otherwise.",
	"Method": "void removeInternal(int current,boolean frontShift){\r\n    int cursor = current;\r\n    if (frontShift) {\r\n        while (cursor != front) {\r\n            int next = circularSmallerPos(cursor);\r\n            elements[cursor] = elements[next];\r\n            cursor = next;\r\n        }\r\n        front = circularBiggerPos(front);\r\n    } else {\r\n        while (cursor != rear) {\r\n            int next = circularBiggerPos(cursor);\r\n            elements[cursor] = elements[next];\r\n            cursor = next;\r\n        }\r\n        rear = circularSmallerPos(rear);\r\n    }\r\n    elements[cursor] = null;\r\n    resetStatus(false);\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.showMenuDialog",
	"Comment": "a menu is implemented as a dialog, this method allows you to override dialogdisplay in order to customize the dialog menu in various ways",
	"Method": "Command showMenuDialog(Dialog menu){\r\n    UIManager manager = parent.getUIManager();\r\n    boolean pref = manager.isThemeConstant(\"menuPrefSizeBool\", false);\r\n    int height;\r\n    int marginLeft;\r\n    int marginRight = 0;\r\n    if (pref) {\r\n        Container dialogContentPane = menu.getDialogComponent();\r\n        marginLeft = parent.getWidth() - (dialogContentPane.getPreferredW() + menu.getStyle().getHorizontalPadding());\r\n        marginLeft = Math.max(0, marginLeft);\r\n        if (parent.getSoftButtonCount() > 1) {\r\n            height = parent.getHeight() - parent.getSoftButton(0).getParent().getPreferredH() - dialogContentPane.getPreferredH();\r\n        } else {\r\n            height = parent.getHeight() - dialogContentPane.getPreferredH();\r\n        }\r\n        height = Math.max(0, height);\r\n    } else {\r\n        float menuWidthPercent = 1 - Float.parseFloat(manager.getThemeConstant(\"menuWidthPercent\", \"75\")) / 100;\r\n        float menuHeightPercent = 1 - Float.parseFloat(manager.getThemeConstant(\"menuHeightPercent\", \"50\")) / 100;\r\n        height = (int) (parent.getHeight() * menuHeightPercent);\r\n        marginLeft = (int) (parent.getWidth() * menuWidthPercent);\r\n    }\r\n    if (isReverseSoftButtons()) {\r\n        marginRight = marginLeft;\r\n        marginLeft = 0;\r\n    }\r\n    if (getCommandBehavior() == Display.COMMAND_BEHAVIOR_ICS) {\r\n        menu.setTransitionOutAnimator(transitionIn);\r\n        menu.setTransitionInAnimator(transitionOut);\r\n        int th = getTitleAreaContainer().getHeight();\r\n        return menu.show(th, height - th, marginLeft, marginRight, true);\r\n    } else {\r\n        if (manager.getLookAndFeel().isTouchMenus() && manager.isThemeConstant(\"PackTouchMenuBool\", true)) {\r\n            return menu.showPacked(BorderLayout.SOUTH, true);\r\n        } else {\r\n            return menu.show(height, 0, marginLeft, marginRight, true);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.cqengine.persistence.support.serialization.KryoSerializer.serialize",
	"Comment": "serializes the given object, using the given instance of kryo serializer.",
	"Method": "byte[] serialize(O object){\r\n    if (object == null) {\r\n        throw new NullPointerException(\"Object was null\");\r\n    }\r\n    try {\r\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n        Output output = new Output(baos);\r\n        Kryo kryo = kryoCache.get();\r\n        if (polymorphic) {\r\n            kryo.writeClassAndObject(output, object);\r\n        } else {\r\n            kryo.writeObject(output, object);\r\n        }\r\n        output.close();\r\n        return baos.toByteArray();\r\n    } catch (Exception e) {\r\n        throw new IllegalStateException(\"Failed to serialize object, object type: \" + objectType + \". \" + \"Configure @PersistenceConfig.polymorphic if the collection will contain a mix of object types. \" + \"Use the KryoSerializer.validateObjectIsRoundTripSerializable() method \" + \"to test your object is compatible with CQEngine.\", e);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.getComponentForm",
	"Comment": "gets the set of all component forms from components in this set.",
	"Method": "ComponentSelector getComponentForm(){\r\n    HashSet<Component> out = new HashSet<Component>();\r\n    for (Component c : this) {\r\n        out.add(c.getComponentForm());\r\n    }\r\n    return new ComponentSelector(out);\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudException.getErrorCode",
	"Comment": "returns the error code for the cloud exception, see the cloud storage for return codes",
	"Method": "int getErrorCode(){\r\n    return errorCode;\r\n}"
}, {
	"Path": "com.l2fprod.common.swing.plaf.LookAndFeelAddons.getUI",
	"Comment": "workaround for ide mixing up with classloaders and applets environments.consider this method as api private. it must not be called directly.",
	"Method": "ComponentUI getUI(JComponent component,Class expectedUIClass){\r\n    maybeInitialize();\r\n    String uiClassname = (String) UIManager.get(component.getUIClassID());\r\n    try {\r\n        Class uiClass = Class.forName(uiClassname);\r\n        UIManager.put(uiClassname, uiClass);\r\n    } catch (Exception e) {\r\n    }\r\n    ComponentUI ui = UIManager.getUI(component);\r\n    if (expectedUIClass.isInstance(ui)) {\r\n        return ui;\r\n    } else {\r\n        String realUI = ui.getClass().getName();\r\n        Class realUIClass;\r\n        try {\r\n            realUIClass = expectedUIClass.getClassLoader().loadClass(realUI);\r\n        } catch (ClassNotFoundException e) {\r\n            throw new RuntimeException(\"Failed to load class \" + realUI, e);\r\n        }\r\n        Method createUIMethod = null;\r\n        try {\r\n            createUIMethod = realUIClass.getMethod(\"createUI\", new Class[] { JComponent.class });\r\n        } catch (NoSuchMethodException e1) {\r\n            throw new RuntimeException(\"Class \" + realUI + \" has no method createUI(JComponent)\");\r\n        }\r\n        try {\r\n            return (ComponentUI) createUIMethod.invoke(null, new Object[] { component });\r\n        } catch (Exception e2) {\r\n            throw new RuntimeException(\"Failed to invoke \" + realUI + \"#createUI(JComponent)\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayeredLayout.setReferencePositionLeft",
	"Comment": "sets the left inset reference position.only applicable if the top inset has a referencecomponent specified.",
	"Method": "LayeredLayout setReferencePositionLeft(Component cmp,float position){\r\n    getOrCreateConstraint(cmp).left().referencePosition(position);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.isAuthenticated",
	"Comment": "this method returns true if the user is authenticated to the facebook service.",
	"Method": "boolean isAuthenticated(){\r\n    return token != null;\r\n}"
}, {
	"Path": "com.codename1.util.regex.RECompiler.nodeInsert",
	"Comment": "inserts a node with a given opcode and opdata at insertat.the node relative nextpointer is initialized to 0.",
	"Method": "void nodeInsert(char opcode,int opdata,int insertAt){\r\n    ensure(RE.nodeSize);\r\n    System.arraycopy(instruction, insertAt, instruction, insertAt + RE.nodeSize, lenInstruction - insertAt);\r\n    instruction[insertAt] = opcode;\r\n    instruction[insertAt + RE.offsetOpdata] = (char) opdata;\r\n    instruction[insertAt + RE.offsetNext] = 0;\r\n    lenInstruction += RE.nodeSize;\r\n}"
}, {
	"Path": "android.support.v4.view.ViewPager.canScroll",
	"Comment": "tests scrollability within child views of v given a delta of dx.",
	"Method": "boolean canScroll(View v,boolean checkV,int dx,int x,int y,boolean canScroll){\r\n    if (v instanceof ViewGroup) {\r\n        final ViewGroup group = (ViewGroup) v;\r\n        final int scrollX = v.getScrollX();\r\n        final int scrollY = v.getScrollY();\r\n        final int count = group.getChildCount();\r\n        for (int i = count - 1; i >= 0; i--) {\r\n            final View child = group.getChildAt(i);\r\n            if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && canScroll(child, true, dx, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return checkV && ViewCompat.canScrollHorizontally(v, -dx);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isContactsPermissionGranted",
	"Comment": "some platforms allow the user to block contacts access on a per application basis this methodreturns true if the user denied permission to access contacts. this can allow you to customize the errormessage presented to the user.",
	"Method": "boolean isContactsPermissionGranted(){\r\n    return impl.isContactsPermissionGranted();\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.DefaultLookAndFeel.isRTLOrWhitespace",
	"Comment": "returns true if the given character is an rtl character or a spacecharacter",
	"Method": "boolean isRTLOrWhitespace(char c){\r\n    return (Display.getInstance().isRTL(c)) || c == ' ';\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.net.URIHelper.getParameters",
	"Comment": "since a uri query can contain a single key multiple times, the responding\tparameter map will contain string values when a key appears only once,\tand string arrays when they key appears multiple times.",
	"Method": "Hashtable<String, Object> getParameters(URI uri){\r\n    try {\r\n        return parseQuery(uri.getQuery(), true);\r\n    } catch (URISyntaxException e) {\r\n        e.printStackTrace();\r\n        throw new IllegalArgumentException(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.startThread",
	"Comment": "some devices need more elaborate thread creation logic e.g. to increase thedefault stack size or might use a pooling strategy",
	"Method": "void startThread(String name,Runnable r){\r\n    new CodenameOneThread(r, name).start();\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.canGetSSLCertificates",
	"Comment": "checks to see if the platform supports getting ssl certificates.",
	"Method": "boolean canGetSSLCertificates(){\r\n    return Util.getImplementation().canGetSSLCertificates();\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSElement.getSelectorPseudoClass",
	"Comment": "this method assumes that calcselectorspecificity was invoked before.",
	"Method": "int getSelectorPseudoClass(){\r\n    return selectorPseudoClass;\r\n}"
}, {
	"Path": "com.l2fprod.common.swing.UserPreferences.getDirectoryChooser",
	"Comment": "gets the directory chooser with the given id. its current directory will betracked and restored on subsequent calls.",
	"Method": "JFileChooser getDirectoryChooser(String id){\r\n    JFileChooser chooser;\r\n    try {\r\n        Class directoryChooserClass = Class.forName(\"com.l2fprod.common.swing.JDirectoryChooser\");\r\n        chooser = (JFileChooser) directoryChooserClass.newInstance();\r\n    } catch (Exception e) {\r\n        chooser = new JFileChooser();\r\n        chooser.setFileSelectionMode(JFileChooser.DIRECTORIES_ONLY);\r\n    }\r\n    track(chooser, \"DirectoryChooser.\" + id + \".path\");\r\n    return chooser;\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.setTwoDigitMode",
	"Comment": "when set to true days will be rendered as 2 digits with 0 precedingsingle digit days",
	"Method": "void setTwoDigitMode(boolean twoDigitMode){\r\n    this.twoDigitMode = twoDigitMode;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.addEdtErrorHandler",
	"Comment": "an error handler will receive an action event with the source exception from the edtonce an error handler is installed the default codename one error dialog will no longer appear",
	"Method": "void addEdtErrorHandler(ActionListener e){\r\n    Display.INSTANCE.addEdtErrorHandler(e);\r\n}"
}, {
	"Path": "com.codename1.ui.animations.ComponentAnimation.addOnCompleteCall",
	"Comment": "invokes the runnable just as the animation finishes thus allowing cleanup of the ui for the upcoming animations, this is useful when running a complex sequence",
	"Method": "void addOnCompleteCall(Runnable r){\r\n    if (post == null) {\r\n        post = new ArrayList<Runnable>();\r\n    }\r\n    post.add(r);\r\n}"
}, {
	"Path": "com.codename1.location.LocationManager.getLocationListener",
	"Comment": "allows the implementation to notify the location listener of changes to location",
	"Method": "LocationListener getLocationListener(){\r\n    return listener;\r\n}"
}, {
	"Path": "com.codename1.properties.SQLMap.getTableName",
	"Comment": "by default the table name matches the property index name unless explicitly modified with this method",
	"Method": "String getTableName(PropertyBusinessObject cmp){\r\n    String s = (String) cmp.getPropertyIndex().getMetaDataOfClass(\"cn1$tableName\");\r\n    if (s != null) {\r\n        return s;\r\n    }\r\n    return cmp.getPropertyIndex().getName();\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLElement.recalcUi",
	"Comment": "causes a recalculation of the ui, if the ui of this element was deduced from children components",
	"Method": "void recalcUi(){\r\n    if (calculatedUi) {\r\n        comps = null;\r\n        calculatedUi = false;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.table.TableLayout.setTruncateHorizontally",
	"Comment": "indicates whether the table should be truncated if it do not have enough available horizontal space to display all its content. if not, will shrink",
	"Method": "void setTruncateHorizontally(boolean truncateHorizontally){\r\n    this.truncateHorizontally = truncateHorizontally;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.LC.minWidth",
	"Comment": "the minimum width for the container. the value will override any value that is set on the container itself.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcontainers.com.",
	"Method": "LC minWidth(String width){\r\n    setWidth(LayoutUtil.derive(getWidth(), ConstraintParser.parseUnitValue(width, true), null, null));\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.io.gzip.Deflate.compress_block",
	"Comment": "send the block data compressed using the given huffman trees",
	"Method": "void compress_block(short[] ltree,short[] dtree){\r\n    int dist;\r\n    int lc;\r\n    int lx = 0;\r\n    int code;\r\n    int extra;\r\n    if (last_lit != 0) {\r\n        do {\r\n            dist = ((pending_buf[d_buf + lx * 2] << 8) & 0xff00) | (pending_buf[d_buf + lx * 2 + 1] & 0xff);\r\n            lc = (pending_buf[l_buf + lx]) & 0xff;\r\n            lx++;\r\n            if (dist == 0) {\r\n                send_code(lc, ltree);\r\n            } else {\r\n                code = Tree._length_code[lc];\r\n                send_code(code + LITERALS + 1, ltree);\r\n                extra = Tree.extra_lbits[code];\r\n                if (extra != 0) {\r\n                    lc -= Tree.base_length[code];\r\n                    send_bits(lc, extra);\r\n                }\r\n                dist--;\r\n                code = Tree.d_code(dist);\r\n                send_code(code, dtree);\r\n                extra = Tree.extra_dbits[code];\r\n                if (extra != 0) {\r\n                    dist -= Tree.base_dist[code];\r\n                    send_bits(dist, extra);\r\n                }\r\n            }\r\n        } while (lx < last_lit);\r\n    }\r\n    send_code(END_BLOCK, ltree);\r\n    last_eob_len = ltree[END_BLOCK * 2 + 1];\r\n}"
}, {
	"Path": "com.codename1.ui.Display.getCrashReporter",
	"Comment": "the crash reporter gets invoked when an uncaught exception is intercepted",
	"Method": "CrashReport getCrashReporter(){\r\n    return crashReporter;\r\n}"
}, {
	"Path": "com.codename1.ui.table.TableLayout.getCellVerticalSpan",
	"Comment": "returns the spanning for the table cell at the given coordinate",
	"Method": "int getCellVerticalSpan(int row,int column){\r\n    return tablePositions[row * columns + column].spanVertical;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.equals",
	"Comment": "compares the specified object to this vector and returns if they areequal. the object must be a list which contains the same objects in thesame order.",
	"Method": "boolean equals(Object object){\r\n    if (this == object) {\r\n        return true;\r\n    }\r\n    if (object instanceof List) {\r\n        List<?> list = (List<?>) object;\r\n        if (list.size() != elementCount) {\r\n            return false;\r\n        }\r\n        int index = 0;\r\n        Iterator<?> it = list.iterator();\r\n        while (it.hasNext()) {\r\n            Object e1 = elementData[index++], e2 = it.next();\r\n            if (!(e1 == null ? e2 == null : e1.equals(e2))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.addEdtErrorHandler",
	"Comment": "an error handler will receive an action event with the source exception from the edtonce an error handler is installed the default codename one error dialog will no longer appear",
	"Method": "void addEdtErrorHandler(ActionListener e){\r\n    if (errorHandler == null) {\r\n        errorHandler = new EventDispatcher();\r\n    }\r\n    errorHandler.addListener(e);\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.builders.ThumbnailParameterBuilder.region",
	"Comment": "sets the region of the source image to use when creating a thumbnail.",
	"Method": "ThumbnailParameterBuilder region(Region sourceRegion){\r\n    this.sourceRegion = sourceRegion;\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.usesInvokeAndBlockForEditString",
	"Comment": "using invokeandblock inside editstring creates peculiar behaviour that needsto be worked around.ideally no port should use invokeandblock for thisbut currently javase and uwp both do.need to be able to detect thisfor workarounds.",
	"Method": "boolean usesInvokeAndBlockForEditString(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.lastChild",
	"Comment": "creates new set consisting of the last child of each component in the current set.",
	"Method": "ComponentSelector lastChild(){\r\n    HashSet<Component> out = new HashSet<Component>();\r\n    for (Component c : this) {\r\n        if (c instanceof Container) {\r\n            Container cnt = (Container) c;\r\n            if (cnt.getComponentCount() > 0) {\r\n                out.add(cnt.getComponentAt(cnt.getComponentCount() - 1));\r\n            }\r\n        }\r\n    }\r\n    return new ComponentSelector(out);\r\n}"
}, {
	"Path": "com.codename1.impl.FullScreenAdService.showWelcomeAd",
	"Comment": "invoked on application startup, this code will download an ad or timeout",
	"Method": "void showWelcomeAd(){\r\n    if (!UIManager.getInstance().wasThemeInstalled()) {\r\n        if (Display.getInstance().hasNativeTheme()) {\r\n            Display.getInstance().installNativeTheme();\r\n        }\r\n    }\r\n    ConnectionRequest r = createAdRequest();\r\n    r.setPriority(ConnectionRequest.PRIORITY_HIGH);\r\n    r.setTimeout(timeout);\r\n    InfiniteProgress ip = new InfiniteProgress();\r\n    Dialog ipDialog = ip.showInifiniteBlocking();\r\n    NetworkManager.getInstance().addToQueueAndWait(r);\r\n    if (failed()) {\r\n        ipDialog.dispose();\r\n        if (!allowWithoutNetwork) {\r\n            ipDialog.dispose();\r\n            Dialog.show(\"Network Error\", \"Please try again later\", \"Exit\", null);\r\n            Display.getInstance().exitApplication();\r\n        } else {\r\n            return;\r\n        }\r\n    }\r\n    Component c = getPendingAd();\r\n    if (c != null) {\r\n        Form adForm = new AdForm(c);\r\n        adForm.setTransitionInAnimator(CommonTransitions.createEmpty());\r\n        adForm.setTransitionOutAnimator(CommonTransitions.createEmpty());\r\n        adForm.show();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.Storage.setStorageInstance",
	"Comment": "allows installing a custom storage instance to provide functionality such as seamless encryption",
	"Method": "void setStorageInstance(Storage s){\r\n    INSTANCE = s;\r\n}"
}, {
	"Path": "com.codename1.maps.Tile.setTileLoadingImage",
	"Comment": "sets a static image that will be drawn on the map if the tile image is not available yet.",
	"Method": "void setTileLoadingImage(Image tileLoadingImage){\r\n    Tile.tileLoadingImage = tileLoadingImage;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setHeight",
	"Comment": "sets the component height, this method is exposed for the purpose of external layout managers and should not be invoked directly.if a user wishes to effect the component size setpreferredsize shouldbe used.",
	"Method": "void setHeight(int height){\r\n    bounds.getSize().setHeight(height);\r\n}"
}, {
	"Path": "com.codename1.io.BufferedOutputStream.setConnection",
	"Comment": "if applicable this member represents the connection object for the stream",
	"Method": "void setConnection(Object connection){\r\n    this.connection = connection;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GridLayout.encloseIn",
	"Comment": "creates a new container with the grid layout and the components added to it",
	"Method": "Container encloseIn(Component cmp,Container encloseIn,int columns,Component cmp){\r\n    return Container.encloseIn(new GridLayout(columns), cmp);\r\n}"
}, {
	"Path": "ly.count.android.sdk.UserData.fromJSON",
	"Comment": "sets user data fields to values from its json representation.",
	"Method": "void fromJSON(JSONObject json){\r\n    if (json != null) {\r\n        name = json.optString(NAME_KEY, null);\r\n        username = json.optString(USERNAME_KEY, null);\r\n        email = json.optString(EMAIL_KEY, null);\r\n        org = json.optString(ORG_KEY, null);\r\n        phone = json.optString(PHONE_KEY, null);\r\n        picture = json.optString(PICTURE_KEY, null);\r\n        gender = json.optString(GENDER_KEY, null);\r\n        byear = json.optInt(BYEAR_KEY, 0);\r\n        if (!json.isNull(CUSTOM_KEY)) {\r\n            JSONObject customJson;\r\n            try {\r\n                customJson = json.getJSONObject(CUSTOM_KEY);\r\n                custom = new HashMap(customJson.length());\r\n                Iterator<String> nameItr = customJson.keys();\r\n                while (nameItr.hasNext()) {\r\n                    final String key = nameItr.next();\r\n                    if (!customJson.isNull(key)) {\r\n                        custom.put(key, customJson.getString(key));\r\n                    }\r\n                }\r\n            } catch (JSONException e) {\r\n                if (Countly.sharedInstance().isLoggingEnabled()) {\r\n                    Log.w(Countly.TAG, \"Got exception converting an Custom Json to Custom User data\", e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.removeAll",
	"Comment": "removes all of the components in the provided collection from the result set.",
	"Method": "boolean removeAll(Collection<?> c,ComponentSelector removeAll,Collection<?> c,boolean chain,ComponentSelector removeAll){\r\n    for (Component c : this) {\r\n        if (c instanceof Container) {\r\n            ((Container) c).removeAll();\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.conscrypt.java.security.TestKeyStore.getIssuer",
	"Comment": "return the issuing ca certificate of the givencertificate. throws illegalstateexception if there are are moreor less than one.",
	"Method": "Certificate getIssuer(Certificate cert){\r\n    return issuer(keyStore, cert);\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.initLaf",
	"Comment": "initialize the default transition for the dialogs overriding the formstransition",
	"Method": "void initLaf(UIManager uim){\r\n    super.initLaf(uim);\r\n    setTransitionOutAnimator(uim.getLookAndFeel().getDefaultDialogTransitionOut());\r\n    setTransitionInAnimator(uim.getLookAndFeel().getDefaultDialogTransitionIn());\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetTable.setModel",
	"Comment": "overriden to register a listener on the model. this listener ensuresediting is cancelled when editing row is being changed.",
	"Method": "void setModel(TableModel newModel){\r\n    if (!(newModel instanceof PropertySheetTableModel)) {\r\n        throw new IllegalArgumentException(\"dataModel must be of type \" + PropertySheetTableModel.class.getName());\r\n    }\r\n    if (cancelEditing == null) {\r\n        cancelEditing = new CancelEditing();\r\n    }\r\n    TableModel oldModel = getModel();\r\n    if (oldModel != null) {\r\n        oldModel.removeTableModelListener(cancelEditing);\r\n    }\r\n    super.setModel(newModel);\r\n    newModel.addTableModelListener(cancelEditing);\r\n    getColumnModel().getColumn(1).setResizable(false);\r\n}"
}, {
	"Path": "com.codename1.ui.table.Table.isIncludeHeader",
	"Comment": "indicates whether the table should render a table header as the first row",
	"Method": "boolean isIncludeHeader(){\r\n    return includeHeader;\r\n}"
}, {
	"Path": "java.lang.Float.parseFloat",
	"Comment": "returns a new float initialized to the value represented by the specified string.",
	"Method": "float parseFloat(java.lang.String s){\r\n    return StringToReal.parseFloat(s);\r\n}"
}, {
	"Path": "com.codename1.charts.renderers.DefaultRenderer.getSelectableBuffer",
	"Comment": "returns the selectable radius value around clickable points.",
	"Method": "int getSelectableBuffer(){\r\n    return selectableBuffer;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.paintBackground",
	"Comment": "exposing the background painting for the benefit of animations",
	"Method": "void paintBackground(Graphics g){\r\n    super.paintBackground(g);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.isFadeScrollEdge",
	"Comment": "indicates whether the edge of a scrollable area should fade out",
	"Method": "boolean isFadeScrollEdge(){\r\n    return fadeScrollEdge;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.setFocusedInstance",
	"Comment": "allows us to define a border that will act as the focused version of this border",
	"Method": "void setFocusedInstance(Border focused){\r\n    focusBorder = focused;\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSEngine.setFontRecursive",
	"Comment": "sets the font of the component and all its children to the closest font that can be found according to the specified properties",
	"Method": "void setFontRecursive(HTMLComponent htmlC,Component cmp,String fontFamily,int fontSize,int fontStyle,int fontWeight,CSSElement selector){\r\n    if (cmp instanceof Container) {\r\n        Container cont = (Container) cmp;\r\n        for (int i = 0; i < cont.getComponentCount(); i++) {\r\n            setFontRecursive(htmlC, cont.getComponentAt(i), fontFamily, fontSize, fontStyle, fontWeight, selector);\r\n        }\r\n    } else if (cmp instanceof Label) {\r\n        setMatchingFont(htmlC, cmp, fontFamily, fontSize, fontStyle, fontWeight, selector);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.translator.NameTranslator.getClassMirrorTranslationDescriptor",
	"Comment": "translates the name only if it represents a fully mirrored class.",
	"Method": "String getClassMirrorTranslationDescriptor(String name){\r\n    if (name == null) {\r\n        return null;\r\n    }\r\n    final StringBuffer buffer = new StringBuffer();\r\n    translate(true, name, buffer, 0, name.length());\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.fadeOut",
	"Comment": "fades out components in this set.uses default duration of 500ms.",
	"Method": "ComponentSelector fadeOut(ComponentSelector fadeOut,int duration,ComponentSelector fadeOut,int duration,SuccessCallback<ComponentSelector> callback){\r\n    final String placeholderProperty = \"com.codename1.ui.ComponentSelector#fadeOutPlaceholder\";\r\n    AnimationManager mgr = null;\r\n    ArrayList<ComponentAnimation> animations = new ArrayList<ComponentAnimation>();\r\n    final ArrayList<Component> animatingComponents = new ArrayList<Component>();\r\n    for (Component c : this) {\r\n        Container parent = c.getParent();\r\n        if (parent != null) {\r\n            AnimationManager cmgr = c.getAnimationManager();\r\n            if (cmgr != null) {\r\n                mgr = cmgr;\r\n                Container placeholder = new Container();\r\n                c.putClientProperty(placeholderProperty, placeholder);\r\n                Component.setSameHeight(placeholder, c);\r\n                Component.setSameWidth(placeholder, c);\r\n                $(placeholder).setMargin(c.getStyle().getMarginTop(), c.getStyle().getMarginRight(false), c.getStyle().getMarginBottom(), c.getStyle().getMarginLeft(false)).setPadding(c.getStyle().getPaddingTop(), c.getStyle().getPaddingRight(false), c.getStyle().getPaddingBottom(), c.getStyle().getPaddingLeft(false));\r\n                ComponentAnimation a = parent.createReplaceTransition(c, placeholder, CommonTransitions.createFade(duration));\r\n                animations.add(a);\r\n                animatingComponents.add(c);\r\n            }\r\n        }\r\n    }\r\n    if (mgr != null) {\r\n        mgr.addAnimation(ComponentAnimation.compoundAnimation(animations.toArray(new ComponentAnimation[animations.size()])), new Runnable() {\r\n            public void run() {\r\n                for (final Component c : animatingComponents) {\r\n                    c.setVisible(false);\r\n                    final Container placeholder = (Container) c.getClientProperty(placeholderProperty);\r\n                    c.putClientProperty(placeholderProperty, null);\r\n                    if (placeholder != null) {\r\n                        Container parent = placeholder.getParent();\r\n                        if (parent != null) {\r\n                            parent.replace(placeholder, c, CommonTransitions.createEmpty());\r\n                        }\r\n                    }\r\n                }\r\n                if (callback != null) {\r\n                    callback.onSucess(ComponentSelector.this);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.fadeOut",
	"Comment": "fades out components in this set.uses default duration of 500ms.",
	"Method": "ComponentSelector fadeOut(ComponentSelector fadeOut,int duration,ComponentSelector fadeOut,int duration,SuccessCallback<ComponentSelector> callback){\r\n    for (final Component c : animatingComponents) {\r\n        c.setVisible(false);\r\n        final Container placeholder = (Container) c.getClientProperty(placeholderProperty);\r\n        c.putClientProperty(placeholderProperty, null);\r\n        if (placeholder != null) {\r\n            Container parent = placeholder.getParent();\r\n            if (parent != null) {\r\n                parent.replace(placeholder, c, CommonTransitions.createEmpty());\r\n            }\r\n        }\r\n    }\r\n    if (callback != null) {\r\n        callback.onSucess(ComponentSelector.this);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.isFlatten",
	"Comment": "makes the component effectively opaque by blending the backgrounds into an image in memory so the layer of underlying componentsis only drawn once when this component is repainted. this does have a significant memory overhead.",
	"Method": "boolean isFlatten(){\r\n    return flatten;\r\n}"
}, {
	"Path": "com.codename1.ui.Label.setIcon",
	"Comment": "sets the label icon, if the icon is unmodified a repaint would not be triggered",
	"Method": "void setIcon(Image icon){\r\n    if (this.icon == icon) {\r\n        return;\r\n    }\r\n    widthAtLastCheck = -1;\r\n    if (icon != null) {\r\n        if (icon.requiresDrawImage()) {\r\n            legacyRenderer = true;\r\n        }\r\n        if (mask != null) {\r\n            maskedIcon = icon.applyMaskAutoScale(mask);\r\n        }\r\n    }\r\n    this.icon = icon;\r\n    setShouldCalcPreferredSize(true);\r\n    checkAnimation();\r\n    repaint();\r\n}"
}, {
	"Path": "com.codename1.util.TMathContext.getPrecision",
	"Comment": "returns the precision. the precision is the number of digits used for anoperation. results are rounded to this precision. the precision isguaranteed to be non negative. if the precision is zero, then thecomputations have to be performed exact, results are not rounded in thiscase.",
	"Method": "int getPrecision(){\r\n    return precision;\r\n}"
}, {
	"Path": "sort.Partition.partition",
	"Comment": "but additionally places separator at the end of the first group",
	"Method": "int partition(int[] a,int fromInclusive,int toExclusive,int separatorIndex){\r\n    int i = fromInclusive;\r\n    int j = toExclusive - 1;\r\n    int separator = a[separatorIndex];\r\n    swap(a, i++, separatorIndex);\r\n    while (i <= j) {\r\n        while (i <= j && a[i] < separator) ++i;\r\n        while (i <= j && a[j] > separator) --j;\r\n        if (i >= j)\r\n            break;\r\n        swap(a, i++, j--);\r\n    }\r\n    swap(a, j, fromInclusive);\r\n    return j;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.listFiles",
	"Comment": "lists the files within the given directory, returns relative file names and notfull file names.",
	"Method": "String[] listFiles(String directory){\r\n    return FileSystemStorage.getInstance().listFiles(directory);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getNextFocusRight",
	"Comment": "allows us to determine which component will receive focus next when traversing with the right key",
	"Method": "Component getNextFocusRight(){\r\n    return nextFocusRight;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.getAPName",
	"Comment": "returns the user displayable name for the given access point",
	"Method": "String getAPName(String id){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.deinitialize",
	"Comment": "if the component is taken off for any reason, makes sure access keys are not active",
	"Method": "void deinitialize(){\r\n    super.deinitialize();\r\n    for (Enumeration e = accessKeys.keys(); e.hasMoreElements(); ) {\r\n        int keyCode = ((Integer) e.nextElement()).intValue();\r\n        getComponentForm().removeKeyListener(keyCode, this);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.Grid.calcRowsOrColsSizes",
	"Comment": "calculates min, preferred and max size for the columns or rows.",
	"Method": "FlowSizeSpec calcRowsOrColsSizes(boolean isHor,int containerSize){\r\n    ArrayList<LinkedDimGroup>[] groupsLists = isHor ? colGroupLists : rowGroupLists;\r\n    Float[] defPush = isHor ? pushXs : pushYs;\r\n    if (containerSize <= 0) {\r\n        containerSize = isHor ? container.getWidth() : container.getHeight();\r\n    }\r\n    BoundSize cSz = isHor ? lc.getWidth() : lc.getHeight();\r\n    if (!cSz.isUnset()) {\r\n        containerSize = cSz.constrain(containerSize, getParentSize(container, isHor), container);\r\n    }\r\n    DimConstraint[] primDCs = (isHor ? colConstr : rowConstr).getConstaints();\r\n    TreeSet<Integer> primIndexes = isHor ? colIndexes : rowIndexes;\r\n    int[][] rowColBoundSizes = new int[primIndexes.size()][];\r\n    HashMap<String, int[]> sizeGroupMap = new HashMap<String, int[]>(4);\r\n    DimConstraint[] allDCs = new DimConstraint[primIndexes.size()];\r\n    Iterator<Integer> primIt = primIndexes.iterator();\r\n    for (int r = 0; r < rowColBoundSizes.length; r++) {\r\n        int cellIx = primIt.next();\r\n        int[] rowColSizes = new int[3];\r\n        if (cellIx >= -MAX_GRID && cellIx <= MAX_GRID) {\r\n            allDCs[r] = primDCs[cellIx >= primDCs.length ? primDCs.length - 1 : cellIx];\r\n        } else {\r\n            allDCs[r] = DOCK_DIM_CONSTRAINT;\r\n        }\r\n        ArrayList<LinkedDimGroup> groups = groupsLists[r];\r\n        int[] groupSizes = new int[] { getTotalGroupsSizeParallel(groups, LayoutUtil.MIN, false), getTotalGroupsSizeParallel(groups, LayoutUtil.PREF, false), LayoutUtil.INF };\r\n        correctMinMax(groupSizes);\r\n        BoundSize dimSize = allDCs[r].getSize();\r\n        for (int sType = LayoutUtil.MIN; sType <= LayoutUtil.MAX; sType++) {\r\n            int rowColSize = groupSizes[sType];\r\n            UnitValue uv = dimSize.getSize(sType);\r\n            if (uv != null) {\r\n                int unit = uv.getUnit();\r\n                if (unit == UnitValue.PREF_SIZE) {\r\n                    rowColSize = groupSizes[LayoutUtil.PREF];\r\n                } else if (unit == UnitValue.MIN_SIZE) {\r\n                    rowColSize = groupSizes[LayoutUtil.MIN];\r\n                } else if (unit == UnitValue.MAX_SIZE) {\r\n                    rowColSize = groupSizes[LayoutUtil.MAX];\r\n                } else {\r\n                    rowColSize = uv.getPixels(containerSize, container, null);\r\n                }\r\n            } else if (cellIx >= -MAX_GRID && cellIx <= MAX_GRID && rowColSize == 0) {\r\n                rowColSize = LayoutUtil.isDesignTime(container) ? LayoutUtil.getDesignTimeEmptySize() : 0;\r\n            }\r\n            rowColSizes[sType] = rowColSize;\r\n        }\r\n        correctMinMax(rowColSizes);\r\n        addToSizeGroup(sizeGroupMap, allDCs[r].getSizeGroup(), rowColSizes);\r\n        rowColBoundSizes[r] = rowColSizes;\r\n    }\r\n    if (sizeGroupMap.size() > 0) {\r\n        for (int r = 0; r < rowColBoundSizes.length; r++) {\r\n            if (allDCs[r].getSizeGroup() != null) {\r\n                rowColBoundSizes[r] = sizeGroupMap.get(allDCs[r].getSizeGroup());\r\n            }\r\n        }\r\n    }\r\n    ResizeConstraint[] resConstrs = getRowResizeConstraints(allDCs);\r\n    boolean[] fillInPushGaps = new boolean[allDCs.length + 1];\r\n    int[][] gapSizes = getRowGaps(allDCs, containerSize, isHor, fillInPushGaps);\r\n    FlowSizeSpec fss = mergeSizesGapsAndResConstrs(resConstrs, fillInPushGaps, rowColBoundSizes, gapSizes);\r\n    adjustMinPrefForSpanningComps(allDCs, defPush, fss, groupsLists);\r\n    return fss;\r\n}"
}, {
	"Path": "com.codename1.components.SplitPane.setTop",
	"Comment": "sets the component that should be placed in the top section of the split pane.",
	"Method": "void setTop(Component cmp){\r\n    setTopOrLeftComponent(cmp);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLFont.getFace",
	"Comment": "return optional operation returning the font face for system fonts",
	"Method": "int getFace(){\r\n    return font.getFace();\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.setChunkedStreamingMode",
	"Comment": "this method is used to enable streaming of a http request body without internal buffering, when the content length is not known in advance. in this mode, chunked transfer encoding is used to send the request body. note, not all http servers support this mode.this mode is supported on android and the desktop ports.",
	"Method": "void setChunkedStreamingMode(int chunklen){\r\n    this.chunkedStreamingLen = chunklen;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.set",
	"Comment": "replaces the element at the specified location in this vector with thespecified object.",
	"Method": "E set(int location,E object){\r\n    if (location < elementCount) {\r\n        E result = (E) elementData[location];\r\n        elementData[location] = object;\r\n        return result;\r\n    }\r\n    throw new ArrayIndexOutOfBoundsException(location);\r\n}"
}, {
	"Path": "com.codename1.ui.List.getFixedSelection",
	"Comment": "indicates whether selection is fixable to place in which case all theelements in the list move and selection stays in place.",
	"Method": "int getFixedSelection(){\r\n    return fixedSelection;\r\n}"
}, {
	"Path": "com.codename1.io.Preferences.getAndSet",
	"Comment": "gets the value as a number if the value is null def is returned and saved",
	"Method": "String getAndSet(String pref,String def,int getAndSet,String pref,int def,long getAndSet,String pref,long def,double getAndSet,String pref,double def,float getAndSet,String pref,float def,boolean getAndSet,String pref,boolean def){\r\n    Boolean t = (Boolean) get().get(pref);\r\n    if (t == null) {\r\n        set(pref, def);\r\n        return def;\r\n    }\r\n    return t.booleanValue();\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.shadowSpread",
	"Comment": "sets the spread in pixels of the shadow i.e how much bigger is it than the actual border",
	"Method": "RoundRectBorder shadowSpread(float shadowSpread,RoundRectBorder shadowSpread,int shadowSpread){\r\n    this.shadowSpread = shadowSpread * 100f / Display.getInstance().convertToPixels(100f);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.List.isMutableRendererBackgrounds",
	"Comment": "indicates that the background of a cell renderer might mutate between one entry and the next,it is recommended that this flag remains false for performance reasons.",
	"Method": "boolean isMutableRendererBackgrounds(){\r\n    return mutableRendererBackgrounds;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.Grid.divideIntoLinkedGroups",
	"Comment": "for one dimension divide the component wraps into logical groups. onegroup for component wraps that share a common something, line theproperty to layout by base line.",
	"Method": "ArrayList<LinkedDimGroup>[] divideIntoLinkedGroups(boolean isRows){\r\n    boolean fromEnd = !(isRows ? lc.isTopToBottom() : LayoutUtil.isLeftToRight(lc, container));\r\n    TreeSet<Integer> primIndexes = isRows ? rowIndexes : colIndexes;\r\n    TreeSet<Integer> secIndexes = isRows ? colIndexes : rowIndexes;\r\n    DimConstraint[] primDCs = (isRows ? rowConstr : colConstr).getConstaints();\r\n    @SuppressWarnings(\"unchecked\")\r\n    ArrayList<LinkedDimGroup>[] groupLists = new ArrayList[primIndexes.size()];\r\n    int gIx = 0;\r\n    for (int i : primIndexes) {\r\n        DimConstraint dc;\r\n        if (i >= -MAX_GRID && i <= MAX_GRID) {\r\n            dc = primDCs[i >= primDCs.length ? primDCs.length - 1 : i];\r\n        } else {\r\n            dc = DOCK_DIM_CONSTRAINT;\r\n        }\r\n        ArrayList<LinkedDimGroup> groupList = new ArrayList<LinkedDimGroup>(4);\r\n        groupLists[gIx++] = groupList;\r\n        for (Integer ix : secIndexes) {\r\n            Cell cell = isRows ? getCell(i, ix) : getCell(ix, i);\r\n            if (cell == null || cell.compWraps.size() == 0) {\r\n                continue;\r\n            }\r\n            int span = (isRows ? cell.spany : cell.spanx);\r\n            if (span > 1) {\r\n                span = convertSpanToSparseGrid(i, span, primIndexes);\r\n            }\r\n            boolean isPar = (cell.flowx == isRows);\r\n            if ((isPar == false && cell.compWraps.size() > 1) || span > 1) {\r\n                int linkType = isPar ? LinkedDimGroup.TYPE_PARALLEL : LinkedDimGroup.TYPE_SERIAL;\r\n                LinkedDimGroup lg = new LinkedDimGroup(\"p,\" + ix, span, linkType, !isRows, fromEnd);\r\n                lg.setCompWraps(cell.compWraps);\r\n                groupList.add(lg);\r\n            } else {\r\n                for (int cwIx = 0; cwIx < cell.compWraps.size(); cwIx++) {\r\n                    CompWrap cw = cell.compWraps.get(cwIx);\r\n                    boolean rowBaselineAlign = (isRows && lc.isTopToBottom() && dc.getAlignOrDefault(!isRows) == UnitValue.BASELINE_IDENTITY);\r\n                    boolean isBaseline = isRows && cw.isBaselineAlign(rowBaselineAlign);\r\n                    String linkCtx = isBaseline ? \"baseline\" : null;\r\n                    boolean foundList = false;\r\n                    for (int glIx = 0, lastGl = groupList.size() - 1; glIx <= lastGl; glIx++) {\r\n                        LinkedDimGroup group = groupList.get(glIx);\r\n                        if (group.linkCtx == linkCtx || linkCtx != null && linkCtx.equals(group.linkCtx)) {\r\n                            group.addCompWrap(cw);\r\n                            foundList = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (foundList == false) {\r\n                        int linkType = isBaseline ? LinkedDimGroup.TYPE_BASELINE : LinkedDimGroup.TYPE_PARALLEL;\r\n                        LinkedDimGroup lg = new LinkedDimGroup(linkCtx, 1, linkType, !isRows, fromEnd);\r\n                        lg.addCompWrap(cw);\r\n                        groupList.add(lg);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return groupLists;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.scrollComponentToVisible",
	"Comment": "makes sure the component is visible in the scroll if this container isscrollable",
	"Method": "void scrollComponentToVisible(Component c){\r\n    if (isScrollable()) {\r\n        if (c != null) {\r\n            Rectangle r = c.getVisibleBounds();\r\n            if (c.getParent() != null) {\r\n                Form f = getComponentForm();\r\n                if (f != null && f.getInvisibleAreaUnderVKB() == 0 && f.findFirstFocusable() == c) {\r\n                    if (r == c.getBounds() && !Display.getInstance().isTouchScreenDevice()) {\r\n                        scrollRectToVisible(new Rectangle(0, 0, c.getX() + Math.min(c.getWidth(), getWidth()), c.getY() + Math.min(c.getHeight(), getHeight())), this);\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            boolean moveToVisible = true;\r\n            Dimension size = r.getSize();\r\n            boolean large = size.getHeight() > getHeight() || size.getWidth() > getWidth();\r\n            if (large) {\r\n                int x = getScrollX();\r\n                int y = getScrollY();\r\n                int w = getWidth();\r\n                int h = getHeight();\r\n                boolean visible = contains(c) && Rectangle.intersects(c.getAbsoluteX(), c.getAbsoluteY(), c.getWidth(), c.getHeight(), getAbsoluteX() + x, getAbsoluteY() + y, w, h);\r\n                moveToVisible = !visible;\r\n            }\r\n            if (moveToVisible) {\r\n                scrollRectToVisible(r.getX(), r.getY(), Math.min(r.getSize().getWidth(), getWidth()), Math.min(r.getSize().getHeight(), getHeight()), c);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.getNativeTransition",
	"Comment": "this method allows a native implementation to implement a native version of a given transition thatcan be faster",
	"Method": "Transition getNativeTransition(Transition t){\r\n    return t;\r\n}"
}, {
	"Path": "java.lang.Long.equals",
	"Comment": "compares this object against the specified object. the result is true if and only if the argument is not null and is a long object that contains the same long value as this object.",
	"Method": "boolean equals(java.lang.Object obj){\r\n    return obj != null && obj.getClass() == getClass() && ((Long) obj).value == value;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isServerSocketAvailable",
	"Comment": "indicates whether the underlying implementation supports server sockets",
	"Method": "boolean isServerSocketAvailable(){\r\n    return false;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.MemberState.canAppend",
	"Comment": "returns a boolean indicating whether an append request can be sent to the member.",
	"Method": "boolean canAppend(){\r\n    return appending == 0 || (appendSucceeded && appending < MAX_APPENDS && System.nanoTime() - (timeBuffer.average() / MAX_APPENDS) >= appendTime);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setHint",
	"Comment": "sets the hint text and icon, the hint text and icon aredisplayed on the component when it is empty",
	"Method": "void setHint(String hint,Image icon){\r\n    Label hintLabel = getHintLabelImpl();\r\n    if (hintLabel == null) {\r\n        hintLabel = new Label(hint);\r\n        hintLabel.setUIID(\"TextHint\");\r\n        setHintLabelImpl(hintLabel);\r\n    } else {\r\n        hintLabel.setText(hint);\r\n    }\r\n    hintLabel.setIcon(icon);\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.isReadResponseForErrors",
	"Comment": "when set to true the read response code will happen even for error codes such as 400 and 500",
	"Method": "boolean isReadResponseForErrors(){\r\n    return readResponseForErrors;\r\n}"
}, {
	"Path": "com.codename1.ui.html.CellConstraint.setHorizontalSpan",
	"Comment": "sets the cells to span horizontally, this number must never be smaller than 1",
	"Method": "void setHorizontalSpan(int span){\r\n    if (span < 1) {\r\n        throw new IllegalArgumentException(\"Illegal span\");\r\n    }\r\n    spanHorizontal = span;\r\n}"
}, {
	"Path": "com.codename1.components.ImageViewer.isCycleRight",
	"Comment": "by default the imageviewer cycles from the end to the beginning of the listwhen going to the right, setting this to false prevents this behaviour",
	"Method": "boolean isCycleRight(){\r\n    return cycleRight;\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.setQwertyAutoDetect",
	"Comment": "indicates whether the text field should try to auto detect qwerty and switch the qwerty device flag implicitly",
	"Method": "void setQwertyAutoDetect(boolean v){\r\n    qwertyAutoDetect = v;\r\n}"
}, {
	"Path": "com.codename1.components.ButtonList.decorateComponent",
	"Comment": "decorates buttons.this allows subclasses to add event listenersto buttons.",
	"Method": "Component decorateComponent(Object modelItem,Component b){\r\n    if (cellUIID != null) {\r\n        setUIID(cellUIID);\r\n    }\r\n    if (b instanceof RadioButton) {\r\n        group.add((RadioButton) b);\r\n    }\r\n    if (decorators != null) {\r\n        for (Decorator d : decorators) {\r\n            d.decorate(modelItem, b);\r\n        }\r\n    }\r\n    return b;\r\n}"
}, {
	"Path": "com.codename1.util.TDivision.remainder",
	"Comment": "divides a biginteger by a signed int andreturns the remainder.",
	"Method": "int remainder(TBigInteger dividend,int divisor){\r\n    return remainderArrayByInt(dividend.digits, dividend.numberLength, divisor);\r\n}"
}, {
	"Path": "java.util.LinkedHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    if (keySet == null) {\r\n        keySet = new AbstractSet<K>() {\r\n            @Override\r\n            public boolean contains(Object object) {\r\n                return containsKey(object);\r\n            }\r\n            @Override\r\n            public int size() {\r\n                return LinkedHashMap.this.size();\r\n            }\r\n            @Override\r\n            public void clear() {\r\n                LinkedHashMap.this.clear();\r\n            }\r\n            @Override\r\n            public boolean remove(Object key) {\r\n                if (containsKey(key)) {\r\n                    LinkedHashMap.this.remove(key);\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n            @Override\r\n            public Iterator<K> iterator() {\r\n                return new KeyIterator<K, V>(LinkedHashMap.this);\r\n            }\r\n        };\r\n    }\r\n    return keySet;\r\n}"
}, {
	"Path": "java.util.LinkedHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return containsKey(object);\r\n}"
}, {
	"Path": "java.util.LinkedHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return LinkedHashMap.this.size();\r\n}"
}, {
	"Path": "java.util.LinkedHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    LinkedHashMap.this.clear();\r\n}"
}, {
	"Path": "java.util.LinkedHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    if (containsKey(key)) {\r\n        LinkedHashMap.this.remove(key);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.LinkedHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return new KeyIterator<K, V>(LinkedHashMap.this);\r\n}"
}, {
	"Path": "org.conscrypt.SSLParametersImpl.setWantClientAuth",
	"Comment": "tunes the peer holding this parameters to request client authentication",
	"Method": "void setWantClientAuth(boolean want){\r\n    want_client_auth = want;\r\n    need_client_auth = false;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.getFileLastModified",
	"Comment": "returns the time that the file denoted by this abstract pathname was last modified.",
	"Method": "long getFileLastModified(String file){\r\n    return -1;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getBaselineResizeBehavior",
	"Comment": "returns a constant indicating how the baseline varies with the sizeof the component.",
	"Method": "int getBaselineResizeBehavior(){\r\n    return BRB_OTHER;\r\n}"
}, {
	"Path": "com.codename1.push.PushActionCategory.getId",
	"Comment": "gets the id of the category.this corresponds with the category of a push notification.",
	"Method": "String getId(){\r\n    return id;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentGroup.isHorizontal",
	"Comment": "indicates that the component group should be horizontal by using the boxlayout y",
	"Method": "boolean isHorizontal(){\r\n    return getLayout() instanceof BoxLayout && ((BoxLayout) getLayout()).getAxis() == BoxLayout.X_AXIS;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.BorderLayout.north",
	"Comment": "convenience method that creates a border layout container and places the given component in the north",
	"Method": "Container north(Component north){\r\n    return Container.encloseIn(new BorderLayout(), north, BorderLayout.NORTH);\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.startEditing",
	"Comment": "launches the text field editing, notice that calling this in a callserially is generally considered good practice",
	"Method": "void startEditing(){\r\n    if (!Display.getInstance().isTextEditing(this)) {\r\n        final TextArea cmp = this;\r\n        Display.getInstance().editString(this, maxSize, constraint, text);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Font.charWidth",
	"Comment": "return the width of the specific character when rendered alone",
	"Method": "int charWidth(char ch){\r\n    return Display.impl.charWidth(font, ch);\r\n}"
}, {
	"Path": "java.util.BitSet.length",
	"Comment": "returns the number of bits up to and including the highest bit set.",
	"Method": "int length(){\r\n    int idx = actualArrayLength - 1;\r\n    while (idx >= 0 && bits[idx] == 0) {\r\n        --idx;\r\n    }\r\n    actualArrayLength = idx + 1;\r\n    if (idx == -1) {\r\n        return 0;\r\n    }\r\n    int i = ELM_SIZE - 1;\r\n    long val = bits[idx];\r\n    while ((val & (TWO_N_ARRAY[i])) == 0 && i > 0) {\r\n        i--;\r\n    }\r\n    return (idx << OFFSET) + i + 1;\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSParser.notifyError",
	"Comment": "a utility method used to notify an error to the parsercallback and throw an illegalargumentexception if parsingerror returned false",
	"Method": "void notifyError(int errorId,String tag,String attribute,String value,String description){\r\n    if (parserCallback != null) {\r\n        boolean cont = parserCallback.parsingError(errorId, tag, attribute, value, description);\r\n        if (!cont) {\r\n            throw new IllegalArgumentException(description);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getPreferredSize",
	"Comment": "returns the component preferred size, there is no guarantee the component will be sized at its preferred size. the final size of the component may besmaller than its preferred size or even larger than the size.the layout manager can take this value into consideration, but there isno guarantee or requirement.",
	"Method": "Dimension getPreferredSize(){\r\n    return preferredSize();\r\n}"
}, {
	"Path": "com.codename1.ui.Font.charsWidth",
	"Comment": "return the width of the given characters in this font instance",
	"Method": "int charsWidth(char[] ch,int offset,int length){\r\n    return Display.impl.charsWidth(font, ch, offset, length);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setInlineStylesTheme",
	"Comment": "sets the theme that is used by inline styles to reference images.inline styles will bedisabled unless an inlinestylestheme is registered with the component.",
	"Method": "void setInlineStylesTheme(Resources inlineStylesTheme){\r\n    this.inlineStylesTheme = inlineStylesTheme;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.add",
	"Comment": "adds the specified object into this vector at the specified location. theobject is inserted before any element with the same or a higher indexincreasing their index by 1. if the location is equal to the size of thisvector, the object is added at the end.",
	"Method": "void add(int location,E object,boolean add,E object){\r\n    if (elementCount == elementData.length) {\r\n        growByOne();\r\n    }\r\n    elementData[elementCount++] = object;\r\n    modCount++;\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.isFocusable",
	"Comment": "returns true if this component can receive focus and is enabled",
	"Method": "boolean isFocusable(){\r\n    return focusable && enabled && isVisible();\r\n}"
}, {
	"Path": "com.codename1.ui.FontImage.createMaterial",
	"Comment": "creates a material design icon font for the given style but size it in millimeters basedon the size argument and not the font",
	"Method": "FontImage createMaterial(char icon,Style s,float size,FontImage createMaterial,char icon,String style,float size,FontImage createMaterial,char icon,Style s){\r\n    Font f = getMaterialDesignFont().derive(s.getFont().getHeight(), Font.STYLE_PLAIN);\r\n    return create(\"\" + icon, s, f);\r\n}"
}, {
	"Path": "com.codename1.components.ButtonList.fireReady",
	"Comment": "this should be called by the concrete implementation once it is ready to generate thebuttons.",
	"Method": "void fireReady(){\r\n    for (Runnable r : onReady) {\r\n        r.run();\r\n    }\r\n    onReady.clear();\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.PlatformDefaults.getButtonOrder",
	"Comment": "returns the order for the typical buttons in a standard button bar. it is one letter per button type.",
	"Method": "String getButtonOrder(){\r\n    return BUTTON_FORMAT;\r\n}"
}, {
	"Path": "com.codename1.properties.ListProperty.set",
	"Comment": "sets the property value and potentially fires a change event",
	"Method": "K set(int offset,T v,K set,Collection<T> t){\r\n    value.clear();\r\n    value.addAll(t);\r\n    firePropertyChanged();\r\n    return (K) parent.parent;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.initNamedTheme",
	"Comment": "same as the initfirsttheme method, but unlike that method this allows specifying the theme resource name",
	"Method": "Resources initNamedTheme(String resourceFile,String resName){\r\n    try {\r\n        Resources theme = Resources.openLayered(resourceFile);\r\n        UIManager.getInstance().setThemeProps(theme.getTheme(resName));\r\n        Resources.setGlobalResources(theme);\r\n        return theme;\r\n    } catch (IOException e) {\r\n        Log.e(e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.atomix.copycat.client.DefaultCopycatClientTest.testQuerySessionRecovery",
	"Comment": "tests calling the recovery strategy when a command fails due to unknownsessionexception.",
	"Method": "void testQuerySessionRecovery(){\r\n    Connection connection = mock(Connection.class);\r\n    when(connection.close()).thenReturn(CompletableFuture.completedFuture(null));\r\n    Client client = mock(Client.class);\r\n    when(client.connect(any())).thenReturn(CompletableFuture.completedFuture(connection));\r\n    Transport transport = mock(Transport.class);\r\n    when(transport.client()).thenReturn(client);\r\n    when(connection.sendAndReceive(isA(ConnectRequest.class))).thenReturn(CompletableFuture.completedFuture(ConnectResponse.builder().withStatus(Response.Status.OK).withLeader(LEADER).withMembers(MEMBERS).build()));\r\n    when(connection.sendAndReceive(isA(RegisterRequest.class))).thenReturn(CompletableFuture.completedFuture(RegisterResponse.builder().withStatus(Response.Status.OK).withSession(1).withTimeout(5000).withLeader(LEADER).withMembers(MEMBERS).build())).thenReturn(CompletableFuture.completedFuture(RegisterResponse.builder().withStatus(Response.Status.OK).withSession(2).withTimeout(5000).withLeader(LEADER).withMembers(MEMBERS).build()));\r\n    Mockito.when(connection.sendAndReceive(isA(KeepAliveRequest.class))).thenReturn(CompletableFuture.completedFuture(KeepAliveResponse.builder().withStatus(Response.Status.OK).withLeader(LEADER).withMembers(MEMBERS).build()));\r\n    Mockito.when(connection.sendAndReceive(isA(QueryRequest.class))).thenReturn(CompletableFuture.completedFuture(QueryResponse.builder().withStatus(Response.Status.ERROR).withError(CopycatError.Type.UNKNOWN_SESSION_ERROR).build())).thenReturn(CompletableFuture.completedFuture(QueryResponse.builder().withStatus(Response.Status.OK).withIndex(1).withEventIndex(0).withResult(\"Hello world!\").build()));\r\n    CopycatClient copycatClient = CopycatClient.builder().withTransport(transport).withRecoveryStrategy(RecoveryStrategies.RECOVER).build();\r\n    copycatClient.connect(MEMBERS).join();\r\n    try {\r\n        copycatClient.submit(new TestQuery()).join();\r\n        fail();\r\n    } catch (CompletionException e) {\r\n        if (!(e.getCause() instanceof ClosedSessionException)) {\r\n            fail();\r\n        }\r\n    }\r\n    CountDownLatch latch = new CountDownLatch(1);\r\n    copycatClient.onStateChange(state -> {\r\n        if (state == CopycatClient.State.CONNECTED) {\r\n            assertEquals(2, copycatClient.session().id());\r\n            latch.countDown();\r\n        }\r\n    });\r\n    latch.await();\r\n    assertEquals(copycatClient.submit(new TestQuery()).join(), \"Hello world!\");\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.MigLayout.setColumnConstraints",
	"Comment": "sets the column layout constraints for the layout manager instance as astring.see the class javadocs for information on how this string is formatted.",
	"Method": "void setColumnConstraints(Object constr){\r\n    if (constr == null || constr instanceof String) {\r\n        constr = ConstraintParser.prepare((String) constr);\r\n        colSpecs = ConstraintParser.parseColumnConstraints((String) constr);\r\n    } else if (constr instanceof AC) {\r\n        colSpecs = (AC) constr;\r\n    } else {\r\n        throw new IllegalArgumentException(\"Illegal constraint type: \" + constr.getClass().toString());\r\n    }\r\n    colConstraints = constr;\r\n    dirty = true;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLUtils.convertXMLCharEntity",
	"Comment": "converts an xml char entity to the matching character or string.this is a convenience method that uses convertcharentity with false for lookuphtmlentities and a null userdefinedcharentities",
	"Method": "String convertXMLCharEntity(String charEntity){\r\n    return convertCharEntity(charEntity, false, null);\r\n}"
}, {
	"Path": "mondrian.rolap.agg.AbstractQuerySpec.isPartOfSelect",
	"Comment": "allows subclasses to specify if a given column mustbe returned as part of the result set, in the select clause.",
	"Method": "boolean isPartOfSelect(RolapStar.Column col,boolean isPartOfSelect,RolapStar.Measure measure){\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.releaseAnimationLock",
	"Comment": "invoke this to release the animation lock that was grabbed in grabanimationlock",
	"Method": "void releaseAnimationLock(){\r\n    globalAnimationLock = false;\r\n}"
}, {
	"Path": "com.codename1.payment.Purchase.getInAppPurchase",
	"Comment": "returns the native os purchase implementation if applicable, if unavailable thismethod will try to fallback to a custom purchase implementation and failing thatwill return null",
	"Method": "Purchase getInAppPurchase(Purchase getInAppPurchase,boolean d){\r\n    return Display.getInstance().getInAppPurchase();\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLElement.verifyStringGroup",
	"Comment": "verifies that the specified string equals to one of the allowed strings",
	"Method": "boolean verifyStringGroup(String value,String[] allowed){\r\n    for (int i = 0; i < allowed.length; i++) {\r\n        if (value.equalsIgnoreCase(allowed[i])) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.TreeSet.subSet",
	"Comment": "answers a sortedset of the specified portion of this treeset whichcontains elements greater or equal to the start element but less than theend element. the returned sortedset is backed by this treeset so changesto one are reflected by the other.",
	"Method": "NavigableSet<E> subSet(E start,boolean startInclusive,E end,boolean endInclusive,SortedSet<E> subSet,E start,E end){\r\n    return subSet(start, true, end, false);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.deregisterPush",
	"Comment": "stop receiving push notifications to this client application",
	"Method": "void deregisterPush(){\r\n    impl.deregisterPush();\r\n}"
}, {
	"Path": "com.codename1.components.SplitPane.getTop",
	"Comment": "gets the component that is currently placed in the top of the split pane.",
	"Method": "Component getTop(){\r\n    return getTopOrLeftComponent();\r\n}"
}, {
	"Path": "com.codename1.ui.Component.isChildOf",
	"Comment": "searches the hierarchy of the component recursively to see if the givencontainer is one of the parents of this component",
	"Method": "boolean isChildOf(Container cnt){\r\n    if (cnt == parent) {\r\n        return true;\r\n    }\r\n    return parent != null && parent.isChildOf(cnt);\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.isCursorPositionCycle",
	"Comment": "returns true if the cursor should cycle to the beginning of the text when theuser navigates beyond the edge of the text and visa versa.",
	"Method": "boolean isCursorPositionCycle(){\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.impl.android.InPlaceEditView.isEditing",
	"Comment": "returns true if an edit is currently in progress, false otherwise",
	"Method": "boolean isEditing(){\r\n    return (sInstance == null) ? false : sInstance.mIsEditing;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.isRippleEffect",
	"Comment": "indicates whether the component displays the material design ripple effect",
	"Method": "boolean isRippleEffect(){\r\n    return rippleEffect;\r\n}"
}, {
	"Path": "com.alibaba.citrus.turbine.util.HtmlPageAttributeTool.addStyle",
	"Comment": "adds a style element to the head of the page with the provided content.",
	"Method": "HtmlPageAttributeTool addStyle(String styleText){\r\n    this.styles.add(styleText);\r\n    return this;\r\n}"
}, {
	"Path": "com.alibaba.citrus.service.upload.impl.cfu.AbstractFileItem.setFormField",
	"Comment": "specifies whether or not a fileitem instance represents asimple form field.",
	"Method": "void setFormField(boolean state){\r\n    isFormField = state;\r\n}"
}, {
	"Path": "org.conscrypt.AbstractConscryptSocket.getHostnameOrIP",
	"Comment": "for the purposes of an sslsession, we want a way to represent the supplied hostnameor the ip address in a textual representation. we do not want to perform reverse dnslookups on this address.",
	"Method": "String getHostnameOrIP(){\r\n    if (peerHostname != null) {\r\n        return peerHostname;\r\n    }\r\n    InetAddress peerAddress = getInetAddress();\r\n    if (peerAddress != null) {\r\n        return Platform.getOriginalHostNameFromInetAddress(peerAddress);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.atomix.copycat.client.session.ClientSequencerTest.testSequenceEventBeforeCommand",
	"Comment": "tests sequencing an event that arrives before a command response.",
	"Method": "void testSequenceEventBeforeCommand(){\r\n    ClientSequencer sequencer = new ClientSequencer(new ClientSessionState(UUID.randomUUID().toString()));\r\n    long sequence = sequencer.nextRequest();\r\n    PublishRequest request = PublishRequest.builder().withSession(1).withEventIndex(1).withPreviousIndex(0).build();\r\n    CommandResponse response = CommandResponse.builder().withStatus(Response.Status.OK).withIndex(2).withEventIndex(1).build();\r\n    AtomicInteger run = new AtomicInteger();\r\n    sequencer.sequenceEvent(request, () -> assertEquals(run.getAndIncrement(), 0));\r\n    sequencer.sequenceResponse(sequence, response, () -> assertEquals(run.getAndIncrement(), 1));\r\n    assertEquals(run.get(), 2);\r\n}"
}, {
	"Path": "java.util.Calendar.after",
	"Comment": "compares the time field records. equivalent to comparing result of conversion to utc.",
	"Method": "boolean after(java.lang.Object when){\r\n    if (!(calendar instanceof Calendar)) {\r\n        return false;\r\n    }\r\n    return getTimeInMillis() > ((Calendar) calendar).getTimeInMillis();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.IdentityHashMap.putAll",
	"Comment": "copies all the mappings in the specified map to this map. these mappingswill replace all mappings that this map had for any of the keys currentlyin the given map.",
	"Method": "void putAll(Map<? extends K, ? extends V> map){\r\n    putAllImpl(map);\r\n}"
}, {
	"Path": "org.conscrypt.CertBlacklistTest.testBlacklistedRootOfTrust",
	"Comment": "check that a chain that is rooted in a blacklisted trusted ca is rejected.",
	"Method": "void testBlacklistedRootOfTrust(){\r\n    X509Certificate[] chain = loadCertificates(BLACKLISTED_CHAIN);\r\n    X509Certificate blacklistedCa = loadCertificate(BLACKLIST_CA);\r\n    assertUntrusted(chain, getTrustManager(blacklistedCa));\r\n}"
}, {
	"Path": "org.conscrypt.OpenSSLX509Certificate.withDeletedExtension",
	"Comment": "delete an extension.a modified copy of the certificate is returned. the original objectis unchanged.if the extension is not present, an unmodified copy is returned.",
	"Method": "OpenSSLX509Certificate withDeletedExtension(String oid){\r\n    OpenSSLX509Certificate copy = new OpenSSLX509Certificate(NativeCrypto.X509_dup(mContext, this), notBefore, notAfter);\r\n    NativeCrypto.X509_delete_ext(copy.getContext(), copy, oid);\r\n    return copy;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.BorderLayout.east",
	"Comment": "convenience method that creates a border layout container and places the given component in the east",
	"Method": "Container east(Component east){\r\n    return Container.encloseIn(new BorderLayout(), east, BorderLayout.EAST);\r\n}"
}, {
	"Path": "com.codename1.charts.ChartComponent.chartToScreenShape",
	"Comment": "converts a screen coordinate spaced shape to the same shape in the chartcoordinate space",
	"Method": "Shape chartToScreenShape(Shape s){\r\n    GeneralPath p = new GeneralPath();\r\n    Transform inverse = Transform.makeTranslation(getAbsoluteX(), getAbsoluteY());\r\n    if (currentTransform != null) {\r\n        inverse.concatenate(currentTransform);\r\n    }\r\n    p.append(s.getPathIterator(inverse), false);\r\n    return p;\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.TimeSpinner.isDurationMode",
	"Comment": "duration mode uses the time spinner to indicate a duration in hours and minutes",
	"Method": "boolean isDurationMode(){\r\n    return durationMode;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.LayoutUtil.getDesignTimeEmptySize",
	"Comment": "the size of an empty row or columns in a grid during design time.",
	"Method": "int getDesignTimeEmptySize(){\r\n    return eSz;\r\n}"
}, {
	"Path": "java.util.Vector.addAll",
	"Comment": "adds the objects in the specified collection to the end of this vector.",
	"Method": "boolean addAll(int location,Collection<? extends E> collection,boolean addAll,Collection<? extends E> collection){\r\n    return addAll(elementCount, collection);\r\n}"
}, {
	"Path": "com.codename1.ui.CN.convertToPixels",
	"Comment": "converts the dips count to pixels, dips are roughly 1mm in length. this is a very rough estimate and notto be relied upon. this version of the method assumes square pixels which is pretty much the norm.",
	"Method": "int convertToPixels(int dipCount,boolean horizontal,int convertToPixels,float dipCount){\r\n    return Math.round(Display.impl.convertToPixels((int) (dipCount * 1000), true) / 1000.0f);\r\n}"
}, {
	"Path": "com.codename1.ui.validation.Validator.setErrorMessageUIID",
	"Comment": "error message uiid defaults to dialogbody. allows customizing the look of the message",
	"Method": "void setErrorMessageUIID(String errorMessageUIID){\r\n    this.errorMessageUIID = errorMessageUIID;\r\n}"
}, {
	"Path": "java.text.DateFormat.getTimeInstance",
	"Comment": "get a dateformat instance that uses a given style for times.",
	"Method": "DateFormat getTimeInstance(DateFormat getTimeInstance,int style){\r\n    return getDateTimeInstance(NONE, style);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLParser.parseHTML",
	"Comment": "a convenience method that casts the returned type of the parse method to htmlelement.basically calling this method is simlar to calling parse and casting to htmlelement.",
	"Method": "HTMLElement parseHTML(InputStreamReader isr){\r\n    return (HTMLElement) super.parse(isr);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.PlatformDefaults.setGridCellGap",
	"Comment": "sets gap between two cells in the grid. note that this is not a gap between component in a cell, that has to be set\ton the component constraints. the value will be the min and preferred size of the gap.",
	"Method": "void setGridCellGap(UnitValue x,UnitValue y){\r\n    if (x != null)\r\n        DEF_HGAP = new BoundSize(x, x, null, null);\r\n    if (y != null)\r\n        DEF_VGAP = new BoundSize(y, y, null, null);\r\n    MOD_COUNT++;\r\n}"
}, {
	"Path": "com.codename1.ui.List.getListeners",
	"Comment": "this method allows extracting the action listeners from the current list",
	"Method": "Collection getListeners(){\r\n    return dispatcher.getListenerCollection();\r\n}"
}, {
	"Path": "com.codename1.ui.util.Resources.createPackedImage8",
	"Comment": "creates a packed image from the input stream for an 8 bit packed image",
	"Method": "Image createPackedImage8(){\r\n    int size = input.readByte() & 0xff;\r\n    if (size == 0) {\r\n        size = 256;\r\n    }\r\n    int[] palette = new int[size];\r\n    int plen = palette.length;\r\n    for (int iter = 0; iter < plen; iter++) {\r\n        palette[iter] = input.readInt();\r\n    }\r\n    int width = input.readShort();\r\n    int height = input.readShort();\r\n    byte[] data = new byte[width * height];\r\n    input.readFully(data, 0, data.length);\r\n    return Image.createIndexed(width, height, palette, data);\r\n}"
}, {
	"Path": "java.util.Vector.ensureCapacity",
	"Comment": "ensures that this vector can hold the specified number of elementswithout growing.",
	"Method": "void ensureCapacity(int minimumCapacity){\r\n    if (elementData.length < minimumCapacity) {\r\n        int next = (capacityIncrement <= 0 ? elementData.length : capacityIncrement) + elementData.length;\r\n        grow(minimumCapacity > next ? minimumCapacity : next);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Motion.createLinearColorMotion",
	"Comment": "creates a linear motion starting from source value all the way to destination value for a color value.unlike a regular linear motion a color linear motion is shifted based on channels where red, green & blue get shifted separately.",
	"Method": "Motion createLinearColorMotion(int sourceValue,int destinationValue,int duration){\r\n    Motion l = new Motion(sourceValue, destinationValue, duration);\r\n    l.motionType = COLOR_LINEAR;\r\n    return l;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Collections.synchronizedSortedSet",
	"Comment": "returns a wrapper on the specified sorted set which synchronizes allaccess to the sorted set.",
	"Method": "SortedSet<E> synchronizedSortedSet(SortedSet<E> set){\r\n    if (set == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    return new SynchronizedSortedSet<E>(set);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.isBlockLead",
	"Comment": "prevent a lead component hierarchy from this specific component, this allows a component within thathierarchy to still act as a standalone component",
	"Method": "boolean isBlockLead(){\r\n    return blockLead;\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.setSymbolTable",
	"Comment": "sets the symbol table to show when the user clicks the symbol table key",
	"Method": "void setSymbolTable(char[] table){\r\n    symbolTable = table;\r\n    ;\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.getUnsupportedChars",
	"Comment": "unsupported characters is a string that contains characters that cause issues when rendering on some problematic fonts. the rendering engine can thus remove themwhen drawing.",
	"Method": "String getUnsupportedChars(){\r\n    return unsupportedChars;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.findCurrentlyEditingComponent",
	"Comment": "returns the component on this form that is currently being edited, or nullif no component is currently being edited.",
	"Method": "Component findCurrentlyEditingComponent(){\r\n    return ComponentSelector.select(\"*\", this).filter(new Filter() {\r\n        @Override\r\n        public boolean filter(Component c) {\r\n            return c.isEditing();\r\n        }\r\n    }).asComponent();\r\n}"
}, {
	"Path": "com.codename1.ui.Form.findCurrentlyEditingComponent",
	"Comment": "returns the component on this form that is currently being edited, or nullif no component is currently being edited.",
	"Method": "Component findCurrentlyEditingComponent(){\r\n    return c.isEditing();\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isGetAllContactsFast",
	"Comment": "indicates if the getallcontacts is platform optimized, notice that the methodmight still take seconds or more to run so you should still use a separate thread!",
	"Method": "boolean isGetAllContactsFast(){\r\n    return impl.isGetAllContactsFast();\r\n}"
}, {
	"Path": "com.codename1.social.Login.doLogin",
	"Comment": "logs in the user.if the service has a native login it will try to use that, otherwise anoauth2 web login will be used.",
	"Method": "void doLogin(){\r\n    if (isNativeLoginSupported()) {\r\n        nativelogin();\r\n    } else {\r\n        if (oauth2URL == null) {\r\n            System.out.println(\"No oauth2URL found Use setOauth2URL\");\r\n            return;\r\n        }\r\n        if (clientId == null) {\r\n            System.out.println(\"No ClientId found Use setClientId\");\r\n            return;\r\n        }\r\n        if (redirectURI == null) {\r\n            System.out.println(\"No redirectURI found Use setRedirectURI\");\r\n            return;\r\n        }\r\n        if (clientSecret == null) {\r\n            System.out.println(\"No clientSecret found Use setClientSecret\");\r\n            return;\r\n        }\r\n        Oauth2 auth = createOauth2();\r\n        auth.showAuthentication(new ActionListener() {\r\n            public void actionPerformed(ActionEvent evt) {\r\n                if (evt.getSource() instanceof AccessToken) {\r\n                    AccessToken t = (AccessToken) evt.getSource();\r\n                    setAccessToken(t);\r\n                    if (callback != null) {\r\n                        callback.loginSuccessful();\r\n                    }\r\n                    return;\r\n                }\r\n                if (evt.getSource() instanceof String) {\r\n                    String t = (String) evt.getSource();\r\n                    setAccessToken(new AccessToken(t, null));\r\n                    if (callback != null) {\r\n                        callback.loginSuccessful();\r\n                    }\r\n                    return;\r\n                }\r\n                if (evt.getSource() instanceof Exception) {\r\n                    if (callback != null) {\r\n                        Exception e = (Exception) evt.getSource();\r\n                        Log.e(e);\r\n                        callback.loginFailed(e.getMessage());\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.codename1.social.Login.doLogin",
	"Comment": "logs in the user.if the service has a native login it will try to use that, otherwise anoauth2 web login will be used.",
	"Method": "void doLogin(){\r\n    if (evt.getSource() instanceof AccessToken) {\r\n        AccessToken t = (AccessToken) evt.getSource();\r\n        setAccessToken(t);\r\n        if (callback != null) {\r\n            callback.loginSuccessful();\r\n        }\r\n        return;\r\n    }\r\n    if (evt.getSource() instanceof String) {\r\n        String t = (String) evt.getSource();\r\n        setAccessToken(new AccessToken(t, null));\r\n        if (callback != null) {\r\n            callback.loginSuccessful();\r\n        }\r\n        return;\r\n    }\r\n    if (evt.getSource() instanceof Exception) {\r\n        if (callback != null) {\r\n            Exception e = (Exception) evt.getSource();\r\n            Log.e(e);\r\n            callback.loginFailed(e.getMessage());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Tabs.isChangeTabContainerStyleOnFocus",
	"Comment": "indicates that the tabs container should have its style changed to the selected style when one of the tabs has focusthis allows incorporating it into the theme of the application",
	"Method": "boolean isChangeTabContainerStyleOnFocus(){\r\n    return changeTabContainerStyleOnFocus;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.createBevelRaised",
	"Comment": "creates a lowered bevel border with default colors, highlight is derivedfrom the component and shadow is a plain dark color",
	"Method": "Border createBevelRaised(Border createBevelRaised,int highlightOuter,int highlightInner,int shadowOuter,int shadowInner){\r\n    Border b = new Border();\r\n    b.type = TYPE_BEVEL_RAISED;\r\n    b.themeColors = false;\r\n    b.colorA = highlightOuter;\r\n    b.colorB = highlightInner;\r\n    b.colorC = shadowOuter;\r\n    b.colorD = shadowInner;\r\n    b.thickness = 2;\r\n    return b;\r\n}"
}, {
	"Path": "com.codename1.ui.Label.getVerticalAlignment",
	"Comment": "returns the vertical alignment of the label, this will only work when the iconis in the side of the text and not above or below it.the valign property is only relevant relatively to the icon and not the entire label, this willonly work when there is an icon",
	"Method": "int getVerticalAlignment(){\r\n    return valign;\r\n}"
}, {
	"Path": "cognitivej.vision.face.person.PersonBuilder.deletePerson",
	"Comment": "delete an existing person from a person group. persisted face images of the person will also be deleted.",
	"Method": "DeletePersonAction deletePerson(String personGroupId,String personId){\r\n    Validation.validate(personGroupId, \"^[a-z0-9_-]{1,64}$\", new ParameterValidationException(\"personGroupId\", \"Person group ID is invalid. Valid format should be a string composed by numbers, english letters in lower case, '-', '_', and no longer than 64 characters.\"));\r\n    return new DeletePersonAction(cognitiveContext, personGroupId, personId);\r\n}"
}, {
	"Path": "com.codename1.components.OnOffSwitch.getActionListeners",
	"Comment": "returns a vector containing the action listeners for this button",
	"Method": "Vector getActionListeners(){\r\n    return dispatcher.getListenerVector();\r\n}"
}, {
	"Path": "com.codename1.charts.transitions.SeriesTransition.setChart",
	"Comment": "sets the chartcomponent that is the subject of the transition.",
	"Method": "void setChart(ChartComponent chart){\r\n    this.chart = chart;\r\n}"
}, {
	"Path": "com.codename1.javascript.JavascriptContext.install",
	"Comment": "installs the context in the current browser component.this effectivelyinstalls listeners in the browser component so that the context can be notified of events like navigation callbacks and script message receivedevents.",
	"Method": "void install(){\r\n    previousNavigationCallback = browser.getBrowserNavigationCallback();\r\n    browser.setBrowserNavigationCallback(browserNavigationCallback);\r\n    browser.addWebEventListener(\"scriptMessageReceived\", scriptMessageListener);\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.installCommands",
	"Comment": "installs the clear and t9 commands onto the parent form, this method canbe overriden to provide device specific placement for these commands",
	"Method": "Command installCommands(Command clear,Command t9){\r\n    Form f = getComponentForm();\r\n    if (f != null) {\r\n        Command original = f.getClearCommand();\r\n        if (original instanceof CommandHandler) {\r\n            original = originalClearCommand;\r\n        }\r\n        if (replaceMenu && originalCommands == null) {\r\n            originalCommands = new Command[f.getCommandCount()];\r\n            int olen = originalCommands.length;\r\n            for (int iter = 0; iter < olen; iter++) {\r\n                originalCommands[iter] = f.getCommand(iter);\r\n            }\r\n            f.removeAllCommands();\r\n            if (Display.getInstance().isThirdSoftButton()) {\r\n                getComponentForm().getMenuBar().addSelectCommand(getSelectCommandText());\r\n                selectCommand = getComponentForm().getCommand(0);\r\n            }\r\n        }\r\n        f.addCommand(clear, 0);\r\n        f.addCommand(t9, 0);\r\n        f.setClearCommand(clear);\r\n        f.revalidate();\r\n        return original;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.isAutoDegradeMaxSize",
	"Comment": "indicates whether a high value for default maxsize will be reduced to a lowervalue if the underlying platform throws an exception.",
	"Method": "boolean isAutoDegradeMaxSize(){\r\n    return autoDegradeMaxSize;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.PlatformDefaults.setLogicalPixelBase",
	"Comment": "what base value should be used to calculate logical pixel sizes.",
	"Method": "void setLogicalPixelBase(int base){\r\n    if (LP_BASE != base) {\r\n        if (base < BASE_FONT_SIZE || base > BASE_REAL_PIXEL)\r\n            throw new IllegalArgumentException(\"Unrecognized base: \" + base);\r\n        LP_BASE = base;\r\n        MOD_COUNT++;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Style.getPaddingRight",
	"Comment": "returns the right padding in pixel or left padding in an rtl situation",
	"Method": "int getPaddingRight(boolean rtl){\r\n    if (rtl) {\r\n        return convertUnit(paddingUnit, padding[Component.LEFT], Component.LEFT);\r\n    }\r\n    return convertUnit(paddingUnit, padding[Component.RIGHT], Component.RIGHT);\r\n}"
}, {
	"Path": "com.codename1.ui.Form.hasMedia",
	"Comment": "used by the implementation to prevent flickering when flushing the double buffer",
	"Method": "boolean hasMedia(){\r\n    return mediaComponents != null && mediaComponents.size() > 0;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.getInputFields",
	"Comment": "returns the input fields of this htmlcomponent, used by the for label mecahnism.",
	"Method": "Hashtable getInputFields(){\r\n    return inputFields;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.translator.MethodsMirror.hasMethod",
	"Comment": "returns true if the mirror contains a method that mirrors\tmethodname. the mirror method should be static, have the\tsame name, and have the exact same arguments excepting an argument of",
	"Method": "boolean hasMethod(String owner,String methodName,String methodDescriptor,int opcode){\r\n    Type[] types = Type.getArgumentTypes(methodDescriptor);\r\n    if (opcode == Opcodes.INVOKEVIRTUAL || opcode == Opcodes.INVOKEINTERFACE) {\r\n        Type[] newTypes = new Type[types.length + 1];\r\n        newTypes[0] = Type.getType(\"L\" + owner + \";\");\r\n        System.arraycopy(types, 0, newTypes, 1, types.length);\r\n        types = newTypes;\r\n    }\r\n    outer_loop: for (Method m : class_.getDeclaredMethods()) {\r\n        final Type[] methodTypes = Type.getArgumentTypes(m);\r\n        if (!m.getName().equals(methodName) || methodTypes.length != types.length) {\r\n            continue;\r\n        }\r\n        for (int i = 0; i < types.length; ++i) {\r\n            if (!types[i].equals(methodTypes[i])) {\r\n                continue outer_loop;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Motion.createLinearMotion",
	"Comment": "creates a linear motion starting from source value all the way to destination value",
	"Method": "Motion createLinearMotion(int sourceValue,int destinationValue,int duration){\r\n    Motion l = new Motion(sourceValue, destinationValue, duration);\r\n    l.motionType = LINEAR;\r\n    return l;\r\n}"
}, {
	"Path": "android.support.v4.content.LocalBroadcastManager.unregisterReceiver",
	"Comment": "unregister a previously registered broadcastreceiver.allfilters that have been registered for this broadcastreceiver will beremoved.",
	"Method": "void unregisterReceiver(BroadcastReceiver receiver){\r\n    synchronized (mReceivers) {\r\n        ArrayList<IntentFilter> filters = mReceivers.remove(receiver);\r\n        if (filters == null) {\r\n            return;\r\n        }\r\n        for (int i = 0; i < filters.size(); i++) {\r\n            IntentFilter filter = filters.get(i);\r\n            for (int j = 0; j < filter.countActions(); j++) {\r\n                String action = filter.getAction(j);\r\n                ArrayList<ReceiverRecord> receivers = mActions.get(action);\r\n                if (receivers != null) {\r\n                    for (int k = 0; k < receivers.size(); k++) {\r\n                        if (receivers.get(k).receiver == receiver) {\r\n                            receivers.remove(k);\r\n                            k--;\r\n                        }\r\n                    }\r\n                    if (receivers.size() <= 0) {\r\n                        mActions.remove(action);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.FollowerStateTest.testFollowerAcceptsPollForMultipleCandidatesPerTerm",
	"Comment": "tests that a follower will accept a poll for many candidates.",
	"Method": "void testFollowerAcceptsPollForMultipleCandidatesPerTerm(){\r\n    runOnServer(() -> {\r\n        serverContext.setTerm(2);\r\n        PollRequest request1 = PollRequest.builder().withTerm(2).withCandidate(members.get(1).hashCode()).withLogIndex(0).withLogTerm(0).build();\r\n        PollResponse response = state.poll(request1).get();\r\n        threadAssertEquals(response.status(), Status.OK);\r\n        threadAssertEquals(serverContext.getTerm(), 2L);\r\n        threadAssertEquals(response.term(), 2L);\r\n        threadAssertTrue(response.accepted());\r\n        PollRequest request2 = PollRequest.builder().withTerm(2).withCandidate(members.get(2).hashCode()).withLogIndex(0).withLogTerm(0).build();\r\n        response = state.poll(request2).get();\r\n        threadAssertEquals(response.status(), Status.OK);\r\n        threadAssertEquals(serverContext.getTerm(), 2L);\r\n        threadAssertEquals(response.term(), 2L);\r\n        threadAssertTrue(response.accepted());\r\n    });\r\n}"
}, {
	"Path": "com.codename1.ui.geom.GeneralPath.setShape",
	"Comment": "sets this path to be a copy of the provided shape, but with the providedtransform applied to it.",
	"Method": "void setShape(Shape s,Transform t){\r\n    if (s.getClass() == GeneralPath.class) {\r\n        setPath((GeneralPath) s, t);\r\n    } else if (s.getClass() == Rectangle.class) {\r\n        setRect((Rectangle) s, t);\r\n    } else {\r\n        reset();\r\n        append(s.getPathIterator(t), false);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.maxWidth",
	"Comment": "the maximum size for the component. the value will override any value that is set on the component itself.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC maxWidth(String size){\r\n    hor.setSize(LayoutUtil.derive(hor.getSize(), null, null, ConstraintParser.parseUnitValue(size, true)));\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.io.Log.sendLog",
	"Comment": "sends the current log to the cloud. notice that this method is synchronous and returns only when the sending completes",
	"Method": "void sendLog(){\r\n    sendLogImpl(true);\r\n}"
}, {
	"Path": "com.codename1.analytics.AnalyticsService.setFailSilently",
	"Comment": "indicates whether analytics server failures should brodcast an error event",
	"Method": "void setFailSilently(boolean aFailSilently){\r\n    failSilently = aFailSilently;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.DefaultLookAndFeel.getRadioButtonFocusImages",
	"Comment": "returns the images used to represent the radio button when in focused mode",
	"Method": "Image[] getRadioButtonFocusImages(){\r\n    return rButtonImagesFocus;\r\n}"
}, {
	"Path": "io.atomix.copycat.protocol.KeepAliveResponse.builder",
	"Comment": "returns a keep alive response builder for an existing response.",
	"Method": "Builder builder(Builder builder,KeepAliveResponse response){\r\n    return new Builder(response);\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.goBack",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "void goBack(){\r\n    TestUtils.goBack();\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isAutoFoldVKBOnFormSwitch",
	"Comment": "normally codename one folds the vkb when switching forms this field allows usto block that behavior.",
	"Method": "boolean isAutoFoldVKBOnFormSwitch(){\r\n    return autoFoldVKBOnFormSwitch;\r\n}"
}, {
	"Path": "com.codename1.impl.android.InPlaceEditView.showActiveTextEditorAgain",
	"Comment": "shows the native text editor for the async editing session that is currently in progress.this is only used when in async edit mode.",
	"Method": "void showActiveTextEditorAgain(){\r\n    if (sInstance != null) {\r\n        sInstance.showTextEditorAgain();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.xml.XMLParser.shouldEvaluate",
	"Comment": "checks if this element should be evaluated by the parserthis can be overriden by subclasses to skip certain elements",
	"Method": "boolean shouldEvaluate(Element element){\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.io.Util.readUTF",
	"Comment": "reads a utf string that may be null previously written by writeutf",
	"Method": "String readUTF(DataInputStream d){\r\n    if (d.readBoolean()) {\r\n        return d.readUTF();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.parseComponentSelectedStyle",
	"Comment": "returns the selected style of the component with the given basestyle or a new instance of the defaultstyle, but overrides styles based on the directives in the stylestrings.this method will always return a new style instance to prevent modification of the globalstyle object.",
	"Method": "Style parseComponentSelectedStyle(Resources theme,String baseStyle,String id,String styleString){\r\n    return parseStyle(theme, id, \"sel#\", baseStyle, true, styleString);\r\n}"
}, {
	"Path": "com.codename1.xml.XMLParser.setParserCallback",
	"Comment": "sets the specified callback to serve as the callback for parsing errors",
	"Method": "void setParserCallback(ParserCallback parserCallback){\r\n    this.parserCallback = parserCallback;\r\n}"
}, {
	"Path": "com.codename1.components.OnOffSwitch.getListeners",
	"Comment": "returns a collection containing the action listeners for this button",
	"Method": "Collection getListeners(){\r\n    return dispatcher.getListenerCollection();\r\n}"
}, {
	"Path": "ly.count.android.sdk.DeviceInfo.getCarrier",
	"Comment": "returns the display name of the current network operator from thetelephonymanager from the specified context.",
	"Method": "String getCarrier(Context context){\r\n    String carrier = \"\";\r\n    final TelephonyManager manager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);\r\n    if (manager != null) {\r\n        carrier = manager.getNetworkOperatorName();\r\n    }\r\n    if (carrier == null || carrier.length() == 0) {\r\n        carrier = \"\";\r\n        if (Countly.sharedInstance().isLoggingEnabled()) {\r\n            Log.i(Countly.TAG, \"No carrier found\");\r\n        }\r\n    }\r\n    return carrier;\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testSubmitQuery",
	"Comment": "tests submitting a query with a configured consistency level.",
	"Method": "void testSubmitQuery(int nodes,Query.ConsistencyLevel consistency){\r\n    createServers(nodes);\r\n    CopycatClient client = createClient();\r\n    client.submit(new TestQuery(consistency)).thenAccept(result -> {\r\n        threadAssertNotNull(result);\r\n        resume();\r\n    });\r\n    await(30000);\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.Spinner.setInputSkipDelay",
	"Comment": "indicates the time after which the skip input area for entering spinner values manually will disappear",
	"Method": "void setInputSkipDelay(int aInputSkipDelay){\r\n    inputSkipDelay = aInputSkipDelay;\r\n}"
}, {
	"Path": "com.codename1.io.rest.RequestBuilder.onErrorCodeString",
	"Comment": "in case of an error this method is invoked asynchronously to processthe error content with the json data",
	"Method": "RequestBuilder onErrorCodeString(ErrorCodeHandler<String> err){\r\n    stringErrorCallback = err;\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.dial",
	"Comment": "opens the device dialer application with the given phone number",
	"Method": "void dial(String phoneNumber){\r\n    Display.impl.dial(phoneNumber);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.getDatabasePath",
	"Comment": "returns the file path of the database if exists and if supported on the platform.",
	"Method": "String getDatabasePath(String databaseName){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.setComponentSelectedStyle",
	"Comment": "allows a developer to programmatically install a style into the ui manager",
	"Method": "void setComponentSelectedStyle(String id,Style style){\r\n    if (id == null || id.length() == 0) {\r\n        id = \"\";\r\n    } else {\r\n        id = id + \".\";\r\n    }\r\n    selectedStyles.put(id, style);\r\n}"
}, {
	"Path": "java.util.Vector.removeElement",
	"Comment": "removes the first occurrence, starting at the beginning and movingtowards the end, of the specified object from this vector. all elementswith an index bigger than the element that gets removed have their indexdecreased by 1.",
	"Method": "boolean removeElement(Object object){\r\n    int index;\r\n    if ((index = indexOf(object, 0)) == -1) {\r\n        return false;\r\n    }\r\n    removeElementAt(index);\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.shouldBlockSideSwipe",
	"Comment": "a component that might need side swipe such as the slidercould block it from being used for some other purpose whenon top of said component.",
	"Method": "boolean shouldBlockSideSwipe(){\r\n    return isScrollableX() || (parent != null && parent.shouldBlockSideSwipe());\r\n}"
}, {
	"Path": "java.lang.Character.toLowerCase",
	"Comment": "returns the lower case equivalent for the specified code point if it isan upper case letter. otherwise, the specified code point is returnedunchanged.",
	"Method": "char toLowerCase(char ch){\r\n    return ' ';\r\n}"
}, {
	"Path": "org.conscrypt.AbstractConscryptSocket.setSoWriteTimeout",
	"Comment": "note write timeouts are not part of the javax.net.ssl.sslsocket api",
	"Method": "void setSoWriteTimeout(int writeTimeoutMilliseconds){\r\n    throw new SocketException(\"Method setSoWriteTimeout() is not supported.\");\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.readResponse",
	"Comment": "callback for the server response with the input stream from the server.this method is invoked on the network thread",
	"Method": "void readResponse(InputStream input){\r\n    if (isKilled()) {\r\n        return;\r\n    }\r\n    if (destinationFile != null) {\r\n        OutputStream o = FileSystemStorage.getInstance().openOutputStream(destinationFile);\r\n        Util.copy(input, o);\r\n        if (isKilled()) {\r\n            FileSystemStorage.getInstance().delete(destinationFile);\r\n        }\r\n    } else {\r\n        if (destinationStorage != null) {\r\n            OutputStream o = Storage.getInstance().createOutputStream(destinationStorage);\r\n            Util.copy(input, o);\r\n            if (isKilled()) {\r\n                Storage.getInstance().deleteStorageFile(destinationStorage);\r\n            }\r\n        } else {\r\n            data = Util.readInputStream(input);\r\n        }\r\n    }\r\n    if (hasResponseListeners() && !isKilled()) {\r\n        fireResponseListener(new NetworkEvent(this, data));\r\n    }\r\n}"
}, {
	"Path": "java.util.Vector.elements",
	"Comment": "returns an enumeration on the elements of this vector. the results of theenumeration may be affected if the contents of this vector is modified.",
	"Method": "java.util.Enumeration<E> elements(){\r\n    return new java.util.Enumeration<E>() {\r\n        int pos = 0;\r\n        public boolean hasMoreElements() {\r\n            return pos < elementCount;\r\n        }\r\n        @SuppressWarnings(\"unchecked\")\r\n        public E nextElement() {\r\n            synchronized (Vector.this) {\r\n                if (pos < elementCount) {\r\n                    return (E) elementData[pos++];\r\n                }\r\n            }\r\n            throw new NoSuchElementException();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "java.util.Vector.elements",
	"Comment": "returns an enumeration on the elements of this vector. the results of theenumeration may be affected if the contents of this vector is modified.",
	"Method": "java.util.Enumeration<E> elements(){\r\n    return pos < elementCount;\r\n}"
}, {
	"Path": "java.util.Vector.elements",
	"Comment": "returns an enumeration on the elements of this vector. the results of theenumeration may be affected if the contents of this vector is modified.",
	"Method": "java.util.Enumeration<E> elements(){\r\n    synchronized (Vector.this) {\r\n        if (pos < elementCount) {\r\n            return (E) elementData[pos++];\r\n        }\r\n    }\r\n    throw new NoSuchElementException();\r\n}"
}, {
	"Path": "com.alibaba.citrus.service.requestcontext.util.tomcat.ServerCookie.isToken",
	"Comment": "tests a string and returns true if the string counts as a reserved tokenin the java language.",
	"Method": "boolean isToken(String value,boolean isToken,String value,String literals){\r\n    String tspecials = literals == null ? ServerCookie.tspecials : literals;\r\n    if (value == null) {\r\n        return true;\r\n    }\r\n    int len = value.length();\r\n    for (int i = 0; i < len; i++) {\r\n        char c = value.charAt(i);\r\n        if (tspecials.indexOf(c) != -1) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Motion.createEaseOutMotion",
	"Comment": "equivalent to createcubicbeziermotion with 0f, 0f, 0.58f, 1.0f as arguments.",
	"Method": "Motion createEaseOutMotion(int sourceValue,int destinationValue,int duration){\r\n    return createCubicBezierMotion(sourceValue, destinationValue, duration, 0f, 0f, 0.58f, 1.0f);\r\n}"
}, {
	"Path": "android.support.v4.util.LongSparseArray.delete",
	"Comment": "removes the mapping from the specified key, if there was any.",
	"Method": "void delete(long key){\r\n    int i = binarySearch(mKeys, 0, mSize, key);\r\n    if (i >= 0) {\r\n        if (mValues[i] != DELETED) {\r\n            mValues[i] = DELETED;\r\n            mGarbage = true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.Stack.search",
	"Comment": "returns the index of the first occurrence of the object, starting fromthe top of the stack.",
	"Method": "int search(Object o){\r\n    final Object[] dumpArray = elementData;\r\n    final int size = elementCount;\r\n    if (o != null) {\r\n        for (int i = size - 1; i >= 0; i--) {\r\n            if (o.equals(dumpArray[i])) {\r\n                return size - i;\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = size - 1; i >= 0; i--) {\r\n            if (dumpArray[i] == null) {\r\n                return size - i;\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.codename1.payment.Receipt.getQuantity",
	"Comment": "quantity.currently this will always be 1, but potentially could be usedinternally to denote other quantities.",
	"Method": "int getQuantity(){\r\n    return quantity;\r\n}"
}, {
	"Path": "com.codename1.components.SpanButton.setShouldLocalize",
	"Comment": "indicates if text should be localized when set to the component, bydefault all text is localized so this allows disabling automaticlocalization for a specific component.",
	"Method": "void setShouldLocalize(boolean shouldLocalize){\r\n    this.shouldLocalize = shouldLocalize;\r\n}"
}, {
	"Path": "android.support.v4.app.TaskStackBuilder.from",
	"Comment": "return a new taskstackbuilder for launching a fresh task stack consistingof a series of activities.",
	"Method": "TaskStackBuilder from(Context context){\r\n    return create(context);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.DimConstraint.setGrow",
	"Comment": "sets the grow weight.\tgrow weight is how flexible the entity should be, relative to other entities, when it comes to growing. null or\tzero mean it will never grow. an entity that has twice the grow weight compared to another entity will get twice\tas much of available space.\tgrowweight are only compared within the same growprio.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "void setGrow(Float weight){\r\n    resize.grow = weight;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isThirdSoftButton",
	"Comment": "indicates whether the 3rd softbutton should be supported on this device",
	"Method": "boolean isThirdSoftButton(){\r\n    return thirdSoftButton;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.getInAppPurchase",
	"Comment": "returns the native os purchase implementation if applicable, if unavailable thismethod will try to fallback to a custom purchase implementation and failing thatwill return null",
	"Method": "Purchase getInAppPurchase(Purchase getInAppPurchase,boolean d){\r\n    return getInAppPurchase();\r\n}"
}, {
	"Path": "org.conscrypt.javax.crypto.CipherTest.test_AESGCMNoPadding_init_algParams",
	"Comment": "check that initializing with a gcm algorithmparameters produces the same resultas initializing with a gcmparameterspec.",
	"Method": "void test_AESGCMNoPadding_init_algParams(){\r\n    SecretKeySpec key = new SecretKeySpec(new byte[16], \"AES\");\r\n    GCMParameterSpec spec = new GCMParameterSpec(96, new byte[12]);\r\n    AlgorithmParameters params = AlgorithmParameters.getInstance(\"GCM\");\r\n    params.init(spec);\r\n    Cipher c1 = Cipher.getInstance(\"AES/GCM/NoPadding\");\r\n    Cipher c2 = Cipher.getInstance(\"AES/GCM/NoPadding\");\r\n    c1.init(Cipher.ENCRYPT_MODE, key, spec);\r\n    c2.init(Cipher.ENCRYPT_MODE, key, params);\r\n    assertEquals(c1.getProvider(), c2.getProvider());\r\n    c1.updateAAD(new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05 });\r\n    c2.updateAAD(new byte[] { 0x01, 0x02, 0x03, 0x04, 0x05 });\r\n    assertEquals(Arrays.toString(c1.doFinal()), Arrays.toString(c2.doFinal()));\r\n}"
}, {
	"Path": "com.codename1.ui.Component.containsOrOwns",
	"Comment": "checks to see if this component either contains the given point, orif it owns the component that contains the given point.",
	"Method": "boolean containsOrOwns(int x,int y){\r\n    if (contains(x, y)) {\r\n        return true;\r\n    }\r\n    Form f = getComponentForm();\r\n    if (f != null) {\r\n        Component cmp = f.getComponentAt(x, y);\r\n        if (cmp != null) {\r\n            if (cmp.isOwnedBy(this)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.AbstractList.indexOf",
	"Comment": "searches this list for the specified object and returns the index of thefirst occurrence.",
	"Method": "int indexOf(Object object){\r\n    ListIterator<?> it = listIterator();\r\n    if (object != null) {\r\n        while (it.hasNext()) {\r\n            if (object.equals(it.next())) {\r\n                return it.previousIndex();\r\n            }\r\n        }\r\n    } else {\r\n        while (it.hasNext()) {\r\n            if (it.next() == null) {\r\n                return it.previousIndex();\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "android.support.v4.view.PagerAdapter.notifyDataSetChanged",
	"Comment": "this method should be called by the application if the data backing this adapter has changedand associated views should update.",
	"Method": "void notifyDataSetChanged(){\r\n    mObservable.notifyChanged();\r\n}"
}, {
	"Path": "com.codename1.components.ImageViewer.getSwipeThreshold",
	"Comment": "the swipe threshold is a number between 0 and 1 that indicates the threshold after which the swiped image moves to the next image. below that number the image will bounce back",
	"Method": "float getSwipeThreshold(){\r\n    return swipeThreshold;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.getPlatformOverrides",
	"Comment": "returns the suffixes for ovr files that should be used when loading a layered resource file on this platform",
	"Method": "String[] getPlatformOverrides(){\r\n    return impl.getPlatformOverrides();\r\n}"
}, {
	"Path": "com.codename1.ui.validation.Validator.getComponentValue",
	"Comment": "returns the value of the given component, this can be overriden to add support for custom built components",
	"Method": "Object getComponentValue(Component cmp){\r\n    if (cmp instanceof InputComponent) {\r\n        cmp = ((InputComponent) cmp).getEditor();\r\n    }\r\n    if (cmp instanceof TextArea) {\r\n        return ((TextArea) cmp).getText();\r\n    }\r\n    if (cmp instanceof Picker) {\r\n        return ((Picker) cmp).getValue();\r\n    }\r\n    if (cmp instanceof RadioButton || cmp instanceof CheckBox) {\r\n        if (((Button) cmp).isSelected()) {\r\n            return Boolean.TRUE;\r\n        }\r\n        return Boolean.FALSE;\r\n    }\r\n    if (cmp instanceof Label) {\r\n        return ((Label) cmp).getText();\r\n    }\r\n    if (cmp instanceof List) {\r\n        return ((List) cmp).getSelectedItem();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isSocketAvailable",
	"Comment": "indicates whether the underlying implementation supports sockets",
	"Method": "boolean isSocketAvailable(){\r\n    return false;\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.hasBeenCalledOnStart",
	"Comment": "returns if the countly sdk onstart function has been called at least once",
	"Method": "boolean hasBeenCalledOnStart(){\r\n    return calledAtLeastOnceOnStart;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.setMinimizeOnBack",
	"Comment": "when set to true the physical back button will minimize the application",
	"Method": "void setMinimizeOnBack(boolean minimizeOnBack){\r\n    menuBar.setMinimizeOnBack(minimizeOnBack);\r\n}"
}, {
	"Path": "io.atomix.copycat.protocol.UnregisterRequest.builder",
	"Comment": "returns a unregister request builder for an existing request.",
	"Method": "Builder builder(Builder builder,UnregisterRequest request){\r\n    return new Builder(request);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.ArrayList.removeRange",
	"Comment": "removes the objects in the specified range from the start to the end, butnot including the end index.",
	"Method": "void removeRange(int start,int end){\r\n    if (start < 0) {\r\n        throw new IndexOutOfBoundsException(\"\" + start);\r\n    } else if (end > size) {\r\n        throw new IndexOutOfBoundsException(\"\" + end + \" out of: \" + size);\r\n    } else if (start > end) {\r\n        throw new IndexOutOfBoundsException(\"\" + start + \" out of: \" + end);\r\n    }\r\n    if (start == end) {\r\n        return;\r\n    }\r\n    if (end == size) {\r\n        Arrays.fill(array, firstIndex + start, firstIndex + size, null);\r\n    } else if (start == 0) {\r\n        Arrays.fill(array, firstIndex, firstIndex + end, null);\r\n        firstIndex += end;\r\n    } else {\r\n        System.arraycopy(array, firstIndex + end, array, firstIndex + start, size - end);\r\n        int lastIndex = firstIndex + size;\r\n        int newLast = lastIndex + start - end;\r\n        Arrays.fill(array, newLast, lastIndex, null);\r\n    }\r\n    size -= end - start;\r\n    modCount++;\r\n}"
}, {
	"Path": "com.codename1.charts.models.XYSeries.clearSeriesValues",
	"Comment": "removes all the existing values from the series but annotations.",
	"Method": "void clearSeriesValues(){\r\n    mXY.clear();\r\n    initRange();\r\n}"
}, {
	"Path": "com.codename1.ui.ComboBox.isDefaultActAsSpinnerDialog",
	"Comment": "when this flag is active the combo box acts as a button that opens a dialog that looks like a spinnerthis allows creating user interfaces for touch devices where a spinner ui approach is more common thana combo box paradigm.",
	"Method": "boolean isDefaultActAsSpinnerDialog(){\r\n    return defaultActAsSpinnerDialog;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.Storage.flushOnCommit",
	"Comment": "returns whether to flush buffers to disk when entries are committed.",
	"Method": "boolean flushOnCommit(){\r\n    return flushOnCommit;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.PlatformDefaults.getMinimumButtonWidth",
	"Comment": "returns the recommended minimum button width depending on the current set platform.",
	"Method": "UnitValue getMinimumButtonWidth(){\r\n    return BUTT_WIDTH;\r\n}"
}, {
	"Path": "com.codename1.properties.SetProperty.removeAll",
	"Comment": "removes from the set all values from the given collection and fires a change event if the set has changed",
	"Method": "K removeAll(Collection<? extends T> v){\r\n    if (value.removeAll(v)) {\r\n        firePropertyChanged();\r\n    }\r\n    return (K) parent.parent;\r\n}"
}, {
	"Path": "java.lang.Integer.equals",
	"Comment": "compares this object to the specified object. the result is true if and only if the argument is not null and is an integer object that contains the same int value as this object.",
	"Method": "boolean equals(java.lang.Object obj){\r\n    return obj != null && obj.getClass() == getClass() && ((Integer) obj).value == value;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getNextFocusDown",
	"Comment": "allows us to determine which component will receive focus next when traversing with the down key",
	"Method": "Component getNextFocusDown(){\r\n    return nextFocusDown;\r\n}"
}, {
	"Path": "android.support.v4.util.LongSparseArray.get",
	"Comment": "gets the object mapped from the specified key, or the specified objectif no such mapping has been made.",
	"Method": "E get(long key,E get,long key,E valueIfKeyNotFound){\r\n    int i = binarySearch(mKeys, 0, mSize, key);\r\n    if (i < 0 || mValues[i] == DELETED) {\r\n        return valueIfKeyNotFound;\r\n    } else {\r\n        return (E) mValues[i];\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Arrays.binarySearch",
	"Comment": "performs a binary search for the specified element in a part of thespecified sorted array.",
	"Method": "int binarySearch(byte[] array,byte value,int binarySearch,char[] array,char value,int binarySearch,double[] array,double value,int binarySearch,float[] array,float value,int binarySearch,int[] array,int value,int binarySearch,long[] array,long value,int binarySearch,Object[] array,Object object,int binarySearch,T[] array,T object,Comparator<? super T> comparator,int binarySearch,short[] array,short value,int binarySearch,byte[] array,int startIndex,int endIndex,byte value,int binarySearch,char[] array,int startIndex,int endIndex,char value,int binarySearch,double[] array,int startIndex,int endIndex,double value,int binarySearch,float[] array,int startIndex,int endIndex,float value,int binarySearch,int[] array,int startIndex,int endIndex,int value,int binarySearch,long[] array,int startIndex,int endIndex,long value,int binarySearch,Object[] array,int startIndex,int endIndex,Object object,int binarySearch,T[] array,int startIndex,int endIndex,T object,Comparator<? super T> comparator,int binarySearch,short[] array,int startIndex,int endIndex,short value){\r\n    checkIndexForBinarySearch(array.length, startIndex, endIndex);\r\n    int low = startIndex, mid = -1, high = endIndex - 1;\r\n    while (low <= high) {\r\n        mid = (low + high) >>> 1;\r\n        if (value > array[mid]) {\r\n            low = mid + 1;\r\n        } else if (value == array[mid]) {\r\n            return mid;\r\n        } else {\r\n            high = mid - 1;\r\n        }\r\n    }\r\n    if (mid < 0) {\r\n        int insertPoint = endIndex;\r\n        for (int index = startIndex; index < endIndex; index++) {\r\n            if (value < array[index]) {\r\n                insertPoint = index;\r\n            }\r\n        }\r\n        return -insertPoint - 1;\r\n    }\r\n    return -mid - (value < array[mid] ? 1 : 2);\r\n}"
}, {
	"Path": "org.conscrypt.Platform.wrapRsaKey",
	"Comment": "wraps an old androidopenssl key instance. this is not needed on ri.",
	"Method": "OpenSSLKey wrapRsaKey(PrivateKey javaKey){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.html.DocumentInfo.setBaseURL",
	"Comment": "sets the base url for this document. usually this is deduced automatically from the page url, but in some cases this is different, for example when an href attribute is provided in the base tag",
	"Method": "void setBaseURL(String baseURL){\r\n    this.baseURL = baseURL;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.createInsetBorder",
	"Comment": "creates an inset border with the specified thickness and color",
	"Method": "Border createInsetBorder(int thickness,Border createInsetBorder,int thickness,int color){\r\n    return createCSSBorder(TYPE_INSET, thickness, color);\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.formNavigationStackDebug",
	"Comment": "useful method for logging form navigation, it returns a string representing the navigation state which can be used to analyze crash reports",
	"Method": "String formNavigationStackDebug(){\r\n    if (baseFormNavigationStack != null) {\r\n        return baseFormNavigationStack.toString();\r\n    }\r\n    return \"Null navigation stack\";\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.TreeMap.putAll",
	"Comment": "copies all the mappings in the given map to this map. these mappings willreplace all mappings that this map had for any of the keys currently inthe given map.",
	"Method": "void putAll(Map<? extends K, ? extends V> map){\r\n    Iterator it = map.entrySet().iterator();\r\n    while (it.hasNext()) {\r\n        Map.Entry<? extends K, ? extends V> entry = (Map.Entry<? extends K, ? extends V>) it.next();\r\n        this.putImpl(entry.getKey(), entry.getValue());\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.Progress.isAutoShow",
	"Comment": "shows the progress automatically when the request processing is started",
	"Method": "boolean isAutoShow(){\r\n    return autoShow;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayeredLayout.getComponentConstraint",
	"Comment": "gets the layeredlayoutconstraint associated with the given component.may return null if there is no constraint.",
	"Method": "Object getComponentConstraint(Component comp){\r\n    return comp.getClientProperty(\"$$LayeredLayoutConstraint\");\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.setMonthViewSelectedStyle",
	"Comment": "sets the selected style of the month view component within the calendar",
	"Method": "void setMonthViewSelectedStyle(Style s){\r\n    mv.setSelectedStyle(s);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLInputFormat.verifyString",
	"Comment": "verifies that the given string conforms to the constraints represented by this object.",
	"Method": "boolean verifyString(String str){\r\n    if ((str.length() > maxLength) || (str.length() < minLength)) {\r\n        return false;\r\n    }\r\n    int i = 0;\r\n    Enumeration e = formatConstraints.elements();\r\n    if (!str.equals(\"\")) {\r\n        char c = str.charAt(i);\r\n        for (; e.hasMoreElements(); ) {\r\n            FormatConstraint constraint = (FormatConstraint) e.nextElement();\r\n            if (constraint.count == FormatConstraint.COUNT_EXACTLY_ONE) {\r\n                if (!verifyChar(c, constraint.type)) {\r\n                    return false;\r\n                }\r\n                i++;\r\n                if (i < str.length()) {\r\n                    c = str.charAt(i);\r\n                } else {\r\n                    break;\r\n                }\r\n            } else {\r\n                int charNum = 0;\r\n                while ((i < str.length()) && (charNum < constraint.count)) {\r\n                    if (!verifyChar(c, constraint.type)) {\r\n                        break;\r\n                    }\r\n                    i++;\r\n                    charNum++;\r\n                    if (i < str.length()) {\r\n                        c = str.charAt(i);\r\n                    } else {\r\n                        break;\r\n                    }\r\n                }\r\n                if (i >= str.length()) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (i < str.length()) {\r\n            return false;\r\n        }\r\n    }\r\n    while (e.hasMoreElements()) {\r\n        FormatConstraint constraint = (FormatConstraint) e.nextElement();\r\n        if (constraint.count == FormatConstraint.COUNT_EXACTLY_ONE) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.actionCommandImplNoRecurseComponent",
	"Comment": "invoked to allow subclasses of form to handle a command from one pointrather than implementing many command instances",
	"Method": "void actionCommandImplNoRecurseComponent(Command cmd,ActionEvent ev){\r\n    if (cmd == null) {\r\n        return;\r\n    }\r\n    if (comboLock) {\r\n        if (cmd == menuBar.getCancelMenuItem()) {\r\n            actionCommand(cmd);\r\n            return;\r\n        }\r\n        return;\r\n    }\r\n    if (cmd != menuBar.getSelectCommand()) {\r\n        if (commandListener != null) {\r\n            commandListener.fireActionEvent(ev);\r\n            if (ev.isConsumed()) {\r\n                return;\r\n            }\r\n        }\r\n        actionCommand(cmd);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.html.DocumentInfo.getFullUrl",
	"Comment": "returns the full url string including parameters in get request",
	"Method": "String getFullUrl(){\r\n    if ((postRequest) || (params == null) || (params.equals(\"\"))) {\r\n        return pageURL;\r\n    } else {\r\n        return pageURL + \"?\" + params;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Tabs.setChangeTabOnFocus",
	"Comment": "indicates that a tab should change when the focus changes without the user physically pressing a button",
	"Method": "void setChangeTabOnFocus(boolean changeTabOnFocus){\r\n    this.changeTabOnFocus = changeTabOnFocus;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getBindablePropertyNames",
	"Comment": "returns the names of the properties within this component that can be bound for persistence,the order of these names mean that the first one will be the first bound",
	"Method": "String[] getBindablePropertyNames(){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.tree.Tree.childToDisplayLabel",
	"Comment": "converts a tree child to a label, this method can be overriden forsimple rendering effects",
	"Method": "String childToDisplayLabel(Object child){\r\n    return child.toString();\r\n}"
}, {
	"Path": "com.codename1.components.InfiniteProgress.setMaterialDesignMode",
	"Comment": "indicates whether this instance of infinite progress works in the materialdesign mode by default",
	"Method": "void setMaterialDesignMode(boolean materialDesignMode){\r\n    this.materialDesignMode = materialDesignMode;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.setScrollable",
	"Comment": "the equivalent of calling both setscrollabley and setscrollablex",
	"Method": "void setScrollable(boolean scrollable){\r\n    setScrollableX(scrollable);\r\n    setScrollableY(scrollable);\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.wasDisposedDueToOutOfBoundsTouch",
	"Comment": "returns true if a dialog that was disposed did it because of a pointer out of bounds",
	"Method": "boolean wasDisposedDueToOutOfBoundsTouch(){\r\n    return pressedOutOfBounds;\r\n}"
}, {
	"Path": "android.support.v4.view.ViewCompat.canScrollHorizontally",
	"Comment": "check if this view can be scrolled horizontally in a certain direction.",
	"Method": "boolean canScrollHorizontally(View v,int direction,boolean canScrollHorizontally,View v,int direction,boolean canScrollHorizontally,View v,int direction,boolean canScrollHorizontally,View v,int direction){\r\n    return IMPL.canScrollHorizontally(v, direction);\r\n}"
}, {
	"Path": "com.codename1.io.Log.setLevel",
	"Comment": "sets the logging level for printing log details, the lower the value the more verbose would the printouts be",
	"Method": "void setLevel(int level){\r\n    instance.level = level;\r\n}"
}, {
	"Path": "java.util.Collections.disjoint",
	"Comment": "returns whether the specified collections have no elements in common.",
	"Method": "boolean disjoint(Collection<?> c1,Collection<?> c2){\r\n    if ((c1 instanceof Set) && !(c2 instanceof Set) || (c2.size()) > c1.size()) {\r\n        Collection<?> tmp = c1;\r\n        c1 = c2;\r\n        c2 = tmp;\r\n    }\r\n    Iterator<?> it = c1.iterator();\r\n    while (it.hasNext()) {\r\n        if (c2.contains(it.next())) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.Tabs.getTabSelectedIcon",
	"Comment": "returns the selected icon of the tab component. this method should be used when overridingcreatetab",
	"Method": "Image getTabSelectedIcon(Component tab,Image getTabSelectedIcon,int index){\r\n    checkIndex(index);\r\n    return getTabSelectedIcon(tabsContainer.getComponentAt(index));\r\n}"
}, {
	"Path": "com.codename1.ui.URLImage.createToStorage",
	"Comment": "creates an image the will be downloaded on the fly as necessary",
	"Method": "URLImage createToStorage(EncodedImage placeholder,String storageFile,String url,URLImage createToStorage,EncodedImage placeholder,String storageFile,String url,ImageAdapter adapter){\r\n    return new URLImage(placeholder, url.intern(), adapter, storageFile.intern(), null);\r\n}"
}, {
	"Path": "io.atomix.copycat.server.protocol.PollResponse.accepted",
	"Comment": "returns a boolean indicating whether the poll was accepted.",
	"Method": "boolean accepted(){\r\n    return accepted;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.setLayout",
	"Comment": "sets the layout manager responsible for arranging this container",
	"Method": "void setLayout(Layout layout){\r\n    if (layout.isConstraintTracking()) {\r\n        for (int iter = 0; iter < getComponentCount(); iter++) {\r\n            Component c = getComponentAt(iter);\r\n            Object cons = this.layout.getComponentConstraint(c);\r\n            if (cons != null) {\r\n                layout.addLayoutComponent(cons, c, this);\r\n            }\r\n        }\r\n    }\r\n    this.layout = layout;\r\n    if (layout instanceof BorderLayout && isScrollable()) {\r\n        setScrollable(false);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Display.getFrameRate",
	"Comment": "indicates the maximum frames the api will try to draw every second",
	"Method": "int getFrameRate(){\r\n    return 1000 / framerateLock;\r\n}"
}, {
	"Path": "org.conscrypt.NativeLibraryLoader.copyLibrary",
	"Comment": "copies the given shared library file from classpath to a temporary file.",
	"Method": "void copyLibrary(URL classpathUrl,File tmpFile){\r\n    InputStream in = null;\r\n    OutputStream out = null;\r\n    try {\r\n        in = classpathUrl.openStream();\r\n        out = new FileOutputStream(tmpFile);\r\n        byte[] buffer = new byte[8192];\r\n        int length;\r\n        while ((length = in.read(buffer)) > 0) {\r\n            out.write(buffer, 0, length);\r\n        }\r\n        out.flush();\r\n    } finally {\r\n        closeQuietly(in);\r\n        closeQuietly(out);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.growOrShrink",
	"Comment": "allows a dialog component to grow or shrink to its new preferred size",
	"Method": "void growOrShrink(){\r\n    getDialogComponent().setShouldCalcPreferredSize(true);\r\n    growOrShrinkImpl(Display.getInstance().getDisplayWidth(), Display.getInstance().getDisplayHeight());\r\n    forceRevalidate();\r\n}"
}, {
	"Path": "com.codename1.components.SplitPane.getLeft",
	"Comment": "gets the component that is currently placed in the left of the split pane.",
	"Method": "Component getLeft(){\r\n    return getTopOrLeftComponent();\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentGroup.encloseHorizontal",
	"Comment": "shorthand method for wrapping the given components in a horizontal component group",
	"Method": "ComponentGroup encloseHorizontal(Component cmp){\r\n    ComponentGroup c = new ComponentGroup();\r\n    c.setHorizontal(true);\r\n    for (Component cc : cmp) {\r\n        c.add(cc);\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "com.codename1.charts.renderers.SimpleSeriesRenderer.isDisplayBoundingPoints",
	"Comment": "returns if the bounding points of the first and last visible ones should be displayed.",
	"Method": "boolean isDisplayBoundingPoints(){\r\n    return mDisplayBoundingPoints;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.paintComponentBackground",
	"Comment": "paints the background of a component based on the style values on thegiven graphics context, the style could be accessed from the drawingthread in read only capacity to make the code slightly more efficient",
	"Method": "void paintComponentBackground(Object nativeGraphics,int x,int y,int width,int height,Style s){\r\n    if (width <= 0 || height <= 0) {\r\n        return;\r\n    }\r\n    Image bgImageOrig = s.getBgImage();\r\n    if (bgImageOrig == null) {\r\n        if (s.getBackgroundType() >= Style.BACKGROUND_GRADIENT_LINEAR_VERTICAL) {\r\n            drawGradientBackground(s, nativeGraphics, x, y, width, height);\r\n            return;\r\n        }\r\n        setColor(nativeGraphics, s.getBgColor());\r\n        fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n    } else {\r\n        int iW = bgImageOrig.getWidth();\r\n        int iH = bgImageOrig.getHeight();\r\n        Object bgImage = bgImageOrig.getImage();\r\n        switch(s.getBackgroundType()) {\r\n            case Style.BACKGROUND_NONE:\r\n                if (s.getBgTransparency() != 0) {\r\n                    setColor(nativeGraphics, s.getBgColor());\r\n                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                }\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_SCALED:\r\n                if (isScaledImageDrawingSupported()) {\r\n                    drawImage(nativeGraphics, bgImage, x, y, width, height);\r\n                } else {\r\n                    if (iW != width || iH != height) {\r\n                        bgImageOrig = bgImageOrig.scaled(width, height);\r\n                        s.setBgImage(bgImageOrig, true);\r\n                        bgImage = bgImageOrig.getImage();\r\n                    }\r\n                    drawImage(nativeGraphics, bgImage, x, y);\r\n                }\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_SCALED_FILL:\r\n                float r = Math.max(((float) width) / ((float) iW), ((float) height) / ((float) iH));\r\n                int bwidth = (int) (((float) iW) * r);\r\n                int bheight = (int) (((float) iH) * r);\r\n                if (isScaledImageDrawingSupported()) {\r\n                    drawImage(nativeGraphics, bgImage, x + (width - bwidth) / 2, y + (height - bheight) / 2, bwidth, bheight);\r\n                } else {\r\n                    if (iW != bwidth || iH != bheight) {\r\n                        bgImageOrig = bgImageOrig.scaled(bwidth, bheight);\r\n                        s.setBgImage(bgImageOrig, true);\r\n                        bgImage = bgImageOrig.getImage();\r\n                    }\r\n                    drawImage(nativeGraphics, bgImage, x + (width - bwidth) / 2, y + (height - bheight) / 2);\r\n                }\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_SCALED_FIT:\r\n                if (s.getBgTransparency() != 0) {\r\n                    setColor(nativeGraphics, s.getBgColor());\r\n                    fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                }\r\n                float r2 = Math.min(((float) width) / ((float) iW), ((float) height) / ((float) iH));\r\n                int awidth = (int) (((float) iW) * r2);\r\n                int aheight = (int) (((float) iH) * r2);\r\n                if (isScaledImageDrawingSupported()) {\r\n                    drawImage(nativeGraphics, bgImage, x + (width - awidth) / 2, y + (height - aheight) / 2, awidth, aheight);\r\n                } else {\r\n                    if (iW != awidth || iH != aheight) {\r\n                        bgImageOrig = bgImageOrig.scaled(awidth, aheight);\r\n                        s.setBgImage(bgImageOrig, true);\r\n                        bgImage = bgImageOrig.getImage();\r\n                    }\r\n                    drawImage(nativeGraphics, bgImage, x + (width - awidth) / 2, y + (height - aheight) / 2, awidth, aheight);\r\n                }\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_TILE_BOTH:\r\n                tileImage(nativeGraphics, bgImage, x, y, width, height);\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_TILE_HORIZONTAL_ALIGN_TOP:\r\n                setColor(nativeGraphics, s.getBgColor());\r\n                fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                tileImage(nativeGraphics, bgImage, x, y, width, iH);\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_TILE_HORIZONTAL_ALIGN_CENTER:\r\n                setColor(nativeGraphics, s.getBgColor());\r\n                fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                tileImage(nativeGraphics, bgImage, x, y + (height / 2 - iH / 2), width, iH);\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_TILE_HORIZONTAL_ALIGN_BOTTOM:\r\n                setColor(nativeGraphics, s.getBgColor());\r\n                fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                tileImage(nativeGraphics, bgImage, x, y + (height - iH), width, iH);\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_TILE_VERTICAL_ALIGN_LEFT:\r\n                setColor(nativeGraphics, s.getBgColor());\r\n                fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                for (int yPos = 0; yPos <= height; yPos += iH) {\r\n                    drawImage(nativeGraphics, bgImage, x, y + yPos);\r\n                }\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_TILE_VERTICAL_ALIGN_CENTER:\r\n                setColor(nativeGraphics, s.getBgColor());\r\n                fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                for (int yPos = 0; yPos <= height; yPos += iH) {\r\n                    drawImage(nativeGraphics, bgImage, x + (width / 2 - iW / 2), y + yPos);\r\n                }\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_TILE_VERTICAL_ALIGN_RIGHT:\r\n                setColor(nativeGraphics, s.getBgColor());\r\n                fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                for (int yPos = 0; yPos <= height; yPos += iH) {\r\n                    drawImage(nativeGraphics, bgImage, x + width - iW, y + yPos);\r\n                }\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_ALIGNED_TOP:\r\n                setColor(nativeGraphics, s.getBgColor());\r\n                fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                drawImage(nativeGraphics, bgImage, x + (width / 2 - iW / 2), y);\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_ALIGNED_BOTTOM:\r\n                setColor(nativeGraphics, s.getBgColor());\r\n                fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                drawImage(nativeGraphics, bgImage, x + (width / 2 - iW / 2), y + (height - iH));\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_ALIGNED_LEFT:\r\n                setColor(nativeGraphics, s.getBgColor());\r\n                fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                drawImage(nativeGraphics, bgImage, x, y + (height / 2 - iH / 2));\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_ALIGNED_RIGHT:\r\n                setColor(nativeGraphics, s.getBgColor());\r\n                fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                drawImage(nativeGraphics, bgImage, x + width - iW, y + (height / 2 - iH / 2));\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_ALIGNED_CENTER:\r\n                setColor(nativeGraphics, s.getBgColor());\r\n                fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                drawImage(nativeGraphics, bgImage, x + (width / 2 - iW / 2), y + (height / 2 - iH / 2));\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_ALIGNED_TOP_LEFT:\r\n                setColor(nativeGraphics, s.getBgColor());\r\n                fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                drawImage(nativeGraphics, bgImage, x, y);\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_ALIGNED_TOP_RIGHT:\r\n                setColor(nativeGraphics, s.getBgColor());\r\n                fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                drawImage(nativeGraphics, bgImage, x + width - iW, y);\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_ALIGNED_BOTTOM_LEFT:\r\n                setColor(nativeGraphics, s.getBgColor());\r\n                fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                drawImage(nativeGraphics, bgImage, x, y + (height - iH));\r\n                return;\r\n            case Style.BACKGROUND_IMAGE_ALIGNED_BOTTOM_RIGHT:\r\n                setColor(nativeGraphics, s.getBgColor());\r\n                fillRect(nativeGraphics, x, y, width, height, s.getBgTransparency());\r\n                drawImage(nativeGraphics, bgImage, x + width - iW, y + (height - iH));\r\n                return;\r\n            case Style.BACKGROUND_GRADIENT_LINEAR_HORIZONTAL:\r\n            case Style.BACKGROUND_GRADIENT_LINEAR_VERTICAL:\r\n            case Style.BACKGROUND_GRADIENT_RADIAL:\r\n                drawGradientBackground(s, nativeGraphics, x, y, width, height);\r\n                return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.html.DefaultDocumentRequestHandler.wasURLVisited",
	"Comment": "returns true if the url was visited, requires trackvisitedurls to be true",
	"Method": "boolean wasURLVisited(String url){\r\n    return visitedURLs != null && visitedURLs.contains(url);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundBorder.strokeAngle",
	"Comment": "sets the stroke angle of the circle, this only applies to circular versions",
	"Method": "RoundBorder strokeAngle(int strokeAngle){\r\n    this.strokeAngle = strokeAngle;\r\n    modificationTime = System.currentTimeMillis();\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.maps.BoundingBox.contains",
	"Comment": "indicates if the given coordinate is inside the counding box",
	"Method": "boolean contains(Coord cur){\r\n    double latitude = cur.getLatitude();\r\n    if (latitude > getNorthEast().getLatitude() || latitude < getSouthWest().getLatitude()) {\r\n        return false;\r\n    }\r\n    double longitude = cur.getLongitude();\r\n    if (longitude < getSouthWest().getLongitude() || longitude > getNorthEast().getLongitude()) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.components.FloatingActionButton.createPopupContent",
	"Comment": "creates the popup content container to display on the dialog.",
	"Method": "Container createPopupContent(List<FloatingActionButton> fabs){\r\n    Container con = new Container(new BoxLayout(BoxLayout.Y_AXIS));\r\n    for (FloatingActionButton next : subMenu) {\r\n        next.setPreferredW(getWidth());\r\n        Container c = new Container(new BorderLayout());\r\n        Label txt = new Label(next.text);\r\n        txt.setUIID(\"FloatingActionText\");\r\n        c.add(BorderLayout.CENTER, FlowLayout.encloseRight(txt));\r\n        c.add(BorderLayout.EAST, next);\r\n        con.add(c);\r\n    }\r\n    return con;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.hasNativeTheme",
	"Comment": "indicates if the implemenetation has a native underlying theme",
	"Method": "boolean hasNativeTheme(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.components.SplitPane.setRight",
	"Comment": "sets the component to be placed on the right of the split pane.",
	"Method": "void setRight(Component cmp){\r\n    setBottomOrRightComponent(cmp);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.calcSize",
	"Comment": "calculates width or height of an element according to its original size, requested size and default size",
	"Method": "int calcSize(int origDim,String requestedDim,int defaultDim,boolean negativeAllowed){\r\n    if (requestedDim == null) {\r\n        return defaultDim;\r\n    }\r\n    boolean percent = false;\r\n    if (requestedDim.endsWith(\"%\")) {\r\n        percent = true;\r\n        requestedDim = requestedDim.substring(0, requestedDim.length() - 1);\r\n    } else if (requestedDim.endsWith(\"px\")) {\r\n        requestedDim = requestedDim.substring(0, requestedDim.length() - 2);\r\n    }\r\n    int dim = 0;\r\n    try {\r\n        dim = Integer.parseInt(requestedDim);\r\n    } catch (Exception e) {\r\n        return origDim;\r\n    }\r\n    if ((dim < 0) && (!negativeAllowed)) {\r\n        return origDim;\r\n    }\r\n    if (percent) {\r\n        return origDim * dim / 100;\r\n    } else {\r\n        return dim;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.BorderLayout.center",
	"Comment": "convenience method that creates a border layout container and places the given component in the center",
	"Method": "BorderLayout center(Container center,Component center){\r\n    return Container.encloseIn(new BorderLayout(), center, BorderLayout.CENTER);\r\n}"
}, {
	"Path": "com.codename1.ui.geom.Rectangle.contains",
	"Comment": "checks wheather the 2nd rectangle is contained in the first rectangle",
	"Method": "boolean contains(Rectangle rect,boolean contains,int rX,int rY,int rWidth,int rHeight,boolean contains,int x1,int y1,int w1,int h1,int x2,int y2,int w2,int h2,boolean contains,int rX,int rY){\r\n    return x <= rX && y <= rY && x + size.getWidth() >= rX && y + size.getHeight() >= rY;\r\n}"
}, {
	"Path": "ly.count.android.sdk.DeviceId.init",
	"Comment": "initialize device id generation, that is start up required services and send requests.device id is expected to be available after some time.in some cases, countly can override id generation strategy to other one, for example whengoogle play services are not available and user chose advertising id strategy, it will fallback to openudid",
	"Method": "void init(Context context,CountlyStore store,boolean raiseExceptions){\r\n    Type overriddenType = retrieveOverriddenType(store);\r\n    if (overriddenType != null && overriddenType != type) {\r\n        if (Countly.sharedInstance().isLoggingEnabled()) {\r\n            Log.i(TAG, \"Overridden device ID generation strategy detected: \" + overriddenType + \", using it instead of \" + this.type);\r\n        }\r\n        type = overriddenType;\r\n    }\r\n    switch(type) {\r\n        case DEVELOPER_SUPPLIED:\r\n            break;\r\n        case OPEN_UDID:\r\n            if (OpenUDIDAdapter.isOpenUDIDAvailable()) {\r\n                if (Countly.sharedInstance().isLoggingEnabled()) {\r\n                    Log.i(TAG, \"Using OpenUDID\");\r\n                }\r\n                if (!OpenUDIDAdapter.isInitialized()) {\r\n                    OpenUDIDAdapter.sync(context);\r\n                }\r\n            } else {\r\n                if (raiseExceptions)\r\n                    throw new IllegalStateException(\"OpenUDID is not available, please make sure that you have it in your classpath\");\r\n            }\r\n            break;\r\n        case ADVERTISING_ID:\r\n            if (AdvertisingIdAdapter.isAdvertisingIdAvailable()) {\r\n                if (Countly.sharedInstance().isLoggingEnabled()) {\r\n                    Log.i(TAG, \"Using Advertising ID\");\r\n                }\r\n                AdvertisingIdAdapter.setAdvertisingId(context, store, this);\r\n            } else if (OpenUDIDAdapter.isOpenUDIDAvailable()) {\r\n                if (Countly.sharedInstance().isLoggingEnabled()) {\r\n                    Log.i(TAG, \"Advertising ID is not available, falling back to OpenUDID\");\r\n                }\r\n                if (!OpenUDIDAdapter.isInitialized()) {\r\n                    OpenUDIDAdapter.sync(context);\r\n                }\r\n            } else {\r\n                if (Countly.sharedInstance().isLoggingEnabled()) {\r\n                    Log.w(TAG, \"Advertising ID is not available, neither OpenUDID is\");\r\n                }\r\n                if (raiseExceptions)\r\n                    throw new IllegalStateException(\"OpenUDID is not available, please make sure that you have it in your classpath\");\r\n            }\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Display.setBidiAlgorithm",
	"Comment": "indicates whether codename one should consider the bidi rtl algorithmwhen drawing text or navigating with the text field cursor.",
	"Method": "void setBidiAlgorithm(boolean activate){\r\n    impl.setBidiAlgorithm(activate);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GroupLayout.createParallelGroup",
	"Comment": "creates and returns an parallelgroup.the alignmentspecifies how children elements should be positioned when thethe parallel group is given more space than necessary.for example,if a parallelgroup with an alignment of trailing is given 100 pixelsand a child only needs 50 pixels, the child will be positioned at theposition 50.",
	"Method": "ParallelGroup createParallelGroup(ParallelGroup createParallelGroup,int alignment,ParallelGroup createParallelGroup,int alignment,boolean resizable){\r\n    if (alignment == BASELINE) {\r\n        return new BaselineGroup(resizable);\r\n    }\r\n    return new ParallelGroup(alignment, resizable);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractList.iterator",
	"Comment": "returns an iterator on the elements of this list. the elements areiterated in the same order as they occur in the list.",
	"Method": "Iterator<E> iterator(Iterator<E> iterator){\r\n    return new SimpleListIterator();\r\n}"
}, {
	"Path": "com.codename1.ui.table.Table.translateSortedRowToModelRow",
	"Comment": "if the table is sorted returns the position of the row in the actualunderlying model",
	"Method": "int translateSortedRowToModelRow(int row){\r\n    if (model instanceof SortableTableModel) {\r\n        return ((SortableTableModel) model).getSortedPosition(row);\r\n    }\r\n    return row;\r\n}"
}, {
	"Path": "java.lang.Thread.yield",
	"Comment": "causes the currently executing thread object to temporarily pause and allow other threads to execute.",
	"Method": "void yield(){\r\n    try {\r\n        sleep(1);\r\n    } catch (InterruptedException i) {\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.Util.getURLProtocol",
	"Comment": "returns the protocol of an absolute url e.g. http, https etc.",
	"Method": "String getURLProtocol(String url){\r\n    int index = url.indexOf(\"://\");\r\n    if (index != -1) {\r\n        return url.substring(0, index);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.atomix.copycat.client.session.ClientSessionState.getCommandRequest",
	"Comment": "returns the last command request sequence number for the session.",
	"Method": "long getCommandRequest(){\r\n    return commandRequest;\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetPanel.setSorting",
	"Comment": "sets sorting properties and categories enabled or disabled.",
	"Method": "void setSorting(boolean value){\r\n    model.setSortingCategories(value);\r\n    model.setSortingProperties(value);\r\n    sortButton.setSelected(value);\r\n}"
}, {
	"Path": "com.codename1.ui.Font.getDescent",
	"Comment": "the descent is the amount by which the character descends below the baseline",
	"Method": "int getDescent(){\r\n    return Display.impl.getFontDescent(font);\r\n}"
}, {
	"Path": "com.codename1.components.StorageImageAsync.create",
	"Comment": "creates an encoded image that maps to a storage file thus allowing toseamlessly cache images as needed. this only works reasonably well for very smallfiles.",
	"Method": "StorageImageAsync create(String fileName,Image placeholder){\r\n    return new StorageImageAsync(fileName, placeholder);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.runtime.java.lang.Class_.getDeclaredAnnotations",
	"Comment": "returns all annotations that are directly present on this element.",
	"Method": "Annotation[] getDeclaredAnnotations(Class c){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.table.AbstractTableModel.getMultipleChoiceOptions",
	"Comment": "allows the table cell to feature multiple choice for a specific entry",
	"Method": "String[] getMultipleChoiceOptions(int row,int column){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.io.services.ImageDownloadService.setEntryInListModel",
	"Comment": "this method is invoked when an image finished downloading and should be set to an offset in the listmodel. this is useful for special cases with complex list model hierarchies or proxies.",
	"Method": "void setEntryInListModel(int offset,Image img){\r\n    Map h;\r\n    ListModel model;\r\n    if (targetModel != null) {\r\n        model = targetModel;\r\n    } else {\r\n        if (targetList instanceof List) {\r\n            model = ((List) targetList).getModel();\r\n        } else {\r\n            model = ((ContainerList) targetList).getModel();\r\n        }\r\n    }\r\n    h = (Map) model.getItemAt(targetOffset);\r\n    if (!fastScale && toScale != null) {\r\n        img = scaleImage(img, toScale, maintainAspectRatio);\r\n    }\r\n    h.put(targetKey, img);\r\n    if (model instanceof DefaultListModel) {\r\n        ((DefaultListModel) model).setItem(targetOffset, h);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.animations.CommonTransitions.createSlideFadeTitle",
	"Comment": "creates a slide transition for the body of the form that fades the title in while sliding",
	"Method": "CommonTransitions createSlideFadeTitle(boolean forward,int duration){\r\n    CommonTransitions c = new CommonTransitions(TYPE_SLIDE_AND_FADE);\r\n    c.forward = forward;\r\n    c.speed = duration;\r\n    return c;\r\n}"
}, {
	"Path": "com.codename1.impl.midp.GameCanvasImplementation.getCodeScanner",
	"Comment": "returns the native implementation of the code scanner or null",
	"Method": "CodeScanner getCodeScanner(){\r\n    try {\r\n        return new ScannerHider().getCodeScanner(canvas);\r\n    } catch (Throwable t) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.LC.setFillX",
	"Comment": "if the layout should always claim the whole bounds of the laid out container even if the preferred size is smaller.",
	"Method": "void setFillX(boolean b){\r\n    this.fillX = b;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.promptInstallOnHomescreen",
	"Comment": "prompts the user to install this app on their homescreen.this is only relevant in the javascript port.",
	"Method": "boolean promptInstallOnHomescreen(){\r\n    return impl.promptInstallOnHomescreen();\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.LC.setFillY",
	"Comment": "if the layout should always claim the whole bounds of the laid out container even if the preferred size is smaller.",
	"Method": "void setFillY(boolean b){\r\n    this.fillY = b;\r\n}"
}, {
	"Path": "android.support.v4.view.PagerAdapter.saveState",
	"Comment": "save any instance state associated with this adapter and its pages that should berestored if the current ui state needs to be reconstructed.",
	"Method": "Parcelable saveState(){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.List.setNumericKeyActions",
	"Comment": "indicate whether pressing the number keys should trigger an action",
	"Method": "void setNumericKeyActions(boolean numericKeyActions){\r\n    this.numericKeyActions = numericKeyActions;\r\n}"
}, {
	"Path": "org.conscrypt.OAEPParameters.readMgfHash",
	"Comment": "shared with pssparameters, since they share some of their encoded form",
	"Method": "String readMgfHash(long seqRef){\r\n    if (NativeCrypto.asn1_read_next_tag_is(seqRef, 1)) {\r\n        long mgfRef = 0;\r\n        long mgfSeqRef = 0;\r\n        try {\r\n            mgfRef = NativeCrypto.asn1_read_tagged(seqRef);\r\n            mgfSeqRef = NativeCrypto.asn1_read_sequence(mgfRef);\r\n            String mgfOid = NativeCrypto.asn1_read_oid(mgfSeqRef);\r\n            if (!mgfOid.equals(MGF1_OID)) {\r\n                throw new IOException(\"Error reading ASN.1 encoding\");\r\n            }\r\n            String mgfHash = getHashName(mgfSeqRef);\r\n            if (!NativeCrypto.asn1_read_is_empty(mgfSeqRef)) {\r\n                throw new IOException(\"Error reading ASN.1 encoding\");\r\n            }\r\n            return mgfHash;\r\n        } finally {\r\n            NativeCrypto.asn1_read_free(mgfSeqRef);\r\n            NativeCrypto.asn1_read_free(mgfRef);\r\n        }\r\n    }\r\n    return \"SHA-1\";\r\n}"
}, {
	"Path": "io.atomix.copycat.client.DefaultCopycatClientTest.testQuerySessionExpiration",
	"Comment": "tests calling the recovery strategy when a query fails due to unknownsessionexception.",
	"Method": "void testQuerySessionExpiration(){\r\n    Connection connection = mock(Connection.class);\r\n    when(connection.close()).thenReturn(CompletableFuture.completedFuture(null));\r\n    Client client = mock(Client.class);\r\n    when(client.connect(any())).thenReturn(CompletableFuture.completedFuture(connection));\r\n    Transport transport = mock(Transport.class);\r\n    when(transport.client()).thenReturn(client);\r\n    when(connection.sendAndReceive(isA(ConnectRequest.class))).thenReturn(CompletableFuture.completedFuture(ConnectResponse.builder().withStatus(Response.Status.OK).withLeader(LEADER).withMembers(MEMBERS).build()));\r\n    when(connection.sendAndReceive(isA(RegisterRequest.class))).thenReturn(CompletableFuture.completedFuture(RegisterResponse.builder().withStatus(Response.Status.OK).withSession(1).withTimeout(5000).withLeader(LEADER).withMembers(MEMBERS).build()));\r\n    Mockito.when(connection.sendAndReceive(isA(KeepAliveRequest.class))).thenReturn(CompletableFuture.completedFuture(KeepAliveResponse.builder().withStatus(Response.Status.OK).withLeader(LEADER).withMembers(MEMBERS).build()));\r\n    Mockito.when(connection.sendAndReceive(isA(QueryRequest.class))).thenReturn(CompletableFuture.completedFuture(QueryResponse.builder().withStatus(Response.Status.ERROR).withError(CopycatError.Type.UNKNOWN_SESSION_ERROR).build()));\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    CopycatClient copycatClient = CopycatClient.builder().withTransport(transport).withRecoveryStrategy(c -> {\r\n        latch.countDown();\r\n    }).build();\r\n    copycatClient.connect(MEMBERS).join();\r\n    copycatClient.submit(new TestQuery());\r\n    latch.await();\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isEdt",
	"Comment": "returns true if we are currently in the event dispatch thread.this is useful for generic code that can be used both with theedt and outside of it.",
	"Method": "boolean isEdt(){\r\n    return edt == Thread.currentThread();\r\n}"
}, {
	"Path": "com.codename1.ui.Label.isTickerEnabled",
	"Comment": "this method return true if the ticker is enabled on this label",
	"Method": "boolean isTickerEnabled(){\r\n    return tickerEnabled;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.BorderLayout.west",
	"Comment": "convenience method that creates a border layout container and places the given component in the west",
	"Method": "Container west(Component west){\r\n    return Container.encloseIn(new BorderLayout(), west, BorderLayout.WEST);\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.builders.ThumbnailParameterBuilder.useExifOrientation",
	"Comment": "sets whether or not the exif metadata should be used to determine the\torientation of the thumbnail.",
	"Method": "ThumbnailParameterBuilder useExifOrientation(boolean use){\r\n    this.useExifOrientation = use;\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.getFileLastModifiedFile",
	"Comment": "returns the time that the file denoted by this abstract pathname was last modified.",
	"Method": "long getFileLastModifiedFile(String file){\r\n    return FileSystemStorage.getInstance().getLastModified(file);\r\n}"
}, {
	"Path": "com.codename1.impl.android.InPlaceEditView.isTextEditorHidden",
	"Comment": "checks if the native text editor is currently hidden.only relevant in async edit mode.",
	"Method": "boolean isTextEditorHidden(){\r\n    return textEditorHidden;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.isSimulator",
	"Comment": "allows detecting development mode so debugging code and special cases can be used to simplify flow",
	"Method": "boolean isSimulator(){\r\n    return Display.impl.isSimulator();\r\n}"
}, {
	"Path": "com.codename1.ui.Display.setThirdSoftButton",
	"Comment": "indicates whether the 3rd softbutton should be supported on this device",
	"Method": "void setThirdSoftButton(boolean thirdSoftButton){\r\n    this.thirdSoftButton = thirdSoftButton;\r\n}"
}, {
	"Path": "org.conscrypt.SSLParametersImpl.setUseClientMode",
	"Comment": "tunes the peer holding this parameters to work in client mode.",
	"Method": "void setUseClientMode(boolean mode){\r\n    client_mode = mode;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.cacheUnmodified",
	"Comment": "this callback is invoked on a 304 server response indicating the data in the server matches the resultwe currently have in the cache. this method can be overriden to detect this case",
	"Method": "void cacheUnmodified(){\r\n    if (destinationFile != null || destinationStorage != null) {\r\n        if (hasResponseListeners() && !isKilled()) {\r\n            if (destinationFile != null) {\r\n                data = Util.readInputStream(FileSystemStorage.getInstance().openInputStream(destinationFile));\r\n            } else {\r\n                data = Util.readInputStream(Storage.getInstance().createInputStream(destinationStorage));\r\n            }\r\n            fireResponseListener(new NetworkEvent(this, data));\r\n        }\r\n        return;\r\n    }\r\n    InputStream is = FileSystemStorage.getInstance().openInputStream(getCacheFileName());\r\n    readResponse(is);\r\n    Util.cleanup(is);\r\n}"
}, {
	"Path": "com.codename1.ui.table.TableLayout.isCellSpannedThroughHorizontally",
	"Comment": "returns true if the cell at the given position is spanned through horizontally",
	"Method": "boolean isCellSpannedThroughHorizontally(int row,int column){\r\n    return tablePositions[row * columns + column] == H_SPAN_CONSTRAINT || tablePositions[row * columns + column] == VH_SPAN_CONSTRAINT;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.sizeChangedInternal",
	"Comment": "this method is only invoked when the underlying canvas for the form getsa size changed event.this method will trigger a relayout of the form.this method will get the callback only if this form is the current form",
	"Method": "void sizeChangedInternal(int w,int h){\r\n    int oldWidth = getWidth();\r\n    int oldHeight = getHeight();\r\n    sizeChanged(w, h);\r\n    Style formStyle = getStyle();\r\n    w = w - (formStyle.getHorizontalMargins());\r\n    h = h - (formStyle.getVerticalMargins());\r\n    setSize(new Dimension(w, h));\r\n    setShouldCalcPreferredSize(true);\r\n    doLayout();\r\n    focused = getFocused();\r\n    if (focused != null) {\r\n        Component.setDisableSmoothScrolling(true);\r\n        scrollComponentToVisible(focused);\r\n        Component.setDisableSmoothScrolling(false);\r\n    }\r\n    if (oldWidth != w && oldHeight != h) {\r\n        if (orientationListener != null) {\r\n            orientationListener.fireActionEvent(new ActionEvent(this, ActionEvent.Type.OrientationChange));\r\n        }\r\n        boolean a = getContentPane().onOrientationChange();\r\n        if (getToolbar() != null) {\r\n            if (getToolbar().onOrientationChange() || a) {\r\n                forceRevalidate();\r\n            }\r\n        } else {\r\n            if (a) {\r\n                forceRevalidate();\r\n            }\r\n        }\r\n    }\r\n    if (sizeChangedListener != null) {\r\n        sizeChangedListener.fireActionEvent(new ActionEvent(this, ActionEvent.Type.SizeChange, w, h));\r\n    }\r\n    repaint();\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.GenericSpinner.setComponentState",
	"Comment": "if getcomponentstate returned a value the setter can update the value and restorethe prior state.",
	"Method": "void setComponentState(Object state){\r\n    if (getColumns() == 1) {\r\n        setValue(state);\r\n        return;\r\n    }\r\n    Object[] o = (Object[]) state;\r\n    int olen = o.length;\r\n    for (int iter = 0; iter < olen; iter++) {\r\n        setValue(iter, o[iter]);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.translator.NameTranslator.getClassMirrorTranslation",
	"Comment": "translates the name only if it represents a fully mirrored class.",
	"Method": "String getClassMirrorTranslation(String name){\r\n    final Mirror mirror = getMirror(name);\r\n    return mirror.isClassMirror() ? mirror.getTranslatedName() : name;\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.isUseSoftkeys",
	"Comment": "when set to true softkeys are used to enable delete functionality",
	"Method": "boolean isUseSoftkeys(){\r\n    return useSoftkeys;\r\n}"
}, {
	"Path": "com.codename1.ui.util.Resources.setGlobalResources",
	"Comment": "global resources are used by new gui builder apps to keep track of the applications resources",
	"Method": "void setGlobalResources(Resources res){\r\n    globalResources = res;\r\n}"
}, {
	"Path": "org.conscrypt.ConscryptEngine.maxSealOverhead",
	"Comment": "returns the maximum overhead, in bytes, of sealing a record with ssl.",
	"Method": "int maxSealOverhead(){\r\n    return maxSealOverhead;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getUIManager",
	"Comment": "this method should be used by the component to retrieve the correct uimanager to work with",
	"Method": "UIManager getUIManager(){\r\n    Container parent = getParent();\r\n    if (parent == null) {\r\n        return UIManager.getInstance();\r\n    }\r\n    return parent.getUIManager();\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSElement.copyAttributesTo",
	"Comment": "copies all properties, both string and numeric values to the destination elementthis is used for grouped selectors",
	"Method": "void copyAttributesTo(CSSElement dest){\r\n    for (int i = 0; i < attrVals.length; i++) {\r\n        dest.attrVals[i] = attrVals[i];\r\n    }\r\n    Hashtable attributes = getAttributes();\r\n    if (attributes != null) {\r\n        for (Enumeration e = attributes.keys(); e.hasMoreElements(); ) {\r\n            Integer key = (Integer) e.nextElement();\r\n            String value = (String) attributes.get(key);\r\n            dest.setAttribute(key, value);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.PriorityQueue.toArray",
	"Comment": "returns all the elements in an array. the result is a copy of all theelements.",
	"Method": "Object[] toArray(T[] toArray,T[] array){\r\n    return newArray(array);\r\n}"
}, {
	"Path": "com.codename1.ui.table.Table.setCellAlignment",
	"Comment": "indicates the alignment of the cells see label alignment for details",
	"Method": "void setCellAlignment(int cellAlignment){\r\n    this.cellAlignment = cellAlignment;\r\n    repaint();\r\n}"
}, {
	"Path": "com.codename1.l10n.SimpleDateFormat.getLocalDSTOffset",
	"Comment": "determine the number of minutes to adjust the date for local dst. thisshould provide a historically correct value, also accounting for changesin gmt offset. see timezone javadoc for more details.",
	"Method": "int getLocalDSTOffset(Calendar source){\r\n    TimeZone localTimezone = Calendar.getInstance().getTimeZone();\r\n    int rawOffset = localTimezone.getRawOffset() / MILLIS_TO_MINUTES;\r\n    return getOffsetInMinutes(source, localTimezone) - rawOffset;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.id",
	"Comment": "the id used to reference this component in some constraints.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC id(String s){\r\n    setId(s);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.retainAll",
	"Comment": "retains only elements of the result set that are contained in the provided collection.",
	"Method": "boolean retainAll(Collection<?> c,ComponentSelector retainAll,Collection<?> c,boolean chain){\r\n    retainAll(c);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.CommonTransitions.createCover",
	"Comment": "creates a cover transition with the given duration and direction",
	"Method": "CommonTransitions createCover(int type,boolean forward,int duration){\r\n    CommonTransitions t = new CommonTransitions(TYPE_COVER);\r\n    t.slideType = type;\r\n    t.forward = forward;\r\n    t.speed = duration;\r\n    t.position = 0;\r\n    return t;\r\n}"
}, {
	"Path": "io.atomix.copycat.test.FuzzTest.scheduleRestarts",
	"Comment": "schedules a random number of servers to be shutdown for a period of time and then restarted.",
	"Method": "void scheduleRestarts(ThreadContext context){\r\n    if (shutdownTimers.isEmpty() && restartTimers.isEmpty()) {\r\n        int shutdownCount = randomNumber(servers.size() - 2) + 1;\r\n        boolean remove = randomBoolean();\r\n        for (int i = 0; i < shutdownCount; i++) {\r\n            scheduleRestart(remove, i, context);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.net.URI.parseIntOption",
	"Comment": "internal utility method to throw a syntax error if a value can not be\tparsed.",
	"Method": "int parseIntOption(String key,String value){\r\n    try {\r\n        return Integer.parseInt(value);\r\n    } catch (NumberFormatException nfe) {\r\n        throw new URISyntaxException(value, \"Invalid \" + key + \" value: \" + value);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setHandlesInput",
	"Comment": "prevents key events from being grabbed for focus traversal. e.g. a list componentmight use the arrow keys for internal navigation so it will switch this flag totrue in order to prevent the focus manager from moving to the next component.",
	"Method": "void setHandlesInput(boolean handlesInput){\r\n    this.handlesInput = handlesInput;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getBindablePropertyTypes",
	"Comment": "returns the types of the properties that are bindable within this component",
	"Method": "Class[] getBindablePropertyTypes(){\r\n    return null;\r\n}"
}, {
	"Path": "org.conscrypt.Conscrypt.setUseEngineSocketByDefault",
	"Comment": "configures the default socket to be created for all socket factory instances.",
	"Method": "void setUseEngineSocketByDefault(boolean useEngineSocket){\r\n    OpenSSLSocketFactoryImpl.setUseEngineSocketByDefault(useEngineSocket);\r\n    OpenSSLServerSocketFactoryImpl.setUseEngineSocketByDefault(useEngineSocket);\r\n}"
}, {
	"Path": "com.codename1.ui.Toolbar.setScrollOffUponContentPane",
	"Comment": "sets the toolbar to scroll off the screen upon content scroll. thisfeature can only work if the form contentpane is scrollabley",
	"Method": "void setScrollOffUponContentPane(boolean scrollOff){\r\n    if (initialized && !this.scrollOff && scrollOff) {\r\n        bindScrollListener(true);\r\n    }\r\n    this.scrollOff = scrollOff;\r\n}"
}, {
	"Path": "io.atomix.copycat.client.util.ClientConnection.resendRequest",
	"Comment": "resends a request due to a request failure, resetting the connection if necessary.",
	"Method": "void resendRequest(Throwable cause,T request,BiFunction sender,Connection connection,CompletableFuture future){\r\n    if (this.connection == connection) {\r\n        LOGGER.trace(\"{} - Resetting connection. Reason: {}\", id, cause);\r\n        this.connection = null;\r\n        connection.close();\r\n    }\r\n    connect().whenComplete((c, e) -> sendRequest(request, sender, c, e, future));\r\n}"
}, {
	"Path": "com.codename1.ui.AutoCompleteTextField.updateFilterList",
	"Comment": "in a case of an asynchronous filter this method can be invoked to refresh the completion list",
	"Method": "void updateFilterList(){\r\n    Form f = getComponentForm();\r\n    boolean v = filter.getSize() > 0 && getText().length() >= minimumLength;\r\n    if (v != popup.isVisible()) {\r\n        if (popup.getComponentCount() > 0) {\r\n            popup.getComponentAt(0).setScrollY(0);\r\n        }\r\n        popup.setVisible(v);\r\n        popup.setEnabled(v);\r\n        f.repaint();\r\n    }\r\n    if (f != null) {\r\n        dontCalcSize = false;\r\n        f.revalidate();\r\n        dontCalcSize = true;\r\n    }\r\n}"
}, {
	"Path": "java.util.PriorityQueue.size",
	"Comment": "gets the size of the priority queue. if the size of the queue is greaterthan the integer.max, then it returns integer.max.",
	"Method": "int size(){\r\n    return size;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setDropTarget",
	"Comment": "indicates whether this component can receive dropped components into it, notice that when dropping on a componentor container the parents will be checked recursively to find a valid drop target",
	"Method": "void setDropTarget(boolean dropTarget){\r\n    this.dropTarget = dropTarget;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.ThumbnailParameter.useExifOrientation",
	"Comment": "returns whether or not the exif metadata should be used to determine\tthe orientation of the thumbnail.",
	"Method": "boolean useExifOrientation(){\r\n    return useExifOrientation;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.setShowOnInit",
	"Comment": "this dialog will be shown when this request enters the network queue",
	"Method": "void setShowOnInit(Dialog showOnInit){\r\n    this.showOnInit = showOnInit;\r\n}"
}, {
	"Path": "com.codename1.io.BufferedOutputStream.getConnection",
	"Comment": "if applicable this member represents the connection object for the stream",
	"Method": "Object getConnection(){\r\n    return connection;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.LC.isVisualPadding",
	"Comment": "if visual padding should be automatically used and compensated for by this layout instance.",
	"Method": "boolean isVisualPadding(){\r\n    return visualPadding;\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.stablePartialSort",
	"Comment": "stable partial sort of a list. returns the desired head of the list.",
	"Method": "List<T> stablePartialSort(List<T> list,Comparator<T> comp,int limit,List<T> stablePartialSort,List<T> list,Comparator<T> comp,int limit,int algorithm){\r\n    assert limit <= list.size();\r\n    assert list.size() > 0;\r\n    for (; ; ) {\r\n        switch(algorithm) {\r\n            case 0:\r\n                float ratio = (float) limit / (float) list.size();\r\n                if (ratio <= .05) {\r\n                    algorithm = 4;\r\n                } else if (ratio <= .35) {\r\n                    algorithm = 2;\r\n                } else {\r\n                    algorithm = 1;\r\n                }\r\n                break;\r\n            case 1:\r\n                return stablePartialSortArray(list, comp, limit);\r\n            case 2:\r\n                return stablePartialSortMarc(list, comp, limit);\r\n            case 3:\r\n                return stablePartialSortPedro(list, comp, limit);\r\n            case 4:\r\n                return stablePartialSortJulian(list, comp, limit);\r\n            default:\r\n                throw new RuntimeException();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.text.DateFormat.getDateTimeInstance",
	"Comment": "get a dateformat instance that uses a given style for dates and times.",
	"Method": "DateFormat getDateTimeInstance(int dateStyle,int timeStyle){\r\n    return new DateFormat(dateStyle, timeStyle);\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.tasks.io.URLImageSource.getProxy",
	"Comment": "returns the proxy to use when connecting to the url to retrieve the\tsource image.",
	"Method": "Proxy getProxy(){\r\n    return proxy;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.sendPushRegistrationError",
	"Comment": "allows implementations to send an error to the push callback",
	"Method": "void sendPushRegistrationError(String message,int errorCode){\r\n    if (callback != null) {\r\n        callback.pushRegistrationError(message, errorCode);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.InfiniteProgress.setDefaultMaterialDesignMode",
	"Comment": "indicates whether infinite progress and pull to refresh work in the materialdesign mode by default",
	"Method": "void setDefaultMaterialDesignMode(boolean aDefaultMaterialDesignMode){\r\n    defaultMaterialDesignMode = aDefaultMaterialDesignMode;\r\n}"
}, {
	"Path": "com.codename1.ui.Graphics.darkerColor",
	"Comment": "makes the current color slightly darker, this is useful for many visual effects",
	"Method": "void darkerColor(int factor){\r\n    int color = getColor();\r\n    int r = color >> 16 & 0xff;\r\n    int g = color >> 8 & 0xff;\r\n    int b = color & 0xff;\r\n    r = Math.max(0, r - factor);\r\n    g = Math.max(0, g - factor);\r\n    b = Math.max(0, b - factor);\r\n    setColor(((r << 16) & 0xff0000) | ((g << 8) & 0xff00) | (b & 0xff));\r\n}"
}, {
	"Path": "ly.count.android.sdk.UserData.setCustomUserData",
	"Comment": "sets custom properties.in custom properties you can provide any string key values to be stored with user",
	"Method": "void setCustomUserData(Map<String, String> customdata){\r\n    if (customdata != null)\r\n        UserData.setCustomData(customdata);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.LC.maxHeight",
	"Comment": "the maximum height for the container. the value will override any value that is set on the container itself.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcontainers.com.",
	"Method": "LC maxHeight(String height){\r\n    setHeight(LayoutUtil.derive(getHeight(), null, null, ConstraintParser.parseUnitValue(height, false)));\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayeredLayout.createConstraint",
	"Comment": "creates a default layered layout constraint.default constrainthas zero insets on all four sides.",
	"Method": "LayeredLayoutConstraint createConstraint(String constraint,LayeredLayoutConstraint createConstraint){\r\n    return new LayeredLayoutConstraint();\r\n}"
}, {
	"Path": "structures.LinkCutTreeConnectivity.expose",
	"Comment": "makes node x the root of the virtual tree, and also x becomes the leftmost node in its splay tree",
	"Method": "Node expose(Node x){\r\n    Node last = null;\r\n    for (Node y = x; y != null; y = y.parent) {\r\n        splay(y);\r\n        y.left = last;\r\n        last = y;\r\n    }\r\n    splay(x);\r\n    return last;\r\n}"
}, {
	"Path": "com.codename1.properties.SetProperty.asExplodedList",
	"Comment": "returns a copy of the content as a new list but if the value is a propertybusinessobject it will be converted to a map",
	"Method": "List<Object> asExplodedList(){\r\n    ArrayList<Object> aa = new ArrayList<Object>();\r\n    for (T t : value) {\r\n        if (t instanceof PropertyBusinessObject) {\r\n            aa.add(((PropertyBusinessObject) t).getPropertyIndex().toMapRepresentation());\r\n        } else {\r\n            aa.add(t);\r\n        }\r\n    }\r\n    return aa;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getOuterHeight",
	"Comment": "gets the outer height of this component.this is the height of the component including vertical margins.",
	"Method": "int getOuterHeight(){\r\n    return getHeight() + getStyle().getVerticalMargins();\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.FollowerStateTest.testFollowerUpdatesLeaderAndTermOnAppend",
	"Comment": "tests that a follower updates a leader on append request with new term.",
	"Method": "void testFollowerUpdatesLeaderAndTermOnAppend(){\r\n    runOnServer(() -> {\r\n        serverContext.setTerm(2).setLeader(0);\r\n        VoteRequest request1 = VoteRequest.builder().withTerm(2).withCandidate(members.get(1).hashCode()).withLogIndex(0).withLogTerm(0).build();\r\n        VoteResponse response1 = state.vote(request1).get();\r\n        threadAssertEquals(serverContext.getTerm(), 2L);\r\n        threadAssertEquals(serverContext.getLastVotedFor(), members.get(1).hashCode());\r\n        threadAssertEquals(response1.term(), 2L);\r\n        threadAssertTrue(response1.voted());\r\n        AppendRequest request2 = AppendRequest.builder().withTerm(3).withLeader(members.get(2).hashCode()).withEntries(Collections.EMPTY_LIST).withLogIndex(0).withLogTerm(0).withCommitIndex(0).withGlobalIndex(0).build();\r\n        AppendResponse response2 = state.append(request2).get();\r\n        threadAssertEquals(serverContext.getTerm(), 3L);\r\n        threadAssertEquals(serverContext.getLeader().serverAddress(), members.get(2).serverAddress());\r\n        threadAssertEquals(serverContext.getLastVotedFor(), 0);\r\n        threadAssertEquals(response2.term(), 3L);\r\n        threadAssertTrue(response2.succeeded());\r\n    });\r\n}"
}, {
	"Path": "java.lang.StringBuilder.insert",
	"Comment": "inserts the string representation of the object argument into this string builder.the second argument is converted to a string as if by the method string.valueof, and the characters of that string are then inserted into this string builder at the indicated offset.the offset argument must be greater than or equal to 0, and less than or equal to the length of this string builder.",
	"Method": "java.lang.StringBuilder insert(int offset,boolean b,java.lang.StringBuilder insert,int offset,char c,java.lang.StringBuilder insert,int offset,char[] str,java.lang.StringBuilder insert,int offset,double d,java.lang.StringBuilder insert,int offset,float f,java.lang.StringBuilder insert,int offset,int i,java.lang.StringBuilder insert,int offset,long l,java.lang.StringBuilder insert,int offset,java.lang.Object obj,java.lang.StringBuilder insert,int offset,java.lang.String str,StringBuilder insert,int offset,java.lang.CharSequence cs,StringBuilder insert,int offset,CharSequence cs,int start,int end){\r\n    return insert(offset, cs.toString(), start, end);\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.getSilentRetryCount",
	"Comment": "indicates the number of times to silently retry a connection that failedbefore prompting",
	"Method": "int getSilentRetryCount(){\r\n    return silentRetryCount;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.translator.NameTranslator.getMirror",
	"Comment": "returns either a class or methods mirror\treturns nomirror if there is no match",
	"Method": "Mirror getMirror(String class_){\r\n    if (class_ == null) {\r\n        return noMirror;\r\n    }\r\n    final Mirror cachedMirror = mirrors.get(class_);\r\n    if (cachedMirror != null) {\r\n        return cachedMirror;\r\n    }\r\n    for (NameSpace n : namespaces) {\r\n        String mirrorClass = n.getMirrorClassName(class_);\r\n        if (mirrorClass == null) {\r\n            continue;\r\n        }\r\n        mirrorClass = mirrorClass.replace('/', '.');\r\n        try {\r\n            final Class clazz = Class.forName(mirrorClass);\r\n            final Mirror mirror = new ClassMirror(clazz);\r\n            mirrors.put(class_, mirror);\r\n            return mirror;\r\n        } catch (ClassNotFoundException e) {\r\n        }\r\n        mirrorClass += '_';\r\n        try {\r\n            final Class clazz = Class.forName(mirrorClass);\r\n            final Mirror mirror = new MethodsMirror(clazz);\r\n            mirrors.put(class_, mirror);\r\n            return mirror;\r\n        } catch (ClassNotFoundException e) {\r\n        }\r\n    }\r\n    mirrors.put(class_, noMirror);\r\n    return noMirror;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.setResourceBundle",
	"Comment": "the resource bundle allows us to implicitly localize the ui on the fly, once itsinstalled all internal application strings query the resource bundle and extracttheir values from this table if applicable.",
	"Method": "void setResourceBundle(Hashtable resourceBundle){\r\n    if (localeAccessible) {\r\n        this.resourceBundle = resourceBundle;\r\n        if (resourceBundle != null) {\r\n            String v = (String) resourceBundle.get(\"@rtl\");\r\n            if (v != null) {\r\n                getLookAndFeel().setRTL(v.equalsIgnoreCase(\"true\"));\r\n                current.refreshTheme(false);\r\n            }\r\n            bundle = new HashMap<String, String>((Hashtable<String, String>) resourceBundle);\r\n        } else {\r\n            bundle = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.setHttpPostForced",
	"Comment": "set the override for forcing to use http post for all connections to the server",
	"Method": "Countly setHttpPostForced(boolean isItForced){\r\n    if (Countly.sharedInstance().isLoggingEnabled()) {\r\n        Log.d(Countly.TAG, \"Setting if HTTP POST is forced: [\" + isItForced + \"]\");\r\n    }\r\n    isHttpPostForced = isItForced;\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.BorderLayout.centerEastWest",
	"Comment": "convenience method that creates a border layout container and places the given component in the centereast and west respectively",
	"Method": "Container centerEastWest(Component center,Component east,Component west){\r\n    Container c;\r\n    if (center != null) {\r\n        c = center(center);\r\n    } else {\r\n        c = new Container(new BorderLayout());\r\n    }\r\n    if (east != null) {\r\n        c.add(BorderLayout.EAST, east);\r\n    }\r\n    if (west != null) {\r\n        c.add(BorderLayout.WEST, west);\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.getComponentByPath",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "Component getComponentByPath(int[] path){\r\n    return TestUtils.getComponentByPath(path);\r\n}"
}, {
	"Path": "com.codename1.util.StringUtil.replaceAll",
	"Comment": "this method replaces all occurrences of the pattern with the replacement string",
	"Method": "String replaceAll(String source,String pattern,String replace){\r\n    StringBuilder sb = new StringBuilder();\r\n    int idx = 0;\r\n    String workingSource = source;\r\n    idx = workingSource.indexOf(pattern);\r\n    if (idx == -1) {\r\n        return source;\r\n    }\r\n    while (idx != -1) {\r\n        sb.append(workingSource.substring(0, idx));\r\n        sb.append(replace);\r\n        workingSource = workingSource.substring(idx + pattern.length());\r\n        idx = workingSource.indexOf(pattern);\r\n    }\r\n    sb.append(workingSource);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.codename1.charts.util.MathHelper.minmax",
	"Comment": "calculate the minimum and maximum values out of a list of doubles.",
	"Method": "double[] minmax(List<Double> values){\r\n    if (values.size() == 0) {\r\n        return new double[2];\r\n    }\r\n    double min = values.get(0);\r\n    double max = min;\r\n    int length = values.size();\r\n    for (int i = 1; i < length; i++) {\r\n        double value = values.get(i);\r\n        min = min == NULL_VALUE ? value : Math.min(min, value);\r\n        max = max == NULL_VALUE ? value : Math.max(max, value);\r\n    }\r\n    return new double[] { min, max };\r\n}"
}, {
	"Path": "com.codename1.designer.ResourceEditorView.isInUse",
	"Comment": "returns true if the given image is used by a theme or timeline animation,false otherwise.",
	"Method": "boolean isInUse(String imageName,boolean isInUse,com.codename1.ui.Image resourceValue){\r\n    for (String themeName : loadedResources.getThemeResourceNames()) {\r\n        Hashtable theme = loadedResources.getTheme(themeName);\r\n        if (theme.values().contains(resourceValue)) {\r\n            return true;\r\n        }\r\n        for (Object v : theme.values()) {\r\n            if (v instanceof Border) {\r\n                Border b = (Border) v;\r\n                if (Accessor.getType(b) == Accessor.TYPE_IMAGE || Accessor.getType(b) == Accessor.TYPE_IMAGE_HORIZONTAL || Accessor.getType(b) == Accessor.TYPE_IMAGE_VERTICAL || Accessor.getType(b) == Accessor.TYPE_IMAGE_SCALED) {\r\n                    com.codename1.ui.Image[] images = Accessor.getImages(b);\r\n                    for (int i = 0; i < images.length; i++) {\r\n                        if (images[i] == resourceValue) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (String image : loadedResources.getImageResourceNames()) {\r\n        com.codename1.ui.Image current = loadedResources.getImage(image);\r\n        if (current instanceof com.codename1.ui.animations.Timeline) {\r\n            com.codename1.ui.animations.Timeline time = (com.codename1.ui.animations.Timeline) current;\r\n            for (int iter = 0; iter < time.getAnimationCount(); iter++) {\r\n                com.codename1.ui.animations.AnimationObject o = time.getAnimation(iter);\r\n                if (AnimationAccessor.getImage(o) == resourceValue) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    UIBuilderOverride builder = new UIBuilderOverride();\r\n    for (String uiResource : loadedResources.getUIResourceNames()) {\r\n        com.codename1.ui.Container c = builder.createContainer(loadedResources, uiResource);\r\n        if (findImageInContainer(c, resourceValue)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.CommonTransitions.setDefaultLinearMotion",
	"Comment": "indicates whether the motion associated with these transitions by default is linear or spline motion",
	"Method": "void setDefaultLinearMotion(boolean aDefaultLinearMotion){\r\n    defaultLinearMotion = aDefaultLinearMotion;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.getCurrent",
	"Comment": "return the form currently displayed on the screen or null if no form iscurrently displayed.",
	"Method": "Form getCurrent(){\r\n    Form current = impl.getCurrentForm();\r\n    if (current != null && current instanceof Dialog) {\r\n        if (((Dialog) current).isMenu() || ((Dialog) current).isDisposed()) {\r\n            Form p = current.getPreviousForm();\r\n            if (p != null) {\r\n                return p;\r\n            }\r\n            if (animationQueue != null) {\r\n                int size = animationQueue.size();\r\n                for (int iter = 0; iter < size; iter++) {\r\n                    Animation o = animationQueue.get(iter);\r\n                    if (o instanceof Transition) {\r\n                        return (Form) ((Transition) o).getDestination();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return current;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Observable.addObserver",
	"Comment": "adds the specified observer to the list of observers. if it is alreadyregistered, it is not added a second time.",
	"Method": "void addObserver(Observer observer){\r\n    if (observer == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    synchronized (this) {\r\n        if (!observers.contains(observer))\r\n            observers.add(observer);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Display.getDragStartPercentage",
	"Comment": "this method allows us to manipulate the drag started detection logic.if the pointer was dragged for more than this percentage of the display size itis safe to assume that a drag is in progress.",
	"Method": "int getDragStartPercentage(){\r\n    return getImplementation().getDragStartPercentage();\r\n}"
}, {
	"Path": "com.codename1.contacts.ContactsManager.isGetAllContactsFast",
	"Comment": "indicates if the getallcontacts is platform optimized, notice that the methodmight still take seconds or more to run so you should still use a separate thread!",
	"Method": "boolean isGetAllContactsFast(){\r\n    return Display.getInstance().isGetAllContactsFast();\r\n}"
}, {
	"Path": "io.prometheus.client.Striped64.getUnsafe",
	"Comment": "returns a sun.misc.unsafe.suitable for use in a 3rd party package.replace with a simple call to unsafe.getunsafe when integratinginto a jdk.",
	"Method": "sun.misc.Unsafe getUnsafe(){\r\n    try {\r\n        return sun.misc.Unsafe.getUnsafe();\r\n    } catch (SecurityException tryReflectionInstead) {\r\n    }\r\n    try {\r\n        return java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction<sun.misc.Unsafe>() {\r\n            public sun.misc.Unsafe run() throws Exception {\r\n                Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\r\n                for (java.lang.reflect.Field f : k.getDeclaredFields()) {\r\n                    f.setAccessible(true);\r\n                    Object x = f.get(null);\r\n                    if (k.isInstance(x))\r\n                        return k.cast(x);\r\n                }\r\n                throw new NoSuchFieldError(\"the Unsafe\");\r\n            }\r\n        });\r\n    } catch (java.security.PrivilegedActionException e) {\r\n        throw new RuntimeException(\"Could not initialize intrinsics\", e.getCause());\r\n    }\r\n}"
}, {
	"Path": "io.prometheus.client.Striped64.getUnsafe",
	"Comment": "returns a sun.misc.unsafe.suitable for use in a 3rd party package.replace with a simple call to unsafe.getunsafe when integratinginto a jdk.",
	"Method": "sun.misc.Unsafe getUnsafe(){\r\n    Class<sun.misc.Unsafe> k = sun.misc.Unsafe.class;\r\n    for (java.lang.reflect.Field f : k.getDeclaredFields()) {\r\n        f.setAccessible(true);\r\n        Object x = f.get(null);\r\n        if (k.isInstance(x))\r\n            return k.cast(x);\r\n    }\r\n    throw new NoSuchFieldError(\"the Unsafe\");\r\n}"
}, {
	"Path": "com.codename1.io.NetworkManager.addToQueueAndWait",
	"Comment": "identical to add to queue but waits until the request is processed in the queue,this is useful for completely synchronous operations.",
	"Method": "void addToQueueAndWait(ConnectionRequest request){\r\n    class WaitingClass implements Runnable, ActionListener<NetworkEvent> {\r\n        private boolean finishedWaiting;\r\n        public void run() {\r\n            while (!finishedWaiting) {\r\n                try {\r\n                    Thread.sleep(30);\r\n                } catch (InterruptedException ex) {\r\n                    ex.printStackTrace();\r\n                }\r\n            }\r\n        }\r\n        public void actionPerformed(NetworkEvent e) {\r\n            if (e.getError() != null) {\r\n                finishedWaiting = true;\r\n                removeProgressListener(this);\r\n                removeErrorListener(this);\r\n                return;\r\n            }\r\n            if (e.getConnectionRequest() == request) {\r\n                if (e.getProgressType() == NetworkEvent.PROGRESS_TYPE_COMPLETED) {\r\n                    if (request.retrying) {\r\n                        request.retrying = false;\r\n                        return;\r\n                    }\r\n                    finishedWaiting = true;\r\n                    removeProgressListener(this);\r\n                    removeErrorListener(this);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    WaitingClass w = new WaitingClass();\r\n    addProgressListener(w);\r\n    addErrorListener(w);\r\n    addToQueue(request);\r\n    if (Display.getInstance().isEdt()) {\r\n        Display.getInstance().invokeAndBlock(w);\r\n    } else {\r\n        w.run();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.NetworkManager.addToQueueAndWait",
	"Comment": "identical to add to queue but waits until the request is processed in the queue,this is useful for completely synchronous operations.",
	"Method": "void addToQueueAndWait(ConnectionRequest request){\r\n    while (!finishedWaiting) {\r\n        try {\r\n            Thread.sleep(30);\r\n        } catch (InterruptedException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.NetworkManager.addToQueueAndWait",
	"Comment": "identical to add to queue but waits until the request is processed in the queue,this is useful for completely synchronous operations.",
	"Method": "void addToQueueAndWait(ConnectionRequest request){\r\n    if (e.getError() != null) {\r\n        finishedWaiting = true;\r\n        removeProgressListener(this);\r\n        removeErrorListener(this);\r\n        return;\r\n    }\r\n    if (e.getConnectionRequest() == request) {\r\n        if (e.getProgressType() == NetworkEvent.PROGRESS_TYPE_COMPLETED) {\r\n            if (request.retrying) {\r\n                request.retrying = false;\r\n                return;\r\n            }\r\n            finishedWaiting = true;\r\n            removeProgressListener(this);\r\n            removeErrorListener(this);\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.validation.Validator.getErrorMessage",
	"Comment": "returns the validation error message for the given component or null if no such message exists",
	"Method": "String getErrorMessage(Component cmp){\r\n    return constraintList.get(cmp).getDefaultFailMessage();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.HashMap.putAll",
	"Comment": "copies all the mappings in the specified map to this map. these mappingswill replace all mappings that this map had for any of the keys currentlyin the given map.",
	"Method": "void putAll(Map<? extends K, ? extends V> map){\r\n    if (!map.isEmpty()) {\r\n        putAllImpl(map);\r\n    }\r\n}"
}, {
	"Path": "ly.count.android.sdk.CountlyStore.events",
	"Comment": "returns an unsorted array of the current stored event json strings.",
	"Method": "String[] events(){\r\n    final String joinedEventsStr = preferences_.getString(EVENTS_PREFERENCE, \"\");\r\n    return joinedEventsStr.length() == 0 ? new String[0] : joinedEventsStr.split(DELIMITER);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.ensureCapacity",
	"Comment": "ensures that this vector can hold the specified number of elementswithout growing.",
	"Method": "void ensureCapacity(int minimumCapacity){\r\n    if (elementData.length < minimumCapacity) {\r\n        int next = (capacityIncrement <= 0 ? elementData.length : capacityIncrement) + elementData.length;\r\n        grow(minimumCapacity > next ? minimumCapacity : next);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.charts.transitions.XYValueSeriesTransition.initTransition",
	"Comment": "initializes the transition.this can be overridden by subclasses to provide their own functionality to be executed just before the transitionoccurs.",
	"Method": "void initTransition(){\r\n    super.initTransition();\r\n    startVals = new XYValueSeries(\"Start\");\r\n    copyValues(series, startVals);\r\n    endVals = new XYValueSeries(\"End\");\r\n    copyValues(cachedSeries, endVals);\r\n}"
}, {
	"Path": "com.codename1.properties.UiBinding.bindGroup",
	"Comment": "binds the given property to the selected value from the set based on the multiple components. this is useful for binding multiple radio buttons to a single property value based on selection",
	"Method": "Binding bindGroup(PropertyBase prop,Object[] values,Component cmps){\r\n    ObjectConverter cnv = getPropertyConverter(prop);\r\n    if (cmps[0] instanceof RadioButton) {\r\n        RadioButton[] rb = new RadioButton[cmps.length];\r\n        System.arraycopy(cmps, 0, rb, 0, cmps.length);\r\n        return bindImpl(prop, rb, new RadioListAdapter(cnv, values));\r\n    }\r\n    throw new RuntimeException(\"Unsupported binding type: \" + cmps[0].getClass().getName());\r\n}"
}, {
	"Path": "com.codename1.ui.CN.getDragStartPercentage",
	"Comment": "this method allows us to manipulate the drag started detection logic.if the pointer was dragged for more than this percentage of the display size itis safe to assume that a drag is in progress.",
	"Method": "int getDragStartPercentage(){\r\n    return Display.impl.getDragStartPercentage();\r\n}"
}, {
	"Path": "com.codename1.ui.Form.getDefaultCommand",
	"Comment": "default command is invoked when a user presses fire, this functionality workswell in some situations but might collide with elements such as navigationand combo boxes. use with caution.",
	"Method": "Command getDefaultCommand(){\r\n    return menuBar.getDefaultCommand();\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.setDefaultMenuTransitionOut",
	"Comment": "allows us to define a default animation that will draw the transition forexiting a menu",
	"Method": "void setDefaultMenuTransitionOut(Transition defaultMenuTransitionOut){\r\n    this.defaultMenuTransitionOut = defaultMenuTransitionOut;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.isRedirecting",
	"Comment": "returns true if this request is been redirected to a different url",
	"Method": "boolean isRedirecting(){\r\n    return redirecting;\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    if (keySet == null) {\r\n        keySet = new AbstractSet<K>() {\r\n            @Override\r\n            public boolean contains(Object object) {\r\n                return containsKey(object);\r\n            }\r\n            @Override\r\n            public int size() {\r\n                return IdentityHashMap.this.size();\r\n            }\r\n            @Override\r\n            public void clear() {\r\n                IdentityHashMap.this.clear();\r\n            }\r\n            @Override\r\n            public boolean remove(Object key) {\r\n                if (containsKey(key)) {\r\n                    IdentityHashMap.this.remove(key);\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n            @Override\r\n            public Iterator<K> iterator() {\r\n                return new IdentityHashMapIterator<K, K, V>(new MapEntry.Type<K, K, V>() {\r\n                    public K get(MapEntry<K, V> entry) {\r\n                        return entry.key;\r\n                    }\r\n                }, IdentityHashMap.this);\r\n            }\r\n        };\r\n    }\r\n    return keySet;\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return containsKey(object);\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return IdentityHashMap.this.size();\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    IdentityHashMap.this.clear();\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    if (containsKey(key)) {\r\n        IdentityHashMap.this.remove(key);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return new IdentityHashMapIterator<K, K, V>(new MapEntry.Type<K, K, V>() {\r\n        public K get(MapEntry<K, V> entry) {\r\n            return entry.key;\r\n        }\r\n    }, IdentityHashMap.this);\r\n}"
}, {
	"Path": "java.util.IdentityHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return entry.key;\r\n}"
}, {
	"Path": "com.codename1.components.InteractionDialog.setFormMode",
	"Comment": "whether the interaction dialog uses the form layered pane of the regular layered pane",
	"Method": "void setFormMode(boolean formMode){\r\n    this.formMode = formMode;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.getResponseData",
	"Comment": "this method will return a valid value for only some of the responses and only after the response was processed",
	"Method": "byte[] getResponseData(){\r\n    return data;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.isPost",
	"Comment": "returns true for a post operation and false for a get operation",
	"Method": "boolean isPost(){\r\n    return post;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.add",
	"Comment": "simpler version of addcomponent that allows chaining the calls for shorter syntax",
	"Method": "Container add(Component cmp,Container add,Object constraint,Component cmp,Container add,String label,Container add,Image img,Container add,Object constraint,String label,Container add,Object constraint,Image img){\r\n    return add(constraint, new Label(img));\r\n}"
}, {
	"Path": "com.alibaba.citrus.service.upload.impl.cfu.AbstractFileItem.write",
	"Comment": "a convenience method to write an uploaded item to disk. the client codeis not concerned with whether or not the item is stored in memory, or ondisk in a temporary location. they just want to write the uploaded itemto a file.this implementation first attempts to rename the uploaded item to thespecified destination file, if the item was originally written to disk.otherwise, the data will be copied to the specified file.this method is only guaranteed to work once, the first time itis invoked for a particular item. this is because, in the event that themethod renames a temporary file, that file will no longer be available tocopy or rename again at a later time.",
	"Method": "void write(File file){\r\n    if (file != null) {\r\n        file.getParentFile().mkdirs();\r\n    }\r\n    if (isInMemory()) {\r\n        FileOutputStream fout = null;\r\n        try {\r\n            fout = new FileOutputStream(file);\r\n            fout.write(get());\r\n        } finally {\r\n            if (fout != null) {\r\n                fout.close();\r\n            }\r\n        }\r\n    } else {\r\n        File outputFile = getStoreLocation();\r\n        if (outputFile != null) {\r\n            size = outputFile.length();\r\n            if (!outputFile.renameTo(file)) {\r\n                BufferedInputStream in = null;\r\n                BufferedOutputStream out = null;\r\n                try {\r\n                    in = new BufferedInputStream(new FileInputStream(outputFile));\r\n                    out = new BufferedOutputStream(new FileOutputStream(file));\r\n                    IOUtils.copy(in, out);\r\n                } finally {\r\n                    if (in != null) {\r\n                        try {\r\n                            in.close();\r\n                        } catch (IOException e) {\r\n                        }\r\n                    }\r\n                    if (out != null) {\r\n                        try {\r\n                            out.close();\r\n                        } catch (IOException e) {\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            throw new FileUploadException(\"Cannot write uploaded file to disk!\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.BufferedOutputStream.getTotalBytesWritten",
	"Comment": "returns the total amount of bytes written to this stream so far",
	"Method": "int getTotalBytesWritten(){\r\n    return totalBytesWritten;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.compaction.MinorCompactionTask.compactEntries",
	"Comment": "compacts entries from the given segment, rewriting them to the compact segment.",
	"Method": "void compactEntries(Segment segment,Segment compactSegment){\r\n    for (long i = segment.firstIndex(); i <= segment.lastIndex(); i++) {\r\n        checkEntry(i, segment, compactSegment);\r\n    }\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.setDisableUpdateSessionRequests",
	"Comment": "disable periodic session time updates.by default, countly will send a request to the server each 30 seconds with a small updatecontaining session duration time. this method allows you to disable such behavior.note that event updates will still be sent every 10 events or 30 seconds after event recording.",
	"Method": "Countly setDisableUpdateSessionRequests(boolean disable){\r\n    if (Countly.sharedInstance().isLoggingEnabled()) {\r\n        Log.d(Countly.TAG, \"Disabling periodic session time updates\");\r\n    }\r\n    disableUpdateSessionRequests_ = disable;\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setInlineUnselectedStyles",
	"Comment": "registers inline styles that should be applied to the unselected state of the component.",
	"Method": "void setInlineUnselectedStyles(String styles){\r\n    if (styles != null && styles.trim().length() == 0) {\r\n        styles = null;\r\n    }\r\n    if (styles == null ? inlineUnselectedStyles != null : !styles.equals(inlineUnselectedStyles)) {\r\n        this.inlineUnselectedStyles = styles;\r\n        unSelectedStyle = null;\r\n        selectedStyle = null;\r\n        disabledStyle = null;\r\n        pressedStyle = null;\r\n        allStyles = null;\r\n        if (!sizeRequestedByUser) {\r\n            preferredSize = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.prometheus.client.CollectorRegistry.register",
	"Comment": "register a collector.a collector can be registered to multiple collectorregistries.",
	"Method": "void register(Collector m){\r\n    List<String> names = collectorNames(m);\r\n    synchronized (collectorsToNames) {\r\n        for (String name : names) {\r\n            if (namesToCollectors.containsKey(name)) {\r\n                throw new IllegalArgumentException(\"Collector already registered that provides name: \" + name);\r\n            }\r\n        }\r\n        for (String name : names) {\r\n            namesToCollectors.put(name, m);\r\n        }\r\n        collectorsToNames.put(m, names);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.designer.BaseForm.getModelSelection",
	"Comment": "returns the selection in the jxtable mapped to the model since the tablemight be sorted or filtered",
	"Method": "int getModelSelection(JTable t){\r\n    EditorTable table = (EditorTable) t;\r\n    if (table.getSelectedRow() < 0 || table.getVisibleRowCount() == 0) {\r\n        return -1;\r\n    }\r\n    return table.convertRowIndexToModel(table.getSelectedRow());\r\n}"
}, {
	"Path": "com.l2fprod.common.swing.JOutlookBar.updateUI",
	"Comment": "notification from the uimanager that the l&f haschanged. replaces the current ui object with the latest versionfrom the uimanager.",
	"Method": "void updateUI(){\r\n    setUI((OutlookBarUI) LookAndFeelAddons.getUI(this, OutlookBarUI.class));\r\n}"
}, {
	"Path": "com.codename1.charts.renderers.DefaultRenderer.getSeriesRendererAt",
	"Comment": "returns the simple renderer from the multiple renderer list.",
	"Method": "SimpleSeriesRenderer getSeriesRendererAt(int index){\r\n    return mRenderers.get(index);\r\n}"
}, {
	"Path": "com.codename1.ui.Graphics.setGraphics",
	"Comment": "setting graphics with a given javax.microedition.lcdui.graphics",
	"Method": "void setGraphics(Object g){\r\n    this.nativeGraphics = g;\r\n}"
}, {
	"Path": "com.codename1.ui.Font.clearBitmapCache",
	"Comment": "bitmap fonts are cached this method allows us to flush the cache thus allowsus to reload a font",
	"Method": "void clearBitmapCache(){\r\n    bitmapCache.clear();\r\n}"
}, {
	"Path": "com.codename1.ui.geom.GeneralPath.isInside",
	"Comment": "checks cross count according to path rule to define is it point inside shape or not.",
	"Method": "boolean isInside(int cross){\r\n    if (rule == WIND_NON_ZERO) {\r\n        return ShapeUtil.isInsideNonZero(cross);\r\n    }\r\n    return ShapeUtil.isInsideEvenOdd(cross);\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Timeline.setAnimationDelay",
	"Comment": "inidicates the minimal delay between animation frames allowing the cpu to rest.increase this number to increase general device performance, decrease it to speedthe animation.",
	"Method": "void setAnimationDelay(int animationDelay){\r\n    this.animationDelay = animationDelay;\r\n}"
}, {
	"Path": "structures.LinkCutTree.expose",
	"Comment": "makes node x the root of the virtual tree, and also x becomes the leftmost node in its splay tree",
	"Method": "Node expose(Node x){\r\n    Node last = null;\r\n    for (Node y = x; y != null; y = y.parent) {\r\n        splay(y);\r\n        y.left = last;\r\n        last = y;\r\n    }\r\n    splay(x);\r\n    return last;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.setDefaultFormTransitionIn",
	"Comment": "allows us to define a default animation that will draw the transition forentering a form",
	"Method": "void setDefaultFormTransitionIn(Transition defaultFormTransitionIn){\r\n    this.defaultFormTransitionIn = defaultFormTransitionIn;\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetTable.getCellEditor",
	"Comment": "gets the celleditor for the given row and column. it uses theeditor registry to find a suitable editor for the property.",
	"Method": "TableCellEditor getCellEditor(int row,int column){\r\n    if (column == 0) {\r\n        return null;\r\n    }\r\n    Item item = getSheetModel().getPropertySheetElement(row);\r\n    if (!item.isProperty())\r\n        return null;\r\n    TableCellEditor result = null;\r\n    Property propery = item.getProperty();\r\n    PropertyEditor editor = getEditorFactory().createPropertyEditor(propery);\r\n    if (editor != null)\r\n        result = new CellEditorAdapter(editor);\r\n    return result;\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSEngine.setColorRecursive",
	"Comment": "sets the specified color as the foreground color of the component and all its children",
	"Method": "void setColorRecursive(Component cmp,int color,CSSElement selector){\r\n    int styles = getApplicableStyles(cmp, selector);\r\n    if ((styles & STYLE_UNSELECTED) != 0) {\r\n        cmp.getUnselectedStyle().setFgColor(color);\r\n    }\r\n    if ((styles & STYLE_SELECTED) != 0) {\r\n        cmp.getSelectedStyle().setFgColor(color);\r\n    }\r\n    if ((styles & STYLE_PRESSED) != 0) {\r\n        ((HTMLLink) cmp).getPressedStyle().setFgColor(color);\r\n    }\r\n    if (cmp instanceof Container) {\r\n        Container cont = (Container) cmp;\r\n        for (int i = 0; i < cont.getComponentCount(); i++) {\r\n            if (!(cont.getComponentAt(i) instanceof HTMLLink)) {\r\n                setColorRecursive(cont.getComponentAt(i), color, selector);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.list.DefaultListCellRenderer.isShowNumbers",
	"Comment": "indicate whether numbering should exist for the default cell renderer",
	"Method": "boolean isShowNumbers(){\r\n    return showNumbers;\r\n}"
}, {
	"Path": "com.codename1.ui.validation.Validator.getDefaultValidationFailedEmblem",
	"Comment": "the emblem that will be drawn on top of the component to indicate the validation failure",
	"Method": "Image getDefaultValidationFailedEmblem(){\r\n    return defaultValidationFailedEmblem;\r\n}"
}, {
	"Path": "org.conscrypt.CertBlacklistTest.testBlacklistedPublicKey",
	"Comment": "ensure that the test blacklisted ca is actually blacklisted by default.",
	"Method": "void testBlacklistedPublicKey(){\r\n    X509Certificate blacklistedCa = loadCertificate(BLACKLIST_CA);\r\n    CertBlacklist blacklist = CertBlacklistImpl.getDefault();\r\n    assertTrue(blacklist.isPublicKeyBlackListed(blacklistedCa.getPublicKey()));\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.ArrayDeque.poll",
	"Comment": "gets and removes the head element of this deque. this method returns nullif the deque is empty.",
	"Method": "E poll(){\r\n    return pollFirst();\r\n}"
}, {
	"Path": "com.codename1.ui.AutoCompleteTextField.getMinimumLength",
	"Comment": "indicates the minimum length of text in the field in order for a popup to showthe default is 0 where a popup is shown immediately for all text length if the numberis 2 a popup will only appear when there are two characters or more.",
	"Method": "int getMinimumLength(){\r\n    return minimumLength;\r\n}"
}, {
	"Path": "com.android.org.conscrypt.OpenSSLSocketImpl.setSoWriteTimeout",
	"Comment": "note write timeouts are not part of the javax.net.ssl.sslsocket api",
	"Method": "void setSoWriteTimeout(int writeTimeoutMilliseconds){\r\n    throw new RuntimeException(\"Stub!\");\r\n}"
}, {
	"Path": "org.conscrypt.ConscryptFileDescriptorSocket.setHostname",
	"Comment": "this method enables server name indication.if the hostname is not a valid sni hostname,the sni extension will be omitted from the handshake.",
	"Method": "void setHostname(String hostname){\r\n    sslParameters.setUseSni(hostname != null);\r\n    super.setHostname(hostname);\r\n}"
}, {
	"Path": "com.codename1.ui.Command.create",
	"Comment": "creates a new command instance that encapsulates the action listener and details, the mainvalue of this approach is in our ability to write commands using the shorthand lambda syntaxof java 8.",
	"Method": "Command create(String name,Image icon,ActionListener ev){\r\n    Command cmd = new Command(name) {\r\n        @Override\r\n        public void actionPerformed(ActionEvent evt) {\r\n            ev.actionPerformed(evt);\r\n        }\r\n    };\r\n    cmd.setIcon(icon);\r\n    return cmd;\r\n}"
}, {
	"Path": "com.codename1.ui.Command.create",
	"Comment": "creates a new command instance that encapsulates the action listener and details, the mainvalue of this approach is in our ability to write commands using the shorthand lambda syntaxof java 8.",
	"Method": "Command create(String name,Image icon,ActionListener ev){\r\n    ev.actionPerformed(evt);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.DimConstraint.getGrowPriority",
	"Comment": "returns the grow priority. relative priority is used for determining which entities gets the extra space first.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "int getGrowPriority(){\r\n    return resize.growPrio;\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.getPhoto",
	"Comment": "gets a photo from a photoidthis is a sync method it will block until a response it returned",
	"Method": "void getPhoto(String photoId,Photo photo,ActionListener callback,Photo getPhoto,String photoId,boolean needAuth){\r\n    final Photo photo = new Photo();\r\n    final Vector err = new Vector();\r\n    addResponseCodeListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            NetworkEvent ne = (NetworkEvent) evt;\r\n            err.addElement(ne);\r\n            removeResponseCodeListener(this);\r\n        }\r\n    });\r\n    getFaceBookObject(photoId, new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            Vector v = (Vector) ((NetworkEvent) evt).getMetaData();\r\n            Hashtable t = (Hashtable) v.elementAt(0);\r\n            photo.copy(t);\r\n        }\r\n    }, needAuth, false);\r\n    if (err.size() > 0) {\r\n        throw new IOException(((NetworkEvent) err.elementAt(0)).getResponseCode() + \": \" + ((NetworkEvent) err.elementAt(0)).getMessage());\r\n    }\r\n    return photo;\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.getPhoto",
	"Comment": "gets a photo from a photoidthis is a sync method it will block until a response it returned",
	"Method": "void getPhoto(String photoId,Photo photo,ActionListener callback,Photo getPhoto,String photoId,boolean needAuth){\r\n    NetworkEvent ne = (NetworkEvent) evt;\r\n    err.addElement(ne);\r\n    removeResponseCodeListener(this);\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.getPhoto",
	"Comment": "gets a photo from a photoidthis is a sync method it will block until a response it returned",
	"Method": "void getPhoto(String photoId,Photo photo,ActionListener callback,Photo getPhoto,String photoId,boolean needAuth){\r\n    Vector v = (Vector) ((NetworkEvent) evt).getMetaData();\r\n    Hashtable t = (Hashtable) v.elementAt(0);\r\n    photo.copy(t);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.calcScrollSize",
	"Comment": "method that can be overriden to represent the actual size of the component when it differs from the desireable size for the viewport",
	"Method": "Dimension calcScrollSize(){\r\n    return calcPreferredSize();\r\n}"
}, {
	"Path": "com.codename1.io.BufferedInputStream.setConnection",
	"Comment": "if applicable this member represents the connection object for the stream",
	"Method": "void setConnection(Object connection){\r\n    this.connection = connection;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setParent",
	"Comment": "sets the component parent.this method should not be called by the user.",
	"Method": "void setParent(Container parent){\r\n    if (parent == this) {\r\n        throw new IllegalArgumentException(\"Attempt to add self as parent\");\r\n    }\r\n    this.parent = parent;\r\n}"
}, {
	"Path": "com.codename1.xml.XMLParser.isWhiteSpace",
	"Comment": "checks if the specified character is a white space or not.exposed to packaage since used by htmlcomponent as well",
	"Method": "boolean isWhiteSpace(char ch){\r\n    return ((ch == ' ') || (ch == '\\n') || (ch == '\\t') || (ch == 10) || (ch == 13));\r\n}"
}, {
	"Path": "com.codename1.util.CStringBuilder.deleteCharAt",
	"Comment": "deletes the character at the specified index. shifts any remainingcharacters to the left.",
	"Method": "CStringBuilder deleteCharAt(int index){\r\n    deleteCharAt0(index);\r\n    return this;\r\n}"
}, {
	"Path": "ly.count.android.sdk.CountlyStore.isEmptyConnections",
	"Comment": "returns true if no connections are current stored, false otherwise.",
	"Method": "boolean isEmptyConnections(){\r\n    return preferences_.getString(CONNECTIONS_PREFERENCE, \"\").length() == 0;\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyIndex.getMetaDataOfClass",
	"Comment": "allows us to fetch class meta data not to be confused with standard properties",
	"Method": "Object getMetaDataOfClass(String meta){\r\n    return getProps().get(meta);\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.waitFor",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "void waitFor(int millis){\r\n    TestUtils.waitFor(millis);\r\n}"
}, {
	"Path": "java.lang.Character.isLowerCase",
	"Comment": "indicates whether the specified code point is a lower case letter.",
	"Method": "boolean isLowerCase(char ch){\r\n    if ('a' <= codePoint && codePoint <= 'z') {\r\n        return true;\r\n    }\r\n    if (codePoint < 128) {\r\n        return false;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Label.getShiftText",
	"Comment": "simple getter to return how many pixels to shift the text inside the label",
	"Method": "int getShiftText(){\r\n    return shiftText;\r\n}"
}, {
	"Path": "com.codename1.impl.android.AndroidImplementation.initSurface",
	"Comment": "init view. a lot of back and forth between this thread and the ui thread.",
	"Method": "void initSurface(){\r\n    if (getActivity() != null && myView == null) {\r\n        relativeLayout = new RelativeLayout(getActivity());\r\n        relativeLayout.setLayoutParams(new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.FILL_PARENT, RelativeLayout.LayoutParams.FILL_PARENT));\r\n        relativeLayout.setFocusable(false);\r\n        getActivity().getWindow().setBackgroundDrawable(null);\r\n        if (asyncView) {\r\n            if (android.os.Build.VERSION.SDK_INT < 14) {\r\n                myView = new AndroidSurfaceView(getActivity(), AndroidImplementation.this);\r\n            } else {\r\n                int hardwareAcceleration = 16777216;\r\n                getActivity().getWindow().setFlags(hardwareAcceleration, hardwareAcceleration);\r\n                myView = new AndroidAsyncView(getActivity(), AndroidImplementation.this);\r\n            }\r\n        } else {\r\n            int hardwareAcceleration = 16777216;\r\n            getActivity().getWindow().setFlags(hardwareAcceleration, hardwareAcceleration);\r\n            superPeerMode = true;\r\n            myView = new AndroidAsyncView(getActivity(), AndroidImplementation.this);\r\n        }\r\n        myView.getAndroidView().setVisibility(View.VISIBLE);\r\n        relativeLayout.addView(myView.getAndroidView());\r\n        myView.getAndroidView().setVisibility(View.VISIBLE);\r\n        int id = getActivity().getResources().getIdentifier(\"main\", \"layout\", getActivity().getApplicationInfo().packageName);\r\n        RelativeLayout root = (RelativeLayout) LayoutInflater.from(getActivity()).inflate(id, null);\r\n        if (viewAbove != null) {\r\n            RelativeLayout.LayoutParams lp = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT);\r\n            lp.addRule(RelativeLayout.ALIGN_PARENT_TOP);\r\n            lp.addRule(RelativeLayout.CENTER_HORIZONTAL);\r\n            RelativeLayout.LayoutParams lp2 = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);\r\n            lp2.setMargins(0, 0, aboveSpacing, 0);\r\n            relativeLayout.setLayoutParams(lp2);\r\n            root.addView(viewAbove, lp);\r\n        }\r\n        root.addView(relativeLayout);\r\n        if (viewBelow != null) {\r\n            RelativeLayout.LayoutParams lp = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT);\r\n            lp.addRule(RelativeLayout.ALIGN_PARENT_BOTTOM);\r\n            lp.addRule(RelativeLayout.CENTER_HORIZONTAL);\r\n            RelativeLayout.LayoutParams lp2 = new RelativeLayout.LayoutParams(RelativeLayout.LayoutParams.MATCH_PARENT, RelativeLayout.LayoutParams.MATCH_PARENT);\r\n            lp2.setMargins(0, 0, 0, belowSpacing);\r\n            relativeLayout.setLayoutParams(lp2);\r\n            root.addView(viewBelow, lp);\r\n        }\r\n        getActivity().setContentView(root);\r\n        if (!myView.getAndroidView().hasFocus()) {\r\n            myView.getAndroidView().requestFocus();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.BorderLayout.south",
	"Comment": "convenience method that creates a border layout container and places the given component in the south",
	"Method": "Container south(Component south){\r\n    return Container.encloseIn(new BorderLayout(), south, BorderLayout.SOUTH);\r\n}"
}, {
	"Path": "com.codename1.ui.Tabs.isChangeTabOnFocus",
	"Comment": "indicates that a tab should change when the focus changes without the user physically pressing a button",
	"Method": "boolean isChangeTabOnFocus(){\r\n    return changeTabOnFocus;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.DefaultLookAndFeel.drawLabelString",
	"Comment": "implements the drawstring for the text component and adjust the valignassuming the icon is in one of the sides",
	"Method": "int drawLabelString(Graphics g,Label l,String text,int x,int y,int textSpaceW){\r\n    Style style = l.getStyle();\r\n    int cx = g.getClipX();\r\n    int cy = g.getClipY();\r\n    int cw = g.getClipWidth();\r\n    int ch = g.getClipHeight();\r\n    g.clipRect(x, cy, textSpaceW, ch);\r\n    if (l.isTickerRunning()) {\r\n        Font font = style.getFont();\r\n        if (l.getShiftText() > 0) {\r\n            if (l.getShiftText() > textSpaceW) {\r\n                l.setShiftText(x - l.getX() - l.getStringWidth(font));\r\n            }\r\n        } else if (l.getShiftText() + l.getStringWidth(font) < 0) {\r\n            l.setShiftText(textSpaceW);\r\n        }\r\n    }\r\n    int drawnW = drawLabelText(g, l, text, x, y, textSpaceW);\r\n    g.setClip(cx, cy, cw, ch);\r\n    return drawnW;\r\n}"
}, {
	"Path": "com.codename1.ui.validation.Validator.setDefaultValidationFailedEmblem",
	"Comment": "the emblem that will be drawn on top of the component to indicate the validation failure",
	"Method": "void setDefaultValidationFailedEmblem(Image aDefaultValidationFailedEmblem){\r\n    defaultValidationFailedEmblem = aDefaultValidationFailedEmblem;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.animateLayoutFade",
	"Comment": "animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation",
	"Method": "void animateLayoutFade(int duration,int startingOpacity){\r\n    animateLayout(duration, false, startingOpacity, true);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.addToEmebeddedCSS",
	"Comment": "adds the specified csselement which represents an embedded css segment to the embedded css vector",
	"Method": "void addToEmebeddedCSS(CSSElement cssElement){\r\n    if (embeddedCSS == null) {\r\n        embeddedCSS = new Vector();\r\n    }\r\n    embeddedCSS.addElement(cssElement);\r\n}"
}, {
	"Path": "java.util.Collections.nCopies",
	"Comment": "returns a list containing the specified number of the specified element.the list cannot be modified. the list is serializable.",
	"Method": "List<T> nCopies(int length,T object){\r\n    return new CopiesList<T>(length, object);\r\n}"
}, {
	"Path": "com.codename1.ui.Form.getLayeredPaneImpl",
	"Comment": "this method returns the layered pane of the form, the layered pane is laidon top of the content pane and is created lazily upon calling this method the layerwill be created.",
	"Method": "Container getLayeredPaneImpl(){\r\n    if (layeredPane == null) {\r\n        layeredPane = new Container(new LayeredLayout());\r\n        Container parent = contentPane.wrapInLayeredPane();\r\n        layeredPane.add(new Container());\r\n        parent.addComponent(layeredPane);\r\n        revalidate();\r\n    }\r\n    return layeredPane;\r\n}"
}, {
	"Path": "com.codename1.io.Oauth2.authenticate",
	"Comment": "this method preforms the actual authentication, this method is a blockingmethod that will display the user the html authentication pages.",
	"Method": "String authenticate(){\r\n    if (token == null) {\r\n        login = new Dialog();\r\n        boolean i = Dialog.isAutoAdjustDialogSize();\r\n        Dialog.setAutoAdjustDialogSize(false);\r\n        login.setLayout(new BorderLayout());\r\n        login.setScrollable(false);\r\n        Component html = createLoginComponent(null, null, null, null);\r\n        login.addComponent(BorderLayout.CENTER, html);\r\n        login.setScrollable(false);\r\n        login.setDialogUIID(\"Container\");\r\n        login.setTransitionInAnimator(CommonTransitions.createSlide(CommonTransitions.SLIDE_VERTICAL, true, 300));\r\n        login.setTransitionOutAnimator(CommonTransitions.createSlide(CommonTransitions.SLIDE_VERTICAL, false, 300));\r\n        login.show(0, 0, 0, 0, false, true);\r\n        Dialog.setAutoAdjustDialogSize(i);\r\n    }\r\n    return token;\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.isEditingEndTrigger",
	"Comment": "indicates whether the given key code should be ignored or should triggercause editing to end. by default the fire key, up or down will triggerthe end of editing.",
	"Method": "boolean isEditingEndTrigger(int keyCode){\r\n    int k = Display.getInstance().getGameAction(keyCode);\r\n    boolean endTrigger = false;\r\n    if (isQwertyInput()) {\r\n        if (isSingleLineTextArea()) {\r\n            endTrigger = keyCode < 0 && (k == Display.GAME_FIRE || k == Display.GAME_UP || k == Display.GAME_DOWN || isEnterKey(keyCode));\r\n        } else {\r\n            endTrigger = keyCode < 0 && (k == Display.GAME_FIRE);\r\n        }\r\n    } else {\r\n        if (isSingleLineTextArea()) {\r\n            endTrigger = (k == Display.GAME_FIRE || k == Display.GAME_UP || k == Display.GAME_DOWN);\r\n        } else {\r\n            endTrigger = (k == Display.GAME_FIRE);\r\n        }\r\n    }\r\n    return endTrigger;\r\n}"
}, {
	"Path": "com.codename1.ui.table.AbstractTableModel.getValidator",
	"Comment": "a validator can be defined here so a validation constraint can bind to a table model cell",
	"Method": "Validator getValidator(){\r\n    return validator;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isAsyncEditMode",
	"Comment": "returns true if edit string will return immediately and broadcast editing events directly to the text field",
	"Method": "boolean isAsyncEditMode(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.isTablet",
	"Comment": "indicates whether the device is a tablet, notice that this is often a guess",
	"Method": "boolean isTablet(){\r\n    return Display.impl.isTablet();\r\n}"
}, {
	"Path": "java.lang.Long.toString",
	"Comment": "returns a new string object representing the specified integer. the argument is converted to signed decimal representation and returned as a string, exactly as if the argument and the radix 10 were given as arguments to themethod that takes two arguments.",
	"Method": "java.lang.String toString(java.lang.String toString,long i,java.lang.String toString,long i,int radix){\r\n    return toString(i, 10);\r\n}"
}, {
	"Path": "org.conscrypt.ConscryptEngine.getChannelId",
	"Comment": "gets the tls channel id for this server engine. channel id is only available once thehandshake completes.",
	"Method": "byte[] getChannelId(){\r\n    synchronized (ssl) {\r\n        if (getUseClientMode()) {\r\n            throw new IllegalStateException(\"Not allowed in client mode\");\r\n        }\r\n        if (isHandshakeStarted()) {\r\n            throw new IllegalStateException(\"Channel ID is only available after handshake completes\");\r\n        }\r\n        return ssl.getTlsChannelId();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.getPopupDirectionBiasPortrait",
	"Comment": "indicates if we want to enforce directional bias for the popup dialog. if null this field is ignored but ifits set to a value it biases the system towards a fixed direction for the popup dialog.",
	"Method": "Boolean getPopupDirectionBiasPortrait(){\r\n    return popupDirectionBiasPortrait;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.animateLayout",
	"Comment": "animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation",
	"Method": "void animateLayout(int duration,ComponentAnimation animateLayout,int duration,boolean wait,int opacity,boolean addAnimation){\r\n    Form f = getComponentForm();\r\n    if (f == null) {\r\n        return null;\r\n    }\r\n    setShouldCalcPreferredSize(true);\r\n    enableLayoutOnPaint = false;\r\n    final int componentCount = getComponentCount();\r\n    int[] beforeX = new int[componentCount];\r\n    int[] beforeY = new int[componentCount];\r\n    int[] beforeW = new int[componentCount];\r\n    int[] beforeH = new int[componentCount];\r\n    final Motion[] xMotions = new Motion[componentCount];\r\n    final Motion[] yMotions = new Motion[componentCount];\r\n    final Motion[] wMotions = new Motion[componentCount];\r\n    final Motion[] hMotions = new Motion[componentCount];\r\n    for (int iter = 0; iter < componentCount; iter++) {\r\n        Component current = getComponentAt(iter);\r\n        beforeX[iter] = current.getX();\r\n        beforeY[iter] = current.getY();\r\n        beforeW[iter] = current.getWidth();\r\n        beforeH[iter] = current.getHeight();\r\n    }\r\n    layoutContainer();\r\n    for (int iter = 0; iter < componentCount; iter++) {\r\n        Component current = getComponentAt(iter);\r\n        xMotions[iter] = createAnimateMotion(beforeX[iter], current.getX(), duration);\r\n        yMotions[iter] = createAnimateMotion(beforeY[iter], current.getY(), duration);\r\n        wMotions[iter] = createAnimateMotion(beforeW[iter], current.getWidth(), duration);\r\n        hMotions[iter] = createAnimateMotion(beforeH[iter], current.getHeight(), duration);\r\n        xMotions[iter].start();\r\n        yMotions[iter].start();\r\n        wMotions[iter].start();\r\n        hMotions[iter].start();\r\n        current.setX(beforeX[iter]);\r\n        current.setY(beforeY[iter]);\r\n        current.setWidth(beforeW[iter]);\r\n        current.setHeight(beforeH[iter]);\r\n    }\r\n    MorphAnimation a = new MorphAnimation(this, duration, new Motion[][] { xMotions, yMotions, wMotions, hMotions });\r\n    setAnimOpacity(opacity, 255, a, componentCount, duration);\r\n    if (addAnimation) {\r\n        if (wait) {\r\n            getAnimationManager().addAnimationAndBlock(a);\r\n        } else {\r\n            getAnimationManager().addAnimation(a);\r\n        }\r\n    } else {\r\n        a.dontRevalidate = true;\r\n    }\r\n    return a;\r\n}"
}, {
	"Path": "com.codename1.ui.FontImage.getMaterialDesignFont",
	"Comment": "the material design icon font allows creating icons based on the materialdesign icon catalog",
	"Method": "Font getMaterialDesignFont(){\r\n    if (materialDesignFont == null) {\r\n        if (Font.isTrueTypeFileSupported()) {\r\n            materialDesignFont = Font.createTrueTypeFont(\"Material Icons\", \"material-design-font.ttf\");\r\n        } else {\r\n            materialDesignFont = Font.getDefaultFont();\r\n        }\r\n    }\r\n    return materialDesignFont;\r\n}"
}, {
	"Path": "com.codename1.ui.Command.getRolloverIcon",
	"Comment": "indicates the icon that is displayed on the button when the button is inrolled over state",
	"Method": "Image getRolloverIcon(){\r\n    return rolloverIcon;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.SegmentDescriptor.locked",
	"Comment": "returns whether the segment has been locked by commitment.segments will be locked once all entries have been committed to the segment. the lock state of each segment is usedto determine log compaction and recovery behavior.",
	"Method": "boolean locked(){\r\n    return locked;\r\n}"
}, {
	"Path": "com.codename1.javascript.JSObject.callDouble",
	"Comment": "calls a method on the underlying javascript object that returns a double. called synchronously with no arguments.",
	"Method": "double callDouble(String key){\r\n    Double d = (Double) call(key);\r\n    return d.doubleValue();\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.newLineIfLastWasNotEmpty",
	"Comment": "same as newline, but only if the last line container was not empty",
	"Method": "void newLineIfLastWasNotEmpty(int align){\r\n    if (!lastWasEmpty) {\r\n        newLine(align);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLElement.getSupportedAttributesList",
	"Comment": "returns a list of supported attributes for this tag. note that the list does not include the core attributes that are supported on almost all tags",
	"Method": "String getSupportedAttributesList(){\r\n    if ((id < 0) || (id >= TAG_ATTRIBUTES.length)) {\r\n        return \"Unknown\";\r\n    }\r\n    String list = \"\";\r\n    for (int a = 0; a < TAG_ATTRIBUTES[id].length; a++) {\r\n        list += ATTRIBUTE_NAMES[TAG_ATTRIBUTES[id][a]] + \",\";\r\n    }\r\n    if (supportsCoreAttributes()) {\r\n        for (int a = 0; a < COMMON_ATTRIBUTES.length; a++) {\r\n            list += ATTRIBUTE_NAMES[COMMON_ATTRIBUTES[a]] + \",\";\r\n        }\r\n    }\r\n    if (list.endsWith(\",\")) {\r\n        list = list.substring(0, list.length() - 1);\r\n    }\r\n    if (list.equals(\"\")) {\r\n        list = \"None\";\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentGroup.setHorizontal",
	"Comment": "indicates that the component group should be horizontal by using the boxlayout y",
	"Method": "void setHorizontal(boolean horizontal){\r\n    if (horizontal != isHorizontal()) {\r\n        if (horizontal) {\r\n            setLayout(new BoxLayout(BoxLayout.X_AXIS));\r\n            if (\"GroupElement\".equals(elementUIID)) {\r\n                elementUIID = \"ToggleButton\";\r\n                buttonUIID = \"ToggleButton\";\r\n                updateUIIDs();\r\n            }\r\n        } else {\r\n            setLayout(new BoxLayout(BoxLayout.Y_AXIS));\r\n            if (\"ToggleButton\".equals(elementUIID)) {\r\n                elementUIID = \"GroupElement\";\r\n                buttonUIID = \"ButtonGroup\";\r\n                updateUIIDs();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.showPopupDialog",
	"Comment": "a popup dialog is shown with the context of a component andits selection, it is disposed seamlessly if the back button is pressedor if the user touches outside its bounds. it can optionally provide an arrow in the theme to point at the context component. the popupdialog has the popupdialog style by default.",
	"Method": "Command showPopupDialog(Component c,Command showPopupDialog,Rectangle rect){\r\n    if (getDialogUIID().equals(\"Dialog\")) {\r\n        setDialogUIID(\"PopupDialog\");\r\n        if (getTitleComponent().getUIID().equals(\"DialogTitle\")) {\r\n            getTitleComponent().setUIID(\"PopupDialogTitle\");\r\n        }\r\n        getContentPane().setUIID(\"PopupContentPane\");\r\n    }\r\n    disposeOnRotation = true;\r\n    disposeWhenPointerOutOfBounds = true;\r\n    Command backCommand = null;\r\n    if (getBackCommand() == null) {\r\n        backCommand = new Command(\"Back\");\r\n        setBackCommand(backCommand);\r\n    }\r\n    Component contentPane = super.getContentPane();\r\n    Label title = super.getTitleComponent();\r\n    int menuHeight = calcMenuHeight();\r\n    UIManager manager = getUIManager();\r\n    if (dialogTitle != null && manager.isThemeConstant(\"hideEmptyTitleBool\", false)) {\r\n        boolean b = getTitle().length() > 0;\r\n        getTitleArea().setVisible(b);\r\n        getTitleComponent().setVisible(b);\r\n        if (!b && manager.isThemeConstant(\"shrinkPopupTitleBool\", true)) {\r\n            getTitleComponent().setPreferredSize(new Dimension(0, 0));\r\n            getTitleComponent().getStyle().setBorder(null);\r\n            getTitleArea().setPreferredSize(new Dimension(0, 0));\r\n            if (getContentPane().getClientProperty(\"$ENLARGED_POP\") == null) {\r\n                getContentPane().putClientProperty(\"$ENLARGED_POP\", Boolean.TRUE);\r\n                int cpPaddingTop = getContentPane().getStyle().getPaddingTop();\r\n                int titlePT = getTitleComponent().getStyle().getPaddingTop();\r\n                byte[] pu = getContentPane().getStyle().getPaddingUnit();\r\n                if (pu == null) {\r\n                    pu = new byte[4];\r\n                }\r\n                pu[0] = Style.UNIT_TYPE_PIXELS;\r\n                getContentPane().getStyle().setPaddingUnit(pu);\r\n                int pop = Display.getInstance().convertToPixels(manager.getThemeConstant(\"popupNoTitleAddPaddingInt\", 1), false);\r\n                getContentPane().getStyle().setPadding(TOP, pop + cpPaddingTop + titlePT);\r\n            }\r\n        }\r\n    }\r\n    revalidate();\r\n    Style contentPaneStyle = getDialogStyle();\r\n    boolean restoreArrow = false;\r\n    if (manager.isThemeConstant(getDialogUIID() + \"ArrowBool\", false)) {\r\n        Image t = manager.getThemeImageConstant(getDialogUIID() + \"ArrowTopImage\");\r\n        Image b = manager.getThemeImageConstant(getDialogUIID() + \"ArrowBottomImage\");\r\n        Image l = manager.getThemeImageConstant(getDialogUIID() + \"ArrowLeftImage\");\r\n        Image r = manager.getThemeImageConstant(getDialogUIID() + \"ArrowRightImage\");\r\n        Border border = contentPaneStyle.getBorder();\r\n        if (border != null) {\r\n            border.setImageBorderSpecialTile(t, b, l, r, rect);\r\n            restoreArrow = true;\r\n        }\r\n    }\r\n    int prefHeight = contentPane.getPreferredH();\r\n    int prefWidth = contentPane.getPreferredW();\r\n    if (contentPaneStyle.getBorder() != null) {\r\n        prefWidth = Math.max(contentPaneStyle.getBorder().getMinimumWidth(), prefWidth);\r\n        prefHeight = Math.max(contentPaneStyle.getBorder().getMinimumHeight(), prefHeight);\r\n    }\r\n    prefWidth += getUIManager().getLookAndFeel().getVerticalScrollWidth();\r\n    int availableHeight = Display.getInstance().getDisplayHeight() - menuHeight - title.getPreferredH();\r\n    int availableWidth = Display.getInstance().getDisplayWidth();\r\n    int width = Math.min(availableWidth, prefWidth);\r\n    int x = 0;\r\n    int y = 0;\r\n    Command result;\r\n    boolean showPortrait;\r\n    if (popupDirectionBiasPortrait != null) {\r\n        showPortrait = popupDirectionBiasPortrait.booleanValue();\r\n    } else {\r\n        showPortrait = Display.getInstance().isPortrait();\r\n    }\r\n    if (showPortrait) {\r\n        if (availableHeight < (availableWidth - rect.getWidth()) / 2) {\r\n            showPortrait = false;\r\n        }\r\n    } else {\r\n        if (availableHeight / 2 > availableWidth - rect.getWidth()) {\r\n            showPortrait = true;\r\n        }\r\n    }\r\n    if (showPortrait) {\r\n        if (width < availableWidth) {\r\n            int idealX = rect.getX() - width / 2 + rect.getSize().getWidth() / 2;\r\n            if (idealX > 0) {\r\n                if (idealX + width > availableWidth) {\r\n                    x = availableWidth - width;\r\n                } else {\r\n                    x = idealX;\r\n                }\r\n            }\r\n        }\r\n        if (rect.getY() < availableHeight / 2) {\r\n            y = rect.getY() + rect.getSize().getHeight();\r\n            int height = Math.min(prefHeight, availableHeight - y);\r\n            result = show(y, availableHeight - height - y, x, availableWidth - width - x, true, true);\r\n        } else {\r\n            int height = Math.min(prefHeight, availableHeight - (availableHeight - rect.getY()));\r\n            y = rect.getY() - height;\r\n            result = show(y, availableHeight - height - y, x, availableWidth - width - x, true, true);\r\n        }\r\n    } else {\r\n        int height = Math.min(prefHeight, availableHeight);\r\n        if (height < availableHeight) {\r\n            int idealY = rect.getY() - height / 2 + rect.getSize().getHeight() / 2;\r\n            if (idealY > 0) {\r\n                if (idealY + height > availableHeight) {\r\n                    y = availableHeight - height;\r\n                } else {\r\n                    y = idealY;\r\n                }\r\n            }\r\n        }\r\n        if (prefWidth > rect.getX()) {\r\n            x = rect.getX() + rect.getSize().getWidth();\r\n            if (x + prefWidth > availableWidth) {\r\n                x = availableWidth - prefWidth;\r\n            }\r\n            width = Math.min(prefWidth, availableWidth - x);\r\n            result = show(y, availableHeight - height - y, Math.max(0, x), Math.max(0, availableWidth - width - x), true, true);\r\n        } else {\r\n            width = Math.min(prefWidth, availableWidth - (availableWidth - rect.getX()));\r\n            x = rect.getX() - width;\r\n            result = show(y, availableHeight - height - y, Math.max(0, x), Math.max(0, availableWidth - width - x), true, true);\r\n        }\r\n    }\r\n    if (restoreArrow) {\r\n        contentPaneStyle.getBorder().clearImageBorderSpecialTile();\r\n    }\r\n    if (result == backCommand) {\r\n        return null;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.shrinkPrioY",
	"Comment": "the shrink priority compared to other components in the same cell.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC shrinkPrioY(int p){\r\n    ver.setShrinkPriority(p);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.social.FacebookImpl.isInviteFriendsSupported",
	"Comment": "returns true if invitefriends is implemented, it is supported on ios and android",
	"Method": "boolean isInviteFriendsSupported(){\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.shrinkPrioX",
	"Comment": "the shrink priority compared to other components in the same cell.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC shrinkPrioX(int p){\r\n    hor.setShrinkPriority(p);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.DimConstraint.getGrow",
	"Comment": "returns the grow weight.\tgrow weight is how flexible the entity should be, relative to other entities, when it comes to growing. null or\tzero mean it will never grow. an entity that has twice the grow weight compared to another entity will get twice\tas much of available space.\tgrowweight are only compared within the same growprio.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "Float getGrow(){\r\n    return resize.grow;\r\n}"
}, {
	"Path": "android.support.v4.view.ViewCompat.getParentForAccessibility",
	"Comment": "gets the parent for accessibility purposes. note that the parent foraccessibility is not necessary the immediate parent. it is the firstpredecessor that is important for accessibility.",
	"Method": "ViewParent getParentForAccessibility(View view,ViewParent getParentForAccessibility,View view,ViewParent getParentForAccessibility,View view,ViewParent getParentForAccessibility,View view){\r\n    return IMPL.getParentForAccessibility(view);\r\n}"
}, {
	"Path": "com.codename1.ui.Form.isInSameColumn",
	"Comment": "returns true if the given dest component is in the column of the source component",
	"Method": "boolean isInSameColumn(Component source,Component dest){\r\n    if (source == null || dest == null) {\r\n        return false;\r\n    }\r\n    return Rectangle.intersects(source.getAbsoluteX(), 0, source.getWidth(), Integer.MAX_VALUE, dest.getAbsoluteX(), dest.getAbsoluteY(), dest.getWidth(), dest.getHeight());\r\n}"
}, {
	"Path": "com.codename1.ui.table.TableLayout.getCellHorizontalSpan",
	"Comment": "returns the spanning for the table cell at the given coordinate",
	"Method": "int getCellHorizontalSpan(int row,int column){\r\n    return tablePositions[row * columns + column].spanHorizontal;\r\n}"
}, {
	"Path": "com.codename1.ui.IndexedImage.toByteArray",
	"Comment": "this method allows us to store a package image into a persistent stream easilythus allowing us to store the image in rms.",
	"Method": "byte[] toByteArray(){\r\n    try {\r\n        ByteArrayOutputStream array = new ByteArrayOutputStream();\r\n        DataOutputStream out = new DataOutputStream(array);\r\n        out.writeShort(width);\r\n        out.writeShort(height);\r\n        out.writeByte(palette.length);\r\n        int plen = palette.length;\r\n        for (int iter = 0; iter < plen; iter++) {\r\n            out.writeInt(palette[iter]);\r\n        }\r\n        out.write(imageDataByte);\r\n        out.close();\r\n        return array.toByteArray();\r\n    } catch (IOException ex) {\r\n        ex.printStackTrace();\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.ServerSessionContext.getLastCompleted",
	"Comment": "returns the index of the highest event acked for the session.",
	"Method": "long getLastCompleted(){\r\n    EventHolder event = events.peek();\r\n    if (event != null && event.eventIndex > completeIndex) {\r\n        return event.eventIndex - 1;\r\n    }\r\n    return lastApplied;\r\n}"
}, {
	"Path": "java.lang.Character.toUpperCase",
	"Comment": "returns the upper case equivalent for the specified code point if thecode point is a lower case letter. otherwise, the specified code point isreturned unchanged.",
	"Method": "char toUpperCase(char ch){\r\n    if ('a' <= codePoint && codePoint <= 'z') {\r\n        return (char) (codePoint - ('a' - 'A'));\r\n    }\r\n    return codePoint;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.protocol.ReconfigureResponse.builder",
	"Comment": "returns a reconfigure response builder for an existing response.",
	"Method": "Builder builder(Builder builder,ReconfigureResponse response){\r\n    return new Builder(response);\r\n}"
}, {
	"Path": "com.codename1.components.RSSReader.sendRequest",
	"Comment": "send the request to the server, will only work once. this is called implicitlywhen the list is initialized",
	"Method": "void sendRequest(){\r\n    if (service == null) {\r\n        service = new RSSService(url, limit);\r\n        if (iconPlaceholder != null) {\r\n            service.setIconPlaceholder(iconPlaceholder);\r\n        }\r\n        service.addResponseListener(new EventHandler());\r\n        if (blockList) {\r\n            Progress p = new Progress(progressTitle, service, displayProgressPercentage);\r\n            p.setAutoShow(true);\r\n            p.setDisposeOnCompletion(true);\r\n        }\r\n        setHint(progressTitle);\r\n        NetworkManager.getInstance().addToQueue(service);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.geom.Rectangle.intersects",
	"Comment": "helper method allowing us to determine if two coordinate sets intersect. this savesus the need of creating a rectangle object for a quick calculation",
	"Method": "boolean intersects(int x,int y,int width,int height,boolean intersects,Rectangle rect,boolean intersects,int tx,int ty,int tw,int th,int x,int y,int width,int height){\r\n    int rw = width;\r\n    int rh = height;\r\n    if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) {\r\n        return false;\r\n    }\r\n    int rx = x;\r\n    int ry = y;\r\n    rw += rx;\r\n    rh += ry;\r\n    tw += tx;\r\n    th += ty;\r\n    return ((rw < rx || rw > tx) && (rh < ry || rh > ty) && (tw < tx || tw > rx) && (th < ty || th > ry));\r\n}"
}, {
	"Path": "com.codename1.media.MediaManager.addCompletionHandler",
	"Comment": "adds a callback to a media element that will be called when the media finishes playing.",
	"Method": "void addCompletionHandler(Media media,Runnable onCompletion){\r\n    Display.getInstance().addCompletionHandler(media, onCompletion);\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.getDialogComponent",
	"Comment": "returns the container that actually implements the dialog positioning.this container is normally not accessible via the codename one api.",
	"Method": "Container getDialogComponent(){\r\n    return super.getContentPane();\r\n}"
}, {
	"Path": "com.codename1.ui.Component.removeScrollListener",
	"Comment": "deregisters interest in receiving callbacks for scroll gained events",
	"Method": "void removeScrollListener(ScrollListener l){\r\n    if (scrollListeners == null) {\r\n        return;\r\n    }\r\n    scrollListeners.removeListener(l);\r\n    if (!scrollListeners.hasListeners()) {\r\n        scrollListeners = null;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.validation.Validator.setShowErrorMessageForFocusedComponent",
	"Comment": "indicates whether an error message should be shown for the focused component",
	"Method": "void setShowErrorMessageForFocusedComponent(boolean showErrorMessageForFocusedComponent){\r\n    this.showErrorMessageForFocusedComponent = showErrorMessageForFocusedComponent;\r\n}"
}, {
	"Path": "com.codename1.ui.BrowserComponent.isNativeBrowserSupported",
	"Comment": "returns true if the platform supports embedding a native browser component",
	"Method": "boolean isNativeBrowserSupported(){\r\n    return Display.impl.isNativeBrowserComponentSupported();\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.actionCommand",
	"Comment": "invoked to allow subclasses of form to handle a command from one pointrather than implementing many command instances",
	"Method": "void actionCommand(Command cmd){\r\n    if (!autoDispose || lastCommandPressed == null) {\r\n        lastCommandPressed = cmd;\r\n    }\r\n    if (menu || (autoDispose && cmd.isDisposesDialog())) {\r\n        dispose();\r\n    }\r\n}"
}, {
	"Path": "org.conscrypt.ConscryptFileDescriptorSocket.getChannelId",
	"Comment": "gets the tls channel id for this server socket. channel id is only available once thehandshake completes.",
	"Method": "byte[] getChannelId(){\r\n    if (getUseClientMode()) {\r\n        throw new IllegalStateException(\"Client mode\");\r\n    }\r\n    synchronized (ssl) {\r\n        if (state != STATE_READY) {\r\n            throw new IllegalStateException(\"Channel ID is only available after handshake completes\");\r\n        }\r\n    }\r\n    return ssl.getTlsChannelId();\r\n}"
}, {
	"Path": "com.codename1.components.SplitPane.setLeft",
	"Comment": "sets the component that should be placed in the left section of the split pane.",
	"Method": "void setLeft(Component cmp){\r\n    setTopOrLeftComponent(cmp);\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.setAutomaticStarRatingSessionLimit",
	"Comment": "set after how many sessions the automatic star rating will be shown for each app version",
	"Method": "Countly setAutomaticStarRatingSessionLimit(int limit){\r\n    if (context_ == null) {\r\n        if (Countly.sharedInstance().isLoggingEnabled()) {\r\n            Log.e(Countly.TAG, \"Can't call this function before init has been called\");\r\n            return this;\r\n        }\r\n    }\r\n    if (Countly.sharedInstance().isLoggingEnabled()) {\r\n        Log.d(Countly.TAG, \"Setting automatic star rating session limit: [\" + limit + \"]\");\r\n    }\r\n    CountlyStarRating.setStarRatingInitConfig(context_, limit, null, null, null);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.analytics.AnalyticsService.sendCrashReport",
	"Comment": "in apps mode we can send information about an exception to the analytics server",
	"Method": "void sendCrashReport(Throwable t,String message,boolean fatal){\r\n    ConnectionRequest req = GetGARequest();\r\n    req.addArgument(\"t\", \"exception\");\r\n    System.out.println(message);\r\n    req.addArgument(\"exd\", message.substring(0, Math.min(message.length(), 150) - 1));\r\n    if (fatal) {\r\n        req.addArgument(\"exf\", \"1\");\r\n    } else {\r\n        req.addArgument(\"exf\", \"0\");\r\n    }\r\n    NetworkManager.getInstance().addToQueue(req);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.areMutableImagesFast",
	"Comment": "on most platforms it is quite fast to draw on a mutable image and then render thatimage, however some platforms have much slower mutable images in comparison to justdrawing on the screen. these platforms should return false here and codename one will tryto use less mutable image related optimizations in transitions and other operations.",
	"Method": "boolean areMutableImagesFast(){\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.components.ImageViewer.setSwipePlaceholder",
	"Comment": "this image is shown briefly during swiping while the full size image is loaded",
	"Method": "void setSwipePlaceholder(Image swipePlaceholder){\r\n    this.swipePlaceholder = swipePlaceholder;\r\n}"
}, {
	"Path": "com.codename1.components.InteractionDialog.isDisposeWhenPointerOutOfBounds",
	"Comment": "this flag indicates if the dialog should be disposed if a pointerreleased event occurred out of the dialog content.",
	"Method": "boolean isDisposeWhenPointerOutOfBounds(){\r\n    return disposeWhenPointerOutOfBounds;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.compaction.MajorCompactionTask.mergeReleased",
	"Comment": "updates the new compact segment with entries that were released during compaction.",
	"Method": "void mergeReleased(List<Segment> segments,List<OffsetPredicate> predicates,Segment compactSegment){\r\n    for (int i = 0; i < segments.size(); i++) {\r\n        mergeReleasedEntries(segments.get(i), predicates.get(i), compactSegment);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.Log.bindCrashProtection",
	"Comment": "binds pro based crash protection logic that will send out an email in case of an exception thrown on the edt",
	"Method": "void bindCrashProtection(boolean consumeError){\r\n    if (Display.getInstance().isSimulator()) {\r\n        return;\r\n    }\r\n    Display.getInstance().addEdtErrorHandler(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            if (consumeError) {\r\n                evt.consume();\r\n            }\r\n            p(\"Exception in \" + Display.getInstance().getProperty(\"AppName\", \"app\") + \" version \" + Display.getInstance().getProperty(\"AppVersion\", \"Unknown\"));\r\n            p(\"OS \" + Display.getInstance().getPlatformName());\r\n            p(\"Error \" + evt.getSource());\r\n            if (Display.getInstance().getCurrent() != null) {\r\n                p(\"Current Form \" + Display.getInstance().getCurrent().getName());\r\n            } else {\r\n                p(\"Before the first form!\");\r\n            }\r\n            e((Throwable) evt.getSource());\r\n            if (getUniqueDeviceKey() != null) {\r\n                sendLog();\r\n            }\r\n        }\r\n    });\r\n    crashBound = true;\r\n}"
}, {
	"Path": "com.codename1.io.Log.bindCrashProtection",
	"Comment": "binds pro based crash protection logic that will send out an email in case of an exception thrown on the edt",
	"Method": "void bindCrashProtection(boolean consumeError){\r\n    if (consumeError) {\r\n        evt.consume();\r\n    }\r\n    p(\"Exception in \" + Display.getInstance().getProperty(\"AppName\", \"app\") + \" version \" + Display.getInstance().getProperty(\"AppVersion\", \"Unknown\"));\r\n    p(\"OS \" + Display.getInstance().getPlatformName());\r\n    p(\"Error \" + evt.getSource());\r\n    if (Display.getInstance().getCurrent() != null) {\r\n        p(\"Current Form \" + Display.getInstance().getCurrent().getName());\r\n    } else {\r\n        p(\"Before the first form!\");\r\n    }\r\n    e((Throwable) evt.getSource());\r\n    if (getUniqueDeviceKey() != null) {\r\n        sendLog();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.isReverseSoftButtons",
	"Comment": "indicates whether softbuttons should be reversed from their default orientation",
	"Method": "boolean isReverseSoftButtons(){\r\n    return reverseSoftButtons;\r\n}"
}, {
	"Path": "com.codename1.components.SignatureComponent.initComponent",
	"Comment": "overridden to register the icon animation when the field is added to the form.",
	"Method": "void initComponent(){\r\n    super.initComponent();\r\n    getComponentForm().registerAnimated(iconAnimation);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLElement.setAttribute",
	"Comment": "adds the specified attribute and value to this element if it is supported for the element and has a valid value.",
	"Method": "int setAttribute(String attribute,String value){\r\n    if (id == TAG_UNSUPPORTED) {\r\n        return -1;\r\n    }\r\n    int attrId = -1;\r\n    int i = 0;\r\n    if (supportsCoreAttributes()) {\r\n        while ((attrId == -1) && (i < COMMON_ATTRIBUTES.length)) {\r\n            if (ATTRIBUTE_NAMES[COMMON_ATTRIBUTES[i]].equals(attribute)) {\r\n                attrId = COMMON_ATTRIBUTES[i];\r\n            } else {\r\n                i++;\r\n            }\r\n        }\r\n    }\r\n    i = 0;\r\n    while ((attrId == -1) && (i < TAG_ATTRIBUTES[id].length)) {\r\n        if (ATTRIBUTE_NAMES[TAG_ATTRIBUTES[id][i]].equals(attribute)) {\r\n            attrId = TAG_ATTRIBUTES[id][i];\r\n        } else {\r\n            i++;\r\n        }\r\n    }\r\n    if (attrId == -1) {\r\n        return HTMLCallback.ERROR_ATTRIBUTE_NOT_SUPPORTED;\r\n    } else {\r\n        if (isValid(ATTRIBUTE_TYPES[attrId], value)) {\r\n            setAttribute(new Integer(attrId), value);\r\n        } else {\r\n            return HTMLCallback.ERROR_ATTIBUTE_VALUE_INVALID;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Motion.createEaseMotion",
	"Comment": "equivalent to createcubicbeziermotion with 0f, 0.25f, 0.25f, 1 as arguments.",
	"Method": "Motion createEaseMotion(int sourceValue,int destinationValue,int duration){\r\n    return createCubicBezierMotion(sourceValue, destinationValue, duration, 0f, 0.25f, 0.25f, 1.0f);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.setPollingFrequency",
	"Comment": "sets the frequency for polling the server in case of polling based push notification",
	"Method": "void setPollingFrequency(int freq){\r\n    impl.setPollingFrequency(freq);\r\n}"
}, {
	"Path": "com.codename1.impl.javase.JavaSEPort.transformPoint",
	"Comment": "transforms a point and stores the result in a provided array.",
	"Method": "void transformPoint(Object nativeTransform,float[] in,float[] out){\r\n    AffineTransform t = (AffineTransform) nativeTransform;\r\n    t.transform(in, 0, out, 0, 1);\r\n    clamp(out);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.setSkip",
	"Comment": "sets how many cells in the grid that should be skipped before the component that this constraint belongs to.\tnote that only the first component will be checked for this property.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "void setSkip(int cells){\r\n    this.skip = cells;\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.getSelectCommand",
	"Comment": "the selectcommand is the command to invoke when a component has foucs inthird soft button state.",
	"Method": "Command getSelectCommand(){\r\n    return selectCommand;\r\n}"
}, {
	"Path": "com.codename1.properties.ListProperty.asExplodedList",
	"Comment": "returns a copy of the content as a new list but if the value is a propertybusinessobject it will be converted to a map",
	"Method": "List<Object> asExplodedList(){\r\n    ArrayList<Object> aa = new ArrayList<Object>();\r\n    for (T t : value) {\r\n        if (t instanceof PropertyBusinessObject) {\r\n            aa.add(((PropertyBusinessObject) t).getPropertyIndex().toMapRepresentation());\r\n        } else {\r\n            aa.add(t);\r\n        }\r\n    }\r\n    return aa;\r\n}"
}, {
	"Path": "com.codename1.ui.Tabs.setTextPosition",
	"Comment": "invokes set text position on the given tab, the tab should be a toggle button radio by default butcan be anything",
	"Method": "void setTextPosition(Component tabComponent,int textPosition){\r\n    ((Button) tabComponent).setTextPosition(textPosition);\r\n}"
}, {
	"Path": "cognitivej.vision.overlay.builder.ImageOverlayBuilder.toDiskAndLaunchViewer",
	"Comment": "saves the image to the disk and launches the default viewer for images.",
	"Method": "ImageOverlayBuilder toDiskAndLaunchViewer(File file){\r\n    toDisk(file);\r\n    try {\r\n        Desktop.getDesktop().open(file);\r\n        Utils.waitFor(3, TimeUnit.SECONDS);\r\n    } catch (IOException e) {\r\n        throw new CognitiveException(\"Could not open image\", e);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.Button.setRolloverIcon",
	"Comment": "indicates the icon that is displayed on the button when the button is in rolled over state",
	"Method": "void setRolloverIcon(Image rolloverIcon){\r\n    this.rolloverIcon = rolloverIcon;\r\n    setShouldCalcPreferredSize(true);\r\n    checkAnimation();\r\n    repaint();\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.MigLayout.isManagingComponent",
	"Comment": "returns if this layout manager is currently managing this component.",
	"Method": "boolean isManagingComponent(Component c){\r\n    return scrConstrMap.containsKey(c);\r\n}"
}, {
	"Path": "com.codename1.components.MultiButton.setInvertFirstTwoEntries",
	"Comment": "inverts the order of the first two entries so the second line appears first. this only works in horizontal mode!",
	"Method": "void setInvertFirstTwoEntries(boolean b){\r\n    if (b != invert) {\r\n        invert = b;\r\n        if (isHorizontalLayout()) {\r\n            Container c = firstRow.getParent();\r\n            c.removeComponent(secondRow);\r\n            if (invert) {\r\n                c.addComponent(BorderLayout.WEST, secondRow);\r\n            } else {\r\n                c.addComponent(BorderLayout.EAST, secondRow);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.isAutoAdjustDialogSize",
	"Comment": "indicates whether codename one should try to automatically adjust a showing dialog sizewhen a screen size change event occurs",
	"Method": "boolean isAutoAdjustDialogSize(){\r\n    return autoAdjustDialogSize;\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.setListModel",
	"Comment": "allows a subclass to set the list model for the given component",
	"Method": "boolean setListModel(List cmp,boolean setListModel,ContainerList cmp){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.containsAll",
	"Comment": "checks if the result set contains all of the components found in the providedcollection.",
	"Method": "boolean containsAll(Collection<?> c){\r\n    return resultsImpl().containsAll(c);\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.ThumbnailParameter.isKeepAspectRatio",
	"Comment": "returns whether or not the thumbnail is to maintain the aspect ratio of\tthe source image when creating the thumbnail.",
	"Method": "boolean isKeepAspectRatio(){\r\n    return keepAspectRatio;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractList.listIterator",
	"Comment": "returns a list iterator on the elements of this list. the elements areiterated in the same order as they occur in the list. the iterationstarts at the specified location.",
	"Method": "ListIterator<E> listIterator(int location,ListIterator<E> listIterator,ListIterator<E> listIterator,int location){\r\n    return new FullListIterator(location);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Arrays.copySwap",
	"Comment": "copies object from one array to another array with reverse of objectsorder. source and destination arrays may be the same.",
	"Method": "void copySwap(Object[] src,int from,Object[] dst,int to,int len){\r\n    if (src == dst && from + len > to) {\r\n        int new_to = to + len - 1;\r\n        for (; from < to; from++, new_to--, len--) {\r\n            dst[new_to] = src[from];\r\n        }\r\n        for (; len > 1; from++, new_to--, len -= 2) {\r\n            swap(from, new_to, dst);\r\n        }\r\n    } else {\r\n        to = to + len - 1;\r\n        for (; len > 0; from++, to--, len--) {\r\n            dst[to] = src[from];\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.util.MathUtil.nextAfter",
	"Comment": "returns the next representable floating point number after the firstargument in the direction of the second argument.",
	"Method": "double nextAfter(double start,double direction){\r\n    if (Double.isNaN(start) || Double.isNaN(direction)) {\r\n        return Double.NaN;\r\n    }\r\n    if (start == direction) {\r\n        return direction;\r\n    }\r\n    final double absStart = Math.abs(start);\r\n    final double absDir = Math.abs(direction);\r\n    final boolean toZero = !isSameSign(start, direction) || absDir < absStart;\r\n    if (toZero) {\r\n        if (absStart == Double.MIN_VALUE) {\r\n            return copySign(0.0, start);\r\n        }\r\n        if (Double.isInfinite(absStart)) {\r\n            return copySign(Double.MAX_VALUE, start);\r\n        }\r\n        return copySign(Double.longBitsToDouble(Double.doubleToLongBits(absStart) - 1L), start);\r\n    } else {\r\n        if (start == 0.0) {\r\n            return copySign(Double.MIN_VALUE, direction);\r\n        }\r\n        if (absStart == Double.MAX_VALUE) {\r\n            return copySign(Double.POSITIVE_INFINITY, start);\r\n        }\r\n        return copySign(Double.longBitsToDouble(Double.doubleToLongBits(absStart) + 1L), start);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.CN.canExecute",
	"Comment": "returns true if executing this url should work, returns false if it will notand null if this is unknown.",
	"Method": "Boolean canExecute(String url){\r\n    return Display.impl.canExecute(url);\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Transition.cleanup",
	"Comment": "optional operation to cleanup the garbage left over by a running transition",
	"Method": "void cleanup(){\r\n    source = null;\r\n    destination = null;\r\n}"
}, {
	"Path": "com.codename1.javascript.JavascriptContext.setBrowserComponent",
	"Comment": "sets the browsercomponent on which this javascript context runs.",
	"Method": "void setBrowserComponent(BrowserComponent c){\r\n    if (c != browser) {\r\n        if (browser != null) {\r\n            this.uninstall();\r\n        }\r\n        browser = c;\r\n        if (browser != null) {\r\n            this.install();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.table.AbstractTableModel.setValidator",
	"Comment": "a validator can be defined here so a validation constraint can bind to a table model cell",
	"Method": "void setValidator(Validator validator){\r\n    this.validator = validator;\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.DateTimeSpinner3D.setHourRange",
	"Comment": "sets the hour range to show for the time selector.setting the range will automatically switchthe time to 24 hour format.",
	"Method": "void setHourRange(int min,int max){\r\n    if (time == null)\r\n        return;\r\n    if (min >= 0 && max > min && isShowMeridiem()) {\r\n        time.setShowMeridiem(false);\r\n    }\r\n    time.setHourRange(min, max);\r\n}"
}, {
	"Path": "io.atomix.copycat.client.session.ClientSequencer.sequenceEvent",
	"Comment": "sequences an event.this method relies on the session event protocol to ensure that events are applied in sequential order.when an event is received, if no operations are outstanding, the event is immediately completed sincethe event could not have occurred concurrently with any other operation. otherwise, the event is queuedand the next response in the sequence of responses is checked to determine whether the event can becompleted.",
	"Method": "void sequenceEvent(PublishRequest request,Runnable callback){\r\n    if (requestSequence == responseSequence) {\r\n        LOGGER.trace(\"{} - Completing {}\", state.getSessionId(), request);\r\n        callback.run();\r\n        eventIndex = request.eventIndex();\r\n    } else {\r\n        eventCallbacks.add(new EventCallback(request, callback));\r\n        completeResponses();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Label.getMaterialIcon",
	"Comment": "returns the material icon assigned to this component or 0 if not applicable",
	"Method": "char getMaterialIcon(){\r\n    return materialIcon;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.index.support.AbstractAttributeIndex.getAttribute",
	"Comment": "returns the attribute which was supplied to the constructor.",
	"Method": "Attribute<O, A> getAttribute(){\r\n    return attribute;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.getDisplayLock",
	"Comment": "returns a lock object which can be synchronized against, this lock is usedby the edt.",
	"Method": "Object getDisplayLock(){\r\n    return displayLock;\r\n}"
}, {
	"Path": "java.lang.Runtime.getRuntime",
	"Comment": "returns the runtime object associated with the current java application. most of the methods of class runtime are instance methods and must be invoked with respect to the current runtime object.",
	"Method": "java.lang.Runtime getRuntime(){\r\n    return instance;\r\n}"
}, {
	"Path": "com.codename1.ui.TextComponent.constraint",
	"Comment": "sets the constraint for text input matching the constraints from the text area class",
	"Method": "TextComponent constraint(int constraint){\r\n    field.setConstraint(constraint);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.CustomFont.drawString",
	"Comment": "draw the given char array using the current font and color in the x,y coordinates",
	"Method": "void drawString(Graphics g,String str,int x,int y){\r\n    if (Display.getInstance().isBidiAlgorithm()) {\r\n        int slen = str.length();\r\n        for (int i = 0; i < slen; i++) {\r\n            if (Display.getInstance().isRTL(str.charAt(i))) {\r\n                str = Display.getInstance().convertBidiLogicalToVisual(str);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    initColor(g);\r\n    int clipX = g.getClipX();\r\n    int clipY = g.getClipY();\r\n    int clipWidth = g.getClipWidth();\r\n    int clipHeight = g.getClipHeight();\r\n    if (clipY <= y + getHeight() && clipY + clipHeight >= y) {\r\n        char c;\r\n        int slen = str.length();\r\n        for (int i = 0; i < slen; i++) {\r\n            c = str.charAt(i);\r\n            int position = charsets.indexOf(c);\r\n            if (position < 0) {\r\n                continue;\r\n            }\r\n            g.clipRect(x, y, charWidth[position], imageHeight);\r\n            if (g.getClipWidth() > 0 && g.getClipHeight() > 0) {\r\n                g.drawImage(cache, x - cutOffsets[position], y);\r\n            }\r\n            x += charWidth[position];\r\n            g.setClip(clipX, clipY, clipWidth, clipHeight);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.xml.XMLParser.startTag",
	"Comment": "invoked when a tag is opened, this method should return true to processthe tag or return false to skip the tag.this callback method is invoked only on the eventparser.",
	"Method": "boolean startTag(String tag){\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.setFormState",
	"Comment": "sets the state of the current form to which we are returing as partof the navigation logic. when a back command is pressed this formstate should be restored, it was obtained via getformstate.the default implementation of this method restores focus and list selection.",
	"Method": "void setFormState(Form f,Hashtable state){\r\n    setContainerStateImpl(f, state);\r\n}"
}, {
	"Path": "com.codename1.io.Util.xorEncode",
	"Comment": "the inverse method of xordecode, this is normally unnecessary and is here mostly for completeness",
	"Method": "String xorEncode(String s){\r\n    try {\r\n        byte[] dat = s.getBytes(\"UTF-8\");\r\n        for (int iter = 0; iter < dat.length; iter++) {\r\n            dat[iter] = (byte) (dat[iter] ^ (iter % 254 + 1));\r\n        }\r\n        return Base64.encodeNoNewline(dat);\r\n    } catch (UnsupportedEncodingException err) {\r\n        err.printStackTrace();\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.setPageStyle",
	"Comment": "sets the style of the page, allowing for example to set transparency to the main page.this applies not only to the current page, but rather to all pages created with this htmlcomponent instance.if both a uiid and a pagestyle were set, the style overrides the uiid.",
	"Method": "void setPageStyle(Style pageStyle){\r\n    this.pageStyle = pageStyle;\r\n    if ((mainContainer != null) && (pageStyle != null)) {\r\n        applyPageStyle();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.android.CodenameOneActivity.isBillingEnabled",
	"Comment": "overriden by subclasses to return true if billing is supported on thisbuild",
	"Method": "boolean isBillingEnabled(){\r\n    return false;\r\n}"
}, {
	"Path": "mondrian.olap.Util.convertStackToString",
	"Comment": "converts an error into an array of strings, the most recent error first.",
	"Method": "String[] convertStackToString(Throwable e){\r\n    List<String> list = new ArrayList<String>();\r\n    while (e != null) {\r\n        String sMsg = getErrorMessage(e);\r\n        list.add(sMsg);\r\n        e = e.getCause();\r\n    }\r\n    return list.toArray(new String[list.size()]);\r\n}"
}, {
	"Path": "com.codename1.io.NetworkManager.updateThreadCount",
	"Comment": "sets the number of network threads and restarts the network threads",
	"Method": "void updateThreadCount(int threadCount){\r\n    this.threadCount = threadCount;\r\n    shutdown();\r\n    start();\r\n}"
}, {
	"Path": "com.codename1.ui.Display.setAutoFoldVKBOnFormSwitch",
	"Comment": "normally codename one folds the vkb when switching forms this field allows usto block that behavior.",
	"Method": "void setAutoFoldVKBOnFormSwitch(boolean autoFoldVKBOnFormSwitch){\r\n    this.autoFoldVKBOnFormSwitch = autoFoldVKBOnFormSwitch;\r\n}"
}, {
	"Path": "com.codename1.impl.blackberry.BlackBerryImplementation.isMinimizeOnEnd",
	"Comment": "indicates whether the application should minimize or exit when the end key is pressed",
	"Method": "boolean isMinimizeOnEnd(){\r\n    return minimizeOnEnd;\r\n}"
}, {
	"Path": "mondrian.olap.Util.dbTimeMillis",
	"Comment": "returns the cumulative amount of time spent accessing the database.",
	"Method": "long dbTimeMillis(){\r\n    return databaseMillis;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.setDefaultSmoothScrolling",
	"Comment": "indicates whether lists and containers should have smooth scrolling by default",
	"Method": "void setDefaultSmoothScrolling(boolean defaultSmoothScrolling){\r\n    this.defaultSmoothScrolling = defaultSmoothScrolling;\r\n}"
}, {
	"Path": "com.codename1.ui.ComboBox.setActAsSpinnerDialog",
	"Comment": "when this flag is active the combo box acts as a button that opens a dialog that looks like a spinnerthis allows creating user interfaces for touch devices where a spinner ui approach is more common thana combo box paradigm.",
	"Method": "void setActAsSpinnerDialog(boolean actAsSpinnerDialog){\r\n    this.actAsSpinnerDialog = actAsSpinnerDialog;\r\n}"
}, {
	"Path": "com.codename1.payments.v3.Inventory.getPurchase",
	"Comment": "returns purchase information for a given product, or null if there is no purchase.",
	"Method": "Purchase getPurchase(String sku){\r\n    return mPurchaseMap.get(sku);\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.recordHandledException",
	"Comment": "log handled exception to report it to server as non fatal crash",
	"Method": "Countly recordHandledException(Exception exception,Countly recordHandledException,Throwable exception){\r\n    return recordException(exception, true);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.installDefaultPainter",
	"Comment": "allows subclasses to create their own custom style types and install the background painter into them",
	"Method": "void installDefaultPainter(Style s){\r\n    if (s.getBgPainter() == null) {\r\n        s.setBgPainter(new BGPainter(s));\r\n    }\r\n}"
}, {
	"Path": "com.codename1.payment.Purchase.setReceiptStore",
	"Comment": "installs a given receipt store to handle receipt management",
	"Method": "void setReceiptStore(ReceiptStore store){\r\n    receiptStore = store;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.getBundle",
	"Comment": "the resource bundle allows us to implicitly localize the ui on the fly, once itsinstalled all internal application strings query the resource bundle and extracttheir values from this table if applicable.",
	"Method": "Map<String, String> getBundle(){\r\n    return bundle;\r\n}"
}, {
	"Path": "io.atomix.copycat.client.session.ClientSessionState.getCommandResponse",
	"Comment": "returns the last command sequence number for which a response has been received.",
	"Method": "long getCommandResponse(){\r\n    return commandResponse;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.ConstraintParser.parseAlignKeywords",
	"Comment": "parses alignment keywords and returns the appropriateunitvalue.",
	"Method": "UnitValue parseAlignKeywords(String s,boolean isHor){\r\n    if (startsWithLenient(s, \"center\", 1, false) != -1) {\r\n        return UnitValue.CENTER;\r\n    }\r\n    if (isHor) {\r\n        if (startsWithLenient(s, \"left\", 1, false) != -1) {\r\n            return UnitValue.LEFT;\r\n        }\r\n        if (startsWithLenient(s, \"right\", 1, false) != -1) {\r\n            return UnitValue.RIGHT;\r\n        }\r\n        if (startsWithLenient(s, \"leading\", 4, false) != -1) {\r\n            return UnitValue.LEADING;\r\n        }\r\n        if (startsWithLenient(s, \"trailing\", 5, false) != -1) {\r\n            return UnitValue.TRAILING;\r\n        }\r\n        if (startsWithLenient(s, \"label\", 5, false) != -1) {\r\n            return UnitValue.LABEL;\r\n        }\r\n    } else {\r\n        if (startsWithLenient(s, \"baseline\", 4, false) != -1) {\r\n            return UnitValue.BASELINE_IDENTITY;\r\n        }\r\n        if (startsWithLenient(s, \"top\", 1, false) != -1) {\r\n            return UnitValue.TOP;\r\n        }\r\n        if (startsWithLenient(s, \"bottom\", 1, false) != -1) {\r\n            return UnitValue.BOTTOM;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.push.PushContent.getMetaData",
	"Comment": "gets the metadata associated with push.this is hidden content not shown to the user.",
	"Method": "String getMetaData(){\r\n    return metaData;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayeredLayout.setInsetBottom",
	"Comment": "sets the top inset for this component to the prescribed value.",
	"Method": "LayeredLayout setInsetBottom(Component cmp,String inset){\r\n    getOrCreateConstraint(cmp).bottom().setValue(inset);\r\n    return this;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.translator.NameTranslator.translateMethodDescriptor",
	"Comment": "translates a descriptor, specifically. only translates names in the\tdescriptor, if they are represented by class mirrors.",
	"Method": "String translateMethodDescriptor(String descriptor){\r\n    Type[] argTypes = Type.getArgumentTypes(descriptor);\r\n    for (int i = 0; i < argTypes.length; ++i) {\r\n        argTypes[i] = getMirrorType(argTypes[i]);\r\n    }\r\n    final Type returnType = getMirrorType(Type.getReturnType(descriptor));\r\n    return Type.getMethodDescriptor(returnType, argTypes);\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.logException",
	"Comment": "log handled exception to report it to server as non fatal crash",
	"Method": "Countly logException(Exception exception){\r\n    return recordException(exception, true);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.localize",
	"Comment": "localizes the given string from the resource bundle if such a string exists in theresource bundle. if no key exists in the bundle then or a bundle is not installedthe default value is returned.",
	"Method": "String localize(String key,String defaultValue){\r\n    if (bundle != null && key != null) {\r\n        Object o = bundle.get(key);\r\n        if (o != null) {\r\n            return (String) o;\r\n        }\r\n    }\r\n    return defaultValue;\r\n}"
}, {
	"Path": "org.conscrypt.ActiveSession.onPeerCertificatesReceived",
	"Comment": "configures the peer information once it has been received by the handshake.",
	"Method": "void onPeerCertificatesReceived(String peerHost,int peerPort,X509Certificate[] peerCertificates){\r\n    configurePeer(peerHost, peerPort, peerCertificates);\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.showMenu",
	"Comment": "this method shows the menu on the form.the method creates a dialog with the commands and calls showmenudialog.the method blocks until the user dispose the dialog.",
	"Method": "void showMenu(){\r\n    final Dialog d = new Dialog(\"Menu\", \"\");\r\n    d.setDisposeWhenPointerOutOfBounds(true);\r\n    d.setMenu(true);\r\n    d.addOrientationListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            d.dispose();\r\n        }\r\n    });\r\n    d.setTransitionInAnimator(transitionIn);\r\n    d.setTransitionOutAnimator(transitionOut);\r\n    d.setLayout(new BorderLayout());\r\n    d.setScrollable(false);\r\n    ((Form) d).getMenuBar().commandList = createCommandComponent(commands);\r\n    if (menuCellRenderer != null && ((Form) d).getMenuBar().commandList instanceof List) {\r\n        ((List) ((Form) d).getMenuBar().commandList).setListCellRenderer(menuCellRenderer);\r\n    }\r\n    d.getContentPane().getStyle().setMargin(0, 0, 0, 0);\r\n    d.addComponent(BorderLayout.CENTER, ((Form) d).getMenuBar().commandList);\r\n    if (thirdSoftButton) {\r\n        d.addCommand(selectMenuItem);\r\n        d.addCommand(cancelMenuItem);\r\n    } else {\r\n        d.addCommand(cancelMenuItem);\r\n        if (soft.length > 1) {\r\n            d.addCommand(selectMenuItem);\r\n        }\r\n    }\r\n    d.setClearCommand(cancelMenuItem);\r\n    d.setBackCommand(cancelMenuItem);\r\n    if (((Form) d).getMenuBar().commandList instanceof List) {\r\n        ((List) ((Form) d).getMenuBar().commandList).addActionListener(((Form) d).getMenuBar());\r\n    }\r\n    menuDisplaying = true;\r\n    Command result = showMenuDialog(d);\r\n    menuDisplaying = false;\r\n    if (result != cancelMenuItem) {\r\n        Command c = null;\r\n        if (result == selectMenuItem) {\r\n            c = getComponentSelectedCommand(((Form) d).getMenuBar().commandList);\r\n            if (c != null) {\r\n                ActionEvent e = new ActionEvent(c, ActionEvent.Type.Command);\r\n                c.actionPerformed(e);\r\n            }\r\n        } else {\r\n            c = result;\r\n            if (!isTouchMenus()) {\r\n                c = result;\r\n                if (c != null) {\r\n                    ActionEvent e = new ActionEvent(c, ActionEvent.Type.Command);\r\n                    c.actionPerformed(e);\r\n                }\r\n            }\r\n        }\r\n        if (c != null) {\r\n            parent.actionCommandImpl(c);\r\n        }\r\n    }\r\n    if (((Form) d).getMenuBar().commandList instanceof List) {\r\n        ((List) ((Form) d).getMenuBar().commandList).removeActionListener(((Form) d).getMenuBar());\r\n    }\r\n    Form upcoming = Display.getInstance().getCurrentUpcoming();\r\n    if (upcoming == parent) {\r\n        d.disposeImpl();\r\n    } else {\r\n        parent.tint = (upcoming instanceof Dialog);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.showMenu",
	"Comment": "this method shows the menu on the form.the method creates a dialog with the commands and calls showmenudialog.the method blocks until the user dispose the dialog.",
	"Method": "void showMenu(){\r\n    d.dispose();\r\n}"
}, {
	"Path": "com.codename1.ui.Form.getTransitionOutAnimator",
	"Comment": "this property allows us to define a an animation that will draw the transition forexiting this form. a transition is an animation that would occur when switching from one form to another.",
	"Method": "Transition getTransitionOutAnimator(){\r\n    return transitionOutAnimator;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.shadowBlur",
	"Comment": "the blur on the shadow this is the standard gaussian blur radius",
	"Method": "RoundRectBorder shadowBlur(float shadowBlur){\r\n    this.shadowBlur = shadowBlur;\r\n    return this;\r\n}"
}, {
	"Path": "org.conscrypt.java.security.TestKeyStore.getIntermediateCa2",
	"Comment": "return an intermediate ca that can be used to issue new certificates.",
	"Method": "TestKeyStore getIntermediateCa2(){\r\n    initCerts();\r\n    return INTERMEDIATE_CA_2;\r\n}"
}, {
	"Path": "android.support.v4.widget.SearchViewCompat.isSubmitButtonEnabled",
	"Comment": "returns whether the submit button is enabled when necessary or never displayed.",
	"Method": "boolean isSubmitButtonEnabled(View searchView,boolean isSubmitButtonEnabled,View searchView,boolean isSubmitButtonEnabled,View searchView,boolean isSubmitButtonEnabled,View searchView){\r\n    return IMPL.isSubmitButtonEnabled(searchView);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayeredLayout.setReferencePositionBottom",
	"Comment": "sets the bottom inset reference position.only applicable if the top inset has a referencecomponent specified.",
	"Method": "LayeredLayout setReferencePositionBottom(Component cmp,float position){\r\n    getOrCreateConstraint(cmp).bottom().referencePosition(position);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.components.MediaPlayer.hideControls",
	"Comment": "hides the controls for this media player.if the player is set to use native controls, then this will hide the native controls.otherwise it hides the lightweight controls.",
	"Method": "void hideControls(){\r\n    if (showControls) {\r\n        showControls = false;\r\n        if (isInitialized()) {\r\n            buttonsBar.setVisible(false);\r\n            buttonsBar.setHidden(true);\r\n            animateLayoutFade(300, 0);\r\n        }\r\n    }\r\n    if (video != null && usesNativeVideoControls()) {\r\n        video.setVariable(Media.VARIABLE_NATIVE_CONTRLOLS_EMBEDDED, false);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.list.ContainerList.getActionListeners",
	"Comment": "this method allows extracting the action listeners from the current list",
	"Method": "Vector getActionListeners(){\r\n    return dispatcher.getListenerVector();\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.getYield",
	"Comment": "returns the amount of time to yield for other processes, this is an implicit method that automatically generates values for lower priority connections",
	"Method": "int getYield(){\r\n    if (priority > PRIORITY_NORMAL) {\r\n        return -1;\r\n    }\r\n    if (priority == PRIORITY_NORMAL) {\r\n        return 20;\r\n    }\r\n    return 40;\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.isReverseSoftButtons",
	"Comment": "allows an individual form to reverse the layout direction of the softbuttons, this method is rtlsensitive and might reverse the result based on rtl state",
	"Method": "boolean isReverseSoftButtons(){\r\n    LookAndFeel lf = parent.getUIManager().getLookAndFeel();\r\n    if (isRTL()) {\r\n        return !lf.isReverseSoftButtons();\r\n    }\r\n    return lf.isReverseSoftButtons();\r\n}"
}, {
	"Path": "com.codename1.components.SplitPane.getBottomOrRightComponent",
	"Comment": "gets the component that is currently placed in the bottom or right of the split pane.",
	"Method": "Component getBottomOrRightComponent(){\r\n    for (Component c : bottomOrRight) {\r\n        return c;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.tryDeregisterAnimated",
	"Comment": "removes the internal animation. this method may be overriden by sublcasses to block automatic removal",
	"Method": "void tryDeregisterAnimated(){\r\n    deregisterAnimatedInternal();\r\n}"
}, {
	"Path": "com.codename1.properties.ListProperty.removeAll",
	"Comment": "removes from the list all values from the given collection and fires a change event if the list has changed",
	"Method": "K removeAll(Collection<? extends T> v){\r\n    if (value.removeAll(v)) {\r\n        firePropertyChanged();\r\n    }\r\n    return (K) parent.parent;\r\n}"
}, {
	"Path": "com.codename1.location.Location.getDistanceTo",
	"Comment": "gets the distance in metres from the current location to another location.",
	"Method": "double getDistanceTo(Location l2){\r\n    return haversine(getLatitude(), getLongitude(), l2.getLatitude(), l2.getLongitude()) * 1000;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.isThemeConstant",
	"Comment": "returns a theme constant defined in the resource editor as a boolean value",
	"Method": "boolean isThemeConstant(String constantName,boolean def,Boolean isThemeConstant,String constantName){\r\n    String c = getThemeConstant(constantName, null);\r\n    if (c == null) {\r\n        return null;\r\n    }\r\n    if (c.equalsIgnoreCase(\"true\") || c.equals(\"1\")) {\r\n        return Boolean.TRUE;\r\n    }\r\n    return Boolean.FALSE;\r\n}"
}, {
	"Path": "ly.count.android.sdk.CountlyStore.removeEvents",
	"Comment": "removes the specified events from the local store. does nothing if the event collectionis null or empty.",
	"Method": "void removeEvents(Collection<Event> eventsToRemove){\r\n    if (eventsToRemove != null && eventsToRemove.size() > 0) {\r\n        final List<Event> events = eventsList();\r\n        if (events.removeAll(eventsToRemove)) {\r\n            preferences_.edit().putString(EVENTS_PREFERENCE, joinEvents(events, DELIMITER)).apply();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.numColors",
	"Comment": "returns the number of colors applicable on the device, note that the apidoes not support gray scale devices.",
	"Method": "int numColors(){\r\n    return 65536;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.SegmentFile.createSegmentFile",
	"Comment": "creates a segment file for the given directory, log name, segment id, and segment version.",
	"Method": "File createSegmentFile(String name,File directory,long id,long version){\r\n    return new File(directory, String.format(\"%s-%d-%d.log\", Assert.notNull(name, \"name\"), id, version));\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.getComponentCustomStyle",
	"Comment": "returns a custom style for the component with the given id, this method always returns anew instance. custom styles allow us to install application specific or component specificstyle attributes such as pressed, disabled, hover etc.",
	"Method": "Style getComponentCustomStyle(String id,String type){\r\n    return getComponentStyleImpl(id, false, type + \"#\");\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Motion.finish",
	"Comment": "sends the motion to the end time instantly which is useful for flushing an animation",
	"Method": "void finish(){\r\n    if (!isFinished()) {\r\n        startTime = System.currentTimeMillis() - duration;\r\n        currentMotionTime = -1;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.isImmediateInputMode",
	"Comment": "returns true if the given input mode should commit immediately or wait for the commit timeout",
	"Method": "boolean isImmediateInputMode(String mode){\r\n    return \"123\".equals(mode);\r\n}"
}, {
	"Path": "com.googlecode.cqengine.attribute.ReflectiveAttribute.forField",
	"Comment": "returns an attribute which reads values from the field indicated using reflection.",
	"Method": "ReflectiveAttribute<O, A> forField(Class<O> objectType,Class<A> fieldType,String fieldName){\r\n    return new ReflectiveAttribute<O, A>(objectType, fieldType, fieldName);\r\n}"
}, {
	"Path": "com.codename1.ui.util.EditableResources.overrideResource",
	"Comment": "copies the value from the base to the override resource as a starting point",
	"Method": "void overrideResource(String name){\r\n    overrideResource.setResource(name, getResourceType(name), getResourceObject(name));\r\n}"
}, {
	"Path": "com.codename1.components.ImageViewer.getImageList",
	"Comment": "returns the list model containing the images in the we can swipe through",
	"Method": "ListModel<Image> getImageList(){\r\n    return swipeableImages;\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.placeButtonCommands",
	"Comment": "places the given commands in the dialog command area, this is very useful for touch devices.",
	"Method": "void placeButtonCommands(Command[] cmds){\r\n    buttonCommands = cmds;\r\n    Container buttonArea;\r\n    if (getUIManager().isThemeConstant(\"dlgCommandGridBool\", false)) {\r\n        buttonArea = new Container(new GridLayout(1, cmds.length));\r\n    } else {\r\n        buttonArea = new Container(new FlowLayout(CENTER));\r\n    }\r\n    buttonArea.setUIID(\"DialogCommandArea\");\r\n    String uiid = getUIManager().getThemeConstant(\"dlgButtonCommandUIID\", null);\r\n    addButtonBar(buttonArea);\r\n    if (cmds.length > 0) {\r\n        String lineColor = getUIManager().getThemeConstant(\"dlgInvisibleButtons\", null);\r\n        if (cmds.length > 3) {\r\n            lineColor = null;\r\n        }\r\n        int largest = Integer.parseInt(getUIManager().getThemeConstant(\"dlgCommandButtonSizeInt\", \"0\"));\r\n        for (int iter = 0; iter < cmds.length; iter++) {\r\n            Button b = new Button(cmds[iter]);\r\n            if (uiid != null) {\r\n                b.setUIID(uiid);\r\n            }\r\n            if (Button.isCapsTextDefault()) {\r\n                b.setCapsText(true);\r\n            }\r\n            largest = Math.max(b.getPreferredW(), largest);\r\n            if (lineColor != null && lineColor.length() > 0) {\r\n                int color = Integer.parseInt(lineColor, 16);\r\n                Border brd = null;\r\n                if (iter < cmds.length - 1) {\r\n                    brd = Border.createCompoundBorder(Border.createLineBorder(1, color), null, null, Border.createLineBorder(1, color));\r\n                } else {\r\n                    brd = Border.createCompoundBorder(Border.createLineBorder(1, color), null, null, null);\r\n                }\r\n                b.getUnselectedStyle().setBorder(brd);\r\n                b.getSelectedStyle().setBorder(brd);\r\n                b.getPressedStyle().setBorder(brd);\r\n            }\r\n            buttonArea.addComponent(b);\r\n        }\r\n        for (int iter = 0; iter < cmds.length; iter++) {\r\n            buttonArea.getComponentAt(iter).setPreferredW(largest);\r\n        }\r\n        buttonArea.getComponentAt(0).requestFocus();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.services.ImageDownloadService.addErrorListener",
	"Comment": "binds an error listener that will fire an instance of networkevent with an errorfor a specific fetch operation if applicable",
	"Method": "void addErrorListener(ActionListener listener){\r\n    if (onErrorListeners == null) {\r\n        onErrorListeners = new EventDispatcher();\r\n    }\r\n    onErrorListeners.addListener(listener);\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.setAutoAdjustDialogSize",
	"Comment": "indicates whether codename one should try to automatically adjust a showing dialog sizewhen a screen size change event occurs",
	"Method": "void setAutoAdjustDialogSize(boolean a){\r\n    autoAdjustDialogSize = a;\r\n}"
}, {
	"Path": "com.codename1.ui.List.getMinElementHeight",
	"Comment": "minimum number of elements shown in a list, this member is used to calculatethe list preferred size. if the number of elements in the model is smaller thanthis then this value is used in the calculations.",
	"Method": "int getMinElementHeight(){\r\n    return minElementHeight;\r\n}"
}, {
	"Path": "com.codename1.io.CSVParser.parse",
	"Comment": "parses input from the given reader and returns the tokens broken into rows and columns",
	"Method": "String[][] parse(InputStream r,String[][] parse,InputStream r,String encoding,String[][] parse,Reader r){\r\n    currentReader = r;\r\n    StringBuilder stringBuf = new StringBuilder();\r\n    boolean isQuoteMode = false;\r\n    Vector returnValue = new Vector();\r\n    Vector currentVector = new Vector();\r\n    returnValue.addElement(currentVector);\r\n    int currentChar = nextChar();\r\n    while (currentChar > -1) {\r\n        if (isQuoteMode) {\r\n            if (currentChar == '\"') {\r\n                int next = peekNextChar();\r\n                if (next == '\"') {\r\n                    stringBuf.append('\"');\r\n                    nextChar();\r\n                } else {\r\n                    isQuoteMode = false;\r\n                }\r\n            } else {\r\n                stringBuf.append((char) currentChar);\r\n            }\r\n        } else {\r\n            if (stringBuf.length() == 0) {\r\n                if (currentChar == '\"') {\r\n                    isQuoteMode = true;\r\n                    currentChar = nextChar();\r\n                    continue;\r\n                }\r\n            }\r\n            if (currentChar == separatorChar) {\r\n                currentVector.addElement(stringBuf.toString());\r\n                stringBuf.setLength(0);\r\n                currentChar = nextChar();\r\n                continue;\r\n            }\r\n            if (currentChar == 10 || currentChar == 13) {\r\n                while (currentChar == 10 || currentChar == 13) {\r\n                    currentChar = nextChar();\r\n                }\r\n                currentVector.addElement(stringBuf.toString());\r\n                stringBuf.setLength(0);\r\n                currentVector = new Vector();\r\n                returnValue.addElement(currentVector);\r\n                continue;\r\n            }\r\n            stringBuf.append((char) currentChar);\r\n        }\r\n        currentChar = nextChar();\r\n    }\r\n    if (stringBuf.length() > 0) {\r\n        currentVector.addElement(stringBuf.toString());\r\n    }\r\n    String[][] actualReturnValue = new String[returnValue.size()][];\r\n    int arlen = actualReturnValue.length;\r\n    for (int iter = 0; iter < arlen; iter++) {\r\n        Vector e = (Vector) returnValue.elementAt(iter);\r\n        actualReturnValue[iter] = new String[e.size()];\r\n        int arlen2 = actualReturnValue[iter].length;\r\n        for (int i = 0; i < arlen2; i++) {\r\n            actualReturnValue[iter][i] = (String) e.elementAt(i);\r\n        }\r\n    }\r\n    currentReader.close();\r\n    currentReader = null;\r\n    return actualReturnValue;\r\n}"
}, {
	"Path": "com.codename1.maps.Coord.translate",
	"Comment": "create a new coord object which is translated with the given coordinates",
	"Method": "Coord translate(double latitude,double longitude,Coord translate,Coord coordinates){\r\n    return translate(coordinates.getLatitude(), coordinates.getLongitude());\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.DefaultLookAndFeel.getCheckBoxFocusImages",
	"Comment": "returns the images used to represent the checkbox when focused",
	"Method": "Image[] getCheckBoxFocusImages(){\r\n    return chkBoxImagesFocus;\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.isMenuShowing",
	"Comment": "this method will return true if the menu dialog is currently displaying",
	"Method": "boolean isMenuShowing(){\r\n    return menuDisplaying;\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.fireCloseEvent",
	"Comment": "fires a close event.this is fired when the textarea is no longer the activevirtual input device for the form.",
	"Method": "void fireCloseEvent(){\r\n    if (closeListeners != null && closeListeners.hasListeners()) {\r\n        ActionEvent evt = new ActionEvent(this);\r\n        closeListeners.fireActionEvent(evt);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Button.getReleaseRadius",
	"Comment": "indicates a radius in which a pointer release will still have effect. notice that this only applies topointer release events and not to pointer press events",
	"Method": "int getReleaseRadius(){\r\n    return releaseRadius;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Style.getMarginLeft",
	"Comment": "returns the left margin in pixel or right margin in an rtl situation",
	"Method": "int getMarginLeft(boolean rtl){\r\n    if (rtl) {\r\n        return convertUnit(marginUnit, margin[Component.RIGHT], Component.RIGHT);\r\n    }\r\n    return convertUnit(marginUnit, margin[Component.LEFT], Component.LEFT);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Collections.addAll",
	"Comment": "adds all the specified elements to the specified collection.",
	"Method": "boolean addAll(Collection<? extends E> collection,boolean addAll,int location,Collection<? extends E> collection,boolean addAll,Collection<? extends E> collection,boolean addAll,int location,Collection<? extends E> collection,boolean addAll,Collection<? super T> c,T a,boolean addAll,Collection<? extends E> c1){\r\n    boolean modified = false;\r\n    for (int i = 0; i < a.length; i++) {\r\n        modified |= c.add(a[i]);\r\n    }\r\n    return modified;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.LinkedHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    if (keySet == null) {\r\n        keySet = new AbstractSet<K>() {\r\n            @Override\r\n            public boolean contains(Object object) {\r\n                return containsKey(object);\r\n            }\r\n            @Override\r\n            public int size() {\r\n                return LinkedHashMap.this.size();\r\n            }\r\n            @Override\r\n            public void clear() {\r\n                LinkedHashMap.this.clear();\r\n            }\r\n            @Override\r\n            public boolean remove(Object key) {\r\n                if (containsKey(key)) {\r\n                    LinkedHashMap.this.remove(key);\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n            @Override\r\n            public Iterator<K> iterator() {\r\n                return new KeyIterator<K, V>(LinkedHashMap.this);\r\n            }\r\n        };\r\n    }\r\n    return keySet;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.LinkedHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return containsKey(object);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.LinkedHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return LinkedHashMap.this.size();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.LinkedHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    LinkedHashMap.this.clear();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.LinkedHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    if (containsKey(key)) {\r\n        LinkedHashMap.this.remove(key);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.LinkedHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return new KeyIterator<K, V>(LinkedHashMap.this);\r\n}"
}, {
	"Path": "io.prometheus.client.exporter.HTTPServer.start",
	"Comment": "start a http server by making sure that its background thread inherit proper daemon flag.",
	"Method": "void start(boolean daemon){\r\n    if (daemon == Thread.currentThread().isDaemon()) {\r\n        server.start();\r\n    } else {\r\n        FutureTask<Void> startTask = new FutureTask<Void>(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                server.start();\r\n            }\r\n        }, null);\r\n        DaemonThreadFactory.defaultThreadFactory(daemon).newThread(startTask).start();\r\n        try {\r\n            startTask.get();\r\n        } catch (ExecutionException e) {\r\n            throw new RuntimeException(\"Unexpected exception on starting HTTPSever\", e);\r\n        } catch (InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.prometheus.client.exporter.HTTPServer.start",
	"Comment": "start a http server by making sure that its background thread inherit proper daemon flag.",
	"Method": "void start(boolean daemon){\r\n    server.start();\r\n}"
}, {
	"Path": "com.codename1.ui.Label.setShowEvenIfBlank",
	"Comment": "by default labels and subclasses become 0 sized when they are blank even ignoring their paddingsetting this to true makes the padding take effect even in a blank field.",
	"Method": "void setShowEvenIfBlank(boolean showEvenIfBlank){\r\n    this.showEvenIfBlank = showEvenIfBlank;\r\n}"
}, {
	"Path": "java.text.DateFormat.getDateTimeInstance",
	"Comment": "get a dateformat instance that uses a given style for dates and times.",
	"Method": "DateFormat getDateTimeInstance(int dateStyle,int timeStyle){\r\n    return new DateFormat(dateStyle, timeStyle);\r\n}"
}, {
	"Path": "com.codename1.ui.Transform.getScaleX",
	"Comment": "gets the x scale factor of this transformation.this value is only reliableif the transform is a scale transform.",
	"Method": "float getScaleX(){\r\n    return scaleX;\r\n}"
}, {
	"Path": "com.codename1.ui.Transform.getScaleY",
	"Comment": "gets the y scale factor of this transformation.this value is only reliableif the transform is a scale transform.",
	"Method": "float getScaleY(){\r\n    return scaleY;\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testSequenceSequentialOperations",
	"Comment": "tests that operations are properly sequenced on the client.",
	"Method": "void testSequenceSequentialOperations(){\r\n    testSequenceOperations(5, Query.ConsistencyLevel.SEQUENTIAL);\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.resizers.AbstractResizer.performChecks",
	"Comment": "performs checks on the source and destination image to see if they are\timages which can be processed.",
	"Method": "void performChecks(BufferedImage srcImage,BufferedImage destImage){\r\n    if (srcImage == null || destImage == null) {\r\n        throw new NullPointerException(\"The source and/or destination image is null.\");\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.CacheMap.setAlwaysStore",
	"Comment": "when set to true indicates that all entries should be persisted to storagefor a constantly persisting cache",
	"Method": "void setAlwaysStore(boolean alwaysStore){\r\n    this.alwaysStore = alwaysStore;\r\n}"
}, {
	"Path": "com.codename1.ui.Transform.getScaleZ",
	"Comment": "gets the z scale factor of this transformation.this value is only reliableif the transform is a scale transform.",
	"Method": "float getScaleZ(){\r\n    return scaleZ;\r\n}"
}, {
	"Path": "com.codename1.components.MultiButton.isInvertFirstTwoEntries",
	"Comment": "inverts the order of the first two entries so the second line appears first. this only works in horizontal mode!",
	"Method": "boolean isInvertFirstTwoEntries(){\r\n    return invert;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.persistence.support.serialization.KryoSerializer.deserialize",
	"Comment": "deserializes the given bytes, into an object of the given type, using the given instance of kryo serializer.",
	"Method": "O deserialize(byte[] bytes){\r\n    try {\r\n        Input input = new Input(new ByteArrayInputStream(bytes));\r\n        Kryo kryo = kryoCache.get();\r\n        O object;\r\n        if (polymorphic) {\r\n            object = (O) kryo.readClassAndObject(input);\r\n        } else {\r\n            object = kryo.readObject(input, objectType);\r\n        }\r\n        input.close();\r\n        return object;\r\n    } catch (Exception e) {\r\n        throw new IllegalStateException(\"Failed to deserialize object, object type: \" + objectType + \". \" + \"Configure @PersistenceConfig.polymorphic if the collection will contain a mix of object types. \" + \"Use the KryoSerializer.validateObjectIsRoundTripSerializable() method \" + \"to test your object is compatible with CQEngine.\", e);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.Spinner.setValue",
	"Comment": "set the value of the spinner to a number or a date based on the spinner type",
	"Method": "void setValue(Object o){\r\n    ListModel m = getModel();\r\n    if (m instanceof SpinnerDateModel) {\r\n        ((SpinnerDateModel) m).setValue((Date) o);\r\n    } else {\r\n        if (m instanceof SpinnerNumberModel) {\r\n            ((SpinnerNumberModel) m).setValue(o);\r\n        } else {\r\n            int size = m.getSize();\r\n            for (int iter = 0; iter < size; iter++) {\r\n                Object c = m.getItemAt(iter);\r\n                if (c == o || c != null && c.equals(o)) {\r\n                    m.setSelectedIndex(iter);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.javase.SEBrowserComponent.executeAndReturnString",
	"Comment": "executes a javascript string and returns the result as a string ifappropriate.",
	"Method": "String executeAndReturnString(String js){\r\n    if (Platform.isFxApplicationThread()) {\r\n        try {\r\n            return \"\" + web.getEngine().executeScript(js);\r\n        } catch (Throwable jse) {\r\n            System.out.println(\"Error trying to execute js \" + js);\r\n            throw new RuntimeException(jse);\r\n        }\r\n    }\r\n    final String[] result = new String[1];\r\n    final boolean[] complete = new boolean[] { false };\r\n    final Throwable[] error = new Throwable[1];\r\n    Platform.runLater(new Runnable() {\r\n        public void run() {\r\n            try {\r\n                result[0] = \"\" + web.getEngine().executeScript(js);\r\n            } catch (Throwable jse) {\r\n                System.out.println(\"Error trying to execute js \" + js);\r\n                error[0] = jse;\r\n            }\r\n            synchronized (complete) {\r\n                complete[0] = true;\r\n                complete.notify();\r\n            }\r\n        }\r\n    });\r\n    while (!complete[0]) {\r\n        Display.getInstance().invokeAndBlock(new Runnable() {\r\n            public void run() {\r\n                if (!complete[0]) {\r\n                    synchronized (complete) {\r\n                        try {\r\n                            complete.wait(20);\r\n                        } catch (InterruptedException ex) {\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    if (error[0] != null) {\r\n        throw new RuntimeException(error[0]);\r\n    }\r\n    return result[0];\r\n}"
}, {
	"Path": "com.codename1.impl.javase.SEBrowserComponent.executeAndReturnString",
	"Comment": "executes a javascript string and returns the result as a string ifappropriate.",
	"Method": "String executeAndReturnString(String js){\r\n    try {\r\n        result[0] = \"\" + web.getEngine().executeScript(js);\r\n    } catch (Throwable jse) {\r\n        System.out.println(\"Error trying to execute js \" + js);\r\n        error[0] = jse;\r\n    }\r\n    synchronized (complete) {\r\n        complete[0] = true;\r\n        complete.notify();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.javase.SEBrowserComponent.executeAndReturnString",
	"Comment": "executes a javascript string and returns the result as a string ifappropriate.",
	"Method": "String executeAndReturnString(String js){\r\n    if (!complete[0]) {\r\n        synchronized (complete) {\r\n            try {\r\n                complete.wait(20);\r\n            } catch (InterruptedException ex) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.getHintLabel",
	"Comment": "returns the hint label component that can be customized directly",
	"Method": "Label getHintLabel(){\r\n    return getHintLabelImpl();\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.setParser",
	"Comment": "sets a custom htmlparser for this htmlcomponentby default, a new htmlparser instance is created for each htmlcomponent, use this method if you have a custom parser.",
	"Method": "void setParser(HTMLParser parser){\r\n    this.parser.setParserCallback(null);\r\n    this.parser.setHTMLComponent(null);\r\n    this.parser = parser;\r\n    parser.setHTMLComponent(this);\r\n    parser.setParserCallback(htmlCallback);\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.isEnableInputScroll",
	"Comment": "indicates whether text field input should scroll to the right side when nomore room for the input is present.",
	"Method": "boolean isEnableInputScroll(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.isBoundsInGrid",
	"Comment": "returns if the absolute pos value should be corrections to the component that is in a normal cell. if false\tthe value of pos is truly absolute in that it will not affect the grid or have a default bounds in the grid.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "boolean isBoundsInGrid(){\r\n    return boundsInGrid;\r\n}"
}, {
	"Path": "com.codename1.ui.Stroke.getJoinStyle",
	"Comment": "returns the join style used for this stroke.see visual examples of join styles here.",
	"Method": "int getJoinStyle(){\r\n    return joinStyle;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.refreshDOM",
	"Comment": "refreshes the current dom so it any changes done after loading will be rendered.",
	"Method": "void refreshDOM(){\r\n    documentReady(docInfo, document);\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.AbstractStateTest.entries",
	"Comment": "creates and returns the given number of entries in the given term.",
	"Method": "List<TestEntry> entries(int entries,long term){\r\n    List<TestEntry> result = new ArrayList();\r\n    for (int i = 0; i < entries; i++) {\r\n        try (TestEntry entry = serverContext.getLog().create(TestEntry.class)) {\r\n            result.add(entry.setTerm(term));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.codename1.ui.Font.setBitmapFontEnabled",
	"Comment": "indicates whether bitmap fonts should be enabled by default when loading orthe fallback system font should be used instead. this allows easy togglingof font loading.",
	"Method": "void setBitmapFontEnabled(boolean enabled){\r\n    enableBitmapFont = enabled;\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.showSymbolDialog",
	"Comment": "invoked to show the symbol dialog, this method can be overriden by subclasses tomanipulate the symbol table",
	"Method": "void showSymbolDialog(){\r\n    Command cancel = new Command(getUIManager().localize(\"cancel\", \"Cancel\"));\r\n    Command r = Dialog.show(\"\", createSymbolTable(), new Command[] { cancel });\r\n    if (r != null && r != cancel) {\r\n        insertChars(r.getCommandName());\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setSelectedStyle",
	"Comment": "changes the component selected style by replacing the component style with the given style",
	"Method": "void setSelectedStyle(Style style){\r\n    if (this.selectedStyle != null) {\r\n        this.selectedStyle.removeStyleListener(this);\r\n    }\r\n    this.selectedStyle = style;\r\n    this.selectedStyle.addStyleListener(this);\r\n    if (this.selectedStyle.getBgPainter() == null) {\r\n        this.selectedStyle.setBgPainter(new BGPainter());\r\n    }\r\n    setShouldCalcPreferredSize(true);\r\n    checkAnimation();\r\n}"
}, {
	"Path": "com.codename1.ui.table.Table.createColumnSortComparator",
	"Comment": "returns a generic comparator that tries to work in a way that will sort columns with similar object types.this method can be overriden to create custom sort orders or return null and thus disable sorting for a specific column",
	"Method": "Comparator createColumnSortComparator(int column){\r\n    final CaseInsensitiveOrder ccmp = new CaseInsensitiveOrder();\r\n    return new Comparator() {\r\n        public int compare(Object o1, Object o2) {\r\n            if (o1 == null) {\r\n                if (o2 == null) {\r\n                    return 0;\r\n                }\r\n                return -1;\r\n            } else {\r\n                if (o2 == null) {\r\n                    return 1;\r\n                }\r\n            }\r\n            if (o1 instanceof String && o2 instanceof String) {\r\n                return ccmp.compare((String) o1, (String) o2);\r\n            }\r\n            try {\r\n                double d = Util.toDoubleValue(o1) - Util.toDoubleValue(o2);\r\n                if (d > 0) {\r\n                    return 1;\r\n                }\r\n                if (d < 0) {\r\n                    return -1;\r\n                }\r\n            } catch (IllegalArgumentException err) {\r\n                long dd = Util.toDateValue(o1).getTime() - Util.toDateValue(o2).getTime();\r\n                return (int) dd;\r\n            }\r\n            return 0;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.codename1.ui.table.Table.createColumnSortComparator",
	"Comment": "returns a generic comparator that tries to work in a way that will sort columns with similar object types.this method can be overriden to create custom sort orders or return null and thus disable sorting for a specific column",
	"Method": "Comparator createColumnSortComparator(int column){\r\n    if (o1 == null) {\r\n        if (o2 == null) {\r\n            return 0;\r\n        }\r\n        return -1;\r\n    } else {\r\n        if (o2 == null) {\r\n            return 1;\r\n        }\r\n    }\r\n    if (o1 instanceof String && o2 instanceof String) {\r\n        return ccmp.compare((String) o1, (String) o2);\r\n    }\r\n    try {\r\n        double d = Util.toDoubleValue(o1) - Util.toDoubleValue(o2);\r\n        if (d > 0) {\r\n            return 1;\r\n        }\r\n        if (d < 0) {\r\n            return -1;\r\n        }\r\n    } catch (IllegalArgumentException err) {\r\n        long dd = Util.toDateValue(o1).getTime() - Util.toDateValue(o2).getTime();\r\n        return (int) dd;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "io.atomix.copycat.client.DefaultCopycatClientTest.testCommandRetryOnLeaderFailure",
	"Comment": "tests calling the recovery strategy when a command fails due to unknownsessionexception.",
	"Method": "void testCommandRetryOnLeaderFailure(){\r\n    Connection connection = mock(Connection.class);\r\n    when(connection.close()).thenReturn(CompletableFuture.completedFuture(null));\r\n    Client client = mock(Client.class);\r\n    when(client.connect(any())).thenReturn(CompletableFuture.completedFuture(connection));\r\n    Transport transport = mock(Transport.class);\r\n    when(transport.client()).thenReturn(client);\r\n    when(connection.sendAndReceive(isA(ConnectRequest.class))).thenReturn(CompletableFuture.completedFuture(ConnectResponse.builder().withStatus(Response.Status.OK).withLeader(LEADER).withMembers(MEMBERS).build()));\r\n    when(connection.sendAndReceive(isA(RegisterRequest.class))).thenReturn(CompletableFuture.completedFuture(RegisterResponse.builder().withStatus(Response.Status.OK).withSession(1).withTimeout(5000).withLeader(LEADER).withMembers(MEMBERS).build()));\r\n    Mockito.when(connection.sendAndReceive(isA(KeepAliveRequest.class))).thenReturn(CompletableFuture.completedFuture(KeepAliveResponse.builder().withStatus(Response.Status.OK).withLeader(LEADER).withMembers(MEMBERS).build()));\r\n    Mockito.when(connection.sendAndReceive(isA(CommandRequest.class))).thenReturn(CompletableFuture.completedFuture(CommandResponse.builder().withStatus(Response.Status.ERROR).withError(CopycatError.Type.NO_LEADER_ERROR).build())).thenReturn(CompletableFuture.completedFuture(CommandResponse.builder().withStatus(Response.Status.OK).withIndex(1).withEventIndex(0).withResult(\"Hello world!\").build()));\r\n    CopycatClient copycatClient = CopycatClient.builder().withTransport(transport).build();\r\n    copycatClient.connect(MEMBERS).join();\r\n    assertEquals(copycatClient.submit(new TestCommand()).join(), \"Hello world!\");\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.LeaderState.queryBoundedLinearizable",
	"Comment": "executes a bounded linearizable query.bounded linearizable queries succeed as long as this server remains the leader. this is possiblesince the leader will step down in the event it fails to contact a majority of the cluster.",
	"Method": "CompletableFuture<QueryResponse> queryBoundedLinearizable(QueryEntry entry){\r\n    return sequenceAndApply(entry);\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyBase.putClientProperty",
	"Comment": "places a property that will apply statically to all instances of this property",
	"Method": "void putClientProperty(String key,Object o){\r\n    parent.putMetaDataOfClass(\"cn1$field\" + name + \"-\" + key, o);\r\n}"
}, {
	"Path": "com.codename1.components.ButtonList.setLayout",
	"Comment": "sets the layout for the list.this refresh the list to match the new layout.",
	"Method": "void setLayout(Layout layout){\r\n    if (layout != this.getLayout()) {\r\n        super.setLayout(layout);\r\n        refresh();\r\n    }\r\n}"
}, {
	"Path": "org.conscrypt.SSLParametersImpl.setEnabledProtocols",
	"Comment": "sets the list of available protocols for use in ssl connection.",
	"Method": "void setEnabledProtocols(String[] protocols){\r\n    if (protocols == null) {\r\n        throw new IllegalArgumentException(\"protocols == null\");\r\n    }\r\n    String[] filteredProtocols = filterFromProtocols(protocols, NativeCrypto.OBSOLETE_PROTOCOL_SSLV3);\r\n    isEnabledProtocolsFiltered = protocols.length != filteredProtocols.length;\r\n    enabledProtocols = NativeCrypto.checkEnabledProtocols(filteredProtocols).clone();\r\n}"
}, {
	"Path": "com.codename1.charts.renderers.XYSeriesRenderer.setFillBelowLine",
	"Comment": "sets if the line chart should be filled below its line. filling below theline transforms a line chart into an area chart.",
	"Method": "void setFillBelowLine(boolean fill){\r\n    mFillBelowLine.clear();\r\n    if (fill) {\r\n        mFillBelowLine.add(new FillOutsideLine(Type.BOUNDS_ALL));\r\n    } else {\r\n        mFillBelowLine.add(new FillOutsideLine(Type.NONE));\r\n    }\r\n}"
}, {
	"Path": "com.codename1.processing.Result.apply",
	"Comment": "internal worker utility method, traverses dom based on path tokens",
	"Method": "StructuredContent apply(StructuredContent start,List tokens,int firstToken){\r\n    if (start == null) {\r\n        return null;\r\n    }\r\n    final int nTokens = tokens.size();\r\n    if (firstToken >= nTokens) {\r\n        return start;\r\n    }\r\n    boolean glob = false;\r\n    for (int i = firstToken; i < nTokens; i++) {\r\n        final String tok1 = (String) tokens.get(i);\r\n        if (tok1.length() == 1 && ResultTokenizer.isDelimiter(tok1.charAt(0))) {\r\n            continue;\r\n        }\r\n        if (tok1.length() == 2) {\r\n            if (tok1.equals(SELECT_GLOB)) {\r\n                glob = true;\r\n                continue;\r\n            } else if (tok1.equals(SELECT_PARENT)) {\r\n                return apply(start.getParent(), tokens, i + 1);\r\n            }\r\n        }\r\n        if (i + 1 >= nTokens) {\r\n            return start;\r\n        }\r\n        final String tok2 = (String) tokens.get(i + 1);\r\n        final char t2 = tok2.charAt(0);\r\n        switch(t2) {\r\n            case SEPARATOR:\r\n                List children;\r\n                if (glob) {\r\n                    children = start.getDescendants(tok1);\r\n                } else {\r\n                    children = start.getChildren(tok1);\r\n                }\r\n                if (children.size() > 0) {\r\n                    return apply(new SubContent(children, start), tokens, i + 2);\r\n                }\r\n                return null;\r\n            case ARRAY_START:\r\n                if (i + 2 >= nTokens) {\r\n                    throw new IllegalArgumentException(\"Syntax error: array must be followed by a dimension: \" + tok1);\r\n                }\r\n                final String tok3 = (String) tokens.get(i + 2);\r\n                Evaluator evaluator = EvaluatorFactory.createEvaluator(tok3);\r\n                if (i + 3 >= nTokens) {\r\n                    throw new IllegalArgumentException(\"Syntax error: array dimension must be closed: \" + tok3);\r\n                }\r\n                final String tok4 = (String) tokens.get(i + 3);\r\n                if (tok4.length() != 1 && tok4.charAt(0) != ARRAY_END) {\r\n                    throw new IllegalArgumentException(\"Syntax error: illegal close of array dimension: \" + tok4);\r\n                }\r\n                i += 4;\r\n                if (i < nTokens) {\r\n                    final String tok5 = (String) tokens.get(i);\r\n                    if (tok5.length() != 1 && tok5.charAt(0) != SEPARATOR) {\r\n                        throw new IllegalArgumentException(\"Syntax error: illegal separator after array: \" + tok4);\r\n                    }\r\n                }\r\n                final List array;\r\n                if (glob) {\r\n                    array = start.getDescendants(tok1);\r\n                } else {\r\n                    array = start.getChildren(tok1);\r\n                }\r\n                Object selected = evaluator.evaluate(array);\r\n                if (selected instanceof StructuredContent) {\r\n                    return apply((StructuredContent) selected, tokens, i + 1);\r\n                } else {\r\n                    if (selected != null && ((List) selected).size() > 0) {\r\n                        List v = new Vector();\r\n                        for (Object o : (List) selected) {\r\n                            StructuredContent sc = apply((StructuredContent) o, tokens, i + 1);\r\n                            v.add(sc);\r\n                        }\r\n                        return new SubContent(v, start);\r\n                    }\r\n                }\r\n        }\r\n    }\r\n    return start;\r\n}"
}, {
	"Path": "com.codename1.components.SplitPane.toggleExpandPreferred",
	"Comment": "toggles the split pane between expanded state and preferred state.e.g. if the inset is currently expanded,then it will be moved to the last position that the user selected.if it is not expanded, it will expand it all the way.",
	"Method": "void toggleExpandPreferred(){\r\n    if (isExpanded) {\r\n        collapse();\r\n    } else if (isCollapsed) {\r\n        expand(true);\r\n    } else {\r\n        expand();\r\n    }\r\n}"
}, {
	"Path": "io.prometheus.client.SimpleCollector.clear",
	"Comment": "remove all children.any references to any children are invalidated.",
	"Method": "void clear(){\r\n    children.clear();\r\n    initializeNoLabelsChild();\r\n}"
}, {
	"Path": "com.codename1.io.rest.RequestBuilder.onErrorCode",
	"Comment": "in case of an error this method is invoked asynchronously to processthe error content with the json data and places it into a businessobject in the callback",
	"Method": "RequestBuilder onErrorCode(ErrorCodeHandler<PropertyBusinessObject> err,Class errorClass){\r\n    propertyErrorCallback = err;\r\n    errorHandlerPropertyType = errorClass;\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.getDefaultDialogTransitionOut",
	"Comment": "allows us to define a default animation that will draw the transition forexiting a dialog",
	"Method": "Transition getDefaultDialogTransitionOut(){\r\n    return defaultDialogTransitionOut;\r\n}"
}, {
	"Path": "com.codename1.ui.FontImage.getDefaultSize",
	"Comment": "default factor for image size, icons without a given size are sized asdefaultsize x default font height.",
	"Method": "float getDefaultSize(){\r\n    return defaultSize;\r\n}"
}, {
	"Path": "com.codename1.io.WebServiceProxyCall.defineWebService",
	"Comment": "creates a webservice definition object which can be used to invoke the webservice.",
	"Method": "WSDefinition defineWebService(String url,String serviceName,int returnType,int argumentTypes){\r\n    WSDefinition def = new WSDefinition();\r\n    def.url = url;\r\n    def.name = serviceName;\r\n    def.returnType = returnType;\r\n    def.arguments = argumentTypes;\r\n    return def;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLFont.isSmallCounterpart",
	"Comment": "checks if the specified font is a small counterpart of this font.",
	"Method": "boolean isSmallCounterpart(HTMLFont font){\r\n    if (size >= font.getSize()) {\r\n        return false;\r\n    }\r\n    return (isSameFamily(font) && (style == font.getStyle()));\r\n}"
}, {
	"Path": "com.codename1.ui.util.Effects.verticalPerspective",
	"Comment": "skews an image in a faux perspective transform on the vertical axis, this is effectively a fast scalealgorithm that both shrinks the image vertically and reduces the width",
	"Method": "Image verticalPerspective(Image i,float topScaleRatio,float bottomScaleRatio,float verticalShrink){\r\n    int[] imageData = i.getRGB();\r\n    int sourceWidth = i.getWidth();\r\n    int sourceHeight = i.getHeight();\r\n    int destinationWidth = (int) (Math.max(topScaleRatio, bottomScaleRatio) * sourceWidth);\r\n    int destinationHeight = (int) (verticalShrink * sourceHeight);\r\n    int[] destinationArray = new int[destinationWidth * destinationHeight];\r\n    float diff;\r\n    if (bottomScaleRatio < topScaleRatio) {\r\n        float smaller = bottomScaleRatio;\r\n        float larger = topScaleRatio;\r\n        diff = smaller - larger;\r\n    } else {\r\n        float larger = bottomScaleRatio;\r\n        float smaller = topScaleRatio;\r\n        diff = larger - smaller;\r\n    }\r\n    if (destinationWidth > sourceWidth) {\r\n        for (int y = 0; y < destinationHeight; y++) {\r\n            float positionY = ((float) y) / ((float) destinationHeight - 1);\r\n            int sourceY = (int) ((float) (sourceHeight - 1) * positionY);\r\n            float currentRowRatio = (topScaleRatio + (diff * positionY)) / bottomScaleRatio;\r\n            int minX = (int) (((float) destinationWidth) * (1 - currentRowRatio));\r\n            int maxX = destinationWidth - minX;\r\n            float distance = maxX - minX;\r\n            for (int x = minX; x < maxX; x++) {\r\n                int sourceX = (int) (((float) sourceWidth) * (((float) x - minX) / distance));\r\n                destinationArray[x + y * destinationWidth] = imageData[sourceY * sourceWidth + sourceX];\r\n            }\r\n        }\r\n    } else {\r\n        for (int y = 0; y < destinationHeight; y++) {\r\n            float positionY = ((float) y) / ((float) destinationHeight);\r\n            int sourceY = (int) ((float) sourceHeight * positionY);\r\n            float currentRowRatio = topScaleRatio + (diff * positionY);\r\n            int minX = (int) (((float) destinationWidth) * (1 - currentRowRatio));\r\n            int maxX = destinationWidth - minX;\r\n            float distance = maxX - minX;\r\n            for (int x = minX; x < maxX; x++) {\r\n                int sourceX = (int) (((float) sourceWidth) * (((float) x - minX) / distance));\r\n                destinationArray[x + y * destinationWidth] = imageData[sourceY * sourceWidth + sourceX];\r\n            }\r\n        }\r\n    }\r\n    return Image.createImage(destinationArray, destinationWidth, destinationHeight);\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentGroup.setForceGroup",
	"Comment": "component grouping can be an element from the theme but can be forced manuallyfor a specific group",
	"Method": "void setForceGroup(boolean forceGroup){\r\n    this.forceGroup = forceGroup;\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.getSelectedDays",
	"Comment": "gets the dates selected on the calendar or null if no date is selected",
	"Method": "Collection<Date> getSelectedDays(){\r\n    return selectedDays;\r\n}"
}, {
	"Path": "com.codename1.javascript.JavascriptContext.retain",
	"Comment": "increments the reference count for a the javascript object wrapped by the given jsobject.this may also trigger a cleanup of the object map ifthe map grows too big, or it randomly decided to perform cleanup.",
	"Method": "void retain(JSObject obj){\r\n    objectMap.put(new Integer(obj.objectId), Display.getInstance().createSoftWeakRef(obj));\r\n    if (objectMap.size() > objectMapThresholdSize || cleanupRandomizer.nextDouble() < cleanupProbability) {\r\n        cleanup();\r\n    }\r\n}"
}, {
	"Path": "java.util.TreeSet.headSet",
	"Comment": "answers a sortedset of the specified portion of this treeset whichcontains elements less than the end element. the returned sortedset isbacked by this treeset so changes to one are reflected by the other.",
	"Method": "NavigableSet<E> headSet(E end,boolean endInclusive,SortedSet<E> headSet,E end){\r\n    return headSet(end, false);\r\n}"
}, {
	"Path": "com.codename1.ui.Image.rotate270Degrees",
	"Comment": "rotates the image by 270 degrees while changing the ratio of the picture",
	"Method": "Image rotate270Degrees(boolean maintainOpacity){\r\n    return Display.impl.rotate270Degrees(this, maintainOpacity);\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.getDefaultCommand",
	"Comment": "default command is invoked when a user presses fire, this functionality workswell in some situations but might collide with elements such as navigationand combo boxes. use with caution.",
	"Method": "Command getDefaultCommand(){\r\n    if (selectCommand != null) {\r\n        return selectCommand;\r\n    }\r\n    return defaultCommand;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setScrollAnimationSpeed",
	"Comment": "scroll animation speed in milliseconds allowing a developer to slow down or acceleratethe smooth animation mode",
	"Method": "void setScrollAnimationSpeed(int animationSpeed){\r\n    this.animationSpeed = animationSpeed;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.LC.minHeight",
	"Comment": "the minimum height for the container. the value will override any value that is set on the container itself.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcontainers.com.",
	"Method": "LC minHeight(String height){\r\n    setHeight(LayoutUtil.derive(getHeight(), ConstraintParser.parseUnitValue(height, false), null, null));\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.impl.android.AndroidImplementation.setNotificationChannel",
	"Comment": "sets the notification channel on a notification builder.uses service properties to set properties of channel.",
	"Method": "void setNotificationChannel(NotificationManager nm,NotificationCompat.Builder mNotifyBuilder,Context context){\r\n    if (android.os.Build.VERSION.SDK_INT >= 26) {\r\n        try {\r\n            NotificationManager mNotificationManager = nm;\r\n            String id = getServiceProperty(\"android.NotificationChannel.id\", \"cn1-channel\", context);\r\n            CharSequence name = getServiceProperty(\"android.NotificationChannel.name\", \"Notifications\", context);\r\n            String description = getServiceProperty(\"android.NotificationChannel.description\", \"Remote notifications\", context);\r\n            int importance = Integer.parseInt(getServiceProperty(\"android.NotificationChannel.importance\", \"4\", context));\r\n            Class clsNotificationChannel = Class.forName(\"android.app.NotificationChannel\");\r\n            Constructor constructor = clsNotificationChannel.getConstructor(java.lang.String.class, java.lang.CharSequence.class, int.class);\r\n            Object mChannel = constructor.newInstance(new Object[] { id, name, importance });\r\n            Method method = clsNotificationChannel.getMethod(\"setDescription\", java.lang.String.class);\r\n            method.invoke(mChannel, new Object[] { description });\r\n            method = clsNotificationChannel.getMethod(\"enableLights\", boolean.class);\r\n            method.invoke(mChannel, new Object[] { Boolean.parseBoolean(getServiceProperty(\"android.NotificationChannel.enableLights\", \"true\", context)) });\r\n            method = clsNotificationChannel.getMethod(\"setLightColor\", int.class);\r\n            method.invoke(mChannel, new Object[] { Integer.parseInt(getServiceProperty(\"android.NotificationChannel.lightColor\", \"\" + android.graphics.Color.RED, context)) });\r\n            method = clsNotificationChannel.getMethod(\"enableVibration\", boolean.class);\r\n            method.invoke(mChannel, new Object[] { Boolean.parseBoolean(getServiceProperty(\"android.NotificationChannel.enableVibration\", \"false\", context)) });\r\n            String vibrationPatternStr = getServiceProperty(\"android.NotificationChannel.vibrationPattern\", null, context);\r\n            if (vibrationPatternStr != null) {\r\n                String[] parts = vibrationPatternStr.split(\",\");\r\n                int len = parts.length;\r\n                long[] pattern = new long[len];\r\n                for (int i = 0; i < len; i++) {\r\n                    pattern[i] = Long.parseLong(parts[i].trim());\r\n                }\r\n                method = clsNotificationChannel.getMethod(\"setVibrationPattern\", long[].class);\r\n                method.invoke(mChannel, new Object[] { pattern });\r\n            }\r\n            method = NotificationManager.class.getMethod(\"createNotificationChannel\", clsNotificationChannel);\r\n            method.invoke(mNotificationManager, new Object[] { mChannel });\r\n            try {\r\n                mNotifyBuilder.getClass().getMethod(\"setChannelId\", new Class[] { String.class }).invoke(mNotifyBuilder, new Object[] { id });\r\n            } catch (Exception ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            }\r\n        } catch (ClassNotFoundException ex) {\r\n            Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n        } catch (NoSuchMethodException ex) {\r\n            Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n        } catch (SecurityException ex) {\r\n            Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n        } catch (IllegalAccessException ex) {\r\n            Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n        } catch (IllegalArgumentException ex) {\r\n            Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n        } catch (InvocationTargetException ex) {\r\n            Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n        } catch (InstantiationException ex) {\r\n            Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.shrinkY",
	"Comment": "shrink weight for the component horizontally.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC shrinkY(float w){\r\n    ver.setShrink(new Float(w));\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.canExecute",
	"Comment": "returns true if executing this url should work, returns false if it will notand null if this is unknown.",
	"Method": "Boolean canExecute(String url){\r\n    if (url.startsWith(\"http:\") || url.startsWith(\"https:\")) {\r\n        return Boolean.TRUE;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.shrinkX",
	"Comment": "shrink weight for the component horizontally.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC shrinkX(float w){\r\n    hor.setShrink(new Float(w));\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testSequenceBoundedLinearizableOperations",
	"Comment": "tests that operations are properly sequenced on the client.",
	"Method": "void testSequenceBoundedLinearizableOperations(){\r\n    testSequenceOperations(5, Query.ConsistencyLevel.LINEARIZABLE_LEASE);\r\n}"
}, {
	"Path": "com.codename1.components.ButtonList.addDecorator",
	"Comment": "adds a decorator that can be used to customize a button when it is created",
	"Method": "void addDecorator(Decorator decorator){\r\n    if (decorators == null) {\r\n        decorators = new ArrayList<Decorator>();\r\n    }\r\n    decorators.add(decorator);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.Grid.wrap",
	"Comment": "wraps to the next row or column depending on if horizontal flow orvertical flow is used.",
	"Method": "void wrap(int[] cellXY,BoundSize gapSize){\r\n    boolean flowx = lc.isFlowX();\r\n    cellXY[0] = flowx ? 0 : cellXY[0] + 1;\r\n    cellXY[1] = flowx ? cellXY[1] + 1 : 0;\r\n    if (gapSize != null) {\r\n        if (wrapGapMap == null) {\r\n            wrapGapMap = new HashMap<Integer, BoundSize>(8);\r\n        }\r\n        wrapGapMap.put(new Integer(cellXY[flowx ? 1 : 0]), gapSize);\r\n    }\r\n    if (flowx) {\r\n        rowIndexes.add(new Integer(cellXY[1]));\r\n    } else {\r\n        colIndexes.add(new Integer(cellXY[0]));\r\n    }\r\n}"
}, {
	"Path": "java.util.Vector.subList",
	"Comment": "returns a list of the specified portion of this vector from the startindex to one less than the end index. the returned list is backed by thisvector so changes to one are reflected by the other.",
	"Method": "List<E> subList(int start,int end){\r\n    return new Collections.SynchronizedRandomAccessList<E>(super.subList(start, end), this);\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.setBackCommand",
	"Comment": "invoked internally to set the back command on the form, this method allows subclassesto change the behavior of back command adding or disable it",
	"Method": "void setBackCommand(Form f,Command backCommand){\r\n    if (f.getToolbar() != null) {\r\n        f.getToolbar().setBackCommand(backCommand);\r\n    } else {\r\n        if (shouldAddBackCommandToMenu()) {\r\n            f.addCommand(backCommand, f.getCommandCount());\r\n        }\r\n        f.setBackCommand(backCommand);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.setDefaultCommand",
	"Comment": "default command is invoked when a user presses fire, this functionality workswell in some situations but might collide with elements such as navigationand combo boxes. use with caution.",
	"Method": "void setDefaultCommand(Command defaultCommand){\r\n    this.defaultCommand = defaultCommand;\r\n}"
}, {
	"Path": "java.lang.String.getBytes",
	"Comment": "convert this string into bytes according to the specified character encoding, storing the result into a new byte array.",
	"Method": "byte[] getBytes(byte[] getBytes,java.lang.String enc){\r\n    return getBytes(charset.displayName());\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.capacity",
	"Comment": "returns the number of elements this vector can hold without growing.",
	"Method": "int capacity(){\r\n    return elementData.length;\r\n}"
}, {
	"Path": "com.l2fprod.common.beans.BaseBeanInfo.removeProperty",
	"Comment": "removes the first occurrence of the property named propertyname",
	"Method": "PropertyDescriptor removeProperty(String propertyName){\r\n    if (propertyName == null) {\r\n        throw new IllegalArgumentException(\"Property name can not be null\");\r\n    }\r\n    for (Iterator iter = properties.iterator(); iter.hasNext(); ) {\r\n        PropertyDescriptor property = (PropertyDescriptor) iter.next();\r\n        if (propertyName.equals(property.getName())) {\r\n            iter.remove();\r\n            return property;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "java.lang.StringBuilder.append",
	"Comment": "appends the string representation of the object argument to this string builder.the argument is converted to a string as if by the method string.valueof, and the characters of that string are then appended to this string builder.",
	"Method": "java.lang.StringBuilder append(boolean b,java.lang.StringBuilder append,char c,java.lang.StringBuilder append,char[] str,java.lang.StringBuilder append,char[] str,int offset,int len,java.lang.StringBuilder append,double d,java.lang.StringBuilder append,float f,java.lang.StringBuilder append,int i,java.lang.StringBuilder append,long l,java.lang.StringBuilder append,java.lang.Object obj,java.lang.StringBuilder append,java.lang.String str,java.lang.StringBuilder append,java.lang.StringBuffer buf,StringBuilder append,java.lang.CharSequence cs,StringBuilder append,java.lang.CharSequence cs,int start,int end){\r\n    if (s == null) {\r\n        s = \"null\";\r\n    }\r\n    int length = end - start;\r\n    int newCount = count + length;\r\n    if (newCount > value.length) {\r\n        enlargeBuffer(newCount);\r\n    }\r\n    if (s instanceof String) {\r\n        ((String) s).getChars(start, end, value, count);\r\n    } else if (s instanceof StringBuilder) {\r\n        StringBuilder other = (StringBuilder) s;\r\n        System.arraycopy(other.value, start, value, count, length);\r\n    } else {\r\n        int j = count;\r\n        for (int i = start; i < end; i++) {\r\n            value[j++] = s.charAt(i);\r\n        }\r\n    }\r\n    this.count = newCount;\r\n    return this;\r\n}"
}, {
	"Path": "org.conscrypt.java.security.TestKeyStore.getClientCA2",
	"Comment": "return a keystore with a second ca certificate that does nottrust the server certificate returned by getserver for negativetesting.",
	"Method": "TestKeyStore getClientCA2(){\r\n    initCerts();\r\n    return CLIENT_2;\r\n}"
}, {
	"Path": "com.codename1.io.MultipartRequest.setLeaveInputStreamsOpen",
	"Comment": "special flag to keep input stream files open after they are read",
	"Method": "void setLeaveInputStreamsOpen(boolean aLeaveInputStreamsOpen){\r\n    leaveInputStreamsOpen = aLeaveInputStreamsOpen;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.LeaderState.startAppendTimer",
	"Comment": "starts sending appendentries requests to all cluster members.",
	"Method": "void startAppendTimer(){\r\n    LOGGER.trace(\"{} - Starting append timer\", context.getCluster().member().address());\r\n    appendTimer = context.getThreadContext().schedule(Duration.ZERO, context.getHeartbeatInterval(), this::appendMembers);\r\n}"
}, {
	"Path": "com.codename1.components.ImageViewer.setCycleRight",
	"Comment": "by default the imageviewer cycles from the end to the beginning of the listwhen going to the right, setting this to false prevents this behaviour",
	"Method": "void setCycleRight(boolean cycleRight){\r\n    this.cycleRight = cycleRight;\r\n}"
}, {
	"Path": "com.codename1.components.MultiButton.isShouldLocalize",
	"Comment": "indicates if text should be localized when set to the component, by defaultall text is localized so this allows disabling automatic localization for a specific component.",
	"Method": "boolean isShouldLocalize(){\r\n    return firstRow.isShouldLocalize();\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.quartile",
	"Comment": "returns the member which lies upon a particular quartile according to agiven expression.",
	"Method": "double quartile(Evaluator evaluator,TupleList members,Calc exp,int range){\r\n    assert range >= 1 && range <= 3;\r\n    SetWrapper sw = evaluateSet(evaluator, members, exp);\r\n    if (sw.errorCount > 0) {\r\n        return Double.NaN;\r\n    } else if (sw.v.size() == 0) {\r\n        return DoubleNull;\r\n    }\r\n    double[] asArray = new double[sw.v.size()];\r\n    for (int i = 0; i < asArray.length; i++) {\r\n        asArray[i] = ((Double) sw.v.get(i)).doubleValue();\r\n    }\r\n    Arrays.sort(asArray);\r\n    double dm = 0.25 * asArray.length * range;\r\n    int median = (int) Math.floor(dm);\r\n    return dm == median && median < asArray.length - 1 ? (asArray[median] + asArray[median + 1]) / 2 : asArray[median];\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.addThemeProps",
	"Comment": "adds the given theme properties on top of the existing properties withoutclearing the existing theme first",
	"Method": "void addThemeProps(Hashtable themeProps){\r\n    if (accessible) {\r\n        buildTheme(themeProps);\r\n        styles.clear();\r\n        selectedStyles.clear();\r\n        imageCache.clear();\r\n        current.refreshTheme(false);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.android.AndroidImplementation.servicePropertiesDirty",
	"Comment": "flag to indicate if any of the service properties have been changed.",
	"Method": "boolean servicePropertiesDirty(){\r\n    for (String key : servicePropertyKeys) {\r\n        if (Display.getInstance().getProperty(key, null) != null) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.onCanInstallOnHomescreen",
	"Comment": "a callback fired when you are allowed to prompt the user to install the app on their homescreen.only relevant in the javascript port.",
	"Method": "void onCanInstallOnHomescreen(Runnable r){\r\n    impl.onCanInstallOnHomescreen(r);\r\n}"
}, {
	"Path": "com.codename1.ui.geom.GeneralPath.transform",
	"Comment": "transforms the current path in place using the given transform.",
	"Method": "void transform(Transform m){\r\n    if (m != null && !m.isIdentity()) {\r\n        m.transformPoints(2, points, 0, points, 0, pointSize / 2);\r\n    }\r\n}"
}, {
	"Path": "org.conscrypt.java.security.TestKeyStore.copyCertificate",
	"Comment": "copy named certificates from one key store to another.returns true if successful, false if no match found.",
	"Method": "boolean copyCertificate(Principal subject,KeyStore dst,KeyStore src){\r\n    for (String alias : Collections.list(src.aliases())) {\r\n        if (!src.isCertificateEntry(alias)) {\r\n            continue;\r\n        }\r\n        X509Certificate cert = (X509Certificate) src.getCertificate(alias);\r\n        if (!cert.getSubjectDN().equals(subject)) {\r\n            continue;\r\n        }\r\n        dst.setCertificateEntry(alias, cert);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.maps.layers.ArrowLinesLayer.paintSegment",
	"Comment": "paints arrows on each segment. arrowsegmentlength decides how manyarrows will be on each segment.",
	"Method": "void paintSegment(Graphics g,Coord[] segment,Tile tile){\r\n    super.paintSegment(g, segment, tile);\r\n    int pointsNo = segment.length;\r\n    for (int i = 1; i < pointsNo; i++) {\r\n        Coord start = segment[i - 1];\r\n        Coord end = segment[i];\r\n        Point s = tile.pointPosition(start);\r\n        Point e = tile.pointPosition(end);\r\n        int noOfSegments = calculateLength(s, e) / arrowSegmentLength;\r\n        if (noOfSegments == 0 && calculateLength(s, e) > minArrowSementLength) {\r\n            noOfSegments = 1;\r\n        }\r\n        for (int j = 1; j <= noOfSegments; j++) {\r\n            if (j == 1) {\r\n                double div = 1.0 / noOfSegments;\r\n                drawArrow(g, new Point(s.getX(), s.getY()), new Point((int) (div * e.getX() + s.getX() * (1 - div)), (int) (div * e.getY() + s.getY() * (1 - div))));\r\n            } else if (j == noOfSegments) {\r\n                double div = (noOfSegments - 1) / (noOfSegments * 1.0);\r\n                drawArrow(g, new Point((int) (div * e.getX() + s.getX() * (1 - div)), (int) (div * e.getY() + s.getY() * (1 - div))), new Point(e.getX(), e.getY()));\r\n            } else {\r\n                double div = ((j - 1) * 1.0) / noOfSegments;\r\n                double div2 = (j * 1.0) / noOfSegments;\r\n                drawArrow(g, new Point((int) (div * e.getX() + s.getX() * (1 - div)), (int) (div * e.getY() + s.getY() * (1 - div))), new Point((int) (div2 * e.getX() + s.getX() * (1 - div2)), (int) (div2 * e.getY() + s.getY() * (1 - div2))));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setScrollX",
	"Comment": "indicates the x position of the scrolling, this number is relative to thecomponent position and so a position of 0 would indicate the x positionof the component.",
	"Method": "void setScrollX(int scrollX){\r\n    int scrollXtmp = scrollX;\r\n    if (!isSmoothScrolling() || !isTensileDragEnabled()) {\r\n        scrollXtmp = Math.min(scrollXtmp, getScrollDimension().getWidth() - getWidth());\r\n        scrollXtmp = Math.max(scrollXtmp, 0);\r\n    }\r\n    if (isScrollableX()) {\r\n        if (Form.activePeerCount > 0) {\r\n            onParentPositionChange();\r\n        }\r\n        repaint();\r\n    }\r\n    if (scrollListeners != null) {\r\n        scrollListeners.fireScrollEvent(scrollXtmp, this.scrollY, this.scrollX, this.scrollY);\r\n    }\r\n    this.scrollX = scrollXtmp;\r\n    onScrollX(scrollX);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setScrollY",
	"Comment": "indicates the x position of the scrolling, this number is relative to thecomponent position and so a position of 0 would indicate the x positionof the component.",
	"Method": "void setScrollY(int scrollY){\r\n    if (this.scrollY != scrollY) {\r\n        CodenameOneImplementation ci = Display.impl;\r\n        if (ci.isAsyncEditMode() && ci.isEditingText()) {\r\n            Component editingText = ci.getEditingText();\r\n            if (editingText != null && this instanceof Container && ((Container) this).contains(editingText)) {\r\n                ci.hideTextEditor();\r\n            }\r\n        }\r\n    }\r\n    int scrollYtmp = scrollY;\r\n    if (!isSmoothScrolling() || !isTensileDragEnabled()) {\r\n        Form parentForm = getComponentForm();\r\n        int v = getInvisibleAreaUnderVKB();\r\n        int h = getScrollDimension().getHeight() - getHeight() + v;\r\n        scrollYtmp = Math.min(scrollYtmp, h);\r\n        scrollYtmp = Math.max(scrollYtmp, 0);\r\n    }\r\n    if (isScrollableY()) {\r\n        if (Form.activePeerCount > 0) {\r\n            onParentPositionChange();\r\n        }\r\n        repaint();\r\n    }\r\n    if (scrollListeners != null) {\r\n        scrollListeners.fireScrollEvent(this.scrollX, scrollYtmp, this.scrollX, this.scrollY);\r\n    }\r\n    this.scrollY = scrollYtmp;\r\n    onScrollY(this.scrollY);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isBackgroundFetchSupported",
	"Comment": "checks to see if the current platform supports background fetch.",
	"Method": "boolean isBackgroundFetchSupported(){\r\n    return impl.isBackgroundFetchSupported();\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testSequenceLinearizableOperations",
	"Comment": "tests that operations are properly sequenced on the client.",
	"Method": "void testSequenceLinearizableOperations(){\r\n    testSequenceOperations(5, Query.ConsistencyLevel.LINEARIZABLE);\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.clickButtonByPath",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "void clickButtonByPath(int[] path){\r\n    TestUtils.clickButtonByPath(path);\r\n}"
}, {
	"Path": "android.support.v4.view.accessibility.AccessibilityRecordCompat.getFromIndex",
	"Comment": "gets the index of the first character of the changed sequence,or the beginning of a text selection or the index of the firstvisible item when scrolling.",
	"Method": "int getFromIndex(Object record,int getFromIndex,Object record,int getFromIndex,Object record,int getFromIndex){\r\n    return IMPL.getFromIndex(mRecord);\r\n}"
}, {
	"Path": "com.codename1.ui.painter.PainterChain.removeGlassPane",
	"Comment": "removes a glass pane from the given form, this is the opposite operation for theinstall glass pane",
	"Method": "void removeGlassPane(Form f,Painter p){\r\n    Painter existing = f.getGlassPane();\r\n    if (existing == null) {\r\n        return;\r\n    }\r\n    if (existing == p) {\r\n        f.setGlassPane(null);\r\n        return;\r\n    }\r\n    if (existing instanceof PainterChain) {\r\n        PainterChain pc = (PainterChain) existing;\r\n        if (pc.chain.length == 1) {\r\n            f.setGlassPane(null);\r\n        } else {\r\n            Vector v = new Vector();\r\n            int plen = pc.chain.length;\r\n            for (int iter = 0; iter < plen; iter++) {\r\n                if (pc.chain[iter] != p) {\r\n                    v.addElement(pc.chain[iter]);\r\n                }\r\n            }\r\n            if (v.size() == 0) {\r\n                f.setGlassPane(null);\r\n                return;\r\n            }\r\n            Painter[] newChain = new Painter[v.size()];\r\n            int clen = newChain.length;\r\n            for (int iter = 0; iter < clen; iter++) {\r\n                newChain[iter] = (Painter) v.elementAt(iter);\r\n            }\r\n            pc.chain = newChain;\r\n            f.repaint();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.createGrooveBorder",
	"Comment": "creates a groove border with the specified thickness and color",
	"Method": "Border createGrooveBorder(int thickness,Border createGrooveBorder,int thickness,int color){\r\n    return createCSSBorder(TYPE_GROOVE, thickness, color);\r\n}"
}, {
	"Path": "com.codename1.ui.animations.CommonTransitions.createMotion",
	"Comment": "this method can be overriden by subclasses to create their own motion object on the fly",
	"Method": "Motion createMotion(int startOffset,int dest,int speed){\r\n    if (motionSetManually) {\r\n        if (lazyMotion != null) {\r\n            return lazyMotion.get(new Integer(startOffset), new Integer(dest), new Integer(speed));\r\n        }\r\n        return motion;\r\n    }\r\n    if (linearMotion) {\r\n        return Motion.createLinearMotion(startOffset, dest, speed);\r\n    }\r\n    return Motion.createEaseInOutMotion(startOffset, dest, speed);\r\n}"
}, {
	"Path": "com.codename1.ui.AutoCompleteTextField.isStartsWithMode",
	"Comment": "when enabled this makes the filter check that the string starts with rather than within the index",
	"Method": "boolean isStartsWithMode(){\r\n    return filter.isStartsWithMode();\r\n}"
}, {
	"Path": "com.codename1.payment.Purchase.isRestoreSupported",
	"Comment": "indicates whether a purchase restore button is supported by the os",
	"Method": "boolean isRestoreSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.allowBackTo",
	"Comment": "indicates whether a back command to this form should be generated automatically whenleaving said form.",
	"Method": "boolean allowBackTo(String formName){\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.DefaultLookAndFeel.setTickWhenFocused",
	"Comment": "this method allows to set all labels, buttons, checkboxes, radiobuttonsto start ticking when the text is too long.",
	"Method": "void setTickWhenFocused(boolean tickWhenFocused){\r\n    this.tickWhenFocused = tickWhenFocused;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.compaction.MinorCompactionTask.mergeReleasedEntries",
	"Comment": "updates the new compact segment with entries that were released from the given segment during compaction.",
	"Method": "void mergeReleasedEntries(Segment segment,Segment compactSegment){\r\n    for (long i = segment.firstIndex(); i <= segment.lastIndex(); i++) {\r\n        if (!segment.isLive(i)) {\r\n            compactSegment.release(i);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Form.stopEditing",
	"Comment": "stops any active editing on the form.closes keyboard if it is opened.",
	"Method": "void stopEditing(Runnable onFinish){\r\n    Display.getInstance().stopEditing(this, onFinish);\r\n}"
}, {
	"Path": "com.codename1.maps.Tile.setPaintLoading",
	"Comment": "this flag indicates if the tile should paint a loading image or text orsimply not do any painting if a map image is not ready for painting",
	"Method": "void setPaintLoading(boolean toPaint){\r\n    paintLoading = toPaint;\r\n}"
}, {
	"Path": "com.codename1.system.NativeLookup.setVerbose",
	"Comment": "indicates whether stack traces should be printed when lookup fails",
	"Method": "void setVerbose(boolean aVerbose){\r\n    verbose = aVerbose;\r\n}"
}, {
	"Path": "com.codename1.ui.util.ImageIO.saveAndKeepAspect",
	"Comment": "scales an image on disk while maintaining an aspect ratio, the appropriate aspect size will be picked based on the status of scaletofill",
	"Method": "String saveAndKeepAspect(String imageFilePath,String preferredOutputPath,String format,int width,int height,float quality,boolean onlyDownscale,boolean scaleToFill){\r\n    Dimension d = getImageSize(imageFilePath);\r\n    if (onlyDownscale) {\r\n        if (scaleToFill) {\r\n            if (d.getHeight() <= height || d.getWidth() <= width) {\r\n                return imageFilePath;\r\n            }\r\n        } else {\r\n            if (d.getHeight() <= height && d.getWidth() <= width) {\r\n                return imageFilePath;\r\n            }\r\n        }\r\n    }\r\n    float ratio = ((float) d.getWidth()) / ((float) d.getHeight());\r\n    int heightBasedOnWidth = (int) (((float) width) / ratio);\r\n    int widthBasedOnHeight = (int) (((float) height) * ratio);\r\n    if (scaleToFill) {\r\n        if (heightBasedOnWidth >= width) {\r\n            height = heightBasedOnWidth;\r\n        } else {\r\n            width = widthBasedOnHeight;\r\n        }\r\n    } else {\r\n        if (heightBasedOnWidth > width) {\r\n            width = widthBasedOnHeight;\r\n        } else {\r\n            height = heightBasedOnWidth;\r\n        }\r\n    }\r\n    OutputStream im = FileSystemStorage.getInstance().openOutputStream(preferredOutputPath);\r\n    save(imageFilePath, im, format, width, height, quality);\r\n    return preferredOutputPath;\r\n}"
}, {
	"Path": "com.codename1.ui.util.Effects.dropshadow",
	"Comment": "generates a shadow for the source image and returns either the shadow itself or the image merged with the shadow.",
	"Method": "Image dropshadow(Image source,int blurRadius,float opacity,int xDistance,int yDistance,Image dropshadow,Image source,int blurRadius,float opacity){\r\n    int[] rgb = source.getRGB();\r\n    for (int iter = 0; iter < rgb.length; iter++) {\r\n        float f = rgb[iter] & 0xff000000;\r\n        f *= opacity;\r\n        rgb[iter] = (int) f;\r\n    }\r\n    Image shadow = Image.createImage(rgb, source.getWidth(), source.getHeight());\r\n    if (Display.getInstance().isGaussianBlurSupported()) {\r\n        shadow = Display.getInstance().gaussianBlurImage(shadow, blurRadius);\r\n    }\r\n    return shadow;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayeredLayout.setReferenceComponentRight",
	"Comment": "sets the reference component for the right inset of the given component.",
	"Method": "LayeredLayout setReferenceComponentRight(Component cmp,Component referenceComponent,LayeredLayout setReferenceComponentRight,Component cmp,Component referenceComponent,float position){\r\n    getOrCreateConstraint(cmp).right().referenceComponent(referenceComponent).referencePosition(position);\r\n    return this;\r\n}"
}, {
	"Path": "java.lang.StringToReal.initialParse",
	"Comment": "returns a stringexponentpair containing a string with no leading or trailing whitespace and trailing zeroes eliminated. the exponent of thestringexponentpair will be used to calculate the floating point number bytaking the positive integer the string represents and multiplying by 10raised to the power of the of the exponent.",
	"Method": "StringExponentPair initialParse(String s,int length,boolean isDouble){\r\n    StringExponentPair result = new StringExponentPair();\r\n    if (length == 0) {\r\n        throw invalidReal(s, isDouble);\r\n    }\r\n    result.negative = (s.charAt(0) == '-');\r\n    char c = s.charAt(length - 1);\r\n    if (c == 'D' || c == 'd' || c == 'F' || c == 'f') {\r\n        length--;\r\n        if (length == 0) {\r\n            throw invalidReal(s, isDouble);\r\n        }\r\n    }\r\n    int end = Math.max(s.indexOf('E'), s.indexOf('e'));\r\n    if (end != -1) {\r\n        if (end + 1 == length) {\r\n            throw invalidReal(s, isDouble);\r\n        }\r\n        int exponentOffset = end + 1;\r\n        boolean negativeExponent = false;\r\n        char firstExponentChar = s.charAt(exponentOffset);\r\n        if (firstExponentChar == '+' || firstExponentChar == '-') {\r\n            negativeExponent = (firstExponentChar == '-');\r\n            ++exponentOffset;\r\n        }\r\n        String exponentString = s.substring(exponentOffset, length);\r\n        if (exponentString.length() == 0) {\r\n            throw invalidReal(s, isDouble);\r\n        }\r\n        for (int i = 0; i < exponentString.length(); ++i) {\r\n            char ch = exponentString.charAt(i);\r\n            if (ch < '0' || ch > '9') {\r\n                throw invalidReal(s, isDouble);\r\n            }\r\n        }\r\n        try {\r\n            result.e = Integer.parseInt(exponentString);\r\n            if (negativeExponent) {\r\n                result.e = -result.e;\r\n            }\r\n        } catch (NumberFormatException ex) {\r\n            if (negativeExponent) {\r\n                result.zero = true;\r\n            } else {\r\n                result.infinity = true;\r\n            }\r\n            return result;\r\n        }\r\n    } else {\r\n        end = length;\r\n    }\r\n    if (length == 0) {\r\n        throw invalidReal(s, isDouble);\r\n    }\r\n    int start = 0;\r\n    c = s.charAt(start);\r\n    if (c == '-') {\r\n        ++start;\r\n        --length;\r\n        result.negative = true;\r\n    } else if (c == '+') {\r\n        ++start;\r\n        --length;\r\n    }\r\n    if (length == 0) {\r\n        throw invalidReal(s, isDouble);\r\n    }\r\n    int decimal = s.indexOf('.');\r\n    if (decimal > -1) {\r\n        result.e -= end - decimal - 1;\r\n        s = s.substring(start, decimal) + s.substring(decimal + 1, end);\r\n    } else {\r\n        s = s.substring(start, end);\r\n    }\r\n    if ((length = s.length()) == 0) {\r\n        throw invalidReal(s, isDouble);\r\n    }\r\n    end = length;\r\n    while (end > 1 && s.charAt(end - 1) == '0') {\r\n        --end;\r\n    }\r\n    start = 0;\r\n    while (start < end - 1 && s.charAt(start) == '0') {\r\n        start++;\r\n    }\r\n    if (end != length || start != 0) {\r\n        result.e += length - end;\r\n        s = s.substring(start, end);\r\n    }\r\n    final int APPROX_MIN_MAGNITUDE = -359;\r\n    final int MAX_DIGITS = 52;\r\n    length = s.length();\r\n    if (length > MAX_DIGITS && result.e < APPROX_MIN_MAGNITUDE) {\r\n        int d = Math.min(APPROX_MIN_MAGNITUDE - (int) result.e, length - 1);\r\n        s = s.substring(0, length - d);\r\n        result.e += d;\r\n    }\r\n    if (result.e < -1024) {\r\n        result.zero = true;\r\n        return result;\r\n    } else if (result.e > 1024) {\r\n        result.infinity = true;\r\n        return result;\r\n    }\r\n    result.s = s;\r\n    return result;\r\n}"
}, {
	"Path": "com.codename1.processing.AbstractEvaluator.evaluateSingle",
	"Comment": "override this element to handle testing a predicate expression with nocomparator.",
	"Method": "Object evaluateSingle(StructuredContent element,String expr,Object evaluateSingle,List elements,String expr){\r\n    List array;\r\n    if (elements instanceof java.util.Vector) {\r\n        array = new java.util.Vector();\r\n    } else {\r\n        array = new ArrayList();\r\n    }\r\n    for (Iterator e = elements.iterator(); e.hasNext(); ) {\r\n        Object o = e.next();\r\n        if (o instanceof StructuredContent) {\r\n            if ((o = evaluateSingle((StructuredContent) o, expr)) != null) {\r\n                array.add(o);\r\n            }\r\n        }\r\n    }\r\n    if (array.size() == 1) {\r\n        return (StructuredContent) array.get(0);\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "com.codename1.properties.InstantUI.getOrder",
	"Comment": "returns the order of the properties or null if they should use their natural order as they were submitted to the index object",
	"Method": "PropertyBase[] getOrder(){\r\n    return order;\r\n}"
}, {
	"Path": "com.codename1.location.GeofenceManager.size",
	"Comment": "checks the number of regions that are currently being monitored.",
	"Method": "int size(){\r\n    return getFences(false).size();\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.numAlphaLevels",
	"Comment": "return the number of alpha levels supported by the implementation.",
	"Method": "int numAlphaLevels(){\r\n    return 255;\r\n}"
}, {
	"Path": "com.codename1.impl.android.AndroidImplementation.hasAndroidMarket",
	"Comment": "indicates whether this is a google certified device which means that ithas android market etc.",
	"Method": "boolean hasAndroidMarket(boolean hasAndroidMarket,Context activity){\r\n    final PackageManager packageManager = activity.getPackageManager();\r\n    List<PackageInfo> packages = packageManager.getInstalledPackages(PackageManager.GET_UNINSTALLED_PACKAGES);\r\n    for (PackageInfo packageInfo : packages) {\r\n        if (packageInfo.packageName.equals(GooglePlayStorePackageNameOld) || packageInfo.packageName.equals(GooglePlayStorePackageNameNew)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.createComponentInstance",
	"Comment": "this method can be overriden to create custom components in a custom way, the componenttype is a shorthand for the component name and not the full name of the class.by default this method returns null which indicates codename one should try to reolve the componenton its own.",
	"Method": "Component createComponentInstance(String componentType,Class cls){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.createUnderlineBorder",
	"Comment": "creates an underline border that uses the color of the component foreground for drawing",
	"Method": "Border createUnderlineBorder(int thickness,Border createUnderlineBorder,float thickness,Border createUnderlineBorder,int thickness,int color,Border createUnderlineBorder,float thickness,int color){\r\n    Border b = new Border();\r\n    b.type = TYPE_UNDERLINE;\r\n    b.themeColors = false;\r\n    b.thickness = thickness;\r\n    b.millimeters = true;\r\n    b.colorA = color;\r\n    return b;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.shouldStop",
	"Comment": "returns true if the request is paused or killed, developers should call thismethod periodically to test whether they should quit the current io operation immediately",
	"Method": "boolean shouldStop(){\r\n    return isPaused() || isKilled();\r\n}"
}, {
	"Path": "com.codename1.ui.Component.calcPreferredSize",
	"Comment": "calculates the preferred size based on component content. this method isinvoked lazily by getpreferred size.",
	"Method": "Dimension calcPreferredSize(){\r\n    Dimension d = new Dimension(0, 0);\r\n    return d;\r\n}"
}, {
	"Path": "com.codename1.impl.javase.TestRunner.main",
	"Comment": "the main method accepts several arguments of which only the main class is a requirement",
	"Method": "void main(String[] argv){\r\n    try {\r\n        if (JavaFXLoader.main(TestRunner.class, argv)) {\r\n            return;\r\n        }\r\n    } catch (JavaFXLoader.JavaFXNotLoadedException notLoaded) {\r\n        System.err.println(\"Your JDK doesn't appear to have JavaFX installed, and the loader failed to install it.  Please download the appropriate javafx-{platform}.zip file from https://github.com/codenameone/cn1-binaries, and extract it to $HOME/.codenameone/javafx\");\r\n        notLoaded.printStackTrace();\r\n        System.exit(100);\r\n    } catch (InvocationTargetException ex) {\r\n        System.err.println(\"An exception occurred running the tests\");\r\n        ex.printStackTrace();\r\n        System.exit(100);\r\n    }\r\n    new TestRunner().init(argv);\r\n}"
}, {
	"Path": "java.io.InputStreamReader.close",
	"Comment": "close the stream. closing a previously closed stream has no effect.",
	"Method": "void close(){\r\n    internal.close();\r\n    cbufferOff = -1;\r\n}"
}, {
	"Path": "com.codename1.io.Log.getThreadAndTimeStamp",
	"Comment": "returns a simple string containing a timestamp and thread name.",
	"Method": "String getThreadAndTimeStamp(){\r\n    long time = System.currentTimeMillis() - zeroTime;\r\n    long milli = time % 1000;\r\n    time /= 1000;\r\n    long sec = time % 60;\r\n    time /= 60;\r\n    long min = time % 60;\r\n    time /= 60;\r\n    long hour = time % 60;\r\n    return \"[\" + Thread.currentThread().getName() + \"] \" + hour + \":\" + min + \":\" + sec + \",\" + milli;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.setDefaultMenuTransitionIn",
	"Comment": "allows us to define a default animation that will draw the transition forentering a menu",
	"Method": "void setDefaultMenuTransitionIn(Transition defaultMenuTransitionIn){\r\n    this.defaultMenuTransitionIn = defaultMenuTransitionIn;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isAllowMinimizing",
	"Comment": "allows a codename one application to minimize without forcing it to the front whenevera new dialog is poped up",
	"Method": "boolean isAllowMinimizing(){\r\n    return allowMinimizing;\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.postCreateComponents",
	"Comment": "invoked after the components were created to allow properties that require the entiretree to exist to update the component. this is useful for properties that pointat other components.",
	"Method": "void postCreateComponents(DataInputStream in,Container parent,Resources res){\r\n    String name = in.readUTF();\r\n    Component lastComponent = null;\r\n    while (name.length() > 0) {\r\n        if (lastComponent == null || !lastComponent.getName().equals(name)) {\r\n            lastComponent = findByName(name, parent);\r\n        }\r\n        Component c = lastComponent;\r\n        int property = in.readInt();\r\n        modifyingProperty(c, property);\r\n        switch(property) {\r\n            case PROPERTY_COMMAND_LEGACY:\r\n                {\r\n                    readCommand(in, c, parent, res, true);\r\n                    break;\r\n                }\r\n            case PROPERTY_COMMAND:\r\n                {\r\n                    readCommand(in, c, parent, res, false);\r\n                    break;\r\n                }\r\n            case PROPERTY_LABEL_FOR:\r\n                c.setLabelForComponent((Label) findByName(in.readUTF(), parent));\r\n                break;\r\n            case PROPERTY_LEAD_COMPONENT:\r\n                ((Container) c).setLeadComponent(findByName(in.readUTF(), parent));\r\n                break;\r\n            case PROPERTY_NEXT_FOCUS_UP:\r\n                c.setNextFocusUp(findByName(in.readUTF(), parent));\r\n                break;\r\n            case PROPERTY_NEXT_FOCUS_DOWN:\r\n                c.setNextFocusDown(findByName(in.readUTF(), parent));\r\n                break;\r\n            case PROPERTY_NEXT_FOCUS_LEFT:\r\n                c.setNextFocusLeft(findByName(in.readUTF(), parent));\r\n                break;\r\n            case PROPERTY_NEXT_FOCUS_RIGHT:\r\n                c.setNextFocusRight(findByName(in.readUTF(), parent));\r\n                break;\r\n        }\r\n        name = in.readUTF();\r\n    }\r\n}"
}, {
	"Path": "cognitivej.vision.overlay.builder.ImageOverlayBuilder.verify",
	"Comment": "draws averification graphic for the base image and the passed image.",
	"Method": "ImageOverlayBuilder verify(String candidateImageAsUrl,VerificationSet verificationSet,ImageOverlayBuilder verify,BufferedImage candidateImage,VerificationSet verificationSet){\r\n    CognitiveJColourPalette verificationColor = verificationSet.getVerification().isIdentical ? CognitiveJColourPalette.GREEN : CognitiveJColourPalette.RED;\r\n    outlineFaceOnImage(verificationSet.getFirstFace(), RectangleType.CORNERED, BorderWeight.THICK, verificationColor);\r\n    OverlayRectangleFilter overlayRectangleFilter = new OverlayRectangleFilter(verificationSet.getSecondFace().faceRectangle.asAwtRectangle(), RectangleType.CORNERED, BorderWeight.THICK, verificationColor);\r\n    MergeImagesFilter mergeImagesFilter = new MergeImagesFilter(overlayRectangleFilter.applyFilter(candidateImage), SMALL_PADDING, MergeImagesFilter.Position.RIGHT);\r\n    LineJoinRectangleFilter lineJoinRectangleFilter = new LineJoinRectangleFilter(verificationSet.getFirstFace().faceRectangle.asAwtRectangle(), verificationSet.getSecondFace().faceRectangle.asAwtRectangle(), BorderWeight.THICK, verificationColor, bufferedImage.getWidth(), SMALL_PADDING);\r\n    Verification verification = verificationSet.getVerification();\r\n    ApplyCaptionOutsideImageFilter applyCaptionOutsideImageFilter = new ApplyCaptionOutsideImageFilter(PointLocations.BOTTOM_CENTER, DEFAULT_TEXT_FONT.deriveFont(80f).deriveFont(80f), verificationColor, verification.isIdentical ? String.format(\"Match (confidence %.3f)\", verification.confidence) : String.format(\"No Match (confidence %.3f)\", verification.confidence));\r\n    bufferedImage = applyCaptionOutsideImageFilter.applyFilter(lineJoinRectangleFilter.applyFilter(mergeImagesFilter.applyFilter(bufferedImage)));\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.processing.AbstractEvaluator._evaluateLeftGreaterRight",
	"Comment": "this internal method simply makes a type safe call the the properabstract method based on the type of element passed.",
	"Method": "Object _evaluateLeftGreaterRight(Object element,String lvalue,String rvalue){\r\n    if (element instanceof List) {\r\n        return evaluateLeftGreaterRight((List) element, lvalue, rvalue);\r\n    } else {\r\n        return evaluateLeftGreaterRight((StructuredContent) element, lvalue, rvalue);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.charts.views.XYChart.drawText",
	"Comment": "the graphical representation of a text, to handle both horizontal andvertical orientations and extra rotation angles.",
	"Method": "void drawText(Canvas canvas,String text,float x,float y,Paint paint,float extraAngle){\r\n    float angle = -mRenderer.getOrientation().getAngle() + extraAngle;\r\n    if (angle != 0) {\r\n        canvas.rotate(angle, x, y);\r\n    }\r\n    drawString(canvas, text, x, y, paint);\r\n    if (angle != 0) {\r\n        canvas.rotate(-angle, x, y);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.findCommandComponent",
	"Comment": "find the command component instance if such an instance exists",
	"Method": "Button findCommandComponent(Command c,Button findCommandComponent,Command c,Container cnt){\r\n    int count = cnt.getComponentCount();\r\n    for (int iter = 0; iter < count; iter++) {\r\n        Component current = cnt.getComponentAt(iter);\r\n        if (current instanceof Button) {\r\n            Button b = (Button) current;\r\n            if (b.getCommand() == c) {\r\n                return b;\r\n            }\r\n        } else {\r\n            if (current instanceof Container) {\r\n                Button b = findCommandComponent(c, (Container) current);\r\n                if (b != null) {\r\n                    return b;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudObject.commitBinding",
	"Comment": "if deferred changes exist this method applies these changes to the data",
	"Method": "void commitBinding(){\r\n    if (deferedValues != null && deferedValues.size() > 0) {\r\n        Enumeration en = deferedValues.keys();\r\n        while (en.hasMoreElements()) {\r\n            Object k = en.nextElement();\r\n            values.put(k, deferedValues.get(k));\r\n        }\r\n        deferedValues = null;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.setPriority",
	"Comment": "the priority of this connection based on the constants in this class",
	"Method": "void setPriority(byte priority){\r\n    this.priority = priority;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractList.equals",
	"Comment": "compares the specified object to this list and return true if they areequal. two lists are equal when they both contain the same objects in thesame order.",
	"Method": "boolean equals(Object object){\r\n    if (this == object) {\r\n        return true;\r\n    }\r\n    if (object instanceof List) {\r\n        List<?> list = (List<?>) object;\r\n        if (list.size() != size()) {\r\n            return false;\r\n        }\r\n        Iterator<?> it1 = iterator(), it2 = list.iterator();\r\n        while (it1.hasNext()) {\r\n            Object e1 = it1.next(), e2 = it2.next();\r\n            if (!(e1 == null ? e2 == null : e1.equals(e2))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.getPlatformOverrides",
	"Comment": "returns the suffixes for ovr files that should be used when loading a layered resource file on this platform",
	"Method": "String[] getPlatformOverrides(){\r\n    return new String[0];\r\n}"
}, {
	"Path": "com.codename1.ui.list.DefaultListCellRenderer.getSelectionTransparency",
	"Comment": "the background transparency factor to apply to the selection focus",
	"Method": "int getSelectionTransparency(){\r\n    return focusComponent.getUnselectedStyle().getBgTransparency() & 0xff;\r\n}"
}, {
	"Path": "com.codename1.ui.validation.Validator.getValidationFailureHighlightMode",
	"Comment": "indicates the default mode in which validation failures are expressed",
	"Method": "HighlightMode getValidationFailureHighlightMode(){\r\n    return validationFailureHighlightMode;\r\n}"
}, {
	"Path": "com.codename1.impl.blackberry.BlackBerryImplementation.createMedia",
	"Comment": "plays the sound in the given uri which is partially platform specific.",
	"Method": "Media createMedia(String uri,boolean isVideo,Runnable onCompletion,Media createMedia,InputStream stream,String mimeType,Runnable onCompletion){\r\n    MMAPIPlayer player = MMAPIPlayer.createPlayer(stream, mimeType, onCompletion);\r\n    if (mimeType.indexOf(\"video\") > -1) {\r\n        VideoMainScreen video = new VideoMainScreen(player, this);\r\n        return video;\r\n    }\r\n    return player;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractList.indexOf",
	"Comment": "searches this list for the specified object and returns the index of thefirst occurrence.",
	"Method": "int indexOf(Object object){\r\n    ListIterator<?> it = listIterator();\r\n    if (object != null) {\r\n        while (it.hasNext()) {\r\n            if (object.equals(it.next())) {\r\n                return it.previousIndex();\r\n            }\r\n        }\r\n    } else {\r\n        while (it.hasNext()) {\r\n            if (it.next() == null) {\r\n                return it.previousIndex();\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.codename1.io.rest.RequestBuilder.fetchAsJsonMap",
	"Comment": "executes the request asynchronously and writes the response to the providedcallback",
	"Method": "ConnectionRequest fetchAsJsonMap(OnComplete<Response<Map>> callback){\r\n    ConnectionRequest request = createRequest(true);\r\n    request.addResponseListener(new ActionListener<NetworkEvent>() {\r\n        @Override\r\n        public void actionPerformed(NetworkEvent evt) {\r\n            Response res = null;\r\n            Map response = (Map) evt.getMetaData();\r\n            res = new Response(evt.getResponseCode(), response, evt.getMessage());\r\n            callback.completed(res);\r\n        }\r\n    });\r\n    CN.addToQueue(request);\r\n    return request;\r\n}"
}, {
	"Path": "com.codename1.io.rest.RequestBuilder.fetchAsJsonMap",
	"Comment": "executes the request asynchronously and writes the response to the providedcallback",
	"Method": "ConnectionRequest fetchAsJsonMap(OnComplete<Response<Map>> callback){\r\n    Response res = null;\r\n    Map response = (Map) evt.getMetaData();\r\n    res = new Response(evt.getResponseCode(), response, evt.getMessage());\r\n    callback.completed(res);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.getInvisibleAreaUnderVKB",
	"Comment": "returns the height of the vkb when it is open for an implementation that requiresus to allow scrolling further",
	"Method": "int getInvisibleAreaUnderVKB(){\r\n    return 0;\r\n}"
}, {
	"Path": "org.conscrypt.CertBlacklistTest.testBlacklistedCaUntrusted",
	"Comment": "check that the blacklisted ca is rejected even if it used as a root of trust",
	"Method": "void testBlacklistedCaUntrusted(){\r\n    X509Certificate blacklistedCa = loadCertificate(BLACKLIST_CA);\r\n    assertUntrusted(new X509Certificate[] { blacklistedCa }, getTrustManager(blacklistedCa));\r\n}"
}, {
	"Path": "java.util.HashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    if (keySet == null) {\r\n        keySet = new AbstractSet<K>() {\r\n            @Override\r\n            public boolean contains(Object object) {\r\n                return containsKey(object);\r\n            }\r\n            @Override\r\n            public int size() {\r\n                return HashMap.this.size();\r\n            }\r\n            @Override\r\n            public void clear() {\r\n                HashMap.this.clear();\r\n            }\r\n            @Override\r\n            public boolean remove(Object key) {\r\n                Entry<K, V> entry = HashMap.this.removeEntry(key);\r\n                return entry != null;\r\n            }\r\n            @Override\r\n            public Iterator<K> iterator() {\r\n                return new KeyIterator<K, V>(HashMap.this);\r\n            }\r\n        };\r\n    }\r\n    return keySet;\r\n}"
}, {
	"Path": "java.util.HashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return containsKey(object);\r\n}"
}, {
	"Path": "java.util.HashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return HashMap.this.size();\r\n}"
}, {
	"Path": "java.util.HashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    HashMap.this.clear();\r\n}"
}, {
	"Path": "java.util.HashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    Entry<K, V> entry = HashMap.this.removeEntry(key);\r\n    return entry != null;\r\n}"
}, {
	"Path": "java.util.HashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return new KeyIterator<K, V>(HashMap.this);\r\n}"
}, {
	"Path": "com.alibaba.citrus.service.requestcontext.util.tomcat.ServerCookie.getCookieHeaderName",
	"Comment": "return the header name to set the cookie, based on cookie version.",
	"Method": "String getCookieHeaderName(int version){\r\n    if (version == 1) {\r\n        return \"Set-Cookie\";\r\n    } else {\r\n        return \"Set-Cookie\";\r\n    }\r\n}"
}, {
	"Path": "org.conscrypt.AddressUtils.isValidSniHostname",
	"Comment": "returns true when the supplied hostname is valid for sni purposes.",
	"Method": "boolean isValidSniHostname(String sniHostname){\r\n    if (sniHostname == null) {\r\n        return false;\r\n    }\r\n    return (sniHostname.equalsIgnoreCase(\"localhost\") || sniHostname.indexOf('.') != -1) && !Platform.isLiteralIpAddress(sniHostname) && !sniHostname.endsWith(\".\") && sniHostname.indexOf('\\0') == -1;\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetTableModel.setSortingCategories",
	"Comment": "set whether this model is currently sorting categories.if this changes the sorting, the model will be rebuilt.",
	"Method": "void setSortingCategories(boolean value){\r\n    boolean old = sortingCategories;\r\n    sortingCategories = value;\r\n    if (sortingCategories != old)\r\n        buildModel();\r\n}"
}, {
	"Path": "mondrian.rolap.RolapStar.getDataSource",
	"Comment": "returns the datasource used to calloutconnect to the underlying dbms.",
	"Method": "DataSource getDataSource(){\r\n    return dataSource;\r\n}"
}, {
	"Path": "com.codename1.ui.validation.RegexConstraint.validEmail",
	"Comment": "generates a valid email constraint by using a regular expression",
	"Method": "Constraint validEmail(String errorMessage,Constraint validEmail){\r\n    return new RegexConstraint(validEmailRegex, \"Invalid Email Address\");\r\n}"
}, {
	"Path": "com.codename1.io.Log.showLog",
	"Comment": "places a form with the log as a textarea on the screen, this method canbe attached to appear at a given time or using a fixed global key. usingthis method might cause a problem with further log output",
	"Method": "void showLog(){\r\n    try {\r\n        String text = getLogContent();\r\n        TextArea area = new TextArea(text, 5, 20);\r\n        Form f = new Form(\"Log\");\r\n        f.setScrollable(false);\r\n        final Form current = Display.getInstance().getCurrent();\r\n        Command back = new Command(\"Back\") {\r\n            public void actionPerformed(ActionEvent ev) {\r\n                current.show();\r\n            }\r\n        };\r\n        f.addCommand(back);\r\n        f.setBackCommand(back);\r\n        f.setLayout(new BorderLayout());\r\n        f.addComponent(BorderLayout.CENTER, area);\r\n        f.show();\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.Log.showLog",
	"Comment": "places a form with the log as a textarea on the screen, this method canbe attached to appear at a given time or using a fixed global key. usingthis method might cause a problem with further log output",
	"Method": "void showLog(){\r\n    current.show();\r\n}"
}, {
	"Path": "com.codename1.impl.android.AndroidImplementation.addActionsToNotification",
	"Comment": "adds actions to a push notification.this is called by the push broadcast receiver probably before codename one is initialized",
	"Method": "void addActionsToNotification(PushActionsProvider provider,String categoryId,NotificationCompat.Builder builder,Intent targetIntent,Context context){\r\n    PushActionCategory category = null;\r\n    PushActionCategory[] categories;\r\n    if (provider != null) {\r\n        categories = provider.getPushActionCategories();\r\n    } else {\r\n        categories = getInstalledPushActionCategories(context);\r\n    }\r\n    for (PushActionCategory candidateCategory : categories) {\r\n        if (categoryId.equals(candidateCategory.getId())) {\r\n            category = candidateCategory;\r\n            break;\r\n        }\r\n    }\r\n    if (category == null) {\r\n        return;\r\n    }\r\n    int requestCode = 1;\r\n    for (PushAction action : category.getActions()) {\r\n        Intent newIntent = (Intent) targetIntent.clone();\r\n        newIntent.putExtra(\"pushActionId\", action.getId());\r\n        PendingIntent contentIntent = PendingIntent.getActivity(context, requestCode++, newIntent, PendingIntent.FLAG_CANCEL_CURRENT);\r\n        try {\r\n            int iconId = 0;\r\n            try {\r\n                iconId = Integer.parseInt(action.getIcon());\r\n            } catch (Exception ex) {\r\n            }\r\n            System.out.println(\"Adding action \" + action.getId() + \", \" + action.getTitle() + \", icon=\" + iconId);\r\n            builder.addAction(iconId, action.getTitle(), contentIntent);\r\n        } catch (Exception ex) {\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.l2fprod.common.swing.plaf.LookAndFeelAddons.getSystemAddonClassName",
	"Comment": "gets the addon best suited for the operating system where thevirtual machine is running.",
	"Method": "String getSystemAddonClassName(){\r\n    String addon = WindowsClassicLookAndFeelAddons.class.getName();\r\n    if (OS.isMacOSX()) {\r\n        addon = AquaLookAndFeelAddons.class.getName();\r\n    } else if (OS.isWindows()) {\r\n        if (OS.isUsingWindowsVisualStyles()) {\r\n            addon = WindowsLookAndFeelAddons.class.getName();\r\n        } else {\r\n            addon = WindowsClassicLookAndFeelAddons.class.getName();\r\n        }\r\n    }\r\n    return addon;\r\n}"
}, {
	"Path": "com.codename1.util.regex.RECompiler.expr",
	"Comment": "compile an expression with possible parens around it.paren matchingis done at this level so we can tie the branch tails together.",
	"Method": "int expr(int[] flags){\r\n    int paren = -1;\r\n    int ret = -1;\r\n    int closeParens = parens;\r\n    if ((flags[0] & NODE_TOPLEVEL) == 0 && pattern.charAt(idx) == '(') {\r\n        if (idx + 2 < len && pattern.charAt(idx + 1) == '?' && pattern.charAt(idx + 2) == ':') {\r\n            paren = 2;\r\n            idx += 3;\r\n            ret = node(RE.OP_OPEN_CLUSTER, 0);\r\n        } else {\r\n            paren = 1;\r\n            idx++;\r\n            ret = node(RE.OP_OPEN, parens++);\r\n        }\r\n    }\r\n    flags[0] &= ~NODE_TOPLEVEL;\r\n    boolean open = false;\r\n    int branch = branch(flags);\r\n    if (ret == -1) {\r\n        ret = branch;\r\n    } else {\r\n        setNextOfEnd(ret, branch);\r\n    }\r\n    while (idx < len && pattern.charAt(idx) == '|') {\r\n        if (!open) {\r\n            nodeInsert(RE.OP_BRANCH, 0, branch);\r\n            open = true;\r\n        }\r\n        idx++;\r\n        setNextOfEnd(branch, branch = node(RE.OP_BRANCH, 0));\r\n        branch(flags);\r\n    }\r\n    int end;\r\n    if (paren > 0) {\r\n        if (idx < len && pattern.charAt(idx) == ')') {\r\n            idx++;\r\n        } else {\r\n            syntaxError(\"Missing close paren\");\r\n        }\r\n        if (paren == 1) {\r\n            end = node(RE.OP_CLOSE, closeParens);\r\n        } else {\r\n            end = node(RE.OP_CLOSE_CLUSTER, 0);\r\n        }\r\n    } else {\r\n        end = node(RE.OP_END, 0);\r\n    }\r\n    setNextOfEnd(ret, end);\r\n    int currentNode = ret;\r\n    int nextNodeOffset = instruction[currentNode + RE.offsetNext];\r\n    while (nextNodeOffset != 0 && currentNode < lenInstruction) {\r\n        if (instruction[currentNode] == RE.OP_BRANCH) {\r\n            setNextOfEnd(currentNode + RE.nodeSize, end);\r\n        }\r\n        nextNodeOffset = instruction[currentNode + RE.offsetNext];\r\n        currentNode += nextNodeOffset;\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.getFileSystemRoots",
	"Comment": "returns the filesystem roots from which the structure of the file systemcan be traversed",
	"Method": "String[] getFileSystemRoots(){\r\n    return FileSystemStorage.getInstance().getRoots();\r\n}"
}, {
	"Path": "android.support.v4.view.ViewPager.executeKeyEvent",
	"Comment": "you can call this function yourself to have the scroll view performscrolling from a key event, just as if the event had been dispatched toit by the view hierarchy.",
	"Method": "boolean executeKeyEvent(KeyEvent event){\r\n    boolean handled = false;\r\n    if (event.getAction() == KeyEvent.ACTION_DOWN) {\r\n        switch(event.getKeyCode()) {\r\n            case KeyEvent.KEYCODE_DPAD_LEFT:\r\n                handled = arrowScroll(FOCUS_LEFT);\r\n                break;\r\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\r\n                handled = arrowScroll(FOCUS_RIGHT);\r\n                break;\r\n            case KeyEvent.KEYCODE_TAB:\r\n                if (Build.VERSION.SDK_INT >= 11) {\r\n                    if (KeyEventCompat.hasNoModifiers(event)) {\r\n                        handled = arrowScroll(FOCUS_FORWARD);\r\n                    } else if (KeyEventCompat.hasModifiers(event, KeyEvent.META_SHIFT_ON)) {\r\n                        handled = arrowScroll(FOCUS_BACKWARD);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return handled;\r\n}"
}, {
	"Path": "android.support.v4.app.FragmentPagerAdapter.getItemId",
	"Comment": "return a unique identifier for the item at the given position.the default implementation returns the given position.subclasses should override this method if the positions of items can change.",
	"Method": "long getItemId(int position){\r\n    return position;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getPropertyValue",
	"Comment": "returns the current value of the property name, this method is used by the gui builder",
	"Method": "Object getPropertyValue(String name){\r\n    return null;\r\n}"
}, {
	"Path": "com.l2fprod.common.beans.ExtendedPropertyDescriptor.setPropertyTableRendererClass",
	"Comment": "you can associate a special tablecellrenderer with a particularproperty. if set to null default renderer will be used.",
	"Method": "void setPropertyTableRendererClass(Class tableCellRendererClass){\r\n    this.tableCellRendererClass = tableCellRendererClass;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Style.isLowered3DText",
	"Comment": "returns true if the 3d text decoration is on, false otherwise",
	"Method": "boolean isLowered3DText(){\r\n    return ((textDecoration & TEXT_DECORATION_3D_LOWERED) != 0);\r\n}"
}, {
	"Path": "java.lang.Double.isInfinite",
	"Comment": "indicates whether the specified double represents an infinite value.",
	"Method": "boolean isInfinite(boolean isInfinite,double v){\r\n    return (d == POSITIVE_INFINITY) || (d == NEGATIVE_INFINITY);\r\n}"
}, {
	"Path": "com.codename1.ui.RadioButton.createToggle",
	"Comment": "shorthand for creating the radio button, adding it to a group, setting the command and making it into a toggle button",
	"Method": "RadioButton createToggle(String text,Image icon,ButtonGroup bg,RadioButton createToggle,String text,ButtonGroup bg,RadioButton createToggle,Image icon,ButtonGroup bg,RadioButton createToggle,Command cmd,ButtonGroup bg){\r\n    RadioButton rb = new RadioButton(cmd.getCommandName(), cmd.getIcon());\r\n    rb.setCommand(cmd);\r\n    bg.add(rb);\r\n    rb.setToggle(true);\r\n    return rb;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.ComponentAnimation.sequentialAnimation",
	"Comment": "allows us to create an animation that places several separate animations in a sequence so they appear as a single animation to the system and process one after the other",
	"Method": "ComponentAnimation sequentialAnimation(ComponentAnimation anims){\r\n    return new CompoundAnimation(anims, true);\r\n}"
}, {
	"Path": "com.codename1.ui.validation.Validator.getDefaultValidationFailureHighlightMode",
	"Comment": "indicates the default mode in which validation failures are expressed",
	"Method": "HighlightMode getDefaultValidationFailureHighlightMode(){\r\n    return defaultValidationFailureHighlightMode;\r\n}"
}, {
	"Path": "com.codename1.charts.models.XYSeries.getRange",
	"Comment": "returns submap of x and y values according to the given start and end",
	"Method": "SortedMap<Double, Double> getRange(double start,double stop,boolean beforeAfterPoints){\r\n    if (beforeAfterPoints) {\r\n        SortedMap<Double, Double> headMap = mXY.headMap(start);\r\n        if (!headMap.isEmpty()) {\r\n            start = headMap.lastKey();\r\n        }\r\n        SortedMap<Double, Double> tailMap = mXY.tailMap(stop);\r\n        if (!tailMap.isEmpty()) {\r\n            Iterator<Double> tailIterator = tailMap.keySet().iterator();\r\n            Double next = tailIterator.next();\r\n            if (tailIterator.hasNext()) {\r\n                stop = tailIterator.next();\r\n            } else {\r\n                stop += next;\r\n            }\r\n        }\r\n    }\r\n    if (start <= stop) {\r\n        return mXY.subMap(start, stop);\r\n    } else {\r\n        return new TreeMap<Double, Double>();\r\n    }\r\n}"
}, {
	"Path": "tests.net.DelegatingSocketFactory.configureSocket",
	"Comment": "invoked after obtaining a socket from the delegate and before returning it to the caller.the default implementation does nothing.",
	"Method": "Socket configureSocket(Socket socket){\r\n    return socket;\r\n}"
}, {
	"Path": "com.codename1.social.FacebookConnect.isFacebookSDKSupported",
	"Comment": "indicates whether the native platform supports native facebook login",
	"Method": "boolean isFacebookSDKSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.addDataChangeListener",
	"Comment": "allows tracking selection changes in the calendar in real time",
	"Method": "void addDataChangeListener(DataChangedListener l){\r\n    mv.addDataChangedListener(l);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.TreeSet.tailSet",
	"Comment": "answers a sortedset of the specified portion of this treeset whichcontains elements greater or equal to the start element. the returnedsortedset is backed by this treeset so changes to one are reflected bythe other.",
	"Method": "NavigableSet<E> tailSet(E start,boolean startInclusive,SortedSet<E> tailSet,E start){\r\n    return tailSet(start, true);\r\n}"
}, {
	"Path": "com.codename1.ui.Image.dispose",
	"Comment": "do not call this method unless you know what you are doing, it will cause platform specifc crashes otherwise! images disposeautomatically for most cases except for very rare special cases.images on devices usually holds a native memory, some platforms garbage collectors might fail to release the native and to fail with out of memoryerrors.use this method to make sure the image will be released from memory, after calling this the image will become unusable.",
	"Method": "void dispose(){\r\n    if (image != null) {\r\n        Display.impl.releaseImage(image);\r\n    }\r\n    image = null;\r\n}"
}, {
	"Path": "com.codename1.ui.Image.rotate90Degrees",
	"Comment": "rotates this image by 90 degrees while changing the ratio of the picture",
	"Method": "Image rotate90Degrees(boolean maintainOpacity){\r\n    return Display.impl.rotate90Degrees(this, maintainOpacity);\r\n}"
}, {
	"Path": "com.codename1.ui.Form.registerAnimated",
	"Comment": "the given component is interested in animating its appearance and will startreceiving callbacks when it is visible in the form allowing it to animateits appearance. this method would not register a compnent instance more than once",
	"Method": "void registerAnimated(Animation cmp){\r\n    if (animatableComponents == null) {\r\n        animatableComponents = new ArrayList<Animation>();\r\n    }\r\n    if (!animatableComponents.contains(cmp)) {\r\n        animatableComponents.add(cmp);\r\n    }\r\n    Display.getInstance().notifyDisplay();\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.Picker.getPreferredPopupHeight",
	"Comment": "the preferred height of the popup dialog.this will only be used on devices where the popup width and height are configurable, such as the ipad or tablets.on iphone, the picker always spans the width of the screen along the bottom.",
	"Method": "int getPreferredPopupHeight(){\r\n    return preferredPopupHeight;\r\n}"
}, {
	"Path": "com.codename1.ui.validation.Validator.setValidationFailedEmblem",
	"Comment": "the emblem that will be drawn on top of the component to indicate the validation failure",
	"Method": "void setValidationFailedEmblem(Image validationFailedEmblem){\r\n    this.validationFailedEmblem = validationFailedEmblem;\r\n}"
}, {
	"Path": "android.support.v4.view.ViewCompat.hasTransientState",
	"Comment": "indicates whether the view is currently tracking transient state that theapp should not need to concern itself with saving and restoring, but thatthe framework should take special note to preserve when possible.",
	"Method": "boolean hasTransientState(View view,boolean hasTransientState,View view,boolean hasTransientState,View view,boolean hasTransientState,View view){\r\n    return IMPL.hasTransientState(view);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.BitSet.length",
	"Comment": "returns the number of bits up to and including the highest bit set.",
	"Method": "int length(){\r\n    int idx = actualArrayLength - 1;\r\n    while (idx >= 0 && bits[idx] == 0) {\r\n        --idx;\r\n    }\r\n    actualArrayLength = idx + 1;\r\n    if (idx == -1) {\r\n        return 0;\r\n    }\r\n    int i = ELM_SIZE - 1;\r\n    long val = bits[idx];\r\n    while ((val & (TWO_N_ARRAY[i])) == 0 && i > 0) {\r\n        i--;\r\n    }\r\n    return (idx << OFFSET) + i + 1;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getVisibleBounds",
	"Comment": "returns the component bounds for scrolling which might differ from the getbounds for large componentse.g. list.",
	"Method": "Rectangle getVisibleBounds(){\r\n    return bounds;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.CommonTransitions.isLinearMotion",
	"Comment": "indicates whether the motion associated with this transition is linear or spline motion",
	"Method": "boolean isLinearMotion(){\r\n    return linearMotion;\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetTableModel.setCategorySortingComparator",
	"Comment": "set the comparator used for sorting categories.if thischanges the comparator, the model will be rebuilt.",
	"Method": "void setCategorySortingComparator(Comparator comp){\r\n    Comparator old = categorySortingComparator;\r\n    categorySortingComparator = comp;\r\n    if (categorySortingComparator != old)\r\n        buildModel();\r\n}"
}, {
	"Path": "com.l2fprod.common.swing.PercentLayout.minimumLayoutSize",
	"Comment": "calculates the minimum size dimensions for the specified panel given thecomponents in the specified parent container.",
	"Method": "Dimension minimumLayoutSize(Container parent){\r\n    return preferredLayoutSize(parent);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isOpenNativeNavigationAppSupported",
	"Comment": "returns true if the underlying os supports opening the native navigationapplication",
	"Method": "boolean isOpenNativeNavigationAppSupported(){\r\n    return impl.isOpenNativeNavigationAppSupported();\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.setChangesSelectedDateEnabled",
	"Comment": "this flag determines if selected date can be changed by selecting analternative date",
	"Method": "void setChangesSelectedDateEnabled(boolean changesSelectedDateEnabled){\r\n    this.changesSelectedDateEnabled = changesSelectedDateEnabled;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.getSoftButton",
	"Comment": "returns the button representing the softbutton, this allows modifying softbuttonattributes and behavior programmatically rather than by using the command api.notice that this api behavior is fragile since the button mapped to a particularoffset might change based on the command api",
	"Method": "Button getSoftButton(int offset){\r\n    return menuBar.getSoftButtons()[offset];\r\n}"
}, {
	"Path": "com.codename1.ui.Form.isMinimizeOnBack",
	"Comment": "when set to true the physical back button will minimize the application",
	"Method": "boolean isMinimizeOnBack(){\r\n    return menuBar.isMinimizeOnBack();\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.setHintIcon",
	"Comment": "sets the textarea hint icon, the hint is displayed on the textareawhen there is no text in the textarea",
	"Method": "void setHintIcon(Image icon){\r\n    setHint(getHint(), icon);\r\n}"
}, {
	"Path": "com.codename1.io.FileSystemStorage.getLastModified",
	"Comment": "returns the time that the file denoted by this abstract pathname was last modified.",
	"Method": "long getLastModified(String file){\r\n    return Util.getImplementation().getFileLastModified(file);\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.getDefaultValign",
	"Comment": "indicates the default vertical alignment for a text field, only applies to single line text fields",
	"Method": "int getDefaultValign(){\r\n    return defaultValign;\r\n}"
}, {
	"Path": "com.codename1.ui.html.CellConstraint.setVerticalSpan",
	"Comment": "sets the cells to span vertically, this number must never be smaller than 1",
	"Method": "void setVerticalSpan(int span){\r\n    if (span < 1) {\r\n        throw new IllegalArgumentException(\"Illegal span\");\r\n    }\r\n    spanVertical = span;\r\n}"
}, {
	"Path": "android.support.v4.net.ConnectivityManagerCompat.isActiveNetworkMetered",
	"Comment": "returns if the currently active data network is metered. a network isclassified as metered when the user is sensitive to heavy data usage onthat connection. you should check this before doing large data transfers,and warn the user or delay the operation until another network isavailable.",
	"Method": "boolean isActiveNetworkMetered(ConnectivityManager cm,boolean isActiveNetworkMetered,ConnectivityManager cm,boolean isActiveNetworkMetered,ConnectivityManager cm,boolean isActiveNetworkMetered,ConnectivityManager cm,boolean isActiveNetworkMetered,ConnectivityManager cm,boolean isActiveNetworkMetered,ConnectivityManager cm){\r\n    return IMPL.isActiveNetworkMetered(cm);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setInlineAllStyles",
	"Comment": "registers inline styles that should be applied to all states of the component.",
	"Method": "void setInlineAllStyles(String styles){\r\n    if (styles != null && styles.trim().length() == 0) {\r\n        styles = null;\r\n    }\r\n    if (styles == null ? inlineAllStyles != null : !styles.equals(inlineAllStyles)) {\r\n        this.inlineAllStyles = styles;\r\n        unSelectedStyle = null;\r\n        selectedStyle = null;\r\n        disabledStyle = null;\r\n        pressedStyle = null;\r\n        allStyles = null;\r\n        if (!sizeRequestedByUser) {\r\n            preferredSize = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Form.setTintColor",
	"Comment": "default color for the screen tint when a dialog or a menu is shown",
	"Method": "void setTintColor(int tintColor){\r\n    this.tintColor = tintColor;\r\n}"
}, {
	"Path": "com.codename1.charts.ChartComponent.screenToChartShape",
	"Comment": "converts a chart coordinate spaced shape to the same shape in the screen coordinate space",
	"Method": "Shape screenToChartShape(Shape s){\r\n    GeneralPath p = new GeneralPath();\r\n    Transform t = Transform.makeIdentity();\r\n    if (currentTransform != null) {\r\n        t.concatenate(currentTransform.getInverse());\r\n    }\r\n    t.translate(-getAbsoluteX(), -getAbsoluteY());\r\n    p.append(s.getPathIterator(t), false);\r\n    return p;\r\n}"
}, {
	"Path": "org.conscrypt.TrustManagerImpl.sortPotentialAnchors",
	"Comment": "sort potential anchors so that the most preferred for use come first.",
	"Method": "Collection<TrustAnchor> sortPotentialAnchors(Set<TrustAnchor> anchors){\r\n    if (anchors.size() <= 1) {\r\n        return anchors;\r\n    }\r\n    List<TrustAnchor> sortedAnchors = new ArrayList<TrustAnchor>(anchors);\r\n    Collections.sort(sortedAnchors, TRUST_ANCHOR_COMPARATOR);\r\n    return sortedAnchors;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.SegmentManager.storage",
	"Comment": "returns the storage configuration underlying the segment manager.",
	"Method": "Storage storage(){\r\n    return storage;\r\n}"
}, {
	"Path": "com.codename1.ui.List.updateAnimationPosition",
	"Comment": "updates the animation constant to a new value based on a keypress",
	"Method": "void updateAnimationPosition(int direction){\r\n    if (animationPosition != 0) {\r\n        animationPosition = 0;\r\n        animate();\r\n    }\r\n    if (isSmoothScrolling()) {\r\n        if (orientation != HORIZONTAL) {\r\n            animationPosition += (direction * getElementSize(false, true).getHeight());\r\n        } else {\r\n            animationPosition += (direction * getElementSize(false, true).getWidth());\r\n        }\r\n        destination = Math.abs(animationPosition);\r\n        initListMotion();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.wasThemeInstalled",
	"Comment": "indicates if a theme was previously installed since the last reset",
	"Method": "boolean wasThemeInstalled(){\r\n    return wasThemeInstalled;\r\n}"
}, {
	"Path": "com.codename1.location.GeofenceManager.setListenerClass",
	"Comment": "sets the geofencelistener class that should receive geofence events.",
	"Method": "void setListenerClass(Class<? extends GeofenceListener> c){\r\n    listenerClass = (Class) c;\r\n    if (c == null) {\r\n        Storage.getInstance().deleteStorageFile(LISTENER_CLASS_KEY);\r\n    } else {\r\n        Storage.getInstance().writeObject(LISTENER_CLASS_KEY, c.getName());\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.List.calculateComponentPosition",
	"Comment": "calculates the desired bounds for the component and returns them within thegiven rectangle.",
	"Method": "void calculateComponentPosition(int index,int defaultWidth,Rectangle rect,Dimension rendererSize,Dimension selectedSize,boolean beforeSelected){\r\n    Style style = getStyle();\r\n    int initialY = style.getPaddingTop();\r\n    int initialX = style.getPaddingLeftNoRTL();\r\n    boolean rtl = isRTL();\r\n    if (rtl) {\r\n        initialX += getSideGap();\r\n    }\r\n    int selection = getCurrentSelected();\r\n    Dimension d = rect.getSize();\r\n    int selectedDiff;\r\n    if (orientation != HORIZONTAL) {\r\n        int height = rendererSize.getHeight();\r\n        selectedDiff = selectedSize.getHeight() - height;\r\n        rect.setX(initialX);\r\n        d.setHeight(height);\r\n        d.setWidth(defaultWidth);\r\n        int y = 0;\r\n        int listHeight = getHeight() - style.getVerticalPadding();\r\n        int totalHeight = (height + itemGap) * getModel().getSize() + selectedDiff;\r\n        switch(fixedSelection) {\r\n            case FIXED_CENTER:\r\n                y = listHeight / 2 - (height + itemGap + selectedDiff) / 2 + (index - selection) * (height + itemGap);\r\n                if (!beforeSelected) {\r\n                    y += selectedDiff;\r\n                }\r\n                y = recalcOffset(y, totalHeight, listHeight, height + itemGap);\r\n                break;\r\n            case FIXED_TRAIL:\r\n                y = listHeight - (height + itemGap + selectedDiff);\r\n            case FIXED_LEAD:\r\n                y += (index - selection) * (height + itemGap);\r\n                if (index - selection > 0) {\r\n                    y += selectedDiff;\r\n                }\r\n                y = recalcOffset(y, totalHeight, listHeight, height + itemGap);\r\n                break;\r\n            default:\r\n                y = index * (height + itemGap);\r\n                if (!beforeSelected) {\r\n                    y += selectedDiff;\r\n                }\r\n                break;\r\n        }\r\n        rect.setY(y + initialY);\r\n        if (index == selection) {\r\n            d.setHeight(d.getHeight() + selectedDiff);\r\n        }\r\n    } else {\r\n        int width = rendererSize.getWidth();\r\n        selectedDiff = selectedSize.getWidth() - width;\r\n        rect.setY(initialY);\r\n        d.setHeight(getHeight() - style.getVerticalPadding());\r\n        d.setWidth(width);\r\n        int x = 0;\r\n        int listWidth = getWidth() - style.getHorizontalPadding();\r\n        int totalWidth = (width + itemGap) * getModel().getSize() + selectedDiff;\r\n        switch(fixedSelection) {\r\n            case FIXED_CENTER:\r\n                x = listWidth / 2 - (width + itemGap + selectedDiff) / 2 + (index - selection) * (width + itemGap);\r\n                if (!beforeSelected) {\r\n                    x += selectedDiff;\r\n                }\r\n                if (rtl) {\r\n                    x = listWidth - x - width;\r\n                }\r\n                x = recalcOffset(x, totalWidth, listWidth, width + itemGap);\r\n                break;\r\n            case FIXED_TRAIL:\r\n                x = listWidth - (width + itemGap + selectedDiff);\r\n            case FIXED_LEAD:\r\n                x += (index - selection) * (width + itemGap);\r\n                if (index - selection > 0) {\r\n                    x += selectedDiff;\r\n                }\r\n                if (rtl) {\r\n                    x = listWidth - x - width;\r\n                }\r\n                x = recalcOffset(x, totalWidth, listWidth, width + itemGap);\r\n                break;\r\n            default:\r\n                x = index * (width + itemGap);\r\n                if (!beforeSelected) {\r\n                    x += selectedDiff;\r\n                }\r\n                break;\r\n        }\r\n        int rectX = initialX + x;\r\n        if ((rtl) && (fixedSelection < FIXED_NONE_BOUNDRY)) {\r\n            rectX = initialX + totalWidth - (x - initialX) - (width + itemGap);\r\n            if (index == getCurrentSelected()) {\r\n                rectX -= selectedDiff;\r\n            }\r\n            if (totalWidth < listWidth) {\r\n                rectX += (listWidth - totalWidth);\r\n            }\r\n        }\r\n        rect.setX(rectX);\r\n        if (index == selection) {\r\n            d.setWidth(d.getWidth() + selectedDiff);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Display.restoreMinimizedApplication",
	"Comment": "restore the minimized application if minimization is supported by the platform",
	"Method": "void restoreMinimizedApplication(){\r\n    getImplementation().restoreMinimizedApplication();\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetTableModel.getPropertiesForCategory",
	"Comment": "convenience method to get all the properties of one category.",
	"Method": "List getPropertiesForCategory(List localProperties,String category){\r\n    List categoryProperties = new ArrayList();\r\n    for (Iterator iter = localProperties.iterator(); iter.hasNext(); ) {\r\n        Property property = (Property) iter.next();\r\n        if ((category == property.getCategory()) || (category != null && category.equals(property.getCategory()))) {\r\n            categoryProperties.add(property);\r\n        }\r\n    }\r\n    return categoryProperties;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayeredLayout.setReferenceComponentLeft",
	"Comment": "sets the reference component for the left inset of the given component.",
	"Method": "LayeredLayout setReferenceComponentLeft(Component cmp,Component referenceComponent,LayeredLayout setReferenceComponentLeft,Component cmp,Component referenceComponent,float position){\r\n    getOrCreateConstraint(cmp).left().referenceComponent(referenceComponent).referencePosition(position);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.events.ActionEvent.getCommand",
	"Comment": "if this event was sent as a result of a command action this method returnsthat command",
	"Method": "Command getCommand(){\r\n    if (source instanceof Command) {\r\n        return (Command) source;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.toArray",
	"Comment": "returns an array containing all elements contained in this vector. if thespecified array is large enough to hold the elements, the specified arrayis used, otherwise an array of the same type is created. if the specifiedarray is used and is larger than this vector, the array element followingthe collection elements is set to null.",
	"Method": "Object[] toArray(T[] toArray,T[] contents){\r\n    if (elementCount > contents.length) {\r\n        return null;\r\n    }\r\n    System.arraycopy(elementData, 0, contents, 0, elementCount);\r\n    if (elementCount < contents.length) {\r\n        contents[elementCount] = null;\r\n    }\r\n    return contents;\r\n}"
}, {
	"Path": "io.atomix.copycat.client.session.ClientSequencerTest.testSequenceEventAfterCommand",
	"Comment": "tests sequencing an event that arrives before a command response.",
	"Method": "void testSequenceEventAfterCommand(){\r\n    ClientSequencer sequencer = new ClientSequencer(new ClientSessionState(UUID.randomUUID().toString()));\r\n    long sequence = sequencer.nextRequest();\r\n    PublishRequest request = PublishRequest.builder().withSession(1).withEventIndex(1).withPreviousIndex(0).build();\r\n    CommandResponse response = CommandResponse.builder().withStatus(Response.Status.OK).withIndex(2).withEventIndex(1).build();\r\n    AtomicInteger run = new AtomicInteger();\r\n    sequencer.sequenceResponse(sequence, response, () -> assertEquals(run.getAndIncrement(), 1));\r\n    sequencer.sequenceEvent(request, () -> assertEquals(run.getAndIncrement(), 0));\r\n    assertEquals(run.get(), 2);\r\n}"
}, {
	"Path": "com.codename1.io.JSONParser.setIncludeNulls",
	"Comment": "indicates that the parser will include null values in the parsed output",
	"Method": "void setIncludeNulls(boolean aIncludeNullsDefault){\r\n    includeNullsDefault = aIncludeNullsDefault;\r\n}"
}, {
	"Path": "mondrian.olap.Util.areOccurencesEqual",
	"Comment": "returns whether a collection contains precisely one distinct element.returns false if the collection is empty, or if it contains elementsthat are not the same as each other.",
	"Method": "boolean areOccurencesEqual(Collection<T> collection){\r\n    Iterator<T> it = collection.iterator();\r\n    if (!it.hasNext()) {\r\n        return false;\r\n    }\r\n    T first = it.next();\r\n    while (it.hasNext()) {\r\n        T t = it.next();\r\n        if (!t.equals(first)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setInlinePressedStyles",
	"Comment": "registers inline styles that should be applied to the pressed state of the component.",
	"Method": "void setInlinePressedStyles(String styles){\r\n    if (styles != null && styles.trim().length() == 0) {\r\n        styles = null;\r\n    }\r\n    if (styles == null ? inlinePressedStyles != null : !styles.equals(inlinePressedStyles)) {\r\n        this.inlinePressedStyles = styles;\r\n        unSelectedStyle = null;\r\n        selectedStyle = null;\r\n        disabledStyle = null;\r\n        pressedStyle = null;\r\n        allStyles = null;\r\n        if (!sizeRequestedByUser) {\r\n            preferredSize = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.SegmentDescriptor.builder",
	"Comment": "returns a descriptor builder for the given descriptor buffer.",
	"Method": "Builder builder(Builder builder,Buffer buffer){\r\n    return new Builder(buffer);\r\n}"
}, {
	"Path": "com.codename1.ui.BrowserComponent.setNativeScrollingEnabled",
	"Comment": "this flag allows disabling the native browser scrolling on platforms that support it",
	"Method": "void setNativeScrollingEnabled(boolean b){\r\n    nativeScrolling = b;\r\n    Display.impl.setNativeBrowserScrollingEnabled(internal, b);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getInlineStylesTheme",
	"Comment": "gets the theme that is used by inline styles to reference images.",
	"Method": "Resources getInlineStylesTheme(){\r\n    return inlineStylesTheme;\r\n}"
}, {
	"Path": "java.util.Collections.synchronizedList",
	"Comment": "returns a wrapper on the specified list which synchronizes all access tothe list.",
	"Method": "List<T> synchronizedList(List<T> list){\r\n    if (list == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    if (list instanceof RandomAccess) {\r\n        return new SynchronizedRandomAccessList<T>(list);\r\n    }\r\n    return new SynchronizedList<T>(list);\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.handleIOException",
	"Comment": "handles ioexception thrown when performing a network operation",
	"Method": "void handleIOException(IOException err){\r\n    handleException(err);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.rotate90Degrees",
	"Comment": "rotates the given image by 90 degrees while changing the ratio of the picture",
	"Method": "Image rotate90Degrees(Image image,boolean maintainOpacity){\r\n    int[] rgb = image.getRGB();\r\n    int[] newRGB = new int[rgb.length];\r\n    int width = image.getWidth();\r\n    int height = image.getHeight();\r\n    for (int y = 0; y < height; y++) {\r\n        for (int x = 0; x < width; x++) {\r\n            int destX = height - y - 1;\r\n            newRGB[destX + x * height] = rgb[x + y * width];\r\n        }\r\n    }\r\n    return EncodedImage.createFromRGB(newRGB, height, width, !maintainOpacity);\r\n}"
}, {
	"Path": "java.util.ArrayDeque.poll",
	"Comment": "gets and removes the head element of this deque. this method returns nullif the deque is empty.",
	"Method": "E poll(){\r\n    return pollFirst();\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.showStetched",
	"Comment": "convenience method to show a dialog stretched to one of the sides",
	"Method": "Command showStetched(String position,boolean modal){\r\n    return showPackedImpl(position, modal, true);\r\n}"
}, {
	"Path": "com.codename1.ui.Button.setPressedIcon",
	"Comment": "indicates the icon that is displayed on the button when the button is in pressed state",
	"Method": "void setPressedIcon(Image pressedIcon){\r\n    this.pressedIcon = pressedIcon;\r\n    setShouldCalcPreferredSize(true);\r\n    checkAnimation();\r\n    repaint();\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getInlineAllStyles",
	"Comment": "gets inline styles that are to be applied to all states of this component.",
	"Method": "String getInlineAllStyles(){\r\n    return inlineAllStyles;\r\n}"
}, {
	"Path": "com.codename1.ui.FontImage.getFont",
	"Comment": "useful method to reuse the font object when creating multiple imageobjects",
	"Method": "Font getFont(){\r\n    return fnt;\r\n}"
}, {
	"Path": "com.codename1.payment.Purchase.getExpiryDate",
	"Comment": "gets the latest expiry date for a set of skus as reflected by a set of receipts.",
	"Method": "Date getExpiryDate(Receipt[] receipts,String skus,Date getExpiryDate,String skus){\r\n    return getExpiryDate(getReceipts(skus), skus);\r\n}"
}, {
	"Path": "com.codename1.payment.Purchase.isSubscriptionSupported",
	"Comment": "returns true if the subscription api is supported in this platform",
	"Method": "boolean isSubscriptionSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Command.getPressedIcon",
	"Comment": "indicates the icon that is displayed on the button when the button is inpressed state",
	"Method": "Image getPressedIcon(){\r\n    return pressedIcon;\r\n}"
}, {
	"Path": "org.conscrypt.ActiveSession.getStatusResponses",
	"Comment": "returns the ocsp stapled response. returns a copy of the internal arrays.the method signature matchesjava9.",
	"Method": "List<byte[]> getStatusResponses(){\r\n    if (peerCertificateOcspData == null) {\r\n        return Collections.<byte[]>emptyList();\r\n    }\r\n    return Collections.singletonList(peerCertificateOcspData.clone());\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.DefaultLookAndFeel.drawLabelStringValign",
	"Comment": "implements the drawstring for the text component and adjust the valignassuming the icon is in one of the sides",
	"Method": "int drawLabelStringValign(Graphics g,Label l,String str,int x,int y,int iconStringHGap,int iconHeight,int textSpaceW,int fontHeight){\r\n    switch(l.getVerticalAlignment()) {\r\n        case Component.TOP:\r\n            return drawLabelString(g, l, str, x, y, textSpaceW);\r\n        case Component.CENTER:\r\n            return drawLabelString(g, l, str, x, y + iconHeight / 2 - fontHeight / 2, textSpaceW);\r\n        default:\r\n            return drawLabelString(g, l, str, x, y + iconStringHGap, textSpaceW);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.services.CachedDataService.updateData",
	"Comment": "checks that the cached data is up to date and if a newer version exits it updates the data in place",
	"Method": "void updateData(CachedData d,ActionListener callback){\r\n    if (d.isFetching()) {\r\n        return;\r\n    }\r\n    d.setFetching(true);\r\n    CachedDataService c = new CachedDataService();\r\n    c.setUrl(d.getUrl());\r\n    c.setPost(false);\r\n    if (callback != null) {\r\n        c.addResponseListener(callback);\r\n    }\r\n    if (d.getModified() != null && d.getModified().length() > 0) {\r\n        c.addRequestHeader(\"If-Modified-Since\", d.getModified());\r\n        if (d.getEtag() != null) {\r\n            c.addRequestHeader(\"If-None-Match\", d.getEtag());\r\n        }\r\n    }\r\n    NetworkManager.getInstance().addToQueue(c);\r\n}"
}, {
	"Path": "com.codename1.components.ImageViewer.setImageList",
	"Comment": "by providing this optional list of images you can allows swiping between multiple images",
	"Method": "void setImageList(ListModel<Image> model){\r\n    if (model == null || model.getSize() == 0) {\r\n        return;\r\n    }\r\n    if (image == null) {\r\n        image = model.getItemAt(0);\r\n    }\r\n    if (swipeableImages != null) {\r\n        swipeableImages.removeDataChangedListener(listListener);\r\n        swipeableImages.removeSelectionListener((SelectionListener) listListener);\r\n        model.addDataChangedListener(listListener);\r\n        model.addSelectionListener((SelectionListener) listListener);\r\n    } else {\r\n        class Listener implements SelectionListener, DataChangedListener {\r\n            public void selectionChanged(int oldSelected, int newSelected) {\r\n                if (selectLock) {\r\n                    return;\r\n                }\r\n                if (swipeableImages.getSize() > 0 && newSelected > -1 && newSelected < swipeableImages.getSize()) {\r\n                    setImage(swipeableImages.getItemAt(newSelected));\r\n                }\r\n            }\r\n            public void dataChanged(int type, int index) {\r\n                if (swipeableImages.getSize() > 0 && swipeableImages.getSelectedIndex() > -1 && swipeableImages.getSelectedIndex() < swipeableImages.getSize()) {\r\n                    setImage(swipeableImages.getItemAt(swipeableImages.getSelectedIndex()));\r\n                }\r\n            }\r\n        }\r\n        listListener = new Listener();\r\n        model.addDataChangedListener(listListener);\r\n        model.addSelectionListener((SelectionListener) listListener);\r\n    }\r\n    this.swipeableImages = model;\r\n}"
}, {
	"Path": "com.codename1.components.ImageViewer.setImageList",
	"Comment": "by providing this optional list of images you can allows swiping between multiple images",
	"Method": "void setImageList(ListModel<Image> model){\r\n    if (selectLock) {\r\n        return;\r\n    }\r\n    if (swipeableImages.getSize() > 0 && newSelected > -1 && newSelected < swipeableImages.getSize()) {\r\n        setImage(swipeableImages.getItemAt(newSelected));\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.ImageViewer.setImageList",
	"Comment": "by providing this optional list of images you can allows swiping between multiple images",
	"Method": "void setImageList(ListModel<Image> model){\r\n    if (swipeableImages.getSize() > 0 && swipeableImages.getSelectedIndex() > -1 && swipeableImages.getSelectedIndex() < swipeableImages.getSize()) {\r\n        setImage(swipeableImages.getItemAt(swipeableImages.getSelectedIndex()));\r\n    }\r\n}"
}, {
	"Path": "android.support.v4.widget.CursorAdapter.newDropDownView",
	"Comment": "makes a new drop down view to hold the data pointed to by cursor.",
	"Method": "View newDropDownView(Context context,Cursor cursor,ViewGroup parent){\r\n    return newView(context, cursor, parent);\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.shouldConvertPostToGetOnRedirect",
	"Comment": "this mimics the behavior of browsers that convert post operations to get operations when redirecting arequest.",
	"Method": "boolean shouldConvertPostToGetOnRedirect(){\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.util.regex.ReaderCharacterIterator.read",
	"Comment": "reads n characters from the stream and appends them to the buffer",
	"Method": "int read(int n){\r\n    if (closed) {\r\n        return 0;\r\n    }\r\n    char[] c = new char[n];\r\n    int count = 0;\r\n    int read = 0;\r\n    do {\r\n        read = reader.read(c);\r\n        if (read < 0) {\r\n            closed = true;\r\n            break;\r\n        }\r\n        count += read;\r\n        buff.append(c, 0, read);\r\n    } while (count < n);\r\n    return count;\r\n}"
}, {
	"Path": "java.io.PushbackInputStream.read",
	"Comment": "reads a single byte from this stream and returns it as an integer in therange from 0 to 255. if the pushback buffer does not contain anyavailable bytes then a byte from the source input stream is returned.blocks until one byte has been read, the end of the source stream isdetected or an exception is thrown.",
	"Method": "int read(int read,byte[] buffer,int offset,int length){\r\n    if (buf == null) {\r\n        throw streamClosed();\r\n    }\r\n    Arrays.checkOffsetAndCount(buffer.length, offset, length);\r\n    int copiedBytes = 0, copyLength = 0, newOffset = offset;\r\n    if (pos < buf.length) {\r\n        copyLength = (buf.length - pos >= length) ? length : buf.length - pos;\r\n        System.arraycopy(buf, pos, buffer, newOffset, copyLength);\r\n        newOffset += copyLength;\r\n        copiedBytes += copyLength;\r\n        pos += copyLength;\r\n    }\r\n    if (copyLength == length) {\r\n        return length;\r\n    }\r\n    int inCopied = in.read(buffer, newOffset, length - copiedBytes);\r\n    if (inCopied > 0) {\r\n        return inCopied + copiedBytes;\r\n    }\r\n    if (copiedBytes == 0) {\r\n        return inCopied;\r\n    }\r\n    return copiedBytes;\r\n}"
}, {
	"Path": "com.codename1.util.AbstractStringBuilder.capacity",
	"Comment": "returns the number of characters that can be held without growing.",
	"Method": "int capacity(){\r\n    return value.length;\r\n}"
}, {
	"Path": "com.codename1.ads.InnerActive.setTestAds",
	"Comment": "if true and no ads exists the network will return house holds ads",
	"Method": "void setTestAds(boolean test){\r\n    testAds = test;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.slideDown",
	"Comment": "display the matched elements with a sliding motion.uses default duration of 500ms",
	"Method": "ComponentSelector slideDown(ComponentSelector slideDown,int duration,ComponentSelector slideDown,int duration,SuccessCallback<ComponentSelector> callback){\r\n    for (Component c : this) {\r\n        c.setHeight(0);\r\n        c.setVisible(true);\r\n    }\r\n    getParent().animateLayout(duration, callback);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.Tabs.isAnimateTabSelection",
	"Comment": "indicates whether clicking on a tab button should result in an animation to the selected tab or an immediate switch",
	"Method": "boolean isAnimateTabSelection(){\r\n    return animateTabSelection;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.ServerStateMachine.setLastCompleted",
	"Comment": "updates the last completed event index based on a commit at the given index.",
	"Method": "void setLastCompleted(long lastCompleted){\r\n    if (!log.isOpen())\r\n        return;\r\n    this.lastCompleted = Math.max(this.lastCompleted, lastCompleted);\r\n    log.compactor().minorIndex(this.lastCompleted);\r\n    completeSnapshot();\r\n}"
}, {
	"Path": "com.codename1.components.RSSReader.setAddBackToTaget",
	"Comment": "indicates whether a back command should be added implicitly to the target container",
	"Method": "void setAddBackToTaget(boolean addBackToTaget){\r\n    this.addBackToTaget = addBackToTaget;\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.addCrashBreadcrumb",
	"Comment": "add crash breadcrumb like log record to the log that will be send together with crash report",
	"Method": "Countly addCrashBreadcrumb(String record){\r\n    if (Countly.sharedInstance().isLoggingEnabled()) {\r\n        Log.d(Countly.TAG, \"Adding crash breadcrumb\");\r\n    }\r\n    if (!getConsent(CountlyFeatureNames.crashes)) {\r\n        return this;\r\n    }\r\n    if (record == null || record.isEmpty()) {\r\n        if (Countly.sharedInstance().isLoggingEnabled()) {\r\n            Log.d(Countly.TAG, \"Can't add a null or empty crash breadcrumb\");\r\n        }\r\n        return this;\r\n    }\r\n    CrashDetails.addLog(record);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.charts.renderers.XYSeriesRenderer.isDisplayChartValues",
	"Comment": "returns if the chart point values should be displayed as text.",
	"Method": "boolean isDisplayChartValues(){\r\n    return mDisplayChartValues;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.compaction.Compactor.minorIndex",
	"Comment": "returns the maximum compaction index for minor compaction.",
	"Method": "Compactor minorIndex(long index,long minorIndex){\r\n    return minorIndex;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.protocol.ConfigureResponse.builder",
	"Comment": "returns a configure response builder for an existing response.",
	"Method": "Builder builder(Builder builder,ConfigureResponse response){\r\n    return new Builder(response);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayeredLayout.layoutComponent",
	"Comment": "lays out the specific component within the container.this will first lay out any components that it depends on.",
	"Method": "void layoutComponent(Container parent,Component cmp,int top,int left,int bottom,int right){\r\n    if (tmpLaidOut.contains(cmp)) {\r\n        return;\r\n    }\r\n    tmpLaidOut.add(cmp);\r\n    LayeredLayoutConstraint constraint = (LayeredLayoutConstraint) getComponentConstraint(cmp);\r\n    if (constraint != null) {\r\n        constraint.fixDependencies(parent);\r\n        for (LayeredLayoutConstraint.Inset inset : constraint.insets) {\r\n            if (inset.referenceComponent != null && inset.referenceComponent.getParent() == parent) {\r\n                layoutComponent(parent, inset.referenceComponent, top, left, bottom, right);\r\n            }\r\n        }\r\n    }\r\n    Style s = cmp.getStyle();\r\n    if (constraint != null) {\r\n        int leftInset = constraint.insets[Component.LEFT].calculate(cmp, top, left, bottom, right);\r\n        int rightInset = constraint.insets[Component.RIGHT].calculate(cmp, top, left, bottom, right);\r\n        int topInset = constraint.insets[Component.TOP].calculate(cmp, top, left, bottom, right);\r\n        int bottomInset = constraint.insets[Component.BOTTOM].calculate(cmp, top, left, bottom, right);\r\n        cmp.setX(left + leftInset + s.getMarginLeft(parent.isRTL()));\r\n        cmp.setY(top + topInset + s.getMarginTop());\r\n        cmp.setWidth(Math.max(0, right - cmp.getX() - s.getMarginRight(parent.isRTL()) - rightInset));\r\n        cmp.setHeight(Math.max(0, bottom - cmp.getY() - s.getMarginBottom() - bottomInset));\r\n    } else {\r\n        int x = left + s.getMarginLeft(parent.isRTL());\r\n        int y = top + s.getMarginTop();\r\n        int w = right - left - s.getHorizontalMargins();\r\n        int h = bottom - top - s.getVerticalMargins();\r\n        cmp.setX(x);\r\n        cmp.setY(y);\r\n        cmp.setWidth(Math.max(0, w));\r\n        cmp.setHeight(Math.max(0, h));\r\n    }\r\n}"
}, {
	"Path": "java.util.Vector.indexOf",
	"Comment": "searches in this vector for the index of the specified object. the searchfor the object starts at the specified location and moves towards the endof this vector.",
	"Method": "int indexOf(Object object,int indexOf,Object object,int location){\r\n    if (object != null) {\r\n        for (int i = location; i < elementCount; i++) {\r\n            if (object.equals(elementData[i])) {\r\n                return i;\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = location; i < elementCount; i++) {\r\n            if (elementData[i] == null) {\r\n                return i;\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.isDefaultTensileHighlight",
	"Comment": "indicates whether tensile highlight should be active by default",
	"Method": "boolean isDefaultTensileHighlight(){\r\n    return defaultTensileHighlight;\r\n}"
}, {
	"Path": "com.codename1.ui.table.TableLayout.isTruncateVertically",
	"Comment": "indicates whether the table should be truncated if it do not have enough available vertical space to display all its content. if not, will shrink",
	"Method": "boolean isTruncateVertically(){\r\n    return truncateVertically;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.setShowVirtualKeyboard",
	"Comment": "displays the virtual keyboard on devices that support manually poping upthe vitual keyboard",
	"Method": "void setShowVirtualKeyboard(boolean show){\r\n    if (isTouchScreenDevice()) {\r\n        VirtualKeyboardInterface vkb = getDefaultVirtualKeyboard();\r\n        if (vkb != null) {\r\n            vkb.showKeyboard(show);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.ButtonList.undecorateComponent",
	"Comment": "undecorates buttons.this allows subclasses to remove event listeners frombuttons.",
	"Method": "Component undecorateComponent(Component b){\r\n    if (decorators != null) {\r\n        for (Decorator d : decorators) {\r\n            d.undecorate(b);\r\n        }\r\n    }\r\n    if (b instanceof RadioButton) {\r\n        group.remove((RadioButton) b);\r\n    }\r\n    return b;\r\n}"
}, {
	"Path": "com.codename1.ui.FontImage.setDefaultSize",
	"Comment": "default factor for image size, icons without a given size are sized asdefaultsize x default font height.",
	"Method": "void setDefaultSize(float aDefaultSize){\r\n    defaultSize = aDefaultSize;\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.getDimensionDefaultHierarchy",
	"Comment": "returns the default hierarchy of a dimension, or null if there is nodefault.",
	"Method": "Hierarchy getDimensionDefaultHierarchy(Dimension dimension){\r\n    final Hierarchy[] hierarchies = dimension.getHierarchies();\r\n    if (hierarchies.length == 1) {\r\n        return hierarchies[0];\r\n    }\r\n    if (MondrianProperties.instance().SsasCompatibleNaming.get()) {\r\n        return null;\r\n    }\r\n    for (Hierarchy hierarchy : hierarchies) {\r\n        if (hierarchy.getName() == null || hierarchy.getUniqueName().equals(dimension.getUniqueName())) {\r\n            return hierarchy;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.Picker.updateValue",
	"Comment": "updates the display value of the picker, subclasses can override this to invoke set text with the right value",
	"Method": "void updateValue(){\r\n    if (value == null) {\r\n        setText(\"...\");\r\n        return;\r\n    }\r\n    if (getFormatter() != null) {\r\n        setText(formatter.format(value));\r\n        return;\r\n    }\r\n    switch(type) {\r\n        case Display.PICKER_TYPE_STRINGS:\r\n            {\r\n                value = getUIManager().localize(value.toString(), value.toString());\r\n                setText(value.toString());\r\n                break;\r\n            }\r\n        case Display.PICKER_TYPE_CALENDAR:\r\n        case Display.PICKER_TYPE_DATE:\r\n            {\r\n                setText(L10NManager.getInstance().formatDateShortStyle((Date) value));\r\n                break;\r\n            }\r\n        case Display.PICKER_TYPE_TIME:\r\n            {\r\n                int v = ((Integer) value).intValue();\r\n                int hour = v / 60;\r\n                int minute = v % 60;\r\n                if (showMeridiem) {\r\n                    String text;\r\n                    if (hour >= 12) {\r\n                        text = \"pm\";\r\n                    } else {\r\n                        text = \"am\";\r\n                    }\r\n                    int cookedHour = hour <= 12 ? hour : hour - 12;\r\n                    if (cookedHour == 0) {\r\n                        cookedHour = 12;\r\n                    }\r\n                    setText(twoDigits(cookedHour) + \":\" + twoDigits(minute) + text);\r\n                } else {\r\n                    setText(twoDigits(hour) + \":\" + twoDigits(minute));\r\n                }\r\n                break;\r\n            }\r\n        case Display.PICKER_TYPE_DATE_AND_TIME:\r\n            {\r\n                setText(L10NManager.getInstance().formatDateTimeShort((Date) value));\r\n                break;\r\n            }\r\n        case Display.PICKER_TYPE_DURATION_HOURS:\r\n        case Display.PICKER_TYPE_DURATION_MINUTES:\r\n        case Display.PICKER_TYPE_DURATION:\r\n            {\r\n                long v = ((Long) value).longValue();\r\n                int hour = (int) (v / 60 / 60 / 1000);\r\n                int minute = (int) (v / 1000 / 60) % 60;\r\n                StringBuilder sb = new StringBuilder();\r\n                UIManager uim = getUIManager();\r\n                if (hour > 0) {\r\n                    sb.append(hour).append(\" \").append(hour > 1 ? uim.localize(\"hours\", \"hours\") : uim.localize(\"hour\", \"hour\")).append(\" \");\r\n                }\r\n                if (minute > 0) {\r\n                    sb.append(minute).append(\" \").append(minute > 1 ? uim.localize(\"minutes\", \"minutes\") : uim.localize(\"minute\", \"minute\"));\r\n                }\r\n                setText(sb.toString().trim());\r\n                if (\"\".equals(getText())) {\r\n                    setText(\"...\");\r\n                }\r\n                break;\r\n            }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.createBevelLowered",
	"Comment": "creates a lowered bevel border with default colors, highlight is derivedfrom the component and shadow is a plain dark color",
	"Method": "Border createBevelLowered(Border createBevelLowered,int highlightOuter,int highlightInner,int shadowOuter,int shadowInner){\r\n    Border b = new Border();\r\n    b.type = TYPE_BEVEL_LOWERED;\r\n    b.themeColors = false;\r\n    b.colorA = highlightOuter;\r\n    b.colorB = highlightInner;\r\n    b.colorC = shadowOuter;\r\n    b.colorD = shadowInner;\r\n    b.thickness = 2;\r\n    return b;\r\n}"
}, {
	"Path": "com.codename1.impl.javase.JavaSEPort.transformTranslate",
	"Comment": "translates the transform by the specified amounts.with the specified translation.",
	"Method": "void transformTranslate(Object nativeTransform,float x,float y,float z){\r\n    ((AffineTransform) nativeTransform).translate(x, y);\r\n    clamp((AffineTransform) nativeTransform);\r\n}"
}, {
	"Path": "com.codename1.io.services.ImageDownloadService.isDownloadToStyles",
	"Comment": "downloads the image to the style objects associated with this component, effectively sets the bgimage property on all the styles for the component instead of invoking seticon",
	"Method": "boolean isDownloadToStyles(){\r\n    return downloadToStyles;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.compaction.MajorCompactionTask.mergeReleasedEntries",
	"Comment": "updates the new compact segment with entries that were released in the given segment during compaction.",
	"Method": "void mergeReleasedEntries(Segment segment,OffsetPredicate predicate,Segment compactSegment){\r\n    for (long i = segment.firstIndex(); i <= segment.lastIndex(); i++) {\r\n        long offset = segment.offset(i);\r\n        if (offset != -1 && !predicate.test(offset)) {\r\n            compactSegment.release(i);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Font.isTrueTypeFileSupported",
	"Comment": "returns true if the underlying platform supports loading truetype fonts froma file.",
	"Method": "boolean isTrueTypeFileSupported(){\r\n    return Display.impl.isTrueTypeSupported();\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.parents",
	"Comment": "creates new set of components consisting of all of the ancestors of components in this set whichmatch the provided selector.",
	"Method": "ComponentSelector parents(String selector){\r\n    ComponentSelector matcher = new ComponentSelector(selector, new Label());\r\n    HashSet<Component> matches = new HashSet<Component>();\r\n    for (Component c : this) {\r\n        Component parent = c.getParent();\r\n        while (parent != null) {\r\n            if (matcher.match(parent)) {\r\n                matches.add(parent);\r\n            }\r\n            parent = parent.getParent();\r\n        }\r\n    }\r\n    return matcher.addAll(matches, true);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.canForceOrientation",
	"Comment": "returns true if the device allows forcing the orientation via code, feature phones do not allow thisalthough some include a jad property allowing for this feature",
	"Method": "boolean canForceOrientation(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.endGroupY",
	"Comment": "the end group that this component should be placed in.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC endGroupY(String s){\r\n    ver.setEndGroup(s);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.endGroupX",
	"Comment": "specifies that the component should be put in the end group s and will thus share the same ending\tcoordinate as them within the group.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC endGroupX(String s){\r\n    hor.setEndGroup(s);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.messaging.Message.isCloudMessageFailSilently",
	"Comment": "indicates whether the cloud message should produce an error dialog if sending failed",
	"Method": "boolean isCloudMessageFailSilently(){\r\n    return cloudMessageFailSilently;\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.isDisposeWhenPointerOutOfBounds",
	"Comment": "this flag indicates if the dialog should be disposed if a pointerreleased event occurred out of the dialog content.",
	"Method": "boolean isDisposeWhenPointerOutOfBounds(){\r\n    return disposeWhenPointerOutOfBounds;\r\n}"
}, {
	"Path": "com.codename1.ui.tree.Tree.bindNodeListener",
	"Comment": "since a node may be any component type developers should override this method toadd support for binding the click listener to the given component.",
	"Method": "void bindNodeListener(ActionListener l,Component node){\r\n    if (node instanceof Button) {\r\n        ((Button) node).addActionListener(l);\r\n        return;\r\n    }\r\n    ((SpanButton) node).addActionListener(l);\r\n}"
}, {
	"Path": "com.codename1.ui.Image.scale",
	"Comment": "scale the image to the given width and height, this is a fast algorithmthat preserves translucent information",
	"Method": "void scale(int width,int height){\r\n    image = Display.impl.scale(image, width, height);\r\n}"
}, {
	"Path": "ly.count.android.sdk.ConnectionQueue.tick",
	"Comment": "starts connectionprocessor instances running in the background toprocess the local connection queue data.does nothing if there is connection queue data or if a connectionprocessoris already running.",
	"Method": "void tick(){\r\n    if (!store_.isEmptyConnections() && (connectionProcessorFuture_ == null || connectionProcessorFuture_.isDone())) {\r\n        ensureExecutor();\r\n        connectionProcessorFuture_ = executor_.submit(new ConnectionProcessor(serverURL_, store_, deviceId_, sslContext_));\r\n    }\r\n}"
}, {
	"Path": "java.text.DateFormat.getDateInstance",
	"Comment": "get a dateformat instance that uses a given style for dates.",
	"Method": "DateFormat getDateInstance(DateFormat getDateInstance,int style){\r\n    return getDateTimeInstance(style, NONE);\r\n}"
}, {
	"Path": "java.util.AbstractList.lastIndexOf",
	"Comment": "searches this list for the specified object and returns the index of thelast occurrence.",
	"Method": "int lastIndexOf(Object object){\r\n    ListIterator<?> it = listIterator(size());\r\n    if (object != null) {\r\n        while (it.hasPrevious()) {\r\n            if (object.equals(it.previous())) {\r\n                return it.nextIndex();\r\n            }\r\n        }\r\n    } else {\r\n        while (it.hasPrevious()) {\r\n            if (it.previous() == null) {\r\n                return it.nextIndex();\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.shouldAutoDetectAccessPoint",
	"Comment": "this callback allows highly broken devices like the blackberry to automatically detect the networktype",
	"Method": "boolean shouldAutoDetectAccessPoint(){\r\n    return false;\r\n}"
}, {
	"Path": "mondrian.olap.Util.lookupProperty",
	"Comment": "finds a member property called propertyname at, or above,level.",
	"Method": "Property lookupProperty(Level level,String propertyName){\r\n    do {\r\n        Property[] properties = level.getProperties();\r\n        for (Property property : properties) {\r\n            if (property.getName().equals(propertyName)) {\r\n                return property;\r\n            }\r\n        }\r\n        level = level.getParentLevel();\r\n    } while (level != null);\r\n    boolean caseSensitive = MondrianProperties.instance().CaseSensitive.get();\r\n    final Property property = Property.lookup(propertyName, caseSensitive);\r\n    if (property != null && property.isMemberProperty() && property.isStandard()) {\r\n        return property;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractList.lastIndexOf",
	"Comment": "searches this list for the specified object and returns the index of thelast occurrence.",
	"Method": "int lastIndexOf(Object object){\r\n    ListIterator<?> it = listIterator(size());\r\n    if (object != null) {\r\n        while (it.hasPrevious()) {\r\n            if (object.equals(it.previous())) {\r\n                return it.nextIndex();\r\n            }\r\n        }\r\n    } else {\r\n        while (it.hasPrevious()) {\r\n            if (it.previous() == null) {\r\n                return it.nextIndex();\r\n            }\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.applyPageStyle",
	"Comment": "applies the user defined page style to the main container. this clones the page style and sets the clone to the page, as various css directives may change the style of the main container.",
	"Method": "void applyPageStyle(){\r\n    Style pageStyleCopy = new Style(pageStyle);\r\n    mainContainer.setUnselectedStyle(pageStyleCopy);\r\n    mainContainer.setSelectedStyle(pageStyleCopy);\r\n}"
}, {
	"Path": "com.codename1.ui.FontImage.create",
	"Comment": "creates the font image with the given style settings but uses the given font, notice that thesize of the given font determines the size of the icon!",
	"Method": "FontImage create(String text,Style s,FontImage create,String text,Style s,Font fnt){\r\n    FontImage f = new FontImage();\r\n    f.backgroundOpacity = s.getBgTransparency();\r\n    f.backgroundColor = s.getBgColor();\r\n    f.text = text;\r\n    f.color = s.getFgColor();\r\n    f.opacity = s.getOpacity();\r\n    f.fnt = fnt;\r\n    int w = Math.max(f.getHeight(), f.fnt.stringWidth(text)) + (f.padding * 2);\r\n    f.width = w;\r\n    f.height = w;\r\n    return f;\r\n}"
}, {
	"Path": "com.codename1.properties.InstantUI.setOrder",
	"Comment": "sets the order of the properties, notice that this can also replace exclude",
	"Method": "void setOrder(PropertyBase order){\r\n    this.order = order;\r\n}"
}, {
	"Path": "io.atomix.copycat.Command.compaction",
	"Comment": "returns the command compaction mode.the compaction mode will dictate the circumstances under which the command can be safely removed from theraft replicated log. commands and the state machines to which they apply must coordinate the compaction processvia this mechanism.",
	"Method": "CompactionMode compaction(){\r\n    return CompactionMode.DEFAULT;\r\n}"
}, {
	"Path": "java.util.PriorityQueue.toArray",
	"Comment": "returns all the elements in an array. the result is a copy of all theelements.",
	"Method": "Object[] toArray(T[] toArray,T[] array){\r\n    return newArray(array);\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyIndex.toString",
	"Comment": "returns a user readable printout of the property values which is useful for debugging",
	"Method": "String toString(String toString,boolean includeNewline){\r\n    StringBuilder b = new StringBuilder(name);\r\n    b.append(\" : {\");\r\n    if (includeNewline) {\r\n        b.append('\\n');\r\n    }\r\n    for (PropertyBase p : this) {\r\n        b.append(p.getName());\r\n        b.append(\" = \");\r\n        b.append(p.toString());\r\n        if (includeNewline) {\r\n            b.append('\\n');\r\n        }\r\n    }\r\n    b.append(\"}\");\r\n    return b.toString();\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.shrinkPrio",
	"Comment": "shrink priority for the component horizontally and optionally vertically.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC shrinkPrio(int widthHeight){\r\n    switch(widthHeight.length) {\r\n        default:\r\n            throw new IllegalArgumentException(\"Illegal argument count: \" + widthHeight.length);\r\n        case 2:\r\n            shrinkPrioY(widthHeight[1]);\r\n        case 1:\r\n            shrinkPrioX(widthHeight[0]);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.validate",
	"Comment": "validates that the request has the required information before being added to the queuee.g. checks if the url is null. this method should throw an illegalstateexception fora case where one of the values required for this connection request is missing.this method can be overriden by subclasses to add additional tests. it is usefullto do tests here since the exception will be thrown immediately when invoking addtoqueuewhich is more intuitive to debug than the alternative.",
	"Method": "void validate(){\r\n    if (!url.toLowerCase().startsWith(\"http\")) {\r\n        throw new IllegalStateException(\"Only HTTP urls are supported!\");\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.PriorityQueue.size",
	"Comment": "gets the size of the priority queue. if the size of the queue is greaterthan the integer.max, then it returns integer.max.",
	"Method": "int size(){\r\n    return size;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.createLineBorder",
	"Comment": "creates a line border that uses the given color for the component",
	"Method": "Border createLineBorder(int thickness,Border createLineBorder,float thickness,Border createLineBorder,int thickness,String title,Border createLineBorder,int thickness,int color,String title,Border createLineBorder,int thickness,int color,Border createLineBorder,float thickness,int color){\r\n    Border b = new Border();\r\n    b.type = TYPE_LINE;\r\n    b.themeColors = false;\r\n    b.thickness = thickness;\r\n    b.millimeters = true;\r\n    b.colorA = color;\r\n    return b;\r\n}"
}, {
	"Path": "com.codename1.ui.List.scrollRectToVisible",
	"Comment": "makes sure the selected index is visible if it is not in the current viewrect the list will scroll so it fits within",
	"Method": "void scrollRectToVisible(Rectangle rect){\r\n    if (fixedSelection < FIXED_NONE_BOUNDRY) {\r\n        Rectangle toScroll;\r\n        if (orientation != HORIZONTAL) {\r\n            toScroll = new Rectangle(getScrollX(), rect.getY(), rect.getSize().getWidth(), rect.getSize().getHeight() + itemGap);\r\n        } else {\r\n            toScroll = new Rectangle(rect.getX(), getScrollY(), rect.getSize().getWidth() + itemGap, rect.getSize().getHeight());\r\n        }\r\n        super.scrollRectToVisible(toScroll, this);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.InfiniteProgress.setDefaultMaterialDesignColor",
	"Comment": "the default color of the current material design progress spinner",
	"Method": "void setDefaultMaterialDesignColor(int aDefaultMaterialDesignColor){\r\n    defaultMaterialDesignColor = aDefaultMaterialDesignColor;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.getLeadComponent",
	"Comment": "returns the lead component for this hierarchy if such a component is defined",
	"Method": "Component getLeadComponent(){\r\n    if (isBlockLead()) {\r\n        return null;\r\n    }\r\n    if (leadComponent != null) {\r\n        return leadComponent;\r\n    }\r\n    if (hasLead) {\r\n        return super.getLeadComponent();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getInnerWidth",
	"Comment": "gets the inner width of this component.this is the width of the component removing horizontal padding.",
	"Method": "int getInnerWidth(){\r\n    return getWidth() - getStyle().getHorizontalPadding();\r\n}"
}, {
	"Path": "com.codename1.ui.Form.scrollComponentToVisible",
	"Comment": "makes sure the component is visible in the scroll if this container is scrollable",
	"Method": "void scrollComponentToVisible(Component c){\r\n    initFocused();\r\n    Container parent = c.getParent();\r\n    while (parent != null) {\r\n        if (parent.isScrollable()) {\r\n            if (parent == this) {\r\n                if (getContentPane().isScrollable()) {\r\n                    getContentPane().scrollComponentToVisible(c);\r\n                }\r\n            } else {\r\n                parent.scrollComponentToVisible(c);\r\n            }\r\n            return;\r\n        }\r\n        parent = parent.getParent();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Tabs.isSwipeActivated",
	"Comment": "returns true if the swipe between tabs is activated, this is relevant fortouch devices only",
	"Method": "boolean isSwipeActivated(){\r\n    return swipeActivated;\r\n}"
}, {
	"Path": "com.codename1.impl.android.InPlaceEditView.showTextEditorAgain",
	"Comment": "shows the native text field again after it has been hidden in async edit mode.",
	"Method": "void showTextEditorAgain(){\r\n    if (!mIsEditing || !isTextEditorHidden()) {\r\n        return;\r\n    }\r\n    textEditorHidden = false;\r\n    final TextArea ta = mEditText.mTextArea;\r\n    synchronized (this) {\r\n        inputBuffer = new ArrayList<TextChange>();\r\n    }\r\n    Display.getInstance().callSerially(new Runnable() {\r\n        public void run() {\r\n            if (mIsEditing && mEditText != null && mEditText.mTextArea == ta) {\r\n                final String text = ta.getText();\r\n                final int cursorPos = ta.getCursorPosition();\r\n                impl.getActivity().runOnUiThread(new Runnable() {\r\n                    public void run() {\r\n                        if (mIsEditing && mEditText != null && mEditText.mTextArea == ta) {\r\n                            synchronized (InPlaceEditView.this) {\r\n                                int start = cursorPos;\r\n                                int end = cursorPos;\r\n                                StringBuilder buf = new StringBuilder();\r\n                                buf.append(text);\r\n                                List<TextChange> tinput = inputBuffer;\r\n                                if (tinput != null) {\r\n                                    for (TextChange change : tinput) {\r\n                                        if (change.textToAppend != null) {\r\n                                            if (end >= 0 && end <= buf.length()) {\r\n                                                buf.insert(end, change.textToAppend);\r\n                                                end += change.textToAppend.length();\r\n                                                start = end;\r\n                                            } else {\r\n                                                buf.append(change.textToAppend);\r\n                                                end = buf.length();\r\n                                                start = end;\r\n                                            }\r\n                                        } else if (change.deleteLength > 0) {\r\n                                            if (end >= change.deleteLength && end <= buf.length()) {\r\n                                                buf.delete(end - change.deleteLength, end);\r\n                                                end -= change.deleteLength;\r\n                                                start = end;\r\n                                            } else if (end > 0 && end < change.deleteLength) {\r\n                                                buf.delete(0, end);\r\n                                                end = 0;\r\n                                                start = end;\r\n                                            }\r\n                                        }\r\n                                    }\r\n                                }\r\n                                inputBuffer = null;\r\n                                mEditText.setText(buf.toString());\r\n                                if (start < 0 || start > mEditText.getText().length()) {\r\n                                    start = mEditText.getText().length();\r\n                                }\r\n                                if (end < 0 || end > mEditText.getText().length()) {\r\n                                    end = mEditText.getText().length();\r\n                                }\r\n                                mEditText.setSelection(start, end);\r\n                            }\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    });\r\n    reLayoutEdit(true);\r\n    repaintTextEditor(true);\r\n}"
}, {
	"Path": "com.codename1.impl.android.InPlaceEditView.showTextEditorAgain",
	"Comment": "shows the native text field again after it has been hidden in async edit mode.",
	"Method": "void showTextEditorAgain(){\r\n    if (mIsEditing && mEditText != null && mEditText.mTextArea == ta) {\r\n        final String text = ta.getText();\r\n        final int cursorPos = ta.getCursorPosition();\r\n        impl.getActivity().runOnUiThread(new Runnable() {\r\n            public void run() {\r\n                if (mIsEditing && mEditText != null && mEditText.mTextArea == ta) {\r\n                    synchronized (InPlaceEditView.this) {\r\n                        int start = cursorPos;\r\n                        int end = cursorPos;\r\n                        StringBuilder buf = new StringBuilder();\r\n                        buf.append(text);\r\n                        List<TextChange> tinput = inputBuffer;\r\n                        if (tinput != null) {\r\n                            for (TextChange change : tinput) {\r\n                                if (change.textToAppend != null) {\r\n                                    if (end >= 0 && end <= buf.length()) {\r\n                                        buf.insert(end, change.textToAppend);\r\n                                        end += change.textToAppend.length();\r\n                                        start = end;\r\n                                    } else {\r\n                                        buf.append(change.textToAppend);\r\n                                        end = buf.length();\r\n                                        start = end;\r\n                                    }\r\n                                } else if (change.deleteLength > 0) {\r\n                                    if (end >= change.deleteLength && end <= buf.length()) {\r\n                                        buf.delete(end - change.deleteLength, end);\r\n                                        end -= change.deleteLength;\r\n                                        start = end;\r\n                                    } else if (end > 0 && end < change.deleteLength) {\r\n                                        buf.delete(0, end);\r\n                                        end = 0;\r\n                                        start = end;\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        inputBuffer = null;\r\n                        mEditText.setText(buf.toString());\r\n                        if (start < 0 || start > mEditText.getText().length()) {\r\n                            start = mEditText.getText().length();\r\n                        }\r\n                        if (end < 0 || end > mEditText.getText().length()) {\r\n                            end = mEditText.getText().length();\r\n                        }\r\n                        mEditText.setSelection(start, end);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.android.InPlaceEditView.showTextEditorAgain",
	"Comment": "shows the native text field again after it has been hidden in async edit mode.",
	"Method": "void showTextEditorAgain(){\r\n    if (mIsEditing && mEditText != null && mEditText.mTextArea == ta) {\r\n        synchronized (InPlaceEditView.this) {\r\n            int start = cursorPos;\r\n            int end = cursorPos;\r\n            StringBuilder buf = new StringBuilder();\r\n            buf.append(text);\r\n            List<TextChange> tinput = inputBuffer;\r\n            if (tinput != null) {\r\n                for (TextChange change : tinput) {\r\n                    if (change.textToAppend != null) {\r\n                        if (end >= 0 && end <= buf.length()) {\r\n                            buf.insert(end, change.textToAppend);\r\n                            end += change.textToAppend.length();\r\n                            start = end;\r\n                        } else {\r\n                            buf.append(change.textToAppend);\r\n                            end = buf.length();\r\n                            start = end;\r\n                        }\r\n                    } else if (change.deleteLength > 0) {\r\n                        if (end >= change.deleteLength && end <= buf.length()) {\r\n                            buf.delete(end - change.deleteLength, end);\r\n                            end -= change.deleteLength;\r\n                            start = end;\r\n                        } else if (end > 0 && end < change.deleteLength) {\r\n                            buf.delete(0, end);\r\n                            end = 0;\r\n                            start = end;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            inputBuffer = null;\r\n            mEditText.setText(buf.toString());\r\n            if (start < 0 || start > mEditText.getText().length()) {\r\n                start = mEditText.getText().length();\r\n            }\r\n            if (end < 0 || end > mEditText.getText().length()) {\r\n                end = mEditText.getText().length();\r\n            }\r\n            mEditText.setSelection(start, end);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Form.isInSameRow",
	"Comment": "returns true if the given dest component is in the row of the source component",
	"Method": "boolean isInSameRow(Component source,Component dest){\r\n    return Rectangle.intersects(0, source.getAbsoluteY(), Integer.MAX_VALUE, source.getHeight(), dest.getAbsoluteX(), dest.getAbsoluteY(), dest.getWidth(), dest.getHeight());\r\n}"
}, {
	"Path": "ly.count.android.sdk.messaging.Message.setType",
	"Comment": "depending on message contents, it can represent different types of actions.",
	"Method": "int setType(){\r\n    int t = CountlyMessaging.NOTIFICATION_TYPE_UNKNOWN;\r\n    if (getMessage() != null && !\"\".equals(getMessage())) {\r\n        t |= CountlyMessaging.NOTIFICATION_TYPE_MESSAGE;\r\n    }\r\n    if (getTitle() != null && !\"\".equals(getTitle())) {\r\n        t |= CountlyMessaging.NOTIFICATION_TYPE_TITLE;\r\n    }\r\n    if (getMedia() != null && !\"\".equals(getMedia())) {\r\n        t |= CountlyMessaging.NOTIFICATION_TYPE_MEDIA;\r\n    }\r\n    if (getButtons() != null && getButtons().size() > 0) {\r\n        t |= CountlyMessaging.NOTIFICATION_TYPE_BUTTONS;\r\n    }\r\n    if (getLink() != null && !\"\".equals(getLink())) {\r\n        t |= CountlyMessaging.NOTIFICATION_TYPE_URL;\r\n    }\r\n    if (\"true\".equals(data.getString(\"c.s\"))) {\r\n        t |= CountlyMessaging.NOTIFICATION_TYPE_SILENT;\r\n    }\r\n    if (getSoundUri() != null && !\"\".equals(getSoundUri())) {\r\n        if (\"default\".equals(getSoundUri()))\r\n            t |= CountlyMessaging.NOTIFICATION_TYPE_SOUND_DEFAULT;\r\n        else\r\n            t |= CountlyMessaging.NOTIFICATION_TYPE_SOUND_URI;\r\n    }\r\n    return t;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.parseComponentStyle",
	"Comment": "returns the style of the component with the given basestyle or a new instance of the defaultstyle, but overrides styles based on the directives in the stylestrings.this method will always return a new style instance to prevent modification of the globalstyle object.",
	"Method": "Style parseComponentStyle(Resources theme,String baseStyle,String id,String styleString){\r\n    return parseStyle(theme, id, \"\", baseStyle, false, styleString);\r\n}"
}, {
	"Path": "ly.count.android.sdk.CountlyStarRating.registerAppSession",
	"Comment": "register that a apps session has transpired. will increase session counter and show automatic star rating if needed.",
	"Method": "void registerAppSession(Context context,RatingCallback starRatingCallback){\r\n    StarRatingPreferences srp = loadStarRatingPreferences(context);\r\n    String currentAppVersion = DeviceInfo.getAppVersion(context);\r\n    if (currentAppVersion != null && !currentAppVersion.equals(srp.appVersion) && !srp.disabledAutomaticForNewVersions) {\r\n        srp.appVersion = currentAppVersion;\r\n        srp.isShownForCurrentVersion = false;\r\n        srp.sessionAmount = 0;\r\n    }\r\n    srp.sessionAmount++;\r\n    if (srp.sessionAmount >= srp.sessionLimit && !srp.isShownForCurrentVersion && srp.automaticRatingShouldBeShown && !(srp.disabledAutomaticForNewVersions && srp.automaticHasBeenShown)) {\r\n        showStarRating(context, starRatingCallback);\r\n        srp.isShownForCurrentVersion = true;\r\n        srp.automaticHasBeenShown = true;\r\n    }\r\n    saveStarRatingPreferences(context, srp);\r\n}"
}, {
	"Path": "com.codename1.ui.Tabs.bindTabActionListener",
	"Comment": "binds an action listener to the tab component. this method should be used when overridingcreatetab",
	"Method": "void bindTabActionListener(Component tab,ActionListener l){\r\n    ((Button) tab).addActionListener(l);\r\n}"
}, {
	"Path": "org.commonmark.internal.DocumentParser.incorporateLine",
	"Comment": "analyze a line of text and update the document appropriately. we parse markdown text by calling this on eachline of input, then finalizing the document.",
	"Method": "void incorporateLine(CharSequence ln){\r\n    line = Parsing.prepareLine(ln);\r\n    index = 0;\r\n    column = 0;\r\n    columnIsInTab = false;\r\n    int matches = 1;\r\n    for (BlockParser blockParser : activeBlockParsers.subList(1, activeBlockParsers.size())) {\r\n        findNextNonSpace();\r\n        BlockContinue result = blockParser.tryContinue(this);\r\n        if (result instanceof BlockContinueImpl) {\r\n            BlockContinueImpl blockContinue = (BlockContinueImpl) result;\r\n            if (blockContinue.isFinalize()) {\r\n                finalize(blockParser);\r\n                return;\r\n            } else {\r\n                if (blockContinue.getNewIndex() != -1) {\r\n                    setNewIndex(blockContinue.getNewIndex());\r\n                } else if (blockContinue.getNewColumn() != -1) {\r\n                    setNewColumn(blockContinue.getNewColumn());\r\n                }\r\n                matches++;\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    List<BlockParser> unmatchedBlockParsers = new ArrayList(activeBlockParsers.subList(matches, activeBlockParsers.size()));\r\n    BlockParser lastMatchedBlockParser = activeBlockParsers.get(matches - 1);\r\n    BlockParser blockParser = lastMatchedBlockParser;\r\n    boolean allClosed = unmatchedBlockParsers.isEmpty();\r\n    boolean tryBlockStarts = blockParser.getBlock() instanceof Paragraph || blockParser.isContainer();\r\n    while (tryBlockStarts) {\r\n        findNextNonSpace();\r\n        if (isBlank() || (indent < Parsing.CODE_BLOCK_INDENT && Parsing.isLetter(line, nextNonSpace))) {\r\n            setNewIndex(nextNonSpace);\r\n            break;\r\n        }\r\n        BlockStartImpl blockStart = findBlockStart(blockParser);\r\n        if (blockStart == null) {\r\n            setNewIndex(nextNonSpace);\r\n            break;\r\n        }\r\n        if (!allClosed) {\r\n            finalizeBlocks(unmatchedBlockParsers);\r\n            allClosed = true;\r\n        }\r\n        if (blockStart.getNewIndex() != -1) {\r\n            setNewIndex(blockStart.getNewIndex());\r\n        } else if (blockStart.getNewColumn() != -1) {\r\n            setNewColumn(blockStart.getNewColumn());\r\n        }\r\n        if (blockStart.isReplaceActiveBlockParser()) {\r\n            removeActiveBlockParser();\r\n        }\r\n        for (BlockParser newBlockParser : blockStart.getBlockParsers()) {\r\n            blockParser = addChild(newBlockParser);\r\n            tryBlockStarts = newBlockParser.isContainer();\r\n        }\r\n    }\r\n    if (!allClosed && !isBlank() && getActiveBlockParser() instanceof ParagraphParser) {\r\n        addLine();\r\n    } else {\r\n        if (!allClosed) {\r\n            finalizeBlocks(unmatchedBlockParsers);\r\n        }\r\n        if (!blockParser.isContainer()) {\r\n            addLine();\r\n        } else if (!isBlank()) {\r\n            addChild(new ParagraphParser());\r\n            addLine();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.support.v4.widget.SlidingPaneLayout.closePane",
	"Comment": "close the sliding pane if it is currently slideable. if first layouthas already completed this will animate.",
	"Method": "boolean closePane(View pane,int initialVelocity,boolean closePane){\r\n    return closePane(mSlideableView, 0);\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.LeaderAppender.updateHeartbeatTime",
	"Comment": "sets a commit time or fails the commit if a quorum of successful responses cannot be achieved.",
	"Method": "void updateHeartbeatTime(MemberState member,Throwable error){\r\n    if (heartbeatFuture == null) {\r\n        return;\r\n    }\r\n    if (error != null && member.getHeartbeatStartTime() == heartbeatTime) {\r\n        int votingMemberSize = context.getClusterState().getActiveMemberStates().size() + (context.getCluster().member().type() == Member.Type.ACTIVE ? 1 : 0);\r\n        int quorumSize = (int) Math.floor(votingMemberSize / 2) + 1;\r\n        if (member.getMember().type() == Member.Type.ACTIVE && ++heartbeatFailures > votingMemberSize - quorumSize) {\r\n            heartbeatFuture.completeExceptionally(new InternalException(\"Failed to reach consensus\"));\r\n            completeHeartbeat();\r\n        }\r\n    } else {\r\n        member.setHeartbeatTime(System.currentTimeMillis());\r\n        if (heartbeatTime <= heartbeatTime()) {\r\n            heartbeatFuture.complete(null);\r\n            completeHeartbeat();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.list.ContainerList.setSelectedIndex",
	"Comment": "sets the current selected offset in the list, by default this implementationwill scroll the list to the selection if the selection is outside of the screen",
	"Method": "void setSelectedIndex(int index){\r\n    if (index < 0) {\r\n        throw new IllegalArgumentException(\"Selection index is negative:\" + index);\r\n    }\r\n    getComponentAt(index).requestFocus();\r\n    model.setSelectedIndex(index);\r\n}"
}, {
	"Path": "com.codename1.social.Login.validateToken",
	"Comment": "returns true if the previous granted access token is still valid otherwise false.",
	"Method": "void validateToken(boolean validateToken,String token){\r\n    String token = Preferences.get(Login.this.getClass().getName() + \"Token\", null);\r\n    if (token == null) {\r\n        throw new RuntimeException(\"No token to validate\");\r\n    }\r\n    if (!validateToken(token)) {\r\n        callbackEnabled = false;\r\n        doLogin();\r\n        Display.getInstance().invokeAndBlock(new Runnable() {\r\n            public void run() {\r\n                while (!callbackEnabled) {\r\n                    Util.sleep(100);\r\n                }\r\n            }\r\n        });\r\n        if (validateErr != null) {\r\n            throw new IOException(validateErr);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.social.Login.validateToken",
	"Comment": "returns true if the previous granted access token is still valid otherwise false.",
	"Method": "void validateToken(boolean validateToken,String token){\r\n    while (!callbackEnabled) {\r\n        Util.sleep(100);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testReservePassiveAvailabilityChange",
	"Comment": "tests detecting an availability change of a passive member on a reserve member.",
	"Method": "void testReservePassiveAvailabilityChange(){\r\n    createServers(3);\r\n    CopycatServer passive = createServer(nextMember(Member.Type.PASSIVE));\r\n    passive.join(members.stream().map(Member::serverAddress).collect(Collectors.toList())).thenRun(this::resume);\r\n    CopycatServer reserve = createServer(nextMember(Member.Type.RESERVE));\r\n    reserve.join(members.stream().map(Member::serverAddress).collect(Collectors.toList())).thenRun(this::resume);\r\n    await(10000, 2);\r\n    reserve.cluster().member(passive.cluster().member().address()).onStatusChange(s -> {\r\n        threadAssertEquals(s, Member.Status.UNAVAILABLE);\r\n        resume();\r\n    });\r\n    passive.shutdown().thenRun(this::resume);\r\n    await(10000, 2);\r\n}"
}, {
	"Path": "com.codename1.ui.BrowserComponent.waitForReady",
	"Comment": "uses invokeandblock to wait until the browsercomponent is ready.the browser componentis considered to be ready once the onload event has been fired for the first page.",
	"Method": "void waitForReady(){\r\n    while (!ready) {\r\n        Display.getInstance().invokeAndBlock(new Runnable() {\r\n            public void run() {\r\n                synchronized (readyLock) {\r\n                    Util.wait(readyLock, 1000);\r\n                }\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.BrowserComponent.waitForReady",
	"Comment": "uses invokeandblock to wait until the browsercomponent is ready.the browser componentis considered to be ready once the onload event has been fired for the first page.",
	"Method": "void waitForReady(){\r\n    synchronized (readyLock) {\r\n        Util.wait(readyLock, 1000);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudStorage.delete",
	"Comment": "deletes the following object from the cloud storage upon commit",
	"Method": "void delete(CloudObject cl){\r\n    storageQueue.addElement(cl.getCloudId());\r\n    Storage.getInstance().writeObject(\"CN1StorageQueue\", storageQueue);\r\n    cl.setStatus(CloudObject.STATUS_DELETE_IN_PROGRESS);\r\n}"
}, {
	"Path": "com.codename1.io.BufferedInputStream.markSupported",
	"Comment": "tests if this input stream supports the mark and reset methods. the marksupported method of bufferedinputstream returns true.",
	"Method": "boolean markSupported(){\r\n    return in.markSupported();\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getPressedStyle",
	"Comment": "returns the component style for the pressed state allowing us to manipulatethe look of the component when it is pressed",
	"Method": "Style getPressedStyle(){\r\n    if (pressedStyle == null) {\r\n        if (hasInlinePressedStyle()) {\r\n            pressedStyle = getUIManager().parseComponentCustomStyle(getInlineStylesTheme(), getUIID(), getInlineStylesUIID(), \"press\", getInlinePressedStyleStrings());\r\n        } else {\r\n            pressedStyle = getUIManager().getComponentCustomStyle(getUIID(), \"press\");\r\n        }\r\n        pressedStyle.addStyleListener(this);\r\n        if (pressedStyle.getBgPainter() == null) {\r\n            pressedStyle.setBgPainter(new BGPainter());\r\n        }\r\n    }\r\n    return pressedStyle;\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSEngine.setTextDecorationRecursive",
	"Comment": "sets the specified decoration to the specified components and all of its label descendants",
	"Method": "void setTextDecorationRecursive(Component cmp,int decoration,CSSElement selector){\r\n    if (cmp instanceof Container) {\r\n        Container cont = (Container) cmp;\r\n        for (int i = 0; i < cont.getComponentCount(); i++) {\r\n            setTextDecorationRecursive(cont.getComponentAt(i), decoration, selector);\r\n        }\r\n    } else if (cmp instanceof Label) {\r\n        int styles = getApplicableStyles(cmp, selector);\r\n        if ((styles & STYLE_UNSELECTED) != 0) {\r\n            applyDecorationOnStyle(cmp.getUnselectedStyle(), decoration);\r\n        }\r\n        if ((styles & STYLE_SELECTED) != 0) {\r\n            applyDecorationOnStyle(cmp.getSelectedStyle(), decoration);\r\n        }\r\n        if ((styles & STYLE_PRESSED) != 0) {\r\n            applyDecorationOnStyle(((HTMLLink) cmp).getPressedStyle(), decoration);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Image.setImageName",
	"Comment": "the name of the image is set for some images mostly to ease the debugging of codename one application",
	"Method": "void setImageName(String imageName){\r\n    this.imageName = imageName;\r\n}"
}, {
	"Path": "java.util.Calendar.equals",
	"Comment": "compares this calendar to the specified object. the result is true if and only if the argument is not null and is a calendar object that represents the same calendar as this object.",
	"Method": "boolean equals(java.lang.Object obj){\r\n    if (this == object) {\r\n        return true;\r\n    }\r\n    if (!(object instanceof Calendar)) {\r\n        return false;\r\n    }\r\n    Calendar cal = (Calendar) object;\r\n    return getTimeInMillis() == cal.getTimeInMillis() && getTimeZone().equals(cal.getTimeZone());\r\n}"
}, {
	"Path": "io.atomix.copycat.client.DefaultCopycatClientTest.testCommandSessionExpiration",
	"Comment": "tests calling the recovery strategy when a command fails due to unknownsessionexception.",
	"Method": "void testCommandSessionExpiration(){\r\n    Connection connection = mock(Connection.class);\r\n    when(connection.close()).thenReturn(CompletableFuture.completedFuture(null));\r\n    Client client = mock(Client.class);\r\n    when(client.connect(any())).thenReturn(CompletableFuture.completedFuture(connection));\r\n    Transport transport = mock(Transport.class);\r\n    when(transport.client()).thenReturn(client);\r\n    when(connection.sendAndReceive(isA(ConnectRequest.class))).thenReturn(CompletableFuture.completedFuture(ConnectResponse.builder().withStatus(Response.Status.OK).withLeader(LEADER).withMembers(MEMBERS).build()));\r\n    when(connection.sendAndReceive(isA(RegisterRequest.class))).thenReturn(CompletableFuture.completedFuture(RegisterResponse.builder().withStatus(Response.Status.OK).withSession(1).withTimeout(5000).withLeader(LEADER).withMembers(MEMBERS).build()));\r\n    Mockito.when(connection.sendAndReceive(isA(KeepAliveRequest.class))).thenReturn(CompletableFuture.completedFuture(KeepAliveResponse.builder().withStatus(Response.Status.OK).withLeader(LEADER).withMembers(MEMBERS).build()));\r\n    Mockito.when(connection.sendAndReceive(isA(CommandRequest.class))).thenReturn(CompletableFuture.completedFuture(CommandResponse.builder().withStatus(Response.Status.ERROR).withError(CopycatError.Type.UNKNOWN_SESSION_ERROR).build()));\r\n    final CountDownLatch latch = new CountDownLatch(1);\r\n    CopycatClient copycatClient = CopycatClient.builder().withTransport(transport).withRecoveryStrategy(c -> {\r\n        latch.countDown();\r\n    }).build();\r\n    copycatClient.connect(MEMBERS).join();\r\n    copycatClient.submit(new TestCommand());\r\n    latch.await();\r\n}"
}, {
	"Path": "com.codename1.io.NetworkManager.setAutoDetectURL",
	"Comment": "this url is used to check whether an internet connection is available",
	"Method": "void setAutoDetectURL(String aAutoDetectURL){\r\n    autoDetectURL = aAutoDetectURL;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.PlatformDefaults.getDialogInsets",
	"Comment": "returns the default dialog inset depending of the current platform.",
	"Method": "UnitValue getDialogInsets(int side){\r\n    return DIALOG_INS[side];\r\n}"
}, {
	"Path": "com.codename1.ui.Tabs.setAnimateTabSelection",
	"Comment": "indicates whether clicking on a tab button should result in an animation to the selected tab or an immediate switch",
	"Method": "void setAnimateTabSelection(boolean animateTabSelection){\r\n    this.animateTabSelection = animateTabSelection;\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetPanel.setToggleStates",
	"Comment": "sets the toggle states for the category views. note this must be called before setting any properties.",
	"Method": "void setToggleStates(Map toggleStates){\r\n    model.setToggleStates(toggleStates);\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.createMenuCancelCommand",
	"Comment": "factory method that returns the form menu cancel command.this method can be overridden to customize the command on the form.",
	"Method": "Command createMenuCancelCommand(){\r\n    UIManager manager = parent.getUIManager();\r\n    LookAndFeel lf = manager.getLookAndFeel();\r\n    return new Command(manager.localize(\"cancel\", \"Cancel\"), lf.getMenuIcons()[1]);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.ArrayDeque.element",
	"Comment": "gets but does not remove the head element of this deque. it throws anexception if the deque is empty.",
	"Method": "E element(){\r\n    return getFirst();\r\n}"
}, {
	"Path": "com.codename1.util.TDivision.multiplyAndSubtract",
	"Comment": "multiplies an array by int and subtracts it from a subarray of anotherarray.",
	"Method": "int multiplyAndSubtract(int a,int start,int b,int bLen,int c){\r\n    long carry0 = 0;\r\n    long carry1 = 0;\r\n    for (int i = 0; i < bLen; i++) {\r\n        carry0 = TMultiplication.unsignedMultAddAdd(b[i], c, (int) carry0, 0);\r\n        carry1 = (a[start + i] & 0xffffffffL) - (carry0 & 0xffffffffL) + carry1;\r\n        a[start + i] = (int) carry1;\r\n        carry1 >>= 32;\r\n        carry0 >>>= 32;\r\n    }\r\n    carry1 = (a[start + bLen] & 0xffffffffL) - carry0 + carry1;\r\n    a[start + bLen] = (int) carry1;\r\n    return (int) (carry1 >> 32);\r\n}"
}, {
	"Path": "java.lang.String.regionMatches",
	"Comment": "compares the specified string to this string and compares the specifiedrange of characters to determine if they are the same.",
	"Method": "boolean regionMatches(boolean ignoreCase,int toffset,java.lang.String other,int ooffset,int len){\r\n    if (!ignoreCase) {\r\n        return regionMatches(thisStart, string, start, length);\r\n    }\r\n    if (string == null) {\r\n        throw new NullPointerException(\"string == null\");\r\n    }\r\n    if (thisStart < 0 || length > count - thisStart) {\r\n        return false;\r\n    }\r\n    if (start < 0 || length > string.count - start) {\r\n        return false;\r\n    }\r\n    thisStart += offset;\r\n    start += string.offset;\r\n    int end = thisStart + length;\r\n    char[] target = string.value;\r\n    while (thisStart < end) {\r\n        char c1 = value[thisStart++];\r\n        char c2 = target[start++];\r\n        if (c1 != c2 && foldCase(c1) != foldCase(c2)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.payment.Purchase.isRefundable",
	"Comment": "indicates whether refunding is possible when the sku is purchased",
	"Method": "boolean isRefundable(String sku){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.notifications.LocalNotification.getAlertSound",
	"Comment": "gets the alert sound to be sounded when the notification arrives.this should refer to a sound file that is bundled in the default package of yourapp.",
	"Method": "String getAlertSound(){\r\n    return alertSound;\r\n}"
}, {
	"Path": "com.codename1.ui.Slider.isInfinite",
	"Comment": "the infinite slider functionality is used to animateprogress for which there is no defined value.",
	"Method": "boolean isInfinite(){\r\n    return infinite;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.shouldSendPointerReleaseToOtherForm",
	"Comment": "indicates whether this form wants to receive pointerreleased events for touchevents that started in a different form",
	"Method": "boolean shouldSendPointerReleaseToOtherForm(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.fireResponseListener",
	"Comment": "fires the response event to the listeners on this connection",
	"Method": "void fireResponseListener(ActionEvent ev){\r\n    if (actionListeners != null) {\r\n        actionListeners.fireActionEvent(ev);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.text.DateFormat.getDateInstance",
	"Comment": "get a dateformat instance that uses a given style for dates.",
	"Method": "DateFormat getDateInstance(DateFormat getDateInstance,int style){\r\n    return getDateTimeInstance(style, DEFAULT);\r\n}"
}, {
	"Path": "org.conscrypt.javax.net.ssl.TestSSLContext.create",
	"Comment": "testsslcontext creation method that allows separate creation of server key store",
	"Method": "TestSSLContext create(TestSSLContext create,TestKeyStore client,TestKeyStore server){\r\n    return new Builder().client(client).server(server).build();\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isAPSupported",
	"Comment": "indicates whether looking up an access point is supported by this device",
	"Method": "boolean isAPSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundBorder.getShadowX",
	"Comment": "x axis bias of the shadow between 0 and 1 where 0 is to the top and 1 is to the bottom, defaults to 0.5",
	"Method": "float getShadowX(){\r\n    return shadowX;\r\n}"
}, {
	"Path": "com.codename1.io.NetworkManager.shutdownSync",
	"Comment": "shuts down the network thread and waits for shutdown to complete",
	"Method": "void shutdownSync(){\r\n    NetworkThread[] n = this.networkThreads;\r\n    if (n != null) {\r\n        NetworkThread t = n[0];\r\n        if (t != null) {\r\n            shutdown();\r\n            t.join();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundBorder.getShadowY",
	"Comment": "y axis bias of the shadow between 0 and 1 where 0 is to the left and 1 is to the right, defaults to 0.5",
	"Method": "float getShadowY(){\r\n    return shadowY;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.SegmentManager.resetCurrentSegment",
	"Comment": "resets the current segment, creating a new segment if necessary.",
	"Method": "void resetCurrentSegment(){\r\n    Segment lastSegment = lastSegment();\r\n    if (lastSegment != null) {\r\n        currentSegment = lastSegment;\r\n    } else {\r\n        SegmentDescriptor descriptor = SegmentDescriptor.builder().withId(1).withVersion(1).withIndex(1).withMaxSegmentSize(storage.maxSegmentSize()).withMaxEntries(storage.maxEntriesPerSegment()).build();\r\n        descriptor.lock();\r\n        currentSegment = createSegment(descriptor);\r\n        segments.put(1L, currentSegment);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Button.isAutoRelease",
	"Comment": "returns if this is an auto released button.auto released buttons will are been disarmed when a drag is happening within the button.",
	"Method": "boolean isAutoRelease(){\r\n    return autoRelease;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setSelectCommandText",
	"Comment": "allows determining the text for the select command used in the 3rd softbuttonmode.",
	"Method": "void setSelectCommandText(String selectText){\r\n    this.selectText = selectText;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.unlockOrientation",
	"Comment": "this is the reverse method for lock orientation allowing orientation lock to be disabled",
	"Method": "void unlockOrientation(){\r\n    Display.impl.unlockOrientation();\r\n}"
}, {
	"Path": "com.codename1.ui.CN.restoreMinimizedApplication",
	"Comment": "restore the minimized application if minimization is supported by the platform",
	"Method": "void restoreMinimizedApplication(){\r\n    Display.impl.restoreMinimizedApplication();\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.addArgumentArray",
	"Comment": "add an argument to the request response as an array of elements, this willtrigger multiple request entries with the same key",
	"Method": "void addArgumentArray(String key,String value){\r\n    addArgument(key, value);\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.waitForUnnamedForm",
	"Comment": "waits for a form change and if no form change occurred after a given timeout then fail the test",
	"Method": "void waitForUnnamedForm(){\r\n    TestUtils.waitForUnnamedForm();\r\n}"
}, {
	"Path": "com.codename1.ui.Component.keyRepeated",
	"Comment": "if this component is focused, the key repeat eventwill call this method.",
	"Method": "void keyRepeated(int keyCode){\r\n    keyPressed(keyCode);\r\n    keyReleased(keyCode);\r\n}"
}, {
	"Path": "com.codename1.util.TBitLevel.flipBit",
	"Comment": "performs a flipbit on the biginteger, returning a biginteger with the thespecified bit flipped.",
	"Method": "TBigInteger flipBit(TBigInteger val,int n){\r\n    int resSign = (val.sign == 0) ? 1 : val.sign;\r\n    int intCount = n >> 5;\r\n    int bitN = n & 31;\r\n    int resLength = Math.max(intCount + 1, val.numberLength) + 1;\r\n    int[] resDigits = new int[resLength];\r\n    int i;\r\n    int bitNumber = 1 << bitN;\r\n    System.arraycopy(val.digits, 0, resDigits, 0, val.numberLength);\r\n    if (val.sign < 0) {\r\n        if (intCount >= val.numberLength) {\r\n            resDigits[intCount] = bitNumber;\r\n        } else {\r\n            int firstNonZeroDigit = val.getFirstNonzeroDigit();\r\n            if (intCount > firstNonZeroDigit) {\r\n                resDigits[intCount] ^= bitNumber;\r\n            } else if (intCount < firstNonZeroDigit) {\r\n                resDigits[intCount] = -bitNumber;\r\n                for (i = intCount + 1; i < firstNonZeroDigit; i++) {\r\n                    resDigits[i] = -1;\r\n                }\r\n                resDigits[i] = resDigits[i]--;\r\n            } else {\r\n                i = intCount;\r\n                resDigits[i] = -((-resDigits[intCount]) ^ bitNumber);\r\n                if (resDigits[i] == 0) {\r\n                    for (i++; resDigits[i] == -1; i++) {\r\n                        resDigits[i] = 0;\r\n                    }\r\n                    resDigits[i]++;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        resDigits[intCount] ^= bitNumber;\r\n    }\r\n    TBigInteger result = new TBigInteger(resSign, resLength, resDigits);\r\n    result.cutOffLeadingZeroes();\r\n    return result;\r\n}"
}, {
	"Path": "com.codename1.notifications.LocalNotification.setAlertImage",
	"Comment": "sets an image to be displayed on the platform notifications bar, if the underlying platformsupports image displaying otherwise the image will be ignored.",
	"Method": "void setAlertImage(String image){\r\n    this.alertImage = image;\r\n}"
}, {
	"Path": "com.codename1.charts.transitions.SeriesTransition.animateChart",
	"Comment": "applies all pending changes to the chart model and renderer using thecurrent animation settings.",
	"Method": "void animateChart(){\r\n    initTransition();\r\n    chart.getComponentForm().registerAnimated(this);\r\n}"
}, {
	"Path": "java.lang.StringBuilder.setCharAt",
	"Comment": "the character at the specified index of this string builder is set to ch. the string builder is altered to represent a new character sequence that is identical to the old character sequence, except that it contains the character ch at position index.the offset argument must be greater than or equal to 0, and less than the length of this string builder.",
	"Method": "void setCharAt(int index,char ch){\r\n    value[index] = ch;\r\n}"
}, {
	"Path": "android.support.v4.widget.SlidingPaneLayout.canScroll",
	"Comment": "tests scrollability within child views of v given a delta of dx.",
	"Method": "boolean canScroll(View v,boolean checkV,int dx,int x,int y){\r\n    if (v instanceof ViewGroup) {\r\n        final ViewGroup group = (ViewGroup) v;\r\n        final int scrollX = v.getScrollX();\r\n        final int scrollY = v.getScrollY();\r\n        final int count = group.getChildCount();\r\n        for (int i = count - 1; i >= 0; i--) {\r\n            final View child = group.getChildAt(i);\r\n            if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && canScroll(child, true, dx, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return checkV && ViewCompat.canScrollHorizontally(v, -dx);\r\n}"
}, {
	"Path": "android.support.v4.widget.SlidingPaneLayout.isOpen",
	"Comment": "check if the layout is completely open. it can be open either because the slideritself is open revealing the left pane, or if all content fits without sliding.",
	"Method": "boolean isOpen(){\r\n    return !mCanSlide || mSlideOffset == 1;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLParser.setHTMLComponent",
	"Comment": "pair this htmlparser with the htmlcomponent that uses it.this pairing is necessary to allow access to the htmlc in parsetagcontent upon finding a css embedded segment",
	"Method": "void setHTMLComponent(HTMLComponent htmlC){\r\n    if ((htmlC != null) && (this.htmlC != null)) {\r\n        throw new IllegalStateException(\"This HTMLParser is already paired with an HTMLComponent\");\r\n    }\r\n    this.htmlC = htmlC;\r\n}"
}, {
	"Path": "com.codename1.l10n.DateFormat.getDateTimeInstance",
	"Comment": "get a dateformat instance that uses a given style for dates and times.",
	"Method": "DateFormat getDateTimeInstance(int dateStyle,int timeStyle){\r\n    return new DateFormat(dateStyle, timeStyle);\r\n}"
}, {
	"Path": "java.lang.Class.isAnnotationPresent",
	"Comment": "returns true if an annotation for the specified type is present on thiselement, else false.",
	"Method": "boolean isAnnotationPresent(Class annotationType){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.AnimationObject.createAnimationImage",
	"Comment": "creates an animation object instance that can define the animation properties for an image.this version of the method is useful while a resource file is in the process of being loadedand not all images are in place. loading will finish implicitly when the image is first used.",
	"Method": "AnimationObject createAnimationImage(Image img,int x,int y,AnimationObject createAnimationImage,String imageName,Resources res,int x,int y){\r\n    AnimationObject o = new AnimationObject();\r\n    o.imageName = imageName;\r\n    o.res = res;\r\n    o.motionX = Motion.createLinearMotion(x, x, 1);\r\n    o.motionX.setStartTime(Long.MAX_VALUE);\r\n    o.motionY = Motion.createLinearMotion(y, y, 1);\r\n    o.motionY.setStartTime(Long.MAX_VALUE);\r\n    return o;\r\n}"
}, {
	"Path": "com.codename1.impl.android.CodenameOneActivity.enableNativeMenu",
	"Comment": "this method will enable the android native menu system instead of theregular form menu.",
	"Method": "void enableNativeMenu(boolean enable){\r\n    nativeMenu = enable;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.getShadowX",
	"Comment": "x axis bias of the shadow between 0 and 1 where 0 is to the top and 1 is to the bottom, defaults to 0.5",
	"Method": "float getShadowX(){\r\n    return shadowX;\r\n}"
}, {
	"Path": "com.codename1.io.Util.split",
	"Comment": "provides a utility method breaks a given string to array of string according to the given separator",
	"Method": "String[] split(String original,String separator){\r\n    Vector nodes = new Vector();\r\n    int index = original.indexOf(separator);\r\n    while (index >= 0) {\r\n        nodes.addElement(original.substring(0, index));\r\n        original = original.substring(index + separator.length());\r\n        index = original.indexOf(separator);\r\n    }\r\n    nodes.addElement(original);\r\n    String[] ret = new String[nodes.size()];\r\n    for (int i = 0; i < nodes.size(); i++) {\r\n        ret[i] = (String) nodes.elementAt(i);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.getShadowY",
	"Comment": "y axis bias of the shadow between 0 and 1 where 0 is to the left and 1 is to the right, defaults to 0.5",
	"Method": "float getShadowY(){\r\n    return shadowY;\r\n}"
}, {
	"Path": "java.io.DataOutputStream.close",
	"Comment": "closes this output stream and releases any system resources associated with the stream.the close method calls its flush method, and then calls the close method of its underlying output stream.",
	"Method": "void close(){\r\n    return;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getScrollX",
	"Comment": "indicates the x position of the scrolling, this number is relative to thecomponent position and so a position of 0 would indicate the x positionof the component.",
	"Method": "int getScrollX(){\r\n    return scrollX;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getScrollY",
	"Comment": "indicates the y position of the scrolling, this number is relative to thecomponent position and so a position of 0 would indicate the x positionof the component.",
	"Method": "int getScrollY(){\r\n    return scrollY;\r\n}"
}, {
	"Path": "com.codename1.maps.Mercator.forwardMercator",
	"Comment": "create a projected mercator coord from the given coordinate",
	"Method": "Coord forwardMercator(double latitude,double longitude){\r\n    double x = longitude * SIZE / 180;\r\n    double y = MathUtil.log(Math.tan((90 + latitude) * Math.PI / 360)) / (Math.PI / 180) * SIZE / 180;\r\n    return new Coord(y, x, true);\r\n}"
}, {
	"Path": "com.codename1.ui.list.DefaultListCellRenderer.setAlwaysRenderSelection",
	"Comment": "indicates that selection should always be rendered regardless of the status of the shouldrenderselection flag",
	"Method": "void setAlwaysRenderSelection(boolean alwaysRenderSelection){\r\n    this.alwaysRenderSelection = alwaysRenderSelection;\r\n}"
}, {
	"Path": "com.codename1.processing.AbstractEvaluator.explode",
	"Comment": "utility method for subclasses to convert a string to an array, delimitedby comma, optionally enclosed in brackets, and elements optionallyenclosed in quotes.",
	"Method": "String[] explode(String arrayAsString){\r\n    arrayAsString = arrayAsString.trim();\r\n    if (arrayAsString.startsWith(\"(\") && arrayAsString.endsWith(\")\")) {\r\n        arrayAsString = arrayAsString.substring(1, arrayAsString.length() - 1);\r\n    }\r\n    List v = StringUtil.tokenizeString(arrayAsString, ',');\r\n    String[] a = new String[v.size()];\r\n    for (int i = 0; i < v.size(); i++) {\r\n        a[i] = stripQuotes(v.get(i).toString().trim());\r\n    }\r\n    return a;\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.showImpl",
	"Comment": "the default version of show modal shows the dialog occupying the center portionof the screen.",
	"Method": "void showImpl(boolean reverse){\r\n    if (modal && Display.isInitialized() && Display.getInstance().isMinimized()) {\r\n        Log.p(\"Modal dialogs cannot be displayed on a minimized app\");\r\n        return;\r\n    }\r\n    setDisposed(false);\r\n    if (top > -1) {\r\n        show(top, bottom, left, right, includeTitle, modal);\r\n    } else {\r\n        if (modal) {\r\n            if (getDialogPosition() == null) {\r\n                super.showModal(reverse);\r\n            } else {\r\n                showPacked(getDialogPosition(), true);\r\n            }\r\n        } else {\r\n            showModeless();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.CN.startThread",
	"Comment": "start a codename one thread that supports crash protection and similar codename one features.",
	"Method": "Thread startThread(Runnable r,String name){\r\n    return Display.INSTANCE.startThread(r, name);\r\n}"
}, {
	"Path": "java.lang.Math.min",
	"Comment": "returns the smaller of two float values. that is, the result is the value closer to negative infinity. if the arguments have the same value, the result is that same value. if either value is nan, then the result is nan. unlike the the numerical comparison operators, this method considers negative zero to be strictly smaller than positive zero. if one argument is positive zero and the other is negative zero, the result is negative zero.",
	"Method": "double min(double a,double b,float min,float a,float b,int min,int a,int b,long min,long a,long b){\r\n    return 0l;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.contains",
	"Comment": "returns true if the given component is within the hierarchy of this container",
	"Method": "boolean contains(Component cmp){\r\n    if (cmp == null) {\r\n        return false;\r\n    }\r\n    cmp = cmp.getParent();\r\n    while (cmp != null) {\r\n        if (cmp == this) {\r\n            return true;\r\n        }\r\n        cmp = cmp.getParent();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.deregisterMediaComponent",
	"Comment": "indicate that cmp would no longer like to receive animation events",
	"Method": "void deregisterMediaComponent(Component mediaCmp){\r\n    mediaComponents.remove(mediaCmp);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GroupLayout.getAutocreateGaps",
	"Comment": "returns true if gaps between components are automatically be created.",
	"Method": "boolean getAutocreateGaps(){\r\n    return autocreatePadding;\r\n}"
}, {
	"Path": "com.codename1.ui.List.isNumericKeyActions",
	"Comment": "indicate whether pressing the number keys should trigger an action",
	"Method": "boolean isNumericKeyActions(){\r\n    return numericKeyActions;\r\n}"
}, {
	"Path": "com.codename1.processing.AbstractEvaluator.isNumeric",
	"Comment": "utility method for subclasses to determine if an entire string is digits",
	"Method": "boolean isNumeric(String text){\r\n    text = text.trim();\r\n    int tlen = text.length();\r\n    for (int i = 0; i < tlen; i++) {\r\n        if (Character.isDigit(text.charAt(i)) == false) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.location.Geofence.equals",
	"Comment": "geofences are equal if their id, radius, and expiration are the same, and the location latitudeand longitude are the same.",
	"Method": "boolean equals(Object o){\r\n    if (o instanceof Geofence) {\r\n        Geofence g = (Geofence) o;\r\n        return eq(id, g.id) && g.radius == radius && eq(loc, g.loc) && g.expiration == expiration;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.handlesInput",
	"Comment": "prevents key events from being grabbed for focus traversal. e.g. a list componentmight use the arrow keys for internal navigation so it will switch this flag totrue in order to prevent the focus manager from moving to the next component.",
	"Method": "boolean handlesInput(){\r\n    return handlesInput;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.getCodeScanner",
	"Comment": "returns the native implementation of the code scanner or null",
	"Method": "CodeScanner getCodeScanner(){\r\n    if (!hasCamera()) {\r\n        return null;\r\n    }\r\n    return impl.getCodeScanner();\r\n}"
}, {
	"Path": "io.atomix.copycat.protocol.ConnectResponse.builder",
	"Comment": "returns a connect client response builder for an existing response.",
	"Method": "Builder builder(Builder builder,ConnectResponse response){\r\n    return new Builder(response);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLForm.addCheckBox",
	"Comment": "adds the specified checkbox to the form.note that unlike adding to a codename one form here the components are added logically only to query them for their value on submit.",
	"Method": "void addCheckBox(String key,CheckBox cb,String value){\r\n    if (cb.isSelected()) {\r\n        defaultCheckedButtons.addElement(cb);\r\n    } else {\r\n        defaultUncheckedButtons.addElement(cb);\r\n    }\r\n    if (key == null) {\r\n        return;\r\n    }\r\n    Hashtable internal = (Hashtable) comps.get(key);\r\n    if (internal == null) {\r\n        internal = new Hashtable();\r\n        comps.put(key, internal);\r\n    }\r\n    internal.put(cb, value);\r\n}"
}, {
	"Path": "com.codename1.io.services.CachedDataService.register",
	"Comment": "makes sure the cached data class is properly registered as an externalizable. this mustbe invoked for caching to work",
	"Method": "void register(){\r\n    Util.register(\"CachedData\", CachedData.class);\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.shouldAutoStoreState",
	"Comment": "indicates whether the uibuilder should try storing states for forms on its ownby seeking lists, tabs and other statefull elements and keeping their selection",
	"Method": "boolean shouldAutoStoreState(){\r\n    return true;\r\n}"
}, {
	"Path": "android.support.v4.app.TaskStackBuilder.getIntents",
	"Comment": "return an array containing the intents added to this builder. the intent at theroot of the task stack will appear as the first item in the array and theintent at the top of the stack will appear as the last item.",
	"Method": "Intent[] getIntents(){\r\n    Intent[] intents = new Intent[mIntents.size()];\r\n    if (intents.length == 0)\r\n        return intents;\r\n    intents[0] = new Intent(mIntents.get(0)).addFlags(Intent.FLAG_ACTIVITY_NEW_TASK | IntentCompat.FLAG_ACTIVITY_CLEAR_TASK | IntentCompat.FLAG_ACTIVITY_TASK_ON_HOME);\r\n    for (int i = 1; i < intents.length; i++) {\r\n        intents[i] = new Intent(mIntents.get(i));\r\n    }\r\n    return intents;\r\n}"
}, {
	"Path": "android.support.v4.view.ViewPager.getOffscreenPageLimit",
	"Comment": "returns the number of pages that will be retained to either side of thecurrent page in the view hierarchy in an idle state. defaults to 1.",
	"Method": "int getOffscreenPageLimit(){\r\n    return mOffscreenPageLimit;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.ServerStateMachine.apply",
	"Comment": "applies a configuration entry to the internal state machine.configuration entries are applied to internal server state when written to the log. thus, no significantlogic needs to take place in the handling of configuration entries. we simply release the previous configurationentry since it was overwritten by a more recent committed configuration entry.",
	"Method": "CompletableFuture<T> apply(long index,CompletableFuture<T> apply,Entry entry,CompletableFuture<Void> apply,ConfigurationEntry entry,CompletableFuture<Long> apply,RegisterEntry entry,CompletableFuture<Void> apply,KeepAliveEntry entry,CompletableFuture<Void> apply,UnregisterEntry entry,CompletableFuture<Result> apply,CommandEntry entry,CompletableFuture<Result> apply,QueryEntry entry,CompletableFuture<Long> apply,InitializeEntry entry){\r\n    long timestamp = executor.timestamp(entry.getTimestamp());\r\n    for (ServerSessionContext session : executor.context().sessions().sessions.values()) {\r\n        session.setTimestamp(timestamp);\r\n    }\r\n    log.release(entry.getIndex());\r\n    return Futures.completedFutureAsync(entry.getIndex(), ThreadContext.currentContextOrThrow().executor());\r\n}"
}, {
	"Path": "com.codename1.ui.table.TableLayout.isCellSpannedThroughVertically",
	"Comment": "returns true if the cell at the given position is spanned through vertically",
	"Method": "boolean isCellSpannedThroughVertically(int row,int column){\r\n    return tablePositions[row * columns + column] == V_SPAN_CONSTRAINT || tablePositions[row * columns + column] == VH_SPAN_CONSTRAINT;\r\n}"
}, {
	"Path": "com.codename1.ui.List.shouldRenderSelection",
	"Comment": "allows subclasses to override the selection rendering for the component, specifically the spinnerin some themes",
	"Method": "boolean shouldRenderSelection(){\r\n    return Display.getInstance().shouldRenderSelection(this);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GroupLayout.setAutocreateGaps",
	"Comment": "sets whether or not a gap between components should automatically be created.for example, if this is trueand you add two components to a sequentialgroup agap between the two will automatically be created.the defaultis false.",
	"Method": "void setAutocreateGaps(boolean autocreatePadding){\r\n    if (this.autocreatePadding != autocreatePadding) {\r\n        this.autocreatePadding = autocreatePadding;\r\n        invalidateHost();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.list.FilterProxyListModel.setStartsWithMode",
	"Comment": "when enabled this makes the filter check that the string starts with rather than within the index",
	"Method": "void setStartsWithMode(boolean startsWithMode){\r\n    this.startsWithMode = startsWithMode;\r\n}"
}, {
	"Path": "com.codename1.ui.Tabs.createTab",
	"Comment": "creates a tab component by default this is a radiobutton but subclasses can use this to return anything",
	"Method": "Component createTab(String title,Image icon){\r\n    RadioButton b = new RadioButton(title != null ? title : \"\", icon);\r\n    radioGroup.add(b);\r\n    b.setToggle(true);\r\n    b.setTextPosition(BOTTOM);\r\n    if (radioGroup.getButtonCount() == 1) {\r\n        b.setSelected(true);\r\n    }\r\n    if (textPosition != -1) {\r\n        b.setTextPosition(textPosition);\r\n    }\r\n    if (b.getIcon() == null && !getUIManager().isThemeConstant(\"TabEnableAutoImageBool\", true)) {\r\n        Image d = getUIManager().getThemeImageConstant(\"TabUnselectedImage\");\r\n        if (d != null) {\r\n            b.setIcon(d);\r\n            d = getUIManager().getThemeImageConstant(\"TabSelectedImage\");\r\n            if (d != null) {\r\n                b.setRolloverIcon(d);\r\n                b.setPressedIcon(d);\r\n            }\r\n        }\r\n    }\r\n    return b;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.LogTest.testAppend",
	"Comment": "asserts that entries spanning 3 segments are appended with the expected indexes.",
	"Method": "void testAppend(){\r\n    appendEntries(entriesPerSegment * 3);\r\n    assertEquals(log.length(), entriesPerSegment * 3);\r\n    assertEquals(log.segments.segments().size(), 3);\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.getDisabledStyle",
	"Comment": "returns a proxy style for all of the disabled styles of the components in this set.",
	"Method": "Style getDisabledStyle(){\r\n    ArrayList<Style> styles = new ArrayList<Style>();\r\n    for (Component c : this) {\r\n        styles.add(c.getDisabledStyle());\r\n    }\r\n    return Style.createProxyStyle(styles.toArray(new Style[styles.size()]));\r\n}"
}, {
	"Path": "com.codename1.ui.Button.getPressedIcon",
	"Comment": "indicates the icon that is displayed on the button when the button is in pressed state",
	"Method": "Image getPressedIcon(){\r\n    return pressedIcon;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.isScreenSaverDisableSupported",
	"Comment": "checks if the device supports disabling the screen display from dimming, allowing the developer to keep the screen display on.",
	"Method": "boolean isScreenSaverDisableSupported(){\r\n    return Display.impl.isScreenLockSupported();\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.createMediaRecorder",
	"Comment": "creates a media recorder object which will record from the device mic toa file in the given path.",
	"Method": "Media createMediaRecorder(String path,String mimeType){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.ComboBox.setDefaultActAsSpinnerDialog",
	"Comment": "when this flag is active the combo box acts as a button that opens a dialog that looks like a spinnerthis allows creating user interfaces for touch devices where a spinner ui approach is more common thana combo box paradigm.",
	"Method": "void setDefaultActAsSpinnerDialog(boolean aDefaultActAsSpinnerDialog){\r\n    defaultActAsSpinnerDialog = aDefaultActAsSpinnerDialog;\r\n}"
}, {
	"Path": "com.codename1.ui.Button.getDisabledIcon",
	"Comment": "indicates the icon that is displayed on the button when the button is inthe disabled state",
	"Method": "Image getDisabledIcon(){\r\n    return disabledIcon;\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.getMonthViewUnSelectedStyle",
	"Comment": "gets the un selected style of the month view component within thecalendar",
	"Method": "Style getMonthViewUnSelectedStyle(){\r\n    return mv.getUnselectedStyle();\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.onTimer",
	"Comment": "called every 60 seconds to send a session heartbeat to the server. does nothing if thereis not an active application session.",
	"Method": "void onTimer(){\r\n    final boolean hasActiveSession = activityCount_ > 0;\r\n    if (hasActiveSession) {\r\n        if (!disableUpdateSessionRequests_) {\r\n            connectionQueue_.updateSession(roundedSecondsSinceLastSessionDurationUpdate());\r\n        }\r\n        if (eventQueue_.size() > 0) {\r\n            connectionQueue_.recordEvents(eventQueue_.events());\r\n        }\r\n    }\r\n    if (isInitialized()) {\r\n        connectionQueue_.tick();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.setOnExit",
	"Comment": "set a task to be executed once the implementation is being destroyed",
	"Method": "void setOnExit(Runnable on){\r\n    onExit = on;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.setPadding",
	"Comment": "sets the absolute resizing in the last stage of the layout cycle. these values are added to the edges and can thus for\tinstance be used to grow or reduce the size or move the component an absolute number of pixels. may be null\tand elements may be null.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "void setPadding(UnitValue[] sides){\r\n    this.padding = sides != null ? new UnitValue[] { sides[0], sides[1], sides[2], sides[3] } : null;\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.createSymbolTable",
	"Comment": "creates a symbol table container used by the showsymboldialog method.this method is designed for subclases to override and customize.",
	"Method": "Container createSymbolTable(){\r\n    char[] symbolArray = getSymbolTable();\r\n    Container symbols = new Container(new GridLayout(symbolArray.length / 5, 5));\r\n    int slen = symbolArray.length;\r\n    for (int iter = 0; iter < slen; iter++) {\r\n        Button button = new Button(new Command(\"\" + symbolArray[iter]));\r\n        button.setUIID(\"VKBButton\");\r\n        button.setAlignment(CENTER);\r\n        symbols.addComponent(button);\r\n    }\r\n    return symbols;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Collections.synchronizedMap",
	"Comment": "returns a wrapper on the specified map which synchronizes all access tothe map.",
	"Method": "Map<K, V> synchronizedMap(Map<K, V> map){\r\n    if (map == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    return new SynchronizedMap<K, V>(map);\r\n}"
}, {
	"Path": "com.codename1.components.InfiniteProgress.isDefaultMaterialDesignMode",
	"Comment": "indicates whether infinite progress and pull to refresh work in the materialdesign mode by default",
	"Method": "boolean isDefaultMaterialDesignMode(){\r\n    return defaultMaterialDesignMode;\r\n}"
}, {
	"Path": "java.util.TreeMap.comparator",
	"Comment": "returns the comparator used to compare elements in this map.",
	"Method": "Comparator<? super K> comparator(Comparator comparator,Comparator comparator,Comparator<? super K> comparator,Comparator<? super K> comparator,Comparator<? super K> comparator,Comparator<? super K> comparator,Comparator<? super K> comparator){\r\n    return comparator;\r\n}"
}, {
	"Path": "com.codename1.social.FacebookConnect.getAccessToken",
	"Comment": "the facebook token that can be used to access facebook functionality",
	"Method": "AccessToken getAccessToken(){\r\n    AccessToken t = super.getAccessToken();\r\n    if (t != null) {\r\n        return t;\r\n    }\r\n    return new AccessToken(getToken(), null);\r\n}"
}, {
	"Path": "android.support.v4.widget.ViewDragHelper.continueSettling",
	"Comment": "move the captured settling view by the appropriate amount for the current time.if continuesettling returns true, the caller should call it againon the next frame to continue.",
	"Method": "boolean continueSettling(boolean deferCallbacks){\r\n    if (mDragState == STATE_SETTLING) {\r\n        boolean keepGoing = mScroller.computeScrollOffset();\r\n        final int x = mScroller.getCurrX();\r\n        final int y = mScroller.getCurrY();\r\n        final int dx = x - mCapturedView.getLeft();\r\n        final int dy = y - mCapturedView.getTop();\r\n        if (dx != 0) {\r\n            mCapturedView.offsetLeftAndRight(dx);\r\n        }\r\n        if (dy != 0) {\r\n            mCapturedView.offsetTopAndBottom(dy);\r\n        }\r\n        if (dx != 0 || dy != 0) {\r\n            mCallback.onViewPositionChanged(mCapturedView, x, y, dx, dy);\r\n        }\r\n        if (keepGoing && x == mScroller.getFinalX() && y == mScroller.getFinalY()) {\r\n            mScroller.abortAnimation();\r\n            keepGoing = mScroller.isFinished();\r\n        }\r\n        if (!keepGoing) {\r\n            if (deferCallbacks) {\r\n                mParentView.post(mSetIdleRunnable);\r\n            } else {\r\n                setDragState(STATE_IDLE);\r\n            }\r\n        }\r\n    }\r\n    return mDragState == STATE_SETTLING;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getY",
	"Comment": "returns the component y location relatively to its parent container",
	"Method": "int getY(){\r\n    return bounds.getY();\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getX",
	"Comment": "returns the current component x location relatively to its parent container",
	"Method": "int getX(){\r\n    return bounds.getX();\r\n}"
}, {
	"Path": "com.codename1.contacts.Contact.getLinkedContactIds",
	"Comment": "returns the ids of all contacts that are linked to this contact.",
	"Method": "String[] getLinkedContactIds(){\r\n    if (linkedIds == null) {\r\n        linkedIds = Display.getInstance().getLinkedContactIds(this);\r\n    }\r\n    return linkedIds;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.setDisplayLock",
	"Comment": "installs the display lock allowing implementors to synchronize against the display mutex, this method is invoked internally and should not be used.",
	"Method": "void setDisplayLock(Object lock){\r\n    displayLock = lock;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.getTransitionInAnimator",
	"Comment": "this property allows us to define a an animation that will draw the transition forentering this form. a transition is an animation that would occur when switching from one form to another.",
	"Method": "Transition getTransitionInAnimator(){\r\n    return transitionInAnimator;\r\n}"
}, {
	"Path": "ly.count.android.sdk.CountlyStore.join",
	"Comment": "joins all the strings in the specified collection into a single string with the specified delimiter.",
	"Method": "String join(Collection<String> collection,String delimiter){\r\n    final StringBuilder builder = new StringBuilder();\r\n    int i = 0;\r\n    for (String s : collection) {\r\n        builder.append(s);\r\n        if (++i < collection.size()) {\r\n            builder.append(delimiter);\r\n        }\r\n    }\r\n    return builder.toString();\r\n}"
}, {
	"Path": "com.codename1.impl.android.InPlaceEditView.getFontHeight",
	"Comment": "calculate the font height in pixels according to the text area",
	"Method": "int getFontHeight(Style style){\r\n    if (style == null) {\r\n        return -1;\r\n    }\r\n    Font font = style.getFont();\r\n    if (font == null) {\r\n        return -1;\r\n    }\r\n    return font.getHeight();\r\n}"
}, {
	"Path": "com.codename1.ui.table.Table.setIncludeHeader",
	"Comment": "indicates whether the table should render a table header as the first row",
	"Method": "void setIncludeHeader(boolean includeHeader){\r\n    this.includeHeader = includeHeader;\r\n    updateModel();\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.isDuplicateSupported",
	"Comment": "indicates whether this connection request supports duplicate entries in the request queue",
	"Method": "boolean isDuplicateSupported(){\r\n    return duplicateSupported;\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testManyEventsAfterLeaderShutdown",
	"Comment": "tests submitting a linearizable event that publishes to all sessions.",
	"Method": "void testManyEventsAfterLeaderShutdown(int nodes){\r\n    List<CopycatServer> servers = createServers(nodes);\r\n    CopycatClient client = createClient();\r\n    client.onEvent(\"test\", message -> {\r\n        threadAssertNotNull(message);\r\n        resume();\r\n    });\r\n    for (int i = 0; i < 10; i++) {\r\n        client.submit(new TestEvent(true)).thenAccept(result -> {\r\n            threadAssertNotNull(result);\r\n            resume();\r\n        });\r\n        await(30000, 2);\r\n    }\r\n    CopycatServer leader = servers.stream().filter(s -> s.state() == CopycatServer.State.LEADER).findFirst().get();\r\n    leader.shutdown().get(10, TimeUnit.SECONDS);\r\n    for (int i = 0; i < 10; i++) {\r\n        client.submit(new TestEvent(true)).thenAccept(result -> {\r\n            threadAssertNotNull(result);\r\n            resume();\r\n        });\r\n        await(30000, 2);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.util.Resources.getL10NResourceNames",
	"Comment": "returns the names of the localization bundles within this bundle",
	"Method": "String[] getL10NResourceNames(){\r\n    return getResourceTypeNames(MAGIC_L10N);\r\n}"
}, {
	"Path": "com.codename1.payment.Receipt.registerExternalizable",
	"Comment": "registers this class as externalizable so that it can be serialized.",
	"Method": "void registerExternalizable(){\r\n    if (!isExternalizableRegistered()) {\r\n        Util.register(\"com.codename1.payment.Receipt\", Receipt.class);\r\n        setExternalizableRegistered(true);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.setPaintOuterBorderFirst",
	"Comment": "allows toggling the order in which the outer and inner borders are painted for the outer border type",
	"Method": "void setPaintOuterBorderFirst(boolean paintOuterBorderFirst){\r\n    this.paintOuterBorderFirst = paintOuterBorderFirst;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isOpenNativeNavigationAppSupported",
	"Comment": "returns true if the underlying os supports opening the native navigationapplication",
	"Method": "boolean isOpenNativeNavigationAppSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.isQwertyInput",
	"Comment": "true is this is a qwerty device or a device that is currently inqwerty mode.",
	"Method": "boolean isQwertyInput(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.charts.transitions.XYSeriesTransition.initTransition",
	"Comment": "initializes the transition.this can be overridden by subclasses to provide their own functionality to be executed just before the transitionoccurs.",
	"Method": "void initTransition(){\r\n    super.initTransition();\r\n    startVals = new XYSeries(\"Start\");\r\n    copyValues(series, startVals);\r\n    endVals = new XYSeries(\"End\");\r\n    copyValues(cachedSeries, endVals);\r\n}"
}, {
	"Path": "com.codename1.ui.animations.MorphTransition.create",
	"Comment": "creates a transition with the given duration, this transition should be modified with the builder methods such as morph",
	"Method": "MorphTransition create(int duration){\r\n    MorphTransition mt = new MorphTransition();\r\n    mt.duration = duration;\r\n    return mt;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isBidiAlgorithm",
	"Comment": "indicates whether codename one should consider the bidi rtl algorithmwhen drawing text or navigating with the text field cursor.",
	"Method": "boolean isBidiAlgorithm(){\r\n    return impl.isBidiAlgorithm();\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.createMenuSelectCommand",
	"Comment": "factory method that returns the form menu select command.this method can be overridden to customize the command on the form.",
	"Method": "Command createMenuSelectCommand(){\r\n    UIManager manager = parent.getUIManager();\r\n    LookAndFeel lf = manager.getLookAndFeel();\r\n    return new Command(manager.localize(\"select\", \"Select\"), lf.getMenuIcons()[0]);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getInnerHeight",
	"Comment": "gets the inner height of this component.this is the height of the component removing vertical padding.",
	"Method": "int getInnerHeight(){\r\n    return getHeight() - getStyle().getVerticalPadding();\r\n}"
}, {
	"Path": "java.util.Vector.elementAt",
	"Comment": "returns the element at the specified location in this vector.",
	"Method": "E elementAt(int location){\r\n    if (location < elementCount) {\r\n        return (E) elementData[location];\r\n    }\r\n    throw new ArrayIndexOutOfBoundsException(location);\r\n}"
}, {
	"Path": "java.lang.StringBuffer.append",
	"Comment": "appends the string representation of the object argument to this string buffer.the argument is converted to a string as if by the method string.valueof, and the characters of that string are then appended to this string buffer.",
	"Method": "java.lang.StringBuffer append(boolean b,java.lang.StringBuffer append,char c,java.lang.StringBuffer append,char[] str,java.lang.StringBuffer append,char[] str,int offset,int len,java.lang.StringBuffer append,double d,java.lang.StringBuffer append,float f,java.lang.StringBuffer append,int i,java.lang.StringBuffer append,long l,java.lang.StringBuffer append,java.lang.Object obj,java.lang.StringBuffer append,java.lang.String str,StringBuffer append,java.lang.CharSequence cs,StringBuffer append,java.lang.CharSequence cs,int start,int end){\r\n    internal.append(cs, start, end);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GroupLayout.setHorizontalGroup",
	"Comment": "sets the group that is responsible forlayout along the horizontal axis.",
	"Method": "void setHorizontalGroup(Group group){\r\n    if (group == null) {\r\n        throw new IllegalArgumentException(\"Group must be non-null\");\r\n    }\r\n    horizontalGroup = createTopLevelGroup(group);\r\n    invalidateHost();\r\n}"
}, {
	"Path": "com.l2fprod.common.swing.UserPreferences.getDefaultFileChooser",
	"Comment": "gets the default file chooser. its current directory will be tracked andrestored on subsequent calls.",
	"Method": "JFileChooser getDefaultFileChooser(){\r\n    return getFileChooser(\"default\");\r\n}"
}, {
	"Path": "com.codename1.javascript.JSObject.callObject",
	"Comment": "calls a method on the underlying javascript object that returns a javascript object. called synchronously with no arguments.",
	"Method": "JSObject callObject(String key){\r\n    return (JSObject) call(key);\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.isDisableStaticDialogScrolling",
	"Comment": "allows a developer to indicate his interest that the dialog should no longerscroll on its own but rather rely on the scrolling properties of internalscrollable containers. this flag only affects the static show methods withinthis class.",
	"Method": "boolean isDisableStaticDialogScrolling(){\r\n    return disableStaticDialogScrolling;\r\n}"
}, {
	"Path": "com.codename1.ui.BrowserComponent.isPinchToZoomEnabled",
	"Comment": "this method is unreliable and is only here for consistency with setpinchtozoomenabled,it will not return whether the platform supports pinch since this is very hard to detectproperly.",
	"Method": "boolean isPinchToZoomEnabled(){\r\n    return pinchToZoom;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLFont.isItalicCounterpart",
	"Comment": "checks if the specified font is an italic counterpart of this font.",
	"Method": "boolean isItalicCounterpart(HTMLFont font){\r\n    if (!italic) {\r\n        return false;\r\n    }\r\n    return ((size == font.getSize()) && (isSameFamily(font)) && (bold == font.isBold()));\r\n}"
}, {
	"Path": "com.codename1.designer.FontEditor.createFont",
	"Comment": "creates a font instance based on the current state to place into the undoable edit within the editor.",
	"Method": "EditorFont createFont(){\r\n    if (!completedConstruction) {\r\n        return null;\r\n    }\r\n    com.codename1.ui.Font systemFont = com.codename1.ui.Font.createSystemFont(FONT_FACE_VALUES[systemFontFace.getSelectedIndex()], FONT_STYLE_VALUES[systemFontStyle.getSelectedIndex()], FONT_SIZE_VALUES[systemFontSize.getSelectedIndex()]);\r\n    java.awt.Font aFont = preview.getFont();\r\n    String s = aFont.getFamily() + \"-\";\r\n    if (aFont.isBold()) {\r\n        s += aFont.isItalic() ? \"bolditalic\" : \"bold\";\r\n    } else {\r\n        s += aFont.isItalic() ? \"italic\" : \"plain\";\r\n    }\r\n    s += \"-\" + aFont.getSize();\r\n    int selIndex = fontMainType.getSelectedIndex();\r\n    EditorFont newFont = new EditorFont(systemFont, null, s + \";\" + lookupString.getText(), selIndex == 1 || selIndex == 2, ANTI_ALIASING_VALUES[antiAliasing.getSelectedIndex()], charset.getText());\r\n    if (!factoryCreation) {\r\n        resources.setFont(fontName, newFont);\r\n    }\r\n    return newFont;\r\n}"
}, {
	"Path": "com.codename1.properties.UiBinding.bindString",
	"Comment": "changes to the text area are automatically reflected to the given property and visa versa",
	"Method": "void bindString(Property<String, ? extends Object> prop,TextArea ta){\r\n    bind(prop, ta);\r\n}"
}, {
	"Path": "com.codename1.components.ButtonList.onReady",
	"Comment": "wrap any calls that requires that the infrastructure is ready inside this.",
	"Method": "void onReady(Runnable r){\r\n    if (ready) {\r\n        r.run();\r\n    } else {\r\n        onReady.add(r);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.getCursorBlinkTimeOn",
	"Comment": "the amount of time in milliseconds in which the cursor is visible",
	"Method": "int getCursorBlinkTimeOn(){\r\n    return blinkOnTime;\r\n}"
}, {
	"Path": "com.codename1.io.Log.sendLogImpl",
	"Comment": "sends the current log to the cloud regardless of the reporting level",
	"Method": "void sendLogImpl(boolean sync){\r\n    try {\r\n        if (!Display.isInitialized()) {\r\n            return;\r\n        }\r\n        if (!instance.logDirty) {\r\n            return;\r\n        }\r\n        instance.logDirty = false;\r\n        String devId = getUniqueDeviceKey();\r\n        if (devId == null) {\r\n            if (Display.getInstance().isSimulator()) {\r\n                Dialog.show(\"Send Log Error\", \"Device Not Registered: Sending a log from an unregistered device is impossible\", \"OK\", null);\r\n            } else {\r\n                Log.p(\"Device Not Registered: Sending a log from an unregistered device is impossible\");\r\n            }\r\n            return;\r\n        }\r\n        ConnectionRequest r = new ConnectionRequest();\r\n        r.setPost(false);\r\n        MultipartRequest m = new MultipartRequest();\r\n        m.setUrl(\"https://crashreport.codenameone.com/CrashReporterEmail/sendCrashReport\");\r\n        byte[] read = Util.readInputStream(Storage.getInstance().createInputStream(\"CN1Log__$\"));\r\n        m.addArgument(\"i\", \"\" + devId);\r\n        m.addArgument(\"u\", Display.getInstance().getProperty(\"built_by_user\", \"\"));\r\n        m.addArgument(\"p\", Display.getInstance().getProperty(\"package_name\", \"\"));\r\n        m.addArgument(\"v\", Display.getInstance().getProperty(\"AppVersion\", \"0.1\"));\r\n        m.addData(\"log\", read, \"text/plain\");\r\n        m.setFailSilently(true);\r\n        if (sync) {\r\n            NetworkManager.getInstance().addToQueueAndWait(m);\r\n        } else {\r\n            NetworkManager.getInstance().addToQueue(m);\r\n        }\r\n    } catch (Throwable ex) {\r\n        ex.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Container.getLayout",
	"Comment": "returns the layout manager responsible for arranging this container.",
	"Method": "Layout getLayout(){\r\n    return layout;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.focusGainedInternal",
	"Comment": "this method is useful since it is not a part of the public api yetallows a component within this package to observe focus eventswithout implementing a public interface or creating a new class",
	"Method": "void focusGainedInternal(){\r\n    startComponentLableTicker();\r\n}"
}, {
	"Path": "com.codename1.impl.javase.JavaSEPort.hasSkins",
	"Comment": "subclasses of this implementation might override this to return builtinskins for a specific implementation",
	"Method": "boolean hasSkins(){\r\n    return System.getProperty(\"skin\") != null || System.getProperty(\"dskin\") != null;\r\n}"
}, {
	"Path": "com.codename1.ui.Font.createSystemFont",
	"Comment": "creates a system native font in a similar way to common midp fonts",
	"Method": "Font createSystemFont(int face,int style,int size){\r\n    return new Font(face, style, size);\r\n}"
}, {
	"Path": "com.codename1.ui.validation.Validator.getErrorMessageUIID",
	"Comment": "error message uiid defaults to dialogbody. allows customizing the look of the message",
	"Method": "String getErrorMessageUIID(){\r\n    return errorMessageUIID;\r\n}"
}, {
	"Path": "io.prometheus.client.SimpleCollector.remove",
	"Comment": "remove the child with the given labels.any references to the child are invalidated.",
	"Method": "void remove(String labelValues){\r\n    children.remove(Arrays.asList(labelValues));\r\n    initializeNoLabelsChild();\r\n}"
}, {
	"Path": "com.codename1.social.FacebookConnect.getToken",
	"Comment": "the facebook token that can be used to access facebook functionality",
	"Method": "String getToken(){\r\n    throw new RuntimeException(\"Native facebook unsupported, if you are running on the Simulator use getAccessToken\");\r\n}"
}, {
	"Path": "java.net.URIHelper.getParameters",
	"Comment": "since a uri query can contain a single key multiple times, the responding\tparameter map will contain string values when a key appears only once,\tand string arrays when they key appears multiple times.",
	"Method": "Hashtable<String, Object> getParameters(URI uri){\r\n    try {\r\n        return parseQuery(uri.getQuery(), true);\r\n    } catch (URISyntaxException e) {\r\n        e.printStackTrace();\r\n        throw new IllegalArgumentException(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.isMinimizeOnBack",
	"Comment": "when set to true the physical back button will minimize the application",
	"Method": "boolean isMinimizeOnBack(){\r\n    return minimizeOnBack;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.DefaultLookAndFeel.isTickWhenFocused",
	"Comment": "this method allows to set all labels, buttons, checkboxes, radiobuttonsto start ticking when the text is too long.",
	"Method": "boolean isTickWhenFocused(){\r\n    return tickWhenFocused;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Collections.synchronizedSortedMap",
	"Comment": "returns a wrapper on the specified sorted map which synchronizes allaccess to the sorted map.",
	"Method": "SortedMap<K, V> synchronizedSortedMap(SortedMap<K, V> map){\r\n    if (map == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    return new SynchronizedSortedMap<K, V>(map);\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testManySessionsManyEvents",
	"Comment": "tests submitting a linearizable event that publishes to all sessions.",
	"Method": "void testManySessionsManyEvents(int nodes){\r\n    createServers(nodes);\r\n    CopycatClient client = createClient();\r\n    client.onEvent(\"test\", message -> {\r\n        threadAssertNotNull(message);\r\n        resume();\r\n    });\r\n    createClient().onEvent(\"test\", message -> {\r\n        threadAssertNotNull(message);\r\n        resume();\r\n    });\r\n    createClient().onEvent(\"test\", message -> {\r\n        threadAssertNotNull(message);\r\n        resume();\r\n    });\r\n    for (int i = 0; i < 10; i++) {\r\n        client.submit(new TestEvent(false)).thenAccept(result -> {\r\n            threadAssertNotNull(result);\r\n            resume();\r\n        });\r\n        await(10000, 4);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.util.regex.REUtil.createRE",
	"Comment": "creates a regular expression, permitting simple or complex syntax",
	"Method": "RE createRE(String expression,int matchFlags,RE createRE,String expression){\r\n    return createRE(expression, RE.MATCH_NORMAL);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.translator.NameTranslator.translateDescriptor",
	"Comment": "translates a simple type descriptor, specifically. only translates names in the\tdescriptor, if they are represented by class mirrors.",
	"Method": "String translateDescriptor(String descriptor){\r\n    Type type = Type.getType(descriptor);\r\n    type = getMirrorType(type);\r\n    return type.getDescriptor();\r\n}"
}, {
	"Path": "com.codename1.ui.table.TableLayout.getNextColumn",
	"Comment": "returns the column where the next operation of add will appear",
	"Method": "int getNextColumn(){\r\n    return currentColumn;\r\n}"
}, {
	"Path": "com.codename1.ui.Toolbar.createOverflowCommandList",
	"Comment": "creates the list component containing the commands within the givenvector used for showing the menu dialog",
	"Method": "List createOverflowCommandList(Vector commands){\r\n    List l = new List(commands);\r\n    l.setRenderingPrototype(null);\r\n    l.setListSizeCalculationSampleCount(commands.size());\r\n    l.setUIID(\"CommandList\");\r\n    Component c = (Component) l.getRenderer();\r\n    c.setUIID(\"Command\");\r\n    c = l.getRenderer().getListFocusComponent(l);\r\n    c.setUIID(\"CommandFocus\");\r\n    l.setFixedSelection(List.FIXED_NONE_CYCLIC);\r\n    l.setScrollVisible(false);\r\n    ((DefaultListCellRenderer) l.getRenderer()).setShowNumbers(false);\r\n    return l;\r\n}"
}, {
	"Path": "java.util.ArrayDeque.peek",
	"Comment": "gets but not removes the head element of this deque. this method returnsnull if the deque is empty.",
	"Method": "E peek(){\r\n    return (status == DequeStatus.Empty) ? null : elements[front];\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Collections.synchronizedList",
	"Comment": "returns a wrapper on the specified list which synchronizes all access tothe list.",
	"Method": "List<T> synchronizedList(List<T> list){\r\n    if (list == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    if (list instanceof RandomAccess) {\r\n        return new SynchronizedRandomAccessList<T>(list);\r\n    }\r\n    return new SynchronizedList<T>(list);\r\n}"
}, {
	"Path": "io.atomix.copycat.client.DefaultCopycatClientTest.testCommandSessionRecovery",
	"Comment": "tests calling the recovery strategy when a command fails due to unknownsessionexception.",
	"Method": "void testCommandSessionRecovery(){\r\n    Connection connection = mock(Connection.class);\r\n    when(connection.close()).thenReturn(CompletableFuture.completedFuture(null));\r\n    Client client = mock(Client.class);\r\n    when(client.connect(any())).thenReturn(CompletableFuture.completedFuture(connection));\r\n    Transport transport = mock(Transport.class);\r\n    when(transport.client()).thenReturn(client);\r\n    when(connection.sendAndReceive(isA(ConnectRequest.class))).thenReturn(CompletableFuture.completedFuture(ConnectResponse.builder().withStatus(Response.Status.OK).withLeader(LEADER).withMembers(MEMBERS).build()));\r\n    when(connection.sendAndReceive(isA(RegisterRequest.class))).thenReturn(CompletableFuture.completedFuture(RegisterResponse.builder().withStatus(Response.Status.OK).withSession(1).withTimeout(5000).withLeader(LEADER).withMembers(MEMBERS).build())).thenReturn(CompletableFuture.completedFuture(RegisterResponse.builder().withStatus(Response.Status.OK).withSession(2).withTimeout(5000).withLeader(LEADER).withMembers(MEMBERS).build()));\r\n    Mockito.when(connection.sendAndReceive(isA(KeepAliveRequest.class))).thenReturn(CompletableFuture.completedFuture(KeepAliveResponse.builder().withStatus(Response.Status.OK).withLeader(LEADER).withMembers(MEMBERS).build()));\r\n    Mockito.when(connection.sendAndReceive(isA(CommandRequest.class))).thenReturn(CompletableFuture.completedFuture(CommandResponse.builder().withStatus(Response.Status.ERROR).withError(CopycatError.Type.UNKNOWN_SESSION_ERROR).build())).thenReturn(CompletableFuture.completedFuture(CommandResponse.builder().withStatus(Response.Status.OK).withIndex(1).withEventIndex(0).withResult(\"Hello world!\").build()));\r\n    CopycatClient copycatClient = CopycatClient.builder().withTransport(transport).withRecoveryStrategy(RecoveryStrategies.RECOVER).build();\r\n    copycatClient.connect(MEMBERS).join();\r\n    try {\r\n        copycatClient.submit(new TestCommand()).join();\r\n        fail();\r\n    } catch (CompletionException e) {\r\n        if (!(e.getCause() instanceof ClosedSessionException)) {\r\n            fail();\r\n        }\r\n    }\r\n    CountDownLatch latch = new CountDownLatch(1);\r\n    copycatClient.onStateChange(state -> {\r\n        if (state == CopycatClient.State.CONNECTED) {\r\n            assertEquals(2, copycatClient.session().id());\r\n            latch.countDown();\r\n        }\r\n    });\r\n    latch.await();\r\n    assertEquals(copycatClient.submit(new TestCommand()).join(), \"Hello world!\");\r\n}"
}, {
	"Path": "io.prometheus.client.CKMSQuantiles.compress",
	"Comment": "try to remove extraneous items from the set of sampled items. this checksif an item is unnecessary based on the desired error bounds, and mergesit with the adjacent item if it is.",
	"Method": "void compress(){\r\n    if (sample.size() < 2) {\r\n        return;\r\n    }\r\n    ListIterator<Item> it = sample.listIterator();\r\n    int removed = 0;\r\n    Item prev = null;\r\n    Item next = it.next();\r\n    while (it.hasNext()) {\r\n        prev = next;\r\n        next = it.next();\r\n        if (prev.g + next.g + next.delta <= allowableError(it.previousIndex())) {\r\n            next.g += prev.g;\r\n            it.previous();\r\n            it.previous();\r\n            it.remove();\r\n            it.next();\r\n            removed++;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyBase.setLabel",
	"Comment": "the label of the property defaults to its name but can be changed to anything, it can be usedwhen binding a property to ui elements",
	"Method": "void setLabel(String label){\r\n    putClientProperty(\"cn1PropertyLabel\", label);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLTableModel.addCell",
	"Comment": "adds the given component as a cell to the end of the current row of the table",
	"Method": "void addCell(Component cell,boolean isHeader,CellConstraint constraint){\r\n    if (isHeader) {\r\n        headers.addElement(cell);\r\n    }\r\n    currentRow.addElement(cell);\r\n    if (currentRow.size() > maxColumn) {\r\n        maxColumn = currentRow.size();\r\n    }\r\n    if (constraint != null) {\r\n        constraints.put(cell, constraint);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyIndex.asExternalizable",
	"Comment": "returns an externalizable object for serialization of this business object, unlike regularexternalizables this implementation is robust to changes, additions and removals of properties",
	"Method": "Externalizable asExternalizable(){\r\n    return new Externalizable() {\r\n        public int getVersion() {\r\n            return 1;\r\n        }\r\n        public void externalize(DataOutputStream out) throws IOException {\r\n            out.writeInt(getSize());\r\n            for (PropertyBase b : PropertyIndex.this) {\r\n                out.writeUTF(b.getName());\r\n                if (b instanceof CollectionProperty) {\r\n                    out.writeByte(2);\r\n                    Util.writeObject(((CollectionProperty) b).asList(), out);\r\n                    continue;\r\n                }\r\n                if (b instanceof MapProperty) {\r\n                    out.writeByte(3);\r\n                    Util.writeObject(((MapProperty) b).asMap(), out);\r\n                    continue;\r\n                }\r\n                if (b instanceof Property) {\r\n                    out.writeByte(1);\r\n                    Util.writeObject(((Property) b).get(), out);\r\n                    continue;\r\n                }\r\n            }\r\n        }\r\n        public void internalize(int version, DataInputStream in) throws IOException {\r\n            int size = in.readInt();\r\n            for (int iter = 0; iter < size; iter++) {\r\n                String pname = in.readUTF();\r\n                int type = in.readByte();\r\n                Object data = Util.readObject(in);\r\n                PropertyBase pb = get(pname);\r\n                switch(type) {\r\n                    case 1:\r\n                        if (pb instanceof Property) {\r\n                            ((Property) pb).set(data);\r\n                        }\r\n                        break;\r\n                    case 2:\r\n                        if (pb instanceof CollectionProperty) {\r\n                            ((CollectionProperty) pb).set((List) data);\r\n                        }\r\n                        break;\r\n                    case 3:\r\n                        if (pb instanceof MapProperty) {\r\n                            ((MapProperty) pb).setMap((Map) data);\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n        public String getObjectId() {\r\n            return getName();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyIndex.asExternalizable",
	"Comment": "returns an externalizable object for serialization of this business object, unlike regularexternalizables this implementation is robust to changes, additions and removals of properties",
	"Method": "Externalizable asExternalizable(){\r\n    return 1;\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyIndex.asExternalizable",
	"Comment": "returns an externalizable object for serialization of this business object, unlike regularexternalizables this implementation is robust to changes, additions and removals of properties",
	"Method": "Externalizable asExternalizable(){\r\n    out.writeInt(getSize());\r\n    for (PropertyBase b : PropertyIndex.this) {\r\n        out.writeUTF(b.getName());\r\n        if (b instanceof CollectionProperty) {\r\n            out.writeByte(2);\r\n            Util.writeObject(((CollectionProperty) b).asList(), out);\r\n            continue;\r\n        }\r\n        if (b instanceof MapProperty) {\r\n            out.writeByte(3);\r\n            Util.writeObject(((MapProperty) b).asMap(), out);\r\n            continue;\r\n        }\r\n        if (b instanceof Property) {\r\n            out.writeByte(1);\r\n            Util.writeObject(((Property) b).get(), out);\r\n            continue;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyIndex.asExternalizable",
	"Comment": "returns an externalizable object for serialization of this business object, unlike regularexternalizables this implementation is robust to changes, additions and removals of properties",
	"Method": "Externalizable asExternalizable(){\r\n    int size = in.readInt();\r\n    for (int iter = 0; iter < size; iter++) {\r\n        String pname = in.readUTF();\r\n        int type = in.readByte();\r\n        Object data = Util.readObject(in);\r\n        PropertyBase pb = get(pname);\r\n        switch(type) {\r\n            case 1:\r\n                if (pb instanceof Property) {\r\n                    ((Property) pb).set(data);\r\n                }\r\n                break;\r\n            case 2:\r\n                if (pb instanceof CollectionProperty) {\r\n                    ((CollectionProperty) pb).set((List) data);\r\n                }\r\n                break;\r\n            case 3:\r\n                if (pb instanceof MapProperty) {\r\n                    ((MapProperty) pb).setMap((Map) data);\r\n                }\r\n                break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyIndex.asExternalizable",
	"Comment": "returns an externalizable object for serialization of this business object, unlike regularexternalizables this implementation is robust to changes, additions and removals of properties",
	"Method": "Externalizable asExternalizable(){\r\n    return getName();\r\n}"
}, {
	"Path": "com.codename1.ui.CN.onCanInstallOnHomescreen",
	"Comment": "a callback fired when you are allowed to prompt the user to install the app on their homescreen.only relevant in the javascript port.",
	"Method": "void onCanInstallOnHomescreen(Runnable r){\r\n    Display.impl.onCanInstallOnHomescreen(r);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Style.getPaddingLeft",
	"Comment": "returns the left padding in pixel or right padding in an rtl situation",
	"Method": "int getPaddingLeft(boolean rtl){\r\n    if (rtl) {\r\n        return convertUnit(paddingUnit, padding[Component.RIGHT], Component.RIGHT);\r\n    }\r\n    return convertUnit(paddingUnit, padding[Component.LEFT], Component.LEFT);\r\n}"
}, {
	"Path": "com.codename1.ui.CN.callSeriallyOnIdle",
	"Comment": "causes the runnable to be invoked on the event dispatch thread when the event dispatch thread is idle. this method returns immediately and will not wait for the serial call to occur. notice this method is identical to call serially but will perform the runnable only whenthe edt is idle",
	"Method": "void callSeriallyOnIdle(Runnable r){\r\n    Display.INSTANCE.callSeriallyOnIdle(r);\r\n}"
}, {
	"Path": "com.codename1.ui.Form.getTabIterator",
	"Comment": "returns an iterator that iterates over all of the components in this form, orderedby their tab index.",
	"Method": "TabIterator getTabIterator(Component start){\r\n    updateTabIndices(0);\r\n    java.util.List<Component> out = new ArrayList<Component>();\r\n    out.addAll(ComponentSelector.select(\"*\", this).filter(new Filter() {\r\n        @Override\r\n        public boolean filter(Component c) {\r\n            return c.getTabIndex() >= 0 && c.isVisible() && c.isFocusable() && c.isEnabled();\r\n        }\r\n    }));\r\n    Collections.sort(out, new Comparator<Component>() {\r\n        @Override\r\n        public int compare(Component o1, Component o2) {\r\n            return o1.getTabIndex() < o2.getTabIndex() ? -1 : o2.getTabIndex() < o1.getTabIndex() ? 1 : 0;\r\n        }\r\n    });\r\n    return new TabIterator(out, start);\r\n}"
}, {
	"Path": "com.codename1.ui.Form.getTabIterator",
	"Comment": "returns an iterator that iterates over all of the components in this form, orderedby their tab index.",
	"Method": "TabIterator getTabIterator(Component start){\r\n    return c.getTabIndex() >= 0 && c.isVisible() && c.isFocusable() && c.isEnabled();\r\n}"
}, {
	"Path": "com.codename1.ui.Form.getTabIterator",
	"Comment": "returns an iterator that iterates over all of the components in this form, orderedby their tab index.",
	"Method": "TabIterator getTabIterator(Component start){\r\n    return o1.getTabIndex() < o2.getTabIndex() ? -1 : o2.getTabIndex() < o1.getTabIndex() ? 1 : 0;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.killAndWait",
	"Comment": "kills the given request and waits until the request is killed if it isbeing processed by one of the threads. this method must not be invoked froma network thread!",
	"Method": "void killAndWait(ConnectionRequest request){\r\n    NetworkManager.getInstance().killAndWait(request);\r\n}"
}, {
	"Path": "com.codename1.ui.Transform.isPerspectiveSupported",
	"Comment": "checks if perspective transforms are supported on this platform.if this returns false,you cannot use this class.",
	"Method": "boolean isPerspectiveSupported(){\r\n    return Display.impl.isPerspectiveTransformSupported();\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.setDefaultEndsWith3Points",
	"Comment": "indicates whether labels should end with 3 points by default",
	"Method": "void setDefaultEndsWith3Points(boolean defaultEndsWith3Points){\r\n    this.defaultEndsWith3Points = defaultEndsWith3Points;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.Segment.contains",
	"Comment": "returns a boolean value indicating whether the entry at the given index is active.",
	"Method": "boolean contains(long index){\r\n    assertSegmentOpen();\r\n    if (!validIndex(index))\r\n        return false;\r\n    long offset = relativeOffset(index);\r\n    return offsetIndex.contains(offset);\r\n}"
}, {
	"Path": "com.codename1.components.ToastBar.showConnectionProgress",
	"Comment": "shows a progress indicator based on connection request, this is incomplete but it meant to serve as a replacement for the inifinte progress",
	"Method": "void showConnectionProgress(String message,ConnectionRequest cr,SuccessCallback<NetworkEvent> onSuccess,FailureCallback<NetworkEvent> onError){\r\n    final ToastBar.Status s = ToastBar.getInstance().createStatus();\r\n    s.setProgress(-1);\r\n    s.setMessage(message);\r\n    s.show();\r\n    final ActionListener[] progListener = new ActionListener[1];\r\n    final ActionListener<NetworkEvent> errorListener = new ActionListener<NetworkEvent>() {\r\n        public void actionPerformed(NetworkEvent evt) {\r\n            s.clear();\r\n            NetworkManager.getInstance().removeErrorListener(this);\r\n            if (progListener[0] != null) {\r\n                NetworkManager.getInstance().removeProgressListener(progListener[0]);\r\n            }\r\n            if (onError != null) {\r\n                onError.onError(cr, evt.getError(), evt.getResponseCode(), evt.getMessage());\r\n            }\r\n        }\r\n    };\r\n    NetworkManager.getInstance().addErrorListener(errorListener);\r\n    progListener[0] = new ActionListener<NetworkEvent>() {\r\n        private int soFar;\r\n        public void actionPerformed(NetworkEvent evt) {\r\n            switch(evt.getProgressType()) {\r\n                case NetworkEvent.PROGRESS_TYPE_INITIALIZING:\r\n                    s.setProgress(-1);\r\n                    break;\r\n                case NetworkEvent.PROGRESS_TYPE_INPUT:\r\n                case NetworkEvent.PROGRESS_TYPE_OUTPUT:\r\n                    int currentLength = cr.getContentLength();\r\n                    if (currentLength > 0) {\r\n                        int sentReceived = evt.getSentReceived();\r\n                        float prog = ((float) sentReceived) / ((float) currentLength) * 100f;\r\n                        s.setProgress((int) prog);\r\n                    } else {\r\n                        s.setProgress(-1);\r\n                    }\r\n            }\r\n        }\r\n    };\r\n    cr.addResponseListener(new ActionListener<NetworkEvent>() {\r\n        @Override\r\n        public void actionPerformed(NetworkEvent evt) {\r\n            NetworkManager.getInstance().removeErrorListener(errorListener);\r\n            NetworkManager.getInstance().removeProgressListener(progListener[0]);\r\n            s.clear();\r\n            int rc = cr.getResponseCode();\r\n            if (onSuccess != null && (rc == 200 || rc == 201 || rc == 202)) {\r\n                onSuccess.onSucess(evt);\r\n            }\r\n        }\r\n    });\r\n    NetworkManager.getInstance().addProgressListener(progListener[0]);\r\n}"
}, {
	"Path": "com.codename1.components.ToastBar.showConnectionProgress",
	"Comment": "shows a progress indicator based on connection request, this is incomplete but it meant to serve as a replacement for the inifinte progress",
	"Method": "void showConnectionProgress(String message,ConnectionRequest cr,SuccessCallback<NetworkEvent> onSuccess,FailureCallback<NetworkEvent> onError){\r\n    s.clear();\r\n    NetworkManager.getInstance().removeErrorListener(this);\r\n    if (progListener[0] != null) {\r\n        NetworkManager.getInstance().removeProgressListener(progListener[0]);\r\n    }\r\n    if (onError != null) {\r\n        onError.onError(cr, evt.getError(), evt.getResponseCode(), evt.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.ToastBar.showConnectionProgress",
	"Comment": "shows a progress indicator based on connection request, this is incomplete but it meant to serve as a replacement for the inifinte progress",
	"Method": "void showConnectionProgress(String message,ConnectionRequest cr,SuccessCallback<NetworkEvent> onSuccess,FailureCallback<NetworkEvent> onError){\r\n    switch(evt.getProgressType()) {\r\n        case NetworkEvent.PROGRESS_TYPE_INITIALIZING:\r\n            s.setProgress(-1);\r\n            break;\r\n        case NetworkEvent.PROGRESS_TYPE_INPUT:\r\n        case NetworkEvent.PROGRESS_TYPE_OUTPUT:\r\n            int currentLength = cr.getContentLength();\r\n            if (currentLength > 0) {\r\n                int sentReceived = evt.getSentReceived();\r\n                float prog = ((float) sentReceived) / ((float) currentLength) * 100f;\r\n                s.setProgress((int) prog);\r\n            } else {\r\n                s.setProgress(-1);\r\n            }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.ToastBar.showConnectionProgress",
	"Comment": "shows a progress indicator based on connection request, this is incomplete but it meant to serve as a replacement for the inifinte progress",
	"Method": "void showConnectionProgress(String message,ConnectionRequest cr,SuccessCallback<NetworkEvent> onSuccess,FailureCallback<NetworkEvent> onError){\r\n    NetworkManager.getInstance().removeErrorListener(errorListener);\r\n    NetworkManager.getInstance().removeProgressListener(progListener[0]);\r\n    s.clear();\r\n    int rc = cr.getResponseCode();\r\n    if (onSuccess != null && (rc == 200 || rc == 201 || rc == 202)) {\r\n        onSuccess.onSucess(evt);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.setTimeZone",
	"Comment": "sets the calendar timezone, if not specified calendar will use thedefault timezone",
	"Method": "void setTimeZone(TimeZone tmz){\r\n    this.tmz = tmz;\r\n}"
}, {
	"Path": "java.lang.Float.toString",
	"Comment": "returns a string representation of this float object. the primitive float value represented by this object is converted to a string exactly as if by the method tostring of one argument.",
	"Method": "java.lang.String toString(java.lang.String toString,float f){\r\n    float m = Math.abs(d);\r\n    if (d == POSITIVE_INFINITY) {\r\n        return \"Infinity\";\r\n    } else if (d == NEGATIVE_INFINITY) {\r\n        return \"-Infinity\";\r\n    } else if (d == 0) {\r\n        return \"0.0\";\r\n    } else if (m >= 1e-3 && m < 1e7) {\r\n        String str = toStringImpl(d, false);\r\n        char[] chars = str.toCharArray();\r\n        int i = chars.length - 1;\r\n        char c;\r\n        while (i >= 0 && (c = chars[i]) == '0') {\r\n            i--;\r\n        }\r\n        if (i < 0 || str.indexOf('.') == -1) {\r\n            return str;\r\n        } else if (chars[i] == '.' || chars[i] == ',') {\r\n            i++;\r\n        }\r\n        return str.substring(0, i + 1);\r\n    } else {\r\n        return toStringImpl(d, true);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.PlatformDefaults.getDefaultRowAlignmentBaseline",
	"Comment": "the default alignment for rows. pre v3.5 this was false but now it is\ttrue.",
	"Method": "boolean getDefaultRowAlignmentBaseline(){\r\n    return dra;\r\n}"
}, {
	"Path": "com.codename1.ui.Font.getSize",
	"Comment": "return optional operation returning the font size for system fonts",
	"Method": "int getSize(){\r\n    return Display.impl.getSize(font);\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.setDayEnabled",
	"Comment": "since a day may be any component type, developers should override thismethod to add support for enabling or disabling the right component.",
	"Method": "void setDayEnabled(Component cmp,boolean enable){\r\n    cmp.setEnabled(enable);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isBadgingSupported",
	"Comment": "returns true if the underlying os supports numeric badges on icons. notice this is only available on iosand only when push notification is enabled",
	"Method": "boolean isBadgingSupported(){\r\n    return impl.isBadgingSupported();\r\n}"
}, {
	"Path": "java.lang.Math.max",
	"Comment": "returns the greater of two float values. that is, the result is the argument closer to positive infinity. if the arguments have the same value, the result is that same value. if either value is nan, then the result is nan. unlike the the numerical comparison operators, this method considers negative zero to be strictly smaller than positive zero. if one argument is positive zero and the other negative zero, the result is positive zero.",
	"Method": "double max(double a,double b,float max,float a,float b,int max,int a,int b,long max,long a,long b){\r\n    return 0l;\r\n}"
}, {
	"Path": "java.util.StringTokenizer.countTokens",
	"Comment": "returns the number of unprocessed tokens remaining in the string.",
	"Method": "int countTokens(){\r\n    int count = 0;\r\n    boolean inToken = false;\r\n    for (int i = position, length = string.length(); i < length; i++) {\r\n        if (delimiters.indexOf(string.charAt(i), 0) >= 0) {\r\n            if (returnDelimiters)\r\n                count++;\r\n            if (inToken) {\r\n                count++;\r\n                inToken = false;\r\n            }\r\n        } else {\r\n            inToken = true;\r\n        }\r\n    }\r\n    if (inToken)\r\n        count++;\r\n    return count;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.pointerHover",
	"Comment": "pushes a pointer hover event with the given coordinates into codename one",
	"Method": "void pointerHover(int[] x,int[] y){\r\n    if (impl.getCurrentForm() == null) {\r\n        return;\r\n    }\r\n    if (x.length == 1) {\r\n        addPointerEventWithTimestamp(POINTER_HOVER, x[0], y[0]);\r\n    } else {\r\n        addPointerEvent(POINTER_HOVER, x, y);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.isTopOnlyMode",
	"Comment": "special mode where only the top of the round rectangle is rounded and the bottom is a regular rectangle",
	"Method": "boolean isTopOnlyMode(){\r\n    return topLeft && topRight && (!bottomLeft) && (!bottomRight);\r\n}"
}, {
	"Path": "com.codename1.ui.List.getSelectedItem",
	"Comment": "returns the current selected item in the list or null for no selection",
	"Method": "T getSelectedItem(){\r\n    int idx = model.getSelectedIndex();\r\n    if (idx < model.getSize() && idx > -1) {\r\n        return model.getItemAt(idx);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.Picker.getTime",
	"Comment": "this value is only used for time type and is ignored in the case of date and time whereboth are embedded within the date.",
	"Method": "int getTime(){\r\n    return ((Integer) value).intValue();\r\n}"
}, {
	"Path": "org.conscrypt.OpenSSLKey.fromPrivateKeyPemInputStream",
	"Comment": "parse a private key in pem encoding from the provided input stream.",
	"Method": "OpenSSLKey fromPrivateKeyPemInputStream(InputStream is){\r\n    OpenSSLBIOInputStream bis = new OpenSSLBIOInputStream(is, true);\r\n    try {\r\n        long keyCtx = NativeCrypto.PEM_read_bio_PrivateKey(bis.getBioContext());\r\n        if (keyCtx == 0L) {\r\n            return null;\r\n        }\r\n        return new OpenSSLKey(keyCtx);\r\n    } catch (Exception e) {\r\n        throw new InvalidKeyException(e);\r\n    } finally {\r\n        bis.release();\r\n    }\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.Thumbnails.fromFilenames",
	"Comment": "indicate to make thumbnails for images with the specified filenames.",
	"Method": "Builder<File> fromFilenames(Iterable<String> files){\r\n    checkForNull(files, \"Cannot specify null for input files.\");\r\n    checkForEmpty(files, \"Cannot specify an empty collection for input files.\");\r\n    return Builder.ofStrings(files);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.PlatformDefaults.getLogicalPixelBase",
	"Comment": "what base value should be used to calculate logical pixel sizes.",
	"Method": "int getLogicalPixelBase(){\r\n    return LP_BASE;\r\n}"
}, {
	"Path": "com.codename1.impl.android.AndroidImplementation.getServiceProperties",
	"Comment": "gets the service properties.will read properties from file so thatthey are available even if cn1 is not initialized.",
	"Method": "Map<String, String> getServiceProperties(Context a){\r\n    if (serviceProperties == null) {\r\n        InputStream i = null;\r\n        try {\r\n            serviceProperties = new HashMap<String, String>();\r\n            i = a.openFileInput(\"CN1$AndroidServiceProperties\");\r\n            if (i == null) {\r\n                return serviceProperties;\r\n            }\r\n            DataInputStream is = new DataInputStream(i);\r\n            int count = is.readInt();\r\n            for (int idx = 0; idx < count; idx++) {\r\n                String key = is.readUTF();\r\n                String value = is.readUTF();\r\n                serviceProperties.put(key, value);\r\n            }\r\n        } catch (IOException ex) {\r\n            Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n        } finally {\r\n            try {\r\n                if (i != null)\r\n                    i.close();\r\n            } catch (Throwable ex) {\r\n                Logger.getLogger(AndroidImplementation.class.getName()).log(Level.SEVERE, null, ex);\r\n            }\r\n        }\r\n    }\r\n    return serviceProperties;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.addRequestHeaderDontRepleace",
	"Comment": "adds the given header to the request that will be sent unless the headeris already set to something else",
	"Method": "void addRequestHeaderDontRepleace(String key,String value){\r\n    if (userHeaders == null) {\r\n        userHeaders = new Hashtable();\r\n    }\r\n    if (!userHeaders.containsKey(key)) {\r\n        userHeaders.put(key, value);\r\n    }\r\n}"
}, {
	"Path": "android.support.v4.content.CursorLoader.onStartLoading",
	"Comment": "starts an asynchronous load of the contacts list data. when the result is ready the callbackswill be called on the ui thread. if a previous load has been completed and is still validthe result may be passed to the callbacks immediately.must be called from the ui thread",
	"Method": "void onStartLoading(){\r\n    if (mCursor != null) {\r\n        deliverResult(mCursor);\r\n    }\r\n    if (takeContentChanged() || mCursor == null) {\r\n        forceLoad();\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.snapshot.SnapshotFile.isSnapshotFile",
	"Comment": "returns a boolean value indicating whether the given file appears to be a parsable snapshot file.",
	"Method": "boolean isSnapshotFile(String name,File file){\r\n    Assert.notNull(name, \"name\");\r\n    Assert.notNull(file, \"file\");\r\n    String fileName = file.getName();\r\n    if (fileName.lastIndexOf(EXTENSION_SEPARATOR) == -1 || fileName.lastIndexOf(PART_SEPARATOR) == -1 || fileName.lastIndexOf(EXTENSION_SEPARATOR) < fileName.lastIndexOf(PART_SEPARATOR) || !fileName.endsWith(EXTENSION))\r\n        return false;\r\n    for (int i = fileName.lastIndexOf(PART_SEPARATOR) + 1; i < fileName.lastIndexOf(EXTENSION_SEPARATOR); i++) {\r\n        if (!Character.isDigit(fileName.charAt(i))) {\r\n            return false;\r\n        }\r\n    }\r\n    if (fileName.lastIndexOf(PART_SEPARATOR, fileName.lastIndexOf(PART_SEPARATOR) - 1) == -1)\r\n        return false;\r\n    for (int i = fileName.lastIndexOf(PART_SEPARATOR, fileName.lastIndexOf(PART_SEPARATOR) - 1) + 1; i < fileName.lastIndexOf(PART_SEPARATOR); i++) {\r\n        if (!Character.isDigit(fileName.charAt(i))) {\r\n            return false;\r\n        }\r\n    }\r\n    return fileName.substring(0, fileName.lastIndexOf(PART_SEPARATOR, fileName.lastIndexOf(PART_SEPARATOR) - 1)).equals(name);\r\n}"
}, {
	"Path": "java.text.SimpleDateFormat.getDSTOffset",
	"Comment": "determine the number of minutes to adjust the date for local dst. this\tshould provide a historically correct value, also accounting for changes\tin gmt offset. see timezone javadoc for more details.",
	"Method": "int getDSTOffset(Calendar source){\r\n    TimeZone localTimezone = Calendar.getInstance().getTimeZone();\r\n    int rawOffset = localTimezone.getRawOffset() / MILLIS_TO_MINUTES;\r\n    return getOffsetInMinutes(source, localTimezone) - rawOffset;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GroupLayout.getHorizontalGroup",
	"Comment": "returns the group that is responsible forlayout along the horizontal axis.",
	"Method": "Group getHorizontalGroup(){\r\n    int index = 0;\r\n    if (horizontalGroup.springs.size() > 1) {\r\n        index = 1;\r\n    }\r\n    return (Group) horizontalGroup.springs.get(index);\r\n}"
}, {
	"Path": "com.codename1.ui.util.Resources.override",
	"Comment": "this method allows overriding the data of a resource file with another resource file thus replacingor enhancing existing content with platform specific content. e.g. default icons for the applicationcan be overriden on a specific platform",
	"Method": "void override(InputStream input){\r\n    openFileImpl(input);\r\n}"
}, {
	"Path": "mondrian.olap.Util.readVirtualFile",
	"Comment": "gets content via apache vfs. file must exist and have content",
	"Method": "InputStream readVirtualFile(String url){\r\n    FileSystemManager fsManager = VFS.getManager();\r\n    if (fsManager == null) {\r\n        throw newError(\"Cannot get virtual file system manager\");\r\n    }\r\n    if (url.startsWith(\"file://localhost\")) {\r\n        url = url.substring(\"file://localhost\".length());\r\n    }\r\n    if (url.startsWith(\"file:\")) {\r\n        url = url.substring(\"file:\".length());\r\n    }\r\n    if (url.startsWith(\"http\")) {\r\n        try {\r\n            return new URL(url).openStream();\r\n        } catch (IOException e) {\r\n            throw newError(\"Could not read URL: \" + url);\r\n        }\r\n    }\r\n    File userDir = new File(\"\").getAbsoluteFile();\r\n    FileObject file = fsManager.resolveFile(userDir, url);\r\n    FileContent fileContent = null;\r\n    try {\r\n        file.refresh();\r\n        if (file instanceof HttpFileObject && !file.getName().getURI().equals(url)) {\r\n            fsManager.getFilesCache().removeFile(file.getFileSystem(), file.getName());\r\n            file = fsManager.resolveFile(userDir, url);\r\n        }\r\n        if (!file.isReadable()) {\r\n            throw newError(\"Virtual file is not readable: \" + url);\r\n        }\r\n        fileContent = file.getContent();\r\n    } finally {\r\n        file.close();\r\n    }\r\n    if (fileContent == null) {\r\n        throw newError(\"Cannot get virtual file content: \" + url);\r\n    }\r\n    return fileContent.getInputStream();\r\n}"
}, {
	"Path": "com.codename1.impl.android.IntentIntegrator.startActivityForResult",
	"Comment": "start an activity. this method is defined to allow different methodsof activity starting for newer versions of android and for compatibilitylibrary.",
	"Method": "void startActivityForResult(Intent intent,int code){\r\n    activity.startActivityForResult(intent, code);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getUIID",
	"Comment": "unique identifier for a component.this id is used to retrieve a suitable style.",
	"Method": "String getUIID(){\r\n    if (landscapeUiid != null) {\r\n        if (Display.impl.isPortrait()) {\r\n            return portraitUiid;\r\n        }\r\n        return landscapeUiid;\r\n    }\r\n    return portraitUiid;\r\n}"
}, {
	"Path": "mondrian.olap.Util.getMatchingCause",
	"Comment": "if one of the causes of an exception is of a particular class, returnsthat cause. otherwise returns null.",
	"Method": "T getMatchingCause(Throwable e,Class<T> clazz){\r\n    for (; ; ) {\r\n        if (clazz.isInstance(e)) {\r\n            return clazz.cast(e);\r\n        }\r\n        final Throwable cause = e.getCause();\r\n        if (cause == null || cause == e) {\r\n            return null;\r\n        }\r\n        e = cause;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.setPopupDirectionBiasPortrait",
	"Comment": "indicates if we want to enforce directional bias for the popup dialog. if null this field is ignored but ifits set to a value it biases the system towards a fixed direction for the popup dialog.",
	"Method": "void setPopupDirectionBiasPortrait(Boolean popupDirectionBiasPortrait){\r\n    this.popupDirectionBiasPortrait = popupDirectionBiasPortrait;\r\n}"
}, {
	"Path": "com.codename1.ui.EncodedImage.resetCache",
	"Comment": "a subclass might choose to load asynchroniously and reset the cache when the image is ready.",
	"Method": "void resetCache(){\r\n    cache = null;\r\n    hardCache = null;\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testEventsAfterFollowerKill",
	"Comment": "tests submitting a sequential event that publishes to all sessions.",
	"Method": "void testEventsAfterFollowerKill(int nodes){\r\n    List<CopycatServer> servers = createServers(nodes);\r\n    CopycatClient client = createClient();\r\n    client.onEvent(\"test\", message -> {\r\n        threadAssertNotNull(message);\r\n        resume();\r\n    });\r\n    for (int i = 0; i < 10; i++) {\r\n        client.submit(new TestEvent(true)).thenAccept(result -> {\r\n            threadAssertNotNull(result);\r\n            resume();\r\n        });\r\n        await(30000, 2);\r\n    }\r\n    client.submit(new TestEvent(true)).thenAccept(result -> {\r\n        threadAssertNotNull(result);\r\n        resume();\r\n    });\r\n    CopycatServer follower = servers.stream().filter(s -> s.state() == CopycatServer.State.FOLLOWER).findFirst().get();\r\n    follower.shutdown().get(10, TimeUnit.SECONDS);\r\n    await(30000, 2);\r\n    for (int i = 0; i < 10; i++) {\r\n        client.submit(new TestEvent(true)).thenAccept(result -> {\r\n            threadAssertNotNull(result);\r\n            resume();\r\n        });\r\n        await(30000, 2);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getInlineSelectedStyles",
	"Comment": "gets inline styles that are to be applied to the selected state of this component.",
	"Method": "String getInlineSelectedStyles(){\r\n    return this.inlineSelectedStyles;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.isHidden",
	"Comment": "returns true if the component was explicitly hidden by the user",
	"Method": "boolean isHidden(){\r\n    return sizeRequestedByUser && preferredSize != null && preferredSize.getWidth() == 0 && preferredSize.getHeight() == 0;\r\n}"
}, {
	"Path": "java.util.Collections.max",
	"Comment": "searches the specified collection for the maximum element using thespecified comparator.",
	"Method": "T max(Collection<? extends T> collection,T max,Collection<? extends T> collection,Comparator<? super T> comparator){\r\n    if (comparator == null) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        T result = (T) max((Collection<java.lang.Comparable>) collection);\r\n        return result;\r\n    }\r\n    Iterator<? extends T> it = collection.iterator();\r\n    T max = it.next();\r\n    while (it.hasNext()) {\r\n        T next = it.next();\r\n        if (comparator.compare(max, next) < 0) {\r\n            max = next;\r\n        }\r\n    }\r\n    return max;\r\n}"
}, {
	"Path": "android.support.v4.text.BidiFormatter.getInstance",
	"Comment": "factory for creating an instance of bidiformatter given the context locale.",
	"Method": "BidiFormatter getInstance(BidiFormatter getInstance,boolean rtlContext,BidiFormatter getInstance,Locale locale){\r\n    return new Builder(locale).build();\r\n}"
}, {
	"Path": "com.codename1.components.SpanLabel.getTextBlockAlign",
	"Comment": "returns the alignment of the whole text block and not the text within it!",
	"Method": "int getTextBlockAlign(){\r\n    if (text.getParent() == this) {\r\n        return -1;\r\n    }\r\n    return ((FlowLayout) text.getParent().getLayout()).getAlign();\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.getDestinationFile",
	"Comment": "when set to a none null string saves the response to file system underthis file name",
	"Method": "String getDestinationFile(){\r\n    return destinationFile;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.slideUpAndWait",
	"Comment": "hide the matched elements with a sliding motion.blocks until animation is complete.",
	"Method": "ComponentSelector slideUpAndWait(int duration){\r\n    for (Component c : this) {\r\n        c.setHeight(0);\r\n    }\r\n    getParent().animateUnlayoutAndWait(duration, 255);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.addOrientationListener",
	"Comment": "this listener is invoked when device orientation changes on devices that support orientation change",
	"Method": "void addOrientationListener(ActionListener l){\r\n    if (orientationListener == null) {\r\n        orientationListener = new EventDispatcher();\r\n    }\r\n    orientationListener.addListener(l);\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.setWidestChar",
	"Comment": "indicates the widest character in the alphabet, this is useful for detectinglinebreaks internally. in cjk languages the widest char is different than whence this functionality is exposed to developers.",
	"Method": "void setWidestChar(char widestC){\r\n    widestChar = widestC;\r\n}"
}, {
	"Path": "com.codename1.impl.midp.GameCanvasImplementation.createMedia",
	"Comment": "plays the sound in the given uri which is partially platform specific.",
	"Method": "Media createMedia(String uri,boolean isVideo,Runnable onCompletion,Media createMedia,InputStream stream,String mimeType,Runnable onCompletion){\r\n    MMAPIPlayer player = MMAPIPlayer.createPlayer(stream, mimeType, onCompletion);\r\n    if (mimeType.indexOf(\"video\") > -1) {\r\n        return new MIDPVideoComponent(player, canvas);\r\n    }\r\n    return player;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.setMenuCellRenderer",
	"Comment": "determine the cell renderer used to render menu elements for themeing the look of the menu options",
	"Method": "void setMenuCellRenderer(ListCellRenderer menuCellRenderer){\r\n    menuBar.setMenuCellRenderer(menuCellRenderer);\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.setDestinationFile",
	"Comment": "when set to a none null string saves the response to file system underthis file name",
	"Method": "void setDestinationFile(String destinationFile){\r\n    this.destinationFile = destinationFile;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Motion.createFrictionMotion",
	"Comment": "creates a friction motion starting from source with initial speed and the friction",
	"Method": "Motion createFrictionMotion(int sourceValue,int maxValue,float initVelocity,float friction){\r\n    Motion frictionMotion = new Motion(sourceValue, initVelocity, friction);\r\n    frictionMotion.destinationValue = maxValue;\r\n    frictionMotion.motionType = FRICTION;\r\n    return frictionMotion;\r\n}"
}, {
	"Path": "com.codename1.testing.TestUtils.assertTextAreaContaining",
	"Comment": "asserts that we have a textarea with the a text contains the given text and with the given name",
	"Method": "void assertTextAreaContaining(String name,String text){\r\n    if (verbose) {\r\n        log(\"assertTextAreaContaining(\" + name + \", \" + text + \")\");\r\n    }\r\n    TextArea l = (TextArea) findByName(name);\r\n    assertBool(l != null, \"Null area \" + text);\r\n    assertBool(l.getText().indexOf(text) > -1, \"assertTextArea: \\\"\" + l.getText() + \"\\\" is not containing: \\\"\" + text + \"\\\"\");\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.wasDisposedDueToRotation",
	"Comment": "returns true if the dialog was disposed automatically due to device rotation",
	"Method": "boolean wasDisposedDueToRotation(){\r\n    return disposedDueToRotation;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.addCmp",
	"Comment": "adds the given component to the curline container after performing size checks",
	"Method": "void addCmp(Component cmp,int align){\r\n    if (cmp != null) {\r\n        if ((FIXED_WIDTH) && (x + cmp.getPreferredW() > width)) {\r\n            newLine(align);\r\n        }\r\n        curLine.addComponent(cmp);\r\n        x += cmp.getPreferredW();\r\n    }\r\n}"
}, {
	"Path": "org.conscrypt.ConscryptFileDescriptorSocket.getSoWriteTimeout",
	"Comment": "note write timeouts are not part of the javax.net.ssl.sslsocket api",
	"Method": "int getSoWriteTimeout(){\r\n    return writeTimeoutMilliseconds;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.clearImageBorderSpecialTile",
	"Comment": "cleans the tile tracking state allowing the garbage collector to pick up the component and the image data",
	"Method": "void clearImageBorderSpecialTile(){\r\n    specialTile = null;\r\n    trackComponent = null;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.setReadResponseForErrors",
	"Comment": "when set to true the read response code will happen even for error codes such as 400 and 500",
	"Method": "void setReadResponseForErrors(boolean readResponseForErrors){\r\n    this.readResponseForErrors = readResponseForErrors;\r\n}"
}, {
	"Path": "com.codename1.ui.scene.Node.getLocalToSceneTransform",
	"Comment": "gets the transform to use to go from the local coordinates to scene coordinates.",
	"Method": "Transform getLocalToSceneTransform(){\r\n    if (parent == null) {\r\n        return getLocalToParentTransform();\r\n    } else {\r\n        Transform t = parent.getLocalToSceneTransform();\r\n        t.concatenate(getLocalToParentTransform());\r\n        return t;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.list.DefaultListCellRenderer.setShowNumbers",
	"Comment": "indicate whether numbering should exist for the default cell renderer",
	"Method": "void setShowNumbers(boolean showNumbers){\r\n    this.showNumbers = showNumbers;\r\n    showNumbersForce = true;\r\n}"
}, {
	"Path": "java.util.AbstractMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the returned setdoes not support adding.",
	"Method": "Set<K> keySet(){\r\n    if (keySet == null) {\r\n        keySet = new AbstractSet<K>() {\r\n            @Override\r\n            public boolean contains(Object object) {\r\n                return containsKey(object);\r\n            }\r\n            @Override\r\n            public int size() {\r\n                return AbstractMap.this.size();\r\n            }\r\n            @Override\r\n            public Iterator<K> iterator() {\r\n                return new Iterator<K>() {\r\n                    Iterator<Map.Entry<K, V>> setIterator = entrySet().iterator();\r\n                    public boolean hasNext() {\r\n                        return setIterator.hasNext();\r\n                    }\r\n                    public K next() {\r\n                        return setIterator.next().getKey();\r\n                    }\r\n                    public void remove() {\r\n                        setIterator.remove();\r\n                    }\r\n                };\r\n            }\r\n        };\r\n    }\r\n    return keySet;\r\n}"
}, {
	"Path": "java.util.AbstractMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the returned setdoes not support adding.",
	"Method": "Set<K> keySet(){\r\n    return containsKey(object);\r\n}"
}, {
	"Path": "java.util.AbstractMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the returned setdoes not support adding.",
	"Method": "Set<K> keySet(){\r\n    return AbstractMap.this.size();\r\n}"
}, {
	"Path": "java.util.AbstractMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the returned setdoes not support adding.",
	"Method": "Set<K> keySet(){\r\n    return new Iterator<K>() {\r\n        Iterator<Map.Entry<K, V>> setIterator = entrySet().iterator();\r\n        public boolean hasNext() {\r\n            return setIterator.hasNext();\r\n        }\r\n        public K next() {\r\n            return setIterator.next().getKey();\r\n        }\r\n        public void remove() {\r\n            setIterator.remove();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "java.util.AbstractMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the returned setdoes not support adding.",
	"Method": "Set<K> keySet(){\r\n    return setIterator.hasNext();\r\n}"
}, {
	"Path": "java.util.AbstractMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the returned setdoes not support adding.",
	"Method": "Set<K> keySet(){\r\n    return setIterator.next().getKey();\r\n}"
}, {
	"Path": "java.util.AbstractMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the returned setdoes not support adding.",
	"Method": "Set<K> keySet(){\r\n    setIterator.remove();\r\n}"
}, {
	"Path": "org.conscrypt.ConscryptFileDescriptorSocket.setSoWriteTimeout",
	"Comment": "note write timeouts are not part of the javax.net.ssl.sslsocket api",
	"Method": "void setSoWriteTimeout(int writeTimeoutMilliseconds){\r\n    this.writeTimeoutMilliseconds = writeTimeoutMilliseconds;\r\n    Platform.setSocketWriteTimeout(this, writeTimeoutMilliseconds);\r\n}"
}, {
	"Path": "com.codename1.ui.Image.subImage",
	"Comment": "extracts a subimage from the given image allowing us to breakdown a single large imageinto multiple smaller images in ram, this actually creates a standalone versionof the image for use.",
	"Method": "Image subImage(int x,int y,int width,int height,boolean processAlpha){\r\n    int[] arr = new int[width * height];\r\n    getRGB(arr, 0, x, y, width, height);\r\n    Image i = new Image(Display.impl.createImage(arr, width, height));\r\n    i.opaque = opaque;\r\n    i.opaqueTested = opaqueTested;\r\n    return i;\r\n}"
}, {
	"Path": "org.conscrypt.SSLParametersImpl.getEnableSessionCreation",
	"Comment": "returns the value indicating if the peer with this parametersallowed to cteate new ssl session",
	"Method": "boolean getEnableSessionCreation(){\r\n    return enable_session_creation;\r\n}"
}, {
	"Path": "com.codename1.ui.Button.setRolloverPressedIcon",
	"Comment": "indicates the icon that is displayed on the button when the button is inpressed state and is selected. this is only applicable to toggle buttons",
	"Method": "void setRolloverPressedIcon(Image rolloverPressedIcon){\r\n    this.rolloverPressedIcon = rolloverPressedIcon;\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.newEvalException",
	"Comment": "creates an exception which indicates that an error has occurred whileexecuting a given function.",
	"Method": "RuntimeException newEvalException(FunDef funDef,String message,RuntimeException newEvalException,Throwable throwable,RuntimeException newEvalException,String message,Throwable throwable){\r\n    return new MondrianEvaluationException(message + \": \" + Util.getErrorMessage(throwable));\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setShouldCalcPreferredSize",
	"Comment": "indicates the values within the component have changed and preferred size should be recalculated",
	"Method": "void setShouldCalcPreferredSize(boolean shouldCalcPreferredSize){\r\n    if (!shouldCalcScrollSize) {\r\n        this.shouldCalcScrollSize = shouldCalcPreferredSize;\r\n    }\r\n    if (shouldCalcPreferredSize != this.shouldCalcPreferredSize) {\r\n        this.shouldCalcPreferredSize = shouldCalcPreferredSize;\r\n        this.shouldCalcScrollSize = shouldCalcPreferredSize;\r\n        if (shouldCalcPreferredSize && getParent() != null) {\r\n            this.shouldCalcPreferredSize = shouldCalcPreferredSize;\r\n            getParent().setShouldLayout(shouldCalcPreferredSize);\r\n        }\r\n    }\r\n    if (shouldCalcPreferredSize) {\r\n        setShouldCalcPreferredSizeGroup(sameWidth);\r\n        setShouldCalcPreferredSizeGroup(sameHeight);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.ServerStateMachine.sequenceCommand",
	"Comment": "sequences a command according to the command sequence number.",
	"Method": "void sequenceCommand(long sequence,ServerSessionContext session,CompletableFuture<Result> future,ThreadContext context){\r\n    if (!log.isOpen()) {\r\n        context.executor().execute(() -> future.completeExceptionally(new IllegalStateException(\"log closed\")));\r\n        return;\r\n    }\r\n    Result result = session.getResult(sequence);\r\n    if (result == null) {\r\n        LOGGER.debug(\"Missing command result for {}:{}\", session.id(), sequence);\r\n    }\r\n    context.executor().execute(() -> future.complete(result));\r\n}"
}, {
	"Path": "com.codename1.ui.Form.getTintColor",
	"Comment": "default color for the screen tint when a dialog or a menu is shown",
	"Method": "int getTintColor(){\r\n    return tintColor;\r\n}"
}, {
	"Path": "java.util.TreeMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(Set<K> keySet,Set<K> keySet){\r\n    if (keySet == null) {\r\n        keySet = new AbstractSet<K>() {\r\n            @Override\r\n            public boolean contains(Object object) {\r\n                return containsKey(object);\r\n            }\r\n            @Override\r\n            public int size() {\r\n                return size;\r\n            }\r\n            @Override\r\n            public void clear() {\r\n                TreeMap.this.clear();\r\n            }\r\n            @Override\r\n            public Iterator<K> iterator() {\r\n                return new UnboundedKeyIterator<K, V>(TreeMap.this);\r\n            }\r\n        };\r\n    }\r\n    return keySet;\r\n}"
}, {
	"Path": "java.util.TreeMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(Set<K> keySet,Set<K> keySet){\r\n    return containsKey(object);\r\n}"
}, {
	"Path": "java.util.TreeMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(Set<K> keySet,Set<K> keySet){\r\n    return size;\r\n}"
}, {
	"Path": "java.util.TreeMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(Set<K> keySet,Set<K> keySet){\r\n    TreeMap.this.clear();\r\n}"
}, {
	"Path": "java.util.TreeMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(Set<K> keySet,Set<K> keySet){\r\n    return new UnboundedKeyIterator<K, V>(TreeMap.this);\r\n}"
}, {
	"Path": "org.conscrypt.OpenSSLCipher.getPadding",
	"Comment": "returns the padding type for which this cipher is initialized.",
	"Method": "Padding getPadding(){\r\n    return padding;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.compaction.MajorCompactionTask.copyPredicates",
	"Comment": "creates a copy of offset predicates prior to compacting segments to prevent race conditions.",
	"Method": "void copyPredicates(){\r\n    predicates = new ArrayList(groups.size());\r\n    for (List<Segment> group : groups) {\r\n        List<OffsetPredicate> groupPredicates = new ArrayList(group.size());\r\n        for (Segment segment : group) {\r\n            groupPredicates.add(segment.offsetPredicate().copy());\r\n        }\r\n        predicates.add(groupPredicates);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.setVisualPadding",
	"Comment": "sets the visual padding used when laying out this component.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "void setVisualPadding(UnitValue[] sides){\r\n    this.visualPadding = sides != null ? new UnitValue[] { sides[0], sides[1], sides[2], sides[3] } : null;\r\n}"
}, {
	"Path": "com.codename1.properties.SetProperty.addAll",
	"Comment": "adds a collection of values to the set and fires a change event if it changed the set",
	"Method": "K addAll(Collection<? extends T> v){\r\n    if (value.addAll(v)) {\r\n        firePropertyChanged();\r\n    }\r\n    return (K) parent.parent;\r\n}"
}, {
	"Path": "com.codename1.ui.List.getListSizeCalculationSampleCount",
	"Comment": "indicates the number of elements the list should check to determine the elementsizes. this is ignored when a rendering prototype is present.",
	"Method": "int getListSizeCalculationSampleCount(){\r\n    return listSizeCalculationSampleCount;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.setProperty",
	"Comment": "sets a local property to the application, this method has no effect on theimplementation code and only allows the user to override the logic of getpropertyfor internal application purposes.",
	"Method": "void setProperty(String key,String value){\r\n    if (\"AppArg\".equals(key)) {\r\n        impl.setAppArg(value);\r\n        return;\r\n    }\r\n    if (\"blockOverdraw\".equals(key)) {\r\n        Container.blockOverdraw = true;\r\n        return;\r\n    }\r\n    if (\"blockCopyPaste\".equals(key)) {\r\n        impl.blockCopyPaste(\"true\".equals(value));\r\n    }\r\n    if (key.startsWith(\"platformHint.\")) {\r\n        impl.setPlatformHint(key, value);\r\n        return;\r\n    }\r\n    if (localProperties == null) {\r\n        localProperties = new HashMap<String, String>();\r\n    }\r\n    if (value == null) {\r\n        localProperties.remove(key);\r\n    } else {\r\n        localProperties.put(key, value);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.test.FuzzTest.scheduleRestart",
	"Comment": "schedules the given server to be shutdown for a period of time and then restarted.",
	"Method": "void scheduleRestart(boolean remove,int serverIndex,ThreadContext context){\r\n    shutdownTimers.put(serverIndex, context.schedule(Duration.ofSeconds(randomNumber(120) + 10), () -> {\r\n        shutdownTimers.remove(serverIndex);\r\n        CopycatServer server = servers.get(serverIndex);\r\n        CompletableFuture<Void> leaveFuture;\r\n        if (remove) {\r\n            System.out.println(\"Removing server: \" + server.cluster().member().address());\r\n            leaveFuture = server.leave();\r\n        } else {\r\n            System.out.println(\"Shutting down server: \" + server.cluster().member().address());\r\n            leaveFuture = server.shutdown();\r\n        }\r\n        leaveFuture.whenComplete((result, error) -> {\r\n            restartTimers.put(serverIndex, context.schedule(Duration.ofSeconds(randomNumber(120) + 10), () -> {\r\n                restartTimers.remove(serverIndex);\r\n                CopycatServer newServer = createServer(server.cluster().member());\r\n                servers.set(serverIndex, newServer);\r\n                CompletableFuture<CopycatServer> joinFuture;\r\n                if (remove) {\r\n                    System.out.println(\"Adding server: \" + newServer.cluster().member().address());\r\n                    joinFuture = newServer.join(members.get(members.size() - 1).address());\r\n                } else {\r\n                    System.out.println(\"Bootstrapping server: \" + newServer.cluster().member().address());\r\n                    joinFuture = newServer.bootstrap(members.stream().map(Member::serverAddress).collect(Collectors.toList()));\r\n                }\r\n                joinFuture.whenComplete((result2, error2) -> {\r\n                    scheduleRestarts(context);\r\n                });\r\n            }));\r\n        });\r\n    }));\r\n}"
}, {
	"Path": "mondrian.olap.Util.getErrorMessage",
	"Comment": "constructs the message associated with an arbitrary java error, makingup one based on the stack trace if there is none.",
	"Method": "String getErrorMessage(Throwable err,String getErrorMessage,Throwable err,boolean prependClassName){\r\n    String errMsg = err.getMessage();\r\n    if ((errMsg == null) || (err instanceof RuntimeException)) {\r\n        StringWriter sw = new StringWriter();\r\n        PrintWriter pw = new PrintWriter(sw);\r\n        err.printStackTrace(pw);\r\n        return sw.toString();\r\n    } else {\r\n        return (prependClassName) ? err.getClass().getName() + \": \" + errMsg : errMsg;\r\n    }\r\n}"
}, {
	"Path": "android.support.v4.widget.CursorAdapter.changeCursor",
	"Comment": "change the underlying cursor to a new cursor. if there is an existing cursor it will beclosed.",
	"Method": "void changeCursor(Cursor cursor){\r\n    Cursor old = swapCursor(cursor);\r\n    if (old != null) {\r\n        old.close();\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.StringTokenizer.countTokens",
	"Comment": "returns the number of unprocessed tokens remaining in the string.",
	"Method": "int countTokens(){\r\n    int count = 0;\r\n    boolean inToken = false;\r\n    for (int i = position, length = string.length(); i < length; i++) {\r\n        if (delimiters.indexOf(string.charAt(i), 0) >= 0) {\r\n            if (returnDelimiters)\r\n                count++;\r\n            if (inToken) {\r\n                count++;\r\n                inToken = false;\r\n            }\r\n        } else {\r\n            inToken = true;\r\n        }\r\n    }\r\n    if (inToken)\r\n        count++;\r\n    return count;\r\n}"
}, {
	"Path": "com.codename1.properties.SQLMap.update",
	"Comment": "the equivalent of an sql update assumes that the object is already in the database",
	"Method": "void update(PropertyBusinessObject cmp){\r\n    String pkName = (String) cmp.getPropertyIndex().getMetaDataOfClass(\"cn1$pk\");\r\n    if (pkName == null) {\r\n        throw new IOException(\"Primary key required for update\");\r\n    }\r\n    String tableName = getTableName(cmp);\r\n    StringBuilder createStatement = new StringBuilder(\"UPDATE \");\r\n    createStatement.append(tableName);\r\n    createStatement.append(\" SET \");\r\n    int count = 0;\r\n    ArrayList<Object> values = new ArrayList<Object>();\r\n    for (PropertyBase p : cmp.getPropertyIndex()) {\r\n        SqlType tp = getSqlType(p);\r\n        if (tp == SqlType.SQL_EXCLUDE) {\r\n            continue;\r\n        }\r\n        if (count > 0) {\r\n            createStatement.append(\",\");\r\n        }\r\n        if (p instanceof Property) {\r\n            values.add(tp.asUpdateInsertValue(((Property) p).get(), (Property) p));\r\n        } else {\r\n            values.add(null);\r\n        }\r\n        count++;\r\n        String columnName = getColumnName(p);\r\n        createStatement.append(columnName);\r\n        createStatement.append(\" = ?\");\r\n    }\r\n    createStatement.append(\" WHERE \");\r\n    createStatement.append(pkName);\r\n    createStatement.append(\" = ?\");\r\n    Property p = (Property) cmp.getPropertyIndex().getIgnoreCase(pkName);\r\n    values.add(p.get());\r\n    execute(createStatement.toString(), values.toArray());\r\n}"
}, {
	"Path": "com.codename1.ui.PeerComponent.shouldRenderPeerImage",
	"Comment": "subclasses should return true here if the peer image should be rendered instead of the actual peer",
	"Method": "boolean shouldRenderPeerImage(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.fadeInAndWait",
	"Comment": "fades in this component and blocks until animation is complete.",
	"Method": "ComponentSelector fadeInAndWait(ComponentSelector fadeInAndWait,int duration){\r\n    final String placeholderProperty = \"com.codename1.ui.ComponentSelector#fadeOutPlaceholder\";\r\n    AnimationManager mgr = null;\r\n    ArrayList<ComponentAnimation> animations1 = new ArrayList<ComponentAnimation>();\r\n    final ArrayList<ComponentAnimation> animations2 = new ArrayList<ComponentAnimation>();\r\n    final ArrayList<Component> animatingComponents = new ArrayList<Component>();\r\n    for (Component c : this) {\r\n        Container parent = c.getParent();\r\n        if (parent != null) {\r\n            AnimationManager cmgr = c.getAnimationManager();\r\n            if (cmgr != null) {\r\n                mgr = cmgr;\r\n                Container placeholder = new Container();\r\n                c.putClientProperty(placeholderProperty, placeholder);\r\n                Component.setSameHeight(placeholder, c);\r\n                Component.setSameWidth(placeholder, c);\r\n                $(placeholder).setMargin(c.getStyle().getMarginTop(), c.getStyle().getMarginRight(false), c.getStyle().getMarginBottom(), c.getStyle().getMarginLeft(false)).setPadding(c.getStyle().getPaddingTop(), c.getStyle().getPaddingRight(false), c.getStyle().getPaddingBottom(), c.getStyle().getPaddingLeft(false));\r\n                ComponentAnimation a = parent.createReplaceTransition(c, placeholder, CommonTransitions.createEmpty());\r\n                animations1.add(a);\r\n                animatingComponents.add(c);\r\n            }\r\n        }\r\n    }\r\n    if (mgr != null) {\r\n        mgr.addAnimationAndBlock(ComponentAnimation.compoundAnimation(animations1.toArray(new ComponentAnimation[animations1.size()])));\r\n        for (final Component c : animatingComponents) {\r\n            Container placeholder = (Container) c.getClientProperty(placeholderProperty);\r\n            if (placeholder != null) {\r\n                c.putClientProperty(placeholderProperty, null);\r\n                AnimationManager cmgr = placeholder.getAnimationManager();\r\n                if (cmgr != null) {\r\n                    mgr = cmgr;\r\n                    c.setVisible(true);\r\n                    Container parent = placeholder.getParent();\r\n                    if (parent != null) {\r\n                        ComponentAnimation a = parent.createReplaceTransition(placeholder, c, CommonTransitions.createFade(duration));\r\n                        animations2.add(a);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (mgr != null) {\r\n            mgr.addAnimationAndBlock(ComponentAnimation.compoundAnimation(animations2.toArray(new ComponentAnimation[animations2.size()])));\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.Graphics.drawChar",
	"Comment": "draw the given char using the current font and color in the x,y coordinates. the font is drawn from the top position and not the baseline.",
	"Method": "void drawChar(char character,int x,int y){\r\n    drawString(\"\" + character, x, y);\r\n}"
}, {
	"Path": "com.googlecode.cqengine.index.sqlite.SQLiteIdentityIndex.getAttribute",
	"Comment": "returns the attribute which given an object can read its primary key.",
	"Method": "Attribute<O, A> getAttribute(){\r\n    return sqLiteIndex.getAttribute();\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Transition.copy",
	"Comment": "create a copy of the transition, usually the transition used is a copy.",
	"Method": "Transition copy(boolean reverse){\r\n    return this;\r\n}"
}, {
	"Path": "android.support.v4.view.PagerAdapter.getPageTitle",
	"Comment": "this method may be called by the viewpager to obtain a title stringto describe the specified page. this method may return nullindicating no title for this page. the default implementation returnsnull.",
	"Method": "CharSequence getPageTitle(int position){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.components.ToastBar.showMessage",
	"Comment": "simplifies a common use case of showing an error message with an error icon that fades out after a few seconds",
	"Method": "Status showMessage(String msg,char icon,int timeout,ActionListener listener,Status showMessage,String msg,char icon,int timeout,Status showMessage,String msg,char icon,ActionListener listener,Status showMessage,String msg,char icon){\r\n    return showMessage(msg, icon, defaultMessageTimeout);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLElement.addAssociatedComponentAt",
	"Comment": "adds the given component to be associated with this element.this is used internally to apply css styling.",
	"Method": "void addAssociatedComponentAt(int index,Component cmp){\r\n    if (comps == null) {\r\n        comps = new Vector();\r\n    }\r\n    comps.insertElementAt(cmp, index);\r\n}"
}, {
	"Path": "io.prometheus.client.guava.cache.CacheMetricsCollector.addCache",
	"Comment": "add or replace the cache with the given name.any references any previous cache with this name is invalidated.",
	"Method": "void addCache(String cacheName,Cache cache){\r\n    children.put(cacheName, cache);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.getDefaultMenuTransitionOut",
	"Comment": "allows us to define a default animation that will draw the transition forexiting a menu",
	"Method": "Transition getDefaultMenuTransitionOut(){\r\n    return defaultMenuTransitionOut;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isGetAllContactsFast",
	"Comment": "indicates if the getallcontacts is platform optimized, notice that the methodmight still take seconds or more to run so you should still use a separate thread!",
	"Method": "boolean isGetAllContactsFast(){\r\n    return false;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.codegen.AttributeBytecodeGenerator.generateSimpleAttribute",
	"Comment": "helper method for generating simpleattribute and simplenullableattribute.",
	"Method": "R generateSimpleAttribute(Class<C> attributeSuperClass,Class<O> pojoClass,Class<A> attributeValueType,String attributeName,String target){\r\n    try {\r\n        ClassPool pool = new ClassPool(false);\r\n        pool.appendClassPath(new ClassClassPath(pojoClass));\r\n        CtClass attributeClass = pool.makeClass(pojoClass.getName() + \"$$CQEngine_\" + attributeSuperClass.getSimpleName() + \"_\" + attributeName);\r\n        attributeClass.setSuperclass(pool.get(attributeSuperClass.getName()));\r\n        SignatureAttribute.ClassType genericTypeOfAttribute = new SignatureAttribute.ClassType(attributeSuperClass.getName(), new SignatureAttribute.TypeArgument[] { new SignatureAttribute.TypeArgument(new SignatureAttribute.ClassType(pojoClass.getName())), new SignatureAttribute.TypeArgument(new SignatureAttribute.ClassType(attributeValueType.getName())) });\r\n        attributeClass.setGenericSignature(genericTypeOfAttribute.encode());\r\n        CtConstructor constructor = CtNewConstructor.make(\"public \" + attributeClass.getSimpleName() + \"() { \" + \"super(\\\"\" + attributeName + \"\\\");\" + \" }\", attributeClass);\r\n        attributeClass.addConstructor(constructor);\r\n        CtMethod getterMethod = CtMethod.make(\"public \" + attributeValueType.getName() + \" getValue(\" + pojoClass.getName() + \" object, \" + QueryOptions.class.getName() + \" queryOptions) { \" + \"return (\" + attributeValueType.getName() + \") \" + GeneratedAttributeSupport.class.getName() + \".valueOf(\" + target + \");\" + \" }\", attributeClass);\r\n        attributeClass.addMethod(getterMethod);\r\n        CtMethod getterBridgeMethod = CtMethod.make(\"public java.lang.Object getValue(java.lang.Object object, \" + QueryOptions.class.getName() + \" queryOptions) { \" + \"return getValue((\" + pojoClass.getName() + \")object, queryOptions);\" + \" }\", attributeClass);\r\n        getterBridgeMethod.setModifiers(getterBridgeMethod.getModifiers() | AccessFlag.BRIDGE);\r\n        attributeClass.addMethod(getterBridgeMethod);\r\n        @SuppressWarnings(\"unchecked\")\r\n        R result = (R) attributeClass.toClass(pojoClass.getClassLoader(), pojoClass.getProtectionDomain());\r\n        attributeClass.detach();\r\n        return result;\r\n    } catch (Exception e) {\r\n        throw new IllegalStateException(getExceptionMessage(pojoClass, attributeValueType, attributeName), e);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.BufferedInputStream.read1",
	"Comment": "read characters into a portion of an array, reading from the underlyingstream at most once if necessary.",
	"Method": "int read1(byte[] b,int off,int len){\r\n    int avail = count - pos;\r\n    if (avail <= 0) {\r\n        if (len >= getBufIfOpen().length && markpos < 0) {\r\n            int val = getInIfOpen().read(b, off, len);\r\n            if (val < 0) {\r\n                actualAvailable = -1;\r\n            } else {\r\n                if (printInput) {\r\n                    System.out.print(new String(b, off, val));\r\n                }\r\n            }\r\n            return val;\r\n        }\r\n        fill();\r\n        avail = count - pos;\r\n        if (avail <= 0) {\r\n            return -1;\r\n        }\r\n    }\r\n    int cnt = (avail < len) ? avail : len;\r\n    System.arraycopy(getBufIfOpen(), pos, b, off, cnt);\r\n    if (printInput) {\r\n        System.out.print(new String(b, off, cnt));\r\n    }\r\n    pos += cnt;\r\n    return cnt;\r\n}"
}, {
	"Path": "ly.count.android.sdk.messaging.Utils.reflectiveCallStrict",
	"Comment": "reflective method call encapsulation with argument types specified explicitly before each parameter.",
	"Method": "Object reflectiveCallStrict(String className,Object instance,String methodName,Object args){\r\n    return utils._reflectiveCallStrict(className, instance, methodName, args);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.minWidth",
	"Comment": "the minimum size for the component. the value will override any value that is set on the component itself.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC minWidth(String size){\r\n    hor.setSize(LayoutUtil.derive(hor.getSize(), ConstraintParser.parseUnitValue(size, true), null, null));\r\n    return this;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.ThumbnailParameter.fitWithinDimenions",
	"Comment": "returns whether or not to fit the thumbnail within the specified\tdimensions.",
	"Method": "boolean fitWithinDimenions(){\r\n    return fitWithinDimensions;\r\n}"
}, {
	"Path": "java.util.AbstractSet.removeAll",
	"Comment": "removes all occurrences in this collection which are contained in thespecified collection.",
	"Method": "boolean removeAll(Collection<?> collection){\r\n    boolean result = false;\r\n    if (size() <= collection.size()) {\r\n        Iterator<?> it = iterator();\r\n        while (it.hasNext()) {\r\n            if (collection.contains(it.next())) {\r\n                it.remove();\r\n                result = true;\r\n            }\r\n        }\r\n    } else {\r\n        Iterator<?> it = collection.iterator();\r\n        while (it.hasNext()) {\r\n            result = remove(it.next()) || result;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.transformTranslate",
	"Comment": "translates the transform by the specified amounts.with the specified translation.",
	"Method": "void transformTranslate(Object nativeTransform,float x,float y,float z){\r\n    Object tr = makeTransformTranslation(x, y, z);\r\n    concatenateTransform(nativeTransform, tr);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.DimConstraint.getShrinkPriority",
	"Comment": "returns the shrink priority. relative priority is used for determining which entities gets smaller first when space is scarce.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "int getShrinkPriority(){\r\n    return resize.shrinkPrio;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.animateHierarchyFadeAndWait",
	"Comment": "animates a pending hierarchy of components into place, this effectively replaces revalidate with a more visual form of animation. this method waits until the operation is completed before returning",
	"Method": "void animateHierarchyFadeAndWait(int duration,int startingOpacity){\r\n    animateHierarchy(duration, true, startingOpacity, true);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.paintBorderBackground",
	"Comment": "draws the component border background if such a border exists.",
	"Method": "void paintBorderBackground(Graphics g){\r\n    Border b = getBorder();\r\n    if (b != null) {\r\n        b.paintBorderBackground(g, this);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.BrowserComponent.isNativeScrollingEnabled",
	"Comment": "this method is unreliable and is only here for consistency with setnativescrollingenabled.",
	"Method": "boolean isNativeScrollingEnabled(){\r\n    return nativeScrolling;\r\n}"
}, {
	"Path": "com.codename1.ui.Tabs.selectTab",
	"Comment": "invoked to select a specific tab, this method should be overriden for subclasses overriding createtab",
	"Method": "void selectTab(Component tab){\r\n    Button b = (Button) tab;\r\n    b.fireClicked();\r\n    b.requestFocus();\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.LC.align",
	"Comment": "sets both the alignx and aligny as the same time.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "LC align(String ax,String ay){\r\n    if (ax != null)\r\n        alignX(ax);\r\n    if (ay != null)\r\n        alignY(ay);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.capture.Capture.capturePhoto",
	"Comment": "invokes the camera and takes a photo synchronously while blocking the edt, the sample belowdemonstrates a simple usage and applying a mask to the result",
	"Method": "void capturePhoto(ActionListener response,String capturePhoto,String capturePhoto,int width,int height){\r\n    CallBack c = new CallBack();\r\n    if (\"ios\".equals(Display.getInstance().getPlatformName()) && (width != -1 || height != -1)) {\r\n        capturePhoto(c);\r\n        Display.getInstance().invokeAndBlock(c);\r\n        if (c.url == null) {\r\n            return null;\r\n        }\r\n        ImageIO scale = Display.getInstance().getImageIO();\r\n        if (scale != null) {\r\n            try {\r\n                String path = c.url.substring(0, c.url.indexOf(\".\")) + \"s\" + c.url.substring(c.url.indexOf(\".\"));\r\n                OutputStream os = FileSystemStorage.getInstance().openOutputStream(path);\r\n                scale.save(c.url, os, ImageIO.FORMAT_JPEG, width, height, 1);\r\n                Util.cleanup(os);\r\n                FileSystemStorage.getInstance().delete(c.url);\r\n                return path;\r\n            } catch (IOException ex) {\r\n                Log.e(ex);\r\n            }\r\n        }\r\n    } else {\r\n        c.targetWidth = width;\r\n        c.targetHeight = height;\r\n        capturePhoto(c);\r\n        Display.getInstance().invokeAndBlock(c);\r\n    }\r\n    return c.url;\r\n}"
}, {
	"Path": "mondrian.olap.Util.lookup",
	"Comment": "looks up an enumeration by name, returning a given default value if nullor not valid.",
	"Method": "OlapElement lookup(Query q,List<Id.Segment> nameParts,Exp lookup,Query q,List<Id.Segment> nameParts,boolean allowProp,Exp lookup,Query q,SchemaReader schemaReader,List<Id.Segment> segments,boolean allowProp,E lookup,Class<E> clazz,String name,E lookup,Class<E> clazz,String name,E defaultValue){\r\n    if (name == null) {\r\n        return defaultValue;\r\n    }\r\n    try {\r\n        return Enum.valueOf(clazz, name);\r\n    } catch (IllegalArgumentException e) {\r\n        return defaultValue;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Label.setTickerEnabled",
	"Comment": "sets the label to allow ticking of the text.by default is true",
	"Method": "void setTickerEnabled(boolean tickerEnabled){\r\n    this.tickerEnabled = tickerEnabled;\r\n}"
}, {
	"Path": "android.support.v4.content.Loader.isAbandoned",
	"Comment": "return whether this loader has been abandoned.in this state, theloader must not report any new data, and must keepits last reported data valid until it is finally reset.",
	"Method": "boolean isAbandoned(){\r\n    return mAbandoned;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.PlatformDefaults.setDefaultRowAlignmentBaseline",
	"Comment": "the default alignment for rows. pre v3.5 this was false but now it is\ttrue.",
	"Method": "void setDefaultRowAlignmentBaseline(boolean b){\r\n    dra = b;\r\n}"
}, {
	"Path": "ly.count.android.sdk.UserData.pushValue",
	"Comment": "create array property, if property does not exist and add value to arrayyou can only use it on array properties or properties that do not exist yet",
	"Method": "void pushValue(String key,String value){\r\n    UserData.modifyCustomData(key, value, \"$push\");\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.getHeader",
	"Comment": "returns the http header field for the given connection, this method is only guaranteed to workwhen invoked from the readheaders method.",
	"Method": "String getHeader(Object connection,String header){\r\n    return Util.getImplementation().getHeaderField(header, connection);\r\n}"
}, {
	"Path": "com.codename1.properties.SetProperty.contains",
	"Comment": "returns true if the given element is contained in the set property",
	"Method": "boolean contains(T element){\r\n    return value.contains(element);\r\n}"
}, {
	"Path": "io.prometheus.client.DoubleAdder.reset",
	"Comment": "resets variables maintaining the sum to zero.this method maybe a useful alternative to creating a new adder, but is onlyeffective if there are no concurrent updates.because thismethod is intrinsically racy, it should only be used when it isknown that no threads are concurrently updating.",
	"Method": "void reset(){\r\n    internalReset(0L);\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.TimeSpinner.setDurationMode",
	"Comment": "duration mode uses the time spinner to indicate a duration in hours and minutes",
	"Method": "void setDurationMode(boolean durationMode){\r\n    if (durationMode) {\r\n        setShowMeridiem(false);\r\n        startHour = 0;\r\n        endHour = 24;\r\n    } else {\r\n        if (showMeridiem) {\r\n            startHour = 1;\r\n            endHour = 13;\r\n        } else {\r\n            startHour = 0;\r\n            endHour = 24;\r\n        }\r\n    }\r\n    this.durationMode = durationMode;\r\n}"
}, {
	"Path": "tests.net.DelegatingSSLSocketFactory.configureSocket",
	"Comment": "invoked after obtaining a socket from the delegate and before returning it to the caller.the default implementation does nothing.",
	"Method": "SSLSocket configureSocket(SSLSocket socket){\r\n    return socket;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.getResponseErrorMessage",
	"Comment": "returns error message associated with an error response code",
	"Method": "String getResponseErrorMessage(){\r\n    return responseErrorMessge;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLForm.addRadioButton",
	"Comment": "adds the specified radiobutton to the form.note that unlike adding to a codename one form here the components are added logically only to query them for their value on submit.",
	"Method": "void addRadioButton(String key,RadioButton rb,String value){\r\n    if (rb.isSelected()) {\r\n        defaultCheckedButtons.addElement(rb);\r\n    } else {\r\n        defaultUncheckedButtons.addElement(rb);\r\n    }\r\n    if (key == null) {\r\n        return;\r\n    }\r\n    Hashtable internal = (Hashtable) comps.get(key);\r\n    ButtonGroup group = null;\r\n    if (internal == null) {\r\n        internal = new Hashtable();\r\n        comps.put(key, internal);\r\n        group = new ButtonGroup();\r\n        buttonGroups.put(key, group);\r\n    } else {\r\n        group = (ButtonGroup) buttonGroups.get(key);\r\n    }\r\n    group.add(rb);\r\n    internal.put(rb, value);\r\n}"
}, {
	"Path": "com.codename1.components.SplitPane.getRight",
	"Comment": "gets the component that is currently placed in the right of the split pane.",
	"Method": "Component getRight(){\r\n    return getBottomOrRightComponent();\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.FollowerState.sendPollRequests",
	"Comment": "polls all members of the cluster to determine whether this member should transition to the candidate state.",
	"Method": "void sendPollRequests(){\r\n    heartbeatTimer = context.getThreadContext().schedule(context.getElectionTimeout(), () -> {\r\n        LOGGER.debug(\"{} - Failed to poll a majority of the cluster in {}\", context.getCluster().member().address(), context.getElectionTimeout());\r\n        resetHeartbeatTimeout();\r\n    });\r\n    final AtomicBoolean complete = new AtomicBoolean();\r\n    final Set<ServerMember> votingMembers = new HashSet(context.getClusterState().getActiveMemberStates().stream().map(MemberState::getMember).collect(Collectors.toList()));\r\n    if (votingMembers.isEmpty()) {\r\n        context.transition(CopycatServer.State.CANDIDATE);\r\n        return;\r\n    }\r\n    final Quorum quorum = new Quorum(context.getClusterState().getQuorum(), (elected) -> {\r\n        complete.set(true);\r\n        if (elected) {\r\n            context.transition(CopycatServer.State.CANDIDATE);\r\n        } else {\r\n            resetHeartbeatTimeout();\r\n        }\r\n    });\r\n    long lastIndex = context.getLog().lastIndex();\r\n    Entry lastEntry = lastIndex > 0 ? context.getLog().get(lastIndex) : null;\r\n    final long lastTerm;\r\n    if (lastEntry != null) {\r\n        lastTerm = lastEntry.getTerm();\r\n        lastEntry.close();\r\n    } else {\r\n        lastTerm = 0;\r\n    }\r\n    LOGGER.info(\"{} - Polling members {}\", context.getCluster().member().address(), votingMembers);\r\n    for (ServerMember member : votingMembers) {\r\n        LOGGER.trace(\"{} - Polling {} for next term {}\", context.getCluster().member().address(), member, context.getTerm() + 1);\r\n        PollRequest request = PollRequest.builder().withTerm(context.getTerm()).withCandidate(context.getCluster().member().id()).withLogIndex(lastIndex).withLogTerm(lastTerm).build();\r\n        context.getConnections().getConnection(member.serverAddress()).thenAccept(connection -> {\r\n            connection.<PollRequest, PollResponse>sendAndReceive(request).whenCompleteAsync((response, error) -> {\r\n                context.checkThread();\r\n                if (isOpen() && !complete.get()) {\r\n                    if (error != null) {\r\n                        LOGGER.warn(\"{} - {}\", context.getCluster().member().address(), error.getMessage());\r\n                        quorum.fail();\r\n                    } else {\r\n                        if (response.term() > context.getTerm()) {\r\n                            context.setTerm(response.term());\r\n                        }\r\n                        if (!response.accepted()) {\r\n                            LOGGER.trace(\"{} - Received rejected poll from {}\", context.getCluster().member().address(), member);\r\n                            quorum.fail();\r\n                        } else if (response.term() != context.getTerm()) {\r\n                            LOGGER.trace(\"{} - Received accepted poll for a different term from {}\", context.getCluster().member().address(), member);\r\n                            quorum.fail();\r\n                        } else {\r\n                            LOGGER.trace(\"{} - Received accepted poll from {}\", context.getCluster().member().address(), member);\r\n                            quorum.succeed();\r\n                        }\r\n                    }\r\n                }\r\n            }, context.getThreadContext().executor());\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Command.setDisposesDialog",
	"Comment": "indicates whether this command causes the dialog to dispose implicitly, defaults to true",
	"Method": "void setDisposesDialog(boolean disposesDialog){\r\n    this.disposesDialog = disposesDialog;\r\n}"
}, {
	"Path": "com.codename1.impl.ios.IOSImplementation.shouldApplicationHandleURL",
	"Comment": "indicates whether the application should handle the given url, defaults to true",
	"Method": "boolean shouldApplicationHandleURL(String url,String caller){\r\n    if (instance.life != null) {\r\n        instance.life.shouldApplicationHandleURL(url, caller);\r\n    }\r\n    if (Display.getInstance() != null) {\r\n        Display.getInstance().setProperty(\"AppArg\", url);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Motion.getCurrentMotionTime",
	"Comment": "returns the current time within the motion relative to start time",
	"Method": "long getCurrentMotionTime(){\r\n    if (currentMotionTime < 0) {\r\n        return System.currentTimeMillis() - startTime;\r\n    }\r\n    return currentMotionTime;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.DimConstraint.setShrinkPriority",
	"Comment": "sets the shrink priority. relative priority is used for determining which entities gets smaller first when space is scarce.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "void setShrinkPriority(int p){\r\n    resize.shrinkPrio = p;\r\n}"
}, {
	"Path": "com.codename1.io.Log.createWriter",
	"Comment": "default method for creating the output writer into which we write, this methodcreates a simple log file using the file connector",
	"Method": "Writer createWriter(){\r\n    try {\r\n        if (getFileURL() == null) {\r\n            return new OutputStreamWriter(Storage.getInstance().createOutputStream(\"CN1Log__$\"));\r\n        }\r\n        if (FileSystemStorage.getInstance().exists(getFileURL())) {\r\n            return new OutputStreamWriter(FileSystemStorage.getInstance().openOutputStream(getFileURL(), (int) FileSystemStorage.getInstance().getLength(getFileURL())));\r\n        } else {\r\n            return new OutputStreamWriter(FileSystemStorage.getInstance().openOutputStream(getFileURL()));\r\n        }\r\n    } catch (Exception err) {\r\n        setFileWriteEnabled(false);\r\n        return new OutputStreamWriter(new ByteArrayOutputStream());\r\n    }\r\n}"
}, {
	"Path": "com.codename1.payments.v3.IabHelper.startSetup",
	"Comment": "starts the setup process. this will start up the setup process asynchronously.you will be notified through the listener when the setup process is complete.this method is safe to call from a ui thread.",
	"Method": "void startSetup(OnIabSetupFinishedListener listener){\r\n    checkNotDisposed();\r\n    if (mSetupDone)\r\n        throw new IllegalStateException(\"IAB helper is already set up.\");\r\n    logDebug(\"Starting in-app billing setup.\");\r\n    mServiceConn = new ServiceConnection() {\r\n        @Override\r\n        public void onServiceDisconnected(ComponentName name) {\r\n            logDebug(\"Billing service disconnected.\");\r\n            mService = null;\r\n        }\r\n        @Override\r\n        public void onServiceConnected(ComponentName name, IBinder service) {\r\n            if (mDisposed)\r\n                return;\r\n            logDebug(\"Billing service connected.\");\r\n            mService = IInAppBillingService.Stub.asInterface(service);\r\n            String packageName = mContext.getPackageName();\r\n            try {\r\n                logDebug(\"Checking for in-app billing 3 support.\");\r\n                int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);\r\n                if (response != BILLING_RESPONSE_RESULT_OK) {\r\n                    if (listener != null)\r\n                        listener.onIabSetupFinished(new IabResult(response, \"Error checking for billing v3 support.\"));\r\n                    mSubscriptionsSupported = false;\r\n                    return;\r\n                }\r\n                logDebug(\"In-app billing version 3 supported for \" + packageName);\r\n                response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);\r\n                if (response == BILLING_RESPONSE_RESULT_OK) {\r\n                    logDebug(\"Subscriptions AVAILABLE.\");\r\n                    mSubscriptionsSupported = true;\r\n                } else {\r\n                    logDebug(\"Subscriptions NOT AVAILABLE. Response: \" + response);\r\n                }\r\n                mSetupDone = true;\r\n            } catch (RemoteException e) {\r\n                if (listener != null) {\r\n                    listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION, \"RemoteException while setting up in-app billing.\"));\r\n                }\r\n                e.printStackTrace();\r\n                return;\r\n            }\r\n            if (listener != null) {\r\n                listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, \"Setup successful.\"));\r\n            }\r\n        }\r\n    };\r\n    Intent serviceIntent = new Intent(\"com.android.vending.billing.InAppBillingService.BIND\");\r\n    serviceIntent.setPackage(\"com.android.vending\");\r\n    if (!mContext.getPackageManager().queryIntentServices(serviceIntent, 0).isEmpty()) {\r\n        mContext.bindService(serviceIntent, mServiceConn, Context.BIND_AUTO_CREATE);\r\n    } else {\r\n        if (listener != null) {\r\n            listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE, \"Billing service unavailable on device.\"));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.payments.v3.IabHelper.startSetup",
	"Comment": "starts the setup process. this will start up the setup process asynchronously.you will be notified through the listener when the setup process is complete.this method is safe to call from a ui thread.",
	"Method": "void startSetup(OnIabSetupFinishedListener listener){\r\n    logDebug(\"Billing service disconnected.\");\r\n    mService = null;\r\n}"
}, {
	"Path": "com.codename1.payments.v3.IabHelper.startSetup",
	"Comment": "starts the setup process. this will start up the setup process asynchronously.you will be notified through the listener when the setup process is complete.this method is safe to call from a ui thread.",
	"Method": "void startSetup(OnIabSetupFinishedListener listener){\r\n    if (mDisposed)\r\n        return;\r\n    logDebug(\"Billing service connected.\");\r\n    mService = IInAppBillingService.Stub.asInterface(service);\r\n    String packageName = mContext.getPackageName();\r\n    try {\r\n        logDebug(\"Checking for in-app billing 3 support.\");\r\n        int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);\r\n        if (response != BILLING_RESPONSE_RESULT_OK) {\r\n            if (listener != null)\r\n                listener.onIabSetupFinished(new IabResult(response, \"Error checking for billing v3 support.\"));\r\n            mSubscriptionsSupported = false;\r\n            return;\r\n        }\r\n        logDebug(\"In-app billing version 3 supported for \" + packageName);\r\n        response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);\r\n        if (response == BILLING_RESPONSE_RESULT_OK) {\r\n            logDebug(\"Subscriptions AVAILABLE.\");\r\n            mSubscriptionsSupported = true;\r\n        } else {\r\n            logDebug(\"Subscriptions NOT AVAILABLE. Response: \" + response);\r\n        }\r\n        mSetupDone = true;\r\n    } catch (RemoteException e) {\r\n        if (listener != null) {\r\n            listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION, \"RemoteException while setting up in-app billing.\"));\r\n        }\r\n        e.printStackTrace();\r\n        return;\r\n    }\r\n    if (listener != null) {\r\n        listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, \"Setup successful.\"));\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Toolbar.setTitleComponent",
	"Comment": "sets the toolbar title component. this method allow placing any componentin the toolbar center instead of the regular label. can be used to placea textfield to perform search operations",
	"Method": "void setTitleComponent(Component titleCmp){\r\n    checkIfInitialized();\r\n    if (titleComponent != null) {\r\n        titleComponent.remove();\r\n    }\r\n    titleComponent = titleCmp;\r\n    addComponent(BorderLayout.CENTER, titleComponent);\r\n}"
}, {
	"Path": "org.conscrypt.Conscrypt.getHostnameOrIP",
	"Comment": "this method attempts to create a textual representation of the peer host or ip. doesnot perform a reverse dns lookup. this is typically used during session creation.",
	"Method": "String getHostnameOrIP(SSLSocket socket){\r\n    return toConscrypt(socket).getHostnameOrIP();\r\n}"
}, {
	"Path": "com.codename1.components.WebBrowser.createDataURI",
	"Comment": "this method creates a data uriwhich allows developers creating html for local use to embed local images into the html byappending them as a uri. e.g. instead of referencing a file or url just load the image dataand place the contents of this string into the src attribute.this is the easiest way to get an html with local images to work on all mobile platforms.",
	"Method": "String createDataURI(byte[] data,String mime){\r\n    return \"data:\" + mime + \";base64,\" + Base64.encodeNoNewline(data);\r\n}"
}, {
	"Path": "io.atomix.copycat.server.protocol.InstallResponse.builder",
	"Comment": "returns a install response builder for an existing response.",
	"Method": "Builder builder(Builder builder,InstallResponse response){\r\n    return new Builder(response);\r\n}"
}, {
	"Path": "com.codename1.io.Log.logThrowable",
	"Comment": "logs an exception to the log, by default print is called with the exception details, on supported devices the stack trace is also physically written to the log",
	"Method": "void logThrowable(Throwable t){\r\n    if (t == null) {\r\n        p(\"Exception logging invoked with null exception...\");\r\n        return;\r\n    }\r\n    print(\"Exception: \" + t.getClass().getName() + \" - \" + t.getMessage(), ERROR);\r\n    Thread thr = Thread.currentThread();\r\n    if (thr instanceof CodenameOneThread && ((CodenameOneThread) thr).hasStackFrame()) {\r\n        print(((CodenameOneThread) thr).getStack(t), ERROR);\r\n    }\r\n    t.printStackTrace();\r\n    try {\r\n        synchronized (this) {\r\n            Writer w = getWriter();\r\n            Util.getImplementation().printStackTraceToStream(t, w);\r\n            w.flush();\r\n        }\r\n    } catch (IOException err) {\r\n        err.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Label.setLegacyRenderer",
	"Comment": "fallback to the old default look and feel renderer for cases where compatibility is essential",
	"Method": "void setLegacyRenderer(boolean legacyRenderer){\r\n    this.legacyRenderer = legacyRenderer;\r\n}"
}, {
	"Path": "java.util.AbstractQueue.element",
	"Comment": "returns but does not remove the element at the head of the queue.",
	"Method": "E element(){\r\n    E o = peek();\r\n    if (null == o) {\r\n        throw new NoSuchElementException();\r\n    }\r\n    return o;\r\n}"
}, {
	"Path": "com.codename1.ui.list.DefaultListCellRenderer.isAlwaysRenderSelection",
	"Comment": "indicates that selection should always be rendered regardless of the status of the shouldrenderselection flag",
	"Method": "boolean isAlwaysRenderSelection(){\r\n    return alwaysRenderSelection;\r\n}"
}, {
	"Path": "com.codename1.components.ImageViewer.isCycleLeft",
	"Comment": "by default the imageviewer cycles from the beginning to the end of the listwhen going to the left, setting this to false prevents this behaviour",
	"Method": "boolean isCycleLeft(){\r\n    return cycleLeft;\r\n}"
}, {
	"Path": "java.util.Collections.checkType",
	"Comment": "checks if specified object is instance of specified class. used for adynamically typesafe view of the collections.",
	"Method": "E checkType(E obj,Class<? extends E> type){\r\n    if (obj != null && !type.isInstance(obj)) {\r\n        throw new IndexOutOfBoundsException(\"\" + obj.getClass().getName() + \" type: \" + type);\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.setProgress",
	"Comment": "sets the progress indicator to get network updates on the queries",
	"Method": "void setProgress(Slider slider){\r\n    this.slider = slider;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.animateStyle",
	"Comment": "animates this set of components, replacing any modified style properties of thedestination style to the components.",
	"Method": "ComponentSelector animateStyle(Style destStyle,int duration,SuccessCallback<ComponentSelector> callback){\r\n    ArrayList<ComponentAnimation> animations = new ArrayList<ComponentAnimation>();\r\n    AnimationManager mgr = null;\r\n    for (Component c : this) {\r\n        AnimationManager cmgr = c.getAnimationManager();\r\n        if (cmgr != null) {\r\n            mgr = cmgr;\r\n            Style sourceStyle = c.getUnselectedStyle();\r\n            destStyle.merge(sourceStyle);\r\n            animations.add(c.createStyleAnimation(sourceStyle, destStyle, duration, null));\r\n        }\r\n    }\r\n    if (mgr != null) {\r\n        ComponentAnimation anim = ComponentAnimation.compoundAnimation(animations.toArray(new ComponentAnimation[animations.size()]));\r\n        mgr.addAnimation(anim, new Runnable() {\r\n            public void run() {\r\n                if (callback != null) {\r\n                    callback.onSucess(ComponentSelector.this);\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.animateStyle",
	"Comment": "animates this set of components, replacing any modified style properties of thedestination style to the components.",
	"Method": "ComponentSelector animateStyle(Style destStyle,int duration,SuccessCallback<ComponentSelector> callback){\r\n    if (callback != null) {\r\n        callback.onSucess(ComponentSelector.this);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Collections.singletonList",
	"Comment": "returns a list containing the specified element. the list cannot bemodified. the list is serializable.",
	"Method": "List<E> singletonList(E object){\r\n    return new SingletonList<E>(object);\r\n}"
}, {
	"Path": "com.codename1.ui.AutoCompleteTextField.setStartsWithMode",
	"Comment": "when enabled this makes the filter check that the string starts with rather than within the index",
	"Method": "void setStartsWithMode(boolean startsWithMode){\r\n    filter.setStartsWithMode(startsWithMode);\r\n}"
}, {
	"Path": "com.codename1.ui.Button.getRolloverIcon",
	"Comment": "indicates the icon that is displayed on the button when the button is in rolled over state",
	"Method": "Image getRolloverIcon(){\r\n    return rolloverIcon;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.removeAll",
	"Comment": "removes all occurrences in this vector of each object in the specifiedcollection.",
	"Method": "boolean removeAll(Collection<?> collection){\r\n    return super.removeAll(collection);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.hasInlineUnselectedStyle",
	"Comment": "checks to see if the component has any inline styles registered for its unselected state.",
	"Method": "boolean hasInlineUnselectedStyle(){\r\n    return getInlineStylesTheme() != null && (inlineAllStyles != null || inlineUnselectedStyles != null);\r\n}"
}, {
	"Path": "com.codename1.ui.table.TableLayout.getRowPosition",
	"Comment": "returns the position of the given table row. a valid value is only returned after thelayout occurred.",
	"Method": "int getRowPosition(int row){\r\n    if (rowPositions != null && rowPositions.length > row) {\r\n        return rowPositions[row];\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayeredLayout.setReferencePositionTop",
	"Comment": "sets the top inset reference position.only applicable if the top inset has a referencecomponent specified.",
	"Method": "LayeredLayout setReferencePositionTop(Component cmp,float position){\r\n    getOrCreateConstraint(cmp).top().referencePosition(position);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.io.tar.TarInputStream.read",
	"Comment": "checks if the bytes being read exceed the entry size and adjusts the bytearray length. updates the byte counters",
	"Method": "int read(int read,byte[] b,int off,int len){\r\n    if (currentEntry != null) {\r\n        if (currentFileSize == currentEntry.getSize()) {\r\n            return -1;\r\n        } else if ((currentEntry.getSize() - currentFileSize) < len) {\r\n            len = (int) (currentEntry.getSize() - currentFileSize);\r\n        }\r\n    }\r\n    int br = super.read(b, off, len);\r\n    if (br != -1) {\r\n        if (currentEntry != null) {\r\n            currentFileSize += br;\r\n        }\r\n        bytesRead += br;\r\n    }\r\n    return br;\r\n}"
}, {
	"Path": "com.codename1.components.RSSReader.isAddBackToTaget",
	"Comment": "indicates whether a back command should be added implicitly to the target container",
	"Method": "boolean isAddBackToTaget(){\r\n    return addBackToTaget;\r\n}"
}, {
	"Path": "com.codename1.util.AbstractStringBuilder.indexOf",
	"Comment": "searches for the index of the specified character. the search for thecharacter starts at the specified offset and moves towards the end.",
	"Method": "int indexOf(String string,int indexOf,String subString,int start){\r\n    if (start < 0) {\r\n        start = 0;\r\n    }\r\n    int subCount = subString.length();\r\n    if (subCount > 0) {\r\n        if (subCount + start > count) {\r\n            return -1;\r\n        }\r\n        char firstChar = subString.charAt(0);\r\n        while (true) {\r\n            int i = start;\r\n            boolean found = false;\r\n            for (; i < count; i++) {\r\n                if (value[i] == firstChar) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!found || subCount + i > count) {\r\n                return -1;\r\n            }\r\n            int o1 = i, o2 = 0;\r\n            while (++o2 < subCount && value[++o1] == subString.charAt(o2)) {\r\n            }\r\n            if (o2 == subCount) {\r\n                return i;\r\n            }\r\n            start = i + 1;\r\n        }\r\n    }\r\n    return (start < count || start == 0) ? start : count;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getOuterWidth",
	"Comment": "gets the outer width of this component. this is the width of the component including horizontal margins.",
	"Method": "int getOuterWidth(){\r\n    return getWidth() + getStyle().getHorizontalMargins();\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.parent",
	"Comment": "creates a new set of components consisting of all of the parents of components in this set.only parent components matching the provided selector will be included in the set.",
	"Method": "ComponentSelector parent(String selector){\r\n    ComponentSelector matcher = new ComponentSelector(selector, new Label());\r\n    HashSet<Component> matches = new HashSet<Component>();\r\n    for (Component c : this) {\r\n        Component parent = c.getParent();\r\n        if (parent != null && matcher.match(parent)) {\r\n            matches.add(parent);\r\n        }\r\n    }\r\n    return matcher.addAll(matches, true);\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.setIcon",
	"Comment": "sets the icon of all elements in this set to a material icon.this will usethe foreground color of the label.",
	"Method": "ComponentSelector setIcon(Image icon,ComponentSelector setIcon,char materialIcon,Style style,float size,ComponentSelector setIcon,char materialIcon,float size,ComponentSelector setIcon,char materialIcon){\r\n    for (Component c : this) {\r\n        if (c instanceof Label) {\r\n            Label l = (Label) c;\r\n            Style style = new Style();\r\n            Style cStyle = c.getUnselectedStyle();\r\n            style.setBgTransparency(0);\r\n            style.setFgColor(cStyle.getFgColor());\r\n            l.setIcon(FontImage.createMaterial(materialIcon, style, 3));\r\n            if (c instanceof Button) {\r\n                Button b = (Button) c;\r\n                style = new Style();\r\n                cStyle = c.getPressedStyle();\r\n                style.setBgTransparency(0);\r\n                style.setFgColor(cStyle.getFgColor());\r\n                b.setPressedIcon(FontImage.createMaterial(materialIcon, style, 3));\r\n            }\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.getCurrentForm",
	"Comment": "return the form currently displayed on the screen or null if no form iscurrently displayed.",
	"Method": "Form getCurrentForm(){\r\n    return Display.INSTANCE.getCurrent();\r\n}"
}, {
	"Path": "com.codename1.l10n.DateFormatSymbols.getZoneLongNameDST",
	"Comment": "gets the long name of a given timezone in daylight saving time.",
	"Method": "String getZoneLongNameDST(String zoneId,String defaultValue){\r\n    zoneId = zoneId.toUpperCase();\r\n    return getLocalizedValue(L10N_ZONE_LONGNAME_DST + zoneId, defaultValue);\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.createAuthComponent",
	"Comment": "this method creates a component which can authenticate. you will receive either theauthentication key or an exception object within the actionlistener callback method.",
	"Method": "Component createAuthComponent(ActionListener al){\r\n    return createOAuth().createAuthComponent(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            if (evt.getSource() instanceof String) {\r\n                token = (String) evt.getSource();\r\n            }\r\n            al.actionPerformed(evt);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.createAuthComponent",
	"Comment": "this method creates a component which can authenticate. you will receive either theauthentication key or an exception object within the actionlistener callback method.",
	"Method": "Component createAuthComponent(ActionListener al){\r\n    if (evt.getSource() instanceof String) {\r\n        token = (String) evt.getSource();\r\n    }\r\n    al.actionPerformed(evt);\r\n}"
}, {
	"Path": "com.googlecode.cqengine.index.sqlite.support.DBUtils.sanitizeForTableName",
	"Comment": "strips illegal characters so that the given string can be used as a sqlite table name.",
	"Method": "String sanitizeForTableName(String input){\r\n    return input.replaceAll(\"[^A-Za-z0-9]\", \"\");\r\n}"
}, {
	"Path": "com.codename1.io.Socket.isSupported",
	"Comment": "returns true if sockets are supported in this port, false otherwise",
	"Method": "boolean isSupported(){\r\n    return Util.getImplementation().isSocketAvailable();\r\n}"
}, {
	"Path": "com.codename1.ui.Stroke.setJoinStyle",
	"Comment": "sets the join style of the stroke.see visual examples of join styles here.",
	"Method": "void setJoinStyle(int joinStyle){\r\n    this.joinStyle = joinStyle;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.isEnableCursors",
	"Comment": "checks if custom cursors are enabled on this form.they are turned off by default since they incur some overhead.",
	"Method": "boolean isEnableCursors(){\r\n    return enableCursors;\r\n}"
}, {
	"Path": "com.codename1.ui.AutoCompleteTextField.setMinimumLength",
	"Comment": "indicates the minimum length of text in the field in order for a popup to showthe default is 0 where a popup is shown immediately for all text length if the numberis 2 a popup will only appear when there are two characters or more.",
	"Method": "void setMinimumLength(int minimumLength){\r\n    this.minimumLength = minimumLength;\r\n}"
}, {
	"Path": "com.codename1.ui.Tabs.getTabTitle",
	"Comment": "returns the title of the tab component. this method should be used when overridingcreatetab",
	"Method": "String getTabTitle(int index,String getTabTitle,Component tab){\r\n    return ((Button) tab).getText();\r\n}"
}, {
	"Path": "com.codename1.ui.table.Table.getCellAlignment",
	"Comment": "indicates the alignment of the cells see label alignment for details",
	"Method": "int getCellAlignment(){\r\n    return cellAlignment;\r\n}"
}, {
	"Path": "java.lang.Throwable.getCause",
	"Comment": "returns the cause of this throwable or null if the cause is nonexistent or unknown.",
	"Method": "Throwable getCause(){\r\n    return cause;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.makers.ScaledThumbnailMaker.scale",
	"Comment": "sets the scaling factor for the thumbnail.\tthe aspect ratio of the resulting image is unaltered from the original.",
	"Method": "ScaledThumbnailMaker scale(double factor,ScaledThumbnailMaker scale,double widthFactor,double heightFactor){\r\n    if (ready.isSet(PARAM_SCALE)) {\r\n        throw new IllegalStateException(\"The scaling factor has already been set.\");\r\n    }\r\n    if (widthFactor <= 0 || heightFactor <= 0) {\r\n        throw new IllegalArgumentException(\"The scaling factor must be greater than zero.\");\r\n    }\r\n    this.widthFactor = widthFactor;\r\n    this.heightFactor = heightFactor;\r\n    ready.set(PARAM_SCALE);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.setCommandBehavior",
	"Comment": "indicates the way commands should be added to a form as one of the ocmmand constants definedin this class",
	"Method": "void setCommandBehavior(int commandBehavior){\r\n    if (!isTouchDevice()) {\r\n        if (commandBehavior == Display.COMMAND_BEHAVIOR_BUTTON_BAR) {\r\n            commandBehavior = Display.COMMAND_BEHAVIOR_SOFTKEY;\r\n        }\r\n    }\r\n    this.commandBehavior = commandBehavior;\r\n    notifyCommandBehavior(commandBehavior);\r\n}"
}, {
	"Path": "com.codename1.ui.list.DefaultListCellRenderer.isShowNumbersDefault",
	"Comment": "indicates whether the default list cell renderer will show numbers by defaultwhen constructed",
	"Method": "boolean isShowNumbersDefault(){\r\n    return showNumbersDefault;\r\n}"
}, {
	"Path": "android.support.v4.text.BidiFormatter.isRtl",
	"Comment": "estimates the directionality of a string using the default text direction heuristic.",
	"Method": "boolean isRtl(String str){\r\n    return mDefaultTextDirectionHeuristicCompat.isRtl(str, 0, str.length());\r\n}"
}, {
	"Path": "com.codename1.ui.BrowserComponent.removeWebEventListener",
	"Comment": "removes the listener, see addwebeventlistener for details",
	"Method": "void removeWebEventListener(String type,ActionListener listener){\r\n    EventDispatcher e = getEventDispatcher(type, false);\r\n    if (e != null) {\r\n        e.removeListener(listener);\r\n        if (!e.hasListeners()) {\r\n            listeners.remove(type);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.runtime.java.lang.Long_.valueOf",
	"Comment": "returns a long instance for the long valuepassed. this method is preferred over the constructor, as this method maymaintain a cache of instances.",
	"Method": "Long valueOf(long lng){\r\n    if (lng < -128 || lng > 127) {\r\n        return new Long(lng);\r\n    }\r\n    return valueOfCache.CACHE[128 + (int) lng];\r\n}"
}, {
	"Path": "com.codename1.ui.Form.setTransitionOutAnimator",
	"Comment": "this property allows us to define a an animation that will draw the transition forexiting this form. a transition is an animation that would occur when switching from one form to another.",
	"Method": "void setTransitionOutAnimator(Transition transitionOutAnimator){\r\n    this.transitionOutAnimator = transitionOutAnimator;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.playBuiltinSound",
	"Comment": "plays a builtin device sound matching the given identifier, implementationsand themes can offer additional identifiers to the ones that are already builtin.",
	"Method": "void playBuiltinSound(String soundIdentifier){\r\n    impl.playBuiltinSound(soundIdentifier);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Style.getMarginRight",
	"Comment": "returns the right margin in pixel or left margin in an rtl situation",
	"Method": "int getMarginRight(boolean rtl){\r\n    if (rtl) {\r\n        return convertUnit(marginUnit, margin[Component.LEFT], Component.LEFT);\r\n    }\r\n    return convertUnit(marginUnit, margin[Component.RIGHT], Component.RIGHT);\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.setDisableStaticDialogScrolling",
	"Comment": "allows a developer to indicate his interest that the dialog should no longerscroll on its own but rather rely on the scrolling properties of internalscrollable containers. this flag only affects the static show methods withinthis class.",
	"Method": "void setDisableStaticDialogScrolling(boolean d){\r\n    disableStaticDialogScrolling = d;\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSEngine.processAccessKey",
	"Comment": "tries to assign the given key string as an access key to the specified componentthe key string given here is a single key",
	"Method": "boolean processAccessKey(String keyStr,HTMLComponent htmlC,Component ui,boolean override){\r\n    if (keyStr.startsWith(\"\\\\\")) {\r\n        try {\r\n            int keyCode = Integer.parseInt(keyStr.substring(1), 16);\r\n            htmlC.addAccessKey((char) keyCode, ui, override);\r\n            return true;\r\n        } catch (NumberFormatException nfe) {\r\n            return false;\r\n        }\r\n    } else if (keyStr.length() == 1) {\r\n        htmlC.addAccessKey(keyStr.charAt(0), ui, override);\r\n        return true;\r\n    } else {\r\n        if (specialKeys != null) {\r\n            Integer key = (Integer) specialKeys.get(keyStr);\r\n            if (key != null) {\r\n                htmlC.addAccessKey(key.intValue(), ui, override);\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.util.EventDispatcher.fireScrollEvent",
	"Comment": "fires the event safely on the edt without risk of concurrency errors",
	"Method": "void fireScrollEvent(int scrollX,int scrollY,int oldscrollX,int oldscrollY){\r\n    if (listeners == null || listeners.size() == 0) {\r\n        return;\r\n    }\r\n    boolean isEdt = Display.getInstance().isEdt();\r\n    if (isEdt && listeners.size() == 1) {\r\n        ScrollListener a = (ScrollListener) listeners.get(0);\r\n        a.scrollChanged(scrollX, scrollY, oldscrollX, oldscrollY);\r\n        return;\r\n    }\r\n    ScrollListener[] array;\r\n    synchronized (this) {\r\n        array = new ScrollListener[listeners.size()];\r\n        int alen = array.length;\r\n        for (int iter = 0; iter < alen; iter++) {\r\n            array[iter] = (ScrollListener) listeners.get(iter);\r\n        }\r\n    }\r\n    if (isEdt) {\r\n        fireScrollSync(array, scrollX, scrollY, oldscrollX, oldscrollY);\r\n    } else {\r\n        scrollListenerArray = true;\r\n        Runnable cl = new CallbackClass(array, new int[] { scrollX, scrollY, oldscrollX, oldscrollY });\r\n        if (blocking) {\r\n            Display.getInstance().callSeriallyAndWait(cl);\r\n        } else {\r\n            Display.getInstance().callSerially(cl);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.support.v4.media.TransportPerformer.onGetBufferPercentage",
	"Comment": "request to find out how much of the media has been buffered on the local device.",
	"Method": "int onGetBufferPercentage(){\r\n    return 100;\r\n}"
}, {
	"Path": "org.conscrypt.Preconditions.checkNotNull",
	"Comment": "ensures that an object reference passed as a parameter to the calling method is not null.",
	"Method": "T checkNotNull(T reference,String errorMessage){\r\n    if (reference == null) {\r\n        throw new NullPointerException(errorMessage);\r\n    }\r\n    return reference;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.updateTabIndices",
	"Comment": "updates the tab indices in this container recursively. this method is used internally by layout managers when calculating the traversal order of components in a form.",
	"Method": "int updateTabIndices(int offset){\r\n    Container parent = this;\r\n    Layout l = parent.getActualLayout();\r\n    if (l.overridesTabIndices(parent)) {\r\n        return l.updateTabIndices(parent, offset);\r\n    }\r\n    int len = parent.getComponentCount();\r\n    int idx = offset;\r\n    for (int i = 0; i < len; i++) {\r\n        Component c = parent.getComponentAt(i);\r\n        int prefIdx = c.getPreferredTabIndex();\r\n        if (prefIdx == 0) {\r\n            c.setTabIndex(idx++);\r\n        } else {\r\n            c.setTabIndex(prefIdx);\r\n        }\r\n        if (c instanceof Container) {\r\n            idx = ((Container) c).updateTabIndices(idx);\r\n        }\r\n    }\r\n    return idx;\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.keyPress",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "void keyPress(int keyCode){\r\n    TestUtils.keyPress(keyCode);\r\n}"
}, {
	"Path": "com.codename1.ui.Form.setFocused",
	"Comment": "sets the focused component and fires the appropriate events to make it so",
	"Method": "void setFocused(Component focused){\r\n    if (this.focused == focused && focused != null) {\r\n        this.focused.repaint();\r\n        return;\r\n    }\r\n    Component oldFocus = this.focused;\r\n    this.focused = focused;\r\n    boolean triggerRevalidate = false;\r\n    if (oldFocus != null) {\r\n        triggerRevalidate = changeFocusState(oldFocus, false);\r\n        if (!triggerRevalidate && oldFocus.getParent() != null) {\r\n            oldFocus.repaint();\r\n        }\r\n    }\r\n    if (focused != null && this.focused == focused) {\r\n        triggerRevalidate = changeFocusState(focused, true) || triggerRevalidate;\r\n        if (!triggerRevalidate) {\r\n            focused.repaint();\r\n        }\r\n    }\r\n    if (triggerRevalidate) {\r\n        revalidate();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.createPressedVersion",
	"Comment": "when applied to buttons borders produce a version that reverses the effects of the border providing a pressed feel",
	"Method": "Border createPressedVersion(){\r\n    if (pressedBorder != null) {\r\n        return pressedBorder;\r\n    }\r\n    switch(type) {\r\n        case TYPE_LINE:\r\n            if (millimeters) {\r\n                return createLineBorder(thickness + 0.1f, colorA);\r\n            }\r\n            return createLineBorder((int) thickness + 1, colorA);\r\n        case TYPE_ETCHED_LOWERED:\r\n            {\r\n                Border b = createEtchedRaised(colorA, colorB);\r\n                b.themeColors = themeColors;\r\n                return b;\r\n            }\r\n        case TYPE_ETCHED_RAISED:\r\n            {\r\n                Border b = createEtchedLowered(colorA, colorB);\r\n                b.themeColors = themeColors;\r\n                return b;\r\n            }\r\n        case TYPE_BEVEL_RAISED:\r\n            {\r\n                Border b = createBevelLowered(colorA, colorB, colorC, colorD);\r\n                b.themeColors = themeColors;\r\n                return b;\r\n            }\r\n        case TYPE_BEVEL_LOWERED:\r\n            {\r\n                Border b = createBevelRaised(colorA, colorB, colorC, colorD);\r\n                b.themeColors = themeColors;\r\n                return b;\r\n            }\r\n        case TYPE_ROUNDED:\r\n            {\r\n                Border b = createRoundBorder(arcWidth, arcHeight, colorA);\r\n                b.themeColors = themeColors;\r\n                b.type = TYPE_ROUNDED_PRESSED;\r\n                return b;\r\n            }\r\n        case TYPE_ROUNDED_PRESSED:\r\n            {\r\n                Border b = createRoundBorder(arcWidth, arcHeight, colorA);\r\n                b.themeColors = themeColors;\r\n                return b;\r\n            }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "java.util.AbstractList.equals",
	"Comment": "compares the specified object to this list and return true if they areequal. two lists are equal when they both contain the same objects in thesame order.",
	"Method": "boolean equals(Object object){\r\n    if (this == object) {\r\n        return true;\r\n    }\r\n    if (object instanceof List) {\r\n        List<?> list = (List<?>) object;\r\n        if (list.size() != size()) {\r\n            return false;\r\n        }\r\n        Iterator<?> it1 = iterator(), it2 = list.iterator();\r\n        while (it1.hasNext()) {\r\n            Object e1 = it1.next(), e2 = it2.next();\r\n            if (!(e1 == null ? e2 == null : e1.equals(e2))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.addCrashLog",
	"Comment": "add crash breadcrumb like log record to the log that will be send together with crash report",
	"Method": "Countly addCrashLog(String record){\r\n    return addCrashBreadcrumb(record);\r\n}"
}, {
	"Path": "com.codename1.xml.XMLParser.isSupported",
	"Comment": "returns true if this element is supported, false otherwisein xmlparser this always returns true, but subclasses can determine if an element is supported in their context according to its name etc.unsupported elements will be skipped by the parser and excluded from the resulting dom object",
	"Method": "boolean isSupported(Element element){\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.createObjectsModel",
	"Comment": "this is a utility method that transforms a defaultlistmodel that contains hashtable entriesinto a defaultlistmodel that will contain fbobject objects that will be initialized with the hashtable entries",
	"Method": "DefaultListModel createObjectsModel(DefaultListModel hashtablesModel,Class fbObjectClass){\r\n    DefaultListModel model = new DefaultListModel();\r\n    for (int i = 0; i < hashtablesModel.getSize(); i++) {\r\n        Hashtable table = (Hashtable) hashtablesModel.getItemAt(i);\r\n        FBObject obj = (FBObject) fbObjectClass.newInstance();\r\n        obj.copy(table);\r\n        model.addItem(obj);\r\n    }\r\n    return model;\r\n}"
}, {
	"Path": "org.conscrypt.Platform.setup",
	"Comment": "runs all the setup for the platform that only needs to run once.",
	"Method": "void setup(){\r\n    NoPreloadHolder.MAPPER.ping();\r\n}"
}, {
	"Path": "com.codename1.io.JSONParser.setUseBoolean",
	"Comment": "indicates that the parser will generate boolean objects and not just strings for boolean values",
	"Method": "void setUseBoolean(boolean aUseBooleanDefault){\r\n    useBooleanDefault = aUseBooleanDefault;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.persistence.composite.CompositePersistence.of",
	"Comment": "creates a compositepersistence wrapping two backing persistences.the collection itself will be persisted to the primary persistence.",
	"Method": "CompositePersistence<O, A> of(Persistence<O, A> primaryPersistence,Persistence<O, A> secondaryPersistence,List<? extends Persistence<O, A>> additionalPersistences,CompositePersistence<O, A> of,Persistence<O, A> primaryPersistence,Persistence<O, A> secondaryPersistence){\r\n    return new CompositePersistence<O, A>(primaryPersistence, secondaryPersistence, Collections.<Persistence<O, A>>emptyList());\r\n}"
}, {
	"Path": "android.support.v4.view.GravityCompat.getAbsoluteGravity",
	"Comment": "convert script specific gravity to absolute horizontal value.if horizontal direction is ltr, then start will set left and end will set right.if horizontal direction is rtl, then start will set right and end will set left.",
	"Method": "int getAbsoluteGravity(int gravity,int layoutDirection,int getAbsoluteGravity,int gravity,int layoutDirection,int getAbsoluteGravity,int gravity,int layoutDirection,int getAbsoluteGravity,int gravity,int layoutDirection){\r\n    return IMPL.getAbsoluteGravity(gravity, layoutDirection);\r\n}"
}, {
	"Path": "com.codename1.ui.list.DefaultListCellRenderer.setSelectionTransparency",
	"Comment": "the background transparency factor to apply to the selection focus",
	"Method": "void setSelectionTransparency(int selectionTransparency){\r\n    focusComponent.getUnselectedStyle().setBgTransparency(selectionTransparency);\r\n}"
}, {
	"Path": "com.codename1.io.Storage.fixFileName",
	"Comment": "if a file name contains slashes replace them with underscores, same goes for , %, ? etc.",
	"Method": "String fixFileName(String name){\r\n    if (normalizeNames) {\r\n        name = StringUtil.replaceAll(name, \"/\", \"_\");\r\n        name = StringUtil.replaceAll(name, \"\\\\\", \"_\");\r\n        name = StringUtil.replaceAll(name, \"%\", \"_\");\r\n        name = StringUtil.replaceAll(name, \"?\", \"_\");\r\n        name = StringUtil.replaceAll(name, \"*\", \"_\");\r\n        name = StringUtil.replaceAll(name, \":\", \"_\");\r\n        name = StringUtil.replaceAll(name, \"=\", \"_\");\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.forceRevalidate",
	"Comment": "a more powerful form of revalidate that recursively lays out the full hierarchy",
	"Method": "void forceRevalidate(){\r\n    forceRevalidateImpl();\r\n    revalidate();\r\n}"
}, {
	"Path": "com.codename1.ui.Form.paintGlassImpl",
	"Comment": "this method can be overriden by a component to draw on top of itself or its childrenafter the component or the children finished drawing in a similar way to the glasspane but more refined per component",
	"Method": "void paintGlassImpl(Graphics g){\r\n    if (getParent() != null) {\r\n        super.paintGlassImpl(g);\r\n        return;\r\n    }\r\n    if (glassPane != null) {\r\n        int tx = g.getTranslateX();\r\n        int ty = g.getTranslateY();\r\n        g.translate(-tx, -ty);\r\n        glassPane.paint(g, getBounds());\r\n        g.translate(tx, ty);\r\n    }\r\n    paintGlass(g);\r\n    if (dragged != null && dragged.isDragAndDropInitialized()) {\r\n        int[] c = g.getClip();\r\n        g.setClip(0, 0, getWidth(), getHeight());\r\n        dragged.drawDraggedImage(g);\r\n        g.setClip(c);\r\n    }\r\n}"
}, {
	"Path": "java.lang.StringToReal.parseFloat",
	"Comment": "returns the closest float value to the real number in the string.",
	"Method": "float parseFloat(String s){\r\n    s = s.trim();\r\n    int length = s.length();\r\n    if (length == 0) {\r\n        throw invalidReal(s, false);\r\n    }\r\n    char last = s.charAt(length - 1);\r\n    if (last == 'y' || last == 'N') {\r\n        return parseName(s, false);\r\n    }\r\n    StringExponentPair info = initialParse(s, length, false);\r\n    if (info.infinity || info.zero) {\r\n        return info.specialValue();\r\n    }\r\n    float result = parseFltImpl(info.s, (int) info.e);\r\n    if (Float.floatToIntBits(result) == 0xffffffff) {\r\n        throw invalidReal(s, false);\r\n    }\r\n    return info.negative ? -result : result;\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.setUnsupportedChars",
	"Comment": "unsupported characters is a string that contains characters that cause issues when rendering on some problematic fonts. the rendering engine can thus remove themwhen drawing.",
	"Method": "void setUnsupportedChars(String unsupportedChars){\r\n    this.unsupportedChars = unsupportedChars;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.StateMachine.isOperationMethod",
	"Comment": "returns a boolean value indicating whether the given method is an operation method.",
	"Method": "boolean isOperationMethod(Method method){\r\n    Class<?>[] paramTypes = method.getParameterTypes();\r\n    return paramTypes.length == 1 && paramTypes[0] == Commit.class;\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudPersona.createAnonymous",
	"Comment": "creates an anonymous persona that will be unique in the cloud, never logout an anonymous user!",
	"Method": "boolean createAnonymous(){\r\n    if (instance == null) {\r\n        getCurrentPersona();\r\n    }\r\n    ConnectionRequest login = new ConnectionRequest();\r\n    login.setPost(true);\r\n    login.setUrl(CloudStorage.SERVER_URL + \"/objStoreUser\");\r\n    login.addArgument(\"pk\", Display.getInstance().getProperty(\"package_name\", null));\r\n    login.addArgument(\"bb\", Display.getInstance().getProperty(\"built_by_user\", null));\r\n    NetworkManager.getInstance().addToQueueAndWait(login);\r\n    if (login.getResposeCode() != 200) {\r\n        return false;\r\n    }\r\n    ByteArrayInputStream bi = new ByteArrayInputStream(login.getResponseData());\r\n    DataInputStream di = new DataInputStream(bi);\r\n    if (instance == null) {\r\n        instance = new CloudPersona();\r\n    }\r\n    try {\r\n        instance.persona = di.readUTF();\r\n    } catch (IOException ex) {\r\n        ex.printStackTrace();\r\n    }\r\n    Preferences.set(\"CN1Persona\", instance.persona);\r\n    Preferences.set(\"CN1PersonaAnonymous\", true);\r\n    Util.cleanup(di);\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.createDayComponent",
	"Comment": "creates a day within the calendar, this method is protected allowingcalendar to be subclassed to replace the rendering logic of individualday buttons.",
	"Method": "Component createDayComponent(){\r\n    return createDay();\r\n}"
}, {
	"Path": "com.codename1.ui.BrowserComponent.setDebugMode",
	"Comment": "toggles debug mode for the browser component which helps detect coding errors in the javascriptbridge logic",
	"Method": "void setDebugMode(boolean mode){\r\n    if (mode) {\r\n        putClientProperty(\"BrowserComponent.firebug\", Boolean.TRUE);\r\n    } else {\r\n        putClientProperty(\"BrowserComponent.firebug\", null);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.designer.BaseForm.createTable",
	"Comment": "create an empty sortable jxtable with sorting etc. enabled for a common look",
	"Method": "JTable createTable(){\r\n    EditorTable table = new EditorTable();\r\n    try {\r\n        table.getAccessibleContext().setAccessibleName(\"Table\");\r\n        table.getAccessibleContext().setAccessibleDescription(\"Table\");\r\n        table.setFillsViewportHeight(true);\r\n    } catch (Throwable err) {\r\n    }\r\n    table.setShowGrid(false);\r\n    return table;\r\n}"
}, {
	"Path": "com.codename1.util.TBigInteger.copy",
	"Comment": "returns a copy of the current instance to achieve immutability",
	"Method": "TBigInteger copy(){\r\n    int[] copyDigits = new int[numberLength];\r\n    System.arraycopy(digits, 0, copyDigits, 0, numberLength);\r\n    return new TBigInteger(sign, numberLength, copyDigits);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.setPressedInstance",
	"Comment": "allows us to define a border that will act as the pressed version of this border",
	"Method": "void setPressedInstance(Border pressed){\r\n    pressedBorder = pressed;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.IdentityHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    if (keySet == null) {\r\n        keySet = new AbstractSet<K>() {\r\n            @Override\r\n            public boolean contains(Object object) {\r\n                return containsKey(object);\r\n            }\r\n            @Override\r\n            public int size() {\r\n                return IdentityHashMap.this.size();\r\n            }\r\n            @Override\r\n            public void clear() {\r\n                IdentityHashMap.this.clear();\r\n            }\r\n            @Override\r\n            public boolean remove(Object key) {\r\n                if (containsKey(key)) {\r\n                    IdentityHashMap.this.remove(key);\r\n                    return true;\r\n                }\r\n                return false;\r\n            }\r\n            @Override\r\n            public Iterator<K> iterator() {\r\n                return new IdentityHashMapIterator<K, K, V>(new MapEntry.Type<K, K, V>() {\r\n                    public K get(MapEntry<K, V> entry) {\r\n                        return entry.key;\r\n                    }\r\n                }, IdentityHashMap.this);\r\n            }\r\n        };\r\n    }\r\n    return keySet;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.IdentityHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return containsKey(object);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.IdentityHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return IdentityHashMap.this.size();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.IdentityHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    IdentityHashMap.this.clear();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.IdentityHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    if (containsKey(key)) {\r\n        IdentityHashMap.this.remove(key);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.IdentityHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return new IdentityHashMapIterator<K, K, V>(new MapEntry.Type<K, K, V>() {\r\n        public K get(MapEntry<K, V> entry) {\r\n            return entry.key;\r\n        }\r\n    }, IdentityHashMap.this);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.IdentityHashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return entry.key;\r\n}"
}, {
	"Path": "io.atomix.copycat.client.util.AddressSelector.changed",
	"Comment": "returns a boolean value indicating whether the selector state would be changed by the given members.",
	"Method": "boolean changed(Address leader,Collection<Address> servers){\r\n    Assert.notNull(servers, \"servers\");\r\n    Assert.argNot(servers.isEmpty(), \"servers list cannot be empty\");\r\n    if (this.leader != null && leader == null) {\r\n        return true;\r\n    } else if (this.leader == null && leader != null) {\r\n        Assert.arg(servers.contains(leader), \"leader must be present in servers list\");\r\n        return true;\r\n    } else if (this.leader != null && !this.leader.equals(leader)) {\r\n        Assert.arg(servers.contains(leader), \"leader must be present in servers list\");\r\n        return true;\r\n    } else if (!matches(this.servers, servers)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.getCommandBehavior",
	"Comment": "indicates the way commands should be added to a form as one of the ocmmand constants definedin this class",
	"Method": "int getCommandBehavior(){\r\n    return commandBehavior;\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudListModel.setRefreshRateMillis",
	"Comment": "indicates the rate in milliseconds in which to poll the server for the current dataof elements that are visible at the moment.",
	"Method": "void setRefreshRateMillis(int refreshRateMillis){\r\n    this.refreshRateMillis = refreshRateMillis;\r\n}"
}, {
	"Path": "java.util.Vector.setElementAt",
	"Comment": "replaces the element at the specified location in this vector with thespecified object.",
	"Method": "void setElementAt(E object,int location){\r\n    if (location < elementCount) {\r\n        elementData[location] = object;\r\n    } else {\r\n        throw new ArrayIndexOutOfBoundsException(location);\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.cqengine.query.logical.And.matches",
	"Comment": "returns true if and only if all child queries matches the given object, otherwise returns false.",
	"Method": "boolean matches(O object,QueryOptions queryOptions){\r\n    for (Query<O> query : super.getSimpleQueries()) {\r\n        if (!query.matches(object, queryOptions)) {\r\n            return false;\r\n        }\r\n    }\r\n    for (Query<O> query : super.getLogicalQueries()) {\r\n        if (!query.matches(object, queryOptions)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "ly.count.android.sdk.CountlyStore.eventsList",
	"Comment": "returns a list of the current stored events, sorted by timestamp from oldest to newest.",
	"Method": "List<Event> eventsList(){\r\n    final String[] array = events();\r\n    final List<Event> events = new ArrayList(array.length);\r\n    for (String s : array) {\r\n        try {\r\n            final Event event = Event.fromJSON(new JSONObject(s));\r\n            if (event != null) {\r\n                events.add(event);\r\n            }\r\n        } catch (JSONException ignored) {\r\n        }\r\n    }\r\n    Collections.sort(events, new Comparator<Event>() {\r\n        @Override\r\n        public int compare(final Event e1, final Event e2) {\r\n            return (int) (e1.timestamp - e2.timestamp);\r\n        }\r\n    });\r\n    return events;\r\n}"
}, {
	"Path": "ly.count.android.sdk.CountlyStore.eventsList",
	"Comment": "returns a list of the current stored events, sorted by timestamp from oldest to newest.",
	"Method": "List<Event> eventsList(){\r\n    return (int) (e1.timestamp - e2.timestamp);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.setPurchaseCallback",
	"Comment": "allows the system to register the purchase callback instance",
	"Method": "void setPurchaseCallback(PurchaseCallback pc){\r\n    purchaseCallback = pc;\r\n}"
}, {
	"Path": "com.codename1.io.JSONParser.isUseBoolean",
	"Comment": "indicates that the parser will generate boolean objects and not just strings for boolean values",
	"Method": "boolean isUseBoolean(){\r\n    return useBooleanDefault;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.isDefaultSnapToGrid",
	"Comment": "indicates whether scrolling this component should jump to a specific locationin a grid",
	"Method": "boolean isDefaultSnapToGrid(){\r\n    return defaultSnapToGrid;\r\n}"
}, {
	"Path": "com.codename1.components.SpanButton.getIconPosition",
	"Comment": "returns the icon position based on border layout constraints",
	"Method": "String getIconPosition(){\r\n    return (String) getLayout().getComponentConstraint(actualButton);\r\n}"
}, {
	"Path": "com.codename1.ui.Form.createStatusBar",
	"Comment": "subclasses can override this method to control the creation of the status bar component.notice that this method will only be invoked if the paintstitlebarbool theme constant is truewhich it is on ios by default",
	"Method": "Component createStatusBar(){\r\n    if (getUIManager().isThemeConstant(\"statusBarScrollsUpBool\", true)) {\r\n        Button bar = new Button();\r\n        bar.setShowEvenIfBlank(true);\r\n        bar.setUIID(\"StatusBar\");\r\n        bar.addActionListener(new ActionListener() {\r\n            @Override\r\n            public void actionPerformed(ActionEvent evt) {\r\n                Component c = findScrollableChild(getContentPane());\r\n                if (c != null) {\r\n                    c.scrollRectToVisible(new Rectangle(0, 0, 10, 10), c);\r\n                }\r\n            }\r\n        });\r\n        return bar;\r\n    } else {\r\n        Container bar = new Container();\r\n        bar.setUIID(\"StatusBar\");\r\n        return bar;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Form.createStatusBar",
	"Comment": "subclasses can override this method to control the creation of the status bar component.notice that this method will only be invoked if the paintstitlebarbool theme constant is truewhich it is on ios by default",
	"Method": "Component createStatusBar(){\r\n    Component c = findScrollableChild(getContentPane());\r\n    if (c != null) {\r\n        c.scrollRectToVisible(new Rectangle(0, 0, 10, 10), c);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.table.TableLayout.setGrowHorizontally",
	"Comment": "indicates whether the table layout should grow horizontally to take up available space by stretching the last column",
	"Method": "void setGrowHorizontally(boolean growHorizontally){\r\n    this.growHorizontally = growHorizontally;\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.unBindDayListener",
	"Comment": "since a day may be any component type, developers should override thismethod to add support for removing the click listener from the givencomponent.",
	"Method": "void unBindDayListener(Component cmp,ActionListener l){\r\n    if (cmp instanceof Button) {\r\n        ((Button) cmp).removeActionListener(l);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.setDisposeOnCompletion",
	"Comment": "a dialog that will be seamlessly disposed once the given request has been completed",
	"Method": "void setDisposeOnCompletion(Dialog disposeOnCompletion){\r\n    this.disposeOnCompletion = disposeOnCompletion;\r\n}"
}, {
	"Path": "java.util.Vector.setSize",
	"Comment": "sets the size of this vector to the specified size. if there are morethan length elements in this vector, the elements at end are lost. ifthere are less than length elements in the vector, the additionalelements contain null.",
	"Method": "void setSize(int length){\r\n    if (length == elementCount) {\r\n        return;\r\n    }\r\n    ensureCapacity(length);\r\n    if (elementCount > length) {\r\n        Arrays.fill(elementData, length, elementCount, null);\r\n    }\r\n    elementCount = length;\r\n    modCount++;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getPropertyNames",
	"Comment": "a component may expose mutable property names for a ui designer to manipulate, thisapi is designed for usage internally by the gui builder code",
	"Method": "String[] getPropertyNames(){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.Image.getImageName",
	"Comment": "the name of the image is set for some images mostly to ease the debugging of codename one application",
	"Method": "String getImageName(){\r\n    return imageName;\r\n}"
}, {
	"Path": "com.codename1.ui.SwipeableContainer.openToLeft",
	"Comment": "this method will open the top component to the left if there is a componentto expose on the right.",
	"Method": "void openToLeft(){\r\n    if (open || openedToLeft) {\r\n        return;\r\n    }\r\n    if (bottomRightWrapper.getComponentCount() == 0) {\r\n        return;\r\n    }\r\n    Component bottom = bottomRightWrapper.getComponentAt(0);\r\n    if (bottomLeftWrapper.getComponentCount() > 0) {\r\n        bottomLeftWrapper.setVisible(false);\r\n    }\r\n    bottomRightWrapper.setVisible(true);\r\n    int topX = topWrapper.getX();\r\n    openCloseMotion = Motion.createSplineMotion(-topX, bottom.getWidth(), 300);\r\n    getComponentForm().registerAnimated(this);\r\n    openCloseMotion.start();\r\n    openedToLeft = true;\r\n    open = true;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.findFirstFocusable",
	"Comment": "creates new componentselector with the set of first focusable elements ofeach of the containers in the current result set.",
	"Method": "ComponentSelector findFirstFocusable(){\r\n    HashSet<Component> out = new HashSet<Component>();\r\n    for (Component c : this) {\r\n        if (c instanceof Container) {\r\n            Component match = ((Container) c).findFirstFocusable();\r\n            if (match != null) {\r\n                out.add(match);\r\n            }\r\n        }\r\n    }\r\n    return new ComponentSelector(out);\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudObject.bindTree",
	"Comment": "binds a ui tree to the cloud object so its values automatically update in the cloud object",
	"Method": "void bindTree(Container ui,int defer,boolean objectLead){\r\n    int componentCount = ui.getComponentCount();\r\n    for (int iter = 0; iter < componentCount; iter++) {\r\n        Component c = ui.getComponentAt(iter);\r\n        if (c instanceof Container) {\r\n            bindTree((Container) c, defer, objectLead);\r\n            continue;\r\n        }\r\n        String bind = c.getCloudBoundProperty();\r\n        if (bind != null && bind.length() > 0) {\r\n            String attributeName = c.getCloudDestinationProperty();\r\n            if (attributeName != null) {\r\n                bindProperty(c, bind, attributeName, defer, objectLead);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.ToastBar.updateStatus",
	"Comment": "updates the toastbar ui component with the settings of the current status.",
	"Method": "void updateStatus(){\r\n    final ToastBarComponent c = getToastBarComponent();\r\n    if (c != null) {\r\n        try {\r\n            if (updatingStatus) {\r\n                pendingUpdateStatus = true;\r\n                return;\r\n            }\r\n            updatingStatus = true;\r\n            if (c.currentlyShowing != null && !statuses.contains(c.currentlyShowing)) {\r\n                c.currentlyShowing = null;\r\n            }\r\n            if (c.currentlyShowing == null || statuses.isEmpty()) {\r\n                if (!statuses.isEmpty()) {\r\n                    c.currentlyShowing = statuses.get(statuses.size() - 1);\r\n                } else {\r\n                    setVisible(false);\r\n                    return;\r\n                }\r\n            }\r\n            Status s = c.currentlyShowing;\r\n            Label l = new Label(s.getMessage() != null ? s.getMessage() : \"\", defaultMessageUIID);\r\n            c.leadButton.getListeners().clear();\r\n            c.leadButton.addActionListener(s.getListener());\r\n            c.leadButton.addActionListener(new ActionListener() {\r\n                @Override\r\n                public void actionPerformed(ActionEvent evt) {\r\n                    if (c.currentlyShowing != null && !c.currentlyShowing.showProgressIndicator) {\r\n                        c.currentlyShowing.clear();\r\n                    }\r\n                    ToastBar.this.setVisible(false);\r\n                }\r\n            });\r\n            c.progressLabel.setVisible(s.isShowProgressIndicator());\r\n            if (c.progressLabel.isVisible()) {\r\n                if (!c.contains(c.progressLabel)) {\r\n                    c.addComponent(BorderLayout.EAST, c.progressLabel);\r\n                }\r\n                Image anim = c.progressLabel.getAnimation();\r\n                if (anim != null && anim.getWidth() > 0) {\r\n                    c.progressLabel.setWidth(anim.getWidth());\r\n                }\r\n                if (anim != null && anim.getHeight() > 0) {\r\n                    c.progressLabel.setHeight(anim.getHeight());\r\n                }\r\n            } else {\r\n                if (c.contains(c.progressLabel)) {\r\n                    c.removeComponent(c.progressLabel);\r\n                }\r\n            }\r\n            c.progressBar.setVisible(s.getProgress() >= -1);\r\n            if (s.getProgress() >= -1) {\r\n                if (!c.contains(c.progressBar)) {\r\n                    c.addComponent(BorderLayout.SOUTH, c.progressBar);\r\n                }\r\n                if (s.getProgress() < 0) {\r\n                    c.progressBar.setInfinite(true);\r\n                } else {\r\n                    c.progressBar.setInfinite(false);\r\n                    c.progressBar.setProgress(s.getProgress());\r\n                }\r\n            } else {\r\n                c.removeComponent(c.progressBar);\r\n            }\r\n            c.icon.setVisible(s.getIcon() != null);\r\n            if (s.getIcon() != null && c.icon.getIcon() != s.getIcon()) {\r\n                c.icon.setIcon(s.getIcon());\r\n            }\r\n            if (s.getIcon() == null && c.contains(c.icon)) {\r\n                c.removeComponent(c.icon);\r\n            } else if (s.getIcon() != null && !c.contains(c.icon)) {\r\n                c.addComponent(BorderLayout.WEST, c.icon);\r\n            }\r\n            String oldText = c.label.getText();\r\n            if (!oldText.equals(l.getText())) {\r\n                if (s.getUiid() != null) {\r\n                    c.setUIID(s.getUiid());\r\n                } else if (defaultUIID != null) {\r\n                    c.setUIID(defaultUIID);\r\n                }\r\n                if (c.isVisible()) {\r\n                    TextArea newLabel = new TextArea();\r\n                    newLabel.setUIID(defaultMessageUIID);\r\n                    newLabel.setFocusable(false);\r\n                    newLabel.setEditable(false);\r\n                    newLabel.setVerticalAlignment(Component.CENTER);\r\n                    if (s.getMessageUIID() != null) {\r\n                        newLabel.setUIID(s.getMessageUIID());\r\n                    } else if (defaultMessageUIID != null) {\r\n                        newLabel.setUIID(defaultMessageUIID);\r\n                    } else {\r\n                        newLabel.setUIID(c.label.getUIID());\r\n                    }\r\n                    if (s.getUiid() != null) {\r\n                        c.setUIID(s.getUiid());\r\n                    } else if (defaultUIID != null) {\r\n                        c.setUIID(defaultUIID);\r\n                    }\r\n                    newLabel.setWidth(c.label.getWidth());\r\n                    newLabel.setText(l.getText());\r\n                    Dimension oldTextAreaSize = UIManager.getInstance().getLookAndFeel().getTextAreaSize(c.label, true);\r\n                    Dimension newTexAreaSize = UIManager.getInstance().getLookAndFeel().getTextAreaSize(newLabel, true);\r\n                    if (c.label.getParent() != null) {\r\n                        c.label.getParent().replaceAndWait(c.label, newLabel, CommonTransitions.createCover(CommonTransitions.SLIDE_VERTICAL, true, 300));\r\n                        c.label = newLabel;\r\n                        if (oldTextAreaSize.getHeight() != newTexAreaSize.getHeight()) {\r\n                            c.label.setPreferredH(newTexAreaSize.getHeight());\r\n                            c.getParent().animateHierarchyAndWait(300);\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (s.getMessageUIID() != null) {\r\n                        c.label.setUIID(s.getMessageUIID());\r\n                    } else if (defaultMessageUIID != null) {\r\n                        c.label.setUIID(defaultMessageUIID);\r\n                    }\r\n                    if (s.getUiid() != null) {\r\n                        c.setUIID(s.getUiid());\r\n                    } else if (defaultUIID != null) {\r\n                        c.setUIID(defaultUIID);\r\n                    }\r\n                    c.label.setText(l.getText());\r\n                    c.label.setPreferredW(c.getWidth());\r\n                    c.revalidate();\r\n                }\r\n            } else {\r\n                c.revalidate();\r\n            }\r\n        } finally {\r\n            updatingStatus = false;\r\n            if (pendingUpdateStatus) {\r\n                pendingUpdateStatus = false;\r\n                Display.getInstance().callSerially(new Runnable() {\r\n                    public void run() {\r\n                        updateStatus();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.ToastBar.updateStatus",
	"Comment": "updates the toastbar ui component with the settings of the current status.",
	"Method": "void updateStatus(){\r\n    if (c.currentlyShowing != null && !c.currentlyShowing.showProgressIndicator) {\r\n        c.currentlyShowing.clear();\r\n    }\r\n    ToastBar.this.setVisible(false);\r\n}"
}, {
	"Path": "com.codename1.components.ToastBar.updateStatus",
	"Comment": "updates the toastbar ui component with the settings of the current status.",
	"Method": "void updateStatus(){\r\n    updateStatus();\r\n}"
}, {
	"Path": "java.util.ArrayDeque.element",
	"Comment": "gets but does not remove the head element of this deque. it throws anexception if the deque is empty.",
	"Method": "E element(){\r\n    return getFirst();\r\n}"
}, {
	"Path": "com.codename1.ui.Display.canExecute",
	"Comment": "returns true if executing this url should work, returns false if it will notand null if this is unknown.",
	"Method": "Boolean canExecute(String url){\r\n    return impl.canExecute(url);\r\n}"
}, {
	"Path": "tests.util.ForEachRunner.runNamed",
	"Comment": "invokes the provided callback for each of the provided named values.",
	"Method": "void runNamed(Callback<T> callback,Iterable<Pair<String, T>> namesAndValues){\r\n    for (Pair<String, T> nameAndValue : namesAndValues) {\r\n        try {\r\n            callback.run(nameAndValue.getSecond());\r\n        } catch (Throwable e) {\r\n            throw new Exception(\"Failed for \" + nameAndValue.getFirst() + \": \" + e.getMessage(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.Preferences.getPreferencesLocation",
	"Comment": "returns the location within the storage of the preferences file to an arbitrary name. this is useful in a caseof encryption where we would want preferences to use a different file name.",
	"Method": "String getPreferencesLocation(){\r\n    return preferencesLocation;\r\n}"
}, {
	"Path": "com.codename1.processing.AbstractEvaluator.evaluateLeftLessRight",
	"Comment": "override this element to handle testing a predicate expression wherelvaluervalue.",
	"Method": "Object evaluateLeftLessRight(List elements,String lvalue,String rvalue,Object evaluateLeftLessRight,StructuredContent element,String lvalue,String rvalue){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.slideUp",
	"Comment": "hide the matched elements with a sliding motion.uses default duration of 500ms",
	"Method": "ComponentSelector slideUp(int duration,ComponentSelector slideUp,int duration,SuccessCallback<ComponentSelector> callback,ComponentSelector slideUp){\r\n    return slideUp(500);\r\n}"
}, {
	"Path": "com.codename1.maps.layers.PointsLayer.fireActionEvent",
	"Comment": "trigger an event for the points that in contained in the boundingbox",
	"Method": "void fireActionEvent(BoundingBox box){\r\n    for (int i = 0; i < points.size(); i++) {\r\n        PointLayer point = (PointLayer) points.elementAt(i);\r\n        if (box.contains(point)) {\r\n            dispatcher.fireActionEvent(new ActionEvent(point));\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.getResourceFilePath",
	"Comment": "allows the navigation code to avoid storing the resource file and lets the gcremove it from memory when its not in use",
	"Method": "String getResourceFilePath(){\r\n    return resourceFilePath;\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.isEnterKey",
	"Comment": "indicates the enter key to be used for editing the text area and by thetext field",
	"Method": "boolean isEnterKey(int keyCode){\r\n    return keyCode == ENTER_KEY;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setName",
	"Comment": "a component name allows us to easily identify the component within a dynamicui.",
	"Method": "void setName(String name){\r\n    this.name = name;\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudListModel.setBatchSize",
	"Comment": "updates the number of elements fetched from the server in a single batch",
	"Method": "void setBatchSize(int batchSize){\r\n    this.batchSize = batchSize;\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.recordUnhandledException",
	"Comment": "log unhandled exception to report it to server as fatal crash",
	"Method": "Countly recordUnhandledException(Exception exception,Countly recordUnhandledException,Throwable exception){\r\n    return recordException(exception, false);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.getImageIO",
	"Comment": "returns the image io instance that allows scaling image files.",
	"Method": "ImageIO getImageIO(){\r\n    return impl.getImageIO();\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.playBuiltinSound",
	"Comment": "plays a builtin device sound matching the given identifier, implementationsand themes can offer additional identifiers to the ones that are already builtin.",
	"Method": "void playBuiltinSound(String soundIdentifier){\r\n    playUserSound(soundIdentifier);\r\n}"
}, {
	"Path": "com.codename1.properties.InstantUI.getBindings",
	"Comment": "returns the binding object for the given container which allows us control over the widgetsand their commit status",
	"Method": "UiBinding.Binding getBindings(Container cnt){\r\n    return (UiBinding.Binding) cnt.getClientProperty(\"cn1$iui-binding\");\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.Picker.getRenderingPrototype",
	"Comment": "when using a lightweight spinner this will be used as the rendering prototype",
	"Method": "Object getRenderingPrototype(){\r\n    return renderingPrototype;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isNotificationSupported",
	"Comment": "indicates whether the notify status bar method will present a notification to the user",
	"Method": "boolean isNotificationSupported(){\r\n    return impl.isNotificationSupported();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.retainAll",
	"Comment": "removes all objects from this vector that are not contained in thespecified collection.",
	"Method": "boolean retainAll(Collection<?> collection){\r\n    return super.retainAll(collection);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.PlatformDefaults.getPanelInsets",
	"Comment": "returns the default panel inset depending of the current platform.",
	"Method": "UnitValue getPanelInsets(int side){\r\n    return PANEL_INS[side];\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.remove",
	"Comment": "removes the first occurrence, starting at the beginning and movingtowards the end, of the specified object from this vector. all elementswith an index bigger than the element that gets removed have their indexdecreased by 1.",
	"Method": "E remove(int location,boolean remove,Object object){\r\n    return removeElement(object);\r\n}"
}, {
	"Path": "com.codename1.processing.Result._internalGet",
	"Comment": "internal function, do not use. this version does not convert thestructured content nodes, so not to be called by end user.",
	"Method": "Object _internalGet(String path){\r\n    List v = _internalGetAsArray(path);\r\n    if (v == null || v.size() == 0) {\r\n        return null;\r\n    }\r\n    return v.get(0);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.isDragActivated",
	"Comment": "indicates whether we are in the middle of a drag operation, this method allowsdevelopers overriding the pointer released events to know when this is a dragoperation.",
	"Method": "boolean isDragActivated(){\r\n    return dragActivated;\r\n}"
}, {
	"Path": "com.codename1.ui.Command.setDisabledIcon",
	"Comment": "indicates the icon that is displayed on the button when the button is inthe disabled state",
	"Method": "void setDisabledIcon(Image disabledIcon){\r\n    this.disabledIcon = disabledIcon;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.showNotify",
	"Comment": "broadcasts show notify into codename one, this method is invoked by the codename one implementationto notify codename one of shownotify events",
	"Method": "void showNotify(){\r\n    addNotifyEvent(SHOW_NOTIFY);\r\n}"
}, {
	"Path": "com.codename1.ui.SwipeableContainer.addSwipeOpenListener",
	"Comment": "adds a listener to the swipeablecontainer which will cause an event to dispatch once the swipeablecontainer is fully opened",
	"Method": "void addSwipeOpenListener(ActionListener l){\r\n    dispatcher.addListener(l);\r\n}"
}, {
	"Path": "com.codename1.ui.table.TableLayout.getMinimumSizePerColumn",
	"Comment": "indicates the minimum size for a column in the table, this is applicable for tables that arenot scrollable on the x axis. this will force the earlier columns to leave room forthe latter columns.",
	"Method": "int getMinimumSizePerColumn(){\r\n    return minimumSizePerColumn;\r\n}"
}, {
	"Path": "android.support.v4.util.SparseArrayCompat.put",
	"Comment": "adds a mapping from the specified key to the specified value,replacing the previous mapping from the specified key if therewas one.",
	"Method": "void put(int key,E value){\r\n    int i = binarySearch(mKeys, 0, mSize, key);\r\n    if (i >= 0) {\r\n        mValues[i] = value;\r\n    } else {\r\n        i = ~i;\r\n        if (i < mSize && mValues[i] == DELETED) {\r\n            mKeys[i] = key;\r\n            mValues[i] = value;\r\n            return;\r\n        }\r\n        if (mGarbage && mSize >= mKeys.length) {\r\n            gc();\r\n            i = ~binarySearch(mKeys, 0, mSize, key);\r\n        }\r\n        if (mSize >= mKeys.length) {\r\n            int n = idealIntArraySize(mSize + 1);\r\n            int[] nkeys = new int[n];\r\n            Object[] nvalues = new Object[n];\r\n            System.arraycopy(mKeys, 0, nkeys, 0, mKeys.length);\r\n            System.arraycopy(mValues, 0, nvalues, 0, mValues.length);\r\n            mKeys = nkeys;\r\n            mValues = nvalues;\r\n        }\r\n        if (mSize - i != 0) {\r\n            System.arraycopy(mKeys, i, mKeys, i + 1, mSize - i);\r\n            System.arraycopy(mValues, i, mValues, i + 1, mSize - i);\r\n        }\r\n        mKeys[i] = key;\r\n        mValues[i] = value;\r\n        mSize++;\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.HashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    if (keySet == null) {\r\n        keySet = new AbstractSet<K>() {\r\n            @Override\r\n            public boolean contains(Object object) {\r\n                return containsKey(object);\r\n            }\r\n            @Override\r\n            public int size() {\r\n                return HashMap.this.size();\r\n            }\r\n            @Override\r\n            public void clear() {\r\n                HashMap.this.clear();\r\n            }\r\n            @Override\r\n            public boolean remove(Object key) {\r\n                Entry<K, V> entry = HashMap.this.removeEntry(key);\r\n                return entry != null;\r\n            }\r\n            @Override\r\n            public Iterator<K> iterator() {\r\n                return new KeyIterator<K, V>(HashMap.this);\r\n            }\r\n        };\r\n    }\r\n    return keySet;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.HashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return containsKey(object);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.HashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return HashMap.this.size();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.HashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    HashMap.this.clear();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.HashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    Entry<K, V> entry = HashMap.this.removeEntry(key);\r\n    return entry != null;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.HashMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(){\r\n    return new KeyIterator<K, V>(HashMap.this);\r\n}"
}, {
	"Path": "org.conscrypt.SSLParametersImpl.getNeedClientAuth",
	"Comment": "returns the value indicating if the peer with this parameters tunedto require client authentication",
	"Method": "boolean getNeedClientAuth(){\r\n    return need_client_auth;\r\n}"
}, {
	"Path": "com.codename1.io.MultipartRequest.isLeaveInputStreamsOpen",
	"Comment": "special flag to keep input stream files open after they are read",
	"Method": "boolean isLeaveInputStreamsOpen(){\r\n    return leaveInputStreamsOpen;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.removeOrientationListener",
	"Comment": "this listener is invoked when device orientation changes on devices that support orientation change",
	"Method": "void removeOrientationListener(ActionListener l){\r\n    if (orientationListener == null) {\r\n        return;\r\n    }\r\n    orientationListener.removeListener(l);\r\n}"
}, {
	"Path": "com.codename1.io.BufferedInputStream.getYield",
	"Comment": "allows setting a yield duration for this stream which is useful for backgroundoperations to release cpu",
	"Method": "int getYield(){\r\n    return yield;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.getDatabasePath",
	"Comment": "returns the file path of the database if exists and if supported on the platform.",
	"Method": "String getDatabasePath(String databaseName){\r\n    return impl.getDatabasePath(databaseName);\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.addDataChangeListener",
	"Comment": "adds a listener for data change events it will be invoked for every changemade to the text field, notice most platforms will invoke only the datachangedlistener.changed event",
	"Method": "void addDataChangeListener(DataChangedListener d){\r\n    listeners.addListener(d);\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.keyRelease",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "void keyRelease(int keyCode){\r\n    TestUtils.keyRelease(keyCode);\r\n}"
}, {
	"Path": "com.codename1.ui.CN.addDefaultHeader",
	"Comment": "adds a header to the global default headers, this header will be implicitly added to all requests going out from this point onwards. the main use case for this isfor authentication information communication via the header.",
	"Method": "void addDefaultHeader(String key,String value){\r\n    NetworkManager.getInstance().addDefaultHeader(key, value);\r\n}"
}, {
	"Path": "com.codename1.media.Audio.onInfo",
	"Comment": "allows us to detect buffering of media to return a better result in playback",
	"Method": "boolean onInfo(MediaPlayer mp,int i,int i1){\r\n    switch(i) {\r\n        case MEDIA_INFO_BUFFERING_START:\r\n            buffering = true;\r\n            break;\r\n        case MEDIA_INFO_BUFFERING_END:\r\n            buffering = false;\r\n            break;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.properties.SetProperty.remove",
	"Comment": "removes the given item from the set and fires a change event if this item has been successfully removed",
	"Method": "K remove(T v,K remove,int v){\r\n    for (T o : value) {\r\n        if (v == 0) {\r\n            return remove(o);\r\n        }\r\n        v--;\r\n    }\r\n    return (K) parent.parent;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.pointerHoverReleased",
	"Comment": "pushes a pointer hover release event with the given coordinates into codename one",
	"Method": "void pointerHoverReleased(int[] x,int[] y){\r\n    if (impl.getCurrentForm() == null) {\r\n        return;\r\n    }\r\n    addPointerEvent(POINTER_HOVER_RELEASED, x[0], y[0]);\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudListModel.clearCache",
	"Comment": "flushes the cache which might be essential when adding new elements",
	"Method": "void clearCache(){\r\n    cache.clearAllCache();\r\n}"
}, {
	"Path": "com.codename1.io.Preferences.fireChange",
	"Comment": "fires the preferencelisteners if priorvalue and value are not equal.",
	"Method": "void fireChange(String pref,Object priorValue,Object value){\r\n    boolean valueChanged = (priorValue != value) && ((priorValue == null) || !priorValue.equals(value));\r\n    if (valueChanged) {\r\n        ArrayList<PreferenceListener> listenerList = listenerMap.get(pref);\r\n        if (listenerList != null) {\r\n            for (int i = listenerList.size() - 1; i >= 0; --i) {\r\n                PreferenceListener listener = listenerList.get(i);\r\n                listener.preferenceChanged(pref, priorValue, value);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLForm.submit",
	"Comment": "called when the a form submit is needed. this querys all form fields, creates a url accordingly and sets it to the htmlcomponent",
	"Method": "void submit(String submitKey,String submitVal){\r\n    if (action == null) {\r\n        return;\r\n    }\r\n    boolean error = false;\r\n    String url = action;\r\n    String params = null;\r\n    if (comps.size() > 0) {\r\n        params = \"\";\r\n        for (Enumeration e = comps.keys(); e.hasMoreElements(); ) {\r\n            String key = (String) e.nextElement();\r\n            Object input = comps.get(key);\r\n            key = HTMLUtils.encodeString(key);\r\n            String value = \"\";\r\n            if (input instanceof String) {\r\n                value = HTMLUtils.encodeString((String) input);\r\n                params += key + \"=\" + value + \"&\";\r\n            } else if (input instanceof Hashtable) {\r\n                Hashtable options = (Hashtable) input;\r\n                for (Enumeration e2 = options.keys(); e2.hasMoreElements(); ) {\r\n                    Button b = (Button) e2.nextElement();\r\n                    if (b.isSelected()) {\r\n                        params += key + \"=\" + HTMLUtils.encodeString((String) options.get(b)) + \"&\";\r\n                    }\r\n                }\r\n            } else if (input instanceof TextArea) {\r\n                TextArea tf = ((TextArea) input);\r\n                String text = tf.getText();\r\n                String errorMsg = null;\r\n                if (HTMLComponent.SUPPORT_INPUT_FORMAT) {\r\n                    boolean ok = false;\r\n                    if (text.equals(\"\")) {\r\n                        if (emptyNotOk.contains(tf)) {\r\n                            errorMsg = htmlC.getUIManager().localize(\"html.format.emptynotok\", \"Field can't be empty\");\r\n                            error = true;\r\n                        } else if (emptyOk.contains(tf)) {\r\n                            ok = true;\r\n                        }\r\n                    }\r\n                    if ((!error) && (!ok)) {\r\n                        HTMLInputFormat inputFormat = (HTMLInputFormat) inputFormats.get(tf);\r\n                        if ((inputFormat != null) && (!inputFormat.verifyString(text))) {\r\n                            String emptyStr = \"\";\r\n                            if (emptyOk.contains(tf)) {\r\n                                emptyStr = htmlC.getUIManager().localize(\"html.format.oremptyok\", \" or an empty string\");\r\n                            } else if (emptyNotOk.contains(tf)) {\r\n                                emptyStr = htmlC.getUIManager().localize(\"html.format.andemptynotok\", \" and cannot be an empty string\");\r\n                            }\r\n                            errorMsg = htmlC.getUIManager().localize(\"html.format.errordesc\", \"Malformed text. Correct value: \") + inputFormat.toString() + emptyStr;\r\n                            error = true;\r\n                        }\r\n                    }\r\n                }\r\n                if (htmlC.getHTMLCallback() != null) {\r\n                    int type = HTMLCallback.FIELD_TEXT;\r\n                    if ((tf.getConstraint() & TextArea.PASSWORD) != 0) {\r\n                        type = HTMLCallback.FIELD_PASSWORD;\r\n                    }\r\n                    text = htmlC.getHTMLCallback().fieldSubmitted(htmlC, tf, url, key, text, type, errorMsg);\r\n                }\r\n                if (errorMsg == null) {\r\n                    params += key + \"=\" + HTMLUtils.encodeString(text) + \"&\";\r\n                }\r\n            } else if (input instanceof ComboBox) {\r\n                Object item = ((ComboBox) input).getSelectedItem();\r\n                if (item instanceof OptionItem) {\r\n                    value = ((OptionItem) item).getValue();\r\n                    params += key + \"=\" + HTMLUtils.encodeString(value) + \"&\";\r\n                }\r\n            } else if (input instanceof MultiComboBox) {\r\n                Vector selected = ((MultiComboBox) input).getSelected();\r\n                for (int i = 0; i < selected.size(); i++) {\r\n                    Object item = selected.elementAt(i);\r\n                    if (item instanceof OptionItem) {\r\n                        value = ((OptionItem) item).getValue();\r\n                        params += key + \"=\" + HTMLUtils.encodeString(value) + \"&\";\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (params.endsWith(\"&\")) {\r\n            params = params.substring(0, params.length() - 1);\r\n        }\r\n    }\r\n    if (submitKey != null) {\r\n        if (params == null) {\r\n            params = \"\";\r\n        }\r\n        if (!params.equals(\"\")) {\r\n            params = params + \"&\";\r\n        }\r\n        params = params + HTMLUtils.encodeString(submitKey) + \"=\" + HTMLUtils.encodeString(submitVal);\r\n    }\r\n    if (!error) {\r\n        DocumentInfo docInfo = new DocumentInfo(url, params, isPostMethod);\r\n        if ((encType != null) && (!encType.equals(\"\"))) {\r\n            docInfo.setEncoding(encType);\r\n        }\r\n        htmlC.setPage(docInfo);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.util.EventDispatcher.fireSelectionEvent",
	"Comment": "fires the event safely on the edt without risk of concurrency errors",
	"Method": "void fireSelectionEvent(int oldSelection,int newSelection){\r\n    if (listeners == null || listeners.size() == 0) {\r\n        return;\r\n    }\r\n    boolean isEdt = Display.getInstance().isEdt();\r\n    if (isEdt && listeners.size() == 1) {\r\n        SelectionListener a = (SelectionListener) listeners.get(0);\r\n        a.selectionChanged(oldSelection, newSelection);\r\n        return;\r\n    }\r\n    SelectionListener[] array;\r\n    synchronized (this) {\r\n        array = new SelectionListener[listeners.size()];\r\n        int alen = array.length;\r\n        for (int iter = 0; iter < alen; iter++) {\r\n            array[iter] = (SelectionListener) listeners.get(iter);\r\n        }\r\n    }\r\n    if (isEdt) {\r\n        fireSelectionSync(array, oldSelection, newSelection);\r\n    } else {\r\n        selectionListenerArray = true;\r\n        Runnable cl = new CallbackClass(array, new int[] { oldSelection, newSelection });\r\n        if (blocking) {\r\n            Display.getInstance().callSeriallyAndWait(cl);\r\n        } else {\r\n            Display.getInstance().callSerially(cl);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.List.setPaintFocusBehindList",
	"Comment": "this method determines if the animated focus is drawn on top of the listor behind the list when moving.",
	"Method": "void setPaintFocusBehindList(boolean paintFocusBehindList){\r\n    this.paintFocusBehindList = paintFocusBehindList;\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.currentDayOfWeek",
	"Comment": "utility method to return a current day of the week that can be used in the count.ly api.",
	"Method": "int currentDayOfWeek(){\r\n    int day = Calendar.getInstance().get(Calendar.DAY_OF_WEEK);\r\n    switch(day) {\r\n        case Calendar.MONDAY:\r\n            return 1;\r\n        case Calendar.TUESDAY:\r\n            return 2;\r\n        case Calendar.WEDNESDAY:\r\n            return 3;\r\n        case Calendar.THURSDAY:\r\n            return 4;\r\n        case Calendar.FRIDAY:\r\n            return 5;\r\n        case Calendar.SATURDAY:\r\n            return 6;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.codename1.io.NetworkManager.getAutoDetectURL",
	"Comment": "this url is used to check whether an internet connection is available",
	"Method": "String getAutoDetectURL(){\r\n    return autoDetectURL;\r\n}"
}, {
	"Path": "org.conscrypt.javax.net.ssl.TestSSLContext.createSSLContext",
	"Comment": "create a sslcontext with a keymanager using the private key andcertificate chain from the given keystore and a trustmanagerusing the certificates authorities from the same keystore.",
	"Method": "SSLContext createSSLContext(String protocol,KeyManager[] keyManagers,TrustManager[] trustManagers){\r\n    try {\r\n        SSLContext context = SSLContext.getInstance(protocol);\r\n        context.init(keyManagers, trustManagers, new SecureRandom());\r\n        return context;\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setSnapToGrid",
	"Comment": "indicates whether scrolling this component should jump to a specific locationin a grid",
	"Method": "void setSnapToGrid(boolean snapToGrid){\r\n    this.snapToGrid = snapToGrid;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLParser.convertCharEntity",
	"Comment": "overrides xmlparser.convertcharentity to add in html char entities",
	"Method": "String convertCharEntity(String charEntity){\r\n    try {\r\n        return HTMLUtils.convertCharEntity(charEntity, true, null);\r\n    } catch (IllegalArgumentException iae) {\r\n        return super.convertCharEntity(charEntity);\r\n    }\r\n}"
}, {
	"Path": "ly.count.android.sdk.CountlyStarRating.getCurrentVersionsSessionCount",
	"Comment": "returns how many sessions has star rating counted internally",
	"Method": "int getCurrentVersionsSessionCount(Context context){\r\n    StarRatingPreferences srp = loadStarRatingPreferences(context);\r\n    return srp.sessionAmount;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getScrollOpacity",
	"Comment": "this method is used internally by the look and feel to implement the fading scrollbarbehavior.",
	"Method": "int getScrollOpacity(){\r\n    if (Display.getInstance().shouldRenderSelection()) {\r\n        scrollOpacity = 0xff;\r\n    }\r\n    return scrollOpacity;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setFocusable",
	"Comment": "a simple setter to determine if this component can get focused",
	"Method": "void setFocusable(boolean focusable){\r\n    this.focusable = focusable;\r\n}"
}, {
	"Path": "com.codename1.ui.validation.Validator.setDefaultValidationFailureHighlightMode",
	"Comment": "indicates the default mode in which validation failures are expressed",
	"Method": "void setDefaultValidationFailureHighlightMode(HighlightMode aDefaultValidationFailureHighlightMode){\r\n    defaultValidationFailureHighlightMode = aDefaultValidationFailureHighlightMode;\r\n}"
}, {
	"Path": "com.codename1.impl.javase.JavaSEPort.createMedia",
	"Comment": "plays the sound in the given uri which is partially platform specific.",
	"Method": "Media createMedia(String uriAddress,boolean isVideo,Runnable onCompletion,Media createMedia,InputStream stream,String mimeType,Runnable onCompletion){\r\n    if (!checkForPermission(\"android.permission.READ_PHONE_STATE\", \"This is required to play media\")) {\r\n        return null;\r\n    }\r\n    if (!checkForPermission(\"android.permission.WRITE_EXTERNAL_STORAGE\", \"This is required to play media\")) {\r\n        return null;\r\n    }\r\n    if (!fxExists) {\r\n        String msg = \"This fetaure is supported from Java version 1.7.0_06, update your Java to enable this feature. This might fail on OpenJDK as well in which case you will need to install the Oracle JDK. \";\r\n        System.out.println(msg);\r\n        throw new IOException(msg);\r\n    }\r\n    java.awt.Container cnt = canvas.getParent();\r\n    while (!(cnt instanceof JFrame)) {\r\n        cnt = cnt.getParent();\r\n        if (cnt == null) {\r\n            return null;\r\n        }\r\n    }\r\n    final java.awt.Container c = cnt;\r\n    final Media[] media = new Media[1];\r\n    final Exception[] err = new Exception[1];\r\n    final javafx.embed.swing.JFXPanel m = new CN1JFXPanel();\r\n    Platform.runLater(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                media[0] = new CodenameOneMediaPlayer(stream, mimeType, (JFrame) c, m, onCompletion);\r\n            } catch (Exception ex) {\r\n                err[0] = ex;\r\n            }\r\n        }\r\n    });\r\n    Display.getInstance().invokeAndBlock(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            while (media[0] == null && err[0] == null) {\r\n                try {\r\n                    Thread.sleep(100);\r\n                } catch (InterruptedException ex) {\r\n                }\r\n            }\r\n        }\r\n    });\r\n    if (err[0] != null) {\r\n        throw new IOException(err[0]);\r\n    }\r\n    return media[0];\r\n}"
}, {
	"Path": "com.codename1.impl.javase.JavaSEPort.createMedia",
	"Comment": "plays the sound in the given uri which is partially platform specific.",
	"Method": "Media createMedia(String uriAddress,boolean isVideo,Runnable onCompletion,Media createMedia,InputStream stream,String mimeType,Runnable onCompletion){\r\n    try {\r\n        media[0] = new CodenameOneMediaPlayer(stream, mimeType, (JFrame) c, m, onCompletion);\r\n    } catch (Exception ex) {\r\n        err[0] = ex;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.javase.JavaSEPort.createMedia",
	"Comment": "plays the sound in the given uri which is partially platform specific.",
	"Method": "Media createMedia(String uriAddress,boolean isVideo,Runnable onCompletion,Media createMedia,InputStream stream,String mimeType,Runnable onCompletion){\r\n    while (media[0] == null && err[0] == null) {\r\n        try {\r\n            Thread.sleep(100);\r\n        } catch (InterruptedException ex) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.midp.codescan.ScannerHider.getCodeScanner",
	"Comment": "returns the native implementation of the code scanner or null",
	"Method": "CodeScanner getCodeScanner(Object canvas){\r\n    try {\r\n        MMAPIPlayer player = null;\r\n        String platform = System.getProperty(\"microedition.platform\");\r\n        if (platform != null && platform.indexOf(\"Nokia\") >= 0) {\r\n            try {\r\n                player = MMAPIPlayer.createPlayer(\"capture://image\", null);\r\n            } catch (Throwable e) {\r\n            }\r\n        }\r\n        if (player == null) {\r\n            try {\r\n                player = MMAPIPlayer.createPlayer(\"capture://video\", null);\r\n            } catch (Exception e) {\r\n                throw new RuntimeException(\"Image/video capture not supported on this phone\");\r\n            }\r\n        }\r\n        GameCanvasImplementation.MIDPVideoComponent video = new GameCanvasImplementation.MIDPVideoComponent(player, canvas);\r\n        video.setFocusable(false);\r\n        return new CodeScannerImpl(video);\r\n    } catch (Throwable t) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.clickButtonByName",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "void clickButtonByName(String name){\r\n    TestUtils.clickButtonByName(name);\r\n}"
}, {
	"Path": "com.codename1.ui.Image.getSVGDocument",
	"Comment": "returns a platform specific dom object that can be manipulated by the userto change the svg image",
	"Method": "Object getSVGDocument(){\r\n    return Display.impl.getSVGDocument(image);\r\n}"
}, {
	"Path": "android.support.v4.widget.SimpleCursorAdapter.getStringConversionColumn",
	"Comment": "return the index of the column used to get a string representationof the cursor.",
	"Method": "int getStringConversionColumn(){\r\n    return mStringConversionColumn;\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSElement.getAttrLengthVal",
	"Comment": "returns the length value of the requested attribute.a css length value can be denoted in various units, or percentages. this method calculates the final value in pixels.",
	"Method": "int getAttrLengthVal(int attrId,Component cmp,int origDimension){\r\n    int val = getAttrVal(attrId);\r\n    return convertLengthVal(val, cmp, origDimension);\r\n}"
}, {
	"Path": "com.codename1.ui.CN.isEdt",
	"Comment": "returns true if we are currently in the event dispatch thread.this is useful for generic code that can be used both with theedt and outside of it.",
	"Method": "boolean isEdt(){\r\n    return Display.INSTANCE.isEdt();\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getLabelForComponent",
	"Comment": "allows us to indicate the label associated with this component thus providingvisual feedback related for this component e.g. starting the ticker whenthe component receives focus.",
	"Method": "Label getLabelForComponent(){\r\n    return componentLabel;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.getUnselectedStyle",
	"Comment": "returns a proxy style for all of the unselected styles of the components in this set.",
	"Method": "Style getUnselectedStyle(){\r\n    ArrayList<Style> styles = new ArrayList<Style>();\r\n    for (Component c : this) {\r\n        styles.add(c.getUnselectedStyle());\r\n    }\r\n    return Style.createProxyStyle(styles.toArray(new Style[styles.size()]));\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.addThemeRefreshListener",
	"Comment": "adds a theme refresh listener.the listenres will get a callback when setthemeprops method is invoked.",
	"Method": "void addThemeRefreshListener(ActionListener l){\r\n    if (themelisteners == null) {\r\n        themelisteners = new EventDispatcher();\r\n    }\r\n    themelisteners.addListener(l);\r\n}"
}, {
	"Path": "com.codename1.io.NetworkManager.addDefaultHeader",
	"Comment": "adds a header to the global default headers, this header will be implicitly added to all requests going out from this point onwards. the main use case for this isfor authentication information communication via the header.",
	"Method": "void addDefaultHeader(String key,String value){\r\n    if (userHeaders == null) {\r\n        userHeaders = new Hashtable();\r\n    }\r\n    userHeaders.put(key, value);\r\n}"
}, {
	"Path": "org.conscrypt.ct.CTVerifier.verifySignedCertificateTimestamps",
	"Comment": "verify a certificate chain for transparency.signed timestamps are extracted from the leaf certificate, tls extension, and stapled ocspresponse, and verified against the list of known logs.",
	"Method": "CTVerificationResult verifySignedCertificateTimestamps(List<X509Certificate> chain,byte[] tlsData,byte[] ocspData,CTVerificationResult verifySignedCertificateTimestamps,OpenSSLX509Certificate[] chain,byte[] tlsData,byte[] ocspData){\r\n    if (chain.length == 0) {\r\n        throw new IllegalArgumentException(\"Chain of certificates mustn't be empty.\");\r\n    }\r\n    OpenSSLX509Certificate leaf = chain[0];\r\n    CTVerificationResult result = new CTVerificationResult();\r\n    List<SignedCertificateTimestamp> tlsScts = getSCTsFromTLSExtension(tlsData);\r\n    verifyExternalSCTs(tlsScts, leaf, result);\r\n    List<SignedCertificateTimestamp> ocspScts = getSCTsFromOCSPResponse(ocspData, chain);\r\n    verifyExternalSCTs(ocspScts, leaf, result);\r\n    List<SignedCertificateTimestamp> embeddedScts = getSCTsFromX509Extension(chain[0]);\r\n    verifyEmbeddedSCTs(embeddedScts, chain, result);\r\n    return result;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.paintBorder",
	"Comment": "draws the component border if such a border exists. the border unlike the contentof the component will not be affected by scrolling for a scrollable component.",
	"Method": "void paintBorder(Graphics g){\r\n    Border b = getBorder();\r\n    if (b != null) {\r\n        g.setColor(getStyle().getFgColor());\r\n        b.paint(g, this);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.Util.writeUTF",
	"Comment": "writes a string with a null flag, this allows a string which may be null",
	"Method": "void writeUTF(String s,DataOutputStream d){\r\n    if (s == null) {\r\n        d.writeBoolean(false);\r\n        return;\r\n    }\r\n    d.writeBoolean(true);\r\n    d.writeUTF(s);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setHideInLandscape",
	"Comment": "indicates that this component and all its children should be hidden when the device is switched to landscape mode",
	"Method": "void setHideInLandscape(boolean hideInLandscape){\r\n    this.hideInLandscape = hideInLandscape;\r\n}"
}, {
	"Path": "android.support.v4.media.TransportMediator.pausePlaying",
	"Comment": "move the controller into the paused state.this updates the remote controlclient to indicate it is paused, but keeps audio focus.",
	"Method": "void pausePlaying(){\r\n    if (mController != null) {\r\n        mController.pausePlaying();\r\n    }\r\n    mCallbacks.onPause();\r\n    pushControllerState();\r\n    reportPlayingChanged();\r\n}"
}, {
	"Path": "org.conscrypt.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    return new SSLSocketFactory() {\r\n        private SSLSocket set(Socket socket) {\r\n            SSLSocket s = (SSLSocket) socket;\r\n            s.setWantClientAuth(want);\r\n            s.setNeedClientAuth(need);\r\n            return s;\r\n        }\r\n        @Override\r\n        public Socket createSocket(String host, int port) throws IOException {\r\n            return set(sf.createSocket(host, port));\r\n        }\r\n        @Override\r\n        public Socket createSocket(String host, int port, InetAddress localHost, int localPort) throws IOException {\r\n            return set(sf.createSocket(host, port, localHost, localPort));\r\n        }\r\n        @Override\r\n        public Socket createSocket(InetAddress host, int port) throws IOException {\r\n            return set(sf.createSocket(host, port));\r\n        }\r\n        @Override\r\n        public Socket createSocket(InetAddress address, int port, InetAddress localAddress, int localPort) throws IOException {\r\n            return set(sf.createSocket(address, port));\r\n        }\r\n        @Override\r\n        public String[] getDefaultCipherSuites() {\r\n            return sf.getDefaultCipherSuites();\r\n        }\r\n        @Override\r\n        public String[] getSupportedCipherSuites() {\r\n            return sf.getSupportedCipherSuites();\r\n        }\r\n        @Override\r\n        public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {\r\n            return set(sf.createSocket(s, host, port, autoClose));\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.conscrypt.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    SSLSocket s = (SSLSocket) socket;\r\n    s.setWantClientAuth(want);\r\n    s.setNeedClientAuth(need);\r\n    return s;\r\n}"
}, {
	"Path": "org.conscrypt.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    return set(sf.createSocket(host, port));\r\n}"
}, {
	"Path": "org.conscrypt.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    return set(sf.createSocket(host, port, localHost, localPort));\r\n}"
}, {
	"Path": "org.conscrypt.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    return set(sf.createSocket(host, port));\r\n}"
}, {
	"Path": "org.conscrypt.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    return set(sf.createSocket(address, port));\r\n}"
}, {
	"Path": "org.conscrypt.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    return sf.getDefaultCipherSuites();\r\n}"
}, {
	"Path": "org.conscrypt.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    return sf.getSupportedCipherSuites();\r\n}"
}, {
	"Path": "org.conscrypt.javax.net.ssl.TestSSLContext.clientAuth",
	"Comment": "returns an sslsocketfactory that calls setwantclientauth andsetneedclientauth as specified on all returned sockets.",
	"Method": "SSLSocketFactory clientAuth(SSLSocketFactory sf,boolean want,boolean need){\r\n    return set(sf.createSocket(s, host, port, autoClose));\r\n}"
}, {
	"Path": "org.conscrypt.TrustedCertificateStore.isUserAddedCertificate",
	"Comment": "returns true to indicate that the certificate was added by theuser, false otherwise.",
	"Method": "boolean isUserAddedCertificate(X509Certificate cert){\r\n    return getCertificateFile(addedDir, cert).exists();\r\n}"
}, {
	"Path": "com.codename1.io.Log.getLevel",
	"Comment": "returns the logging level for printing log details, the lower the value the more verbose would the printouts be",
	"Method": "int getLevel(){\r\n    return instance.level;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLParser.createNewElement",
	"Comment": "overrides xmlparser.createnewelement to return an htmlelement instance",
	"Method": "Element createNewElement(String name){\r\n    HTMLElement elem = new HTMLElement(name);\r\n    return elem;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.setFadeScrollEdge",
	"Comment": "indicates whether the edge of a scrollable area should fade out",
	"Method": "void setFadeScrollEdge(boolean fadeScrollEdge){\r\n    this.fadeScrollEdge = fadeScrollEdge;\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.setCursorBlinkTimeOff",
	"Comment": "the amount of time in milliseconds in which the cursor is invisible",
	"Method": "void setCursorBlinkTimeOff(int time){\r\n    blinkOffTime = time;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setPressedStyle",
	"Comment": "sets the component style for the pressed state allowing us to manipulatethe look of the component when it is pressed",
	"Method": "void setPressedStyle(Style style){\r\n    if (pressedStyle != null) {\r\n        pressedStyle.removeStyleListener(this);\r\n    }\r\n    pressedStyle = style;\r\n    pressedStyle.addStyleListener(this);\r\n    if (pressedStyle.getBgPainter() == null) {\r\n        pressedStyle.setBgPainter(new BGPainter());\r\n    }\r\n    setShouldCalcPreferredSize(true);\r\n    checkAnimation();\r\n}"
}, {
	"Path": "com.codename1.impl.android.AndroidImplementation.isLookupFontSupported",
	"Comment": "indicates whether loading a font by a string is supported by the platform",
	"Method": "boolean isLookupFontSupported(){\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.repaintAnimations",
	"Comment": "makes sure all animations are repainted so they would be rendered in everyframe",
	"Method": "void repaintAnimations(){\r\n    if (rippleComponent != null) {\r\n        rippleComponent.repaint();\r\n        if (rippleMotion == null) {\r\n            rippleComponent = null;\r\n        }\r\n    }\r\n    if (animatableComponents != null) {\r\n        loopAnimations(animatableComponents, null);\r\n    }\r\n    if (internalAnimatableComponents != null) {\r\n        loopAnimations(internalAnimatableComponents, animatableComponents);\r\n    }\r\n    if (animMananger != null) {\r\n        animMananger.updateAnimations();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.properties.Property.set",
	"Comment": "sets the property value and potentially fires a change event",
	"Method": "K set(T value){\r\n    if (!(this.value == value || (this.value != null && this.value.equals(value)))) {\r\n        this.value = value;\r\n        firePropertyChanged();\r\n    }\r\n    if (parent == null) {\r\n        return null;\r\n    }\r\n    return (K) parent.parent;\r\n}"
}, {
	"Path": "org.conscrypt.SSLUtils.getClientKeyType",
	"Comment": "similar to getserverkeytype, but returns value given tlsclientcertificatetype byte values from a certificaterequestmessage for use with x509keymanager.chooseclientalias orx509extendedkeymanager.chooseengineclientalias.visible for testing.",
	"Method": "String getClientKeyType(byte clientCertificateType){\r\n    switch(clientCertificateType) {\r\n        case NativeConstants.TLS_CT_RSA_SIGN:\r\n            return KEY_TYPE_RSA;\r\n        case NativeConstants.TLS_CT_ECDSA_SIGN:\r\n            return KEY_TYPE_EC;\r\n        default:\r\n            return null;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.rotate270Degrees",
	"Comment": "rotates the given image by 270 degrees while changing the ratio of the picture",
	"Method": "Image rotate270Degrees(Image image,boolean maintainOpacity){\r\n    int[] rgb = image.getRGB();\r\n    int[] newRGB = new int[rgb.length];\r\n    int width = image.getWidth();\r\n    int height = image.getHeight();\r\n    for (int y = 0; y < height; y++) {\r\n        for (int x = 0; x < width; x++) {\r\n            newRGB[y + x * height] = rgb[x + y * width];\r\n        }\r\n    }\r\n    return EncodedImage.createFromRGB(newRGB, height, width, !maintainOpacity);\r\n}"
}, {
	"Path": "com.codename1.payments.v3.Inventory.hasDetails",
	"Comment": "return whether or not details about the given product are available.",
	"Method": "boolean hasDetails(String sku){\r\n    return mSkuMap.containsKey(sku);\r\n}"
}, {
	"Path": "com.codename1.ui.Font.getAscent",
	"Comment": "the ascent is the amount by which the character ascends above the baseline.",
	"Method": "int getAscent(){\r\n    return Display.impl.getFontAscent(font);\r\n}"
}, {
	"Path": "com.codename1.system.NativeLookup.create",
	"Comment": "creates an instance of the given native interface and returns it foruser callbacks.",
	"Method": "T create(Class<T> c){\r\n    try {\r\n        if (interfaceToClassLookup != null) {\r\n            Class cls = interfaceToClassLookup.get(c);\r\n            if (cls == null) {\r\n                return null;\r\n            }\r\n            return (T) cls.newInstance();\r\n        }\r\n        return (T) Class.forName(c.getName() + \"Impl\").newInstance();\r\n    } catch (Throwable ex) {\r\n        if (verbose) {\r\n            Log.e(ex);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.getActualRows",
	"Comment": "returns the number of actual rows in the text area taking into considerationgrowsbycontent",
	"Method": "int getActualRows(){\r\n    if (growByContent) {\r\n        if (growLimit > -1) {\r\n            return Math.min(Math.max(rows, getLines()), growLimit);\r\n        }\r\n        return Math.max(rows, getLines());\r\n    }\r\n    return rows;\r\n}"
}, {
	"Path": "android.support.v4.widget.ViewDragHelper.isEdgeTouched",
	"Comment": "check if any of the edges specified were initially touched by the pointer withthe specified id. if there is no currently active gesture or if there is no pointer withthe given id currently down this method will return false.",
	"Method": "boolean isEdgeTouched(int edges,boolean isEdgeTouched,int edges,int pointerId){\r\n    return isPointerDown(pointerId) && (mInitialEdgesTouched[pointerId] & edges) != 0;\r\n}"
}, {
	"Path": "com.codename1.io.gzip.InfBlocks.inflate_flush",
	"Comment": "copy as much as possible from the sliding window to the output area",
	"Method": "int inflate_flush(int r){\r\n    int n;\r\n    int p;\r\n    int q;\r\n    p = z.next_out_index;\r\n    q = read;\r\n    n = (int) ((q <= write ? write : end) - q);\r\n    if (n > z.avail_out)\r\n        n = z.avail_out;\r\n    if (n != 0 && r == Z_BUF_ERROR)\r\n        r = Z_OK;\r\n    z.avail_out -= n;\r\n    z.total_out += n;\r\n    if (check && n > 0) {\r\n        z.adler.update(window, q, n);\r\n    }\r\n    System.arraycopy(window, q, z.next_out, p, n);\r\n    p += n;\r\n    q += n;\r\n    if (q == end) {\r\n        q = 0;\r\n        if (write == end)\r\n            write = 0;\r\n        n = write - q;\r\n        if (n > z.avail_out)\r\n            n = z.avail_out;\r\n        if (n != 0 && r == Z_BUF_ERROR)\r\n            r = Z_OK;\r\n        z.avail_out -= n;\r\n        z.total_out += n;\r\n        if (check && n > 0) {\r\n            z.adler.update(window, q, n);\r\n        }\r\n        System.arraycopy(window, q, z.next_out, p, n);\r\n        p += n;\r\n        q += n;\r\n    }\r\n    z.next_out_index = p;\r\n    read = q;\r\n    return r;\r\n}"
}, {
	"Path": "com.codename1.processing.Result.toString",
	"Comment": "convert the object to a formatted structured content document. forexample, an xml or json document.",
	"Method": "String toString(){\r\n    return root.toString();\r\n}"
}, {
	"Path": "com.codename1.components.InteractionDialog.setDisposeWhenPointerOutOfBounds",
	"Comment": "this flag indicates if the dialog should be disposed if a pointer released event occurred out of the dialog content.",
	"Method": "void setDisposeWhenPointerOutOfBounds(boolean disposeWhenPointerOutOfBounds){\r\n    this.disposeWhenPointerOutOfBounds = disposeWhenPointerOutOfBounds;\r\n}"
}, {
	"Path": "com.codename1.ui.list.FilterProxyListModel.compare",
	"Comment": "this method can be overriden by subclasses to allow sorting arbitrary objects withinthe list, it follows the traditional contract of the compare method in java",
	"Method": "int compare(Object a,Object b,boolean ascending){\r\n    String s1;\r\n    String s2;\r\n    if (a instanceof String) {\r\n        s1 = (String) a;\r\n        s2 = (String) b;\r\n    } else {\r\n        s1 = (String) ((Map) a).get(\"name\");\r\n        s2 = (String) ((Map) b).get(\"name\");\r\n    }\r\n    s1 = s1.toUpperCase();\r\n    s2 = s2.toUpperCase();\r\n    if (ascending) {\r\n        return s1.compareTo(s2);\r\n    } else {\r\n        return -s1.compareTo(s2);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.protocol.RegisterResponse.builder",
	"Comment": "returns a register client response builder for an existing response.",
	"Method": "Builder builder(Builder builder,RegisterResponse response){\r\n    return new Builder(response);\r\n}"
}, {
	"Path": "android.support.v4.media.TransportMediator.startPlaying",
	"Comment": "move the controller into the playing state.this updates the remote controlclient to indicate it is playing, and takes audio focus for the app.",
	"Method": "void startPlaying(){\r\n    if (mController != null) {\r\n        mController.startPlaying();\r\n    }\r\n    mCallbacks.onStart();\r\n    pushControllerState();\r\n    reportPlayingChanged();\r\n}"
}, {
	"Path": "com.codename1.ui.tree.Tree.createNodeComponent",
	"Comment": "creates a node within the tree, this method is protected allowing tree to besubclassed to replace the rendering logic of individual tree buttons.",
	"Method": "Button createNodeComponent(Object node,int depth){\r\n    Button cmp = new Button(childToDisplayLabel(node));\r\n    cmp.setUIID(\"TreeNode\");\r\n    if (model.isLeaf(node)) {\r\n        if (nodeImage == null) {\r\n            FontImage.setMaterialIcon(cmp, FontImage.MATERIAL_DESCRIPTION, 3);\r\n        } else {\r\n            cmp.setIcon(nodeImage);\r\n        }\r\n    } else {\r\n        if (folder == null) {\r\n            FontImage.setMaterialIcon(cmp, FontImage.MATERIAL_FOLDER, 3);\r\n        } else {\r\n            cmp.setIcon(folder);\r\n        }\r\n    }\r\n    updateNodeComponentStyle(cmp.getAllStyles(), depth);\r\n    return cmp;\r\n}"
}, {
	"Path": "com.codename1.ui.html.ResourceThreadQueue.startDequeue",
	"Comment": "starts dequeuing the queue into the running pool and launch them",
	"Method": "boolean startDequeue(){\r\n    int threads = Math.min(queue.size(), maxThreads);\r\n    for (int i = 0; i < threads; i++) {\r\n        ResourceThread t = (ResourceThread) queue.firstElement();\r\n        queue.removeElementAt(0);\r\n        running.addElement(t);\r\n        threadCount++;\r\n    }\r\n    for (Enumeration e = running.elements(); e.hasMoreElements(); ) {\r\n        ResourceThread t = (ResourceThread) e.nextElement();\r\n        t.go();\r\n    }\r\n    return (threads > 0);\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.parseCookieHeader",
	"Comment": "parses a raw cookie header and returns a cookie object to send back at the server",
	"Method": "Cookie parseCookieHeader(String h){\r\n    String lowerH = h.toLowerCase();\r\n    Cookie c = new Cookie();\r\n    int edge = h.indexOf(';');\r\n    int equals = h.indexOf('=');\r\n    if (equals < 0) {\r\n        return null;\r\n    }\r\n    c.setName(h.substring(0, equals));\r\n    if (edge < 0) {\r\n        c.setValue(h.substring(equals + 1));\r\n        c.setDomain(Util.getImplementation().getURLDomain(url));\r\n        return c;\r\n    } else {\r\n        c.setValue(h.substring(equals + 1, edge));\r\n    }\r\n    int index = lowerH.indexOf(\"domain=\");\r\n    if (index > -1) {\r\n        String domain = h.substring(index + 7);\r\n        index = domain.indexOf(';');\r\n        if (index != -1) {\r\n            domain = domain.substring(0, index);\r\n        }\r\n        if (url.indexOf(domain) < 0) {\r\n            System.out.println(\"Warning: Cookie tried to set to another domain\");\r\n            c.setDomain(Util.getImplementation().getURLDomain(url));\r\n        } else {\r\n            c.setDomain(domain);\r\n        }\r\n    } else {\r\n        c.setDomain(Util.getImplementation().getURLDomain(url));\r\n    }\r\n    index = lowerH.indexOf(\"path=\");\r\n    if (index > -1) {\r\n        String path = h.substring(index + 5);\r\n        index = path.indexOf(';');\r\n        if (index > -1) {\r\n            path = path.substring(0, index);\r\n        }\r\n        if (Util.getImplementation().getURLPath(url).indexOf(path) != 0) {\r\n            System.out.println(\"Warning: Cookie tried to set to another path\");\r\n            c.setPath(path);\r\n        } else {\r\n        }\r\n    } else {\r\n    }\r\n    java.util.List parts = StringUtil.tokenize(lowerH, ';');\r\n    for (int i = 0; i < parts.size(); i++) {\r\n        String part = (String) parts.get(i);\r\n        part = part.trim();\r\n        if (part.indexOf(\"secure\") == 0) {\r\n            c.setSecure(true);\r\n        } else if (part.indexOf(\"httponly\") == 0) {\r\n            c.setHttpOnly(true);\r\n        } else if (part.indexOf(\"expires\") == 0) {\r\n            String date = part.substring(part.indexOf(\"=\") + 1);\r\n            java.util.Date dt = parseDate(date, \"EEE, dd-MMM-yyyy HH:mm:ss z\", \"EEE dd-MMM-yyyy HH:mm:ss z\", \"EEE, dd MMM yyyy HH:mm:ss z\", \"EEE dd MMM yyyy HH:mm:ss z\", \"EEE, dd-MMM-yyyy HH:mm:ss Z\", \"EEE dd-MMM-yyyy HH:mm:ss Z\", \"EEE, dd MMM yyyy HH:mm:ss Z\", \"EEE dd MMM yyyy HH:mm:ss Z\", \"EEE, dd-MMM-yy HH:mm:ss z\", \"EEE dd-MMM-yy HH:mm:ss z\", \"EEE, dd MMM yy HH:mm:ss z\", \"EEE dd MMM yy HH:mm:ss z\", \"EEE, dd-MMM-yy HH:mm:ss Z\", \"EEE dd-MMM-yy HH:mm:ss Z\", \"EEE, dd MMM yy HH:mm:ss Z\", \"EEE dd MMM yy HH:mm:ss Z\");\r\n            if (dt != null) {\r\n                c.setExpires(dt.getTime());\r\n            } else {\r\n                if (\"true\".equals(Display.getInstance().getProperty(\"com.codename1.io.ConnectionRequest.throwExceptionOnFailedCookieParse\", \"false\"))) {\r\n                    throw new RuntimeException(\"Failed to parse expires date \" + date + \" for cookie\");\r\n                } else {\r\n                    Log.p(\"Failed to parse expires date \" + date + \" for cookie\", Log.WARNING);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "com.codename1.components.MediaPlayer.getDataSource",
	"Comment": "convenience javabean method, see other version of this method",
	"Method": "String getDataSource(){\r\n    if (!isInitialized() && dataSource == null) {\r\n        return pendingDataURI;\r\n    }\r\n    return dataSource;\r\n}"
}, {
	"Path": "com.codename1.io.services.TwitterRESTService.getIdStr",
	"Comment": "gets the id string of the first entry which is important if we want to set the idto start with in the next request",
	"Method": "String getIdStr(){\r\n    if (getStatusesCount() > 0) {\r\n        return (String) getStatus(0).get(\"id_str\");\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.Graphics.clipRect",
	"Comment": "clips the given rectangle by intersecting with the current clipping region, thismethod can thus only shrink the clipping region and never increase it.",
	"Method": "void clipRect(int x,int y,int width,int height){\r\n    impl.clipRect(nativeGraphics, xTranslate + x, yTranslate + y, width, height);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.setReverseSoftButtons",
	"Comment": "indicates whether softbuttons should be reversed from their default orientation",
	"Method": "void setReverseSoftButtons(boolean reverseSoftButtons){\r\n    this.reverseSoftButtons = reverseSoftButtons;\r\n}"
}, {
	"Path": "com.codename1.io.Socket.isServerSocketSupported",
	"Comment": "returns true if server sockets are supported in this port, if this method returnsfalse invocations of listen will always fail",
	"Method": "boolean isServerSocketSupported(){\r\n    return Util.getImplementation().isServerSocketAvailable();\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.createEtchedLowered",
	"Comment": "creates a lowered etched border with default colors, highlight is derivedfrom the component and shadow is a plain dark color",
	"Method": "Border createEtchedLowered(Border createEtchedLowered,int highlight,int shadow){\r\n    Border b = new Border();\r\n    b.type = TYPE_ETCHED_LOWERED;\r\n    b.themeColors = false;\r\n    b.colorA = shadow;\r\n    b.colorB = highlight;\r\n    return b;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.getLayoutWidth",
	"Comment": "returns the width for layout manager purposes, this takes scrollinginto consideration unlike the getwidth method.",
	"Method": "int getLayoutWidth(){\r\n    if (isScrollableX()) {\r\n        return Math.max(getWidth(), getPreferredW());\r\n    } else {\r\n        Container parent = getScrollableParent();\r\n        if (parent != null && parent.isScrollableX()) {\r\n            return Math.max(getWidth(), getPreferredW());\r\n        }\r\n        int width = getWidth();\r\n        if (width <= 0) {\r\n            return getPreferredW();\r\n        }\r\n        return width;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isAltKeyDown",
	"Comment": "checks if the alt key is currently down.only relevant for desktop ports.",
	"Method": "boolean isAltKeyDown(){\r\n    return impl.isAltKeyDown();\r\n}"
}, {
	"Path": "mondrian.olap.Util.canCast",
	"Comment": "returns whether it is safe to cast a collection to a collection with agiven element type.",
	"Method": "boolean canCast(Collection<?> collection,Class<T> clazz){\r\n    for (Object o : collection) {\r\n        if (o != null && !clazz.isInstance(o)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.Button.isOppositeSide",
	"Comment": "places the check box or radio button on the opposite side at the far end",
	"Method": "boolean isOppositeSide(){\r\n    return false;\r\n}"
}, {
	"Path": "org.conscrypt.TrustManagerImpl.setOcspResponses",
	"Comment": "sets the ocsp response data that was possibly stapled to the tls response.",
	"Method": "void setOcspResponses(PKIXParameters params,X509Certificate cert,byte[] ocspData){\r\n    if (ocspData == null) {\r\n        return;\r\n    }\r\n    PKIXRevocationChecker revChecker = null;\r\n    List<PKIXCertPathChecker> checkers = new ArrayList<PKIXCertPathChecker>(params.getCertPathCheckers());\r\n    for (PKIXCertPathChecker checker : checkers) {\r\n        if (checker instanceof PKIXRevocationChecker) {\r\n            revChecker = (PKIXRevocationChecker) checker;\r\n            break;\r\n        }\r\n    }\r\n    if (revChecker == null) {\r\n        try {\r\n            revChecker = (PKIXRevocationChecker) validator.getRevocationChecker();\r\n        } catch (UnsupportedOperationException e) {\r\n            return;\r\n        }\r\n        checkers.add(revChecker);\r\n        revChecker.setOptions(Collections.singleton(Option.ONLY_END_ENTITY));\r\n    }\r\n    revChecker.setOcspResponses(Collections.singletonMap(cert, ocspData));\r\n    params.setCertPathCheckers(checkers);\r\n}"
}, {
	"Path": "com.codename1.ui.Slider.setRenderPercentageOnTop",
	"Comment": "indicates that the value of the slider should be rendered with a percentage signon top of the slider.",
	"Method": "void setRenderPercentageOnTop(boolean renderPercentageOnTop){\r\n    this.renderPercentageOnTop = renderPercentageOnTop;\r\n}"
}, {
	"Path": "android.support.v4.util.AtomicFile.delete",
	"Comment": "delete the atomic file.this deletes both the base and backup files.",
	"Method": "void delete(){\r\n    mBaseName.delete();\r\n    mBackupName.delete();\r\n}"
}, {
	"Path": "com.codename1.ui.list.GenericListCellRenderer.setFisheye",
	"Comment": "in fisheye rendering mode the renderer maintains selected component drawing",
	"Method": "void setFisheye(boolean fisheye){\r\n    this.fisheye = fisheye;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.elements",
	"Comment": "returns an enumeration on the elements of this vector. the results of theenumeration may be affected if the contents of this vector is modified.",
	"Method": "java.util.Enumeration<E> elements(){\r\n    return new java.util.Enumeration<E>() {\r\n        int pos = 0;\r\n        public boolean hasMoreElements() {\r\n            return pos < elementCount;\r\n        }\r\n        @SuppressWarnings(\"unchecked\")\r\n        public E nextElement() {\r\n            synchronized (Vector.this) {\r\n                if (pos < elementCount) {\r\n                    return (E) elementData[pos++];\r\n                }\r\n            }\r\n            throw new NoSuchElementException();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.elements",
	"Comment": "returns an enumeration on the elements of this vector. the results of theenumeration may be affected if the contents of this vector is modified.",
	"Method": "java.util.Enumeration<E> elements(){\r\n    return pos < elementCount;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.elements",
	"Comment": "returns an enumeration on the elements of this vector. the results of theenumeration may be affected if the contents of this vector is modified.",
	"Method": "java.util.Enumeration<E> elements(){\r\n    synchronized (Vector.this) {\r\n        if (pos < elementCount) {\r\n            return (E) elementData[pos++];\r\n        }\r\n    }\r\n    throw new NoSuchElementException();\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.createDottedBorder",
	"Comment": "creates a dotted border with the specified thickness and the theme colors",
	"Method": "Border createDottedBorder(int thickness,int color,Border createDottedBorder,int thickness){\r\n    return createCSSBorder(TYPE_DOTTED, thickness);\r\n}"
}, {
	"Path": "java.util.AbstractList.listIterator",
	"Comment": "returns a list iterator on the elements of this list. the elements areiterated in the same order as they occur in the list. the iterationstarts at the specified location.",
	"Method": "ListIterator<E> listIterator(int location,ListIterator<E> listIterator,ListIterator<E> listIterator,int location){\r\n    return new FullListIterator(location);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isInTransition",
	"Comment": "returns true if the system is currently in the process of transitioning betweenforms",
	"Method": "boolean isInTransition(){\r\n    if (animationQueue != null && animationQueue.size() > 0) {\r\n        Animation ani = (Animation) animationQueue.get(0);\r\n        return ani instanceof Transition;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.find",
	"Comment": "uses the results of this selector as the roots to create a new selector with the provided selector string.",
	"Method": "ComponentSelector find(String selector){\r\n    return new ComponentSelector(selector, resultsImpl());\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testReserveJoinLate",
	"Comment": "tests joining a server after many entries have been committed.",
	"Method": "void testReserveJoinLate(){\r\n    testServerJoinLate(Member.Type.RESERVE, CopycatServer.State.RESERVE);\r\n}"
}, {
	"Path": "com.codename1.io.services.RSSService.hasMore",
	"Comment": "indicates whether more entries might be available since the limt might have been reached",
	"Method": "boolean hasMore(){\r\n    return hasMore;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getInlineUnselectedStyles",
	"Comment": "gets inline styles that are to be applied to the unselected state of this component.",
	"Method": "String getInlineUnselectedStyles(){\r\n    return this.inlineUnselectedStyles;\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyIndex.toJSONList",
	"Comment": "creates a json string, containing the list of property business objects",
	"Method": "String toJSONList(List<? extends PropertyBusinessObject> objs){\r\n    StringBuilder b = new StringBuilder(\"[\");\r\n    boolean first = true;\r\n    for (PropertyBusinessObject pb : objs) {\r\n        if (first) {\r\n            first = false;\r\n        } else {\r\n            b.append(\",\\n\");\r\n        }\r\n        b.append(pb.getPropertyIndex().toJSON());\r\n    }\r\n    b.append(\"]\");\r\n    return b.toString();\r\n}"
}, {
	"Path": "com.codename1.ui.Container.getLeadParent",
	"Comment": "returns the lead container thats handling the leading, this is useful fora container hierarchy where the parent container might not be the leader",
	"Method": "Container getLeadParent(){\r\n    if (isBlockLead()) {\r\n        return null;\r\n    }\r\n    if (leadComponent != null) {\r\n        return this;\r\n    }\r\n    if (hasLead) {\r\n        return getParent().getLeadParent();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.createDashedBorder",
	"Comment": "creates a dashed border with the specified thickness and the theme colors",
	"Method": "Border createDashedBorder(int thickness,int color,Border createDashedBorder,int thickness){\r\n    return createCSSBorder(TYPE_DASHED, thickness);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayeredLayout.setInsetRight",
	"Comment": "sets the right inset for this component to the prescribed value.",
	"Method": "LayeredLayout setInsetRight(Component cmp,String inset){\r\n    getOrCreateConstraint(cmp).right().setValue(inset);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.animateLayoutFadeAndWait",
	"Comment": "animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation. this methodwaits until the operation is completed before returning",
	"Method": "void animateLayoutFadeAndWait(int duration,int startingOpacity){\r\n    animateLayout(duration, true, startingOpacity, true);\r\n}"
}, {
	"Path": "android.support.v4.widget.ScrollerCompat.computeScrollOffset",
	"Comment": "call this when you want to know the new location.if it returns true,the animation is not yet finished.loc will be altered to provide thenew location.",
	"Method": "boolean computeScrollOffset(Object scroller,boolean computeScrollOffset,Object scroller,boolean computeScrollOffset,Object scroller,boolean computeScrollOffset){\r\n    return IMPL.computeScrollOffset(mScroller);\r\n}"
}, {
	"Path": "com.codename1.ui.html.ResourceThreadQueue.discardQueue",
	"Comment": "discards the entire queue and signals the running threads to cancel.this will be triggered if the user cancelled the page or moved to another page.",
	"Method": "void discardQueue(){\r\n    queue.removeAllElements();\r\n    for (Enumeration e = running.elements(); e.hasMoreElements(); ) {\r\n        ResourceThread t = (ResourceThread) e.nextElement();\r\n        t.cancel();\r\n    }\r\n    running.removeAllElements();\r\n    bgImageCompsSelected.removeAllElements();\r\n    bgImageCompsUnselected.removeAllElements();\r\n    bgImageCompsPressed.removeAllElements();\r\n    threadCount = 0;\r\n    cssCount = -1;\r\n    started = false;\r\n}"
}, {
	"Path": "ly.count.android.sdk.ConnectionQueue.ensureExecutor",
	"Comment": "ensures that an executor has been created for connectionprocessor instances to be submitted to.",
	"Method": "void ensureExecutor(){\r\n    if (executor_ == null) {\r\n        executor_ = Executors.newSingleThreadExecutor();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.push.Push.pushType",
	"Comment": "sets the type of push to use.see developer guide for details of different push types.default is 1",
	"Method": "Push pushType(int pushType){\r\n    this.pushType = pushType;\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.CommonTransitions.setLinearMotion",
	"Comment": "indicates whether the motion associated with this transition is linear or spline motion",
	"Method": "void setLinearMotion(boolean linearMotion){\r\n    this.linearMotion = linearMotion;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.builders.ThumbnailParameterBuilder.fitWithinDimensions",
	"Comment": "sets whether or not the thumbnail should fit within the specified\tdimensions.",
	"Method": "ThumbnailParameterBuilder fitWithinDimensions(boolean fit){\r\n    this.fitWithinDimensions = fit;\r\n    return this;\r\n}"
}, {
	"Path": "android.support.v4.view.ViewPager.onRequestFocusInDescendants",
	"Comment": "we only want the current page that is being shown to be focusable.",
	"Method": "boolean onRequestFocusInDescendants(int direction,Rect previouslyFocusedRect){\r\n    int index;\r\n    int increment;\r\n    int end;\r\n    int count = getChildCount();\r\n    if ((direction & FOCUS_FORWARD) != 0) {\r\n        index = 0;\r\n        increment = 1;\r\n        end = count;\r\n    } else {\r\n        index = count - 1;\r\n        increment = -1;\r\n        end = -1;\r\n    }\r\n    for (int i = index; i != end; i += increment) {\r\n        View child = getChildAt(i);\r\n        if (child.getVisibility() == VISIBLE) {\r\n            ItemInfo ii = infoForChild(child);\r\n            if (ii != null && ii.position == mCurItem) {\r\n                if (child.requestFocus(direction, previouslyFocusedRect)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "java.util.Vector.hashCode",
	"Comment": "returns an integer hash code for the receiver. objects which are equalreturn the same value for this method.",
	"Method": "int hashCode(){\r\n    int result = 1;\r\n    for (int i = 0; i < elementCount; i++) {\r\n        result = (31 * result) + (elementData[i] == null ? 0 : elementData[i].hashCode());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.codename1.io.NetworkManager.killAndWait",
	"Comment": "kills the given request and waits until the request is killed if it isbeing processed by one of the threads. this method must not be invoked froma network thread!",
	"Method": "void killAndWait(ConnectionRequest request){\r\n    request.kill();\r\n    class KillWaitingClass implements Runnable {\r\n        public void run() {\r\n            for (int iter = 0; iter < threadCount; iter++) {\r\n                if (networkThreads[iter].currentRequest == request) {\r\n                    synchronized (LOCK) {\r\n                        while (networkThreads[iter].currentRequest == request) {\r\n                            try {\r\n                                LOCK.wait(20);\r\n                            } catch (InterruptedException ex) {\r\n                                ex.printStackTrace();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Display.getInstance().invokeAndBlock(new KillWaitingClass());\r\n}"
}, {
	"Path": "com.codename1.io.NetworkManager.killAndWait",
	"Comment": "kills the given request and waits until the request is killed if it isbeing processed by one of the threads. this method must not be invoked froma network thread!",
	"Method": "void killAndWait(ConnectionRequest request){\r\n    for (int iter = 0; iter < threadCount; iter++) {\r\n        if (networkThreads[iter].currentRequest == request) {\r\n            synchronized (LOCK) {\r\n                while (networkThreads[iter].currentRequest == request) {\r\n                    try {\r\n                        LOCK.wait(20);\r\n                    } catch (InterruptedException ex) {\r\n                        ex.printStackTrace();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "java.util.Vector.removeAllElements",
	"Comment": "removes all elements from this vector, leaving the size zero and thecapacity unchanged.",
	"Method": "void removeAllElements(){\r\n    for (int i = 0; i < elementCount; i++) {\r\n        elementData[i] = null;\r\n    }\r\n    modCount++;\r\n    elementCount = 0;\r\n}"
}, {
	"Path": "com.codename1.ui.AnimationManager.addAnimationAndBlock",
	"Comment": "adds the animation to the end of the animation queue and blocks the current thread until the animationcompletes",
	"Method": "void addAnimationAndBlock(ComponentAnimation an){\r\n    final Object LOCK = new Object();\r\n    an.setNotifyLock(LOCK);\r\n    addAnimation(an);\r\n    Display.getInstance().invokeAndBlock(new Runnable() {\r\n        public void run() {\r\n            while (an.isInProgress() && anims.contains(an)) {\r\n                Util.wait(LOCK, 50);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.codename1.ui.AnimationManager.addAnimationAndBlock",
	"Comment": "adds the animation to the end of the animation queue and blocks the current thread until the animationcompletes",
	"Method": "void addAnimationAndBlock(ComponentAnimation an){\r\n    while (an.isInProgress() && anims.contains(an)) {\r\n        Util.wait(LOCK, 50);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.MediaPlayer.showControls",
	"Comment": "shows the controls for this media player.if the player is set to use native controls, then this will show the native controls.otherwise itshows the lightweight controls.",
	"Method": "void showControls(){\r\n    if (!showControls) {\r\n        showControls = true;\r\n        if (isInitialized()) {\r\n            buttonsBar.setVisible(true);\r\n            buttonsBar.setHidden(false);\r\n            animateLayoutFade(300, 0);\r\n        }\r\n    }\r\n    if (video != null && usesNativeVideoControls()) {\r\n        video.setVariable(Media.VARIABLE_NATIVE_CONTRLOLS_EMBEDDED, true);\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Collections.max",
	"Comment": "searches the specified collection for the maximum element using thespecified comparator.",
	"Method": "T max(Collection<? extends T> collection,T max,Collection<? extends T> collection,Comparator<? super T> comparator){\r\n    if (comparator == null) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        T result = (T) max((Collection<net.sourceforge.retroweaver.harmony.runtime.java.lang.Comparable>) collection);\r\n        return result;\r\n    }\r\n    Iterator<? extends T> it = collection.iterator();\r\n    T max = it.next();\r\n    while (it.hasNext()) {\r\n        T next = it.next();\r\n        if (comparator.compare(max, next) < 0) {\r\n            max = next;\r\n        }\r\n    }\r\n    return max;\r\n}"
}, {
	"Path": "com.l2fprod.common.swing.UserPreferences.getDefaultDirectoryChooser",
	"Comment": "gets the default directory chooser. its current directory will be trackedand restored on subsequent calls.",
	"Method": "JFileChooser getDefaultDirectoryChooser(){\r\n    return getDirectoryChooser(\"default\");\r\n}"
}, {
	"Path": "java.util.ArrayDeque.iterator",
	"Comment": "returns the iterator of the deque. the elements will be ordered from headto tail.",
	"Method": "Iterator<E> iterator(){\r\n    return new ArrayDequeIterator<E>();\r\n}"
}, {
	"Path": "com.codename1.charts.transitions.SeriesTransition.getChart",
	"Comment": "gets the chartcomponent that is the subject of the transition.",
	"Method": "ChartComponent getChart(){\r\n    return chart;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.createRidgeBorder",
	"Comment": "creates a ridge border with the specified thickness and color",
	"Method": "Border createRidgeBorder(int thickness,Border createRidgeBorder,int thickness,int color){\r\n    return createCSSBorder(TYPE_RIDGE, thickness, color);\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.ServerStateMachine.getLastCompleted",
	"Comment": "returns the highest index completed for all sessions.the lastcompleted index is representative of the highest index for which related events have beenreceived byclients. in other words, no events lower than the given index should remain inmemory.",
	"Method": "long getLastCompleted(){\r\n    return lastCompleted > 0 ? lastCompleted : lastApplied;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setY",
	"Comment": "sets the component y location relative to the parent container, this methodis exposed for the purpose of external layout managers and should not be invokeddirectly.",
	"Method": "void setY(int y){\r\n    bounds.setY(y);\r\n    if (Form.activePeerCount > 0) {\r\n        onParentPositionChange();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Button.getListeners",
	"Comment": "returns a collection containing the action listeners for this button",
	"Method": "Collection getListeners(){\r\n    return dispatcher.getListenerCollection();\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Style.merge",
	"Comment": "merges the new style with the current style without changing the elements thatwere modified.",
	"Method": "void merge(Style style){\r\n    int tmp = modifiedFlag;\r\n    if ((modifiedFlag & FG_COLOR_MODIFIED) == 0) {\r\n        setFgColor(style.getFgColor());\r\n    }\r\n    if ((modifiedFlag & BG_COLOR_MODIFIED) == 0) {\r\n        setBgColor(style.getBgColor());\r\n    }\r\n    if ((modifiedFlag & BG_IMAGE_MODIFIED) == 0) {\r\n        setBgImage(style.getBgImage());\r\n    }\r\n    if ((modifiedFlag & BACKGROUND_TYPE_MODIFIED) == 0) {\r\n        setBackgroundType(style.getBackgroundType());\r\n    }\r\n    if ((modifiedFlag & BACKGROUND_ALIGNMENT_MODIFIED) == 0) {\r\n        setBackgroundAlignment(style.getBackgroundAlignment());\r\n    }\r\n    if ((modifiedFlag & BACKGROUND_GRADIENT_MODIFIED) == 0) {\r\n        setBackgroundGradientStartColor(style.getBackgroundGradientStartColor());\r\n        setBackgroundGradientEndColor(style.getBackgroundGradientEndColor());\r\n        setBackgroundGradientRelativeX(style.getBackgroundGradientRelativeX());\r\n        setBackgroundGradientRelativeY(style.getBackgroundGradientRelativeY());\r\n        setBackgroundGradientRelativeSize(style.getBackgroundGradientRelativeSize());\r\n    }\r\n    if ((modifiedFlag & FONT_MODIFIED) == 0) {\r\n        setFont(style.getFont());\r\n    }\r\n    if ((modifiedFlag & TRANSPARENCY_MODIFIED) == 0) {\r\n        setBgTransparency(style.getBgTransparency());\r\n    }\r\n    if ((modifiedFlag & OPACITY_MODIFIED) == 0) {\r\n        setOpacity(style.getOpacity());\r\n    }\r\n    if ((modifiedFlag & PADDING_MODIFIED) == 0) {\r\n        setPadding(style.padding[Component.TOP], style.padding[Component.BOTTOM], style.padding[Component.LEFT], style.padding[Component.RIGHT]);\r\n        setPaddingUnit(paddingUnit);\r\n    }\r\n    if ((modifiedFlag & MARGIN_MODIFIED) == 0) {\r\n        setMargin(style.margin[Component.TOP], style.margin[Component.BOTTOM], style.margin[Component.LEFT], style.margin[Component.RIGHT]);\r\n        setMarginUnit(style.marginUnit);\r\n    }\r\n    if ((modifiedFlag & BORDER_MODIFIED) == 0) {\r\n        setBorder(style.getBorder());\r\n    }\r\n    if ((modifiedFlag & TEXT_DECORATION_MODIFIED) == 0) {\r\n        setTextDecoration(style.getTextDecoration());\r\n    }\r\n    if ((modifiedFlag & ALIGNMENT_MODIFIED) == 0) {\r\n        setAlignment(style.getAlignment());\r\n    }\r\n    this.bgPainter = style.bgPainter;\r\n    modifiedFlag = tmp;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.createInstance",
	"Comment": "this factory method allows creating a new uimanager instance, this is usefull where an application has some screens with different context",
	"Method": "UIManager createInstance(){\r\n    return new UIManager();\r\n}"
}, {
	"Path": "com.codename1.components.InfiniteProgress.getDefaultMaterialDesignColor",
	"Comment": "the default color of the current material design progress spinner",
	"Method": "int getDefaultMaterialDesignColor(){\r\n    return defaultMaterialDesignColor;\r\n}"
}, {
	"Path": "com.codename1.ui.validation.Validator.trimLongString",
	"Comment": "long error messages are trimmed to fit the available space in the layout",
	"Method": "String trimLongString(String errorMessage,String uiid,int width){\r\n    Label errorLabel = new Label(errorMessage, uiid);\r\n    while (errorLabel.getPreferredW() > width && errorMessage.length() > 1) {\r\n        errorMessage = errorMessage.substring(0, errorMessage.length() - 1);\r\n        errorLabel.setText(errorMessage);\r\n    }\r\n    return errorMessage;\r\n}"
}, {
	"Path": "com.codename1.system.NativeLookup.register",
	"Comment": "do not invoke this method. this method is invoked internally by the stub to register the implementation class that matches a specific interface type.",
	"Method": "void register(Class ni,Class cls){\r\n    if (interfaceToClassLookup == null) {\r\n        interfaceToClassLookup = new HashMap<Class, Class>();\r\n    }\r\n    interfaceToClassLookup.put(ni, cls);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.copyToClipboard",
	"Comment": "performs a clipboard copy operation, if the native clipboard is supported by the implementation it would be used",
	"Method": "void copyToClipboard(Object obj){\r\n    lightweightClipboard = obj;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.MigLayout.setLayoutConstraints",
	"Comment": "sets the layout constraints for the layout manager instance as a string.see the class javadocs for information on how this string is formatted.",
	"Method": "void setLayoutConstraints(Object constr){\r\n    if (constr == null || constr instanceof String) {\r\n        constr = ConstraintParser.prepare((String) constr);\r\n        lc = ConstraintParser.parseLayoutConstraint((String) constr);\r\n    } else if (constr instanceof LC) {\r\n        lc = (LC) constr;\r\n    } else {\r\n        throw new IllegalArgumentException(\"Illegal constraint type: \" + constr.getClass().toString());\r\n    }\r\n    layoutConstraints = constr;\r\n    dirty = true;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setX",
	"Comment": "sets the component x location relative to the parent container, this methodis exposed for the purpose of external layout managers and should not be invokeddirectly.",
	"Method": "void setX(int x){\r\n    bounds.setX(x);\r\n    if (Form.activePeerCount > 0) {\r\n        onParentPositionChange();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.getDialogPosition",
	"Comment": "screen orientation position for the upcoming dialog. by defaultthe dialog will be shown at hardcoded coordinates, this method allows usto pack the dialog appropriately in one of the border layout based locationssee borderlayout for futher details.",
	"Method": "String getDialogPosition(){\r\n    return dialogPosition;\r\n}"
}, {
	"Path": "com.codename1.ui.Slider.isRenderPercentageOnTop",
	"Comment": "indicates that the value of the slider should be rendered with a percentage signon top of the slider.",
	"Method": "boolean isRenderPercentageOnTop(){\r\n    return renderPercentageOnTop;\r\n}"
}, {
	"Path": "com.codename1.charts.views.AbstractChart.getLabel",
	"Comment": "makes sure the fraction digit is not displayed, if not needed.",
	"Method": "String getLabel(NumberFormat format,double label){\r\n    String text = \"\";\r\n    if (format != null) {\r\n        text = format.format(label);\r\n    } else if (label == Math.round(label)) {\r\n        text = Math.round(label) + \"\";\r\n    } else {\r\n        text = label + \"\";\r\n    }\r\n    return text;\r\n}"
}, {
	"Path": "com.codename1.ui.ComboBox.createPopupList",
	"Comment": "creates the list object used within the popup dialog. this method allows subclassesto customize the list creation for the popup dialog shown when the combo box is pressed.",
	"Method": "List<T> createPopupList(){\r\n    List<T> l = new List<T>(getModel());\r\n    l.setCommandList(isCommandList());\r\n    l.setSmoothScrolling(isSmoothScrolling());\r\n    l.setFixedSelection(getFixedSelection());\r\n    l.setListCellRenderer(getRenderer());\r\n    l.setItemGap(getItemGap());\r\n    l.setUIID(\"ComboBoxList\");\r\n    if (getUIManager().isThemeConstant(\"otherPopupRendererBool\", false)) {\r\n        DefaultListCellRenderer renderer = new DefaultListCellRenderer();\r\n        renderer.setUIID(\"PopupItem\");\r\n        renderer.getListFocusComponent(l).setUIID(\"PopupFocus\");\r\n        l.setListCellRenderer(renderer);\r\n    }\r\n    return l;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.Layout.isConstraintTracking",
	"Comment": "if this method returns true, the addlayoutcomponent method will be called when replacing a layout for every component within the container",
	"Method": "boolean isConstraintTracking(){\r\n    return false;\r\n}"
}, {
	"Path": "android.support.v4.widget.SlidingPaneLayout.openPane",
	"Comment": "open the sliding pane if it is currently slideable. if first layouthas already completed this will animate.",
	"Method": "boolean openPane(View pane,int initialVelocity,boolean openPane){\r\n    return openPane(mSlideableView, 0);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.grow",
	"Comment": "grow weight for the component horizontally and optionally vertically.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC grow(float widthHeight,CC grow){\r\n    growX();\r\n    growY();\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.Segment.releaseCount",
	"Comment": "returns the number of entries in the segment that have been released.",
	"Method": "long releaseCount(){\r\n    assertSegmentOpen();\r\n    return offsetPredicate.count();\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setCloudBoundProperty",
	"Comment": "indicates the property within this component that should be bound to the cloud object",
	"Method": "void setCloudBoundProperty(String cloudBoundProperty){\r\n    this.cloudBoundProperty = cloudBoundProperty;\r\n    if (cloudBoundProperty == null || this.cloudBoundProperty.length() == 0) {\r\n        noBind = true;\r\n        this.cloudBoundProperty = null;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Form.deregisterAnimated",
	"Comment": "indicate that cmp would no longer like to receive animation events",
	"Method": "void deregisterAnimated(Animation cmp){\r\n    if (animatableComponents != null) {\r\n        animatableComponents.remove(cmp);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.server.protocol.InstallRequest.complete",
	"Comment": "returns a boolean value indicating whether this is the last chunk of the snapshot.",
	"Method": "boolean complete(){\r\n    return complete;\r\n}"
}, {
	"Path": "com.codename1.ui.html.DocumentInfo.getUrl",
	"Comment": "returns the absolute url associated with this documentinfo object",
	"Method": "String getUrl(){\r\n    return pageURL;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.FlowLayout.isValignByRow",
	"Comment": "returns whether vertical alignment is done internally or externally",
	"Method": "boolean isValignByRow(){\r\n    return vAlignByRow;\r\n}"
}, {
	"Path": "com.codename1.ui.table.TableLayout.setTruncateVertically",
	"Comment": "indicates whether the table should be truncated if it do not have enough available vertical space to display all its content. if not, will shrink",
	"Method": "void setTruncateVertically(boolean truncateVertically){\r\n    this.truncateVertically = truncateVertically;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.updateNativeOverlay",
	"Comment": "updates the native overlay for this component.this is called each time the componentis laid out, so it can change the position and visibility to match the current context.",
	"Method": "void updateNativeOverlay(){\r\n    if (nativeOverlay != null) {\r\n        Display.getInstance().getImplementation().updateNativeOverlay(this, nativeOverlay);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.growX",
	"Comment": "grow weight for the component horizontally.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC growX(CC growX,float w){\r\n    hor.setGrow(new Float(w));\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.growY",
	"Comment": "grow weight for the component vertically.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC growY(CC growY,Float w){\r\n    ver.setGrow(w);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.getVertAlign",
	"Comment": "converts a textual vertical alignment description to a codename one alignment constant",
	"Method": "int getVertAlign(String alignment,int defaultAlign){\r\n    if (alignment != null) {\r\n        if (alignment.equals(\"top\")) {\r\n            return Component.TOP;\r\n        } else if (alignment.equals(\"bottom\")) {\r\n            return Component.BOTTOM;\r\n        } else if ((alignment.equals(\"center\")) || (alignment.equals(\"middle\"))) {\r\n            return Component.CENTER;\r\n        }\r\n    }\r\n    return defaultAlign;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.MigLayout.setComponentConstraintsImpl",
	"Comment": "sets the component constraint for the component that already must behandled by this layout manager.see the class javadocs for information on how this string is formatted.",
	"Method": "void setComponentConstraintsImpl(Component comp,Object constr,boolean noCheck){\r\n    Container parent = comp.getParent();\r\n    if (noCheck == false && scrConstrMap.containsKey(comp) == false) {\r\n        throw new IllegalArgumentException(\"Component must already be added to parent!\");\r\n    }\r\n    ComponentWrapper cw = new CodenameOneMiGComponentWrapper(comp);\r\n    if (constr == null || constr instanceof String) {\r\n        String cStr = ConstraintParser.prepare((String) constr);\r\n        scrConstrMap.put(comp, constr);\r\n        ccMap.put(cw, ConstraintParser.parseComponentConstraint(cStr));\r\n    } else if (constr instanceof CC) {\r\n        scrConstrMap.put(comp, constr);\r\n        ccMap.put(cw, (CC) constr);\r\n    } else {\r\n        throw new IllegalArgumentException(\"Constraint must be String or ComponentConstraint: \" + constr.getClass().toString());\r\n    }\r\n    dirty = true;\r\n}"
}, {
	"Path": "com.codename1.io.rest.RequestBuilder.onErrorCodeJSON",
	"Comment": "in case of an error this method is invoked asynchronously to processthe error content with the json data",
	"Method": "RequestBuilder onErrorCodeJSON(ErrorCodeHandler<Map> err){\r\n    jsonErrorCallback = err;\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.components.SplitPane.setBottom",
	"Comment": "sets the component to be placed on the bottom of the split pane.",
	"Method": "void setBottom(Component cmp){\r\n    setBottomOrRightComponent(cmp);\r\n}"
}, {
	"Path": "com.codename1.testing.TestUtils.assertTextAreaStartingWith",
	"Comment": "asserts that we have a textarea with the a text starting with the given text and with the given name",
	"Method": "void assertTextAreaStartingWith(String name,String text){\r\n    if (verbose) {\r\n        log(\"assertTextAreaStartingWith(\" + name + \", \" + text + \")\");\r\n    }\r\n    TextArea l = (TextArea) findByName(name);\r\n    assertBool(l != null, \"Null area \" + text);\r\n    assertBool(l.getText().startsWith(text), \"assertTextArea: \\\"\" + l.getText() + \"\\\" is not starting with: \\\"\" + text + \"\\\"\");\r\n}"
}, {
	"Path": "com.codename1.ui.NavigationCommand.setNextForm",
	"Comment": "sets the form to navigate to when the actionperformed is invoked on thiscommand",
	"Method": "void setNextForm(Form nextForm){\r\n    this.nextForm = nextForm;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundBorder.shadowX",
	"Comment": "the position of the shadow on the x axis where 0.5f means the center and higher values draw it to the right side",
	"Method": "RoundBorder shadowX(float shadowX){\r\n    this.shadowX = shadowX;\r\n    modificationTime = System.currentTimeMillis();\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.Font.substringWidth",
	"Comment": "return the width of the given string subset in this font instance",
	"Method": "int substringWidth(String str,int offset,int len){\r\n    return Display.impl.stringWidth(font, str.substring(offset, offset + len));\r\n}"
}, {
	"Path": "com.codename1.ui.tree.Tree.buildBranch",
	"Comment": "adds the child components of a tree branch to the given container.",
	"Method": "void buildBranch(Object parent,int depth,Container destination){\r\n    Vector children = model.getChildren(parent);\r\n    int size = children.size();\r\n    Integer depthVal = new Integer(depth + 1);\r\n    for (int iter = 0; iter < size; iter++) {\r\n        final Object current = children.elementAt(iter);\r\n        Component nodeComponent = createNode(current, depth);\r\n        if (model.isLeaf(current)) {\r\n            destination.addComponent(nodeComponent);\r\n            bindNodeListener(new Handler(current), nodeComponent);\r\n        } else {\r\n            Container componentArea = new Container(new BorderLayout());\r\n            componentArea.addComponent(BorderLayout.NORTH, nodeComponent);\r\n            destination.addComponent(componentArea);\r\n            bindNodeListener(expansionListener, nodeComponent);\r\n        }\r\n        nodeComponent.putClientProperty(KEY_OBJECT, current);\r\n        nodeComponent.putClientProperty(KEY_PARENT, parent);\r\n        nodeComponent.putClientProperty(KEY_DEPTH, depthVal);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.topLeftMode",
	"Comment": "true to draw the top left corner rounded, false to draw it as a corner",
	"Method": "RoundRectBorder topLeftMode(boolean topLeft){\r\n    this.topLeft = topLeft;\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.javascript.JavascriptContext.release",
	"Comment": "decrements the reference count for the javascript object with the given id.this id was assigned inside the jsobject constructor and refers to the javascriptlookup table location for the javascript object.",
	"Method": "void release(int id){\r\n    String ID_KEY = JSObject.ID_KEY;\r\n    String PROP_REFCOUNT = JSObject.PROP_REFCOUNT;\r\n    String lt = jsLookupTable;\r\n    String p = lt + \"[\" + id + \"]\";\r\n    String js = \"var id = \" + id + \"; \" + \"if (typeof(id) != 'undefined' && typeof(\" + lt + \"[id]) != 'undefined' && \" + lt + \"[id].\" + ID_KEY + \"==id){\" + p + \".\" + PROP_REFCOUNT + \"--;\" + \"if (\" + p + \".\" + PROP_REFCOUNT + \"<=0){\" + \"delete \" + lt + \"[id];\" + \"}\" + \"}\";\r\n    exec(js, true);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundBorder.shadowY",
	"Comment": "the position of the shadow on the y axis where 0.5f means the center and higher values draw it to the bottom",
	"Method": "RoundBorder shadowY(float shadowY){\r\n    this.shadowY = shadowY;\r\n    modificationTime = System.currentTimeMillis();\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.io.services.ImageDownloadService.removeErrorListener",
	"Comment": "unbinds an error listener that will fire an instance of networkevent with an errorfor a specific fetch operation if applicable",
	"Method": "void removeErrorListener(ActionListener listener){\r\n    if (onErrorListeners == null) {\r\n        return;\r\n    }\r\n    onErrorListeners.removeListener(listener);\r\n    if (!onErrorListeners.hasListeners()) {\r\n        onErrorListeners = null;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.InteractionDialog.isFormMode",
	"Comment": "whether the interaction dialog uses the form layered pane of the regular layered pane",
	"Method": "boolean isFormMode(){\r\n    return formMode;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.lang.Character_.isSupplementaryCodePoint",
	"Comment": "a test for determining if the codepoint is within thesupplementary code point range.",
	"Method": "boolean isSupplementaryCodePoint(int codePoint){\r\n    return (MIN_SUPPLEMENTARY_CODE_POINT <= codePoint && MAX_CODE_POINT >= codePoint);\r\n}"
}, {
	"Path": "io.atomix.copycat.client.util.AddressSelector.matches",
	"Comment": "returns a boolean value indicating whether the servers in the first list match the servers in the second list.",
	"Method": "boolean matches(Collection<Address> left,Collection<Address> right){\r\n    if (left.size() != right.size())\r\n        return false;\r\n    for (Address address : left) {\r\n        if (!right.contains(address)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.conscrypt.AddressUtils.isLiteralIpAddress",
	"Comment": "returns true if the supplied hostname is an literal ip address.",
	"Method": "boolean isLiteralIpAddress(String hostname){\r\n    Pattern ipPattern = AddressUtils.ipPattern;\r\n    if (ipPattern == null) {\r\n        AddressUtils.ipPattern = ipPattern = Pattern.compile(IP_PATTERN);\r\n    }\r\n    return ipPattern.matcher(hostname).matches();\r\n}"
}, {
	"Path": "com.codename1.ui.List.setMutableRendererBackgrounds",
	"Comment": "indicates that the background of a cell renderer might mutate between one entry and the next,it is recommended that this flag remains false for performance reasons.",
	"Method": "void setMutableRendererBackgrounds(boolean mutableRendererBackgrounds){\r\n    this.mutableRendererBackgrounds = mutableRendererBackgrounds;\r\n}"
}, {
	"Path": "java.io.ByteArrayOutputStream.size",
	"Comment": "returns the total number of bytes written to this stream so far.",
	"Method": "int size(){\r\n    return count;\r\n}"
}, {
	"Path": "com.codename1.io.rest.RequestBuilder.getAsBytesAsync",
	"Comment": "executes the request asynchronously and writes the response to the providedcallback",
	"Method": "void getAsBytesAsync(Callback<Response<byte[]>> callback){\r\n    getAsBytesAsyncImpl(callback);\r\n}"
}, {
	"Path": "org.commonmark.internal.DocumentParser.processInlines",
	"Comment": "walk through a block & children recursively, parsing string content into inline content where appropriate.",
	"Method": "void processInlines(){\r\n    for (BlockParser blockParser : allBlockParsers) {\r\n        blockParser.parseInlines(inlineParser);\r\n    }\r\n}"
}, {
	"Path": "org.conscrypt.Platform.getClass",
	"Comment": "tries to return a class reference of one of the supplied class names.",
	"Method": "Class<?> getClass(String klasses){\r\n    for (String klass : klasses) {\r\n        try {\r\n            return Class.forName(klass);\r\n        } catch (Exception ignored) {\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.prometheus.client.bridge.Graphite.start",
	"Comment": "push samples from the given registry to graphite at the given interval.",
	"Method": "Thread start(CollectorRegistry registry,Thread start,CollectorRegistry registry,int intervalSeconds){\r\n    Thread thread = new PushThread(registry, intervalSeconds);\r\n    thread.setDaemon(true);\r\n    thread.start();\r\n    return thread;\r\n}"
}, {
	"Path": "org.conscrypt.AbstractConscryptSocket.getHostname",
	"Comment": "returns the hostname that was supplied during socket creation. no dns resolution isattempted before returning the hostname.",
	"Method": "String getHostname(){\r\n    return peerHostname;\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.showPacked",
	"Comment": "convenience method to show a dialog sized to match its content.",
	"Method": "Command showPacked(String position,boolean modal){\r\n    return showPackedImpl(position, modal, false);\r\n}"
}, {
	"Path": "com.codename1.ui.IndexedImage.rotate",
	"Comment": "unsupported in the current version, this method will be implemented in a future release",
	"Method": "Image rotate(int degrees){\r\n    throw new RuntimeException(\"The rotate method is not supported by indexed images at the moment\");\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayeredLayout.setInsetLeft",
	"Comment": "sets the left inset for this component to the prescribed value.",
	"Method": "LayeredLayout setInsetLeft(Component cmp,String inset){\r\n    getOrCreateConstraint(cmp).left().setValue(inset);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isMetaKeyDown",
	"Comment": "checks if the meta key is currently down.only relevant for desktop ports.",
	"Method": "boolean isMetaKeyDown(){\r\n    return impl.isMetaKeyDown();\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSParser.isMediaTypeSupported",
	"Comment": "returns true if the specified css media type is unsupported, false otherwise",
	"Method": "boolean isMediaTypeSupported(String media){\r\n    for (int i = 0; i < SUPPORTED_MEDIA_TYPES.length; i++) {\r\n        if (media.equalsIgnoreCase(SUPPORTED_MEDIA_TYPES[i])) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.l2fprod.common.swing.JCollapsiblePane.setContentPane",
	"Comment": "sets the content pane of this jcollapsiblepane. components must be addedto this content pane, not to the jcollapsiblepane.",
	"Method": "void setContentPane(Container contentPanel){\r\n    if (contentPanel == null) {\r\n        throw new IllegalArgumentException(\"Content pane can't be null\");\r\n    }\r\n    if (wrapper != null) {\r\n        super.remove(wrapper);\r\n    }\r\n    wrapper = new WrapperContainer(contentPanel);\r\n    super.addImpl(wrapper, BorderLayout.CENTER, -1);\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.LeaderState.initializing",
	"Comment": "returns a boolean value indicating whether the leader is still being initialized.",
	"Method": "boolean initializing(){\r\n    return appender.index() == 0 || context.getCommitIndex() < appender.index();\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setInlineSelectedStyles",
	"Comment": "registers inline styles that should be applied to the selected state of the component.",
	"Method": "void setInlineSelectedStyles(String styles){\r\n    if (styles != null && styles.trim().length() == 0) {\r\n        styles = null;\r\n    }\r\n    if (styles == null ? inlineSelectedStyles != null : !styles.equals(inlineSelectedStyles)) {\r\n        this.inlineSelectedStyles = styles;\r\n        unSelectedStyle = null;\r\n        selectedStyle = null;\r\n        disabledStyle = null;\r\n        pressedStyle = null;\r\n        allStyles = null;\r\n        if (!sizeRequestedByUser) {\r\n            preferredSize = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "android.support.v4.widget.SimpleCursorAdapter.setCursorToStringConverter",
	"Comment": "sets the converterused to convert the filtering cursorinto a string.",
	"Method": "void setCursorToStringConverter(CursorToStringConverter cursorToStringConverter){\r\n    mCursorToStringConverter = cursorToStringConverter;\r\n}"
}, {
	"Path": "mondrian.olap.Util.getAnnotation",
	"Comment": "returns an annotation of a particular class on a method. returns thedefault value if the annotation is not present, or in jdk 1.4.",
	"Method": "T getAnnotation(Method method,String annotationClassName,T defaultValue){\r\n    return compatible.getAnnotation(method, annotationClassName, defaultValue);\r\n}"
}, {
	"Path": "com.codename1.ui.Form.grabAnimationLock",
	"Comment": "allows grabbing a flag that is used by convention to indicate that you are running an exclusive animation.this is used by some code to prevent collision between optional animation",
	"Method": "boolean grabAnimationLock(){\r\n    if (globalAnimationLock) {\r\n        return false;\r\n    }\r\n    globalAnimationLock = true;\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLElement.setAssociatedComponents",
	"Comment": "sets the given component or vector of components to be associated with this element.this is used internally to apply css styling.",
	"Method": "void setAssociatedComponents(Object obj){\r\n    if (obj instanceof Vector) {\r\n        comps = (Vector) obj;\r\n    } else {\r\n        comps = new Vector();\r\n        comps.addElement(obj);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.getLinesToScroll",
	"Comment": "indicates the number of lines to scroll with every scroll operation",
	"Method": "int getLinesToScroll(){\r\n    return linesToScroll;\r\n}"
}, {
	"Path": "com.codename1.components.InfiniteProgress.setTintColor",
	"Comment": "the tinting color of the screen when the showinifiniteblocking method is invoked",
	"Method": "void setTintColor(int tintColor){\r\n    this.tintColor = tintColor;\r\n}"
}, {
	"Path": "com.codename1.util.AbstractStringBuilder.lastIndexOf",
	"Comment": "searches for the index of the specified character. the search for thecharacter starts at the specified offset and moves towards the beginning.",
	"Method": "int lastIndexOf(String string,int lastIndexOf,String subString,int start){\r\n    int subCount = subString.length();\r\n    if (subCount <= count && start >= 0) {\r\n        if (subCount > 0) {\r\n            if (start > count - subCount) {\r\n                start = count - subCount;\r\n            }\r\n            char firstChar = subString.charAt(0);\r\n            while (true) {\r\n                int i = start;\r\n                boolean found = false;\r\n                for (; i >= 0; --i) {\r\n                    if (value[i] == firstChar) {\r\n                        found = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!found) {\r\n                    return -1;\r\n                }\r\n                int o1 = i, o2 = 0;\r\n                while (++o2 < subCount && value[++o1] == subString.charAt(o2)) {\r\n                }\r\n                if (o2 == subCount) {\r\n                    return i;\r\n                }\r\n                start = i - 1;\r\n            }\r\n        }\r\n        return start < count ? start : count;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.codename1.components.StorageImage.create",
	"Comment": "creates an encoded image that maps to a storage file thus allowing toseamlessly cache images as needed. this only works reasonably well for very smallfiles.",
	"Method": "StorageImage create(String fileName,byte[] data,int width,int height,StorageImage create,String fileName,byte[] data,int width,int height,boolean keep,StorageImage create,String fileName,InputStream data,int width,int height,StorageImage create,String fileName,int width,int height,StorageImage create,String fileName,int width,int height,boolean keep){\r\n    return new StorageImage(fileName, width, height, keep);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.FlowLayout.isFillRows",
	"Comment": "indicates whether the layout manager should try to fill up the available spacein the row",
	"Method": "boolean isFillRows(){\r\n    return fillRows;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.getImageIO",
	"Comment": "returns the image io instance that allows scaling image files.",
	"Method": "ImageIO getImageIO(){\r\n    return null;\r\n}"
}, {
	"Path": "io.atomix.copycat.protocol.ConnectRequest.builder",
	"Comment": "returns a connect client request builder for an existing request.",
	"Method": "Builder builder(Builder builder,ConnectRequest request){\r\n    return new Builder(request);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.bottomLeftMode",
	"Comment": "true to draw the bottom left corner rounded, false to draw it as a corner",
	"Method": "RoundRectBorder bottomLeftMode(boolean bottomLeft){\r\n    this.bottomLeft = bottomLeft;\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.io.CacheMap.isAlwaysStore",
	"Comment": "when set to true indicates that all entries should be persisted to storagefor a constantly persisting cache",
	"Method": "boolean isAlwaysStore(){\r\n    return alwaysStore;\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetTableModel.setPropertySortingComparator",
	"Comment": "set the comparator used for sorting properties.if thischanges the comparator, the model will be rebuilt.",
	"Method": "void setPropertySortingComparator(Comparator comp){\r\n    Comparator old = propertySortingComparator;\r\n    propertySortingComparator = comp;\r\n    if (propertySortingComparator != old)\r\n        buildModel();\r\n}"
}, {
	"Path": "mondrian.olap.Util.uniquify",
	"Comment": "makes a name distinct from other names which have already been usedand shorter than a length limit, adds it to the list, and returns it.",
	"Method": "String uniquify(String name,int maxLength,Collection<String> nameList){\r\n    assert name != null;\r\n    if (name.length() > maxLength) {\r\n        name = name.substring(0, maxLength);\r\n    }\r\n    if (nameList.contains(name)) {\r\n        String aliasBase = name;\r\n        int j = 0;\r\n        while (true) {\r\n            name = aliasBase + j;\r\n            if (name.length() > maxLength) {\r\n                aliasBase = aliasBase.substring(0, aliasBase.length() - 1);\r\n                continue;\r\n            }\r\n            if (!nameList.contains(name)) {\r\n                break;\r\n            }\r\n            j++;\r\n        }\r\n    }\r\n    nameList.add(name);\r\n    return name;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.cleanup",
	"Comment": "rebuilds the htmlcomponent, this is called usually after a new page was loaded.",
	"Method": "void cleanup(){\r\n    if (document != null) {\r\n        cleanElementUI(document);\r\n    }\r\n    if (eventsListener != null) {\r\n        eventsListener.deregisterAll();\r\n    }\r\n    displayWidth = Display.getInstance().getDisplayWidth();\r\n    leftIndent = 0;\r\n    x = 0;\r\n    containers = new Vector();\r\n    marqueeComponents = new Vector();\r\n    marqueeMotion = null;\r\n    anchors = new Hashtable();\r\n    anchor = null;\r\n    accesskey = '\\0';\r\n    for (Enumeration e = accessKeys.keys(); e.hasMoreElements(); ) {\r\n        int keyCode = ((Integer) e.nextElement()).intValue();\r\n        getComponentForm().removeKeyListener(keyCode, this);\r\n    }\r\n    accessKeys.clear();\r\n    fieldsets = new Vector();\r\n    curTable = null;\r\n    tables = new Vector();\r\n    tableCells = new Vector();\r\n    ulLevel = 0;\r\n    olIndex = Integer.MIN_VALUE;\r\n    olUpperLevelIndex = new Vector();\r\n    listType = HTMLListIndex.LIST_NUMERIC;\r\n    underlineCount = 0;\r\n    strikethruCount = 0;\r\n    textDecoration = 0;\r\n    imageMapComponents = null;\r\n    imageMapData = null;\r\n    curImageMap = null;\r\n    superscript = 0;\r\n    maxSuperscript = 0;\r\n    counters = null;\r\n    font = defaultFont;\r\n    labelForID = null;\r\n    inputFields = new Hashtable();\r\n    link = null;\r\n    linkVisited = false;\r\n    mainLink = null;\r\n    firstFocusable = null;\r\n    curForm = null;\r\n    curTextArea = null;\r\n    curComboBox = null;\r\n    textfieldsToForms = new Hashtable();\r\n    optionTag = false;\r\n    optionSelected = false;\r\n    preTagCount = 0;\r\n    quoteTagCount = 0;\r\n    mainContainer = new Container();\r\n    if (pageUIID != null) {\r\n        mainContainer.setUIID(pageUIID);\r\n    }\r\n    if (pageStyle != null) {\r\n        applyPageStyle();\r\n    }\r\n    mainContainer.setScrollableX(false);\r\n    mainContainer.setLayout(new BoxLayout(BoxLayout.Y_AXIS));\r\n    curContainer = mainContainer;\r\n    curLine = new Container();\r\n    lastWasEmpty = false;\r\n    width = Display.getInstance().getDisplayWidth() - getStyle().getMargin(Component.LEFT) - getStyle().getPadding(Component.LEFT) - getStyle().getMargin(Component.RIGHT) - getStyle().getPadding(Component.RIGHT) - 10;\r\n    textColor = DEFAULT_TEXT_COLOR;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLLink.setParentChangesOnFocus",
	"Comment": "if this is called it indicates that when the link is focused, its parent should change to focused as well",
	"Method": "void setParentChangesOnFocus(){\r\n    if (parentLink == null) {\r\n        parentChangesOnFocus = true;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.table.Table.setCollapseBorder",
	"Comment": "indicates whether the borders of the cells should collapse to form a one line border",
	"Method": "void setCollapseBorder(boolean collapseBorder){\r\n    if (this.collapseBorder != collapseBorder) {\r\n        this.collapseBorder = collapseBorder;\r\n        if ((horizontalBorderSpacing != 0) || (verticalBorderSpacing != 0)) {\r\n            updateMargins();\r\n        }\r\n        repaint();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.registerCustomComponent",
	"Comment": "this methodallows the uibuilder to package a smaller portion of codename one into the jarand add support for additional 3rd party components to the gui builder. componentsmust be registered using their uiid name, by default all the content of com.codename1.ui isregistered however subpackages and 3rd party components are not.registration is essential for obfuscation to work properly!",
	"Method": "void registerCustomComponent(String name,Class cmp){\r\n    getComponentRegistry().put(name, cmp);\r\n}"
}, {
	"Path": "io.atomix.copycat.protocol.UnregisterResponse.builder",
	"Comment": "returns a keep alive response builder for an existing response.",
	"Method": "Builder builder(Builder builder,UnregisterResponse response){\r\n    return new Builder(response);\r\n}"
}, {
	"Path": "com.codename1.ui.Toolbar.getRightBarCommands",
	"Comment": "returns the commands within the right bar section which can be useful forthings like unit testing. notice that you should not mutate the commandsor the iteratable set in any way!",
	"Method": "Iterable<Command> getRightBarCommands(){\r\n    return getBarCommands(null);\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isControlKeyDown",
	"Comment": "checks if the control key is currently down.only relevant for desktop ports.",
	"Method": "boolean isControlKeyDown(){\r\n    return impl.isControlKeyDown();\r\n}"
}, {
	"Path": "com.codename1.ui.EncodedImage.scaledEncoded",
	"Comment": "performs scaling using imageio to generate an encoded image",
	"Method": "EncodedImage scaledEncoded(int width,int height){\r\n    if (width == getWidth() && height == getHeight()) {\r\n        return this;\r\n    }\r\n    if (width < 0) {\r\n        float ratio = ((float) height) / ((float) getHeight());\r\n        width = Math.max(1, (int) (getWidth() * ratio));\r\n    } else {\r\n        if (height < 0) {\r\n            float ratio = ((float) width) / ((float) getWidth());\r\n            height = Math.max(1, (int) (getHeight() * ratio));\r\n        }\r\n    }\r\n    try {\r\n        ImageIO io = ImageIO.getImageIO();\r\n        if (io != null) {\r\n            String format = ImageIO.FORMAT_PNG;\r\n            if (isOpaque() || !io.isFormatSupported(ImageIO.FORMAT_PNG)) {\r\n                if (io.isFormatSupported(ImageIO.FORMAT_JPEG)) {\r\n                    format = ImageIO.FORMAT_JPEG;\r\n                }\r\n            }\r\n            if (io.isFormatSupported(format)) {\r\n                ByteArrayOutputStream bo = new ByteArrayOutputStream();\r\n                io.save(new ByteArrayInputStream(getImageData()), bo, format, width, height, 0.9f);\r\n                EncodedImage img = EncodedImage.create(bo.toByteArray());\r\n                Util.cleanup(bo);\r\n                img.opaque = opaque;\r\n                img.opaqueChecked = opaqueChecked;\r\n                if (width > -1 && height > -1) {\r\n                    img.width = width;\r\n                    img.height = height;\r\n                }\r\n                return img;\r\n            }\r\n        }\r\n    } catch (IOException err) {\r\n        Log.e(err);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyBase.getLabel",
	"Comment": "the label of the property defaults to its name but can be changed to anything",
	"Method": "String getLabel(){\r\n    String l = (String) getClientProperty(\"cn1PropertyLabel\");\r\n    if (l == null) {\r\n        return getName();\r\n    }\r\n    return l;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Collections.synchronizedCollection",
	"Comment": "returns a wrapper on the specified collection which synchronizes allaccess to the collection.",
	"Method": "Collection<T> synchronizedCollection(Collection<T> collection){\r\n    if (collection == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    return new SynchronizedCollection<T>(collection);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.ConstraintParser.startsWithLenient",
	"Comment": "returns if a string shares at least a specified numbers startingcharacters with a match.",
	"Method": "int startsWithLenient(String s,String[] matches,int[] minChars,boolean acceptTrailing,int startsWithLenient,String s,String match,int minChars,boolean acceptTrailing){\r\n    if (s.charAt(0) != match.charAt(0)) {\r\n        return -1;\r\n    }\r\n    if (minChars == -1) {\r\n        minChars = match.length();\r\n    }\r\n    int sSz = s.length();\r\n    if (sSz < minChars) {\r\n        return -1;\r\n    }\r\n    int mSz = match.length();\r\n    int sIx = 0;\r\n    for (int mIx = 0; mIx < mSz; sIx++, mIx++) {\r\n        while (sIx < sSz && (s.charAt(sIx) == ' ' || s.charAt(sIx) == '_')) {\r\n            sIx++;\r\n        }\r\n        if (sIx >= sSz || s.charAt(sIx) != match.charAt(mIx)) {\r\n            return mIx >= minChars && (acceptTrailing || sIx >= sSz) && (sIx >= sSz || s.charAt(sIx - 1) == ' ') ? sIx : -1;\r\n        }\r\n    }\r\n    return sIx >= sSz || acceptTrailing || s.charAt(sIx) == ' ' ? sIx : -1;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.MemberState.canConfigure",
	"Comment": "returns a boolean indicating whether a configure request can be sent to the member.",
	"Method": "boolean canConfigure(){\r\n    return !configuring;\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSEngine.getInstance",
	"Comment": "returns the singleton instance of cssengine and creates it if necessary",
	"Method": "CSSEngine getInstance(){\r\n    if (instance == null) {\r\n        instance = new CSSEngine();\r\n    }\r\n    return instance;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.engine.CollectionQueryEngine.forEachIndexDo",
	"Comment": "iterates through all indexes and for each index invokes the given index operation. if the operation returnsfalse for any index, stops iterating and returns false. if the operation returns true for every index,returns true after all indexes have been iterated.",
	"Method": "boolean forEachIndexDo(IndexOperation<O> indexOperation){\r\n    Iterable<Index<O>> attributeIndexes = new ConcatenatingIterable<Index<O>>(this.attributeIndexes.values());\r\n    for (Index<O> index : attributeIndexes) {\r\n        boolean continueIterating = indexOperation.perform(index);\r\n        if (!continueIterating) {\r\n            return false;\r\n        }\r\n    }\r\n    Iterable<? extends Index<O>> compoundIndexes = this.compoundIndexes.values();\r\n    for (Index<O> index : compoundIndexes) {\r\n        boolean continueIterating = indexOperation.perform(index);\r\n        if (!continueIterating) {\r\n            return false;\r\n        }\r\n    }\r\n    Iterable<? extends Index<O>> standingQueryIndexes = this.standingQueryIndexes.values();\r\n    for (Index<O> index : standingQueryIndexes) {\r\n        boolean continueIterating = indexOperation.perform(index);\r\n        if (!continueIterating) {\r\n            return false;\r\n        }\r\n    }\r\n    return indexOperation.perform(fallbackIndex);\r\n}"
}, {
	"Path": "io.prometheus.client.exporter.common.TextFormat.write004",
	"Comment": "write out the text version 0.0.4 of the given metricfamilysamples.",
	"Method": "void write004(Writer writer,Enumeration<Collector.MetricFamilySamples> mfs){\r\n    while (mfs.hasMoreElements()) {\r\n        Collector.MetricFamilySamples metricFamilySamples = mfs.nextElement();\r\n        writer.write(\"# HELP \");\r\n        writer.write(metricFamilySamples.name);\r\n        writer.write(' ');\r\n        writeEscapedHelp(writer, metricFamilySamples.help);\r\n        writer.write('\\n');\r\n        writer.write(\"# TYPE \");\r\n        writer.write(metricFamilySamples.name);\r\n        writer.write(' ');\r\n        writer.write(typeString(metricFamilySamples.type));\r\n        writer.write('\\n');\r\n        for (Collector.MetricFamilySamples.Sample sample : metricFamilySamples.samples) {\r\n            writer.write(sample.name);\r\n            if (sample.labelNames.size() > 0) {\r\n                writer.write('{');\r\n                for (int i = 0; i < sample.labelNames.size(); ++i) {\r\n                    writer.write(sample.labelNames.get(i));\r\n                    writer.write(\"=\\\"\");\r\n                    writeEscapedLabelValue(writer, sample.labelValues.get(i));\r\n                    writer.write(\"\\\",\");\r\n                }\r\n                writer.write('}');\r\n            }\r\n            writer.write(' ');\r\n            writer.write(Collector.doubleToGoString(sample.value));\r\n            if (sample.timestampMs != null) {\r\n                writer.write(' ');\r\n                writer.write(sample.timestampMs.toString());\r\n            }\r\n            writer.write('\\n');\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.FullScreenAdService.setAllowWithoutNetwork",
	"Comment": "if set to true this flag allows the application to load even if an ad cannot be displayed",
	"Method": "void setAllowWithoutNetwork(boolean allowWithoutNetwork){\r\n    this.allowWithoutNetwork = allowWithoutNetwork;\r\n}"
}, {
	"Path": "com.codename1.ui.List.setMaxElementHeight",
	"Comment": "maximum number of elements shown in a list, this member is used to calculatethe list preferred size. if the number of elements in the model is larger thanthis then this value is used in the calculations.",
	"Method": "void setMaxElementHeight(int maxElementHeight){\r\n    this.maxElementHeight = maxElementHeight;\r\n}"
}, {
	"Path": "com.codename1.ui.Form.setEnableCursors",
	"Comment": "enable or disable custom cursors on this form.they are turned off by default since they incur some overhead.",
	"Method": "void setEnableCursors(boolean e){\r\n    this.enableCursors = e;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.pointerPressed",
	"Comment": "pushes a pointer press event with the given coordinates into codename one",
	"Method": "void pointerPressed(int[] x,int[] y){\r\n    if (impl.getCurrentForm() == null) {\r\n        return;\r\n    }\r\n    lastInteractionWasKeypad = false;\r\n    longPointerCharged = true;\r\n    longKeyPressTime = System.currentTimeMillis();\r\n    pointerX = x[0];\r\n    pointerY = y[0];\r\n    if (x.length == 1) {\r\n        addPointerEvent(POINTER_PRESSED, x[0], y[0]);\r\n    } else {\r\n        addPointerEvent(POINTER_PRESSED_MULTI, x, y);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setHideInPortrait",
	"Comment": "indicates that this component and all its children should be hidden when the device is switched to portrait mode",
	"Method": "void setHideInPortrait(boolean hideInPortrait){\r\n    this.hideInPortrait = hideInPortrait;\r\n}"
}, {
	"Path": "com.codename1.ui.util.Resources.listL10NLocales",
	"Comment": "returns an enumration of the locales supported by this resource id",
	"Method": "Enumeration listL10NLocales(String id){\r\n    return ((Hashtable) resources.get(id)).keys();\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.PlatformDefaults.getDefaultComponentGap",
	"Comment": "returns the default gap between two components that are in the same cell.",
	"Method": "BoundSize getDefaultComponentGap(ComponentWrapper comp,ComponentWrapper adjacentComp,int adjacentSide,String tag,boolean isLTR){\r\n    if (GAP_PROVIDER != null)\r\n        return GAP_PROVIDER.getDefaultGap(comp, adjacentComp, adjacentSide, tag, isLTR);\r\n    if (adjacentComp == null)\r\n        return null;\r\n    return (adjacentSide == 2 || adjacentSide == 4) ? RELATED_X : RELATED_Y;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.removeEdtErrorHandler",
	"Comment": "an error handler will receive an action event with the source exception from the edtonce an error handler is installed the default codename one error dialog will no longer appear",
	"Method": "void removeEdtErrorHandler(ActionListener e){\r\n    if (errorHandler != null) {\r\n        errorHandler.removeListener(e);\r\n        Collection v = errorHandler.getListenerCollection();\r\n        if (v == null || v.size() == 0) {\r\n            errorHandler = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Display.numAlphaLevels",
	"Comment": "return the number of alpha levels supported by the implementation.",
	"Method": "int numAlphaLevels(){\r\n    return impl.numAlphaLevels();\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.autoAdjust",
	"Comment": "auto adjust size of the dialog.this method is triggered from a sizechanged event.",
	"Method": "void autoAdjust(int w,int h){\r\n    if (autoAdjustDialogSize) {\r\n        growOrShrinkImpl(w, h);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Display.keyPressed",
	"Comment": "pushes a key press event with the given keycode into codename one",
	"Method": "void keyPressed(int keyCode){\r\n    if (impl.getCurrentForm() == null) {\r\n        return;\r\n    }\r\n    addSingleArgumentEvent(KEY_PRESSED, keyCode);\r\n    lastInteractionWasKeypad = lastInteractionWasKeypad || (keyCode != MenuBar.leftSK && keyCode != MenuBar.clearSK && keyCode != MenuBar.backSK);\r\n    keyRepeatCharged = (keyCode >= 0 || getGameAction(keyCode) > 0) || keyCode == impl.getClearKeyCode();\r\n    longPressCharged = keyRepeatCharged;\r\n    longKeyPressTime = System.currentTimeMillis();\r\n    keyRepeatValue = keyCode;\r\n    nextKeyRepeatEvent = System.currentTimeMillis() + keyRepeatInitialIntervalTime;\r\n    previousKeyPressed = lastKeyPressed;\r\n    lastKeyPressed = keyCode;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.getLayoutHeight",
	"Comment": "returns the height for layout manager purposes, this takes scrollinginto consideration unlike the getheight method.",
	"Method": "int getLayoutHeight(){\r\n    if (scrollableY) {\r\n        return Math.max(getHeight(), getPreferredH());\r\n    } else {\r\n        Container parent = getScrollableParent();\r\n        if (parent != null && parent.scrollableY) {\r\n            return Math.max(getHeight(), getPreferredH());\r\n        }\r\n        int height = getHeight();\r\n        if (height <= 1) {\r\n            return getPreferredH();\r\n        }\r\n        return height;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Stroke.setCapStyle",
	"Comment": "gets the cap style of the stroke.see visual examples of cap styles here.",
	"Method": "void setCapStyle(int capStyle){\r\n    this.capStyle = capStyle;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.LeaderStateTest.testLeaderStepsDownAndVotesOnHigherTerm",
	"Comment": "tests that a leader steps down when it receives a higher term.",
	"Method": "void testLeaderStepsDownAndVotesOnHigherTerm(){\r\n    runOnServer(() -> {\r\n        serverContext.setTerm(1).setLeader(0);\r\n        VoteRequest request = VoteRequest.builder().withTerm(2).withCandidate(members.get(1).hashCode()).withLogIndex(11).withLogTerm(2).build();\r\n        VoteResponse response = state.vote(request).get();\r\n        threadAssertEquals(serverContext.getTerm(), 2L);\r\n        threadAssertEquals(serverContext.getLastVotedFor(), members.get(1).hashCode());\r\n        threadAssertEquals(response.term(), 2L);\r\n        threadAssertTrue(response.voted());\r\n        threadAssertEquals(serverContext.getState(), CopycatServer.State.FOLLOWER);\r\n    });\r\n}"
}, {
	"Path": "com.codename1.ui.Component.removeFocusListener",
	"Comment": "deregisters interest in receiving callbacks for focus gained events",
	"Method": "void removeFocusListener(FocusListener l){\r\n    if (focusListeners == null) {\r\n        return;\r\n    }\r\n    focusListeners.removeListener(l);\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSEngine.applyStyleAttribute",
	"Comment": "applies the style attribute in the specified element, if exists",
	"Method": "void applyStyleAttribute(HTMLElement element,HTMLComponent htmlC){\r\n    String styleStr = element.getAttributeById(HTMLElement.ATTR_STYLE);\r\n    if (styleStr != null) {\r\n        CSSElement style = null;\r\n        styleStr = \"{\" + styleStr + \"}\";\r\n        try {\r\n            style = CSSParser.getInstance().parseCSS(new InputStreamReader(new ByteArrayInputStream(styleStr.getBytes())), htmlC);\r\n            applyStyle(element, style, htmlC);\r\n        } catch (IOException ex) {\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.RSSReader.getLimit",
	"Comment": "places a limit on the number of rss entries requested from the server",
	"Method": "int getLimit(){\r\n    return limit;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.paramString",
	"Comment": "returns a string representing the state of this component. this method is intended to be used only for debugging purposes, and the content and format of the returned string may vary between implementations. the returned string may be empty but may not be null.",
	"Method": "String paramString(){\r\n    return \"x=\" + getX() + \" y=\" + getY() + \" width=\" + getWidth() + \" height=\" + getHeight() + \" name=\" + getName();\r\n}"
}, {
	"Path": "com.codename1.charts.renderers.DefaultRenderer.getSeriesRenderers",
	"Comment": "returns an array of the simple renderers in the multiple renderer list.",
	"Method": "SimpleSeriesRenderer[] getSeriesRenderers(){\r\n    SimpleSeriesRenderer[] out = new SimpleSeriesRenderer[mRenderers.size()];\r\n    return mRenderers.toArray(out);\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetTableModel.addPropertiesToModel",
	"Comment": "add the specified properties to the model using the specified parent.",
	"Method": "void addPropertiesToModel(List localProperties,Item parent){\r\n    for (Iterator iter = localProperties.iterator(); iter.hasNext(); ) {\r\n        Property property = (Property) iter.next();\r\n        Item propertyItem = new Item(property, parent);\r\n        model.add(propertyItem);\r\n        Property[] subProperties = property.getSubProperties();\r\n        if (subProperties != null && subProperties.length > 0)\r\n            addPropertiesToModel(Arrays.asList(subProperties), propertyItem);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Stroke.getMiterLimit",
	"Comment": "gets the miter limit of the stroke. the miter limit controls the point at which a miter join automatically is converted to a bevel join. if the distance from the inner intersection point to the tip of the triangle measured in stroke widths is more than the miter limit, the join will be drawn in the bevel style.",
	"Method": "float getMiterLimit(){\r\n    return miterLimit;\r\n}"
}, {
	"Path": "java.util.ArrayList.remove",
	"Comment": "removes the object at the specified location from this list.",
	"Method": "E remove(int location,boolean remove,Object object){\r\n    int location = indexOf(object);\r\n    if (location >= 0) {\r\n        remove(location);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "ly.count.android.sdk.DeviceId.deviceIDEqualsNullSafe",
	"Comment": "helper method for null safe comparison of current device id and the one supplied to countly.init",
	"Method": "boolean deviceIDEqualsNullSafe(String id,Type type,DeviceId deviceId){\r\n    if (type == null || type == Type.DEVELOPER_SUPPLIED) {\r\n        final String deviceIdId = deviceId == null ? null : deviceId.getId();\r\n        return (deviceIdId == null && id == null) || (deviceIdId != null && deviceIdId.equals(id));\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "android.support.v4.view.MenuItemCompat.setActionView",
	"Comment": "set an action view for this menu item. an action view will be displayed in placeof an automatically generated menu item element in the ui when this item is shownas an action within a parent.",
	"Method": "MenuItem setActionView(MenuItem item,View view,MenuItem setActionView,MenuItem item,int resId,MenuItem setActionView,MenuItem item,View view,MenuItem setActionView,MenuItem item,int resId,MenuItem setActionView,MenuItem item,View view,MenuItem setActionView,MenuItem item,int resId,MenuItem setActionView,MenuItem item,View view,MenuItem setActionView,MenuItem item,int resId){\r\n    if (item instanceof SupportMenuItem) {\r\n        return ((SupportMenuItem) item).setActionView(resId);\r\n    }\r\n    return IMPL.setActionView(item, resId);\r\n}"
}, {
	"Path": "com.codename1.ui.EncodedImage.getImageData",
	"Comment": "returns the byte array data backing the image allowing the image to be storedand discarded completely from ram.",
	"Method": "byte[] getImageData(){\r\n    if (imageData.length == 1) {\r\n        return imageData[0];\r\n    }\r\n    int dpi = Display.getInstance().getDeviceDensity();\r\n    int bestFitOffset = 0;\r\n    int bestFitDPI = 0;\r\n    int dlen = dpis.length;\r\n    for (int iter = 0; iter < dlen; iter++) {\r\n        int currentDPI = dpis[iter];\r\n        if (dpi == currentDPI) {\r\n            bestFitOffset = iter;\r\n            break;\r\n        }\r\n        if (bestFitDPI != dpi && dpi >= currentDPI && currentDPI >= bestFitDPI) {\r\n            bestFitDPI = currentDPI;\r\n            bestFitOffset = iter;\r\n        }\r\n    }\r\n    lastTestedDPI = dpi;\r\n    return imageData[bestFitOffset];\r\n}"
}, {
	"Path": "com.codename1.tools.translator.BytecodeMethod.isMethodUsedTester",
	"Comment": "use this instead of ismethodused to compare traditional with new results",
	"Method": "boolean isMethodUsedTester(BytecodeMethod bm){\r\n    boolean oldway = isMethodUsedOldWay(bm);\r\n    boolean newway = isMethodUsed(bm);\r\n    if (oldway != newway) {\r\n        throw new Error(\"different result\");\r\n    }\r\n    return newway;\r\n}"
}, {
	"Path": "com.codename1.processing.Result.fromContent",
	"Comment": "internal method, do not use.create an evaluator object from a structuredcontent element.",
	"Method": "Result fromContent(StructuredContent content,Result fromContent,String content,String format,Result fromContent,InputStream content,String format,Result fromContent,Reader content,String format,Result fromContent,Element content,Result fromContent,Map content){\r\n    if (content == null) {\r\n        throw new IllegalArgumentException(\"content cannot be null\");\r\n    }\r\n    return fromContent(new MapContent(content));\r\n}"
}, {
	"Path": "cognitivej.vision.computervision.ComputerVisionBuilder.describeImage",
	"Comment": "this operation generates a description of an image in human readable language with complete sentences.the description is based on a collection of content tags, which are also returned by the operation. more than one description can be generated for each image.descriptions are ordered by their confidence score. all descriptions are in english.",
	"Method": "DescribeImageAction describeImage(int maxCandidates,String imageUrl,DescribeImageAction describeImage,int maxCandidates,InputStream image){\r\n    return new DescribeImageAction(cognitiveContext, maxCandidates, image);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.setId",
	"Comment": "sets the id used to reference this component in some constraints.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "void setId(String id){\r\n    this.id = id;\r\n}"
}, {
	"Path": "com.codename1.properties.SetProperty.add",
	"Comment": "adds a property value to the set and fires a change event if it changed the set",
	"Method": "K add(T v){\r\n    if (value.add(v)) {\r\n        firePropertyChanged();\r\n    }\r\n    return (K) parent.parent;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLLink.setFocus",
	"Comment": "overrides setfocus in order to focus all associated components",
	"Method": "void setFocus(boolean focused){\r\n    if (parentLink != null) {\r\n        parentLink.setChildrenFocused(focused);\r\n        parentLink.superSetFocus(focused);\r\n    } else {\r\n        setChildrenFocused(focused);\r\n        superSetFocus(focused);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.isAutoDispose",
	"Comment": "determines whether the execution of a command on this dialog implicitly disposes the dialog. this defaults to true which is a sensible default forsimple dialogs.",
	"Method": "boolean isAutoDispose(){\r\n    return autoDispose;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.callSerially",
	"Comment": "causes the runnable to be invoked on the event dispatch thread. this methodreturns immediately and will not wait for the serial call to occur",
	"Method": "void callSerially(Runnable r){\r\n    Display.INSTANCE.callSerially(r);\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.MemberState.canInstall",
	"Comment": "returns a boolean indicating whether an install request can be sent to the member.",
	"Method": "boolean canInstall(){\r\n    return !installing;\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.setUseNativeTextInput",
	"Comment": "indicates that native text input should be used in text field when in place editing is supported by the platform",
	"Method": "void setUseNativeTextInput(boolean aUseNativeTextInput){\r\n    useNativeTextInput = aUseNativeTextInput;\r\n}"
}, {
	"Path": "ly.count.android.sdk.CountlyStarRating.setStarRatingDisableAskingForEachAppVersion",
	"Comment": "set if automatic star rating should be disabled for each new version.by default automatic star rating will be shown for every new app version.if this is set to true, star rating will be shown only once over apps lifetime",
	"Method": "void setStarRatingDisableAskingForEachAppVersion(Context context,boolean disableAsking){\r\n    StarRatingPreferences srp = loadStarRatingPreferences(context);\r\n    srp.disabledAutomaticForNewVersions = disableAsking;\r\n    saveStarRatingPreferences(context, srp);\r\n}"
}, {
	"Path": "com.codename1.ui.Form.getActualPane",
	"Comment": "gets the actual pane, but first checks to see if the provided overlayresponds to events at the provided absolute x and y coordinates.",
	"Method": "Container getActualPane(Container getActualPane,Container overlay,int x,int y){\r\n    if (overlay != null && overlay.getResponderAt(x, y) != null) {\r\n        return overlay;\r\n    }\r\n    if (menuBar != null && menuBar.contains(x, y)) {\r\n        return menuBar;\r\n    }\r\n    return getActualPane();\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.installTar",
	"Comment": "installs a tar file from the build server into the file system storage so it can be used with respect for hierarchy",
	"Method": "void installTar(){\r\n    String p = Preferences.get(\"cn1$InstallKey\", null);\r\n    String buildKey = Display.getInstance().getProperty(\"build_key\", null);\r\n    if (p == null || !p.equals(buildKey)) {\r\n        FileSystemStorage fs = FileSystemStorage.getInstance();\r\n        String tardir = fs.getAppHomePath() + \"cn1html/\";\r\n        fs.mkdir(tardir);\r\n        TarInputStream is = new TarInputStream(Display.getInstance().getResourceAsStream(getClass(), \"/html.tar\"));\r\n        TarEntry t = is.getNextEntry();\r\n        byte[] data = new byte[8192];\r\n        while (t != null) {\r\n            String name = t.getName();\r\n            if (t.isDirectory()) {\r\n                fs.mkdir(tardir + name);\r\n            } else {\r\n                String path = tardir + name;\r\n                String dir = path.substring(0, path.lastIndexOf('/'));\r\n                if (!fs.exists(dir)) {\r\n                    mkdirs(fs, dir);\r\n                }\r\n                OutputStream os = fs.openOutputStream(tardir + name);\r\n                int count;\r\n                while ((count = is.read(data)) != -1) {\r\n                    os.write(data, 0, count);\r\n                }\r\n                os.close();\r\n            }\r\n            t = is.getNextEntry();\r\n        }\r\n        Util.cleanup(is);\r\n        Preferences.set(\"cn1$InstallKey\", buildKey);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.util.EmbeddedContainer.getEmbed",
	"Comment": "indicates the name of the container to embed into this container",
	"Method": "String getEmbed(){\r\n    return embed;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isTablet",
	"Comment": "indicates whether the device is a tablet, notice that this is often a guess",
	"Method": "boolean isTablet(){\r\n    return impl.isTablet();\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Border.getFocusedInstance",
	"Comment": "returns the focused version of the border if one is installed",
	"Method": "Border getFocusedInstance(){\r\n    if (focusBorder != null) {\r\n        return focusBorder;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.charts.util.MathHelper.getLabels",
	"Comment": "computes a reasonable set of labels for a data interval and number oflabels.",
	"Method": "List<Double> getLabels(double start,double end,int approxNumLabels){\r\n    List<Double> labels = new ArrayList<Double>();\r\n    if (approxNumLabels <= 0) {\r\n        return labels;\r\n    }\r\n    FORMAT.setMaximumFractionDigits(5);\r\n    double[] labelParams = computeLabels(start, end, approxNumLabels);\r\n    int numLabels = 1 + (int) ((labelParams[1] - labelParams[0]) / labelParams[2]);\r\n    for (int i = 0; i < numLabels; i++) {\r\n        double z = labelParams[0] + i * labelParams[2];\r\n        try {\r\n            z = FORMAT.parseDouble(FORMAT.format(z));\r\n        } catch (ParseException e) {\r\n        }\r\n        labels.add(z);\r\n    }\r\n    return labels;\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudObject.getAccessPermissions",
	"Comment": "the access permissions for an object can only be changed for an object in whichthe current user is the owner",
	"Method": "int getAccessPermissions(){\r\n    return accessPermissions;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.maxHeight",
	"Comment": "the maximum size for the component. the value will override any value that is set on the component itself.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC maxHeight(String size){\r\n    ver.setSize(LayoutUtil.derive(ver.getSize(), null, null, ConstraintParser.parseUnitValue(size, false)));\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.List.setFixedSelection",
	"Comment": "indicates whether selection is fixable to place in which case all theelements in the list move and selection stays in place.",
	"Method": "void setFixedSelection(int fixedSelection){\r\n    this.fixedSelection = fixedSelection;\r\n}"
}, {
	"Path": "com.codename1.properties.ListProperty.contains",
	"Comment": "returns true if the given element is contained in the list property",
	"Method": "boolean contains(T element){\r\n    return value.contains(element);\r\n}"
}, {
	"Path": "org.conscrypt.ct.Serialization.writeNumber",
	"Comment": "write a number to the output stream.the number is encoded in big endian order.",
	"Method": "void writeNumber(OutputStream output,long value,int width){\r\n    if (width < 0) {\r\n        throw new SerializationException(\"Negative width: \" + width);\r\n    }\r\n    if (width < 8 && value >= (1L << (8 * width))) {\r\n        throw new SerializationException(\"Number too large, \" + value + \" does not fit in \" + width + \" bytes\");\r\n    }\r\n    try {\r\n        while (width > 0) {\r\n            long shift = (width - 1) * 8L;\r\n            if (shift < Long.SIZE) {\r\n                output.write((byte) ((value >> shift) & 0xFF));\r\n            } else {\r\n                output.write(0);\r\n            }\r\n            width--;\r\n        }\r\n    } catch (IOException e) {\r\n        throw new SerializationException(e);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.shadowX",
	"Comment": "the position of the shadow on the x axis where 0.5f means the center and higher values draw it to the right side",
	"Method": "RoundRectBorder shadowX(float shadowX){\r\n    this.shadowX = shadowX;\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.protocol.AppendResponse.succeeded",
	"Comment": "returns a boolean indicating whether the append was successful.",
	"Method": "boolean succeeded(){\r\n    return succeeded;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.shadowY",
	"Comment": "the position of the shadow on the y axis where 0.5f means the center and higher values draw it to the bottom",
	"Method": "RoundRectBorder shadowY(float shadowY){\r\n    this.shadowY = shadowY;\r\n    return this;\r\n}"
}, {
	"Path": "mondrian.olap.Util.readFully",
	"Comment": "reads an input stream until it returns eof and returns the contents as anarray of bytes.",
	"Method": "String readFully(Reader rdr,int bufferSize,byte[] readFully,InputStream in,int bufferSize){\r\n    if (bufferSize <= 0) {\r\n        throw new IllegalArgumentException(\"Buffer size must be greater than 0\");\r\n    }\r\n    final byte[] buffer = new byte[bufferSize];\r\n    final ByteArrayOutputStream baos = new ByteArrayOutputStream(bufferSize);\r\n    int len;\r\n    while ((len = in.read(buffer)) != -1) {\r\n        baos.write(buffer, 0, len);\r\n    }\r\n    return baos.toByteArray();\r\n}"
}, {
	"Path": "android.support.v4.app.DialogFragment.show",
	"Comment": "display the dialog, adding the fragment using an existing transactionand then committing the transaction.",
	"Method": "void show(FragmentManager manager,String tag,int show,FragmentTransaction transaction,String tag){\r\n    mDismissed = false;\r\n    mShownByMe = true;\r\n    transaction.add(this, tag);\r\n    mViewDestroyed = false;\r\n    mBackStackId = transaction.commit();\r\n    return mBackStackId;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getNextFocusUp",
	"Comment": "allows us to determine which component will receive focus next when traversing with the up key.",
	"Method": "Component getNextFocusUp(){\r\n    return nextFocusUp;\r\n}"
}, {
	"Path": "ly.count.android.sdk.messaging.Message.getIntent",
	"Comment": "depending on message contents, different intents can be run.",
	"Method": "Intent getIntent(Context context,Class<? extends Activity> activityClass){\r\n    if (hasLink()) {\r\n        return new Intent(Intent.ACTION_VIEW, Uri.parse(getLink()));\r\n    } else if (hasMessage()) {\r\n        if (activityClass == null) {\r\n            activityClass = CountlyMessaging.getMainActivityClass(context);\r\n        }\r\n        if (activityClass != null) {\r\n            Intent intent = new Intent(context, activityClass);\r\n            intent.setFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP);\r\n            return intent;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.findDropTargetAt",
	"Comment": "recursively searches the container hierarchy for a drop target",
	"Method": "Component findDropTargetAt(int x,int y){\r\n    int count = getComponentCount();\r\n    for (int i = count - 1; i >= 0; i--) {\r\n        Component cmp = getComponentAt(i);\r\n        if (cmp.contains(x, y)) {\r\n            if (cmp.isDropTarget()) {\r\n                return cmp;\r\n            }\r\n            if (cmp instanceof Container) {\r\n                Component component = ((Container) cmp).findDropTargetAt(x, y);\r\n                if (component != null) {\r\n                    return component;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.connect",
	"Comment": "connects to a given url, returns a connection object to be used with the implementationlater",
	"Method": "Object connect(String url,boolean read,boolean write,Object connect,String url,boolean read,boolean write,int timeout){\r\n    return connect(url, read, write);\r\n}"
}, {
	"Path": "android.support.v4.accessibilityservice.AccessibilityServiceInfoCompat.getCapabilities",
	"Comment": "returns the bit mask of capabilities this accessibility service has such asbeing able to retrieve the active window content, etc.",
	"Method": "int getCapabilities(AccessibilityServiceInfo info,int getCapabilities,AccessibilityServiceInfo info,int getCapabilities,AccessibilityServiceInfo info,int getCapabilities,AccessibilityServiceInfo info,int getCapabilities,AccessibilityServiceInfo info){\r\n    return IMPL.getCapabilities(info);\r\n}"
}, {
	"Path": "org.conscrypt.ct.CTVerifier.getSCTsFromOCSPResponse",
	"Comment": "extract a list of signedcertificatetimestamp contained in an ocsp response.if the data is null, or parsing the ocsp response fails, an empty list is returned.individual scts which fail to be parsed are skipped.",
	"Method": "List<SignedCertificateTimestamp> getSCTsFromOCSPResponse(byte[] data,OpenSSLX509Certificate[] chain){\r\n    if (data == null || chain.length < 2) {\r\n        return Collections.emptyList();\r\n    }\r\n    byte[] extData = NativeCrypto.get_ocsp_single_extension(data, CTConstants.OCSP_SCT_LIST_OID, chain[0].getContext(), chain[0], chain[1].getContext(), chain[1]);\r\n    if (extData == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    try {\r\n        return getSCTsFromSCTList(Serialization.readDEROctetString(Serialization.readDEROctetString(extData)), SignedCertificateTimestamp.Origin.OCSP_RESPONSE);\r\n    } catch (SerializationException e) {\r\n        return Collections.emptyList();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.animations.MorphTransition.morph",
	"Comment": "morphs the component with the given source name in the source container hierarchy to the component with the given name in the destination hierarchy",
	"Method": "MorphTransition morph(String cmp,MorphTransition morph,String source,String to){\r\n    fromTo.put(source, to);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyIndex.isXmlTextElement",
	"Comment": "toggles whether a given property should act as a text element for this object",
	"Method": "boolean isXmlTextElement(PropertyBase p){\r\n    Boolean b = (Boolean) p.getClientProperty(\"xmlTextElement\");\r\n    return b != null && b.booleanValue();\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getGridPosX",
	"Comment": "this method should be implemented correctly by subclasses to make snap to grid functionality workas expected. returns the ideal grid x position closest to the current x position.",
	"Method": "int getGridPosX(){\r\n    return getScrollX();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Collections.checkType",
	"Comment": "checks if specified object is instance of specified class. used for adynamically typesafe view of the collections.",
	"Method": "E checkType(E obj,Class<? extends E> type){\r\n    if (obj != null && !type.isInstance(obj)) {\r\n        throw new IndexOutOfBoundsException(\"\" + obj.getClass().getName() + \" type: \" + type);\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "com.codename1.charts.renderers.SimpleSeriesRenderer.setDisplayBoundingPoints",
	"Comment": "sets if the bounding points of the first and last visible ones should be displayed.",
	"Method": "void setDisplayBoundingPoints(boolean display){\r\n    mDisplayBoundingPoints = display;\r\n}"
}, {
	"Path": "com.codename1.social.Login.setCallback",
	"Comment": "sets the login callback that will receive event callback notificationfrom the api",
	"Method": "void setCallback(LoginCallback lc){\r\n    loginCallback = lc;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getGridPosY",
	"Comment": "this method should be implemented correctly by subclasses to make snap to grid functionality workas expected. returns the ideal grid y position closest to the current y position.",
	"Method": "int getGridPosY(){\r\n    return getScrollY();\r\n}"
}, {
	"Path": "com.codename1.ui.animations.CommonTransitions.createSlide",
	"Comment": "creates a slide transition with the given duration and direction",
	"Method": "CommonTransitions createSlide(int type,boolean forward,int duration,CommonTransitions createSlide,int type,boolean forward,int duration,boolean drawDialogMenu){\r\n    CommonTransitions t = new CommonTransitions(TYPE_SLIDE);\r\n    t.slideType = type;\r\n    t.forward = forward;\r\n    t.speed = duration;\r\n    t.position = 0;\r\n    t.drawDialogMenu = drawDialogMenu;\r\n    return t;\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSParser.getImportURLByMediaType",
	"Comment": "returns the import url if the specified media matches, or null otherwise",
	"Method": "String getImportURLByMediaType(String token){\r\n    String url = token;\r\n    boolean mediaMatches = true;\r\n    int space = token.indexOf(' ');\r\n    if (space != -1) {\r\n        url = token.substring(0, space);\r\n        token = token.substring(space + 1);\r\n        mediaMatches = mediaTypeMatches(token);\r\n    }\r\n    if (mediaMatches) {\r\n        if (url.startsWith(\"url(\")) {\r\n            url = CSSEngine.getCSSUrl(url);\r\n        }\r\n        return url;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Container.animateHierarchyFade",
	"Comment": "animates a pending hierarchy of components into place, this effectively replaces revalidate with a more visual form of animation",
	"Method": "void animateHierarchyFade(int duration,int startingOpacity){\r\n    animateHierarchy(duration, false, startingOpacity, true);\r\n}"
}, {
	"Path": "org.conscrypt.Conscrypt.unwrap",
	"Comment": "exteneded unwrap method for multiple source and destination buffers.",
	"Method": "SSLEngineResult unwrap(SSLEngine engine,ByteBuffer[] srcs,ByteBuffer[] dsts,SSLEngineResult unwrap,SSLEngine engine,ByteBuffer[] srcs,int srcsOffset,int srcsLength,ByteBuffer[] dsts,int dstsOffset,int dstsLength){\r\n    return toConscrypt(engine).unwrap(srcs, srcsOffset, srcsLength, dsts, dstsOffset, dstsLength);\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.newLine",
	"Comment": "adds the container representing the current line to the current container and creates a new one",
	"Method": "void newLine(int align){\r\n    if (curLine.getComponentCount() == 0) {\r\n        curLine.setPreferredH(font.getHeight());\r\n    } else if (maxSuperscript != 0) {\r\n        for (int i = 0; i < curLine.getComponentCount(); i++) {\r\n            Component cmp = curLine.getComponentAt(i);\r\n            Style style = cmp.getStyle();\r\n            style.setMargin(Component.TOP, style.getMargin(Component.TOP) + maxSuperscript - style.getMargin(Component.BOTTOM));\r\n            style.setMargin(Component.BOTTOM, 0);\r\n            if (cmp instanceof HTMLLink) {\r\n                style = cmp.getSelectedStyle();\r\n                style.setMargin(Component.TOP, style.getMargin(Component.TOP) + maxSuperscript - style.getMargin(Component.BOTTOM));\r\n                style.setMargin(Component.BOTTOM, 0);\r\n                style = ((HTMLLink) cmp).getPressedStyle();\r\n                style.setMargin(Component.TOP, style.getMargin(Component.TOP) + maxSuperscript - style.getMargin(Component.BOTTOM));\r\n                style.setMargin(Component.BOTTOM, 0);\r\n            }\r\n        }\r\n        maxSuperscript = 0;\r\n    }\r\n    lastWasEmpty = (curLine.getComponentCount() == 0);\r\n    curContainer.addComponent(curLine);\r\n    curLine = new Container();\r\n    curLine.getStyle().setBgTransparency(0);\r\n    if (!FIXED_WIDTH) {\r\n        FlowLayout fl = new FlowLayout(align);\r\n        fl.setValign(Component.BOTTOM);\r\n        fl.setValignByRow(true);\r\n        curLine.setLayout(fl);\r\n    } else {\r\n        FlowLayout fl = (FlowLayout) curLine.getLayout();\r\n        fl.setValign(Component.BOTTOM);\r\n    }\r\n    curLine.setScrollableX(false);\r\n    curLine.getStyle().setMargin(Component.LEFT, leftIndent);\r\n    x = leftIndent;\r\n}"
}, {
	"Path": "com.codename1.ui.Label.setMaskName",
	"Comment": "determines the name of the mask from the image constants thus allowing the mask to be applied from the theme",
	"Method": "void setMaskName(String maskName){\r\n    this.maskName = maskName;\r\n    setMask(UIManager.getInstance().getThemeMaskConstant(maskName));\r\n    repaint();\r\n}"
}, {
	"Path": "java.lang.String.valueOf",
	"Comment": "returns the string representation of the long argument.the representation is exactly the one returned by the long.tostring method of one argument.",
	"Method": "java.lang.String valueOf(boolean b,java.lang.String valueOf,char c,java.lang.String valueOf,char[] data,java.lang.String valueOf,char[] data,int offset,int count,java.lang.String valueOf,double d,java.lang.String valueOf,float f,java.lang.String valueOf,int i,java.lang.String valueOf,long l,java.lang.String valueOf,java.lang.Object obj){\r\n    return obj == null ? \"null\" : obj.toString();\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.waitForFormName",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "void waitForFormName(String name){\r\n    TestUtils.waitForFormName(name);\r\n}"
}, {
	"Path": "libcore.java.security.StandardNames.assertDefaultCipherSuites",
	"Comment": "assert cipher suites match the default list in content and priority order and containonly cipher suites permitted by default.",
	"Method": "void assertDefaultCipherSuites(String[] cipherSuites){\r\n    assertValidCipherSuites(cipherSuites);\r\n    Set<String> expected = new TreeSet<String>(CIPHER_SUITES_DEFAULT);\r\n    Set<String> actual = new TreeSet<String>(Arrays.asList(cipherSuites));\r\n    assertEquals(expected, actual);\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.isTwoDigitMode",
	"Comment": "when set to true days will be rendered as 2 digits with 0 precedingsingle digit days",
	"Method": "boolean isTwoDigitMode(){\r\n    return twoDigitMode;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isVirtualKeyboardShowing",
	"Comment": "indicates if the virtual keyboard is currently showing or not",
	"Method": "boolean isVirtualKeyboardShowing(){\r\n    if (!isTouchScreenDevice()) {\r\n        return false;\r\n    }\r\n    return getDefaultVirtualKeyboard() != null && getDefaultVirtualKeyboard().isVirtualKeyboardShowing();\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.LC.setVisualPadding",
	"Comment": "if visual padding should be automatically used and compensated for by this layout instance.",
	"Method": "void setVisualPadding(boolean b){\r\n    this.visualPadding = b;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setSameWidth",
	"Comment": "places all of these components in the same width group, to remove a component fromthe group invoke this method with that component only.",
	"Method": "void setSameWidth(Component c){\r\n    if (c.length == 1) {\r\n        if (c[0].sameWidth != null) {\r\n            ArrayList<Component> lst = new ArrayList<Component>(Arrays.asList(c[0].sameWidth));\r\n            lst.remove(c[0]);\r\n            if (lst.size() == 1) {\r\n                lst.get(0).sameWidth = null;\r\n            } else {\r\n                if (lst.size() > 0) {\r\n                    Component[] cmps = new Component[lst.size()];\r\n                    lst.toArray(cmps);\r\n                    setSameWidth(cmps);\r\n                }\r\n            }\r\n            c[0].sameWidth = null;\r\n        }\r\n    } else {\r\n        for (Component cc : c) {\r\n            cc.sameWidth = c;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.conscrypt.javax.net.ssl.SSLSocketTest.test_SSLSocket_noncontiguousProtocols_useLower",
	"Comment": "tests that when the client has a hole in their supported protocol list, thelower span of contiguous protocols is used in practice.",
	"Method": "void test_SSLSocket_noncontiguousProtocols_useLower(){\r\n    TestSSLContext c = TestSSLContext.create();\r\n    SSLContext serverContext = c.serverContext;\r\n    SSLContext clientContext = c.clientContext;\r\n    SSLSocket client = (SSLSocket) clientContext.getSocketFactory().createSocket(c.host, c.port);\r\n    client.setEnabledProtocols(new String[] { \"TLSv1.2\", \"TLSv1\" });\r\n    final SSLSocket server = (SSLSocket) c.serverSocket.accept();\r\n    server.setEnabledProtocols(new String[] { \"TLSv1.2\", \"TLSv1.1\", \"TLSv1\" });\r\n    ExecutorService executor = Executors.newSingleThreadExecutor();\r\n    Future<Void> future = executor.submit(new Callable<Void>() {\r\n        @Override\r\n        public Void call() throws Exception {\r\n            server.startHandshake();\r\n            return null;\r\n        }\r\n    });\r\n    executor.shutdown();\r\n    client.startHandshake();\r\n    assertEquals(\"TLSv1\", client.getSession().getProtocol());\r\n    future.get();\r\n    client.close();\r\n    server.close();\r\n    c.close();\r\n}"
}, {
	"Path": "org.conscrypt.javax.net.ssl.SSLSocketTest.test_SSLSocket_noncontiguousProtocols_useLower",
	"Comment": "tests that when the client has a hole in their supported protocol list, thelower span of contiguous protocols is used in practice.",
	"Method": "void test_SSLSocket_noncontiguousProtocols_useLower(){\r\n    server.startHandshake();\r\n    return null;\r\n}"
}, {
	"Path": "org.conscrypt.Conscrypt.checkAvailability",
	"Comment": "checks that the conscrypt support is available for the system.",
	"Method": "void checkAvailability(){\r\n    NativeCrypto.checkAvailability();\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.isBackgroundImageDetermineSize",
	"Comment": "indicates if the bg image of a style should determine the minimum preferred size according to the theme",
	"Method": "boolean isBackgroundImageDetermineSize(){\r\n    return backgroundImageDetermineSize;\r\n}"
}, {
	"Path": "mondrian.rolap.RolapStar.prepareToLoadAggregates",
	"Comment": "place holder in case in the future we wish to be able toreload aggregates. in that case, if aggregates had already been loaded,i.e., this star has some aggstars, then those aggstars are cleared.",
	"Method": "void prepareToLoadAggregates(){\r\n    aggStars.clear();\r\n}"
}, {
	"Path": "com.codename1.ui.IndexedImage.load",
	"Comment": "loads a packaged image that was stored in a stream using the tobytearray method",
	"Method": "IndexedImage load(byte[] data){\r\n    try {\r\n        DataInputStream input = new DataInputStream(new ByteArrayInputStream(data));\r\n        int width = input.readShort();\r\n        int height = input.readShort();\r\n        int[] palette = new int[input.readByte() & 0xff];\r\n        int plen = palette.length;\r\n        for (int iter = 0; iter < plen; iter++) {\r\n            palette[iter] = input.readInt();\r\n        }\r\n        byte[] arr = new byte[width * height];\r\n        input.readFully(arr);\r\n        return new IndexedImage(width, height, palette, arr);\r\n    } catch (IOException ex) {\r\n        Log.e(ex);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.isExternal",
	"Comment": "returns if this component should have its bounds handled by an external source and not this layout manager.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "boolean isExternal(){\r\n    return external;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.ServerStateMachine.takeSnapshot",
	"Comment": "takes a snapshot of the state machine state if necessary.snapshots of the state machine are taken only once the log becomes compactable. this means snapshotsare largely dependent on the storage configuration and ensures that snapshots are not taken morefrequently than will benefit log compaction.",
	"Method": "void takeSnapshot(){\r\n    state.checkThread();\r\n    Snapshot currentSnapshot = state.getSnapshotStore().currentSnapshot();\r\n    if (pendingSnapshot == null && stateMachine instanceof Snapshottable && (currentSnapshot == null || (log.compactor().compactIndex() > currentSnapshot.index() && lastApplied > currentSnapshot.index()))) {\r\n        pendingSnapshot = state.getSnapshotStore().createSnapshot(lastApplied);\r\n        LOGGER.info(\"{} - Taking snapshot {}\", state.getCluster().member().address(), pendingSnapshot.index());\r\n        executor.executor().execute(() -> {\r\n            synchronized (pendingSnapshot) {\r\n                try (SnapshotWriter writer = pendingSnapshot.writer()) {\r\n                    ((Snapshottable) stateMachine).snapshot(writer);\r\n                }\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.getStrokeThickness",
	"Comment": "the thickness of the edge of the border if applicable, 0 if no stroke is needed",
	"Method": "float getStrokeThickness(){\r\n    return strokeThickness;\r\n}"
}, {
	"Path": "io.atomix.copycat.client.session.ClientSequencerTest.testSequenceEventAtCommand",
	"Comment": "tests sequencing an event that arrives before a command response.",
	"Method": "void testSequenceEventAtCommand(){\r\n    ClientSequencer sequencer = new ClientSequencer(new ClientSessionState(UUID.randomUUID().toString()));\r\n    long sequence = sequencer.nextRequest();\r\n    PublishRequest request = PublishRequest.builder().withSession(1).withEventIndex(2).withPreviousIndex(0).build();\r\n    CommandResponse response = CommandResponse.builder().withStatus(Response.Status.OK).withIndex(2).withEventIndex(2).build();\r\n    AtomicInteger run = new AtomicInteger();\r\n    sequencer.sequenceResponse(sequence, response, () -> assertEquals(run.getAndIncrement(), 1));\r\n    sequencer.sequenceEvent(request, () -> assertEquals(run.getAndIncrement(), 0));\r\n    assertEquals(run.get(), 2);\r\n}"
}, {
	"Path": "com.codename1.ui.Toolbar.isCenteredDefault",
	"Comment": "indicates whether the toolbar should be properly centered by default",
	"Method": "boolean isCenteredDefault(){\r\n    return centeredDefault;\r\n}"
}, {
	"Path": "com.codename1.properties.InstantUI.setTextFieldConstraint",
	"Comment": "sets the text field constraint for the property explicitly, notice that some constraints are implicit unless set manually e.g. numeric for numbers or password for fields with password in the name",
	"Method": "void setTextFieldConstraint(PropertyBase p,int cons){\r\n    p.putClientProperty(\"cn1$tconstraint\", cons);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.Layout.isOverlapSupported",
	"Comment": "this method returns true if the layout allows components tooverlap.",
	"Method": "boolean isOverlapSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.analytics.AnalyticsService.isAppsMode",
	"Comment": "apps mode allows improved analytics using the newer google analytics api designed for apps",
	"Method": "boolean isAppsMode(){\r\n    return appsMode;\r\n}"
}, {
	"Path": "com.codename1.components.Switch.setComponentState",
	"Comment": "if getcomponentstate returned a value the setter can update the value andrestore the prior state.",
	"Method": "void setComponentState(Object state){\r\n    value = ((Boolean) state).booleanValue();\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyIndex.setExcludeFromJSON",
	"Comment": "allows us to exclude a specific property from the tojson process",
	"Method": "void setExcludeFromJSON(PropertyBase pb,boolean exclude){\r\n    if (exclude) {\r\n        pb.putClientProperty(\"jsonExclude\", Boolean.TRUE);\r\n    } else {\r\n        pb.putClientProperty(\"jsonExclude\", null);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLElement.getUi",
	"Comment": "returns a vector of components associated with this htmlelement",
	"Method": "Vector getUi(){\r\n    if (comps == null) {\r\n        comps = new Vector();\r\n        Vector children = getChildren();\r\n        if (children != null) {\r\n            for (Enumeration e = children.elements(); e.hasMoreElements(); ) {\r\n                HTMLElement child = (HTMLElement) e.nextElement();\r\n                Vector childUI = child.getUi();\r\n                for (Enumeration e2 = childUI.elements(); e2.hasMoreElements(); ) {\r\n                    comps.addElement(e2.nextElement());\r\n                }\r\n            }\r\n        }\r\n        calculatedUi = true;\r\n    }\r\n    return comps;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.merge",
	"Comment": "merges style with all styles of components in current found set.",
	"Method": "ComponentSelector merge(Style style){\r\n    for (Component c : this) {\r\n        getStyle(c).merge(style);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.List.calculateElementSize",
	"Comment": "calculates the size of an element based on a forumla or on rendering prototype",
	"Method": "Dimension calculateElementSize(boolean selected,boolean addMargin){\r\n    if (renderingPrototype != null) {\r\n        Component unselected = renderer.getListCellRendererComponent(this, renderingPrototype, 0, selected);\r\n        if (addMargin) {\r\n            return unselected.getPreferredSizeWithMargin();\r\n        } else {\r\n            return unselected.getPreferredSize();\r\n        }\r\n    }\r\n    int width = 0;\r\n    int height = 0;\r\n    int elements = Math.min(listSizeCalculationSampleCount, model.getSize());\r\n    int marginY = 0;\r\n    int marginX = 0;\r\n    for (int iter = 0; iter < elements; iter++) {\r\n        Component cmp = renderer.getListCellRendererComponent(this, model.getItemAt(iter), iter, selected);\r\n        if (cmp instanceof Container) {\r\n            cmp.setShouldCalcPreferredSize(true);\r\n        }\r\n        Dimension d = cmp.getPreferredSize();\r\n        width = Math.max(width, d.getWidth());\r\n        height = Math.max(height, d.getHeight());\r\n        if (iter == 0) {\r\n            Style s = cmp.getStyle();\r\n            marginY = s.getVerticalMargins();\r\n            marginX = s.getHorizontalMargins();\r\n        }\r\n    }\r\n    return new Dimension(width + marginX, height + marginY);\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.ServerCommit.checkOpen",
	"Comment": "checks whether the commit is open and throws an exception if not.",
	"Method": "void checkOpen(){\r\n    Assert.state(references.get() > 0, \"commit not open\");\r\n}"
}, {
	"Path": "org.conscrypt.Conscrypt.setHandshakeListener",
	"Comment": "sets a listener on the given engine for completion of the tls handshake",
	"Method": "void setHandshakeListener(SSLEngine engine,HandshakeListener handshakeListener){\r\n    toConscrypt(engine).setHandshakeListener(handshakeListener);\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.addAppCrawlerName",
	"Comment": "add app crawler device name to the list of names that should be ignored",
	"Method": "void addAppCrawlerName(String crawlerName){\r\n    if (Countly.sharedInstance().isLoggingEnabled()) {\r\n        Log.d(Countly.TAG, \"Adding app crawler name: [\" + crawlerName + \"]\");\r\n    }\r\n    if (crawlerName != null && !crawlerName.isEmpty()) {\r\n        appCrawlerNames.add(crawlerName);\r\n    }\r\n}"
}, {
	"Path": "org.conscrypt.OpenSSLKey.fromPublicKeyPemInputStream",
	"Comment": "parse a public key in pem encoding from the provided input stream.",
	"Method": "OpenSSLKey fromPublicKeyPemInputStream(InputStream is){\r\n    OpenSSLBIOInputStream bis = new OpenSSLBIOInputStream(is, true);\r\n    try {\r\n        long keyCtx = NativeCrypto.PEM_read_bio_PUBKEY(bis.getBioContext());\r\n        if (keyCtx == 0L) {\r\n            return null;\r\n        }\r\n        return new OpenSSLKey(keyCtx);\r\n    } catch (Exception e) {\r\n        throw new InvalidKeyException(e);\r\n    } finally {\r\n        bis.release();\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.Segment.isLive",
	"Comment": "returns a boolean value indicating whether the given index was released from the segment.",
	"Method": "boolean isLive(long index){\r\n    assertSegmentOpen();\r\n    return offsetPredicate.test(offsetIndex.find(relativeOffset(index)));\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.OffsetIndexTest.testIndexContainsUncommitted",
	"Comment": "tests indexing an offset and checking whether the index contains the offset.",
	"Method": "void testIndexContainsUncommitted(){\r\n    OffsetIndex index = new DelegatingOffsetIndex(HeapBuffer.allocate(1024 * 8));\r\n    assertFalse(index.contains(1));\r\n    index.index(0, 1234);\r\n    index.index(1, 2345);\r\n    index.index(2, 3456);\r\n    assertTrue(index.contains(1));\r\n    assertFalse(index.contains(4));\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setNextFocusRight",
	"Comment": "allows us to determine which component will receive focus next when traversing with the right key",
	"Method": "void setNextFocusRight(Component nextFocusRight){\r\n    this.nextFocusRight = nextFocusRight;\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyIndex.registerExternalizable",
	"Comment": "invoking this method will allow a property object to be serialized seamlessly",
	"Method": "void registerExternalizable(){\r\n    Util.register(getName(), parent.getClass());\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Collections.synchronizedSet",
	"Comment": "returns a wrapper on the specified set which synchronizes all access tothe set.",
	"Method": "Set<E> synchronizedSet(Set<E> set){\r\n    if (set == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    return new SynchronizedSet<E>(set);\r\n}"
}, {
	"Path": "mondrian.rolap.RolapStar.reOrderAggStarList",
	"Comment": "reorder the list of aggregate stars. this should be called if thealgorithm used to order the aggstars has been changed.",
	"Method": "void reOrderAggStarList(){\r\n    List<AggStar> oldList = new ArrayList<AggStar>(aggStars);\r\n    aggStars.clear();\r\n    for (AggStar aggStar : oldList) {\r\n        addAggStar(aggStar);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.setDefaultDialogTransitionOut",
	"Comment": "allows us to define a default animation that will draw the transition forexiting a dialog",
	"Method": "void setDefaultDialogTransitionOut(Transition defaultDialogTransitionOut){\r\n    this.defaultDialogTransitionOut = defaultDialogTransitionOut;\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.setLinesToScroll",
	"Comment": "indicates the number of lines to scroll with every scroll operation",
	"Method": "void setLinesToScroll(int linesToScroll){\r\n    if (linesToScroll < 1) {\r\n        throw new IllegalArgumentException(\"lines to scroll has to be >= 1\");\r\n    }\r\n    this.linesToScroll = linesToScroll;\r\n}"
}, {
	"Path": "org.conscrypt.Conscrypt.exportKeyingMaterial",
	"Comment": "exports a value derived from the tls master secret as described in rfc 5705.",
	"Method": "byte[] exportKeyingMaterial(SSLSocket socket,String label,byte[] context,int length,byte[] exportKeyingMaterial,SSLEngine engine,String label,byte[] context,int length){\r\n    return toConscrypt(engine).exportKeyingMaterial(label, context, length);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.registerPushOnServer",
	"Comment": "sends a server request to register push support. this is a method for useby implementations.",
	"Method": "void registerPushOnServer(String id,String applicationKey,byte pushType,String udid,String packageName){\r\n    registerServerPush(id, applicationKey, pushType, udid, packageName);\r\n}"
}, {
	"Path": "com.codename1.ui.Command.createMaterial",
	"Comment": "creates a new command instance that encapsulates the action listener and details, the mainvalue of this approach is in our ability to write commands using the shorthand lambda syntaxof java 8.",
	"Method": "Command createMaterial(String name,char icon,ActionListener ev){\r\n    Command cmd = new Command(name) {\r\n        @Override\r\n        public void actionPerformed(ActionEvent evt) {\r\n            ev.actionPerformed(evt);\r\n        }\r\n    };\r\n    cmd.setMaterialIcon(icon);\r\n    return cmd;\r\n}"
}, {
	"Path": "com.codename1.ui.Command.createMaterial",
	"Comment": "creates a new command instance that encapsulates the action listener and details, the mainvalue of this approach is in our ability to write commands using the shorthand lambda syntaxof java 8.",
	"Method": "Command createMaterial(String name,char icon,ActionListener ev){\r\n    ev.actionPerformed(evt);\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudStorage.deleteAllCloudFilesBefore",
	"Comment": "deletes all the cloud files before the given time stamp for the givendevelopment account. notice that this method is meant for internal use and not for distributable apps since it includes your developer account.this method works in a background server process and returns immediately.",
	"Method": "void deleteAllCloudFilesBefore(long timestamp,String developerAccount,String developerPassword){\r\n    if (CloudPersona.getCurrentPersona().getToken() == null) {\r\n        return;\r\n    }\r\n    ConnectionRequest req = new ConnectionRequest();\r\n    req.setPost(false);\r\n    req.setFailSilently(true);\r\n    req.setUrl(SERVER_URL + \"/purgeCloudFiles\");\r\n    req.addArgument(\"d\", \"\" + timestamp);\r\n    req.addArgument(\"u\", developerAccount);\r\n    req.addArgument(\"p\", developerPassword);\r\n    NetworkManager.getInstance().addToQueue(req);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.runtime.java.lang.Class_.isAnnotationPresent",
	"Comment": "returns true if an annotation for the specified type is present on this element, else false.",
	"Method": "boolean isAnnotationPresent(Class c,Class<? extends Annotation> annotationType){\r\n    return getAnnotation(c, annotationType) != null;\r\n}"
}, {
	"Path": "com.codename1.components.RSSReader.setLimit",
	"Comment": "places a limit on the number of rss entries requested from the server",
	"Method": "void setLimit(int limit){\r\n    this.limit = limit;\r\n}"
}, {
	"Path": "com.codename1.ui.List.getMaxElementHeight",
	"Comment": "maximum number of elements shown in a list, this member is used to calculatethe list preferred size. if the number of elements in the model is larger thanthis then this value is used in the calculations.",
	"Method": "int getMaxElementHeight(){\r\n    return maxElementHeight;\r\n}"
}, {
	"Path": "android.support.v4.database.DatabaseUtilsCompat.concatenateWhere",
	"Comment": "concatenates two sql where clauses, handling empty or null values.",
	"Method": "String concatenateWhere(String a,String b){\r\n    if (TextUtils.isEmpty(a)) {\r\n        return b;\r\n    }\r\n    if (TextUtils.isEmpty(b)) {\r\n        return a;\r\n    }\r\n    return \"(\" + a + \") AND (\" + b + \")\";\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.handleEDTException",
	"Comment": "invoked when an exception occurs on the edt, allows the implementation totake control of the device to produce testing information.",
	"Method": "boolean handleEDTException(Throwable err){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getDragImage",
	"Comment": "this method returns an image representing the dragged component, it can be overriden by subclasses to customize the lookof the image, the image will be overlaid on top of the form during a drag and drop operation",
	"Method": "Image getDragImage(){\r\n    Image draggedImage = Image.createImage(getWidth(), getHeight(), 0x00ff7777);\r\n    Graphics g = draggedImage.getGraphics();\r\n    g.translate(-getX(), -getY());\r\n    paintComponentBackground(g);\r\n    paint(g);\r\n    if (isBorderPainted()) {\r\n        paintBorder(g);\r\n    }\r\n    g.translate(getX(), getY());\r\n    draggedImage = draggedImage.modifyAlpha((byte) 0x55, 0xff7777);\r\n    return draggedImage;\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.isPendingCommit",
	"Comment": "returns true if the text field is waiting for a commit on editing",
	"Method": "boolean isPendingCommit(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.contacts.Contact.getPrimaryEmail",
	"Comment": "gets the primary email of this contact, notice this can be null even thoughthe contact has emails declared",
	"Method": "String getPrimaryEmail(){\r\n    if (primaryEmail == null && emails != null) {\r\n        Collection c = emails.values();\r\n        if (c.size() > 0) {\r\n            return (String) c.iterator().next();\r\n        }\r\n    }\r\n    return primaryEmail;\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudStorage.getUrlForCloudFileId",
	"Comment": "converts a file id to a url with which the file can be downloaded, notice that the file url is world readable!",
	"Method": "String getUrlForCloudFileId(String fileId){\r\n    return SERVER_URL + \"/fileStoreDownload?i=\" + fileId;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.DefaultLookAndFeel.getTextFieldCursorX",
	"Comment": "calculates the position of the text field cursor within the string",
	"Method": "int getTextFieldCursorX(TextArea ta){\r\n    Style style = ta.getStyle();\r\n    Font f = style.getFont();\r\n    String displayText = getTextFieldString(ta);\r\n    String inputMode = ta.getInputMode();\r\n    int inputModeWidth = f.stringWidth(inputMode);\r\n    if (ta.isQwertyInput() || Display.getInstance().isVirtualKeyboardShowing()) {\r\n        inputMode = \"\";\r\n        inputModeWidth = 0;\r\n    }\r\n    int xPos = 0;\r\n    int cursorCharPosition = ta.getCursorX();\r\n    int cursorX = 0;\r\n    int x = 0;\r\n    if (reverseAlignForBidi(ta) == Component.RIGHT) {\r\n        if (Display.getInstance().isBidiAlgorithm()) {\r\n            cursorCharPosition = Display.getInstance().getCharLocation(displayText, cursorCharPosition - 1);\r\n            if (cursorCharPosition == -1) {\r\n                xPos = f.stringWidth(displayText);\r\n            } else {\r\n                displayText = Display.getInstance().convertBidiLogicalToVisual(displayText);\r\n                if (!isRTLOrWhitespace((displayText.charAt(cursorCharPosition)))) {\r\n                    cursorCharPosition++;\r\n                }\r\n                xPos = f.stringWidth(displayText.substring(0, cursorCharPosition));\r\n            }\r\n        }\r\n        int displayX = ta.getX() + ta.getWidth() - style.getPaddingLeft(ta.isRTL()) - f.stringWidth(displayText);\r\n        cursorX = displayX + xPos;\r\n        x = 0;\r\n    } else {\r\n        if (cursorCharPosition > 0) {\r\n            cursorCharPosition = Math.min(displayText.length(), cursorCharPosition);\r\n            xPos = f.stringWidth(displayText.substring(0, cursorCharPosition));\r\n        }\r\n        cursorX = ta.getX() + style.getPaddingLeft(ta.isRTL()) + xPos;\r\n        if (ta.isSingleLineTextArea() && ta.getWidth() > (f.getHeight() * 2) && cursorX >= ta.getWidth() - inputModeWidth - style.getPaddingLeft(ta.isRTL())) {\r\n            if (x + xPos >= ta.getWidth() - inputModeWidth - style.getPaddingLeftNoRTL() - style.getPaddingRightNoRTL()) {\r\n                x = ta.getWidth() - inputModeWidth - style.getPaddingLeftNoRTL() - style.getPaddingRightNoRTL() - xPos - 1;\r\n            }\r\n        }\r\n    }\r\n    return cursorX + x;\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.setMenuCellRenderer",
	"Comment": "the menubar default implementation shows the menu commands in a list contained in a dialog.this method replaces the menu listcellrenderer of the menu list.",
	"Method": "void setMenuCellRenderer(ListCellRenderer menuCellRenderer){\r\n    this.menuCellRenderer = menuCellRenderer;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.createBrowserComponent",
	"Comment": "if the implementation supports the creation of a browser component it should be returned in thismethod",
	"Method": "PeerComponent createBrowserComponent(Object browserComponent){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.location.Geofence.createDistanceComparator",
	"Comment": "creates a comparator for sorting geofences from the given reference point.",
	"Method": "Comparator<Geofence> createDistanceComparator(Geofence refRegion,Comparator<Geofence> createDistanceComparator,Location refPoint){\r\n    return new Comparator<Geofence>() {\r\n        public int compare(Geofence o1, Geofence o2) {\r\n            double d1 = Math.max(0, refPoint.getDistanceTo(o1.getLoc()) - o1.getRadius());\r\n            double d2 = Math.max(0, refPoint.getDistanceTo(o2.getLoc()) - o2.getRadius());\r\n            return d1 < d2 ? -1 : d2 < d1 ? 1 : 0;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.codename1.location.Geofence.createDistanceComparator",
	"Comment": "creates a comparator for sorting geofences from the given reference point.",
	"Method": "Comparator<Geofence> createDistanceComparator(Geofence refRegion,Comparator<Geofence> createDistanceComparator,Location refPoint){\r\n    double d1 = Math.max(0, refPoint.getDistanceTo(o1.getLoc()) - o1.getRadius());\r\n    double d2 = Math.max(0, refPoint.getDistanceTo(o2.getLoc()) - o2.getRadius());\r\n    return d1 < d2 ? -1 : d2 < d1 ? 1 : 0;\r\n}"
}, {
	"Path": "com.codename1.ui.tree.Tree.getTreeState",
	"Comment": "gets the state of the tree in a format that can be restored laterby either the same tree or a different tree whose model includes the samenodes.",
	"Method": "TreeState getTreeState(){\r\n    State out = new State();\r\n    out.extractStateFrom(this);\r\n    return out;\r\n}"
}, {
	"Path": "org.conscrypt.SSLParametersImpl.getWantClientAuth",
	"Comment": "returns the value indicating if the peer with this parameterstuned to request client authentication",
	"Method": "boolean getWantClientAuth(){\r\n    return want_client_auth;\r\n}"
}, {
	"Path": "com.codename1.maps.BoundingBox.extend",
	"Comment": "create a new bounding box that extends this bounding box with the given bounding box",
	"Method": "BoundingBox extend(BoundingBox other){\r\n    double north = Math.max(getNorthEast().getLatitude(), other.getNorthEast().getLatitude());\r\n    double east = Math.max(getNorthEast().getLongitude(), other.getNorthEast().getLongitude());\r\n    double south = Math.min(getSouthWest().getLatitude(), other.getSouthWest().getLatitude());\r\n    double west = Math.min(getSouthWest().getLongitude(), other.getSouthWest().getLongitude());\r\n    return new BoundingBox(new Coord(south, west, projected()), new Coord(north, east, projected()));\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.getAbsoluteAlignment",
	"Comment": "returns the absolute alignment of the textareain rtl left alignment is actually right, but this method returns the actual alignment",
	"Method": "int getAbsoluteAlignment(){\r\n    int a = getAlignment();\r\n    if (isRTL()) {\r\n        switch(a) {\r\n            case RIGHT:\r\n                return LEFT;\r\n            case LEFT:\r\n                return RIGHT;\r\n        }\r\n    }\r\n    return a;\r\n}"
}, {
	"Path": "mondrian.olap.Util.deprecated",
	"Comment": "insert a call to this method if you want to flag a piece ofundesirable code.",
	"Method": "T deprecated(T reason,T deprecated,T reason,boolean fail){\r\n    if (fail) {\r\n        throw new UnsupportedOperationException(reason.toString());\r\n    } else {\r\n        return reason;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.javascript.JavascriptContext.addCallback",
	"Comment": "adds a jsfunction to handle calls to the specified javascript object.this essentially installed a javascript proxy method that sends a message viaa navigation callback to the javascriptcontext so that it can cause javacode to be executed.",
	"Method": "void addCallback(JSObject source,String method,JSFunction callback,boolean async){\r\n    String key = source.toJSPointer() + \".\" + method;\r\n    callbacks.put(key, callback);\r\n    String id = JSObject.ID_KEY;\r\n    String self = source.toJSPointer();\r\n    String isSimulator = Display.getInstance().isSimulator() ? \"true\" : \"false\";\r\n    String js = self + \".\" + method + \"=function(){\" + \"var len=arguments.length;var url='https://www.codenameone.com/!cn1command/\" + self + \".\" + method + \"?'; \" + \"for (var i=0; i<len; i++){\" + \"var val = arguments[i]; var strval=val;\" + \"if ( (typeof(val) == 'object') || (typeof(val) == 'function')){ \" + \"var id = val.\" + id + \"; \" + \"if (typeof(id)=='undefined' || typeof(\" + jsLookupTable + \"[id]) == 'undefined' || \" + jsLookupTable + \"[id].\" + id + \"!=id){\" + jsLookupTable + \".push(val); id=\" + jsLookupTable + \".indexOf(val); Object.defineProperty(val,\\\"\" + id + \"\\\",{value:id, enumerable:false});\" + \"}\" + \"strval='\" + jsLookupTable + \"['+id+']'\" + \"}\" + \"url += encodeURIComponent(typeof(val))+'='+encodeURIComponent(strval);\" + \"if (i < len-1){ url += '&';}\" + \"} if (window.cn1application && window.cn1application.shouldNavigate) { window.cn1application.shouldNavigate(url) } else if (\" + isSimulator + \") {window._cn1ready = window._cn1ready || []; window._cn1ready.push(function(){window.cn1application.shouldNavigate(url)});} else {window.location.href=url}\" + \"}\";\r\n    exec(js, async);\r\n}"
}, {
	"Path": "com.codename1.util.TDivision.slidingWindow",
	"Comment": "implements the montgomery modular exponentiation based in the slidingwindows algorithm and the mongomeryreduction.",
	"Method": "TBigInteger slidingWindow(TBigInteger x2,TBigInteger a2,TBigInteger exponent,TBigInteger modulus,int n2){\r\n    TBigInteger[] pows = new TBigInteger[8];\r\n    TBigInteger res = x2;\r\n    int lowexp;\r\n    TBigInteger x3;\r\n    int acc3;\r\n    pows[0] = a2;\r\n    x3 = monPro(a2, a2, modulus, n2);\r\n    for (int i = 1; i <= 7; i++) {\r\n        pows[i] = monPro(pows[i - 1], x3, modulus, n2);\r\n    }\r\n    for (int i = exponent.bitLength() - 1; i >= 0; i--) {\r\n        if (TBitLevel.testBit(exponent, i)) {\r\n            lowexp = 1;\r\n            acc3 = i;\r\n            for (int j = Math.max(i - 3, 0); j <= i - 1; j++) {\r\n                if (TBitLevel.testBit(exponent, j)) {\r\n                    if (j < acc3) {\r\n                        acc3 = j;\r\n                        lowexp = (lowexp << (i - j)) ^ 1;\r\n                    } else {\r\n                        lowexp = lowexp ^ (1 << (j - acc3));\r\n                    }\r\n                }\r\n            }\r\n            for (int j = acc3; j <= i; j++) {\r\n                res = monPro(res, res, modulus, n2);\r\n            }\r\n            res = monPro(pows[(lowexp - 1) >> 1], res, modulus, n2);\r\n            i = acc3;\r\n        } else {\r\n            res = monPro(res, res, modulus, n2);\r\n        }\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.entity.MapEntity.hashCode",
	"Comment": "returns the hashcode of the wrapped map which was cached when this mapentity was created.",
	"Method": "int hashCode(){\r\n    return cachedHashCode;\r\n}"
}, {
	"Path": "android.support.v4.app.TaskStackBuilder.addNextIntent",
	"Comment": "add a new intent to the task stack. the most recently added intent will invokethe activity at the top of the final task stack.",
	"Method": "TaskStackBuilder addNextIntent(Intent nextIntent){\r\n    mIntents.add(nextIntent);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.FlowLayout.setFillRows",
	"Comment": "indicates whether the layout manager should try to fill up the available spacein the row",
	"Method": "void setFillRows(boolean fillRows){\r\n    this.fillRows = fillRows;\r\n}"
}, {
	"Path": "mondrian.olap.fun.FunUtil.hierarchizeMemberList",
	"Comment": "sorts a list of members into hierarchical order. the members must belongto the same dimension.",
	"Method": "void hierarchizeMemberList(List<Member> memberList,boolean post){\r\n    if (memberList.size() <= 1) {\r\n        return;\r\n    }\r\n    if (memberList.get(0).getDimension().isHighCardinality()) {\r\n        return;\r\n    }\r\n    Comparator<Member> comparator = new HierarchizeComparator(post);\r\n    Collections.sort(memberList, comparator);\r\n}"
}, {
	"Path": "org.conscrypt.javax.crypto.CipherTest.getCipherTransformationWithNoPadding",
	"Comment": "gets the cipher transformation with the same algorithm and mode as the provided one butwhich uses no padding.",
	"Method": "String getCipherTransformationWithNoPadding(String transformation){\r\n    int paddingModeDelimiterIndex = transformation.lastIndexOf('/');\r\n    if (paddingModeDelimiterIndex == -1) {\r\n        fail(\"No padding mode delimiter: \" + transformation);\r\n    }\r\n    String paddingMode = transformation.substring(paddingModeDelimiterIndex + 1);\r\n    if (!paddingMode.toLowerCase().endsWith(\"padding\")) {\r\n        fail(\"No padding mode specified:\" + transformation);\r\n    }\r\n    return transformation.substring(0, paddingModeDelimiterIndex) + \"/NoPadding\";\r\n}"
}, {
	"Path": "com.codename1.ui.Form.addGameKeyListener",
	"Comment": "add a game key listener to the given gamekey for a callback when the key is released",
	"Method": "void addGameKeyListener(int keyCode,ActionListener listener){\r\n    if (gameKeyListeners == null) {\r\n        gameKeyListeners = new HashMap<Integer, ArrayList<ActionListener>>();\r\n    }\r\n    addKeyListener(keyCode, listener, gameKeyListeners);\r\n}"
}, {
	"Path": "com.codename1.ui.Container.setUIManager",
	"Comment": "allows replacing the uimanager in a component hierarchy to update the look and feelonly to a specific hierarchy",
	"Method": "void setUIManager(UIManager uiManager){\r\n    this.uiManager = uiManager;\r\n}"
}, {
	"Path": "android.support.v4.app.ListFragment.onViewCreated",
	"Comment": "attach to list view once the view hierarchy has been created.",
	"Method": "void onViewCreated(View view,Bundle savedInstanceState){\r\n    super.onViewCreated(view, savedInstanceState);\r\n    ensureList();\r\n}"
}, {
	"Path": "com.codename1.ui.Image.getRGBCached",
	"Comment": "returns the content of this image as a newly created argb array or a cachedinstance if possible. note that cached instances may be garbage collected.",
	"Method": "int[] getRGBCached(){\r\n    int[] r = getRGBCache();\r\n    if (r == null) {\r\n        r = getRGBImpl();\r\n        rgbCache = Display.getInstance().createSoftWeakRef(r);\r\n    }\r\n    return r;\r\n}"
}, {
	"Path": "com.codename1.ui.Toolbar.getRightSideMenuCommands",
	"Comment": "returns the commands within the right side menu which can be useful forthings like unit testing. notice that you should not mutate the commandsor the iteratable set in any way!",
	"Method": "Iterable<Command> getRightSideMenuCommands(){\r\n    ArrayList<Command> cmds = new ArrayList<Command>();\r\n    if (permanentSideMenu || onTopSideMenu) {\r\n        if (permanentRightSideMenuContainer != null) {\r\n            findAllCommands(permanentRightSideMenuContainer, cmds);\r\n        }\r\n    }\r\n    return cmds;\r\n}"
}, {
	"Path": "com.codename1.components.SpanLabel.setShouldLocalize",
	"Comment": "indicates if text should be localized when set to the component, by defaultall text is localized so this allows disabling automatic localization for a specific component.",
	"Method": "void setShouldLocalize(boolean shouldLocalize){\r\n    this.shouldLocalize = shouldLocalize;\r\n}"
}, {
	"Path": "android.support.v4.view.accessibility.AccessibilityNodeInfoCompat.obtain",
	"Comment": "returns a cached instance if such is available or a new one is create.the returned instance is initialized from the given info.",
	"Method": "Object obtain(Object obtain,View source,Object obtain,Object info,Object obtain,View root,int virtualDescendantId,Object obtain,Object obtain,View source,Object obtain,View root,int virtualDescendantId,Object obtain,Object info,Object obtain,Object obtain,View source,Object obtain,Object info,Object obtain,View root,int virtualDescendantId,AccessibilityNodeInfoCompat obtain,View source,AccessibilityNodeInfoCompat obtain,View root,int virtualDescendantId,AccessibilityNodeInfoCompat obtain,AccessibilityNodeInfoCompat obtain,AccessibilityNodeInfoCompat info){\r\n    return AccessibilityNodeInfoCompat.wrapNonNullInstance(IMPL.obtain(info.mInfo));\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.screenshotTest",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "boolean screenshotTest(String screenshotName){\r\n    return TestUtils.screenshotTest(screenshotName);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.LayeredLayout.setInsetTop",
	"Comment": "sets the top inset for this component to the prescribed value.",
	"Method": "LayeredLayout setInsetTop(Component cmp,String inset){\r\n    getOrCreateConstraint(cmp).top().setValue(inset);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.getApplicationKey",
	"Comment": "returns the key for the application comprised of the builders email coupled with the package name. it should uniquely identify the application across different builds which allows interaction with the cloud.",
	"Method": "String getApplicationKey(){\r\n    Display d = Display.getInstance();\r\n    return d.getProperty(\"built_by_user\", \"Unknown Build Key\") + '/' + d.getProperty(\"package_name\", \"Unknown Build Key\");\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.createCommand",
	"Comment": "creates a command instance. this method is invoked by the loading code andcan be overriden to create a subclass of the command class.",
	"Method": "Command createCommand(String commandName,Image icon,int commandId,String action){\r\n    return new Command(commandName, icon, commandId);\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.firstChild",
	"Comment": "creates new set consisting of the first child of each component in the current set.",
	"Method": "ComponentSelector firstChild(){\r\n    HashSet<Component> out = new HashSet<Component>();\r\n    for (Component c : this) {\r\n        if (c instanceof Container) {\r\n            Container cnt = (Container) c;\r\n            if (cnt.getComponentCount() > 0) {\r\n                out.add(cnt.getComponentAt(0));\r\n            }\r\n        }\r\n    }\r\n    return new ComponentSelector(out);\r\n}"
}, {
	"Path": "com.codename1.ui.util.EditableResources.normalizeFileName",
	"Comment": "converts a file name to a normalized name so it can be saved on a windows filesystem",
	"Method": "String normalizeFileName(String fName){\r\n    return fName.replace(\"*\", \"_\").replace(\"?\", \"_\").replace(\":\", \"_\");\r\n}"
}, {
	"Path": "com.codename1.ui.Container.animateHierarchyAndWait",
	"Comment": "animates a pending hierarchy of components into place, this effectively replaces revalidate with a more visual form of animation. this method waits until the operation is completed before returning",
	"Method": "void animateHierarchyAndWait(int duration){\r\n    animateHierarchy(duration, true, 255, true);\r\n}"
}, {
	"Path": "org.conscrypt.javax.net.ssl.KeyManagerFactoryTest.rotate",
	"Comment": "generates an array of arrays of all the rotational permutations of its input.",
	"Method": "String[][] rotate(String[] input){\r\n    int size = input.length;\r\n    String[][] result = new String[size][size];\r\n    for (int i = 0; i < size; i++) {\r\n        for (int j = 0; j < size; j++) {\r\n            result[i][j] = input[(i + j) % size];\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.removeElement",
	"Comment": "removes the first occurrence, starting at the beginning and movingtowards the end, of the specified object from this vector. all elementswith an index bigger than the element that gets removed have their indexdecreased by 1.",
	"Method": "boolean removeElement(Object object){\r\n    int index;\r\n    if ((index = indexOf(object, 0)) == -1) {\r\n        return false;\r\n    }\r\n    removeElementAt(index);\r\n    return true;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.TreeMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(Set<K> keySet,Set<K> keySet){\r\n    if (keySet == null) {\r\n        keySet = new AbstractSet<K>() {\r\n            @Override\r\n            public boolean contains(Object object) {\r\n                return containsKey(object);\r\n            }\r\n            @Override\r\n            public int size() {\r\n                return size;\r\n            }\r\n            @Override\r\n            public void clear() {\r\n                TreeMap.this.clear();\r\n            }\r\n            @Override\r\n            public Iterator<K> iterator() {\r\n                return new UnboundedKeyIterator<K, V>(TreeMap.this);\r\n            }\r\n        };\r\n    }\r\n    return keySet;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.TreeMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(Set<K> keySet,Set<K> keySet){\r\n    return containsKey(object);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.TreeMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(Set<K> keySet,Set<K> keySet){\r\n    return size;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.TreeMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(Set<K> keySet,Set<K> keySet){\r\n    TreeMap.this.clear();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.TreeMap.keySet",
	"Comment": "returns a set of the keys contained in this map. the set is backed bythis map so changes to one are reflected by the other. the set does notsupport adding.",
	"Method": "Set<K> keySet(Set<K> keySet,Set<K> keySet){\r\n    return new UnboundedKeyIterator<K, V>(TreeMap.this);\r\n}"
}, {
	"Path": "com.codename1.contacts.Contact.getPrimaryPhoneNumber",
	"Comment": "gets the primary phone number of this contact, notice this can be null even though the contact has phone numbers declared",
	"Method": "String getPrimaryPhoneNumber(){\r\n    if (primaryPhoneNumber == null && phoneNumbers != null) {\r\n        Collection c = phoneNumbers.values();\r\n        if (c.size() > 0) {\r\n            return (String) c.iterator().next();\r\n        }\r\n    }\r\n    return primaryPhoneNumber;\r\n}"
}, {
	"Path": "android.support.v4.widget.SearchViewCompat.isQueryRefinementEnabled",
	"Comment": "returns whether query refinement is enabled for all items or only specific ones.",
	"Method": "boolean isQueryRefinementEnabled(View searchView,boolean isQueryRefinementEnabled,View searchView,boolean isQueryRefinementEnabled,View searchView,boolean isQueryRefinementEnabled,View searchView){\r\n    return IMPL.isQueryRefinementEnabled(searchView);\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.assertTitle",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "void assertTitle(String title){\r\n    TestUtils.assertTitle(title);\r\n}"
}, {
	"Path": "com.codename1.ui.List.setListSizeCalculationSampleCount",
	"Comment": "indicates the number of elements the list should check to determine the elementsizes. this is ignored when a rendering prototype is present.",
	"Method": "void setListSizeCalculationSampleCount(int listSizeCalculationSampleCount){\r\n    this.listSizeCalculationSampleCount = listSizeCalculationSampleCount;\r\n}"
}, {
	"Path": "java.lang.Throwable.printStackTrace",
	"Comment": "prints this throwable and its backtrace to the standard error stream. this method prints a stack trace for this throwable object on the error output stream that is the value of the field system.err. the first line of output contains the result of themethod for this object.the format of the backtrace information depends on the implementation.",
	"Method": "void printStackTrace(){\r\n    System.out.println(stack);\r\n    if (cause != null) {\r\n        System.out.println(\"Caused by \");\r\n        cause.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Command.setPressedIcon",
	"Comment": "indicates the icon that is displayed on the button when the button is inpressed state",
	"Method": "void setPressedIcon(Image pressedIcon){\r\n    this.pressedIcon = pressedIcon;\r\n}"
}, {
	"Path": "com.codename1.ui.BrowserComponent.addWebEventListener",
	"Comment": "adds a listener to the given event type name, event type names are platform specific but some must be fired for all platforms and will invoke the action listener when the appropriate event loads",
	"Method": "void addWebEventListener(String type,ActionListener listener){\r\n    getEventDispatcher(type, true).addListener(listener);\r\n}"
}, {
	"Path": "org.apache.harmony.xnet.provider.jsse.OpenSSLSocketImpl.setHandshakeTimeout",
	"Comment": "set the handshake timeout on this socket.this timeout is specified inmilliseconds and will be used only during the handshake process.",
	"Method": "void setHandshakeTimeout(int handshakeTimeoutMilliseconds){\r\n    throw new RuntimeException(\"Stub!\");\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetTable.getIndent",
	"Comment": "calculates the required left indent for a given item, given its type andits hierarchy level.",
	"Method": "int getIndent(PropertySheetTable table,Item item){\r\n    int indent = 0;\r\n    if (item.isProperty()) {\r\n        if ((item.getParent() == null || !item.getParent().isProperty()) && !item.hasToggle()) {\r\n            indent = table.getWantsExtraIndent() ? HOTSPOT_SIZE : 0;\r\n        } else {\r\n            if (item.hasToggle()) {\r\n                indent = item.getDepth() * HOTSPOT_SIZE;\r\n            } else {\r\n                indent = (item.getDepth() + 1) * HOTSPOT_SIZE;\r\n            }\r\n        }\r\n        if (table.getSheetModel().getMode() == PropertySheet.VIEW_AS_CATEGORIES && table.getWantsExtraIndent()) {\r\n            indent += HOTSPOT_SIZE;\r\n        }\r\n    } else {\r\n        indent = 0;\r\n    }\r\n    return indent;\r\n}"
}, {
	"Path": "android.support.v4.view.ViewCompat.canScrollVertically",
	"Comment": "check if this view can be scrolled vertically in a certain direction.",
	"Method": "boolean canScrollVertically(View v,int direction,boolean canScrollVertically,View v,int direction,boolean canScrollVertically,View v,int direction,boolean canScrollVertically,View v,int direction){\r\n    return IMPL.canScrollVertically(v, direction);\r\n}"
}, {
	"Path": "com.codename1.ui.animations.BubbleTransition.setComponentName",
	"Comment": "the name of the component from the source form that this transition should start from.",
	"Method": "void setComponentName(String componentName){\r\n    this.componentName = componentName;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getDraggedy",
	"Comment": "gets the current dragged y values when the component is being dragged",
	"Method": "int getDraggedy(){\r\n    return draggedy;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getDraggedx",
	"Comment": "gets the current dragged x values when the component is being dragged",
	"Method": "int getDraggedx(){\r\n    return draggedx;\r\n}"
}, {
	"Path": "com.codename1.components.OnOffSwitch.setComponentState",
	"Comment": "if getcomponentstate returned a value the setter can update the value and restorethe prior state.",
	"Method": "void setComponentState(Object state){\r\n    value = ((Boolean) state).booleanValue();\r\n}"
}, {
	"Path": "com.codename1.contacts.ContactsManager.isAllContactsFast",
	"Comment": "indicates if the getallcontacts is platform optimized, notice that the methodmight still take seconds or more to run so you should still use a separate thread!",
	"Method": "boolean isAllContactsFast(){\r\n    return Display.getInstance().isGetAllContactsFast();\r\n}"
}, {
	"Path": "com.codename1.ui.Display.startThread",
	"Comment": "start a codename one thread that supports crash protection and similar codename one features.",
	"Method": "Thread startThread(Runnable r,String name){\r\n    return new CodenameOneThread(r, name);\r\n}"
}, {
	"Path": "com.codename1.charts.views.XYChart.getPointsChart",
	"Comment": "returns the scatter chart to be used for drawing the data points.",
	"Method": "ScatterChart getPointsChart(){\r\n    return null;\r\n}"
}, {
	"Path": "java.util.Collections.synchronizedSortedMap",
	"Comment": "returns a wrapper on the specified sorted map which synchronizes allaccess to the sorted map.",
	"Method": "SortedMap<K, V> synchronizedSortedMap(SortedMap<K, V> map){\r\n    if (map == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    return new SynchronizedSortedMap<K, V>(map);\r\n}"
}, {
	"Path": "com.googlecode.cqengine.ConcurrentIndexedCollection.flagAsReadRequest",
	"Comment": "sets a flag into the given query options to record that this request will read from the collectionbut will not modify it.this is used to facilitate locking in some persistence implementations.",
	"Method": "void flagAsReadRequest(QueryOptions queryOptions){\r\n    FlagsEnabled.forQueryOptions(queryOptions).add(PersistenceFlags.READ_REQUEST);\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.setDestinationStorage",
	"Comment": "when set to a none null string saves the response to storage underthis file name",
	"Method": "void setDestinationStorage(String destinationStorage){\r\n    this.destinationStorage = destinationStorage;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Style.getPaddingValue",
	"Comment": "returns the padding in the internal value regardless of the unit",
	"Method": "int getPaddingValue(boolean rtl,int orientation){\r\n    if (orientation < Component.TOP || orientation > Component.RIGHT) {\r\n        throw new IllegalArgumentException(\"wrong orientation \" + orientation);\r\n    }\r\n    if (rtl) {\r\n        switch(orientation) {\r\n            case Component.LEFT:\r\n                orientation = Component.RIGHT;\r\n                break;\r\n            case Component.RIGHT:\r\n                orientation = Component.LEFT;\r\n                break;\r\n        }\r\n    }\r\n    return (int) padding[orientation];\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.LayoutUtil.getSerializedObject",
	"Comment": "returns the serialized object that are associated with caller. it also removes it from the list.",
	"Method": "Object getSerializedObject(Object caller){\r\n    synchronized (SER_MAP) {\r\n        return SER_MAP.remove(caller);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getSelectCommandText",
	"Comment": "allows determining the text for the select command used in the 3rd softbuttonmode.",
	"Method": "String getSelectCommandText(){\r\n    return selectText;\r\n}"
}, {
	"Path": "java.util.Collections.synchronizedMap",
	"Comment": "returns a wrapper on the specified map which synchronizes all access tothe map.",
	"Method": "Map<K, V> synchronizedMap(Map<K, V> map){\r\n    if (map == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    return new SynchronizedMap<K, V>(map);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.hasPendingPaints",
	"Comment": "returns true if the implementation still has elements to paint.",
	"Method": "boolean hasPendingPaints(){\r\n    return paintQueueFill != 0;\r\n}"
}, {
	"Path": "com.codename1.ui.Tabs.getSelectedComponent",
	"Comment": "returns the component associated with the tab at the given index",
	"Method": "Component getSelectedComponent(){\r\n    int i = getSelectedIndex();\r\n    if (i == -1) {\r\n        return null;\r\n    }\r\n    return getTabComponentAt(i);\r\n}"
}, {
	"Path": "com.codename1.impl.blackberry.BlackBerryImplementation.setMinimizeOnEnd",
	"Comment": "indicates whether the application should minimize or exit when the end key is pressed",
	"Method": "void setMinimizeOnEnd(boolean aMinimizeOnEnd){\r\n    minimizeOnEnd = aMinimizeOnEnd;\r\n}"
}, {
	"Path": "com.alibaba.citrus.service.upload.impl.cfu.AbstractFileItem.get",
	"Comment": "returns the contents of the file as an array of bytes. if the contents ofthe file were not yet cached in memory, they will be loaded from the diskstorage and cached.",
	"Method": "byte[] get(){\r\n    if (isInMemory()) {\r\n        if (cachedContent == null) {\r\n            cachedContent = dfos.getData();\r\n        }\r\n        return cachedContent;\r\n    }\r\n    byte[] fileData = new byte[(int) getSize()];\r\n    FileInputStream fis = null;\r\n    try {\r\n        fis = new FileInputStream(dfos.getFile());\r\n        fis.read(fileData);\r\n    } catch (IOException e) {\r\n        fileData = null;\r\n    } finally {\r\n        if (fis != null) {\r\n            try {\r\n                fis.close();\r\n            } catch (IOException e) {\r\n            }\r\n        }\r\n    }\r\n    return fileData;\r\n}"
}, {
	"Path": "com.codename1.system.NativeLookup.isVerbose",
	"Comment": "indicates whether stack traces should be printed when lookup fails",
	"Method": "boolean isVerbose(){\r\n    return verbose;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.index.support.PartialIndex.supportsQuery",
	"Comment": "returns true if this partial index can answer this branch of the query.see the class javadoc for the conditions which must be satisfied for this method to return true.",
	"Method": "boolean supportsQuery(Query<O> query,QueryOptions queryOptions){\r\n    @SuppressWarnings(\"unchecked\")\r\n    Query<O> rootQuery = (Query<O>) queryOptions.get(CollectionQueryEngine.ROOT_QUERY);\r\n    return supportsQueryInternal(backingIndex(), filterQuery, rootQuery, query, queryOptions);\r\n}"
}, {
	"Path": "org.conscrypt.java.security.TestKeyStore.getServer",
	"Comment": "return a server keystore with a matched rsa certificate andprivate key as well as a ca certificate.",
	"Method": "TestKeyStore getServer(){\r\n    initCerts();\r\n    return SERVER;\r\n}"
}, {
	"Path": "org.conscrypt.OAEPParameters.writeHashAndMgfHash",
	"Comment": "shared with pssparameters, since they share some of their encoded form",
	"Method": "void writeHashAndMgfHash(long seqRef,String hash,MGF1ParameterSpec mgfSpec){\r\n    if (!hash.equals(\"SHA-1\")) {\r\n        long hashRef = 0;\r\n        long hashParamsRef = 0;\r\n        try {\r\n            hashRef = NativeCrypto.asn1_write_tag(seqRef, 0);\r\n            hashParamsRef = writeAlgorithmIdentifier(hashRef, NAME_TO_OID.get(hash));\r\n            NativeCrypto.asn1_write_null(hashParamsRef);\r\n        } finally {\r\n            NativeCrypto.asn1_write_flush(seqRef);\r\n            NativeCrypto.asn1_write_free(hashParamsRef);\r\n            NativeCrypto.asn1_write_free(hashRef);\r\n        }\r\n    }\r\n    if (!mgfSpec.getDigestAlgorithm().equals(\"SHA-1\")) {\r\n        long mgfRef = 0;\r\n        long mgfParamsRef = 0;\r\n        long hashParamsRef = 0;\r\n        try {\r\n            mgfRef = NativeCrypto.asn1_write_tag(seqRef, 1);\r\n            mgfParamsRef = writeAlgorithmIdentifier(mgfRef, MGF1_OID);\r\n            hashParamsRef = writeAlgorithmIdentifier(mgfParamsRef, NAME_TO_OID.get(mgfSpec.getDigestAlgorithm()));\r\n            NativeCrypto.asn1_write_null(hashParamsRef);\r\n        } finally {\r\n            NativeCrypto.asn1_write_flush(seqRef);\r\n            NativeCrypto.asn1_write_free(hashParamsRef);\r\n            NativeCrypto.asn1_write_free(mgfParamsRef);\r\n            NativeCrypto.asn1_write_free(mgfRef);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.onStopHelper",
	"Comment": "called when final activity is stopped. sends an end session event to the server,also sends any unsent custom events.",
	"Method": "void onStopHelper(){\r\n    connectionQueue_.endSession(roundedSecondsSinceLastSessionDurationUpdate());\r\n    prevSessionDurationStartTime_ = 0;\r\n    if (eventQueue_.size() > 0) {\r\n        connectionQueue_.recordEvents(eventQueue_.events());\r\n    }\r\n}"
}, {
	"Path": "org.conscrypt.SSLParametersImpl.setEnabledCipherSuites",
	"Comment": "sets the enabled cipher suites after filtering through openssl.",
	"Method": "void setEnabledCipherSuites(String[] cipherSuites){\r\n    enabledCipherSuites = NativeCrypto.checkEnabledCipherSuites(filterFromCipherSuites(cipherSuites, NativeCrypto.SUPPORTED_TLS_1_3_CIPHER_SUITES_SET));\r\n}"
}, {
	"Path": "io.atomix.copycat.client.session.ClientSessionState.setCommandResponse",
	"Comment": "sets the last command sequence number for which a response has been received.",
	"Method": "ClientSessionState setCommandResponse(long commandResponse){\r\n    this.commandResponse = commandResponse;\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.processing.AbstractEvaluator._evaluateLeftLessRight",
	"Comment": "this internal method simply makes a type safe call the the properabstract method based on the type of element passed.",
	"Method": "Object _evaluateLeftLessRight(Object element,String lvalue,String rvalue){\r\n    if (element instanceof List) {\r\n        return evaluateLeftLessRight((List) element, lvalue, rvalue);\r\n    } else {\r\n        return evaluateLeftLessRight((StructuredContent) element, lvalue, rvalue);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.CN.setDragStartPercentage",
	"Comment": "this method allows us to manipulate the drag started detection logic.if the pointer was dragged for more than this percentage of the display size itis safe to assume that a drag is in progress.",
	"Method": "void setDragStartPercentage(int dragStartPercentage){\r\n    Display.impl.setDragStartPercentage(dragStartPercentage);\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.setEnableInputScroll",
	"Comment": "indicates whether text field input should scroll to the right side when nomore room for the input is present.",
	"Method": "void setEnableInputScroll(boolean enableInputScroll){\r\n    this.enableInputScroll = enableInputScroll;\r\n}"
}, {
	"Path": "com.codename1.io.File.delete",
	"Comment": "deletes the file described by this object on the file system.",
	"Method": "boolean delete(){\r\n    FileSystemStorage.getInstance().delete(path);\r\n    return FileSystemStorage.getInstance().exists(path);\r\n}"
}, {
	"Path": "com.codename1.components.Accordion.setAutoClose",
	"Comment": "sets the auto close flag, if this flag is true clicking on an item to open an item will automatically close the previous opened item.",
	"Method": "void setAutoClose(boolean autoClose){\r\n    this.autoClose = autoClose;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.createProxyStyle",
	"Comment": "creates a proxy style to mutate the styles of all component styles in found set.",
	"Method": "Style createProxyStyle(){\r\n    HashSet<Style> styles = new HashSet<Style>();\r\n    for (Component c : this) {\r\n        styles.add(getStyle(c));\r\n    }\r\n    return Style.createProxyStyle(styles.toArray(new Style[styles.size()]));\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GroupLayout.setVerticalGroup",
	"Comment": "sets the group that is responsible forlayout along the vertical axis.",
	"Method": "void setVerticalGroup(Group group){\r\n    if (group == null) {\r\n        throw new IllegalArgumentException(\"Group must be non-null\");\r\n    }\r\n    verticalGroup = createTopLevelGroup(group);\r\n    invalidateHost();\r\n}"
}, {
	"Path": "io.atomix.copycat.server.util.Quorum.cancel",
	"Comment": "cancels the quorum. once this method has been called, the quorum will be marked complete andthe handler will never be called.",
	"Method": "void cancel(){\r\n    callback = null;\r\n    complete = true;\r\n}"
}, {
	"Path": "com.codename1.ui.util.EmbeddedContainer.setEmbed",
	"Comment": "indicates the name of the container to embed into this container",
	"Method": "void setEmbed(String embed){\r\n    this.embed = embed;\r\n}"
}, {
	"Path": "com.l2fprod.common.propertysheet.PropertySheetPanel.writeToObject",
	"Comment": "writes the propertysheet to the given object. if any, it commits pendingedit before proceeding with properties.",
	"Method": "void writeToObject(Object data){\r\n    getTable().commitEditing();\r\n    Property[] properties = getProperties();\r\n    for (int i = 0, c = properties.length; i < c; i++) {\r\n        properties[i].writeToObject(data);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.media.MediaManager.getMediaRecorderingMimeType",
	"Comment": "gets the recording mime type for the returned media from the createmediarecorder method",
	"Method": "String getMediaRecorderingMimeType(){\r\n    return Display.getInstance().getMediaRecorderingMimeType();\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSEngine.setLineHeightRecursive",
	"Comment": "sets the given spacing to all words in this component and its children",
	"Method": "void setLineHeightRecursive(Component cmp,int halfHeight){\r\n    if (cmp instanceof Container) {\r\n        Container cont = (Container) cmp;\r\n        for (int i = 0; i < cont.getComponentCount(); i++) {\r\n            setLineHeightRecursive(cont.getComponentAt(i), halfHeight);\r\n        }\r\n    } else if (cmp instanceof Label) {\r\n        cmp.getUnselectedStyle().setMargin(Component.TOP, halfHeight);\r\n        cmp.getUnselectedStyle().setMargin(Component.BOTTOM, halfHeight);\r\n        if (cmp instanceof HTMLLink) {\r\n            cmp.getSelectedStyle().setPadding(Component.TOP, halfHeight);\r\n            cmp.getSelectedStyle().setPadding(Component.BOTTOM, halfHeight);\r\n            ((HTMLLink) cmp).getPressedStyle().setPadding(Component.TOP, halfHeight);\r\n            ((HTMLLink) cmp).getPressedStyle().setPadding(Component.BOTTOM, halfHeight);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.focusLostInternal",
	"Comment": "this method is useful since it is not a part of the public api yetallows a component within this package to observe focus eventswithout implementing a public interface or creating a new class",
	"Method": "void focusLostInternal(){\r\n    stopComponentLableTicker();\r\n}"
}, {
	"Path": "ly.count.android.sdk.ConnectionQueue.checkInternalState",
	"Comment": "checks internal state and throws illegalstateexception if state is invalid to begin use.",
	"Method": "void checkInternalState(){\r\n    if (context_ == null) {\r\n        throw new IllegalStateException(\"context has not been set\");\r\n    }\r\n    if (appKey_ == null || appKey_.length() == 0) {\r\n        throw new IllegalStateException(\"app key has not been set\");\r\n    }\r\n    if (store_ == null) {\r\n        throw new IllegalStateException(\"countly store has not been set\");\r\n    }\r\n    if (serverURL_ == null || !Countly.isValidURL(serverURL_)) {\r\n        throw new IllegalStateException(\"server URL is not valid\");\r\n    }\r\n    if (Countly.publicKeyPinCertificates != null && !serverURL_.startsWith(\"https\")) {\r\n        throw new IllegalStateException(\"server must start with https once you specified public keys\");\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.BrowserComponent.fireBrowserNavigationCallbacks",
	"Comment": "fires all of the registered browser navigation callbacks against the provided url.",
	"Method": "boolean fireBrowserNavigationCallbacks(String url){\r\n    boolean shouldNavigate = true;\r\n    if (browserNavigationCallback != null && !browserNavigationCallback.shouldNavigate(url)) {\r\n        shouldNavigate = false;\r\n    }\r\n    if (browserNavigationCallbacks != null) {\r\n        for (BrowserNavigationCallback cb : browserNavigationCallbacks) {\r\n            if (!cb.shouldNavigate(url)) {\r\n                shouldNavigate = false;\r\n            }\r\n        }\r\n    }\r\n    if (!url.startsWith(\"javascript:\") && url.indexOf(RETURN_URL_PREFIX) != -1) {\r\n        String result = decodeURL(url.substring(url.indexOf(RETURN_URL_PREFIX) + RETURN_URL_PREFIX.length()), \"UTF-8\");\r\n        Result structResult = Result.fromContent(result, Result.JSON);\r\n        int callbackId = structResult.getAsInteger(\"callbackId\");\r\n        final String value = structResult.getAsString(\"value\");\r\n        final String type = structResult.getAsString(\"type\");\r\n        final String errorMessage = structResult.getAsString(\"errorMessage\");\r\n        final SuccessCallback<JSRef> callback = popReturnValueCallback(callbackId);\r\n        if (jsCallbacks != null && jsCallbacks.contains(callback)) {\r\n            returnValueCallbacks.put(callbackId, callback);\r\n        }\r\n        if (callback != null) {\r\n            if (errorMessage != null) {\r\n                if (fireCallbacksOnEdt) {\r\n                    Display.getInstance().callSerially(new Runnable() {\r\n                        public void run() {\r\n                            if (callback instanceof Callback) {\r\n                                ((Callback) callback).onError(this, new RuntimeException(errorMessage), 0, errorMessage);\r\n                            }\r\n                        }\r\n                    });\r\n                } else {\r\n                    if (callback instanceof Callback) {\r\n                        ((Callback) callback).onError(this, new RuntimeException(errorMessage), 0, errorMessage);\r\n                    }\r\n                }\r\n            } else {\r\n                if (fireCallbacksOnEdt) {\r\n                    Display.getInstance().callSerially(new Runnable() {\r\n                        public void run() {\r\n                            callback.onSucess(new JSRef(value, type));\r\n                        }\r\n                    });\r\n                } else {\r\n                    callback.onSucess(new JSRef(value, type));\r\n                }\r\n            }\r\n        } else {\r\n            Log.e(new RuntimeException(\"Received return value from javascript, but no callback could be found for that ID\"));\r\n        }\r\n        shouldNavigate = false;\r\n    }\r\n    return shouldNavigate;\r\n}"
}, {
	"Path": "com.codename1.ui.BrowserComponent.fireBrowserNavigationCallbacks",
	"Comment": "fires all of the registered browser navigation callbacks against the provided url.",
	"Method": "boolean fireBrowserNavigationCallbacks(String url){\r\n    if (callback instanceof Callback) {\r\n        ((Callback) callback).onError(this, new RuntimeException(errorMessage), 0, errorMessage);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.BrowserComponent.fireBrowserNavigationCallbacks",
	"Comment": "fires all of the registered browser navigation callbacks against the provided url.",
	"Method": "boolean fireBrowserNavigationCallbacks(String url){\r\n    callback.onSucess(new JSRef(value, type));\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.Spinner.getInputSkipDelay",
	"Comment": "indicates the time after which the skip input area for entering spinner values manually will disappear",
	"Method": "int getInputSkipDelay(){\r\n    return inputSkipDelay;\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.dispose",
	"Comment": "closes the current form and returns to the previous form, releasing the edt in the process",
	"Method": "void dispose(){\r\n    if (isDisposed()) {\r\n        return;\r\n    }\r\n    setDisposed(true);\r\n    if (!menu) {\r\n        super.dispose();\r\n    }\r\n}"
}, {
	"Path": "android.support.v4.widget.SlidingPaneLayout.setParallaxDistance",
	"Comment": "set a distance to parallax the lower pane by when the upper pane is in itsfully closed state. the lower pane will scroll between this position andits fully open state.",
	"Method": "void setParallaxDistance(int parallaxBy){\r\n    mParallaxBy = parallaxBy;\r\n    requestLayout();\r\n}"
}, {
	"Path": "ly.count.android.sdk.UserData.pullValue",
	"Comment": "create array property, if property does not exist and remove value from arrayyou can only use it on array properties or properties that do not exist yet",
	"Method": "void pullValue(String key,String value){\r\n    UserData.modifyCustomData(key, value, \"$pull\");\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Motion.createEaseInMotion",
	"Comment": "equivalent to createcubicbeziermotion with 0f, 0.42f, 1f, 1f as arguments.",
	"Method": "Motion createEaseInMotion(int sourceValue,int destinationValue,int duration){\r\n    return createCubicBezierMotion(sourceValue, destinationValue, duration, 0f, 0.42f, 1f, 1f);\r\n}"
}, {
	"Path": "org.conscrypt.AbstractConscryptSocket.setHandshakeTimeout",
	"Comment": "set the handshake timeout on this socket.this timeout is specified inmilliseconds and will be used only during the handshake process.",
	"Method": "void setHandshakeTimeout(int handshakeTimeoutMilliseconds){\r\n    throw new SocketException(\"Method setHandshakeTimeout() is not supported.\");\r\n}"
}, {
	"Path": "io.prometheus.client.cache.caffeine.CacheMetricsCollector.removeCache",
	"Comment": "remove the cache with the given name.any references to the cache are invalidated.",
	"Method": "Cache removeCache(String cacheName){\r\n    return children.remove(cacheName);\r\n}"
}, {
	"Path": "java.util.Vector.add",
	"Comment": "adds the specified object into this vector at the specified location. theobject is inserted before any element with the same or a higher indexincreasing their index by 1. if the location is equal to the size of thisvector, the object is added at the end.",
	"Method": "void add(int location,E object,boolean add,E object){\r\n    if (elementCount == elementData.length) {\r\n        growByOne();\r\n    }\r\n    elementData[elementCount++] = object;\r\n    modCount++;\r\n    return true;\r\n}"
}, {
	"Path": "org.conscrypt.AbstractConscryptSocket.getSoWriteTimeout",
	"Comment": "note write timeouts are not part of the javax.net.ssl.sslsocket api",
	"Method": "int getSoWriteTimeout(){\r\n    return 0;\r\n}"
}, {
	"Path": "com.codename1.components.SpanButton.getTextAllStyles",
	"Comment": "returns the style proxy object for the text of this span button.",
	"Method": "Style getTextAllStyles(){\r\n    return text.getAllStyles();\r\n}"
}, {
	"Path": "com.codename1.ui.Toolbar.setCenteredDefault",
	"Comment": "indicates whether the toolbar should be properly centered by default",
	"Method": "void setCenteredDefault(boolean aCenteredDefault){\r\n    centeredDefault = aCenteredDefault;\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.makers.ThumbnailMaker.makeThumbnail",
	"Comment": "makes a thumbnail of the specified dimensions, from the specified\tsource image.",
	"Method": "BufferedImage makeThumbnail(BufferedImage img,int width,int height){\r\n    if (!ready.isReady()) {\r\n        throw new IllegalStateException(ThumbnailMaker.NOT_READY_FOR_MAKE);\r\n    }\r\n    if (width <= 0) {\r\n        throw new IllegalArgumentException(\"Width must be greater than zero.\");\r\n    }\r\n    if (height <= 0) {\r\n        throw new IllegalArgumentException(\"Height must be greater than zero.\");\r\n    }\r\n    BufferedImage thumbnailImage = new BufferedImageBuilder(width, height, imageType).build();\r\n    Dimension imgSize = new Dimension(img.getWidth(), img.getHeight());\r\n    Dimension thumbnailSize = new Dimension(width, height);\r\n    Resizer resizer = resizerFactory.getResizer(imgSize, thumbnailSize);\r\n    resizer.resize(img, thumbnailImage);\r\n    return thumbnailImage;\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.getCursorX",
	"Comment": "returns the position of the cursor char position in the current line.",
	"Method": "int getCursorX(){\r\n    return -1;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.Style.isUnderline",
	"Comment": "returns true if the underline text decoration is on, false otherwise",
	"Method": "boolean isUnderline(){\r\n    return ((textDecoration & TEXT_DECORATION_UNDERLINE) != 0);\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.Picker.setPreferredPopupHeight",
	"Comment": "the preferred height of the popup dialog for the picker.this will only be used on devices where the popup width and height are configurable, such as the ipad or tablets.on iphone, the picker always spans the width of the screen along the bottom.",
	"Method": "void setPreferredPopupHeight(int height){\r\n    this.preferredPopupHeight = height;\r\n}"
}, {
	"Path": "com.codename1.ui.util.Resources.open",
	"Comment": "creates a resource object from the local jar resource identifier",
	"Method": "Resources open(String resource,Resources open,InputStream resource,Resources open,String resource,int dpi,Resources open,InputStream resource,int dpi){\r\n    return new Resources(resource, dpi);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.DefaultLookAndFeel.setPasswordChar",
	"Comment": "sets the password character to display in the textarea and the textfield",
	"Method": "void setPasswordChar(char c){\r\n    passwordChar = c;\r\n}"
}, {
	"Path": "com.codename1.components.MultiButton.getIconPosition",
	"Comment": "returns the icon position based on border layout constraints",
	"Method": "String getIconPosition(){\r\n    return (String) getLayout().getComponentConstraint(icon.getParent());\r\n}"
}, {
	"Path": "io.atomix.copycat.client.session.ClientSequencerTest.testSequenceEventAfterAllCommands",
	"Comment": "tests sequencing an event that arrives before a command response.",
	"Method": "void testSequenceEventAfterAllCommands(){\r\n    ClientSequencer sequencer = new ClientSequencer(new ClientSessionState(UUID.randomUUID().toString()));\r\n    long sequence = sequencer.nextRequest();\r\n    PublishRequest request1 = PublishRequest.builder().withSession(1).withEventIndex(2).withPreviousIndex(0).build();\r\n    PublishRequest request2 = PublishRequest.builder().withSession(1).withEventIndex(3).withPreviousIndex(2).build();\r\n    CommandResponse response = CommandResponse.builder().withStatus(Response.Status.OK).withIndex(2).withEventIndex(2).build();\r\n    AtomicInteger run = new AtomicInteger();\r\n    sequencer.sequenceEvent(request1, () -> assertEquals(run.getAndIncrement(), 0));\r\n    sequencer.sequenceEvent(request2, () -> assertEquals(run.getAndIncrement(), 2));\r\n    sequencer.sequenceResponse(sequence, response, () -> assertEquals(run.getAndIncrement(), 1));\r\n    assertEquals(run.get(), 3);\r\n}"
}, {
	"Path": "com.codename1.designer.css.CN1CSSCompiler.convertSelector",
	"Comment": "converts a selector from a css selector to a property in the cn1 themeformat.",
	"Method": "String convertSelector(Selector sel,String key){\r\n    StringBuilder out = new StringBuilder();\r\n    switch(sel.getSelectorType()) {\r\n        case Selector.SAC_ELEMENT_NODE_SELECTOR:\r\n            return ((ElementSelector) sel).getLocalName() + \".\" + key;\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isNotificationSupported",
	"Comment": "indicates whether the notify status bar method will present a notification to the user",
	"Method": "boolean isNotificationSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.xml.Element.setAttribute",
	"Comment": "adds the specified attribute and value to this element if it is supported for the element and has a valid value.",
	"Method": "void setAttribute(Object id,String value,int setAttribute,String attribute,String value){\r\n    if (textElement) {\r\n        throw new IllegalStateException(\"Text elements cannot have attributes\");\r\n    }\r\n    setAttribute((Object) attribute, value);\r\n    return -1;\r\n}"
}, {
	"Path": "com.codename1.io.JSONParser.setUseLongs",
	"Comment": "indicates that the parser will generate long objects and not just doubles for numeric values",
	"Method": "void setUseLongs(boolean aUseLongsDefault){\r\n    useLongsDefault = aUseLongsDefault;\r\n}"
}, {
	"Path": "com.codename1.ui.Stroke.getCapStyle",
	"Comment": "gets the cap style of the stroke.see visual examples of cap styles here.",
	"Method": "int getCapStyle(){\r\n    return capStyle;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.setElementAt",
	"Comment": "replaces the element at the specified location in this vector with thespecified object.",
	"Method": "void setElementAt(E object,int location){\r\n    if (location < elementCount) {\r\n        elementData[location] = object;\r\n    } else {\r\n        throw new ArrayIndexOutOfBoundsException(location);\r\n    }\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.util.OffsetPredicate.test",
	"Comment": "returns a boolean value indicating whether an offset is live.",
	"Method": "boolean test(Long offset){\r\n    return offset != -1 && (bits.size() <= offset || !bits.get(offset));\r\n}"
}, {
	"Path": "com.codename1.ui.Component.resetFocusable",
	"Comment": "restores the state of the focusable flag to its default state",
	"Method": "void resetFocusable(){\r\n    setFocusable(false);\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.gameKeyPress",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "void gameKeyPress(int gameKey){\r\n    TestUtils.gameKeyPress(gameKey);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.runtime.java.lang.String_.lastIndexOf",
	"Comment": "searches in this string for the index of the specified string. the searchfor the string starts at the specified offset and moves towards thebeginning of this string.",
	"Method": "int lastIndexOf(String orig,String string,int lastIndexOf,String orig,String subString,int start){\r\n    int count = orig.length();\r\n    int subCount = subString.length();\r\n    if (subCount <= count && start >= 0) {\r\n        if (subCount > 0) {\r\n            if (start > count - subCount) {\r\n                start = count - subCount;\r\n            }\r\n            char[] target = subString.toCharArray();\r\n            int subOffset = 0;\r\n            char firstChar = target[subOffset];\r\n            int end = subOffset + subCount;\r\n            while (true) {\r\n                int i = orig.lastIndexOf(firstChar, start);\r\n                if (i == -1) {\r\n                    return -1;\r\n                }\r\n                int o1 = i, o2 = subOffset;\r\n                while (++o2 < end && orig.charAt(++o1) == target[o2]) {\r\n                }\r\n                if (o2 == end) {\r\n                    return i;\r\n                }\r\n                start = i - 1;\r\n            }\r\n        }\r\n        return start < count ? start : count;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "cognitivej.vision.face.person.PersonBuilder.deletePersonFace",
	"Comment": "delete a face from a person. relative image for the persisted face will also be deleted.",
	"Method": "DeletePersonFaceAction deletePersonFace(String personGroupId,String personId,String persistedFaceId){\r\n    Validation.validate(personGroupId, \"^[a-z0-9_-]{1,64}$\", new ParameterValidationException(\"personGroupId\", \"Person group ID is invalid. Valid format should be a string composed by numbers, english letters in lower case, '-', '_', and no longer than 64 characters.\"));\r\n    return new DeletePersonFaceAction(cognitiveContext, personGroupId, personId, persistedFaceId);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Vector.setSize",
	"Comment": "sets the size of this vector to the specified size. if there are morethan length elements in this vector, the elements at end are lost. ifthere are less than length elements in the vector, the additionalelements contain null.",
	"Method": "void setSize(int length){\r\n    if (length == elementCount) {\r\n        return;\r\n    }\r\n    ensureCapacity(length);\r\n    if (elementCount > length) {\r\n        Arrays.fill(elementData, length, elementCount, null);\r\n    }\r\n    elementCount = length;\r\n    modCount++;\r\n}"
}, {
	"Path": "com.codename1.ui.RadioButton.setUnselectAllowed",
	"Comment": "allows unselecting a selected radiobutton.this is useful for when implementing a buttongroup that allows no selection or a single selection.,",
	"Method": "void setUnselectAllowed(boolean unselectAllowed){\r\n    this.unselectAllowed = unselectAllowed;\r\n}"
}, {
	"Path": "com.alibaba.citrus.turbine.util.HtmlPageAttributeTool.setStyle",
	"Comment": "adds a style element to the head of the page with the provided content.",
	"Method": "HtmlPageAttributeTool setStyle(String styleText){\r\n    log.info(\"Use of the setStyle(styleText) method is deprecated.  Please use \" + \"addStyle(styleText) instead.\");\r\n    return addStyle(styleText);\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.DateSpinner3D.setDateRange",
	"Comment": "sets the start and end dates in this spinner.month range is only limited if the year of the start and end dates are the same.day range is only limited ifboth the year and monthof the start and end dates are the same.",
	"Method": "void setDateRange(Date start,Date end){\r\n    explicitStartMonth = true;\r\n    explicitEndMonth = true;\r\n    explicitStartDay = true;\r\n    explicitEndDay = true;\r\n    explicitStartYear = true;\r\n    explicitEndYear = true;\r\n    int setEndYear = (end == null) ? 2100 : getYear(end) + 1900 + 1;\r\n    if (!explicitCurrentYear && currentYear > setEndYear - 1) {\r\n        currentYear = setEndYear - 1;\r\n    }\r\n    setEndYear(setEndYear);\r\n    int setStartYear = start == null ? 1970 : getYear(start) + 1900;\r\n    if (!explicitCurrentYear && currentYear < setStartYear) {\r\n        currentYear = setStartYear;\r\n    }\r\n    setStartYear(setStartYear);\r\n    if (start != null && end != null && getYear(start) == getYear(end)) {\r\n        startMonth = getMonth(start) + 1;\r\n        endMonth = getMonth(end) + 2;\r\n    } else {\r\n        startMonth = 1;\r\n        endMonth = 13;\r\n    }\r\n    rebuildMonth();\r\n    if (start != null && end != null && getYear(start) == getYear(end) && getMonth(start) == getMonth(end)) {\r\n        startDay = getDate(start);\r\n        endDay = getDate(end) + 1;\r\n    } else {\r\n        startDay = 1;\r\n        endDay = 32;\r\n    }\r\n    rebuildDay();\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Motion.createSplineMotion",
	"Comment": "creates a spline motion starting from source value all the way to destination value",
	"Method": "Motion createSplineMotion(int sourceValue,int destinationValue,int duration){\r\n    Motion spline = new Motion(sourceValue, destinationValue, duration);\r\n    spline.motionType = SPLINE;\r\n    return spline;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isScreenLockSupported",
	"Comment": "checks if the device supports locking the screen display from dimming, allowing the developer to keep the screen display on.",
	"Method": "boolean isScreenLockSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.Spinner.getValue",
	"Comment": "returns the value of the spinner to a number or a date based on the spinner type",
	"Method": "Object getValue(){\r\n    ListModel m = getModel();\r\n    if (m instanceof SpinnerDateModel) {\r\n        return ((SpinnerDateModel) m).getValue();\r\n    }\r\n    return ((SpinnerNumberModel) m).getValue();\r\n}"
}, {
	"Path": "com.codename1.components.ImageViewer.setSwipeThreshold",
	"Comment": "the swipe threshold is a number between 0 and 1 that indicates the threshold after which the swiped image moves to the next image. below that number the image will bounce back",
	"Method": "void setSwipeThreshold(float swipeThreshold){\r\n    this.swipeThreshold = swipeThreshold;\r\n}"
}, {
	"Path": "com.codename1.charts.renderers.XYMultipleSeriesRenderer.setBarSpacing",
	"Comment": "sets the spacing between bars, in bar charts. only available for barcharts. this is a coefficient of the bar width. for instance, if you wantthe spacing to be a half of the bar width, set this value to 0.5.",
	"Method": "void setBarSpacing(double spacing){\r\n    mBarSpacing = spacing;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.FollowerStateTest.testFollowerRejectsPollRequestWithLowerTerm",
	"Comment": "tests that a follower rejects a poll request with a lower term.",
	"Method": "void testFollowerRejectsPollRequestWithLowerTerm(){\r\n    runOnServer(() -> {\r\n        serverContext.setTerm(2).setLeader(0);\r\n        PollRequest request = PollRequest.builder().withTerm(1).withCandidate(members.get(1).hashCode()).withLogIndex(0).withLogTerm(0).build();\r\n        PollResponse response = state.poll(request).get();\r\n        threadAssertEquals(response.status(), Status.OK);\r\n        threadAssertEquals(serverContext.getTerm(), 2L);\r\n        threadAssertEquals(response.term(), 2L);\r\n        threadAssertFalse(response.accepted());\r\n    });\r\n}"
}, {
	"Path": "com.codename1.ui.Form.showDialog",
	"Comment": "the default version of show dialog shows the dialog occupying the center portionof the screen.",
	"Method": "void showDialog(boolean modal,boolean reverse){\r\n    int h = Display.getInstance().getDisplayHeight() - menuBar.getPreferredH() - title.getPreferredH();\r\n    int w = Display.getInstance().getDisplayWidth();\r\n    int topSpace = h / 100 * 20;\r\n    int bottomSpace = h / 100 * 10;\r\n    int sideSpace = w / 100 * 20;\r\n    showModal(topSpace, bottomSpace, sideSpace, sideSpace, true, modal, reverse);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.getId",
	"Comment": "returns the id used to reference this component in some constraints.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "String getId(){\r\n    return id;\r\n}"
}, {
	"Path": "ly.count.android.sdk.UserData.toJSON",
	"Comment": "creates and returns a jsonobject containing the user data from this object.",
	"Method": "JSONObject toJSON(){\r\n    final JSONObject json = new JSONObject();\r\n    try {\r\n        if (name != null)\r\n            if (name.equals(\"\"))\r\n                json.put(NAME_KEY, JSONObject.NULL);\r\n            else\r\n                json.put(NAME_KEY, name);\r\n        if (username != null)\r\n            if (username.equals(\"\"))\r\n                json.put(USERNAME_KEY, JSONObject.NULL);\r\n            else\r\n                json.put(USERNAME_KEY, username);\r\n        if (email != null)\r\n            if (email.equals(\"\"))\r\n                json.put(EMAIL_KEY, JSONObject.NULL);\r\n            else\r\n                json.put(EMAIL_KEY, email);\r\n        if (org != null)\r\n            if (org.equals(\"\"))\r\n                json.put(ORG_KEY, JSONObject.NULL);\r\n            else\r\n                json.put(ORG_KEY, org);\r\n        if (phone != null)\r\n            if (phone.equals(\"\"))\r\n                json.put(PHONE_KEY, JSONObject.NULL);\r\n            else\r\n                json.put(PHONE_KEY, phone);\r\n        if (picture != null)\r\n            if (picture.equals(\"\"))\r\n                json.put(PICTURE_KEY, JSONObject.NULL);\r\n            else\r\n                json.put(PICTURE_KEY, picture);\r\n        if (gender != null)\r\n            if (gender.equals(\"\"))\r\n                json.put(GENDER_KEY, JSONObject.NULL);\r\n            else\r\n                json.put(GENDER_KEY, gender);\r\n        if (byear != 0)\r\n            if (byear > 0)\r\n                json.put(BYEAR_KEY, byear);\r\n            else\r\n                json.put(BYEAR_KEY, JSONObject.NULL);\r\n        JSONObject ob;\r\n        if (custom != null) {\r\n            ob = new JSONObject(custom);\r\n        } else {\r\n            ob = new JSONObject();\r\n        }\r\n        if (customMods != null) {\r\n            for (Map.Entry<String, JSONObject> entry : customMods.entrySet()) {\r\n                ob.put(entry.getKey(), entry.getValue());\r\n            }\r\n        }\r\n        json.put(CUSTOM_KEY, ob);\r\n    } catch (JSONException e) {\r\n        if (Countly.sharedInstance().isLoggingEnabled()) {\r\n            Log.w(Countly.TAG, \"Got exception converting an UserData to JSON\", e);\r\n        }\r\n    }\r\n    return json;\r\n}"
}, {
	"Path": "com.codename1.components.SpanLabel.getTextAllStyles",
	"Comment": "returns the style proxy object for the text of this span button.",
	"Method": "Style getTextAllStyles(){\r\n    return text.getAllStyles();\r\n}"
}, {
	"Path": "com.codename1.components.SplitPane.getBottom",
	"Comment": "gets the component that is currently placed in the bottom of the split pane.",
	"Method": "Component getBottom(){\r\n    return getBottomOrRightComponent();\r\n}"
}, {
	"Path": "com.codename1.properties.UiBinding.createTableModel",
	"Comment": "creates a table model which is implicitly bound to the properties",
	"Method": "BoundTableModel createTableModel(List<? extends PropertyBusinessObject> objects,PropertyBusinessObject prototype,BoundTableModel createTableModel,CollectionProperty<? extends PropertyBusinessObject, ? extends Object> objects,PropertyBusinessObject prototype){\r\n    return new BoundTableModel(objects, prototype);\r\n}"
}, {
	"Path": "com.codename1.ui.Container.createAnimateHierarchy",
	"Comment": "animates a pending hierarchy of components into place, this effectively replaces revalidate with a more visual form of animation.",
	"Method": "ComponentAnimation createAnimateHierarchy(int duration){\r\n    return animateHierarchy(duration, false, 255, false);\r\n}"
}, {
	"Path": "android.support.v4.view.ViewPager.setInternalPageChangeListener",
	"Comment": "set a separate onpagechangelistener for internal use by the support library.",
	"Method": "OnPageChangeListener setInternalPageChangeListener(OnPageChangeListener listener){\r\n    OnPageChangeListener oldListener = mInternalPageChangeListener;\r\n    mInternalPageChangeListener = listener;\r\n    return oldListener;\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testPassiveReserveAvailabilityChange",
	"Comment": "tests detecting an availability change of a reserve member on a passive member.",
	"Method": "void testPassiveReserveAvailabilityChange(){\r\n    createServers(3);\r\n    CopycatServer passive = createServer(nextMember(Member.Type.PASSIVE));\r\n    passive.join(members.stream().map(Member::serverAddress).collect(Collectors.toList())).thenRun(this::resume);\r\n    await(10000);\r\n    Member reserveMember = nextMember(Member.Type.RESERVE);\r\n    passive.cluster().onJoin(member -> {\r\n        threadAssertEquals(member.address(), reserveMember.address());\r\n        member.onStatusChange(s -> {\r\n            threadAssertEquals(s, Member.Status.UNAVAILABLE);\r\n            resume();\r\n        });\r\n    });\r\n    CopycatServer reserve = createServer(reserveMember);\r\n    reserve.join(members.stream().map(Member::serverAddress).collect(Collectors.toList())).thenRun(this::resume);\r\n    await(10000);\r\n    reserve.shutdown().thenRun(this::resume);\r\n    await(10000, 2);\r\n}"
}, {
	"Path": "com.codename1.processing.AbstractEvaluator.evaluate",
	"Comment": "evaluate the predicate expression against an array of elements.",
	"Method": "Object evaluate(StructuredContent element,Object evaluate,List elements){\r\n    return _evaluate(elements);\r\n}"
}, {
	"Path": "com.codename1.ui.table.TableLayout.setMinimumSizePerColumn",
	"Comment": "sets the minimum size for a column in the table, this is applicable for tables that arenot scrollable on the x axis. this will force the earlier columns to leave room forthe latter columns.",
	"Method": "void setMinimumSizePerColumn(int minimumSize){\r\n    minimumSizePerColumn = minimumSize;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.deregisterPush",
	"Comment": "stop receiving push notifications to this client application",
	"Method": "void deregisterPush(){\r\n    Preferences.delete(\"PollingPush\");\r\n    stopPolling();\r\n}"
}, {
	"Path": "com.codename1.io.rest.RequestBuilder.fetchAsBytes",
	"Comment": "executes the request asynchronously and writes the response to the providedcallback",
	"Method": "ConnectionRequest fetchAsBytes(OnComplete<Response<byte[]>> callback){\r\n    return getAsBytesAsyncImpl(callback);\r\n}"
}, {
	"Path": "com.codename1.impl.blackberry.TransportDetective.determineTransportType",
	"Comment": "given a service record, determines the transport it represents.",
	"Method": "int determineTransportType(ServiceRecord serviceRecord){\r\n    String cid = serviceRecord.getCid();\r\n    if (\"ippp\".equalsIgnoreCase(cid)) {\r\n        int ippType = getEncodedIntFromIPPPServiceRecord(serviceRecord, SERVICE_RECORD_TYPE_IPPP_TAG);\r\n        if (ippType == SERVICE_RECORD_TYPE_IPPP_PUBLIC) {\r\n            int result = 0;\r\n            srBis = serviceRecord;\r\n            result |= TRANSPORT_BIS_B;\r\n            return result;\r\n        } else if ((ippType == SERVICE_RECORD_TYPE_IPPP_CORPORATE) || (ippType != SERVICE_RECORD_TYPE_IPPP_PROVISIONING)) {\r\n            srMds = serviceRecord;\r\n            return TRANSPORT_MDS;\r\n        }\r\n    }\r\n    if (\"wptcp\".equalsIgnoreCase(cid)) {\r\n        String interfaceName = getEncodedStringFieldFromWptcpServiceRecord(serviceRecord, ENCODED_TYPE_INTERFACE);\r\n        if (SERVICE_RECORD_TYPE_WPTCP_INTERFACE_WIFI.equals(interfaceName)) {\r\n            srTcpWiFi = serviceRecord;\r\n            return TRANSPORT_TCP_WIFI;\r\n        } else {\r\n            String mmscUrl = getEncodedStringFieldFromWptcpServiceRecord(serviceRecord, ENCODED_TYPE_MMSC_URL);\r\n            String httpProxyAddress = getEncodedStringFieldFromWptcpServiceRecord(serviceRecord, ENCODED_TYPE_HTTP_PROXY_ADDRESS);\r\n            if ((mmscUrl == null) || (mmscUrl.trim().length() == 0)) {\r\n                if (getEncodedIntFieldFromWptcpServiceRecord(serviceRecord, ENCODED_TYPE_PROXY_AUTH_USERNAME_TYPE) != AUTH_TYPE_BBAUTH_TOKEN_NEGOTIATION) {\r\n                    if ((httpProxyAddress == null) || (httpProxyAddress.trim().length() == 0)) {\r\n                        srTcpCellularWithApn = serviceRecord;\r\n                        return TCP_CELLULAR_APN_SERVICE_BOOK;\r\n                    } else {\r\n                        srWap2 = serviceRecord;\r\n                        return TRANSPORT_WAP2;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (\"wap\".equalsIgnoreCase(cid)) {\r\n        String mmscUrl = getEncodedStringFieldFromWapServiceRecord(serviceRecord, SERVICE_RECORD_TYPE_WAP_MMSC_URL_TAG);\r\n        if ((mmscUrl == null) || (mmscUrl.trim().length() == 0)) {\r\n            srWap = serviceRecord;\r\n            return TRANSPORT_WAP;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.codename1.charts.renderers.XYMultipleSeriesRenderer.getPointSize",
	"Comment": "returns the size of the points, for charts displaying points.",
	"Method": "float getPointSize(){\r\n    return mPointSize;\r\n}"
}, {
	"Path": "org.conscrypt.TrustManagerImpl.findTrustAnchorBySubjectAndPublicKey",
	"Comment": "check the trustedcertificateindex for the cert to see if it isalready trusted and failing that check the keystore if it isavailable.",
	"Method": "TrustAnchor findTrustAnchorBySubjectAndPublicKey(X509Certificate cert){\r\n    TrustAnchor trustAnchor = trustedCertificateIndex.findBySubjectAndPublicKey(cert);\r\n    if (trustAnchor != null) {\r\n        return trustAnchor;\r\n    }\r\n    if (trustedCertificateStore == null) {\r\n        return null;\r\n    }\r\n    X509Certificate systemCert = trustedCertificateStore.getTrustAnchor(cert);\r\n    if (systemCert != null) {\r\n        return new TrustAnchor(systemCert, null);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.sizeGroupY",
	"Comment": "the size group that this component should be placed in.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC sizeGroupY(String s){\r\n    ver.setSizeGroup(s);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.sizeGroupX",
	"Comment": "specifies that the component should be put in the size group s and will thus share the same size\tas them within the group.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC sizeGroupX(String s){\r\n    hor.setSizeGroup(s);\r\n    return this;\r\n}"
}, {
	"Path": "misc.TernarySearch.ternarySearch",
	"Comment": "finds maximum of strictly increasing and then strictly decreasing function",
	"Method": "double ternarySearch(DoubleUnaryOperator f,double lo,double hi,int ternarySearch,IntUnaryOperator f,int fromInclusive,int toInclusive){\r\n    int lo = fromInclusive;\r\n    int hi = toInclusive;\r\n    while (hi > lo + 2) {\r\n        int m1 = lo + (hi - lo) / 3;\r\n        int m2 = hi - (hi - lo) / 3;\r\n        if (f.applyAsInt(m1) < f.applyAsInt(m2))\r\n            lo = m1;\r\n        else\r\n            hi = m2;\r\n    }\r\n    int res = lo;\r\n    for (int i = lo + 1; i <= hi; i++) if (f.applyAsInt(res) < f.applyAsInt(i))\r\n        res = i;\r\n    return res;\r\n}"
}, {
	"Path": "com.codename1.charts.views.LineChart.isRenderPoints",
	"Comment": "returns if the chart should display the points as a certain shape.",
	"Method": "boolean isRenderPoints(SimpleSeriesRenderer renderer){\r\n    return ((XYSeriesRenderer) renderer).getPointStyle() != PointStyle.POINT;\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.createCommandList",
	"Comment": "creates the list component containing the commands within the given vectorused for showing the menu dialog",
	"Method": "List createCommandList(Vector commands){\r\n    List l = new List(commands);\r\n    l.setUIID(\"CommandList\");\r\n    Component c = (Component) l.getRenderer();\r\n    c.setUIID(\"Command\");\r\n    c = l.getRenderer().getListFocusComponent(l);\r\n    c.setUIID(\"CommandFocus\");\r\n    l.setFixedSelection(List.FIXED_NONE_CYCLIC);\r\n    if (parent.getUIManager().isThemeConstant(\"menuPrefSizeBool\", false)) {\r\n        l.setListSizeCalculationSampleCount(50);\r\n    }\r\n    return l;\r\n}"
}, {
	"Path": "com.codename1.testing.TestUtils.assertTitle",
	"Comment": "verifies the current title is the same otherwise throws an exception",
	"Method": "void assertTitle(String title){\r\n    if (verbose) {\r\n        log(\"assertTitle(\" + title + \")\");\r\n    }\r\n    assertBool(Display.getInstance().getCurrent().getTitle().equals(title), title);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.GroupLayout.areParallelSiblings",
	"Comment": "returns true if the two components have a common parallelgroup ancestoralong the particular axis.",
	"Method": "boolean areParallelSiblings(Component source,Component target,int axis){\r\n    ComponentInfo sourceInfo = getComponentInfo(source);\r\n    ComponentInfo targetInfo = getComponentInfo(target);\r\n    Spring sourceSpring;\r\n    Spring targetSpring;\r\n    if (axis == HORIZONTAL) {\r\n        sourceSpring = sourceInfo.horizontalSpring;\r\n        targetSpring = targetInfo.horizontalSpring;\r\n    } else {\r\n        sourceSpring = sourceInfo.verticalSpring;\r\n        targetSpring = targetInfo.verticalSpring;\r\n    }\r\n    ArrayList sourcePath = tmpParallelSet;\r\n    sourcePath.clear();\r\n    Spring spring = sourceSpring.getParent();\r\n    while (spring != null) {\r\n        sourcePath.add(spring);\r\n        spring = spring.getParent();\r\n    }\r\n    spring = targetSpring.getParent();\r\n    while (spring != null) {\r\n        if (sourcePath.contains(spring)) {\r\n            sourcePath.clear();\r\n            while (spring != null) {\r\n                if (spring instanceof ParallelGroup) {\r\n                    return true;\r\n                }\r\n                spring = spring.getParent();\r\n            }\r\n            return false;\r\n        }\r\n        spring = spring.getParent();\r\n    }\r\n    sourcePath.clear();\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.impl.android.InPlaceEditView.waitForEditCompletion",
	"Comment": "this method waits until the user leaves the edittextit must not access sinstance since it might not have been created yet.",
	"Method": "void waitForEditCompletion(){\r\n    Display.getInstance().invokeAndBlock(new Runnable() {\r\n        public void run() {\r\n            while (waitingForSynchronousEditingCompletion) {\r\n                try {\r\n                    Thread.sleep(50);\r\n                } catch (Throwable e) {\r\n                }\r\n            }\r\n            ;\r\n        }\r\n    });\r\n    Log.d(TAG, \"waitForEditCompletion - Waiting for lock\");\r\n}"
}, {
	"Path": "com.codename1.impl.android.InPlaceEditView.waitForEditCompletion",
	"Comment": "this method waits until the user leaves the edittextit must not access sinstance since it might not have been created yet.",
	"Method": "void waitForEditCompletion(){\r\n    while (waitingForSynchronousEditingCompletion) {\r\n        try {\r\n            Thread.sleep(50);\r\n        } catch (Throwable e) {\r\n        }\r\n    }\r\n    ;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.deinitializeImpl",
	"Comment": "cleansup the initialization flags in the hierachy, notice that paint calls mightstill occur after deinitilization mostly to perform transitions etc.however interactivity, animation and event tracking code can and probablyshould be removed by this method.",
	"Method": "void deinitializeImpl(){\r\n    if (isInitialized()) {\r\n        hideNativeOverlay();\r\n        paintLockRelease();\r\n        setInitialized(false);\r\n        setDirtyRegion(null);\r\n        Style stl = getStyle();\r\n        Image i = stl.getBgImage();\r\n        if (i != null) {\r\n            i.unlock();\r\n        } else {\r\n            Border b = stl.getBorder();\r\n            if (b != null) {\r\n                b.unlock();\r\n            }\r\n        }\r\n        Painter p = stl.getBgPainter();\r\n        if (p instanceof BGPainter) {\r\n            ((BGPainter) p).radialCache = null;\r\n        }\r\n        deinitialize();\r\n        if (refreshTaskDragListener != null) {\r\n            Form f = getComponentForm();\r\n            f.removePointerDraggedListener(refreshTaskDragListener);\r\n            f.removePointerPressedListener(refreshTaskDragListener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isBuiltinSoundAvailable",
	"Comment": "indicates whether a user installed or system sound is available",
	"Method": "boolean isBuiltinSoundAvailable(String soundIdentifier){\r\n    return builtinSounds.containsKey(soundIdentifier);\r\n}"
}, {
	"Path": "com.codename1.io.BufferedOutputStream.flush",
	"Comment": "flushes this buffered output stream. this forces any buffered output bytes to be written out to the underlying output stream.",
	"Method": "void flush(){\r\n    if (closed) {\r\n        return;\r\n    }\r\n    flushBuffer();\r\n    out.flush();\r\n    lastActivityTime = System.currentTimeMillis();\r\n}"
}, {
	"Path": "com.codename1.ui.events.ActionEvent.getKeyEvent",
	"Comment": "if this event was triggered by a key press this method will return the appropriate keycode",
	"Method": "int getKeyEvent(){\r\n    return keyEvent;\r\n}"
}, {
	"Path": "com.codename1.impl.javase.JavaSEPort.makeTransformInverse",
	"Comment": "gets the inverse transformation for the provided transform.",
	"Method": "Object makeTransformInverse(Object nativeTransform){\r\n    try {\r\n        return clamp(((AffineTransform) nativeTransform).createInverse());\r\n    } catch (Exception ex) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractSet.equals",
	"Comment": "compares the specified object to this set and returns true if they areequal. the object must be an instance of set and contain the sameobjects.",
	"Method": "boolean equals(Object object){\r\n    if (this == object) {\r\n        return true;\r\n    }\r\n    if (object instanceof Set) {\r\n        Set<?> s = (Set<?>) object;\r\n        try {\r\n            return size() == s.size() && containsAll(s);\r\n        } catch (NullPointerException ignored) {\r\n            return false;\r\n        } catch (ClassCastException ignored) {\r\n            return false;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "android.support.v4.app.ListFragment.setEmptyText",
	"Comment": "the default content for a listfragment has a textview that canbe shown when the list is empty.if you would like to have itshown, call this method to supply the text it should use.",
	"Method": "void setEmptyText(CharSequence text){\r\n    ensureList();\r\n    if (mStandardEmptyView == null) {\r\n        throw new IllegalStateException(\"Can't be used with a custom content view\");\r\n    }\r\n    mStandardEmptyView.setText(text);\r\n    if (mEmptyText == null) {\r\n        mList.setEmptyView(mStandardEmptyView);\r\n    }\r\n    mEmptyText = text;\r\n}"
}, {
	"Path": "io.atomix.copycat.protocol.OperationResponse.lastSequence",
	"Comment": "returns the last in sequence command.this argument is only populated if the command request failed.",
	"Method": "long lastSequence(){\r\n    return lastSequence;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.CommonTransitions.createEmpty",
	"Comment": "creates an empty transition that does nothing. this has the same effect assetting a transition to null.",
	"Method": "CommonTransitions createEmpty(){\r\n    CommonTransitions t = new CommonTransitions(TYPE_EMPTY);\r\n    return t;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.CommonTransitions.createUncover",
	"Comment": "creates a uncover transition with the given duration and direction",
	"Method": "CommonTransitions createUncover(int type,boolean forward,int duration){\r\n    CommonTransitions t = new CommonTransitions(TYPE_UNCOVER);\r\n    t.slideType = type;\r\n    t.forward = forward;\r\n    t.speed = duration;\r\n    t.position = 0;\r\n    return t;\r\n}"
}, {
	"Path": "com.codename1.designer.PreviewInSimulator.main",
	"Comment": "called back from simulatedeviceactionperformed to show the simulator skin",
	"Method": "void main(String[] argv){\r\n    com.codename1.ui.Display.init(new Runnable() {\r\n        public void run() {\r\n            try {\r\n                Preferences pref = Preferences.userNodeForPackage(PreviewInSimulator.class);\r\n                String theme = pref.get(\"previewTheme\", null);\r\n                File resFile = new File(pref.get(\"previewResource\", null));\r\n                String baseResDir = pref.get(\"baseResourceDir\", null);\r\n                if (baseResDir != null) {\r\n                    JavaSEPort.setBaseResourceDir(new File(baseResDir));\r\n                }\r\n                String selection = pref.get(\"previewSelection\", null);\r\n                Resources res = Resources.open(new FileInputStream(resFile));\r\n                if (theme == null || theme.length() == 0) {\r\n                    if (com.codename1.ui.Display.getInstance().hasNativeTheme()) {\r\n                        com.codename1.ui.Display.getInstance().installNativeTheme();\r\n                    }\r\n                } else {\r\n                    com.codename1.ui.plaf.UIManager.getInstance().setThemeProps(res.getTheme(theme));\r\n                }\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"Table\", com.codename1.ui.table.Table.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"MediaPlayer\", com.codename1.components.MediaPlayer.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"ContainerList\", com.codename1.ui.list.ContainerList.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"ComponentGroup\", com.codename1.ui.ComponentGroup.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"Tree\", com.codename1.ui.tree.Tree.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"HTMLComponent\", com.codename1.ui.html.HTMLComponent.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"RSSReader\", com.codename1.components.RSSReader.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"FileTree\", com.codename1.components.FileTree.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"WebBrowser\", com.codename1.components.WebBrowser.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"NumericSpinner\", com.codename1.ui.spinner.NumericSpinner.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"DateSpinner\", com.codename1.ui.spinner.DateSpinner.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"TimeSpinner\", com.codename1.ui.spinner.TimeSpinner.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"DateTimeSpinner\", com.codename1.ui.spinner.DateTimeSpinner.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"GenericSpinner\", com.codename1.ui.spinner.GenericSpinner.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"LikeButton\", com.codename1.facebook.ui.LikeButton.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"InfiniteProgress\", com.codename1.components.InfiniteProgress.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"MultiButton\", com.codename1.components.MultiButton.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"SpanButton\", com.codename1.components.SpanButton.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"SpanLabel\", com.codename1.components.SpanLabel.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"Ads\", com.codename1.components.Ads.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"MapComponent\", com.codename1.maps.MapComponent.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"MultiList\", com.codename1.ui.list.MultiList.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"ShareButton\", com.codename1.components.ShareButton.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"OnOffSwitch\", com.codename1.components.OnOffSwitch.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"ImageViewer\", com.codename1.components.ImageViewer.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"AutoCompleteTextField\", com.codename1.ui.AutoCompleteTextField.class);\r\n                com.codename1.ui.util.UIBuilder.registerCustomComponent(\"Picker\", com.codename1.ui.spinner.Picker.class);\r\n                com.codename1.ui.util.UIBuilder builder = new com.codename1.ui.util.UIBuilder();\r\n                com.codename1.ui.Container c = builder.createContainer(res, selection);\r\n                if (c instanceof com.codename1.ui.Form) {\r\n                    ((com.codename1.ui.Form) c).refreshTheme();\r\n                    if (c instanceof com.codename1.ui.Dialog) {\r\n                        ((com.codename1.ui.Dialog) c).showModeless();\r\n                    } else {\r\n                        ((com.codename1.ui.Form) c).show();\r\n                    }\r\n                } else {\r\n                    com.codename1.ui.Form f = new com.codename1.ui.Form();\r\n                    f.setLayout(new com.codename1.ui.layouts.BorderLayout());\r\n                    f.addComponent(com.codename1.ui.layouts.BorderLayout.CENTER, c);\r\n                    f.refreshTheme();\r\n                    f.show();\r\n                }\r\n            } catch (Exception ex) {\r\n                ex.printStackTrace();\r\n                JOptionPane.showMessageDialog(null, \"Error While Running In Simulator: \" + ex, \"Error\", JOptionPane.ERROR_MESSAGE);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.codename1.designer.PreviewInSimulator.main",
	"Comment": "called back from simulatedeviceactionperformed to show the simulator skin",
	"Method": "void main(String[] argv){\r\n    try {\r\n        Preferences pref = Preferences.userNodeForPackage(PreviewInSimulator.class);\r\n        String theme = pref.get(\"previewTheme\", null);\r\n        File resFile = new File(pref.get(\"previewResource\", null));\r\n        String baseResDir = pref.get(\"baseResourceDir\", null);\r\n        if (baseResDir != null) {\r\n            JavaSEPort.setBaseResourceDir(new File(baseResDir));\r\n        }\r\n        String selection = pref.get(\"previewSelection\", null);\r\n        Resources res = Resources.open(new FileInputStream(resFile));\r\n        if (theme == null || theme.length() == 0) {\r\n            if (com.codename1.ui.Display.getInstance().hasNativeTheme()) {\r\n                com.codename1.ui.Display.getInstance().installNativeTheme();\r\n            }\r\n        } else {\r\n            com.codename1.ui.plaf.UIManager.getInstance().setThemeProps(res.getTheme(theme));\r\n        }\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"Table\", com.codename1.ui.table.Table.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"MediaPlayer\", com.codename1.components.MediaPlayer.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"ContainerList\", com.codename1.ui.list.ContainerList.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"ComponentGroup\", com.codename1.ui.ComponentGroup.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"Tree\", com.codename1.ui.tree.Tree.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"HTMLComponent\", com.codename1.ui.html.HTMLComponent.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"RSSReader\", com.codename1.components.RSSReader.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"FileTree\", com.codename1.components.FileTree.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"WebBrowser\", com.codename1.components.WebBrowser.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"NumericSpinner\", com.codename1.ui.spinner.NumericSpinner.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"DateSpinner\", com.codename1.ui.spinner.DateSpinner.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"TimeSpinner\", com.codename1.ui.spinner.TimeSpinner.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"DateTimeSpinner\", com.codename1.ui.spinner.DateTimeSpinner.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"GenericSpinner\", com.codename1.ui.spinner.GenericSpinner.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"LikeButton\", com.codename1.facebook.ui.LikeButton.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"InfiniteProgress\", com.codename1.components.InfiniteProgress.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"MultiButton\", com.codename1.components.MultiButton.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"SpanButton\", com.codename1.components.SpanButton.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"SpanLabel\", com.codename1.components.SpanLabel.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"Ads\", com.codename1.components.Ads.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"MapComponent\", com.codename1.maps.MapComponent.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"MultiList\", com.codename1.ui.list.MultiList.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"ShareButton\", com.codename1.components.ShareButton.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"OnOffSwitch\", com.codename1.components.OnOffSwitch.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"ImageViewer\", com.codename1.components.ImageViewer.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"AutoCompleteTextField\", com.codename1.ui.AutoCompleteTextField.class);\r\n        com.codename1.ui.util.UIBuilder.registerCustomComponent(\"Picker\", com.codename1.ui.spinner.Picker.class);\r\n        com.codename1.ui.util.UIBuilder builder = new com.codename1.ui.util.UIBuilder();\r\n        com.codename1.ui.Container c = builder.createContainer(res, selection);\r\n        if (c instanceof com.codename1.ui.Form) {\r\n            ((com.codename1.ui.Form) c).refreshTheme();\r\n            if (c instanceof com.codename1.ui.Dialog) {\r\n                ((com.codename1.ui.Dialog) c).showModeless();\r\n            } else {\r\n                ((com.codename1.ui.Form) c).show();\r\n            }\r\n        } else {\r\n            com.codename1.ui.Form f = new com.codename1.ui.Form();\r\n            f.setLayout(new com.codename1.ui.layouts.BorderLayout());\r\n            f.addComponent(com.codename1.ui.layouts.BorderLayout.CENTER, c);\r\n            f.refreshTheme();\r\n            f.show();\r\n        }\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n        JOptionPane.showMessageDialog(null, \"Error While Running In Simulator: \" + ex, \"Error\", JOptionPane.ERROR_MESSAGE);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Toolbar.findCommandComponent",
	"Comment": "find the command component instance if such an instance exists",
	"Method": "Button findCommandComponent(Command c,Button findCommandComponent,Command c,Container cnt){\r\n    int count = cnt.getComponentCount();\r\n    for (int iter = 0; iter < count; iter++) {\r\n        Component current = cnt.getComponentAt(iter);\r\n        if (current instanceof Button) {\r\n            Button b = (Button) current;\r\n            if (b.getCommand() == c || sideMenu.unwrapCommand(b.getCommand()) == c) {\r\n                return b;\r\n            }\r\n        } else {\r\n            if (current instanceof Container) {\r\n                Button b = findCommandComponent(c, (Container) current);\r\n                if (b != null) {\r\n                    return b;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.refreshTheme",
	"Comment": "this method is a callback to the lookandfeel when a theme is being changed in the uimanager",
	"Method": "void refreshTheme(boolean completeClear){\r\n    fadeScrollTop = null;\r\n    fadeScrollBottom = null;\r\n    fadeScrollRight = null;\r\n    fadeScrollLeft = null;\r\n    initScroll();\r\n    if (menuRenderer != null) {\r\n        if (menuRenderer instanceof Component) {\r\n            ((Component) menuRenderer).refreshTheme();\r\n        }\r\n    }\r\n    Toolbar.setGlobalToolbar(manager.isThemeConstant(\"globalToobarBool\", Toolbar.isGlobalToolbar()));\r\n    boolean isTouch = Display.getInstance().isTouchScreenDevice();\r\n    scrollVisible = manager.isThemeConstant(\"scrollVisibleBool\", true);\r\n    fadeScrollEdge = manager.isThemeConstant(\"fadeScrollEdgeBool\", false);\r\n    fadeScrollEdgeLength = manager.getThemeConstant(\"fadeScrollEdgeInt\", fadeScrollEdgeLength);\r\n    fadeScrollBar = manager.isThemeConstant(\"fadeScrollBarBool\", false);\r\n    try {\r\n        tickerSpeed = Long.parseLong(manager.getThemeConstant(\"tickerSpeedInt\", \"\" + tickerSpeed));\r\n        if (tickerSpeed < 1) {\r\n            Label.setDefaultTickerEnabled(false);\r\n        } else {\r\n            Label.setDefaultTickerEnabled(true);\r\n        }\r\n    } catch (NumberFormatException err) {\r\n        Log.e(err);\r\n    }\r\n    Button.setCapsTextDefault(manager.isThemeConstant(\"capsButtonTextBool\", false));\r\n    Button.setButtonRippleEffectDefault(manager.isThemeConstant(\"buttonRippleBool\", false));\r\n    defaultFormTintColor = (int) Long.parseLong(manager.getThemeConstant(\"tintColor\", Integer.toHexString(defaultFormTintColor)), 16);\r\n    disableColor = Integer.parseInt(manager.getThemeConstant(\"disabledColor\", Integer.toHexString(disableColor)), 16);\r\n    Dialog.setDefaultDialogPosition(manager.getThemeConstant(\"dialogPosition\", Dialog.getDefaultDialogPosition()));\r\n    Dialog.setCommandsAsButtons(manager.isThemeConstant(\"dialogButtonCommandsBool\", Dialog.isCommandsAsButtons()));\r\n    Dialog.setDefaultBlurBackgroundRadius(manager.getThemeConstant(\"dialogBlurRadiusInt\", (int) Dialog.getDefaultBlurBackgroundRadius()));\r\n    List.setDefaultIgnoreFocusComponentWhenUnfocused(manager.isThemeConstant(\"ignorListFocusBool\", List.isDefaultIgnoreFocusComponentWhenUnfocused()));\r\n    if (isTouch) {\r\n        Display.getInstance().setPureTouch(manager.isThemeConstant(\"pureTouchBool\", Display.getInstance().isPureTouch()));\r\n    }\r\n    int defaultTransitionSpeed = Integer.parseInt(manager.getThemeConstant(\"transitionSpeedInt\", \"220\"));\r\n    String slideDir = manager.getThemeConstant(\"slideDirection\", \"horizontal\");\r\n    String dialogSlideDir = manager.getThemeConstant(\"dlgSlideDirection\", \"vertical\");\r\n    String menuSlideDir = manager.getThemeConstant(\"menuSlideDirection\", dialogSlideDir);\r\n    boolean outdir = manager.isThemeConstant(\"slideOutDirBool\", false);\r\n    boolean indir = manager.isThemeConstant(\"slideInDirBool\", true);\r\n    boolean dialogOutdir = manager.isThemeConstant(\"dlgSlideOutDirBool\", false);\r\n    boolean dialogIndir = manager.isThemeConstant(\"dlgSlideInDirBool\", true);\r\n    boolean menuOutdir = manager.isThemeConstant(\"menuSlideOutDirBool\", false);\r\n    boolean menuIndir = manager.isThemeConstant(\"menuSlideInDirBool\", true);\r\n    defaultFormTransitionIn = getTransitionConstant(defaultFormTransitionIn, \"formTransitionIn\", slideDir, defaultTransitionSpeed, indir);\r\n    defaultFormTransitionOut = getTransitionConstant(defaultFormTransitionOut, \"formTransitionOut\", slideDir, defaultTransitionSpeed, outdir);\r\n    defaultMenuTransitionIn = getTransitionConstant(defaultMenuTransitionIn, \"menuTransitionIn\", menuSlideDir, defaultTransitionSpeed, menuIndir);\r\n    defaultMenuTransitionOut = getTransitionConstant(defaultMenuTransitionOut, \"menuTransitionOut\", menuSlideDir, defaultTransitionSpeed, menuOutdir);\r\n    defaultDialogTransitionIn = getTransitionConstant(defaultDialogTransitionIn, \"dialogTransitionIn\", dialogSlideDir, defaultTransitionSpeed, dialogIndir);\r\n    defaultDialogTransitionOut = getTransitionConstant(defaultDialogTransitionOut, \"dialogTransitionOut\", dialogSlideDir, defaultTransitionSpeed, dialogOutdir);\r\n    initCommandBehaviorConstant(manager.getThemeConstant(\"commandBehavior\", null), completeClear);\r\n    reverseSoftButtons = manager.isThemeConstant(\"reverseSoftButtonsBool\", reverseSoftButtons);\r\n    textFieldCursorColor = manager.getThemeConstant(\"textFieldCursorColorInt\", 0);\r\n    String gap = manager.getThemeConstant(\"labelGap\", null);\r\n    if (gap != null) {\r\n        Label.setDefaultGap(Display.getInstance().convertToPixels(Util.toFloatValue(gap)));\r\n    }\r\n    InfiniteProgress.setDefaultMaterialDesignMode(manager.isThemeConstant(\"infiniteProgressMaterialModeBool\", false));\r\n    InfiniteProgress.setDefaultMaterialDesignColor(manager.getThemeConstant(\"infiniteProgressMaterialColorInt\", 0x6200ee));\r\n    TextArea.setDefaultValign(manager.getThemeConstant(\"textCmpVAlignInt\", TextArea.getDefaultValign()));\r\n    defaultSnapToGrid = manager.isThemeConstant(\"snapGridBool\", false);\r\n    defaultAlwaysTensile = manager.isThemeConstant(\"alwaysTensileBool\", false);\r\n    defaultTensileDrag = manager.isThemeConstant(\"tensileDragBool\", true);\r\n    defaultEndsWith3Points = manager.isThemeConstant(\"endsWith3PointsBool\", false);\r\n    defaultTensileHighlight = manager.isThemeConstant(\"tensileHighlightBool\", false);\r\n    tensileHighlightBottomImage = null;\r\n    tensileHighlightTopImage = null;\r\n    if (defaultTensileHighlight) {\r\n        tensileHighlightBottomImage = manager.getThemeImageConstant(\"tensileHighlightBottomImage\");\r\n        tensileHighlightTopImage = manager.getThemeImageConstant(\"tensileHighlightTopImage\");\r\n        tensileGlowBottomImage = manager.getThemeImageConstant(\"tensileGlowBottomImage\");\r\n        tensileGlowTopImage = manager.getThemeImageConstant(\"tensileGlowTopImage\");\r\n        if (tensileHighlightBottomImage != null && tensileHighlightTopImage != null) {\r\n            defaultTensileDrag = true;\r\n            defaultAlwaysTensile = false;\r\n        } else {\r\n            defaultTensileHighlight = false;\r\n        }\r\n    }\r\n    backgroundImageDetermineSize = manager.isThemeConstant(\"bgImageSizeBool\", false);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Collections.singleton",
	"Comment": "returns a set containing the specified element. the set cannot bemodified. the set is serializable.",
	"Method": "Set<E> singleton(E object){\r\n    return new SingletonSet<E>(object);\r\n}"
}, {
	"Path": "com.codename1.ui.Component.setDisabledStyle",
	"Comment": "changes the component disalbed style by replacing the component style with the given style",
	"Method": "void setDisabledStyle(Style style){\r\n    if (this.disabledStyle != null) {\r\n        this.disabledStyle.removeStyleListener(this);\r\n    }\r\n    this.disabledStyle = style;\r\n    this.disabledStyle.addStyleListener(this);\r\n    if (this.disabledStyle.getBgPainter() == null) {\r\n        this.disabledStyle.setBgPainter(new BGPainter());\r\n    }\r\n    setShouldCalcPreferredSize(true);\r\n    checkAnimation();\r\n}"
}, {
	"Path": "java.util.Vector.capacity",
	"Comment": "returns the number of elements this vector can hold without growing.",
	"Method": "int capacity(){\r\n    return elementData.length;\r\n}"
}, {
	"Path": "com.codename1.payments.v3.Security.verify",
	"Comment": "verifies that the signature from the server matches the computedsignature on the data.returns true if the data is correctly signed.",
	"Method": "boolean verify(PublicKey publicKey,String signedData,String signature){\r\n    Signature sig;\r\n    try {\r\n        sig = Signature.getInstance(SIGNATURE_ALGORITHM);\r\n        sig.initVerify(publicKey);\r\n        sig.update(signedData.getBytes());\r\n        if (!sig.verify(Base64.decode(signature))) {\r\n            Log.e(TAG, \"Signature verification failed.\");\r\n            return false;\r\n        }\r\n        return true;\r\n    } catch (NoSuchAlgorithmException e) {\r\n        Log.e(TAG, \"NoSuchAlgorithmException.\");\r\n    } catch (InvalidKeyException e) {\r\n        Log.e(TAG, \"Invalid key specification.\");\r\n    } catch (SignatureException e) {\r\n        Log.e(TAG, \"Signature exception.\");\r\n    } catch (Base64DecoderException e) {\r\n        Log.e(TAG, \"Base64 decoding failed.\");\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.util.regex.RE.match",
	"Comment": "matches the current regular expression program against a string.",
	"Method": "boolean match(String search,int i,boolean match,CharacterIterator search,int i,boolean match,String search){\r\n    return match(search, 0);\r\n}"
}, {
	"Path": "com.codename1.ui.util.EventDispatcher.fireActionEvent",
	"Comment": "fires the event safely on the edt without risk of concurrency errors",
	"Method": "void fireActionEvent(ActionEvent ev){\r\n    if (listeners == null || listeners.size() == 0) {\r\n        return;\r\n    }\r\n    boolean isEdt = Display.getInstance().isEdt();\r\n    if (isEdt && listeners.size() == 1) {\r\n        ActionListener a = (ActionListener) listeners.get(0);\r\n        a.actionPerformed(ev);\r\n        return;\r\n    }\r\n    ActionListener[] array;\r\n    synchronized (this) {\r\n        array = new ActionListener[listeners.size()];\r\n        int alen = array.length;\r\n        for (int iter = 0; iter < alen; iter++) {\r\n            array[iter] = (ActionListener) listeners.get(iter);\r\n        }\r\n    }\r\n    if (isEdt) {\r\n        fireActionSync(array, ev);\r\n    } else {\r\n        actionListenerArray = true;\r\n        Runnable cl = new CallbackClass(array, ev);\r\n        if (blocking) {\r\n            Display.getInstance().callSeriallyAndWait(cl);\r\n        } else {\r\n            Display.getInstance().callSerially(cl);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.components.SpanButton.isShouldLocalize",
	"Comment": "indicates if text should be localized when set to the component, bydefault all text is localized so this allows disabling automaticlocalization for a specific component.",
	"Method": "boolean isShouldLocalize(){\r\n    return shouldLocalize;\r\n}"
}, {
	"Path": "com.codename1.components.InteractionDialog.disposeToTheTop",
	"Comment": "removes the interaction dialog from view with an animation to the top",
	"Method": "void disposeToTheTop(){\r\n    disposeTo(Component.TOP);\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isNativeShareSupported",
	"Comment": "indicates if the underlying platform supports sharing capabilities",
	"Method": "boolean isNativeShareSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.html.CSSEngine.setTextAlignmentRecursive",
	"Comment": "sets the alignment of the component and all its children according to the given alignment",
	"Method": "void setTextAlignmentRecursive(Component cmp,int align){\r\n    if (cmp instanceof Container) {\r\n        Container cont = (Container) cmp;\r\n        if (cont.getLayout() instanceof FlowLayout) {\r\n            cont.setLayout(new FlowLayout(align));\r\n        }\r\n        for (int i = 0; i < cont.getComponentCount(); i++) {\r\n            setTextAlignmentRecursive(cont.getComponentAt(i), align);\r\n        }\r\n    } else if ((HTMLComponent.FIXED_WIDTH) && (cmp instanceof Label)) {\r\n        ((Label) cmp).setAlignment(align);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.MigLayout.setRowConstraints",
	"Comment": "sets the row layout constraints for the layout manager instance as astring.see the class javadocs for information on how this string is formatted.",
	"Method": "void setRowConstraints(Object constr){\r\n    if (constr == null || constr instanceof String) {\r\n        constr = ConstraintParser.prepare((String) constr);\r\n        rowSpecs = ConstraintParser.parseRowConstraints((String) constr);\r\n    } else if (constr instanceof AC) {\r\n        rowSpecs = (AC) constr;\r\n    } else {\r\n        throw new IllegalArgumentException(\"Illegal constraint type: \" + constr.getClass().toString());\r\n    }\r\n    rowConstraints = constr;\r\n    dirty = true;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.LayoutUtil.roundSizes",
	"Comment": "round a number of float sizes into int sizes so that the total length match up",
	"Method": "int[] roundSizes(float[] sizes){\r\n    int[] retInts = new int[sizes.length];\r\n    float posD = 0;\r\n    for (int i = 0; i < retInts.length; i++) {\r\n        int posI = (int) (posD + 0.5f);\r\n        posD += sizes[i];\r\n        retInts[i] = (int) (posD + 0.5f) - posI;\r\n    }\r\n    return retInts;\r\n}"
}, {
	"Path": "java.net.URIHelper.encodeEntities",
	"Comment": "utility method for encoding html entities within query parameters.",
	"Method": "String encodeEntities(String source){\r\n    StringBuffer buffer = new StringBuffer();\r\n    String encoded;\r\n    for (int index = 0; index < source.length(); index++) {\r\n        char ch = source.charAt(index);\r\n        if ((encoded = encodeEntity(ch)) != null) {\r\n            buffer.append(encoded);\r\n        } else {\r\n            buffer.append(ch);\r\n        }\r\n    }\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "com.codename1.ui.Image.createIndexed",
	"Comment": "creates an indexed image with byte data this method may return a native indexed image rather thanan instance of the indexedimage class",
	"Method": "Image createIndexed(int width,int height,int[] palette,byte[] data){\r\n    IndexedImage i = new IndexedImage(width, height, palette, data);\r\n    CodenameOneImplementation impl = Display.impl;\r\n    if (impl.isNativeIndexed()) {\r\n        return new Image(impl.createNativeIndexed(i));\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.drawLabelStringValign",
	"Comment": "implements the drawstring for the text component and adjust the valignassuming the icon is in one of the sides",
	"Method": "int drawLabelStringValign(Object nativeGraphics,Object nativeFont,String str,int x,int y,int textSpaceW,boolean isTickerRunning,int tickerShiftText,int textDecoration,boolean rtl,boolean endsWith3Points,int textWidth,int iconStringHGap,int iconHeight,int fontHeight,int valign){\r\n    switch(valign) {\r\n        case Component.TOP:\r\n            return drawLabelString(nativeGraphics, nativeFont, str, x, y, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, textWidth, fontHeight);\r\n        case Component.CENTER:\r\n            return drawLabelString(nativeGraphics, nativeFont, str, x, y + iconHeight / 2 - fontHeight / 2, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, textWidth, fontHeight);\r\n        default:\r\n            return drawLabelString(nativeGraphics, nativeFont, str, x, y + iconStringHGap, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, textWidth, fontHeight);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.setMonthViewUnSelectedStyle",
	"Comment": "sets the un selected style of the month view component within thecalendar",
	"Method": "void setMonthViewUnSelectedStyle(Style s){\r\n    mv.setUnselectedStyle(s);\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.bindDayListener",
	"Comment": "since a day may be any component type, developers should override thismethod to add support for binding the click listener to the givencomponent.",
	"Method": "void bindDayListener(Component cmp,ActionListener l){\r\n    if (cmp instanceof Button) {\r\n        ((Button) cmp).addActionListener(l);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Display.canForceOrientation",
	"Comment": "returns true if the device allows forcing the orientation via code, feature phones do not allow thisalthough some include a jad property allowing for this feature",
	"Method": "boolean canForceOrientation(){\r\n    return impl.canForceOrientation();\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.text.DateFormat.getTimeInstance",
	"Comment": "get a dateformat instance that uses a given style for times.",
	"Method": "DateFormat getTimeInstance(DateFormat getTimeInstance,int style){\r\n    return getDateTimeInstance(DEFAULT, style);\r\n}"
}, {
	"Path": "com.codename1.xml.Element.getDescendantsByTagNameAndAttribute",
	"Comment": "returns all descendants with the specified tag name and the none empty attribute",
	"Method": "Vector getDescendantsByTagNameAndAttribute(String name,String attributeName,int depth){\r\n    if (depth < 1) {\r\n        throw new IllegalArgumentException(\"Depth must be 1 or higher\");\r\n    }\r\n    if (children == null) {\r\n        return null;\r\n    }\r\n    Vector v = new Vector();\r\n    getDescendantsByTagNameAndAttributeInternal(v, name, attributeName, depth);\r\n    return v;\r\n}"
}, {
	"Path": "com.codename1.ui.TextField.isUseNativeTextInput",
	"Comment": "indicates that native text input should be used in text field when in place editing is supported by the platform",
	"Method": "boolean isUseNativeTextInput(){\r\n    return useNativeTextInput;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.isHideInPortrait",
	"Comment": "indicates that this component and all its children should be hidden when the device is switched to portrait mode",
	"Method": "boolean isHideInPortrait(){\r\n    return hideInPortrait;\r\n}"
}, {
	"Path": "com.codename1.designer.CodenameOneImageRenderer.setAnimationObjectList",
	"Comment": "used to map the timeline component to the animation object list",
	"Method": "void setAnimationObjectList(JTable animationObjectList,TimelineEditor editor){\r\n    if (this.animationObjectList == null) {\r\n        addMouseListener(this);\r\n        addMouseMotionListener(this);\r\n    }\r\n    this.animationObjectList = animationObjectList;\r\n    this.editor = editor;\r\n}"
}, {
	"Path": "com.codename1.ui.Dialog.setAutoDispose",
	"Comment": "determines whether the execution of a command on this dialog implicitly disposes the dialog. this defaults to true which is a sensible default forsimple dialogs.",
	"Method": "void setAutoDispose(boolean autoDispose){\r\n    this.autoDispose = autoDispose;\r\n}"
}, {
	"Path": "com.codename1.xml.XMLParser.getSupportedStandardName",
	"Comment": "returns a string identifying the document type this parser supports.this should be overriden by subclassing parsers.",
	"Method": "String getSupportedStandardName(){\r\n    return \"XML\";\r\n}"
}, {
	"Path": "com.codename1.util.TMultiplication.multiply",
	"Comment": "performs a multiplication of two biginteger and hides the algorithm used.",
	"Method": "TBigInteger multiply(TBigInteger x,TBigInteger y){\r\n    return karatsuba(x, y);\r\n}"
}, {
	"Path": "com.alibaba.citrus.service.upload.impl.cfu.AbstractFileItem.getContentType",
	"Comment": "returns the content type passed by the agent or null if notdefined.",
	"Method": "String getContentType(){\r\n    return contentType;\r\n}"
}, {
	"Path": "com.codename1.ui.List.removeSelectionListener",
	"Comment": "invoked to indicate no further interest in future selection events",
	"Method": "void removeSelectionListener(SelectionListener l){\r\n    model.removeSelectionListener(l);\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyIndex.loadJSONList",
	"Comment": "loads json containing a list of property objects of this type",
	"Method": "List<X> loadJSONList(String name){\r\n    try {\r\n        InputStream is = Storage.getInstance().createInputStream(name);\r\n        JSONParser jp = new JSONParser();\r\n        JSONParser.setUseBoolean(true);\r\n        JSONParser.setUseLongs(true);\r\n        List<X> response = new ArrayList<X>();\r\n        Map<String, Object> result = jp.parseJSON(new InputStreamReader(is, \"UTF-8\"));\r\n        List<Map> entries = (List<Map>) result.get(\"root\");\r\n        for (Map m : entries) {\r\n            X pb = (X) newInstance();\r\n            pb.getPropertyIndex().populateFromMap(m, parent.getClass());\r\n            response.add(pb);\r\n        }\r\n        return response;\r\n    } catch (IOException err) {\r\n        Log.e(err);\r\n        throw new RuntimeException(err.toString());\r\n    }\r\n}"
}, {
	"Path": "net.coobird.thumbnailator.util.ThumbnailatorUtils.isSupportedOutputFormat",
	"Comment": "returns whether a specified format is supported for output.",
	"Method": "boolean isSupportedOutputFormat(String format){\r\n    if (format == ThumbnailParameter.ORIGINAL_FORMAT) {\r\n        return true;\r\n    }\r\n    for (String supportedFormat : getSupportedOutputFormats()) {\r\n        if (supportedFormat.equals(format)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.hideTextEditor",
	"Comment": "in case of scrolling we can hide the text editor unless the user starts typing again,this is only relevant for the async mode...",
	"Method": "void hideTextEditor(){\r\n    Component c = editingText;\r\n    editingText = null;\r\n    if (c != null) {\r\n        c.repaint();\r\n    }\r\n}"
}, {
	"Path": "com.codename1.facebook.Photo.getComments",
	"Comment": "gets the comments on this photos, where eachentry is a post object",
	"Method": "Vector getComments(){\r\n    return comments;\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.createDayTitle",
	"Comment": "this method creates the day title component for the month view",
	"Method": "Label createDayTitle(int day){\r\n    String value = getUIManager().localize(\"Calendar.\" + DAYS[day], LABELS[day]);\r\n    Label dayh = new Label(value, \"CalendarTitle\");\r\n    dayh.setEndsWith3Points(false);\r\n    dayh.setTickerEnabled(false);\r\n    return dayh;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractQueue.addAll",
	"Comment": "adds all the elements of a collection to the queue. if the collection isthe queue itself, then an illegalargumentexception will be thrown. ifduring the process, some runtime exception is thrown, then those elementsin the collection which have already successfully been added will remainin the queue. the result of the method is undefined if the collection ismodified during the process of the method.",
	"Method": "boolean addAll(Collection<? extends E> c){\r\n    if (null == c) {\r\n        throw new NullPointerException();\r\n    }\r\n    if (this == c) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return super.addAll(c);\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.PassiveState.checkPreviousEntry",
	"Comment": "checks the previous entry in the append request for consistency.",
	"Method": "AppendResponse checkPreviousEntry(AppendRequest request){\r\n    if (request.logIndex() != 0 && context.getLog().isEmpty()) {\r\n        LOGGER.debug(\"{} - Rejected {}: Previous index ({}) is greater than the local log's last index ({})\", context.getCluster().member().address(), request, request.logIndex(), context.getLog().lastIndex());\r\n        return AppendResponse.builder().withStatus(Response.Status.OK).withTerm(context.getTerm()).withSucceeded(false).withLogIndex(context.getLog().lastIndex()).build();\r\n    } else if (request.logIndex() != 0 && context.getLog().lastIndex() != 0 && request.logIndex() > context.getLog().lastIndex()) {\r\n        LOGGER.debug(\"{} - Rejected {}: Previous index ({}) is greater than the local log's last index ({})\", context.getCluster().member().address(), request, request.logIndex(), context.getLog().lastIndex());\r\n        return AppendResponse.builder().withStatus(Response.Status.OK).withTerm(context.getTerm()).withSucceeded(false).withLogIndex(context.getLog().lastIndex()).build();\r\n    }\r\n    return appendEntries(request);\r\n}"
}, {
	"Path": "com.codename1.impl.android.AndroidImplementation.isOpenNativeNavigationAppSupported",
	"Comment": "returns true if the underlying os supports opening the native navigationapplication",
	"Method": "boolean isOpenNativeNavigationAppSupported(){\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.io.Oauth2.setBackToParent",
	"Comment": "enables going back to the parent form after login is completed",
	"Method": "void setBackToParent(boolean aBackToParent){\r\n    backToParent = aBackToParent;\r\n}"
}, {
	"Path": "com.codename1.io.rest.RequestBuilder.fetchAsPropertyList",
	"Comment": "executes the request asynchronously and writes the response to the providedcallback. this fetches json data and parses it into a properties business object",
	"Method": "ConnectionRequest fetchAsPropertyList(OnComplete<Response<List<PropertyBusinessObject>>> callback,Class type){\r\n    ConnectionRequest request = createRequest(true);\r\n    request.addResponseListener(new ActionListener<NetworkEvent>() {\r\n        @Override\r\n        public void actionPerformed(NetworkEvent evt) {\r\n            Response res = null;\r\n            Map response = (Map) evt.getMetaData();\r\n            List<Map> lst = (List<Map>) response.get(\"root\");\r\n            if (lst == null) {\r\n                return;\r\n            }\r\n            try {\r\n                List<PropertyBusinessObject> result = new ArrayList<PropertyBusinessObject>();\r\n                for (Map m : lst) {\r\n                    PropertyBusinessObject pb = (PropertyBusinessObject) type.newInstance();\r\n                    pb.getPropertyIndex().populateFromMap(m);\r\n                    result.add(pb);\r\n                }\r\n                res = new Response(evt.getResponseCode(), result, evt.getMessage());\r\n                callback.completed(res);\r\n            } catch (Exception err) {\r\n                Log.e(err);\r\n                throw new RuntimeException(err.toString());\r\n            }\r\n        }\r\n    });\r\n    CN.addToQueue(request);\r\n    return request;\r\n}"
}, {
	"Path": "com.codename1.io.rest.RequestBuilder.fetchAsPropertyList",
	"Comment": "executes the request asynchronously and writes the response to the providedcallback. this fetches json data and parses it into a properties business object",
	"Method": "ConnectionRequest fetchAsPropertyList(OnComplete<Response<List<PropertyBusinessObject>>> callback,Class type){\r\n    Response res = null;\r\n    Map response = (Map) evt.getMetaData();\r\n    List<Map> lst = (List<Map>) response.get(\"root\");\r\n    if (lst == null) {\r\n        return;\r\n    }\r\n    try {\r\n        List<PropertyBusinessObject> result = new ArrayList<PropertyBusinessObject>();\r\n        for (Map m : lst) {\r\n            PropertyBusinessObject pb = (PropertyBusinessObject) type.newInstance();\r\n            pb.getPropertyIndex().populateFromMap(m);\r\n            result.add(pb);\r\n        }\r\n        res = new Response(evt.getResponseCode(), result, evt.getMessage());\r\n        callback.completed(res);\r\n    } catch (Exception err) {\r\n        Log.e(err);\r\n        throw new RuntimeException(err.toString());\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.Picker.getPreferredPopupWidth",
	"Comment": "the preferred width of the popup dialog. this will only be used on devices where the popup width and height are configurable, such as the ipad or tablets.on iphone, the picker always spans the width of the screen along the bottom.",
	"Method": "int getPreferredPopupWidth(){\r\n    return preferredPopupWidth;\r\n}"
}, {
	"Path": "mondrian.olap.Util.makeBigDecimalFromDouble",
	"Comment": "make a bigdecimal from a double. on jdk 1.5 or later, the bigdecimalprecision reflects the precision of the double while with jdk 1.4this is not the case.",
	"Method": "BigDecimal makeBigDecimalFromDouble(double d){\r\n    return compatible.makeBigDecimalFromDouble(d);\r\n}"
}, {
	"Path": "com.codename1.components.SpanLabel.isShouldLocalize",
	"Comment": "indicates if text should be localized when set to the component, by defaultall text is localized so this allows disabling automatic localization for a specific component.",
	"Method": "boolean isShouldLocalize(){\r\n    return shouldLocalize;\r\n}"
}, {
	"Path": "com.codename1.impl.android.AndroidGraphics.drawLabelStringValign",
	"Comment": "implements the drawstring for the text component and adjust the valignassuming the icon is in one of the sides",
	"Method": "int drawLabelStringValign(Object nativeFont,String str,int x,int y,int textSpaceW,boolean isTickerRunning,int tickerShiftText,int textDecoration,boolean rtl,boolean endsWith3Points,int textWidth,int iconStringHGap,int iconHeight,int fontHeight,int valign){\r\n    switch(valign) {\r\n        case Component.TOP:\r\n            return drawLabelString(nativeFont, str, x, y, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, textWidth, fontHeight);\r\n        case Component.CENTER:\r\n            return drawLabelString(nativeFont, str, x, y + iconHeight / 2 - fontHeight / 2, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, textWidth, fontHeight);\r\n        default:\r\n            return drawLabelString(nativeFont, str, x, y + iconStringHGap, textSpaceW, isTickerRunning, tickerShiftText, textDecoration, rtl, endsWith3Points, textWidth, fontHeight);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.File.lastModified",
	"Comment": "gets the last modified time as a unix timestamp in milliseconds.",
	"Method": "long lastModified(){\r\n    return FileSystemStorage.getInstance().getLastModified(path);\r\n}"
}, {
	"Path": "android.support.v4.widget.SlidingPaneLayout.isSlideable",
	"Comment": "check if the content in this layout cannot fully fit side by side and thereforethe content pane can be slid back and forth.",
	"Method": "boolean isSlideable(){\r\n    return mCanSlide;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.net.URIHelper.encodeEntities",
	"Comment": "utility method for encoding html entities within query parameters.",
	"Method": "String encodeEntities(String source){\r\n    StringBuffer buffer = new StringBuffer();\r\n    String encoded;\r\n    for (int index = 0; index < source.length(); index++) {\r\n        char ch = source.charAt(index);\r\n        if ((encoded = encodeEntity(ch)) != null) {\r\n            buffer.append(encoded);\r\n        } else {\r\n            buffer.append(ch);\r\n        }\r\n    }\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.showTextFixedWidth",
	"Comment": "shows the given text. this method breaks lines as necessary and adds the text either as regular labels or links.",
	"Method": "Vector showTextFixedWidth(String text,int align){\r\n    Vector comps = new Vector();\r\n    if ((text == null) || (text.equals(\"\"))) {\r\n        return comps;\r\n    }\r\n    int spaceW = width - x;\r\n    Vector words = getWords(text, align, false);\r\n    if (words.size() > 0) {\r\n        int w = 0;\r\n        String wordStr = \"\";\r\n        if ((CSSParser.isWhiteSpace(text.charAt(0))) && (curLine.getComponentCount() != 0)) {\r\n            wordStr = \" \";\r\n        }\r\n        while (w < words.size()) {\r\n            String nextWord = (String) words.elementAt(w);\r\n            String space = \"\";\r\n            if ((!wordStr.equals(\"\")) && (!wordStr.equals(\" \"))) {\r\n                space = \" \";\r\n            }\r\n            if (font.stringWidth(wordStr + space + nextWord) > spaceW - 2) {\r\n                comps.addElement(addString(wordStr, align));\r\n                newLineIfNotEmpty(align);\r\n                spaceW = width - x;\r\n                wordStr = nextWord;\r\n            } else {\r\n                wordStr += space + nextWord;\r\n            }\r\n            w++;\r\n        }\r\n        if (CSSParser.isWhiteSpace(text.charAt(text.length() - 1))) {\r\n            wordStr += \" \";\r\n        }\r\n        comps.addElement(addString(wordStr, align));\r\n    }\r\n    return comps;\r\n}"
}, {
	"Path": "org.conscrypt.ct.Serialization.writeVariableBytes",
	"Comment": "write length prefixed sequence of bytes to the ouput stream.the length prefix is encoded in big endian order.",
	"Method": "void writeVariableBytes(OutputStream output,byte[] data,int width){\r\n    writeNumber(output, data.length, width);\r\n    writeFixedBytes(output, data);\r\n}"
}, {
	"Path": "com.codename1.ui.Transform.isSupported",
	"Comment": "checks if transforms are supported on this platform.if this returns false,you cannot use this class.",
	"Method": "boolean isSupported(){\r\n    return Display.impl.isTransformSupported();\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.isDefaultEndsWith3Points",
	"Comment": "indicates whether labels should end with 3 points by default",
	"Method": "boolean isDefaultEndsWith3Points(){\r\n    return defaultEndsWith3Points;\r\n}"
}, {
	"Path": "com.codename1.maps.Tile.setsTileReadyListener",
	"Comment": "sets a listener to be notified when the tile is fireready to be painted",
	"Method": "void setsTileReadyListener(ActionListener listener){\r\n    this.listener = listener;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.HashMap.removeEntry",
	"Comment": "remove the given entry from the hashmap.assumes that the entry is in the map.",
	"Method": "void removeEntry(Entry<K, V> entry,Entry<K, V> removeEntry,Object key){\r\n    int index = 0;\r\n    Entry<K, V> entry;\r\n    Entry<K, V> last = null;\r\n    if (key != null) {\r\n        int hash = computeHashCode(key);\r\n        index = hash & (elementData.length - 1);\r\n        entry = elementData[index];\r\n        while (entry != null && !(entry.origKeyHash == hash && areEqualKeys(key, entry.key))) {\r\n            last = entry;\r\n            entry = entry.next;\r\n        }\r\n    } else {\r\n        entry = elementData[0];\r\n        while (entry != null && entry.key != null) {\r\n            last = entry;\r\n            entry = entry.next;\r\n        }\r\n    }\r\n    if (entry == null) {\r\n        return null;\r\n    }\r\n    if (last == null) {\r\n        elementData[index] = entry.next;\r\n    } else {\r\n        last.next = entry.next;\r\n    }\r\n    modCount++;\r\n    elementCount--;\r\n    return entry;\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyBase.validateCollectionType",
	"Comment": "validates that the collection type is valid and throws an exception otherwise",
	"Method": "void validateCollectionType(Class elementType){\r\n    if (elementType == null || !PropertyBusinessObject.class.isAssignableFrom(elementType)) {\r\n        if (elementType == String.class || elementType == Integer.class || elementType == Long.class || elementType == Double.class || elementType == Byte.class || elementType == Float.class || elementType == Boolean.class || elementType == Character.class) {\r\n            return;\r\n        }\r\n        throw new IllegalArgumentException(\"the element type class needs to be a subclass of PropertyBusinessObject\");\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.isChangesSelectedDateEnabled",
	"Comment": "this flag determines if selected date can be changed by selecting analternative date",
	"Method": "boolean isChangesSelectedDateEnabled(){\r\n    return changesSelectedDateEnabled;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.AbstractMap.hashCode",
	"Comment": "returns the hash code for this object. objects which are equal mustreturn the same value for this method.",
	"Method": "int hashCode(int hashCode,int hashCode){\r\n    int result = 0;\r\n    Iterator<Map.Entry<K, V>> it = entrySet().iterator();\r\n    while (it.hasNext()) {\r\n        result += it.next().hashCode();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "ly.count.android.sdk.messaging.Message.isValid",
	"Comment": "message is considered valid only when it has countly id and its type is determined",
	"Method": "boolean isValid(){\r\n    String id = data.getString(\"c.i\");\r\n    return !isUnknown() && id != null && id.length() == 24;\r\n}"
}, {
	"Path": "com.codename1.analytics.AnalyticsService.isFailSilently",
	"Comment": "indicates whether analytics server failures should brodcast an error event",
	"Method": "boolean isFailSilently(){\r\n    return failSilently;\r\n}"
}, {
	"Path": "com.codename1.analytics.AnalyticsService.visitPage",
	"Comment": "subclasses should override this method to track page visits",
	"Method": "void visitPage(String page,String referer){\r\n    if (appsMode) {\r\n        ConnectionRequest req = GetGARequest();\r\n        req.addArgument(\"t\", \"appview\");\r\n        req.addArgument(\"an\", Display.getInstance().getProperty(\"AppName\", \"Codename One App\"));\r\n        String version = Display.getInstance().getProperty(\"AppVersion\", \"1.0\");\r\n        req.addArgument(\"av\", version);\r\n        req.addArgument(\"cd\", page);\r\n        NetworkManager.getInstance().addToQueue(req);\r\n    } else {\r\n        String url = Display.getInstance().getProperty(\"cloudServerURL\", \"https://codename-one.appspot.com/\") + \"anal\";\r\n        ConnectionRequest r = new ConnectionRequest();\r\n        r.setUrl(url);\r\n        r.setPost(false);\r\n        r.setFailSilently(failSilently);\r\n        r.addArgument(\"guid\", \"ON\");\r\n        r.addArgument(\"utmac\", instance.agent);\r\n        r.addArgument(\"utmn\", Integer.toString((int) (System.currentTimeMillis() % 0x7fffffff)));\r\n        if (page == null || page.length() == 0) {\r\n            page = \"-\";\r\n        }\r\n        r.addArgument(\"utmp\", page);\r\n        if (referer == null || referer.length() == 0) {\r\n            referer = \"-\";\r\n        }\r\n        r.addArgument(\"utmr\", referer);\r\n        r.addArgument(\"d\", instance.domain);\r\n        r.setPriority(ConnectionRequest.PRIORITY_LOW);\r\n        NetworkManager.getInstance().addToQueue(r);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Display.hasNativeTheme",
	"Comment": "indicates if the implemenetation has a native underlying theme",
	"Method": "boolean hasNativeTheme(){\r\n    return impl.hasNativeTheme();\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.transformScale",
	"Comment": "scales the provided transform by the provide scale factors.",
	"Method": "void transformScale(Object nativeTransform,float x,float y,float z){\r\n    Object scale = makeTransformScale(x, y, z);\r\n    concatenateTransform(nativeTransform, scale);\r\n}"
}, {
	"Path": "com.codename1.ui.list.ContainerList.getListeners",
	"Comment": "this method allows extracting the action listeners from the current list",
	"Method": "Collection getListeners(){\r\n    return dispatcher.getListenerCollection();\r\n}"
}, {
	"Path": "cognitivej.vision.emotion.EmotionStringBuilder.listAllEmotions",
	"Comment": "returns the most dominate emotion and the score for that emotion",
	"Method": "String listAllEmotions(Emotion emotion){\r\n    return emotion.scores.scores().entrySet().stream().map((entry1) -> String.format(\"%s:%.2f\\n\", entry1.getKey(), entry1.getValue())).collect(Collectors.joining());\r\n}"
}, {
	"Path": "java.lang.Thread.activeCount",
	"Comment": "returns the current number of active threads in the virtual machine.",
	"Method": "int activeCount(){\r\n    return activeThreads;\r\n}"
}, {
	"Path": "com.codename1.designer.AddThemeEntry.removeKeys",
	"Comment": "method used to prevent the concurrent modification exception when changing the iterated keyset",
	"Method": "void removeKeys(Hashtable themeRes,String uiid){\r\n    if (uiid == null || uiid.length() == 0) {\r\n        for (Object k : themeRes.keySet()) {\r\n            String key = (String) k;\r\n            if (key.indexOf('.') > -1 || key.indexOf('#') > -1 || key.indexOf('@') > -1) {\r\n                continue;\r\n            }\r\n            themeRes.remove(key);\r\n            removeKeys(themeRes, uiid);\r\n            return;\r\n        }\r\n        return;\r\n    }\r\n    for (Object k : themeRes.keySet()) {\r\n        String key = (String) k;\r\n        if (key.startsWith(uiid)) {\r\n            if (prefix.length() == 0 && key.indexOf('#') > 0) {\r\n                continue;\r\n            }\r\n            themeRes.remove(key);\r\n            removeKeys(themeRes, uiid);\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.addDropListener",
	"Comment": "binds an action listener to drop events which are invoked when this component is dropped on a target",
	"Method": "void addDropListener(ActionListener l){\r\n    if (dropListener == null) {\r\n        dropListener = new EventDispatcher();\r\n    }\r\n    dropListener.addListener(l);\r\n}"
}, {
	"Path": "com.codename1.ui.geom.Rectangle2D.intersects",
	"Comment": "helper method allowing us to determine if two coordinate sets intersect. this savesus the need of creating a rectangle object for a quick calculation",
	"Method": "boolean intersects(double x,double y,double width,double height,boolean intersects,Rectangle2D rect,boolean intersects,double tx,double ty,double tw,double th,double x,double y,double width,double height){\r\n    double rw = width;\r\n    double rh = height;\r\n    if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) {\r\n        return false;\r\n    }\r\n    double rx = x;\r\n    double ry = y;\r\n    rw += rx;\r\n    rh += ry;\r\n    tw += tx;\r\n    th += ty;\r\n    return ((rw < rx || rw > tx) && (rh < ry || rh > ty) && (tw < tx || tw > rx) && (th < ty || th > ry));\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.Collections.min",
	"Comment": "searches the specified collection for the minimum element using thespecified comparator.",
	"Method": "T min(Collection<? extends T> collection,T min,Collection<? extends T> collection,Comparator<? super T> comparator){\r\n    if (comparator == null) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        T result = (T) min((Collection<net.sourceforge.retroweaver.harmony.runtime.java.lang.Comparable>) collection);\r\n        return result;\r\n    }\r\n    Iterator<? extends T> it = collection.iterator();\r\n    T min = it.next();\r\n    while (it.hasNext()) {\r\n        T next = it.next();\r\n        if (comparator.compare(min, next) > 0) {\r\n            min = next;\r\n        }\r\n    }\r\n    return min;\r\n}"
}, {
	"Path": "com.codename1.ui.Slider.removeActionListener",
	"Comment": "action listeners give a more coarse event only when the user lifts the finger from the slider",
	"Method": "void removeActionListener(ActionListener l){\r\n    actionListeners.removeListener(l);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.isBezierCorners",
	"Comment": "true if the corners are bezier curves, otherwise the corners are drawn as a regular arc",
	"Method": "boolean isBezierCorners(){\r\n    return bezierCorners;\r\n}"
}, {
	"Path": "com.codename1.io.rest.RequestBuilder.getAsStringAsync",
	"Comment": "executes the request asynchronously and writes the response to the providedcallback",
	"Method": "void getAsStringAsync(Callback<Response<String>> callback){\r\n    getAsStringAsyncImpl(callback);\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.getStarRatingsCurrentVersionsSessionCount",
	"Comment": "returns how many sessions has star rating counted internally for the current apps version",
	"Method": "int getStarRatingsCurrentVersionsSessionCount(){\r\n    if (context_ == null) {\r\n        if (Countly.sharedInstance().isLoggingEnabled()) {\r\n            Log.e(Countly.TAG, \"Can't call this function before init has been called\");\r\n            return -1;\r\n        }\r\n    }\r\n    int sessionCount = CountlyStarRating.getCurrentVersionsSessionCount(context_);\r\n    if (Countly.sharedInstance().isLoggingEnabled()) {\r\n        Log.d(Countly.TAG, \"Getting star rating current version session count: [\" + sessionCount + \"]\");\r\n    }\r\n    return sessionCount;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.getMediaRecorderingMimeType",
	"Comment": "gets the recording mime type for the returned media from the createmediarecorder method",
	"Method": "String getMediaRecorderingMimeType(){\r\n    return impl.getAvailableRecordingMimeTypes()[0];\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.enableCrashReporting",
	"Comment": "enable crash reporting to send unhandled crash reports to server",
	"Method": "Countly enableCrashReporting(){\r\n    if (Countly.sharedInstance().isLoggingEnabled()) {\r\n        Log.d(Countly.TAG, \"Enabling unhandled crash reporting\");\r\n    }\r\n    final Thread.UncaughtExceptionHandler oldHandler = Thread.getDefaultUncaughtExceptionHandler();\r\n    Thread.UncaughtExceptionHandler handler = new Thread.UncaughtExceptionHandler() {\r\n        @Override\r\n        public void uncaughtException(Thread t, Throwable e) {\r\n            if (getConsent(CountlyFeatureNames.crashes)) {\r\n                StringWriter sw = new StringWriter();\r\n                PrintWriter pw = new PrintWriter(sw);\r\n                e.printStackTrace(pw);\r\n                Countly.sharedInstance().connectionQueue_.sendCrashReport(sw.toString(), false);\r\n            }\r\n            if (oldHandler != null) {\r\n                oldHandler.uncaughtException(t, e);\r\n            }\r\n        }\r\n    };\r\n    Thread.setDefaultUncaughtExceptionHandler(handler);\r\n    return this;\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.enableCrashReporting",
	"Comment": "enable crash reporting to send unhandled crash reports to server",
	"Method": "Countly enableCrashReporting(){\r\n    if (getConsent(CountlyFeatureNames.crashes)) {\r\n        StringWriter sw = new StringWriter();\r\n        PrintWriter pw = new PrintWriter(sw);\r\n        e.printStackTrace(pw);\r\n        Countly.sharedInstance().connectionQueue_.sendCrashReport(sw.toString(), false);\r\n    }\r\n    if (oldHandler != null) {\r\n        oldHandler.uncaughtException(t, e);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.setDefaultFormTintColor",
	"Comment": "tint color is set when a form is partially covered be it by a menu or by a dialog. a look and feel can override this default value.",
	"Method": "void setDefaultFormTintColor(int defaultFormTintColor){\r\n    this.defaultFormTintColor = defaultFormTintColor;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.getComponentSelectedStyle",
	"Comment": "returns the selected style of the component with the given id or a new instance of the defaultstyle.this method will always return a new style instance to prevent modification of the globalstyle object.",
	"Method": "Style getComponentSelectedStyle(String id){\r\n    return getComponentStyleImpl(id, true, \"sel#\");\r\n}"
}, {
	"Path": "com.codename1.components.ImageViewer.getImageX",
	"Comment": "returns the x position of the image viewport which can be useful when it is being panned by the user",
	"Method": "int getImageX(){\r\n    return imageX;\r\n}"
}, {
	"Path": "com.codename1.components.ImageViewer.getImageY",
	"Comment": "returns the y position of the image viewport which can be useful when it is being panned by the user",
	"Method": "int getImageY(){\r\n    return imageY;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.getHeaders",
	"Comment": "returns the http header field for the given connection, this method is only guaranteed to workwhen invoked from the readheaders method. unlike the getheader method this version works whenthe same header name is declared multiple times.",
	"Method": "String[] getHeaders(Object connection,String header){\r\n    return Util.getImplementation().getHeaderFields(header, connection);\r\n}"
}, {
	"Path": "android.support.v4.app.FragmentActivity.getSupportLoaderManager",
	"Comment": "return the loadermanager for this fragment, creating it if needed.",
	"Method": "LoaderManager getSupportLoaderManager(){\r\n    if (mLoaderManager != null) {\r\n        return mLoaderManager;\r\n    }\r\n    mCheckedForLoaderManager = true;\r\n    mLoaderManager = getLoaderManager(null, mLoadersStarted, true);\r\n    return mLoaderManager;\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.sendEventsIfNeeded",
	"Comment": "submits all of the locally queued events to the server if there are more than 10 of them.",
	"Method": "void sendEventsIfNeeded(){\r\n    if (eventQueue_.size() >= EVENT_QUEUE_SIZE_THRESHOLD) {\r\n        connectionQueue_.recordEvents(eventQueue_.events());\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Component.isDraggable",
	"Comment": "indicates whether this component can be dragged in a drag and drop operation rather than scroll the parent",
	"Method": "boolean isDraggable(){\r\n    return draggable;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.DimConstraint.setGrowPriority",
	"Comment": "sets the grow priority. relative priority is used for determining which entities gets the extra space first.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "void setGrowPriority(int p){\r\n    resize.growPrio = p;\r\n}"
}, {
	"Path": "com.codename1.xml.XMLParser.isCaseSensitive",
	"Comment": "sets the parser to be case sensitive and retain case, otherwise it will convert all data to lower case",
	"Method": "boolean isCaseSensitive(){\r\n    return caseSensitive;\r\n}"
}, {
	"Path": "com.alibaba.citrus.service.requestcontext.util.tomcat.ServerCookie.maybeQuote2",
	"Comment": "quotes values using rules that vary depending on cookie version.",
	"Method": "int maybeQuote2(int version,StringBuilder buf,String value,int maybeQuote2,int version,StringBuilder buf,String value,boolean allowVersionSwitch,int maybeQuote2,int version,StringBuilder buf,String value,String literals,boolean allowVersionSwitch){\r\n    if (value == null || value.length() == 0) {\r\n    } else if (containsCTL(value, version)) {\r\n        throw new IllegalArgumentException(\"Control character in cookie value, consider BASE64 encoding your value\");\r\n    } else if (alreadyQuoted(value)) {\r\n        buf.append('\"');\r\n        buf.append(escapeDoubleQuotes(value, 1, value.length() - 1));\r\n        buf.append('\"');\r\n    } else if (allowVersionSwitch && !STRICT_SERVLET_COMPLIANCE && version == 0 && !isToken2(value, literals)) {\r\n        buf.append('\"');\r\n        buf.append(escapeDoubleQuotes(value, 0, value.length()));\r\n        buf.append('\"');\r\n        version = 1;\r\n    } else if (version == 0 && !isToken(value, literals)) {\r\n        buf.append('\"');\r\n        buf.append(escapeDoubleQuotes(value, 0, value.length()));\r\n        buf.append('\"');\r\n    } else if (version == 1 && !isToken2(value, literals)) {\r\n        buf.append('\"');\r\n        buf.append(escapeDoubleQuotes(value, 0, value.length()));\r\n        buf.append('\"');\r\n    } else {\r\n        buf.append(value);\r\n    }\r\n    return version;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.getText",
	"Comment": "gets the text on the first component in this set that supports this property.currently this works withlabel, textarea, spanlabel, and spanbuttons, and subclasses thereof.",
	"Method": "String getText(){\r\n    for (Component c : this) {\r\n        if (c instanceof Label) {\r\n            return ((Label) c).getText();\r\n        } else if (c instanceof TextArea) {\r\n            return ((TextArea) c).getText();\r\n        } else if (c instanceof SpanLabel) {\r\n            return ((SpanLabel) c).getText();\r\n        } else if (c instanceof SpanButton) {\r\n            return ((SpanButton) c).getText();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.atomix.copycat.test.ClusterTest.testActiveJoinLate",
	"Comment": "tests joining a server after many entries have been committed.",
	"Method": "void testActiveJoinLate(){\r\n    testServerJoinLate(Member.Type.ACTIVE, CopycatServer.State.FOLLOWER);\r\n}"
}, {
	"Path": "com.codename1.components.InfiniteProgress.getTintColor",
	"Comment": "the tinting color of the screen when the showinifiniteblocking method is invoked",
	"Method": "int getTintColor(){\r\n    return tintColor;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLFont.isBigCounterpart",
	"Comment": "checks if the specified font is a big counterpart of this font.",
	"Method": "boolean isBigCounterpart(HTMLFont font){\r\n    if (size <= font.getSize()) {\r\n        return false;\r\n    }\r\n    return (isSameFamily(font) && (style == font.getStyle()));\r\n}"
}, {
	"Path": "com.codename1.charts.util.MathHelper.roundUp",
	"Comment": "given a number, round up to the nearest power of ten times 1, 2, or 5.",
	"Method": "double roundUp(double val){\r\n    int exponent = (int) Math.floor(MathUtil.log10(val));\r\n    double rval = val * MathUtil.pow(10, -exponent);\r\n    if (rval > 5.0) {\r\n        rval = 10.0;\r\n    } else if (rval > 2.0) {\r\n        rval = 5.0;\r\n    } else if (rval > 1.0) {\r\n        rval = 2.0;\r\n    }\r\n    rval *= MathUtil.pow(10, exponent);\r\n    return rval;\r\n}"
}, {
	"Path": "com.codename1.ui.ButtonGroup.clearSelection",
	"Comment": "clears the selection such that none of the buttons in the buttongroup are selected.",
	"Method": "void clearSelection(){\r\n    if (selectedIndex != -1) {\r\n        if (selectedIndex < buttons.size()) {\r\n            ((RadioButton) buttons.get(selectedIndex)).setSelected(false);\r\n        }\r\n        selectedIndex = -1;\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.painter.PainterChain.installGlassPane",
	"Comment": "installs a glass pane on the given form making sure to make it a painterchain only if required by existing painter",
	"Method": "void installGlassPane(Form f,Painter p){\r\n    Painter existing = f.getGlassPane();\r\n    if (existing == null) {\r\n        f.setGlassPane(p);\r\n        return;\r\n    }\r\n    if (existing instanceof PainterChain) {\r\n        f.setGlassPane(((PainterChain) existing).addPainter(p));\r\n    } else {\r\n        PainterChain pc = new PainterChain(new Painter[] { existing, p });\r\n        f.setGlassPane(pc);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.charts.views.TimeChart.getDateFormat",
	"Comment": "returns the date format pattern to be used, based on the date range.",
	"Method": "String getDateFormat(DateFormat getDateFormat,double start,double end){\r\n    if (mDateFormat != null) {\r\n        SimpleDateFormat format = null;\r\n        try {\r\n            format = new SimpleDateFormat(mDateFormat);\r\n            return format;\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    DateFormat format = SimpleDateFormat.getDateInstance(SimpleDateFormat.MEDIUM);\r\n    double diff = end - start;\r\n    if (diff > DAY && diff < 5 * DAY) {\r\n        format = SimpleDateFormat.getDateTimeInstance(SimpleDateFormat.SHORT, SimpleDateFormat.SHORT);\r\n    } else if (diff < DAY) {\r\n        format = SimpleDateFormat.getTimeInstance(SimpleDateFormat.MEDIUM);\r\n    }\r\n    return format;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentSelector.setText",
	"Comment": "sets the text on all components in found set that support this.currently this works withlabel, textarea, spanlabel, and spanbuttons, and subclasses thereof.",
	"Method": "ComponentSelector setText(String text){\r\n    for (Component c : this) {\r\n        if (c instanceof Label) {\r\n            ((Label) c).setText(text);\r\n        } else if (c instanceof TextArea) {\r\n            ((TextArea) c).setText(text);\r\n        } else if (c instanceof SpanLabel) {\r\n            ((SpanLabel) c).setText(text);\r\n        } else if (c instanceof SpanButton) {\r\n            ((SpanButton) c).setText(text);\r\n        }\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.UIManager.getResourceBundle",
	"Comment": "the resource bundle allows us to implicitly localize the ui on the fly, once itsinstalled all internal application strings query the resource bundle and extracttheir values from this table if applicable.",
	"Method": "Hashtable getResourceBundle(){\r\n    if (resourceBundle == null && bundle != null) {\r\n        resourceBundle = new Hashtable(bundle);\r\n    }\r\n    return resourceBundle;\r\n}"
}, {
	"Path": "com.codename1.ui.IndexedImage.pack",
	"Comment": "tries to pack the given image and would return the packed image or sourceimage if packing failed",
	"Method": "Image pack(String imageName,IndexedImage pack,int[] rgb,int width,int height,Image pack,Image sourceImage){\r\n    int width = sourceImage.getWidth();\r\n    int height = sourceImage.getHeight();\r\n    int[] rgb = sourceImage.getRGBCached();\r\n    Image i = pack(rgb, width, height);\r\n    if (i == null) {\r\n        return sourceImage;\r\n    }\r\n    return i;\r\n}"
}, {
	"Path": "org.conscrypt.Platform.isLiteralIpAddress",
	"Comment": "returns true if the supplied hostname is an literal ip address.",
	"Method": "boolean isLiteralIpAddress(String hostname){\r\n    return InetAddress.isNumeric(hostname);\r\n}"
}, {
	"Path": "ly.count.android.sdk.ConnectionQueue.updateSession",
	"Comment": "records a session duration event for the app and sends it to the server. this method does nothingif passed a negative or zero duration.",
	"Method": "void updateSession(int duration){\r\n    checkInternalState();\r\n    if (duration > 0) {\r\n        boolean dataAvailable = false;\r\n        String data = prepareCommonRequestData();\r\n        if (Countly.sharedInstance().getConsent(Countly.CountlyFeatureNames.sessions)) {\r\n            data += \"&session_duration=\" + duration;\r\n            dataAvailable = true;\r\n        }\r\n        if (Countly.sharedInstance().getConsent(Countly.CountlyFeatureNames.attribution)) {\r\n            if (Countly.sharedInstance().isAttributionEnabled) {\r\n                String cachedAdId = store_.getCachedAdvertisingId();\r\n                if (!cachedAdId.isEmpty()) {\r\n                    data += \"&aid=\" + ConnectionProcessor.urlEncodeString(\"{\\\"adid\\\":\\\"\" + cachedAdId + \"\\\"}\");\r\n                    dataAvailable = true;\r\n                }\r\n            }\r\n        }\r\n        if (dataAvailable) {\r\n            store_.addConnection(data);\r\n            tick();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.BufferedInputStream.setPrintInput",
	"Comment": "prints out all the data that passes through this stream to the console.this is a very useful debugging tool.",
	"Method": "void setPrintInput(boolean printInput){\r\n    this.printInput = printInput;\r\n}"
}, {
	"Path": "com.l2fprod.common.swing.JOutlookBar.getUIClassID",
	"Comment": "returns the name of the l&f class that renders this component.",
	"Method": "String getUIClassID(){\r\n    return UI_CLASS_ID;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.query.logical.Or.matches",
	"Comment": "returns true if at least one child query matches the given object, returns false if none match.",
	"Method": "boolean matches(O object,QueryOptions queryOptions){\r\n    for (Query<O> query : super.getSimpleQueries()) {\r\n        if (query.matches(object, queryOptions)) {\r\n            return true;\r\n        }\r\n    }\r\n    for (Query<O> query : super.getLogicalQueries()) {\r\n        if (query.matches(object, queryOptions)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.html.DocumentInfo.isPostRequest",
	"Comment": "returns whether this document request is a post request or not",
	"Method": "boolean isPostRequest(){\r\n    return postRequest;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.topRightMode",
	"Comment": "true to draw the top right corner rounded, false to draw it as a corner",
	"Method": "RoundRectBorder topRightMode(boolean topRight){\r\n    this.topRight = topRight;\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.Stroke.setMiterLimit",
	"Comment": "sets the miter limit of the stroke. the miter limit controls the point at which a miter join automatically is converted to a bevel join. if the distance from the inner intersection point to the tip of the triangle measured in stroke widths is more than the miter limit, the join will be drawn in the bevel style.",
	"Method": "void setMiterLimit(float miterLimit){\r\n    this.miterLimit = miterLimit;\r\n}"
}, {
	"Path": "com.codename1.ui.util.UIBuilder.setResourceFilePath",
	"Comment": "allows the navigation code to avoid storing the resource file and lets the gcremove it from memory when its not in use",
	"Method": "void setResourceFilePath(String resourceFilePath){\r\n    this.resourceFilePath = resourceFilePath;\r\n    if (resourceFilePath != null) {\r\n        resourceFile = null;\r\n    }\r\n}"
}, {
	"Path": "mondrian.olap.Util.needToImplement",
	"Comment": "returns an exception which indicates that a particular piece offunctionality should work, but a developer has not implemented it yet.",
	"Method": "RuntimeException needToImplement(Object o){\r\n    throw new UnsupportedOperationException(\"need to implement \" + o);\r\n}"
}, {
	"Path": "com.codename1.payment.Purchase.isManualPaymentSupported",
	"Comment": "indicates whether the purchasing platform supports manual payments which are just payments of a specific amount of money.",
	"Method": "boolean isManualPaymentSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.ui.ComponentGroup.enclose",
	"Comment": "shorthand method for wrapping the given components in a vertical component group",
	"Method": "ComponentGroup enclose(Component cmp){\r\n    ComponentGroup c = new ComponentGroup();\r\n    for (Component cc : cmp) {\r\n        c.add(cc);\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "com.codename1.ui.Component.getInlineDisabledStyles",
	"Comment": "gets inline styles that are to be applied to the disabled state of this component.",
	"Method": "String getInlineDisabledStyles(){\r\n    return this.inlineDisabledStyles;\r\n}"
}, {
	"Path": "org.conscrypt.ct.Serialization.readLong",
	"Comment": "read a number in big endian format from the input stream.this methods supports a width of up to 8 bytes.",
	"Method": "long readLong(InputStream input,int width){\r\n    if (width > 8 || width < 0) {\r\n        throw new IllegalArgumentException(\"Invalid width: \" + width);\r\n    }\r\n    long result = 0;\r\n    for (int i = 0; i < width; i++) {\r\n        result = (result << 8) | (readByte(input) & 0xFF);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "android.support.v4.widget.SimpleCursorAdapter.getCursorToStringConverter",
	"Comment": "returns the converter used to convert the filtering cursorinto a string.",
	"Method": "CursorToStringConverter getCursorToStringConverter(){\r\n    return mCursorToStringConverter;\r\n}"
}, {
	"Path": "com.codename1.ui.Font.getFace",
	"Comment": "return optional operation returning the font face for system fonts",
	"Method": "int getFace(){\r\n    return Display.impl.getFace(font);\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.LookAndFeel.getDefaultFormTransitionOut",
	"Comment": "allows us to define a default animation that will draw the transition forexiting a form",
	"Method": "Transition getDefaultFormTransitionOut(){\r\n    return defaultFormTransitionOut;\r\n}"
}, {
	"Path": "com.android.org.conscrypt.OpenSSLSocketImpl.getSoWriteTimeout",
	"Comment": "note write timeouts are not part of the javax.net.ssl.sslsocket api",
	"Method": "int getSoWriteTimeout(){\r\n    throw new RuntimeException(\"Stub!\");\r\n}"
}, {
	"Path": "com.codename1.io.FileSystemStorage.listFiles",
	"Comment": "lists the files within the given directory, returns relative file names and notfull file names.",
	"Method": "String[] listFiles(String directory){\r\n    return Util.getImplementation().listFiles(directory);\r\n}"
}, {
	"Path": "com.codename1.ui.Form.setDefaultCommand",
	"Comment": "default command is invoked when a user presses fire, this functionality workswell in some situations but might collide with elements such as navigationand combo boxes. use with caution.",
	"Method": "void setDefaultCommand(Command defaultCommand){\r\n    menuBar.setDefaultCommand(defaultCommand);\r\n}"
}, {
	"Path": "com.codename1.ui.TextArea.addActionListener",
	"Comment": "add an action listener which is invoked when the text area was modified not duringmodification. a text field might never fire an action event if it is editedin place and the user never leaves the text field!",
	"Method": "void addActionListener(ActionListener a){\r\n    if (actionListeners == null) {\r\n        actionListeners = new EventDispatcher();\r\n    }\r\n    actionListeners.addListener(a);\r\n}"
}, {
	"Path": "com.codename1.ui.MenuBar.setMinimizeOnBack",
	"Comment": "when set to true the physical back button will minimize the application",
	"Method": "void setMinimizeOnBack(boolean minimizeOnBack){\r\n    this.minimizeOnBack = minimizeOnBack;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLInputFormat.applyConstraints",
	"Comment": "applies the constrains represented by this object to the given textarea.after invoking this method the returned textarea should be used as restrictions are made sometimes on a new object.in case this is a textfield, this method will also set the input modes as needed.",
	"Method": "TextArea applyConstraints(TextArea ta){\r\n    int widestConstraint = 0;\r\n    for (Enumeration e = formatConstraints.elements(); e.hasMoreElements(); ) {\r\n        FormatConstraint constraint = (FormatConstraint) e.nextElement();\r\n        for (int i = 1; i <= 16; i *= 2) {\r\n            if ((constraint.type & i) != 0) {\r\n                widestConstraint |= i;\r\n            }\r\n        }\r\n    }\r\n    if (maxLength != Integer.MAX_VALUE) {\r\n        ta.setMaxSize(maxLength);\r\n    }\r\n    if (widestConstraint == FormatConstraint.TYPE_NUMERIC) {\r\n        ta.setConstraint(ta.getConstraint() | TextArea.NUMERIC);\r\n    }\r\n    if (ta instanceof TextField) {\r\n        TextField tf = (TextField) ta;\r\n        if (((widestConstraint & FormatConstraint.TYPE_SYMBOL) == 0) && ((widestConstraint & FormatConstraint.TYPE_ANY) == 0)) {\r\n            tf = new TextField(ta.getText()) {\r\n                protected void showSymbolDialog() {\r\n                }\r\n            };\r\n            tf.setConstraint(ta.getConstraint());\r\n            ta = tf;\r\n        }\r\n        if ((widestConstraint & FormatConstraint.TYPE_ANY) != 0) {\r\n            if ((widestConstraint & FormatConstraint.TYPE_UPPERCASE) != 0) {\r\n                tf.setInputMode(\"ABC\");\r\n            } else {\r\n                tf.setInputMode(\"abc\");\r\n            }\r\n        } else {\r\n            if ((widestConstraint & FormatConstraint.TYPE_LOWERCASE) == 0) {\r\n                excludeInputMode(tf, \"abc\");\r\n                excludeInputMode(tf, \"Abc\");\r\n            }\r\n            if ((widestConstraint & FormatConstraint.TYPE_UPPERCASE) == 0) {\r\n                excludeInputMode(tf, \"ABC\");\r\n                excludeInputMode(tf, \"Abc\");\r\n            }\r\n            if ((widestConstraint & FormatConstraint.TYPE_NUMERIC) == 0) {\r\n                excludeInputMode(tf, \"123\");\r\n            }\r\n        }\r\n    }\r\n    return ta;\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLInputFormat.applyConstraints",
	"Comment": "applies the constrains represented by this object to the given textarea.after invoking this method the returned textarea should be used as restrictions are made sometimes on a new object.in case this is a textfield, this method will also set the input modes as needed.",
	"Method": "TextArea applyConstraints(TextArea ta){\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.lang.Character_.isValidCodePoint",
	"Comment": "a test for determining if the codepoint is a valid unicodecode point.",
	"Method": "boolean isValidCodePoint(int codePoint){\r\n    return (MIN_CODE_POINT <= codePoint && MAX_CODE_POINT >= codePoint);\r\n}"
}, {
	"Path": "com.codename1.ui.List.isDefaultIgnoreFocusComponentWhenUnfocused",
	"Comment": "indicates whether the list should not paint the focus component if the listitself has no focus.",
	"Method": "boolean isDefaultIgnoreFocusComponentWhenUnfocused(){\r\n    return defaultIgnoreFocusComponentWhenUnfocused;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundBorder.isRectangle",
	"Comment": "true if this border grows into a rectangle horizontally or keeps growing as a circle",
	"Method": "boolean isRectangle(){\r\n    return rectangle;\r\n}"
}, {
	"Path": "com.codename1.ui.Calendar.getMonthViewSelectedStyle",
	"Comment": "gets the selected style of the month view component within the calendar",
	"Method": "Style getMonthViewSelectedStyle(){\r\n    return mv.getSelectedStyle();\r\n}"
}, {
	"Path": "com.codename1.maps.Tile.pointPosition",
	"Comment": "returns the x, y point of the given coordinate relative to this tile",
	"Method": "Point pointPosition(Coord point){\r\n    int x = position(dimension.getWidth(), point.getLongitude(), bbox.getSouthWest().getLongitude(), bbox.getNorthEast().getLongitude());\r\n    int y = position(dimension.getHeight(), point.getLatitude(), bbox.getSouthWest().getLatitude(), bbox.getNorthEast().getLatitude());\r\n    return new Point(x, dimension.getHeight() - y);\r\n}"
}, {
	"Path": "com.codename1.io.rest.RequestBuilder.fetchAsString",
	"Comment": "executes the request asynchronously and writes the response to the providedcallback",
	"Method": "ConnectionRequest fetchAsString(OnComplete<Response<String>> callback){\r\n    return getAsStringAsyncImpl(callback);\r\n}"
}, {
	"Path": "android.support.v4.view.accessibility.AccessibilityRecordCompat.getToIndex",
	"Comment": "gets the index of text selection end or the index of the lastvisible item when scrolling.",
	"Method": "int getToIndex(Object record,int getToIndex,Object record,int getToIndex,Object record,int getToIndex){\r\n    return IMPL.getToIndex(mRecord);\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.net.URI.relativize",
	"Comment": "create a relative uri object against this uri, given the uri parameter.",
	"Method": "URI relativize(URI uri){\r\n    if (isOpaque() || uri.isOpaque()) {\r\n        return uri;\r\n    }\r\n    if (getScheme() == null || uri.getScheme() == null || getScheme().equals(uri.getScheme()) == false) {\r\n        return uri;\r\n    }\r\n    String thisAuthority = null;\r\n    String thatAuthority = null;\r\n    String thisPath = null;\r\n    String thatPath = null;\r\n    if ((thisAuthority = getAuthority()) == null || (thatAuthority = uri.getAuthority()) == null || thisAuthority.equals(thatAuthority) == false) {\r\n        return uri;\r\n    }\r\n    if ((thisPath = getPath()) == null || (thatPath = uri.getPath()) == null || thatPath.startsWith(thisPath + PATH_SEPARATOR) == false) {\r\n        return uri;\r\n    }\r\n    try {\r\n        return new URI(null, null, thatPath.substring(thisPath.length() + 1), uri.getQuery(), uri.getFragment());\r\n    } catch (URISyntaxException e) {\r\n        throw new IllegalArgumentException(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.html.HTMLComponent.getPercentage",
	"Comment": "a convenience method to convert a string describing a percentage to an int.",
	"Method": "int getPercentage(String percent){\r\n    if ((percent == null) || (!percent.endsWith(\"%\"))) {\r\n        return 0;\r\n    }\r\n    return getInt(percent.substring(0, percent.length() - 1));\r\n}"
}, {
	"Path": "com.codename1.push.PushContent.setTextResponse",
	"Comment": "sets the text response for the notification.only applies to notifications where the user has entered a text response.",
	"Method": "void setTextResponse(String textResponse){\r\n    setProperty(\"textResponse\", textResponse);\r\n}"
}, {
	"Path": "com.codename1.cloud.CloudListModel.getRefreshRateMillis",
	"Comment": "indicates the rate in milliseconds in which to poll the server for the current dataof elements that are visible at the moment.",
	"Method": "int getRefreshRateMillis(){\r\n    return refreshRateMillis;\r\n}"
}, {
	"Path": "com.codename1.ui.events.ActionEvent.getProgress",
	"Comment": "returns the numeric progress of native browser loading on android",
	"Method": "int getProgress(){\r\n    return keyEvent;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.isBackgroundFetchSupported",
	"Comment": "checks to see if the current platform supports background fetch.",
	"Method": "boolean isBackgroundFetchSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "cognitivej.vision.computervision.ComputerVisionBuilder.analyzeImage",
	"Comment": "this operation extracts a rich set of visual features based on the image content.",
	"Method": "AnalyzeImageAction analyzeImage(List<VisualFeatures> visualFeatures,List<DomainSpecificDetails> domainSpecificDetails,String imageUrl,AnalyzeImageAction analyzeImage,List<VisualFeatures> visualFeatures,List<DomainSpecificDetails> domainSpecificDetails,InputStream image){\r\n    return new AnalyzeImageAction(cognitiveContext, visualFeatures, domainSpecificDetails, image);\r\n}"
}, {
	"Path": "com.codename1.impl.FullScreenAdService.isAllowWithoutNetwork",
	"Comment": "if set to true this flag allows the application to load even if an ad cannot be displayed",
	"Method": "boolean isAllowWithoutNetwork(){\r\n    return allowWithoutNetwork;\r\n}"
}, {
	"Path": "com.codename1.charts.renderers.SimpleSeriesRenderer.setHighlighted",
	"Comment": "sets if the item for this renderer should be highlighted. pie chart is supported for now.",
	"Method": "void setHighlighted(boolean highlighted){\r\n    mHighlighted = highlighted;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.clearStorageCache",
	"Comment": "storage is cached for faster access, however this might cause a problem with refreshingobjects since they are not cloned. clearing the cache allows to actually reload from thestorage file.",
	"Method": "void clearStorageCache(){\r\n    Storage.getInstance().clearCache();\r\n}"
}, {
	"Path": "com.codename1.ui.spinner.DateSpinner.setMonthRenderingPrototype",
	"Comment": "sets the month rendering prototype to be used, useful when the language is changed and you need the month spinner to be wider.",
	"Method": "void setMonthRenderingPrototype(String monthPrototype){\r\n    this.monthRenderingPrototype = monthPrototype;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.createNativePeer",
	"Comment": "creates a peer component for the given lightweight component",
	"Method": "PeerComponent createNativePeer(Object nativeComponent){\r\n    throw new IllegalArgumentException(nativeComponent.getClass().getName());\r\n}"
}, {
	"Path": "com.codename1.ui.animations.Timeline.getAnimationDelay",
	"Comment": "inidicates the minimal delay between animation frames allowing the cpu to rest.increase this number to increase general device performance, decrease it to speedthe animation.",
	"Method": "int getAnimationDelay(){\r\n    return animationDelay;\r\n}"
}, {
	"Path": "com.codename1.ui.Label.getMaskName",
	"Comment": "determines the name of the mask from the image constants thus allowing the mask to be applied from the theme",
	"Method": "String getMaskName(){\r\n    return maskName;\r\n}"
}, {
	"Path": "com.codename1.javascript.JSObject.callInt",
	"Comment": "calls a method on the underlying javascript object that returns an int. called synchronously with no arguments.",
	"Method": "int callInt(String key){\r\n    Double d = (Double) call(key);\r\n    return d.intValue();\r\n}"
}, {
	"Path": "com.codename1.io.MultipartRequest.getBoundary",
	"Comment": "returns the boundary string which is normally generated based on system time",
	"Method": "String getBoundary(){\r\n    return boundary;\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.gameKeyRelease",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "void gameKeyRelease(int gameKey){\r\n    TestUtils.gameKeyRelease(gameKey);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.getVisualPadding",
	"Comment": "returns the visual padding used when laying out this component. may be null and elements may be null.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "UnitValue[] getVisualPadding(){\r\n    return visualPadding != null ? new UnitValue[] { visualPadding[0], visualPadding[1], visualPadding[2], visualPadding[3] } : null;\r\n}"
}, {
	"Path": "com.codename1.ui.util.Resources.getGlobalResources",
	"Comment": "global resources are used by new gui builder apps to keep track of the applications resources",
	"Method": "Resources getGlobalResources(){\r\n    return globalResources;\r\n}"
}, {
	"Path": "com.codename1.testing.AbstractTest.waitForFormTitle",
	"Comment": "this method just invokes the test utils method, it is here for convenience",
	"Method": "void waitForFormTitle(String title){\r\n    TestUtils.waitForFormTitle(title);\r\n}"
}, {
	"Path": "com.codename1.impl.javase.JavaSEPort.addFormChangeListener",
	"Comment": "this is useful for debugging tools used in software automation",
	"Method": "void addFormChangeListener(com.codename1.ui.events.ActionListener al){\r\n    if (formChangeListener == null) {\r\n        formChangeListener = new EventDispatcher();\r\n    }\r\n    formChangeListener.addListener(al);\r\n}"
}, {
	"Path": "org.conscrypt.ct.SignedCertificateTimestamp.decode",
	"Comment": "decode a tls encoded signedcertificatetimestamp structure.",
	"Method": "SignedCertificateTimestamp decode(InputStream input,Origin origin,SignedCertificateTimestamp decode,byte[] input,Origin origin){\r\n    return decode(new ByteArrayInputStream(input), origin);\r\n}"
}, {
	"Path": "com.codename1.ui.AutoCompleteTextField.filter",
	"Comment": "subclasses can override this method to perform more elaborate filter operations",
	"Method": "boolean filter(String text){\r\n    if (filter != null) {\r\n        filter.filter(text);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.atomix.copycat.client.session.ClientSessionState.setResponseIndex",
	"Comment": "sets the highest index for which a response has been received.",
	"Method": "ClientSessionState setResponseIndex(long responseIndex){\r\n    this.responseIndex = Math.max(this.responseIndex, responseIndex);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.tree.Tree.createNode",
	"Comment": "creates a node within the tree, this method is protected allowing tree to besubclassed to replace the rendering logic of individual tree buttons.",
	"Method": "Component createNode(Object node,int depth){\r\n    if (multilineMode) {\r\n        SpanButton cmp = new SpanButton(childToDisplayLabel(node));\r\n        cmp.setUIID(\"TreeNode\");\r\n        cmp.setTextUIID(\"TreeNode\");\r\n        if (model.isLeaf(node)) {\r\n            cmp.setIcon(nodeImage);\r\n        } else {\r\n            cmp.setIcon(folder);\r\n        }\r\n        updateNodeComponentStyle(cmp.getAllStyles(), depth);\r\n        return cmp;\r\n    }\r\n    return createNodeComponent(node, depth);\r\n}"
}, {
	"Path": "com.codename1.ui.CustomFont.drawChars",
	"Comment": "override this frequently used method for a slight performance boost...",
	"Method": "void drawChars(Graphics g,char[] data,int offset,int length,int x,int y){\r\n    if (Display.getInstance().isBidiAlgorithm()) {\r\n        for (int i = offset; i < length; i++) {\r\n            if (Display.getInstance().isRTL(data[i])) {\r\n                String s = Display.getInstance().convertBidiLogicalToVisual(new String(data, offset, length));\r\n                data = s.toCharArray();\r\n                offset = 0;\r\n                length = s.length();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    initColor(g);\r\n    int clipX = g.getClipX();\r\n    int clipY = g.getClipY();\r\n    int clipWidth = g.getClipWidth();\r\n    int clipHeight = g.getClipHeight();\r\n    if (clipY <= y + getHeight() && clipY + clipHeight >= y) {\r\n        char c;\r\n        for (int i = 0; i < length; i++) {\r\n            c = data[offset + i];\r\n            int position = charsets.indexOf(c);\r\n            if (position < 0) {\r\n                continue;\r\n            }\r\n            g.clipRect(x, y, charWidth[position], imageHeight);\r\n            if (g.getClipWidth() > 0 && g.getClipHeight() > 0) {\r\n                g.drawImage(cache, x - cutOffsets[position], y);\r\n            }\r\n            x += charWidth[position];\r\n            g.setClip(clipX, clipY, clipWidth, clipHeight);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.codename1.io.services.ImageDownloadService.getResult",
	"Comment": "returns the image returned from the server, this method is useful for renderers",
	"Method": "EncodedImage getResult(){\r\n    return result;\r\n}"
}, {
	"Path": "java.util.Vector.equals",
	"Comment": "compares the specified object to this vector and returns if they areequal. the object must be a list which contains the same objects in thesame order.",
	"Method": "boolean equals(Object object){\r\n    if (this == object) {\r\n        return true;\r\n    }\r\n    if (object instanceof List) {\r\n        List<?> list = (List<?>) object;\r\n        if (list.size() != elementCount) {\r\n            return false;\r\n        }\r\n        int index = 0;\r\n        Iterator<?> it = list.iterator();\r\n        while (it.hasNext()) {\r\n            Object e1 = elementData[index++], e2 = it.next();\r\n            if (!(e1 == null ? e2 == null : e1.equals(e2))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.codename1.impl.CodenameOneImplementation.registerServerPush",
	"Comment": "sends a server request to register push support. this is a method for useby implementations.",
	"Method": "boolean registerServerPush(String id,String applicationKey,byte pushType,String udid,String packageName){\r\n    Preferences.set(\"push_key\", id);\r\n    return true;\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.mig.CC.minHeight",
	"Comment": "the minimum size for the component. the value will override any value that is set on the component itself.\tfor a more thorough explanation of what this constraint does see the white paper or cheat sheet at www.migcomponents.com.",
	"Method": "CC minHeight(String size){\r\n    ver.setSize(LayoutUtil.derive(ver.getSize(), ConstraintParser.parseUnitValue(size, false), null, null));\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.ui.list.DefaultListCellRenderer.setShowNumbersDefault",
	"Comment": "indicates whether the default list cell renderer will show numbers by defaultwhen constructed",
	"Method": "void setShowNumbersDefault(boolean def){\r\n    showNumbersDefault = def;\r\n}"
}, {
	"Path": "com.codename1.ui.Display.unlockOrientation",
	"Comment": "this is the reverse method for lock orientation allowing orientation lock to be disabled",
	"Method": "void unlockOrientation(){\r\n    impl.unlockOrientation();\r\n}"
}, {
	"Path": "com.codename1.designer.ResourceEditorApp.startup",
	"Comment": "at startup create and show the main frame of the application.",
	"Method": "void startup(){\r\n    ri = new ResourceEditorView(this, fileToLoad);\r\n    show(ri);\r\n    Image large = Toolkit.getDefaultToolkit().createImage(getClass().getResource(\"/application64.png\"));\r\n    Image small = Toolkit.getDefaultToolkit().createImage(getClass().getResource(\"/application48.png\"));\r\n    try {\r\n        getMainFrame().setIconImages(Arrays.asList(new Image[] { large, small }));\r\n    } catch (Throwable err) {\r\n        getMainFrame().setIconImage(small);\r\n    }\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.getPost",
	"Comment": "gets a post from a postidthis is a sync method it will block until a response it returned",
	"Method": "void getPost(String postId,Post post,ActionListener callback,Post getPost,String postId,boolean needAuth){\r\n    final Post post = new Post();\r\n    final Vector err = new Vector();\r\n    addResponseCodeListener(new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            NetworkEvent ne = (NetworkEvent) evt;\r\n            err.addElement(ne);\r\n            removeResponseCodeListener(this);\r\n        }\r\n    });\r\n    getFaceBookObject(postId, new ActionListener() {\r\n        public void actionPerformed(ActionEvent evt) {\r\n            Vector v = (Vector) ((NetworkEvent) evt).getMetaData();\r\n            Hashtable t = (Hashtable) v.elementAt(0);\r\n            post.copy(t);\r\n        }\r\n    }, needAuth, false);\r\n    if (err.size() > 0) {\r\n        throw new IOException(((NetworkEvent) err.elementAt(0)).getResponseCode() + \": \" + ((NetworkEvent) err.elementAt(0)).getMessage());\r\n    }\r\n    return post;\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.getPost",
	"Comment": "gets a post from a postidthis is a sync method it will block until a response it returned",
	"Method": "void getPost(String postId,Post post,ActionListener callback,Post getPost,String postId,boolean needAuth){\r\n    NetworkEvent ne = (NetworkEvent) evt;\r\n    err.addElement(ne);\r\n    removeResponseCodeListener(this);\r\n}"
}, {
	"Path": "com.codename1.facebook.FaceBookAccess.getPost",
	"Comment": "gets a post from a postidthis is a sync method it will block until a response it returned",
	"Method": "void getPost(String postId,Post post,ActionListener callback,Post getPost,String postId,boolean needAuth){\r\n    Vector v = (Vector) ((NetworkEvent) evt).getMetaData();\r\n    Hashtable t = (Hashtable) v.elementAt(0);\r\n    post.copy(t);\r\n}"
}, {
	"Path": "com.codename1.ui.layouts.BorderLayout.defineLandscapeSwap",
	"Comment": "this method allows swapping positions within the border layout when the layoutorientation changes to landscape or if the layout starts off as landscape.",
	"Method": "void defineLandscapeSwap(String portraitPosition,String landscapePosition){\r\n    if (landscapeSwap == null) {\r\n        landscapeSwap = new HashMap<String, String>();\r\n    }\r\n    landscapeSwap.put(portraitPosition, landscapePosition);\r\n    landscapeSwap.put(landscapePosition, portraitPosition);\r\n}"
}, {
	"Path": "java.lang.Boolean.booleanValue",
	"Comment": "returns the value of this boolean object as a boolean primitive.",
	"Method": "boolean booleanValue(){\r\n    return value;\r\n}"
}, {
	"Path": "net.sourceforge.retroweaver.harmony.runtime.java.util.IdentityHashMap.findIndex",
	"Comment": "returns the index where the key is found at, or the index of the nextempty spot if the key is not found in this table.",
	"Method": "int findIndex(Object key,Object[] array){\r\n    int length = array.length;\r\n    int index = getModuloHash(key, length);\r\n    int last = (index + length - 2) % length;\r\n    while (index != last) {\r\n        if (array[index] == key || (array[index] == null)) {\r\n            break;\r\n        }\r\n        index = (index + 2) % length;\r\n    }\r\n    return index;\r\n}"
}, {
	"Path": "com.codename1.ui.painter.PainterChain.prependPainter",
	"Comment": "creates a new chain based on the existing chain with the new element addedat the beginning",
	"Method": "PainterChain prependPainter(Painter p){\r\n    Painter[] newChain = new Painter[chain.length + 1];\r\n    System.arraycopy(chain, 1, newChain, 0, chain.length);\r\n    newChain[0] = p;\r\n    return new PainterChain(newChain);\r\n}"
}, {
	"Path": "com.codename1.ui.Slider.formattedValue",
	"Comment": "allows formatting the appearance of the progress when text is drawn on top",
	"Method": "String formattedValue(int value){\r\n    if (renderValueOnTop) {\r\n        return (\"\" + value);\r\n    }\r\n    if (renderPercentageOnTop) {\r\n        return (value + \"%\");\r\n    }\r\n    return (\"\");\r\n}"
}, {
	"Path": "com.codename1.ui.Button.pressed",
	"Comment": "invoked to change the state of the button to the pressed state",
	"Method": "void pressed(){\r\n    if (!Display.impl.isScrollWheeling()) {\r\n        state = STATE_PRESSED;\r\n        repaint();\r\n    }\r\n}"
}, {
	"Path": "ly.count.android.sdk.Countly.recordView",
	"Comment": "record a view manually, without automatic trackingor track view that is not automatically trackedlike fragment, message box or transparent activity",
	"Method": "Countly recordView(String viewName){\r\n    if (Countly.sharedInstance().isLoggingEnabled()) {\r\n        Log.d(Countly.TAG, \"Recording view with name: [\" + viewName + \"]\");\r\n    }\r\n    reportViewDuration();\r\n    lastView = viewName;\r\n    lastViewStart = Countly.currentTimestamp();\r\n    HashMap<String, String> segments = new HashMap();\r\n    segments.put(\"name\", viewName);\r\n    segments.put(\"visit\", \"1\");\r\n    segments.put(\"segment\", \"Android\");\r\n    if (firstView) {\r\n        firstView = false;\r\n        segments.put(\"start\", \"1\");\r\n    }\r\n    recordEvent(VIEW_EVENT_KEY, segments, 1);\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.testing.TestUtils.assertTextAreaEndingWith",
	"Comment": "asserts that we have a textarea with the a text ending with the given text and with the given name",
	"Method": "void assertTextAreaEndingWith(String name,String text){\r\n    if (verbose) {\r\n        log(\"assertTextAreaEndingWith(\" + name + \", \" + text + \")\");\r\n    }\r\n    TextArea l = (TextArea) findByName(name);\r\n    assertBool(l != null, \"Null area \" + text);\r\n    assertBool(l.getText().endsWith(text), \"assertTextArea: \\\"\" + l.getText() + \"\\\" is not ending with: \\\"\" + text + \"\\\"\");\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.bezierCorners",
	"Comment": "true if the corners are bezier curves, otherwise the corners are drawn as a regular arc",
	"Method": "RoundRectBorder bezierCorners(boolean bezierCorners){\r\n    this.bezierCorners = bezierCorners;\r\n    return this;\r\n}"
}, {
	"Path": "com.codename1.io.ConnectionRequest.getHeaderFieldNames",
	"Comment": "returns the http header field names for the given connection, this method is only guaranteed to workwhen invoked from the readheaders method.",
	"Method": "String[] getHeaderFieldNames(Object connection){\r\n    return Util.getImplementation().getHeaderFieldNames(connection);\r\n}"
}, {
	"Path": "com.codename1.ui.Font.isBitmapFontEnabled",
	"Comment": "indicates whether bitmap fonts should be enabled when loading orthe fallback system font should be used instead. this allows easy togglingof font loading.",
	"Method": "boolean isBitmapFontEnabled(){\r\n    return enableBitmapFont;\r\n}"
}, {
	"Path": "java.util.Arrays.find",
	"Comment": "finds the place of specified range of specified sorted array, where theelement should be inserted for getting sorted array. uses exponentialsearch algorithm.",
	"Method": "int find(Object[] arr,java.lang.Comparable val,int bnd,int l,int r,int find,Object[] arr,Object val,int bnd,int l,int r,Comparator c){\r\n    int m = l;\r\n    int d = 1;\r\n    while (m <= r) {\r\n        if (c.compare(val, arr[m]) > bnd) {\r\n            l = m + 1;\r\n        } else {\r\n            r = m - 1;\r\n            break;\r\n        }\r\n        m += d;\r\n        d <<= 1;\r\n    }\r\n    while (l <= r) {\r\n        m = (l + r) >>> 1;\r\n        if (c.compare(val, arr[m]) > bnd) {\r\n            l = m + 1;\r\n        } else {\r\n            r = m - 1;\r\n        }\r\n    }\r\n    return l - 1;\r\n}"
}, {
	"Path": "java.lang.Runtime.freeMemory",
	"Comment": "returns the amount of free memory in the system. calling the gc method may result in increasing the value returned by freememory.",
	"Method": "long freeMemory(){\r\n    return freeMemoryImpl();\r\n}"
}, {
	"Path": "com.codename1.ui.List.getCurrentSelected",
	"Comment": "returns the visual selection during a drag operation, otherwise equivalent to model.getselectedindex",
	"Method": "int getCurrentSelected(){\r\n    if (fixedSelection > FIXED_NONE_BOUNDRY && isDragActivated()) {\r\n        return fixedDraggedSelection;\r\n    }\r\n    return model.getSelectedIndex();\r\n}"
}, {
	"Path": "ly.count.android.sdk.Event.fromJSON",
	"Comment": "factory method to create an event from its json representation.",
	"Method": "Event fromJSON(JSONObject json){\r\n    Event event = new Event();\r\n    try {\r\n        if (!json.isNull(KEY_KEY)) {\r\n            event.key = json.getString(KEY_KEY);\r\n        }\r\n        event.count = json.optInt(COUNT_KEY);\r\n        event.sum = json.optDouble(SUM_KEY, 0.0d);\r\n        event.dur = json.optDouble(DUR_KEY, 0.0d);\r\n        event.timestamp = json.optLong(TIMESTAMP_KEY);\r\n        event.hour = json.optInt(HOUR);\r\n        event.dow = json.optInt(DAY_OF_WEEK);\r\n        if (!json.isNull(SEGMENTATION_KEY)) {\r\n            JSONObject segm = json.getJSONObject(SEGMENTATION_KEY);\r\n            final HashMap<String, String> segmentation = new HashMap();\r\n            final HashMap<String, Integer> segmentationInt = new HashMap();\r\n            final HashMap<String, Double> segmentationDouble = new HashMap();\r\n            final Iterator nameItr = segm.keys();\r\n            while (nameItr.hasNext()) {\r\n                final String key = (String) nameItr.next();\r\n                if (!segm.isNull(key)) {\r\n                    Object obj = segm.opt(key);\r\n                    if (obj instanceof Double) {\r\n                        segmentationDouble.put(key, segm.getDouble(key));\r\n                    } else if (obj instanceof Integer) {\r\n                        segmentationInt.put(key, segm.getInt(key));\r\n                    } else {\r\n                        segmentation.put(key, segm.getString(key));\r\n                    }\r\n                }\r\n            }\r\n            event.segmentation = segmentation;\r\n            event.segmentationDouble = segmentationDouble;\r\n            event.segmentationInt = segmentationInt;\r\n        }\r\n    } catch (JSONException e) {\r\n        if (Countly.sharedInstance().isLoggingEnabled()) {\r\n            Log.w(Countly.TAG, \"Got exception converting JSON to an Event\", e);\r\n        }\r\n        event = null;\r\n    }\r\n    return (event != null && event.key != null && event.key.length() > 0) ? event : null;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.attribute.MultiValueNullableAttribute.getValues",
	"Comment": "returns the values of the attribute from the object, omitting any null values.",
	"Method": "Iterable<A> getValues(O object,QueryOptions queryOptions){\r\n    Iterable<A> values = getNullableValues(object, queryOptions);\r\n    values = (values == null ? Collections.<A>emptyList() : values);\r\n    if (!componentValuesNullable) {\r\n        return values;\r\n    }\r\n    final Iterable<A> finalValues = values;\r\n    return new Iterable<A>() {\r\n        @Override\r\n        public Iterator<A> iterator() {\r\n            return IteratorUtil.removeNulls(finalValues.iterator());\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.googlecode.cqengine.attribute.MultiValueNullableAttribute.getValues",
	"Comment": "returns the values of the attribute from the object, omitting any null values.",
	"Method": "Iterable<A> getValues(O object,QueryOptions queryOptions){\r\n    return IteratorUtil.removeNulls(finalValues.iterator());\r\n}"
}, {
	"Path": "java.lang.Class.getDeclaredAnnotations",
	"Comment": "returns all annotations that are directly present on this element.",
	"Method": "Annotation[] getDeclaredAnnotations(){\r\n    return null;\r\n}"
}, {
	"Path": "com.codename1.io.Oauth2.createAuthComponent",
	"Comment": "this method creates a component which can authenticate. you will receiveeither the authentication key or an exception object within theactionlistener callback method.",
	"Method": "Component createAuthComponent(ActionListener al){\r\n    return createLoginComponent(al, null, null, null);\r\n}"
}, {
	"Path": "com.codename1.ui.Graphics.shear",
	"Comment": "shear the graphics coordinate system using the affine transform",
	"Method": "void shear(float x,float y){\r\n    impl.shear(nativeGraphics, x, y);\r\n}"
}, {
	"Path": "com.codename1.io.Storage.isNormalizeNames",
	"Comment": "indicates whether characters that are typically illegal in filesystems shouldbe sanitized and replaced with underscore",
	"Method": "boolean isNormalizeNames(){\r\n    return normalizeNames;\r\n}"
}, {
	"Path": "com.codename1.ui.Container.animateUnlayout",
	"Comment": "animates a pending layout into place, this effectively replaces revalidate with a more visual form of animation",
	"Method": "void animateUnlayout(int duration,int opacity,Runnable callback,ComponentAnimation animateUnlayout,int duration,boolean wait,int opacity,Runnable callback,boolean add){\r\n    setShouldCalcPreferredSize(true);\r\n    enableLayoutOnPaint = false;\r\n    final int componentCount = getComponentCount();\r\n    int[] beforeX = new int[componentCount];\r\n    int[] beforeY = new int[componentCount];\r\n    int[] beforeW = new int[componentCount];\r\n    int[] beforeH = new int[componentCount];\r\n    final Motion[] xMotions = new Motion[componentCount];\r\n    final Motion[] yMotions = new Motion[componentCount];\r\n    final Motion[] wMotions = new Motion[componentCount];\r\n    final Motion[] hMotions = new Motion[componentCount];\r\n    for (int iter = 0; iter < componentCount; iter++) {\r\n        Component current = getComponentAt(iter);\r\n        beforeX[iter] = current.getX();\r\n        beforeY[iter] = current.getY();\r\n        beforeW[iter] = current.getWidth();\r\n        beforeH[iter] = current.getHeight();\r\n    }\r\n    layoutContainer();\r\n    for (int iter = 0; iter < componentCount; iter++) {\r\n        Component current = getComponentAt(iter);\r\n        xMotions[iter] = createAnimateMotion(current.getX(), beforeX[iter], duration);\r\n        yMotions[iter] = createAnimateMotion(current.getY(), beforeY[iter], duration);\r\n        wMotions[iter] = createAnimateMotion(current.getWidth(), beforeW[iter], duration);\r\n        hMotions[iter] = createAnimateMotion(current.getHeight(), beforeH[iter], duration);\r\n        xMotions[iter].start();\r\n        yMotions[iter].start();\r\n        wMotions[iter].start();\r\n        hMotions[iter].start();\r\n    }\r\n    MorphAnimation a = new MorphAnimation(this, duration, new Motion[][] { xMotions, yMotions, wMotions, hMotions });\r\n    setAnimOpacity(255, opacity, a, componentCount, duration);\r\n    a.dontRevalidate = true;\r\n    if (add) {\r\n        if (wait) {\r\n            getAnimationManager().addAnimationAndBlock(a);\r\n        } else {\r\n            if (callback != null) {\r\n                getAnimationManager().addAnimation(a, callback);\r\n            } else {\r\n                getAnimationManager().addAnimation(a);\r\n            }\r\n        }\r\n    }\r\n    return a;\r\n}"
}, {
	"Path": "com.codename1.ui.plaf.RoundRectBorder.bottomOnlyMode",
	"Comment": "special mode where only the bottom of the round rectangle is rounded and the top is a regular rectangle",
	"Method": "RoundRectBorder bottomOnlyMode(boolean bottomOnlyMode){\r\n    if (bottomOnlyMode) {\r\n        this.topLeft = true;\r\n        this.topRight = true;\r\n        this.bottomLeft = false;\r\n        this.bottomRight = false;\r\n    } else {\r\n        this.bottomLeft = true;\r\n        this.bottomRight = true;\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "io.atomix.copycat.server.storage.MetaStoreTest.testBackwardCompability",
	"Comment": "tests backward compatibility with pre 1.2.6 release. this can be removed in release where backward compabitlitycode is removed.",
	"Method": "void testBackwardCompability(){\r\n    File storageDir = new File(String.format(\"target/test-logs/%s\", testId));\r\n    storageDir.mkdirs();\r\n    File file = new File(String.format(\"target/test-logs/%s/test.meta\", testId));\r\n    FileBuffer buffer = FileBuffer.allocate(file, 32);\r\n    buffer.writeLong(0, 1).flush();\r\n    buffer.writeInt(8, 2).flush();\r\n    List<Member> members = new ArrayList(Arrays.asList(new TestMember(Member.Type.ACTIVE, new Address(\"localhost\", 5000), new Address(\"localhost\", 6000))));\r\n    Configuration configuration = new Configuration(1, 1, System.currentTimeMillis(), members);\r\n    Serializer serializer = new Serializer().resolve(new ProtocolSerialization(), new ServerSerialization(), new StorageSerialization()).register(TestMember.class);\r\n    serializer.writeObject(configuration.members(), buffer.position(12).writeByte(1).writeLong(configuration.index()).writeLong(configuration.term()).writeLong(configuration.time()));\r\n    buffer.flush();\r\n    buffer.close();\r\n    MetaStore meta = createMetaStore();\r\n    assertEquals(meta.loadTerm(), 1);\r\n    assertEquals(meta.loadVote(), 2);\r\n    assertTrue(meta.loadConfiguration().members().equals(members));\r\n    meta.storeTerm(3);\r\n    meta.storeVote(4);\r\n    members = new ArrayList(Arrays.asList(new TestMember(Member.Type.ACTIVE, new Address(\"localhost\", 5001), new Address(\"localhost\", 6001))));\r\n    configuration = new Configuration(1, 1, System.currentTimeMillis(), members);\r\n    meta.storeConfiguration(configuration);\r\n    meta.close();\r\n    meta = createMetaStore();\r\n    assertEquals(meta.loadTerm(), 3);\r\n    assertEquals(meta.loadVote(), 4);\r\n    assertTrue(meta.loadConfiguration().members().equals(members));\r\n    meta.close();\r\n}"
}, {
	"Path": "io.atomix.copycat.server.state.ServerCommitPool.warn",
	"Comment": "issues a warning that the given commit was garbage collected.",
	"Method": "void warn(ServerCommit commit){\r\n    LOGGER.trace(\"Server commit \" + commit + \" was garbage collected!\\nCommit log is dirty!\");\r\n}"
}, {
	"Path": "com.codename1.components.Switch.addChangeListener",
	"Comment": "adds a listener to the switch which will cause an event on change",
	"Method": "void addChangeListener(ActionListener l){\r\n    changeDispatcher.addListener(l);\r\n}"
}, {
	"Path": "io.prometheus.client.guava.cache.CacheMetricsCollector.removeCache",
	"Comment": "remove the cache with the given name.any references to the cache are invalidated.",
	"Method": "Cache removeCache(String cacheName){\r\n    return children.remove(cacheName);\r\n}"
}, {
	"Path": "com.codename1.properties.PropertyBase.getGenericType",
	"Comment": "returns the generic type of this property if it is known or null",
	"Method": "Class getGenericType(){\r\n    return genericType;\r\n}"
}, {
	"Path": "com.codename1.ui.animations.ComponentAnimation.setStep",
	"Comment": "sets the current animation step to a value between 0 and maxsteps",
	"Method": "void setStep(int step){\r\n    this.step = step;\r\n}"
}, {
	"Path": "com.codename1.ui.CN.addToQueueAndWait",
	"Comment": "identical to add to queue but waits until the request is processed in the queue,this is useful for completely synchronous operations.",
	"Method": "void addToQueueAndWait(ConnectionRequest request){\r\n    NetworkManager.getInstance().addToQueueAndWait(request);\r\n}"
}, {
	"Path": "org.conscrypt.javax.crypto.CipherTest.assertIllegalStateException",
	"Comment": "asserts that running the given runnable results in an illegalstateexception",
	"Method": "void assertIllegalStateException(String failureMessage,Runnable runnable){\r\n    try {\r\n        runnable.run();\r\n        fail(failureMessage);\r\n    } catch (IllegalStateException expected) {\r\n    }\r\n}"
}, {
	"Path": "com.codename1.ui.Display.isNativeCommands",
	"Comment": "indicates whether codename one commands should be mapped to the native menus",
	"Method": "boolean isNativeCommands(){\r\n    return getCommandBehavior() == COMMAND_BEHAVIOR_NATIVE;\r\n}"
}, {
	"Path": "android.support.v4.util.SparseArrayCompat.get",
	"Comment": "gets the object mapped from the specified key, or the specified objectif no such mapping has been made.",
	"Method": "E get(int key,E get,int key,E valueIfKeyNotFound){\r\n    int i = binarySearch(mKeys, 0, mSize, key);\r\n    if (i < 0 || mValues[i] == DELETED) {\r\n        return valueIfKeyNotFound;\r\n    } else {\r\n        return (E) mValues[i];\r\n    }\r\n}"
}, {
	"Path": "java.lang.StringBuilder.charAt",
	"Comment": "the specified character of the sequence currently represented by the string builder, as indicated by the index argument, is returned. the first character of a string builder is at index 0, the next at index 1, and so on, for array indexing.the index argument must be greater than or equal to 0, and less than the length of this string builder.",
	"Method": "char charAt(int index){\r\n    return ' ';\r\n}"
}]