[{
	"Path": "com.haulmont.cuba.restapi.XMLConverter.encodeNull",
	"Comment": "sets the given value element as null. the null attribute is set to true.",
	"Method": "void encodeNull(Element element){\r\n    element.setAttribute(ATTR_NULL, \"true\");\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.TypedNativeQueryTest.testTypedNativeQueryByChangingAttribute",
	"Comment": "test that entity which is loaded by native typed query, is managed,by changing loaded entity attribute.",
	"Method": "void testTypedNativeQueryByChangingAttribute(){\r\n    Group group = new Group();\r\n    groupId = group.getId();\r\n    group.setName(\"Old Name\");\r\n    Transaction tx = cont.persistence().createTransaction();\r\n    try {\r\n        cont.persistence().getEntityManager().persist(group);\r\n        tx.commit();\r\n    } finally {\r\n        tx.end();\r\n    }\r\n    String nativeQuery = \"select ID, VERSION, CREATE_TS, CREATED_BY, UPDATE_TS, UPDATED_BY, NAME from SEC_GROUP where ID = ?\";\r\n    tx = cont.persistence().createTransaction();\r\n    try {\r\n        EntityManager em = cont.persistence().getEntityManager();\r\n        TypedQuery<Group> q = em.createNativeQuery(nativeQuery, Group.class);\r\n        q.setParameter(1, group.getId().toString());\r\n        Group g = q.getResultList().get(0);\r\n        g.setName(\"New Name\");\r\n        tx.commit();\r\n    } finally {\r\n        tx.end();\r\n    }\r\n    Group g2;\r\n    tx = cont.persistence().createTransaction();\r\n    try {\r\n        EntityManager em = cont.persistence().getEntityManager();\r\n        g2 = em.find(Group.class, group.getId());\r\n        assertNotNull(g2);\r\n        assertEquals(\"New Name\", g2.getName());\r\n        tx.commit();\r\n    } finally {\r\n        tx.end();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.app.core.entityinspector.EntityInspectorEditor.createView",
	"Comment": "creates a view, loading all the properties.referenced entities will be loaded with a local view.",
	"Method": "View createView(MetaClass meta){\r\n    View view = new View(meta.getJavaClass(), false);\r\n    for (MetaProperty metaProperty : meta.getProperties()) {\r\n        switch(metaProperty.getType()) {\r\n            case DATATYPE:\r\n            case ENUM:\r\n                view.addProperty(metaProperty.getName());\r\n                break;\r\n            case ASSOCIATION:\r\n            case COMPOSITION:\r\n                MetaClass metaPropertyClass = metaProperty.getRange().asClass();\r\n                String metaPropertyClassName = metaPropertyClass.getName();\r\n                if (metadata.getTools().isEmbedded(metaProperty)) {\r\n                    View embeddedViewWithRelations = createEmbeddedView(metaPropertyClass);\r\n                    view.addProperty(metaProperty.getName(), embeddedViewWithRelations);\r\n                } else {\r\n                    String viewName;\r\n                    if (metaProperty.getRange().getCardinality().isMany()) {\r\n                        viewName = View.LOCAL;\r\n                    } else {\r\n                        viewName = View.MINIMAL;\r\n                    }\r\n                    View propView = viewRepository.getView(metaPropertyClass, viewName);\r\n                    view.addProperty(metaProperty.getName(), new View(propView, metaPropertyClassName + \".entity-inspector-view\", true));\r\n                }\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"unknown property type\");\r\n        }\r\n    }\r\n    return view;\r\n}"
}, {
	"Path": "com.haulmont.cuba.restapi.RestServicePermissions.isPermitted",
	"Comment": "checks whether method of service is allowed to be invoked with rest api",
	"Method": "boolean isPermitted(String serviceName,String methodName){\r\n    lock.readLock().lock();\r\n    try {\r\n        checkInitialized();\r\n        Set<String> methods = serviceMethods.get(serviceName);\r\n        return methods != null && methods.contains(methodName);\r\n    } finally {\r\n        lock.readLock().unlock();\r\n    }\r\n}"
}, {
	"Path": "com.cronutils.model.time.TimeNode.getNearestForwardValue",
	"Comment": "we return same reference value if matches or next one if does not match.then we start applying shifts.this way we ensure same value is returned if no shift is requested.",
	"Method": "NearestValue getNearestForwardValue(int reference,int shiftsToApply){\r\n    final List<Integer> temporaryValues = new ArrayList(this.values);\r\n    int index = 0;\r\n    boolean foundGreater = false;\r\n    final AtomicInteger shift = new AtomicInteger(0);\r\n    if (!temporaryValues.contains(reference)) {\r\n        for (final Integer value : temporaryValues) {\r\n            if (value > reference) {\r\n                index = temporaryValues.indexOf(value);\r\n                shiftsToApply--;\r\n                foundGreater = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!foundGreater) {\r\n            shift.incrementAndGet();\r\n        }\r\n    } else {\r\n        index = temporaryValues.indexOf(reference);\r\n    }\r\n    int value = temporaryValues.get(index);\r\n    for (int j = 0; j < shiftsToApply; j++) {\r\n        value = getValueFromList(temporaryValues, index + 1, shift);\r\n        index = temporaryValues.indexOf(value);\r\n    }\r\n    return new NearestValue(value, shift.get());\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.EntityStates.isLoadedWithView",
	"Comment": "check that all properties of the view are loaded from db for the passed entity.",
	"Method": "boolean isLoadedWithView(Entity entity,View view,Set<Entity> visited,boolean isLoadedWithView,Entity entity,View view,boolean isLoadedWithView,Entity entity,String viewName){\r\n    checkNotNullArgument(viewName);\r\n    return isLoadedWithView(entity, viewRepository.getView(entity.getMetaClass(), viewName));\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.Tools.isUseSimpleMultiselectForTouchDevice",
	"Comment": "caution do not use multiselect mode simple for touch devices, it may be laptop with touch screen",
	"Method": "boolean isUseSimpleMultiselectForTouchDevice(){\r\n    return BrowserInfo.get().isAndroid() || BrowserInfo.get().isIOS();\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.app.AttributeSecuritySupport.afterMerge",
	"Comment": "should be called after merging an entity and before transaction commit.",
	"Method": "void afterMerge(Entity entity){\r\n    if (entity instanceof BaseGenericIdEntity) {\r\n        BaseGenericIdEntity genericIdEntity = (BaseGenericIdEntity) entity;\r\n        setupAttributeAccess(genericIdEntity);\r\n        metadataTools.traverseAttributes(genericIdEntity, new AttributeAccessVisitor(Sets.newHashSet(entity)));\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.AbstractEditor.preCommit",
	"Comment": "hook to be implemented in subclasses. called by the framework when all validation is done and datasources aregoing to be committed.",
	"Method": "boolean preCommit(){\r\n    return true;\r\n}"
}, {
	"Path": "com.cv4j.image.util.Tools.split",
	"Comment": "splits a string into substring using the characterscontained in the second argument as the delimiter set.",
	"Method": "String[] split(String str,String[] split,String str,String delim){\r\n    if (delim.equals(\"\\n\"))\r\n        return splitLines(str);\r\n    StringTokenizer t = new StringTokenizer(str, delim);\r\n    int tokens = t.countTokens();\r\n    String[] strings;\r\n    if (tokens > 0) {\r\n        strings = new String[tokens];\r\n        for (int i = 0; i < tokens; i++) strings[i] = t.nextToken();\r\n    } else\r\n        strings = new String[0];\r\n    return strings;\r\n}"
}, {
	"Path": "com.cronutils.model.SingleCron.equivalent",
	"Comment": "provides means to compare if two cron expressions are equivalent.assumes same cron definition.",
	"Method": "boolean equivalent(CronMapper cronMapper,Cron cron,boolean equivalent,Cron cron){\r\n    return asString().equals(cron.asString());\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.Window.applySettings",
	"Comment": "this method is called by the framework after opening the screen to apply user settings to all components.",
	"Method": "void applySettings(Settings settings){\r\n    UiControllerUtils.applySettings(getFrameOwner(), settings);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.app.core.entityinspector.EntityInspectorEditor.createRemoveAction",
	"Comment": "creates either remove or exclude action depending on property type",
	"Method": "RemoveAction createRemoveAction(MetaProperty metaProperty,Table table){\r\n    RemoveAction result;\r\n    switch(metaProperty.getType()) {\r\n        case COMPOSITION:\r\n            result = new com.haulmont.cuba.gui.components.actions.RemoveAction(table);\r\n            break;\r\n        case ASSOCIATION:\r\n            result = new com.haulmont.cuba.gui.components.actions.ExcludeAction(table);\r\n            result.setShortcut(configuration.getConfig(ClientConfig.class).getTableRemoveShortcut());\r\n            break;\r\n        default:\r\n            throw new IllegalArgumentException(\"property must contain an entity\");\r\n    }\r\n    result.setAutocommit(false);\r\n    return result;\r\n}"
}, {
	"Path": "org.crsh.cli.type.ValueType.parse",
	"Comment": "parse the s argument into a value of type s that is a subclass of thegeneric value type v.",
	"Method": "V parse(String s,S parse,Class<S> type,String s){\r\n    return parse(type, s);\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.aceeditor.AceEditorConnector.setOnRoundtrip",
	"Comment": "todo xxx not sure if this roundtrip thing is correct, seems to work ok...",
	"Method": "void setOnRoundtrip(boolean on){\r\n    if (on == onRoundtrip) {\r\n        return;\r\n    }\r\n    onRoundtrip = on;\r\n    if (!onRoundtrip) {\r\n        sendToServerImmediately(sendAfterRoundtrip);\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.actions.CreateAction.create",
	"Comment": "creates an action with default id, opening the editor screen in this tab.",
	"Method": "CreateAction create(ListComponent target,CreateAction create,ListComponent target,WindowManager.OpenType openType,CreateAction create,ListComponent target,WindowManager.OpenType openType,String id){\r\n    return AppBeans.getPrototype(\"cuba_CreateAction\", target, openType, id);\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.v7.ui.horizontallayout.VDDHorizontalLayout.getDragMode",
	"Comment": "returns the current drag mode which determines how the drag is visualized",
	"Method": "LayoutDragMode getDragMode(){\r\n    return ddMouseHandler.getDragMode();\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.sys.singleapp.SingleAppWebContextLoader.contextInitialized",
	"Comment": "here we create servlets and filters manually, to make sure the classes would be loaded using necessary classloader.",
	"Method": "void contextInitialized(ServletContextEvent servletContextEvent){\r\n    super.contextInitialized(servletContextEvent);\r\n    try {\r\n        ServletContext servletContext = servletContextEvent.getServletContext();\r\n        registerAppServlet(servletContext);\r\n        registerDispatchServlet(servletContext);\r\n        registerRestApiServlet(servletContext);\r\n        registerCubaHttpFilter(servletContext);\r\n        registerFrontAppServlet(servletContext);\r\n        registerClassLoaderFilter(servletContext);\r\n        initWebServletContextListener(servletContextEvent, servletContext);\r\n    } catch (RuntimeException e) {\r\n        log.error(\"Error initializing web servlets\", e);\r\n        try {\r\n            ApplicationContext springContext = AppContext.getApplicationContext();\r\n            if (springContext != null) {\r\n                ((ConfigurableApplicationContext) springContext).close();\r\n            }\r\n        } catch (Exception e1) {\r\n            log.debug(\"Error closing application context: {}\", e1.toString());\r\n        }\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.DDHorizontalSplitPanel.getDropHandler",
	"Comment": "returns the drop handler which handles drop events from droppingcomponents on the layout. returns null if dropping is disabled.",
	"Method": "DropHandler getDropHandler(){\r\n    return dropHandler;\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.sys.vcl.SearchAutoCompleteSupport.findArrowButton",
	"Comment": "a convenience method to search through the given jcombobox for thejbutton which toggles the popup up open and closed.",
	"Method": "JButton findArrowButton(JComboBox c){\r\n    for (int i = 0, n = c.getComponentCount(); i < n; i++) {\r\n        final Component comp = c.getComponent(i);\r\n        if (comp instanceof JButton)\r\n            return (JButton) comp;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.OptionsField.setOptionsMap",
	"Comment": "sets options from the passed map and automatically applies option caption provider based on map keys.",
	"Method": "void setOptionsMap(Map<String, I> map){\r\n    checkNotNullArgument(map);\r\n    BiMap<String, I> biMap = ImmutableBiMap.copyOf(map);\r\n    setOptions(new MapOptions(map));\r\n    setOptionCaptionProvider(v -> biMap.inverse().get(v));\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.Window.addListener",
	"Comment": "add a listener that will be notified when this screen is closed.",
	"Method": "void addListener(CloseListener listener){\r\n    getFrameOwner().addAfterCloseListener(new AfterCloseListenerAdapter(listener));\r\n}"
}, {
	"Path": "name.fraser.neil.plaintext.diff_match_patch.diff_main",
	"Comment": "find the differences between two texts.simplifies the problem bystripping any common prefix or suffix off the texts before diffing.",
	"Method": "LinkedList<Diff> diff_main(String text1,String text2,LinkedList<Diff> diff_main,String text1,String text2,boolean checklines,LinkedList<Diff> diff_main,String text1,String text2,boolean checklines,long deadline){\r\n    if (text1 == null || text2 == null) {\r\n        throw new IllegalArgumentException(\"Null inputs. (diff_main)\");\r\n    }\r\n    LinkedList<Diff> diffs;\r\n    if (text1.equals(text2)) {\r\n        diffs = new LinkedList<Diff>();\r\n        if (text1.length() != 0) {\r\n            diffs.add(new Diff(Operation.EQUAL, text1));\r\n        }\r\n        return diffs;\r\n    }\r\n    int commonlength = diff_commonPrefix(text1, text2);\r\n    String commonprefix = text1.substring(0, commonlength);\r\n    text1 = text1.substring(commonlength);\r\n    text2 = text2.substring(commonlength);\r\n    commonlength = diff_commonSuffix(text1, text2);\r\n    String commonsuffix = text1.substring(text1.length() - commonlength);\r\n    text1 = text1.substring(0, text1.length() - commonlength);\r\n    text2 = text2.substring(0, text2.length() - commonlength);\r\n    diffs = diff_compute(text1, text2, checklines, deadline);\r\n    if (commonprefix.length() != 0) {\r\n        diffs.addFirst(new Diff(Operation.EQUAL, commonprefix));\r\n    }\r\n    if (commonsuffix.length() != 0) {\r\n        diffs.addLast(new Diff(Operation.EQUAL, commonsuffix));\r\n    }\r\n    diff_cleanupMerge(diffs);\r\n    return diffs;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.config.type.TypeFactory.getInstance",
	"Comment": "get a typefactory instance appropriate for the return type of thespecified configuration interface method.",
	"Method": "TypeFactory getInstance(Class<?> configInterface,Method method){\r\n    Class<?> returnType = method.getReturnType();\r\n    if (returnType.isPrimitive()) {\r\n        returnType = ClassUtils.primitiveToWrapper(returnType);\r\n    }\r\n    Factory factory = ConfigUtil.getAnnotation(configInterface, method, Factory.class, true);\r\n    if (factory != null) {\r\n        try {\r\n            if (\"\".equals(factory.method())) {\r\n                return factory.factory().newInstance();\r\n            } else {\r\n                String methodName = factory.method();\r\n                Method factoryMethod = returnType.getMethod(methodName, String.class);\r\n                if (!isAcceptableMethod(returnType, factoryMethod)) {\r\n                    throw new IllegalArgumentException(\"Invalid factory method: \" + factoryMethod);\r\n                }\r\n                return new StaticTypeFactory(factoryMethod);\r\n            }\r\n        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException e) {\r\n            throw new RuntimeException(\"Unable to instantiate an type factory\", e);\r\n        }\r\n    } else {\r\n        if (Entity.class.isAssignableFrom(returnType)) {\r\n            return AppBeans.get(ENTITY_FACTORY_BEAN_NAME, TypeFactory.class);\r\n        } else {\r\n            if (EnumClass.class.isAssignableFrom(returnType)) {\r\n                EnumStore mode = ConfigUtil.getAnnotation(configInterface, method, EnumStore.class, true);\r\n                if (mode != null && EnumStoreMode.ID == mode.value()) {\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    Class<EnumClass> enumeration = (Class<EnumClass>) returnType;\r\n                    Class<?> idType = ConfigUtil.getEnumIdType(enumeration);\r\n                    TypeFactory idFactory = getInferred(idType);\r\n                    try {\r\n                        Method fromIdMethod = returnType.getMethod(\"fromId\", idType);\r\n                        if (!isAcceptableMethod(returnType, fromIdMethod) || idFactory == null) {\r\n                            throw new IllegalArgumentException(\"Cannot use method as factory method: \" + method);\r\n                        }\r\n                        return new EnumClassFactory(idFactory, fromIdMethod);\r\n                    } catch (NoSuchMethodException e) {\r\n                        throw new IllegalArgumentException(\"fromId method is not found for \" + enumeration.getName());\r\n                    }\r\n                }\r\n            }\r\n            TypeFactory factoryT = getInferred(returnType);\r\n            if (factoryT == null) {\r\n                throw new IllegalArgumentException(\"Unsupported return type for \" + method);\r\n            }\r\n            return factoryT;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.cronutils.model.definition.CronDefinitionBuilder.instanceDefinitionFor",
	"Comment": "creates crondefinition instance matching crontype specification.",
	"Method": "CronDefinition instanceDefinitionFor(CronType cronType){\r\n    switch(cronType) {\r\n        case CRON4J:\r\n            return cron4j();\r\n        case QUARTZ:\r\n            return quartz();\r\n        case UNIX:\r\n            return unixCrontab();\r\n        case SPRING:\r\n            return spring();\r\n        default:\r\n            throw new IllegalArgumentException(String.format(\"No cron definition found for %s\", cronType));\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.ExtendedEntities.getEffectiveMetaClass",
	"Comment": "searches for an extended entity and returns it if found, otherwise returns the original entity.",
	"Method": "MetaClass getEffectiveMetaClass(MetaClass originalMetaClass,MetaClass getEffectiveMetaClass,Class originalClass,MetaClass getEffectiveMetaClass,String entityName){\r\n    return getEffectiveMetaClass(metadata.getSession().getClassNN(entityName));\r\n}"
}, {
	"Path": "com.oath.cyclops.async.adapters.Queue.add",
	"Comment": "add a single data point to the queueif the queue is a bounded queue and is full, will return false",
	"Method": "boolean add(T data){\r\n    try {\r\n        final boolean result = queue.add((T) nullSafe(data));\r\n        if (result) {\r\n            if (sizeSignal != null)\r\n                this.sizeSignal.set(queue.size());\r\n        }\r\n        return result;\r\n    } catch (final IllegalStateException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.cqengine.query.parser.sql.support.SQLAntlrListener.addParsedQuery",
	"Comment": "adds the given query to a list of child queries which have not yet been wrapped in a parent query.",
	"Method": "void addParsedQuery(ParserRuleContext currentContext,Query<O> parsedQuery){\r\n    ParserRuleContext parentContext = getParentContextOfType(currentContext, getAndOrNotContextClasses());\r\n    Collection<Query<O>> childrenOfParent = this.childQueries.get(parentContext);\r\n    if (childrenOfParent == null) {\r\n        childrenOfParent = new ArrayList<Query<O>>();\r\n        this.childQueries.put(parentContext, childrenOfParent);\r\n    }\r\n    childrenOfParent.add(parsedQuery);\r\n    numQueriesParsed++;\r\n}"
}, {
	"Path": "com.vinaygaba.creditcardview.CreditCardView.getFormattedCardNumber",
	"Comment": "returns the formatted card number based on the user entered value for card number format",
	"Method": "String getFormattedCardNumber(String cardNumber){\r\n    if (DEBUG) {\r\n        Log.e(\"Card Number\", cardNumber);\r\n    }\r\n    switch(getCardNumberFormat()) {\r\n        case MASKED_ALL_BUT_LAST_FOUR:\r\n            cardNumber = \"**** **** **** \" + cardNumber.substring(cardNumber.length() - 4);\r\n            break;\r\n        case ONLY_LAST_FOUR:\r\n            cardNumber = cardNumber.substring(cardNumber.length() - 4);\r\n            break;\r\n        case MASKED_ALL:\r\n            cardNumber = \"**** **** **** ****\";\r\n            break;\r\n        case ALL_DIGITS:\r\n            break;\r\n        default:\r\n            throw new UnsupportedOperationException(\"CreditCardFormat: \" + mCardNumberFormat + \" is not supported. Use `CreditCardFormat.*`\");\r\n    }\r\n    return cardNumber;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.filter.addcondition.ConditionDescriptorsDs.setFilter",
	"Comment": "sets a filter string, fills internal collection with filtered items and refreshes the datasource",
	"Method": "void setFilter(String filter){\r\n    this.conditionsFilter = filter;\r\n    filterApplied = false;\r\n    filteredItemsIds = new ArrayList();\r\n    for (UUID rootId : getRootItemIds()) {\r\n        recursivelyFindSelectedItems(rootId);\r\n    }\r\n    filterApplied = true;\r\n    refresh(Collections.<String, Object>singletonMap(\"descriptorsTree\", descriptorsTree));\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.export.ExcelAutoColumnSizer.isNotificationRequired",
	"Comment": "when you add a new value to a column, call this method to ask whetherthe autocolumnsizer is interested in it.",
	"Method": "boolean isNotificationRequired(int row){\r\n    if (row < 0)\r\n        throw new IllegalArgumentException(\"illegal row: \" + row);\r\n    int rowBand = -1;\r\n    for (int band = 0; band < ROW_BAND.length; band++) {\r\n        if (row < ROW_BAND[band]) {\r\n            rowBand = band - 1;\r\n            break;\r\n        }\r\n    }\r\n    if (rowBand == -1) {\r\n        return false;\r\n    } else if ((row % ROW_BAND_SAMPLE_FREQUENCY[rowBand]) != 0) {\r\n        return false;\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "com.cronutils.model.time.SingleExecutionTime.nextClosestMatch",
	"Comment": "if date is not match, will return next closest match.if date is match, will return this date.",
	"Method": "ZonedDateTime nextClosestMatch(ZonedDateTime date){\r\n    ExecutionTimeResult result = new ExecutionTimeResult(date, false);\r\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\r\n        result = potentialNextClosestMatch(result.getTime());\r\n        if (result.isMatch()) {\r\n            return result.getTime();\r\n        }\r\n        if (result.getTime().getYear() - date.getYear() > 100) {\r\n            throw new NoSuchValueException();\r\n        }\r\n    }\r\n    throw new NoSuchValueException();\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.AppBeans.getPrototype",
	"Comment": "return an instance of prototype bean, specifying explicit constructor arguments.",
	"Method": "T getPrototype(String name,Object args){\r\n    return (T) getBeanLocator().getPrototype(name, args);\r\n}"
}, {
	"Path": "name.fraser.neil.plaintext.diff_match_patch.diff_fromDelta",
	"Comment": "given the original text1, and an encoded string which describes theoperations required to transform text1 into text2, compute the full diff.",
	"Method": "LinkedList<Diff> diff_fromDelta(String text1,String delta){\r\n    LinkedList<Diff> diffs = new LinkedList<Diff>();\r\n    int pointer = 0;\r\n    String[] tokens = delta.split(\"\\t\");\r\n    for (String token : tokens) {\r\n        if (token.length() == 0) {\r\n            continue;\r\n        }\r\n        String param = token.substring(1);\r\n        switch(token.charAt(0)) {\r\n            case '+':\r\n                param = param.replace(\"+\", \"+\");\r\n                try {\r\n                    param = URLDecoder.decode(param, \"UTF-8\");\r\n                } catch (UnsupportedEncodingException e) {\r\n                    throw new Error(\"This system does not support UTF-8.\", e);\r\n                } catch (IllegalArgumentException e) {\r\n                    throw new IllegalArgumentException(\"Illegal escape in diff_fromDelta: \" + param, e);\r\n                }\r\n                diffs.add(new Diff(Operation.INSERT, param));\r\n                break;\r\n            case '-':\r\n            case '=':\r\n                int n;\r\n                try {\r\n                    n = Integer.parseInt(param);\r\n                } catch (NumberFormatException e) {\r\n                    throw new IllegalArgumentException(\"Invalid number in diff_fromDelta: \" + param, e);\r\n                }\r\n                if (n < 0) {\r\n                    throw new IllegalArgumentException(\"Negative number in diff_fromDelta: \" + param);\r\n                }\r\n                String text;\r\n                try {\r\n                    text = text1.substring(pointer, pointer += n);\r\n                } catch (StringIndexOutOfBoundsException e) {\r\n                    throw new IllegalArgumentException(\"Delta length (\" + pointer + \") larger than source text length (\" + text1.length() + \").\", e);\r\n                }\r\n                if (token.charAt(0) == '=') {\r\n                    diffs.add(new Diff(Operation.EQUAL, text));\r\n                } else {\r\n                    diffs.add(new Diff(Operation.DELETE, text));\r\n                }\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(\"Invalid diff operation in diff_fromDelta: \" + token.charAt(0));\r\n        }\r\n    }\r\n    if (pointer != text1.length()) {\r\n        throw new IllegalArgumentException(\"Delta length (\" + pointer + \") smaller than source text length (\" + text1.length() + \").\");\r\n    }\r\n    return diffs;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.config.ConfigAccessorMethod.getPropertyName",
	"Comment": "get the name of the configuration property associated with thisaccessor method.",
	"Method": "String getPropertyName(){\r\n    return property;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.actions.ListAction.withHandler",
	"Comment": "set action performed event handler using fluent api method. can be used instead of subclassing baseaction class.",
	"Method": "ListAction withHandler(Consumer<ActionPerformedEvent> handler){\r\n    getEventHub().subscribe(ActionPerformedEvent.class, handler);\r\n    return this;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.v7.DDHorizontalLayout.getDropHandler",
	"Comment": "returns the drop handler which handles drop events from droppingcomponents on the layout. returns null if dropping is disabled.",
	"Method": "DropHandler getDropHandler(){\r\n    return dropHandler;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.exception.AbstractGenericExceptionHandler.canHandle",
	"Comment": "should be implemented in subclasses if the exception class name is not enough to determine the ability tohandle the exception.",
	"Method": "boolean canHandle(String className,String message,Throwable throwable){\r\n    return true;\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.sys.vcl.SearchAutoCompleteSupport.applyFilter",
	"Comment": "this method updates the value which filters the items in thecomboboxmodel.",
	"Method": "void applyFilter(String newFilter){\r\n    if (doNotFilter)\r\n        return;\r\n    doNotChangeDocument = true;\r\n    final ActionListener[] listeners = unregisterAllActionListeners(comboBox);\r\n    isFiltering = true;\r\n    try {\r\n        if (filterEnabled) {\r\n            filterMatcherEditor.setFilterText(new String[] { newFilter });\r\n        }\r\n    } finally {\r\n        isFiltering = false;\r\n        registerAllActionListeners(comboBox, listeners);\r\n        doNotChangeDocument = false;\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.MetadataTools.isEmbeddable",
	"Comment": "determine whether the given entity class is persistent embeddable.",
	"Method": "boolean isEmbeddable(MetaClass metaClass,boolean isEmbeddable,Class aClass){\r\n    checkNotNullArgument(aClass, \"Class is null\");\r\n    return Boolean.TRUE.equals(metadata.getClassNN(aClass).getAnnotations().get(PERSISTENT_ANN_NAME)) && aClass.isAnnotationPresent(javax.persistence.Embeddable.class);\r\n}"
}, {
	"Path": "name.fraser.neil.plaintext.diff_match_patch.diff_cleanupSemantic",
	"Comment": "reduce the number of edits by eliminating semantically trivial equalities.",
	"Method": "void diff_cleanupSemantic(LinkedList<Diff> diffs){\r\n    if (diffs.isEmpty()) {\r\n        return;\r\n    }\r\n    boolean changes = false;\r\n    Stack<Diff> equalities = new Stack<Diff>();\r\n    String lastequality = null;\r\n    ListIterator<Diff> pointer = diffs.listIterator();\r\n    int length_insertions1 = 0;\r\n    int length_deletions1 = 0;\r\n    int length_insertions2 = 0;\r\n    int length_deletions2 = 0;\r\n    Diff thisDiff = pointer.next();\r\n    while (thisDiff != null) {\r\n        if (thisDiff.operation == Operation.EQUAL) {\r\n            equalities.push(thisDiff);\r\n            length_insertions1 = length_insertions2;\r\n            length_deletions1 = length_deletions2;\r\n            length_insertions2 = 0;\r\n            length_deletions2 = 0;\r\n            lastequality = thisDiff.text;\r\n        } else {\r\n            if (thisDiff.operation == Operation.INSERT) {\r\n                length_insertions2 += thisDiff.text.length();\r\n            } else {\r\n                length_deletions2 += thisDiff.text.length();\r\n            }\r\n            if (lastequality != null && (lastequality.length() <= Math.max(length_insertions1, length_deletions1)) && (lastequality.length() <= Math.max(length_insertions2, length_deletions2))) {\r\n                while (thisDiff != equalities.lastElement()) {\r\n                    thisDiff = pointer.previous();\r\n                }\r\n                pointer.next();\r\n                pointer.set(new Diff(Operation.DELETE, lastequality));\r\n                pointer.add(new Diff(Operation.INSERT, lastequality));\r\n                equalities.pop();\r\n                if (!equalities.empty()) {\r\n                    equalities.pop();\r\n                }\r\n                if (equalities.empty()) {\r\n                    while (pointer.hasPrevious()) {\r\n                        pointer.previous();\r\n                    }\r\n                } else {\r\n                    thisDiff = equalities.lastElement();\r\n                    while (thisDiff != pointer.previous()) {\r\n                    }\r\n                }\r\n                length_insertions1 = 0;\r\n                length_insertions2 = 0;\r\n                length_deletions1 = 0;\r\n                length_deletions2 = 0;\r\n                lastequality = null;\r\n                changes = true;\r\n            }\r\n        }\r\n        thisDiff = pointer.hasNext() ? pointer.next() : null;\r\n    }\r\n    if (changes) {\r\n        diff_cleanupMerge(diffs);\r\n    }\r\n    diff_cleanupSemanticLossless(diffs);\r\n    pointer = diffs.listIterator();\r\n    Diff prevDiff = null;\r\n    thisDiff = null;\r\n    if (pointer.hasNext()) {\r\n        prevDiff = pointer.next();\r\n        if (pointer.hasNext()) {\r\n            thisDiff = pointer.next();\r\n        }\r\n    }\r\n    while (thisDiff != null) {\r\n        if (prevDiff.operation == Operation.DELETE && thisDiff.operation == Operation.INSERT) {\r\n            String deletion = prevDiff.text;\r\n            String insertion = thisDiff.text;\r\n            int overlap_length1 = this.diff_commonOverlap(deletion, insertion);\r\n            int overlap_length2 = this.diff_commonOverlap(insertion, deletion);\r\n            if (overlap_length1 >= overlap_length2) {\r\n                if (overlap_length1 >= deletion.length() / 2.0 || overlap_length1 >= insertion.length() / 2.0) {\r\n                    pointer.previous();\r\n                    pointer.add(new Diff(Operation.EQUAL, insertion.substring(0, overlap_length1)));\r\n                    prevDiff.text = deletion.substring(0, deletion.length() - overlap_length1);\r\n                    thisDiff.text = insertion.substring(overlap_length1);\r\n                }\r\n            } else {\r\n                if (overlap_length2 >= deletion.length() / 2.0 || overlap_length2 >= insertion.length() / 2.0) {\r\n                    pointer.previous();\r\n                    pointer.add(new Diff(Operation.EQUAL, deletion.substring(0, overlap_length2)));\r\n                    prevDiff.operation = Operation.INSERT;\r\n                    prevDiff.text = insertion.substring(0, insertion.length() - overlap_length2);\r\n                    thisDiff.operation = Operation.DELETE;\r\n                    thisDiff.text = deletion.substring(overlap_length2);\r\n                }\r\n            }\r\n            thisDiff = pointer.hasNext() ? pointer.next() : null;\r\n        }\r\n        prevDiff = thisDiff;\r\n        thisDiff = pointer.hasNext() ? pointer.next() : null;\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.filter.ConditionsTree.createCopy",
	"Comment": "creates a copy of conditionstree. each node of new tree contains a copy of source condition.",
	"Method": "ConditionsTree createCopy(){\r\n    ConditionsTree copyTree = new ConditionsTree();\r\n    List<Node<AbstractCondition>> newRootNodes = new ArrayList();\r\n    for (Node<AbstractCondition> rootNode : this.getRootNodes()) {\r\n        Node<AbstractCondition> newRootNode = new Node();\r\n        newRootNodes.add(newRootNode);\r\n        recursivelyCopyNode(rootNode, newRootNode);\r\n    }\r\n    copyTree.setRootNodes(newRootNodes);\r\n    return copyTree;\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.gui.components.DesktopTableCellEditor.isInline",
	"Comment": "inline components always fit in standard row height,so there is no need to pack rows for desktop table.",
	"Method": "boolean isInline(){\r\n    if (componentClass == null) {\r\n        return false;\r\n    }\r\n    for (Class inlineClass : inlineComponentClasses) {\r\n        if (componentClass.isAssignableFrom(inlineClass)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.gui.components.DesktopTableCellEditor.isEditableComponent",
	"Comment": "if component is editable, it should gain focus from table.mouse events like mouse dragging are treated differently for editable columns.",
	"Method": "boolean isEditableComponent(Class<? extends com.haulmont.cuba.gui.components.Component> componentClass){\r\n    if (componentClass == null) {\r\n        return true;\r\n    }\r\n    for (Class readOnlyClass : readOnlyComponentClasses) {\r\n        if (componentClass.isAssignableFrom(readOnlyClass)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.sys.DisabledGlassPane.setBackground",
	"Comment": "the\tbackground color of the message label will be the same as thebackground of the glass pane without the alpha value",
	"Method": "void setBackground(Color background){\r\n    super.setBackground(background);\r\n    Color messageBackground = new Color(background.getRGB());\r\n    message.setBackground(messageBackground);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.MetadataTools.viewContainsProperty",
	"Comment": "determine whether the view contains a property, traversing a view branch according to the given property path.",
	"Method": "boolean viewContainsProperty(View view,MetaPropertyPath propertyPath){\r\n    View currentView = view;\r\n    for (MetaProperty metaProperty : propertyPath.getMetaProperties()) {\r\n        if (currentView == null)\r\n            return false;\r\n        ViewProperty property = currentView.getProperty(metaProperty.getName());\r\n        if (property == null)\r\n            return false;\r\n        currentView = property.getView();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.drophandlers.AbstractDefaultLayoutDropHandler.handleDropFromAbsoluteParentLayout",
	"Comment": "handles a drop by a component which has an absolute layout as parent. inthis case the component is moved.",
	"Method": "void handleDropFromAbsoluteParentLayout(DragAndDropEvent event){\r\n    LayoutBoundTransferable transferable = (LayoutBoundTransferable) event.getTransferable();\r\n    TargetDetails details = event.getTargetDetails();\r\n    MouseEventDetails mouseDown = transferable.getMouseDownEvent();\r\n    MouseEventDetails mouseUp = MouseEventDetails.deSerialize((String) details.getData(Constants.DROP_DETAIL_MOUSE_EVENT));\r\n    int movex = mouseUp.getClientX() - mouseDown.getClientX();\r\n    int movey = mouseUp.getClientY() - mouseDown.getClientY();\r\n    Component comp = transferable.getComponent();\r\n    DDAbsoluteLayout parent = (DDAbsoluteLayout) comp.getParent();\r\n    ComponentPosition position = parent.getPosition(comp);\r\n    if (position.getLeftValue() != null) {\r\n        float x = position.getLeftValue() + movex;\r\n        position.setLeft(x, Sizeable.UNITS_PIXELS);\r\n    }\r\n    if (position.getRightValue() != null) {\r\n        float x = position.getRightValue() - movex;\r\n        position.setRight(x, Sizeable.UNITS_PIXELS);\r\n    }\r\n    if (position.getTopValue() != null) {\r\n        float y = position.getTopValue() + movey;\r\n        position.setTop(y, Sizeable.UNITS_PIXELS);\r\n    }\r\n    if (position.getBottomValue() != null) {\r\n        float y = position.getBottomValue() - movey;\r\n        position.setBottom(y, Sizeable.UNITS_PIXELS);\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.cqengine.query.parser.sql.support.SQLAntlrListener.exitQuery",
	"Comment": "this handler is called for all queries, allows us to validate that no handlers are missing.",
	"Method": "void exitQuery(SQLGrammarParser.QueryContext ctx){\r\n    numQueriesEncountered++;\r\n    validateAllQueriesParsed(numQueriesEncountered, numQueriesParsed);\r\n}"
}, {
	"Path": "org.crsh.plugin.PropertyDescriptor.toProperty",
	"Comment": "parse a string representation of a value and returns the correspondig property value.",
	"Method": "Property<T> toProperty(String s){\r\n    T value = parse(s);\r\n    return new Property<T>(this, value);\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.popupbutton.PopupButton.addPopupVisibilityListener",
	"Comment": "add a listener that is called whenever the visibility of the popup ischanged.",
	"Method": "Registration addPopupVisibilityListener(PopupVisibilityListener listener){\r\n    return addListener(PopupVisibilityEvent.class, listener, PopupVisibilityListener.popupVisibilityMethod);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.screen.MasterDetailScreen.initBrowseCreateAction",
	"Comment": "adds a createaction that removes selection in table, sets a newly created item to editdsand enables controls for record editing.",
	"Method": "void initBrowseCreateAction(){\r\n    ListComponent<T> table = getTable();\r\n    CreateAction createAction = (CreateAction) table.getActionNN(\"create\");\r\n    createAction.withHandler(actionPerformedEvent -> {\r\n        T entity = getBeanLocator().get(Metadata.class).create(getEntityClass());\r\n        T trackedEntity = getScreenData().getDataContext().merge(entity);\r\n        fireEvent(StandardEditor.InitEntityEvent.class, new StandardEditor.InitEntityEvent(this, trackedEntity));\r\n        getEditContainer().setItem(trackedEntity);\r\n        refreshOptionsForLookupFields();\r\n        enableEditControls(true);\r\n        table.setSelected(Collections.emptyList());\r\n    });\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.exception.AbstractExceptionHandler.canHandle",
	"Comment": "should be implemented in subclasses if the exception class name is not enough to determine the ability tohandle the exception.",
	"Method": "boolean canHandle(String className,String message,Throwable throwable){\r\n    return true;\r\n}"
}, {
	"Path": "com.haulmont.bali.db.DbUtils.rollbackAndClose",
	"Comment": "performs a rollback on the connection then closes it,avoid closing if null.",
	"Method": "void rollbackAndClose(Connection conn){\r\n    if (conn != null) {\r\n        try {\r\n            conn.rollback();\r\n        } finally {\r\n            conn.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.cronutils.mapper.CronMapper.buildMappings",
	"Comment": "builds functions that map the fields from source crondefinition to target.",
	"Method": "void buildMappings(CronDefinition from,CronDefinition to){\r\n    final Map<CronFieldName, FieldDefinition> sourceFieldDefinitions = getFieldDefinitions(from);\r\n    final Map<CronFieldName, FieldDefinition> destFieldDefinitions = getFieldDefinitions(to);\r\n    boolean startedDestMapping = false;\r\n    boolean startedSourceMapping = false;\r\n    for (final CronFieldName name : CronFieldName.values()) {\r\n        final FieldDefinition destinationFieldDefinition = destFieldDefinitions.get(name);\r\n        final FieldDefinition sourceFieldDefinition = sourceFieldDefinitions.get(name);\r\n        if (destinationFieldDefinition != null) {\r\n            startedDestMapping = true;\r\n        }\r\n        if (sourceFieldDefinition != null) {\r\n            startedSourceMapping = true;\r\n        }\r\n        if (startedDestMapping && destinationFieldDefinition == null) {\r\n            break;\r\n        }\r\n        if (!startedSourceMapping && destinationFieldDefinition != null) {\r\n            mappings.put(name, returnOnZeroExpression(name));\r\n        }\r\n        if (startedSourceMapping && sourceFieldDefinition == null && destinationFieldDefinition != null) {\r\n            mappings.put(name, returnAlwaysExpression(name));\r\n        }\r\n        if (sourceFieldDefinition == null || destinationFieldDefinition == null) {\r\n            continue;\r\n        }\r\n        if (CronFieldName.DAY_OF_WEEK.equals(name)) {\r\n            mappings.put(name, dayOfWeekMapping((DayOfWeekFieldDefinition) sourceFieldDefinition, (DayOfWeekFieldDefinition) destinationFieldDefinition));\r\n        } else if (CronFieldName.DAY_OF_MONTH.equals(name)) {\r\n            mappings.put(name, dayOfMonthMapping(sourceFieldDefinition, destinationFieldDefinition));\r\n        } else {\r\n            mappings.put(name, returnSameExpression());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.screen.MasterDetailScreen.discardChanges",
	"Comment": "method invoked when clicking the cancel button, discards changes and disables controls for editing.",
	"Method": "void discardChanges(){\r\n    releaseLock();\r\n    getScreenData().getDataContext().evict(getEditContainer().getItem());\r\n    getEditContainer().setItem(null);\r\n    T selectedItem = getBrowseContainer().getItemOrNull();\r\n    if (selectedItem != null) {\r\n        View view = getEditContainer().getView();\r\n        boolean loadDynamicAttributes = getEditLoader().isLoadDynamicAttributes();\r\n        T reloadedItem = getBeanLocator().get(DataManager.class).reload(selectedItem, view, null, loadDynamicAttributes);\r\n        getBrowseContainer().setItem(reloadedItem);\r\n    }\r\n    disableEditControls();\r\n}"
}, {
	"Path": "com.vinaygaba.creditcardview.CreditCardView.getLogo",
	"Comment": "return the appropriate drawable resource based on the card type",
	"Method": "int getLogo(){\r\n    switch(mType) {\r\n        case VISA:\r\n            return R.drawable.visa;\r\n        case MASTERCARD:\r\n            return R.drawable.mastercard;\r\n        case AMERICAN_EXPRESS:\r\n            return R.drawable.amex;\r\n        case DISCOVER:\r\n            return R.drawable.discover;\r\n        case AUTO:\r\n            return findCardType();\r\n        default:\r\n            throw new UnsupportedOperationException(\"CardType: \" + mType + \"  is not supported\" + \". Use `CardType.*` or `CardType.AUTO` if unknown\");\r\n    }\r\n}"
}, {
	"Path": "com.oath.cyclops.matching.Case.or",
	"Comment": "return the test for this user case or for the other. there is no guaranteeone successful result will be produced.",
	"Method": "Case<T, R> or(Case<T, R> orCase){\r\n    return (t) -> {\r\n        Option<R> val = test(t);\r\n        return val.isPresent() ? val : orCase.test(t);\r\n    };\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.app.dynamicattributes.DynamicAttributesUtils.getMetaPropertyPath",
	"Comment": "get special meta property path object for dynamic attribute id",
	"Method": "MetaPropertyPath getMetaPropertyPath(MetaClass metaClass,CategoryAttribute attribute,MetaPropertyPath getMetaPropertyPath,MetaClass metaClass,String attributeCode,MetaPropertyPath getMetaPropertyPath,MetaClass metaClass,UUID attributeId){\r\n    return AppBeans.get(DynamicAttributesTools.NAME, DynamicAttributesTools.class).getMetaPropertyPath(metaClass, attributeId);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.MetadataTools.getPropertyEnclosingMetaClass",
	"Comment": "get metaclass that contains metaproperty for passed propertypath.resolves real metaclass for property in consideration of inherited entity classes and extended classes.",
	"Method": "MetaClass getPropertyEnclosingMetaClass(MetaPropertyPath propertyPath){\r\n    checkNotNullArgument(propertyPath, \"Property path should not be null\");\r\n    MetaProperty[] propertyChain = propertyPath.getMetaProperties();\r\n    if (propertyChain.length > 1) {\r\n        MetaProperty chainProperty = propertyChain[propertyChain.length - 2];\r\n        return chainProperty.getRange().asClass();\r\n    } else {\r\n        return propertyPath.getMetaClass();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.config.DeviceInfo.getBrowserMajorVersion",
	"Comment": "gets the major version of the browser the user is using.note that internet explorer in ie7 compatibility mode might return 8 insome cases even though it should return 7.",
	"Method": "int getBrowserMajorVersion(){\r\n    return browserMajorVersion;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.v7.ui.verticallayout.VDDVerticalLayout.getDragMode",
	"Comment": "returns the current drag mode which determines how the drag is visualized",
	"Method": "LayoutDragMode getDragMode(){\r\n    return ddMouseHandler.getDragMode();\r\n}"
}, {
	"Path": "com.googlecode.cqengine.query.parser.sql.support.SQLAntlrListener.getParsedQuery",
	"Comment": "can be called when parsing has finished, to retrieve the parsed query.",
	"Method": "Query<O> getParsedQuery(){\r\n    Collection<Query<O>> rootQuery = childQueries.get(null);\r\n    if (rootQuery == null) {\r\n        return QueryFactory.all(this.queryParser.getObjectType());\r\n    }\r\n    validateExpectedNumberOfChildQueries(1, rootQuery.size());\r\n    return rootQuery.iterator().next();\r\n}"
}, {
	"Path": "com.cronutils.model.field.constraint.FieldConstraintsBuilder.createConstraintsInstance",
	"Comment": "creates fieldconstraints instance based on previously built parameters.",
	"Method": "FieldConstraints createConstraintsInstance(){\r\n    return new FieldConstraints(stringMapping, intMapping, specialChars, startRange, endRange);\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.gui.components.DesktopComponentsHelper.isRecursivelyEnabled",
	"Comment": "determines whether component will be displayed on the screen.",
	"Method": "boolean isRecursivelyEnabled(java.awt.Component component){\r\n    if (component.getParent() instanceof JTabbedPane) {\r\n        JTabbedPane jTabbedPane = (JTabbedPane) component.getParent();\r\n        boolean tabVisible = false;\r\n        for (java.awt.Component childComponent : jTabbedPane.getComponents()) {\r\n            if (childComponent == component) {\r\n                tabVisible = true;\r\n                break;\r\n            }\r\n        }\r\n        return tabVisible && isRecursivelyEnabled(component.getParent());\r\n    }\r\n    return component.isEnabled() && (component.getParent() == null || isRecursivelyEnabled(component.getParent())) && isRecursivelyVisible(component);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.EntityCombinedScreen.cancel",
	"Comment": "method that is invoked by clicking cancel button, discards changes and disables controls for editing.",
	"Method": "void cancel(){\r\n    CollectionDatasource browseDs = getTable().getDatasource();\r\n    Datasource editDs = getFieldGroup().getDatasource();\r\n    Entity selectedItem = browseDs.getItem();\r\n    if (selectedItem != null) {\r\n        Entity reloadedItem = getDsContext().getDataSupplier().reload(selectedItem, editDs.getView(), null, editDs.getLoadDynamicAttributes());\r\n        browseDs.setItem(reloadedItem);\r\n    } else {\r\n        editDs.setItem(null);\r\n    }\r\n    releaseLock();\r\n    disableEditControls();\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.sys.vcl.SearchAutoCompleteSupport.convertToString",
	"Comment": "a convenience method to produce a string from the givencomboboxelement.",
	"Method": "String convertToString(Object comboBoxElement){\r\n    if (comboBoxElement == NOT_FOUND)\r\n        return \"NOT_FOUND\";\r\n    if (format != null)\r\n        return format.format(comboBoxElement);\r\n    return comboBoxElement == null ? \"\" : comboBoxElement.toString();\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.RemoveOperation.removeSelected",
	"Comment": "removes selected items from the list component with confirmation dialog. after confirmation removes items from db if the bound container is not nested.",
	"Method": "void removeSelected(ListComponent<E> target){\r\n    builder(target).withConfirmation(true).remove();\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.data.impl.CollectionDsListenersWrapper.getEventRouter",
	"Comment": "use eventrouter for listeners instead of fields with listeners list.",
	"Method": "EventRouter getEventRouter(){\r\n    if (eventRouter == null) {\r\n        eventRouter = new EventRouter();\r\n    }\r\n    return eventRouter;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.screen.StandardEditor.validateScreen",
	"Comment": "validates screen data. default implementation validates visible and enabled ui components. can be overridden in subclasses.",
	"Method": "ValidationErrors validateScreen(){\r\n    ValidationErrors validationErrors = validateUiComponents();\r\n    validateAdditionalRules(validationErrors);\r\n    return validationErrors;\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.sys.DisabledGlassPane.activate",
	"Comment": "make the glass pane visible and change the cursor to the wait cursora message can be displayed and it will be centered on the frame.",
	"Method": "void activate(String text){\r\n    if (text != null && text.length() > 0) {\r\n        message.setVisible(true);\r\n        message.setText(text);\r\n        message.setForeground(getForeground());\r\n    } else\r\n        message.setVisible(false);\r\n    setVisible(true);\r\n    requestFocusInWindow();\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.exception.AbstractUiExceptionHandler.canHandle",
	"Comment": "should be implemented in subclasses if the exception class name is not enough to determine the ability tohandle the exception.",
	"Method": "boolean canHandle(String className,String message,Throwable throwable){\r\n    return true;\r\n}"
}, {
	"Path": "com.cv4j.image.util.Tools.parseDouble",
	"Comment": "returns a double containg the value represented by thespecified string.",
	"Method": "double parseDouble(String s,double defaultValue,double parseDouble,String s){\r\n    return parseDouble(s, Double.NaN);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.CommitContext.getViews",
	"Comment": "enables defining a view for each committed entity. these views are used in merge operation to ensure allrequired attributes are loaded in returned instances.",
	"Method": "Map<Object, View> getViews(){\r\n    return views;\r\n}"
}, {
	"Path": "com.haulmont.cuba.security.global.UserSession.removeLocalAttribute",
	"Comment": "remove local attribute. local attribute is a named object bound to session. unlike normal user session attributes,local attributes are not passed between tiers and not replicated in cluster.",
	"Method": "void removeLocalAttribute(String name){\r\n    localAttributes.remove(name);\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.gui.components.DesktopComponentsHelper.isRecursivelyVisible",
	"Comment": "determines whether component will be displayed on the screen.",
	"Method": "boolean isRecursivelyVisible(java.awt.Component component){\r\n    if (component.getParent() instanceof JTabbedPane) {\r\n        JTabbedPane jTabbedPane = (JTabbedPane) component.getParent();\r\n        boolean tabVisible = false;\r\n        for (java.awt.Component childComponent : jTabbedPane.getComponents()) {\r\n            if (childComponent == component) {\r\n                tabVisible = true;\r\n                break;\r\n            }\r\n        }\r\n        return tabVisible && isRecursivelyVisible(component.getParent());\r\n    }\r\n    if (component.getParent() instanceof CollapsiblePanel) {\r\n        return isRecursivelyVisible(component.getParent());\r\n    }\r\n    return component.isVisible() && (component.getParent() == null || isRecursivelyVisible(component.getParent()));\r\n}"
}, {
	"Path": "com.cronutils.parser.CronParserField.createFieldTypeComparator",
	"Comment": "create a comparator that compares cronfield instances using cronfieldname value.",
	"Method": "Comparator<CronParserField> createFieldTypeComparator(){\r\n    return Comparator.comparingInt(o -> o.getField().getOrder());\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.DDAbsoluteLayout.setDropHandler",
	"Comment": "sets the drop handler which handles component drops on the layout",
	"Method": "void setDropHandler(DropHandler dropHandler){\r\n    DDUtil.verifyHandlerType(this, dropHandler);\r\n    if (this.dropHandler != dropHandler) {\r\n        this.dropHandler = dropHandler;\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.restapi.ParseUtils.tryParse",
	"Comment": "tries to parse a string value into some of the available datatypeswhen no datatype was specified.",
	"Method": "Object tryParse(String value){\r\n    try {\r\n        if (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"false\")) {\r\n            return parseByDatatype(value, Boolean.class);\r\n        }\r\n    } catch (ParseException ignored) {\r\n    }\r\n    try {\r\n        return parseByDatatype(value, UUID.class);\r\n    } catch (Exception ignored) {\r\n    }\r\n    try {\r\n        return parseByDatatype(value, Date.class);\r\n    } catch (ParseException ignored) {\r\n    }\r\n    try {\r\n        return parseByDatatype(value, Time.class);\r\n    } catch (ParseException ignored) {\r\n    }\r\n    try {\r\n        return parseByDatatype(value, java.sql.Date.class);\r\n    } catch (ParseException ignored) {\r\n    }\r\n    try {\r\n        return parseByDatatype(value, BigDecimal.class);\r\n    } catch (ParseException ignored) {\r\n    }\r\n    try {\r\n        return parseByDatatype(value, Double.class);\r\n    } catch (ParseException ignored) {\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.ui.horizontalsplitpanel.VDDHorizontalSplitPanel.updateDragDetails",
	"Comment": "updates the drop details while dragging. this is needed to ensure clientside criterias can validate the drop location.",
	"Method": "void updateDragDetails(VDragEvent event){\r\n    Element over = event.getElementOver();\r\n    if (over == null) {\r\n        return;\r\n    }\r\n    HorizontalDropLocation location = null;\r\n    Widget content = null;\r\n    if (firstContainer.isOrHasChild(over)) {\r\n        location = HorizontalDropLocation.LEFT;\r\n        content = Util.findWidget(firstContainer, null);\r\n    } else if (splitter.isOrHasChild(over)) {\r\n        location = HorizontalDropLocation.CENTER;\r\n        content = this;\r\n    } else if (secondContainer.isOrHasChild(over)) {\r\n        location = HorizontalDropLocation.RIGHT;\r\n        content = Util.findWidget(secondContainer, null);\r\n    }\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_HORIZONTAL_DROP_LOCATION, location);\r\n    if (content != null) {\r\n        event.getDropDetails().put(Constants.DROP_DETAIL_OVER_CLASS, content.getClass().getName());\r\n    } else {\r\n        event.getDropDetails().put(Constants.DROP_DETAIL_OVER_CLASS, this.getClass().getName());\r\n    }\r\n    MouseEventDetails details = MouseEventDetailsBuilder.buildMouseEventDetails(event.getCurrentGwtEvent(), getElement());\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_MOUSE_EVENT, details.serialize());\r\n}"
}, {
	"Path": "com.haulmont.chile.core.datatypes.Datatypes.get",
	"Comment": "get datatype instance by the corresponding java class. this method tries to find matching supertype too.",
	"Method": "Datatype get(String name,Datatype<T> get,Class<T> clazz){\r\n    return getDatatypeRegistry().get(clazz);\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.gui.components.WebAbstractTable.updateCompositionStylesTopPanelVisible",
	"Comment": "if buttons panel becomes hidden we need to set top panel height to 0",
	"Method": "void updateCompositionStylesTopPanelVisible(){\r\n    if (topPanel != null) {\r\n        boolean hasChildren = topPanel.getComponentCount() > 0;\r\n        boolean anyChildVisible = false;\r\n        for (Component childComponent : topPanel) {\r\n            if (childComponent.isVisible()) {\r\n                anyChildVisible = true;\r\n                break;\r\n            }\r\n        }\r\n        boolean topPanelVisible = hasChildren && anyChildVisible;\r\n        if (!topPanelVisible) {\r\n            componentComposition.removeStyleName(HAS_TOP_PANEL_STYLENAME);\r\n            internalStyles.remove(HAS_TOP_PANEL_STYLENAME);\r\n        } else {\r\n            componentComposition.addStyleName(HAS_TOP_PANEL_STYLENAME);\r\n            if (!internalStyles.contains(HAS_TOP_PANEL_STYLENAME)) {\r\n                internalStyles.add(HAS_TOP_PANEL_STYLENAME);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.executors.BackgroundTaskWrapper.getResult",
	"Comment": "if there is running task, block until its completion and return result.",
	"Method": "V getResult(){\r\n    if (taskHandler != null)\r\n        return taskHandler.getResult();\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "org.crsh.telnet.term.console.TermIOBuffer.push",
	"Comment": "pushone char in the buffer at the current cursor position. this operation ensures that the bufferis large enough and it may increase the buffer capacity when required. the cursor position is incrementedwhen a char is appended at the last position, otherwise the cursor position remains unchanged.",
	"Method": "boolean push(char c){\r\n    if (size >= buffer.length) {\r\n        char[] tmp = new char[buffer.length * 2 + 1];\r\n        System.arraycopy(buffer, 0, tmp, 0, buffer.length);\r\n        TermIOBuffer.this.buffer = tmp;\r\n    }\r\n    if (curAt == size) {\r\n        buffer[size++] = c;\r\n        curAt++;\r\n        return true;\r\n    } else {\r\n        for (int i = size - 1; i > curAt - 1; i--) {\r\n            buffer[i + 1] = buffer[i];\r\n        }\r\n        buffer[curAt] = c;\r\n        ++size;\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.cronutils.descriptor.CronDescriptor.getResourceBundle",
	"Comment": "gets the current resource bundle that is in use to allow custom reuse of text phrases.",
	"Method": "ResourceBundle getResourceBundle(){\r\n    return resourceBundle;\r\n}"
}, {
	"Path": "com.haulmont.cuba.security.global.UserSession.setLocalAttributeIfAbsent",
	"Comment": "set local attribute. local attribute is a named object bound to session. unlike normal user session attributes,local attributes are not passed between tiers and not replicated in cluster.",
	"Method": "Object setLocalAttributeIfAbsent(String name,Object value){\r\n    return localAttributes.putIfAbsent(name, value);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.TypedNativeQueryTest.testTypedNativeQueryByPersistingAnotherEntity",
	"Comment": "test that entity which is loaded by native typed query,is managed, by persisting another entity linked to it.",
	"Method": "void testTypedNativeQueryByPersistingAnotherEntity(){\r\n    Group group = new Group();\r\n    groupId = group.getId();\r\n    group.setName(\"Old Name\");\r\n    Transaction tx = cont.persistence().createTransaction();\r\n    try {\r\n        cont.persistence().getEntityManager().persist(group);\r\n        tx.commit();\r\n    } finally {\r\n        tx.end();\r\n    }\r\n    String nativeQuery = \"select ID, CREATE_TS, CREATED_BY, UPDATE_TS, UPDATED_BY, VERSION, NAME from SEC_GROUP where ID = ?\";\r\n    tx = cont.persistence().createTransaction();\r\n    Group g;\r\n    try {\r\n        EntityManager em = cont.persistence().getEntityManager();\r\n        TypedQuery<Group> q = em.createNativeQuery(nativeQuery, Group.class);\r\n        q.setParameter(1, group.getId().toString());\r\n        g = q.getResultList().get(0);\r\n        tx.commit();\r\n    } finally {\r\n        tx.end();\r\n    }\r\n    User user = new User();\r\n    userId = user.getId();\r\n    user.setLogin(\"typednativesqlquery\");\r\n    user.setGroup(g);\r\n    user.setName(\"Test\");\r\n    tx = cont.persistence().createTransaction();\r\n    try {\r\n        EntityManager em = cont.persistence().getEntityManager();\r\n        em.persist(user);\r\n        tx.commit();\r\n    } finally {\r\n        tx.end();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.app.importexport.EntityImportViewBuilder.mergeViews",
	"Comment": "recursively merges two views. the result view will contain all fields that are defined either in view1 or inview2.",
	"Method": "EntityImportView mergeViews(EntityImportView view1,EntityImportView view2){\r\n    if (view1 == null)\r\n        return view2;\r\n    if (view2 == null)\r\n        return view1;\r\n    EntityImportView mergedView = new EntityImportView(view1.getEntityClass());\r\n    for (EntityImportViewProperty p1 : view1.getProperties()) {\r\n        EntityImportViewProperty newProperty = new EntityImportViewProperty(p1.getName());\r\n        newProperty.setReferenceImportBehaviour(p1.getReferenceImportBehaviour());\r\n        newProperty.setCollectionImportPolicy(p1.getCollectionImportPolicy());\r\n        EntityImportViewProperty p2 = view2.getProperty(p1.getName());\r\n        if (p2 == null) {\r\n            newProperty.setView(p1.getView());\r\n        } else {\r\n            newProperty.setView(mergeViews(p1.getView(), p2.getView()));\r\n        }\r\n        mergedView.addProperty(newProperty);\r\n    }\r\n    for (EntityImportViewProperty p2 : view2.getProperties()) {\r\n        if (view1.getProperty(p2.getName()) == null) {\r\n            EntityImportViewProperty newProperty = new EntityImportViewProperty(p2.getName());\r\n            newProperty.setView(p2.getView());\r\n            newProperty.setReferenceImportBehaviour(p2.getReferenceImportBehaviour());\r\n            newProperty.setCollectionImportPolicy(p2.getCollectionImportPolicy());\r\n            mergedView.addProperty(newProperty);\r\n        }\r\n    }\r\n    return mergedView;\r\n}"
}, {
	"Path": "com.haulmont.restapi.common.RestControllerUtils.getView",
	"Comment": "finds a view for a given metaclass. throws a restapiexception if view not found",
	"Method": "View getView(MetaClass metaClass,String viewName){\r\n    try {\r\n        return viewRepository.getView(metaClass, viewName);\r\n    } catch (ViewNotFoundException e) {\r\n        throw new RestAPIException(\"View not found\", String.format(\"View %s for entity %s not found\", viewName, metaClass.getName()), HttpStatus.BAD_REQUEST);\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.chile.core.model.MetaPropertyPath.getMetaProperties",
	"Comment": "array of metaproperties between the originating metaclass and target metaproperty",
	"Method": "MetaProperty[] getMetaProperties(){\r\n    return metaProperties;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.DDFormLayout.setDropHandler",
	"Comment": "sets the current handler which handles dropped components on the layout.by setting a drop handler dropping components on the layout is enabled.by setting the drophandler to null dropping is disabled.",
	"Method": "void setDropHandler(DropHandler dropHandler){\r\n    DDUtil.verifyHandlerType(this, dropHandler);\r\n    if (this.dropHandler != dropHandler) {\r\n        this.dropHandler = dropHandler;\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.MetadataTools.isEmbedded",
	"Comment": "determine whether the given property denotes an embedded object.",
	"Method": "boolean isEmbedded(MetaProperty metaProperty){\r\n    Objects.requireNonNull(metaProperty, \"metaProperty is null\");\r\n    return Boolean.TRUE.equals(metaProperty.getAnnotations().get(EMBEDDED_ANN_NAME));\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.jmx.AnnotationMBeanInfoAssembler.getAttributeDescription",
	"Comment": "creates a description for the attribute corresponding to this propertydescriptor. attempts to create the description using metadata from eitherthe getter or setter attributes, otherwise uses the property name.",
	"Method": "String getAttributeDescription(PropertyDescriptor propertyDescriptor,String beanKey){\r\n    Method readMethod = propertyDescriptor.getReadMethod();\r\n    Method writeMethod = propertyDescriptor.getWriteMethod();\r\n    Method resolvedGetter = findJmxMethod(readMethod, beanKey);\r\n    Method resolvedSetter = findJmxMethod(writeMethod, beanKey);\r\n    ManagedAttribute getter = (resolvedGetter != null ? this.attributeSource.getManagedAttribute(resolvedGetter) : null);\r\n    ManagedAttribute setter = (resolvedSetter != null ? this.attributeSource.getManagedAttribute(resolvedSetter) : null);\r\n    if (getter != null && StringUtils.hasText(getter.getDescription())) {\r\n        return getter.getDescription();\r\n    } else if (setter != null && StringUtils.hasText(setter.getDescription())) {\r\n        return setter.getDescription();\r\n    }\r\n    ManagedMetric metric = (resolvedGetter != null ? this.attributeSource.getManagedMetric(resolvedGetter) : null);\r\n    if (metric != null && StringUtils.hasText(metric.getDescription())) {\r\n        return metric.getDescription();\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "com.haulmont.cuba.security.app.UserSessionLogBean.closeDeadSessionsOnStartup",
	"Comment": "set finishedts to all sessions that were interrupted by server reboot",
	"Method": "void closeDeadSessionsOnStartup(){\r\n    if (!globalConfig.getUserSessionLogEnabled()) {\r\n        return;\r\n    }\r\n    if (clusterManager.isMaster()) {\r\n        authentication.withSystemUser(() -> {\r\n            LoadContext<SessionLogEntry> lc = LoadContext.create(SessionLogEntry.class).setView(SessionLogEntry.DEFAULT_VIEW).setQuery(createQuery(\"select e from sec$SessionLogEntry e where e.finishedTs is null\"));\r\n            List<SessionLogEntry> sessionLogEntries = dataManager.loadList(lc);\r\n            CommitContext cc = new CommitContext();\r\n            Set<UUID> activeSessionsIds = userSessionsAPI.getUserSessionsStream().map(UserSession::getId).collect(Collectors.toSet());\r\n            for (SessionLogEntry entry : sessionLogEntries) {\r\n                if (activeSessionsIds.contains(entry.getSessionId())) {\r\n                    continue;\r\n                }\r\n                entry.setFinishedTs(timeSource.currentTimestamp());\r\n                entry.setLastAction(SessionAction.EXPIRATION);\r\n                cc.addInstanceToCommit(entry);\r\n            }\r\n            dataManager.commit(cc);\r\n            log.info(\"Dead session records have been closed\");\r\n            return null;\r\n        });\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.filter.ConditionsTree.removeCondition",
	"Comment": "removes a node with condition from the tree. do nothing if condition is not in the tree.",
	"Method": "void removeCondition(AbstractCondition condition){\r\n    Node<AbstractCondition> node = getNode(condition);\r\n    if (node != null) {\r\n        if (node.getParent() == null) {\r\n            getRootNodes().remove(node);\r\n        } else {\r\n            node.getParent().getChildren().remove(node);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.gui.components.DesktopAbstractTable.packRows",
	"Comment": "sets the height of each row into the preferred height of the tallest cell in that row.",
	"Method": "void packRows(){\r\n    if (!contentRepaintEnabled) {\r\n        return;\r\n    }\r\n    impl.setRowHeight(defaultRowHeight);\r\n    for (Column column : columnsOrder) {\r\n        if (column.isEditable()) {\r\n            impl.setRowHeight(defaultEditableRowHeight);\r\n            break;\r\n        }\r\n    }\r\n    if (allColumnsAreInline()) {\r\n        return;\r\n    }\r\n    int preferredRowHeight = -1;\r\n    boolean equalsRowHeight = true;\r\n    StopWatch sw = new Slf4JStopWatch(\"DAT packRows \" + id);\r\n    for (int r = 0; r < impl.getRowCount(); r++) {\r\n        int h = getPreferredRowHeight(r);\r\n        if (preferredRowHeight == -1) {\r\n            preferredRowHeight = h;\r\n        } else if (preferredRowHeight != h) {\r\n            equalsRowHeight = false;\r\n        }\r\n        if (impl.getRowHeight(r) != h) {\r\n            impl.setRowHeight(r, h);\r\n        }\r\n    }\r\n    if (equalsRowHeight && preferredRowHeight > 0) {\r\n        impl.setRowHeight(preferredRowHeight);\r\n    }\r\n    sw.stop();\r\n}"
}, {
	"Path": "com.haulmont.bali.db.QueryRunner.rethrow",
	"Comment": "throws a new exception with a more informative error message.",
	"Method": "void rethrow(SQLException cause,String sql,Object[] params){\r\n    StringBuilder msg = new StringBuilder(cause.getMessage());\r\n    msg.append(\" Query: \");\r\n    msg.append(sql);\r\n    msg.append(\" Parameters: \");\r\n    if (params == null) {\r\n        msg.append(\"[]\");\r\n    } else {\r\n        msg.append(Arrays.asList(params));\r\n    }\r\n    SQLException e = new SQLException(msg.toString(), cause.getSQLState(), cause.getErrorCode());\r\n    e.setNextException(cause);\r\n    throw e;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.remoting.RemotingServlet.checkConfiguration",
	"Comment": "check correctness of some configuration parameters and log the warning if necessary.",
	"Method": "void checkConfiguration(HttpServletRequest request){\r\n    if (!checkCompleted) {\r\n        GlobalConfig config = AppBeans.get(Configuration.class).getConfig(GlobalConfig.class);\r\n        if (config.getLogIncorrectWebAppPropertiesEnabled()) {\r\n            StringBuilder sb = new StringBuilder();\r\n            if (!request.getServerName().equals(config.getWebHostName())) {\r\n                sb.append(\"***** cuba.webHostName=\").append(config.getWebHostName()).append(\", actual=\").append(request.getServerName()).append(\"\\n\");\r\n            }\r\n            if (request.getServerPort() != Integer.parseInt(config.getWebPort())) {\r\n                sb.append(\"***** cuba.webPort=\").append(config.getWebPort()).append(\", actual=\").append(request.getServerPort()).append(\"\\n\");\r\n            }\r\n            String contextPath = request.getContextPath();\r\n            if (contextPath.startsWith(\"/\"))\r\n                contextPath = contextPath.substring(1);\r\n            if (!contextPath.equals(config.getWebContextName())) {\r\n                sb.append(\"***** cuba.webContextName=\").append(config.getWebContextName()).append(\", actual=\").append(contextPath).append(\"\\n\");\r\n            }\r\n            if (sb.length() > 0) {\r\n                sb.insert(0, \"\\n*****\\n\");\r\n                sb.append(\"*****\");\r\n                log.warn(\" Invalid configuration parameters that may cause problems:\" + sb.toString());\r\n            }\r\n        }\r\n        checkCompleted = true;\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.ui.gridlayout.VDDGridLayout.getDropHandler",
	"Comment": "returns the drop handler used when the user drops a component over thegrid layout",
	"Method": "VDDGridLayoutDropHandler getDropHandler(){\r\n    return dropHandler;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.exception.GenericExceptionHandler.handle",
	"Comment": "handle an exception. implementation class should either handle the exception and return true, or return falseto delegate execution to the next handler in the chain of responsibility.",
	"Method": "boolean handle(Throwable exception,WindowManager windowManager,boolean handle,Throwable exception,UiContext context){\r\n    return handle(exception, ((WindowManager) context.getScreens()));\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.app.filestorage.amazon.auth.AWS4SignerBase.getCanonicalizedResourcePath",
	"Comment": "returns the canonicalized resource path for the service endpoint.",
	"Method": "String getCanonicalizedResourcePath(URL endpoint){\r\n    if (endpoint == null) {\r\n        return \"/\";\r\n    }\r\n    String path = endpoint.getPath();\r\n    if (path == null || path.isEmpty()) {\r\n        return \"/\";\r\n    }\r\n    String encodedPath = HttpUtils.urlEncode(path, true);\r\n    if (encodedPath.startsWith(\"/\")) {\r\n        return encodedPath;\r\n    } else {\r\n        return \"/\".concat(encodedPath);\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.ComponentsHelper.fillErrorMessages",
	"Comment": "place component with error message to validation errors container.",
	"Method": "void fillErrorMessages(Validatable component,ValidationException e,ValidationErrors errors){\r\n    if (e instanceof ValidationException.HasRelatedComponent) {\r\n        errors.add(((ValidationException.HasRelatedComponent) e).getComponent(), e.getMessage());\r\n    } else if (e instanceof CompositeValidationException) {\r\n        for (CompositeValidationException.ViolationCause cause : ((CompositeValidationException) e).getCauses()) {\r\n            errors.add((Component) component, cause.getMessage());\r\n        }\r\n    } else if (e instanceof FieldGroup.FieldsValidationException) {\r\n        FieldGroup.FieldsValidationException fve = (FieldGroup.FieldsValidationException) e;\r\n        Map<Validatable, ValidationException> fields = fve.getProblemFields();\r\n        for (Map.Entry<Validatable, ValidationException> problem : fields.entrySet()) {\r\n            ValidationException exception = problem.getValue();\r\n            fillErrorMessages(problem.getKey(), exception, errors);\r\n        }\r\n    } else {\r\n        errors.add((Component) component, e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.MarginInfo.hasLeft",
	"Comment": "checks if this margininfo object has the left edge margin enabled.",
	"Method": "boolean hasLeft(){\r\n    return (bitMask & LEFT) == LEFT;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.query.parser.cqn.support.CQNAntlrListener.getParsedQuery",
	"Comment": "can be called when parsing has finished, to retrieve the parsed query.",
	"Method": "Query<O> getParsedQuery(){\r\n    Collection<Query<O>> rootQuery = childQueries.get(null);\r\n    validateExpectedNumberOfChildQueries(1, rootQuery.size());\r\n    return rootQuery.iterator().next();\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.screen.MasterDetailScreen.validateEditorForm",
	"Comment": "validates screen data. default implementation validates visible and enabled ui components. can be overridden in subclasses.",
	"Method": "ValidationErrors validateEditorForm(){\r\n    ScreenValidation screenValidation = getBeanLocator().get(ScreenValidation.NAME);\r\n    return screenValidation.validateUiComponents(getForm().getComponents());\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.AbstractWindow.formatMessage",
	"Comment": "get localized message from the message pack associated with this frame or window, and use it as a formatstring for parameters provided.",
	"Method": "String formatMessage(String key,Object params){\r\n    return messageBundle.formatMessage(key, params);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.persistence.OrmCacheSupport.evictMasterEntity",
	"Comment": "evicts an entity from cache if it has the given entity as an element of collection.",
	"Method": "void evictMasterEntity(BaseGenericIdEntity entity,EntityAttributeChanges changes){\r\n    MetaClass metaClass = metadata.getClassNN(entity.getClass());\r\n    for (MetaProperty property : metaClass.getProperties()) {\r\n        if (!property.getRange().isClass() || property.getRange().getCardinality().isMany())\r\n            continue;\r\n        MetaProperty inverseProp = property.getInverse();\r\n        if (inverseProp == null || !inverseProp.getRange().getCardinality().isMany())\r\n            continue;\r\n        if (metadata.getTools().isCacheable(property.getRange().asClass())) {\r\n            if (changes != null) {\r\n                for (String attributeName : changes.getOwnAttributes()) {\r\n                    if (property.getName().equals(attributeName)) {\r\n                        evictEntity(changes.getOldValue(attributeName));\r\n                        break;\r\n                    }\r\n                }\r\n            } else {\r\n                Object masterEntity = entity.getValue(property.getName());\r\n                evictEntity(masterEntity);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.crsh.shell.impl.command.CRaSH.getCommand",
	"Comment": "attempt to obtain a command instance. null is returned when such command does not exist.",
	"Method": "Command<?> getCommand(String name){\r\n    if (name == null) {\r\n        throw new NullPointerException(\"No null name accepted\");\r\n    }\r\n    for (int i = 0; i < resolvers.size(); i++) {\r\n        Command<?> command = resolvers.get(i).resolveCommand(name);\r\n        if (command != null) {\r\n            return command;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.DDCssLayout.setDropHandler",
	"Comment": "sets the drop handler which handles component drops on the layout",
	"Method": "void setDropHandler(DropHandler dropHandler){\r\n    DDUtil.verifyHandlerType(this, dropHandler);\r\n    if (this.dropHandler != dropHandler) {\r\n        this.dropHandler = dropHandler;\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.jqueryfileupload.CubaFileUploadWidget.getFileInputElement",
	"Comment": "due to jquery file upload behavior we need to get input element from dom",
	"Method": "Element getFileInputElement(){\r\n    return getElement().getElementsByTagName(\"input\").getItem(0);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.app.filestorage.amazon.auth.AWS4SignerForChunkedUpload.calculateChunkedContentLength",
	"Comment": "calculates the expanded payload size of our data when it is chunked",
	"Method": "long calculateChunkedContentLength(long originalLength,long chunkSize){\r\n    if (originalLength <= 0) {\r\n        throw new IllegalArgumentException(\"Nonnegative content length expected.\");\r\n    }\r\n    long maxSizeChunks = originalLength / chunkSize;\r\n    long remainingBytes = originalLength % chunkSize;\r\n    return maxSizeChunks * calculateChunkHeaderLength(chunkSize) + (remainingBytes > 0 ? calculateChunkHeaderLength(remainingBytes) : 0) + calculateChunkHeaderLength(0);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.ExtendedEntities.getOriginalClass",
	"Comment": "searches for an original entity for the provided extended entity.",
	"Method": "Class getOriginalClass(MetaClass extendedMetaClass){\r\n    return (Class) extendedMetaClass.getAnnotations().get(Extends.class.getName());\r\n}"
}, {
	"Path": "com.cv4j.core.pixels.PrincipalColorExtractor.reCalculateClusterCenters",
	"Comment": "using cluster color of each point to update cluster center color",
	"Method": "double[][] reCalculateClusterCenters(){\r\n    for (int i = 0; i < clusterCenterList.size(); i++) {\r\n        clusterCenterList.get(i).numOfPoints = 0;\r\n    }\r\n    double[] redSums = new double[numOfCluster];\r\n    double[] greenSum = new double[numOfCluster];\r\n    double[] blueSum = new double[numOfCluster];\r\n    for (int i = 0; i < pointList.size(); i++) {\r\n        int cIndex = (int) pointList.get(i).clusterIndex;\r\n        clusterCenterList.get(cIndex).numOfPoints++;\r\n        int tr = pointList.get(i).pixelColor.red;\r\n        int tg = pointList.get(i).pixelColor.green;\r\n        int tb = pointList.get(i).pixelColor.blue;\r\n        redSums[cIndex] += tr;\r\n        greenSum[cIndex] += tg;\r\n        blueSum[cIndex] += tb;\r\n    }\r\n    double[][] oldClusterCentersColors = new double[clusterCenterList.size()][3];\r\n    for (int i = 0; i < clusterCenterList.size(); i++) {\r\n        double sum = clusterCenterList.get(i).numOfPoints;\r\n        int cIndex = clusterCenterList.get(i).cIndex;\r\n        int red = (int) (greenSum[cIndex] / sum);\r\n        int green = (int) (greenSum[cIndex] / sum);\r\n        int blue = (int) (blueSum[cIndex] / sum);\r\n        clusterCenterList.get(i).color = new Scalar(red, green, blue);\r\n        oldClusterCentersColors[i][0] = red;\r\n        oldClusterCentersColors[i][0] = green;\r\n        oldClusterCentersColors[i][0] = blue;\r\n    }\r\n    return oldClusterCentersColors;\r\n}"
}, {
	"Path": "com.haulmont.bali.db.BeanProcessor.createBean",
	"Comment": "creates a new object and initializes its fields from the resultset.",
	"Method": "Object createBean(ResultSet rs,Class type,PropertyDescriptor[] props,int[] columnToProperty){\r\n    Object bean = this.newInstance(type);\r\n    for (int i = 1; i < columnToProperty.length; i++) {\r\n        if (columnToProperty[i] == PROPERTY_NOT_FOUND) {\r\n            continue;\r\n        }\r\n        PropertyDescriptor prop = props[columnToProperty[i]];\r\n        Class propType = prop.getPropertyType();\r\n        Object value = this.processColumn(rs, i, propType);\r\n        if (propType != null && value == null && propType.isPrimitive()) {\r\n            value = primitiveDefaults.get(propType);\r\n        }\r\n        this.callSetter(bean, prop, value);\r\n    }\r\n    return bean;\r\n}"
}, {
	"Path": "org.crsh.vfs.spi.AbstractFSDriver.child",
	"Comment": "a simple implementation that iterates over the children to return the one specifiedby the name argument. subclasses can override this method to providea more efficient implementation.",
	"Method": "H child(H handle,String name){\r\n    if (handle == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    if (name == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    for (H child : children(handle)) {\r\n        String childName = name(child);\r\n        if (childName.equals(name)) {\r\n            return child;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.resultset.iterator.MarkableIterator.reset",
	"Comment": "repositions this iterator to the position at the time the mark method was last called.if the mark method has not been called since the iterator was created, or the number of objects read from theiterator since mark was last called is larger than the argument to mark at that last call,then an illegalstateexception will be thrown.otherwise, the iterator is reset to a state such that all the objects read since the most recent call to markwill be resupplied to subsequent callers of the next method, followed by any objects that otherwise would havebeen the next input data as of the time of the call to reset.",
	"Method": "void reset(){\r\n    if (state == State.READ) {\r\n        throw new IllegalStateException(\"Iterator has not been marked or the mark has been invalidated\");\r\n    }\r\n    replayIterator = replayBuffer.iterator();\r\n    state = State.REPLAY;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.App.setRedirectHandler",
	"Comment": "internal.sets redirect handler that will be triggered on log in.",
	"Method": "void setRedirectHandler(RedirectHandler redirectHandler){\r\n    this.redirectHandler = redirectHandler;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.JsDate.toJs",
	"Comment": "converts a java date to a jsdate.if the date is null, the functionreturns null.",
	"Method": "JsDate toJs(Date java){\r\n    return java == null ? null : create(java.getTime());\r\n}"
}, {
	"Path": "com.oath.cyclops.async.adapters.Topic.disconnect",
	"Comment": "topic will maintain a queue for each subscribing streamif a stream is finished with a topic it is good practice to disconnect from the topicso messages will no longer be stored for that stream",
	"Method": "void disconnect(ReactiveSeq<T> stream){\r\n    Option<Queue<T>> o = streamToQueue.get(stream);\r\n    distributor.removeQueue(streamToQueue.getOrElse(stream, new Queue()));\r\n    this.streamToQueue = streamToQueue.remove(stream);\r\n    this.index--;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.functional.JoinTest.testSqlExistsMultiValuedNoForeignRestriction",
	"Comment": "find garages which can service cars which we do not have on file.",
	"Method": "void testSqlExistsMultiValuedNoForeignRestriction(){\r\n    Query<Garage> garagesQuery = not(existsIn(cars, Garage.BRANDS_SERVICED, Car.NAME));\r\n    Set<Garage> results = asSet(garages.retrieve(garagesQuery));\r\n    assertEquals(\"should have 1 result\", 1, results.size());\r\n    assertTrue(\"results should contain garage6\", results.contains(garage6));\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.details.AbsoluteLayoutTargetDetails.getRelativeLeft",
	"Comment": "the relative left coordinate in pixels measured from the containers leftedge",
	"Method": "int getRelativeLeft(){\r\n    return Integer.valueOf(getData(Constants.DROP_DETAIL_RELATIVE_LEFT).toString());\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.javacl.compiler.FileManagerImpl.getJavaFileForOutput",
	"Comment": "create a javafileimpl for an output class file and store it in the classloader.",
	"Method": "JavaFileObject getJavaFileForOutput(Location location,String qualifiedName,JavaFileObject.Kind kind,FileObject outputFile){\r\n    JavaFileObject file = new JavaFileObjectImpl(qualifiedName, kind);\r\n    classLoader.add(qualifiedName, file);\r\n    return file;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.functional.JoinTest.testSqlExistsNoForeignRestriction",
	"Comment": "find cars which are convertible or which have a sunroof,which can be serviced by any garage which we have on file.",
	"Method": "void testSqlExistsNoForeignRestriction(){\r\n    Query<Car> carsQuery = and(in(Car.FEATURES, \"sunroof\", \"convertible\"), existsIn(garages, Car.NAME, Garage.BRANDS_SERVICED));\r\n    Set<Car> results = asSet(cars.retrieve(carsQuery));\r\n    assertEquals(\"should have 3 results\", 3, results.size());\r\n    assertTrue(\"results should contain car1\", results.contains(car1));\r\n    assertTrue(\"results should contain car4\", results.contains(car4));\r\n    assertTrue(\"results should contain car5\", results.contains(car5));\r\n}"
}, {
	"Path": "com.googlecode.cqengine.resultset.connective.ResultSetUnionAll.contains",
	"Comment": "returns true if the given object is contained in any underlying resultsets.",
	"Method": "boolean contains(O object){\r\n    for (ResultSet<O> resultSet : this.resultSets) {\r\n        if (resultSet.contains(object)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.testutil.TestUtil.setOf",
	"Comment": "returns a set of the given vararg values. the set preserves the order of values given, but eliminates duplicates.",
	"Method": "Set<A> setOf(A values,Set<A> setOf,Iterable<A> values){\r\n    Set<A> result = new LinkedHashSet<A>();\r\n    for (A value : values) {\r\n        result.add(value);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.haulmont.bali.db.DbUtils.commitAndCloseQuietly",
	"Comment": "commits a connection then closes it, avoid closing if nulland hide any sqlexceptions that occur.",
	"Method": "void commitAndCloseQuietly(Connection conn){\r\n    try {\r\n        commitAndClose(conn);\r\n    } catch (SQLException e) {\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.CubaDefaultListableBeanFactory.resetBeanDefinition",
	"Comment": "reset all bean definition caches for the given bean,including the caches of beans that depends on it.",
	"Method": "void resetBeanDefinition(String beanName){\r\n    String[] dependentBeans = getDependentBeans(beanName);\r\n    super.resetBeanDefinition(beanName);\r\n    if (dependentBeans != null) {\r\n        for (String dependentBean : dependentBeans) {\r\n            resetBeanDefinition(dependentBean);\r\n            registerDependentBean(beanName, dependentBean);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.actions.EditAction.create",
	"Comment": "creates an action with default id, opening the edit screen in this tab.",
	"Method": "EditAction create(ListComponent target,EditAction create,ListComponent target,OpenType openType,EditAction create,ListComponent target,OpenType openType,String id){\r\n    return AppBeans.getPrototype(\"cuba_EditAction\", target, openType, id);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.entity.FileDescriptor.fromUrlParam",
	"Comment": "used by the framework to transfer file between application tiers.",
	"Method": "FileDescriptor fromUrlParam(String urlParam){\r\n    String[] parts = urlParam.split(\",\");\r\n    if (parts.length != 3 && parts.length != 4) {\r\n        throw new IllegalArgumentException(\"Invalid FileDescriptor format\");\r\n    }\r\n    Metadata metadata = AppBeans.get(Metadata.NAME);\r\n    FileDescriptor fd = metadata.create(FileDescriptor.class);\r\n    fd.setId(UuidProvider.fromString(parts[0]));\r\n    fd.setExtension(parts[1]);\r\n    fd.setCreateDate(new Date(Long.parseLong(parts[2])));\r\n    if (parts.length == 4) {\r\n        fd.setSize(Long.parseLong(parts[3]));\r\n    }\r\n    return fd;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.query.QueriesEqualsAndHashCodeTest.testQueryClass",
	"Comment": "parameterized test which validates a query class using equalsverifier.",
	"Method": "void testQueryClass(Class<? extends Query> queryClass){\r\n    EqualsVerifier.forClass(queryClass).withIgnoredFields(\"attributeIsSimple\", \"simpleAttribute\").withCachedHashCode(\"cachedHashCode\", \"calcHashCode\", null).suppress(Warning.NULL_FIELDS, Warning.STRICT_INHERITANCE, Warning.NO_EXAMPLE_FOR_CACHED_HASHCODE).verify();\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.filter.FilterDelegateImpl.saveInitialFilterState",
	"Comment": "saves initial filter state. it is used for indicating of filter modifications",
	"Method": "void saveInitialFilterState(){\r\n    initialFilterEntity = metadata.create(FilterEntity.class);\r\n    initialFilterEntity.setName(filterEntity.getName());\r\n    initialFilterEntity.setCode(filterEntity.getCode());\r\n    initialFilterEntity.setUser(filterEntity.getUser());\r\n    initialFilterEntity.setXml(filterEntity.getXml());\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.Window.deleteSettings",
	"Comment": "this method is called by the framework on reset to defaults action",
	"Method": "void deleteSettings(){\r\n    UiControllerUtils.deleteSettings(getFrameOwner());\r\n}"
}, {
	"Path": "com.haulmont.bali.db.BasicRowProcessor.toBean",
	"Comment": "convert a resultset row into a javabean.thisimplementation delegates to a beanprocessor instance.",
	"Method": "Object toBean(ResultSet rs,Class type){\r\n    return this.convert.toBean(rs, type);\r\n}"
}, {
	"Path": "com.cronutils.model.time.SingleExecutionTime.previousClosestMatch",
	"Comment": "if date is not match, will return previous closest match.if date is match, will return this date.",
	"Method": "ZonedDateTime previousClosestMatch(ZonedDateTime date){\r\n    ExecutionTimeResult result = new ExecutionTimeResult(date, false);\r\n    for (int i = 0; i < MAX_ITERATIONS; i++) {\r\n        result = potentialPreviousClosestMatch(result.getTime());\r\n        if (result.isMatch()) {\r\n            return result.getTime();\r\n        }\r\n    }\r\n    throw new NoSuchValueException();\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.AbstractWindow.saveSettings",
	"Comment": "this method is called when the screen is closed to save the screen settings to the database.",
	"Method": "void saveSettings(){\r\n    super.saveSettings();\r\n}"
}, {
	"Path": "org.crsh.util.Utils.findLongestCommonPrefix",
	"Comment": "find the longest possible common prefix of the provided char sequence.",
	"Method": "String findLongestCommonPrefix(CharSequence seqs,String findLongestCommonPrefix,Iterable<? extends CharSequence> seqs){\r\n    String common = \"\";\r\n    out: while (true) {\r\n        String candidate = null;\r\n        for (CharSequence s : seqs) {\r\n            if (common.length() + 1 > s.length()) {\r\n                break out;\r\n            } else {\r\n                if (candidate == null) {\r\n                    candidate = s.subSequence(0, common.length() + 1).toString();\r\n                } else if (s.subSequence(0, common.length() + 1).toString().equals(candidate)) {\r\n                } else {\r\n                    break out;\r\n                }\r\n            }\r\n        }\r\n        if (candidate == null) {\r\n            break;\r\n        } else {\r\n            common = candidate;\r\n        }\r\n    }\r\n    return common;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.ExtendedEntities.getEffectiveClass",
	"Comment": "searches for an extended entity and returns it if found, otherwise returns the original entity.",
	"Method": "Class getEffectiveClass(MetaClass originalMetaClass,Class getEffectiveClass,Class originalClass,Class getEffectiveClass,String entityName){\r\n    return getEffectiveClass(metadata.getSession().getClassNN(entityName));\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.sys.vcl.SearchAutoCompleteSupport.findAutoCompleteTerm",
	"Comment": "performs a linear scan of all items, regardless of the filtering stateof the comboboxmodel, to locate the autocomplete term. if an exactmatch of the given value can be found, then the item isreturned. if an exact match cannot be found, the first term thatstarts with the given value is returned.if no exact or partial match can be located, null isreturned.",
	"Method": "Object findAutoCompleteTerm(String value){\r\n    final boolean prefixIsEmpty = \"\".equals(value);\r\n    final Matcher<String> valueMatcher = new TextMatcher<String>(new SearchTerm[] { new SearchTerm(value) }, GlazedLists.toStringTextFilterator(), TextMatcherEditor.STARTS_WITH, getTextMatchingStrategy());\r\n    Object partialMatchItem = NOT_FOUND;\r\n    for (int i = 0, n = allItemsUnfiltered.size(); i < n; i++) {\r\n        final E item = allItemsUnfiltered.get(i);\r\n        final String itemString = convertToString(item);\r\n        if (value.equals(itemString))\r\n            return item;\r\n        if (partialMatchItem == NOT_FOUND) {\r\n            if (prefixIsEmpty ? \"\".equals(itemString) : valueMatcher.matches(itemString))\r\n                partialMatchItem = item;\r\n        }\r\n    }\r\n    return partialMatchItem;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.ui.verticalsplitpanel.VDDVerticalSplitPanel.updateDragDetails",
	"Comment": "updates the drop details while dragging. this is needed to ensure clientside criterias can validate the drop location.",
	"Method": "void updateDragDetails(VDragEvent event){\r\n    Element over = event.getElementOver();\r\n    VerticalDropLocation location = null;\r\n    Widget content = null;\r\n    if (firstContainer.isOrHasChild(over)) {\r\n        location = VerticalDropLocation.TOP;\r\n        content = Util.findWidget(firstContainer, null);\r\n    } else if (splitter.isOrHasChild(over)) {\r\n        location = VerticalDropLocation.MIDDLE;\r\n        content = this;\r\n    } else if (secondContainer.isOrHasChild(over)) {\r\n        location = VerticalDropLocation.BOTTOM;\r\n        content = Util.findWidget(secondContainer, null);\r\n    }\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_VERTICAL_DROP_LOCATION, location);\r\n    if (content != null) {\r\n        event.getDropDetails().put(Constants.DROP_DETAIL_OVER_CLASS, content.getClass().getName());\r\n    } else {\r\n        event.getDropDetails().put(Constants.DROP_DETAIL_OVER_CLASS, this.getClass().getName());\r\n    }\r\n    MouseEventDetails details = MouseEventDetailsBuilder.buildMouseEventDetails(event.getCurrentGwtEvent(), getElement());\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_MOUSE_EVENT, details.serialize());\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.screen.MasterDetailScreen.saveChanges",
	"Comment": "method invoked when clicking on the ok button after editing an existing or creating a new record.",
	"Method": "void saveChanges(){\r\n    if (!editing)\r\n        return;\r\n    ValidationErrors validationErrors = validateEditorForm();\r\n    if (!validationErrors.isEmpty()) {\r\n        ScreenValidation screenValidation = getBeanLocator().get(ScreenValidation.class);\r\n        screenValidation.showValidationErrors(this, validationErrors);\r\n        return;\r\n    }\r\n    getScreenData().getDataContext().commit();\r\n    T editedItem = getEditContainer().getItem();\r\n    if (creating) {\r\n        getBrowseContainer().getMutableItems().add(0, editedItem);\r\n    } else {\r\n        getBrowseContainer().replaceItem(editedItem);\r\n    }\r\n    getTable().setSelected(editedItem);\r\n    releaseLock();\r\n    disableEditControls();\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.screen.ScreenValidation.showValidationErrors",
	"Comment": "show validation alert with passed errors and first problem ui component.",
	"Method": "void showValidationErrors(FrameOwner origin,ValidationErrors errors){\r\n    checkNotNullArgument(origin);\r\n    checkNotNullArgument(errors);\r\n    if (errors.isEmpty()) {\r\n        return;\r\n    }\r\n    StringBuilder buffer = new StringBuilder();\r\n    for (ValidationErrors.Item error : errors.getAll()) {\r\n        buffer.append(error.description).append(\"\\n\");\r\n    }\r\n    ClientConfig clientConfig = configuration.getConfig(ClientConfig.class);\r\n    String validationNotificationType = clientConfig.getValidationNotificationType();\r\n    if (validationNotificationType.endsWith(\"_HTML\")) {\r\n        validationNotificationType = validationNotificationType.replace(\"_HTML\", \"\");\r\n    }\r\n    Notifications notifications = getScreenContext(origin).getNotifications();\r\n    notifications.create(NotificationType.valueOf(validationNotificationType)).withCaption(messages.getMainMessage(\"validationFail.caption\")).withDescription(buffer.toString()).show();\r\n    focusProblemComponent(errors);\r\n}"
}, {
	"Path": "com.cronutils.model.field.constraint.FieldConstraintsBuilder.forField",
	"Comment": "creates range constraints according to cronfieldname parameter.",
	"Method": "FieldConstraintsBuilder forField(CronFieldName field){\r\n    switch(field) {\r\n        case SECOND:\r\n        case MINUTE:\r\n            endRange = 59;\r\n            return this;\r\n        case HOUR:\r\n            endRange = 23;\r\n            return this;\r\n        case DAY_OF_WEEK:\r\n            stringMapping = daysOfWeekMapping();\r\n            endRange = 6;\r\n            return this;\r\n        case DAY_OF_MONTH:\r\n            startRange = 1;\r\n            endRange = 31;\r\n            return this;\r\n        case MONTH:\r\n            stringMapping = monthsMapping();\r\n            startRange = 1;\r\n            endRange = 12;\r\n            return this;\r\n        case DAY_OF_YEAR:\r\n            startRange = 1;\r\n            endRange = 366;\r\n            return this;\r\n        default:\r\n            return this;\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.jmx.AnnotationMBeanInfoAssembler.resolveStringDescriptor",
	"Comment": "locates the value of a descriptor based on values attachedto both the getter and setter methods. if both have valuessupplied then the value attached to the getter is preferred.the supplied default value is used to check to see if the valueassociated with the getter has changed from the default.",
	"Method": "String resolveStringDescriptor(String getter,String setter){\r\n    return (StringUtils.hasLength(getter) ? getter : setter);\r\n}"
}, {
	"Path": "com.haulmont.bali.db.BasicRowProcessor.toBeanList",
	"Comment": "convert a resultset into a list of javabeans.this implementation delegates to a beanprocessor instance.",
	"Method": "List toBeanList(ResultSet rs,Class type){\r\n    return this.convert.toBeanList(rs, type);\r\n}"
}, {
	"Path": "com.cronutils.descriptor.CronDescriptor.describe",
	"Comment": "provide a description of given cronfieldparseresult list.",
	"Method": "String describe(Cron cron){\r\n    Preconditions.checkNotNull(cron, \"Cron must not be null\");\r\n    final Map<CronFieldName, CronField> expressions = cron.retrieveFieldsAsMap();\r\n    final Map<CronFieldName, FieldDefinition> fieldDefinitions = cron.getCronDefinition().retrieveFieldDefinitionsAsMap();\r\n    return new StringBuilder().append(describeHHmmss(expressions)).append(\" \").append(describeDayOfMonth(expressions)).append(\" \").append(describeMonth(expressions)).append(\" \").append(describeDayOfWeek(expressions, fieldDefinitions)).append(\" \").append(describeYear(expressions)).toString().replaceAll(\"\\\\s+\", \" \").trim();\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.gui.components.WebTree.updateCompositionStylesTopPanelVisible",
	"Comment": "if buttons panel becomes hidden we need to set top panel height to 0",
	"Method": "void updateCompositionStylesTopPanelVisible(){\r\n    if (topPanel != null) {\r\n        boolean hasChildren = topPanel.getComponentCount() > 0;\r\n        boolean anyChildVisible = false;\r\n        for (com.vaadin.ui.Component childComponent : topPanel) {\r\n            if (childComponent.isVisible()) {\r\n                anyChildVisible = true;\r\n                break;\r\n            }\r\n        }\r\n        boolean topPanelVisible = hasChildren && anyChildVisible;\r\n        if (!topPanelVisible) {\r\n            componentComposition.removeStyleName(HAS_TOP_PANEL_STYLENAME);\r\n            internalStyles.remove(HAS_TOP_PANEL_STYLENAME);\r\n        } else {\r\n            componentComposition.addStyleName(HAS_TOP_PANEL_STYLENAME);\r\n            if (!internalStyles.contains(HAS_TOP_PANEL_STYLENAME)) {\r\n                internalStyles.add(HAS_TOP_PANEL_STYLENAME);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.crsh.console.Editor.getCursorBound",
	"Comment": "returns the right cursor bound depending on the current mode.",
	"Method": "int getCursorBound(){\r\n    if (console.getMode() == Mode.EMACS) {\r\n        return buffer.getSize();\r\n    } else {\r\n        return Math.max(0, buffer.getSize() - 1);\r\n    }\r\n}"
}, {
	"Path": "com.cv4j.image.util.Tools.rank",
	"Comment": "returns a sorted list of indices of the specified string array.",
	"Method": "int[] rank(double[] values,int[] rank,String[] data){\r\n    int n = data.length;\r\n    final Integer[] indexes = new Integer[n];\r\n    for (int i = 0; i < n; i++) indexes[i] = new Integer(i);\r\n    Arrays.sort(indexes, new Comparator<Integer>() {\r\n        public int compare(final Integer o1, final Integer o2) {\r\n            return data[o1].compareToIgnoreCase(data[o2]);\r\n        }\r\n    });\r\n    int[] indexes2 = new int[n];\r\n    for (int i = 0; i < n; i++) indexes2[i] = indexes[i].intValue();\r\n    return indexes2;\r\n}"
}, {
	"Path": "com.cv4j.image.util.Tools.rank",
	"Comment": "returns a sorted list of indices of the specified string array.",
	"Method": "int[] rank(double[] values,int[] rank,String[] data){\r\n    return data[o1].compareToIgnoreCase(data[o2]);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.ComponentsHelper.getComponents",
	"Comment": "returns the collection of components within the specified container and all of its children.",
	"Method": "Collection<Component> getComponents(ComponentContainer container){\r\n    Collection<Component> res = new ArrayList();\r\n    fillChildComponents(container, res);\r\n    if (res.isEmpty()) {\r\n        return Collections.emptyList();\r\n    }\r\n    return Collections.unmodifiableCollection(res);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.config.ConfigMethods.getInstance",
	"Comment": "get a configmethod implementation appropriate for handling aconfiguration interface method. internally, this uses a cache sothat it can operate very efficiently.",
	"Method": "ConfigMethod getInstance(Class<?> configInterface,Method method){\r\n    ConfigMethod configMethod = (ConfigMethod) configMethods.get(configInterface, method);\r\n    if (configMethod == null) {\r\n        configMethod = newInstance(configInterface, method);\r\n        configMethods.put(configInterface, method, configMethod);\r\n    }\r\n    return configMethod;\r\n}"
}, {
	"Path": "com.cronutils.model.field.definition.FieldDayOfWeekDefinitionBuilder.and",
	"Comment": "registers cronfield in parserdefinitionbuilder and returns its instance.",
	"Method": "CronDefinitionBuilder and(){\r\n    final boolean zeroInRange = constraints.createConstraintsInstance().isInRange(0);\r\n    cronDefinitionBuilder.register(new DayOfWeekFieldDefinition(fieldName, constraints.createConstraintsInstance(), optional, new WeekDay(mondayDoWValue, zeroInRange)));\r\n    return cronDefinitionBuilder;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.app.core.bulk.BulkEditorWindow.createView",
	"Comment": "creates a view, loading only necessary properties.referenced entities will be loaded with a minimal view.",
	"Method": "View createView(MetaClass meta){\r\n    View view = new View(meta.getJavaClass(), false);\r\n    for (MetaProperty metaProperty : meta.getProperties()) {\r\n        if (!managedFields.containsKey(metaProperty.getName()) && !managedEmbeddedProperties.contains(metaProperty.getName())) {\r\n            continue;\r\n        }\r\n        switch(metaProperty.getType()) {\r\n            case DATATYPE:\r\n            case ENUM:\r\n                view.addProperty(metaProperty.getName());\r\n                break;\r\n            case ASSOCIATION:\r\n            case COMPOSITION:\r\n                View propView;\r\n                if (!metadataTools.isEmbedded(metaProperty)) {\r\n                    propView = viewRepository.getView(metaProperty.getRange().asClass(), View.MINIMAL);\r\n                    view.addProperty(metaProperty.getName(), propView);\r\n                } else {\r\n                    propView = createEmbeddedView(metaProperty.getRange().asClass(), metaProperty.getName());\r\n                    view.addProperty(metaProperty.getName(), propView);\r\n                }\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"unknown property type\");\r\n        }\r\n    }\r\n    return view;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.app.core.entityinspector.EntityInspectorEditor.isRelatedToNonLocalProperty",
	"Comment": "determine whether the given metaproperty relates to at least one non local property",
	"Method": "boolean isRelatedToNonLocalProperty(MetaProperty metaProperty){\r\n    MetaClass metaClass = metaProperty.getDomain();\r\n    for (String relatedProperty : metadata.getTools().getRelatedProperties(metaProperty)) {\r\n        if (metaClass.getProperty(relatedProperty).getRange().isClass()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.jpql.QueryVariableContext.addEntityVariable",
	"Comment": "internal method to register entity variables found in query",
	"Method": "void addEntityVariable(String variableName,JpqlEntityModel entity){\r\n    if (variableName == null) {\r\n        throw new JPA2RecognitionException(\"No entity variable name passed\");\r\n    }\r\n    if (entity == null) {\r\n        throw new JPA2RecognitionException(\"No entity passed\");\r\n    }\r\n    if (entityVariableName2entity.containsKey(variableName))\r\n        throw new JPA2RecognitionException(String.format(\"The identification variable '%s' cannot be declared more than once\", variableName));\r\n    entityVariableName2entity.put(variableName, entity);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.singleapp.SingleAppCoreContextLoader.contextInitialized",
	"Comment": "here we create servlets and filters manually, to make sure the classes would be loaded using necessary classloader.",
	"Method": "void contextInitialized(ServletContextEvent servletContextEvent){\r\n    super.contextInitialized(servletContextEvent);\r\n    try {\r\n        ServletContext servletContext = servletContextEvent.getServletContext();\r\n        RemotingServlet remotingServlet = new RemotingServlet();\r\n        try {\r\n            remotingServlet.init(new CubaServletConfig(\"remoting\", servletContext));\r\n        } catch (ServletException e) {\r\n            throw new RuntimeException(\"An error occurred while initializing remoting servlet\", e);\r\n        }\r\n        ServletRegistration.Dynamic remotingReg = servletContext.addServlet(\"remoting\", remotingServlet);\r\n        remotingReg.addMapping(\"/remoting/*\");\r\n        remotingReg.setLoadOnStartup(0);\r\n        FilterRegistration.Dynamic filterReg = servletContext.addFilter(\"CoreSingleWarHttpFilter\", new SetClassLoaderFilter());\r\n        filterReg.addMappingForUrlPatterns(EnumSet.of(DispatcherType.REQUEST), false, \"/remoting/*\");\r\n    } catch (RuntimeException e) {\r\n        log.error(\"Error initializing core servlets\", e);\r\n        try {\r\n            ApplicationContext springContext = AppContext.getApplicationContext();\r\n            if (springContext != null) {\r\n                ((ConfigurableApplicationContext) springContext).close();\r\n            }\r\n        } catch (Exception e1) {\r\n            log.debug(\"Error closing application context: {}\", e1.toString());\r\n        }\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "com.cronutils.model.time.SingleExecutionTime.isMatch",
	"Comment": "provide feedback if a given date matches the cron expression.",
	"Method": "boolean isMatch(ZonedDateTime date,boolean isMatch){\r\n    final boolean isSecondGranularity = cronDefinition.containsFieldDefinition(SECOND);\r\n    if (isSecondGranularity) {\r\n        date = date.truncatedTo(SECONDS);\r\n    } else {\r\n        date = date.truncatedTo(ChronoUnit.MINUTES);\r\n    }\r\n    final Optional<ZonedDateTime> last = lastExecution(date);\r\n    if (last.isPresent()) {\r\n        final Optional<ZonedDateTime> next = nextExecution(last.get());\r\n        if (next.isPresent()) {\r\n            return next.get().equals(date);\r\n        } else {\r\n            boolean everythingInRange = false;\r\n            try {\r\n                everythingInRange = dateValuesInExpectedRanges(nextClosestMatch(date), date);\r\n            } catch (final NoSuchValueException ignored) {\r\n            }\r\n            try {\r\n                everythingInRange = dateValuesInExpectedRanges(previousClosestMatch(date), date);\r\n            } catch (final NoSuchValueException ignored) {\r\n            }\r\n            return everythingInRange;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.MarginInfo.hasAll",
	"Comment": "checks if this margininfo object has margins on all edges enabled.",
	"Method": "boolean hasAll(){\r\n    return (bitMask & ALL) == ALL;\r\n}"
}, {
	"Path": "com.cronutils.model.field.definition.FieldSpecialCharsDefinitionBuilder.withIntMapping",
	"Comment": "defines mapping between integer values with equivalent meaning.",
	"Method": "FieldSpecialCharsDefinitionBuilder withIntMapping(int source,int dest){\r\n    super.withIntMapping(source, dest);\r\n    return this;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.xml.DeclarativeColumnGenerator.findGeneratorMethod",
	"Comment": "find method with one parameter of type extends entity and result extends component",
	"Method": "Method findGeneratorMethod(Class cls,String methodName){\r\n    Method exactMethod = MethodUtils.getAccessibleMethod(cls, methodName, Entity.class);\r\n    if (exactMethod != null) {\r\n        return exactMethod;\r\n    }\r\n    Method[] methods = cls.getMethods();\r\n    for (Method availableMethod : methods) {\r\n        if (availableMethod.getName().equals(methodName)) {\r\n            if (availableMethod.getParameterCount() == 1 && Component.class.isAssignableFrom(availableMethod.getReturnType())) {\r\n                if (Entity.class.isAssignableFrom(availableMethod.getParameterTypes()[0])) {\r\n                    return MethodUtils.getAccessibleMethod(availableMethod);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.cronutils.mapper.ConstantsMapper.weekDayMapping",
	"Comment": "performs weekday mapping between two weekday definitions.",
	"Method": "int weekDayMapping(WeekDay source,WeekDay target,int weekday){\r\n    return source.mapTo(weekday, target);\r\n}"
}, {
	"Path": "com.googlecode.cqengine.resultset.connective.ResultSetIntersection.contains",
	"Comment": "returns true if the given object is contained in all underlying resultsets.",
	"Method": "boolean contains(O object){\r\n    if (this.resultSets.isEmpty()) {\r\n        return false;\r\n    }\r\n    for (ResultSet<O> resultSet : this.resultSets) {\r\n        if (!resultSet.contains(object)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.oath.cyclops.async.adapters.Queue.close",
	"Comment": "close this queuepoison pills are used to communicate closure to connected streamsa poison pill is added per connected stream to the queueif a blockingqueue is backing this async.queue it will block untilable to add to the queue.",
	"Method": "boolean close(){\r\n    this.open = false;\r\n    for (int i = 0; i < listeningStreams.get(); i++) {\r\n        try {\r\n            this.queue.offer((T) POISON_PILL);\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.ui.horizontalsplitpanel.VDDHorizontalSplitPanel.getDragMode",
	"Comment": "returns the current drag mode which determines how the drag is visualized",
	"Method": "LayoutDragMode getDragMode(){\r\n    return ddMouseHandler.getDragMode();\r\n}"
}, {
	"Path": "org.crsh.shell.impl.command.spi.Command.resolveInvoker",
	"Comment": "provides an invoker for the command line specified as a command line to parse.",
	"Method": "CommandInvoker<?, ?> resolveInvoker(String line){\r\n    return resolveCommand(line).getInvoker();\r\n}"
}, {
	"Path": "org.crsh.cli.descriptor.CommandDescriptor.resolveOption",
	"Comment": "find an command option by its name, this will look through the command hierarchy.",
	"Method": "OptionDescriptor resolveOption(String name){\r\n    OptionDescriptor option = getOption(name);\r\n    if (option == null) {\r\n        CommandDescriptor<T> owner = getOwner();\r\n        if (owner != null) {\r\n            option = owner.resolveOption(name);\r\n        }\r\n    }\r\n    return option;\r\n}"
}, {
	"Path": "com.cronutils.descriptor.TimeDescriptionStrategy.registerFunctions",
	"Comment": "registers functions that map timefields to a human readable description.",
	"Method": "void registerFunctions(){\r\n    descriptions.add(timeFields -> {\r\n        if (timeFields.hours instanceof Always && timeFields.minutes instanceof Always) {\r\n            if (timeFields.seconds instanceof Always) {\r\n                return String.format(EVERY_MINUTE_FORMAT, bundle.getString(EVERY), bundle.getString(SECOND));\r\n            }\r\n            if (timeFields.seconds instanceof On) {\r\n                if (TimeDescriptionStrategy.this.isDefault((On) timeFields.seconds)) {\r\n                    return String.format(EVERY_MINUTE_FORMAT, bundle.getString(EVERY), bundle.getString(MINUTE));\r\n                } else {\r\n                    return String.format(\"%s %s %s %s d\", bundle.getString(EVERY), bundle.getString(MINUTE), bundle.getString(\"at\"), bundle.getString(SECOND), ((On) timeFields.seconds).getTime().getValue());\r\n                }\r\n            }\r\n        }\r\n        return StringUtils.EMPTY;\r\n    });\r\n    descriptions.add(timeFields -> {\r\n        if (timeFields.hours instanceof Always && timeFields.minutes instanceof On && timeFields.seconds instanceof On) {\r\n            if (TimeDescriptionStrategy.this.isDefault((On) timeFields.seconds)) {\r\n                if (TimeDescriptionStrategy.this.isDefault((On) timeFields.minutes)) {\r\n                    return String.format(EVERY_MINUTE_FORMAT, bundle.getString(EVERY), bundle.getString(\"hour\"));\r\n                }\r\n                return String.format(\"%s %s %s %s %s\", bundle.getString(EVERY), bundle.getString(\"hour\"), bundle.getString(\"at\"), bundle.getString(MINUTE), ((On) timeFields.minutes).getTime().getValue());\r\n            } else {\r\n                return String.format(\"%s %s %s %s %s %s %s %s\", bundle.getString(EVERY), bundle.getString(\"hour\"), bundle.getString(\"at\"), bundle.getString(MINUTE), ((On) timeFields.minutes).getTime().getValue(), bundle.getString(\"and\"), bundle.getString(SECOND), ((On) timeFields.seconds).getTime().getValue());\r\n            }\r\n        }\r\n        return StringUtils.EMPTY;\r\n    });\r\n    descriptions.add(timeFields -> {\r\n        if (timeFields.hours instanceof On && timeFields.minutes instanceof On && timeFields.seconds instanceof Always) {\r\n            return String.format(\"%s %s %s d:d\", bundle.getString(EVERY), bundle.getString(SECOND), bundle.getString(\"at\"), ((On) hours).getTime().getValue(), ((On) minutes).getTime().getValue());\r\n        }\r\n        return StringUtils.EMPTY;\r\n    });\r\n    descriptions.add(timeFields -> {\r\n        if (timeFields.hours instanceof On && timeFields.minutes instanceof On && timeFields.seconds instanceof On) {\r\n            if (TimeDescriptionStrategy.this.isDefault((On) timeFields.seconds)) {\r\n                return String.format(\"%s d:d\", bundle.getString(\"at\"), ((On) hours).getTime().getValue(), ((On) minutes).getTime().getValue());\r\n            } else {\r\n                return String.format(\"%s d:d:d\", bundle.getString(\"at\"), ((On) hours).getTime().getValue(), ((On) minutes).getTime().getValue(), ((On) seconds).getTime().getValue());\r\n            }\r\n        }\r\n        return StringUtils.EMPTY;\r\n    });\r\n    descriptions.add(timeFields -> {\r\n        if (timeFields.hours instanceof On && timeFields.minutes instanceof Always && timeFields.seconds instanceof Always) {\r\n            return String.format(\"%s d:00\", bundle.getString(\"at\"), ((On) hours).getTime().getValue());\r\n        }\r\n        return StringUtils.EMPTY;\r\n    });\r\n    descriptions.add(timeFields -> {\r\n        if (timeFields.hours instanceof On && timeFields.minutes instanceof Between) {\r\n            if (timeFields.seconds instanceof On) {\r\n                return String.format(\"%s %s %s d:d %s d:d\", bundle.getString(EVERY), bundle.getString(MINUTE), bundle.getString(\"between\"), ((On) timeFields.hours).getTime().getValue(), ((Between) timeFields.minutes).getFrom().getValue(), bundle.getString(\"and\"), ((On) timeFields.hours).getTime().getValue(), ((Between) timeFields.minutes).getTo().getValue());\r\n            }\r\n            if (timeFields.seconds instanceof Always) {\r\n                return String.format(\"%s %s %s d:d %s d:d\", bundle.getString(EVERY), bundle.getString(SECOND), bundle.getString(\"between\"), ((On) timeFields.hours).getTime().getValue(), ((Between) timeFields.minutes).getFrom().getValue(), bundle.getString(\"and\"), ((On) timeFields.hours).getTime().getValue(), ((Between) timeFields.minutes).getTo().getValue());\r\n            }\r\n        }\r\n        return StringUtils.EMPTY;\r\n    });\r\n    descriptions.add(timeFields -> {\r\n        if (timeFields.hours instanceof Always && timeFields.minutes instanceof Every && timeFields.seconds instanceof On) {\r\n            final Every minute = (Every) timeFields.minutes;\r\n            String desc;\r\n            if (minute.getPeriod().getValue() == 1 && TimeDescriptionStrategy.this.isDefault((On) timeFields.seconds)) {\r\n                desc = String.format(EVERY_MINUTE_FORMAT, bundle.getString(EVERY), bundle.getString(MINUTE));\r\n            } else {\r\n                desc = String.format(\"%s %s %s \", bundle.getString(EVERY), minute.getPeriod().getValue(), bundle.getString(\"minutes\"));\r\n            }\r\n            if (minute.getExpression() instanceof Between) {\r\n                return StringUtils.EMPTY;\r\n            }\r\n            return desc;\r\n        }\r\n        return StringUtils.EMPTY;\r\n    });\r\n    descriptions.add(timeFields -> {\r\n        if (timeFields.hours instanceof Every && timeFields.minutes instanceof On && timeFields.seconds instanceof On) {\r\n            if (((On) timeFields.minutes).getTime().getValue() == 0 && ((On) timeFields.seconds).getTime().getValue() == 0) {\r\n                final Integer period = ((Every) timeFields.hours).getPeriod().getValue();\r\n                if (period == null || period == 1) {\r\n                    return String.format(EVERY_MINUTE_FORMAT, bundle.getString(EVERY), bundle.getString(\"hour\"));\r\n                }\r\n            }\r\n            final String result = String.format(\"%s %s %s %s %s %s \", bundle.getString(EVERY), ((Every) hours).getPeriod().getValue(), bundle.getString(\"hours\"), bundle.getString(\"at\"), bundle.getString(MINUTE), ((On) minutes).getTime().getValue());\r\n            if (TimeDescriptionStrategy.this.isDefault((On) timeFields.seconds)) {\r\n                return result;\r\n            } else {\r\n                return String.format(\"%s %s %s\", bundle.getString(\"and\"), bundle.getString(SECOND), ((On) seconds).getTime().getValue());\r\n            }\r\n        }\r\n        return StringUtils.EMPTY;\r\n    });\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.jmx.AnnotationMBeanInfoAssembler.findJmxMethod",
	"Comment": "try to find method exposed in bean jmx interface. return null if not found",
	"Method": "Method findJmxMethod(Method method,String beanKey){\r\n    if (method == null) {\r\n        return null;\r\n    }\r\n    Class ifc = findJmxInterface(beanKey, method.getDeclaringClass());\r\n    if (ifc == null) {\r\n        return null;\r\n    }\r\n    for (Method ifcMethod : ifc.getMethods()) {\r\n        if (ifcMethod.getName().equals(method.getName()) && Arrays.equals(ifcMethod.getParameterTypes(), method.getParameterTypes())) {\r\n            return ifcMethod;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "name.fraser.neil.plaintext.diff_match_patch.patch_make",
	"Comment": "compute a list of patches to turn text1 into text2.text2 is not provided, diffs are the delta between text1 and text2.",
	"Method": "LinkedList<Patch> patch_make(String text1,String text2,LinkedList<Patch> patch_make,LinkedList<Diff> diffs,LinkedList<Patch> patch_make,String text1,String text2,LinkedList<Diff> diffs,LinkedList<Patch> patch_make,String text1,LinkedList<Diff> diffs){\r\n    if (text1 == null || diffs == null) {\r\n        throw new IllegalArgumentException(\"Null inputs. (patch_make)\");\r\n    }\r\n    LinkedList<Patch> patches = new LinkedList<Patch>();\r\n    if (diffs.isEmpty()) {\r\n        return patches;\r\n    }\r\n    Patch patch = new Patch();\r\n    int char_count1 = 0;\r\n    int char_count2 = 0;\r\n    String prepatch_text = text1;\r\n    String postpatch_text = text1;\r\n    for (Diff aDiff : diffs) {\r\n        if (patch.diffs.isEmpty() && aDiff.operation != Operation.EQUAL) {\r\n            patch.start1 = char_count1;\r\n            patch.start2 = char_count2;\r\n        }\r\n        switch(aDiff.operation) {\r\n            case INSERT:\r\n                patch.diffs.add(aDiff);\r\n                patch.length2 += aDiff.text.length();\r\n                postpatch_text = postpatch_text.substring(0, char_count2) + aDiff.text + postpatch_text.substring(char_count2);\r\n                break;\r\n            case DELETE:\r\n                patch.length1 += aDiff.text.length();\r\n                patch.diffs.add(aDiff);\r\n                postpatch_text = postpatch_text.substring(0, char_count2) + postpatch_text.substring(char_count2 + aDiff.text.length());\r\n                break;\r\n            case EQUAL:\r\n                if (aDiff.text.length() <= 2 * Patch_Margin && !patch.diffs.isEmpty() && aDiff != diffs.getLast()) {\r\n                    patch.diffs.add(aDiff);\r\n                    patch.length1 += aDiff.text.length();\r\n                    patch.length2 += aDiff.text.length();\r\n                }\r\n                if (aDiff.text.length() >= 2 * Patch_Margin) {\r\n                    if (!patch.diffs.isEmpty()) {\r\n                        patch_addContext(patch, prepatch_text);\r\n                        patches.add(patch);\r\n                        patch = new Patch();\r\n                        prepatch_text = postpatch_text;\r\n                        char_count1 = char_count2;\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n        if (aDiff.operation != Operation.INSERT) {\r\n            char_count1 += aDiff.text.length();\r\n        }\r\n        if (aDiff.operation != Operation.DELETE) {\r\n            char_count2 += aDiff.text.length();\r\n        }\r\n    }\r\n    if (!patch.diffs.isEmpty()) {\r\n        patch_addContext(patch, prepatch_text);\r\n        patches.add(patch);\r\n    }\r\n    return patches;\r\n}"
}, {
	"Path": "org.crsh.shell.impl.command.spi.Command.resolveCommand",
	"Comment": "provides an invoker for the command line specified in a detyped manner.",
	"Method": "CommandMatch<?, ?> resolveCommand(String line,CommandMatch<?, ?> resolveCommand,Map<String, ?> options,String subordinate,Map<String, ?> subordinateOptions,List<?> arguments){\r\n    InvocationMatcher<T> matcher = getDescriptor().matcher();\r\n    InvocationMatch<T> match;\r\n    try {\r\n        if (options != null && options.size() > 0) {\r\n            for (Map.Entry<String, ?> option : options.entrySet()) {\r\n                matcher = matcher.option(option.getKey(), Collections.singletonList(option.getValue()));\r\n            }\r\n        }\r\n        if (subordinate != null && subordinate.length() > 0) {\r\n            matcher = matcher.subordinate(subordinate);\r\n            if (subordinateOptions != null && subordinateOptions.size() > 0) {\r\n                for (Map.Entry<String, ?> option : subordinateOptions.entrySet()) {\r\n                    matcher = matcher.option(option.getKey(), Collections.singletonList(option.getValue()));\r\n                }\r\n            }\r\n        }\r\n        match = matcher.arguments(arguments != null ? arguments : Collections.emptyList());\r\n    } catch (org.crsh.cli.impl.SyntaxException e) {\r\n        throw new CommandException(ErrorKind.EVALUATION, \"Could not resolve command \" + getDescriptor().getName(), e);\r\n    }\r\n    return resolve(match);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.DialogOptions.setCloseOnClickOutside",
	"Comment": "set closeonclickoutside to true if a window should be closed by click on outside window area.it works when a window has a modal mode.",
	"Method": "DialogOptions setCloseOnClickOutside(Boolean closeOnClickOutside){\r\n    this.closeOnClickOutside = closeOnClickOutside;\r\n    return this;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.DialogOptions.setMaximized",
	"Comment": "set maximized to true if a window should be maximized across the screen.",
	"Method": "DialogOptions setMaximized(Boolean maximized){\r\n    this.maximized = maximized;\r\n    return this;\r\n}"
}, {
	"Path": "org.crsh.plugin.PluginContext.refresh",
	"Comment": "refresh the fs system view. this is normally triggered by the periodic job but it can be manuallyinvoked to trigger explicit refreshes.",
	"Method": "void refresh(){\r\n    resourceManager.refresh();\r\n}"
}, {
	"Path": "com.haulmont.bali.util.ReflectionHelper.getParamTypes",
	"Comment": "constructs an array of argument types from an array of actual values. values can not contain nulls.",
	"Method": "Class[] getParamTypes(Object params){\r\n    List<Class> paramClasses = new ArrayList();\r\n    for (Object param : params) {\r\n        if (param == null)\r\n            throw new IllegalStateException(\"Null parameter\");\r\n        final Class aClass = param.getClass();\r\n        if (List.class.isAssignableFrom(aClass)) {\r\n            paramClasses.add(List.class);\r\n        } else if (Set.class.isAssignableFrom(aClass)) {\r\n            paramClasses.add(Set.class);\r\n        } else if (Map.class.isAssignableFrom(aClass)) {\r\n            paramClasses.add(Map.class);\r\n        } else if (Element.class.isAssignableFrom(aClass)) {\r\n            paramClasses.add(Element.class);\r\n        } else {\r\n            paramClasses.add(aClass);\r\n        }\r\n    }\r\n    return paramClasses.toArray(new Class<?>[paramClasses.size()]);\r\n}"
}, {
	"Path": "com.cronutils.model.field.expression.visitor.ValidationFieldExpressionVisitor.isInRange",
	"Comment": "check if given number is greater or equal to start range and minor or equal to end range.",
	"Method": "void isInRange(FieldValue<?> fieldValue){\r\n    if (fieldValue instanceof IntegerFieldValue) {\r\n        final int value = ((IntegerFieldValue) fieldValue).getValue();\r\n        if (!constraints.isInRange(value)) {\r\n            throw new IllegalArgumentException(String.format(OORANGE, value, constraints.getStartRange(), constraints.getEndRange()));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.ComponentContainer.getComponentNN",
	"Comment": "get component belonging to the whole components tree below this container.",
	"Method": "Component getComponentNN(String id){\r\n    Component component = getComponent(id);\r\n    if (component == null) {\r\n        throw new IllegalArgumentException(String.format(\"Not found component with id '%s'\", id));\r\n    }\r\n    return component;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.aceeditor.AceEditor.setCursorPosition",
	"Comment": "sets the cursor position to be pos characters from the beginning of the\ttext.",
	"Method": "void setCursorPosition(int pos){\r\n    setSelection(pos, pos);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.TabSheet.getTab",
	"Comment": "get selected tab. may be null if the tabsheet does not contain tabs at all.",
	"Method": "Tab getTab(Tab getTab,String name){\r\n    return getSelectedTab();\r\n}"
}, {
	"Path": "com.googlecode.cqengine.functional.JoinTest.testSqlExistsWithForeignRestriction",
	"Comment": "find cars which are convertible or which have a sunroof, which can be serviced in dublin.",
	"Method": "void testSqlExistsWithForeignRestriction(){\r\n    Query<Car> carsQuery = and(in(Car.FEATURES, \"sunroof\", \"convertible\"), existsIn(garages, Car.NAME, Garage.BRANDS_SERVICED, equal(Garage.LOCATION, \"Dublin\")));\r\n    Set<Car> results = asSet(cars.retrieve(carsQuery));\r\n    assertEquals(\"should have 2 results\", 2, results.size());\r\n    assertTrue(\"results should contain car1\", results.contains(car1));\r\n    assertTrue(\"results should contain car4\", results.contains(car4));\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.ComponentGenerationContext.setComponentClass",
	"Comment": "sets a component class for which a component is created, using fluent api method.",
	"Method": "ComponentGenerationContext setComponentClass(Class componentClass){\r\n    this.componentClass = componentClass;\r\n    return this;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.TimeZones.convert",
	"Comment": "not recommended for use. will be removed in a future versionconverts date between time zones.",
	"Method": "Date convert(Date srcDate,TimeZone srcTimeZone,TimeZone dstTimeZone){\r\n    if (srcDate == null)\r\n        return null;\r\n    Preconditions.checkNotNullArgument(srcTimeZone, \"srcTimeZone is null\");\r\n    Preconditions.checkNotNullArgument(dstTimeZone, \"dstTimeZone is null\");\r\n    int srcOffset = srcTimeZone.getOffset(srcDate.getTime());\r\n    int dstOffset = dstTimeZone.getOffset(srcDate.getTime());\r\n    return new Date(srcDate.getTime() - srcOffset + dstOffset);\r\n}"
}, {
	"Path": "org.crsh.plugin.ResourceManager.refresh",
	"Comment": "refresh the fs system view. this is normally triggered by the periodic job but it can be manuallyinvoked to trigger explicit refreshes.",
	"Method": "void refresh(){\r\n    try {\r\n        File commands = cmdFS.get(Path.get(\"/\"));\r\n        List<File> newDirs = new ArrayList<File>();\r\n        newDirs.add(commands);\r\n        for (File path : commands.children()) {\r\n            if (path.children().iterator().hasNext()) {\r\n                newDirs.add(path);\r\n            }\r\n        }\r\n        dirs = newDirs;\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.AbstractWindow.preClose",
	"Comment": "hook to be implemented in subclasses. called by the framework before closing the screen.",
	"Method": "boolean preClose(String actionId){\r\n    return true;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.exception.ExceptionHandlers.setDefaultHandler",
	"Comment": "set the default handler instead of initialized in constructor.",
	"Method": "void setDefaultHandler(ExceptionHandler defaultHandler){\r\n    this.defaultHandler = defaultHandler;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.details.AbsoluteLayoutTargetDetails.getAbsoluteTop",
	"Comment": "the absolute top coordinate in pixels measured from the windows top edge",
	"Method": "int getAbsoluteTop(){\r\n    return Integer.valueOf(getData(Constants.DROP_DETAIL_ABSOLUTE_TOP).toString());\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.PersistenceSecurity.restoreSecurityStateAndFilteredData",
	"Comment": "reads security token and restores security state and filtered data",
	"Method": "void restoreSecurityStateAndFilteredData(Entity entity){\r\n    restoreSecurityState(entity);\r\n    restoreFilteredData(entity);\r\n}"
}, {
	"Path": "com.cronutils.utils.descriptor.Issue343Test.expressions",
	"Comment": "cron expressions from spring docs class cronsequencegenerator",
	"Method": "Object[] expressions(){\r\n    return new Object[] { new Expr(\"0 0 * * * *\", \"every hour\"), new Expr(\"*/10 * * * * *\", \"every 10 seconds\"), new Expr(\"0 0 8-10 * * *\", \"every hour between 8 and 10\"), new Expr(\"0 0 6,19 * * *\", \"at 6 and 19 hours\"), new Expr(\"0 0/30 8-10 * * *\", \"every 30 minutes every hour between 8 and 10\"), new Expr(\"0 0 9-17 * * MON-FRI\", \"every hour between 9 and 17 every day between Monday and Friday\") };\r\n}"
}, {
	"Path": "com.cronutils.parser.FieldParser.stringToInt",
	"Comment": "maps string expression to integer. if no mapping is found, will try to parse string as integer",
	"Method": "int stringToInt(String exp){\r\n    final Integer value = fieldConstraints.getStringMappingValue(exp);\r\n    if (value != null) {\r\n        return value;\r\n    } else {\r\n        try {\r\n            return Integer.parseInt(exp);\r\n        } catch (final NumberFormatException e) {\r\n            final String invalidChars = new StringValidations(fieldConstraints).removeValidChars(exp);\r\n            throw new IllegalArgumentException(String.format(\"Invalid chars in expression! Expression: %s Invalid chars: %s\", exp, invalidChars));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.ComponentGenerationContext.setOptionsDatasource",
	"Comment": "sets a datasource that can be used to show options, using fluent api method.",
	"Method": "ComponentGenerationContext setOptionsDatasource(CollectionDatasource optionsDatasource){\r\n    this.optionsDatasource = optionsDatasource;\r\n    return this;\r\n}"
}, {
	"Path": "com.cronutils.model.definition.CronDefinitionBuilder.cron4j",
	"Comment": "creates crondefinition instance matching cron4j specification.",
	"Method": "CronDefinition cron4j(){\r\n    return CronDefinitionBuilder.defineCron().withMinutes().and().withHours().and().withDayOfMonth().supportsL().and().withMonth().and().withDayOfWeek().withValidRange(0, 6).withMondayDoWValue(1).and().enforceStrictRanges().matchDayOfWeekAndDayOfMonth().instance();\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.MetadataTools.isOwningSide",
	"Comment": "determine whether the given property is on the owning side of an association.",
	"Method": "boolean isOwningSide(MetaProperty metaProperty){\r\n    checkNotNullArgument(metaProperty, \"metaProperty is null\");\r\n    if (!metaProperty.getRange().isClass())\r\n        return false;\r\n    AnnotatedElement el = metaProperty.getAnnotatedElement();\r\n    for (Annotation annotation : el.getAnnotations()) {\r\n        if (annotation instanceof ManyToOne)\r\n            return true;\r\n        if (annotation instanceof OneToMany || annotation instanceof OneToOne)\r\n            return el.isAnnotationPresent(JoinColumn.class) || el.isAnnotationPresent(JoinTable.class);\r\n        if (annotation instanceof ManyToMany)\r\n            return el.isAnnotationPresent(JoinTable.class);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.foldable.Folds.atPercentile",
	"Comment": "value at percentile denoted by a double value between 0 and 100assumes the data is already sortedreturns an option, option.none is returned when an invalid percentile or empty dataset is used",
	"Method": "Option<T> atPercentile(double percentile){\r\n    List<T> list = stream().collect(Collectors.toList());\r\n    if (list.size() == 0)\r\n        return Option.none();\r\n    Long pos = new Double(Math.ceil((percentile / 100) * list.size())).longValue();\r\n    if (pos < 0 || pos > list.size()) {\r\n        return Option.none();\r\n    }\r\n    return Option.some(list.get(pos.intValue()));\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.app.core.bulk.BulkEditorWindow.createEmbeddedFields",
	"Comment": "recursively instantiates the embedded properties.e.g. embedded properties of the embedded property will also be instantiated.",
	"Method": "void createEmbeddedFields(MetaClass metaClass,Entity item,String fqnPrefix){\r\n    for (MetaProperty metaProperty : metaClass.getProperties()) {\r\n        String fqn = metaProperty.getName();\r\n        if (StringUtils.isNotEmpty(fqnPrefix)) {\r\n            fqn = fqnPrefix + \".\" + fqn;\r\n        }\r\n        if (managedEmbeddedProperties.contains(fqn) && metadataTools.isEmbedded(metaProperty)) {\r\n            MetaClass embeddedMetaClass = metaProperty.getRange().asClass();\r\n            Entity embedded = item.getValue(metaProperty.getName());\r\n            if (embedded == null) {\r\n                embedded = metadata.create(embeddedMetaClass);\r\n                item.setValue(metaProperty.getName(), embedded);\r\n            }\r\n            createEmbeddedFields(embeddedMetaClass, embedded, fqn);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.SecurityTokenManager.writeSecurityToken",
	"Comment": "encrypt filtered data and write the result to the security token",
	"Method": "void writeSecurityToken(Entity entity){\r\n    SecurityState securityState = getOrCreateSecurityState(entity);\r\n    if (securityState != null) {\r\n        JSONObject jsonObject = new JSONObject();\r\n        Multimap<String, Object> filtered = getFilteredData(securityState);\r\n        if (filtered != null) {\r\n            Set<Map.Entry<String, Collection<Object>>> entries = filtered.asMap().entrySet();\r\n            String[] filteredAttributes = new String[entries.size()];\r\n            int i = 0;\r\n            for (Map.Entry<String, Collection<Object>> entry : entries) {\r\n                jsonObject.put(entry.getKey(), entry.getValue());\r\n                filteredAttributes[i++] = entry.getKey();\r\n            }\r\n            setFilteredAttributes(securityState, filteredAttributes);\r\n        }\r\n        if (!securityState.getReadonlyAttributes().isEmpty()) {\r\n            jsonObject.put(READ_ONLY_ATTRIBUTES_KEY, securityState.getReadonlyAttributes());\r\n        }\r\n        if (!securityState.getHiddenAttributes().isEmpty()) {\r\n            jsonObject.put(HIDDEN_ATTRIBUTES_KEY, securityState.getHiddenAttributes());\r\n        }\r\n        if (!securityState.getRequiredAttributes().isEmpty()) {\r\n            jsonObject.put(REQUIRED_ATTRIBUTES_KEY, securityState.getRequiredAttributes());\r\n        }\r\n        MetaClass metaClass = entity.getMetaClass();\r\n        jsonObject.put(ENTITY_NAME_KEY, metaClass.getName());\r\n        if (!metadata.getTools().hasCompositePrimaryKey(metaClass)) {\r\n            jsonObject.put(ENTITY_ID_KEY, getEntityId(entity));\r\n        }\r\n        String json = jsonObject.toString();\r\n        byte[] encrypted;\r\n        Cipher cipher = getCipher(Cipher.ENCRYPT_MODE);\r\n        try {\r\n            encrypted = cipher.doFinal(json.getBytes(StandardCharsets.UTF_8));\r\n        } catch (Exception e) {\r\n            throw new RuntimeException(\"An error occurred while generating security token\", e);\r\n        }\r\n        setSecurityToken(securityState, encrypted);\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.config.ConfigMethods.newInstance",
	"Comment": "create a new configmethod implementation appropriate for handling aconfiguration interface method.",
	"Method": "ConfigMethod newInstance(Class<?> configInterface,Method method){\r\n    for (ConfigMethod.Factory factory : CONFIG_METHOD_FACTORIES) {\r\n        if (factory.canHandle(method)) {\r\n            return factory.newInstance(configInterface, method);\r\n        }\r\n    }\r\n    throw new RuntimeException(\"Invalid config interface method: \" + method);\r\n}"
}, {
	"Path": "com.haulmont.cuba.restapi.Authentication.end",
	"Comment": "end authenticated block of code, i.e. remove user session from the execution thread.",
	"Method": "void end(){\r\n    AppContext.setSecurityContext(null);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.filter.addcondition.ConditionDescriptorsDs.recursivelyFindSelectedItems",
	"Comment": "checks whether an item or any of its child passes filter and fills internal collection of filtered items",
	"Method": "boolean recursivelyFindSelectedItems(UUID itemId){\r\n    boolean passesFilter = passesFilter(itemId);\r\n    for (UUID childId : getChildren(itemId)) {\r\n        passesFilter |= recursivelyFindSelectedItems(childId);\r\n    }\r\n    if (passesFilter) {\r\n        filteredItemsIds.add(itemId);\r\n    }\r\n    return passesFilter;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.MarginInfo.hasTop",
	"Comment": "checks if this margininfo object has the top edge margin enabled.",
	"Method": "boolean hasTop(){\r\n    return (bitMask & TOP) == TOP;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.screen.MasterDetailScreen.initBrowseItemChangeListener",
	"Comment": "adds a listener that reloads the selected record and sets it to editct.",
	"Method": "void initBrowseItemChangeListener(){\r\n    getBrowseContainer().addItemChangeListener(e -> {\r\n        if (e.getItem() != null) {\r\n            InstanceLoader<T> editLoader = getEditLoader();\r\n            editLoader.setEntityId(e.getItem().getId());\r\n            editLoader.load();\r\n        } else {\r\n            if (!editing) {\r\n                getEditContainer().setItem(null);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.EntityManagerImpl.deepCopyIgnoringNulls",
	"Comment": "copies all property values from source to dest excluding null values.",
	"Method": "void deepCopyIgnoringNulls(Entity source,Entity dest,Set<Entity> visited){\r\n    if (visited.contains(source))\r\n        return;\r\n    visited.add(source);\r\n    MetadataTools metadataTools = metadata.getTools();\r\n    for (MetaProperty srcProperty : source.getMetaClass().getProperties()) {\r\n        String name = srcProperty.getName();\r\n        if (!PersistenceHelper.isLoaded(source, name)) {\r\n            continue;\r\n        }\r\n        if (srcProperty.isReadOnly()) {\r\n            continue;\r\n        }\r\n        Object value = source.getValue(name);\r\n        if (value == null) {\r\n            continue;\r\n        }\r\n        if (srcProperty.getRange().isClass() && !metadataTools.isEmbedded(srcProperty)) {\r\n            if (!metadataTools.isOwningSide(srcProperty))\r\n                continue;\r\n            Class refClass = srcProperty.getRange().asClass().getJavaClass();\r\n            if (!metadataTools.isPersistent(refClass))\r\n                continue;\r\n            if (srcProperty.getRange().getCardinality().isMany()) {\r\n                if (!metadataTools.isOwningSide(srcProperty))\r\n                    continue;\r\n                Collection<Entity> srcCollection = (Collection) value;\r\n                Collection<Entity> dstCollection = dest.getValue(name);\r\n                if (dstCollection == null)\r\n                    throw new RuntimeException(\"Collection is null: \" + srcProperty);\r\n                boolean equal = srcCollection.size() == dstCollection.size();\r\n                if (equal) {\r\n                    if (srcProperty.getRange().isOrdered()) {\r\n                        equal = Arrays.equals(srcCollection.toArray(), dstCollection.toArray());\r\n                    } else {\r\n                        equal = CollectionUtils.isEqualCollection(srcCollection, dstCollection);\r\n                    }\r\n                }\r\n                if (!equal) {\r\n                    dstCollection.clear();\r\n                    for (Entity srcRef : srcCollection) {\r\n                        Entity reloadedRef = findOrCreate(srcRef.getClass(), srcRef.getId());\r\n                        dstCollection.add(reloadedRef);\r\n                        deepCopyIgnoringNulls(srcRef, reloadedRef, visited);\r\n                    }\r\n                }\r\n            } else {\r\n                Entity srcRef = (Entity) value;\r\n                Entity destRef = dest.getValue(name);\r\n                if (srcRef.equals(destRef)) {\r\n                    deepCopyIgnoringNulls(srcRef, destRef, visited);\r\n                } else {\r\n                    Entity reloadedRef = findOrCreate(srcRef.getClass(), srcRef.getId());\r\n                    dest.setValue(name, reloadedRef);\r\n                    deepCopyIgnoringNulls(srcRef, reloadedRef, visited);\r\n                }\r\n            }\r\n        } else if (metadataTools.isEmbedded(srcProperty)) {\r\n            Entity srcRef = (Entity) value;\r\n            Entity destRef = dest.getValue(name);\r\n            if (destRef != null) {\r\n                deepCopyIgnoringNulls(srcRef, destRef, visited);\r\n            } else {\r\n                Entity newRef = (Entity) metadata.create(srcProperty.getRange().asClass().getJavaClass());\r\n                dest.setValue(name, newRef);\r\n                deepCopyIgnoringNulls(srcRef, newRef, visited);\r\n            }\r\n        } else {\r\n            dest.setValue(name, value);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.contextmenu.TableContextMenu.setAsContextMenuOf",
	"Comment": "sets this as a context menu of the component. you can set one menu to asmany components as you wish.",
	"Method": "void setAsContextMenuOf(ContextClickNotifier component){\r\n    if (component instanceof Table) {\r\n        useTableSpecificContextClickListener((Table) component);\r\n    }\r\n    super.setAsContextMenuOf(component);\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.v7.DDVerticalLayout.getDropHandler",
	"Comment": "returns the drop handler which handles drop events from droppingcomponents on the layout. returns null if dropping is disabled.",
	"Method": "DropHandler getDropHandler(){\r\n    return dropHandler;\r\n}"
}, {
	"Path": "com.haulmont.cuba.restapi.XMLConverter.encodeEntityInstance",
	"Comment": "encodes the closure of a persistent instance into a xml element.",
	"Method": "Element encodeEntityInstance(HashSet<Entity> visited,Entity entity,Element parent,boolean isRef,MetaClass metaClass,View view){\r\n    if (!readPermitted(metaClass))\r\n        return null;\r\n    if (parent == null)\r\n        throw new NullPointerException(\"No parent specified\");\r\n    Document doc = parent.getOwnerDocument();\r\n    if (doc == null)\r\n        throw new NullPointerException(\"No document specified\");\r\n    if (entity == null) {\r\n        return encodeRef(parent, entity);\r\n    }\r\n    isRef |= !visited.add(entity);\r\n    if (isRef) {\r\n        return encodeRef(parent, entity);\r\n    }\r\n    Element root = doc.createElement(ELEMENT_INSTANCE);\r\n    parent.appendChild(root);\r\n    root.setAttribute(ATTR_ID, ior(entity));\r\n    MetadataTools metadataTools = AppBeans.get(MetadataTools.NAME);\r\n    List<MetaProperty> properties = ConverterHelper.getOrderedProperties(metaClass);\r\n    for (MetaProperty property : properties) {\r\n        Element child;\r\n        if (!attrViewPermitted(metaClass, property.getName()))\r\n            continue;\r\n        if (!isPropertyIncluded(view, property, metadataTools)) {\r\n            continue;\r\n        }\r\n        Object value = entity.getValue(property.getName());\r\n        switch(property.getType()) {\r\n            case DATATYPE:\r\n                String nodeType;\r\n                if (property.equals(metadataTools.getPrimaryKeyProperty(metaClass)) && !property.getJavaType().equals(String.class)) {\r\n                    continue;\r\n                } else if (property.getAnnotatedElement().isAnnotationPresent(Version.class)) {\r\n                    nodeType = \"version\";\r\n                } else {\r\n                    nodeType = \"basic\";\r\n                }\r\n                child = doc.createElement(nodeType);\r\n                child.setAttribute(ATTR_NAME, property.getName());\r\n                if (value == null) {\r\n                    encodeNull(child);\r\n                } else {\r\n                    String str = property.getRange().asDatatype().format(value);\r\n                    encodeBasic(child, str, property.getJavaType());\r\n                }\r\n                break;\r\n            case ENUM:\r\n                child = doc.createElement(\"enum\");\r\n                child.setAttribute(ATTR_NAME, property.getName());\r\n                if (value == null) {\r\n                    encodeNull(child);\r\n                } else {\r\n                    String str = property.getRange().asEnumeration().format(value);\r\n                    encodeBasic(child, str, property.getJavaType());\r\n                }\r\n                break;\r\n            case COMPOSITION:\r\n            case ASSOCIATION:\r\n                {\r\n                    MetaClass meta = propertyMetaClass(property);\r\n                    if (!readPermitted(meta)) {\r\n                        child = null;\r\n                        break;\r\n                    }\r\n                    View propertyView = (view == null ? null : view.getProperty(property.getName()).getView());\r\n                    if (!property.getRange().getCardinality().isMany()) {\r\n                        boolean isEmbedded = property.getAnnotatedElement().isAnnotationPresent(Embedded.class);\r\n                        child = doc.createElement(isEmbedded ? \"embedded\" : property.getRange().getCardinality().name().replace(UNDERSCORE, DASH).toLowerCase());\r\n                        child.setAttribute(ATTR_NAME, property.getName());\r\n                        if (isEmbedded) {\r\n                            encodeEntityInstance(visited, (Entity) value, child, false, property.getRange().asClass(), propertyView);\r\n                        } else {\r\n                            encodeEntityInstance(visited, (Entity) value, child, false, property.getRange().asClass(), propertyView);\r\n                        }\r\n                    } else {\r\n                        child = doc.createElement(getCollectionReferenceTag(property));\r\n                        child.setAttribute(ATTR_NAME, property.getName());\r\n                        child.setAttribute(ATTR_MEMBER_TYPE, typeOfEntityProperty(property));\r\n                        if (value == null) {\r\n                            encodeNull(child);\r\n                            break;\r\n                        }\r\n                        Collection<?> members = (Collection<?>) value;\r\n                        for (Object o : members) {\r\n                            Element member = doc.createElement(ELEMENT_MEMBER);\r\n                            child.appendChild(member);\r\n                            if (o == null) {\r\n                                encodeNull(member);\r\n                            } else {\r\n                                encodeEntityInstance(visited, (Entity) o, member, true, property.getRange().asClass(), propertyView);\r\n                            }\r\n                        }\r\n                    }\r\n                    break;\r\n                }\r\n            default:\r\n                throw new IllegalStateException(\"Unknown property type\");\r\n        }\r\n        if (child != null) {\r\n            root.appendChild(child);\r\n        }\r\n    }\r\n    return root;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.JsDate.toJava",
	"Comment": "converts a jsdate to a java date.if the jsdate is null, the functionreturns null.",
	"Method": "Date toJava(JsDate js){\r\n    return js == null ? null : new Date(js.getTimeMs());\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.ui.formlayout.VDDFormLayout.updateDragDetails",
	"Comment": "updates the drop details while dragging. this is needed to ensure clientside criterias can validate the drop location.",
	"Method": "void updateDragDetails(Widget widget,VDragEvent event){\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_VERTICAL_DROP_LOCATION, getVerticalDropLocation(VDDFormLayout.getRowFromChildElement(widget.getElement(), VDDFormLayout.this.getElement()), event));\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_TO, \"-1\");\r\n    for (int i = 0; i < table.getRowCount(); i++) {\r\n        Widget w = table.getWidget(i, COLUMN_WIDGET);\r\n        if (widget.equals(w)) {\r\n            event.getDropDetails().put(Constants.DROP_DETAIL_TO, i);\r\n        }\r\n    }\r\n    String className = widget.getClass().getName();\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_OVER_CLASS, className);\r\n    MouseEventDetails details = MouseEventDetailsBuilder.buildMouseEventDetails(event.getCurrentGwtEvent(), getElement());\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_MOUSE_EVENT, details.serialize());\r\n}"
}, {
	"Path": "com.haulmont.cuba.security.global.UserSession.getAttribute",
	"Comment": "get user session attribute. attribute is a named serializable object bound to session.",
	"Method": "T getAttribute(String name){\r\n    if (\"userId\".equals(name))\r\n        return (T) getCurrentOrSubstitutedUser().getId();\r\n    if (\"userLogin\".equals(name))\r\n        return (T) getCurrentOrSubstitutedUser().getLoginLowerCase();\r\n    else\r\n        return (T) attributes.get(name);\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.gui.components.WebComponentsHelper.isComponentEnabled",
	"Comment": "tests if component enabled and visible and its container enabled.",
	"Method": "boolean isComponentEnabled(Component child){\r\n    if (child.getParent() instanceof TabSheet) {\r\n        TabSheet tabSheet = (TabSheet) child.getParent();\r\n        TabSheet.Tab tab = tabSheet.getTab(child);\r\n        if (!tab.isEnabled()) {\r\n            return false;\r\n        }\r\n    }\r\n    return child.isEnabled() && (child.getParent() == null || isComponentEnabled(child.getParent())) && isComponentVisible(child);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.DialogOptions.setResizable",
	"Comment": "set resizable option if a window will be opened as a dialog or change resizable option if the window is already opened as a dialog.",
	"Method": "DialogOptions setResizable(Boolean resizable){\r\n    this.resizable = resizable;\r\n    return this;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.app.events.AttributeChanges.isChanged",
	"Comment": "returns true if an attribute with the given name is changed.if the attribute is not changed or does not exist at all, returns false.",
	"Method": "boolean isChanged(String attributeName){\r\n    for (Change change : changes) {\r\n        if (change.name.equals(attributeName))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.EntityStates.isManaged",
	"Comment": "determines whether the instance is managed, i.e. attached to a persistence context.",
	"Method": "boolean isManaged(Object entity){\r\n    checkNotNullArgument(entity, \"entity is null\");\r\n    if (entity instanceof BaseGenericIdEntity) {\r\n        return BaseEntityInternalAccess.isManaged((BaseGenericIdEntity) entity);\r\n    } else {\r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"EntityStates.isManaged is called for unsupported type '{}'. Stacktrace:\\n{}\", entity.getClass().getSimpleName(), StackTrace.asString());\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "name.fraser.neil.plaintext.diff_match_patch.diff_compute",
	"Comment": "find the differences between two texts.assumes that the texts do nothave any common prefix or suffix.",
	"Method": "LinkedList<Diff> diff_compute(String text1,String text2,boolean checklines,long deadline){\r\n    LinkedList<Diff> diffs = new LinkedList<Diff>();\r\n    if (text1.length() == 0) {\r\n        diffs.add(new Diff(Operation.INSERT, text2));\r\n        return diffs;\r\n    }\r\n    if (text2.length() == 0) {\r\n        diffs.add(new Diff(Operation.DELETE, text1));\r\n        return diffs;\r\n    }\r\n    String longtext = text1.length() > text2.length() ? text1 : text2;\r\n    String shorttext = text1.length() > text2.length() ? text2 : text1;\r\n    int i = longtext.indexOf(shorttext);\r\n    if (i != -1) {\r\n        Operation op = (text1.length() > text2.length()) ? Operation.DELETE : Operation.INSERT;\r\n        diffs.add(new Diff(op, longtext.substring(0, i)));\r\n        diffs.add(new Diff(Operation.EQUAL, shorttext));\r\n        diffs.add(new Diff(op, longtext.substring(i + shorttext.length())));\r\n        return diffs;\r\n    }\r\n    if (shorttext.length() == 1) {\r\n        diffs.add(new Diff(Operation.DELETE, text1));\r\n        diffs.add(new Diff(Operation.INSERT, text2));\r\n        return diffs;\r\n    }\r\n    String[] hm = diff_halfMatch(text1, text2);\r\n    if (hm != null) {\r\n        String text1_a = hm[0];\r\n        String text1_b = hm[1];\r\n        String text2_a = hm[2];\r\n        String text2_b = hm[3];\r\n        String mid_common = hm[4];\r\n        LinkedList<Diff> diffs_a = diff_main(text1_a, text2_a, checklines, deadline);\r\n        LinkedList<Diff> diffs_b = diff_main(text1_b, text2_b, checklines, deadline);\r\n        diffs = diffs_a;\r\n        diffs.add(new Diff(Operation.EQUAL, mid_common));\r\n        diffs.addAll(diffs_b);\r\n        return diffs;\r\n    }\r\n    if (checklines && text1.length() > 100 && text2.length() > 100) {\r\n        return diff_lineMode(text1, text2, deadline);\r\n    }\r\n    return diff_bisect(text1, text2, deadline);\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.DDCssLayout.getDropHandler",
	"Comment": "gets the drop handler which handles component drops on the layout",
	"Method": "DropHandler getDropHandler(){\r\n    return dropHandler;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.events.sys.UiEventListenerMethodAdapter.getDetailedErrorMessage",
	"Comment": "add additional details such as the bean type and method signature tothe given error message.",
	"Method": "String getDetailedErrorMessage(Object bean,String message){\r\n    StringBuilder sb = new StringBuilder(message).append(\"\\n\");\r\n    sb.append(\"HandlerMethod details: \\n\");\r\n    sb.append(\"Bean [\").append(bean.getClass().getName()).append(\"]\\n\");\r\n    sb.append(\"Method [\").append(this.bridgedMethod.toGenericString()).append(\"]\\n\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.haulmont.restapi.common.RestControllerUtils.getMetaClass",
	"Comment": "finds metaclass by entityname. throws a restapiexception if metaclass not found",
	"Method": "MetaClass getMetaClass(String entityName){\r\n    MetaClass metaClass = metadata.getClass(entityName);\r\n    if (metaClass == null) {\r\n        throw new RestAPIException(\"MetaClass not found\", String.format(\"MetaClass %s not found\", entityName), HttpStatus.NOT_FOUND);\r\n    }\r\n    return metaClass;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.actions.RemoveAction.create",
	"Comment": "creates an action with default id. autocommit is set to true.",
	"Method": "RemoveAction create(ListComponent target,RemoveAction create,ListComponent target,boolean autocommit,RemoveAction create,ListComponent target,boolean autocommit,String id){\r\n    return AppBeans.getPrototype(\"cuba_RemoveAction\", target, autocommit, id);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.MessageTools.getDefaultRequiredMessage",
	"Comment": "get default required message for specified property of metaclass.",
	"Method": "String getDefaultRequiredMessage(MetaProperty metaProperty,String getDefaultRequiredMessage,MetaClass metaClass,String propertyName){\r\n    MetaPropertyPath propertyPath = metaClass.getPropertyPath(propertyName);\r\n    if (propertyPath != null) {\r\n        String notNullMessage = getNotNullMessage(propertyPath.getMetaProperty());\r\n        if (notNullMessage != null) {\r\n            return notNullMessage;\r\n        }\r\n    }\r\n    return messages.formatMessage(messages.getMainMessagePack(), \"validation.required.defaultMsg\", getPropertyCaption(metaClass, propertyName));\r\n}"
}, {
	"Path": "com.vinaygaba.creditcardview.CreditCardView.findCardType",
	"Comment": "returns the appropriate card type drawable resource based on the regex pattern of the cardnumber",
	"Method": "int findCardType(){\r\n    this.mType = VISA;\r\n    if (!TextUtils.isEmpty(mCardNumber)) {\r\n        final String cardNumber = mCardNumber.replaceAll(\"\\\\s+\", \"\");\r\n        if (Pattern.compile(PATTERN_MASTER_CARD).matcher(cardNumber).matches()) {\r\n            this.mType = MASTERCARD;\r\n        } else if (Pattern.compile(PATTERN_AMERICAN_EXPRESS).matcher(cardNumber).matches()) {\r\n            this.mType = AMERICAN_EXPRESS;\r\n        } else if (Pattern.compile(PATTERN_DISCOVER).matcher(cardNumber).matches()) {\r\n            this.mType = DISCOVER;\r\n        }\r\n    }\r\n    return getLogo();\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.EntityCombinedScreen.lockIfNeeded",
	"Comment": "pessimistic lock before start of editing, if it is configured for the entity.",
	"Method": "boolean lockIfNeeded(Entity entity){\r\n    MetaClass metaClass = getMetaClassForLocking(entity);\r\n    LockInfo lockInfo = AppBeans.get(LockService.class).lock(metaClass.getName(), entity.getId().toString());\r\n    if (lockInfo == null) {\r\n        justLocked = true;\r\n    } else if (!(lockInfo instanceof LockNotSupported)) {\r\n        showNotification(messages.getMainMessage(\"entityLocked.msg\"), String.format(messages.getMainMessage(\"entityLocked.desc\"), lockInfo.getUser().getLogin(), AppBeans.get(DatatypeFormatter.class).formatDateTime(lockInfo.getSince())), Frame.NotificationType.HUMANIZED);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.screen.MasterDetailScreen.initEditComponents",
	"Comment": "initializes edit controls, depending on if they should be enabled or disabled.",
	"Method": "void initEditComponents(boolean enabled){\r\n    TabSheet tabSheet = getTabSheet();\r\n    if (tabSheet != null) {\r\n        ComponentsHelper.walkComponents(tabSheet, (component, name) -> {\r\n            if (component instanceof FieldGroup) {\r\n                ((FieldGroup) component).setEditable(enabled);\r\n            } else if (component instanceof Table) {\r\n                ((Table) component).getActions().forEach(action -> action.setEnabled(enabled));\r\n            } else if (!(component instanceof ComponentContainer)) {\r\n                component.setEnabled(enabled);\r\n            }\r\n        });\r\n    } else {\r\n        getForm().setEditable(enabled);\r\n    }\r\n    getActionsPane().setVisible(enabled);\r\n    getLookupBox().setEnabled(!enabled);\r\n}"
}, {
	"Path": "name.fraser.neil.plaintext.diff_match_patch.diff_linesToChars",
	"Comment": "split two texts into a list of strings.reduce the texts to a string ofhashes where each unicode character represents one line.",
	"Method": "LinesToCharsResult diff_linesToChars(String text1,String text2){\r\n    List<String> lineArray = new ArrayList<String>();\r\n    Map<String, Integer> lineHash = new HashMap<String, Integer>();\r\n    lineArray.add(\"\");\r\n    String chars1 = diff_linesToCharsMunge(text1, lineArray, lineHash);\r\n    String chars2 = diff_linesToCharsMunge(text2, lineArray, lineHash);\r\n    return new LinesToCharsResult(chars1, chars2, lineArray);\r\n}"
}, {
	"Path": "org.crsh.shell.impl.command.spi.CommandInvoker.getKeyHandler",
	"Comment": "return the key handler or null if the invoker cannot handler key events.",
	"Method": "KeyHandler getKeyHandler(){\r\n    return null;\r\n}"
}, {
	"Path": "name.fraser.neil.plaintext.diff_match_patch.patch_fromText",
	"Comment": "parse a textual representation of patches and return a list of patchobjects.",
	"Method": "List<Patch> patch_fromText(String textline){\r\n    List<Patch> patches = new LinkedList<Patch>();\r\n    if (textline.length() == 0) {\r\n        return patches;\r\n    }\r\n    List<String> textList = Arrays.asList(textline.split(\"\\n\"));\r\n    LinkedList<String> text = new LinkedList<String>(textList);\r\n    Patch patch;\r\n    Pattern patchHeader = Pattern.compile(\"^@@ -(\\\\d+),?(\\\\d*) \\\\+(\\\\d+),?(\\\\d*) @@$\");\r\n    Matcher m;\r\n    char sign;\r\n    String line;\r\n    while (!text.isEmpty()) {\r\n        m = patchHeader.matcher(text.getFirst());\r\n        if (!m.matches()) {\r\n            throw new IllegalArgumentException(\"Invalid patch string: \" + text.getFirst());\r\n        }\r\n        patch = new Patch();\r\n        patches.add(patch);\r\n        patch.start1 = Integer.parseInt(m.group(1));\r\n        if (m.group(2).length() == 0) {\r\n            patch.start1--;\r\n            patch.length1 = 1;\r\n        } else if (m.group(2).equals(\"0\")) {\r\n            patch.length1 = 0;\r\n        } else {\r\n            patch.start1--;\r\n            patch.length1 = Integer.parseInt(m.group(2));\r\n        }\r\n        patch.start2 = Integer.parseInt(m.group(3));\r\n        if (m.group(4).length() == 0) {\r\n            patch.start2--;\r\n            patch.length2 = 1;\r\n        } else if (m.group(4).equals(\"0\")) {\r\n            patch.length2 = 0;\r\n        } else {\r\n            patch.start2--;\r\n            patch.length2 = Integer.parseInt(m.group(4));\r\n        }\r\n        text.removeFirst();\r\n        while (!text.isEmpty()) {\r\n            try {\r\n                sign = text.getFirst().charAt(0);\r\n            } catch (IndexOutOfBoundsException e) {\r\n                text.removeFirst();\r\n                continue;\r\n            }\r\n            line = text.getFirst().substring(1);\r\n            line = line.replace(\"+\", \"+\");\r\n            try {\r\n                line = URLDecoder.decode(line, \"UTF-8\");\r\n            } catch (UnsupportedEncodingException e) {\r\n                throw new Error(\"This system does not support UTF-8.\", e);\r\n            } catch (IllegalArgumentException e) {\r\n                throw new IllegalArgumentException(\"Illegal escape in patch_fromText: \" + line, e);\r\n            }\r\n            if (sign == '-') {\r\n                patch.diffs.add(new Diff(Operation.DELETE, line));\r\n            } else if (sign == '+') {\r\n                patch.diffs.add(new Diff(Operation.INSERT, line));\r\n            } else if (sign == ' ') {\r\n                patch.diffs.add(new Diff(Operation.EQUAL, line));\r\n            } else if (sign == '@') {\r\n                break;\r\n            } else {\r\n                throw new IllegalArgumentException(\"Invalid patch mode '\" + sign + \"' in: \" + line);\r\n            }\r\n            text.removeFirst();\r\n        }\r\n    }\r\n    return patches;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.details.AbsoluteLayoutTargetDetails.getAbsoluteLeft",
	"Comment": "the absolute left coordinate in pixels measured from the windows leftedge",
	"Method": "int getAbsoluteLeft(){\r\n    return Integer.valueOf(getData(Constants.DROP_DETAIL_ABSOLUTE_LEFT).toString());\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.ui.VDragDropUtil.createLayoutTransferableFromMouseDown",
	"Comment": "creates a transferable from a mouse down event. returns null if creationwas not successful.",
	"Method": "VTransferable createLayoutTransferableFromMouseDown(NativeEvent event,Widget root,Widget target){\r\n    if (target == null) {\r\n        VConsole.error(\"Could not find widget\");\r\n        return null;\r\n    }\r\n    VConsole.log(\"Creating transferable for root:\" + root.getElement() + \"\\t target:\" + target.getElement());\r\n    if (root instanceof VDDTabSheet) {\r\n        VDDTabSheet tabsheet = (VDDTabSheet) root;\r\n        TabCaption tab = WidgetUtil.findWidget(target.getElement(), TabCaption.class);\r\n        if (tab != null && tabsheet.getElement().isOrHasChild(tab.getElement())) {\r\n            return createTabsheetTransferableFromMouseDown(tabsheet, tab, event);\r\n        } else {\r\n            VConsole.error(\"Not on tab\");\r\n            return null;\r\n        }\r\n    }\r\n    if (root instanceof VDDAccordion) {\r\n        VDDAccordion accordion = (VDDAccordion) root;\r\n        StackItem tab = WidgetUtil.findWidget(target.getElement(), StackItem.class);\r\n        if (tab != null && accordion.getElement().isOrHasChild(tab.getElement())) {\r\n            return createAccordionTransferableFromMouseDown(accordion, tab, event);\r\n        } else {\r\n            VConsole.error(\"Not on tab\");\r\n            return null;\r\n        }\r\n    }\r\n    target = getTransferableWidget(target);\r\n    ComponentConnector widgetConnector = Util.findConnectorFor(target);\r\n    if (widgetConnector == null) {\r\n        VConsole.error(\"No connector found for \" + target);\r\n        return null;\r\n    }\r\n    ComponentConnector layoutConnector = (ComponentConnector) widgetConnector.getParent();\r\n    Widget layout = layoutConnector.getWidget();\r\n    while (layout != root && layout != null && layoutConnector != null) {\r\n        if (isDraggingEnabled(layoutConnector, target)) {\r\n            break;\r\n        }\r\n        target = layout;\r\n        widgetConnector = layoutConnector;\r\n        layoutConnector = (ComponentConnector) layoutConnector.getParent();\r\n        if (layoutConnector == null) {\r\n            break;\r\n        }\r\n        layout = layoutConnector.getWidget();\r\n    }\r\n    if (target == null) {\r\n        VConsole.error(\"Target was null\");\r\n        return null;\r\n    }\r\n    if (root == target) {\r\n        target.getElement().dispatchEvent(createMouseDownEvent(event));\r\n        return null;\r\n    }\r\n    if (layoutConnector == null) {\r\n        VConsole.error(\"No layout connector was found\");\r\n        return null;\r\n    }\r\n    return createTransferable(layoutConnector, widgetConnector, event);\r\n}"
}, {
	"Path": "com.haulmont.cuba.security.sys.UserSessionManager.createSession",
	"Comment": "create a new session from existing for another user and fill it with security data for that new user.must be called inside a transaction.",
	"Method": "UserSession createSession(User user,Locale locale,boolean system,UserSession createSession,UUID sessionId,User user,Locale locale,boolean system,UserSession createSession,UserSession src,User user){\r\n    List<Role> roles = new ArrayList();\r\n    for (UserRole userRole : user.getUserRoles()) {\r\n        if (userRole.getRole() != null) {\r\n            roles.add(userRole.getRole());\r\n        }\r\n    }\r\n    UserSession session = new UserSession(src, user, roles, src.getLocale());\r\n    compilePermissions(session, roles);\r\n    if (user.getGroup() == null)\r\n        throw new IllegalStateException(\"User is not in a Group\");\r\n    compileConstraints(session, user.getGroup());\r\n    compileSessionAttributes(session, user.getGroup());\r\n    return session;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.DialogOptions.setCloseable",
	"Comment": "set closeable option if a window will be opened as a dialog or change closeable option if the window is already opened as a dialog.",
	"Method": "DialogOptions setCloseable(Boolean closeable){\r\n    this.closeable = closeable;\r\n    return this;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.DDTabSheet.setDropHandler",
	"Comment": "sets the current handler which handles dropped components on the layout.by setting a drop handler dropping components on the layout is enabled.by setting the drophandler to null dropping is disabled.",
	"Method": "void setDropHandler(DropHandler dropHandler){\r\n    DDUtil.verifyHandlerType(this, dropHandler);\r\n    if (this.dropHandler != dropHandler) {\r\n        this.dropHandler = dropHandler;\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "org.crsh.plugin.WebPluginLifeCycle.getPluginContext",
	"Comment": "returns a plugin context associated with the servlet context or null if such context does not exist.",
	"Method": "PluginContext getPluginContext(String contextPath){\r\n    synchronized (lock) {\r\n        return contextMap.get(contextPath);\r\n    }\r\n}"
}, {
	"Path": "org.crsh.plugin.PropertyManager.setProperty",
	"Comment": "set a context property to a new value. if the provided value is null, then the property is removed.",
	"Method": "void setProperty(PropertyDescriptor<T> desc,T value){\r\n    if (desc == null) {\r\n        throw new NullPointerException(\"No null descriptor allowed\");\r\n    }\r\n    if (value == null) {\r\n        log.log(Level.FINE, \"Removing property \" + desc.name);\r\n        properties.remove(desc.getName());\r\n    } else {\r\n        Property<T> property = new Property<T>(desc, value);\r\n        log.log(Level.FINE, \"Setting property \" + desc.name + \" to value \" + property.getValue());\r\n        properties.put(desc.getName(), property);\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.AppBeans.get",
	"Comment": "return the bean instance that matches the given object type.if the provided bean class contains a public static field name, this name is used to look up thebean to improve performance.",
	"Method": "T get(Class<T> beanType,T get,String name,T get,String name,Class<T> beanType){\r\n    return getBeanLocator().get(name, beanType);\r\n}"
}, {
	"Path": "com.haulmont.cuba.security.global.UserSession.getAttributeNames",
	"Comment": "user session attribute names. attribute is a named serializable object bound to session.",
	"Method": "Collection<String> getAttributeNames(){\r\n    return new ArrayList(attributes.keySet());\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.MetadataTools.isPersistent",
	"Comment": "determine whether the given property is persistent, that is managed by orm.",
	"Method": "boolean isPersistent(MetaPropertyPath metaPropertyPath,boolean isPersistent,MetaProperty metaProperty,boolean isPersistent,MetaClass metaClass,MetaProperty metaProperty,boolean isPersistent,MetaClass metaClass,boolean isPersistent,Class aClass){\r\n    checkNotNullArgument(aClass, \"class is null\");\r\n    return isPersistent(metadata.getClassNN(aClass));\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.EntityStates.isNew",
	"Comment": "determines whether the instance is new, i.e. just created and not stored in database yet.",
	"Method": "boolean isNew(Object entity){\r\n    checkNotNullArgument(entity, \"entity is null\");\r\n    if (entity instanceof BaseGenericIdEntity) {\r\n        return BaseEntityInternalAccess.isNew((BaseGenericIdEntity) entity);\r\n    } else if (entity instanceof AbstractNotPersistentEntity) {\r\n        return BaseEntityInternalAccess.isNew((AbstractNotPersistentEntity) entity);\r\n    } else {\r\n        if (log.isTraceEnabled()) {\r\n            log.trace(\"EntityStates.isNew is called for unsupported type '{}'. Stacktrace:\\n{}\", entity.getClass().getSimpleName(), StackTrace.asString());\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.App.logout",
	"Comment": "try to perform logout. if there are unsaved changes in opened windows then logout will not be performed andunsaved changes dialog will appear.",
	"Method": "void logout(Runnable runWhenLoggedOut,OperationResult logout){\r\n    AppUI ui = getAppUI();\r\n    try {\r\n        RootWindow topLevelWindow = ui != null ? ui.getTopLevelWindow() : null;\r\n        if (topLevelWindow != null) {\r\n            topLevelWindow.saveSettings();\r\n            Screens screens = ui.getScreens();\r\n            if (!screens.hasUnsavedChanges()) {\r\n                forceLogout();\r\n                return OperationResult.success();\r\n            }\r\n            UnknownOperationResult result = new UnknownOperationResult();\r\n            Messages messages = beanLocator.get(Messages.NAME);\r\n            Icons icons = beanLocator.get(Icons.NAME);\r\n            Dialogs dialogs = ui.getDialogs();\r\n            dialogs.createOptionDialog().withCaption(messages.getMainMessage(\"closeUnsaved.caption\")).withMessage(messages.getMainMessage(\"discardChangesOnClose\")).withActions(new BaseAction(\"closeApplication\").withCaption(messages.getMainMessage(\"closeApplication\")).withIcon(icons.get(CubaIcon.DIALOG_OK)).withHandler(event -> {\r\n                forceLogout();\r\n                result.success();\r\n            }), new DialogAction(DialogAction.Type.CANCEL, Action.Status.PRIMARY).withHandler(event -> {\r\n                result.fail();\r\n            })).show();\r\n            return OperationResult.fail();\r\n        } else {\r\n            forceLogout();\r\n            return OperationResult.success();\r\n        }\r\n    } catch (Exception e) {\r\n        log.error(\"Error on logout\", e);\r\n        String url = ControllerUtils.getLocationWithoutParams() + \"?restartApp\";\r\n        if (ui != null) {\r\n            ui.getPage().open(url, \"_self\");\r\n        }\r\n        return new UnknownOperationResult();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.bali.db.DbUtils.rollbackAndCloseQuietly",
	"Comment": "performs a rollback on the connection then closes it,avoid closing if null and hide any sqlexceptions that occur.",
	"Method": "void rollbackAndCloseQuietly(Connection conn){\r\n    try {\r\n        rollbackAndClose(conn);\r\n    } catch (SQLException e) {\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.ui.tabsheet.VDDTabSheet.getTabLeftRightDropRatio",
	"Comment": "get the distribution of how a drop should be interpreted over a tab",
	"Method": "double getTabLeftRightDropRatio(){\r\n    return tabLeftRightDropRatio;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.app.AttributeSecuritySupport.afterCommit",
	"Comment": "should be called after merging an entity and transaction commit.",
	"Method": "void afterCommit(Entity entity){\r\n    if (!config.getEntityAttributePermissionChecking()) {\r\n        return;\r\n    }\r\n    if (entity != null) {\r\n        metadataTools.traverseAttributes(entity, new ClearInaccessibleAttributesVisitor());\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.security.global.UserSession.getLocalAttributeNames",
	"Comment": "local attribute names. local attribute is a named object bound to session. unlike normal user session attributes,local attributes are not passed between tiers and not replicated in cluster.",
	"Method": "Collection<String> getLocalAttributeNames(){\r\n    return new ArrayList(localAttributes.keySet());\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.app.dynamicattributes.DynamicAttributesTools.getMetaPropertyPath",
	"Comment": "get special meta property path object for dynamic attribute id",
	"Method": "MetaPropertyPath getMetaPropertyPath(MetaClass metaClass,String attributeCode,MetaPropertyPath getMetaPropertyPath,MetaClass metaClass,UUID attributeId){\r\n    Collection<CategoryAttribute> attributes = dynamicAttributes.getAttributesForMetaClass(metaClass);\r\n    CategoryAttribute attribute = null;\r\n    for (CategoryAttribute theAttribute : attributes) {\r\n        if (theAttribute.getId().equals(attributeId)) {\r\n            attribute = theAttribute;\r\n            break;\r\n        }\r\n    }\r\n    if (attribute != null) {\r\n        return DynamicAttributesUtils.getMetaPropertyPath(metaClass, attribute);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.validators.AbstractBeanValidator.setValidationErrorMessage",
	"Comment": "set main validation error message. useful only for custom validation in screen controller.",
	"Method": "void setValidationErrorMessage(String validationErrorMessage){\r\n    this.validationErrorMessage = validationErrorMessage;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.Window.addCloseListener",
	"Comment": "add a listener that will be notified when this screen is closed.",
	"Method": "void addCloseListener(CloseListener listener){\r\n    getFrameOwner().addAfterCloseListener(new AfterCloseListenerAdapter(listener));\r\n}"
}, {
	"Path": "com.haulmont.cuba.restapi.DataServiceController.removePermitted",
	"Comment": "checks if the user have permissions to remove all of the requested entities.",
	"Method": "boolean removePermitted(Collection removeInstances,boolean removePermitted,MetaClass metaClass){\r\n    return entityOpPermitted(metaClass, EntityOp.DELETE);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.actions.ExcludeAction.create",
	"Comment": "creates an action with default id. autocommit and confirm properties are set to false.",
	"Method": "ExcludeAction create(ListComponent target,ExcludeAction create,ListComponent target,boolean autocommit,boolean confirm,ExcludeAction create,ListComponent target,boolean autocommit,boolean confirm,String id){\r\n    return AppBeans.getPrototype(\"cuba_ExcludeAction\", target, autocommit, confirm, id);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.filter.FilterDelegateImpl.setFilterEntity",
	"Comment": "sets filter entity, creates condition editor components and applies filter if necessary",
	"Method": "void setFilterEntity(FilterEntity filterEntity){\r\n    this.filterEntity = filterEntity;\r\n    conditions = filterParser.getConditions(filter, filterEntity.getXml());\r\n    prevConditions = conditions;\r\n    initialConditions = conditions.toConditionsList();\r\n    for (AbstractCondition condition : initialConditions) {\r\n        if (!suitableCondition(condition)) {\r\n            String message = String.format(getMainMessage(\"filter.inappropriate.filter\"), filterEntity.getName(), adapter.getMetaClass().getName());\r\n            windowManager.showNotification(message, Frame.NotificationType.HUMANIZED);\r\n            setFilterEntity(adHocFilter);\r\n            break;\r\n        }\r\n        condition.addListener(new AbstractCondition.Listener() {\r\n            @Override\r\n            public void captionChanged() {\r\n            }\r\n            @Override\r\n            public void paramChanged(Param oldParam, Param newParam) {\r\n                updateFilterModifiedIndicator();\r\n            }\r\n        });\r\n    }\r\n    Window window = getWindow();\r\n    for (AbstractCondition condition : conditions.toConditionsList()) {\r\n        if (condition.getParam() != null) {\r\n            for (Map.Entry<String, Object> entry : window.getContext().getParams().entrySet()) {\r\n                if (entry.getKey().equals(condition.getParam().getName()))\r\n                    condition.getParam().parseValue((String) entry.getValue());\r\n            }\r\n        }\r\n    }\r\n    saveInitialFilterState();\r\n    if (filtersLookupDisplayed) {\r\n        filtersLookupListenerEnabled = false;\r\n        filtersLookup.setValue(filterEntity);\r\n        filtersLookupListenerEnabled = true;\r\n    }\r\n    setFilterActionsEnabled();\r\n    setFilterActionsVisible();\r\n    fillConditionsLayout(ConditionsFocusType.FIRST);\r\n    if (delayedFocus) {\r\n        delayedFocus = false;\r\n        requestFocus();\r\n    } else {\r\n        requestFocusToParamEditComponent();\r\n    }\r\n    setConditionsLayoutVisible(true);\r\n    if (BooleanUtils.isTrue(filterEntity.getIsSet()) || (filterEntity.getFolder() != null && BooleanUtils.isNotFalse(filterEntity.getApplyDefault()))) {\r\n        apply(true);\r\n    }\r\n    for (Filter.FilterEntityChangeListener listener : filterEntityChangeListeners) {\r\n        listener.filterEntityChanged(filterEntity);\r\n    }\r\n    updateWindowCaption();\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.filter.FilterDelegateImpl.setFilterEntity",
	"Comment": "sets filter entity, creates condition editor components and applies filter if necessary",
	"Method": "void setFilterEntity(FilterEntity filterEntity){\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.filter.FilterDelegateImpl.setFilterEntity",
	"Comment": "sets filter entity, creates condition editor components and applies filter if necessary",
	"Method": "void setFilterEntity(FilterEntity filterEntity){\r\n    updateFilterModifiedIndicator();\r\n}"
}, {
	"Path": "com.googlecode.cqengine.query.parser.sql.SQLParser.forPojoWithAttributes",
	"Comment": "creates a new sqlparser for the given pojo class, and registers the given attributes with it.",
	"Method": "SQLParser<O> forPojoWithAttributes(Class<O> pojoClass,Map<String, ? extends Attribute<O, ?>> attributes){\r\n    SQLParser<O> parser = forPojo(pojoClass);\r\n    parser.registerAttributes(attributes);\r\n    return parser;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.actions.BaseAction.isApplicable",
	"Comment": "callback method which is invoked by the action to determine its enabled state.",
	"Method": "boolean isApplicable(){\r\n    return true;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.gui.components.WebAbstractDataGrid.updateCompositionStylesTopPanelVisible",
	"Comment": "if buttons panel becomes hidden we need to set top panel height to 0",
	"Method": "void updateCompositionStylesTopPanelVisible(){\r\n    if (topPanel != null) {\r\n        boolean hasChildren = topPanel.getComponentCount() > 0;\r\n        boolean anyChildVisible = false;\r\n        for (Component childComponent : topPanel) {\r\n            if (childComponent.isVisible()) {\r\n                anyChildVisible = true;\r\n                break;\r\n            }\r\n        }\r\n        boolean topPanelVisible = hasChildren && anyChildVisible;\r\n        if (!topPanelVisible) {\r\n            componentComposition.removeStyleName(HAS_TOP_PANEL_STYLE_NAME);\r\n            internalStyles.remove(HAS_TOP_PANEL_STYLE_NAME);\r\n        } else {\r\n            componentComposition.addStyleName(HAS_TOP_PANEL_STYLE_NAME);\r\n            if (!internalStyles.contains(HAS_TOP_PANEL_STYLE_NAME)) {\r\n                internalStyles.add(HAS_TOP_PANEL_STYLE_NAME);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.crsh.cli.descriptor.ArgumentDescriptor.getName",
	"Comment": "returns the argument name, that can be null. this value is used for display capabilities and does not play a rolewhen a command line is parsed.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "com.haulmont.cuba.security.global.UserSession.removeAttribute",
	"Comment": "remove user session attribute. attribute is a named serializable object bound to session.",
	"Method": "void removeAttribute(String name){\r\n    attributes.remove(name);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.View.setLoadPartialEntities",
	"Comment": "specifies whether the view affects loading of local attributes. by default only reference attributes are affected andlocal are always loaded.",
	"Method": "View setLoadPartialEntities(boolean loadPartialEntities){\r\n    this.loadPartialEntities = loadPartialEntities;\r\n    return this;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.Window.saveSettings",
	"Comment": "this method is called by the framework when closing the screento save user settings if they have been changed.",
	"Method": "void saveSettings(){\r\n    UiControllerUtils.saveSettings(getFrameOwner());\r\n}"
}, {
	"Path": "org.crsh.shell.impl.command.spi.Command.describe",
	"Comment": "returns a description of the command or null if none can be found.",
	"Method": "String describe(InvocationMatch<T> match,Format format,String describe,String line,Format format){\r\n    CommandDescriptor<T> descriptor = getDescriptor();\r\n    InvocationMatcher<T> analyzer = descriptor.matcher();\r\n    InvocationMatch<T> match;\r\n    try {\r\n        match = analyzer.parse(line);\r\n    } catch (org.crsh.cli.impl.SyntaxException e) {\r\n        throw new CommandException(ErrorKind.SYNTAX, \"Syntax exception when evaluating \" + descriptor.getName(), e);\r\n    }\r\n    return describe(match, format);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.MetadataTools.isCascade",
	"Comment": "determine whether an object denoted by the given property is merged into persistence context together with theowning object. this is true if the property is manytomany, or if it is onetomany with certain cascadetypedefined.",
	"Method": "boolean isCascade(MetaProperty metaProperty){\r\n    Objects.requireNonNull(metaProperty, \"metaProperty is null\");\r\n    OneToMany oneToMany = metaProperty.getAnnotatedElement().getAnnotation(OneToMany.class);\r\n    if (oneToMany != null) {\r\n        final Collection<CascadeType> cascadeTypes = Arrays.asList(oneToMany.cascade());\r\n        if (cascadeTypes.contains(CascadeType.ALL) || cascadeTypes.contains(CascadeType.MERGE)) {\r\n            return true;\r\n        }\r\n    }\r\n    ManyToMany manyToMany = metaProperty.getAnnotatedElement().getAnnotation(ManyToMany.class);\r\n    if (manyToMany != null && StringUtils.isBlank(manyToMany.mappedBy())) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.ComponentGenerationContext.setProperty",
	"Comment": "sets the entity attribute for which the component is created, using fluent api method.",
	"Method": "ComponentGenerationContext setProperty(String property){\r\n    this.property = property;\r\n    return this;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.log.LogItem.sanitize",
	"Comment": "cleans reference to throwable. stacktrace still will be available.",
	"Method": "void sanitize(){\r\n    if (throwable != null) {\r\n        fullStackTrace = ExceptionUtils.getStackTrace(throwable);\r\n    }\r\n    this.throwable = null;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.data.DsBuilder.setDsClass",
	"Comment": "set datasource implementation class. if not specified, a standard implementation is used.",
	"Method": "DsBuilder setDsClass(Class<?> dsClass){\r\n    this.dsClass = dsClass;\r\n    return this;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.query.simple.ExistsIn.foreignCollectionContains",
	"Comment": "checks if the given foreign collection contains objects which match the given query.",
	"Method": "boolean foreignCollectionContains(IndexedCollection<F> foreignCollection,Query<F> query){\r\n    ResultSet<F> resultSet = foreignCollection.retrieve(query);\r\n    try {\r\n        return resultSet.isNotEmpty();\r\n    } finally {\r\n        resultSet.close();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.dynamicattributes.DynamicAttributesGuiTools.screenContainsDynamicAttributes",
	"Comment": "method checks whether any class in the view hierarchy contains dynamic attributes that must be displayed onthe current screen",
	"Method": "boolean screenContainsDynamicAttributes(View mainDatasourceView,String screenId){\r\n    DynamicAttributesGuiTools dynamicAttributesGuiTools = AppBeans.get(DynamicAttributesGuiTools.class);\r\n    Set<Class> classesWithDynamicAttributes = collectEntityClassesWithDynamicAttributes(mainDatasourceView);\r\n    for (Class classWithDynamicAttributes : classesWithDynamicAttributes) {\r\n        MetaClass metaClass = metadata.getClassNN(classWithDynamicAttributes);\r\n        if (!dynamicAttributesGuiTools.getAttributesToShowOnTheScreen(metaClass, screenId, null).isEmpty()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.crsh.console.Mode.on",
	"Comment": "transform a key stroke into a editor action. if no action must be taken, null should be returned.",
	"Method": "EditorAction on(KeyStroke keyStroke,EditorAction on,KeyStroke keyStroke,EditorAction on,KeyStroke keyStroke){\r\n    String message = \"Operation \" + keyStroke.operation + \" not mapped in \" + getClass().getSimpleName() + \" mode \" + this;\r\n    log.warning(message);\r\n    return null;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.EntityStates.checkLoaded",
	"Comment": "check that entity has all specified properties loaded from db.throw exception if property is not loaded.",
	"Method": "void checkLoaded(Object entity,String properties){\r\n    checkNotNullArgument(entity);\r\n    for (String property : properties) {\r\n        if (!isLoaded(entity, property)) {\r\n            String errorMessage = String.format(\"%s.%s is not loaded\", entity.getClass().getSimpleName(), property);\r\n            throw new IllegalArgumentException(errorMessage);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.exception.ExceptionHandlersConfiguration.setHandlerClasses",
	"Comment": "set the list of exception handler class names, usually from spring.xml.",
	"Method": "void setHandlerClasses(List<String> list){\r\n    for (String className : list) {\r\n        handlerClasses.add(ReflectionHelper.getClass(className));\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.EntityCombinedScreen.initEditComponents",
	"Comment": "initializes edit controls, depending on if they should be enabled or disabled.",
	"Method": "void initEditComponents(boolean enabled){\r\n    TabSheet tabSheet = getTabSheet();\r\n    if (tabSheet != null) {\r\n        ComponentsHelper.walkComponents(tabSheet, (component, name) -> {\r\n            if (component instanceof FieldGroup) {\r\n                ((FieldGroup) component).setEditable(enabled);\r\n            } else if (component instanceof Table) {\r\n                ((Table) component).getActions().forEach(action -> action.setEnabled(enabled));\r\n            } else if (!(component instanceof ComponentContainer)) {\r\n                component.setEnabled(enabled);\r\n            }\r\n        });\r\n    } else {\r\n        getFieldGroup().setEditable(enabled);\r\n    }\r\n    getActionsPane().setVisible(enabled);\r\n    getLookupBox().setEnabled(!enabled);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.PersistenceImpl.registerSynchronizations",
	"Comment": "internal.register synchronizations with a just started transaction.",
	"Method": "void registerSynchronizations(String store){\r\n    log.trace(\"registerSynchronizations for store '{}'\", store);\r\n    TransactionSynchronizationManager.registerSynchronization(createSynchronization(store));\r\n    support.getInstanceContainerResourceHolder(store);\r\n    statisticsAccumulator.incStartedTransactionsCount();\r\n    TransactionSynchronizationManager.registerSynchronization(new StatisticsTransactionSynchronization());\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.ui.formlayout.VDDFormLayout.getDragMode",
	"Comment": "returns the current drag mode which determines how the drag is visualized",
	"Method": "LayoutDragMode getDragMode(){\r\n    return ddMouseHandler.getDragMode();\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.theme.impl.DesktopThemeImpl.addStyle",
	"Comment": "add style to theme. adding any subsequent style with the same name will override existing styles.",
	"Method": "void addStyle(DesktopStyle style){\r\n    List<DesktopStyle> list = styles.get(style.getName());\r\n    if (list != null) {\r\n        list.add(0, style);\r\n    } else {\r\n        list = new ArrayList();\r\n        list.add(style);\r\n        styles.put(style.getName(), list);\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.PersistenceHelper.checkLoadedWithView",
	"Comment": "check that all properties of the view are loaded from db for the passed entity.throws exception if some property is not loaded.",
	"Method": "void checkLoadedWithView(Entity entity,String viewName){\r\n    EntityStates entityStates = AppBeans.get(EntityStates.class);\r\n    if (entityStates != null) {\r\n        entityStates.checkLoadedWithView(entity, viewName);\r\n    } else {\r\n        _entityStates.checkLoadedWithView(entity, viewName);\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.ui.tabsheet.VDDTabSheet.setTabLeftRightDropRatio",
	"Comment": "set the distribution of how a drop should be interpreted over a tab",
	"Method": "void setTabLeftRightDropRatio(double tabLeftRightDropRatio){\r\n    this.tabLeftRightDropRatio = tabLeftRightDropRatio;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.entity.BaseGenericIdEntity.copySystemState",
	"Comment": "copies the state which is not related to attributes registered in metadata.override this method in subclasses that have additional state which must be preserved when creating copies.",
	"Method": "void copySystemState(BaseGenericIdEntity src){\r\n    __state = src.__state;\r\n    __securityState = src.__securityState;\r\n    dynamicAttributes = src.dynamicAttributes;\r\n}"
}, {
	"Path": "com.haulmont.cuba.security.global.UserSession.getLocalAttribute",
	"Comment": "get local attribute. local attribute is a named object bound to session. unlike normal user session attributes,local attributes are not passed between tiers and not replicated in cluster.",
	"Method": "T getLocalAttribute(String name){\r\n    return (T) localAttributes.get(name);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.entity.FileDescriptor.toUrlParam",
	"Comment": "used by the framework to transfer file between application tiers.",
	"Method": "String toUrlParam(){\r\n    StringBuilder strBuilder = new StringBuilder().append(id).append(\",\").append(extension).append(\",\").append(createDate.getTime());\r\n    if (size != null) {\r\n        strBuilder.append(\",\").append(size);\r\n    }\r\n    return strBuilder.toString();\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.remoting.HttpServiceExporter.handleRequest",
	"Comment": "in base implementation, exceptions which are thrown during reading remote invocation request, are not handled.client gets useless http status 500 in this case.this implementation passes some known exceptions to client.",
	"Method": "void handleRequest(HttpServletRequest request,HttpServletResponse response){\r\n    try {\r\n        RemoteInvocationResult result;\r\n        try {\r\n            RemoteInvocation invocation = readRemoteInvocation(request);\r\n            result = invokeAndCreateResult(invocation, getProxy());\r\n        } catch (OptionalDataException | ClassCastException e) {\r\n            logger.error(\"Failed to read remote invocation request\", e);\r\n            result = new RemoteInvocationResult(e);\r\n        }\r\n        writeRemoteInvocationResult(request, response, result);\r\n    } catch (ClassNotFoundException ex) {\r\n        throw new NestedServletException(\"Class not found during deserialization\", ex);\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.security.global.UserSession.setLocalAttribute",
	"Comment": "set local attribute. local attribute is a named object bound to session. unlike normal user session attributes,local attributes are not passed between tiers and not replicated in cluster.",
	"Method": "void setLocalAttribute(String name,Object value){\r\n    localAttributes.put(name, value);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.dynamicattributes.DynamicAttributesGuiTools.createLookupAction",
	"Comment": "creates the lookup action that will open the lookup screen with the dynamic filter applied. this filter containsa condition with join and where clauses",
	"Method": "PickerField.LookupAction createLookupAction(PickerField pickerField,String joinClause,String whereClause){\r\n    FilteringLookupAction filteringLookupAction = new FilteringLookupAction(pickerField, joinClause, whereClause);\r\n    Map<String, Object> params = new HashMap();\r\n    WindowParams.DISABLE_RESUME_SUSPENDED.set(params, true);\r\n    WindowParams.DISABLE_AUTO_REFRESH.set(params, true);\r\n    filteringLookupAction.setLookupScreenParams(params);\r\n    return filteringLookupAction;\r\n}"
}, {
	"Path": "name.fraser.neil.plaintext.diff_match_patch.diff_commonOverlap",
	"Comment": "determine if the suffix of one string is the prefix of another.",
	"Method": "int diff_commonOverlap(String text1,String text2){\r\n    int text1_length = text1.length();\r\n    int text2_length = text2.length();\r\n    if (text1_length == 0 || text2_length == 0) {\r\n        return 0;\r\n    }\r\n    if (text1_length > text2_length) {\r\n        text1 = text1.substring(text1_length - text2_length);\r\n    } else if (text1_length < text2_length) {\r\n        text2 = text2.substring(0, text1_length);\r\n    }\r\n    int text_length = Math.min(text1_length, text2_length);\r\n    if (text1.equals(text2)) {\r\n        return text_length;\r\n    }\r\n    int best = 0;\r\n    int length = 1;\r\n    while (true) {\r\n        String pattern = text1.substring(text_length - length);\r\n        int found = text2.indexOf(pattern);\r\n        if (found == -1) {\r\n            return best;\r\n        }\r\n        length += found;\r\n        if (found == 0 || text1.substring(text_length - length).equals(text2.substring(0, length))) {\r\n            best = length;\r\n            length++;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.cronutils.model.time.TimeNode.getValueFromList",
	"Comment": "obtain value from list considering specified index and required shifts.",
	"Method": "int getValueFromList(List<Integer> values,int index,AtomicInteger shift){\r\n    Preconditions.checkNotNullNorEmpty(values, \"List must not be empty\");\r\n    if (index < 0) {\r\n        index = index + values.size();\r\n        shift.incrementAndGet();\r\n        return getValueFromList(values, index, shift);\r\n    }\r\n    if (index >= values.size()) {\r\n        index = index - values.size();\r\n        shift.incrementAndGet();\r\n        return getValueFromList(values, index, shift);\r\n    }\r\n    return values.get(index);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.DateTimeTransformations.transformFromLocalTime",
	"Comment": "obtains an instance of specified by type date object fromfrom localtime",
	"Method": "Object transformFromLocalTime(LocalTime localTime,Class javaType){\r\n    if (java.sql.Time.class.equals(javaType)) {\r\n        return java.sql.Time.valueOf(localTime);\r\n    } else if (Date.class.equals(javaType)) {\r\n        return new Date(java.sql.Time.valueOf(localTime).getTime());\r\n    } else if (LocalTime.class.equals(javaType)) {\r\n        return localTime;\r\n    } else if (OffsetTime.class.equals(javaType)) {\r\n        return new Date(java.sql.Time.valueOf(localTime).getTime()).toInstant().atZone(ZoneId.systemDefault()).toOffsetDateTime().toOffsetTime();\r\n    }\r\n    throw newUnsupportedTypeException(javaType);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.actions.BaseAction.isPermitted",
	"Comment": "callback method which is invoked by the action to determine its enabled state.",
	"Method": "boolean isPermitted(){\r\n    return true;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.autocomplete.impl.HintProvider.getLastWord",
	"Comment": "returns word in query denoting entity or field parameter user have requested hint for",
	"Method": "String getLastWord(String queryString,int caretPosition){\r\n    if (caretPosition < 0)\r\n        return \"\";\r\n    if (Character.isSpaceChar(queryString.charAt(caretPosition))) {\r\n        return \"\";\r\n    }\r\n    String[] words = queryString.substring(0, caretPosition + 1).split(\"\\\\s\");\r\n    String result = words[words.length - 1];\r\n    if (StringUtils.isBlank(result)) {\r\n        return result;\r\n    }\r\n    int leftBracketsIdx = result.lastIndexOf('(');\r\n    if (leftBracketsIdx >= 0 && leftBracketsIdx < result.length()) {\r\n        result = result.substring(leftBracketsIdx + 1);\r\n    }\r\n    result = getLastWordWithArithmeticOperation(result);\r\n    return result;\r\n}"
}, {
	"Path": "com.cronutils.descriptor.refactor.SecondsDescriptor.describe",
	"Comment": "provide a human readable description for between instance.",
	"Method": "String describe(FieldExpression fieldExpression,String describe,FieldExpression fieldExpression,boolean and,String describe,Always always,boolean and,String describe,And and,String describe,Between between,boolean and,String describe,Every every,boolean and,String describe,On on,boolean and){\r\n    if (and) {\r\n        return nominalValue(on.getTime());\r\n    }\r\n    return String.format(\"%s %s \", bundle.getString(\"at\"), nominalValue(on.getTime())) + \"%s\";\r\n}"
}, {
	"Path": "org.crsh.text.LineRenderer.reader",
	"Comment": "create a renderer for the specified width or return null if the element does not provide any output.",
	"Method": "LineReader reader(int width,int height,LineReader reader,int width,LineReader reader,int width,int height,LineReader reader,int width){\r\n    if (height > 0) {\r\n        return null;\r\n    } else {\r\n        return reader(width);\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.MessageTools.loadString",
	"Comment": "get localized message by reference provided in full or brief format.",
	"Method": "String loadString(String ref,String loadString,String ref,Locale locale,String loadString,String messagesPack,String ref,String loadString,String messagesPack,String ref,Locale locale){\r\n    if (ref != null) {\r\n        if (ref.startsWith(MARK)) {\r\n            String path = ref.substring(6);\r\n            final String[] strings = path.split(\"/\");\r\n            if (strings.length == 1 && messagesPack != null) {\r\n                if (locale == null) {\r\n                    ref = messages.getMessage(messagesPack, strings[0]);\r\n                } else {\r\n                    ref = messages.getMessage(messagesPack, strings[0], locale);\r\n                }\r\n            } else if (strings.length == 2) {\r\n                if (locale == null) {\r\n                    ref = messages.getMessage(strings[0], strings[1]);\r\n                } else {\r\n                    ref = messages.getMessage(strings[0], strings[1], locale);\r\n                }\r\n            } else {\r\n                throw new UnsupportedOperationException(\"Unsupported resource string format: '\" + ref + \"', messagesPack=\" + messagesPack);\r\n            }\r\n        } else if (ref.startsWith(MAIN_MARK)) {\r\n            String path = ref.substring(10);\r\n            if (locale == null) {\r\n                return messages.getMainMessage(path);\r\n            } else {\r\n                return messages.getMainMessage(path, locale);\r\n            }\r\n        }\r\n    }\r\n    return ref;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.contextmenu.ContextMenu.setAsContextMenuOf",
	"Comment": "sets this as a context menu of the component. you can set one menu to asmany components as you wish.",
	"Method": "void setAsContextMenuOf(ContextClickNotifier component){\r\n    component.addContextClickListener(contextClickListener);\r\n}"
}, {
	"Path": "com.cronutils.utils.Preconditions.checkNotNullNorEmpty",
	"Comment": "ensures that a collection reference passed as a parameter to the calling method is not null.nor empty.",
	"Method": "String checkNotNullNorEmpty(String reference,Object errorMessage,T checkNotNullNorEmpty,T reference,Object errorMessage){\r\n    if (reference == null) {\r\n        throw new NullPointerException(String.valueOf(errorMessage));\r\n    }\r\n    if (reference.isEmpty()) {\r\n        throw new IllegalArgumentException(String.valueOf(errorMessage));\r\n    }\r\n    return reference;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.data.impl.AbstractCollectionDatasource.getCount",
	"Comment": "return number of rows for the current query set in the datasource.",
	"Method": "int getCount(){\r\n    LoadContext<Entity> context = new LoadContext(metaClass);\r\n    LoadContext.Query q = (LoadContext.Query) createDataQuery(context, savedParameters == null ? Collections.<String, Object>emptyMap() : savedParameters);\r\n    context.setSoftDeletion(isSoftDeletion());\r\n    if (q == null)\r\n        return 0;\r\n    prepareLoadContext(context);\r\n    dataLoadError = null;\r\n    try {\r\n        long res = dataSupplier.getCount(context);\r\n        if (res > Integer.MAX_VALUE)\r\n            throw new RuntimeException(\"Number of records is too big: \" + res);\r\n        return (int) res;\r\n    } catch (Throwable e) {\r\n        dataLoadError = e;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.screen.StandardEditor.validateUiComponents",
	"Comment": "validates visible and enabled ui components. can be overridden in subclasses.",
	"Method": "ValidationErrors validateUiComponents(){\r\n    Collection<Component> components = ComponentsHelper.getComponents(getWindow());\r\n    ScreenValidation screenValidation = getBeanLocator().get(ScreenValidation.NAME);\r\n    return screenValidation.validateUiComponents(components);\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.sys.vcl.SearchAutoCompleteSupport.togglePopup",
	"Comment": "a small convenience method to try showing the comboboxpopup.",
	"Method": "void togglePopup(){\r\n    if (doNotTogglePopup)\r\n        return;\r\n    if (comboBoxModel.getSize() == 0) {\r\n        comboBox.hidePopup();\r\n    } else if (comboBox.isShowing() && !comboBox.isPopupVisible() && comboBoxEditorComponent.hasFocus())\r\n        comboBox.showPopup();\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.DateTimeTransformations.transformToZDT",
	"Comment": "obtains an instance of zoneddatetimefrom date or localdate or localdatetime or offsetdatetimezoneddatetime is created for localdate, localdatetime with default system timezone",
	"Method": "ZonedDateTime transformToZDT(Object date){\r\n    Preconditions.checkNotNull(date);\r\n    ZoneId zoneId = ZoneId.systemDefault();\r\n    if (date instanceof java.sql.Date) {\r\n        return ((java.sql.Date) date).toLocalDate().atStartOfDay(zoneId);\r\n    } else if (date instanceof Date) {\r\n        return ((Date) date).toInstant().atZone(zoneId);\r\n    } else if (date instanceof LocalDate) {\r\n        return ((LocalDate) date).atStartOfDay(zoneId);\r\n    } else if (date instanceof LocalDateTime) {\r\n        return ((LocalDateTime) date).atZone(zoneId);\r\n    } else if (date instanceof OffsetDateTime) {\r\n        return ((OffsetDateTime) date).atZoneSameInstant(zoneId);\r\n    }\r\n    throw newUnsupportedTypeException(date.getClass());\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.ui.verticallayout.VDDVerticalLayout.updateDragDetails",
	"Comment": "updates the drop details while dragging. this is needed to ensure clientside criterias can validate the drop location.",
	"Method": "void updateDragDetails(Widget widget,VDragEvent event){\r\n    if (widget == null) {\r\n        return;\r\n    }\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_VERTICAL_DROP_LOCATION, getVerticalDropLocation(widget, event));\r\n    int index = -1;\r\n    if (widget instanceof Slot) {\r\n        WidgetCollection captionsAndSlots = getChildren();\r\n        index = VDragDropUtil.findSlotIndex(captionsAndSlots, (Slot) widget);\r\n    }\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_TO, index);\r\n    MouseEventDetails details = MouseEventDetailsBuilder.buildMouseEventDetails(event.getCurrentGwtEvent(), getElement());\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_MOUSE_EVENT, details.serialize());\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.DialogOptions.setWidthAuto",
	"Comment": "set width of a window to auto if it will be opened as a dialog or change width at run time if the window is already opened as a dialog.",
	"Method": "DialogOptions setWidthAuto(){\r\n    return setWidth(AUTO_SIZE);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.PersistenceHelper.isLoadedWithView",
	"Comment": "check that all properties of the view are loaded from db for the passed entity.",
	"Method": "boolean isLoadedWithView(Entity entity,String viewName){\r\n    EntityStates entityStates = AppBeans.get(EntityStates.class);\r\n    if (entityStates != null) {\r\n        return entityStates.isLoadedWithView(entity, viewName);\r\n    } else {\r\n        return _entityStates.isLoadedWithView(entity, viewName);\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.queryconditions.ConditionJpqlGenerator.processQuery",
	"Comment": "returns a jpql query modified according to the given tree of conditions.",
	"Method": "String processQuery(String query,Condition condition){\r\n    if (condition == null) {\r\n        return query;\r\n    }\r\n    QueryTransformer transformer = queryTransformerFactory.transformer(query);\r\n    String joins = generateJoins(condition);\r\n    String where = generateWhere(condition);\r\n    if (!Strings.isNullOrEmpty(joins)) {\r\n        transformer.addJoinAndWhere(joins, where);\r\n    } else {\r\n        transformer.addWhere(where);\r\n    }\r\n    return transformer.getResult();\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.DDPanel.setDropHandler",
	"Comment": "sets the drop handler which handles component drops on the layout",
	"Method": "void setDropHandler(DropHandler dropHandler){\r\n    DDUtil.verifyHandlerType(this, dropHandler);\r\n    if (this.dropHandler != dropHandler) {\r\n        this.dropHandler = dropHandler;\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.cqengine.IndexedCollectionFunctionalTest.getMacroScenarios",
	"Comment": "this allows to run the same set of queries with different combinations of indexes etc.",
	"Method": "List<MacroScenario> getMacroScenarios(){\r\n    return Arrays.asList(new MacroScenario() {\r\n        {\r\n            name = \"typical queries\";\r\n            dataSet = REGULAR_DATASET;\r\n            alsoEvaluateWithIndexMergeStrategy = true;\r\n            collectionImplementations = SKIP_SLOW_SCENARIOS ? classes(ConcurrentIndexedCollection.class, TransactionalIndexedCollection.class, OffHeapConcurrentIndexedCollection.class) : classes(ConcurrentIndexedCollection.class, TransactionalIndexedCollection.class, OffHeapConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class);\r\n            queriesToEvaluate = asList(new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.CAR_ID, 500);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 1;\r\n                            carIdsAnyOrder = asSet(500);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.CAR_ID, 500, 500);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 1;\r\n                            carIdsAnyOrder = asSet(500);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.CAR_ID, 998, 2000);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 2;\r\n                            carIdsAnyOrder = asSet(998, 999);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.CAR_ID, -10, 2);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            carIdsAnyOrder = asSet(0, 1, 2);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.CAR_ID, 499, 501);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            carIdsAnyOrder = asSet(499, 500, 501);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.CAR_ID, 407, 683);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 277;\r\n                            carIdsAnyOrder = integersBetween(407, 683);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.CAR_ID, 407, true, 683, true);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 277;\r\n                            carIdsAnyOrder = integersBetween(407, 683);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.CAR_ID, 407, false, 683, true);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 276;\r\n                            carIdsAnyOrder = integersBetween(408, 683);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.CAR_ID, 407, true, 683, false);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 276;\r\n                            carIdsAnyOrder = integersBetween(407, 682);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.CAR_ID, 407, false, 683, false);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 275;\r\n                            carIdsAnyOrder = integersBetween(408, 682);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = lessThan(Car.CAR_ID, 5);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 5;\r\n                            carIdsAnyOrder = integersBetween(0, 4);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = lessThanOrEqualTo(Car.CAR_ID, 5);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 6;\r\n                            carIdsAnyOrder = integersBetween(0, 5);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = greaterThan(Car.CAR_ID, 995);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 4;\r\n                            carIdsAnyOrder = integersBetween(996, 999);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = greaterThanOrEqualTo(Car.CAR_ID, 995);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 5;\r\n                            carIdsAnyOrder = integersBetween(995, 999);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = in(Car.CAR_ID, 5, 463, 999);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            carIdsAnyOrder = asSet(5, 463, 999);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = in(Car.CAR_ID, -10, 5, 463, 999, 1500);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            carIdsAnyOrder = asSet(5, 463, 999);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = all(Car.class);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 1000;\r\n                            carIdsAnyOrder = integersBetween(0, 999);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = none(Car.class);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 0;\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = and(between(Car.CAR_ID, 400, 500), lessThan(Car.CAR_ID, 450));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            containsCarIds = asSet(400, 449);\r\n                            doesNotContainCarIds = asSet(399, 450, 501);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = and(between(Car.CAR_ID, 400, 500), not(greaterThan(Car.CAR_ID, 450)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            containsCarIds = asSet(400, 450, 449);\r\n                            doesNotContainCarIds = asSet(11, 399, 451, 501);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = or(between(Car.CAR_ID, 400, 500), between(Car.CAR_ID, 450, 550));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            containsCarIds = integersBetween(400, 550);\r\n                            doesNotContainCarIds = asSet(399, 551);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = not(greaterThan(Car.CAR_ID, 450));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            containsCarIds = asSet(1, 449, 450);\r\n                            doesNotContainCarIds = asSet(451);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.FEATURES, \"hybrid\");\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 200;\r\n                            containsCarIds = asSet(1, 7);\r\n                            doesNotContainCarIds = asSet(0, 2, 3, 4, 5, 6, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = in(Car.FEATURES, \"hybrid\", \"coupe\");\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 300;\r\n                            containsCarIds = asSet(1, 7, 9);\r\n                            doesNotContainCarIds = asSet(0, 2, 3, 4, 5, 6, 8);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.FEATURES, \"grade a\", \"grade c\");\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 300;\r\n                            containsCarIds = asSet(2, 3, 4);\r\n                            doesNotContainCarIds = asSet(0, 1, 5, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.FEATURES, \"grade a\", false, \"grade c\", true);\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 200;\r\n                            containsCarIds = asSet(3, 4);\r\n                            doesNotContainCarIds = asSet(0, 1, 2, 5, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.FEATURES, \"grade a\", true, \"grade c\", false);\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 200;\r\n                            containsCarIds = asSet(2, 3);\r\n                            doesNotContainCarIds = asSet(0, 1, 4, 5, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.FEATURES, \"grade a\", false, \"grade c\", false);\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 100;\r\n                            containsCarIds = asSet(3);\r\n                            doesNotContainCarIds = asSet(0, 1, 2, 4, 5, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = and(greaterThan(Car.FEATURES, \"grade a\"), lessThan(Car.FEATURES, \"grade c\"));\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 100;\r\n                            containsCarIds = asSet(3);\r\n                            doesNotContainCarIds = asSet(0, 1, 2, 4, 5, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = and(greaterThanOrEqualTo(Car.FEATURES, \"grade a\"), lessThanOrEqualTo(Car.FEATURES, \"grade c\"));\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 300;\r\n                            containsCarIds = asSet(2, 3, 4);\r\n                            doesNotContainCarIds = asSet(0, 1, 5, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = startsWith(Car.FEATURES, \"grade\");\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 300;\r\n                            containsCarIds = asSet(2, 3, 4);\r\n                            doesNotContainCarIds = asSet(0, 1, 5, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = startsWith(Car.MANUFACTURER, \"Hon\");\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 300;\r\n                            containsCarIds = asSet(3, 4, 5);\r\n                            doesNotContainCarIds = asSet(0, 1, 2, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = contains(Car.FEATURES, \"ade\");\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 300;\r\n                            containsCarIds = asSet(2, 3, 4);\r\n                            doesNotContainCarIds = asSet(0, 1, 5, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = contains(Car.MANUFACTURER, \"on\");\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 300;\r\n                            containsCarIds = asSet(3, 4, 5);\r\n                            doesNotContainCarIds = asSet(0, 1, 2, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = isContainedIn(Car.MANUFACTURER, \"I would like to buy a Honda car\");\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 300;\r\n                            containsCarIds = asSet(3, 4, 5);\r\n                            doesNotContainCarIds = asSet(0, 1, 2, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = and(lessThan(Car.CAR_ID, 100), or(none(Car.class), isContainedIn(Car.MANUFACTURER, \"I would like to buy a Honda car\")));\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 30;\r\n                            containsCarIds = asSet(3, 4, 5);\r\n                            doesNotContainCarIds = asSet(0, 1, 2, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = isContainedIn(Car.FEATURES, \"I would like a coupe or a sunroof please\");\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 200;\r\n                            containsCarIds = asSet(7, 9);\r\n                            doesNotContainCarIds = asSet(0, 1, 2, 3, 4, 5, 6, 8);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = matchesRegex(Car.MODEL, \"F.+n\");\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 100;\r\n                            containsCarIds = asSet(1);\r\n                            doesNotContainCarIds = asSet(0, 2, 3, 4, 5, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = matchesRegex(Car.FEATURES, \".*ade.*\");\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 300;\r\n                            containsCarIds = asSet(2, 3, 4);\r\n                            doesNotContainCarIds = asSet(0, 1, 5, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = or(between(Car.CAR_ID, 400, 500), between(Car.CAR_ID, 450, 550));\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.MATERIALIZE));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 151;\r\n                            containsCarIds = integersBetween(400, 550);\r\n                            doesNotContainCarIds = asSet(399, 551);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = or(between(Car.CAR_ID, 400, 500), between(Car.CAR_ID, 450, 550));\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 151;\r\n                            containsCarIds = integersBetween(400, 550);\r\n                            doesNotContainCarIds = asSet(399, 551);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = or(between(Car.CAR_ID, 400, 450), or(between(Car.CAR_ID, 451, 499), between(Car.CAR_ID, 500, 550)));\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 151;\r\n                            containsCarIds = integersBetween(400, 550);\r\n                            doesNotContainCarIds = asSet(399, 551);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = endsWith(Car.FEATURES, \"roof\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 100;\r\n                            containsCarIds = asSet(7);\r\n                            doesNotContainCarIds = asSet(0, 1, 2, 3, 4, 5, 6, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = endsWith(Car.MODEL, \"sight\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 100;\r\n                            containsCarIds = asSet(5);\r\n                            doesNotContainCarIds = asSet(0, 1, 2, 3, 4, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = and(equal(Car.MANUFACTURER, \"Ford\"), equal(Car.MODEL, \"Fusion\"));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 100;\r\n                            containsCarIds = asSet(1);\r\n                            doesNotContainCarIds = asSet(0, 2, 3, 4, 5, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = and(equal(Car.MANUFACTURER, \"Ford\"), equal(Car.MODEL, \"XXX\"));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 0;\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = has(Car.FEATURES);\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 600;\r\n                            containsCarIds = asSet(1, 2, 3, 4, 7, 9);\r\n                            doesNotContainCarIds = asSet(0, 5, 6, 8);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = has(Car.FEATURES);\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.MATERIALIZE));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 600;\r\n                            containsCarIds = asSet(1, 2, 3, 4, 7, 9);\r\n                            doesNotContainCarIds = asSet(0, 5, 6, 8);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = has(Car.MANUFACTURER);\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.LOGICAL_ELIMINATION));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 1000;\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = has(Car.MANUFACTURER);\r\n                    queryOptions = queryOptions(deduplicate(DeduplicationStrategy.MATERIALIZE));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 1000;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(noIndexes(), indexCombination(UniqueIndex.onAttribute(Car.CAR_ID)), indexCombination(HashIndex.onAttribute(Car.CAR_ID)), indexCombination(HashIndex.withQuantizerOnAttribute(IntegerQuantizer.withCompressionFactor(10), Car.CAR_ID)), indexCombination(NavigableIndex.onAttribute(Car.CAR_ID)), indexCombination(NavigableIndex.withQuantizerOnAttribute(IntegerQuantizer.withCompressionFactor(10), Car.CAR_ID)), indexCombination(NavigableIndex.onAttribute(Car.FEATURES)), indexCombination(HashIndex.onAttribute(Car.FEATURES)), indexCombination(RadixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(InvertedRadixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(ReversedRadixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(SuffixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(CompoundIndex.onAttributes(Car.MANUFACTURER, Car.MODEL)), indexCombination(CompoundIndex.withQuantizerOnAttributes(new Quantizer<CompoundValueTuple<Car>>() {\r\n                @Override\r\n                public CompoundValueTuple<Car> getQuantizedValue(CompoundValueTuple<Car> tuple) {\r\n                    Iterator<Object> tupleValues = tuple.getAttributeValues().iterator();\r\n                    String manufacturer = (String) tupleValues.next();\r\n                    String model = (String) tupleValues.next();\r\n                    String quantizedModel = \"Focus\".equals(model) ? \"Focus\" : \"Other\";\r\n                    return new CompoundValueTuple<Car>(Arrays.asList(manufacturer, quantizedModel));\r\n                }\r\n            }, Car.MANUFACTURER, Car.MODEL)), indexCombination(OffHeapIndex.onAttribute(Car.MANUFACTURER)), indexCombination(DiskIndex.onAttribute(Car.FEATURES)), indexCombination(DiskIndex.onAttribute(Car.MANUFACTURER)), indexCombination(OffHeapIndex.onAttribute(Car.MANUFACTURER)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"off-heap collection\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(OffHeapConcurrentIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = in(Car.CAR_ID, 3, 4, 5);\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            carIdsAnyOrder = asSet(3, 4, 5);\r\n                            indexUsed = true;\r\n                            mergeCost = 3;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(noIndexes());\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"off-heap index\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(OffHeapConcurrentIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.MANUFACTURER, \"Ford\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            carIdsAnyOrder = asSet(0, 1, 2);\r\n                            indexUsed = true;\r\n                            mergeCost = 3;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(OffHeapIndex.onAttribute(Car.MANUFACTURER)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"disk index\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(DiskConcurrentIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.MANUFACTURER, \"Ford\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            carIdsAnyOrder = asSet(0, 1, 2);\r\n                            indexUsed = true;\r\n                            mergeCost = 3;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(DiskIndex.onAttribute(Car.MANUFACTURER)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"merge cost without indexes\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class, TransactionalIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.MANUFACTURER, \"Ford\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            carIdsAnyOrder = asSet(0, 1, 2);\r\n                            indexUsed = false;\r\n                            mergeCost = Integer.MAX_VALUE;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(noIndexes());\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"merge costs with indexes\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class, TransactionalIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.MANUFACTURER, \"Ford\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            carIdsAnyOrder = asSet(0, 1, 2);\r\n                            indexUsed = true;\r\n                            mergeCost = 3;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(HashIndex.onAttribute(Car.MANUFACTURER)), indexCombination(NavigableIndex.onAttribute(Car.MANUFACTURER)), indexCombination(RadixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(ReversedRadixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(InvertedRadixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(SuffixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(DiskIndex.onAttribute(Car.MANUFACTURER)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"retrieval cost without indexes\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class, TransactionalIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.MANUFACTURER, \"Ford\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            retrievalCost = Integer.MAX_VALUE;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(noIndexes());\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"retrieval cost with HashIndex\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class, TransactionalIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.MANUFACTURER, \"Ford\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            retrievalCost = 30;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(HashIndex.onAttribute(Car.MANUFACTURER)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"retrieval cost with NavigableIndex\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class, TransactionalIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.MANUFACTURER, \"Ford\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            retrievalCost = 40;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(NavigableIndex.onAttribute(Car.MANUFACTURER)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"retrieval cost with RadixTreeIndex\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class, TransactionalIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.MANUFACTURER, \"Ford\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            retrievalCost = 50;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(RadixTreeIndex.onAttribute(Car.MANUFACTURER)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"retrieval cost with ReversedRadixTreeIndex\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class, TransactionalIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.MANUFACTURER, \"Ford\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            retrievalCost = 51;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(ReversedRadixTreeIndex.onAttribute(Car.MANUFACTURER)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"retrieval cost with InvertedRadixTreeIndex\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class, TransactionalIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.MANUFACTURER, \"Ford\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            retrievalCost = 52;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(InvertedRadixTreeIndex.onAttribute(Car.MANUFACTURER)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"retrieval cost with SuffixTreeIndex\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class, TransactionalIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.MANUFACTURER, \"Ford\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            retrievalCost = 53;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(SuffixTreeIndex.onAttribute(Car.MANUFACTURER)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"retrieval cost with CompoundIndex\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class, TransactionalIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = and(equal(Car.MANUFACTURER, \"Ford\"), equal(Car.MODEL, \"Fusion\"));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            retrievalCost = 20;\r\n                            mergeCost = 1;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(CompoundIndex.onAttributes(Car.MANUFACTURER, Car.MODEL)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"retrieval cost with PartialNavigableIndex\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = and(greaterThan(Car.PRICE, 4000.0), equal(Car.MANUFACTURER, \"Ford\"));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            retrievalCost = 35;\r\n                            mergeCost = 2;\r\n                            size = 2;\r\n                            carIdsAnyOrder = asSet(0, 2);\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(PartialNavigableIndex.onAttributeWithFilterQuery(Car.PRICE, equal(Car.MANUFACTURER, \"Ford\"))));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"retrieval cost with PartialOffHeapIndex\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = and(greaterThan(Car.PRICE, 4000.0), equal(Car.MANUFACTURER, \"Ford\"));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            retrievalCost = 65;\r\n                            mergeCost = 2;\r\n                            size = 2;\r\n                            carIdsAnyOrder = asSet(0, 2);\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(PartialOffHeapIndex.onAttributeWithFilterQuery(Car.PRICE, equal(Car.MANUFACTURER, \"Ford\"))));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"retrieval cost with PartialDiskIndex\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = and(greaterThan(Car.PRICE, 4000.0), equal(Car.MANUFACTURER, \"Ford\"));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            retrievalCost = 85;\r\n                            mergeCost = 2;\r\n                            size = 2;\r\n                            carIdsAnyOrder = asSet(0, 2);\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(PartialDiskIndex.onAttributeWithFilterQuery(Car.PRICE, equal(Car.MANUFACTURER, \"Ford\"))));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"string queries 1\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class, TransactionalIndexedCollection.class);\r\n            queriesToEvaluate = asList(new QueryToEvaluate() {\r\n                {\r\n                    query = startsWith(Car.MANUFACTURER, \"For\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            mergeCost = 3;\r\n                            carIdsAnyOrder = asSet(0, 1, 2);\r\n                            indexUsed = true;\r\n                            containsCarIds = asSet(1);\r\n                            doesNotContainCarIds = asSet(5, 8);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.MANUFACTURER, \"Ford\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            mergeCost = 3;\r\n                            carIdsAnyOrder = asSet(0, 1, 2);\r\n                            indexUsed = true;\r\n                            containsCarIds = asSet(1);\r\n                            doesNotContainCarIds = asSet(5, 8);\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(RadixTreeIndex.onAttribute(Car.MANUFACTURER)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"string queries 2\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class, TransactionalIndexedCollection.class);\r\n            queriesToEvaluate = asList(new QueryToEvaluate() {\r\n                {\r\n                    query = endsWith(Car.MANUFACTURER, \"ord\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            mergeCost = 3;\r\n                            carIdsAnyOrder = asSet(0, 1, 2);\r\n                            indexUsed = true;\r\n                            containsCarIds = asSet(1);\r\n                            doesNotContainCarIds = asSet(5, 8);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.MANUFACTURER, \"Ford\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            mergeCost = 3;\r\n                            carIdsAnyOrder = asSet(0, 1, 2);\r\n                            indexUsed = true;\r\n                            containsCarIds = asSet(1);\r\n                            doesNotContainCarIds = asSet(5, 8);\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(ReversedRadixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(SuffixTreeIndex.onAttribute(Car.MANUFACTURER)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"string queries 3\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class, TransactionalIndexedCollection.class);\r\n            queriesToEvaluate = asList(new QueryToEvaluate() {\r\n                {\r\n                    query = contains(Car.MANUFACTURER, \"on\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            mergeCost = 3;\r\n                            carIdsAnyOrder = asSet(3, 4, 5);\r\n                            indexUsed = true;\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.MANUFACTURER, \"Ford\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            mergeCost = 3;\r\n                            carIdsAnyOrder = asSet(0, 1, 2);\r\n                            indexUsed = true;\r\n                            containsCarIds = asSet(1);\r\n                            doesNotContainCarIds = asSet(5, 8);\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(SuffixTreeIndex.onAttribute(Car.MANUFACTURER)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"ordering\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class);\r\n            queriesToEvaluate = asList(new QueryToEvaluate() {\r\n                {\r\n                    query = in(Car.MANUFACTURER, \"Ford\", \"Toyota\");\r\n                    queryOptions = queryOptions(orderBy(descending(Car.MANUFACTURER), ascending(Car.CAR_ID)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 6;\r\n                            carIdsInOrder = asList(6, 7, 8, 0, 1, 2);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = all(Car.class);\r\n                    queryOptions = queryOptions(orderBy(ascending(Car.FEATURES), descending(Car.CAR_ID)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 10;\r\n                            carIdsInOrder = asList(8, 6, 5, 0, 9, 2, 3, 4, 1, 7);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = all(Car.class);\r\n                    queryOptions = queryOptions(orderBy(ascending(missingLast(Car.FEATURES)), descending(Car.CAR_ID)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 10;\r\n                            carIdsInOrder = asList(9, 2, 3, 4, 1, 7, 8, 6, 5, 0);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = all(Car.class);\r\n                    queryOptions = queryOptions(orderBy(descending(Car.FEATURES), descending(Car.CAR_ID)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 10;\r\n                            carIdsInOrder = asList(7, 1, 4, 3, 2, 9, 8, 6, 5, 0);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = all(Car.class);\r\n                    queryOptions = queryOptions(orderBy(descending(missingFirst(Car.FEATURES)), descending(Car.CAR_ID)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 10;\r\n                            carIdsInOrder = asList(8, 6, 5, 0, 7, 1, 4, 3, 2, 9);\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(noIndexes(), indexCombination(NavigableIndex.onAttribute(Car.CAR_ID), NavigableIndex.onAttribute(Car.FEATURES), NavigableIndex.onAttribute(forObjectsMissing(Car.FEATURES))));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"index ordering\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class, TransactionalIndexedCollection.class);\r\n            queriesToEvaluate = asList(new QueryToEvaluate() {\r\n                {\r\n                    query = all(Car.class);\r\n                    queryOptions = queryOptions(orderBy(ascending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 10;\r\n                            carIdsInOrder = asList(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.CAR_ID, 4, 6);\r\n                    queryOptions = queryOptions(orderBy(ascending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            carIdsInOrder = asList(4, 5, 6);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = lessThan(Car.CAR_ID, 6);\r\n                    queryOptions = queryOptions(orderBy(ascending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 6;\r\n                            carIdsInOrder = asList(0, 1, 2, 3, 4, 5);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = lessThanOrEqualTo(Car.CAR_ID, 6);\r\n                    queryOptions = queryOptions(orderBy(ascending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 7;\r\n                            carIdsInOrder = asList(0, 1, 2, 3, 4, 5, 6);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = greaterThan(Car.CAR_ID, 3);\r\n                    queryOptions = queryOptions(orderBy(ascending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 6;\r\n                            carIdsInOrder = asList(4, 5, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = greaterThanOrEqualTo(Car.CAR_ID, 3);\r\n                    queryOptions = queryOptions(orderBy(ascending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 7;\r\n                            carIdsInOrder = asList(3, 4, 5, 6, 7, 8, 9);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = all(Car.class);\r\n                    queryOptions = queryOptions(orderBy(descending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 10;\r\n                            carIdsInOrder = asList(9, 8, 7, 6, 5, 4, 3, 2, 1, 0);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.CAR_ID, 4, 6);\r\n                    queryOptions = queryOptions(orderBy(descending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            carIdsInOrder = asList(6, 5, 4);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = lessThan(Car.CAR_ID, 6);\r\n                    queryOptions = queryOptions(orderBy(descending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 6;\r\n                            carIdsInOrder = asList(5, 4, 3, 2, 1, 0);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = lessThanOrEqualTo(Car.CAR_ID, 6);\r\n                    queryOptions = queryOptions(orderBy(descending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 7;\r\n                            carIdsInOrder = asList(6, 5, 4, 3, 2, 1, 0);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = greaterThan(Car.CAR_ID, 3);\r\n                    queryOptions = queryOptions(orderBy(descending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 6;\r\n                            carIdsInOrder = asList(9, 8, 7, 6, 5, 4);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = greaterThanOrEqualTo(Car.CAR_ID, 3);\r\n                    queryOptions = queryOptions(orderBy(descending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 7;\r\n                            carIdsInOrder = asList(9, 8, 7, 6, 5, 4, 3);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = and(greaterThanOrEqualTo(Car.CAR_ID, 3), lessThanOrEqualTo(Car.CAR_ID, 6));\r\n                    queryOptions = queryOptions(orderBy(descending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 4;\r\n                            carIdsInOrder = asList(6, 5, 4, 3);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = or(greaterThanOrEqualTo(Car.CAR_ID, 7), none(Car.class));\r\n                    queryOptions = queryOptions(orderBy(descending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            carIdsInOrder = asList(9, 8, 7);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = and(or(greaterThanOrEqualTo(Car.CAR_ID, 7), none(Car.class)), or(all(Car.class), none(Car.class)));\r\n                    queryOptions = queryOptions(orderBy(descending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            carIdsInOrder = asList(9, 8, 7);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = and(equal(Car.CAR_ID, 8), all(Car.class));\r\n                    queryOptions = queryOptions(orderBy(ascending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 1;\r\n                            carIdsInOrder = singletonList(8);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = all(Car.class);\r\n                    queryOptions = queryOptions(orderBy(ascending(Car.FEATURES), ascending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 10;\r\n                            carIdsInOrder = asList(0, 5, 6, 8, 9, 2, 3, 4, 1, 7);\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = all(Car.class);\r\n                    queryOptions = queryOptions(orderBy(descending(Car.FEATURES), ascending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 10;\r\n                            carIdsInOrder = asList(7, 1, 4, 3, 2, 9, 0, 5, 6, 8);\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(NavigableIndex.onAttribute(Car.CAR_ID), NavigableIndex.onAttribute(Car.FEATURES), NavigableIndex.onAttribute(forObjectsMissing(Car.FEATURES))), indexCombination(OffHeapIndex.onAttribute(Car.CAR_ID)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"index ordering strategy selection\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class);\r\n            queriesToEvaluate = asList(new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.CAR_ID, 4, 6);\r\n                    queryOptions = queryOptions(orderBy(ascending(Car.MANUFACTURER), descending(Car.PRICE)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 0.8)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            carIdsInOrder = asList(5, 4, 6);\r\n                            containsQueryLogMessages = asList(\"querySelectivity: 0.7\", \"orderingStrategy: index\");\r\n                        }\r\n                    };\r\n                }\r\n            }, new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.CAR_ID, 4, 6);\r\n                    queryOptions = queryOptions(orderBy(ascending(Car.MANUFACTURER), descending(Car.PRICE)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 0.6)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            carIdsInOrder = asList(5, 4, 6);\r\n                            containsQueryLogMessages = asList(\"querySelectivity: 0.7\", \"orderingStrategy: materialize\");\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(NavigableIndex.onAttribute(Car.CAR_ID), NavigableIndex.onAttribute(Car.MANUFACTURER), NavigableIndex.onAttribute(Car.PRICE)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"index ordering strategy selection - negative\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class);\r\n            queriesToEvaluate = asList(new QueryToEvaluate() {\r\n                {\r\n                    query = between(Car.CAR_ID, 4, 6);\r\n                    queryOptions = queryOptions(orderBy(descending(Car.CAR_ID)), applyThresholds(threshold(INDEX_ORDERING_SELECTIVITY, 1.0)));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 3;\r\n                            carIdsInOrder = asList(6, 5, 4);\r\n                            containsQueryLogMessages = singletonList(\"orderingStrategy: materialize\");\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(NavigableIndex.withQuantizerOnAttribute(IntegerQuantizer.withCompressionFactor(5), Car.CAR_ID)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"remove objects\";\r\n            dataSet = REGULAR_DATASET;\r\n            removeDataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class, TransactionalIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.MANUFACTURER, \"Ford\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 297;\r\n                            doesNotContainCarIds = asSet(0, 1, 2);\r\n                            containsCarIds = asSet(10, 11, 12);\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(noIndexes(), indexCombination(UniqueIndex.onAttribute(Car.CAR_ID)), indexCombination(HashIndex.onAttribute(Car.MANUFACTURER)), indexCombination(NavigableIndex.onAttribute(Car.MANUFACTURER)), indexCombination(RadixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(ReversedRadixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(InvertedRadixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(SuffixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(OffHeapIndex.onAttribute(Car.MANUFACTURER)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"clear objects\";\r\n            dataSet = REGULAR_DATASET;\r\n            clearDataSet = true;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class, ObjectLockingIndexedCollection.class, TransactionalIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = equal(Car.MANUFACTURER, \"Ford\");\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 0;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(noIndexes(), indexCombination(UniqueIndex.onAttribute(Car.CAR_ID)), indexCombination(HashIndex.onAttribute(Car.MANUFACTURER)), indexCombination(NavigableIndex.onAttribute(Car.MANUFACTURER)), indexCombination(RadixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(ReversedRadixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(InvertedRadixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(SuffixTreeIndex.onAttribute(Car.MANUFACTURER)), indexCombination(OffHeapIndex.onAttribute(Car.MANUFACTURER)));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"standing query index\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = or(equal(Car.MANUFACTURER, \"Ford\"), equal(Car.COLOR, Car.Color.BLUE));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 5;\r\n                            retrievalCost = 10;\r\n                            mergeCost = 5;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(StandingQueryIndex.onQuery(or(equal(Car.MANUFACTURER, \"Ford\"), equal(Car.COLOR, Car.Color.BLUE)))));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"HashIndex on standing query\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = or(equal(Car.MANUFACTURER, \"Ford\"), equal(Car.COLOR, Car.Color.BLUE));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 5;\r\n                            retrievalCost = 30;\r\n                            mergeCost = 5;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(HashIndex.onAttribute(forStandingQuery(or(equal(Car.MANUFACTURER, \"Ford\"), equal(Car.COLOR, Car.Color.BLUE))))));\r\n        }\r\n    }, new MacroScenario() {\r\n        {\r\n            name = \"OffHeapIndex on standing query\";\r\n            dataSet = SMALL_DATASET;\r\n            collectionImplementations = classes(ConcurrentIndexedCollection.class);\r\n            queriesToEvaluate = singletonList(new QueryToEvaluate() {\r\n                {\r\n                    query = or(equal(Car.MANUFACTURER, \"Ford\"), equal(Car.COLOR, Car.Color.BLUE));\r\n                    expectedResults = new ExpectedResults() {\r\n                        {\r\n                            size = 5;\r\n                            retrievalCost = 70;\r\n                            mergeCost = 5;\r\n                        }\r\n                    };\r\n                }\r\n            });\r\n            indexCombinations = indexCombinations(indexCombination(OffHeapIndex.onAttribute(forStandingQuery(or(equal(Car.MANUFACTURER, \"Ford\"), equal(Car.COLOR, Car.Color.BLUE))))));\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.googlecode.cqengine.IndexedCollectionFunctionalTest.getMacroScenarios",
	"Comment": "this allows to run the same set of queries with different combinations of indexes etc.",
	"Method": "List<MacroScenario> getMacroScenarios(){\r\n    Iterator<Object> tupleValues = tuple.getAttributeValues().iterator();\r\n    String manufacturer = (String) tupleValues.next();\r\n    String model = (String) tupleValues.next();\r\n    String quantizedModel = \"Focus\".equals(model) ? \"Focus\" : \"Other\";\r\n    return new CompoundValueTuple<Car>(Arrays.asList(manufacturer, quantizedModel));\r\n}"
}, {
	"Path": "com.haulmont.cuba.restapi.JSONConverter.checkCollectionItemTypes",
	"Comment": "checks that all collection items are instances of given class",
	"Method": "boolean checkCollectionItemTypes(Collection collection,Class<?> itemClass){\r\n    for (Object collectionItem : collection) {\r\n        if (!itemClass.isAssignableFrom(collectionItem.getClass()))\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.MessageTools.getPropertyCaption",
	"Comment": "get localized name of an entity property. messages pack must be located in the same package as entity.",
	"Method": "String getPropertyCaption(MetaClass metaClass,String propertyName,String getPropertyCaption,MetaClass metaClass,String propertyName,Locale locale,String getPropertyCaption,MetaProperty property,String getPropertyCaption,MetaProperty property,Locale locale){\r\n    Class<?> declaringClass = property.getDeclaringClass();\r\n    if (declaringClass == null) {\r\n        return property.getName();\r\n    }\r\n    String className = declaringClass.getSimpleName();\r\n    if (locale == null) {\r\n        return messages.getMessage(declaringClass, className + \".\" + property.getName());\r\n    }\r\n    return messages.getMessage(declaringClass, className + \".\" + property.getName(), locale);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.ComponentGenerationContext.setXmlDescriptor",
	"Comment": "sets an xml descriptor which contains additional information, using fluent api method.",
	"Method": "ComponentGenerationContext setXmlDescriptor(Element xmlDescriptor){\r\n    this.xmlDescriptor = xmlDescriptor;\r\n    return this;\r\n}"
}, {
	"Path": "name.fraser.neil.plaintext.diff_match_patch.diff_charsToLines",
	"Comment": "rehydrate the text in a diff from a string of line hashes to real lines oftext.",
	"Method": "void diff_charsToLines(LinkedList<Diff> diffs,List<String> lineArray){\r\n    StringBuilder text;\r\n    for (Diff diff : diffs) {\r\n        text = new StringBuilder();\r\n        for (int y = 0; y < diff.text.length(); y++) {\r\n            text.append(lineArray.get(diff.text.charAt(y)));\r\n        }\r\n        diff.text = text.toString();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.config.type.TypeStringify.getInstance",
	"Comment": "get a typestringify instance appropriate for the parameter type of thespecified configuration interface method.",
	"Method": "TypeStringify getInstance(Class<?> configInterface,Method method){\r\n    Class<?> methodType = ConfigUtil.getMethodType(method);\r\n    try {\r\n        Stringify stringify = ConfigUtil.getAnnotation(configInterface, method, Stringify.class, true);\r\n        if (stringify != null) {\r\n            if (\"\".equals(stringify.method())) {\r\n                return stringify.stringify().newInstance();\r\n            } else {\r\n                String methodName = stringify.method();\r\n                return new MethodTypeStringify(methodType.getMethod(methodName));\r\n            }\r\n        } else {\r\n            if ((method.getParameterTypes().length > 0)) {\r\n                if (Entity.class.isAssignableFrom(method.getParameterTypes()[0])) {\r\n                    return new EntityStringify();\r\n                }\r\n            }\r\n            if (EnumClass.class.isAssignableFrom(methodType)) {\r\n                EnumStore mode = ConfigUtil.getAnnotation(configInterface, method, EnumStore.class, true);\r\n                if (mode != null && EnumStoreMode.ID == mode.value()) {\r\n                    @SuppressWarnings(\"unchecked\")\r\n                    Class<EnumClass> enumeration = (Class<EnumClass>) methodType;\r\n                    TypeStringify idStringify = getInferred(ConfigUtil.getEnumIdType(enumeration));\r\n                    return new EnumClassStringify(idStringify);\r\n                }\r\n            }\r\n            return getInferred(methodType);\r\n        }\r\n    } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | RuntimeException e) {\r\n        throw new RuntimeException(\"Type stringify error\", e);\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.restapi.config.RestQueriesConfiguration.getQuery",
	"Comment": "returns a query description with the given name for the given entity.",
	"Method": "QueryInfo getQuery(String entityName,String queryName){\r\n    lock.readLock().lock();\r\n    try {\r\n        checkInitialized();\r\n        if (ALL_ENTITIES_QUERY_NAME.equalsIgnoreCase(queryName)) {\r\n            return createAllEntitiesQuery(entityName);\r\n        }\r\n        for (QueryInfo query : queries) {\r\n            if (queryName.equals(query.getName()) && entityName.equals(query.getEntityName())) {\r\n                return query;\r\n            }\r\n        }\r\n        return null;\r\n    } finally {\r\n        lock.readLock().unlock();\r\n    }\r\n}"
}, {
	"Path": "com.cv4j.core.binary.TopHat.process",
	"Comment": "top hat is difference between original binary and morphology open on it",
	"Method": "void process(ByteProcessor binary,Size structureElement){\r\n    int width = binary.getWidth();\r\n    int height = binary.getHeight();\r\n    byte[] data = new byte[width * height];\r\n    System.arraycopy(binary.getGray(), 0, data, 0, data.length);\r\n    MorphOpen open = new MorphOpen();\r\n    open.process(binary, structureElement);\r\n    byte[] output = binary.getGray();\r\n    int c = 0;\r\n    for (int i = 0; i < data.length; i++) {\r\n        c = (data[i] & 0xff - output[i] & 0xff);\r\n        output[i] = (byte) ((c > 0) ? 255 : 0);\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.screen.Screen.setId",
	"Comment": "sets id of the screen. called by the framework during screen init to assign screen id.",
	"Method": "void setId(String id){\r\n    this.id = id;\r\n}"
}, {
	"Path": "org.crsh.telnet.term.console.TermIOBuffer.appendData",
	"Comment": "append a char at the current cursor position and increment the cursor position.",
	"Method": "boolean appendData(CharSequence s,int start,int end,boolean appendData,char c){\r\n    if (previousCR && c == '\\n') {\r\n        previousCR = false;\r\n        return false;\r\n    } else if (c == '\\r' || c == '\\n') {\r\n        previousCR = c == '\\r';\r\n        String line = new String(buffer, 0, size);\r\n        lines.add(line);\r\n        size = 0;\r\n        curAt = size;\r\n        return echoCRLF();\r\n    } else {\r\n        if (push(c)) {\r\n            return echo(c);\r\n        } else {\r\n            String disp = new String(buffer, curAt, size - curAt);\r\n            io.write(disp);\r\n            int amount = size - curAt - 1;\r\n            curAt++;\r\n            while (amount > 0) {\r\n                io.moveLeft();\r\n                amount--;\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.cqengine.examples.replace.Car.equals",
	"Comment": "implement equals, to return true only if carids are equal and version fields are equal",
	"Method": "boolean equals(Object o){\r\n    if (this == o)\r\n        return true;\r\n    if (!(o instanceof Car))\r\n        return false;\r\n    Car other = (Car) o;\r\n    return this.carId == other.carId && this.version == other.version;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.ComponentGenerationContext.setMetaClass",
	"Comment": "sets the entity for which the component is created, using fluent api method.",
	"Method": "ComponentGenerationContext setMetaClass(MetaClass metaClass){\r\n    this.metaClass = metaClass;\r\n    return this;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.query.parser.cqn.support.CQNAntlrListener.addParsedQuery",
	"Comment": "adds the given query to a list of child queries which have not yet been wrapped in a parent query.",
	"Method": "void addParsedQuery(ParserRuleContext currentContext,Query<O> parsedQuery){\r\n    ParserRuleContext parentContext = getParentContextOfType(currentContext, getAndOrNotContextClasses());\r\n    Collection<Query<O>> childrenOfParent = this.childQueries.get(parentContext);\r\n    if (childrenOfParent == null) {\r\n        childrenOfParent = new ArrayList<Query<O>>();\r\n        this.childQueries.put(parentContext, childrenOfParent);\r\n    }\r\n    childrenOfParent.add(parsedQuery);\r\n    numQueriesParsed++;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.filter.FilterDelegateImpl.loadFiltersAndApplyDefault",
	"Comment": "loads filter entities, finds default filter and applies it if found",
	"Method": "void loadFiltersAndApplyDefault(){\r\n    initShortcutActions();\r\n    initAdHocFilter();\r\n    loadFilterEntities();\r\n    FilterEntity defaultFilter = getDefaultFilter(filterEntities);\r\n    initFilterSelectComponents();\r\n    if (defaultFilter == null) {\r\n        defaultFilter = adHocFilter;\r\n    }\r\n    try {\r\n        setFilterEntity(defaultFilter);\r\n    } catch (Exception e) {\r\n        log.error(\"Exception on loading default filter '{}'\", defaultFilter.getName(), e);\r\n        windowManager.showNotification(messages.formatMainMessage(\"filter.errorLoadingDefaultFilter\", defaultFilter.getName()), Frame.NotificationType.ERROR);\r\n        defaultFilter = adHocFilter;\r\n        setFilterEntity(adHocFilter);\r\n    }\r\n    if (defaultFilter != adHocFilter && (filterMode == FilterMode.GENERIC_MODE)) {\r\n        Window window = getWindow();\r\n        if (!WindowParams.DISABLE_AUTO_REFRESH.getBool(window.getContext())) {\r\n            if (getResultingManualApplyRequired()) {\r\n                if (BooleanUtils.isTrue(defaultFilter.getApplyDefault())) {\r\n                    adapter.preventNextDataLoading();\r\n                    apply(true);\r\n                }\r\n            } else {\r\n                adapter.preventNextDataLoading();\r\n                apply(true);\r\n            }\r\n            if (filterEntity != null) {\r\n                window.setDescription(getFilterCaption(filterEntity));\r\n            } else\r\n                window.setDescription(null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.gui.components.DesktopAbstractTable.getPreferredRowHeight",
	"Comment": "returns the preferred height of a row.the result is equal to the tallest cell in the row.",
	"Method": "int getPreferredRowHeight(int rowIndex){\r\n    int height = impl.getRowHeight();\r\n    for (int c = 0; c < impl.getColumnCount(); c++) {\r\n        TableCellRenderer renderer = impl.getCellRenderer(rowIndex, c);\r\n        Component comp = impl.prepareRenderer(renderer, rowIndex, c);\r\n        int componentHeight = comp.getPreferredSize().height;\r\n        height = Math.max(height, componentHeight);\r\n    }\r\n    return height;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.MetadataTools.getCrossDataStoreReferenceIdProperty",
	"Comment": "if the given property is a reference to an entity from different data store, returns the name of a persistentproperty which stores the identifier of the related entity.",
	"Method": "String getCrossDataStoreReferenceIdProperty(String thisStore,MetaProperty metaProperty){\r\n    checkNotNullArgument(metaProperty, \"metaProperty is null\");\r\n    if (!metaProperty.getRange().isClass())\r\n        return null;\r\n    String propStore = getStoreName(metaProperty.getRange().asClass());\r\n    if (Objects.equals(thisStore, propStore))\r\n        return null;\r\n    List<String> relatedProperties = getRelatedProperties(metaProperty);\r\n    if (relatedProperties.size() == 1)\r\n        return relatedProperties.get(0);\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.data.impl.CollectionPropertyDatasourceImpl.sort",
	"Comment": "implementation of collectiondatasource.sortable interface",
	"Method": "void sort(SortInfo[] sortInfos){\r\n    if (sortInfos.length != 1) {\r\n        throw new UnsupportedOperationException(\"Supporting sort by one field only\");\r\n    }\r\n    this.sortInfos = sortInfos;\r\n    doSort();\r\n    fireCollectionChanged(Operation.REFRESH, Collections.emptyList());\r\n}"
}, {
	"Path": "com.cronutils.utils.Preconditions.checkNotNull",
	"Comment": "ensures that an object reference passed as a parameter to the calling method is not null.",
	"Method": "T checkNotNull(T reference,T checkNotNull,T reference,Object errorMessage){\r\n    if (reference == null) {\r\n        throw new NullPointerException(String.valueOf(errorMessage));\r\n    }\r\n    return reference;\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.gui.components.DesktopWindow.getEventRouter",
	"Comment": "use eventrouter for listeners instead of fields with listeners list.",
	"Method": "EventRouter getEventRouter(){\r\n    if (eventRouter == null) {\r\n        eventRouter = new EventRouter();\r\n    }\r\n    return eventRouter;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.AbstractFrame.formatMessage",
	"Comment": "get localized message from the message pack associated with this frame or window, and use it as a formatstring for parameters provided.",
	"Method": "String formatMessage(String key,Object params){\r\n    String msgPack = getMessagesPack();\r\n    if (StringUtils.isEmpty(msgPack)) {\r\n        throw new DevelopmentException(\"MessagePack is not set\");\r\n    }\r\n    return messages.formatMessage(msgPack, key, params);\r\n}"
}, {
	"Path": "com.cronutils.descriptor.NominalDescriptionStrategy.addDescription",
	"Comment": "allows to provide a specific description to handle a cronfieldexpression instance.",
	"Method": "NominalDescriptionStrategy addDescription(Function<FieldExpression, String> desc){\r\n    descriptions.add(desc);\r\n    return this;\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.stream.publisher.PublisherIterable.complete",
	"Comment": "calls onsubscribe on the target subscriber with the zero instance followed by a call to oncomplete.",
	"Method": "void complete(Subscriber<?> s){\r\n    s.onSubscribe(EmptySubscription.INSTANCE);\r\n    s.onComplete();\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.DDHorizontalLayout.getDropHandler",
	"Comment": "returns the drop handler which handles drop events from droppingcomponents on the layout. returns null if dropping is disabled.",
	"Method": "DropHandler getDropHandler(){\r\n    return dropHandler;\r\n}"
}, {
	"Path": "org.crsh.plugin.Embedded.createConfFS",
	"Comment": "create the conf file system from the crash.mountpointconfig.conf servlet context parameter.",
	"Method": "FS createConfFS(){\r\n    return createFS(resolveConfMountPointConfig());\r\n}"
}, {
	"Path": "name.fraser.neil.plaintext.diff_match_patch.patch_deepCopy",
	"Comment": "given an array of patches, return another array that is identical.",
	"Method": "LinkedList<Patch> patch_deepCopy(LinkedList<Patch> patches){\r\n    LinkedList<Patch> patchesCopy = new LinkedList<Patch>();\r\n    for (Patch aPatch : patches) {\r\n        Patch patchCopy = new Patch();\r\n        for (Diff aDiff : aPatch.diffs) {\r\n            Diff diffCopy = new Diff(aDiff.operation, aDiff.text);\r\n            patchCopy.diffs.add(diffCopy);\r\n        }\r\n        patchCopy.start1 = aPatch.start1;\r\n        patchCopy.start2 = aPatch.start2;\r\n        patchCopy.length1 = aPatch.length1;\r\n        patchCopy.length2 = aPatch.length2;\r\n        patchesCopy.add(patchCopy);\r\n    }\r\n    return patchesCopy;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.data.impl.AbstractDatasource.getEventRouter",
	"Comment": "use eventrouter for listeners instead of fields with listeners list.",
	"Method": "EventRouter getEventRouter(){\r\n    if (eventRouter == null) {\r\n        eventRouter = new EventRouter();\r\n    }\r\n    return eventRouter;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.DDAccordion.setDropHandler",
	"Comment": "sets the current handler which handles dropped components on the layout.by setting a drop handler dropping components on the layout is enabled.by setting the drophandler to null dropping is disabled.",
	"Method": "void setDropHandler(DropHandler dropHandler){\r\n    DDUtil.verifyHandlerType(this, dropHandler);\r\n    if (this.dropHandler != dropHandler) {\r\n        this.dropHandler = dropHandler;\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.entity.IdProxy.copy",
	"Comment": "returns a copy of this idproxy cleaned from a reference to entity.",
	"Method": "IdProxy<T> copy(IdProxy<T> copy,boolean shared){\r\n    if (copy == null || !shared || !Objects.equals(value, copy.value) || !Objects.equals(uuid, copy.uuid) || (copy.value == null && entity != null && entity.getDbGeneratedId() != null)) {\r\n        copy = new IdProxy();\r\n        if (value != null)\r\n            copy.value = value;\r\n        else if (entity != null && entity.getDbGeneratedId() != null)\r\n            copy.value = entity.getDbGeneratedId();\r\n        copy.uuid = uuid;\r\n        copy.hashCode = hashCode;\r\n    }\r\n    return copy;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.screen.ScreenFragment.setId",
	"Comment": "sets id of the screen fragment. called by the framework during screen init to assign screen id.",
	"Method": "void setId(String id){\r\n    this.id = id;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.v7.ui.horizontallayout.VDDHorizontalLayout.setDropHandler",
	"Comment": "creates a drop handler if one does not already exist and updates it fromthe details received from the server.",
	"Method": "void setDropHandler(VDDHorizontalLayoutDropHandler dropHandler){\r\n    this.dropHandler = dropHandler;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.actions.ListAction.withPrimary",
	"Comment": "set whether this action is primary using fluent api method. can be used instead of subclassing baseaction class.",
	"Method": "ListAction withPrimary(boolean primary){\r\n    this.primary = primary;\r\n    return this;\r\n}"
}, {
	"Path": "org.crsh.console.EditorBuffer.replace",
	"Comment": "replace all the characters before the cursor by the provided char sequence.",
	"Method": "String replace(CharSequence s){\r\n    StringBuilder builder = new StringBuilder();\r\n    for (int i = appendDel(); i != -1; i = appendDel()) {\r\n        builder.append((char) i);\r\n        needFlush = true;\r\n    }\r\n    appendData(s, 0, s.length());\r\n    return builder.reverse().toString();\r\n}"
}, {
	"Path": "org.crsh.util.Utils.toFile",
	"Comment": "convert an file url to a file, avoids issues on windows with whitespaces.",
	"Method": "File toFile(URL url){\r\n    if (url == null) {\r\n        throw new NullPointerException(\"No null URL accepted\");\r\n    }\r\n    if (!url.getProtocol().equals(\"file\")) {\r\n        throw new IllegalArgumentException(\"Not file protocol\");\r\n    }\r\n    try {\r\n        return new File(url.toURI());\r\n    } catch (URISyntaxException e) {\r\n        return new File(url.getPath());\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.DateTimeTransformations.transformToLocalTime",
	"Comment": "obtains an instance of localtimefrom time or date or localtime or offsettime",
	"Method": "LocalTime transformToLocalTime(Object date){\r\n    Preconditions.checkNotNull(date);\r\n    if (date instanceof java.sql.Time) {\r\n        return ((java.sql.Time) date).toLocalTime();\r\n    } else if (date instanceof Date) {\r\n        return ((Date) date).toInstant().atZone(ZoneId.systemDefault()).toLocalTime();\r\n    } else if (date instanceof LocalTime) {\r\n        return (LocalTime) date;\r\n    } else if (date instanceof OffsetTime) {\r\n        return ((OffsetTime) date).toLocalTime();\r\n    }\r\n    throw newUnsupportedTypeException(date.getClass());\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.v7.ui.verticallayout.VDDVerticalLayout.updateDragDetails",
	"Comment": "updates the drop details while dragging. this is needed to ensure clientside criterias can validate the drop location.",
	"Method": "void updateDragDetails(Widget widget,VDragEvent event){\r\n    if (widget == null) {\r\n        return;\r\n    }\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_VERTICAL_DROP_LOCATION, getVerticalDropLocation(widget, event));\r\n    int index = -1;\r\n    if (widget instanceof Slot) {\r\n        WidgetCollection captionsAndSlots = getChildren();\r\n        index = VDragDropUtil.findSlotIndex(captionsAndSlots, (Slot) widget);\r\n    }\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_TO, index);\r\n    MouseEventDetails details = MouseEventDetailsBuilder.buildMouseEventDetails(event.getCurrentGwtEvent(), getElement());\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_MOUSE_EVENT, details.serialize());\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.aceeditor.AceEditor.addMarker",
	"Comment": "adds an ace marker with a generated id. the id is unique within this\teditor.",
	"Method": "String addMarker(AceMarker marker,String addMarker,AceRange range,String cssClass,Type type,boolean inFront,OnTextChange onChange){\r\n    return addMarker(new AceMarker(newMarkerId(), range, cssClass, type, inFront, onChange));\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.v7.DDVerticalLayout.setDropHandler",
	"Comment": "sets the current handler which handles dropped components on the layout.by setting a drop handler dropping components on the layout is enabled.by setting the drophandler to null dropping is disabled.",
	"Method": "void setDropHandler(DropHandler dropHandler){\r\n    DDUtil.verifyHandlerType(this, dropHandler);\r\n    if (this.dropHandler != dropHandler) {\r\n        this.dropHandler = dropHandler;\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.MetadataLoader.guessDatatypeId",
	"Comment": "guesses id for a datatype registered in legacy datatypes.xml file.for backward compatibility only.",
	"Method": "String guessDatatypeId(Datatype datatype){\r\n    if (datatype instanceof BigDecimalDatatype)\r\n        return \"decimal\";\r\n    if (datatype instanceof BooleanDatatype)\r\n        return \"boolean\";\r\n    if (datatype instanceof ByteArrayDatatype)\r\n        return \"byteArray\";\r\n    if (datatype instanceof DateDatatype)\r\n        return \"date\";\r\n    if (datatype instanceof DateTimeDatatype)\r\n        return \"dateTime\";\r\n    if (datatype instanceof DoubleDatatype)\r\n        return \"double\";\r\n    if (datatype instanceof IntegerDatatype)\r\n        return \"int\";\r\n    if (datatype instanceof LongDatatype)\r\n        return \"long\";\r\n    if (datatype instanceof StringDatatype)\r\n        return \"string\";\r\n    if (datatype instanceof TimeDatatype)\r\n        return \"time\";\r\n    if (datatype instanceof UUIDDatatype)\r\n        return \"uuid\";\r\n    try {\r\n        Field nameField = datatype.getClass().getField(\"NAME\");\r\n        if (Modifier.isStatic(nameField.getModifiers()) && nameField.isAccessible()) {\r\n            return (String) nameField.get(null);\r\n        }\r\n    } catch (Exception e) {\r\n        log.trace(\"Cannot get NAME static field value: {}\", e);\r\n    }\r\n    throw new IllegalStateException(\"Cannot guess id for datatype \" + datatype);\r\n}"
}, {
	"Path": "org.crsh.cli.impl.invocation.ParameterMatch.computeValue",
	"Comment": "compute the value from the parameter metadata and the values list.",
	"Method": "Object computeValue(){\r\n    List<String> strings = getStrings();\r\n    return parameter.parse(strings);\r\n}"
}, {
	"Path": "com.haulmont.restapi.controllers.FileUploadController.uploadFile",
	"Comment": "method for simple file upload. file contents are placed in the request body. optional file name parameter ispassed as a query param.",
	"Method": "ResponseEntity<FileInfo> uploadFile(HttpServletRequest request,String name,ResponseEntity<FileInfo> uploadFile,MultipartFile file,String name,HttpServletRequest request){\r\n    try {\r\n        if (Strings.isNullOrEmpty(name)) {\r\n            name = file.getOriginalFilename();\r\n        }\r\n        long size = file.getSize();\r\n        FileDescriptor fd = createFileDescriptor(name, size);\r\n        InputStream is = file.getInputStream();\r\n        uploadToMiddleware(is, fd);\r\n        saveFileDescriptor(fd);\r\n        return createFileInfoResponseEntity(request, fd);\r\n    } catch (Exception e) {\r\n        log.error(\"File upload failed\", e);\r\n        throw new RestAPIException(\"File upload failed\", \"File upload failed\", HttpStatus.INTERNAL_SERVER_ERROR, e);\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.exception.AbstractExceptionHandler.canHandle",
	"Comment": "should be implemented in subclasses if the exception class name is not enough to determine the ability tohandle the exception.",
	"Method": "boolean canHandle(String className,String message,Throwable throwable){\r\n    return true;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.View.containsProperty",
	"Comment": "check if a directly owned property with the given name exists in the view.",
	"Method": "boolean containsProperty(String name){\r\n    return properties.containsKey(name);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.MarginInfo.hasBottom",
	"Comment": "checks if this margininfo object has the bottom edge margin enabled.",
	"Method": "boolean hasBottom(){\r\n    return (bitMask & BOTTOM) == BOTTOM;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.App.initExceptionHandlers",
	"Comment": "initializes exception handlers immediately after login and logout.can be overridden in descendants to manipulate exception handlers programmatically.",
	"Method": "void initExceptionHandlers(boolean isConnected){\r\n    if (isConnected) {\r\n        exceptionHandlers.createByConfiguration();\r\n    } else {\r\n        exceptionHandlers.removeAll();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.app.core.entityinspector.EntityInspectorEditor.addField",
	"Comment": "adds field to the specified field group.if the field should be custom, adds it to the specified customfields collectionwhich can be used later to create fieldgenerators",
	"Method": "void addField(MetaClass metaClass,MetaProperty metaProperty,Entity item,FieldGroup fieldGroup,boolean required,boolean custom,boolean readOnly,Collection<FieldGroup.FieldConfig> customFields){\r\n    if (!attrViewPermitted(metaClass, metaProperty))\r\n        return;\r\n    if ((metaProperty.getType() == MetaProperty.Type.COMPOSITION || metaProperty.getType() == MetaProperty.Type.ASSOCIATION) && !entityOpPermitted(metaProperty.getRange().asClass(), EntityOp.READ))\r\n        return;\r\n    FieldGroup.FieldConfig field = fieldGroup.createField(metaProperty.getName());\r\n    field.setProperty(metaProperty.getName());\r\n    field.setCaption(getPropertyCaption(metaClass, metaProperty));\r\n    field.setCustom(custom);\r\n    field.setRequired(required);\r\n    field.setEditable(!readOnly);\r\n    field.setWidth(\"400px\");\r\n    if (requireTextArea(metaProperty, item)) {\r\n        Element root = DocumentHelper.createElement(\"textArea\");\r\n        root.addAttribute(\"rows\", \"3\");\r\n        field.setXmlDescriptor(root);\r\n    }\r\n    if (focusFieldId == null && !readOnly) {\r\n        focusFieldId = field.getId();\r\n        focusFieldGroup = fieldGroup;\r\n    }\r\n    if (required) {\r\n        field.setRequiredMessage(messageTools.getDefaultRequiredMessage(metaClass, metaProperty.getName()));\r\n    }\r\n    fieldGroup.addField(field);\r\n    if (custom)\r\n        customFields.add(field);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.ExtendedEntities.getOriginalMetaClass",
	"Comment": "searches for an original entity for the provided extended entity.",
	"Method": "MetaClass getOriginalMetaClass(MetaClass extendedMetaClass,MetaClass getOriginalMetaClass,String extendedEntityName){\r\n    return getOriginalMetaClass(metadata.getSession().getClassNN(extendedEntityName));\r\n}"
}, {
	"Path": "com.googlecode.cqengine.query.parser.common.QueryParser.retrieve",
	"Comment": "shortcut for parsing the given query and its query options, and then retrieving objects matching thequery from the given collection, using the parsed query options.",
	"Method": "ResultSet<O> retrieve(IndexedCollection<O> collection,String query){\r\n    ParseResult<O> parseResult = parse(query);\r\n    return collection.retrieve(parseResult.getQuery(), parseResult.getQueryOptions());\r\n}"
}, {
	"Path": "org.crsh.standalone.Bootstrap.setAttributes",
	"Comment": "replaces the attributes to use, the new attributes map will be used as is and not copied.",
	"Method": "void setAttributes(Map<String, Object> attributes){\r\n    this.attributes = attributes;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.dynamicattributes.DynamicAttributesGuiTools.getAttributesToShowOnTheScreen",
	"Comment": "get attributes which should be added automatically to the screen and component.based on visibility settings from category attribute editor.",
	"Method": "Set<CategoryAttribute> getAttributesToShowOnTheScreen(MetaClass metaClass,String screen,String component){\r\n    Collection<CategoryAttribute> attributesForMetaClass = dynamicAttributes.getAttributesForMetaClass(metaClass);\r\n    Set<CategoryAttribute> categoryAttributes = new LinkedHashSet();\r\n    for (CategoryAttribute attribute : attributesForMetaClass) {\r\n        if (attributeShouldBeShownOnTheScreen(screen, component, attribute)) {\r\n            categoryAttributes.add(attribute);\r\n        }\r\n    }\r\n    return categoryAttributes;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.app.filestorage.amazon.auth.AWS4SignerForChunkedUpload.calculateChunkHeaderLength",
	"Comment": "returns the size of a chunk header, which only varies depending on theselected chunk size",
	"Method": "long calculateChunkHeaderLength(long chunkDataSize){\r\n    return Long.toHexString(chunkDataSize).length() + CHUNK_SIGNATURE_HEADER.length() + SIGNATURE_LENGTH + CLRF.length() + chunkDataSize + CLRF.length();\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.filter.FilterDelegateImpl.fillConditionsLayout",
	"Comment": "removes all components from conditionslayout and fills it with components for editing filter conditions",
	"Method": "void fillConditionsLayout(ConditionsFocusType conditionsFocusType){\r\n    for (Component component : conditionsLayout.getComponents()) {\r\n        conditionsLayout.remove(component);\r\n    }\r\n    paramEditComponentToFocus = null;\r\n    recursivelyCreateConditionsLayout(conditionsFocusType, false, conditions.getRootNodes(), conditionsLayout, 0);\r\n    conditionsLayout.setVisible(!conditionsLayout.getComponents().isEmpty());\r\n}"
}, {
	"Path": "org.crsh.cron.CronPlugin.getConfig",
	"Comment": "this method is protected so it can be overriden for unit tests",
	"Method": "Resource getConfig(){\r\n    Resource config = null;\r\n    String configPath = getContext().getProperty(CRON_CONFIG_PATH);\r\n    if (configPath != null) {\r\n        File configFile = new File(configPath);\r\n        if (configFile.exists()) {\r\n            log.log(Level.FINE, \"Found crontab file \" + configPath);\r\n            if (configFile.isFile()) {\r\n                try {\r\n                    config = new Resource(\"crontab\", configFile.toURI().toURL());\r\n                } catch (MalformedURLException e) {\r\n                    log.log(Level.SEVERE, \"Could not retrieve cron config file from \" + configPath, e);\r\n                } catch (IOException e) {\r\n                    log.log(Level.FINE, \"Could not load cron config file from \" + configPath, e);\r\n                }\r\n            } else {\r\n                log.log(Level.FINE, \"Crontab file \" + configPath + \" is not a file\");\r\n            }\r\n        } else {\r\n            log.log(Level.FINE, \"Crontab file \" + configPath + \" does not exist\");\r\n        }\r\n    } else {\r\n        Resource res = getContext().loadResource(\"crontab\", ResourceKind.CONFIG);\r\n        if (res != null) {\r\n            config = res;\r\n            log.log(Level.FINE, \"Found crontab config url \" + res);\r\n        }\r\n    }\r\n    if (config == null) {\r\n        log.log(Level.INFO, \"No crontab configuration\");\r\n    }\r\n    return config;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.data.impl.DsContextImpl.replaceMasterCopies",
	"Comment": "because in case of nested property datasources there may be references to cloned master entities.",
	"Method": "void replaceMasterCopies(Entity entity,NestedDatasource datasource){\r\n    Datasource masterDs = datasource.getMaster();\r\n    MetaProperty metaProperty = datasource.getProperty();\r\n    if (masterDs != null && metaProperty != null) {\r\n        MetaProperty inverseProp = metaProperty.getInverse();\r\n        if (inverseProp != null && !inverseProp.getRange().getCardinality().isMany()) {\r\n            MetaClass metaClass = metadata.getExtendedEntities().getEffectiveMetaClass(inverseProp.getDomain());\r\n            if (metaClass.equals(datasource.getMetaClass()) && (PersistenceHelper.isLoaded(entity, inverseProp.getName()) && entity.getValue(inverseProp.getName()) != null)) {\r\n                Object masterItem = null;\r\n                if (masterDs instanceof CollectionDatasource) {\r\n                    Entity value = entity.getValue(inverseProp.getName());\r\n                    if (value != null) {\r\n                        Object id = value.getId();\r\n                        masterItem = ((CollectionDatasource) masterDs).getItem(id);\r\n                    }\r\n                } else {\r\n                    masterItem = masterDs.getItem();\r\n                }\r\n                if (masterItem != null) {\r\n                    ((AbstractInstance) entity).setValue(inverseProp.getName(), masterItem, false);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.sys.DesktopWindowManager.dispose",
	"Comment": "release resources right before throwing away this windowmanagerimpl instance.",
	"Method": "void dispose(){\r\n    for (WindowOpenInfo openInfo : windowOpenMode.values()) {\r\n        if (openInfo.getOpenMode() == OpenMode.DIALOG) {\r\n            JDialog dialog = (JDialog) openInfo.getData();\r\n            dialog.setVisible(false);\r\n        }\r\n    }\r\n    if (isMainWindowManager) {\r\n        WatchDog watchDog = AppBeans.get(WatchDog.NAME);\r\n        watchDog.stopTasks();\r\n    }\r\n    for (Window window : windowOpenMode.keySet()) {\r\n        Frame frame = window.getFrame();\r\n        if (frame instanceof Component.Disposable)\r\n            ((Component.Disposable) frame).dispose();\r\n    }\r\n    tabs.clear();\r\n    windowOpenMode.clear();\r\n    stacks.clear();\r\n}"
}, {
	"Path": "com.cv4j.core.binary.MorphClose.process",
	"Comment": "erode operator after success doing dilate operatorcan fill litter hole.",
	"Method": "void process(ByteProcessor binary,Size structureElement){\r\n    Erode erode = new Erode();\r\n    Dilate dilate = new Dilate();\r\n    dilate.process(binary, structureElement);\r\n    erode.process(binary, structureElement);\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.ui.gridlayout.VDDGridLayout.emphasis",
	"Comment": "emphasizes a component container when user is hovering a draggedcomponent over the container.",
	"Method": "void emphasis(CellDetails cell,VDragEvent event){\r\n    Style shadowStyle = dragShadow.getElement().getStyle();\r\n    shadowStyle.setPosition(Position.ABSOLUTE);\r\n    shadowStyle.setWidth(cell.width, Unit.PX);\r\n    shadowStyle.setHeight(cell.height, Unit.PX);\r\n    shadowStyle.setLeft(cell.x, Unit.PX);\r\n    shadowStyle.setTop(cell.y, Unit.PX);\r\n    deEmphasis();\r\n    ComponentConnector draggedConnector = (ComponentConnector) event.getTransferable().getData(Constants.TRANSFERABLE_DETAIL_COMPONENT);\r\n    if (draggedConnector != null && draggedConnector.getWidget() == VDDGridLayout.this) {\r\n        return;\r\n    }\r\n    HorizontalDropLocation hl = getHorizontalDropLocation(cell, event);\r\n    VerticalDropLocation vl = getVerticalDropLocation(cell, event);\r\n    setStyleName(dragShadow.getElement(), OVER, true);\r\n    setStyleName(dragShadow.getElement(), OVER + \"-\" + vl.toString().toLowerCase(), true);\r\n    setStyleName(dragShadow.getElement(), OVER + \"-\" + hl.toString().toLowerCase(), true);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.config.DeviceInfo.getScreenHeight",
	"Comment": "gets the height of the screen in pixels. this is the full screenresolution and not the height available for the application.",
	"Method": "int getScreenHeight(){\r\n    return screenHeight;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.CubaFileUpload.interruptUpload",
	"Comment": "interrupts the upload currently being received. the interruption will be done by the receiving thread so thismethod will return immediately and the actual interrupt will happen a bit later.",
	"Method": "void interruptUpload(){\r\n    if (isUploading) {\r\n        interrupted = true;\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.cqengine.resultset.connective.ResultSetUnion.contains",
	"Comment": "returns true if the given object is contained in any underlying resultsets.",
	"Method": "boolean contains(O object){\r\n    for (ResultSet<O> resultSet : this.resultSets) {\r\n        if (resultSet.contains(object)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.KeyCombination.create",
	"Comment": "creates a new keycombination instance from a string representation.",
	"Method": "KeyCombination create(String keyString){\r\n    if (keyString == null) {\r\n        return null;\r\n    }\r\n    keyString = keyString.toUpperCase();\r\n    Key key;\r\n    Modifier[] modifiers = null;\r\n    if (keyString.contains(\"-\")) {\r\n        String[] keys = keyString.split(\"-\", -1);\r\n        int modifiersCnt = keys.length;\r\n        key = Key.valueOf(keys[modifiersCnt - 1]);\r\n        --modifiersCnt;\r\n        modifiers = new Modifier[modifiersCnt];\r\n        for (int i = 0; i < modifiersCnt; i++) {\r\n            modifiers[i] = Modifier.valueOf(keys[i]);\r\n        }\r\n    } else {\r\n        key = Key.valueOf(keyString);\r\n    }\r\n    return new KeyCombination(key, modifiers);\r\n}"
}, {
	"Path": "com.cronutils.model.field.definition.FieldDefinitionBuilder.and",
	"Comment": "registers cronfield in parserdefinitionbuilder and returns its instance.",
	"Method": "CronDefinitionBuilder and(){\r\n    cronDefinitionBuilder.register(new FieldDefinition(fieldName, constraints.createConstraintsInstance(), optional));\r\n    return cronDefinitionBuilder;\r\n}"
}, {
	"Path": "com.googlecode.cqengine.query.parser.cqn.support.CQNAntlrListener.exitQuery",
	"Comment": "this handler is called for all queries, allows us to validate that no handlers are missing.",
	"Method": "void exitQuery(CQNGrammarParser.QueryContext ctx){\r\n    numQueriesEncountered++;\r\n    validateAllQueriesParsed(numQueriesEncountered, numQueriesParsed);\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.DDVerticalLayout.setDropHandler",
	"Comment": "sets the current handler which handles dropped components on the layout.by setting a drop handler dropping components on the layout is enabled.by setting the drophandler to null dropping is disabled.",
	"Method": "void setDropHandler(DropHandler dropHandler){\r\n    DDUtil.verifyHandlerType(this, dropHandler);\r\n    if (this.dropHandler != dropHandler) {\r\n        this.dropHandler = dropHandler;\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.cqengine.query.simple.SimpleQuery.getAttribute",
	"Comment": "returns the attribute originally supplied to the constructor.",
	"Method": "Attribute<O, A> getAttribute(){\r\n    return attribute;\r\n}"
}, {
	"Path": "com.haulmont.bali.db.DbUtils.loadDriver",
	"Comment": "loads and registers a database driver class.if this succeeds, it returns true, else it returns false.",
	"Method": "boolean loadDriver(String driverClassName){\r\n    try {\r\n        Class.forName(driverClassName).newInstance();\r\n        return true;\r\n    } catch (ClassNotFoundException e) {\r\n        return false;\r\n    } catch (IllegalAccessException e) {\r\n        return true;\r\n    } catch (InstantiationException e) {\r\n        return false;\r\n    } catch (Throwable e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.ValueLoadContext.setStoreName",
	"Comment": "sets a data store name if it is different from the main database.",
	"Method": "ValueLoadContext setStoreName(String storeName){\r\n    this.storeName = storeName;\r\n    return this;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.actions.BaseAction.withPrimary",
	"Comment": "set whether this action is primary using fluent api method. can be used instead of subclassing baseaction class.",
	"Method": "BaseAction withPrimary(boolean primary){\r\n    this.primary = primary;\r\n    return this;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.sys.CubaVaadinServletService.setSessionLock",
	"Comment": "associates the given lock with this service and the given wrappedsession. this method should not be called more than once when the lock isinitialized for the session.",
	"Method": "void setSessionLock(WrappedSession wrappedSession,Lock lock){\r\n    if (wrappedSession == null) {\r\n        throw new IllegalArgumentException(\"Can't set a lock for a null session\");\r\n    }\r\n    Object currentSessionLock = wrappedSession.getAttribute(getLockAttributeName());\r\n    assert (currentSessionLock == null || currentSessionLock == lock) : \"Changing the lock for a session is not allowed\";\r\n    wrappedSession.setAttribute(getLockAttributeName(), lock);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.PersistenceImpl.dispose",
	"Comment": "internal.destroys the persistence configuration. further use of this bean instance is impossible.",
	"Method": "void dispose(){\r\n    jpaEmf.close();\r\n    for (String store : Stores.getAdditional()) {\r\n        EntityManagerFactory emf = beanLocator.get(\"entityManagerFactory_\" + store);\r\n        emf.close();\r\n    }\r\n}"
}, {
	"Path": "name.fraser.neil.plaintext.diff_match_patch.diff_cleanupEfficiency",
	"Comment": "reduce the number of edits by eliminating operationally trivial equalities.",
	"Method": "void diff_cleanupEfficiency(LinkedList<Diff> diffs){\r\n    if (diffs.isEmpty()) {\r\n        return;\r\n    }\r\n    boolean changes = false;\r\n    Stack<Diff> equalities = new Stack<Diff>();\r\n    String lastequality = null;\r\n    ListIterator<Diff> pointer = diffs.listIterator();\r\n    boolean pre_ins = false;\r\n    boolean pre_del = false;\r\n    boolean post_ins = false;\r\n    boolean post_del = false;\r\n    Diff thisDiff = pointer.next();\r\n    Diff safeDiff = thisDiff;\r\n    while (thisDiff != null) {\r\n        if (thisDiff.operation == Operation.EQUAL) {\r\n            if (thisDiff.text.length() < Diff_EditCost && (post_ins || post_del)) {\r\n                equalities.push(thisDiff);\r\n                pre_ins = post_ins;\r\n                pre_del = post_del;\r\n                lastequality = thisDiff.text;\r\n            } else {\r\n                equalities.clear();\r\n                lastequality = null;\r\n                safeDiff = thisDiff;\r\n            }\r\n            post_ins = post_del = false;\r\n        } else {\r\n            if (thisDiff.operation == Operation.DELETE) {\r\n                post_del = true;\r\n            } else {\r\n                post_ins = true;\r\n            }\r\n            if (lastequality != null && ((pre_ins && pre_del && post_ins && post_del) || ((lastequality.length() < Diff_EditCost / 2) && ((pre_ins ? 1 : 0) + (pre_del ? 1 : 0) + (post_ins ? 1 : 0) + (post_del ? 1 : 0)) == 3))) {\r\n                while (thisDiff != equalities.lastElement()) {\r\n                    thisDiff = pointer.previous();\r\n                }\r\n                pointer.next();\r\n                pointer.set(new Diff(Operation.DELETE, lastequality));\r\n                pointer.add(thisDiff = new Diff(Operation.INSERT, lastequality));\r\n                equalities.pop();\r\n                lastequality = null;\r\n                if (pre_ins && pre_del) {\r\n                    post_ins = post_del = true;\r\n                    equalities.clear();\r\n                    safeDiff = thisDiff;\r\n                } else {\r\n                    if (!equalities.empty()) {\r\n                        equalities.pop();\r\n                    }\r\n                    if (equalities.empty()) {\r\n                        thisDiff = safeDiff;\r\n                    } else {\r\n                        thisDiff = equalities.lastElement();\r\n                    }\r\n                    while (thisDiff != pointer.previous()) {\r\n                    }\r\n                    post_ins = post_del = false;\r\n                }\r\n                changes = true;\r\n            }\r\n        }\r\n        thisDiff = pointer.hasNext() ? pointer.next() : null;\r\n    }\r\n    if (changes) {\r\n        diff_cleanupMerge(diffs);\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.bali.db.QueryRunner.update",
	"Comment": "execute an sql insert, update, or delete query with a single replacementparameter.",
	"Method": "int update(Connection conn,String sql,int update,Connection conn,String sql,Object param,int update,Connection conn,String sql,Object[] params,int update,Connection conn,String sql,Object[] params,int[] paramTypes,int update,String sql,int update,String sql,Object param,int update,String sql,Object[] params,int update,String sql,Object[] params,int[] paramTypes){\r\n    Connection conn = this.prepareConnection();\r\n    try {\r\n        return this.update(conn, sql, params, paramTypes);\r\n    } finally {\r\n        close(conn);\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.executors.impl.TaskHandlerImpl.getResult",
	"Comment": "join task thread to current caution! call this method only from synchronous gui action",
	"Method": "V getResult(){\r\n    checkState(started, \"Task is not running\");\r\n    return taskExecutor.getResult();\r\n}"
}, {
	"Path": "org.crsh.ssh.term.SSHLifeCycle.getLocalPort",
	"Comment": "returns the local part after the ssh server has been succesfully bound or null. this is useful whenthe port is chosen at random by the system.",
	"Method": "Integer getLocalPort(){\r\n    return localPort;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.EmailHeader.parse",
	"Comment": "returns instance of emailheader object from string argument.",
	"Method": "EmailHeader parse(String line){\r\n    if (line == null)\r\n        return null;\r\n    String[] values = line.split(SEPARATOR);\r\n    if (values.length == 2) {\r\n        String name = values[0].trim();\r\n        String value = values[1].trim();\r\n        return new EmailHeader(name, value);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.DialogOptions.setModal",
	"Comment": "set modal option if a window will be opened as a dialog or change modal option if the window is already opened as a dialog.",
	"Method": "DialogOptions setModal(Boolean modal){\r\n    this.modal = modal;\r\n    return this;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.app.core.entityinspector.EntityInspectorEditor.getNullIndicatorProperty",
	"Comment": "returns metaproperty of the referred entity annotated with either nullindicatorattributename ornullindicatorcolumnname property.",
	"Method": "MetaProperty getNullIndicatorProperty(MetaProperty embeddedMetaProperty){\r\n    return null;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.Window.removeBeforeCloseWithShortcutListener",
	"Comment": "removes a previously registered before close with shortcut listener.",
	"Method": "void removeBeforeCloseWithShortcutListener(Consumer<BeforeCloseWithShortcutEvent> listener){\r\n    removeBeforeWindowCloseListener(new BeforeCloseWithShortcutListenerAdapter(listener));\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.AbstractFrame.showValidationErrors",
	"Comment": "show validation errors alert. can be overridden in subclasses.",
	"Method": "void showValidationErrors(ValidationErrors errors){\r\n    StringBuilder buffer = new StringBuilder();\r\n    for (ValidationErrors.Item error : errors.getAll()) {\r\n        buffer.append(error.description).append(\"\\n\");\r\n    }\r\n    Configuration configuration = AppBeans.get(Configuration.NAME);\r\n    ClientConfig clientConfig = configuration.getConfig(ClientConfig.class);\r\n    NotificationType notificationType = NotificationType.valueOf(clientConfig.getValidationNotificationType());\r\n    showNotification(messages.getMainMessage(\"validationFail.caption\"), buffer.toString(), notificationType);\r\n}"
}, {
	"Path": "org.crsh.console.EditorBuffer.getSize",
	"Comment": "returns the total number of chars in the buffer, independently of the cursor position.",
	"Method": "int getSize(){\r\n    return current.length();\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.ui.panel.VDDPanel.updateDragDetails",
	"Comment": "updates the drop details while dragging. this is needed to ensure clientside criterias can validate the drop location.",
	"Method": "void updateDragDetails(VDragEvent event){\r\n    Element over = event.getElementOver();\r\n    Widget content = WidgetUtil.findWidget(over, null);\r\n    if (content != null && content != this) {\r\n        event.getDropDetails().put(Constants.DROP_DETAIL_OVER_CLASS, content.getClass().getName());\r\n    } else {\r\n        event.getDropDetails().put(Constants.DROP_DETAIL_OVER_CLASS, this.getClass().getName());\r\n    }\r\n    MouseEventDetails details = MouseEventDetailsBuilder.buildMouseEventDetails(event.getCurrentGwtEvent(), getElement());\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_MOUSE_EVENT, details.serialize());\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.ui.csslayout.VDDCssLayout.updateDragDetails",
	"Comment": "updates the drop details while dragging. this is needed to ensure clientside criterias can validate the drop location.",
	"Method": "void updateDragDetails(VDragEvent event){\r\n    Element over = event.getElementOver();\r\n    if (placeHolderElement.isOrHasChild(over)) {\r\n        return;\r\n    }\r\n    Widget widget = (Widget) Util.findWidget(over, null);\r\n    if (widget == null) {\r\n        return;\r\n    }\r\n    int offset = 0;\r\n    int index = -1;\r\n    for (int i = 0; i < getElement().getChildCount(); i++) {\r\n        Element child = getElement().getChild(i).cast();\r\n        if (child.isOrHasChild(placeHolderElement)) {\r\n            offset--;\r\n        } else if (child.isOrHasChild(widget.getElement())) {\r\n            index = i + offset;\r\n            break;\r\n        }\r\n    }\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_TO, index);\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_HORIZONTAL_DROP_LOCATION, getHorizontalDropLocation(widget, event));\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_VERTICAL_DROP_LOCATION, getVerticalDropLocation(widget, event));\r\n    MouseEventDetails details = MouseEventDetailsBuilder.buildMouseEventDetails(event.getCurrentGwtEvent(), getElement());\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_MOUSE_EVENT, details.serialize());\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.MetadataLoader.initExtensionMetaAnnotations",
	"Comment": "initialize connections between extended and base entities.",
	"Method": "void initExtensionMetaAnnotations(){\r\n    for (MetaClass metaClass : session.getClasses()) {\r\n        Class<?> javaClass = metaClass.getJavaClass();\r\n        List<Class> superClasses = new ArrayList();\r\n        Extends extendsAnnotation = javaClass.getAnnotation(Extends.class);\r\n        while (extendsAnnotation != null) {\r\n            Class<? extends Entity> superClass = extendsAnnotation.value();\r\n            superClasses.add(superClass);\r\n            extendsAnnotation = superClass.getAnnotation(Extends.class);\r\n        }\r\n        for (Class superClass : superClasses) {\r\n            metaClass.getAnnotations().put(Extends.class.getName(), superClass);\r\n            MetaClass superMetaClass = session.getClassNN(superClass);\r\n            Class<?> extendedByClass = (Class) superMetaClass.getAnnotations().get(ExtendedBy.class.getName());\r\n            if (extendedByClass != null && !javaClass.equals(extendedByClass)) {\r\n                if (javaClass.isAssignableFrom(extendedByClass))\r\n                    continue;\r\n                else if (!extendedByClass.isAssignableFrom(javaClass))\r\n                    throw new IllegalStateException(superClass + \" is already extended by \" + extendedByClass);\r\n            }\r\n            superMetaClass.getAnnotations().put(ExtendedBy.class.getName(), javaClass);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.cronutils.mapper.WeekDay.mapTo",
	"Comment": "maps given weekday to representation hold by this instance.",
	"Method": "int mapTo(int dayOfWeek,WeekDay targetWeekDayDefinition){\r\n    if (firstDayZero && targetWeekDayDefinition.isFirstDayZero()) {\r\n        return bothSameStartOfRange(0, 6, this, targetWeekDayDefinition).apply(dayOfWeek);\r\n    }\r\n    if (!firstDayZero && !targetWeekDayDefinition.isFirstDayZero()) {\r\n        return bothSameStartOfRange(1, 7, this, targetWeekDayDefinition).apply(dayOfWeek);\r\n    }\r\n    if (targetWeekDayDefinition.isFirstDayZero()) {\r\n        return mapTo(dayOfWeek, new WeekDay(targetWeekDayDefinition.getMondayDoWValue() + 1, false)) - 1;\r\n    } else {\r\n        return mapTo(dayOfWeek, new WeekDay(targetWeekDayDefinition.getMondayDoWValue() - 1, true)) + 1;\r\n    }\r\n}"
}, {
	"Path": "org.crsh.cli.descriptor.CommandDescriptor.getParameters",
	"Comment": "returns the command parameters, the returned collection contains the command options andthe command arguments.",
	"Method": "List<ParameterDescriptor> getParameters(){\r\n    return uParameters;\r\n}"
}, {
	"Path": "org.crsh.plugin.Embedded.create",
	"Comment": "create the plugin context, allow subclasses to customize it.",
	"Method": "PluginContext create(Map<String, Object> attributes,PluginDiscovery discovery,ClassLoader loader){\r\n    FS cmdFS;\r\n    FS confFS;\r\n    try {\r\n        cmdFS = createCommandFS();\r\n        confFS = createConfFS();\r\n    } catch (IOException e) {\r\n        log.log(Level.SEVERE, \"Coult not initialize the file system\", e);\r\n        return null;\r\n    }\r\n    return new PluginContext(discovery, attributes, cmdFS, confFS, loader);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.javacl.JavaClassLoader.linkDependencies",
	"Comment": "add dependencies for each class and also add each class to dependent for each dependency",
	"Method": "void linkDependencies(Map<String, TimestampClass> compiledTimestampClasses,Multimap<String, String> dependencies){\r\n    for (Map.Entry<String, TimestampClass> entry : compiledTimestampClasses.entrySet()) {\r\n        String className = entry.getKey();\r\n        TimestampClass timestampClass = entry.getValue();\r\n        Collection<String> dependencyClasses = dependencies.get(className);\r\n        timestampClass.dependencies.addAll(dependencyClasses);\r\n        for (String dependencyClassName : timestampClass.dependencies) {\r\n            TimestampClass dependencyClass = compiled.get(dependencyClassName);\r\n            if (dependencyClass != null) {\r\n                dependencyClass.dependent.add(className);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.popupbutton.VPopupButton.popupHasChild",
	"Comment": "simply check if popup has child equal to passed element haulmont api",
	"Method": "boolean popupHasChild(Element element){\r\n    return popup.getElement().isOrHasChild(element);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.filter.FilterDelegateImpl.refreshDatasource",
	"Comment": "extenders should be able to modify the datasourcebefore it will be refreshed",
	"Method": "void refreshDatasource(Map<String, Object> parameters){\r\n    adapter.refreshIfNotSuspended(parameters);\r\n}"
}, {
	"Path": "com.cronutils.model.field.definition.FieldDayOfWeekDefinitionBuilder.withIntMapping",
	"Comment": "defines mapping between integer values with equivalent meaning.",
	"Method": "FieldDayOfWeekDefinitionBuilder withIntMapping(int source,int dest){\r\n    super.withIntMapping(source, dest);\r\n    return this;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.MarginInfo.hasRight",
	"Comment": "checks if this margininfo object has the right edge margin enabled.",
	"Method": "boolean hasRight(){\r\n    return (bitMask & RIGHT) == RIGHT;\r\n}"
}, {
	"Path": "com.cronutils.mapper.CronMapper.returnOnZeroExpression",
	"Comment": "creates a function that returns a on instance with zero value.",
	"Method": "Function<CronField, CronField> returnOnZeroExpression(CronFieldName name){\r\n    return field -> {\r\n        final FieldConstraints constraints = FieldConstraintsBuilder.instance().forField(name).createConstraintsInstance();\r\n        return new CronField(name, new On(new IntegerFieldValue(0)), constraints);\r\n    };\r\n}"
}, {
	"Path": "name.fraser.neil.plaintext.diff_match_patch.diff_halfMatchI",
	"Comment": "does a substring of shorttext exist within longtext such that thesubstring is at least half the length of longtext?",
	"Method": "String[] diff_halfMatchI(String longtext,String shorttext,int i){\r\n    String seed = longtext.substring(i, i + longtext.length() / 4);\r\n    int j = -1;\r\n    String best_common = \"\";\r\n    String best_longtext_a = \"\", best_longtext_b = \"\";\r\n    String best_shorttext_a = \"\", best_shorttext_b = \"\";\r\n    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {\r\n        int prefixLength = diff_commonPrefix(longtext.substring(i), shorttext.substring(j));\r\n        int suffixLength = diff_commonSuffix(longtext.substring(0, i), shorttext.substring(0, j));\r\n        if (best_common.length() < suffixLength + prefixLength) {\r\n            best_common = shorttext.substring(j - suffixLength, j) + shorttext.substring(j, j + prefixLength);\r\n            best_longtext_a = longtext.substring(0, i - suffixLength);\r\n            best_longtext_b = longtext.substring(i + prefixLength);\r\n            best_shorttext_a = shorttext.substring(0, j - suffixLength);\r\n            best_shorttext_b = shorttext.substring(j + prefixLength);\r\n        }\r\n    }\r\n    if (best_common.length() * 2 >= longtext.length()) {\r\n        return new String[] { best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b, best_common };\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.details.AccordionTargetDetails.getDropLocation",
	"Comment": "get the horizontal position of the dropped component within theunderlying cell.",
	"Method": "VerticalDropLocation getDropLocation(){\r\n    if (getData(\"vdetail\") != null) {\r\n        return VerticalDropLocation.valueOf((String) getData(\"vdetail\"));\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.v7.DDHorizontalLayout.setDropHandler",
	"Comment": "sets the current handler which handles dropped components on the layout.by setting a drop handler dropping components on the layout is enabled.by setting the drophandler to null dropping is disabled.",
	"Method": "void setDropHandler(DropHandler dropHandler){\r\n    DDUtil.verifyHandlerType(this, dropHandler);\r\n    if (this.dropHandler != dropHandler) {\r\n        this.dropHandler = dropHandler;\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.exception.ExceptionHandlers.setDefaultHandler",
	"Comment": "set the default handler instead of initialized in constructor.",
	"Method": "void setDefaultHandler(ExceptionHandler defaultHandler){\r\n    this.defaultHandler = defaultHandler;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.jmx.AnnotationMBeanInfoAssembler.resolveObjectDescriptor",
	"Comment": "locates the value of a descriptor based on values attachedto both the getter and setter methods. if both have valuessupplied then the value attached to the getter is preferred.",
	"Method": "Object resolveObjectDescriptor(Object getter,Object setter){\r\n    return (getter != null ? getter : setter);\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.exception.ExceptionHandlersConfiguration.setHandlerClasses",
	"Comment": "set the list of exception handler class names, usually from spring.xml.",
	"Method": "void setHandlerClasses(List<String> list){\r\n    for (String className : list) {\r\n        handlerClasses.add(ReflectionHelper.getClass(className));\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.tabsheetcsslayout.CubaTabSheetCssLayoutConnector.onConnectorHierarchyChange",
	"Comment": "this method is copied from the superclass but its parts are swapped",
	"Method": "void onConnectorHierarchyChange(ConnectorHierarchyChangeEvent event){\r\n    for (ComponentConnector child : event.getOldChildren()) {\r\n        if (child.getParent() == this) {\r\n            continue;\r\n        }\r\n        getWidget().remove(child.getWidget());\r\n        VCaption vCaption = childIdToCaption.get(child.getConnectorId());\r\n        if (vCaption != null) {\r\n            childIdToCaption.remove(child.getConnectorId());\r\n            getWidget().remove(vCaption);\r\n        }\r\n    }\r\n    int index = 0;\r\n    for (ComponentConnector child : getChildComponents()) {\r\n        VCaption childCaption = childIdToCaption.get(child.getConnectorId());\r\n        if (childCaption != null) {\r\n            getWidget().addOrMove(childCaption, index++);\r\n        }\r\n        getWidget().addOrMove(child.getWidget(), index++);\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.remoting.discovery.StaticServerSelectorTest.testFail3",
	"Comment": "each new session on first request should get the full list of servers regardless of previously failed ones",
	"Method": "void testFail3(){\r\n    StaticServerSelector selector = createSelector(\"server1,server2\");\r\n    currentSession = session1;\r\n    Object context1 = newRequest(selector, \"server2/path\");\r\n    selector.fail(context1);\r\n    sameRequest(selector, context1, \"server1/path\");\r\n    currentSession = session2;\r\n    Object context2 = newRequest(selector, \"server1/path\");\r\n    currentSession = session3;\r\n    Object context3 = newRequest(selector, \"server2/path\");\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.ui.horizontallayout.VDDHorizontalLayout.getDragMode",
	"Comment": "returns the current drag mode which determines how the drag is visualized",
	"Method": "LayoutDragMode getDragMode(){\r\n    return ddMouseHandler.getDragMode();\r\n}"
}, {
	"Path": "com.cronutils.descriptor.DescriptionStrategy.describe",
	"Comment": "provide a human readable description for between instance.",
	"Method": "String describe(String describe,FieldExpression fieldExpression,String describe,FieldExpression fieldExpression,boolean and,String describe,Always always,boolean and,String describe,And and,String describe,Between between,boolean and,String describe,Every every,boolean and,String describe,On on,boolean and){\r\n    if (and) {\r\n        return nominalValue(on.getTime());\r\n    }\r\n    return String.format(\"%s %s \", bundle.getString(\"at\"), nominalValue(on.getTime())) + \"%s\";\r\n}"
}, {
	"Path": "com.cronutils.parser.CronParser.buildPossibleExpressions",
	"Comment": "build possible cron expressions from definitions. one is built for sure. a second one may be build if last field is optional.",
	"Method": "void buildPossibleExpressions(CronDefinition cronDefinition){\r\n    final List<CronParserField> sortedExpression = cronDefinition.getFieldDefinitions().stream().map(this::toCronParserField).sorted(CronParserField.createFieldTypeComparator()).collect(Collectors.toList());\r\n    List<CronParserField> tempExpression = sortedExpression;\r\n    while (lastFieldIsOptional(tempExpression)) {\r\n        int expressionLength = tempExpression.size() - 1;\r\n        ArrayList<CronParserField> possibleExpression = new ArrayList(tempExpression.subList(0, expressionLength));\r\n        expressions.put(expressionLength, possibleExpression);\r\n        tempExpression = possibleExpression;\r\n    }\r\n    expressions.put(sortedExpression.size(), sortedExpression);\r\n}"
}, {
	"Path": "com.haulmont.bali.db.QueryRunner.query",
	"Comment": "execute an sql select query without any replacement parameters.thecaller is responsible for closing the connection.",
	"Method": "T query(Connection conn,String sql,Object param,ResultSetHandler<T> rsh,T query,Connection conn,String sql,Object[] params,ResultSetHandler<T> rsh,T query,Connection conn,String sql,Object[] params,int[] paramTypes,ResultSetHandler<T> rsh,T query,Connection conn,String sql,ResultSetHandler<T> rsh,T query,String sql,Object param,ResultSetHandler<T> rsh,T query,String sql,Object[] params,ResultSetHandler<T> rsh,T query,String sql,Object[] params,int[] paramTypes,ResultSetHandler<T> rsh,T query,String sql,ResultSetHandler<T> rsh){\r\n    return this.query(sql, (Object[]) null, rsh);\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.EntityAttributeVisitor.skip",
	"Comment": "optionally indicates, whether the property has to be visited",
	"Method": "boolean skip(MetaProperty property){\r\n    return false;\r\n}"
}, {
	"Path": "org.crsh.util.Utils.resolve",
	"Comment": "a simplistic implementation, it may not handle all cases but it should handle enough.",
	"Method": "Type resolve(Type implementation,Class<?> type,int parameterIndex){\r\n    if (implementation == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    if (implementation == type) {\r\n        TypeVariable<? extends Class<?>>[] tp = type.getTypeParameters();\r\n        if (parameterIndex < tp.length) {\r\n            return tp[parameterIndex];\r\n        } else {\r\n            throw new IllegalArgumentException();\r\n        }\r\n    } else if (implementation instanceof Class<?>) {\r\n        Class<?> c = (Class<?>) implementation;\r\n        Type gsc = c.getGenericSuperclass();\r\n        Type resolved = null;\r\n        if (gsc != null) {\r\n            resolved = resolve(gsc, type, parameterIndex);\r\n            if (resolved == null) {\r\n            }\r\n        }\r\n        return resolved;\r\n    } else if (implementation instanceof ParameterizedType) {\r\n        ParameterizedType pt = (ParameterizedType) implementation;\r\n        Type[] typeArgs = pt.getActualTypeArguments();\r\n        Type rawType = pt.getRawType();\r\n        if (rawType == type) {\r\n            return typeArgs[parameterIndex];\r\n        } else if (rawType instanceof Class<?>) {\r\n            Class<?> classRawType = (Class<?>) rawType;\r\n            Type resolved = resolve(classRawType, type, parameterIndex);\r\n            if (resolved == null) {\r\n                return null;\r\n            } else if (resolved instanceof TypeVariable) {\r\n                TypeVariable resolvedTV = (TypeVariable) resolved;\r\n                TypeVariable[] a = classRawType.getTypeParameters();\r\n                for (int i = 0; i < a.length; i++) {\r\n                    if (a[i].equals(resolvedTV)) {\r\n                        return resolve(implementation, classRawType, i);\r\n                    }\r\n                }\r\n                throw new AssertionError();\r\n            } else {\r\n                throw new UnsupportedOperationException(\"Cannot support resolution of \" + resolved);\r\n            }\r\n        } else {\r\n            throw new UnsupportedOperationException();\r\n        }\r\n    } else {\r\n        throw new UnsupportedOperationException(\"todo \" + implementation + \" \" + implementation.getClass());\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.DDAbsoluteLayout.getDropHandler",
	"Comment": "get the drophandler which handles component drops on the layout",
	"Method": "DropHandler getDropHandler(){\r\n    return dropHandler;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.ComponentsHelper.findComponent",
	"Comment": "searches for a component by identifier, down by the hierarchy of frames.",
	"Method": "Component findComponent(Frame frame,String id){\r\n    Component find = frame.getComponent(id);\r\n    if (find != null) {\r\n        return find;\r\n    } else {\r\n        for (Component c : frame.getComponents()) {\r\n            if (c instanceof Frame) {\r\n                Component comp = ((Frame) c).getComponent(id);\r\n                if (comp != null) {\r\n                    return comp;\r\n                } else {\r\n                    return findComponent((Frame) c, id);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.screen.ScreenFragment.init",
	"Comment": "convenient method to perform programmatic initialization of the fragment.",
	"Method": "ScreenFragment init(){\r\n    getScreenContext().getFragments().init(this);\r\n    return this;\r\n}"
}, {
	"Path": "com.cronutils.model.definition.CronDefinitionBuilder.instance",
	"Comment": "creates a new crondefinition instance with provided field definitions.",
	"Method": "CronDefinition instance(){\r\n    final Set<CronConstraint> validations = new HashSet();\r\n    validations.addAll(cronConstraints);\r\n    final List<FieldDefinition> values = new ArrayList(fields.values());\r\n    values.sort(FieldDefinition.createFieldDefinitionComparator());\r\n    return new CronDefinition(values, validations, enforceStrictRanges, matchDayOfWeekAndDayOfMonth);\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.DDVerticalSplitPanel.getDropHandler",
	"Comment": "returns the drop handler which handles drop events from droppingcomponents on the layout. returns null if dropping is disabled.",
	"Method": "DropHandler getDropHandler(){\r\n    return dropHandler;\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.stream.SpliteratorBasedStream.mergeMap",
	"Comment": "a potentially asynchronous flatmap operation where data from each publisher may arrive out of order",
	"Method": "ReactiveSeq<R> mergeMap(Function<? super T, ? extends Publisher<? extends R>> mapper,ReactiveSeq<R> mergeMap,int maxConcurrency,Function<? super T, ? extends Publisher<? extends R>> mapper){\r\n    return Spouts.fromIterable(this).mergeMap(maxConcurrency, mapper);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.EntityCombinedScreen.initBrowseCreateAction",
	"Comment": "adds a createaction that removes selection in table, sets a newly created item to editdsand enables controls for record editing.",
	"Method": "void initBrowseCreateAction(){\r\n    ListComponent table = getTable();\r\n    table.addAction(new CreateAction(table) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        @Override\r\n        protected void internalOpenEditor(CollectionDatasource datasource, Entity newItem, Datasource parentDs, Map<String, Object> params) {\r\n            initNewItem(newItem);\r\n            table.setSelected(Collections.emptyList());\r\n            getFieldGroup().getDatasource().setItem(newItem);\r\n            refreshOptionsForLookupFields();\r\n            enableEditControls(true);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.EntityCombinedScreen.initBrowseCreateAction",
	"Comment": "adds a createaction that removes selection in table, sets a newly created item to editdsand enables controls for record editing.",
	"Method": "void initBrowseCreateAction(){\r\n    initNewItem(newItem);\r\n    table.setSelected(Collections.emptyList());\r\n    getFieldGroup().getDatasource().setItem(newItem);\r\n    refreshOptionsForLookupFields();\r\n    enableEditControls(true);\r\n}"
}, {
	"Path": "com.cronutils.model.definition.CronDefinition.isMatchDayOfWeekAndDayOfMonth",
	"Comment": "if both the day of the week and day of the month should be matched.",
	"Method": "boolean isMatchDayOfWeekAndDayOfMonth(){\r\n    return matchDayOfWeekAndDayOfMonth;\r\n}"
}, {
	"Path": "com.haulmont.cuba.desktop.App.initExceptionHandlers",
	"Comment": "initializes exception handlers immediately after login and logout.can be overridden in descendants to manipulate exception handlers programmatically.",
	"Method": "void initExceptionHandlers(boolean isConnected){\r\n    ExceptionHandlers handlers = AppBeans.get(\"cuba_ExceptionHandlers\", ExceptionHandlers.class);\r\n    if (isConnected) {\r\n        handlers.createByConfiguration();\r\n    } else {\r\n        handlers.createMinimalSet();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.DDHorizontalSplitPanel.setDropHandler",
	"Comment": "sets the current handler which handles dropped components on the layout.by setting a drop handler dropping components on the layout is enabled.by setting the drophandler to null dropping is disabled.",
	"Method": "void setDropHandler(DropHandler dropHandler){\r\n    DDUtil.verifyHandlerType(this, dropHandler);\r\n    if (this.dropHandler != dropHandler) {\r\n        this.dropHandler = dropHandler;\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.security.global.UserSession.setAttribute",
	"Comment": "set user session attribute. attribute is a named serializable object bound to session.",
	"Method": "void setAttribute(String name,Serializable value){\r\n    attributes.put(name, value);\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.actions.AddAction.create",
	"Comment": "creates an action with default id, opening the lookup screen in this tab.",
	"Method": "AddAction create(ListComponent target,AddAction create,ListComponent target,Window.Lookup.Handler handler,AddAction create,ListComponent target,Window.Lookup.Handler handler,OpenType openType,AddAction create,ListComponent target,Window.Lookup.Handler handler,OpenType openType,String id){\r\n    return AppBeans.getPrototype(\"cuba_AddAction\", target, handler, openType, id);\r\n}"
}, {
	"Path": "com.googlecode.cqengine.resultset.connective.ResultSetDifference.contains",
	"Comment": "returns true if the given object is contained in the first resultset,but is not contained in the second resultset.",
	"Method": "boolean contains(O object){\r\n    return firstResultSet.contains(object) && !secondResultSet.contains(object);\r\n}"
}, {
	"Path": "com.googlecode.cqengine.query.parser.cqn.CQNParser.forPojoWithAttributes",
	"Comment": "creates a new cqnparser for the given pojo class, and registers the given attributes with it.",
	"Method": "CQNParser<O> forPojoWithAttributes(Class<O> pojoClass,Map<String, ? extends Attribute<O, ?>> attributes){\r\n    CQNParser<O> parser = forPojo(pojoClass);\r\n    parser.registerAttributes(attributes);\r\n    return parser;\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.ui.tabsheet.VDDTabSheet.updateDragDetails",
	"Comment": "updates the drop details while dragging. this is needed to ensure clientside criterias can validate the drop location.",
	"Method": "void updateDragDetails(VDragEvent event){\r\n    Element element = event.getElementOver();\r\n    if (element == null)\r\n        return;\r\n    if (tabBar.getElement().isOrHasChild(element)) {\r\n        Widget w = Util.findWidget(element, null);\r\n        if (w == tabBar) {\r\n            event.getDropDetails().put(Constants.DROP_DETAIL_TO, tabBar.getWidgetCount() - 1);\r\n            event.getDropDetails().put(Constants.DROP_DETAIL_HORIZONTAL_DROP_LOCATION, HorizontalDropLocation.RIGHT);\r\n        } else {\r\n            event.getDropDetails().put(Constants.DROP_DETAIL_TO, getTabPosition(w));\r\n            HorizontalDropLocation location = VDragDropUtil.getHorizontalDropLocation(DOM.asOld(element), Util.getTouchOrMouseClientX(event.getCurrentGwtEvent()), tabLeftRightDropRatio);\r\n            event.getDropDetails().put(Constants.DROP_DETAIL_HORIZONTAL_DROP_LOCATION, location);\r\n        }\r\n        MouseEventDetails details = MouseEventDetailsBuilder.buildMouseEventDetails(event.getCurrentGwtEvent(), getElement());\r\n        event.getDropDetails().put(Constants.DROP_DETAIL_MOUSE_EVENT, details.serialize());\r\n    }\r\n}"
}, {
	"Path": "com.googlecode.cqengine.testutil.TestUtil.valuesOf",
	"Comment": "returns the values of the given attribute in objects returned by the given result set.the set returned preserves the order of objects returned by the result set, but eliminates duplicates.",
	"Method": "Set<A> valuesOf(Attribute<O, A> attribute,ResultSet<O> resultSet){\r\n    Set<A> attributeValues = new LinkedHashSet<A>();\r\n    for (O object : resultSet) {\r\n        for (A value : attribute.getValues(object, noQueryOptions())) {\r\n            attributeValues.add(value);\r\n        }\r\n    }\r\n    return attributeValues;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.EntityLoadInfoBuilder.contains",
	"Comment": "check whether an info about the given entity instance is contained in the collection.",
	"Method": "boolean contains(Collection<EntityLoadInfo> collection,Entity entity){\r\n    Preconditions.checkNotNullArgument(collection, \"collection is null\");\r\n    Preconditions.checkNotNullArgument(entity, \"entity is null\");\r\n    MetaClass metaClass = metadata.getClassNN(entity.getClass());\r\n    for (EntityLoadInfo info : collection) {\r\n        if (metaClass.equals(info.getMetaClass()) && entity.getId().equals(info.getId()))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.components.Window.removeBeforeCloseWithCloseButtonListener",
	"Comment": "removes a previously registered before close with close button listener.",
	"Method": "void removeBeforeCloseWithCloseButtonListener(Consumer<BeforeCloseWithCloseButtonEvent> listener){\r\n    removeBeforeWindowCloseListener(new BeforeCloseWithCloseButtonListenerAdapter(listener));\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.v7.ui.horizontallayout.VDDHorizontalLayout.updateDragDetails",
	"Comment": "updates the drop details while dragging. this is needed to ensure clientside criterias can validate the drop location.",
	"Method": "void updateDragDetails(Widget widget,VDragEvent event){\r\n    if (widget == null) {\r\n        return;\r\n    }\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_HORIZONTAL_DROP_LOCATION, getHorizontalDropLocation(widget, event));\r\n    int index = -1;\r\n    if (widget instanceof Slot) {\r\n        WidgetCollection captionsAndSlots = getChildren();\r\n        index = VDragDropUtil.findSlotIndex(captionsAndSlots, (Slot) widget);\r\n    }\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_TO, index);\r\n    MouseEventDetails details = MouseEventDetailsBuilder.buildMouseEventDetails(event.getCurrentGwtEvent(), getElement());\r\n    event.getDropDetails().put(Constants.DROP_DETAIL_MOUSE_EVENT, details.serialize());\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.app.AbstractBeansMetadata.getAvailableBeans",
	"Comment": "returns a map, the key is bean name, the value is a list of objects that hold a bean methods information",
	"Method": "Map<String, List<MethodInfo>> getAvailableBeans(){\r\n    Map<String, List<MethodInfo>> result = new TreeMap();\r\n    String[] beanNames = AppContext.getApplicationContext().getBeanDefinitionNames();\r\n    for (String name : beanNames) {\r\n        if (AppContext.getApplicationContext().isSingleton(name) && !name.startsWith(\"org.springframework.\") && !getBeansToIgnore().contains(name)) {\r\n            List<MethodInfo> availableMethods = getAvailableMethods(name);\r\n            if (!availableMethods.isEmpty())\r\n                result.put(name, availableMethods);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.app.core.entityinspector.EntityInspectorEditor.createEmbeddedFields",
	"Comment": "recursively instantiates the embedded properties.e.g. embedded properties of the embedded property will also be instantiated.",
	"Method": "void createEmbeddedFields(MetaClass metaClass,Entity item){\r\n    for (MetaProperty metaProperty : metaClass.getProperties()) {\r\n        if (isEmbedded(metaProperty)) {\r\n            MetaClass embeddedMetaClass = metaProperty.getRange().asClass();\r\n            Entity embedded = item.getValue(metaProperty.getName());\r\n            if (embedded == null) {\r\n                embedded = metadata.create(embeddedMetaClass);\r\n                item.setValue(metaProperty.getName(), embedded);\r\n            }\r\n            createEmbeddedFields(embeddedMetaClass, embedded);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.App.onHeartbeat",
	"Comment": "called from heartbeat request. used for ping middleware session and show session messages",
	"Method": "void onHeartbeat(){\r\n    Connection connection = getConnection();\r\n    boolean sessionIsAlive = false;\r\n    if (connection.isAuthenticated()) {\r\n        log.debug(\"Ping middleware session\");\r\n        try {\r\n            String message = userSessionService.getMessages();\r\n            sessionIsAlive = true;\r\n            if (message != null) {\r\n                message = message.replace(\"\\n\", \"<br/>\");\r\n                getWindowManager().showNotification(message, Frame.NotificationType.ERROR_HTML);\r\n            }\r\n        } catch (NoUserSessionException ignored) {\r\n        } catch (Exception e) {\r\n            log.warn(\"Exception while session ping\", e);\r\n        }\r\n    }\r\n    if (sessionIsAlive) {\r\n        events.publish(new SessionHeartbeatEvent(this));\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.View.loadPartialEntities",
	"Comment": "if true, the view affects loading of local attributes. if false, only reference attributes are affected andlocal are always loaded.",
	"Method": "boolean loadPartialEntities(){\r\n    return loadPartialEntities;\r\n}"
}, {
	"Path": "com.haulmont.cuba.gui.DialogOptions.setHeightAuto",
	"Comment": "set height of a window to auto if it will be opened as a dialog or change height at run time if the window is already opened as a dialog.",
	"Method": "DialogOptions setHeightAuto(){\r\n    return setHeight(AUTO_SIZE);\r\n}"
}, {
	"Path": "org.crsh.telnet.term.console.TermIOBuffer.replace",
	"Comment": "replace all the characters before the cursor by the provided char sequence.",
	"Method": "CharSequence replace(CharSequence s){\r\n    StringBuilder builder = new StringBuilder();\r\n    boolean flush = false;\r\n    for (int i = appendDel(); i != -1; i = appendDel()) {\r\n        builder.append((char) i);\r\n        flush = true;\r\n    }\r\n    flush |= appendData(s, 0, s.length());\r\n    if (flush) {\r\n        io.flush();\r\n    }\r\n    return builder.reverse().toString();\r\n}"
}, {
	"Path": "com.haulmont.bali.db.BeanProcessor.newInstance",
	"Comment": "factory method that returns a new instance of the given class.thisis called at the start of the bean creation process and may beoverridden to provide custom behavior like returning a cached beaninstance.",
	"Method": "Object newInstance(Class c){\r\n    try {\r\n        return c.newInstance();\r\n    } catch (InstantiationException | IllegalAccessException e) {\r\n        throw new SQLException(\"Cannot create \" + c.getName() + \": \" + e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.global.ValueLoadContext.setIdName",
	"Comment": "sets name of the property that represents an identifier of the returned keyvalueentity.",
	"Method": "void setIdName(String idName){\r\n    this.idName = idName;\r\n}"
}, {
	"Path": "com.haulmont.cuba.core.sys.javacl.compiler.FileManagerImpl.getFileForInput",
	"Comment": "for a given file location, return a fileobject from which the compiler can obtain source or byte code.",
	"Method": "FileObject getFileForInput(Location location,String packageName,String relativeName){\r\n    FileObject o = fileObjects.get(uri(location, packageName, relativeName));\r\n    if (o != null)\r\n        return o;\r\n    return super.getFileForInput(location, packageName, relativeName);\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.gui.components.WebComponentsHelper.isComponentVisibleToClient",
	"Comment": "checks if the component should be visible to the client. returns false ifthe child should not be sent to the client, true otherwise.",
	"Method": "boolean isComponentVisibleToClient(Component child){\r\n    if (!child.isVisible()) {\r\n        return false;\r\n    }\r\n    HasComponents parent = child.getParent();\r\n    if (parent instanceof SelectiveRenderer) {\r\n        if (!((SelectiveRenderer) parent).isRendered(child)) {\r\n            return false;\r\n        }\r\n    }\r\n    if (parent != null) {\r\n        return isComponentVisibleToClient(parent);\r\n    } else {\r\n        if (child instanceof UI) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.addons.dragdroplayouts.DDVerticalSplitPanel.setDropHandler",
	"Comment": "sets the current handler which handles dropped components on the layout.by setting a drop handler dropping components on the layout is enabled.by setting the drophandler to null dropping is disabled.",
	"Method": "void setDropHandler(DropHandler dropHandler){\r\n    DDUtil.verifyHandlerType(this, dropHandler);\r\n    if (this.dropHandler != dropHandler) {\r\n        this.dropHandler = dropHandler;\r\n        markAsDirty();\r\n    }\r\n}"
}, {
	"Path": "com.haulmont.cuba.web.widgets.client.addons.dragdroplayouts.ui.accordion.VDDAccordion.updateDragDetails",
	"Comment": "updates the drop details while dragging. this is needed to ensure clientside criterias can validate the drop location.",
	"Method": "void updateDragDetails(VDragEvent event){\r\n    if (event.getElementOver() == null) {\r\n        return;\r\n    }\r\n    StackItem tab = WidgetUtil.findWidget(event.getElementOver(), StackItem.class);\r\n    if (tab != null && getElement().isOrHasChild(tab.getElement())) {\r\n        Map<String, Object> dropDetails = event.getDropDetails();\r\n        int index = getTabPosition(tab);\r\n        dropDetails.put(Constants.DROP_DETAIL_TO, index);\r\n        VerticalDropLocation location = getDropLocation(tab, event);\r\n        dropDetails.put(Constants.DROP_DETAIL_VERTICAL_DROP_LOCATION, location);\r\n        MouseEventDetails details = MouseEventDetailsBuilder.buildMouseEventDetails(event.getCurrentGwtEvent(), getElement());\r\n        dropDetails.put(Constants.DROP_DETAIL_MOUSE_EVENT, details.serialize());\r\n    }\r\n}"
}, {
	"Path": "org.crsh.plugin.Embedded.createCommandFS",
	"Comment": "create the command file system from the crash.mountpointconfig.cmd servlet context parameter.",
	"Method": "FS createCommandFS(){\r\n    return createFS(resolveCmdMountPointConfig());\r\n}"
}, {
	"Path": "org.crsh.telnet.term.console.TermIOBuffer.getSize",
	"Comment": "returns the total number of chars in the buffer, independently of the cursor position.",
	"Method": "int getSize(){\r\n    return size;\r\n}"
}]