[{
	"Path": "io.ebean.config.ServerConfig.setChangeLogListener",
	"Comment": "set the changeloglistener which actually performs the logging of change setsin the background.",
	"Method": "void setChangeLogListener(ChangeLogListener changeLogListener){\r\n    this.changeLogListener = changeLogListener;\r\n}"
}, {
	"Path": "io.ebean.meta.BasicMetricVisitor.getTimedMetrics",
	"Comment": "return timed metrics for transactions, labelled sqlquery, labelled sqlupdate.",
	"Method": "List<MetaTimedMetric> getTimedMetrics(){\r\n    return timed;\r\n}"
}, {
	"Path": "cyclops.kinds.CompletableFutureKind.narrowK",
	"Comment": "convert the higherkindedtype definition for a completablefuture into",
	"Method": "CompletableFuture<T> narrowK(Higher<DataWitness.completableFuture, T> completableFuture){\r\n    if (completableFuture instanceof CompletionStage) {\r\n        final CompletionStage<T> ft = (CompletionStage<T>) completableFuture;\r\n        return CompletableFuture.completedFuture(1).thenCompose(f -> ft);\r\n    }\r\n    final Box<T> type = (Box<T>) completableFuture;\r\n    final CompletionStage<T> stage = type.narrow();\r\n    return CompletableFuture.completedFuture(1).thenCompose(f -> stage);\r\n}"
}, {
	"Path": "io.ebean.config.DbConstraintNormalise.lowerColumnName",
	"Comment": "lower case the column name checking for quoted identifiers.",
	"Method": "String lowerColumnName(String name){\r\n    if (lowerCaseColumns && notQuoted(name)) {\r\n        return name.toLowerCase();\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.BasicTypeConverter.toBigDecimal",
	"Comment": "convert the passed in object to a bigdecimal. it should be anothernumeric type.",
	"Method": "BigDecimal toBigDecimal(Object value){\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    if (value instanceof BigDecimal) {\r\n        return (BigDecimal) value;\r\n    }\r\n    return new BigDecimal(value.toString());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.getVersionsBetweenSuffix",
	"Comment": "return the versions between timestamp suffix based on the dbhistorysupport.",
	"Method": "String getVersionsBetweenSuffix(DatabasePlatform databasePlatform,ServerConfig serverConfig){\r\n    DbHistorySupport historySupport = databasePlatform.getHistorySupport();\r\n    return (historySupport == null) ? serverConfig.getAsOfViewSuffix() : historySupport.getVersionsBetweenSuffix(serverConfig.getAsOfViewSuffix());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQueryBuilder.createSqlTree",
	"Comment": "build the sqltree.the sqltree is immutable after construction and so is safe to use byconcurrent threads.the predicates is used to add additional joins that come from the where ororder by clauses that are not already included for the select clause.",
	"Method": "SqlTree createSqlTree(OrmQueryRequest<?> request,CQueryPredicates predicates){\r\n    if (request.isNativeSql()) {\r\n        return createNativeSqlTree(request, predicates);\r\n    }\r\n    if (request.isRawSql()) {\r\n        return createRawSqlSqlTree(request, predicates);\r\n    }\r\n    return new SqlTreeBuilder(this, request, predicates).build();\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getAsOfViewSuffix",
	"Comment": "return the suffix appended to the base table to derive the view that contains the unionof the base table and the history table in order to support asof queries.",
	"Method": "String getAsOfViewSuffix(){\r\n    return asOfViewSuffix;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.JdbcTransaction.isRegisteredBean",
	"Comment": "return true if this is a bean that has already been saved. this willregister the bean if it is not already.",
	"Method": "boolean isRegisteredBean(Object bean){\r\n    if (persistingBeans == null) {\r\n        persistingBeans = new IdentityHashMap();\r\n    }\r\n    return (persistingBeans.put(bean, PLACEHOLDER) != null);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.SortedSetX.iterate",
	"Comment": "create a sortedsetx by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "SortedSetX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).sortedSetX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.OrmQueryDetail.isQueryJoinCandidate",
	"Comment": "return true if this path is a candidate for converting to a query join.",
	"Method": "boolean isQueryJoinCandidate(String lazyLoadManyPath,OrmQueryProperties chunk){\r\n    return chunk.isFetchJoin() && !isLazyLoadManyRoot(lazyLoadManyPath, chunk) && !hasParentSecJoin(lazyLoadManyPath, chunk);\r\n}"
}, {
	"Path": "io.ebean.Ebean.currentTransaction",
	"Comment": "returns the current transaction or null if there is no current transactionin scope.",
	"Method": "Transaction currentTransaction(){\r\n    return serverMgr.getDefaultServer().currentTransaction();\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DbPlatformType.renderType",
	"Comment": "return the type for a specific property that incorporates the name, length,precision and scale.the deploylength and deployscale are for the property we are rendering thedb type for.",
	"Method": "String renderType(int deployLength,int deployScale,String renderType,int deployLength,int deployScale,boolean strict){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(name);\r\n    if (canHaveLength || !strict) {\r\n        renderLengthScale(deployLength, deployScale, sb);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.type.TypeReflectHelper.asEnumClass",
	"Comment": "return the enum class for this type taking into account wildcard type.",
	"Method": "Class<? extends Enum<?>> asEnumClass(Type valueType){\r\n    Class<?> enumClass = getClass(valueType);\r\n    return (Class<? extends Enum<?>>) enumClass;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorCacheHelp.manyPropGet",
	"Comment": "return the cachedmanyids for a given bean many property. returns null if not in the cache.",
	"Method": "CachedManyIds manyPropGet(Object parentId,String propertyName){\r\n    ServerCache collectionIdsCache = cacheManager.getCollectionIdsCache(beanType, propertyName);\r\n    CachedManyIds entry = (CachedManyIds) collectionIdsCache.get(parentId);\r\n    if (entry == null) {\r\n        if (manyLog.isTraceEnabled()) {\r\n            manyLog.trace(\"   GET {}({}).{} - cache miss\", cacheName, parentId, propertyName);\r\n        }\r\n    } else if (manyLog.isDebugEnabled()) {\r\n        manyLog.debug(\"   GET {}({}).{} - hit\", cacheName, parentId, propertyName);\r\n    }\r\n    return entry;\r\n}"
}, {
	"Path": "io.ebean.config.DocStoreConfig.setUsername",
	"Comment": "set the user credential for connecting to the document store.",
	"Method": "void setUsername(String username){\r\n    this.username = username;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.TransactionManager.collectMetricReadOnly",
	"Comment": "collect execution time for implicit read only transaction.",
	"Method": "void collectMetricReadOnly(long exeMicros){\r\n    txnReadOnly.add(exeMicros);\r\n}"
}, {
	"Path": "cyclops.monads.transformers.reactor.MonoT.of",
	"Comment": "construct an monot from an anym that wraps a monad containingmonows",
	"Method": "MonoT<W, A> of(AnyM<W, Mono<A>> monads){\r\n    return new MonoT(monads);\r\n}"
}, {
	"Path": "io.ebean.config.AutoTuneConfig.setSkipProfileReportingOnShutdown",
	"Comment": "set to true if profile reporting should be skipped on shutdown.",
	"Method": "void setSkipProfileReportingOnShutdown(boolean skipProfileReportingOnShutdown){\r\n    this.skipProfileReportingOnShutdown = skipProfileReportingOnShutdown;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.type.ScalarTypeBaseDateTime.toJsonNanos",
	"Comment": "helper method that given epoch seconds and nanos return a json nanos formatted string.",
	"Method": "String toJsonNanos(T value,String toJsonNanos,long epochSecs,int nanos){\r\n    return DecimalUtils.toDecimal(epochSecs, nanos);\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DatabasePlatform.getBlobDbType",
	"Comment": "return the data type that should be used for blob.this is typically types.blob but for postgres is types.longvarbinary forexample.",
	"Method": "int getBlobDbType(){\r\n    return blobDbType;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.Binder.isMultiValueSupported",
	"Comment": "return true if multivalue binding is supported for the given type.",
	"Method": "boolean isMultiValueSupported(Class<?> cls){\r\n    try {\r\n        ScalarType<?> scalarType = getScalarType(cls);\r\n        return multiValueBind.isTypeSupported(scalarType.getJdbcType());\r\n    } catch (PersistenceException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.oath.cyclops.anym.AnyMSeq.forEach4",
	"Comment": "perform a four level nested internal iteration over this monad and thesupplied monads",
	"Method": "AnyMSeq<W, R> forEach4(Function<? super T, ? extends AnyM<W, R1>> monad1,BiFunction<? super T, ? super R1, ? extends AnyM<W, R2>> monad2,Function3<? super T, ? super R1, ? super R2, ? extends AnyM<W, R3>> monad3,Function4<? super T, ? super R1, ? super R2, ? super R3, ? extends R> yieldingFunction,AnyMSeq<W, R> forEach4,Function<? super T, ? extends AnyM<W, R1>> monad1,BiFunction<? super T, ? super R1, ? extends AnyM<W, R2>> monad2,Function3<? super T, ? super R1, ? super R2, ? extends AnyM<W, R3>> monad3,Function4<? super T, ? super R1, ? super R2, ? super R3, Boolean> filterFunction,Function4<? super T, ? super R1, ? super R2, ? super R3, ? extends R> yieldingFunction){\r\n    return this.flatMapA(in -> {\r\n        AnyM<W, R1> a = monad1.apply(in);\r\n        return a.flatMapA(ina -> {\r\n            AnyM<W, R2> b = monad2.apply(in, ina);\r\n            return b.flatMapA(inb -> {\r\n                AnyM<W, R3> c = monad3.apply(in, ina, inb);\r\n                return c.filter(in2 -> filterFunction.apply(in, ina, inb, in2)).map(in2 -> yieldingFunction.apply(in, ina, inb, in2));\r\n            });\r\n        });\r\n    });\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setObjectMapper",
	"Comment": "set the jackson objectmapper.note that this is not strongly typed as jackson objectmapper is an optional dependency.",
	"Method": "void setObjectMapper(Object objectMapper){\r\n    this.objectMapper = objectMapper;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.readaudit.DefaultReadAuditLogger.auditMany",
	"Comment": "write the many beans read event details in json format to the logger.",
	"Method": "void auditMany(ReadEvent readMany){\r\n    writeEvent(readMany);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.JdbcTransaction.getPersistenceContext",
	"Comment": "return the persistence context associated with this transaction.",
	"Method": "PersistenceContext getPersistenceContext(){\r\n    return persistenceContext;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.BagX.range",
	"Comment": "create a bagx that contains the integers between skip and take",
	"Method": "BagX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).bagX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.rawsql.DRawSql.getColumnMapping",
	"Comment": "return the column mapping for the sql columns to bean properties.",
	"Method": "ColumnMapping getColumnMapping(){\r\n    return columnMapping;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentQueueX.widen2",
	"Comment": "widen a persistentqueuex nest inside another hkt encoded type",
	"Method": "Higher<C2, Higher<persistentQueueX, T>> widen2(Higher<C2, PersistentQueueX<T>> list){\r\n    return (Higher) list;\r\n}"
}, {
	"Path": "cyclops.futurestream.FutureStream.permutations",
	"Comment": "generate the permutations based on values in the futurestreammakes use of streamable to store intermediate stages in a tox",
	"Method": "FutureStream<ReactiveSeq<U>> permutations(){\r\n    return this.fromStream(ReactiveSeq.oneShotStream(stream()).permutations());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocOne.isOneToOne",
	"Comment": "return true if this a onetoone property. otherwise assumed manytoone.",
	"Method": "boolean isOneToOne(){\r\n    return oneToOne;\r\n}"
}, {
	"Path": "io.ebean.config.AutoTuneConfig.setMode",
	"Comment": "set the mode used when autotune has not been explicit defined on a query.",
	"Method": "void setMode(AutoTuneMode mode){\r\n    this.mode = mode;\r\n}"
}, {
	"Path": "cyclops.companion.Streamable.permutations",
	"Comment": "generate the permutations based on values in the streamable",
	"Method": "Streamable<ReactiveSeq<T>> permutations(){\r\n    return Streamable.fromStream(stream().permutations());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.DeployParser.readLiteral",
	"Comment": "read the rest of a literal value. these do not get translated so are justread and appended to the string builder.",
	"Method": "void readLiteral(){\r\n    while (++pos < sourceLength) {\r\n        char ch = source.charAt(pos);\r\n        sb.append(ch);\r\n        if (ch == SINGLE_QUOTE) {\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.TableName.getQualifiedName",
	"Comment": "returns the qualified name in the form catalog.schema.name.catalog and schema are optional.",
	"Method": "String getQualifiedName(){\r\n    StringBuilder buffer = new StringBuilder();\r\n    if (catalog != null) {\r\n        buffer.append(catalog);\r\n    }\r\n    if (schema != null) {\r\n        if (buffer.length() > 0) {\r\n            buffer.append(\".\");\r\n        }\r\n        buffer.append(schema);\r\n    }\r\n    if (buffer.length() > 0) {\r\n        buffer.append(\".\");\r\n    }\r\n    buffer.append(name);\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "io.ebean.event.BeanPersistAdapter.preSoftDelete",
	"Comment": "returns true indicating normal processing should continue.",
	"Method": "boolean preSoftDelete(BeanPersistRequest<?> request){\r\n    return true;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.InheritInfo.findSubTypeProperty",
	"Comment": "get the bean property additionally looking in the sub types.",
	"Method": "BeanProperty findSubTypeProperty(String propertyName){\r\n    BeanProperty prop;\r\n    for (InheritInfo childInfo : children) {\r\n        prop = childInfo.desc().findProperty(propertyName);\r\n        if (prop != null) {\r\n            return prop;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.ChainedBeanPostLoad.register",
	"Comment": "register a new beanpostload and return the resulting chain.",
	"Method": "ChainedBeanPostLoad register(BeanPostLoad c){\r\n    if (list.contains(c)) {\r\n        return this;\r\n    } else {\r\n        List<BeanPostLoad> newList = new ArrayList(list);\r\n        newList.add(c);\r\n        return new ChainedBeanPostLoad(newList);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.JdbcTransaction.getBatchSize",
	"Comment": "return the batchsize specifically set for this transaction or 0.returning 0 implies to use the system wide default batch size.",
	"Method": "int getBatchSize(){\r\n    return batchSize;\r\n}"
}, {
	"Path": "io.ebean.OrderBy.hashCode",
	"Comment": "return a hash value for this orderby. this can be to determine logicalequality for orderby clauses.",
	"Method": "int hashCode(int hashCode){\r\n    return list.hashCode();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.setBoundId",
	"Comment": "set the id value that was bound. used for the purposes of logging summary information on thisrequest.",
	"Method": "void setBoundId(Object idValue){\r\n    this.idValue = idValue;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.BatchedPstmtHolder.getStmt",
	"Comment": "return the preparedstatement if it has already been used in this batch.this will return null if no matching preparedstatement is found.",
	"Method": "PreparedStatement getStmt(String stmtKey,BatchPostExecute postExecute){\r\n    BatchedPstmt batchedPstmt = getBatchedPstmt(stmtKey, postExecute);\r\n    return (batchedPstmt == null) ? null : batchedPstmt.getStatement();\r\n}"
}, {
	"Path": "io.ebean.BaseTestCase.sqlOf",
	"Comment": "return the generated sql trimming column alias if required.",
	"Method": "String sqlOf(Query<?> query,String sqlOf,Query<?> query,int columns){\r\n    return trimSql(query.getGeneratedSql(), columns);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.isCacheNotify",
	"Comment": "return true if the persist request needs to notify the cache.",
	"Method": "boolean isCacheNotify(PersistRequest.Type type,boolean publish){\r\n    if (draftable && !publish) {\r\n        return false;\r\n    }\r\n    return cacheHelp.isCacheNotify(type);\r\n}"
}, {
	"Path": "io.ebean.config.TableName.parse",
	"Comment": "parse a qualifiedtablename that might include a catalog and schema and just return the table name.",
	"Method": "String parse(String qualifiedTableName){\r\n    return new TableName(qualifiedTableName).getName();\r\n}"
}, {
	"Path": "cyclops.function.Memoize.memoizeBiFunctionAsync",
	"Comment": "memoize this function and update cached values on a scheduledoes not support null keys",
	"Method": "Function2<T1, T2, R> memoizeBiFunctionAsync(BiFunction<T1, T2, R> fn,ScheduledExecutorService ex,long updateRateInMillis,Function2<T1, T2, R> memoizeBiFunctionAsync,BiFunction<T1, T2, R> fn,ScheduledExecutorService ex,String cron){\r\n    val memoise2 = memoizeFunctionAsync((final Tuple2<T1, T2> pair) -> fn.apply(pair._1(), pair._2()), ex, cron);\r\n    return (t1, t2) -> memoise2.apply(tuple(t1, t2));\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.VectorX.rangeLong",
	"Comment": "create a vectorx that contains the longs between skip and take",
	"Method": "VectorX<Long> rangeLong(long start,long end){\r\n    return ReactiveSeq.rangeLong(start, end).to(ReactiveConvertableSequence::converter).vectorX(LAZY);\r\n}"
}, {
	"Path": "com.oath.cyclops.util.box.LazyImmutable.map",
	"Comment": "map the value stored in this immutable closed value from one value to anotherif this is an unitiatilised immutableclosedvalue, an uninitialised closed value will be returned instead",
	"Method": "LazyImmutable<R> map(Function<? super T, ? extends R> fn){\r\n    final T val = get();\r\n    if (val == UNSET)\r\n        return (LazyImmutable<R>) this;\r\n    else\r\n        return LazyImmutable.of(fn.apply(val));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.BeanRequest.rollbackTransIfRequired",
	"Comment": "rollback the transaction if it was created for this request.",
	"Method": "void rollbackTransIfRequired(){\r\n    if (createdTransaction) {\r\n        try {\r\n            ebeanServer.endTransaction();\r\n        } catch (Exception e) {\r\n            log.error(\"Error trying to rollback a transaction (after a prior exception thrown)\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.DbMigrationConfig.getRunnerConfig",
	"Comment": "return the underlying migration runner configuration allowing for more advanced settings.",
	"Method": "MigrationConfig getRunnerConfig(){\r\n    return runnerConfig;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.addDocStoreUpdates",
	"Comment": "for requests that update document store add this event to either the listof queue events or list of update events.",
	"Method": "void addDocStoreUpdates(DocStoreUpdates docStoreUpdates){\r\n    if (type == Type.UPDATE) {\r\n        beanDescriptor.docStoreUpdateEmbedded(this, docStoreUpdates);\r\n    }\r\n    switch(docStoreMode) {\r\n        case UPDATE:\r\n            {\r\n                docStoreUpdates.addPersist(this);\r\n                return;\r\n            }\r\n        case QUEUE:\r\n            {\r\n                if (type == Type.DELETE) {\r\n                    docStoreUpdates.queueDelete(beanDescriptor.getDocStoreQueueId(), idValue);\r\n                } else {\r\n                    docStoreUpdates.queueIndex(beanDescriptor.getDocStoreQueueId(), idValue);\r\n                }\r\n            }\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "cyclops.monads.transformers.jdk.CompletableFutureT.fromAnyM",
	"Comment": "construct an futuret from an anym that contains a monad type that contains type other than futurethe values in the underlying monad will be mapped to completablefuture",
	"Method": "CompletableFutureT<W, A> fromAnyM(AnyM<W, A> anyM){\r\n    return of(anyM.map(e -> {\r\n        CompletableFuture<A> f = new CompletableFuture<A>();\r\n        f.complete(e);\r\n        return f;\r\n    }));\r\n}"
}, {
	"Path": "io.ebean.OrderBy.containsProperty",
	"Comment": "return true if the property is known to be contained in the order by clause.",
	"Method": "boolean containsProperty(String propertyName){\r\n    for (Property aList : list) {\r\n        if (propertyName.equals(aList.getProperty())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.ebean.Pairs.add",
	"Comment": "add a pair of value objects.both values are expected to be immutable with equals and hashcode implementations.",
	"Method": "Pairs add(Object a,Object b){\r\n    entries.add(new Entry(a, b));\r\n    return this;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.Same.sameByValue",
	"Comment": "return true if both collections are the same by value and order is taken into account.",
	"Method": "boolean sameByValue(Object v1,Object v2,boolean sameByValue,Collection<?> v1,Collection<?> v2){\r\n    if (v1 == null) {\r\n        return v2 == null;\r\n    }\r\n    if (v2 == null || v1.size() != v2.size()) {\r\n        return false;\r\n    }\r\n    Iterator<?> thisIt = v1.iterator();\r\n    Iterator<?> thatIt = v2.iterator();\r\n    while (thisIt.hasNext() && thatIt.hasNext()) {\r\n        if (!thisIt.next().equals(thatIt.next())) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQuery.auditFindMany",
	"Comment": "a find many query with read auditing so build the readevent and log it.",
	"Method": "void auditFindMany(){\r\n    if (auditIds != null && !auditIds.isEmpty()) {\r\n        ReadEvent futureReadEvent = query.getFutureFetchAudit();\r\n        if (futureReadEvent == null) {\r\n            desc.readAuditMany(queryPlan.getAuditQueryKey(), bindLog, auditIds);\r\n        } else {\r\n            futureReadEvent.setQueryKey(queryPlan.getAuditQueryKey());\r\n            futureReadEvent.setBindLog(bindLog);\r\n            futureReadEvent.setIds(auditIds);\r\n            desc.readAuditFutureMany(futureReadEvent);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorCacheHelp.setupContext",
	"Comment": "for a bean built from the cache this sets up its persistence context for future lazy loading etc.",
	"Method": "void setupContext(Object bean,PersistenceContext context){\r\n    if (context == null) {\r\n        context = new DefaultPersistenceContext();\r\n    }\r\n    EntityBean entityBean = (EntityBean) bean;\r\n    EntityBeanIntercept ebi = entityBean._ebean_getIntercept();\r\n    ebi.setPersistenceContext(context);\r\n    Object id = desc.getId(entityBean);\r\n    desc.contextPut(context, id, bean);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.parse.AnnotationParser.readEmbeddedAttributeOverrides",
	"Comment": "read an attributeoverrides if they exist for this embedded bean.",
	"Method": "void readEmbeddedAttributeOverrides(DeployBeanPropertyAssocOne<?> prop){\r\n    Set<AttributeOverride> attrOverrides = getAll(prop, AttributeOverride.class);\r\n    if (!attrOverrides.isEmpty()) {\r\n        HashMap<String, String> propMap = new HashMap(attrOverrides.size());\r\n        for (AttributeOverride attrOverride : attrOverrides) {\r\n            propMap.put(attrOverride.name(), attrOverride.column().name());\r\n        }\r\n        prop.getDeployEmbedded().putAll(propMap);\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DbViewHistorySupport.getSysPeriodLower",
	"Comment": "return the lower bound column prepended with the table alias.",
	"Method": "String getSysPeriodLower(String tableAlias,String sysPeriod){\r\n    return tableAlias + \".\" + sysPeriod + \"_start\";\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.InheritInfo.readType",
	"Comment": "return the associated inheritinfo for this discriminator value.",
	"Method": "InheritInfo readType(DbReadContext ctx,InheritInfo readType,String discValue,InheritInfo readType,Class<?> beanType){\r\n    InheritInfo typeInfo = root.getTypeByClass(beanType);\r\n    if (typeInfo == null) {\r\n        throw new PersistenceException(\"Inheritance type for bean type [\" + beanType.getName() + \"] was not found?\");\r\n    }\r\n    return typeInfo;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setAsOfViewSuffix",
	"Comment": "set the suffix appended to the base table to derive the view that contains the unionof the base table and the history table in order to support asof queries.",
	"Method": "void setAsOfViewSuffix(String asOfViewSuffix){\r\n    this.asOfViewSuffix = asOfViewSuffix;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.SqlTreeNodeExtraJoin.isManyJoin",
	"Comment": "return true if the extra join is a many join.this means we need to add distinct to the sql query.",
	"Method": "boolean isManyJoin(){\r\n    return manyJoin;\r\n}"
}, {
	"Path": "io.ebean.config.DbMigrationConfig.getPatchInsertOn",
	"Comment": "return migration versions that should be added to history without running.",
	"Method": "String getPatchInsertOn(){\r\n    return patchInsertOn;\r\n}"
}, {
	"Path": "io.ebean.config.PlatformConfig.getDatabaseSequenceBatchSize",
	"Comment": "return the number of db sequence values that should be preallocated.",
	"Method": "int getDatabaseSequenceBatchSize(){\r\n    return databaseSequenceBatchSize;\r\n}"
}, {
	"Path": "io.ebeanservice.docstore.api.mapping.DocMappingBuilder.applyMapping",
	"Comment": "apply any override mappings from the top level docstore annotation.",
	"Method": "void applyMapping(){\r\n    DocMapping[] mapping = docStore.mapping();\r\n    for (DocMapping docMapping : mapping) {\r\n        applyFieldMapping(null, docMapping);\r\n    }\r\n}"
}, {
	"Path": "org.tests.cache.TestCacheCollectionIds.testUpdatingCollectionCacheForManyToManyRelations",
	"Comment": "when updating a manytomany relations also the collection cache must be updated.",
	"Method": "void testUpdatingCollectionCacheForManyToManyRelations(){\r\n    ResetBasicData.reset();\r\n    OCachedBean cachedBean = new OCachedBean();\r\n    cachedBean.setName(\"hello\");\r\n    cachedBean.getCountries().add(Ebean.find(Country.class, \"NZ\"));\r\n    cachedBean.getCountries().add(Ebean.find(Country.class, \"AU\"));\r\n    Ebean.save(cachedBean);\r\n    OCachedBean dummyToLoad = Ebean.find(OCachedBean.class, cachedBean.getId());\r\n    dummyToLoad.getCountries().size();\r\n    ServerCache cachedBeanCountriesCache = cacheManager.getCollectionIdsCache(OCachedBean.class, \"countries\");\r\n    CachedManyIds cachedManyIds = (CachedManyIds) cachedBeanCountriesCache.get(cachedBean.getId());\r\n    assertEquals(2, dummyToLoad.getCountries().size());\r\n    assertEquals(2, cachedManyIds.getIdList().size());\r\n    OCachedBean loadedBean = Ebean.find(OCachedBean.class, cachedBean.getId());\r\n    loadedBean.getCountries().clear();\r\n    loadedBean.getCountries().add(Ebean.find(Country.class, \"AU\"));\r\n    Ebean.save(loadedBean);\r\n    awaitL2Cache();\r\n    OCachedBean result = Ebean.find(OCachedBean.class, cachedBean.getId());\r\n    cachedManyIds = (CachedManyIds) cachedBeanCountriesCache.get(result.getId());\r\n    assertEquals(1, result.getCountries().size());\r\n    assertEquals(1, cachedManyIds.getIdList().size());\r\n    assertFalse(cachedManyIds.getIdList().contains(\"NZ\"));\r\n    assertTrue(cachedManyIds.getIdList().contains(\"AU\"));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQueryBuilder.prefixOrderByFields",
	"Comment": "split the order by claus on the field delimiter and prefix each field withthe relation name",
	"Method": "String prefixOrderByFields(String name,String orderBy){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (String token : orderBy.split(\",\")) {\r\n        if (sb.length() > 0) {\r\n            sb.append(\", \");\r\n        }\r\n        sb.append(name);\r\n        sb.append(\".\");\r\n        sb.append(token.trim());\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "io.ebean.text.json.JsonReadOptions.getPersistenceContext",
	"Comment": "return the persistence context to use when marshalling json.",
	"Method": "PersistenceContext getPersistenceContext(){\r\n    return persistenceContext;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.parse.DeployCreateProperties.determineTargetType",
	"Comment": "determine the type of the list,set or map. not been set explicitly so determine this fromparameterizedtype.",
	"Method": "Class<?> determineTargetType(Field field){\r\n    Type genType = field.getGenericType();\r\n    if (genType instanceof ParameterizedType) {\r\n        ParameterizedType ptype = (ParameterizedType) genType;\r\n        Type[] typeArgs = ptype.getActualTypeArguments();\r\n        if (typeArgs.length == 1) {\r\n            if (typeArgs[0] instanceof Class<?>) {\r\n                return (Class<?>) typeArgs[0];\r\n            }\r\n            return null;\r\n        }\r\n        if (typeArgs.length == 2) {\r\n            if (typeArgs[1] instanceof ParameterizedType) {\r\n                return null;\r\n            }\r\n            if (typeArgs[1] instanceof WildcardType) {\r\n                return Object.class;\r\n            }\r\n            return (Class<?>) typeArgs[1];\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.OrmQueryProperties.isSameByAutoTune",
	"Comment": "return true if the properties are the same for autotune purposes.",
	"Method": "boolean isSameByAutoTune(OrmQueryProperties p2){\r\n    if (included == null) {\r\n        return p2 == null || p2.included == null;\r\n    } else if (p2 == null) {\r\n        return false;\r\n    }\r\n    return included.equals(p2.included);\r\n}"
}, {
	"Path": "io.ebean.Ebean.createSqlQuery",
	"Comment": "create a sqlquery for executing native sqlquery statements.note that you can use raw sql with entity beans, refer to the sqlselectannotation for examples.",
	"Method": "SqlQuery createSqlQuery(String sql){\r\n    return serverMgr.getDefaultServer().createSqlQuery(sql);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.SqlTreeNodeBean.appendFromBaseTable",
	"Comment": "join to base table for this node. this includes a join to the intersectiontable if this is a manytomany node.",
	"Method": "SqlJoinType appendFromBaseTable(DbSqlContext ctx,SqlJoinType joinType){\r\n    SqlJoinType sqlJoinType = appendFromAsJoin(ctx, joinType);\r\n    if (temporalMode != SpiQuery.TemporalMode.SOFT_DELETED && desc.isSoftDelete()) {\r\n        ctx.append(\"and \").append(desc.getSoftDeletePredicate(ctx.getTableAlias(prefix))).append(\" \");\r\n    }\r\n    return sqlJoinType;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.LinkedListX.iterate",
	"Comment": "create a linkedlistx by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "LinkedListX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).linkedListX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.SqlTreeBuilder.isIncludeMany",
	"Comment": "return true if this many node should be included in the query.",
	"Method": "boolean isIncludeMany(String propName,STreePropertyAssocMany manyProp){\r\n    if (queryDetail.isJoinsEmpty()) {\r\n        return false;\r\n    }\r\n    if (queryDetail.includesPath(propName)) {\r\n        if (manyProperty != null) {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Not joining [\" + propName + \"] as already joined to a Many[\" + manyProperty + \"].\");\r\n            }\r\n            return false;\r\n        }\r\n        manyProperty = manyProp;\r\n        summary.append(\" +many:\").append(propName);\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.SaveManyBeans.canSkipForOrderColumn",
	"Comment": "return true if we can skip based on .. no modifications to the collection and no beans are dirty.",
	"Method": "boolean canSkipForOrderColumn(){\r\n    return value instanceof BeanCollection && !((BeanCollection<?>) value).wasTouched() && noDirtyBeans();\r\n}"
}, {
	"Path": "io.ebean.TxScope.setSkipGeneratedKeys",
	"Comment": "set if the transaction should skip reading generated keys for inserts.",
	"Method": "TxScope setSkipGeneratedKeys(){\r\n    this.skipGeneratedKeys = true;\r\n    return this;\r\n}"
}, {
	"Path": "io.ebeaninternal.json.DJsonService.parseSet",
	"Comment": "parse the json returning as a set taking into account the current token.",
	"Method": "Set<T> parseSet(String json,boolean modifyAware,Set<T> parseSet,JsonParser parser,JsonToken currentToken){\r\n    return new LinkedHashSet(parseList(parser, currentToken));\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.DequeX.fromIterable",
	"Comment": "construct a deque from the provided collector and iterable.",
	"Method": "DequeX<T> fromIterable(Iterable<T> it,DequeX<T> fromIterable,Collector<T, ?, Deque<T>> collector,Iterable<T> it){\r\n    if (it instanceof DequeX)\r\n        return ((DequeX) it).type(collector);\r\n    if (it instanceof Deque)\r\n        return new LazyDequeX<T>((Deque) it, collector, LAZY);\r\n    return new LazyDequeX<T>(Streams.stream(it).collect(collector), collector, LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.PlatformDdl.createWithHistory",
	"Comment": "add history support to this table using the platform specific mechanism.",
	"Method": "void createWithHistory(DdlWrite writer,MTable table){\r\n    historyDdl.createWithHistory(writer, table);\r\n}"
}, {
	"Path": "cyclops.function.Reducer.mapToType",
	"Comment": "map this reducer to the supported type t.default implementation is a simple cast.",
	"Method": "Stream<T> mapToType(Stream<U> stream){\r\n    return stream.map(conversion());\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.MColumn.compare",
	"Comment": "compare the column meta data and return true if there is a change that meansthe history table column needs",
	"Method": "void compare(ModelDiff modelDiff,MTable table,MColumn newColumn){\r\n    this.dbMigrationInfos = newColumn.dbMigrationInfos;\r\n    boolean tableWithHistory = table.isWithHistory();\r\n    String tableName = table.getName();\r\n    this.alterColumn = null;\r\n    boolean changeBaseAttribute = false;\r\n    if (historyExclude != newColumn.historyExclude) {\r\n        getAlterColumn(tableName, tableWithHistory).setHistoryExclude(newColumn.historyExclude);\r\n    }\r\n    if (different(type, newColumn.type)) {\r\n        changeBaseAttribute = true;\r\n        getAlterColumn(tableName, tableWithHistory).setType(newColumn.type);\r\n    }\r\n    if (notnull != newColumn.notnull) {\r\n        changeBaseAttribute = true;\r\n        getAlterColumn(tableName, tableWithHistory).setNotnull(newColumn.notnull);\r\n    }\r\n    if (different(defaultValue, newColumn.defaultValue)) {\r\n        AlterColumn alter = getAlterColumn(tableName, tableWithHistory);\r\n        if (newColumn.defaultValue == null) {\r\n            alter.setDefaultValue(DdlHelp.DROP_DEFAULT);\r\n        } else {\r\n            alter.setDefaultValue(newColumn.defaultValue);\r\n        }\r\n    }\r\n    if (different(comment, newColumn.comment)) {\r\n        AlterColumn alter = getAlterColumn(tableName, tableWithHistory);\r\n        if (newColumn.comment == null) {\r\n            alter.setComment(DdlHelp.DROP_COMMENT);\r\n        } else {\r\n            alter.setComment(newColumn.comment);\r\n        }\r\n    }\r\n    if (different(checkConstraint, newColumn.checkConstraint)) {\r\n        AlterColumn alter = getAlterColumn(tableName, tableWithHistory);\r\n        if (hasValue(checkConstraint) && !hasValue(newColumn.checkConstraint)) {\r\n            alter.setDropCheckConstraint(checkConstraintName);\r\n        }\r\n        if (hasValue(newColumn.checkConstraint)) {\r\n            alter.setCheckConstraintName(newColumn.checkConstraintName);\r\n            alter.setCheckConstraint(newColumn.checkConstraint);\r\n        }\r\n    }\r\n    if (different(references, newColumn.references) || hasValue(newColumn.references) && fkeyOnDelete != newColumn.fkeyOnDelete || hasValue(newColumn.references) && fkeyOnUpdate != newColumn.fkeyOnUpdate) {\r\n        AlterColumn alter = getAlterColumn(tableName, tableWithHistory);\r\n        if (hasValue(foreignKeyName)) {\r\n            alter.setDropForeignKey(foreignKeyName);\r\n        }\r\n        if (hasValue(foreignKeyIndex)) {\r\n            alter.setDropForeignKeyIndex(foreignKeyIndex);\r\n        }\r\n        if (hasValue(newColumn.references)) {\r\n            alter.setReferences(newColumn.references);\r\n            alter.setForeignKeyName(newColumn.foreignKeyName);\r\n            alter.setForeignKeyIndex(newColumn.foreignKeyIndex);\r\n            if (newColumn.fkeyOnDelete != null) {\r\n                alter.setForeignKeyOnDelete(fkeyModeOf(newColumn.fkeyOnDelete));\r\n            }\r\n            if (newColumn.fkeyOnUpdate != null) {\r\n                alter.setForeignKeyOnUpdate(fkeyModeOf(newColumn.fkeyOnUpdate));\r\n            }\r\n        }\r\n    }\r\n    if (different(unique, newColumn.unique)) {\r\n        AlterColumn alter = getAlterColumn(tableName, tableWithHistory);\r\n        if (hasValue(unique)) {\r\n            alter.setDropUnique(unique);\r\n        }\r\n        if (hasValue(newColumn.unique)) {\r\n            alter.setUnique(newColumn.unique);\r\n        }\r\n    }\r\n    if (different(uniqueOneToOne, newColumn.uniqueOneToOne)) {\r\n        AlterColumn alter = getAlterColumn(tableName, tableWithHistory);\r\n        if (hasValue(uniqueOneToOne)) {\r\n            alter.setDropUnique(uniqueOneToOne);\r\n        }\r\n        if (hasValue(newColumn.uniqueOneToOne)) {\r\n            alter.setUniqueOneToOne(newColumn.uniqueOneToOne);\r\n        }\r\n    }\r\n    if (alterColumn != null) {\r\n        modelDiff.addAlterColumn(alterColumn);\r\n        if (changeBaseAttribute) {\r\n            alterColumn.setCurrentType(type);\r\n            alterColumn.setCurrentNotnull(notnull);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.autotune.service.ProfileManager.collectQueryInfo",
	"Comment": "gather query execution statistics. this could either be the originatingquery in which case the parentnode will be null, or a lazy loading queryresulting from traversal of the object graph.",
	"Method": "void collectQueryInfo(ObjectGraphNode node,long beans,long micros){\r\n    if (node != null) {\r\n        ObjectGraphOrigin origin = node.getOriginQueryPoint();\r\n        if (origin != null) {\r\n            ProfileOrigin stats = getProfileOrigin(origin);\r\n            stats.collectQueryInfo(node, beans, micros);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.DefaultConstraintMaxLength.maxLength",
	"Comment": "apply a maximum length to the constraint name.this implementation should work well apart from perhaps db2 where the limit is 18.",
	"Method": "String maxLength(String constraintName,int count){\r\n    if (constraintName.length() < maxConstraintNameLength) {\r\n        return constraintName;\r\n    }\r\n    if (maxConstraintNameLength < 60) {\r\n        constraintName = VowelRemover.trim(constraintName, 4);\r\n        if (constraintName.length() < maxConstraintNameLength) {\r\n            return constraintName;\r\n        }\r\n    }\r\n    return constraintName.substring(0, maxConstraintNameLength - 3) + \"_\" + count;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.DefaultPersister.getDeleteUnloadedForeignKeys",
	"Comment": "support for loading any imported associated one properties that are notloaded but required for delete cascade.",
	"Method": "DeleteUnloadedForeignKeys getDeleteUnloadedForeignKeys(PersistRequestBean<?> request){\r\n    DeleteUnloadedForeignKeys fkeys = null;\r\n    for (BeanPropertyAssocOne<?> one : request.getBeanDescriptor().propertiesOneImportedDelete()) {\r\n        if (!request.isLoadedProperty(one)) {\r\n            if (fkeys == null) {\r\n                fkeys = new DeleteUnloadedForeignKeys(server, request);\r\n            }\r\n            fkeys.add(one);\r\n        }\r\n    }\r\n    return fkeys;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanPropertyAssoc.getBeanTable",
	"Comment": "return the beantable for this association.this has the table name which is used to determine the relationship forthis association.",
	"Method": "BeanTable getBeanTable(){\r\n    return beanTable;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.isUpdateChangesOnly",
	"Comment": "return true if updates should only include changed properties. otherwiseall loaded properties are included in the update.",
	"Method": "boolean isUpdateChangesOnly(){\r\n    return updateChangesOnly;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanProperty.parseAggregation",
	"Comment": "get the parsed aggregation formula with table alias placeholders.",
	"Method": "String parseAggregation(){\r\n    if (aggregation != null) {\r\n        int pos = aggregation.indexOf('(');\r\n        if (pos > -1) {\r\n            String maybePropertyName = aggregation.substring(pos + 1, aggregation.length() - 1);\r\n            if (name.equals(maybePropertyName)) {\r\n                return aggregationJoin(pos, dbColumn);\r\n            } else {\r\n                DeployBeanProperty other = desc.getBeanProperty(maybePropertyName);\r\n                if (other != null) {\r\n                    return aggregationJoin(pos, other.getDbColumnRaw());\r\n                }\r\n            }\r\n        }\r\n        aggregationParsed = desc.parse(aggregation);\r\n    }\r\n    return aggregationParsed;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanDescriptor.getFullName",
	"Comment": "return the bean class name this descriptor is used for.if this beandescriptor is for a table then this returns the table nameinstead.",
	"Method": "String getFullName(){\r\n    return beanType.getName();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.DefaultProfileHandler.createProfileStream",
	"Comment": "create and return a profilestream if we are profiling for the given transaction profileid.",
	"Method": "ProfileStream createProfileStream(int profileId){\r\n    if (profileId < 1) {\r\n        return null;\r\n    }\r\n    if (includeIds.length == 0) {\r\n        return new DefaultProfileStream(profileId, verbose);\r\n    }\r\n    for (int includeId : includeIds) {\r\n        if (includeId == profileId) {\r\n            return new DefaultProfileStream(profileId, verbose);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DatabasePlatform.getMaxConstraintNameLength",
	"Comment": "return the maximum constraint name allowed for the platform.",
	"Method": "int getMaxConstraintNameLength(){\r\n    return maxConstraintNameLength;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.InheritInfo.getRoot",
	"Comment": "return the root node of the tree.the root has a map of discriminator values to types.",
	"Method": "InheritInfo getRoot(){\r\n    return root;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.isDocStoreNotify",
	"Comment": "return true if this request should update the document store.",
	"Method": "boolean isDocStoreNotify(){\r\n    return docStoreMode != DocStoreMode.IGNORE;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getBeanDescriptor",
	"Comment": "return the beandescriptor for a given path of associated one or many beans.",
	"Method": "BeanDescriptor<?> getBeanDescriptor(String path,BeanDescriptor<U> getBeanDescriptor,Class<U> otherType){\r\n    return owner.getBeanDescriptor(otherType);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.TableModState.touch",
	"Comment": "set the modified timestamp on the tables that have been touched.",
	"Method": "void touch(Set<String> touchedTables,long modTimestamp){\r\n    for (String tableName : touchedTables) {\r\n        tableModStamp.put(tableName, modTimestamp);\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"TableModState updated - touched:{} modTimestamp:{}\", touchedTables, modTimestamp);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocMany.lazyLoadMany",
	"Comment": "add the loaded current bean to its associated parent.helper method used by elastic integration when loading with a persistence context.",
	"Method": "void lazyLoadMany(EntityBean current){\r\n    EntityBean parentBean = childMasterProperty.getValueAsEntityBean(current);\r\n    if (parentBean != null) {\r\n        addBeanToCollectionWithCreate(parentBean, current, true);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.isNaturalKeyCaching",
	"Comment": "return true if there is a natural key defined for this bean type.",
	"Method": "boolean isNaturalKeyCaching(){\r\n    return cacheHelp.isNaturalKeyCaching();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.RemoteTransactionEvent.writeBinaryAsBytes",
	"Comment": "write a binary message to byte array given an initial buffer size.",
	"Method": "byte[] writeBinaryAsBytes(int bufferSize){\r\n    ByteArrayOutputStream buffer = new ByteArrayOutputStream(bufferSize);\r\n    DataOutputStream out = new DataOutputStream(buffer);\r\n    BinaryWriteContext context = new BinaryWriteContext(out);\r\n    writeBinary(context);\r\n    out.close();\r\n    return buffer.toByteArray();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.completeUpdate",
	"Comment": "completed update request handling cases for element collection and where onlymany properties were updated.",
	"Method": "void completeUpdate(){\r\n    if (!dirty && updatedManys != null) {\r\n        if (idValue == null) {\r\n            this.idValue = beanDescriptor.getId(entityBean);\r\n        }\r\n        postExecute = true;\r\n        updatedManysOnly = true;\r\n        setNotifyCache();\r\n        addPostCommitListeners();\r\n    }\r\n    notifyCacheOnComplete();\r\n    postUpdateNotify();\r\n}"
}, {
	"Path": "io.ebean.config.AutoTuneConfig.getProfilingFile",
	"Comment": "return the name of the file that profiling information is written to.",
	"Method": "String getProfilingFile(){\r\n    return profilingFile;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.JunctionExpression.simplify",
	"Comment": "simplify nested expressions where possible.this is expected to only used after expressions are built via query language parsing.",
	"Method": "void simplify(){\r\n    exprList.simplifyEntries();\r\n    List<SpiExpression> list = exprList.list;\r\n    if (list.size() == 1 && list.get(0) instanceof JunctionExpression) {\r\n        @SuppressWarnings(\"rawtypes\")\r\n        JunctionExpression nested = (JunctionExpression) list.get(0);\r\n        if (type == Type.AND && !nested.type.isText()) {\r\n            this.exprList = nested.exprList;\r\n            this.type = nested.type;\r\n        } else if (type == Type.NOT && nested.type == Type.AND) {\r\n            this.exprList = nested.exprList;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.PlatformDdl.tableInlineForeignKey",
	"Comment": "return the foreign key constraint when used inline with create table.",
	"Method": "String tableInlineForeignKey(WriteForeignKey request){\r\n    StringBuilder buffer = new StringBuilder(90);\r\n    buffer.append(\"foreign key\");\r\n    appendColumns(request.cols(), buffer);\r\n    buffer.append(\" references \").append(lowerTableName(request.refTable()));\r\n    appendColumns(request.refCols(), buffer);\r\n    appendForeignKeySuffix(request, buffer);\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.ChainedBeanPostConstructListener.register",
	"Comment": "register a new beanpostcreate and return the resulting chain.",
	"Method": "ChainedBeanPostConstructListener register(BeanPostConstructListener c){\r\n    if (list.contains(c)) {\r\n        return this;\r\n    } else {\r\n        List<BeanPostConstructListener> newList = new ArrayList(list);\r\n        newList.add(c);\r\n        return new ChainedBeanPostConstructListener(newList);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.generatedproperty.GeneratedCounterLong.includeInInsert",
	"Comment": "include this in every insert setting initial counter value to 1.",
	"Method": "boolean includeInInsert(){\r\n    return true;\r\n}"
}, {
	"Path": "org.tests.callable.TestMysqlCallable.test",
	"Comment": "only run this test manually against mysql with the above stored procedure.",
	"Method": "void test(){\r\n    EbeanServer server = Ebean.getServer(\"mysql\");\r\n    EBasic basic = new EBasic();\r\n    basic.setName(\"calling\");\r\n    server.save(basic);\r\n    CallableSql cs = server.createCallableSql(\"{call my_stored_procedure(?,?)}\");\r\n    cs.setParameter(1, basic.getId());\r\n    cs.setParameter(2, \"modBySP\");\r\n    server.execute(cs);\r\n    EBasic basic1 = server.find(EBasic.class, basic.getId());\r\n    assertEquals(\"modBySP\", basic1.getName());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultServer.nextId",
	"Comment": "return the next unique identity value.uses the beandescriptor deployment information to determine the sequence touse.",
	"Method": "Object nextId(Class<?> beanType){\r\n    BeanDescriptor<?> desc = getBeanDescriptor(beanType);\r\n    return desc.nextId(null);\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DbPlatformTypeMapping.loadDefaults",
	"Comment": "load the standard types. these can be overridden by db specific platform.",
	"Method": "void loadDefaults(boolean logicalTypes){\r\n    put(DbType.BOOLEAN, BOOLEAN_LOGICAL);\r\n    put(DbType.BIT);\r\n    put(DbType.INTEGER);\r\n    put(DbType.BIGINT);\r\n    put(DbType.DOUBLE);\r\n    put(DbType.SMALLINT);\r\n    put(DbType.TINYINT);\r\n    put(DbType.BLOB);\r\n    put(DbType.CLOB);\r\n    put(DbType.ARRAY);\r\n    put(DbType.DATE);\r\n    put(DbType.TIME);\r\n    put(DbType.TIMESTAMP);\r\n    put(DbType.LONGVARBINARY);\r\n    put(DbType.LONGVARCHAR);\r\n    put(DbType.REAL, new DbPlatformType(\"float\"));\r\n    put(DbType.POINT, POINT);\r\n    put(DbType.POLYGON, POLYGON);\r\n    put(DbType.LINESTRING, LINESTRING);\r\n    put(DbType.MULTIPOINT, MULTIPOINT);\r\n    put(DbType.MULTILINESTRING, MULTILINESTRING);\r\n    put(DbType.MULTIPOLYGON, MULTIPOLYGON);\r\n    if (logicalTypes) {\r\n        put(DbType.VARCHAR, new DbPlatformType(\"varchar\"));\r\n        put(DbType.DECIMAL, new DbPlatformType(\"decimal\"));\r\n        put(DbType.VARBINARY, new DbPlatformType(\"varbinary\"));\r\n        put(DbType.BINARY, new DbPlatformType(\"binary\"));\r\n        put(DbType.CHAR, new DbPlatformType(\"char\"));\r\n        put(DbType.HSTORE, new DbPlatformType(\"hstore\", false));\r\n        put(DbType.JSON, new DbPlatformType(\"json\", false));\r\n        put(DbType.JSONB, new DbPlatformType(\"jsonb\", false));\r\n        put(DbType.JSONCLOB, new DbPlatformType(\"jsonclob\"));\r\n        put(DbType.JSONBLOB, new DbPlatformType(\"jsonblob\"));\r\n        put(DbType.JSONVARCHAR, new DbPlatformType(\"jsonvarchar\", 1000));\r\n        put(DbType.UUID, UUID_NATIVE);\r\n    } else {\r\n        put(DbType.VARCHAR, new DbPlatformType(\"varchar\", 255));\r\n        put(DbType.DECIMAL, new DbPlatformType(\"decimal\", 38));\r\n        put(DbType.VARBINARY, new DbPlatformType(\"varbinary\", 255));\r\n        put(DbType.BINARY, new DbPlatformType(\"binary\", 255));\r\n        put(DbType.CHAR, new DbPlatformType(\"char\", 1));\r\n        put(DbType.JSON, JSON_CLOB_PLACEHOLDER);\r\n        put(DbType.JSONB, JSON_CLOB_PLACEHOLDER);\r\n        put(DbType.JSONCLOB, JSON_CLOB_PLACEHOLDER);\r\n        put(DbType.JSONBLOB, JSON_BLOB_PLACEHOLDER);\r\n        put(DbType.JSONVARCHAR, JSON_VARCHAR_PLACEHOLDER);\r\n        put(DbType.UUID, UUID_NATIVE);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.type.DefaultTypeFactory.createCalendar",
	"Comment": "create a scalartype for java.util.calendar explicitly specifying the typeto map to.",
	"Method": "ScalarType<Calendar> createCalendar(JsonConfig.DateTime mode,ScalarType<Calendar> createCalendar,JsonConfig.DateTime mode,int jdbcType){\r\n    return new ScalarTypeCalendar(mode, jdbcType);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setSkipCacheAfterWrite",
	"Comment": "set to false when we still want to hit the cache after a write has occurred on a transaction.",
	"Method": "void setSkipCacheAfterWrite(boolean skipCacheAfterWrite){\r\n    this.skipCacheAfterWrite = skipCacheAfterWrite;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultServer.createTransaction",
	"Comment": "create a transaction additionally specify the isolation level.note that this transaction is not stored in a thread local.",
	"Method": "Transaction createTransaction(Transaction createTransaction,TxIsolation isolation){\r\n    return transactionManager.createTransaction(true, isolation.getLevel());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getChangeLogBean",
	"Comment": "return true if this request should be included in the change log.",
	"Method": "BeanChange getChangeLogBean(PersistRequestBean<T> request){\r\n    switch(request.getType()) {\r\n        case INSERT:\r\n            return changeLogFilter.includeInsert(request) ? insertBeanChange(request) : null;\r\n        case UPDATE:\r\n        case DELETE_SOFT:\r\n            return changeLogFilter.includeUpdate(request) ? updateBeanChange(request) : null;\r\n        case DELETE:\r\n            return changeLogFilter.includeDelete(request) ? deleteBeanChange(request) : null;\r\n        default:\r\n            throw new IllegalStateException(\"Unhandled request type \" + request.getType());\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQueryFetchSingleAttribute.close",
	"Comment": "close the resources.the jdbc resultset and statement need to be closed. its important thatthis method is called.",
	"Method": "void close(){\r\n    try {\r\n        if (dataReader != null) {\r\n            dataReader.close();\r\n            dataReader = null;\r\n        }\r\n    } catch (SQLException e) {\r\n        logger.error(\"Error closing DataReader\", e);\r\n    }\r\n    JdbcClose.close(pstmt);\r\n    pstmt = null;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.dml.InsertHandler.fetchGeneratedKeyUsingSelect",
	"Comment": "for non batch insert with dbs that do not support getgeneratedkeys. use asql select to fetch back the id value.",
	"Method": "void fetchGeneratedKeyUsingSelect(){\r\n    PreparedStatement stmt = null;\r\n    ResultSet rset = null;\r\n    try {\r\n        stmt = transaction.getConnection().prepareStatement(persistRequest.getSelectLastInsertedId());\r\n        rset = stmt.executeQuery();\r\n        setGeneratedKey(rset);\r\n    } finally {\r\n        JdbcClose.close(rset);\r\n        JdbcClose.close(stmt);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.propertiesOne",
	"Comment": "all the beanpropertyassocone that are not embedded. these are effectivelyjoined beans. for manytoone and onetoone associations.",
	"Method": "BeanPropertyAssocOne<?>[] propertiesOne(){\r\n    return propertiesOne;\r\n}"
}, {
	"Path": "cyclops.companion.Streamable.range",
	"Comment": "create an efficiently reversable sequence that produces the integers between skipand take",
	"Method": "Streamable<Integer> range(int start,int end){\r\n    return fromStream(ReactiveSeq.range(start, end));\r\n}"
}, {
	"Path": "cyclops.control.Future.of",
	"Comment": "create a future object that asyncrhonously populates using the providedexecutor and supplier",
	"Method": "Future<T> of(CompletableFuture<T> f,Future<T> of,Supplier<T> s,Future<T> of,Supplier<T> s,Executor ex){\r\n    return Future.of(CompletableFuture.supplyAsync(s, ex));\r\n}"
}, {
	"Path": "org.tests.cache.TestCacheCollectionIds.testClearingCollectionCacheOnORMUpdate",
	"Comment": "when doing an orm update the collection cache must be cleared.",
	"Method": "void testClearingCollectionCacheOnORMUpdate(){\r\n    ResetBasicData.reset();\r\n    Order order1 = Ebean.find(Order.class, 1L);\r\n    OrderDetail orderDetail1 = order1.getDetails().get(0);\r\n    String updStatement = \"delete from orderDetail where id = :id\";\r\n    Update<OrderDetail> update = Ebean.createUpdate(OrderDetail.class, updStatement);\r\n    update.set(\"id\", orderDetail1.getId());\r\n    int rows = update.execute();\r\n    assertEquals(1, rows);\r\n    Order orderFromCache = Ebean.find(Order.class, 1L);\r\n    OrderDetail orderDetailFromCache = orderFromCache.getDetails().get(0);\r\n    orderDetailFromCache.getCretime();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.convertSetId",
	"Comment": "convert and set the id value.if the bean is not null, the id value is set to the id property of the beanafter it has been converted to the correct type.",
	"Method": "Object convertSetId(Object idValue,EntityBean bean){\r\n    return idBinder.convertSetId(idValue, bean);\r\n}"
}, {
	"Path": "cyclops.function.Memoize.memoizeQuadFunctionAsync",
	"Comment": "memoize a function and update the cached values asynchronously using the provided scheduled executor servicedoes not support null keys",
	"Method": "Function4<T1, T2, T3, T4, R> memoizeQuadFunctionAsync(Function4<T1, T2, T3, T4, R> fn,ScheduledExecutorService ex,String cron,Function4<T1, T2, T3, T4, R> memoizeQuadFunctionAsync,Function4<T1, T2, T3, T4, R> fn,ScheduledExecutorService ex,long updateRateInMillis){\r\n    Function1<Tuple4<T1, T2, T3, T4>, R> memoise2 = memoizeFunctionAsync((final Tuple4<T1, T2, T3, T4> quad) -> fn.apply(quad._1(), quad._2(), quad._3(), quad._4()), ex, updateRateInMillis);\r\n    return (t1, t2, t3, t4) -> memoise2.apply(tuple(t1, t2, t3, t4));\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DatabasePlatform.convertQuotedIdentifiers",
	"Comment": "convert backticks to the platform specific open quote and close quotespecific plugins may implement this method to cater for platform specificnaming rules.",
	"Method": "String convertQuotedIdentifiers(String dbName){\r\n    if (dbName != null && !dbName.isEmpty()) {\r\n        if (dbName.charAt(0) == BACK_TICK) {\r\n            if (dbName.charAt(dbName.length() - 1) == BACK_TICK) {\r\n                return openQuote + dbName.substring(1, dbName.length() - 1) + closeQuote;\r\n            } else {\r\n                logger.error(\"Missing backquote on [\" + dbName + \"]\");\r\n            }\r\n        } else if (allQuotedIdentifiers) {\r\n            return openQuote + dbName + closeQuote;\r\n        }\r\n    }\r\n    return dbName;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanProperty.setDbRead",
	"Comment": "set to true if this property is included in database queries.",
	"Method": "void setDbRead(boolean isDBRead){\r\n    this.dbRead = isDBRead;\r\n}"
}, {
	"Path": "io.ebean.BeanRepository.save",
	"Comment": "insert or update this entity depending on its state.ebean will detect if this is a new bean or a previously fetched bean and perform either aninsert or an update based on that.",
	"Method": "void save(T bean){\r\n    db().save(bean);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.DefaultProfileStream.offset",
	"Comment": "return the time offset from the beginning of the transaction.",
	"Method": "long offset(){\r\n    return ((System.nanoTime() - startNanos) / 1_000L);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.Same.sameBy",
	"Comment": "null safe check by samebyvalue or samebynull based on byvalue.",
	"Method": "boolean sameBy(boolean byValue,Object value,Object value1){\r\n    if (byValue) {\r\n        return sameByValue(value, value1);\r\n    } else {\r\n        return sameByNull(value, value1);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestUpdateSql.setType",
	"Comment": "specify the type of statement executed. used to automatically registerwith the transaction event.",
	"Method": "void setType(SqlType sqlType,String tableName,String description){\r\n    this.sqlType = sqlType;\r\n    this.tableName = tableName;\r\n    this.description = description;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.autotune.service.ProfileOrigin.profilingCollection",
	"Comment": "collect profiling information with the option to reset the underlying profiling detail.",
	"Method": "void profilingCollection(BeanDescriptor<?> rootDesc,AutoTuneCollection req,boolean reset){\r\n    synchronized (monitor) {\r\n        if (nodeUsageMap.isEmpty()) {\r\n            return;\r\n        }\r\n        OrmQueryDetail detail = buildDetail(rootDesc);\r\n        AutoTuneCollection.Entry entry = req.add(origin, detail, originalQuery);\r\n        Collection<ProfileOriginQuery> values = queryStatsMap.values();\r\n        for (ProfileOriginQuery queryEntry : values) {\r\n            entry.addQuery(queryEntry.createEntryQuery(reset));\r\n        }\r\n        if (reset) {\r\n            nodeUsageMap.clear();\r\n            if (requestCount.get() > RESET_COUNT) {\r\n                requestCount.set(profilingBase);\r\n                profileCount.set(0);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQueryPlanStats.getSnapshot",
	"Comment": "return a snapshot of the query execution statistics potentially resetting the internal counters.",
	"Method": "Snapshot getSnapshot(boolean reset){\r\n    TimedMetricStats collect = timedMetric.collect(reset);\r\n    List<MetaOrmQueryOrigin> origins = getOrigins(reset);\r\n    return new Snapshot(queryPlan, collect, lastQueryTime, origins);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployTableJoin.setColumns",
	"Comment": "copy all the columns to this join potentially reversing the columns.",
	"Method": "void setColumns(DeployTableJoinColumn[] cols,boolean reverse){\r\n    columns = new ArrayList();\r\n    for (DeployTableJoinColumn col : cols) {\r\n        addJoinColumn(col.copy(reverse));\r\n    }\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.filterSync",
	"Comment": "synchronous filtering operationremoves elements that do not fold the supplied predicate from thedataflow",
	"Method": "SimpleReactStream<U> filterSync(Predicate<? super U> p){\r\n    final Function<Stream<CompletableFuture>, Stream<CompletableFuture>> fn = s -> s.map(ft -> ft.thenApply((in) -> {\r\n        if (!p.test((U) in)) {\r\n            throw new FilteredExecutionPathException();\r\n        }\r\n        return in;\r\n    }));\r\n    return this.withLastActive(getLastActive().stream(fn));\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.MapX.toSortedSetX",
	"Comment": "convert this mapx to a sortedsetx via the provided transformation function",
	"Method": "SortedSetX<T> toSortedSetX(Function<? super Tuple2<? super K, ? super V>, ? extends T> fn){\r\n    return SortedSetX.narrow(stream().map(fn).to(ReactiveConvertableSequence::converter).sortedSetX());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.JdbcTransaction.doRollback",
	"Comment": "perform the jdbc rollback and fire any registered callbacks.",
	"Method": "void doRollback(Throwable cause){\r\n    firePreRollback();\r\n    try {\r\n        performRollback();\r\n    } catch (SQLException ex) {\r\n        throw new PersistenceException(ex);\r\n    } finally {\r\n        firePostRollback();\r\n        notifyRollback(cause);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.api.LoadManyRequest.postLoad",
	"Comment": "after the query execution check for empty collections and load l2 cache if desired.",
	"Method": "void postLoad(){\r\n    BeanDescriptor<?> desc = loadContext.getBeanDescriptor();\r\n    BeanPropertyAssocMany<?> many = getMany();\r\n    for (BeanCollection<?> bc : batch) {\r\n        if (bc.checkEmptyLazyLoad()) {\r\n            if (logger.isDebugEnabled()) {\r\n                EntityBean ownerBean = bc.getOwnerBean();\r\n                Object parentId = desc.getId(ownerBean);\r\n                logger.debug(\"BeanCollection after lazy load was empty. type:\" + ownerBean.getClass().getName() + \" id:\" + parentId + \" owner:\" + ownerBean);\r\n            }\r\n        } else if (isLoadCache()) {\r\n            Object parentId = desc.getId(bc.getOwnerBean());\r\n            desc.cacheManyPropPut(many, bc, parentId);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.dropUntil",
	"Comment": "return a stream with the same values as this stream, but with all values omitted until the provided stream starts emitting values.provided stream ends the stream of values from this stream.",
	"Method": "ReactiveSeq<U> dropUntil(SimpleReactStream<T> s){\r\n    return EagerFutureStreamFunctions.dropUntil(this, s);\r\n}"
}, {
	"Path": "io.ebean.Pairs.setConcatSuffix",
	"Comment": "add a suffix used with db varchar concatenation to combine the 2 values.",
	"Method": "Pairs setConcatSuffix(String concatSuffix){\r\n    this.concatSuffix = concatSuffix;\r\n    return this;\r\n}"
}, {
	"Path": "io.ebeaninternal.api.LoadRequest.getTransaction",
	"Comment": "return the transaction to use if this is a secondary query.lazy loading queries run in their own transaction.",
	"Method": "Transaction getTransaction(){\r\n    return transaction;\r\n}"
}, {
	"Path": "io.ebean.config.DocStoreConfig.isDropCreate",
	"Comment": "return true if the document store should recreate mapped indexes.",
	"Method": "boolean isDropCreate(){\r\n    String systemValue = System.getProperty(\"ebean.docstore.dropCreate\");\r\n    if (systemValue != null) {\r\n        return Boolean.parseBoolean(systemValue);\r\n    }\r\n    return dropCreate;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DatabasePlatform.setSequenceBatchMode",
	"Comment": "set to false to not use sequence batch mode but instead step mode.",
	"Method": "void setSequenceBatchMode(boolean sequenceBatchMode){\r\n    this.sequenceBatchMode = sequenceBatchMode;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.dml.InsertMeta.deriveConcatenatedId",
	"Comment": "return true if the id can be derived from other property values.",
	"Method": "boolean deriveConcatenatedId(PersistRequestBean<?> persist){\r\n    return id.deriveConcatenatedId(persist);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.OperationsOnFutures.toStream",
	"Comment": "convert this futurestream to a stream of completablefutures",
	"Method": "ReactiveSeq<CompletableFuture<T>> toStream(){\r\n    return this.getLastActive().injectFuturesSeq().map(f -> f.toCompletableFuture());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.JdbcTransaction.flush",
	"Comment": "flush any queued persist requests.this is general will result in a number of batched preparedstatementsexecuting.",
	"Method": "void flush(){\r\n    if (!isActive()) {\r\n        throw new IllegalStateException(illegalStateMessage);\r\n    }\r\n    internalBatchFlush();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.DefaultExpressionList.containsMany",
	"Comment": "return true if one of the expressions is related to a many property.",
	"Method": "void containsMany(BeanDescriptor<?> desc,ManyWhereJoins whereManyJoins){\r\n    for (SpiExpression aList : list) {\r\n        aList.containsMany(desc, whereManyJoins);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.isDbRead",
	"Comment": "return true if this property is included in database queries.",
	"Method": "boolean isDbRead(){\r\n    return dbRead;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.ListX.iterate",
	"Comment": "create a listx by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "ListX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).listX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.checkMutableProperties",
	"Comment": "check for mutable scalar types and mark as dirty if necessary.",
	"Method": "void checkMutableProperties(EntityBeanIntercept ebi){\r\n    for (BeanProperty beanProperty : propertiesMutable) {\r\n        int propertyIndex = beanProperty.getPropertyIndex();\r\n        if (!ebi.isDirtyProperty(propertyIndex) && ebi.isLoadedProperty(propertyIndex)) {\r\n            Object value = beanProperty.getValue(ebi.getOwner());\r\n            if (value == null || beanProperty.isDirtyValue(value)) {\r\n                ebi.markPropertyAsChanged(propertyIndex);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.DeployPropertyParser.skipWordConvert",
	"Comment": "skip if in raw sql expression with from tablename or join tablename.",
	"Method": "boolean skipWordConvert(){\r\n    return FROM.equalsIgnoreCase(priorWord) || JOIN.equalsIgnoreCase(priorWord);\r\n}"
}, {
	"Path": "io.ebean.text.PathProperties.includesPath",
	"Comment": "return true if the fetch path is included in the pathproperties.the fetch path is a onetomany or manytomany path in dot notation.",
	"Method": "boolean includesPath(String path,boolean includesPath,String prefix,String name){\r\n    return includesPath(SplitName.add(prefix, name));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.docStoreInclude",
	"Comment": "append this property to the document store based on includebydefault setting.",
	"Method": "void docStoreInclude(boolean includeByDefault,DocStructure docStructure){\r\n    if (includeByDefault) {\r\n        docStructure.addProperty(name);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQueryBuilder.buildQuery",
	"Comment": "return the sql select statement as a string. converts logical propertynames to physical deployment column names.",
	"Method": "CQuery<T> buildQuery(OrmQueryRequest<T> request){\r\n    CQueryPredicates predicates = new CQueryPredicates(binder, request);\r\n    CQueryPlan queryPlan = request.getQueryPlan();\r\n    if (queryPlan != null) {\r\n        predicates.prepare(false);\r\n        return new CQuery(request, predicates, queryPlan);\r\n    }\r\n    predicates.prepare(true);\r\n    SpiQuery<T> query = request.getQuery();\r\n    SqlTree sqlTree = createSqlTree(request, predicates);\r\n    if (query.isAsOfQuery()) {\r\n        sqlTree.addAsOfTableAlias(query);\r\n    } else if (SpiQuery.TemporalMode.CURRENT == query.getTemporalMode()) {\r\n        sqlTree.addSoftDeletePredicate(query);\r\n    }\r\n    SqlLimitResponse res = buildSql(null, request, predicates, sqlTree);\r\n    boolean rawSql = request.isRawSql();\r\n    if (rawSql) {\r\n        queryPlan = new CQueryPlanRawSql(request, res, sqlTree, predicates.getLogWhereSql());\r\n    } else {\r\n        queryPlan = new CQueryPlan(request, res, sqlTree, false, predicates.getLogWhereSql());\r\n    }\r\n    BeanDescriptor<T> desc = request.getBeanDescriptor();\r\n    if (desc.isReadAuditing()) {\r\n        desc.getReadAuditLogger().queryPlan(new ReadAuditQueryPlan(desc.getFullName(), queryPlan.getAuditQueryKey(), queryPlan.getSql()));\r\n    }\r\n    request.putQueryPlan(queryPlan);\r\n    return new CQuery(request, predicates, queryPlan);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.autotune.service.ProfileOrigin.isProfile",
	"Comment": "return true if this query should be profiled based on a percentage rate.",
	"Method": "boolean isProfile(){\r\n    long count = requestCount.incrementAndGet();\r\n    if (count < profilingBase) {\r\n        return true;\r\n    }\r\n    long hits = profileCount.get();\r\n    if (profilingRate > (double) hits / count) {\r\n        profileCount.incrementAndGet();\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanDescriptor.setBaseTable",
	"Comment": "set the base table. only properties mapped to the base table are by default persisted.",
	"Method": "void setBaseTable(TableName baseTableFull,String asOfSuffix,String versionsBetweenSuffix){\r\n    this.baseTableFull = baseTableFull;\r\n    this.baseTable = baseTableFull == null ? null : baseTableFull.getQualifiedName();\r\n    this.baseTableAsOf = baseTable + asOfSuffix;\r\n    this.baseTableVersionsBetween = baseTable + versionsBetweenSuffix;\r\n    this.draftTable = (draftable) ? baseTable + \"_draft\" : baseTable;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.DbTriggerBasedHistoryDdl.columnNamesForApply",
	"Comment": "return the column names included in history for the apply script.note that dropped columns are actually still included at this point as they are goingto be removed from the history handling when the drop script runs that also deletesthe column.",
	"Method": "List<String> columnNamesForApply(MTable table){\r\n    return table.allHistoryColumns(true);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.generatedproperty.InsertTimestampFactory.createInsertTimestamp",
	"Comment": "create the insert generatedproperty depending on the property type.",
	"Method": "GeneratedProperty createInsertTimestamp(DeployBeanProperty property){\r\n    Class<?> propType = property.getPropertyType();\r\n    GeneratedProperty generatedProperty = map.get(propType);\r\n    if (generatedProperty != null) {\r\n        return generatedProperty;\r\n    }\r\n    throw new PersistenceException(\"Generated Insert Timestamp not supported on \" + propType.getName());\r\n}"
}, {
	"Path": "io.ebean.config.AutoTuneConfig.setProfiling",
	"Comment": "set to true if profiling information should be collected.the profiling information is collected and then used to generate the tunedqueries for autotune.",
	"Method": "void setProfiling(boolean profiling){\r\n    this.profiling = profiling;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.docStoreMapping",
	"Comment": "build the document mapping recursively with the given prefix relative to the root of the document.",
	"Method": "void docStoreMapping(DocMappingBuilder mapping,String prefix){\r\n    if (prefix != null && idProperty != null) {\r\n        idProperty.docStoreMapping(mapping, prefix);\r\n    }\r\n    if (inheritInfo != null) {\r\n        String discCol = inheritInfo.getDiscriminatorColumn();\r\n        if (Types.VARCHAR == inheritInfo.getDiscriminatorType()) {\r\n            mapping.add(new DocPropertyMapping(discCol, DocPropertyType.ENUM));\r\n        } else {\r\n            mapping.add(new DocPropertyMapping(discCol, DocPropertyType.INTEGER));\r\n        }\r\n    }\r\n    for (BeanProperty prop : propertiesNonTransient) {\r\n        prop.docStoreMapping(mapping, prefix);\r\n    }\r\n    if (inheritInfo != null) {\r\n        inheritInfo.visitChildren(inheritInfo1 -> {\r\n            for (BeanProperty localProperty : inheritInfo1.localProperties()) {\r\n                localProperty.docStoreMapping(mapping, prefix);\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.TransactionManager.wrapExternalConnection",
	"Comment": "wrap an externally supplied connection with a known transaction id.",
	"Method": "SpiTransaction wrapExternalConnection(Connection c,SpiTransaction wrapExternalConnection,String id,Connection c){\r\n    ExternalJdbcTransaction t = new ExternalJdbcTransaction(id, true, c, this);\r\n    t.setBatchMode(persistBatch);\r\n    t.setBatchOnCascade(persistBatchOnCascade);\r\n    return t;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocOne.createExported",
	"Comment": "create the array of exportedproperty used to build reference objects.",
	"Method": "ExportedProperty[] createExported(){\r\n    BeanProperty idProp = descriptor.getIdProperty();\r\n    ArrayList<ExportedProperty> list = new ArrayList();\r\n    if (idProp != null && idProp.isEmbedded()) {\r\n        BeanPropertyAssocOne<?> one = (BeanPropertyAssocOne<?>) idProp;\r\n        BeanDescriptor<?> targetDesc = one.getTargetDescriptor();\r\n        BeanProperty[] emIds = targetDesc.propertiesBaseScalar();\r\n        try {\r\n            for (BeanProperty emId : emIds) {\r\n                list.add(findMatch(true, emId));\r\n            }\r\n        } catch (PersistenceException e) {\r\n            e.printStackTrace();\r\n        }\r\n    } else {\r\n        if (idProp != null) {\r\n            list.add(findMatch(false, idProp));\r\n        }\r\n    }\r\n    return list.toArray(new ExportedProperty[list.size()]);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.PlatformDdl.alterTableAddUniqueConstraint",
	"Comment": "add a unique constraint to the table.overridden by mssqlserver for specific null handling on unique constraints.",
	"Method": "String alterTableAddUniqueConstraint(String tableName,String uqName,String[] columns,String[] nullableColumns){\r\n    StringBuilder buffer = new StringBuilder(90);\r\n    buffer.append(\"alter table \").append(tableName).append(\" add constraint \").append(maxConstraintName(uqName)).append(\" unique \");\r\n    appendColumns(columns, buffer);\r\n    return buffer.toString();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.checkMappedByOneToMany",
	"Comment": "if the property has mappedby set then do two things. make sure the mappedbyproperty exists, and secondly read its join information.we can use the join information from the mappedby property and reverse itfor using in the onetomany direction.",
	"Method": "void checkMappedByOneToMany(DeployBeanInfo<?> info,DeployBeanPropertyAssocMany<?> prop){\r\n    if (prop.isElementCollection()) {\r\n        return;\r\n    }\r\n    DeployBeanDescriptor<?> targetDesc = getTargetDescriptor(prop);\r\n    if (targetDesc.isDraftableElement()) {\r\n        prop.setModifyListenMode(BeanCollection.ModifyListenMode.REMOVALS);\r\n        prop.getCascadeInfo().setSaveDelete(true, true);\r\n    }\r\n    if (prop.hasOrderColumn()) {\r\n        makeOrderColumn(prop);\r\n    }\r\n    if (prop.getMappedBy() == null) {\r\n        if (info.getDescriptor().isDocStoreOnly()) {\r\n            prop.setUnidirectional();\r\n            return;\r\n        }\r\n        if (!findMappedBy(prop)) {\r\n            if (!prop.isO2mJoinTable()) {\r\n                makeUnidirectional(prop);\r\n            }\r\n            return;\r\n        }\r\n    }\r\n    String mappedBy = prop.getMappedBy();\r\n    DeployBeanProperty mappedProp = targetDesc.getBeanProperty(mappedBy);\r\n    if (mappedProp == null) {\r\n        String m = \"Error on \" + prop.getFullBeanName();\r\n        m += \"  Can not find mappedBy property [\" + mappedBy + \"] \";\r\n        m += \"in [\" + targetDesc + \"]\";\r\n        throw new PersistenceException(m);\r\n    }\r\n    if (!(mappedProp instanceof DeployBeanPropertyAssocOne<?>)) {\r\n        String m = \"Error on \" + prop.getFullBeanName();\r\n        m += \". mappedBy property [\" + mappedBy + \"]is not a ManyToOne?\";\r\n        m += \"in [\" + targetDesc + \"]\";\r\n        throw new PersistenceException(m);\r\n    }\r\n    DeployBeanPropertyAssocOne<?> mappedAssocOne = (DeployBeanPropertyAssocOne<?>) mappedProp;\r\n    DeployTableJoin tableJoin = prop.getTableJoin();\r\n    if (!tableJoin.hasJoinColumns()) {\r\n        DeployTableJoin otherTableJoin = mappedAssocOne.getTableJoin();\r\n        otherTableJoin.copyTo(tableJoin, true, tableJoin.getTable());\r\n    }\r\n    PropertyForeignKey foreignKey = mappedAssocOne.getForeignKey();\r\n    if (foreignKey != null) {\r\n        ConstraintMode onDelete = foreignKey.getOnDelete();\r\n        switch(onDelete) {\r\n            case SET_DEFAULT:\r\n            case SET_NULL:\r\n            case CASCADE:\r\n                {\r\n                    prop.getCascadeInfo().setDelete(false);\r\n                }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getBaseTableAlias",
	"Comment": "return the base table alias. this is always the first letter of the bean name.",
	"Method": "String getBaseTableAlias(){\r\n    return baseTableAlias;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorCacheHelp.isBeanCaching",
	"Comment": "return true if there is currently bean caching for this type of bean.",
	"Method": "boolean isBeanCaching(){\r\n    return beanCache != null;\r\n}"
}, {
	"Path": "io.ebean.config.properties.Loader.eval",
	"Comment": "evaluate all the configuration entries and return as properties.",
	"Method": "Properties eval(){\r\n    return loadContext.eval();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.convertOrmUpdateToSql",
	"Comment": "convert the logical orm update statement into sql by converting the beanproperties and bean name to database columns and table.",
	"Method": "String convertOrmUpdateToSql(String ormUpdateStatement){\r\n    return new DeployUpdateParser(this).parse(ormUpdateStatement);\r\n}"
}, {
	"Path": "cyclops.kinds.CompletableFutureKind.narrow",
	"Comment": "convert the raw higher kinded type for completablefuturekind types into the completablefuturekind type definition class",
	"Method": "CompletableFutureKind<T> narrow(Higher<DataWitness.completableFuture, T> future,CompletionStage<T> narrow){\r\n    return (CompletableFutureKind<T>) future;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.MergeRequest.idExists",
	"Comment": "return true if a bean of the type with the given id exists in the database.",
	"Method": "boolean idExists(Class<?> beanType,Object beanId){\r\n    return context.idExists(beanType, beanId);\r\n}"
}, {
	"Path": "cyclops.monads.transformers.EitherT.of",
	"Comment": "construct an maybewt from an anym that wraps a monad containingmaybews",
	"Method": "EitherT<W, ST, A> of(AnyM<W, Either<ST, A>> monads){\r\n    return new EitherT(monads);\r\n}"
}, {
	"Path": "chapter06trees.BinaryTreeNode.findInBT",
	"Comment": "tests whether the root argument contains within itself the data argument.",
	"Method": "boolean findInBT(BinaryTreeNode root,int data){\r\n    if (root == null)\r\n        return false;\r\n    if (root.getData() == data)\r\n        return true;\r\n    return findInBT(root.getLeft(), data) || findInBT(root.getRight(), data);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.isDocStoreEmbeddedInvalidation",
	"Comment": "return true if this bean type has embedded doc store invalidation.",
	"Method": "boolean isDocStoreEmbeddedInvalidation(){\r\n    return docStoreEmbeddedInvalidation;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.cockroach.CockroachPlatform.isDdlCommitOnCreateIndex",
	"Comment": "needs a commit after create index such that alter table add foreign key ... succeeds.",
	"Method": "boolean isDdlCommitOnCreateIndex(){\r\n    return true;\r\n}"
}, {
	"Path": "io.ebean.config.DbMigrationConfig.getPatchResetChecksumOn",
	"Comment": "return migration versions that should have their checksum reset and not run.",
	"Method": "String getPatchResetChecksumOn(){\r\n    return patchResetChecksumOn;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.BatchedPstmtHolder.getMaxSize",
	"Comment": "return the size of the biggest batched statement.used to determine when to flush the batch.",
	"Method": "int getMaxSize(){\r\n    return maxSize;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.TChangeLogHolder.postRollback",
	"Comment": "on post rollback send the changes we have collected andleave it up to the listener to decide what to do.",
	"Method": "void postRollback(){\r\n    changes.setTxnState(TxnState.ROLLBACK);\r\n    owner.sendChangeLog(changes);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanDescriptor.propertiesAll",
	"Comment": "return a collection of all beanproperty deployment information.",
	"Method": "Collection<DeployBeanProperty> propertiesAll(){\r\n    return propMap.values();\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.DequeX.rangeLong",
	"Comment": "create a dequex that contains the longs between skip and take",
	"Method": "DequeX<Long> rangeLong(long start,long end){\r\n    return ReactiveSeq.rangeLong(start, end).to(ReactiveConvertableSequence::converter).dequeX(LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.InheritInfo.appendCheckConstraintValues",
	"Comment": "append check constraint values for the entire inheritance hierarchy.",
	"Method": "void appendCheckConstraintValues(String propertyName,Set<String> checkConstraintValues){\r\n    visitChildren(inheritInfo -> {\r\n        BeanProperty prop = inheritInfo.desc().getBeanProperty(propertyName);\r\n        if (prop != null) {\r\n            Set<String> values = prop.getDbCheckConstraintValues();\r\n            if (values != null) {\r\n                checkConstraintValues.addAll(values);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "cyclops.function.Monoid.fromBiFunction",
	"Comment": "construct a monoid from the supplied identity element and combining function",
	"Method": "Monoid<T> fromBiFunction(T zero,BiFunction<T, T, T> combiner){\r\n    return new Monoid<T>() {\r\n        @Override\r\n        public T zero() {\r\n            return zero;\r\n        }\r\n        @Override\r\n        public T apply(final T t, final T u) {\r\n            return combiner.apply(t, u);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "cyclops.function.Monoid.fromBiFunction",
	"Comment": "construct a monoid from the supplied identity element and combining function",
	"Method": "Monoid<T> fromBiFunction(T zero,BiFunction<T, T, T> combiner){\r\n    return zero;\r\n}"
}, {
	"Path": "cyclops.function.Monoid.fromBiFunction",
	"Comment": "construct a monoid from the supplied identity element and combining function",
	"Method": "Monoid<T> fromBiFunction(T zero,BiFunction<T, T, T> combiner){\r\n    return combiner.apply(t, u);\r\n}"
}, {
	"Path": "cyclops.companion.reactor.Monos.fromIterable",
	"Comment": "construct a mono from iterable by taking the first value from iterable",
	"Method": "Mono<T> fromIterable(Iterable<T> t){\r\n    return Mono.from(Flux.fromIterable(t));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.isDDLNotNull",
	"Comment": "return true if ddl not null constraint should be defined for this columnbased on it being a version column or having a generated property.",
	"Method": "boolean isDDLNotNull(){\r\n    return isVersion() || (generatedProperty != null && generatedProperty.isDDLNotNullable());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.DeployParser.readNamedParameter",
	"Comment": "read a named parameter. these are not translated. they will be replacedby positioned parameters later.",
	"Method": "void readNamedParameter(){\r\n    while (++pos < sourceLength) {\r\n        char ch = source.charAt(pos);\r\n        sb.append(ch);\r\n        if (Character.isWhitespace(ch)) {\r\n            break;\r\n        } else if (ch == ',') {\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.dataalgorithms.chap24.mapreduce.FastaInputFormat.getSplits",
	"Comment": "logically splits the set of input files for the job, splits n linesof the input as one split.",
	"Method": "List<InputSplit> getSplits(JobContext job){\r\n    List<InputSplit> splits = new ArrayList<InputSplit>();\r\n    int numberOfLinesPerSplit = getNumberOfLinesPerSplit(job);\r\n    for (FileStatus status : listStatus(job)) {\r\n        splits.addAll(getSplitsForFile(status, job.getConfiguration(), numberOfLinesPerSplit));\r\n    }\r\n    return splits;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.isMarkDraftDirty",
	"Comment": "return true if the draftdirty property should be set to true for this request.",
	"Method": "boolean isMarkDraftDirty(boolean publish){\r\n    return !publish && type != Type.DELETE && beanDescriptor.isDraftable();\r\n}"
}, {
	"Path": "io.ebean.config.DocStoreConfig.getPersist",
	"Comment": "return the default behavior for when insert, update and delete events occur on beans that have an associateddocument store.",
	"Method": "DocStoreMode getPersist(){\r\n    return persist;\r\n}"
}, {
	"Path": "io.ebean.Pairs.setConcatSeparator",
	"Comment": "set the separator character used with db varchar concatenation to combine the 2 values.",
	"Method": "Pairs setConcatSeparator(String concatSeparator){\r\n    this.concatSeparator = concatSeparator;\r\n    return this;\r\n}"
}, {
	"Path": "io.ebean.Expr.raw",
	"Comment": "add raw expression with an array of parameters.the raw expression should contain the same number of ? as there areparameters.",
	"Method": "Expression raw(String raw,Object value,Expression raw,String raw,Object[] values,Expression raw,String raw){\r\n    return Ebean.getExpressionFactory().raw(raw);\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.getLoadedPropertyNames",
	"Comment": "return the set of property names for a partially loaded bean.",
	"Method": "Set<String> getLoadedPropertyNames(){\r\n    if (fullyLoadedBean) {\r\n        return null;\r\n    }\r\n    Set<String> props = new LinkedHashSet();\r\n    for (int i = 0; i < flags.length; i++) {\r\n        if ((flags[i] & FLAG_LOADED_PROP) != 0) {\r\n            props.add(getProperty(i));\r\n        }\r\n    }\r\n    return props;\r\n}"
}, {
	"Path": "org.dataalgorithms.machinelearning.kmeans.Util.buildVector",
	"Comment": "build a vector from given features denoted by a comma separated feature values",
	"Method": "Vector buildVector(String features,String delimiter){\r\n    String[] tokens = StringUtils.split(features, delimiter);\r\n    double[] d = new double[tokens.length];\r\n    for (int i = 0; i < d.length; i++) {\r\n        d[i] = Double.parseDouble(tokens[i]);\r\n    }\r\n    return new DenseVector(d);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.MergeHandler.merge",
	"Comment": "fetch the ids for the graph and use them to determine inserts, updates and deletes for the merge paths.",
	"Method": "List<EntityBean> merge(){\r\n    Set<String> paths = options.paths();\r\n    if (desc.isIdGeneratedValue() && paths.isEmpty() && !options.isClientGeneratedIds()) {\r\n        Object id = desc.getId(bean);\r\n        if (id != null) {\r\n            bean._ebean_getIntercept().setForceUpdate(true);\r\n        }\r\n        return Collections.emptyList();\r\n    }\r\n    EntityBean outline = fetchOutline(paths);\r\n    if (outline == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    bean._ebean_getIntercept().setForceUpdate(true);\r\n    MergeContext context = new MergeContext(server, transaction, options.isClientGeneratedIds());\r\n    MergeRequest request = new MergeRequest(context, bean, outline);\r\n    for (MergeNode value : nodes.values()) {\r\n        value.merge(request);\r\n    }\r\n    return context.getDeletedBeans();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.TransactionManager.profileCollect",
	"Comment": "process the collected transaction profiling information.",
	"Method": "void profileCollect(TransactionProfile transactionProfile){\r\n    profileHandler.collectTransactionProfile(transactionProfile);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentSetX.iterate",
	"Comment": "create a persistentsetx by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "PersistentSetX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).persistentSetX(LAZY);\r\n}"
}, {
	"Path": "io.ebean.config.ProfilingConfig.setIncludeProfileIds",
	"Comment": "set a specific set of profileids to include in profiling.when not set all transactions with profileids are included.",
	"Method": "void setIncludeProfileIds(int[] includeProfileIds){\r\n    this.includeProfileIds = includeProfileIds;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQuery.readUntilDifferentBeanStarted",
	"Comment": "read resultset rows until we hit the end or get a different bean.",
	"Method": "void readUntilDifferentBeanStarted(){\r\n    while (moveToNextRow()) {\r\n        if (checkForDifferentBean())\r\n            return;\r\n    }\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.LazySimpleReactStream.filter",
	"Comment": "removes elements that do not fold the supplied predicate from thedataflow",
	"Method": "LazySimpleReactStream<U> filter(Predicate<? super U> p){\r\n    if (!isAsync())\r\n        return filterSync(p);\r\n    final Function<PipelineBuilder, PipelineBuilder> fn = ft -> ft.thenApplyAsync((in) -> {\r\n        if (!p.test((U) in)) {\r\n            throw new FilteredExecutionPathException();\r\n        }\r\n        return in;\r\n    }, getTaskExecutor());\r\n    return this.withLastActive(getLastActive().operation(fn));\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setPersistBatchSize",
	"Comment": "set the batch size used for jdbc batching. if unset this defaults to 20.you can also set the batch size on the transaction.",
	"Method": "void setPersistBatchSize(int persistBatchSize){\r\n    this.persistBatchSize = persistBatchSize;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.bootup.BootupClasses.isInterestingInterface",
	"Comment": "look for interesting interfaces.this includes scalartype, beancontroller, beanfinder and beanlistener.",
	"Method": "boolean isInterestingInterface(Class<?> cls){\r\n    if (Modifier.isAbstract(cls.getModifiers())) {\r\n        return false;\r\n    }\r\n    boolean interesting = false;\r\n    if (ScalarType.class.isAssignableFrom(cls)) {\r\n        scalarTypeList.add((Class<? extends ScalarType<?>>) cls);\r\n        interesting = true;\r\n    }\r\n    if (ScalarTypeConverter.class.isAssignableFrom(cls)) {\r\n        scalarConverterList.add((Class<? extends ScalarTypeConverter<?, ?>>) cls);\r\n        interesting = true;\r\n    }\r\n    if (AttributeConverter.class.isAssignableFrom(cls)) {\r\n        attributeConverterList.add((Class<? extends AttributeConverter<?, ?>>) cls);\r\n        interesting = true;\r\n    }\r\n    if (IdGenerator.class.isAssignableFrom(cls)) {\r\n        idGeneratorCandidates.add((Class<? extends IdGenerator>) cls);\r\n        interesting = true;\r\n    }\r\n    if (BeanPersistController.class.isAssignableFrom(cls)) {\r\n        beanPersistControllerCandidates.add((Class<? extends BeanPersistController>) cls);\r\n        interesting = true;\r\n    }\r\n    if (BeanPostLoad.class.isAssignableFrom(cls)) {\r\n        beanPostLoadCandidates.add((Class<? extends BeanPostLoad>) cls);\r\n        interesting = true;\r\n    }\r\n    if (BeanPostConstructListener.class.isAssignableFrom(cls)) {\r\n        beanPostConstructListenerCandidates.add((Class<? extends BeanPostConstructListener>) cls);\r\n        interesting = true;\r\n    }\r\n    if (BeanFindController.class.isAssignableFrom(cls)) {\r\n        beanFindControllerCandidates.add((Class<? extends BeanFindController>) cls);\r\n        interesting = true;\r\n    }\r\n    if (BeanPersistListener.class.isAssignableFrom(cls)) {\r\n        beanPersistListenerCandidates.add((Class<? extends BeanPersistListener>) cls);\r\n        interesting = true;\r\n    }\r\n    if (BeanQueryAdapter.class.isAssignableFrom(cls)) {\r\n        beanQueryAdapterCandidates.add((Class<? extends BeanQueryAdapter>) cls);\r\n        interesting = true;\r\n    }\r\n    if (ServerConfigStartup.class.isAssignableFrom(cls)) {\r\n        serverConfigStartupCandidates.add((Class<? extends ServerConfigStartup>) cls);\r\n        interesting = true;\r\n    }\r\n    if (ChangeLogListener.class.isAssignableFrom(cls)) {\r\n        changeLogListenerClass = (Class<? extends ChangeLogListener>) cls;\r\n        interesting = true;\r\n    }\r\n    if (ChangeLogRegister.class.isAssignableFrom(cls)) {\r\n        changeLogRegisterClass = (Class<? extends ChangeLogRegister>) cls;\r\n        interesting = true;\r\n    }\r\n    if (ChangeLogPrepare.class.isAssignableFrom(cls)) {\r\n        changeLogPrepareClass = (Class<? extends ChangeLogPrepare>) cls;\r\n        interesting = true;\r\n    }\r\n    if (ReadAuditPrepare.class.isAssignableFrom(cls)) {\r\n        readAuditPrepareClass = (Class<? extends ReadAuditPrepare>) cls;\r\n        interesting = true;\r\n    }\r\n    if (ReadAuditLogger.class.isAssignableFrom(cls)) {\r\n        readAuditLoggerClass = (Class<? extends ReadAuditLogger>) cls;\r\n        interesting = true;\r\n    }\r\n    return interesting;\r\n}"
}, {
	"Path": "cyclops.companion.Streamable.rangeLong",
	"Comment": "create an efficiently reversable sequence that produces the integers between skipand take",
	"Method": "Streamable<Long> rangeLong(long start,long end){\r\n    return fromStream(ReactiveSeq.rangeLong(start, end));\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setTransactionRollbackOnChecked",
	"Comment": "set to true if transactions should by default rollback on checked exceptions.",
	"Method": "void setTransactionRollbackOnChecked(boolean transactionRollbackOnChecked){\r\n    this.transactionRollbackOnChecked = transactionRollbackOnChecked;\r\n}"
}, {
	"Path": "io.ebean.config.ProfilingConfig.getIncludeProfileIds",
	"Comment": "return the specific set of profileids to include in profiling.when not set all transactions with profileids are included.",
	"Method": "int[] getIncludeProfileIds(){\r\n    return includeProfileIds;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.OrmQueryRequest.endTransIfRequired",
	"Comment": "will end a locally created transaction.it ends the query only transaction.",
	"Method": "void endTransIfRequired(){\r\n    if (createdTransaction && transaction.isActive()) {\r\n        transaction.commit();\r\n    }\r\n}"
}, {
	"Path": "org.dataalgorithms.chapB04.rankproduct.spark.SparkRankProductUsingGroupByKey.computeRankedProducts",
	"Comment": "where n is the number of elements for computing the rankedproduct",
	"Method": "JavaPairRDD<String, Tuple2<Double, Integer>> computeRankedProducts(JavaSparkContext context,JavaPairRDD<String, Long>[] ranks){\r\n    JavaPairRDD<String, Long> unionRDD = context.union(ranks);\r\n    JavaPairRDD<String, Iterable<Long>> groupedByGeneRDD = unionRDD.groupByKey();\r\n    JavaPairRDD<String, Tuple2<Double, Integer>> rankedProducts = groupedByGeneRDD.mapValues(new Function<Iterable<Long>, Tuple2<Double, Integer>>() {\r\n        @Override\r\n        public Tuple2<Double, Integer> call(Iterable<Long> values) {\r\n            int N = 0;\r\n            long products = 1;\r\n            for (Long v : values) {\r\n                products *= v;\r\n                N++;\r\n            }\r\n            double rankedProduct = Math.pow((double) products, 1.0 / ((double) N));\r\n            return new Tuple2<Double, Integer>(rankedProduct, N);\r\n        }\r\n    });\r\n    return rankedProducts;\r\n}"
}, {
	"Path": "org.dataalgorithms.chapB04.rankproduct.spark.SparkRankProductUsingGroupByKey.computeRankedProducts",
	"Comment": "where n is the number of elements for computing the rankedproduct",
	"Method": "JavaPairRDD<String, Tuple2<Double, Integer>> computeRankedProducts(JavaSparkContext context,JavaPairRDD<String, Long>[] ranks){\r\n    int N = 0;\r\n    long products = 1;\r\n    for (Long v : values) {\r\n        products *= v;\r\n        N++;\r\n    }\r\n    double rankedProduct = Math.pow((double) products, 1.0 / ((double) N));\r\n    return new Tuple2<Double, Integer>(rankedProduct, N);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getChangeLogRegister",
	"Comment": "return the changelogregister which controls which changelogfilter is used for eachbean type and in this way provide fine grained control over which persist requestsare included in the change log.",
	"Method": "ChangeLogRegister getChangeLogRegister(){\r\n    return changeLogRegister;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.bootup.BootupClasses.createAdd",
	"Comment": "create the instance if it has a default constructor and add it to the list of instances.it clears the list of classes afterwards, so that each class in the given list isinstantiated only once",
	"Method": "List<T> createAdd(List<T> instances,List<Class<? extends T>> candidates){\r\n    for (Class<? extends T> cls : candidates) {\r\n        T newInstance = create(cls, true);\r\n        if (newInstance != null) {\r\n            instances.add(newInstance);\r\n        }\r\n    }\r\n    candidates.clear();\r\n    return instances;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultContainer.attachListener",
	"Comment": "create and attach a datasourcepoollistener if it has been specified via properties and there is not one already attached.",
	"Method": "void attachListener(ServerConfig config,DataSourceConfig dsConfig){\r\n    if (dsConfig.getListener() == null) {\r\n        String poolListener = dsConfig.getPoolListener();\r\n        if (poolListener != null) {\r\n            dsConfig.setListener((DataSourcePoolListener) config.getClassLoadConfig().newInstance(poolListener));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.DefaultProfileHandler.sleep",
	"Comment": "sleep backing off towards 250 millis when there is no activity.this seems to be simple and decent for our queue consumer.",
	"Method": "void sleep(){\r\n    try {\r\n        int sleepFor = Math.min(++sleepBackoff, 250);\r\n        Thread.sleep(sleepFor);\r\n    } catch (InterruptedException e) {\r\n        Thread.currentThread().interrupt();\r\n    }\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.SetX.iterate",
	"Comment": "create a setx by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "SetX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).setX(LAZY);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.DequeX.range",
	"Comment": "create a dequex that contains the integers between skip and take",
	"Method": "DequeX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).dequeX(LAZY);\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DatabasePlatform.getLikeClause",
	"Comment": "returns the like clause used by this database platform.this may include an escape clause to disable a default escape character.",
	"Method": "String getLikeClause(boolean rawLikeExpression){\r\n    return rawLikeExpression ? likeClauseRaw : likeClauseEscaped;\r\n}"
}, {
	"Path": "io.ebean.config.ClassLoadConfig.newInstance",
	"Comment": "return a new instance of the class using the default constructor.",
	"Method": "Object newInstance(String className){\r\n    try {\r\n        Class<?> cls = forName(className);\r\n        return cls.newInstance();\r\n    } catch (Exception e) {\r\n        throw new IllegalArgumentException(\"Error constructing \" + className, e);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.bootup.BootupClassPathSearch.search",
	"Comment": "search the classpath for the classes we are interested in returningthem as bootupclasses.",
	"Method": "BootupClasses search(ServerConfig serverConfig){\r\n    return new BootupClassPathSearch(serverConfig).getBootupClasses();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.cache.DefaultServerCache.getTrimSize",
	"Comment": "return the size to trim to based on the max size.this returns 90% of the max size.",
	"Method": "int getTrimSize(){\r\n    return (maxSize * 90 / 100);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.OrmQueryDetail.clear",
	"Comment": "remove all joins and properties.typically for the row count query.",
	"Method": "void clear(){\r\n    fetchPaths.clear();\r\n}"
}, {
	"Path": "io.ebean.cache.ServerCacheStatistics.getEvictByLRU",
	"Comment": "return the count of entries evicted due to time least recently used.",
	"Method": "long getEvictByLRU(){\r\n    return evictByLRU;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DbPlatformTypeMapping.config",
	"Comment": "map the uuid appropriately based on native db support and serverconfig.dbuuid.",
	"Method": "void config(boolean nativeUuidType,PlatformConfig.DbUuid dbUuid){\r\n    if (nativeUuidType && dbUuid.useNativeType()) {\r\n    } else if (dbUuid.useBinary()) {\r\n        put(DbType.UUID, get(DbType.BINARY).withLength(16));\r\n    } else {\r\n        put(DbType.UUID, get(DbType.VARCHAR).withLength(40));\r\n    }\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.setEmbeddedPropertyDirty",
	"Comment": "set that an embedded bean has had one of its properties changed.",
	"Method": "void setEmbeddedPropertyDirty(int propertyIndex){\r\n    flags[propertyIndex] |= FLAG_EMBEDDED_DIRTY;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocOne.createEmbeddedId",
	"Comment": "create a bean of the target type to be used as an embeddedidvalue.",
	"Method": "Object createEmbeddedId(){\r\n    return getTargetDescriptor().createEntityBean();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getVersionProperty",
	"Comment": "return the first version property that exists on the bean. returns null ifno version property exists on the bean.note that this does not find a version property on an embedded bean.",
	"Method": "BeanProperty getVersionProperty(){\r\n    return versionProperty;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.ListX.fill",
	"Comment": "generate a listx from the provided value up to the provided limit number of times",
	"Method": "ListX<T> fill(long limit,T s){\r\n    return ReactiveSeq.fill(s).limit(limit).to(ReactiveConvertableSequence::converter).listX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DatabasePlatform.getClobDbType",
	"Comment": "return the data type that should be used for clob.this is typically types.clob but for postgres is types.varchar.",
	"Method": "int getClobDbType(){\r\n    return clobDbType;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.DbTriggerUpdate.dropDependencyBuffer",
	"Comment": "return the appropriate drop dependency buffer for the current mode.",
	"Method": "DdlBuffer dropDependencyBuffer(){\r\n    return writer.applyDropDependencies();\r\n}"
}, {
	"Path": "io.ebean.bean.CallStack.description",
	"Comment": "return the call stack lines appended with the given newline string.",
	"Method": "String description(String newLine){\r\n    StringBuilder sb = new StringBuilder(400);\r\n    for (StackTraceElement aCallStack : callStack) {\r\n        sb.append(aCallStack.toString()).append(newLine);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.LazyStream.run",
	"Comment": "trigger a lazy stream and return the results in the collection created bythe collector",
	"Method": "void run(R run,Collector<U, A, R> collector){\r\n    if (getLastActive().isSequential()) {\r\n        if (collector.supplier().get() == null) {\r\n            forEach(r -> {\r\n            });\r\n            return null;\r\n        }\r\n        final A col = collector.supplier().get();\r\n        forEach(r -> collector.accumulator().accept(col, r));\r\n        return collector.finisher().apply(col);\r\n    }\r\n    final Function<FastFuture<U>, U> safeJoin = (final FastFuture<U> cf) -> (U) BlockingStreamHelper.getSafe(cf, getErrorHandler());\r\n    final LazyResultConsumer<U> batcher = collector.supplier().get() != null ? getLazyCollector().get().withResults(new ArrayList()) : new EmptyCollector(this.getMaxActive(), safeJoin);\r\n    try {\r\n        this.getLastActive().injectFutures().forEach(n -> {\r\n            batcher.accept(n);\r\n        });\r\n    } catch (final SimpleReactProcessingException e) {\r\n    }\r\n    if (collector.supplier().get() == null) {\r\n        batcher.block(safeJoin);\r\n        return null;\r\n    }\r\n    return (R) batcher.getAllResults().stream().map(cf -> BlockingStreamHelper.getSafe(cf, getErrorHandler())).filter(v -> v != MissingValue.MISSING_VALUE).collect((Collector) collector);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.build.ModelBuildContext.getDbTypeMap",
	"Comment": "return the map used to determine the db specific typefor a given bean property.",
	"Method": "DbPlatformTypeMapping getDbTypeMap(){\r\n    return dbTypeMap;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.lazyLoadMany",
	"Comment": "return true if the lazy loading property is a many in which case justdefine a reference for the collection and not invoke a query.",
	"Method": "boolean lazyLoadMany(EntityBeanIntercept ebi,boolean lazyLoadMany,EntityBeanIntercept ebi,int lazyLoadProperty){\r\n    BeanProperty lazyLoadBeanProp = propertiesIndex[lazyLoadProperty];\r\n    if (lazyLoadBeanProp instanceof BeanPropertyAssocMany<?>) {\r\n        BeanPropertyAssocMany<?> manyProp = (BeanPropertyAssocMany<?>) lazyLoadBeanProp;\r\n        manyProp.createReference(ebi.getOwner());\r\n        ebi.setLoadedLazy();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.ebean.config.AutoTuneConfig.isSkipProfileReportingOnShutdown",
	"Comment": "return true if profile reporting should be skipped on shutdown.",
	"Method": "boolean isSkipProfileReportingOnShutdown(){\r\n    return skipProfileReportingOnShutdown;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultServer.beginTransaction",
	"Comment": "start a transaction with a specific isolation level.note that the transaction is stored in a threadlocal variable.",
	"Method": "Transaction beginTransaction(Transaction beginTransaction,TxScope txScope,Transaction beginTransaction,TxIsolation isolation){\r\n    SpiTransaction t = transactionManager.createTransaction(true, isolation.getLevel());\r\n    try {\r\n        transactionManager.set(t);\r\n    } catch (PersistenceException existingTransactionError) {\r\n        t.end();\r\n        throw existingTransactionError;\r\n    }\r\n    return t;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.BeanPersistIds.notifyCache",
	"Comment": "notify the cache of this event that came from another server in the cluster.",
	"Method": "void notifyCache(CacheChangeSet changeSet){\r\n    changeSet.addClearQuery(beanDescriptor);\r\n    if (ids != null) {\r\n        changeSet.addBeanRemoveMany(beanDescriptor, ids);\r\n    }\r\n}"
}, {
	"Path": "cyclops.reactive.Spouts.narrowK",
	"Comment": "convert the raw higher kinded type for reactiveseq types into the reactiveseq type definition class",
	"Method": "ReactiveSeq<T> narrowK(Higher<reactiveSeq, T> future){\r\n    return (ReactiveSeq<T>) future;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.createDeployDescriptor",
	"Comment": "create a deploybeandescriptor for an elementcollection target.",
	"Method": "DeployBeanDescriptor<A> createDeployDescriptor(Class<A> targetType){\r\n    return new DeployBeanDescriptor(this, targetType, serverConfig);\r\n}"
}, {
	"Path": "cyclops.control.Try.runWithCatch",
	"Comment": "try to execute supplied runnable and will catch specified excpetions or java.lang.exceptionif none specified.",
	"Method": "Try<Void, X> runWithCatch(CheckedRunnable<X> cf,Class<? extends X> classes){\r\n    Objects.requireNonNull(cf);\r\n    try {\r\n        cf.run();\r\n        return Try.success(null);\r\n    } catch (final Throwable t) {\r\n        if (classes.length == 0)\r\n            return Try.failure((X) t);\r\n        val error = Stream.of(classes).filter(c -> c.isAssignableFrom(t.getClass())).findFirst();\r\n        if (error.isPresent())\r\n            return Try.failure((X) t);\r\n        else\r\n            throw ExceptionSoftener.throwSoftenedException(t);\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.AutoTuneConfig.getProfilingUpdateFrequency",
	"Comment": "return the frequency in seconds the profiling should be collected and automatically applied to the tuning.",
	"Method": "int getProfilingUpdateFrequency(){\r\n    return profilingUpdateFrequency;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.parse.DeployCreateProperties.ignoreFieldByName",
	"Comment": "return true if we should ignore this field.we want to ignore ebean internal fields and some others as well.",
	"Method": "boolean ignoreFieldByName(String fieldName){\r\n    if (fieldName.startsWith(\"_ebean_\")) {\r\n        return true;\r\n    }\r\n    if (fieldName.startsWith(\"ajc$instance$\")) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "cyclops.reactive.ReactiveSeq.narrowK",
	"Comment": "convert the raw higher kinded type for reactiveseq types into the reactiveseq type definition class",
	"Method": "ReactiveSeq<T> narrowK(Higher<reactiveSeq, T> future){\r\n    return (ReactiveSeq<T>) future;\r\n}"
}, {
	"Path": "cyclops.control.LazyEither4.toIor",
	"Comment": "return an ior that can be this object or a ior.right or ior.left",
	"Method": "Ior<LT1, RT> toIor(){\r\n    return this.fold(l -> Ior.left(l), m -> Ior.left(null), m -> Ior.left(null), r -> Ior.right(r));\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setJsonFactory",
	"Comment": "set the jackson jsonfactory to use.if not set a default implementation will be used.",
	"Method": "void setJsonFactory(JsonFactory jsonFactory){\r\n    this.jsonFactory = jsonFactory;\r\n}"
}, {
	"Path": "io.ebean.RawSqlBuilder.resultSet",
	"Comment": "create and return a rawsql object based on the resultset and list of properties the columns inthe resultset map to.the properties listed in the propertynames must be in the same order as the columns in theresultset.",
	"Method": "RawSql resultSet(ResultSet resultSet,String propertyNames){\r\n    return XServiceProvider.rawSql().resultSet(resultSet, propertyNames);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.DdlGenerator.getClassLoader",
	"Comment": "return the classloader to use to read sql scripts as resources.",
	"Method": "ClassLoader getClassLoader(){\r\n    ClassLoader cl = Thread.currentThread().getContextClassLoader();\r\n    if (cl == null) {\r\n        cl = this.getClassLoader();\r\n    }\r\n    return cl;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.SqlTreeProperties.requireSqlDistinct",
	"Comment": "check for an aggregation property and set manywherejoin as needed.return true if a sql distinct is required.",
	"Method": "boolean requireSqlDistinct(ManyWhereJoins manyWhereJoins){\r\n    String joinProperty = aggregationJoin();\r\n    if (joinProperty != null) {\r\n        manyWhereJoins.addAggregationJoin(joinProperty);\r\n        return false;\r\n    } else {\r\n        return manyWhereJoins.requireSqlDistinct();\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.DefaultTransactionThreadLocal.get",
	"Comment": "return the current transaction for this servername and thread.",
	"Method": "SpiTransaction get(String serverName){\r\n    TransactionMap map = local.get();\r\n    State state = map.getState(serverName);\r\n    SpiTransaction t = (state == null) ? null : state.transaction;\r\n    if (map.isEmpty()) {\r\n        local.remove();\r\n    }\r\n    return t;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.OrmQueryDetail.isEmpty",
	"Comment": "return true if the query detail has neither select properties specified or any joins defined.",
	"Method": "boolean isEmpty(){\r\n    return fetchPaths.isEmpty() && baseProps.allProperties();\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getChangeLogListener",
	"Comment": "return the changeloglistener which actually performs the logging of change setsin the background.",
	"Method": "ChangeLogListener getChangeLogListener(){\r\n    return changeLogListener;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultCallableSql.getTransactionEventTable",
	"Comment": "return the transactionevent which holds the table modificationinformation for this callablesql. this information is merged into thetransaction after the transaction is commited.",
	"Method": "TransactionEventTable getTransactionEventTable(){\r\n    return transactionEvent;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.dml.InsertHandler.execute",
	"Comment": "execute non batched insert additionally using getgeneratedkeys if required.",
	"Method": "int execute(){\r\n    int rowCount = dataBind.executeUpdate();\r\n    if (useGeneratedKeys) {\r\n        getGeneratedKeys();\r\n    } else if (useSelectLastInsertedId) {\r\n        fetchGeneratedKeyUsingSelect();\r\n    }\r\n    checkRowCount(rowCount);\r\n    return rowCount;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.ChainedBeanQueryAdapter.register",
	"Comment": "register a new beanqueryadapter and return the resulting chain.",
	"Method": "ChainedBeanQueryAdapter register(BeanQueryAdapter c){\r\n    if (list.contains(c)) {\r\n        return this;\r\n    } else {\r\n        List<BeanQueryAdapter> newList = new ArrayList(list);\r\n        newList.add(c);\r\n        return new ChainedBeanQueryAdapter(newList);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.InheritInfo.isDeleteRecurseSkippable",
	"Comment": "return true if anything in the inheritance hierarchy has a relationship with a delete cascadeon it.",
	"Method": "boolean isDeleteRecurseSkippable(){\r\n    return root.isNodeDeleteRecurseSkippable();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.ChainedBeanPostConstructListener.postConstruct",
	"Comment": "fire postload on all registered beanpostcreate implementations.",
	"Method": "void postConstruct(Object bean){\r\n    for (BeanPostConstructListener aChain : chain) {\r\n        aChain.postConstruct(bean);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.AbstractValueExpression.value",
	"Comment": "return the bind value taking into account named parameters.",
	"Method": "Object value(){\r\n    return NamedParamHelp.value(bindValue);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.SqlTreeNodeManyWhereJoin.appendFromBaseTable",
	"Comment": "join to base table for this node. this includes a join to theintersection table if this is a manytomany node.",
	"Method": "void appendFromBaseTable(DbSqlContext ctx,SqlJoinType joinType){\r\n    String alias = ctx.getTableAliasManyWhere(prefix);\r\n    String parentAlias = ctx.getTableAliasManyWhere(parentPrefix);\r\n    if (nodeBeanProp instanceof STreePropertyAssocOne) {\r\n        nodeBeanProp.addJoin(joinType, parentAlias, alias, ctx);\r\n    } else {\r\n        STreePropertyAssocMany manyProp = (STreePropertyAssocMany) nodeBeanProp;\r\n        if (!manyProp.hasJoinTable()) {\r\n            manyProp.addJoin(joinType, parentAlias, alias, ctx);\r\n        } else {\r\n            String alias2 = alias + \"z_\";\r\n            TableJoin manyToManyJoin = manyProp.getIntersectionTableJoin();\r\n            manyToManyJoin.addJoin(joinType, parentAlias, alias2, ctx);\r\n            manyProp.addJoin(joinType, alias2, alias, ctx);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.ImplicitReadOnlyTransaction.isBatchThisRequest",
	"Comment": "return true if this request should be batched. returning false means thatthis request should be executed immediately.",
	"Method": "boolean isBatchThisRequest(){\r\n    return false;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.OrmQueryRequest.createJsonReadOptions",
	"Comment": "return the jsonreadoptions taking into account lazy loading and persistence context.",
	"Method": "JsonReadOptions createJsonReadOptions(){\r\n    persistenceContext = getPersistenceContext(query, transaction);\r\n    if (query.getPersistenceContext() == null) {\r\n        query.setPersistenceContext(persistenceContext);\r\n    }\r\n    jsonRead = new JsonReadOptions();\r\n    jsonRead.setPersistenceContext(persistenceContext);\r\n    if (!query.isDisableLazyLoading()) {\r\n        loadContext = new DLoadContext(this, secondaryQueries);\r\n        jsonRead.setLoadContext(loadContext);\r\n    }\r\n    return jsonRead;\r\n}"
}, {
	"Path": "cyclops.function.Consumer4.apply",
	"Comment": "partially applyhkt the first, second and third input parameters to this c4",
	"Method": "Function<T2, Function<T3, Consumer<T4>>> apply(T1 s,Function<T3, Consumer<T4>> apply,T1 s,T2 s2,Consumer<T4> apply,T1 s,T2 s2,T3 s3){\r\n    return CurryConsumer.curryC4(this).apply(s).apply(s2).apply(s3);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.MTable.checkDuplicateForeignKeys",
	"Comment": "check if there are duplicate foreign keys.this can occur when an manytomany relates back to itself.",
	"Method": "void checkDuplicateForeignKeys(){\r\n    if (hasDuplicateForeignKeys()) {\r\n        int counter = 1;\r\n        for (MCompoundForeignKey fk : compoundKeys) {\r\n            fk.addNameSuffix(counter++);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setChangeLogIncludeInserts",
	"Comment": "set if inserts should be included in the change log by default.",
	"Method": "void setChangeLogIncludeInserts(boolean changeLogIncludeInserts){\r\n    this.changeLogIncludeInserts = changeLogIncludeInserts;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getReadAuditPrepare",
	"Comment": "return the readauditprepare for preparing read audit events prior to logging.",
	"Method": "ReadAuditPrepare getReadAuditPrepare(){\r\n    return ebeanServer.getReadAuditPrepare();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.DefaultExpressionList.setUnderlying",
	"Comment": "replace the underlying expression list with one organised by nested path.",
	"Method": "void setUnderlying(List<SpiExpression> groupedByNesting){\r\n    this.list = groupedByNesting;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.createListeners",
	"Comment": "create the beancontrollers, beanfinders and beanlisteners.",
	"Method": "void createListeners(){\r\n    int qa = beanQueryAdapterManager.getRegisterCount();\r\n    int cc = persistControllerManager.getRegisterCount();\r\n    int pl = postLoadManager.getRegisterCount();\r\n    int pc = postConstructManager.getRegisterCount();\r\n    int lc = persistListenerManager.getRegisterCount();\r\n    int fc = beanFinderManager.getRegisterCount();\r\n    logger.debug(\"BeanPersistControllers[{}] BeanFinders[{}] BeanPersistListeners[{}] BeanQueryAdapters[{}] BeanPostLoaders[{}] BeanPostConstructors[{}]\", cc, fc, lc, qa, pl, pc);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.parse.AnnotationAssocManys.readJoinTable",
	"Comment": "define the joins for a manytomany relationship.this includes joins to the intersection table and from the intersection tableto the other side of the manytomany.",
	"Method": "void readJoinTable(JoinTable joinTable,DeployBeanPropertyAssocMany<?> prop){\r\n    String intTableName = getFullTableName(joinTable);\r\n    if (intTableName.isEmpty()) {\r\n        BeanTable localTable = factory.getBeanTable(descriptor.getBeanType());\r\n        BeanTable otherTable = factory.getBeanTable(prop.getTargetType());\r\n        intTableName = getM2MJoinTableName(localTable, otherTable);\r\n    }\r\n    DeployTableJoin intJoin = new DeployTableJoin();\r\n    intJoin.setTable(intTableName);\r\n    intJoin.addJoinColumn(true, joinTable.joinColumns(), prop.getBeanTable());\r\n    DeployTableJoin destJoin = prop.getTableJoin();\r\n    destJoin.addJoinColumn(false, joinTable.inverseJoinColumns(), prop.getBeanTable());\r\n    intJoin.setType(SqlJoinType.OUTER);\r\n    DeployTableJoin inverseDest = destJoin.createInverse(intTableName);\r\n    prop.setIntersectionJoin(intJoin);\r\n    prop.setInverseJoin(inverseDest);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getPersistBatchSize",
	"Comment": "return the batch size used for jdbc batching. this defaults to 20.",
	"Method": "int getPersistBatchSize(){\r\n    return persistBatchSize;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.platform.DbExpressionHandlerFactory.from",
	"Comment": "create and return the appropriate platform specific handing of expressions.",
	"Method": "DbExpressionHandler from(DatabasePlatform databasePlatform){\r\n    Platform platform = databasePlatform.getPlatform();\r\n    switch(platform) {\r\n        case H2:\r\n            return new H2DbExpression();\r\n        case POSTGRES:\r\n            return new PostgresDbExpression();\r\n        case MYSQL:\r\n            return new MySqlDbExpression();\r\n        case ORACLE:\r\n            return new OracleDbExpression();\r\n        case SQLSERVER16:\r\n        case SQLSERVER17:\r\n        case SQLSERVER:\r\n            return new SqlServerDbExpression();\r\n        case HANA:\r\n            return new HanaDbExpression();\r\n        default:\r\n            return new BasicDbExpression();\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.SqlTree.getManyProperty",
	"Comment": "return the property that is associated with the many. there can only be oneper sqlselect. this can be null.",
	"Method": "STreePropertyAssocMany getManyProperty(){\r\n    return manyProperty;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanPropertyAssocMany.setFetchOrderBy",
	"Comment": "set the order by clause used to order the fetching or the data for thislist, set or map.",
	"Method": "void setFetchOrderBy(String orderBy){\r\n    if (orderBy != null && !orderBy.isEmpty()) {\r\n        fetchOrderBy = orderBy;\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssoc.newQuery",
	"Comment": "create a new query for the target type.we use target descriptor rather than target property type to support elementcollection.",
	"Method": "SpiQuery<T> newQuery(SpiEbeanServer server){\r\n    return new DefaultOrmQuery(targetDescriptor, server, server.getExpressionFactory());\r\n}"
}, {
	"Path": "cyclops.futurestream.SimpleReact.fromStream",
	"Comment": "start a reactive dataflow from a stream of completablefutures.",
	"Method": "SimpleReactStream<U> fromStream(Stream<CompletableFuture<U>> stream){\r\n    final Stream s = stream;\r\n    return construct(s);\r\n}"
}, {
	"Path": "cyclops.control.LazyEither5.toIor",
	"Comment": "return an ior that can be this object or a ior.right or ior.left",
	"Method": "Ior<LT1, RT> toIor(){\r\n    return this.fold(l -> Ior.left(l), m -> Ior.left(null), m -> Ior.left(null), m -> Ior.left(null), r -> Ior.right(r));\r\n}"
}, {
	"Path": "cyclops.kinds.StreamKind.narrowK",
	"Comment": "convert the raw higher kinded type for stream types into the streamkind type definition class",
	"Method": "StreamKind<T> narrowK(Higher<DataWitness.stream, T> stream){\r\n    return (StreamKind<T>) stream;\r\n}"
}, {
	"Path": "cyclops.stream.StreamSource.of",
	"Comment": "construct a pushable streamsource using the provided queuefactory as a push mechanism",
	"Method": "StreamSource of(QueueFactory<?> q,StreamSource of,int backPressureAfter){\r\n    if (backPressureAfter < 1)\r\n        throw new IllegalArgumentException(\"Can't apply back pressure after less than 1 event\");\r\n    return new StreamSource(backPressureAfter, true);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.BeanRequest.isLogSummary",
	"Comment": "return true if summary information should be logged for this transaction.",
	"Method": "boolean isLogSummary(){\r\n    return transaction.isLogSummary();\r\n}"
}, {
	"Path": "cyclops.data.ImmutableMap.toLazySeq",
	"Comment": "convert this immutablemap to a lazyseq via the provided transformation function",
	"Method": "LazySeq<T> toLazySeq(Function<? super Tuple2<? super K, ? super V>, ? extends T> fn){\r\n    return LazySeq.narrow(stream().map(fn).to().lazySeq());\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.HistoryTableUpdate.add",
	"Comment": "add a comment for column added, dropped, included or excluded.",
	"Method": "void add(Change change,String column){\r\n    columnChanges.add(new Column(change, column));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.InheritInfo.getType",
	"Comment": "for a discriminator get the inheritance information for this tree.",
	"Method": "Class<?> getType(InheritInfo getType,String discValue){\r\n    return discMap.get(discValue);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.DefaultOrmQuery.markQueryJoins",
	"Comment": "limit the number of fetch joins to many properties, mark as query joins as needed.",
	"Method": "void markQueryJoins(){\r\n    detail.markQueryJoins(beanDescriptor, lazyLoadManyPath, isAllowOneManyFetch(), type != Type.ATTRIBUTE);\r\n}"
}, {
	"Path": "cyclops.monads.transformers.ListT.of",
	"Comment": "construct an listt from an anym that wraps a monad containinglists",
	"Method": "ListT<W, A> of(AnyM<W, ? extends IndexedSequenceX<A>> monads){\r\n    return new ListT(monads);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.lib.ShutdownManager.registerEbeanServer",
	"Comment": "register an ebeanserver to be shutdown when the jvm is shutdown.",
	"Method": "void registerEbeanServer(SpiEbeanServer server){\r\n    synchronized (servers) {\r\n        servers.add(server);\r\n    }\r\n}"
}, {
	"Path": "org.dataalgorithms.chap08.mapreduce.CommonFriendsReducer.reduce",
	"Comment": "the goal is to find common friends by intersecting all lists defined in values parameter.",
	"Method": "void reduce(Text key,Iterable<Text> values,Context context){\r\n    Map<String, Integer> map = new HashMap<String, Integer>();\r\n    Iterator<Text> iterator = values.iterator();\r\n    int numOfValues = 0;\r\n    while (iterator.hasNext()) {\r\n        String friends = iterator.next().toString();\r\n        if (friends.equals(\"\")) {\r\n            context.write(key, new Text(\"[]\"));\r\n            return;\r\n        }\r\n        addFriends(map, friends);\r\n        numOfValues++;\r\n    }\r\n    List<String> commonFriends = new ArrayList<String>();\r\n    for (Map.Entry<String, Integer> entry : map.entrySet()) {\r\n        if (entry.getValue() == numOfValues) {\r\n            commonFriends.add(entry.getKey());\r\n        }\r\n    }\r\n    context.write(key, new Text(commonFriends.toString()));\r\n}"
}, {
	"Path": "cyclops.companion.Streams.streamToCompletableFuture",
	"Comment": "create a completablefuture containing a list materialized from a stream",
	"Method": "CompletableFuture<List<T>> streamToCompletableFuture(Stream<T> stream){\r\n    return CompletableFuture.completedFuture(stream.collect(Collectors.toList()));\r\n}"
}, {
	"Path": "io.ebeanservice.docstore.api.DocStoreUpdates.getPersistEvents",
	"Comment": "return the persist insert and update requests to be sent to the document store.",
	"Method": "List<DocStoreUpdate> getPersistEvents(){\r\n    return persistEvents;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultServer.initialise",
	"Comment": "run any initialisation required before registering with the clustermanager.",
	"Method": "void initialise(){\r\n    if (encryptKeyManager != null) {\r\n        encryptKeyManager.initialise();\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.ExplicitTransactionManager.initOnQueryOnly",
	"Comment": "override the initialise of onqueryonly with the intention not to use close with explicitjdbctransaction.",
	"Method": "DatabasePlatform.OnQueryOnly initOnQueryOnly(DatabasePlatform.OnQueryOnly dbPlatformOnQueryOnly){\r\n    String systemPropertyValue = System.getProperty(\"ebean.transaction.onqueryonly\");\r\n    if (systemPropertyValue != null) {\r\n        return DatabasePlatform.OnQueryOnly.valueOf(systemPropertyValue.trim().toUpperCase());\r\n    }\r\n    return dbPlatformOnQueryOnly == null ? DatabasePlatform.OnQueryOnly.ROLLBACK : dbPlatformOnQueryOnly;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.changelog.ChangeJsonBuilder.writeBeanChange",
	"Comment": "write the bean change as json document containing the transaction header details.",
	"Method": "void writeBeanChange(JsonGenerator gen,BeanChange bean,ChangeSet changeSet){\r\n    gen.writeStartObject();\r\n    gen.writeNumberField(\"ts\", bean.getEventTime());\r\n    gen.writeStringField(\"change\", bean.getEvent().getCode());\r\n    gen.writeStringField(\"type\", bean.getType());\r\n    gen.writeStringField(\"id\", bean.getId().toString());\r\n    if (bean.getTenantId() != null) {\r\n        gen.writeStringField(\"tenantId\", bean.getTenantId().toString());\r\n    }\r\n    writeBeanTransactionDetails(gen, changeSet);\r\n    writeBeanValues(gen, bean);\r\n    gen.writeEndObject();\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.isAllQuotedIdentifiers",
	"Comment": "return true if all db column and table names should use quoted identifiers.",
	"Method": "boolean isAllQuotedIdentifiers(){\r\n    return platformConfig.isAllQuotedIdentifiers();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.NamedParamHelp.value",
	"Comment": "return the bind value taking into account named parameters.",
	"Method": "Object value(Object val){\r\n    if (val instanceof SpiNamedParam) {\r\n        return ((SpiNamedParam) val).getValue();\r\n    }\r\n    return val;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.util.ArrayStack.peek",
	"Comment": "returns the object at the top of this stack without removing it.",
	"Method": "E peek(){\r\n    return peekZero(false);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.InPairsExpression.concat",
	"Comment": "using db concat at this stage. usually a db expression index should match the concat.",
	"Method": "String concat(Object key,Object value){\r\n    StringBuilder sb = new StringBuilder(30);\r\n    sb.append(key);\r\n    sb.append(separator);\r\n    sb.append(value);\r\n    if (suffix != null) {\r\n        sb.append(suffix);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.DdlHelp.isDropForeignKey",
	"Comment": "return true if the default value is the special drop foreign key value.",
	"Method": "boolean isDropForeignKey(String value){\r\n    return DROP_FOREIGN_KEY.equals(value);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.MigrationModel.read",
	"Comment": "read all the migrations returning the model with allthe migrations applied in version order.",
	"Method": "ModelContainer read(){\r\n    readMigrations();\r\n    return model;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.QueueX.generate",
	"Comment": "generate a queuex from the provided supplier up to the provided limit number of times",
	"Method": "QueueX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).queueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.suppressForeignKey",
	"Comment": "return true if foreign keys to the base table should be suppressed.",
	"Method": "boolean suppressForeignKey(){\r\n    return partitionMeta != null;\r\n}"
}, {
	"Path": "io.ebean.config.DocStoreConfig.getBulkBatchSize",
	"Comment": "return the default batch size to use for calls to the bulk api.",
	"Method": "int getBulkBatchSize(){\r\n    return bulkBatchSize;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanProperty.isLocalEncrypted",
	"Comment": "return true if the property is encrypted in java rather than in the db.",
	"Method": "boolean isLocalEncrypted(){\r\n    return localEncrypted;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.InternalConfiguration.createTransactionScopeManager",
	"Comment": "create the transactionscopemanager taking into account jta or external transaction manager.",
	"Method": "TransactionScopeManager createTransactionScopeManager(){\r\n    ExternalTransactionManager externalTransactionManager = serverConfig.getExternalTransactionManager();\r\n    if (externalTransactionManager == null && serverConfig.isUseJtaTransactionManager()) {\r\n        externalTransactionManager = new JtaTransactionManager();\r\n    }\r\n    if (externalTransactionManager != null) {\r\n        logger.info(\"Using Transaction Manager [\" + externalTransactionManager.getClass() + \"]\");\r\n        return new ExternalTransactionScopeManager(serverConfig.getName(), externalTransactionManager);\r\n    } else {\r\n        return new DefaultTransactionScopeManager(serverConfig.getName());\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.json.DJsonService.parseObject",
	"Comment": "parse the json and return as a map taking a jsonparser and a starting token.used when the first token is checked to see if the value is null prior to calling this.",
	"Method": "Map<String, Object> parseObject(String json,boolean modifyAware,Map<String, Object> parseObject,String json,Map<String, Object> parseObject,Reader reader,boolean modifyAware,Map<String, Object> parseObject,Reader reader,Map<String, Object> parseObject,JsonParser parser,Map<String, Object> parseObject,JsonParser parser,JsonToken token){\r\n    return EJsonReader.parseObject(parser, token);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.DefaultPersister.getBeanIds",
	"Comment": "helper method to return the list of id values for the list of beans.",
	"Method": "List<Object> getBeanIds(BeanDescriptor<T> desc,List<T> beans){\r\n    List<Object> idList = new ArrayList(beans.size());\r\n    for (T liveBean : beans) {\r\n        idList.add(desc.getBeanId(liveBean));\r\n    }\r\n    return idList;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.propertiesOneImported",
	"Comment": "returns manytoones and onetoones on the imported owning side.excludes onetoones on the exported side.",
	"Method": "BeanPropertyAssocOne<?>[] propertiesOneImported(){\r\n    return propertiesOneImported;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.DefaultPersister.createRequest",
	"Comment": "create the persist request object that wraps all the objects used toperform an insert, update or delete.",
	"Method": "PersistRequestBean<T> createRequest(T bean,Transaction t,PersistRequest.Type type,PersistRequestBean<T> createRequest,T bean,Transaction t,Object parentBean,BeanManager<?> mgr,PersistRequest.Type type,int flags){\r\n    if (type == Type.DELETE_PERMANENT) {\r\n        type = Type.DELETE;\r\n    } else if (type == Type.DELETE && mgr.getBeanDescriptor().isSoftDelete()) {\r\n        type = Type.DELETE_SOFT;\r\n    }\r\n    return new PersistRequestBean(server, bean, parentBean, mgr, (SpiTransaction) t, persistExecute, type, flags);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getBackgroundExecutorShutdownSecs",
	"Comment": "return the background executor shutdown seconds. this is the time allowed for the pool to shutdown nicelybefore it is forced shutdown.",
	"Method": "int getBackgroundExecutorShutdownSecs(){\r\n    return backgroundExecutorShutdownSecs;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.PstmtFactory.getPstmt",
	"Comment": "return a prepared statement taking into account batch requirements.",
	"Method": "PreparedStatement getPstmt(SpiTransaction t,String sql,boolean getGeneratedKeys,PreparedStatement getPstmt,SpiTransaction t,boolean logSql,String sql,BatchPostExecute batchExe){\r\n    BatchedPstmtHolder batch = t.getBatchControl().getPstmtHolder();\r\n    PreparedStatement stmt = batch.getStmt(sql, batchExe);\r\n    if (stmt != null) {\r\n        return stmt;\r\n    }\r\n    if (logSql) {\r\n        t.logSql(TrimLogSql.trim(sql));\r\n    }\r\n    Connection conn = t.getInternalConnection();\r\n    stmt = conn.prepareStatement(sql);\r\n    BatchedPstmt bs = new BatchedPstmt(stmt, false, sql, t);\r\n    batch.addStmt(bs, batchExe);\r\n    return stmt;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.isBeanCaching",
	"Comment": "return true if there is currently bean caching for this type of bean.",
	"Method": "boolean isBeanCaching(){\r\n    return cacheHelp.isBeanCaching();\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.MapX.toQueueX",
	"Comment": "convert this mapx to a queuex via the provided transformation function",
	"Method": "QueueX<T> toQueueX(Function<? super Tuple2<? super K, ? super V>, ? extends T> fn){\r\n    return QueueX.narrow(stream().map(fn).to(ReactiveConvertableSequence::converter).queueX());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.type.EnumToDbValueMap.isIntegerType",
	"Comment": "return true if this is mapping to integers, falseif mapping to strings.",
	"Method": "boolean isIntegerType(){\r\n    return isIntegerType;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.createBeanTable",
	"Comment": "create the beantable from the deployment information gathered so far.",
	"Method": "BeanTable createBeanTable(DeployBeanInfo<?> info){\r\n    DeployBeanDescriptor<?> deployDescriptor = info.getDescriptor();\r\n    DeployBeanTable beanTable = deployDescriptor.createDeployBeanTable();\r\n    return new BeanTable(beanTable, this);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.filter",
	"Comment": "removes elements that do not fold the supplied predicate from thedataflow",
	"Method": "SimpleReactStream<U> filter(Predicate<? super U> p){\r\n    if (!isAsync())\r\n        return filterSync(p);\r\n    final Function<Stream<CompletableFuture>, Stream<CompletableFuture>> fn = s -> s.map(ft -> ft.thenApplyAsync((in) -> {\r\n        if (!p.test((U) in)) {\r\n            throw new FilteredExecutionPathException();\r\n        }\r\n        return in;\r\n    }));\r\n    return this.withLastActive(getLastActive().stream(fn));\r\n}"
}, {
	"Path": "io.ebean.Pairs.getConcatSuffix",
	"Comment": "returna suffix used with db varchar concatenation to combine the 2 values.",
	"Method": "String getConcatSuffix(){\r\n    return concatSuffix;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.DefaultPersister.createPublishRequest",
	"Comment": "create the persist request object additionally specifying the publish status.",
	"Method": "PersistRequestBean<T> createPublishRequest(T bean,Transaction t,PersistRequest.Type type,int flags){\r\n    return createRequestInternal(bean, t, type, Flags.unsetRecuse(flags));\r\n}"
}, {
	"Path": "io.ebean.config.EncryptDeploy.getDbLength",
	"Comment": "return a hint to specify the db length.returning 0 means just use the normal db length determination.",
	"Method": "int getDbLength(){\r\n    return dbLength;\r\n}"
}, {
	"Path": "io.ebean.bean.ObjectGraphOrigin.getKey",
	"Comment": "the key includes the queryplan hash and the callstack hash. this becomesthe unique identifier for a query point.",
	"Method": "String getKey(){\r\n    return key;\r\n}"
}, {
	"Path": "io.ebean.common.BeanList.setActualList",
	"Comment": "set the actual underlying list.this is primarily for the deferred fetching function.",
	"Method": "void setActualList(List<?> list){\r\n    this.list = (List<E>) list;\r\n}"
}, {
	"Path": "io.ebean.config.DbMigrationConfig.setPatchInsertOn",
	"Comment": "set migration versions that should be added to history without running.value can be a string containing comma delimited list of version numbers.",
	"Method": "void setPatchInsertOn(String patchInsertOn){\r\n    this.patchInsertOn = patchInsertOn;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanProperty.setUndirectionalShadow",
	"Comment": "mark this property as a placeholder for a unidirectional relationship.",
	"Method": "void setUndirectionalShadow(){\r\n    this.undirectionalShadow = true;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.ImplicitReadOnlyTransaction.getPersistenceContext",
	"Comment": "return the persistence context associated with this transaction.",
	"Method": "PersistenceContext getPersistenceContext(){\r\n    return persistenceContext;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.ImplicitReadOnlyTransaction.isRegisteredBean",
	"Comment": "return true if this is a bean that has already been saved. this willregister the bean if it is not already.",
	"Method": "boolean isRegisteredBean(Object bean){\r\n    return false;\r\n}"
}, {
	"Path": "io.ebean.config.DocStoreConfig.setPathToResources",
	"Comment": "set the relative file system path to resources when generating mapping files.",
	"Method": "void setPathToResources(String pathToResources){\r\n    this.pathToResources = pathToResources;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.reactive.ReactiveTask.requestAllAsync",
	"Comment": "request all elements to be processed asynchronously in the processing stream",
	"Method": "ReactiveTask requestAllAsync(){\r\n    return requestAsync(Long.MAX_VALUE);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.docStoreMapping",
	"Comment": "add to the document mapping if this property is included for this index.",
	"Method": "void docStoreMapping(DocMappingBuilder mapping,String prefix){\r\n    if (mapping.includesProperty(prefix, name)) {\r\n        DocPropertyType type = scalarType.getDocType();\r\n        DocPropertyOptions options = docOptions.copy();\r\n        if (isKeywordType(type, options)) {\r\n            type = DocPropertyType.KEYWORD;\r\n        }\r\n        mapping.add(new DocPropertyMapping(name, type, options));\r\n    }\r\n}"
}, {
	"Path": "io.ebean.ProfileLocation.createAt",
	"Comment": "create and return a new profilelocation with a given location.",
	"Method": "ProfileLocation createAt(String location){\r\n    return XServiceProvider.profileLocationFactory().createAt(location);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.OrmQueryRequest.flushPersistenceContextOnIterate",
	"Comment": "for iterate queries reset the persistencecontext and loadcontext.",
	"Method": "void flushPersistenceContextOnIterate(){\r\n    persistenceContext = new DefaultPersistenceContext();\r\n    loadContext.resetPersistenceContext(persistenceContext);\r\n    if (jsonRead != null) {\r\n        jsonRead.setPersistenceContext(persistenceContext);\r\n        jsonRead.setLoadContext(loadContext);\r\n    }\r\n}"
}, {
	"Path": "chapter06trees.WidthOfTree.width",
	"Comment": "the width of a binary tree is the maximum number of elements on one level of the tree.",
	"Method": "int width(BinaryTreeNode root,int width,BinaryTreeNode root,int depth){\r\n    if (root == null)\r\n        return 0;\r\n    else if (depth == 0)\r\n        return 1;\r\n    else\r\n        return width(root.left, depth - 1) + width(root.right, depth - 1);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.isEmbedded",
	"Comment": "return true if this is an embedded property. in this case it shares thetable and primary key of its owner object.",
	"Method": "boolean isEmbedded(){\r\n    return embedded;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.ChainedBeanPersistListener.addList",
	"Comment": "helper method used to create a list from 2 beanpersistlistener.",
	"Method": "List<BeanPersistListener> addList(BeanPersistListener c1,BeanPersistListener c2){\r\n    ArrayList<BeanPersistListener> addList = new ArrayList(2);\r\n    addList.add(c1);\r\n    addList.add(c2);\r\n    return addList;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.ChainedBeanPostLoad.postLoad",
	"Comment": "fire postload on all registered beanpostload implementations.",
	"Method": "void postLoad(Object bean){\r\n    for (BeanPostLoad aChain : chain) {\r\n        aChain.postLoad(bean);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.lib.DaemonScheduleThreadPool.shutdown",
	"Comment": "shutdown this thread pool nicely if possible.this will wait a maximum of 20 seconds before terminating any threads stillworking.",
	"Method": "void shutdown(){\r\n    synchronized (this) {\r\n        if (super.isShutdown()) {\r\n            logger.debug(\"DaemonScheduleThreadPool {} already shut down\", namePrefix);\r\n            return;\r\n        }\r\n        try {\r\n            logger.debug(\"DaemonScheduleThreadPool {} shutting down...\", namePrefix);\r\n            super.shutdown();\r\n            if (!super.awaitTermination(shutdownWaitSeconds, TimeUnit.SECONDS)) {\r\n                logger.info(\"DaemonScheduleThreadPool shut down timeout exceeded. Terminating running threads.\");\r\n                super.shutdownNow();\r\n            }\r\n        } catch (Exception e) {\r\n            logger.error(\"Error during shutdown of \" + namePrefix, e);\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.DefaultExpressionList.jsonEqualTo",
	"Comment": "equal to expression for the value at the given path in the json document.",
	"Method": "ExpressionList<T> jsonEqualTo(String propertyName,String path,Object value){\r\n    add(expr.jsonEqualTo(propertyName, path, value));\r\n    return this;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.PostgresHistoryDdl.addSysPeriodColumns",
	"Comment": "use postgres range type rather than start and end timestamps.",
	"Method": "void addSysPeriodColumns(DdlBuffer apply,String baseTableName,String whenCreatedColumn){\r\n    apply.append(\"alter table \").append(baseTableName).append(\" add column \").append(sysPeriod).append(\" tstzrange not null default tstzrange(\").append(currentTimestamp).append(\", null)\").endOfStatement();\r\n    if (whenCreatedColumn != null) {\r\n        apply.append(\"update \").append(baseTableName).append(\" set \").append(sysPeriod).append(\" = tstzrange(\").append(whenCreatedColumn).append(\", null)\").endOfStatement();\r\n    }\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.ListX.generate",
	"Comment": "generate a listx from the provided supplier up to the provided limit number of times",
	"Method": "ListX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).listX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getDefaultOrderBy",
	"Comment": "return the default order by that may need to be added if a many property isincluded in the query.",
	"Method": "String getDefaultOrderBy(){\r\n    return idBinder.getDefaultOrderBy();\r\n}"
}, {
	"Path": "io.ebeaninternal.extraddl.model.ExtraDdlXmlReader.read",
	"Comment": "read and return a extraddl from an xml document at the given resource path.",
	"Method": "ExtraDdl read(ExtraDdl read,String resourcePath,ExtraDdl read,InputStream is){\r\n    try {\r\n        JAXBContext jaxbContext = JAXBContext.newInstance(ExtraDdl.class);\r\n        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\r\n        return (ExtraDdl) unmarshaller.unmarshal(is);\r\n    } catch (JAXBException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "io.ebean.TxScope.setIsolation",
	"Comment": "set the transaction isolation level this transaction should run with.",
	"Method": "TxScope setIsolation(TxIsolation isolation){\r\n    this.isolation = isolation;\r\n    return this;\r\n}"
}, {
	"Path": "chapter03linkedlists.DoublyLinkedList.remove",
	"Comment": "if the position is greater than 0, remove the value at the last position.",
	"Method": "void remove(int position){\r\n    if (position < 0) {\r\n        position = 0;\r\n    }\r\n    if (position >= length) {\r\n        position = length - 1;\r\n    }\r\n    if (head == null)\r\n        return;\r\n    if (position == 0) {\r\n        head = head.getNext();\r\n        if (head == null)\r\n            tail = null;\r\n    } else {\r\n        DLLNode temp = head;\r\n        for (int i = 1; i < position; i += 1) {\r\n            temp = temp.getNext();\r\n        }\r\n        temp.getNext().setPrev(temp.getPrev());\r\n        temp.getPrev().setNext(temp.getNext());\r\n    }\r\n    length -= 1;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.cache.CacheChangeSet.addBeanInsert",
	"Comment": "on bean insert register table for view based entity invalidation.",
	"Method": "void addBeanInsert(String baseTable){\r\n    touchedTables.add(baseTable);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.IdInExpression.addSqlNoAlias",
	"Comment": "for use with deleting non attached detail beans during stateless update.",
	"Method": "void addSqlNoAlias(SpiExpressionRequest request){\r\n    DefaultExpressionRequest r = (DefaultExpressionRequest) request;\r\n    BeanDescriptor<?> descriptor = r.getBeanDescriptor();\r\n    IdBinder idBinder = descriptor.getIdBinder();\r\n    if (idCollection.isEmpty()) {\r\n        request.append(\"1=0\");\r\n    } else {\r\n        request.append(descriptor.getIdBinder().getBindIdInSql(null));\r\n        String inClause = idBinder.getIdInValueExpr(false, idCollection.size());\r\n        request.append(inClause);\r\n    }\r\n}"
}, {
	"Path": "chapter06trees.DeepestNode.deepestNodeinBinaryTree",
	"Comment": "the last node processed from queue in level order is the deepest node in binary tree.",
	"Method": "BinaryTreeNode deepestNodeinBinaryTree(BinaryTreeNode root){\r\n    BinaryTreeNode tmp = null;\r\n    if (root == null)\r\n        return null;\r\n    Queue<BinaryTreeNode> q = new LinkedList<BinaryTreeNode>();\r\n    q.offer(root);\r\n    while (!q.isEmpty()) {\r\n        tmp = q.poll();\r\n        if (tmp.getLeft() != null)\r\n            q.offer(tmp.getLeft());\r\n        if (tmp.right != null)\r\n            q.offer(tmp.right);\r\n    }\r\n    return tmp;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.InternalConfiguration.getDbExpressionHandler",
	"Comment": "return the json expression handler for the given database platform.",
	"Method": "DbExpressionHandler getDbExpressionHandler(DatabasePlatform databasePlatform){\r\n    return DbExpressionHandlerFactory.from(databasePlatform);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getNamingConvention",
	"Comment": "return the namingconvention.if none has been set the default underscorenamingconvention is used.",
	"Method": "NamingConvention getNamingConvention(){\r\n    return namingConvention;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocMany.hasDraftIntersection",
	"Comment": "return true if the relationship is a manytomany with the intersection having an associated draft table.",
	"Method": "boolean hasDraftIntersection(){\r\n    return intersectionDraftTable != null && !intersectionDraftTable.equals(intersectionPublishTable);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.type.DefaultTypeManager.initialiseStandard",
	"Comment": "register all the standard types supported. this is the standard jdbc typesplus some other common types such as java.util.date and java.util.calendar.",
	"Method": "void initialiseStandard(JsonConfig.DateTime mode,ServerConfig config){\r\n    DatabasePlatform databasePlatform = config.getDatabasePlatform();\r\n    int platformClobType = databasePlatform.getClobDbType();\r\n    int platformBlobType = databasePlatform.getBlobDbType();\r\n    nativeMap.put(DbPlatformType.HSTORE, hstoreType);\r\n    ScalarType<?> utilDateType = extraTypeFactory.createUtilDate(mode);\r\n    addType(java.util.Date.class, utilDateType);\r\n    ScalarType<?> calType = extraTypeFactory.createCalendar(mode);\r\n    addType(Calendar.class, calType);\r\n    ScalarType<?> mathBigIntType = extraTypeFactory.createMathBigInteger();\r\n    addType(BigInteger.class, mathBigIntType);\r\n    ScalarTypeBool booleanType = extraTypeFactory.createBoolean();\r\n    addType(Boolean.class, booleanType);\r\n    addType(boolean.class, booleanType);\r\n    databasePlatform.setDbTrueLiteral(booleanType.getDbTrueLiteral());\r\n    databasePlatform.setDbFalseLiteral(booleanType.getDbFalseLiteral());\r\n    nativeMap.put(Types.BOOLEAN, booleanType);\r\n    if (booleanType.getJdbcType() == Types.BIT) {\r\n        nativeMap.put(Types.BIT, booleanType);\r\n    }\r\n    PlatformConfig.DbUuid dbUuid = config.getPlatformConfig().getDbUuid();\r\n    if (offlineMigrationGeneration || (databasePlatform.isNativeUuidType() && dbUuid.useNativeType())) {\r\n        addType(UUID.class, new ScalarTypeUUIDNative());\r\n    } else {\r\n        ScalarType<?> uuidType = dbUuid.useBinary() ? new ScalarTypeUUIDBinary(dbUuid.useBinaryOptimized()) : new ScalarTypeUUIDVarchar();\r\n        addType(UUID.class, uuidType);\r\n    }\r\n    addType(File.class, fileType);\r\n    addType(InetAddress.class, inetAddressType);\r\n    addType(Locale.class, localeType);\r\n    addType(Currency.class, currencyType);\r\n    addType(TimeZone.class, timeZoneType);\r\n    addType(URL.class, urlType);\r\n    addType(URI.class, uriType);\r\n    addType(char[].class, charArrayType);\r\n    addType(char.class, charType);\r\n    addType(String.class, stringType);\r\n    nativeMap.put(Types.VARCHAR, stringType);\r\n    nativeMap.put(Types.CHAR, stringType);\r\n    nativeMap.put(Types.LONGVARCHAR, longVarcharType);\r\n    addType(Class.class, classType);\r\n    if (platformClobType == Types.CLOB) {\r\n        nativeMap.put(Types.CLOB, clobType);\r\n    } else {\r\n        ScalarType<?> platClobScalarType = nativeMap.get(platformClobType);\r\n        if (platClobScalarType == null) {\r\n            throw new IllegalArgumentException(\"Type for dbPlatform clobType [\" + clobType + \"] not found.\");\r\n        }\r\n        nativeMap.put(Types.CLOB, platClobScalarType);\r\n    }\r\n    addType(byte[].class, varbinaryType);\r\n    nativeMap.put(Types.BINARY, binaryType);\r\n    nativeMap.put(Types.VARBINARY, varbinaryType);\r\n    nativeMap.put(Types.LONGVARBINARY, longVarbinaryType);\r\n    if (platformBlobType == Types.BLOB) {\r\n        nativeMap.put(Types.BLOB, blobType);\r\n    } else {\r\n        ScalarType<?> platBlobScalarType = nativeMap.get(platformBlobType);\r\n        if (platBlobScalarType == null) {\r\n            throw new IllegalArgumentException(\"Type for dbPlatform blobType [\" + blobType + \"] not found.\");\r\n        }\r\n        nativeMap.put(Types.BLOB, platBlobScalarType);\r\n    }\r\n    addType(Byte.class, byteType);\r\n    addType(byte.class, byteType);\r\n    nativeMap.put(Types.TINYINT, byteType);\r\n    addType(Short.class, shortType);\r\n    addType(short.class, shortType);\r\n    nativeMap.put(Types.SMALLINT, shortType);\r\n    addType(Integer.class, integerType);\r\n    addType(int.class, integerType);\r\n    nativeMap.put(Types.INTEGER, integerType);\r\n    addType(Long.class, longType);\r\n    addType(long.class, longType);\r\n    nativeMap.put(Types.BIGINT, longType);\r\n    addType(Double.class, doubleType);\r\n    addType(double.class, doubleType);\r\n    nativeMap.put(Types.FLOAT, doubleType);\r\n    nativeMap.put(Types.DOUBLE, doubleType);\r\n    addType(Float.class, floatType);\r\n    addType(float.class, floatType);\r\n    nativeMap.put(Types.REAL, floatType);\r\n    addType(BigDecimal.class, bigDecimalType);\r\n    nativeMap.put(Types.DECIMAL, bigDecimalType);\r\n    nativeMap.put(Types.NUMERIC, bigDecimalType);\r\n    addType(Time.class, timeType);\r\n    nativeMap.put(Types.TIME, timeType);\r\n    addType(Date.class, dateType);\r\n    nativeMap.put(Types.DATE, dateType);\r\n    ScalarType<?> timestampType = new ScalarTypeTimestamp(mode);\r\n    addType(Timestamp.class, timestampType);\r\n    nativeMap.put(Types.TIMESTAMP, timestampType);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.readEntityBeanTable",
	"Comment": "create the beantable information which has the base table and id.this is determined prior to resolving relationship information.",
	"Method": "void readEntityBeanTable(){\r\n    for (DeployBeanInfo<?> info : deployInfoMap.values()) {\r\n        BeanTable beanTable = createBeanTable(info);\r\n        beanTableMap.put(beanTable.getBeanType(), beanTable);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQuery.auditFindIterate",
	"Comment": "indicate that read auditing is occurring on this finditerate query.",
	"Method": "void auditFindIterate(){\r\n    auditFindIterate = true;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.DdlWrite.applyDropDependencies",
	"Comment": "return the buffer that executes early to drop dependencies like views etc.",
	"Method": "DdlBuffer applyDropDependencies(){\r\n    return applyDropDependencies;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DbIdentity.isSupportsGetGeneratedKeys",
	"Comment": "return true if getgeneratedkeys is supported.getgeneratedkeys required to support jdbc batching transparently.",
	"Method": "boolean isSupportsGetGeneratedKeys(){\r\n    return supportsGetGeneratedKeys;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getIdBinder",
	"Comment": "return the idbinder which is helpful for handling the various types of id.",
	"Method": "IdBinder getIdBinder(){\r\n    return idBinder;\r\n}"
}, {
	"Path": "io.ebeaninternal.api.ScopeTrans.isRollbackThrowable",
	"Comment": "return true if this throwable should cause a rollback to occur.",
	"Method": "boolean isRollbackThrowable(Throwable e){\r\n    if (e instanceof Error) {\r\n        return true;\r\n    }\r\n    if (noRollbackFor != null) {\r\n        for (Class<? extends Throwable> aNoRollbackFor : noRollbackFor) {\r\n            if (aNoRollbackFor.equals(e.getClass())) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    if (rollbackFor != null) {\r\n        for (Class<? extends Throwable> aRollbackFor : rollbackFor) {\r\n            if (aRollbackFor.equals(e.getClass())) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return e instanceof RuntimeException || rollbackOnChecked;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.isAutoTunable",
	"Comment": "return true if queries for beans of this type are auto tunable.",
	"Method": "boolean isAutoTunable(){\r\n    return autoTunable;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanPropertyAssocMany.setInverseJoin",
	"Comment": "manytomany only, join from foreign table to intersection table.",
	"Method": "void setInverseJoin(DeployTableJoin inverseJoin){\r\n    this.inverseJoin = inverseJoin;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.VectorX.range",
	"Comment": "create a vectorx that contains the integers between skip and take",
	"Method": "VectorX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).vectorX(LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanProperty.checkPrimitiveBoolean",
	"Comment": "primitive boolean check so see if not null default false should be applied.",
	"Method": "void checkPrimitiveBoolean(){\r\n    if (boolean.class.equals(propertyType) && !softDelete) {\r\n        this.nullable = false;\r\n        if (dbColumnDefault == null) {\r\n            this.dbColumnDefault = DbDefaultValue.FALSE;\r\n        }\r\n    } else if (!id && !versionColumn && PRIMITIVE_NUMBER_TYPES.contains(propertyType)) {\r\n        this.nullable = false;\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.ChainedBeanPersistController.register",
	"Comment": "register a new beanpersistcontroller and return the resulting chain.",
	"Method": "ChainedBeanPersistController register(BeanPersistController c){\r\n    if (list.contains(c)) {\r\n        return this;\r\n    } else {\r\n        List<BeanPersistController> newList = new ArrayList(list);\r\n        newList.add(c);\r\n        return new ChainedBeanPersistController(newList);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.descOf",
	"Comment": "return the correct beandescriptor based on the bean class type.",
	"Method": "BeanDescriptor<?> descOf(Class<?> type){\r\n    return inheritInfo.readType(type).desc();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.DefaultOrmQuery.isDistinctQuery",
	"Comment": "return true if this query uses sql distinct either explicitly by the user or internally definedby ebean.",
	"Method": "boolean isDistinctQuery(){\r\n    return distinct || sqlDistinct;\r\n}"
}, {
	"Path": "io.ebean.Ebean.createNamedQuery",
	"Comment": "create a named query.for rawsql the named query is expected to be in ebean.xml.",
	"Method": "Query<T> createNamedQuery(Class<T> beanType,String namedQuery){\r\n    return serverMgr.getDefaultServer().createNamedQuery(beanType, namedQuery);\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.SequenceBatchIdGenerator.readIds",
	"Comment": "add the next set of ids as the next value plus all the following numbers up to the step size.",
	"Method": "List<Long> readIds(ResultSet resultSet,int loadSize){\r\n    List<Long> newIds = new ArrayList(loadSize);\r\n    while (resultSet.next()) {\r\n        newIds.add(resultSet.getLong(1));\r\n    }\r\n    return newIds;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorCacheHelp.isCacheNotify",
	"Comment": "return true if the persist request needs to notify the cache.",
	"Method": "boolean isCacheNotify(PersistRequest.Type type){\r\n    return cacheNotifyOnAll || cacheNotifyOnDelete && (type == PersistRequest.Type.DELETE || type == PersistRequest.Type.DELETE_PERMANENT);\r\n}"
}, {
	"Path": "io.ebean.PrimaryServer.determineDefaultServerName",
	"Comment": "determine and return the default server name checking system environment variables and then global properties.",
	"Method": "String determineDefaultServerName(){\r\n    String defaultServerName = System.getenv(\"EBEAN_DB\");\r\n    defaultServerName = System.getProperty(\"db\", defaultServerName);\r\n    defaultServerName = System.getProperty(\"ebean_db\", defaultServerName);\r\n    if (isEmpty(defaultServerName)) {\r\n        defaultServerName = System.getProperty(\"datasource.default\");\r\n        if (isEmpty(defaultServerName)) {\r\n            defaultServerName = System.getProperty(\"ebean.default.datasource\");\r\n            if (isEmpty(defaultServerName)) {\r\n                defaultServerName = globalProperties.getProperty(\"datasource.default\");\r\n                if (isEmpty(defaultServerName)) {\r\n                    defaultServerName = globalProperties.getProperty(\"ebean.default.datasource\");\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (defaultServerName == null) {\r\n        defaultServerName = \"db\";\r\n    }\r\n    return defaultServerName;\r\n}"
}, {
	"Path": "com.oath.cyclops.util.stream.scheduling.cron.CronExpression.isValidExpression",
	"Comment": "indicates whether the specified cron expression can be parsed into avalid cron expression",
	"Method": "boolean isValidExpression(String cronExpression){\r\n    try {\r\n        new CronExpression(cronExpression);\r\n    } catch (final ParseException pe) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.ebean.config.AutoTuneConfig.setQueryTuningAddVersion",
	"Comment": "set to true to force the version property to be always added by the querytuning.if this is false then the version property will be added when profilingdetects that the bean is possibly going to be modified.generally this is not expected to be turned on.",
	"Method": "void setQueryTuningAddVersion(boolean queryTuningAddVersion){\r\n    this.queryTuningAddVersion = queryTuningAddVersion;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.PlatformDdl.identityType",
	"Comment": "determine the id type to use based on requested identitytype andthe support for that in the database platform.",
	"Method": "IdType identityType(IdentityType modelIdentity,IdType platformIdType,boolean supportsSequence,boolean supportsIdentity){\r\n    switch(modelIdentity) {\r\n        case GENERATOR:\r\n            return IdType.GENERATOR;\r\n        case EXTERNAL:\r\n            return IdType.EXTERNAL;\r\n        case SEQUENCE:\r\n            return supportsSequence ? IdType.SEQUENCE : platformIdType;\r\n        case IDENTITY:\r\n            return supportsIdentity ? IdType.IDENTITY : platformIdType;\r\n        default:\r\n            return platformIdType;\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.cacheManyPropLoad",
	"Comment": "try to load the beancollection from cache return true if successful.",
	"Method": "boolean cacheManyPropLoad(BeanPropertyAssocMany<?> many,BeanCollection<?> bc,Object parentId,Boolean readOnly){\r\n    return cacheHelp.manyPropLoad(many, bc, parentId, readOnly);\r\n}"
}, {
	"Path": "io.ebean.config.AutoTuneConfig.getQueryTuningFile",
	"Comment": "return the name of the file that holds the query tuning information.",
	"Method": "String getQueryTuningFile(){\r\n    return queryTuningFile;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DbDefaultValue.convert",
	"Comment": "convert the db default literal to platform specific type or function.this is intended for the db column default clause in ddl.",
	"Method": "String convert(String dbDefaultLiteral){\r\n    if (dbDefaultLiteral == null) {\r\n        return null;\r\n    }\r\n    if (dbDefaultLiteral.startsWith(\"$RAW:\")) {\r\n        return dbDefaultLiteral.substring(5);\r\n    }\r\n    String val = map.get(dbDefaultLiteral);\r\n    return val != null ? val : dbDefaultLiteral;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorCacheHelp.isNaturalKeyCaching",
	"Comment": "return true if there is natural key caching for this type of bean.",
	"Method": "boolean isNaturalKeyCaching(){\r\n    return naturalKeyCache != null;\r\n}"
}, {
	"Path": "cyclops.function.Consumer5.apply",
	"Comment": "partially applyhkt the first, second, third and fourth input parameters to this c5",
	"Method": "Function<T2, Function<T3, Function<T4, Consumer<T5>>>> apply(T1 s,Function<T3, Function<T4, Consumer<T5>>> apply,T1 s,T2 s2,Function<T4, Consumer<T5>> apply,T1 s,T2 s2,T3 s3,Consumer<T5> apply,T1 s,T2 s2,T3 s3,T4 s4){\r\n    return CurryConsumer.curryC5(this).apply(s).apply(s2).apply(s3).apply(s4);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQueryHistorySupport.isStandardsBased",
	"Comment": "return true if the underlying history support is standards based.",
	"Method": "boolean isStandardsBased(){\r\n    return dbHistorySupport.isStandardsBased();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssoc.docStoreInclude",
	"Comment": "determine if and how the associated bean is included in the doc store document.",
	"Method": "void docStoreInclude(boolean includeByDefault,DocStructure docStructure){\r\n    String embeddedDoc = getDocStoreDoc();\r\n    if (embeddedDoc == null) {\r\n        if (includeByDefault) {\r\n            docStoreIncludeByDefault(docStructure.doc());\r\n        }\r\n    } else {\r\n        if (embeddedDoc.isEmpty()) {\r\n            embeddedDoc = \"*\";\r\n        }\r\n        PathProperties embDoc = PathProperties.parse(embeddedDoc);\r\n        docStructure.addNested(name, embDoc);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.ExportedProperty.appendWhere",
	"Comment": "append a logical where for the foreign db column to logical property name,",
	"Method": "void appendWhere(StringBuilder sb,String alias,String path){\r\n    sb.append(alias).append(foreignDbColumn).append(\" = \");\r\n    if (path != null) {\r\n        sb.append(path).append(\".\");\r\n    }\r\n    sb.append(property.getName());\r\n}"
}, {
	"Path": "io.ebean.config.ClassLoadConfig.isJacksonAnnotationsPresent",
	"Comment": "return true if jackson annotations like jsonignore are present.",
	"Method": "boolean isJacksonAnnotationsPresent(){\r\n    return isPresent(\"com.fasterxml.jackson.annotation.JsonIgnore\");\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.BatchControl.setBatchSize",
	"Comment": "set the size of batch execution.the user can set this via the transaction.",
	"Method": "void setBatchSize(int batchSize){\r\n    if (batchSize > 1) {\r\n        this.batchSize = batchSize;\r\n    }\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.VectorX.generate",
	"Comment": "generate a vectorx from the provided supplier up to the provided limit number of times",
	"Method": "VectorX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).vectorX(LAZY);\r\n}"
}, {
	"Path": "io.ebean.config.ClassLoadConfig.isJavaTimePresent",
	"Comment": "return true if the java.time types are available and should be supported.",
	"Method": "boolean isJavaTimePresent(){\r\n    return isPresent(\"java.time.LocalDate\");\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.OrderedSetX.generate",
	"Comment": "generate a orderedsetx from the provided supplier up to the provided limit number of times",
	"Method": "OrderedSetX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).orderedSetX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.profile.DTimeMetricStats.getStartTime",
	"Comment": "return the time the counter started statistics collection.",
	"Method": "long getStartTime(){\r\n    return startTime;\r\n}"
}, {
	"Path": "org.tests.model.basic.finder.CustomerFinder.updateToInactive",
	"Comment": "bulk update customers matching the name to inactive status.",
	"Method": "int updateToInactive(String name){\r\n    return update().set(\"status\", Customer.Status.INACTIVE).setRaw(\"version = version + 1\").where().eq(\"name\", name).update();\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.PlatformDdl.convertArrayType",
	"Comment": "convert the logical array type to a db platform specific type to support the array data.",
	"Method": "String convertArrayType(String logicalArrayType){\r\n    if (logicalArrayType.endsWith(\"]\")) {\r\n        return fallbackArrayType;\r\n    }\r\n    int colonPos = logicalArrayType.lastIndexOf(']');\r\n    return \"varchar\" + logicalArrayType.substring(colonPos + 1);\r\n}"
}, {
	"Path": "cyclops.kinds.OptionalKind.narrowK",
	"Comment": "convert the higherkindedtype definition for a optional into",
	"Method": "Optional<T> narrowK(Higher<optional, T> Optional){\r\n    return ((OptionalKind<T>) Optional).boxed;\r\n}"
}, {
	"Path": "io.ebeaninternal.api.LoadBeanRequest.postLoad",
	"Comment": "load the beans into the l2 cache if that is requested and check for load failures due to deletes.",
	"Method": "void postLoad(List<?> list){\r\n    Set<Object> loadedIds = new HashSet();\r\n    BeanDescriptor<?> desc = loadBuffer.getBeanDescriptor();\r\n    for (Object aList : list) {\r\n        EntityBean loadedBean = (EntityBean) aList;\r\n        loadedIds.add(desc.getId(loadedBean));\r\n    }\r\n    if (isLoadCache()) {\r\n        desc.cacheBeanPutAll(list);\r\n    }\r\n    if (lazyLoadProperty != null) {\r\n        for (EntityBeanIntercept ebi : batch) {\r\n            Object id = desc.getId(ebi.getOwner());\r\n            if (!loadedIds.contains(id)) {\r\n                desc.markAsDeleted(ebi.getOwner());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultServer.saveAllInternal",
	"Comment": "save all beans in the iterator with an explicit transaction.",
	"Method": "int saveAllInternal(Collection<?> beans,Transaction transaction){\r\n    if (beans == null || beans.isEmpty()) {\r\n        return 0;\r\n    }\r\n    return executeInTrans((txn) -> {\r\n        txn.checkBatchEscalationOnCollection();\r\n        int saveCount = 0;\r\n        for (Object bean : beans) {\r\n            persister.save(checkEntityBean(bean), txn);\r\n            saveCount++;\r\n        }\r\n        txn.flushBatchOnCollection();\r\n        return saveCount;\r\n    }, transaction);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanCollectionUtil.isModified",
	"Comment": "return true if this is a bean collection and not considered dirty.",
	"Method": "boolean isModified(Object collection){\r\n    if ((collection instanceof BeanCollection<?>)) {\r\n        return ((BeanCollection<?>) collection).holdsModifications();\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.convertToLazyStream",
	"Comment": "convert between an lazy and eager future stream,can be used to take advantages of each approach during a single stream",
	"Method": "FutureStream<U> convertToLazyStream(){\r\n    return new LazyReact(getTaskExecutor()).fromStreamFutures((Stream) getLastActive().stream());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocMany.setJoinValuesToChild",
	"Comment": "set the join properties from the parent bean to the child bean.this is only valid for onetomany and not valid for manytomany.",
	"Method": "void setJoinValuesToChild(EntityBean parent,EntityBean child,Object mapKeyValue){\r\n    if (mapKeyProperty != null) {\r\n        mapKeyProperty.setValue(child, mapKeyValue);\r\n    }\r\n    if (!manyToMany && childMasterProperty != null) {\r\n        childMasterProperty.setValue(child, parent);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.OrmQueryRequest.getPersistenceContext",
	"Comment": "get the transactioncontext either explicitly set on the query ortransaction scoped.",
	"Method": "PersistenceContext getPersistenceContext(PersistenceContext getPersistenceContext,SpiQuery<?> query,SpiTransaction t){\r\n    PersistenceContext ctx = query.getPersistenceContext();\r\n    if (ctx != null)\r\n        return ctx;\r\n    PersistenceContextScope scope = ebeanServer.getPersistenceContextScope(query);\r\n    return (scope == PersistenceContextScope.QUERY || t == null) ? new DefaultPersistenceContext() : t.getPersistenceContext();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.BeanRequest.createImplicitTransIfRequired",
	"Comment": "a helper method for creating an implicit transaction is it is required.a transaction may have been passed in or active in the thread local. ifnot then create one implicitly to handle the request.",
	"Method": "boolean createImplicitTransIfRequired(){\r\n    if (transaction != null) {\r\n        return false;\r\n    }\r\n    transaction = ebeanServer.currentServerTransaction();\r\n    if (transaction == null || !transaction.isActive()) {\r\n        transaction = ebeanServer.beginServerTransaction();\r\n        createdTransaction = true;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.JdbcTransaction.isSaveAssocManyIntersection",
	"Comment": "return true if the m2m intersection save is allowed from a given bean direction.this is to stop m2m intersection management via both directions of a m2m.",
	"Method": "boolean isSaveAssocManyIntersection(String intersectionTable,String beanName){\r\n    if (m2mIntersectionSave == null) {\r\n        m2mIntersectionSave = new HashMap();\r\n        m2mIntersectionSave.put(intersectionTable, beanName);\r\n        return true;\r\n    }\r\n    String existingBean = m2mIntersectionSave.get(intersectionTable);\r\n    if (existingBean == null) {\r\n        m2mIntersectionSave.put(intersectionTable, beanName);\r\n        return true;\r\n    }\r\n    return existingBean.equals(beanName);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setDisableClasspathSearch",
	"Comment": "set to true to disable the class path search even for the case where no entity bean classeshave been registered. this can be used to start an ebeanserver instance just to use thesql functions such as sqlquery, sqlupdate etc.",
	"Method": "void setDisableClasspathSearch(boolean disableClasspathSearch){\r\n    this.disableClasspathSearch = disableClasspathSearch;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.BatchedPstmtHolder.addStmt",
	"Comment": "add a new preparedstatement wrapped in the batchstatement object.",
	"Method": "void addStmt(BatchedPstmt bs,BatchPostExecute postExecute){\r\n    bs.add(postExecute);\r\n    stmtMap.put(bs.getSql(), bs);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.dml.InsertMeta.supportsSelectLastInsertedId",
	"Comment": "return true if we should use a sql query to return the generated key.this can not be used with jdbc batch mode.",
	"Method": "boolean supportsSelectLastInsertedId(){\r\n    return supportsSelectLastInsertedId;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.util.VowelRemover.trim",
	"Comment": "trim a word by removing vowels skipping some initial characters.",
	"Method": "String trim(String word,int skipChars){\r\n    if (word.length() < skipChars) {\r\n        return word;\r\n    }\r\n    StringBuilder res = new StringBuilder();\r\n    res.append(word.substring(0, skipChars));\r\n    for (int i = skipChars; i < word.length(); i++) {\r\n        char ch = word.charAt(i);\r\n        if (!isVowel(ch)) {\r\n            res.append(ch);\r\n        }\r\n    }\r\n    return res.toString();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.OrmQueryDetail.hasParentSecJoin",
	"Comment": "if the chunk has a parent that is a query or lazy join. in this case it does not need to beconverted.",
	"Method": "boolean hasParentSecJoin(String lazyLoadManyPath,OrmQueryProperties chunk){\r\n    OrmQueryProperties parent = getParent(chunk);\r\n    if (parent == null) {\r\n        return false;\r\n    } else {\r\n        if (lazyLoadManyPath != null && lazyLoadManyPath.equals(parent.getPath())) {\r\n            return false;\r\n        } else {\r\n            return !parent.isFetchJoin() || hasParentSecJoin(lazyLoadManyPath, parent);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebean.TxScope.isSkipCache",
	"Comment": "return true if the l2 cache should be skipped for this transaction.",
	"Method": "boolean isSkipCache(){\r\n    return skipCache;\r\n}"
}, {
	"Path": "cyclops.control.Try.flatMapOrCatch",
	"Comment": "perform a flatmapping operation that may catch the supplied exception typesthe supplied exception types are only applied during this map operation",
	"Method": "Try<R, X> flatMapOrCatch(CheckedFunction<? super T, ? extends Try<? extends R, X>, X> fn,Class<? extends X> classes){\r\n    return new Try(xor.flatMap(i -> safeApplyM(i, fn.asFunction(), classes).toEither()), classes);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.DefaultPersister.delete",
	"Comment": "delete the bean.note that predelete fires before the deletion of children.",
	"Method": "int delete(EntityBean bean,Transaction t,boolean permanent,int delete,Class<?> beanType,Object id,Transaction transaction,boolean permanent,int delete,BeanDescriptor<?> descriptor,Object id,List<Object> idList,Transaction transaction,DeleteMode deleteMode,int delete,PersistRequestBean<?> request){\r\n    DeleteUnloadedForeignKeys unloadedForeignKeys = null;\r\n    if (request.isPersistCascade()) {\r\n        request.registerDeleteBean();\r\n        deleteAssocMany(request);\r\n        request.unregisterDeleteBean();\r\n        unloadedForeignKeys = getDeleteUnloadedForeignKeys(request);\r\n        if (unloadedForeignKeys != null) {\r\n            unloadedForeignKeys.queryForeignKeys();\r\n        }\r\n    }\r\n    int count = request.executeOrQueue();\r\n    if (request.isPersistCascade()) {\r\n        deleteAssocOne(request);\r\n        if (unloadedForeignKeys != null) {\r\n            unloadedForeignKeys.deleteCascade();\r\n        }\r\n    }\r\n    request.complete();\r\n    return count;\r\n}"
}, {
	"Path": "io.ebean.Ebean.getBeanState",
	"Comment": "return the beanstate for a given entity bean.this will return null if the bean is not an enhanced entity bean.",
	"Method": "BeanState getBeanState(Object bean){\r\n    return serverMgr.getDefaultServer().getBeanState(bean);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.ExternalJdbcTransaction.end",
	"Comment": "this will always throw a persistenceexception.externally created connections should be committed or rolled back externally.",
	"Method": "void end(){\r\n    throw new PersistenceException(\"This is an external transaction so must be committed externally\");\r\n}"
}, {
	"Path": "io.ebean.config.DocStoreConfig.setDropCreate",
	"Comment": "set to true if the document store should recreate mapped indexes.",
	"Method": "void setDropCreate(boolean dropCreate){\r\n    this.dropCreate = dropCreate;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.OrmQueryDetail.setDefaultSelectClause",
	"Comment": "set any default select clauses for the main bean and any joins that have not explicitly defineda select clause.that is this will use fetchtype.lazy to exclude some properties by default.",
	"Method": "void setDefaultSelectClause(BeanDescriptor<?> desc){\r\n    if (desc.hasDefaultSelectClause() && !hasSelectClause()) {\r\n        baseProps = new OrmQueryProperties(null, desc.getDefaultSelectClause());\r\n    }\r\n    for (OrmQueryProperties joinProps : fetchPaths.values()) {\r\n        if (!joinProps.hasSelectClause()) {\r\n            BeanDescriptor<?> assocDesc = desc.getBeanDescriptor(joinProps.getPath());\r\n            if (assocDesc != null && assocDesc.hasDefaultSelectClause()) {\r\n                fetch(joinProps.getPath(), assocDesc.getDefaultSelectClause(), joinProps.getFetchConfig());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebean.Model.delete",
	"Comment": "perform a delete using this entity against the specified server.",
	"Method": "boolean delete(boolean delete,String server){\r\n    return db(server).delete(this);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setAutoReadOnlyDataSource",
	"Comment": "set to true if ebean should create a datasource for use with implicit read only transactions.",
	"Method": "void setAutoReadOnlyDataSource(boolean autoReadOnlyDataSource){\r\n    this.autoReadOnlyDataSource = autoReadOnlyDataSource;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.isDeleteMissingChildren",
	"Comment": "return true if a stateless update should also delete any missing details beans.",
	"Method": "boolean isDeleteMissingChildren(){\r\n    return deleteMissingChildren;\r\n}"
}, {
	"Path": "io.ebeaninternal.api.ManyWhereJoins.addFormulaWithJoin",
	"Comment": "in findcount query found a formula property with a join clause so building a select clausespecifically for the findcount query.",
	"Method": "void addFormulaWithJoin(String propertyName){\r\n    if (formulaWithJoin) {\r\n        formulaProperties.append(\",\");\r\n    } else {\r\n        formulaProperties = new StringBuilder();\r\n        formulaWithJoin = true;\r\n    }\r\n    formulaProperties.append(propertyName);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanProperty.getScalarType",
	"Comment": "return the scalartype. this returns null for native jdbc types, otherwiseit is used to convert between logical types and jdbc types.",
	"Method": "ScalarType<?> getScalarType(){\r\n    return scalarType;\r\n}"
}, {
	"Path": "cyclops.futurestream.SimpleReact.parallelBuilder",
	"Comment": "construct a new simplereact builder, with a new task executor and retry executorwith configured number of threads",
	"Method": "SimpleReact parallelBuilder(SimpleReact parallelBuilder,int parallelism){\r\n    return SimpleReact.builder().executor(new ForkJoinPool(parallelism)).async(true).build();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.PstmtFactory.getCstmt",
	"Comment": "return a callable statement taking into account batch requirements.",
	"Method": "CallableStatement getCstmt(SpiTransaction t,String sql,CallableStatement getCstmt,SpiTransaction t,boolean logSql,String sql,BatchPostExecute batchExe){\r\n    BatchedPstmtHolder batch = t.getBatchControl().getPstmtHolder();\r\n    CallableStatement stmt = (CallableStatement) batch.getStmt(sql, batchExe);\r\n    if (stmt != null) {\r\n        return stmt;\r\n    }\r\n    if (logSql) {\r\n        t.logSql(sql);\r\n    }\r\n    Connection conn = t.getInternalConnection();\r\n    stmt = conn.prepareCall(sql);\r\n    BatchedPstmt bs = new BatchedPstmt(stmt, false, sql, t);\r\n    batch.addStmt(bs, batchExe);\r\n    return stmt;\r\n}"
}, {
	"Path": "cyclops.control.Future.complete",
	"Comment": "if not already completed, sets the value of this future to the provided value",
	"Method": "boolean complete(T value){\r\n    return future.complete(value);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setAllQuotedIdentifiers",
	"Comment": "set to true if all db column and table names should use quoted identifiers.",
	"Method": "void setAllQuotedIdentifiers(boolean allQuotedIdentifiers){\r\n    platformConfig.setAllQuotedIdentifiers(allQuotedIdentifiers);\r\n    if (allQuotedIdentifiers) {\r\n        adjustNamingConventionForAllQuoted();\r\n    }\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.DequeX.narrowK",
	"Comment": "convert the raw higher kinded type for deque types into the dequetype type definition class",
	"Method": "DequeX<T> narrowK(Higher<deque, T> list){\r\n    return (DequeX<T>) list;\r\n}"
}, {
	"Path": "io.ebean.cache.ServerCacheStatistics.getMissCount",
	"Comment": "return the miss count. the number of gets that returned null.",
	"Method": "long getMissCount(){\r\n    return missCount;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.build.ModelBuildPropertyVisitor.determineForeignKeyIndexName",
	"Comment": "return the foreign key constraint name given a single column foreign key.",
	"Method": "String determineForeignKeyIndexName(String column,String determineForeignKeyIndexName,String[] columns){\r\n    return ctx.foreignKeyIndexName(table.getName(), columns, ++countIndex);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.setTrans",
	"Comment": "set the transaction from prior persist request.only used when hard deleting draft & associated live beans.",
	"Method": "void setTrans(SpiTransaction transaction){\r\n    this.transaction = transaction;\r\n    this.createdTransaction = false;\r\n    this.persistCascade = transaction.isPersistCascade();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.OrmQueryProperties.addSecJoinOrderProperty",
	"Comment": "move a orderby.property from the main query to this query join.",
	"Method": "void addSecJoinOrderProperty(OrderBy.Property orderProp){\r\n    if (orderBy == null) {\r\n        orderBy = new OrderBy();\r\n    }\r\n    orderBy.add(orderProp);\r\n}"
}, {
	"Path": "cyclops.reactive.Spouts.async",
	"Comment": "create a push based stream with no backpressure fromm the provided stream.the provided stream will be executed on the provided executor and pushed to the returned stream",
	"Method": "ReactiveSeq<T> async(Consumer<? super PushSubscriber<T>> sub,ReactiveSeq<T> async,Stream<T> seq,Executor exec){\r\n    return async(s -> {\r\n        ReactiveSeq.fromStream(seq).foldFuture(exec, t -> {\r\n            PushSubscriber<T> local = s;\r\n            t.forEach(local::onNext, local::onError, local::onComplete);\r\n            return null;\r\n        });\r\n    });\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.SequenceBatchIdGenerator.preAllocateIds",
	"Comment": "if allocatesize is large load some sequences in a background thread.for example, when inserting a bean with a cascade on a onetomany with manybeans ebean can call this to ensure .",
	"Method": "void preAllocateIds(int requestSize){\r\n    if (allocationSize > 1 && requestSize > allocationSize) {\r\n        if (requestSize > 100) {\r\n            requestSize = 100;\r\n        }\r\n        loadInBackground(requestSize);\r\n    }\r\n}"
}, {
	"Path": "cyclops.function.Function1.before",
	"Comment": "apply before advice to this function, capture the input with the provided consumer",
	"Method": "Function1<T, R> before(Consumer<? super T> action){\r\n    return FluentFunctions.of(this).before(action);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.generatedproperty.GeneratedCounter.includeInInsert",
	"Comment": "include this in every insert setting initial counter value to 1.",
	"Method": "boolean includeInInsert(){\r\n    return true;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.hasDefaultSelectClause",
	"Comment": "return true if this bean type has a default select clause that is notsimply select all properties.",
	"Method": "boolean hasDefaultSelectClause(){\r\n    return defaultSelectClause != null;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocMany.findMatch",
	"Comment": "find the matching foreigndbcolumn for a given local property.",
	"Method": "ExportedProperty findMatch(boolean embedded,BeanProperty prop){\r\n    if (hasJoinTable()) {\r\n        return findMatch(embedded, prop, prop.getDbColumn(), intersectionJoin);\r\n    } else {\r\n        return findMatch(embedded, prop, prop.getDbColumn(), tableJoin);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssoc.getExtraWhere",
	"Comment": "return an extra clause to add to the query for loading or joiningto this bean type.",
	"Method": "String getExtraWhere(){\r\n    return extraWhere;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.cache.CacheChangeSet.many",
	"Comment": "return the manychange for the given descriptor and property manyproperty.",
	"Method": "ManyChange many(BeanDescriptor<?> desc,String manyProperty){\r\n    ManyKey key = new ManyKey(desc, manyProperty);\r\n    return manyChangeMap.computeIfAbsent(key, ManyChange::new);\r\n}"
}, {
	"Path": "io.ebean.util.AnnotationUtil.findAnnotationsRecursive",
	"Comment": "finds all annotations recusively for a class and its superclasses or interfaces.",
	"Method": "Set<A> findAnnotationsRecursive(Class<?> clazz,Class<A> annotationType){\r\n    if (annotationType == null) {\r\n        return null;\r\n    }\r\n    Set<A> ret = new LinkedHashSet();\r\n    Set<Annotation> visited = new HashSet();\r\n    Set<Class<?>> visitedInterfaces = new HashSet();\r\n    while (clazz != null && !clazz.getName().startsWith(\"java.lang.\")) {\r\n        findMetaAnnotationsRecursive(clazz, annotationType, ret, visited, visitedInterfaces);\r\n        clazz = clazz.getSuperclass();\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.isLob",
	"Comment": "return true if this is mapped to a clob blob longvarchar orlongvarbinary.",
	"Method": "boolean isLob(){\r\n    return lob;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.text.json.WriteJson.isIncludeNull",
	"Comment": "return true if null values should be included in json output.",
	"Method": "boolean isIncludeNull(){\r\n    return include == JsonConfig.Include.ALL;\r\n}"
}, {
	"Path": "cyclops.futurestream.FutureStream.group",
	"Comment": "batch elements into a stream of collections with user defined function",
	"Method": "FutureStream<C> group(Function<Supplier<U>, Supplier<C>> fn){\r\n    final Queue queue = toQueue();\r\n    return fromStream(queue.streamBatchNoTimeout(getSubscription(), fn));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.findMappedBy",
	"Comment": "check that the many property has either an implied mappedby property ormark it as unidirectional.",
	"Method": "boolean findMappedBy(DeployBeanPropertyAssocMany<?> prop){\r\n    Class<?> owningType = prop.getOwningType();\r\n    Set<String> matchSet = new HashSet();\r\n    DeployBeanDescriptor<?> targetDesc = getTargetDescriptor(prop);\r\n    List<DeployBeanPropertyAssocOne<?>> ones = targetDesc.propertiesAssocOne();\r\n    for (DeployBeanPropertyAssocOne<?> possibleMappedBy : ones) {\r\n        Class<?> possibleMappedByType = possibleMappedBy.getTargetType();\r\n        if (possibleMappedByType.equals(owningType)) {\r\n            prop.setMappedBy(possibleMappedBy.getName());\r\n            matchSet.add(possibleMappedBy.getName());\r\n        }\r\n    }\r\n    if (matchSet.isEmpty()) {\r\n        return false;\r\n    }\r\n    if (matchSet.size() == 1) {\r\n        return true;\r\n    }\r\n    if (matchSet.size() == 2) {\r\n        String name = prop.getName();\r\n        String targetType = prop.getTargetType().getName();\r\n        String shortTypeName = targetType.substring(targetType.lastIndexOf('.') + 1);\r\n        int p = name.indexOf(shortTypeName);\r\n        if (p > 1) {\r\n            String searchName = name.substring(0, p).toLowerCase();\r\n            for (String possibleMappedBy : matchSet) {\r\n                String possibleLower = possibleMappedBy.toLowerCase();\r\n                if (possibleLower.contains(searchName)) {\r\n                    prop.setMappedBy(possibleMappedBy);\r\n                    String m = \"Implicitly found mappedBy for \" + targetDesc + \".\" + prop;\r\n                    m += \" by searching for [\" + searchName + \"] against \" + matchSet;\r\n                    logger.debug(m);\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    String msg = \"Error on \" + prop.getFullBeanName() + \" missing mappedBy.\";\r\n    msg += \" There are [\" + matchSet.size() + \"] possible properties in \" + targetDesc;\r\n    msg += \" that this association could be mapped to. Please specify one using \";\r\n    msg += \"the mappedBy attribute on @OneToMany.\";\r\n    throw new PersistenceException(msg);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.peek",
	"Comment": "peek asynchronously at the results in the current stage. current resultsare passed through to the next stage.",
	"Method": "SimpleReactStream<U> peek(Consumer<? super U> consumer){\r\n    if (!isAsync())\r\n        return peekSync(consumer);\r\n    return then((t) -> {\r\n        consumer.accept(t);\r\n        return t;\r\n    });\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQueryPredicates.getPredicateIncludes",
	"Comment": "return the includes required for the where and order by clause.",
	"Method": "Set<String> getPredicateIncludes(){\r\n    return predicateIncludes;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.isDeleteRecurseSkippable",
	"Comment": "return true if delete does not recurse to other beans. that is return trueif there are no assoc one or assoc many beans that cascade delete.",
	"Method": "boolean isDeleteRecurseSkippable(){\r\n    return deleteRecurseSkippable;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.addMappingLocation",
	"Comment": "add a mapping location to search for xml mapping via class path search.",
	"Method": "void addMappingLocation(String mappingLocation){\r\n    if (mappingLocations == null) {\r\n        mappingLocations = new ArrayList();\r\n    }\r\n    mappingLocations.add(mappingLocation);\r\n}"
}, {
	"Path": "org.dataalgorithms.chapB04.rankproduct.sparkwithlambda.SparkRankProductUsingCombineByKey.computeRankedProductsUsingCombineByKey",
	"Comment": "where n is the number of elements for computing the rankedproduct",
	"Method": "JavaPairRDD<String, Tuple2<Double, Integer>> computeRankedProductsUsingCombineByKey(JavaSparkContext context,JavaPairRDD<String, Long>[] ranks){\r\n    JavaPairRDD<String, Long> unionRDD = context.union(ranks);\r\n    Function<Long, RankProduct> createCombiner = (Long x) -> new RankProduct(x, 1);\r\n    Function2<RankProduct, Long, RankProduct> addAndCount = (RankProduct a, Long x) -> {\r\n        a.product *= x;\r\n        a.count += 1;\r\n        return a;\r\n    };\r\n    Function2<RankProduct, RankProduct, RankProduct> mergeCombiners = (RankProduct a, RankProduct b) -> {\r\n        a.product *= b.product;\r\n        a.count += b.count;\r\n        return a;\r\n    };\r\n    JavaPairRDD<String, RankProduct> combinedByGeneRDD = unionRDD.combineByKey(createCombiner, addAndCount, mergeCombiners);\r\n    JavaPairRDD<String, Tuple2<Double, Integer>> rankedProducts = combinedByGeneRDD.mapValues((RankProduct value) -> {\r\n        double theRankedProduct = value.rank();\r\n        return new Tuple2<Double, Integer>(theRankedProduct, value.count);\r\n    });\r\n    return rankedProducts;\r\n}"
}, {
	"Path": "com.oath.cyclops.util.ExceptionSoftener.throwOrHandle",
	"Comment": "throw the exception as upwards if the predicate holds, otherwise pass to the handler",
	"Method": "void throwOrHandle(X e,Predicate<X> p,Consumer<X> handler){\r\n    if (p.test(e))\r\n        throw ExceptionSoftener.<RuntimeException>uncheck(e);\r\n    else\r\n        handler.accept(e);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanProperty.setGeneratedProperty",
	"Comment": "set the generatedvalue. used to generate update timestamp etc.",
	"Method": "void setGeneratedProperty(GeneratedProperty generatedValue){\r\n    this.generatedProperty = generatedValue;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.DefaultPersister.deleteRequest",
	"Comment": "execute the delete request support a second delete request for live and draft permanent delete.a common transaction is used across both requests.",
	"Method": "int deleteRequest(PersistRequestBean<?> req,int deleteRequest,PersistRequestBean<?> req,PersistRequestBean<?> draftReq){\r\n    if (req.isRegisteredForDeleteBean()) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"skipping delete on alreadyRegistered \" + req.getBean());\r\n        }\r\n        return 0;\r\n    }\r\n    try {\r\n        req.initTransIfRequiredWithBatchCascade();\r\n        int rows = delete(req);\r\n        if (draftReq != null) {\r\n            draftReq.setTrans(req.getTransaction());\r\n            rows = delete(draftReq);\r\n        }\r\n        req.commitTransIfRequired();\r\n        req.flushBatchOnCascade();\r\n        return rows;\r\n    } catch (RuntimeException ex) {\r\n        req.rollbackTransIfRequired();\r\n        throw ex;\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.isDbOffline",
	"Comment": "return true if the ebeanserver instance should be created in offline mode.",
	"Method": "boolean isDbOffline(){\r\n    return dbOffline;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQuery.getManyProperty",
	"Comment": "return the property that is associated with the many. there can only be oneper sqlselect. this can be null.",
	"Method": "STreePropertyAssocMany getManyProperty(){\r\n    return manyProperty;\r\n}"
}, {
	"Path": "cyclops.control.LazyEither5.traverse",
	"Comment": "traverse a collection of either3 producing an either4 with a seq, applying the transformation function to everyelement in the list",
	"Method": "LazyEither5<L1, L2, L3, L4, ReactiveSeq<R>> traverse(Function<? super T, ? extends R> fn,ReactiveSeq<LazyEither5<L1, L2, L3, L4, T>> stream,LazyEither5<LT1, LT2, LT3, LT4, ReactiveSeq<R>> traverse,Iterable<LazyEither5<LT1, LT2, LT3, LT4, PT>> xors,Function<? super PT, ? extends R> fn){\r\n    return sequence(xors).map(l -> l.map(fn));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.DefaultOrmUpdate.isNotifyCache",
	"Comment": "return true if the cache should be notified so that invalidatesappropriate objects.",
	"Method": "boolean isNotifyCache(){\r\n    return notifyCache;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.getParentBean",
	"Comment": "return the parent bean for cascading save with unidirectional relationship.",
	"Method": "Object getParentBean(){\r\n    return parentBean;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DatabasePlatform.translate",
	"Comment": "translate the sqlexception into a specific persistence exception if possible.",
	"Method": "PersistenceException translate(String message,SQLException e){\r\n    return exceptionTranslator.translate(message, e);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.readTableToDescriptor",
	"Comment": "build a map of table names to beandescriptors.this is generally used to maintain caches from table names.",
	"Method": "void readTableToDescriptor(){\r\n    for (BeanDescriptor<?> desc : descMap.values()) {\r\n        String baseTable = desc.getBaseTable();\r\n        if (baseTable != null) {\r\n            baseTable = baseTable.toLowerCase();\r\n            List<BeanDescriptor<?>> list = tableToDescMap.computeIfAbsent(baseTable, k -> new ArrayList(1));\r\n            list.add(desc);\r\n        }\r\n        if (desc.getEntityType() == EntityType.VIEW && desc.isQueryCaching()) {\r\n            String[] dependentTables = desc.getDependentTables();\r\n            if (dependentTables != null && dependentTables.length > 0) {\r\n                for (String depTable : dependentTables) {\r\n                    depTable = depTable.toLowerCase();\r\n                    List<BeanDescriptor<?>> list = tableToViewDescMap.computeIfAbsent(depTable, k -> new ArrayList(1));\r\n                    list.add(desc);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebean.cache.QueryCacheEntry.getTimestamp",
	"Comment": "return the timestamp used to check for modifications on the dependent tables.",
	"Method": "long getTimestamp(){\r\n    return timestamp;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQuery.updateExecutionStatisticsIterator",
	"Comment": "update execution stats but skip slow query check as expected large query.",
	"Method": "void updateExecutionStatisticsIterator(){\r\n    updateStatistics();\r\n}"
}, {
	"Path": "io.ebean.text.json.JsonReadOptions.setPersistenceContext",
	"Comment": "set the persistence context to use when building the object graph from the json.",
	"Method": "JsonReadOptions setPersistenceContext(PersistenceContext persistenceContext){\r\n    this.persistenceContext = persistenceContext;\r\n    return this;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorCacheHelp.persistTableIUD",
	"Comment": "invalidate parts of cache due to sqlupdate or external modification etc.",
	"Method": "void persistTableIUD(TableIUD tableIUD,CacheChangeSet changeSet){\r\n    if (invalidateQueryCache) {\r\n        changeSet.addInvalidate(desc);\r\n        return;\r\n    }\r\n    if (noCaching) {\r\n        return;\r\n    }\r\n    changeSet.addInvalidate(desc);\r\n    if (tableIUD.isUpdateOrDelete()) {\r\n        changeSet.addClearBean(desc);\r\n    }\r\n    changeSet.addClearQuery(desc);\r\n    for (BeanPropertyAssocOne<?> imported : propertiesOneImported) {\r\n        imported.cacheClear(changeSet);\r\n    }\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.EagerFutureStreamFunctions.combineLatest",
	"Comment": "zip two streams into one. uses the latest values from each rather than waiting for both",
	"Method": "ReactiveSeq<Tuple2<T1, T2>> combineLatest(SimpleReactStream<T1> left,SimpleReactStream<T2> right,ReactiveSeq<R> combineLatest,SimpleReactStream<T1> left,SimpleReactStream<T2> right,BiFunction<T1, T2, R> zipper){\r\n    final Queue q = left.then(it -> new Val(Val.Pos.left, it)).merge(right.then(it -> new Val(Val.Pos.right, it))).toQueue();\r\n    final Iterator<Val> it = q.stream(left.getSubscription()).iterator();\r\n    class Zip implements Iterator<R> {\r\n        T1 lastLeft = null;\r\n        T2 lastRight = null;\r\n        @Override\r\n        public boolean hasNext() {\r\n            return it.hasNext();\r\n        }\r\n        @Override\r\n        public R next() {\r\n            final Val v = it.next();\r\n            if (v.pos == Val.Pos.left)\r\n                lastLeft = (T1) v.val;\r\n            else\r\n                lastRight = (T2) v.val;\r\n            return zipper.apply(lastLeft, lastRight);\r\n        }\r\n    }\r\n    return ReactiveSeq.fromIterator(new Zip());\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.EagerFutureStreamFunctions.combineLatest",
	"Comment": "zip two streams into one. uses the latest values from each rather than waiting for both",
	"Method": "ReactiveSeq<Tuple2<T1, T2>> combineLatest(SimpleReactStream<T1> left,SimpleReactStream<T2> right,ReactiveSeq<R> combineLatest,SimpleReactStream<T1> left,SimpleReactStream<T2> right,BiFunction<T1, T2, R> zipper){\r\n    return it.hasNext();\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.EagerFutureStreamFunctions.combineLatest",
	"Comment": "zip two streams into one. uses the latest values from each rather than waiting for both",
	"Method": "ReactiveSeq<Tuple2<T1, T2>> combineLatest(SimpleReactStream<T1> left,SimpleReactStream<T2> right,ReactiveSeq<R> combineLatest,SimpleReactStream<T1> left,SimpleReactStream<T2> right,BiFunction<T1, T2, R> zipper){\r\n    final Val v = it.next();\r\n    if (v.pos == Val.Pos.left)\r\n        lastLeft = (T1) v.val;\r\n    else\r\n        lastRight = (T2) v.val;\r\n    return zipper.apply(lastLeft, lastRight);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.ModelDiff.getMigration",
	"Comment": "return the diff as a migration potentially containingan apply changeset and a drop changeset.",
	"Method": "Migration getMigration(){\r\n    Migration migration = new Migration();\r\n    if (!applyChanges.isEmpty()) {\r\n        migration.getChangeSet().add(getApplyChangeSet());\r\n    }\r\n    if (!dropChanges.isEmpty()) {\r\n        migration.getChangeSet().add(getDropChangeSet());\r\n    }\r\n    return migration;\r\n}"
}, {
	"Path": "io.ebean.config.DocStoreConfig.isGenerateMapping",
	"Comment": "return true if ebean should generate mapping files on server startup.",
	"Method": "boolean isGenerateMapping(){\r\n    String systemValue = System.getProperty(\"ebean.docstore.generateMapping\");\r\n    if (systemValue != null) {\r\n        return Boolean.parseBoolean(systemValue);\r\n    }\r\n    return generateMapping;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.OrmQueryRequest.isFindIterate",
	"Comment": "return true if this is a findeach, finditerate type query where we expect many results.",
	"Method": "boolean isFindIterate(){\r\n    return query.getType() == Type.ITERATE;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.SequenceIdGenerator.nextId",
	"Comment": "return the next id.if a transaction has been passed in use the connection from it.",
	"Method": "Object nextId(Transaction t){\r\n    synchronized (monitor) {\r\n        int size = idList.size();\r\n        if (size > 0) {\r\n            maybeLoadMoreInBackground(size);\r\n        } else {\r\n            loadMore(allocationSize);\r\n        }\r\n        return idList.remove(0);\r\n    }\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.MapX.toListX",
	"Comment": "convert this mapx to a listx via the provided transformation function",
	"Method": "ListX<T> toListX(Function<? super Tuple2<? super K, ? super V>, ? extends T> fn){\r\n    return ListX.narrow(stream().map(fn).to(ReactiveConvertableSequence::converter).listX());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.TransactionManager.remoteTransactionEvent",
	"Comment": "notify local beanpersistlisteners etc of events from another server in the cluster.",
	"Method": "void remoteTransactionEvent(RemoteTransactionEvent remoteEvent){\r\n    if (clusterLogger.isDebugEnabled()) {\r\n        clusterLogger.debug(\"processing {}\", remoteEvent);\r\n    }\r\n    CacheChangeSet changeSet = new CacheChangeSet(clockNowMillis());\r\n    RemoteTableMod tableMod = remoteEvent.getRemoteTableMod();\r\n    if (tableMod != null) {\r\n        changeSet.addInvalidate(tableMod.getTables());\r\n    }\r\n    List<TableIUD> tableIUDList = remoteEvent.getTableIUDList();\r\n    if (tableIUDList != null) {\r\n        for (TableIUD tableIUD : tableIUDList) {\r\n            beanDescriptorManager.cacheNotify(tableIUD, changeSet);\r\n        }\r\n    }\r\n    List<BeanPersistIds> beanPersistList = remoteEvent.getBeanPersistList();\r\n    if (beanPersistList != null) {\r\n        for (BeanPersistIds persistIds : beanPersistList) {\r\n            persistIds.notifyCache(changeSet);\r\n        }\r\n    }\r\n    changeSet.apply();\r\n}"
}, {
	"Path": "cyclops.control.Future.narrowK",
	"Comment": "convert the raw higher kinded type forfuturetype types into the futuretype type definition class",
	"Method": "Future<T> narrowK(Higher<future, T> future){\r\n    return (Future<T>) future;\r\n}"
}, {
	"Path": "org.tests.cache.TestCacheDelete.testCacheDeleteOneToMany",
	"Comment": "when deleting a cached entity all entities with a referenced onetomany relation must also be invalidated!",
	"Method": "void testCacheDeleteOneToMany(){\r\n    OCachedBeanChild child = new OCachedBeanChild();\r\n    OCachedBeanChild child2 = new OCachedBeanChild();\r\n    OCachedBean parentBean = new OCachedBean();\r\n    parentBean.getChildren().add(child);\r\n    parentBean.getChildren().add(child2);\r\n    Ebean.save(parentBean);\r\n    assertEquals(2, Ebean.find(OCachedBean.class, parentBean.getId()).getChildren().size());\r\n    Ebean.find(OCachedBeanChild.class, child.getId());\r\n    child2 = Ebean.find(OCachedBeanChild.class, child2.getId());\r\n    parentBean = Ebean.find(OCachedBean.class, parentBean.getId());\r\n    Ebean.delete(child2);\r\n    awaitL2Cache();\r\n    OCachedBean beanFromCache = Ebean.find(OCachedBean.class, parentBean.getId());\r\n    assertEquals(1, beanFromCache.getChildren().size());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.createDeployBeanInfo",
	"Comment": "read the initial deployment information for a given bean type.",
	"Method": "DeployBeanInfo<T> createDeployBeanInfo(Class<T> beanClass){\r\n    DeployBeanDescriptor<T> desc = new DeployBeanDescriptor(this, beanClass, serverConfig);\r\n    desc.setUpdateChangesOnly(updateChangesOnly);\r\n    beanLifecycleAdapterFactory.addLifecycleMethods(desc);\r\n    setBeanControllerFinderListener(desc);\r\n    deplyInherit.process(desc);\r\n    desc.checkInheritanceMapping();\r\n    createProperties.createProperties(desc);\r\n    DeployBeanInfo<T> info = new DeployBeanInfo(deployUtil, desc);\r\n    readAnnotations.readInitial(info);\r\n    return info;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.isTransactionRollbackOnChecked",
	"Comment": "return true if transactions should rollback on checked exceptions.",
	"Method": "boolean isTransactionRollbackOnChecked(){\r\n    return transactionRollbackOnChecked;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.BaseTableDdl.regenerateHistoryTriggers",
	"Comment": "register the base table that we need to regenerate the history triggers on.",
	"Method": "void regenerateHistoryTriggers(String baseTableName,HistoryTableUpdate.Change change,String column){\r\n    HistoryTableUpdate update = regenerateHistoryTriggers.computeIfAbsent(baseTableName, HistoryTableUpdate::new);\r\n    update.add(change, column);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanProperty.setLocalEncrypted",
	"Comment": "set to true when the property is encrypted in java rather than in the db.",
	"Method": "void setLocalEncrypted(){\r\n    this.localEncrypted = true;\r\n}"
}, {
	"Path": "io.ebeaninternal.json.DJsonService.parseList",
	"Comment": "parse the json returning as a list taking into account the current token.",
	"Method": "List<T> parseList(String json,boolean modifyAware,List<Object> parseList,String json,List<Object> parseList,Reader reader,List<Object> parseList,JsonParser parser,List<T> parseList,JsonParser parser,JsonToken currentToken){\r\n    return (List<T>) EJsonReader.parse(parser, currentToken, false);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.docStoreAdapter",
	"Comment": "return doc store adapter for internal use for processing persist requests.",
	"Method": "DocStoreBeanAdapter<T> docStoreAdapter(){\r\n    return docStoreAdapter;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.cacheNotify",
	"Comment": "for sql based modifications we need to invalidate appropriate parts of the cache.",
	"Method": "void cacheNotify(TransactionEventTable.TableIUD tableIUD,CacheChangeSet changeSet){\r\n    String tableName = tableIUD.getTableName().toLowerCase();\r\n    List<BeanDescriptor<?>> normalBeanTypes = tableToDescMap.get(tableName);\r\n    if (normalBeanTypes != null) {\r\n        for (BeanDescriptor<?> normalBeanType : normalBeanTypes) {\r\n            normalBeanType.cachePersistTableIUD(tableIUD, changeSet);\r\n        }\r\n    }\r\n    List<BeanDescriptor<?>> viewBeans = tableToViewDescMap.get(tableName);\r\n    if (viewBeans != null) {\r\n        for (BeanDescriptor<?> viewBean : viewBeans) {\r\n            viewBean.cachePersistTableIUD(tableIUD, changeSet);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebean.cache.ServerCacheStatistics.getMaxSize",
	"Comment": "return the maximum size of the cache.can be used in conjunction with the size to determine if the cache use isbeing potentially limited by its maximum size.",
	"Method": "int getMaxSize(){\r\n    return maxSize;\r\n}"
}, {
	"Path": "io.ebean.event.BeanPersistAdapter.preInsert",
	"Comment": "returns true indicating normal processing should continue.",
	"Method": "boolean preInsert(BeanPersistRequest<?> request){\r\n    return true;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.h2.H2Platform.createSequenceIdGenerator",
	"Comment": "return a h2 specific sequence idgenerator that supports batch fetchingsequence values.",
	"Method": "PlatformIdGenerator createSequenceIdGenerator(BackgroundExecutor be,DataSource ds,int stepSize,String seqName){\r\n    return new H2SequenceIdGenerator(be, ds, seqName, sequenceBatchSize);\r\n}"
}, {
	"Path": "chapter03linkedlists.DoublyLinkedList.removeTail",
	"Comment": "remove the tail value from the list. if the list is empty, do nothing.",
	"Method": "int removeTail(){\r\n    if (length == 0)\r\n        return Integer.MIN_VALUE;\r\n    DLLNode save = tail.getPrev();\r\n    tail.setPrev(save.getPrev());\r\n    save.getPrev().setNext(tail);\r\n    length -= 1;\r\n    return save.getData();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultServer.createCallStack",
	"Comment": "create a callstack object.this trims off the avaje ebean part of the stack trace so that the firstelement in the callstack should be application code.",
	"Method": "CallStack createCallStack(){\r\n    return callStackFactory.createCallStack();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.FilterExprPath.getPath",
	"Comment": "return the path. this is a prefix used in the filtermany expressions.",
	"Method": "String getPath(){\r\n    return path;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.bootup.BootupClasses.add",
	"Comment": "adds the list toadd to instances and removes any pendingcandiate, to prevent duplicate instantiiation.",
	"Method": "void add(List<T> toAdd,List<T> instances,List<Class<? extends T>> candidates){\r\n    if (toAdd != null) {\r\n        for (T obj : toAdd) {\r\n            instances.add(obj);\r\n            candidates.remove(obj.getClass());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.AutoTuneConfig.setQueryTuningFile",
	"Comment": "set the name of the file that holds the query tuning information.",
	"Method": "void setQueryTuningFile(String queryTuningFile){\r\n    this.queryTuningFile = queryTuningFile;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getClasses",
	"Comment": "return the classes registered for this server. typically this includesentities and perhaps listeners.",
	"Method": "List<Class<?>> getClasses(List<Class<?>> getClasses,PropertiesWrapper properties){\r\n    String classNames = properties.get(\"classes\", null);\r\n    if (classNames == null) {\r\n        return classes;\r\n    }\r\n    List<Class<?>> classes = new ArrayList();\r\n    String[] split = StringHelper.splitNames(classNames);\r\n    for (String cn : split) {\r\n        if (!\"class\".equalsIgnoreCase(cn)) {\r\n            try {\r\n                classes.add(Class.forName(cn));\r\n            } catch (ClassNotFoundException e) {\r\n                String msg = \"Error registering class [\" + cn + \"] from [\" + classNames + \"]\";\r\n                throw new RuntimeException(msg, e);\r\n            }\r\n        }\r\n    }\r\n    return classes;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.parse.AnnotationParser.setCascadeTypes",
	"Comment": "helper method to set cascade types to the cascadeinfo on beanproperty.",
	"Method": "void setCascadeTypes(CascadeType[] cascadeTypes,BeanCascadeInfo cascadeInfo){\r\n    if (cascadeTypes != null && cascadeTypes.length > 0) {\r\n        cascadeInfo.setTypes(cascadeTypes);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.InternalConfiguration.createTransactionManager",
	"Comment": "create the transactionmanager taking into account autocommit mode.",
	"Method": "TransactionManager createTransactionManager(DocStoreUpdateProcessor indexUpdateProcessor){\r\n    TransactionScopeManager scopeManager = createTransactionScopeManager();\r\n    boolean notifyL2CacheInForeground = cacheManager.isLocalL2Caching() || serverConfig.isNotifyL2CacheInForeground();\r\n    TransactionManagerOptions options = new TransactionManagerOptions(notifyL2CacheInForeground, serverConfig, scopeManager, clusterManager, backgroundExecutor, indexUpdateProcessor, beanDescriptorManager, dataSource(), profileHandler(), logManager, tableModState, cacheNotify, clockService);\r\n    if (serverConfig.isExplicitTransactionBeginMode()) {\r\n        return new ExplicitTransactionManager(options);\r\n    }\r\n    if (isAutoCommitMode()) {\r\n        return new AutoCommitTransactionManager(options);\r\n    }\r\n    if (serverConfig.isDocStoreOnly()) {\r\n        return new DocStoreTransactionManager(options);\r\n    }\r\n    return new TransactionManager(options);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.type.DefaultTypeFactory.createUtilDate",
	"Comment": "create a scalartype for java.util.date explicitly specifying the type tomap to.",
	"Method": "ScalarType<java.util.Date> createUtilDate(JsonConfig.DateTime mode,ScalarType<java.util.Date> createUtilDate,JsonConfig.DateTime mode,int utilDateType){\r\n    switch(utilDateType) {\r\n        case Types.DATE:\r\n            return new ScalarTypeUtilDate.DateType();\r\n        case Types.TIMESTAMP:\r\n            return new ScalarTypeUtilDate.TimestampType(mode);\r\n        default:\r\n            throw new RuntimeException(\"Invalid type \" + utilDateType);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.el.ElPropertyChain.containsManySince",
	"Comment": "return true if there is a many property from sinceproperty tothe end of this chain.",
	"Method": "boolean containsManySince(String sinceProperty){\r\n    if (sinceProperty == null) {\r\n        return containsMany;\r\n    }\r\n    if (!expression.startsWith(sinceProperty)) {\r\n        return containsMany;\r\n    }\r\n    int i = 1 + SplitName.count(sinceProperty);\r\n    for (; i < chain.length; i++) {\r\n        if (chain[i].getBeanProperty().containsMany()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.oath.cyclops.react.threads.ReactPool.elasticPool",
	"Comment": "if all reactors are in use calling react will create a new reactor to handle the extra demand.generate an elastic pool of reactors",
	"Method": "ReactPool<REACTOR> elasticPool(Supplier<REACTOR> supplier){\r\n    return new ReactPool(supplier);\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.initialisedMany",
	"Comment": "called when a beancollection is initialised automatically.",
	"Method": "void initialisedMany(int propertyIndex){\r\n    flags[propertyIndex] |= FLAG_LOADED_PROP;\r\n}"
}, {
	"Path": "org.tests.basic.delete.TestDeleteCascadeByQuery.init",
	"Comment": "init each test. delete all existing beans. then create otouser, add otouseroptional and save.",
	"Method": "void init(){\r\n    Ebean.deleteAll(userQuery.findList());\r\n    Ebean.deleteAll(userOptionalQuery.findList());\r\n    userOptional = new OtoUserOptional();\r\n    Ebean.save(userOptional);\r\n    testUser = new OtoUser();\r\n    testUser.setOptional(userOptional);\r\n    Ebean.save(testUser);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentQueueX.fill",
	"Comment": "generate a persistentqueuex from the provided value up to the provided limit number of times",
	"Method": "PersistentQueueX<T> fill(long limit,T s){\r\n    return ReactiveSeq.fill(s).limit(limit).to(ReactiveConvertableSequence::converter).persistentQueueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.util.BindParamsParser.parseSql",
	"Comment": "parse the sql changed named parameters to positioned parameters if required.the sql is used when named parameters are used.this is used in most cases of named parameters. the case it is not used for isnamed parameters in a having clause. in this case some of the named parameterscould be for a where clause and some for the having clause.",
	"Method": "String parseSql(){\r\n    if (params.isSameBindHash()) {\r\n        String preparedSql = params.getPreparedSql();\r\n        if (preparedSql != null && !preparedSql.isEmpty()) {\r\n            return preparedSql;\r\n        }\r\n    }\r\n    String preparedSql;\r\n    if (params.requiresNamedParamsPrepare()) {\r\n        OrderedList orderedList = params.createOrderedList();\r\n        parseNamedParams(orderedList);\r\n        preparedSql = orderedList.getPreparedSql();\r\n    } else {\r\n        preparedSql = sql;\r\n    }\r\n    params.setPreparedSql(preparedSql);\r\n    return preparedSql;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.type.DefaultTypeManager.createEnumScalarType",
	"Comment": "create a scalartype for an enum that has additional mapping.the reason for this is that often in a db there will be short codes usedsuch as a,i,n rather than the active, inactive, new. so there really needsto be a mapping from the nicely named enumeration values to the typicallymuch shorter codes used in the db.",
	"Method": "ScalarType<?> createEnumScalarType(Class<? extends Enum<?>> enumType,EnumType type,ScalarTypeEnum<?> createEnumScalarType,Class enumType,Map<String, String> nameValueMap,boolean integerType,int dbColumnLength){\r\n    EnumToDbValueMap<?> beanDbMap = EnumToDbValueMap.create(integerType);\r\n    int maxValueLen = 0;\r\n    for (Map.Entry<String, String> entry : nameValueMap.entrySet()) {\r\n        String name = entry.getKey();\r\n        String value = entry.getValue();\r\n        maxValueLen = Math.max(maxValueLen, value.length());\r\n        Object enumValue = Enum.valueOf(enumType, name.trim());\r\n        beanDbMap.add(enumValue, value, name.trim());\r\n    }\r\n    if (dbColumnLength == 0 && !integerType) {\r\n        dbColumnLength = maxValueLen;\r\n    }\r\n    return new ScalarTypeEnumWithMapping(beanDbMap, enumType, dbColumnLength);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.autotune.service.AutoTuneDiffCollection.createOrigin",
	"Comment": "create the xml origin bean for the given entry and objectgraphorigin.",
	"Method": "Origin createOrigin(AutoTuneCollection.Entry entry,ObjectGraphOrigin point,String query){\r\n    Origin origin = new Origin();\r\n    origin.setKey(point.getKey());\r\n    origin.setBeanType(point.getBeanType());\r\n    origin.setDetail(entry.getDetail().toString());\r\n    origin.setCallStack(point.getCallStack().description(\"\\n\"));\r\n    origin.setOriginal(query);\r\n    if (updateTuning) {\r\n        queryTuner.put(origin);\r\n    }\r\n    return origin;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DatabasePlatform.tablePartitionInit",
	"Comment": "return the sql to create an initial partition for the given table.",
	"Method": "String tablePartitionInit(String tableName,PartitionMode mode,String property,String singlePrimaryKey){\r\n    return null;\r\n}"
}, {
	"Path": "cyclops.futurestream.LazyReact.constructFutures",
	"Comment": "construct a futurestream from a stream of completablefutures",
	"Method": "FutureStream<U> constructFutures(Stream<CompletableFuture<U>> s){\r\n    final LazyReact toUse = withStreamOfFutures(true);\r\n    return toUse.construct((Stream<U>) s);\r\n}"
}, {
	"Path": "io.ebean.BaseTestCase.isSqlServer",
	"Comment": "ms sql server does not allow setting explicit values on identity columnsso tests that do this need to be skipped for sql server.",
	"Method": "boolean isSqlServer(){\r\n    return Platform.SQLSERVER17 == platform();\r\n}"
}, {
	"Path": "cyclops.monads.transformers.EvalT.of",
	"Comment": "construct an evalwt from an anym that wraps a monad containingevalws",
	"Method": "EvalT<W, A> of(AnyM<W, Eval<A>> monads){\r\n    return new EvalT(monads);\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.h2.H2DbEncrypt.isBindEncryptDataFirst",
	"Comment": "for h2 encrypt function returns false binding the key before the data.",
	"Method": "boolean isBindEncryptDataFirst(){\r\n    return false;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getPackages",
	"Comment": "return packages to search for entities via class path search.this is only used if classes have not been explicitly specified.",
	"Method": "List<String> getPackages(){\r\n    return packages;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.BatchedPstmtHolder.execute",
	"Comment": "execute one of the batched statements returning the row counts.",
	"Method": "int[] execute(String key,boolean getGeneratedKeys){\r\n    BatchedPstmt batchedPstmt = stmtMap.remove(key);\r\n    if (batchedPstmt == null) {\r\n        throw new PersistenceException(\"No batched statement found for key \" + key);\r\n    }\r\n    batchedPstmt.executeBatch(getGeneratedKeys);\r\n    return batchedPstmt.getResults();\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.QueueX.fill",
	"Comment": "generate a queuex from the provided value up to the provided limit number of times",
	"Method": "QueueX<T> fill(long limit,T s){\r\n    return ReactiveSeq.fill(s).limit(limit).to(ReactiveConvertableSequence::converter).queueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.propertiesAll",
	"Comment": "return a collection of all beanproperty. this includes transient properties.",
	"Method": "Collection<BeanProperty> propertiesAll(){\r\n    return propMap.values();\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.MapX.toSetX",
	"Comment": "convert this mapx to a setx via the provided transformation function",
	"Method": "SetX<T> toSetX(Function<? super Tuple2<? super K, ? super V>, ? extends T> fn){\r\n    return SetX.narrow(stream().map(fn).to(ReactiveConvertableSequence::converter).setX());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.JdbcTransaction.isBatchThisRequest",
	"Comment": "return true if this request should be batched. returning false means thatthis request should be executed immediately.",
	"Method": "boolean isBatchThisRequest(){\r\n    if (!batchOnCascadeSet && !explicit && depth <= 0) {\r\n        return false;\r\n    }\r\n    return batchMode;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanPropertyAssoc.setExtraWhere",
	"Comment": "set a literal expression to add to the query that lazy loads thecollection.",
	"Method": "void setExtraWhere(String extraWhere){\r\n    this.extraWhere = extraWhere;\r\n}"
}, {
	"Path": "io.ebean.config.AutoTuneConfig.isQueryTuningAddVersion",
	"Comment": "return true if the version property should be added when the query istuned.if this is false then the version property will be added when profilingdetects that the bean is possibly going to be modified.",
	"Method": "boolean isQueryTuningAddVersion(){\r\n    return queryTuningAddVersion;\r\n}"
}, {
	"Path": "io.ebeaninternal.extraddl.model.ExtraDdlXmlReader.buildExtra",
	"Comment": "return the combined extra ddl that should be run given the platform name.",
	"Method": "String buildExtra(String platformName,boolean drops,String buildExtra,String platformName,boolean drops,ExtraDdl read){\r\n    if (read == null) {\r\n        return null;\r\n    }\r\n    StringBuilder sb = new StringBuilder(300);\r\n    for (DdlScript script : read.getDdlScript()) {\r\n        if (script.isDrop() == drops && matchPlatform(platformName, script.getPlatforms())) {\r\n            logger.debug(\"include script {}\", script.getName());\r\n            String value = script.getValue();\r\n            sb.append(value);\r\n            if (value.lastIndexOf(';') == -1) {\r\n                sb.append(\";\");\r\n            }\r\n            sb.append(\"\\n\");\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "io.ebean.EbeanServerFactory.createWithContextClassLoader",
	"Comment": "create using the serverconfig additionally specifying a classloader to use as the context class loader.",
	"Method": "EbeanServer createWithContextClassLoader(ServerConfig config,ClassLoader classLoader){\r\n    ClassLoader currentContextLoader = Thread.currentThread().getContextClassLoader();\r\n    Thread.currentThread().setContextClassLoader(classLoader);\r\n    try {\r\n        return EbeanServerFactory.create(config);\r\n    } finally {\r\n        Thread.currentThread().setContextClassLoader(currentContextLoader);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.platform.MultiValueBind.isSupported",
	"Comment": "defaults to not supported and using a bind value per element.",
	"Method": "boolean isSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.Value.toTry",
	"Comment": "convert this value to a try that will catch the provided exception types on subsequent operations",
	"Method": "Try<T, X> toTry(X throwable,Try<T, Throwable> toTry,Try<T, X> toTry,Class<X> classes){\r\n    return Try.fromPublisher(this, classes);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.TransactionManager.getActiveScoped",
	"Comment": "return the current active transaction as a scoped transaction.",
	"Method": "ScopedTransaction getActiveScoped(){\r\n    return (ScopedTransaction) scopeManager.getActive();\r\n}"
}, {
	"Path": "cyclops.companion.Streams.toConcurrentLazyCollection",
	"Comment": "lazily constructs a collection from specified stream. collections iterator may be safely usedconcurrently by multiple threads.",
	"Method": "Collection<A> toConcurrentLazyCollection(Stream<A> stream,Collection<A> toConcurrentLazyCollection,Iterator<A> iterator){\r\n    return SeqUtils.toConcurrentLazyCollection(iterator);\r\n}"
}, {
	"Path": "io.ebean.config.DbConstraintNaming.foreignKeyIndexName",
	"Comment": "return the index name associated with a foreign key constraint given a single column foreign key.",
	"Method": "String foreignKeyIndexName(String tableName,String[] columns,String foreignKeyIndexName,String tableName,String column){\r\n    String colPart = normaliseTable(column);\r\n    return fkIndexPrefix + normaliseTable(tableName) + fkIndexMiddle + colPart + fkIndexSuffix;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.isUpdateAllPropertiesInBatch",
	"Comment": "returns true if updates in jdbc batch default to include all properties by default.",
	"Method": "boolean isUpdateAllPropertiesInBatch(){\r\n    return updateAllPropertiesInBatch;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.BeanRequest.getEbeanServer",
	"Comment": "return the server processing the request. made available forbeancontroller and beanfinder.",
	"Method": "EbeanServer getEbeanServer(){\r\n    return ebeanServer;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.contextGetWithOption",
	"Comment": "get the bean from the persistence context with delete check option.",
	"Method": "PersistenceContext.WithOption contextGetWithOption(PersistenceContext pc,Object id){\r\n    return pc.getWithOption(rootBeanType, id);\r\n}"
}, {
	"Path": "cyclops.function.Memoize.memoizeSupplierAsync",
	"Comment": "memoize a supplier and update the cached values asynchronously using the provided scheduled executor servicedoes not support null keys",
	"Method": "Function0<R> memoizeSupplierAsync(Supplier<R> fn,ScheduledExecutorService ex,long updateRateInMillis,Function0<R> memoizeSupplierAsync,Supplier<R> fn,ScheduledExecutorService ex,String cron){\r\n    return () -> Memoize.memoizeFunctionAsync(a -> fn.get(), ex, cron).apply(\"k\");\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.isDiscriminator",
	"Comment": "return true if this property maps to the inheritance discriminator column.",
	"Method": "boolean isDiscriminator(){\r\n    return discriminator;\r\n}"
}, {
	"Path": "cyclops.monads.transformers.ReaderT.of",
	"Comment": "construct an futuret from an anym that wraps a monad containingfutures",
	"Method": "ReaderT<W, T, R> of(AnyM<W, Reader<T, R>> monads){\r\n    return new ReaderT(monads);\r\n}"
}, {
	"Path": "io.ebean.EbeanServerFactory.shutdown",
	"Comment": "shutdown gracefully all ebeanservers cleaning up any resources as required.this is typically invoked via jvm shutdown hook and not explicitly called.",
	"Method": "void shutdown(){\r\n    container.shutdown();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.OrmQueryRequest.rollbackTransIfRequired",
	"Comment": "rollback the transaction if it was created for this request.",
	"Method": "void rollbackTransIfRequired(){\r\n    if (createdTransaction) {\r\n        try {\r\n            transaction.end();\r\n        } catch (Exception e) {\r\n            log.error(\"Error trying to rollback a transaction (after a prior exception thrown)\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.PostCommitProcessing.backgroundNotify",
	"Comment": "in background notify persist listeners, cluster and document store.",
	"Method": "Runnable backgroundNotify(){\r\n    return () -> {\r\n        if (!manager.notifyL2CacheInForeground) {\r\n            processCacheChanges();\r\n        }\r\n        localPersistListenersNotify();\r\n        notifyCluster();\r\n        processDocStoreUpdates();\r\n    };\r\n}"
}, {
	"Path": "io.ebean.text.json.EJson.parseObject",
	"Comment": "parse the json and return as a map taking a jsonparser and a starting token.used when the first token is checked to see if the value is null prior to calling this.",
	"Method": "Map<String, Object> parseObject(String json,boolean modifyAware,Map<String, Object> parseObject,String json,Map<String, Object> parseObject,Reader reader,boolean modifyAware,Map<String, Object> parseObject,Reader reader,Map<String, Object> parseObject,JsonParser parser,Map<String, Object> parseObject,JsonParser parser,JsonToken token){\r\n    return plugin.parseObject(parser, token);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanTable.getBaseTable",
	"Comment": "return the base table for this beantable.this is used to determine the join informationfor associations.",
	"Method": "String getBaseTable(){\r\n    return baseTable;\r\n}"
}, {
	"Path": "cyclops.function.Monoid.of",
	"Comment": "construct a monoid from the supplied identity element and combining function",
	"Method": "Monoid<T> of(T zero,Semigroup<T> group,Monoid<T> of,T zero,Function<T, Function<T, T>> combiner){\r\n    return new Monoid<T>() {\r\n        @Override\r\n        public T zero() {\r\n            return zero;\r\n        }\r\n        @Override\r\n        public T apply(final T t, final T u) {\r\n            return combiner.apply(t).apply(u);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "cyclops.function.Monoid.of",
	"Comment": "construct a monoid from the supplied identity element and combining function",
	"Method": "Monoid<T> of(T zero,Semigroup<T> group,Monoid<T> of,T zero,Function<T, Function<T, T>> combiner){\r\n    return zero;\r\n}"
}, {
	"Path": "cyclops.function.Monoid.of",
	"Comment": "construct a monoid from the supplied identity element and combining function",
	"Method": "Monoid<T> of(T zero,Semigroup<T> group,Monoid<T> of,T zero,Function<T, Function<T, T>> combiner){\r\n    return combiner.apply(t).apply(u);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.DefaultExpressionFactory.exampleLike",
	"Comment": "create the query by example expression specifying more options.",
	"Method": "ExampleExpression exampleLike(Object example,ExampleExpression exampleLike,Object example,boolean caseInsensitive,LikeType likeType){\r\n    return new DefaultExampleExpression(checkEntityBean(example), caseInsensitive, likeType);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.dml.DmlHandler.setIdValue",
	"Comment": "set the id value that was bound. this value is used for logging summarylevel information.",
	"Method": "void setIdValue(Object idValue){\r\n    persistRequest.setBoundId(idValue);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.type.DefaultTypeManager.loadTypesFromProviders",
	"Comment": "load custom scalar types registered via extratypefactory and serviceloader.",
	"Method": "void loadTypesFromProviders(ServerConfig config,Object objectMapper){\r\n    ServiceLoader<ExtraTypeFactory> factories = ServiceLoader.load(ExtraTypeFactory.class);\r\n    Iterator<ExtraTypeFactory> iterator = factories.iterator();\r\n    if (iterator.hasNext()) {\r\n        ExtraTypeFactory plugin = iterator.next();\r\n        List<? extends ScalarType<?>> types = plugin.createTypes(config, objectMapper);\r\n        for (ScalarType<?> type : types) {\r\n            logger.debug(\"adding ScalarType {}\", type.getClass());\r\n            addCustomType(type);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getConstraintNaming",
	"Comment": "return the constraint naming convention used in ddl generation.",
	"Method": "DbConstraintNaming getConstraintNaming(){\r\n    return constraintNaming;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.BaseDdlBuffer.end",
	"Comment": "used to demarcate the end of a series of statements.this should be just whitespace or a sql comment.",
	"Method": "DdlBuffer end(){\r\n    writer.append(\"\\n\");\r\n    return this;\r\n}"
}, {
	"Path": "cyclops.control.Try.mapOrCatch",
	"Comment": "perform a mapping operation that may catch the supplied exception typesthe supplied exception types are only applied during this map operation",
	"Method": "Try<R, X> mapOrCatch(CheckedFunction<? super T, ? extends R, X> fn,Class<? extends X> classes){\r\n    return new Try<R, X>(xor.flatMap(i -> safeApply(i, fn.asFunction(), classes)), this.classes);\r\n}"
}, {
	"Path": "io.ebeaninternal.api.ManyWhereJoins.getFormulaProperties",
	"Comment": "return the formula properties to build the select clause for a findcount query.",
	"Method": "String getFormulaProperties(){\r\n    return formulaProperties.toString();\r\n}"
}, {
	"Path": "cyclops.reactive.ReactiveSeq.of",
	"Comment": "create an efficiently reversable sequence from the provided elements",
	"Method": "ReactiveSeq<T> of(T value,ReactiveSeq<T> of,T elements){\r\n    final ReversingArraySpliterator<T> array = new ReversingArraySpliterator<T>(elements, 0, elements.length, false);\r\n    return Streams.reactiveSeq(array, Optional.ofNullable(array));\r\n}"
}, {
	"Path": "io.ebean.text.json.JsonWriteOptions.getObjectMapper",
	"Comment": "return the jackson object mapper to use.if null the objectmapper from serverconfig will be used.",
	"Method": "Object getObjectMapper(){\r\n    return objectMapper;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.BaseTableDdl.generateEpilog",
	"Comment": "called at the end to generate additional ddl such as regenerate history triggers.",
	"Method": "void generateEpilog(DdlWrite write){\r\n    if (!regenerateHistoryTriggers.isEmpty()) {\r\n        platformDdl.lockTables(write.applyHistoryTrigger(), regenerateHistoryTriggers.keySet());\r\n        for (HistoryTableUpdate update : this.regenerateHistoryTriggers.values()) {\r\n            platformDdl.regenerateHistoryTriggers(write, update);\r\n        }\r\n        platformDdl.unlockTables(write.applyHistoryTrigger(), regenerateHistoryTriggers.keySet());\r\n    }\r\n    platformDdl.generateEpilog(write);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.el.ElPropertyChainBuilder.setEmbedded",
	"Comment": "permits to set whole chain as embedded when the leaf is embedded",
	"Method": "void setEmbedded(boolean embedded){\r\n    this.embedded = embedded;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.readaudit.DefaultReadAuditLogger.auditBean",
	"Comment": "write the bean read event details in json format to the logger.",
	"Method": "void auditBean(ReadEvent beanEvent){\r\n    writeEvent(beanEvent);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setDisableL2Cache",
	"Comment": "set to true to disable l2 caching. typically useful in performance testing.",
	"Method": "void setDisableL2Cache(boolean disableL2Cache){\r\n    this.disableL2Cache = disableL2Cache;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setMappingLocations",
	"Comment": "set mapping locations to search for xml mapping via class path search.this is only used if classes have not been explicitly specified.",
	"Method": "void setMappingLocations(List<String> mappingLocations){\r\n    this.mappingLocations = mappingLocations;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQueryPlanStats.isEmpty",
	"Comment": "return true if there are no statistics collected since the last reset.",
	"Method": "boolean isEmpty(){\r\n    return timedMetric.isEmpty();\r\n}"
}, {
	"Path": "cyclops.monads.transformers.jdk.OptionalT.of",
	"Comment": "construct an optionalwt from an anym that wraps a monad containingoptionalws",
	"Method": "OptionalT<W, A> of(AnyM<W, Optional<A>> monads){\r\n    return new OptionalT(monads);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.ModelContainer.migrationForPendingDrop",
	"Comment": "return the migration for the pending drops for a given version.",
	"Method": "Migration migrationForPendingDrop(String pendingVersion){\r\n    return pendingDrops.migrationForVersion(pendingVersion);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.isDbInsertable",
	"Comment": "return true if this property should be included in an insert.",
	"Method": "boolean isDbInsertable(){\r\n    return dbInsertable;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultServer.start",
	"Comment": "start any services after registering with the clustermanager.",
	"Method": "void start(){\r\n    if (TenantMode.DB != serverConfig.getTenantMode()) {\r\n        serverConfig.runDbMigration(serverConfig.getDataSource());\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.getFullName",
	"Comment": "returns a description of the request. this is typically the bean class name or the base tablefor mapbeans.used to determine common persist requests for queueing and statement batching.",
	"Method": "String getFullName(){\r\n    return beanDescriptor.getFullName();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.cache.DefaultServerCache.runEviction",
	"Comment": "run the eviction based on idle time, time to live and lru last access.",
	"Method": "void runEviction(){\r\n    long trimForMaxSize;\r\n    if (maxSize == 0) {\r\n        trimForMaxSize = 0;\r\n    } else {\r\n        trimForMaxSize = size() - maxSize;\r\n    }\r\n    if (maxIdleSecs == 0 && maxSecsToLive == 0 && trimForMaxSize < 0) {\r\n        return;\r\n    }\r\n    long startNanos = System.nanoTime();\r\n    long trimmedByIdle = 0;\r\n    long trimmedByTTL = 0;\r\n    long trimmedByLRU = 0;\r\n    List<CacheEntry> activeList = new ArrayList(map.size());\r\n    long idleExpireNano = startNanos - TimeUnit.SECONDS.toNanos(maxIdleSecs);\r\n    long ttlExpireNano = startNanos - TimeUnit.SECONDS.toNanos(maxSecsToLive);\r\n    Iterator<CacheEntry> it = map.values().iterator();\r\n    while (it.hasNext()) {\r\n        CacheEntry cacheEntry = it.next();\r\n        if (maxIdleSecs > 0 && idleExpireNano > cacheEntry.getLastAccessTime()) {\r\n            it.remove();\r\n            trimmedByIdle++;\r\n        } else if (maxSecsToLive > 0 && ttlExpireNano > cacheEntry.getCreateTime()) {\r\n            it.remove();\r\n            trimmedByTTL++;\r\n        } else if (trimForMaxSize > 0) {\r\n            activeList.add(cacheEntry);\r\n        }\r\n    }\r\n    if (trimForMaxSize > 0) {\r\n        trimmedByLRU = activeList.size() - maxSize;\r\n        if (trimmedByLRU > 0) {\r\n            activeList.sort(BY_LAST_ACCESS);\r\n            int trimSize = getTrimSize();\r\n            for (int i = trimSize; i < activeList.size(); i++) {\r\n                map.remove(activeList.get(i).getKey());\r\n            }\r\n        }\r\n    }\r\n    long exeNanos = System.nanoTime() - startNanos;\r\n    long exeMicros = TimeUnit.MICROSECONDS.convert(exeNanos, TimeUnit.NANOSECONDS);\r\n    evictMicros.add(exeMicros);\r\n    evictCount.increment();\r\n    evictByIdle.add(trimmedByIdle);\r\n    evictByTTL.add(trimmedByTTL);\r\n    evictByLRU.add(trimmedByLRU);\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Executed trim of cache {} in [{}]millis idle[{}] timeToLive[{}] accessTime[{}]\", name, exeMicros, trimmedByIdle, trimmedByTTL, trimmedByLRU);\r\n    }\r\n}"
}, {
	"Path": "org.dataalgorithms.chap08.mapreduce.CommonFriendsReducerUsingList.reduce",
	"Comment": "the goal is to find common friends by intersecting all lists defined in values parameter.",
	"Method": "void reduce(Text key,Iterable<ArrayListOfLongsWritable> values,Context context){\r\n    Map<Long, Integer> map = new HashMap<Long, Integer>();\r\n    Iterator<ArrayListOfLongsWritable> iterator = values.iterator();\r\n    int numOfValues = 0;\r\n    while (iterator.hasNext()) {\r\n        ArrayListOfLongsWritable friends = iterator.next();\r\n        if (friends == null) {\r\n            context.write(key, null);\r\n            return;\r\n        }\r\n        addFriends(map, friends);\r\n        numOfValues++;\r\n    }\r\n    List<Long> commonFriends = new ArrayList<Long>();\r\n    for (Map.Entry<Long, Integer> entry : map.entrySet()) {\r\n        if (entry.getValue() == numOfValues) {\r\n            commonFriends.add(entry.getKey());\r\n        }\r\n    }\r\n    context.write(key, new Text(commonFriends.toString()));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultServer.currentTransaction",
	"Comment": "return the current transaction or null if there is not one currently inscope.",
	"Method": "Transaction currentTransaction(){\r\n    return transactionManager.getActive();\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.DefaultDbMigration.generatePendingDrop",
	"Comment": "return true if the next pending drop changeset should be generated as the next migration.",
	"Method": "String generatePendingDrop(Request request,String pendingVersion,String generatePendingDrop){\r\n    String nextDrop = System.getProperty(\"ddl.migration.pendingDropsFor\");\r\n    if (nextDrop != null) {\r\n        return nextDrop;\r\n    }\r\n    return generatePendingDrop;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.BaseTableDdl.writeUniqueConstraints",
	"Comment": "write the unique constraints inline with the create table statement.",
	"Method": "void writeUniqueConstraints(DdlBuffer apply,CreateTable createTable){\r\n    boolean inlineUniqueWhenNullable = platformDdl.isInlineUniqueWhenNullable();\r\n    List<Column> columns = new WriteUniqueConstraint(createTable.getColumn()).uniqueKeys();\r\n    for (Column column : columns) {\r\n        if (Boolean.TRUE.equals(column.isNotnull()) || inlineUniqueWhenNullable) {\r\n            inlineUniqueConstraintSingle(apply, column);\r\n        } else {\r\n            externalUnique.add(column);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.isDraftDirty",
	"Comment": "return true if this property is a boolean flag only on the draft tableindicating that when the draft is different from the published row.",
	"Method": "boolean isDraftDirty(){\r\n    return draftDirty;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentSetX.generate",
	"Comment": "generate a persistentsetx from the provided supplier up to the provided limit number of times",
	"Method": "PersistentSetX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).persistentSetX(LAZY);\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DbViewHistorySupport.getSysPeriodUpper",
	"Comment": "return the upper bound column prepended with the table alias.",
	"Method": "String getSysPeriodUpper(String tableAlias,String sysPeriod){\r\n    return tableAlias + \".\" + sysPeriod + \"_end\";\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getDraftDirty",
	"Comment": "return the draft dirty boolean property or null if there is not one assigned to this bean type.",
	"Method": "BeanProperty getDraftDirty(){\r\n    return draftDirty;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.isInheritanceRoot",
	"Comment": "return true if this object is the root level object in its entityinheritance.",
	"Method": "boolean isInheritanceRoot(){\r\n    return inheritInfo == null || inheritInfo.isRoot();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.util.ArrayStack.peekWithNull",
	"Comment": "returns the object at the top of this stack without removing it.if the stack is empty this returns null.",
	"Method": "E peekWithNull(){\r\n    return peekZero(true);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.isSimpleId",
	"Comment": "return true if this bean type has a simple single id property.",
	"Method": "boolean isSimpleId(){\r\n    return idBinder instanceof IdBinderSimple;\r\n}"
}, {
	"Path": "io.ebean.config.DocStoreConfig.getPathToResources",
	"Comment": "return the relative file system path to resources when generating mapping files.",
	"Method": "String getPathToResources(){\r\n    return pathToResources;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQuery.getLogWhereSql",
	"Comment": "return the where predicate for display in the transaction log.",
	"Method": "String getLogWhereSql(){\r\n    return logWhereSql;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocMany.initChildMasterProperty",
	"Comment": "return the child property that links back to the master bean.note that childmasterproperty will be null if a field is used instead ofa manytoone bean association.",
	"Method": "BeanPropertyAssocOne<?> initChildMasterProperty(){\r\n    if (unidirectional) {\r\n        return null;\r\n    }\r\n    Class<?> beanType = descriptor.getBeanType();\r\n    BeanDescriptor<?> targetDesc = getTargetDescriptor();\r\n    for (BeanPropertyAssocOne<?> prop : targetDesc.propertiesOne()) {\r\n        if (mappedBy != null) {\r\n            if (mappedBy.equalsIgnoreCase(prop.getName())) {\r\n                return prop;\r\n            }\r\n        } else {\r\n            if (prop.getTargetType().equals(beanType)) {\r\n                return prop;\r\n            }\r\n        }\r\n    }\r\n    throw new RuntimeException(\"Can not find Master [\" + beanType + \"] in Child[\" + targetDesc + \"]\");\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQueryUpdate.execute",
	"Comment": "execute the update or delete statement returning the row count.",
	"Method": "int execute(){\r\n    long startNano = System.nanoTime();\r\n    try {\r\n        SpiTransaction t = getTransaction();\r\n        profileOffset = t.profileOffset();\r\n        Connection conn = t.getInternalConnection();\r\n        pstmt = conn.prepareStatement(sql);\r\n        if (query.getTimeout() > 0) {\r\n            pstmt.setQueryTimeout(query.getTimeout());\r\n        }\r\n        bindLog = predicates.bind(pstmt, conn);\r\n        rowCount = pstmt.executeUpdate();\r\n        executionTimeMicros = (System.nanoTime() - startNano) / 1000L;\r\n        request.slowQueryCheck(executionTimeMicros, rowCount);\r\n        queryPlan.executionTime(rowCount, executionTimeMicros, null);\r\n        getTransaction().profileEvent(this);\r\n        return rowCount;\r\n    } finally {\r\n        close();\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.cache.CachedBeanData.update",
	"Comment": "create and return a new version of cachedbeandata based on thisentry applying the given changes.",
	"Method": "CachedBeanData update(Map<String, Object> changes,long version){\r\n    Map<String, Object> copy = new HashMap();\r\n    copy.putAll(data);\r\n    copy.putAll(changes);\r\n    return new CachedBeanData(null, discValue, copy, version);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.DefaultPersister.deleteChildrenById",
	"Comment": "cascade delete child entities by id.will use delete by object if the child entity has manytomany relationships.",
	"Method": "void deleteChildrenById(SpiTransaction t,BeanDescriptor<?> targetDesc,List<Object> childIds,DeleteMode deleteMode){\r\n    if (!targetDesc.isDeleteByBulk()) {\r\n        List<Object> refList = new ArrayList(childIds.size());\r\n        for (Object id : childIds) {\r\n            refList.add(targetDesc.createReference(id, null));\r\n        }\r\n        deleteList(refList, t, deleteMode, true);\r\n    } else {\r\n        delete(targetDesc, null, childIds, t, deleteMode);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.getBeanHash",
	"Comment": "the hash used to register the bean with the transaction.takes into account the class type and id value.",
	"Method": "Integer getBeanHash(){\r\n    if (beanHash == null) {\r\n        Object id = beanDescriptor.getId(entityBean);\r\n        int hc = 92821 * bean.getClass().getName().hashCode();\r\n        if (id != null) {\r\n            hc += id.hashCode();\r\n        }\r\n        beanHash = hc;\r\n    }\r\n    return beanHash;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.takeUntil",
	"Comment": "return a stream with the same values, but will stop emitting values once the provided stream starts to emit values.e.g. if the provided stream is asynchronously refreshing state from some remote store, this stream can proceed untilthe provided stream succeeds in retrieving data.",
	"Method": "ReactiveSeq<U> takeUntil(SimpleReactStream<T> s){\r\n    return EagerFutureStreamFunctions.takeUntil(this, s);\r\n}"
}, {
	"Path": "org.tests.basic.delete.TestDeleteCascadeByQuery.testDeleteCascadeByQuery",
	"Comment": "test that validates deleting a bean with onetoone mapping with a query respects the cascadetype.delete setting.",
	"Method": "void testDeleteCascadeByQuery(){\r\n    assertThat(userQuery.delete()).isEqualTo(1);\r\n    assertThat(userOptionalQuery.findCount()).overridingErrorMessage(\"Entity OtoUserOptional found. Ebean query delete() on the user \" + \"did not delete the OneToOne mapped entity as set with CascadeType.ALL\").isEqualTo(0);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.putServiceObject",
	"Comment": "put a service object into configuration such that it can be passed to a plugin.for example, put igniteconfiguration in to be passed to the ignite plugin.",
	"Method": "void putServiceObject(String key,Object configObject){\r\n    serviceObject.put(key, configObject);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.PlatformDdl.alterColumnBaseAttributes",
	"Comment": "alter column setting both the type and not null constraint.used by mysql, sql server, and hana as these require both column attributes to be set together.",
	"Method": "String alterColumnBaseAttributes(AlterColumn alter){\r\n    return null;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.LinkedListX.rangeLong",
	"Comment": "create a linkedlistx that contains the longs between skip and take",
	"Method": "LinkedListX<Long> rangeLong(long start,long end){\r\n    return ReactiveSeq.rangeLong(start, end).to(ReactiveConvertableSequence::converter).linkedListX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.DefaultOrmQuery.isDetailEmpty",
	"Comment": "return true if the query detail has neither select or joins specified.",
	"Method": "boolean isDetailEmpty(){\r\n    return detail.isEmpty();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.InheritInfo.isSaveRecurseSkippable",
	"Comment": "return true if anything in the inheritance hierarchy has a relationship with a save cascade on",
	"Method": "boolean isSaveRecurseSkippable(){\r\n    return root.isNodeSaveRecurseSkippable();\r\n}"
}, {
	"Path": "io.ebeaninternal.api.BindParams.setPreparedSql",
	"Comment": "set the sql with named parameters replaced with place holder ?.",
	"Method": "void setPreparedSql(String preparedSql){\r\n    this.preparedSql = preparedSql;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.isMappedSuperWithNoProperties",
	"Comment": "return true if this is a mappedsuperclass bean with no persistent properties.if so it is ok for it not to be enhanced.",
	"Method": "boolean isMappedSuperWithNoProperties(Class<?> beanClass){\r\n    MappedSuperclass annotation = AnnotationUtil.findAnnotation(beanClass, MappedSuperclass.class);\r\n    if (annotation == null) {\r\n        return false;\r\n    }\r\n    Field[] fields = beanClass.getDeclaredFields();\r\n    for (Field field : fields) {\r\n        if (!Modifier.isStatic(field.getModifiers()) && !Modifier.isTransient(field.getModifiers()) && !field.isAnnotationPresent(Transient.class)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.resetManyProperties",
	"Comment": "reset the many properties to empty state ready for reloading.",
	"Method": "void resetManyProperties(Object dbBean){\r\n    EntityBean bean = (EntityBean) dbBean;\r\n    for (BeanPropertyAssocMany<?> aPropertiesMany : propertiesMany) {\r\n        if (aPropertiesMany.isCascadeRefresh()) {\r\n            aPropertiesMany.resetMany(bean);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanDescriptor.getSelectLastInsertedId",
	"Comment": "return the sql used to return the last inserted id.used with identity columns where getgeneratedkeys is not supported.",
	"Method": "String getSelectLastInsertedId(){\r\n    return selectLastInsertedId;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.dmlbind.MatchedImportedFactory.build",
	"Comment": "create the array of matchedimportedproperty based on the properties and descriptor.",
	"Method": "MatchedImportedProperty[] build(BeanProperty[] props,BeanDescriptor<?> desc){\r\n    MatchedImportedProperty[] matches = new MatchedImportedProperty[props.length];\r\n    for (int i = 0; i < props.length; i++) {\r\n        matches[i] = findMatch(props[i], desc);\r\n        if (matches[i] == null) {\r\n            return null;\r\n        }\r\n    }\r\n    return matches;\r\n}"
}, {
	"Path": "cyclops.futurestream.FutureStream.control",
	"Comment": "allows clients to control the emission of data for the next phase of thestream. the user specified function can delay, drop, or change elements",
	"Method": "FutureStream<U> control(Function<Supplier<U>, Supplier<U>> fn){\r\n    final Queue queue = toQueue();\r\n    return fromStream(queue.streamControl(getSubscription(), fn));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.changelog.DefaultChangeLogRegister.getChangeLog",
	"Comment": "find and return the changelog annotation in the inheritance hierarchy.",
	"Method": "ChangeLog getChangeLog(Class<?> beanType){\r\n    return AnnotationUtil.findAnnotationRecursive(beanType, ChangeLog.class);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.appendFrom",
	"Comment": "add any extra joins required to support this property. generally a nooperation except for a onetoone exported.",
	"Method": "void appendFrom(DbSqlContext ctx,SqlJoinType joinType){\r\n    if (formula && sqlFormulaJoin != null) {\r\n        ctx.appendFormulaJoin(sqlFormulaJoin, joinType);\r\n    } else if (secondaryTableJoin != null) {\r\n        String relativePrefix = ctx.getRelativePrefix(secondaryTableJoinPrefix);\r\n        secondaryTableJoin.addJoin(joinType, relativePrefix, ctx);\r\n    }\r\n}"
}, {
	"Path": "cyclops.monads.transformers.EitherT.fromAnyM",
	"Comment": "construct an maybewt from an anym that contains a monad type that contains type other than maybethe values in the underlying monad will be mapped to maybe",
	"Method": "EitherT<W, ST, A> fromAnyM(AnyM<W, A> anyM){\r\n    return of(anyM.map(Either::right));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanProperty.isUndirectionalShadow",
	"Comment": "return true if this is a placeholder property for a unidirectional relationship.",
	"Method": "boolean isUndirectionalShadow(){\r\n    return undirectionalShadow;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.IntersectionTable.insert",
	"Comment": "return a sqlupdate for inserting into the intersection table.",
	"Method": "SqlUpdate insert(EbeanServer server,boolean draft){\r\n    return server.createSqlUpdate(draft ? draftInsertSql : insertSql);\r\n}"
}, {
	"Path": "cyclops.companion.rx2.Singles.combine",
	"Comment": "lazily combine this single with the supplied single via the supplied bifunction",
	"Method": "Single<R> combine(Single<? extends T1> single,Value<? extends T2> app,BiFunction<? super T1, ? super T2, ? extends R> fn,Single<R> combine,Single<? extends T1> single,Single<? extends T2> app,BiFunction<? super T1, ? super T2, ? extends R> fn){\r\n    return Single.fromPublisher(Future.fromPublisher(single.toFlowable()).zip(Future.fromPublisher(app.toFlowable()), fn));\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.MCompoundUniqueConstraint.isOneToOne",
	"Comment": "return true if this unqiue constraint is specifically for onetoone mapping.",
	"Method": "boolean isOneToOne(){\r\n    return oneToOne;\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.loadBeanInternal",
	"Comment": "invoke the lazy loading. this method is synchronised externally.",
	"Method": "void loadBeanInternal(int loadProperty,BeanLoader loader){\r\n    if ((flags[loadProperty] & FLAG_LOADED_PROP) != 0) {\r\n        return;\r\n    }\r\n    if (lazyLoadFailure) {\r\n        throw new EntityNotFoundException(\"(Lazy) loading failed on type:\" + owner.getClass().getName() + \" id:\" + ownerId + \" - Bean has been deleted\");\r\n    }\r\n    if (lazyLoadProperty == -1) {\r\n        lazyLoadProperty = loadProperty;\r\n        if (nodeUsageCollector != null) {\r\n            nodeUsageCollector.setLoadProperty(getProperty(lazyLoadProperty));\r\n        }\r\n        loader.loadBean(this);\r\n        if (lazyLoadFailure) {\r\n            throw new EntityNotFoundException(\"Lazy loading failed on type:\" + owner.getClass().getName() + \" id:\" + ownerId + \" - Bean has been deleted.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.DefaultPersister.getBeanManager",
	"Comment": "return the beandescriptor for a bean that is being persisted.note that this checks to see if the bean is a mapbean with a tablename.if so it will return the table based beandescriptor.",
	"Method": "BeanManager<T> getBeanManager(T bean){\r\n    return (BeanManager<T>) beanDescriptorManager.getBeanManager(bean.getClass());\r\n}"
}, {
	"Path": "io.ebean.config.DocStoreConfig.getPassword",
	"Comment": "return the password credential for connecting to the document store.",
	"Method": "String getPassword(){\r\n    return password;\r\n}"
}, {
	"Path": "io.ebean.config.UnderscoreNamingConvention.toCamelFromUnderscore",
	"Comment": "convert and return the from string from underscore to camel case.",
	"Method": "String toCamelFromUnderscore(String underscore){\r\n    return CamelCaseHelper.toCamelFromUnderscore(underscore);\r\n}"
}, {
	"Path": "chapter06trees.SearchBinaryTreeRecursive.findInBT",
	"Comment": "tests whether the root argument contains within itself the data argument.",
	"Method": "boolean findInBT(BinaryTreeNode root,int data){\r\n    if (root == null)\r\n        return false;\r\n    if (root.getData() == data)\r\n        return true;\r\n    return findInBT(root.getLeft(), data) || findInBT(root.getRight(), data);\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.AbstractDbEncrypt.getDbEncryptFunction",
	"Comment": "return the db encryption function for the given jdbc type.null is returned if db encryption of the type is not supported.",
	"Method": "DbEncryptFunction getDbEncryptFunction(int jdbcType){\r\n    switch(jdbcType) {\r\n        case Types.VARCHAR:\r\n            return varcharEncryptFunction;\r\n        case Types.CLOB:\r\n            return varcharEncryptFunction;\r\n        case Types.CHAR:\r\n            return varcharEncryptFunction;\r\n        case Types.LONGVARCHAR:\r\n            return varcharEncryptFunction;\r\n        case Types.DATE:\r\n            return dateEncryptFunction;\r\n        case Types.TIMESTAMP:\r\n            return timestampEncryptFunction;\r\n        default:\r\n            return null;\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.getEncryptKey",
	"Comment": "return the encrypt key for the column matching this property.",
	"Method": "EncryptKey getEncryptKey(){\r\n    return descriptor.getEncryptKey(this);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQueryDraftSupport.getDraftTable",
	"Comment": "return the draft table associated to the base table.this returns null for entities that are not draftable and in that casethe usual base table is used.",
	"Method": "String getDraftTable(String table){\r\n    return tableMap.get(table);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.OrderedSetX.rangeLong",
	"Comment": "create a orderedsetx that contains the longs between skip and take",
	"Method": "OrderedSetX<Long> rangeLong(long start,long end){\r\n    return ReactiveSeq.rangeLong(start, end).to(ReactiveConvertableSequence::converter).orderedSetX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.CaseInsensitiveEqualExpression.val",
	"Comment": "return the bind value taking into account named parameters.",
	"Method": "String val(){\r\n    return strValue().toLowerCase();\r\n}"
}, {
	"Path": "io.ebean.util.AnnotationUtil.findAnnotation",
	"Comment": "perform the search algorithm avoiding endless recursion by tracking whichannotations have already been visited.",
	"Method": "A findAnnotation(AnnotatedElement annotatedElement,Class<A> annotationType,A findAnnotation,AnnotatedElement annotatedElement,Class<A> annotationType,Platform platform,A findAnnotation,Annotation[] anns,Class<A> annotationType,Set<Annotation> visited){\r\n    for (Annotation ann : anns) {\r\n        if (!isInJavaLangAnnotationPackage(ann) && visited.add(ann)) {\r\n            Annotation[] metaAnns = ann.annotationType().getAnnotations();\r\n            for (Annotation metaAnn : metaAnns) {\r\n                if (metaAnn.annotationType() == annotationType) {\r\n                    return (A) metaAnn;\r\n                }\r\n            }\r\n            if (metaAnns.length > 0) {\r\n                A annotation = findAnnotation(metaAnns, annotationType, visited);\r\n                if (annotation != null) {\r\n                    return annotation;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getDocStoreConfig",
	"Comment": "return the configuration for the elasticsearch integration.",
	"Method": "DocStoreConfig getDocStoreConfig(){\r\n    return docStoreConfig;\r\n}"
}, {
	"Path": "io.ebean.util.StringHelper.replaceString",
	"Comment": "this method takes a string and will replace all occurrences of the matchstring with that of the replace string.",
	"Method": "String replaceString(String source,String match,String replace,String replaceString,String source,String match,String replace,int additionalSize,int startPos,int endPos){\r\n    if (source == null) {\r\n        return null;\r\n    }\r\n    char match0 = match.charAt(0);\r\n    int matchLength = match.length();\r\n    if (matchLength == 1 && replace.length() == 1) {\r\n        char replace0 = replace.charAt(0);\r\n        return source.replace(match0, replace0);\r\n    }\r\n    if (matchLength >= replace.length()) {\r\n        additionalSize = 0;\r\n    }\r\n    int sourceLength = source.length();\r\n    int lastMatch = endPos - matchLength;\r\n    StringBuilder sb = new StringBuilder(sourceLength + additionalSize);\r\n    if (startPos > 0) {\r\n        sb.append(source.substring(0, startPos));\r\n    }\r\n    char sourceChar;\r\n    boolean isMatch;\r\n    int sourceMatchPos;\r\n    for (int i = startPos; i < sourceLength; i++) {\r\n        sourceChar = source.charAt(i);\r\n        if (i > lastMatch || sourceChar != match0) {\r\n            sb.append(sourceChar);\r\n        } else {\r\n            isMatch = true;\r\n            sourceMatchPos = i;\r\n            for (int j = 1; j < matchLength; j++) {\r\n                sourceMatchPos++;\r\n                if (source.charAt(sourceMatchPos) != match.charAt(j)) {\r\n                    isMatch = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (isMatch) {\r\n                i = i + matchLength - 1;\r\n                sb.append(replace);\r\n            } else {\r\n                sb.append(sourceChar);\r\n            }\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.SequenceStepIdGenerator.readIds",
	"Comment": "add the next set of ids as the next value plus all the following numbers up to the step size.",
	"Method": "List<Long> readIds(ResultSet resultSet,int ignoreRequestSize){\r\n    List<Long> newIds = new ArrayList(allocationSize);\r\n    if (resultSet.next()) {\r\n        long start = resultSet.getLong(1);\r\n        for (int i = 0; i < allocationSize; i++) {\r\n            newIds.add(start + i);\r\n        }\r\n    }\r\n    return newIds;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentSetX.range",
	"Comment": "create a persistentsetx that contains the integers between skip and take",
	"Method": "PersistentSetX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).persistentSetX(LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.MConfiguration.apply",
	"Comment": "apply the migration configuration.it is expected that these are applied in the correct chronological orderfrom earliest to latest.",
	"Method": "void apply(Configuration configuration){\r\n    DefaultTablespace defaultTablespace = configuration.getDefaultTablespace();\r\n    if (defaultTablespace != null) {\r\n        String tables = defaultTablespace.getTables();\r\n        if (isNotEmpty(tables)) {\r\n            this.tableTablespace = tables;\r\n        }\r\n        String indexes = defaultTablespace.getIndexes();\r\n        if (isNotEmpty(indexes)) {\r\n            this.indexTablespace = indexes;\r\n        }\r\n        String history = defaultTablespace.getHistory();\r\n        if (isNotEmpty(history)) {\r\n            this.historyTablespace = history;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DatabasePlatform.getOnQueryOnly",
	"Comment": "return the behaviour to use when ending a read only transaction.",
	"Method": "OnQueryOnly getOnQueryOnly(){\r\n    return onQueryOnly;\r\n}"
}, {
	"Path": "cyclops.data.ImmutableMap.toSeq",
	"Comment": "convert this mapx to a seq via the provided transformation function",
	"Method": "Seq<T> toSeq(Function<? super Tuple2<? super K, ? super V>, ? extends T> fn){\r\n    return Seq.narrow(stream().map(fn).seq());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.BatchControl.addToBatch",
	"Comment": "add the request to the batch and return true if we should flush.",
	"Method": "boolean addToBatch(PersistRequestBean<?> request){\r\n    BatchedBeanHolder beanHolder = getBeanHolder(request);\r\n    int bufferSize = beanHolder.append(request);\r\n    bufferMax = Math.max(bufferMax, bufferSize);\r\n    return (bufferMax >= batchSize * 10);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.bootup.ManifestReader.create",
	"Comment": "create with a classloader to use to read the ebean.mf resources.",
	"Method": "ManifestReader create(ClassLoader classLoader){\r\n    return new ManifestReader(classLoader);\r\n}"
}, {
	"Path": "cyclops.futurestream.LazyReact.parallelBuilder",
	"Comment": "construct a new lazyreact builder, with a new task executor and retryexecutor with configured number of threads",
	"Method": "LazyReact parallelBuilder(LazyReact parallelBuilder,int parallelism){\r\n    return LazyReact.builder().executor(Executors.newFixedThreadPool(parallelism)).build();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.PrepareDocNested.group",
	"Comment": "reorganise the flat list of expressions into a tree grouping expressions by nested path.returns the new top level list of expressions.",
	"Method": "List<SpiExpression> group(){\r\n    Map<String, Group> groups = new LinkedHashMap();\r\n    for (int i = 0; i < origSize; i++) {\r\n        SpiExpression expr = origUnderlying.get(i);\r\n        String nestedPath = expr.nestedPath(beanDescriptor);\r\n        Group group = groups.computeIfAbsent(nestedPath, Group::new);\r\n        group.list.add(expr);\r\n    }\r\n    List<SpiExpression> newList = new ArrayList();\r\n    Collection<Group> values = groups.values();\r\n    for (Group group : values) {\r\n        group.addTo(newList);\r\n    }\r\n    return newList;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.getSoftDeleteDbPredicate",
	"Comment": "return the db literal predicate used to filter out soft deleted rows from a query.",
	"Method": "String getSoftDeleteDbPredicate(String tableAlias){\r\n    return tableAlias + softDeleteDbPredicate;\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.setPropertyUnloaded",
	"Comment": "set the property to be treated as unloaded. used for properties initialised in defaultconstructor.",
	"Method": "void setPropertyUnloaded(int propertyIndex){\r\n    flags[propertyIndex] &= ~FLAG_LOADED_PROP;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.build.ModelBuildBeanVisitor.setIdentity",
	"Comment": "set the identity type to use for this table.takes into account the requested identity type and the underlying support in thedatabase platform.",
	"Method": "void setIdentity(BeanDescriptor<?> descriptor,MTable table){\r\n    if (IdType.GENERATOR == descriptor.getIdType()) {\r\n        table.setIdentityType(IdentityType.GENERATOR);\r\n        return;\r\n    }\r\n    if (IdType.EXTERNAL == descriptor.getIdType()) {\r\n        table.setIdentityType(IdentityType.EXTERNAL);\r\n        return;\r\n    }\r\n    int initialValue = descriptor.getSequenceInitialValue();\r\n    int allocationSize = descriptor.getSequenceAllocationSize();\r\n    if (!descriptor.isIdTypePlatformDefault() || initialValue > 0 || allocationSize > 0) {\r\n        if (IdType.IDENTITY == descriptor.getIdType()) {\r\n            if (!descriptor.isIdTypePlatformDefault()) {\r\n                table.setIdentityType(IdentityType.IDENTITY);\r\n            }\r\n        } else {\r\n            table.setIdentityType(IdentityType.SEQUENCE);\r\n            table.setSequenceName(descriptor.getSequenceName());\r\n            table.setSequenceInitial(initialValue);\r\n            table.setSequenceAllocate(allocationSize);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeanservice.docstore.api.support.DocStoreBeanBaseAdapter.getEmbeddedInvalidation",
	"Comment": "return the dsinvalidationlistener based on the properties, path.",
	"Method": "DocStoreEmbeddedInvalidation getEmbeddedInvalidation(String queueId,String path,Set<String> properties){\r\n    if (properties.contains(\"*\")) {\r\n        return new DocStoreEmbeddedInvalidation(queueId, path);\r\n    } else {\r\n        return new DocStoreEmbeddedInvalidationProperties(queueId, path, getPropertyPositions(properties));\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setAutoCommitMode",
	"Comment": "set to true if autocommit mode is on and ebean should use autocommit friendly transactions and transactionmanager.",
	"Method": "void setAutoCommitMode(boolean autoCommitMode){\r\n    this.autoCommitMode = autoCommitMode;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.self",
	"Comment": "give a function access to the current stage of a simplereact stream",
	"Method": "SimpleReactStream<U> self(Consumer<SimpleReactStream<U>> consumer){\r\n    return peek(n -> consumer.accept(this));\r\n}"
}, {
	"Path": "cyclops.control.Try.withCatch",
	"Comment": "try to execute supplied supplier and will catch specified excpetions or java.lang.exceptionif none specified.",
	"Method": "Try<T, X> withCatch(CheckedSupplier<T, X> cf,Class<? extends X> classes){\r\n    Objects.requireNonNull(cf);\r\n    try {\r\n        return Try.success(cf.get());\r\n    } catch (final Throwable t) {\r\n        if (classes.length == 0)\r\n            return Try.failure((X) t);\r\n        val error = Stream.of(classes).filter(c -> c.isAssignableFrom(t.getClass())).findFirst();\r\n        if (error.isPresent())\r\n            return Try.failure((X) t);\r\n        else\r\n            throw ExceptionSoftener.throwSoftenedException(t);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.BasicTypeConverter.toLong",
	"Comment": "convert the object to a long. it should be another numeric type.",
	"Method": "Long toLong(Object value){\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    if (value instanceof Long) {\r\n        return (Long) value;\r\n    }\r\n    if (value instanceof String) {\r\n        return Long.valueOf((String) value);\r\n    }\r\n    if (value instanceof Number) {\r\n        return ((Number) value).longValue();\r\n    }\r\n    if (value instanceof java.util.Date) {\r\n        return ((java.util.Date) value).getTime();\r\n    }\r\n    if (value instanceof Calendar) {\r\n        return ((Calendar) value).getTime().getTime();\r\n    }\r\n    return Long.valueOf(value.toString());\r\n}"
}, {
	"Path": "io.ebean.TxScope.getIsolation",
	"Comment": "return the isolation level this transaction should run with.",
	"Method": "TxIsolation getIsolation(){\r\n    return isolation;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DbViewHistorySupport.getBindCount",
	"Comment": "return 2 if we have effective start and effective end as 2 columns.note that for postgres we can use a single range type so that returns 1.",
	"Method": "int getBindCount(){\r\n    return 2;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.BaseTableDdl.writePrimaryKeyConstraint",
	"Comment": "write the primary key constraint inline with the create table statement.",
	"Method": "void writePrimaryKeyConstraint(DdlBuffer buffer,String pkName,String[] pkColumns){\r\n    buffer.append(\",\").newLine();\r\n    buffer.append(\"  constraint \").append(pkName).append(\" primary key\");\r\n    appendColumns(pkColumns, buffer);\r\n}"
}, {
	"Path": "io.ebeaninternal.api.BeanIdList.setHasMore",
	"Comment": "set to true when max rows is hit and there are more rows to fetch.",
	"Method": "void setHasMore(boolean hasMore){\r\n    this.hasMore = hasMore;\r\n}"
}, {
	"Path": "cyclops.control.Future.flatMapCf",
	"Comment": "a flatmap operation that accepts a completeablefuture completionstage asthe return type",
	"Method": "Future<R> flatMapCf(Function<? super T, ? extends CompletionStage<? extends R>> mapper){\r\n    return Future.<R>of(future.<R>thenCompose(t -> (CompletionStage<R>) mapper.apply(t)));\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.MTable.updateCompoundIndices",
	"Comment": "this method adds information which columns are nullable or not to the compound indices.",
	"Method": "void updateCompoundIndices(){\r\n    for (MCompoundUniqueConstraint uniq : uniqueConstraints) {\r\n        List<String> nullableColumns = new ArrayList();\r\n        for (String columnName : uniq.getColumns()) {\r\n            MColumn col = getColumn(columnName);\r\n            if (col == null) {\r\n                throw new IllegalStateException(\"Column '\" + columnName + \"' not found in table \" + getName());\r\n            }\r\n            if (!col.isNotnull()) {\r\n                nullableColumns.add(columnName);\r\n            }\r\n        }\r\n        uniq.setNullableColumns(nullableColumns.toArray(new String[nullableColumns.size()]));\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getReadOnlyDataSourceConfig",
	"Comment": "return the configuration for the read only datasource.this is only used if autoreadonlydatasource is true.the driver, url, username and password default to the configuration for the main datasource if they are notset on this configuration. this means there is actually no need to set any configuration here and we onlyset configuration for url, username and password etc if it is different from the main datasource.",
	"Method": "DataSourceConfig getReadOnlyDataSourceConfig(){\r\n    return readOnlyDataSourceConfig;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssoc.getTargetType",
	"Comment": "return the type of the target.this is the class of the associated bean, or beans contained in a list,set or map.",
	"Method": "Class<?> getTargetType(){\r\n    return targetType;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.isDDLColumn",
	"Comment": "return true if this property should have a db column created in ddl.",
	"Method": "boolean isDDLColumn(){\r\n    return !formula && !secondaryTable && (aggregation == null);\r\n}"
}, {
	"Path": "io.ebeanservice.docstore.api.support.DocStoreBeanBaseAdapter.registerInvalidationPath",
	"Comment": "register a doc store invalidation listener for the given bean type, path and properties.",
	"Method": "void registerInvalidationPath(String queueId,String path,Set<String> properties){\r\n    if (!mapped) {\r\n        if (update == DocStoreMode.IGNORE) {\r\n            update = DocStoreMode.UPDATE;\r\n        }\r\n    }\r\n    embeddedInvalidation.add(getEmbeddedInvalidation(queueId, path, properties));\r\n}"
}, {
	"Path": "io.ebean.Ebean.deleteAllPermanent",
	"Comment": "delete permanent several beans given their type and id values.",
	"Method": "int deleteAllPermanent(Class<?> beanType,Collection<?> ids,int deleteAllPermanent,Collection<?> beans){\r\n    return serverMgr.getDefaultServer().deleteAllPermanent(beans);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.MCompoundUniqueConstraint.addUniqueConstraint",
	"Comment": "return a adduniqueconstraint migration for this constraint.",
	"Method": "AddUniqueConstraint addUniqueConstraint(String tableName){\r\n    AddUniqueConstraint create = new AddUniqueConstraint();\r\n    create.setConstraintName(getName());\r\n    create.setTableName(tableName);\r\n    create.setColumnNames(join(columns));\r\n    create.setNullableColumns(join(nullableColumns));\r\n    create.setOneToOne(isOneToOne());\r\n    return create;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.JdbcTransaction.flushCommitAndNotify",
	"Comment": "batch flush, jdbc commit, trigger registered transactioncallbacks, notify l2 cache etc.",
	"Method": "void flushCommitAndNotify(){\r\n    internalBatchFlush();\r\n    firePreCommit();\r\n    performCommit();\r\n    firePostCommit();\r\n    notifyCommit();\r\n}"
}, {
	"Path": "io.ebeaninternal.api.ManyWhereJoins.requireSqlDistinct",
	"Comment": "return true if this is an aggregation query or if there are no extra many where joins.",
	"Method": "boolean requireSqlDistinct(){\r\n    return !aggregation && !joins.isEmpty();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.DefaultOrmQueryEngine.flushJdbcBatchOnQuery",
	"Comment": "flushes the jdbc batch by default unless explicitly turned off on the transaction.",
	"Method": "void flushJdbcBatchOnQuery(OrmQueryRequest<T> request){\r\n    SpiTransaction t = request.getTransaction();\r\n    if (t.isBatchFlushOnQuery()) {\r\n        t.flushBatch();\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorDraftHelp.resetProperties",
	"Comment": "return the properties that are reset on draft beans after publish.",
	"Method": "BeanProperty[] resetProperties(){\r\n    List<BeanProperty> list = new ArrayList();\r\n    BeanProperty[] props = desc.propertiesNonMany();\r\n    for (BeanProperty prop : props) {\r\n        if (prop.isDraftReset()) {\r\n            list.add(prop);\r\n        }\r\n    }\r\n    return list.toArray(new BeanProperty[list.size()]);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.determineUpdateAllLoadedProperties",
	"Comment": "determine if all loaded properties should be used for an update.takes into account transaction setting and jdbc batch.",
	"Method": "boolean determineUpdateAllLoadedProperties(){\r\n    Boolean txnUpdateAll = transaction.isUpdateAllLoadedProperties();\r\n    if (txnUpdateAll != null) {\r\n        requestUpdateAllLoadedProps = txnUpdateAll;\r\n    } else {\r\n        requestUpdateAllLoadedProps = isBatchThisRequest() && ebeanServer.isUpdateAllPropertiesInBatch();\r\n    }\r\n    return requestUpdateAllLoadedProps;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.postControllerPrepareUpdate",
	"Comment": "prepare the update after potential modifications in a beanpersistcontroller.",
	"Method": "void postControllerPrepareUpdate(){\r\n    if (statelessUpdate && controller != null) {\r\n        intercept.setNewBeanForUpdate();\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.supportsSelectLastInsertedId",
	"Comment": "return true if this bean uses a sql select to fetch the last inserted id value.",
	"Method": "boolean supportsSelectLastInsertedId(){\r\n    return selectLastInsertedId != null;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.OrmQueryDetail.sortByFetchPreference",
	"Comment": "sort the fetch entries taking into account fetchpreference on the path.",
	"Method": "List<FetchEntry> sortByFetchPreference(BeanDescriptor<?> desc){\r\n    List<FetchEntry> entries = new ArrayList(fetchPaths.size());\r\n    int idx = 0;\r\n    for (Map.Entry<String, OrmQueryProperties> entry : fetchPaths.entrySet()) {\r\n        String fetchPath = entry.getKey();\r\n        ElPropertyDeploy elProp = desc.getElPropertyDeploy(fetchPath);\r\n        if (elProp == null) {\r\n            throw new PersistenceException(\"Invalid fetch path \" + fetchPath + \" from \" + desc.getFullName());\r\n        }\r\n        entries.add(new FetchEntry(idx++, fetchPath, elProp, entry.getValue()));\r\n    }\r\n    Collections.sort(entries);\r\n    return entries;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.isInherited",
	"Comment": "return true if this object is part of an inheritance hierarchy.",
	"Method": "boolean isInherited(){\r\n    return inherited;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.BaseSimpleReactStream.of",
	"Comment": "create a sequential synchronous stream that runs on the current thread",
	"Method": "SimpleReactStream<T> of(T value,SimpleReactStream<T> of,T values){\r\n    return simpleReactStream((Stream) Stream.of(values));\r\n}"
}, {
	"Path": "cyclops.futurestream.Pipes.close",
	"Comment": "close the adapter identified by the provided key if it exists",
	"Method": "void close(String key){\r\n    Optional.ofNullable(registered.get(key)).ifPresent(a -> a.close());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.createReference",
	"Comment": "create and return a new reference bean matching this beans id value.",
	"Method": "T createReference(){\r\n    return beanDescriptor.createReference(getBeanId(), null);\r\n}"
}, {
	"Path": "com.oath.cyclops.util.stream.scheduling.cron.CronExpression.getTimeZone",
	"Comment": "returns the time zone for which this cronexpressionwill be resolved.",
	"Method": "TimeZone getTimeZone(){\r\n    if (timeZone == null) {\r\n        timeZone = TimeZone.getDefault();\r\n    }\r\n    return timeZone;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.ModelDiff.isEmpty",
	"Comment": "return true if the apply and drop changes are both empty.this means there are no migration changes.",
	"Method": "boolean isEmpty(){\r\n    return applyChanges.isEmpty() && dropChanges.isEmpty();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.platform.PostgresCast.cast",
	"Comment": "postgres cast the type if necessary additionally specify if db array is used.",
	"Method": "String cast(Object value,String cast,Object value,boolean asArray){\r\n    if (value == null) {\r\n        return \"\";\r\n    }\r\n    if (value instanceof Integer) {\r\n        return asArray ? \"::integer[]\" : \"::integer\";\r\n    }\r\n    if (value instanceof Long) {\r\n        return asArray ? \"::bigint[]\" : \"::bigint\";\r\n    }\r\n    if (value instanceof Number) {\r\n        return asArray ? \"::decimal[]\" : \"::decimal\";\r\n    }\r\n    if (value instanceof Boolean) {\r\n        return asArray ? \"::boolean[]\" : \"::boolean\";\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQueryPlanRawSql.foreignKeyPath",
	"Comment": "return the path for a foreign key column that was automatically mapped.",
	"Method": "String foreignKeyPath(String logicalPropertyPath){\r\n    return logicalPropertyPath.substring(0, logicalPropertyPath.length() - 3) + \"Id\";\r\n}"
}, {
	"Path": "com.oath.cyclops.util.box.LazyImmutable.setOnce",
	"Comment": "set the value of this immutableclosedvalueif it has already been set will throw an exception",
	"Method": "LazyImmutable<T> setOnce(T val){\r\n    this.value.compareAndSet(UNSET, val);\r\n    set.set(true);\r\n    return this;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocMany.getModifyListenMode",
	"Comment": "return the mode for listening to modifications to collections for thisassociation.",
	"Method": "ModifyListenMode getModifyListenMode(){\r\n    return modifyListenMode;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.SqlTreeProperties.isAggregationRoot",
	"Comment": "return true if a top level aggregation which means the id property must be excluded.",
	"Method": "boolean isAggregationRoot(){\r\n    return aggregation && (aggregationPath == null);\r\n}"
}, {
	"Path": "io.ebean.PrimaryServer.isSkip",
	"Comment": "return true to skip automatically creating the primary server.",
	"Method": "boolean isSkip(){\r\n    return skip;\r\n}"
}, {
	"Path": "cyclops.kinds.OptionalKind.narrow",
	"Comment": "convert the raw higher kinded type for optionalkind types into the optionalkind type definition class",
	"Method": "OptionalKind<T> narrow(Higher<optional, T> future){\r\n    return (OptionalKind<T>) future;\r\n}"
}, {
	"Path": "io.ebean.config.properties.LoadContext.indirectLocation",
	"Comment": "read the special properties that can point to an external properties source.",
	"Method": "String indirectLocation(){\r\n    String indirectLocation = map.get(\"load.properties\");\r\n    if (indirectLocation == null) {\r\n        indirectLocation = map.get(\"load.properties.override\");\r\n    }\r\n    return indirectLocation;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocOne.initialisePostTarget",
	"Comment": "derive late in lifecycle cache notification on this relationship.",
	"Method": "void initialisePostTarget(){\r\n    this.cacheNotifyRelationship = isCacheNotifyRelationship();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.InheritInfo.isConcrete",
	"Comment": "return true if this is considered a concrete type in the inheritance hierarchy.",
	"Method": "boolean isConcrete(){\r\n    return !Modifier.isAbstract(type.getModifiers());\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.getLazyLoadPropertyIndex",
	"Comment": "return the index of the property that triggered the lazy load.",
	"Method": "int getLazyLoadPropertyIndex(){\r\n    return lazyLoadProperty;\r\n}"
}, {
	"Path": "cyclops.monads.transformers.reactor.MonoT.fromAnyM",
	"Comment": "construct an monot from an anym that contains a monad type that contains type other than monothe values in the underlying monad will be mapped to mono",
	"Method": "MonoT<W, A> fromAnyM(AnyM<W, A> anyM){\r\n    return of(anyM.map(Mono::just));\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.PostgresDdl.asIdentityColumn",
	"Comment": "map bigint, integer and smallint into their equivalent serial types.",
	"Method": "String asIdentityColumn(String columnDefn){\r\n    if (\"bigint\".equalsIgnoreCase(columnDefn)) {\r\n        return \"bigserial\";\r\n    }\r\n    if (\"integer\".equalsIgnoreCase(columnDefn)) {\r\n        return \"serial\";\r\n    }\r\n    if (\"smallint\".equalsIgnoreCase(columnDefn)) {\r\n        return \"smallserial\";\r\n    }\r\n    return columnDefn;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.isSaveRecurseSkippable",
	"Comment": "return true if save does not recurse to other beans. that is return true ifthere are no assoc one or assoc many beans that cascade save.",
	"Method": "boolean isSaveRecurseSkippable(){\r\n    return saveRecurseSkippable;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.RawSqlQueryPlanKey.getPartialKey",
	"Comment": "return as a partial key. for rawsql hash the sql is part of the key and as suchneeds to be included in order to have a complete key. typically the md5 of the sqlcan be used as a short form proxy for the actual sql.",
	"Method": "String getPartialKey(){\r\n    return hashCode() + \"_0\";\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.CurrentModel.read",
	"Comment": "return the current model by reading all the bean descriptors and properties.",
	"Method": "ModelContainer read(){\r\n    if (model == null) {\r\n        model = new ModelContainer();\r\n        ModelBuildContext context = new ModelBuildContext(model, constraintNaming, maxLength, platformTypes);\r\n        ModelBuildBeanVisitor visitor = new ModelBuildBeanVisitor(context);\r\n        VisitAllUsing visit = new VisitAllUsing(visitor, server);\r\n        visit.visitAllBeans();\r\n        context.adjustDraftReferences();\r\n    }\r\n    return model;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.autotune.service.ProfileOrigin.collectQueryInfo",
	"Comment": "collect query execution summary statistics.this can give us a quick overview into bad lazy loading areas etc.",
	"Method": "void collectQueryInfo(ObjectGraphNode node,long beansLoaded,long micros){\r\n    String key = node.getPath();\r\n    if (key == null) {\r\n        key = \"\";\r\n    }\r\n    ProfileOriginQuery stats = queryStatsMap.get(key);\r\n    if (stats == null) {\r\n        stats = new ProfileOriginQuery(key);\r\n        queryStatsMap.put(key, stats);\r\n    }\r\n    stats.add(beansLoaded, micros);\r\n}"
}, {
	"Path": "io.ebean.config.ProfilingConfig.setMinimumMicros",
	"Comment": "set the minimum transaction execution to be included in profiling.",
	"Method": "void setMinimumMicros(long minimumMicros){\r\n    this.minimumMicros = minimumMicros;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.JdbcTransaction.setBatchControl",
	"Comment": "set the batchcontrol to the transaction. this is done once per transactionon the first persist request.",
	"Method": "void setBatchControl(BatchControl batchControl){\r\n    queryOnly = false;\r\n    this.batchControl = batchControl;\r\n    if (batchGetGeneratedKeys != null) {\r\n        batchControl.setGetGeneratedKeys(batchGetGeneratedKeys);\r\n    }\r\n    if (batchSize != -1) {\r\n        batchControl.setBatchSize(batchSize);\r\n    }\r\n    if (batchFlushOnMixed != null) {\r\n        batchControl.setBatchFlushOnMixed(batchFlushOnMixed);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssoc.findMatch",
	"Comment": "find and return the exported property matching to this property.",
	"Method": "ExportedProperty findMatch(boolean embedded,BeanProperty prop,String matchColumn,TableJoin tableJoin){\r\n    String searchTable = tableJoin.getTable();\r\n    for (TableJoinColumn column : tableJoin.columns()) {\r\n        String matchTo = column.getLocalDbColumn();\r\n        if (matchColumn.equalsIgnoreCase(matchTo)) {\r\n            String foreignCol = column.getForeignDbColumn();\r\n            return new ExportedProperty(embedded, foreignCol, prop);\r\n        }\r\n    }\r\n    String msg = \"Error with the Join on [\" + getFullBeanName() + \"]. Could not find the matching foreign key for [\" + matchColumn + \"] in table[\" + searchTable + \"]?\" + \" Perhaps using a @JoinColumn with the name/referencedColumnName attributes swapped?\";\r\n    throw new PersistenceException(msg);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.MColumn.copyForDraft",
	"Comment": "return a copy of this column used for creating the associated draft table.",
	"Method": "MColumn copyForDraft(){\r\n    MColumn copy = new MColumn(name, type);\r\n    copy.draftOnly = draftOnly;\r\n    copy.checkConstraint = checkConstraint;\r\n    copy.checkConstraintName = checkConstraintName;\r\n    copy.defaultValue = defaultValue;\r\n    copy.dbMigrationInfos = dbMigrationInfos;\r\n    copy.references = references;\r\n    copy.comment = comment;\r\n    copy.foreignKeyName = foreignKeyName;\r\n    copy.foreignKeyIndex = foreignKeyIndex;\r\n    copy.fkeyOnUpdate = fkeyOnUpdate;\r\n    copy.fkeyOnDelete = fkeyOnDelete;\r\n    copy.historyExclude = historyExclude;\r\n    copy.notnull = notnull;\r\n    copy.primaryKey = primaryKey;\r\n    copy.identity = identity;\r\n    copy.unique = unique;\r\n    copy.uniqueOneToOne = uniqueOneToOne;\r\n    return copy;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DatabasePlatform.setOnQueryOnly",
	"Comment": "set the behaviour to use when ending a read only transaction.",
	"Method": "void setOnQueryOnly(OnQueryOnly onQueryOnly){\r\n    this.onQueryOnly = onQueryOnly;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocMany.getFetchOrderBy",
	"Comment": "return the order by clause used to order the fetching of the data forthis list, set or map.",
	"Method": "String getFetchOrderBy(){\r\n    return fetchOrderBy;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssoc.getMappedBy",
	"Comment": "return the mappedby property.this will be null on the owning side.",
	"Method": "String getMappedBy(){\r\n    return mappedBy;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.sqlserver.SqlServerBasePlatform.fromForUpdate",
	"Comment": "for update is part of the from clause on the base table for sql server.",
	"Method": "String fromForUpdate(Query.ForUpdate forUpdateMode){\r\n    switch(forUpdateMode) {\r\n        case SKIPLOCKED:\r\n            return \"with (updlock,readpast)\";\r\n        case NOWAIT:\r\n            return \"with (updlock,nowait)\";\r\n        default:\r\n            return \"with (updlock)\";\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.DdlHelp.isDropConstraint",
	"Comment": "return true if the default value is the special drop constraint value.",
	"Method": "boolean isDropConstraint(String value){\r\n    return DROP_CONSTRAINT.equals(value);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getBackgroundExecutorSchedulePoolSize",
	"Comment": "return the background executor schedule pool size. defaults to 1.",
	"Method": "int getBackgroundExecutorSchedulePoolSize(){\r\n    return backgroundExecutorSchedulePoolSize;\r\n}"
}, {
	"Path": "io.ebean.config.ClassLoadConfig.isJodaTimePresent",
	"Comment": "return true if the joda types are available and should be supported.",
	"Method": "boolean isJodaTimePresent(){\r\n    return isPresent(\"org.joda.time.LocalDateTime\");\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.serviceLoad",
	"Comment": "return the service loader using the classloader defined in classloadconfig.",
	"Method": "ServiceLoader<T> serviceLoad(Class<T> spiService){\r\n    return ServiceLoader.load(spiService, classLoadConfig.getClassLoader());\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.zip",
	"Comment": "zip two streams, zipping against the underlying futures of this stream",
	"Method": "SimpleReactStream<Tuple2<U, R>> zip(Stream<R> other,SimpleReactStream<Tuple2<U, R>> zip,SimpleReactStream<R> other){\r\n    final ReactiveSeq seq = ReactiveSeq.fromStream(getLastActive().stream()).zip(ReactiveSeq.fromStream(other.getLastActive().stream()));\r\n    final ReactiveSeq<Tuple2<CompletableFuture<U>, CompletableFuture<R>>> withType = seq;\r\n    final SimpleReactStream futureStream = fromStreamOfFutures((Stream) withType.map(t -> CompletableFuture.allOf(t._1(), t._2()).thenApply(v -> Tuple.tuple(t._1().join(), t._2().join()))));\r\n    return futureStream;\r\n}"
}, {
	"Path": "io.ebean.cache.ServerCacheOptions.applyDefaults",
	"Comment": "apply any settings from the default settings that have not already beenspecifically set.",
	"Method": "ServerCacheOptions applyDefaults(ServerCacheOptions defaults){\r\n    if (maxSize == 0) {\r\n        maxSize = defaults.getMaxSize();\r\n    }\r\n    if (maxIdleSecs == 0) {\r\n        maxIdleSecs = defaults.getMaxIdleSecs();\r\n    }\r\n    if (maxSecsToLive == 0) {\r\n        maxSecsToLive = defaults.getMaxSecsToLive();\r\n    }\r\n    if (trimFrequency == 0) {\r\n        trimFrequency = defaults.getTrimFrequency();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getManyProperty",
	"Comment": "return the many property included in the query or null if one is not.",
	"Method": "BeanPropertyAssocMany<?> getManyProperty(SpiQuery<?> query){\r\n    OrmQueryDetail detail = query.getDetail();\r\n    for (BeanPropertyAssocMany<?> aPropertiesMany : propertiesMany) {\r\n        if (detail.includesPath(aPropertiesMany.getName())) {\r\n            return aPropertiesMany;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentQueueX.narrowK",
	"Comment": "convert the raw higher kinded type for pqueue types into the pqueuetype type definition class",
	"Method": "PersistentQueueX<T> narrowK(Higher<persistentQueueX, T> list){\r\n    return (PersistentQueueX<T>) list;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.ExternalJdbcTransaction.commit",
	"Comment": "this will always throw a persistenceexception.externally created connections should be committed or rolled back externally.",
	"Method": "void commit(){\r\n    throw new PersistenceException(\"This is an external transaction so must be committed externally\");\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.docStoreUpdateEmbedded",
	"Comment": "check if this update invalidates an embedded part of a doc store document.",
	"Method": "void docStoreUpdateEmbedded(PersistRequestBean<T> request,DocStoreUpdates docStoreUpdates){\r\n    docStoreAdapter.updateEmbedded(request, docStoreUpdates);\r\n}"
}, {
	"Path": "io.ebeaninternal.api.ManyWhereJoins.isFormulaWithJoin",
	"Comment": "return true if the query select includes a formula with join.",
	"Method": "boolean isFormulaWithJoin(){\r\n    return formulaWithJoin;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.deleteById",
	"Comment": "return sql that can be used to delete by id without any optimisticconcurrency checking.",
	"Method": "SqlUpdate deleteById(Object id,List<Object> idList,DeleteMode mode,SqlUpdate deleteById,Object id,DeleteMode mode){\r\n    String baseSql = mode.isHard() ? deleteByIdSql : softDeleteByIdSql;\r\n    DefaultSqlUpdate sqlDelete = new DefaultSqlUpdate(baseSql);\r\n    Object[] bindValues = idBinder.getBindValues(id);\r\n    for (Object bindValue : bindValues) {\r\n        sqlDelete.setNextParameter(bindValue);\r\n    }\r\n    return sqlDelete;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.SortedSetX.generate",
	"Comment": "generate a sortedsetx from the provided supplier up to the provided limit number of times",
	"Method": "SortedSetX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).sortedSetX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.isDirtyProperty",
	"Comment": "return true if the property was changed or if it is embedded and one of itsembedded properties is dirty.",
	"Method": "boolean isDirtyProperty(int propertyIndex){\r\n    return (flags[propertyIndex] & (FLAG_CHANGED_PROP + FLAG_EMBEDDED_DIRTY)) != 0;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.initialiseId",
	"Comment": "initialise the id properties first.these properties need to be initialised prior to the association propertiesas they are used to get the imported and exported properties.",
	"Method": "void initialiseId(BeanDescriptorInitContext initContext){\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"BeanDescriptor initialise \" + fullName);\r\n    }\r\n    if (draftable) {\r\n        initContext.addDraft(baseTable, draftTable);\r\n    }\r\n    if (historySupport) {\r\n        initContext.addHistory(baseTable, baseTableAsOf);\r\n    }\r\n    if (inheritInfo != null) {\r\n        inheritInfo.setDescriptor(this);\r\n    }\r\n    if (isEmbedded()) {\r\n        for (BeanProperty prop : propertiesAll()) {\r\n            prop.initialise(initContext);\r\n        }\r\n    } else {\r\n        if (idProperty != null) {\r\n            idProperty.initialise(initContext);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.DefaultExpressionList.copy",
	"Comment": "return a copy of the expression list.each of the expressions are expected to be immutable and safe to reference.",
	"Method": "DefaultExpressionList<T> copy(Query<T> query){\r\n    DefaultExpressionList<T> copy = new DefaultExpressionList(query, expr, null);\r\n    copy.list.addAll(list);\r\n    return copy;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setLocalTimeWithNanos",
	"Comment": "set to true if localtime should be persisted with nanos precision.otherwise it is persisted using java.sql.time which is seconds precision.",
	"Method": "void setLocalTimeWithNanos(boolean localTimeWithNanos){\r\n    this.localTimeWithNanos = localTimeWithNanos;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.isVersion",
	"Comment": "return true if this is a version column used for concurrency checking.",
	"Method": "boolean isVersion(){\r\n    return version;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.OrmQueryRequest.getManyProperty",
	"Comment": "return the many property that is fetched in the query or null if there is not one.",
	"Method": "BeanPropertyAssocMany<?> getManyProperty(){\r\n    return manyProperty;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentSetX.rangeLong",
	"Comment": "create a persistentsetx that contains the longs between skip and take",
	"Method": "PersistentSetX<Long> rangeLong(long start,long end){\r\n    return ReactiveSeq.rangeLong(start, end).to(ReactiveConvertableSequence::converter).persistentSetX(LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.getSecondaryTableJoinPrefix",
	"Comment": "returns null unless this property is using a secondary table. in thatcase this returns the logical property prefix.",
	"Method": "String getSecondaryTableJoinPrefix(){\r\n    return secondaryTableJoinPrefix;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.OrmQueryProperties.getSelectProperties",
	"Comment": "this excludes the bean joined properties.this is because bean joins will have there own node in the sqltree.",
	"Method": "Set<String> getSelectProperties(){\r\n    if (secondaryQueryJoins == null) {\r\n        return included;\r\n    }\r\n    LinkedHashSet<String> temp = new LinkedHashSet(2 * (secondaryQueryJoins.size() + included.size()));\r\n    temp.addAll(included);\r\n    temp.addAll(secondaryQueryJoins);\r\n    return temp;\r\n}"
}, {
	"Path": "cyclops.function.Function1.after",
	"Comment": "apply more advice to this function capturing both the input and the emitted with the provided biconsumer",
	"Method": "Function1<T, R> after(BiConsumer<? super T, ? super R> action){\r\n    return FluentFunctions.of(this).after(action);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.DefaultExpressionList.prepareDocNested",
	"Comment": "prepare expressions for document store nested path handling.",
	"Method": "void prepareDocNested(BeanDescriptor<T> beanDescriptor){\r\n    PrepareDocNested.prepare(this, beanDescriptor);\r\n}"
}, {
	"Path": "org.tests.idkeys.TestLazyLoad.testPartialLoad",
	"Comment": "this test loads just a single property of the entity auditlog and later on accessthe description which should force a lazy load of this property",
	"Method": "void testPartialLoad(){\r\n    TOne log = new TOne();\r\n    log.setName(\"test partial\");\r\n    log.setDescription(\"log\");\r\n    server().save(log);\r\n    assertNotNull(log.getId());\r\n    List<TOne> logs = server().find(TOne.class).select(\"id\").where().eq(\"id\", log.getId()).findList();\r\n    assertNotNull(logs);\r\n    assertEquals(1, logs.size());\r\n    TOne logLazy = logs.get(0);\r\n    String description = logLazy.getDescription();\r\n    assertEquals(log.getDescription(), description);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.lib.ShutdownManager.unregisterEbeanServer",
	"Comment": "deregister an ebeanserver.this is done when the ebeanserver is shutdown manually.",
	"Method": "void unregisterEbeanServer(SpiEbeanServer server){\r\n    synchronized (servers) {\r\n        servers.remove(server);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.api.BindParams.buildQueryPlanHash",
	"Comment": "calculate and return a query plan bind hash with total bind count.",
	"Method": "void buildQueryPlanHash(StringBuilder builder){\r\n    int tempBindCount;\r\n    int bc = 0;\r\n    for (Param param : positionedParameters) {\r\n        tempBindCount = param.queryBindCount();\r\n        bc += tempBindCount;\r\n        builder.append(\"p\").append(bc).append(\" ?:\").append(tempBindCount).append(\",\");\r\n    }\r\n    for (Map.Entry<String, Param> entry : namedParameters.entrySet()) {\r\n        tempBindCount = entry.getValue().queryBindCount();\r\n        bc += tempBindCount;\r\n        builder.append(\"n\").append(bc).append(\" k:\").append(entry.getKey()).append(\" ?:\").append(tempBindCount).append(\",\");\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.setEbeanServer",
	"Comment": "set the internal ebeanserver instance to all beandescriptors.",
	"Method": "void setEbeanServer(SpiEbeanServer internalEbean){\r\n    for (BeanDescriptor<?> desc : immutableDescriptorList) {\r\n        desc.setEbeanServer(internalEbean);\r\n    }\r\n}"
}, {
	"Path": "io.ebean.XServiceProvider.fetchGroupOf",
	"Comment": "return the fetchgroupbuilder with the given select clause.",
	"Method": "FetchGroup<T> fetchGroupOf(Class<T> cls,String select,FetchGroupBuilder<T> fetchGroupOf,Class<T> cls){\r\n    return fetchGroupService.of(cls);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanPropertyAssocMany.getFetchOrderBy",
	"Comment": "return the order by clause used to order the fetching of the data forthis list, set or map.",
	"Method": "String getFetchOrderBy(){\r\n    return fetchOrderBy;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DatabasePlatform.getMaxTableNameLength",
	"Comment": "return the maximum table name length.this is used when deriving names of intersection tables.",
	"Method": "int getMaxTableNameLength(){\r\n    return maxTableNameLength;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.isUseIdGenerator",
	"Comment": "return true if this bean type should use idgeneration.if this is false and the id is null it is assumed that a database autoincrement feature is being used to populate the id.",
	"Method": "boolean isUseIdGenerator(){\r\n    return idGenerator != null;\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.getDirtyPropertyKey",
	"Comment": "return a dirty property hash taking into account embedded beans.",
	"Method": "StringBuilder getDirtyPropertyKey(){\r\n    StringBuilder sb = new StringBuilder();\r\n    addDirtyPropertyKey(sb);\r\n    return sb;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.visitor.VisitAllUsing.visitInheritanceProperties",
	"Comment": "visit all the other inheritance properties that are not on the root.",
	"Method": "void visitInheritanceProperties(BeanDescriptor<?> descriptor,BeanPropertyVisitor pv){\r\n    InheritInfo inheritInfo = descriptor.getInheritInfo();\r\n    if (inheritInfo != null && inheritInfo.isRoot()) {\r\n        inheritInfo.visitChildren(new InheritChildVisitor(this, pv));\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setRegister",
	"Comment": "set to false if you do not want this server to be registered with the ebeansingleton when it is created.by default this is set to true.",
	"Method": "void setRegister(boolean register){\r\n    this.register = register;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanPropertyAssocMany.getIntersectionJoin",
	"Comment": "manytomany only, join from local table to intersection table.",
	"Method": "DeployTableJoin getIntersectionJoin(){\r\n    return intersectionJoin;\r\n}"
}, {
	"Path": "io.ebean.config.PlatformConfig.isAllQuotedIdentifiers",
	"Comment": "return true if all db column and table names should use quoted identifiers.",
	"Method": "boolean isAllQuotedIdentifiers(){\r\n    return allQuotedIdentifiers;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.isDeleteByStatement",
	"Comment": "return true if delete can use a single sql statement.this implies cascade delete does not continue depth wise and that this is noassociated l2 bean caching.",
	"Method": "boolean isDeleteByStatement(){\r\n    return persistListener == null && persistController == null && deleteRecurseSkippable && !isBeanCaching();\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.isAutoReadOnlyDataSource",
	"Comment": "return true if ebean should create a datasource for use with implicit read only transactions.",
	"Method": "boolean isAutoReadOnlyDataSource(){\r\n    return autoReadOnlyDataSource;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setPackages",
	"Comment": "set packages to search for entities via class path search.this is only used if classes have not been explicitly specified.",
	"Method": "void setPackages(List<String> packages){\r\n    this.packages = packages;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getDocStoreQueueId",
	"Comment": "return the queueid used to uniquely identify this type when queuing an index updateadd.",
	"Method": "String getDocStoreQueueId(){\r\n    return docStoreQueueId;\r\n}"
}, {
	"Path": "cyclops.function.PartialApplicator.partial4",
	"Comment": "returns a bifunction with 2 arguments applied to the supplied quadfunction",
	"Method": "Supplier<R> partial4(T1 t1,T2 t2,T3 t3,T4 t4,Function4<T1, T2, T3, T4, R> quadFunc,Function<T4, R> partial4,T1 t1,T2 t2,T3 t3,Function4<T1, T2, T3, T4, R> quadFunc,BiFunction<T3, T4, R> partial4,T1 t1,T2 t2,Function4<T1, T2, T3, T4, R> quadFunc,Function3<T2, T3, T4, R> partial4,T1 t1,Function4<T1, T2, T3, T4, R> quadFunc){\r\n    return (t2, t3, t4) -> quadFunc.apply(t1, t2, t3, t4);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.readEntityDeploymentAssociations",
	"Comment": "create the beantable information which has the base table and id.this is determined prior to resolving relationship information.",
	"Method": "void readEntityDeploymentAssociations(){\r\n    for (DeployBeanInfo<?> info : deployInfoMap.values()) {\r\n        readDeployAssociations(info);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.migrationreader.MigrationXmlReader.read",
	"Comment": "read and return a migration from an xml document at the given resource path.",
	"Method": "Migration read(String resourcePath,Migration read,File migrationFile,Migration read,InputStream is){\r\n    try {\r\n        JAXBContext jaxbContext = JAXBContext.newInstance(Migration.class);\r\n        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\r\n        return (Migration) unmarshaller.unmarshal(is);\r\n    } catch (JAXBException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.build.ModelBuildPropertyVisitor.determineForeignKeyConstraintName",
	"Comment": "return the foreign key constraint name given a single column foreign key.",
	"Method": "String determineForeignKeyConstraintName(String columnName){\r\n    return ctx.foreignKeyConstraintName(table.getName(), columnName, ++countForeignKey);\r\n}"
}, {
	"Path": "cyclops.control.Maybe.narrowK",
	"Comment": "convert the raw higher kinded type for maybetype types into the maybetype type definition class",
	"Method": "Maybe<T> narrowK(Higher<option, T> future){\r\n    return Maybe.fromOption(Option.narrowK(future));\r\n}"
}, {
	"Path": "io.ebean.config.DbConstraintNormalise.normaliseColumn",
	"Comment": "normalise the column name by removing any quoted identifier characters.",
	"Method": "String normaliseColumn(String columnName){\r\n    columnName = trimQuotes(columnName);\r\n    if (lowerCaseColumns) {\r\n        columnName = columnName.toLowerCase();\r\n    }\r\n    return columnName;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.VectorX.fill",
	"Comment": "generate a vectorx from the provided value up to the provided limit number of times",
	"Method": "VectorX<T> fill(long limit,T s){\r\n    return ReactiveSeq.fill(s).limit(limit).to(ReactiveConvertableSequence::converter).vectorX(LAZY);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.Value.mkString",
	"Comment": "returns the class name and the name of the subclass, if there is any value, the value is showed between square brackets.",
	"Method": "String mkString(){\r\n    return fold(p -> getClass().getSimpleName() + \"[\" + p + \"]\", () -> getClass().getSimpleName() + \"[]\");\r\n}"
}, {
	"Path": "com.oath.cyclops.react.StageWithResults.submit",
	"Comment": "this method allows the simplereact executor to be reused by jdk parallel streams",
	"Method": "R submit(Function<RS, R> fn,T submit,Callable<T> callable){\r\n    if (taskExecutor instanceof ForkJoinPool) {\r\n        try {\r\n            return ((ForkJoinPool) taskExecutor).submit(callable).get();\r\n        } catch (final ExecutionException e) {\r\n            throw ExceptionSoftener.throwSoftenedException(e);\r\n        } catch (final InterruptedException e) {\r\n            Thread.currentThread().interrupt();\r\n            throw ExceptionSoftener.throwSoftenedException(e);\r\n        }\r\n    }\r\n    try {\r\n        return callable.call();\r\n    } catch (final Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.InternalConfiguration.changeLogRegister",
	"Comment": "return the changelogregister to use with a default implementation if none defined.",
	"Method": "ChangeLogRegister changeLogRegister(ChangeLogRegister register){\r\n    boolean includeInserts = serverConfig.isChangeLogIncludeInserts();\r\n    return plugin((register != null) ? register : new DefaultChangeLogRegister(includeInserts));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQuery.auditIterateLogMessage",
	"Comment": "send the current buffer of finditerate collected ids to the audit log.",
	"Method": "void auditIterateLogMessage(){\r\n    desc.readAuditMany(queryPlan.getAuditQueryKey(), bindLog, auditIds);\r\n    auditIds = null;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DatabasePlatform.isSupportsNativeIlike",
	"Comment": "return true if this database platform supports native ilike expression.",
	"Method": "boolean isSupportsNativeIlike(){\r\n    return supportsNativeIlike;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.DefaultOrmQuery.createQueryPlanKey",
	"Comment": "calculate the query hash for either autotune query tuning or query plan caching.",
	"Method": "CQueryPlanKey createQueryPlanKey(){\r\n    if (isNativeSql()) {\r\n        queryPlanKey = new NativeSqlQueryPlanKey(type.ordinal() + nativeSql + \"-\" + firstRow + \"-\" + maxRows);\r\n    } else {\r\n        queryPlanKey = new OrmQueryPlanKey(planDescription(), maxRows, firstRow, rawSql);\r\n    }\r\n    return queryPlanKey;\r\n}"
}, {
	"Path": "io.ebean.text.json.JsonWriteOptions.setObjectMapper",
	"Comment": "set the jackson object mapper to use.if null the objectmapper from serverconfig will be used.",
	"Method": "void setObjectMapper(Object objectMapper){\r\n    this.objectMapper = objectMapper;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.isAddToUpdate",
	"Comment": "return true if the property should be included in the update.",
	"Method": "boolean isAddToUpdate(BeanProperty prop){\r\n    if (requestUpdateAllLoadedProps) {\r\n        return intercept.isLoadedProperty(prop.getPropertyIndex());\r\n    } else {\r\n        return intercept.isDirtyProperty(prop.getPropertyIndex());\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.setValue",
	"Comment": "set the value of the property without interception orpropertychangesupport.",
	"Method": "void setValue(EntityBean bean,Object value){\r\n    try {\r\n        setter.set(bean, value);\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(setterErrorMsg(bean, value, \"set \"), ex);\r\n    }\r\n}"
}, {
	"Path": "cyclops.control.Unrestricted.forEach4",
	"Comment": "perform a for comprehension over a unrestricted, accepting 3 generating function.this results in a four level nested internal iteration over the provided computationss.",
	"Method": "Unrestricted<R3> forEach4(Function<? super T, ? extends Unrestricted<R1>> value2,BiFunction<? super T, ? super R1, ? extends Unrestricted<R2>> value3,Function3<? super T, ? super R1, ? super R2, ? extends Unrestricted<R3>> value4){\r\n    return this.flatMap(in -> {\r\n        Unrestricted<R1> a = value2.apply(in);\r\n        return a.flatMap(ina -> {\r\n            Unrestricted<R2> b = value3.apply(in, ina);\r\n            return b.flatMap(inb -> {\r\n                Unrestricted<R3> c = value4.apply(in, ina, inb);\r\n                return c;\r\n            });\r\n        });\r\n    });\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.PlatformDdl.isInlineComments",
	"Comment": "return true if the table and column comments are included inline.",
	"Method": "boolean isInlineComments(){\r\n    return inlineComments;\r\n}"
}, {
	"Path": "cyclops.control.Unrestricted.forEach3",
	"Comment": "perform a for comprehension over a unrestricted, accepting 2 generating function.this results in a three level nested internal iteration over the provided computationss.",
	"Method": "Unrestricted<R2> forEach3(Function<? super T, ? extends Unrestricted<R1>> value2,BiFunction<? super T, ? super R1, ? extends Unrestricted<R2>> value3){\r\n    return this.flatMap(in -> {\r\n        Unrestricted<R1> a = value2.apply(in);\r\n        return a.flatMap(ina -> {\r\n            Unrestricted<R2> b = value3.apply(in, ina);\r\n            return b;\r\n        });\r\n    });\r\n}"
}, {
	"Path": "cyclops.control.Unrestricted.forEach2",
	"Comment": "perform a for comprehension over a unrestricted, accepting a generating function.this results in a two level nested internal iteration over the provided computationss.",
	"Method": "Unrestricted<R1> forEach2(Function<? super T, Unrestricted<R1>> value2){\r\n    return this.flatMap(in -> {\r\n        Unrestricted<R1> a = value2.apply(in);\r\n        return a;\r\n    });\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.build.ModelBuildPropertyVisitor.addIndexes",
	"Comment": "add unique constraints defined via jpa uniqueconstraint annotations.",
	"Method": "void addIndexes(IndexDefinition[] indexes){\r\n    if (indexes != null) {\r\n        for (IndexDefinition index : indexes) {\r\n            String[] columns = index.getColumns();\r\n            indexSet.add(columns);\r\n            if (index.isUnique()) {\r\n                String uqName = index.getName();\r\n                if (uqName == null || uqName.trim().isEmpty()) {\r\n                    uqName = determineUniqueConstraintName(columns);\r\n                }\r\n                table.addUniqueConstraint(columns, false, uqName);\r\n            } else {\r\n                String idxName = index.getName();\r\n                if (idxName == null || idxName.trim().isEmpty()) {\r\n                    idxName = determineIndexName(columns);\r\n                }\r\n                ctx.addIndex(idxName, table.getName(), columns);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.TransactionManager.getInScope",
	"Comment": "return the current transaction from thread local scope. note that it may be inactive.",
	"Method": "SpiTransaction getInScope(){\r\n    return scopeManager.getInScope();\r\n}"
}, {
	"Path": "chapter07priorityqueues.BinaryHeap.buildHeap",
	"Comment": "establish heap order property from an arbitrary arrangement of items. runs in linear time.",
	"Method": "void buildHeap(){\r\n    for (int i = currentSize / 2; i > 0; i--) percolateDown(i);\r\n}"
}, {
	"Path": "io.ebeaninternal.api.SpiExpressionValidation.getUnknownProperties",
	"Comment": "return the set of properties considered as having unknown paths.",
	"Method": "Set<String> getUnknownProperties(){\r\n    return unknown;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.type.DefaultTypeManager.initialiseJodaTypes",
	"Comment": "detect if joda classes are in the classpath and if so register the joda data types.",
	"Method": "void initialiseJodaTypes(JsonConfig.DateTime mode,ServerConfig config){\r\n    if (config.getClassLoadConfig().isJodaTimePresent()) {\r\n        logger.debug(\"Registering Joda data types\");\r\n        addType(LocalDateTime.class, new ScalarTypeJodaLocalDateTime(mode));\r\n        addType(DateTime.class, new ScalarTypeJodaDateTime(mode));\r\n        addType(LocalDate.class, new ScalarTypeJodaLocalDate());\r\n        addType(org.joda.time.DateMidnight.class, new ScalarTypeJodaDateMidnight());\r\n        addType(org.joda.time.Period.class, new ScalarTypeJodaPeriod());\r\n        String jodaLocalTimeMode = config.getJodaLocalTimeMode();\r\n        if (\"normal\".equalsIgnoreCase(jodaLocalTimeMode)) {\r\n            addType(LocalTime.class, new ScalarTypeJodaLocalTime());\r\n            logger.debug(\"registered ScalarTypeJodaLocalTime\");\r\n        } else if (\"utc\".equalsIgnoreCase(jodaLocalTimeMode)) {\r\n            addType(LocalTime.class, new ScalarTypeJodaLocalTimeUTC());\r\n            logger.debug(\"registered ScalarTypeJodaLocalTimeUTC\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorCacheHelp.loadBeanDirect",
	"Comment": "load the entity bean from cache data given this is the root bean type.",
	"Method": "EntityBean loadBeanDirect(Object id,Boolean readOnly,CachedBeanData data,PersistenceContext context){\r\n    if (context == null) {\r\n        context = new DefaultPersistenceContext();\r\n    }\r\n    EntityBean bean = desc.createEntityBean();\r\n    id = desc.convertSetId(id, bean);\r\n    CachedBeanDataToBean.load(desc, bean, data, context);\r\n    EntityBeanIntercept ebi = bean._ebean_getIntercept();\r\n    ebi.setBeanLoader(desc.getEbeanServer());\r\n    if (Boolean.TRUE.equals(readOnly)) {\r\n        ebi.setReadOnly(true);\r\n    }\r\n    ebi.setPersistenceContext(context);\r\n    desc.contextPut(context, id, bean);\r\n    if (desc.isReadAuditing()) {\r\n        desc.readAuditBean(\"l2\", \"\", bean);\r\n    }\r\n    return bean;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanTable.getBaseTable",
	"Comment": "return the base table for this beantable.this is used to determine the join informationfor associations.",
	"Method": "String getBaseTable(){\r\n    return baseTable;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.postLoad",
	"Comment": "execute the postload if a beanpostload exists for this bean.",
	"Method": "void postLoad(Object bean){\r\n    if (beanPostLoad != null) {\r\n        beanPostLoad.postLoad(bean);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.ImplicitReadOnlyTransaction.setPersistenceContext",
	"Comment": "set the persistence context to this transaction.this could be considered similar to ejb3 extended persistancecontext. inthat you get the persistancecontext from a transaction, hold onto it, andthen set it back later to a second transaction.",
	"Method": "void setPersistenceContext(PersistenceContext context){\r\n    if (!isActive()) {\r\n        throw new IllegalStateException(illegalStateMessage);\r\n    }\r\n    this.persistenceContext = context;\r\n}"
}, {
	"Path": "cyclops.control.LazyEither.traverseRight",
	"Comment": "traverseops a collection of either producting an either3 with a seq, applying the transformation function to everyelement in the list",
	"Method": "LazyEither<LT1, ReactiveSeq<R>> traverseRight(Iterable<LazyEither<LT1, PT>> xors,Function<? super PT, ? extends R> fn){\r\n    return sequenceRight(xors).map(l -> l.map(fn));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.BatchControl.setGetGeneratedKeys",
	"Comment": "set whether or not to use getgeneratedkeys for this batch execution.the user can set this via the transaction",
	"Method": "void setGetGeneratedKeys(Boolean getGeneratedKeys){\r\n    if (getGeneratedKeys != null) {\r\n        this.getGeneratedKeys = getGeneratedKeys;\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.derivePropertiesToUnload",
	"Comment": "derive an array of property positions for properties that are initialised in the constructor.these properties need to be unloaded when populating beans for queries.",
	"Method": "int[] derivePropertiesToUnload(EntityBean prototypeEntityBean){\r\n    boolean[] loaded = prototypeEntityBean._ebean_getIntercept().getLoaded();\r\n    int[] props = new int[loaded.length];\r\n    int pos = 0;\r\n    for (int i = 0; i < loaded.length; i++) {\r\n        if (loaded[i]) {\r\n            props[pos++] = i;\r\n        }\r\n    }\r\n    if (pos == 0) {\r\n        return new int[0];\r\n    }\r\n    int[] unload = new int[pos];\r\n    System.arraycopy(props, 0, unload, 0, pos);\r\n    return unload;\r\n}"
}, {
	"Path": "chapter06trees.BinaryTreeNode.hashCode",
	"Comment": "computes a hash code for the complete binary tree rooted at this binarytreenode node.",
	"Method": "int hashCode(){\r\n    int result = this.hashCode();\r\n    if (left != null) {\r\n        result += 3 * left.hashCode();\r\n    }\r\n    if (right != null) {\r\n        result += 7 * right.hashCode();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "io.ebeaninternal.api.TransactionEvent.obtainCacheChangeSet",
	"Comment": "return the cachechangeset that we add cache notification messages to.we want to add to this change set as we process requests allowing thepersistrequestbean to be garbage collected for large transactions.",
	"Method": "CacheChangeSet obtainCacheChangeSet(){\r\n    if (changeSet == null) {\r\n        changeSet = new CacheChangeSet(startMillis);\r\n    }\r\n    return changeSet;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DbPlatformTypeMapping.lookup",
	"Comment": "lookup the platform specific dbtype given the standard sql type name.",
	"Method": "DbPlatformType lookup(String name,boolean withScale){\r\n    DbType type = lookup.byName(name);\r\n    if (type == null) {\r\n        throw new IllegalArgumentException(\"Unknown type [\" + name + \"] - not standard sql type\");\r\n    }\r\n    switch(type) {\r\n        case JSONBLOB:\r\n            return get(DbType.BLOB);\r\n        case JSONCLOB:\r\n            return get(DbType.CLOB);\r\n        case JSONVARCHAR:\r\n            return get(DbType.VARCHAR);\r\n        case JSON:\r\n            return getJsonType(DbType.JSON, withScale);\r\n        case JSONB:\r\n            return getJsonType(DbType.JSONB, withScale);\r\n        default:\r\n            return get(type);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getDocStoreMode",
	"Comment": "return the type of docstoremode that should occur for this type of persist requestgiven the transactions requested mode.",
	"Method": "DocStoreMode getDocStoreMode(PersistRequest.Type persistType,DocStoreMode txnMode){\r\n    return docStoreAdapter.getMode(persistType, txnMode);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.bootup.DistillPackages.notAlreadyContained",
	"Comment": "return true if the package is not already contained in the distilled list.",
	"Method": "boolean notAlreadyContained(List<String> distilled,String pack){\r\n    for (String aDistilled : distilled) {\r\n        if (pack.startsWith(aDistilled)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.DequeX.iterate",
	"Comment": "create a dequex by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "DequeX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).dequeX(LAZY);\r\n}"
}, {
	"Path": "cyclops.typeclasses.foldable.Foldable.foldRight",
	"Comment": "starting from the right combine each value in turn with an accumulator",
	"Method": "T foldRight(Monoid<T> monoid,Higher<CRE, T> ds,T foldRight,T identity,BinaryOperator<T> semigroup,Higher<CRE, T> ds){\r\n    return foldRight(Monoid.fromBiFunction(identity, semigroup), ds);\r\n}"
}, {
	"Path": "cyclops.futurestream.SimpleReact.from",
	"Comment": "construct a simplereactstream from an array of completablefutures",
	"Method": "SimpleReactStream<U> from(Stream<U> stream,SimpleReactStream<R> from,Collection<R> collection,SimpleReactStream<U> from,Iterator<U> iterator,SimpleReactStream<Integer> from,IntStream stream,SimpleReactStream<Double> from,DoubleStream stream,SimpleReactStream<Long> from,LongStream stream,SimpleReactStream<U> from,CompletableFuture<U> cf,SimpleReactStream<U> from,CompletableFuture<U> cf){\r\n    return this.construct(Stream.of(cf));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.OrmQueryRequest.getQueryPlanKey",
	"Comment": "return the queryplanhash.this identifies the query plan for a given bean type. it effectivelymatches a sql statement with ? bind variables. a query plan can be reusedwith just the bind variables changing.",
	"Method": "CQueryPlanKey getQueryPlanKey(){\r\n    return queryPlanKey;\r\n}"
}, {
	"Path": "io.ebean.config.DocStoreConfig.getUsername",
	"Comment": "return the user credential for connecting to the document store.",
	"Method": "String getUsername(){\r\n    return username;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.ModelContainer.registerPendingDropColumn",
	"Comment": "register a drop column on a history tables that has not been applied yet.",
	"Method": "void registerPendingDropColumn(DropColumn dropColumn){\r\n    MTable table = getTable(dropColumn.getTableName());\r\n    if (table == null) {\r\n        throw new IllegalArgumentException(\"Table [\" + dropColumn.getTableName() + \"] not found?\");\r\n    }\r\n    table.registerPendingDropColumn(dropColumn.getColumnName());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.findPropertyFromPath",
	"Comment": "return the bean property traversing the object graph and taking intoaccount inheritance.",
	"Method": "BeanProperty findPropertyFromPath(String path){\r\n    BeanDescriptor<?> other = this;\r\n    while (true) {\r\n        String[] split = SplitName.splitBegin(path);\r\n        if (split[1] == null) {\r\n            return other._findBeanProperty(split[0]);\r\n        }\r\n        BeanPropertyAssoc<?> assocProp = (BeanPropertyAssoc<?>) other._findBeanProperty(split[0]);\r\n        BeanDescriptor<?> targetDesc = assocProp.getTargetDescriptor();\r\n        path = split[1];\r\n        other = targetDesc;\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocMany.addBeanToCollectionWithCreate",
	"Comment": "add the bean to the appropriate collection on the parent bean.",
	"Method": "void addBeanToCollectionWithCreate(EntityBean parentBean,EntityBean detailBean,boolean withCheck){\r\n    BeanCollection<?> bc = (BeanCollection<?>) super.getValue(parentBean);\r\n    if (bc == null) {\r\n        bc = help.createEmpty(parentBean);\r\n        setValue(parentBean, bc);\r\n    }\r\n    help.add(bc, detailBean, withCheck);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.QueueX.iterate",
	"Comment": "create a queuex by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "QueueX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).queueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQueryBuilder.assocOneIdPath",
	"Comment": "return a path for a foreign key property using the default naming convention.",
	"Method": "String assocOneIdPath(String propertyName){\r\n    return propertyName.substring(0, propertyName.length() - 2) + \".id\";\r\n}"
}, {
	"Path": "cyclops.function.Function0.iterate",
	"Comment": "use the value stored in this value to seed a stream generated from the provided function",
	"Method": "ReactiveSeq<R> iterate(UnaryOperator<R> fn){\r\n    return ReactiveSeq.iterate(get(), fn);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.build.ModelBuildBeanVisitor.visitBean",
	"Comment": "return the propertyvisitor used to read all the property meta dataand in this case add mcolumn objects to the model.this creates an mtable and adds it to the model.",
	"Method": "ModelBuildPropertyVisitor visitBean(BeanDescriptor<?> descriptor){\r\n    if (!descriptor.isInheritanceRoot()) {\r\n        return null;\r\n    }\r\n    MTable table = new MTable(descriptor.getBaseTable());\r\n    table.setPartitionMeta(descriptor.getPartitionMeta());\r\n    table.setComment(descriptor.getDbComment());\r\n    if (descriptor.isHistorySupport()) {\r\n        table.setWithHistory(true);\r\n        BeanProperty whenCreated = descriptor.getWhenCreatedProperty();\r\n        if (whenCreated != null) {\r\n            table.setWhenCreatedColumn(whenCreated.getDbColumn());\r\n        }\r\n    }\r\n    setIdentity(descriptor, table);\r\n    ctx.addTable(table);\r\n    InheritInfo inheritInfo = descriptor.getInheritInfo();\r\n    if (inheritInfo != null && inheritInfo.isRoot()) {\r\n        String discColumn = inheritInfo.getDiscriminatorColumn();\r\n        String columnDefn = inheritInfo.getColumnDefn();\r\n        if (columnDefn == null || columnDefn.isEmpty()) {\r\n            DbPlatformType dbType = ctx.getDbTypeMap().get(inheritInfo.getDiscriminatorType());\r\n            columnDefn = dbType.renderType(inheritInfo.getColumnLength(), 0);\r\n        }\r\n        table.addColumn(new MColumn(discColumn, columnDefn, true));\r\n    }\r\n    return new ModelBuildPropertyVisitor(ctx, table, descriptor);\r\n}"
}, {
	"Path": "io.ebean.config.DocStoreConfig.setGenerateMapping",
	"Comment": "set to true if ebean should generate mapping files on server startup.",
	"Method": "void setGenerateMapping(boolean generateMapping){\r\n    this.generateMapping = generateMapping;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.setSoftDeleteValue",
	"Comment": "set the soft delete property value on the bean without invoking lazy loading.",
	"Method": "void setSoftDeleteValue(EntityBean bean){\r\n    setValue(bean, true);\r\n    bean._ebean_getIntercept().setChangedProperty(propertyIndex);\r\n}"
}, {
	"Path": "cyclops.monads.collections.AbstractAnyMSeqTest.prependAppend",
	"Comment": "prepends, append,append,prependall,prependall,insertat,deletebetween,insertats,recover",
	"Method": "void prependAppend(){\r\n    assertThat(of(1).prependStream(Stream.of(2)).append(3).prepend(4).appendAll(5, 6).prependAll(7, 8).insertAt(4, 9).deleteBetween(1, 2).insertStreamAt(5, Stream.of(11, 12)).stream().count(), equalTo(10L));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanProperty.getGeneratedProperty",
	"Comment": "return the generatedvalue. used to generate update timestamp etc.",
	"Method": "GeneratedProperty getGeneratedProperty(){\r\n    return generatedProperty;\r\n}"
}, {
	"Path": "io.ebean.text.json.EJson.parseSet",
	"Comment": "parse the json returning as a set taking into account the current token.",
	"Method": "Set<T> parseSet(String json,boolean modifyAware,Set<T> parseSet,JsonParser parser,JsonToken currentToken){\r\n    return plugin.parseSet(parser, currentToken);\r\n}"
}, {
	"Path": "cyclops.function.Memoize.memoizeTriFunctionAsync",
	"Comment": "memoize a function and update the cached values asynchronously using the provided scheduled executor servicedoes not support null keys",
	"Method": "Function3<T1, T2, T3, R> memoizeTriFunctionAsync(Function3<T1, T2, T3, R> fn,ScheduledExecutorService ex,String cron,Function3<T1, T2, T3, R> memoizeTriFunctionAsync,Function3<T1, T2, T3, R> fn,ScheduledExecutorService ex,long updateRateInMillis){\r\n    Function1<Tuple3<T1, T2, T3>, R> memoise2 = memoizeFunctionAsync((final Tuple3<T1, T2, T3> triple) -> fn.apply(triple._1(), triple._2(), triple._3()), ex, updateRateInMillis);\r\n    return (t1, t2, t3) -> memoise2.apply(tuple(t1, t2, t3));\r\n}"
}, {
	"Path": "io.ebean.common.BeanList.equals",
	"Comment": "equal if obj is a list and equal in a list sense.specifically obj does not need to be a beanlist but any list. this does notuse the findmany, fetchedmaxrows or finishedfetch properties in the equalstest.",
	"Method": "boolean equals(Object obj){\r\n    init();\r\n    return list.equals(obj);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXEvents",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription,when the entire stream has been processed an oncomplete event will be recieved.",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXEvents(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError,Runnable onComplete){\r\n    final CompletableFuture<Subscription> subscription = new CompletableFuture();\r\n    final CompletableFuture<Boolean> streamCompleted = new CompletableFuture();\r\n    return tuple(subscription, () -> {\r\n        stream.subscribe(new Subscriber<T>() {\r\n            @Override\r\n            public void onSubscribe(final Subscription s) {\r\n                Objects.requireNonNull(s);\r\n                if (x != 0)\r\n                    s.request(x);\r\n                subscription.complete(s);\r\n            }\r\n            @Override\r\n            public void onNext(final T t) {\r\n                consumerElement.accept(t);\r\n            }\r\n            @Override\r\n            public void onError(final Throwable t) {\r\n                consumerError.accept(t);\r\n            }\r\n            @Override\r\n            public void onComplete() {\r\n                streamCompleted.complete(true);\r\n                onComplete.run();\r\n            }\r\n        });\r\n    }, streamCompleted);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXEvents",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription,when the entire stream has been processed an oncomplete event will be recieved.",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXEvents(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError,Runnable onComplete){\r\n    Objects.requireNonNull(s);\r\n    if (x != 0)\r\n        s.request(x);\r\n    subscription.complete(s);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXEvents",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription,when the entire stream has been processed an oncomplete event will be recieved.",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXEvents(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError,Runnable onComplete){\r\n    consumerElement.accept(t);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXEvents",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription,when the entire stream has been processed an oncomplete event will be recieved.",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXEvents(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError,Runnable onComplete){\r\n    consumerError.accept(t);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXEvents",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription,when the entire stream has been processed an oncomplete event will be recieved.",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXEvents(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError,Runnable onComplete){\r\n    streamCompleted.complete(true);\r\n    onComplete.run();\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.setReadOnly",
	"Comment": "set the readonly status. if readonly then calls to setter methods throughan exception.",
	"Method": "void setReadOnly(boolean readOnly){\r\n    this.readOnly = readOnly;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQuery.auditNextBean",
	"Comment": "add the id to the audit id buffer and flush if needed in batches of 100.",
	"Method": "void auditNextBean(){\r\n    if (auditIds == null) {\r\n        auditIds = new ArrayList(100);\r\n    }\r\n    auditIds.add(desc.getIdForJson(nextBean));\r\n    if (auditFindIterate && auditIds.size() >= 100) {\r\n        auditIterateLogMessage();\r\n    }\r\n}"
}, {
	"Path": "cyclops.monads.transformers.FutureT.of",
	"Comment": "construct an futuret from an anym that wraps a monad containingfutures",
	"Method": "FutureT<W, A> of(AnyM<W, Future<A>> monads){\r\n    return new FutureT(monads);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanDescriptor.parse",
	"Comment": "parse the aggregation formula into expressions with table alias placeholders.",
	"Method": "String parse(String aggregation){\r\n    return new Parser(this).parse(aggregation);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanDescriptor.getDefaultSelectClause",
	"Comment": "return the defaultselectclause using fetchtype.lazy and fetchtype.eager.",
	"Method": "String getDefaultSelectClause(){\r\n    StringBuilder sb = new StringBuilder();\r\n    boolean hasLazyFetch = false;\r\n    for (DeployBeanProperty prop : propMap.values()) {\r\n        if (!prop.isTransient() && !(prop instanceof DeployBeanPropertyAssocMany<?>)) {\r\n            if (prop.isFetchEager()) {\r\n                sb.append(prop.getName()).append(\",\");\r\n            } else {\r\n                hasLazyFetch = true;\r\n            }\r\n        }\r\n    }\r\n    if (!hasLazyFetch) {\r\n        return null;\r\n    }\r\n    String selectClause = sb.toString();\r\n    if (selectClause.isEmpty()) {\r\n        throw new IllegalStateException(\"Bean \" + getFullName() + \" has no properties?\");\r\n    }\r\n    return selectClause.substring(0, selectClause.length() - 1);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanPropertyAssoc.getTargetDeploy",
	"Comment": "return the target deploybeandescriptor for this associated bean property.",
	"Method": "DeployBeanDescriptor<?> getTargetDeploy(){\r\n    return desc.getDeploy(targetType).getDescriptor();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.DefaultExpressionList.wrap",
	"Comment": "wrap the expression list as a junction or top level defaultexpressionlist.",
	"Method": "SpiExpression wrap(List<SpiExpression> list,String nestedPath,Junction.Type type){\r\n    DefaultExpressionList<T> wrapper = new DefaultExpressionList(query, expr, null, list, false);\r\n    wrapper.setAllDocNested(nestedPath);\r\n    if (type != null) {\r\n        return new JunctionExpression(type, wrapper);\r\n    } else {\r\n        return wrapper;\r\n    }\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.LinkedListX.generate",
	"Comment": "generate a linkedlistx from the provided supplier up to the provided limit number of times",
	"Method": "LinkedListX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).linkedListX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getEbeanServer",
	"Comment": "return the ebeanserver instance that owns this beandescriptor.",
	"Method": "SpiEbeanServer getEbeanServer(){\r\n    return ebeanServer;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultContainer.createServer",
	"Comment": "create the server reading configuration information from ebean.properties.",
	"Method": "SpiEbeanServer createServer(String name,SpiEbeanServer createServer,ServerConfig serverConfig){\r\n    synchronized (this) {\r\n        if (serverConfig.isDefaultServer()) {\r\n            for (ServerConfigProvider configProvider : ServiceLoader.load(ServerConfigProvider.class)) {\r\n                configProvider.apply(serverConfig);\r\n            }\r\n        }\r\n        setNamingConvention(serverConfig);\r\n        BootupClasses bootupClasses = getBootupClasses(serverConfig);\r\n        boolean online = true;\r\n        if (serverConfig.isDocStoreOnly()) {\r\n            serverConfig.setDatabasePlatform(new H2Platform());\r\n        } else {\r\n            TenantMode tenantMode = serverConfig.getTenantMode();\r\n            if (TenantMode.DB != tenantMode) {\r\n                setDataSource(serverConfig);\r\n                if (!tenantMode.isDynamicDataSource()) {\r\n                    online = checkDataSource(serverConfig);\r\n                }\r\n            }\r\n        }\r\n        setDatabasePlatform(serverConfig);\r\n        if (serverConfig.getDbEncrypt() != null) {\r\n            serverConfig.getDatabasePlatform().setDbEncrypt(serverConfig.getDbEncrypt());\r\n        }\r\n        serverConfig.getNamingConvention().setDatabasePlatform(serverConfig.getDatabasePlatform());\r\n        SpiBackgroundExecutor executor = createBackgroundExecutor(serverConfig);\r\n        InternalConfiguration c = new InternalConfiguration(online, clusterManager, executor, serverConfig, bootupClasses);\r\n        DefaultServer server = new DefaultServer(c, c.cacheManager());\r\n        if (!DbOffline.isGenerateMigration()) {\r\n            server.executePlugins(online);\r\n            server.initialise();\r\n            if (online) {\r\n                if (clusterManager.isClustering()) {\r\n                    clusterManager.registerServer(server);\r\n                }\r\n            }\r\n            server.start();\r\n        }\r\n        DbOffline.reset();\r\n        return server;\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.diff",
	"Comment": "populate diff map comparing the property values between the beans.",
	"Method": "void diff(String prefix,Map<String, ValuePair> map,EntityBean newBean,EntityBean oldBean){\r\n    Object newVal = (newBean == null) ? null : getValue(newBean);\r\n    Object oldVal = (oldBean == null) ? null : getValue(oldBean);\r\n    diffVal(prefix, map, newVal, oldVal);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.bindId",
	"Comment": "bind the idvalue to the preparedstatement.this takes care of the various id types such as embedded beans etc.",
	"Method": "void bindId(DataBind dataBind,Object idValue){\r\n    idBinder.bindId(dataBind, idValue);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.cachePersistTableIUD",
	"Comment": "invalidate parts of cache due to sqlupdate or external modification etc.",
	"Method": "void cachePersistTableIUD(TableIUD tableIUD,CacheChangeSet changeSet){\r\n    cacheHelp.persistTableIUD(tableIUD, changeSet);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.BasicTypeConverter.toBoolean",
	"Comment": "convert the value to a boolean with an explicit string true value.",
	"Method": "Boolean toBoolean(Object value,String dbTrueValue,Boolean toBoolean,Object value){\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    if (value instanceof Boolean) {\r\n        return (Boolean) value;\r\n    }\r\n    return Boolean.valueOf(value.toString());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.DefaultSqlRow.asKey",
	"Comment": "keys internally always lower cased to take out differences in database dictionaries.",
	"Method": "Object asKey(Object name){\r\n    return ((String) name).toLowerCase();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.dml.DmlHandler.getPstmt",
	"Comment": "return a prepared statement taking into account batch requirements.",
	"Method": "PreparedStatement getPstmt(SpiTransaction t,String sql,boolean genKeys,PreparedStatement getPstmt,SpiTransaction t,String sql,PersistRequestBean<?> request,boolean genKeys){\r\n    BatchedPstmtHolder batch = t.getBatchControl().getPstmtHolder();\r\n    batchedPstmt = batch.getBatchedPstmt(sql, request);\r\n    if (batchedPstmt != null) {\r\n        return batchedPstmt.getStatement();\r\n    }\r\n    PreparedStatement stmt = getPstmt(t, sql, genKeys);\r\n    batchedPstmt = new BatchedPstmt(stmt, genKeys, sql, t);\r\n    batch.addStmt(batchedPstmt, request);\r\n    return stmt;\r\n}"
}, {
	"Path": "cyclops.monads.transformers.ListT.fromAnyM",
	"Comment": "construct an listt from an anym that contains a monad type that contains type other than listthe values in the underlying monad will be mapped to list",
	"Method": "ListT<W, A> fromAnyM(AnyM<W, A> anyM){\r\n    AnyM<W, ListX<A>> y = anyM.map(i -> ListX.of(i));\r\n    return of(y);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.dml.InsertHandler.getPstmt",
	"Comment": "check with usegeneratedkeys to get appropriate preparedstatement.",
	"Method": "PreparedStatement getPstmt(SpiTransaction t,String sql,boolean useGeneratedKeys){\r\n    Connection conn = t.getInternalConnection();\r\n    if (useGeneratedKeys) {\r\n        return conn.prepareStatement(sql, meta.getIdentityDbColumns());\r\n    } else {\r\n        return conn.prepareStatement(sql);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.autotune.service.BaseQueryTuner.get",
	"Comment": "return the detail currently used for tuning.this returns null if there is currently no matching tuning.",
	"Method": "OrmQueryDetail get(String key){\r\n    TunedQueryInfo info = tunedQueryInfoMap.get(key);\r\n    return (info == null) ? null : info.getTunedDetail();\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.newPlatformConfig",
	"Comment": "create a new platformconfig based of the one held but with overridden properties by readingproperties with the given path and prefix.typically used in db migration generation for many platform targets that might have differentconfiguration for idtype, uuid, quoted identifiers etc.",
	"Method": "PlatformConfig newPlatformConfig(String propertiesPath,String platformPrefix){\r\n    if (properties == null) {\r\n        properties = new Properties();\r\n    }\r\n    PropertiesWrapper p = new PropertiesWrapper(propertiesPath, platformPrefix, properties, classLoadConfig);\r\n    PlatformConfig config = new PlatformConfig(platformConfig);\r\n    config.loadSettings(p);\r\n    return config;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssoc.createImportedId",
	"Comment": "build the list of imported property. matches beanproperty from the targetdescriptor back to local database columns in the tablejoin.",
	"Method": "ImportedId createImportedId(BeanPropertyAssoc<?> owner,BeanDescriptor<?> target,TableJoin join){\r\n    BeanProperty idProp = target.getIdProperty();\r\n    BeanProperty[] others = target.propertiesBaseScalar();\r\n    if (descriptor.isRawSqlBased()) {\r\n        String dbColumn = owner.getDbColumn();\r\n        return new ImportedIdSimple(owner, dbColumn, null, idProp, 0);\r\n    }\r\n    TableJoinColumn[] cols = join.columns();\r\n    if (idProp == null) {\r\n        return null;\r\n    }\r\n    if (!idProp.isEmbedded()) {\r\n        if (cols.length != 1) {\r\n            String msg = \"No Imported Id column for [\" + idProp + \"] in table [\" + join.getTable() + \"]\";\r\n            logger.error(msg);\r\n            return null;\r\n        } else {\r\n            BeanProperty[] idProps = { idProp };\r\n            return createImportedScalar(owner, cols[0], idProps, others);\r\n        }\r\n    } else {\r\n        BeanPropertyAssocOne<?> embProp = (BeanPropertyAssocOne<?>) idProp;\r\n        BeanProperty[] embBaseProps = embProp.getTargetDescriptor().propertiesBaseScalar();\r\n        ImportedIdSimple[] scalars = createImportedList(owner, cols, embBaseProps, others);\r\n        return new ImportedIdEmbedded(owner, embProp, scalars);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanDescriptor.getInheritInfo",
	"Comment": "returns the inheritance mapping information. this will be null if this typeof bean is not involved in any orm inheritance mapping.",
	"Method": "InheritInfo getInheritInfo(){\r\n    return inheritInfo;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setBackgroundExecutorShutdownSecs",
	"Comment": "set the background executor shutdown seconds. this is the time allowed for the pool to shutdown nicelybefore it is forced shutdown.",
	"Method": "void setBackgroundExecutorShutdownSecs(int backgroundExecutorShutdownSecs){\r\n    this.backgroundExecutorShutdownSecs = backgroundExecutorShutdownSecs;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.isExplicitTransactionBeginMode",
	"Comment": "return true if transaction begin should be started with explicit statement.",
	"Method": "boolean isExplicitTransactionBeginMode(){\r\n    return explicitTransactionBeginMode;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQuery.isAutoTuneProfiling",
	"Comment": "should we create profilenodes for beans created in this query.this is true for all queries except lazy load bean queries.",
	"Method": "boolean isAutoTuneProfiling(){\r\n    return autoTuneProfiling && query.isUsageProfiling();\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.DefaultDbMigration.setServer",
	"Comment": "set the server to use to determine the current model.typically this is not called explicitly.",
	"Method": "void setServer(EbeanServer ebeanServer){\r\n    this.server = (SpiEbeanServer) ebeanServer;\r\n    setServerConfig(server.getServerConfig());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.text.json.ReadJson.readValueUsingObjectMapper",
	"Comment": "read the property value using jackson objectmapper.typically this is used to read transient properties where the type is unknown to ebean.",
	"Method": "Object readValueUsingObjectMapper(Class<?> propertyType){\r\n    return getObjectMapper().readValue(parser, propertyType);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.MergeHandler.fetchOutline",
	"Comment": "fetch the outline bean with associated one and associated many beans loaded with id values only.we use the id values to determine what are inserts, updates and deletes as part of the merge.",
	"Method": "EntityBean fetchOutline(Set<String> paths){\r\n    Query<?> query = server.find(desc.getBeanType());\r\n    query.setBeanCacheMode(CacheMode.OFF);\r\n    query.setPersistenceContextScope(PersistenceContextScope.QUERY);\r\n    query.setId(desc.getId(bean));\r\n    query.select(desc.getIdProperty().getName());\r\n    for (String path : paths) {\r\n        MergeNode node = buildNode(path);\r\n        node.addSelectId(query);\r\n    }\r\n    return (EntityBean) server.findOne(query, transaction);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.isDisableLazyLoading",
	"Comment": "return true if lazy loading is disabled on queries by default.",
	"Method": "boolean isDisableLazyLoading(){\r\n    return disableLazyLoading;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanDescriptor.propertiesAssocOne",
	"Comment": "return an iterator of beanpropertyassocone that are not embedded. these areeffectively joined beans. for manytoone and onetoone associations.",
	"Method": "List<DeployBeanPropertyAssocOne<?>> propertiesAssocOne(){\r\n    ArrayList<DeployBeanPropertyAssocOne<?>> list = new ArrayList();\r\n    for (DeployBeanProperty prop : propMap.values()) {\r\n        if (prop instanceof DeployBeanPropertyAssocOne<?>) {\r\n            if (!prop.isEmbedded()) {\r\n                list.add((DeployBeanPropertyAssocOne<?>) prop);\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.ChainedBeanPersistListener.register",
	"Comment": "register a new beanpersistlistener and return the resulting chain.",
	"Method": "ChainedBeanPersistListener register(BeanPersistListener c){\r\n    if (list.contains(c)) {\r\n        return this;\r\n    } else {\r\n        List<BeanPersistListener> newList = new ArrayList(list);\r\n        newList.add(c);\r\n        return new ChainedBeanPersistListener(newList);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.MTable.clearForeignKeyIndexes",
	"Comment": "clear the indexes on the foreign keys as they are covered by unique constraints.",
	"Method": "void clearForeignKeyIndexes(){\r\n    for (MCompoundForeignKey compoundKey : compoundKeys) {\r\n        compoundKey.setIndexName(null);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getServerName",
	"Comment": "return the name of the server this beandescriptor belongs to.",
	"Method": "String getServerName(){\r\n    return serverName;\r\n}"
}, {
	"Path": "cyclops.companion.Streams.cycle",
	"Comment": "create a stream that infiniteable cycles the provided streamable",
	"Method": "Stream<U> cycle(Stream<U> s,Stream<U> cycle,Streamable<U> s,Stream<U> cycle,long times,Streamable<U> s){\r\n    return Stream.iterate(s.stream(), s1 -> s.stream()).limit(times).flatMap(Function.identity());\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.MCompoundForeignKey.setIndexName",
	"Comment": "set the associated index name. note that setting to null has the effectof indicating an associated index should not be created for this foreign key.",
	"Method": "void setIndexName(String indexName){\r\n    this.indexName = indexName;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.OrmQueryRequest.isAuditReads",
	"Comment": "return true if read auditing is on for this query request.this means that read audit is on for this bean type and that query has not explicitly disabled it.",
	"Method": "boolean isAuditReads(){\r\n    return beanDescriptor.isReadAuditing() && !query.isDisableReadAudit();\r\n}"
}, {
	"Path": "io.ebean.Expr.exampleLike",
	"Comment": "create the query by example expression specifying more options.",
	"Method": "ExampleExpression exampleLike(Object example,ExampleExpression exampleLike,Object example,boolean caseInsensitive,LikeType likeType){\r\n    return Ebean.getExpressionFactory().exampleLike(example, caseInsensitive, likeType);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.EagerFutureStreamFunctions.firstOf",
	"Comment": "return first stream out of provided streams that starts emitted results",
	"Method": "SimpleReactStream<U> firstOf(SimpleReactStream<U> futureStreams){\r\n    final List<Tuple2<SimpleReactStream<U>, QueueReader>> racers = Stream.of(futureStreams).map(s -> Tuple.tuple(s, new Queue.QueueReader(s.toQueue(), null))).collect(Collectors.toList());\r\n    while (true) {\r\n        for (final Tuple2<SimpleReactStream<U>, Queue.QueueReader> q : racers) {\r\n            if (q._2().notEmpty()) {\r\n                EagerFutureStreamFunctions.closeOthers(q._2().getQueue(), racers.stream().map(t -> t._2().getQueue()).collect(Collectors.toList()));\r\n                closeOthers(q._1(), racers.stream().map(t -> t._1()).collect(Collectors.toList()));\r\n                return q._1().fromStream(q._2().getQueue().stream(q._1().getSubscription()));\r\n            }\r\n        }\r\n        LockSupport.parkNanos(1l);\r\n    }\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentQueueX.rangeLong",
	"Comment": "create a persistentqueuex that contains the longs between skip and take",
	"Method": "PersistentQueueX<Long> rangeLong(long start,long end){\r\n    return ReactiveSeq.rangeLong(start, end).to(ReactiveConvertableSequence::converter).persistentQueueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorCacheHelp.isQueryCaching",
	"Comment": "return true if there is currently query caching for this type of bean.",
	"Method": "boolean isQueryCaching(){\r\n    return queryCache != null;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.MColumn.isIncludeInHistory",
	"Comment": "return true if this column should be included in history db triggers etc.",
	"Method": "boolean isIncludeInHistory(){\r\n    return !draftOnly && !historyExclude;\r\n}"
}, {
	"Path": "io.ebean.config.AutoTuneConfig.setProfilingUpdateFrequency",
	"Comment": "set the frequency in seconds the profiling should be collected and automatically applied to the tuning.",
	"Method": "void setProfilingUpdateFrequency(int profilingUpdateFrequency){\r\n    this.profilingUpdateFrequency = profilingUpdateFrequency;\r\n}"
}, {
	"Path": "io.ebean.text.csv.DefaultCsvCallback.initTransactionIfRequired",
	"Comment": "create a transaction if one is not already active and set its batch modeand batch size.",
	"Method": "void initTransactionIfRequired(){\r\n    transaction = server.currentTransaction();\r\n    if (transaction == null || !transaction.isActive()) {\r\n        transaction = server.beginTransaction();\r\n        createdTransaction = true;\r\n        if (persistBatchSize > 1) {\r\n            logger.info(\"Creating transaction, batchSize[\" + persistBatchSize + \"]\");\r\n            transaction.setBatchMode(true);\r\n            transaction.setBatchSize(persistBatchSize);\r\n            transaction.setBatchGetGeneratedKeys(false);\r\n        } else {\r\n            transaction.setBatchMode(false);\r\n            logger.info(\"Creating transaction with no JDBC batching\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.api.NaturalKeyQueryData.matchProperties",
	"Comment": "return true if the properties match the natural key properties.",
	"Method": "boolean matchProperties(){\r\n    if (naturalKey.length == 1) {\r\n        if (inProperty != null) {\r\n            return inProperty.equals(naturalKey[0]);\r\n        } else {\r\n            return eqList.get(0).property.equals(naturalKey[0]);\r\n        }\r\n    }\r\n    Set<String> exprProps = new HashSet();\r\n    if (inProperty != null) {\r\n        exprProps.add(inProperty);\r\n    }\r\n    if (inProperty0 != null) {\r\n        exprProps.add(inProperty0);\r\n    }\r\n    if (inProperty1 != null) {\r\n        exprProps.add(inProperty1);\r\n    }\r\n    if (eqList != null) {\r\n        for (NaturalKeyEq eq : eqList) {\r\n            exprProps.add(eq.property);\r\n        }\r\n    }\r\n    if (exprProps.size() != naturalKey.length) {\r\n        return false;\r\n    }\r\n    for (String key : naturalKey) {\r\n        if (!exprProps.remove(key)) {\r\n            return false;\r\n        }\r\n    }\r\n    return exprProps.isEmpty();\r\n}"
}, {
	"Path": "org.dataalgorithms.chapB04.rankproduct.sparkwithlambda.SparkRankProductUsingGroupByKey.computeRankedProducts",
	"Comment": "where n is the number of elements for computing the rankedproduct",
	"Method": "JavaPairRDD<String, Tuple2<Double, Integer>> computeRankedProducts(JavaSparkContext context,JavaPairRDD<String, Long>[] ranks){\r\n    JavaPairRDD<String, Long> unionRDD = context.union(ranks);\r\n    JavaPairRDD<String, Iterable<Long>> groupedByGeneRDD = unionRDD.groupByKey();\r\n    JavaPairRDD<String, Tuple2<Double, Integer>> rankedProducts = groupedByGeneRDD.mapValues((Iterable<Long> values) -> {\r\n        int N = 0;\r\n        long products = 1;\r\n        for (Long v : values) {\r\n            products *= v;\r\n            N++;\r\n        }\r\n        double rankedProduct = Math.pow((double) products, 1.0 / ((double) N));\r\n        return new Tuple2<Double, Integer>(rankedProduct, N);\r\n    });\r\n    return rankedProducts;\r\n}"
}, {
	"Path": "io.ebean.util.CamelCaseHelper.toUnderscoreFromCamel",
	"Comment": "convert and return the string to underscore from camel case.",
	"Method": "String toUnderscoreFromCamel(String camelCase,String toUnderscoreFromCamel,String camelCase,boolean digitsCompressed,boolean forceUpperCase){\r\n    int lastUpper = -1;\r\n    StringBuilder sb = new StringBuilder(camelCase.length() + 4);\r\n    for (int i = 0; i < camelCase.length(); i++) {\r\n        char c = camelCase.charAt(i);\r\n        if ('_' == c) {\r\n            sb.append(c);\r\n            lastUpper = i;\r\n        } else if (Character.isDigit(c)) {\r\n            if (i > lastUpper + 1 && !digitsCompressed) {\r\n                sb.append(\"_\");\r\n            }\r\n            sb.append(c);\r\n            lastUpper = i;\r\n        } else if (Character.isUpperCase(c)) {\r\n            if (i > lastUpper + 1) {\r\n                sb.append(\"_\");\r\n            }\r\n            sb.append(Character.toLowerCase(c));\r\n            lastUpper = i;\r\n        } else {\r\n            sb.append(c);\r\n        }\r\n    }\r\n    String ret = sb.toString();\r\n    if (forceUpperCase) {\r\n        ret = ret.toUpperCase();\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.SqlServerDdl.alterTableAddUniqueConstraint",
	"Comment": "mssqlserver specific null handling on unique constraints.",
	"Method": "String alterTableAddUniqueConstraint(String tableName,String uqName,String[] columns,String[] nullableColumns){\r\n    if (nullableColumns == null || nullableColumns.length == 0) {\r\n        return super.alterTableAddUniqueConstraint(tableName, uqName, columns, nullableColumns);\r\n    }\r\n    if (uqName == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    String start = \"create unique nonclustered index \" + uqName + \" on \" + tableName + \"(\";\r\n    StringBuilder sb = new StringBuilder(start);\r\n    for (int i = 0; i < columns.length; i++) {\r\n        if (i > 0) {\r\n            sb.append(\",\");\r\n        }\r\n        sb.append(columns[i]);\r\n    }\r\n    sb.append(\") where\");\r\n    String sep = \" \";\r\n    for (String column : nullableColumns) {\r\n        sb.append(sep).append(column).append(\" is not null\");\r\n        sep = \" and \";\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getClassLoadConfig",
	"Comment": "return the classloadconfig which is used to detect joda, java8 types etc and alsocreate new instances of plugins given a classname.",
	"Method": "ClassLoadConfig getClassLoadConfig(){\r\n    return classLoadConfig;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.text.csv.CsvUtilReader.readNext",
	"Comment": "reads the next line from the buffer and converts to a string array.",
	"Method": "String[] readNext(){\r\n    String nextLine = getNextLine();\r\n    return hasNext ? parseLine(nextLine) : null;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.findPropertyWithDynamic",
	"Comment": "return a property that is part of the sql tree.the property can be a dynamic formula or a well known bean property.",
	"Method": "STreeProperty findPropertyWithDynamic(String propName){\r\n    if (propName.indexOf('(') > -1) {\r\n        return findSqlTreeFormula(propName);\r\n    }\r\n    return _findBeanProperty(propName);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.generatedproperty.UpdateTimestampFactory.createUpdateTimestamp",
	"Comment": "create the update generatedproperty depending on the property type.",
	"Method": "GeneratedProperty createUpdateTimestamp(DeployBeanProperty property){\r\n    Class<?> propType = property.getPropertyType();\r\n    GeneratedProperty generatedProperty = map.get(propType);\r\n    if (generatedProperty != null) {\r\n        return generatedProperty;\r\n    }\r\n    throw new PersistenceException(\"Generated update Timestamp not supported on \" + propType.getName());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.MergeNode.addSelectId",
	"Comment": "add to the query to fetch the ids values for the foreign keys basically.",
	"Method": "void addSelectId(Query<?> query){\r\n    BeanProperty idProperty = targetDescriptor.getIdProperty();\r\n    query.fetch(fullPath, idProperty.getName());\r\n}"
}, {
	"Path": "io.ebeanservice.docstore.api.support.DocStoreIndexEvent.docStoreUpdate",
	"Comment": "add appropriate json content for sending to the elasticsearch bulk api.",
	"Method": "void docStoreUpdate(DocStoreUpdateContext txn){\r\n    beanType.docStore().index(idValue, bean, txn);\r\n}"
}, {
	"Path": "io.ebean.config.EncryptDeploy.isDbEncrypt",
	"Comment": "return true if string type should use db encryption.return false if string type should use java client encryption instead.",
	"Method": "boolean isDbEncrypt(){\r\n    return dbEncrypt;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.TransactionManager.getOnQueryOnly",
	"Comment": "defines the type of behavior to use when closing a transaction that was used to query data only.",
	"Method": "OnQueryOnly getOnQueryOnly(){\r\n    return onQueryOnly;\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXWithError",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXWithError(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    final CompletableFuture<Subscription> subscription = new CompletableFuture();\r\n    final CompletableFuture<Boolean> streamCompleted = new CompletableFuture();\r\n    return tuple(subscription, () -> {\r\n        stream.subscribe(new Subscriber<T>() {\r\n            @Override\r\n            public void onSubscribe(final Subscription s) {\r\n                Objects.requireNonNull(s);\r\n                if (x != 0)\r\n                    s.request(x);\r\n                subscription.complete(s);\r\n            }\r\n            @Override\r\n            public void onNext(final T t) {\r\n                consumerElement.accept(t);\r\n            }\r\n            @Override\r\n            public void onError(final Throwable t) {\r\n                consumerError.accept(t);\r\n            }\r\n            @Override\r\n            public void onComplete() {\r\n                streamCompleted.complete(true);\r\n            }\r\n        });\r\n    }, streamCompleted);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXWithError",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXWithError(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    Objects.requireNonNull(s);\r\n    if (x != 0)\r\n        s.request(x);\r\n    subscription.complete(s);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXWithError",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXWithError(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    consumerElement.accept(t);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXWithError",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXWithError(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    consumerError.accept(t);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachXWithError",
	"Comment": "perform a foreach operation over the streamwithout closing it,capturing any elements and errors in the supplied consumers, but only consumingthe specified number of elements from the stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachXWithError(FutureStream<T> stream,long x,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    streamCompleted.complete(true);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanPropertyAssoc.getExtraWhere",
	"Comment": "return a literal expression that is added to the query that lazy loadsthe collection.",
	"Method": "String getExtraWhere(){\r\n    return extraWhere;\r\n}"
}, {
	"Path": "org.tests.basic.TestSharedInstancePropagation.testSharedListNavigate",
	"Comment": "test that the sharedinstance status is propagated on lazy loading.",
	"Method": "void testSharedListNavigate(){\r\n    ResetBasicData.reset();\r\n    Ebean.getServerCacheManager().clearAll();\r\n    Order order = Ebean.find(Order.class).setAutoTune(false).setReadOnly(true).setId(1).findOne();\r\n    assertNotNull(order);\r\n    assertTrue(Ebean.getBeanState(order).isReadOnly());\r\n    List<OrderDetail> details = order.getDetails();\r\n    BeanCollection<?> bc = (BeanCollection<?>) details;\r\n    assertTrue(bc.isReadOnly());\r\n    assertFalse(bc.isPopulated());\r\n    bc.size();\r\n    assertTrue(bc.isPopulated());\r\n    assertTrue(!bc.isEmpty());\r\n    OrderDetail detail = details.get(0);\r\n    assertTrue(Ebean.getBeanState(detail).isReadOnly());\r\n    assertFalse(Ebean.getBeanState(detail).isReference());\r\n    Product product = detail.getProduct();\r\n    assertTrue(Ebean.getBeanState(product).isReadOnly());\r\n    product.getName();\r\n    assertFalse(Ebean.getBeanState(product).isReference());\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.isCollectQueryStatsByNode",
	"Comment": "return true if the ebeanserver should collection query statistics by objectgraphnode.",
	"Method": "boolean isCollectQueryStatsByNode(){\r\n    return collectQueryStatsByNode;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.OrmQueryRequest.getLazyLoadBatchSize",
	"Comment": "return the batch size for lazy loading on this bean query request.",
	"Method": "int getLazyLoadBatchSize(){\r\n    int batchSize = query.getLazyLoadBatchSize();\r\n    return (batchSize > 0) ? batchSize : ebeanServer.getLazyLoadBatchSize();\r\n}"
}, {
	"Path": "io.ebean.common.BeanMap.isPopulated",
	"Comment": "return true if the underlying map has been populated. returns false if ithas a deferred fetch pending.",
	"Method": "boolean isPopulated(){\r\n    return map != null;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getQueryCacheMaxTimeToLive",
	"Comment": "return the l2 query cache default max time to live in seconds.",
	"Method": "int getQueryCacheMaxTimeToLive(){\r\n    return queryCacheMaxTimeToLive;\r\n}"
}, {
	"Path": "io.ebean.text.json.JsonReadOptions.isEnableLazyLoading",
	"Comment": "return true if lazy loading is enabled after the objects are loaded.",
	"Method": "boolean isEnableLazyLoading(){\r\n    return enableLazyLoading;\r\n}"
}, {
	"Path": "com.oath.cyclops.util.stream.scheduling.cron.CronExpression.setCalendarHour",
	"Comment": "advance the calendar to the particular hour paying particular attentionto daylight saving problems.",
	"Method": "void setCalendarHour(Calendar cal,int hour){\r\n    cal.set(java.util.Calendar.HOUR_OF_DAY, hour);\r\n    if (cal.get(java.util.Calendar.HOUR_OF_DAY) != hour && hour != 24) {\r\n        cal.set(java.util.Calendar.HOUR_OF_DAY, hour + 1);\r\n    }\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.registerGetterCallback",
	"Comment": "register the callback to be triggered when getter is called.this is used primarily to automatically flush the jdbc batch.",
	"Method": "void registerGetterCallback(PreGetterCallback getterCallback){\r\n    this.preGetterCallback = getterCallback;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.OrmUpdateProperties.buildSetClause",
	"Comment": "build the actual set clause converting logical property names to db columns etc.",
	"Method": "String buildSetClause(DeployParser deployParser){\r\n    int setCount = 0;\r\n    StringBuilder sb = new StringBuilder();\r\n    for (Map.Entry<String, Value> entry : values.entrySet()) {\r\n        String property = entry.getKey();\r\n        if (setCount++ > 0) {\r\n            sb.append(\", \");\r\n        }\r\n        sb.append(TABLE_ALIAS_REPLACE.matcher(deployParser.parse(property)).replaceAll(\"\"));\r\n        sb.append(entry.getValue().bindClause());\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequest.getType",
	"Comment": "return the type of this request. one of insert, update, delete, updatesqlor callablesql.",
	"Method": "Type getType(){\r\n    return type;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocOne.getProperties",
	"Comment": "return meta data for the deployment of the embedded bean specific to thisproperty.",
	"Method": "BeanProperty[] getProperties(){\r\n    return embeddedProps;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getIdBinderIdSql",
	"Comment": "return the sql for binding an id. this is the columns with table alias thatmake up the id.",
	"Method": "String getIdBinderIdSql(String alias){\r\n    if (alias == null) {\r\n        return idBinderIdSql;\r\n    } else {\r\n        return idBinder.getBindIdSql(alias);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.isCacheDataInclude",
	"Comment": "return true if this property should be included in the cache bean data.",
	"Method": "boolean isCacheDataInclude(){\r\n    return true;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.DefaultOrmQuery.selectAllForLazyLoadProperty",
	"Comment": "return true if select all properties was used to ensure the property invoking a lazy load wasincluded in the query.",
	"Method": "boolean selectAllForLazyLoadProperty(){\r\n    if (lazyLoadProperty != null) {\r\n        if (!detail.containsProperty(lazyLoadProperty)) {\r\n            detail.select(\"*\");\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "cyclops.reactive.ReactiveSeq.permutations",
	"Comment": "generate the permutations based on values in the reactiveseq makes use ofstreamable to store intermediate stages in a tox",
	"Method": "ReactiveSeq<ReactiveSeq<T>> permutations(){\r\n    return Streams.permutations(toArray());\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.BaseTableDdl.historyTable",
	"Comment": "return the name of the history table given the base table name.",
	"Method": "String historyTable(String baseTable){\r\n    return baseTable + historyTableSuffix;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanProperty.isDbRead",
	"Comment": "return true if this property is included in database queries.",
	"Method": "boolean isDbRead(){\r\n    return dbRead;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.addPackage",
	"Comment": "add a package to search for entities via class path search.this is only used if classes have not been explicitly specified.",
	"Method": "void addPackage(String packageName){\r\n    if (packages == null) {\r\n        packages = new ArrayList();\r\n    }\r\n    packages.add(packageName);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.Value.toEither",
	"Comment": "convert to an xor where the left value will be used if no right value is present",
	"Method": "Either<ST, T> toEither(ST secondary){\r\n    return fold(p -> Either.right(p), () -> Either.left(secondary));\r\n}"
}, {
	"Path": "cyclops.reactive.ReactiveSeq.range",
	"Comment": "create an efficiently reversable sequence that produces the integersbetween skip and take",
	"Method": "ReactiveSeq<Integer> range(int start,int end,ReactiveSeq<Integer> range,int start,int step,int end){\r\n    if (start > end)\r\n        return range(end, step, start);\r\n    final ReversingRangeIntSpliterator range = new ReversingRangeIntSpliterator(start, end, step, false);\r\n    return Streams.reactiveSeq(range, Optional.ofNullable(range));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.DbOrderByTrim.trim",
	"Comment": "convert the dborderby clause to be safe for adding to select or distinct on.",
	"Method": "String trim(String dbOrderBy){\r\n    return orderByTrim.matcher(dbOrderBy).replaceAll(\"\");\r\n}"
}, {
	"Path": "cyclops.companion.Streams.foldMap",
	"Comment": "attempt to transform this stream to the same type as the supplied monoid, using supplied function then use monoid to reduce values",
	"Method": "R foldMap(Stream<T> stream,Reducer<R, T> reducer,R foldMap,Stream<T> stream,Function<? super T, ? extends R> mapper,Monoid<R> reducer){\r\n    return reducer.foldLeft(stream.map(mapper));\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setChangeLogPrepare",
	"Comment": "set the changelogprepare.this is used to set user context information to the changeset in theforeground thread prior to the logging occurring in a background thread.",
	"Method": "void setChangeLogPrepare(ChangeLogPrepare changeLogPrepare){\r\n    this.changeLogPrepare = changeLogPrepare;\r\n}"
}, {
	"Path": "io.ebean.cache.ServerCacheConfig.getQueryCacheEntryValidate",
	"Comment": "return the service that provides validation for query cache entries.",
	"Method": "QueryCacheEntryValidate getQueryCacheEntryValidate(){\r\n    return queryCacheEntryValidate;\r\n}"
}, {
	"Path": "io.ebean.TxScope.isSkipGeneratedKeys",
	"Comment": "return true if getgeneratedkeys should be skipped for this transaction.",
	"Method": "boolean isSkipGeneratedKeys(){\r\n    return skipGeneratedKeys;\r\n}"
}, {
	"Path": "io.ebeanservice.docstore.api.mapping.DocPropertyOptions.copy",
	"Comment": "create a copy of this such that it can be overridden on a per index basis.",
	"Method": "DocPropertyOptions copy(){\r\n    return new DocPropertyOptions(this);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.JdbcTransaction.wrapIfNeeded",
	"Comment": "try to keep specific exceptions and otherwise wrap as rollbackexception.",
	"Method": "RuntimeException wrapIfNeeded(Exception e){\r\n    if (e instanceof PersistenceException) {\r\n        return (PersistenceException) e;\r\n    }\r\n    return new RollbackException(e);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.draftQueryOptimise",
	"Comment": "optimise the draft query fetching any draftable element relationships.",
	"Method": "void draftQueryOptimise(Query<T> query){\r\n    query.setPersistenceContextScope(PersistenceContextScope.QUERY);\r\n    draftHelp.draftQueryOptimise(query);\r\n}"
}, {
	"Path": "cyclops.companion.Streams.debounce",
	"Comment": "allow one element through per time period, drop all other elements inthat time period",
	"Method": "Stream<T> debounce(Stream<T> stream,long time,TimeUnit t){\r\n    return new DebounceOperator(stream).debounce(time, t);\r\n}"
}, {
	"Path": "cyclops.control.LazyEither4.traverse",
	"Comment": "traverseops a collection of either3 producing an either4 with a seq, applying the transformation function to everyelement in the list",
	"Method": "LazyEither4<L1, L2, L3, ReactiveSeq<R>> traverse(Function<? super T, ? extends R> fn,ReactiveSeq<LazyEither4<L1, L2, L3, T>> stream,LazyEither4<LT1, LT2, LT3, ReactiveSeq<R>> traverse,Iterable<LazyEither4<LT1, LT2, LT3, PT>> xors,Function<? super PT, ? extends R> fn){\r\n    return sequence(xors).map(l -> l.map(fn));\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.BagX.iterate",
	"Comment": "create a bagx by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "BagX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).bagX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.SqlTreeBuilder.buildSelectChain",
	"Comment": "recursively build the query tree depending on what leaves in the treeshould be included.",
	"Method": "SqlTreeNode buildSelectChain(String prefix,STreePropertyAssoc prop,STreeType desc,List<SqlTreeNode> joinList){\r\n    List<SqlTreeNode> myJoinList = new ArrayList();\r\n    for (STreePropertyAssocOne one : desc.propsOne()) {\r\n        String propPrefix = SplitName.add(prefix, one.getName());\r\n        if (isIncludeBean(propPrefix)) {\r\n            selectIncludes.add(propPrefix);\r\n            buildSelectChain(propPrefix, one, one.target(), myJoinList);\r\n        }\r\n    }\r\n    for (STreePropertyAssocMany many : desc.propsMany()) {\r\n        String propPrefix = SplitName.add(prefix, many.getName());\r\n        if (isIncludeMany(propPrefix, many)) {\r\n            selectIncludes.add(propPrefix);\r\n            buildSelectChain(propPrefix, many, many.target(), myJoinList);\r\n        }\r\n    }\r\n    OrmQueryProperties queryProps = queryDetail.getChunk(prefix, false);\r\n    SqlTreeProperties props = getBaseSelect(desc, queryProps);\r\n    if (prefix == null && !rawSql) {\r\n        if (props.requireSqlDistinct(manyWhereJoins)) {\r\n            query.setSqlDistinct(true);\r\n        }\r\n        addManyWhereJoins(myJoinList);\r\n    }\r\n    SqlTreeNode selectNode = buildNode(prefix, prop, desc, myJoinList, props);\r\n    if (joinList != null) {\r\n        joinList.add(selectNode);\r\n    }\r\n    return selectNode;\r\n}"
}, {
	"Path": "io.ebean.config.DbMigrationConfig.setPatchResetChecksumOn",
	"Comment": "set migration versions that should have their checksum reset and not run.value can be a string containing comma delimited list of version numbers.",
	"Method": "void setPatchResetChecksumOn(String patchResetChecksumOn){\r\n    this.patchResetChecksumOn = patchResetChecksumOn;\r\n}"
}, {
	"Path": "cyclops.control.LazyEither3.toIor",
	"Comment": "return an ior that can be this object or a ior.right or ior.left",
	"Method": "Ior<LT1, RT> toIor(){\r\n    return this.fold(l -> Ior.left(l), m -> Ior.left(null), r -> Ior.right(r));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequest.startBind",
	"Comment": "effectively set start nanos if we are collecting metrics on a label.",
	"Method": "void startBind(boolean batchThisRequest){\r\n    if (!batchThisRequest && label != null) {\r\n        startNanos = System.nanoTime();\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.DefaultPersistenceContext.size",
	"Comment": "return the number of beans of the given type in the persistence context.",
	"Method": "int size(Class<?> rootType,int size){\r\n    synchronized (monitor) {\r\n        ClassContext classMap = typeCache.get(rootType);\r\n        return classMap == null ? 0 : classMap.size();\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.DdlHelp.isDropComment",
	"Comment": "return true if the default value is the special drop comment value.",
	"Method": "boolean isDropComment(String value){\r\n    return DROP_COMMENT.equals(value);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.dml.InsertMeta.supportsGetGeneratedKeys",
	"Comment": "return true if getgeneratedkeys is supported by the underlying jdbcdriver and database.",
	"Method": "boolean supportsGetGeneratedKeys(){\r\n    return supportsGetGeneratedKeys;\r\n}"
}, {
	"Path": "cyclops.control.Future.ofResult",
	"Comment": "construct a successfully completed future from the given value",
	"Method": "Future<T> ofResult(T result){\r\n    return Future.of(CompletableFuture.completedFuture(result));\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.SetX.range",
	"Comment": "create a setx that contains the integers between skip and take",
	"Method": "SetX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).setX(LAZY);\r\n}"
}, {
	"Path": "io.ebean.util.AnnotationUtil.findMetaAnnotations",
	"Comment": "perform the search algorithm avoiding endless recursion by tracking whichannotations have already been visited.",
	"Method": "void findMetaAnnotations(AnnotatedElement annotatedElement,Class<A> annotationType,Set<A> ret,Set<Annotation> visited){\r\n    Annotation[] anns = annotatedElement.getAnnotations();\r\n    for (Annotation ann : anns) {\r\n        if (!isInJavaLangAnnotationPackage(ann) && visited.add(ann)) {\r\n            if (ann.annotationType() == annotationType) {\r\n                ret.add((A) ann);\r\n            } else {\r\n                Method repeatableValueMethod = getRepeatableValueMethod(ann, annotationType);\r\n                if (repeatableValueMethod != null) {\r\n                    try {\r\n                        A[] repeatedAnns = (A[]) repeatableValueMethod.invoke(ann);\r\n                        for (Annotation repeatedAnn : repeatedAnns) {\r\n                            ret.add((A) repeatedAnn);\r\n                            findMetaAnnotations(repeatedAnn.annotationType(), annotationType, ret, visited);\r\n                        }\r\n                    } catch (Exception e) {\r\n                        throw new RuntimeException(e);\r\n                    }\r\n                } else {\r\n                    findMetaAnnotations(ann.annotationType(), annotationType, ret, visited);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocOne.findMatch",
	"Comment": "find the matching foreigndbcolumn for a given local property.",
	"Method": "ExportedProperty findMatch(boolean embeddedProp,BeanProperty prop){\r\n    return findMatch(embeddedProp, prop, prop.getDbColumn(), tableJoin);\r\n}"
}, {
	"Path": "io.ebean.config.AbstractNamingConvention.setUseForeignKeyPrefix",
	"Comment": "set this to false when the primary key columns matching your foreign keycolumns.",
	"Method": "void setUseForeignKeyPrefix(boolean useForeignKeyPrefix){\r\n    this.useForeignKeyPrefix = useForeignKeyPrefix;\r\n}"
}, {
	"Path": "io.ebeaninternal.api.TransactionEvent.isLocal",
	"Comment": "return true if this was a local transaction. returns false if thistransaction originated on another server in the cluster.",
	"Method": "boolean isLocal(){\r\n    return local;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanProperty.isVersionColumn",
	"Comment": "return true if this is a version column used for concurrency checking.",
	"Method": "boolean isVersionColumn(){\r\n    return versionColumn;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.SqlTreeAlias.buildAlias",
	"Comment": "build a set of table alias for the given bean and fetch joined properties.",
	"Method": "void buildAlias(){\r\n    for (String joinProp : joinProps) {\r\n        calcAlias(joinProp);\r\n    }\r\n    for (String joinProp : manyWhereJoinProps) {\r\n        calcAliasManyWhere(joinProp);\r\n    }\r\n    mapEmbeddedPropertyAlias();\r\n}"
}, {
	"Path": "cyclops.futurestream.FutureStream.then",
	"Comment": "react to new events with the supplied function on the suppliedexecutor",
	"Method": "FutureStream<R> then(Function<? super U, ? extends R> fn,Executor service,FutureStream<R> then,Function<? super U, ? extends R> fn){\r\n    return (FutureStream) LazySimpleReactStream.super.then(fn);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.autotune.service.TunedQueryInfo.tuneQuery",
	"Comment": "tune the query by replacing its ormquerydetail with a tuned one.",
	"Method": "boolean tuneQuery(SpiQuery<?> query){\r\n    if (tunedDetail == null) {\r\n        return false;\r\n    }\r\n    boolean tuned;\r\n    if (query.isDetailEmpty()) {\r\n        tuned = true;\r\n        query.setDetail(tunedDetail.copy());\r\n    } else {\r\n        tuned = query.tuneFetchProperties(tunedDetail);\r\n    }\r\n    if (tuned) {\r\n        query.setAutoTuned(true);\r\n    }\r\n    return tuned;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.OrmQueryRequest.getQueryPlan",
	"Comment": "return a queryplan for the current query if one exists. returns null if noquery plan for this query exists.",
	"Method": "CQueryPlan getQueryPlan(){\r\n    return beanDescriptor.getQueryPlan(queryPlanKey);\r\n}"
}, {
	"Path": "cyclops.function.Memoize.memoizeFunctionAsync",
	"Comment": "memoize this function and update cached values on a scheduledoes not support null keys",
	"Method": "Function1<T, R> memoizeFunctionAsync(Function<T, R> fn,ScheduledExecutorService ex,long updateRateInMillis,Function1<T, R> memoizeFunctionAsync,Function<T, R> fn,ScheduledExecutorService ex,String cron){\r\n    final Map<T, R> lazy = new ConcurrentHashMap();\r\n    ReactiveSeq.generate(() -> {\r\n        lazy.forEach((k, v) -> {\r\n            lazy.put(k, fn.apply(k));\r\n        });\r\n        return null;\r\n    }).schedule(cron, ex);\r\n    return t -> lazy.computeIfAbsent(t, fn);\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.isReadOnly",
	"Comment": "return true if the bean should be treated as readonly. if a setter methodis called when it is readonly an exception is thrown.",
	"Method": "boolean isReadOnly(){\r\n    return readOnly;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getJsonFactory",
	"Comment": "return the jackson jsonfactory to use.if not set a default implementation will be used.",
	"Method": "JsonFactory getJsonFactory(){\r\n    return jsonFactory;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.getGeneratedProperty",
	"Comment": "return the generatedvalue. used to generate update timestamp etc.",
	"Method": "GeneratedProperty getGeneratedProperty(){\r\n    return generatedProperty;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.isNotifyL2CacheInForeground",
	"Comment": "return true if l2 cache notification should run in the foreground.",
	"Method": "boolean isNotifyL2CacheInForeground(){\r\n    return notifyL2CacheInForeground;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.DefaultOrmQuery.setParameter",
	"Comment": "set a named bind parameter. named parameters have a colon to prefix the name.",
	"Method": "DefaultOrmQuery<T> setParameter(int position,Object value,DefaultOrmQuery<T> setParameter,String name,Object value){\r\n    if (namedParams != null) {\r\n        ONamedParam param = namedParams.get(name);\r\n        if (param != null) {\r\n            param.setValue(value);\r\n            return this;\r\n        }\r\n    }\r\n    if (bindParams == null) {\r\n        bindParams = new BindParams();\r\n    }\r\n    bindParams.setParameter(name, value);\r\n    return this;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.OrmQueryProperties.filterMany",
	"Comment": "return the expressions used to filter on this path. this should be a many path to use thismethod.",
	"Method": "SpiExpressionList<T> filterMany(Query<T> rootQuery){\r\n    if (filterMany == null) {\r\n        FilterExprPath exprPath = new FilterExprPath(path);\r\n        SpiExpressionFactory queryEf = (SpiExpressionFactory) rootQuery.getExpressionFactory();\r\n        ExpressionFactory filterEf = queryEf.createExpressionFactory();\r\n        filterMany = new FilterExpressionList(exprPath, filterEf, rootQuery);\r\n        markForQueryJoin = true;\r\n    }\r\n    return filterMany;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.LazySimpleReactStream.peek",
	"Comment": "peek asynchronously at the results in the current stage. current resultsare passed through to the next stage.",
	"Method": "LazySimpleReactStream<U> peek(Consumer<? super U> consumer){\r\n    if (!isAsync())\r\n        return peekSync(consumer);\r\n    return then((t) -> {\r\n        consumer.accept(t);\r\n        return t;\r\n    });\r\n}"
}, {
	"Path": "io.ebean.config.DbConstraintNaming.lowerColumnName",
	"Comment": "lower case the column name checking for quoted identifiers.",
	"Method": "String lowerColumnName(String name){\r\n    return normalise.lowerColumnName(name);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.initTransIfRequiredWithBatchCascade",
	"Comment": "init the transaction and also check for batch on cascade escalation.",
	"Method": "void initTransIfRequiredWithBatchCascade(){\r\n    if (createImplicitTransIfRequired()) {\r\n        docStoreMode = calcDocStoreMode(transaction, type);\r\n    }\r\n    checkBatchEscalationOnCascade();\r\n}"
}, {
	"Path": "cyclops.companion.Streams.groupedStatefullyUntil",
	"Comment": "group data in a stream using knowledge of the current batch and the next entry to determing grouping limits",
	"Method": "Stream<Seq<T>> groupedStatefullyUntil(Stream<T> stream,BiPredicate<Seq<? super T>, ? super T> predicate){\r\n    return StreamSupport.stream(new GroupedStatefullySpliterator(stream.spliterator(), () -> Seq.of(), Function.identity(), predicate.negate()), stream.isParallel());\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.BaseSimpleReactStream.empty",
	"Comment": "create an zero sequential synchronous stream that runs on the current thread",
	"Method": "SimpleReactStream<T> empty(){\r\n    return simpleReactStream((Stream) Stream.empty());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.createReference",
	"Comment": "create a non read only reference bean without checking cachesharablebeans.",
	"Method": "T createReference(Boolean readOnly,boolean disableLazyLoad,Object id,PersistenceContext pc,T createReference,Object id,PersistenceContext pc){\r\n    try {\r\n        if (inheritInfo != null && !inheritInfo.isConcrete()) {\r\n            return findReferenceBean(id, pc);\r\n        }\r\n        EntityBean eb = createEntityBean();\r\n        id = convertSetId(id, eb);\r\n        EntityBeanIntercept ebi = eb._ebean_getIntercept();\r\n        ebi.setBeanLoader(ebeanServer);\r\n        ebi.setReference(idPropertyIndex);\r\n        if (pc != null) {\r\n            contextPut(pc, id, eb);\r\n            ebi.setPersistenceContext(pc);\r\n        }\r\n        return (T) eb;\r\n    } catch (Exception ex) {\r\n        throw new PersistenceException(ex);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanDescriptor.getBeanFinder",
	"Comment": "return the beanfinder. usually null unless overriding the finder.",
	"Method": "BeanFindController getBeanFinder(){\r\n    return beanFinder;\r\n}"
}, {
	"Path": "io.ebean.config.DbMigrationConfig.createRunner",
	"Comment": "create the migrationrunner to run migrations if necessary.",
	"Method": "MigrationRunner createRunner(ClassLoader classLoader,Properties properties){\r\n    runnerConfig.setMetaTable(metaTable);\r\n    runnerConfig.setApplySuffix(applySuffix);\r\n    runnerConfig.setMigrationPath(migrationPath);\r\n    runnerConfig.setRunPlaceholderMap(runPlaceholderMap);\r\n    runnerConfig.setRunPlaceholders(runPlaceholders);\r\n    runnerConfig.setDbUsername(getDbUsername());\r\n    runnerConfig.setDbPassword(getDbPassword());\r\n    runnerConfig.setDbSchema(getDbSchema());\r\n    if (defaultDbSchema) {\r\n        runnerConfig.setSetCurrentSchema(false);\r\n    }\r\n    runnerConfig.setClassLoader(classLoader);\r\n    if (patchInsertOn != null) {\r\n        runnerConfig.setPatchInsertOn(patchInsertOn);\r\n    }\r\n    if (patchResetChecksumOn != null) {\r\n        runnerConfig.setPatchResetChecksumOn(patchResetChecksumOn);\r\n    }\r\n    if (properties != null) {\r\n        runnerConfig.load(properties);\r\n    }\r\n    return new MigrationRunner(runnerConfig);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanPropertyAssocOne.isOneToOne",
	"Comment": "return true if this a onetoone property. otherwise assumed manytoone.",
	"Method": "boolean isOneToOne(){\r\n    return oneToOne;\r\n}"
}, {
	"Path": "io.ebean.text.csv.DefaultCsvCallback.rollbackTransactionIfCreated",
	"Comment": "rollback the transaction if we where not successful in processing all therows.",
	"Method": "void rollbackTransactionIfCreated(Throwable e){\r\n    if (createdTransaction) {\r\n        transaction.rollback(e);\r\n        logger.info(\"Rolled back transaction\");\r\n    }\r\n}"
}, {
	"Path": "org.ebeantest.LoggedSqlCollector.stop",
	"Comment": "stop collection of the logged sql statements return the list of captured messages that containthe sql.",
	"Method": "List<String> stop(){\r\n    return LoggedSql.stop();\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setDatabasePlatform",
	"Comment": "explicitly set the database platform to use.if none is set then the platform is determined via the databaseplatformnameor automatically via the jdbc driver information.",
	"Method": "void setDatabasePlatform(DatabasePlatform databasePlatform){\r\n    this.databasePlatform = databasePlatform;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanPropertyAssocMany.setIntersectionJoin",
	"Comment": "manytomany only, join from local table to intersection table.",
	"Method": "void setIntersectionJoin(DeployTableJoin intersectionJoin){\r\n    this.intersectionJoin = intersectionJoin;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.readEntityDeploymentInitial",
	"Comment": "read the initial deployment information for the entities.this stops short of reading relationship meta data until after thebeantables have all been created.",
	"Method": "void readEntityDeploymentInitial(){\r\n    for (Class<?> entityClass : bootupClasses.getEntities()) {\r\n        DeployBeanInfo<?> info = createDeployBeanInfo(entityClass);\r\n        deployInfoMap.put(entityClass, info);\r\n    }\r\n    for (Class<?> entityClass : bootupClasses.getEmbeddables()) {\r\n        DeployBeanInfo<?> info = createDeployBeanInfo(entityClass);\r\n        readDeployAssociations(info);\r\n        deployInfoMap.put(entityClass, info);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.loadcontext.DLoadContext.getSecondaryQueriesMinBatchSize",
	"Comment": "return the minimum batch size when using queryiterator with query joins.",
	"Method": "int getSecondaryQueriesMinBatchSize(int defaultQueryBatch){\r\n    if (secQuery == null) {\r\n        return -1;\r\n    }\r\n    int maxBatch = 0;\r\n    for (OrmQueryProperties aSecQuery : secQuery) {\r\n        int batchSize = aSecQuery.getQueryFetchBatch();\r\n        if (batchSize == 0) {\r\n            batchSize = defaultQueryBatch;\r\n        }\r\n        maxBatch = Math.max(maxBatch, batchSize);\r\n    }\r\n    return maxBatch;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultContainer.setNamingConvention",
	"Comment": "set the naming convention to underscore if it has not already been set.",
	"Method": "void setNamingConvention(ServerConfig config){\r\n    if (config.getNamingConvention() == null) {\r\n        config.setNamingConvention(new UnderscoreNamingConvention());\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.propertiesEmbedded",
	"Comment": "return the beans that are embedded. these share the base table with theowner bean.",
	"Method": "BeanPropertyAssocOne<?>[] propertiesEmbedded(){\r\n    return propertiesEmbedded;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.build.ModelBuildPropertyVisitor.buildCheckConstraint",
	"Comment": "build the check constraint clause given the db column and values.",
	"Method": "String buildCheckConstraint(String dbColumn,Set<String> checkConstraintValues){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"check ( \").append(dbColumn).append(\" in (\");\r\n    int count = 0;\r\n    for (String value : checkConstraintValues) {\r\n        if (count++ > 0) {\r\n            sb.append(\",\");\r\n        }\r\n        sb.append(value);\r\n    }\r\n    sb.append(\"))\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.TransactionManager.translate",
	"Comment": "translate the sqlexception into a specific exception if possible based on the db platform.",
	"Method": "PersistenceException translate(String message,SQLException cause){\r\n    return databasePlatform.translate(message, cause);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequest.translateSqlException",
	"Comment": "translate the sqlexception into a specific exception given the platform.",
	"Method": "PersistenceException translateSqlException(SQLException e){\r\n    return transaction.translate(e.getMessage(), e);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanProperty.setVersionColumn",
	"Comment": "set if this is a version column used for concurrency checking.",
	"Method": "void setVersionColumn(){\r\n    this.versionColumn = true;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.SortedSetX.rangeLong",
	"Comment": "create a sortedsetx that contains the longs between skip and take",
	"Method": "SortedSetX<Long> rangeLong(long start,long end){\r\n    return ReactiveSeq.rangeLong(start, end).to(ReactiveConvertableSequence::converter).sortedSetX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setClassLoadConfig",
	"Comment": "set the classloadconfig which is used to detect joda, java8 types etc and alsocreate new instances of plugins given a classname.",
	"Method": "void setClassLoadConfig(ClassLoadConfig classLoadConfig){\r\n    this.classLoadConfig = classLoadConfig;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocMany.registerDraftIntersectionTable",
	"Comment": "register the mapping of intersection table to associated draft table.",
	"Method": "void registerDraftIntersectionTable(BeanDescriptorInitContext initContext){\r\n    if (hasDraftIntersection()) {\r\n        initContext.addDraftIntersection(intersectionPublishTable, intersectionDraftTable);\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.DocStoreConfig.setPassword",
	"Comment": "set the password credential for connecting to the document store.",
	"Method": "void setPassword(String password){\r\n    this.password = password;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.DequeX.fill",
	"Comment": "generate a dequex from the provided value up to the provided limit number of times",
	"Method": "DequeX<T> fill(long limit,T s){\r\n    return ReactiveSeq.fill(s).limit(limit).to(ReactiveConvertableSequence::converter).dequeX(LAZY);\r\n}"
}, {
	"Path": "cyclops.function.Consumer3.apply",
	"Comment": "partially applyhkt the first and second input parameter to this c3",
	"Method": "Function<S2, Consumer<S3>> apply(S1 s,Consumer<S3> apply,S1 s,S2 s2){\r\n    return CurryConsumer.curryC3(this).apply(s).apply(s2);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.firstOf",
	"Comment": "return first stream out of provided streams that starts emitted results",
	"Method": "SimpleReactStream<U> firstOf(SimpleReactStream<U> futureStreams){\r\n    return EagerFutureStreamFunctions.firstOf(futureStreams);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.autotune.service.ProfileManager.collectNodeUsage",
	"Comment": "collect usage statistics from a node in the object graph.this is sent to use from a entitybeanintercept when the finalise methodis called on the bean.",
	"Method": "void collectNodeUsage(NodeUsageCollector usageCollector){\r\n    ProfileOrigin profileOrigin = getProfileOrigin(usageCollector.getNode().getOriginQueryPoint());\r\n    profileOrigin.collectUsageInfo(usageCollector);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getDbEncrypt",
	"Comment": "return the dbencrypt used to encrypt and decrypt properties.note that if this is not set then the dbplatform may already have adbencrypt set and that will be used.",
	"Method": "DbEncrypt getDbEncrypt(){\r\n    return dbEncrypt;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.OrderedSetX.range",
	"Comment": "create a orderedsetx that contains the integers between skip and take",
	"Method": "OrderedSetX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).orderedSetX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.grammer.ParseFetchConfig.parse",
	"Comment": "parse the path that potentially is a fetchconfig definition.return the fetchconfig if it is and otherwise null.",
	"Method": "FetchConfig parse(String path){\r\n    if (path.startsWith(\"lazy\")) {\r\n        if (path.length() == 4) {\r\n            return new FetchConfig().lazy();\r\n        } else if (path.charAt(4) == '(') {\r\n            path = path.substring(5);\r\n            int batchSize = parseBatchSize(path);\r\n            return new FetchConfig().lazy(batchSize);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    if (path.startsWith(\"query\")) {\r\n        if (path.length() == 5) {\r\n            return new FetchConfig().query();\r\n        } else if (path.charAt(5) == '(') {\r\n            path = path.substring(6);\r\n            int batchSize = parseBatchSize(path);\r\n            return new FetchConfig().query(batchSize);\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "cyclops.typeclasses.foldable.Foldable.foldLeft",
	"Comment": "starting from the left combine each value in turn with an accumulator",
	"Method": "T foldLeft(Monoid<T> monoid,Higher<CRE, T> ds,T foldLeft,T identity,BinaryOperator<T> semigroup,Higher<CRE, T> ds){\r\n    return foldLeft(Monoid.fromBiFunction(identity, semigroup), ds);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.platform.MultiValueBind.isTypeSupported",
	"Comment": "defaults to not supported and using a bind value per element.",
	"Method": "boolean isTypeSupported(int jdbcType){\r\n    return false;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentQueueX.generate",
	"Comment": "generate a persistentqueuex from the provided supplier up to the provided limit number of times",
	"Method": "PersistentQueueX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).persistentQueueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getChangeLogPrepare",
	"Comment": "return the changelogprepare.this is used to set user context information to the changeset in theforeground thread prior to the logging occurring in a background thread.",
	"Method": "ChangeLogPrepare getChangeLogPrepare(){\r\n    return changeLogPrepare;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultServer.executePlugins",
	"Comment": "execute all the plugins with an online flag indicating the db is up or not.",
	"Method": "void executePlugins(boolean online){\r\n    if (!serverConfig.isDocStoreOnly()) {\r\n        ddlGenerator.execute(online);\r\n    }\r\n    for (Plugin plugin : serverPlugins) {\r\n        plugin.online(online);\r\n    }\r\n}"
}, {
	"Path": "cyclops.futurestream.FutureStream.unboundedWaitFree",
	"Comment": "this is the default setting, internal queues are backed by a concurrentlinkedqueuethis operator will return the next stage to using this queue type if it has been changed",
	"Method": "FutureStream<U> unboundedWaitFree(){\r\n    return this.withQueueFactory(QueueFactories.unboundedNonBlockingQueue());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.PostCommitProcessing.isDocStoreUpdate",
	"Comment": "return true if updates to the document store occur for this transaction.",
	"Method": "boolean isDocStoreUpdate(){\r\n    return manager.isDocStoreActive() && (txnDocStoreMode == null || txnDocStoreMode != DocStoreMode.IGNORE);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.DefaultProfileHandler.collect",
	"Comment": "main loop for polling the queue and processing profiling messages.",
	"Method": "void collect(){\r\n    try {\r\n        while (!shutdown) {\r\n            TransactionProfile profile = queue.poll();\r\n            if (profile == null) {\r\n                sleep();\r\n            } else if (include(profile)) {\r\n                write(profile);\r\n            }\r\n        }\r\n        flushCurrentFile();\r\n    } catch (Exception e) {\r\n        log.warn(\"Error on collect\", e);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.isDbUpdatable",
	"Comment": "return true if this property should be included in an update.",
	"Method": "boolean isDbUpdatable(){\r\n    return dbUpdatable;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.type.ScalarTypeJsonCollection.getDbColumnDefn",
	"Comment": "return the logical db column definition based on the element document type.",
	"Method": "String getDbColumnDefn(){\r\n    switch(docPropertyType) {\r\n        case SHORT:\r\n        case INTEGER:\r\n        case LONG:\r\n            return \"integer[]\";\r\n        case DOUBLE:\r\n        case FLOAT:\r\n            return \"decimal[]\";\r\n    }\r\n    return \"varchar[]\";\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.JdbcTransaction.setPersistenceContext",
	"Comment": "set the persistence context to this transaction.this could be considered similar to ejb3 extended persistancecontext. inthat you get the persistancecontext from a transaction, hold onto it, andthen set it back later to a second transaction.",
	"Method": "void setPersistenceContext(PersistenceContext context){\r\n    if (!isActive()) {\r\n        throw new IllegalStateException(illegalStateMessage);\r\n    }\r\n    this.persistenceContext = context;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.QueueX.rangeLong",
	"Comment": "create a queuex that contains the longs between skip and take",
	"Method": "QueueX<Long> rangeLong(long start,long end){\r\n    return ReactiveSeq.rangeLong(start, end).to(ReactiveConvertableSequence::converter).queueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.ClassPathScanners.find",
	"Comment": "return the list of classpathscanner services using serverconfig service loader.",
	"Method": "List<ClassPathScanner> find(ServerConfig serverConfig){\r\n    List<ClassPathScanner> scanners = new ArrayList();\r\n    for (ClassPathScannerFactory factory : serverConfig.serviceLoad(ClassPathScannerFactory.class)) {\r\n        scanners.add(factory.createScanner(serverConfig.getClassLoadConfig().getClassLoader()));\r\n    }\r\n    return scanners;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.reactive.ReactiveTask.requestAll",
	"Comment": "request all elements to be processed from the processing stream",
	"Method": "void requestAll(){\r\n    request(Long.MAX_VALUE);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanLifecycleAdapterFactory.addLifecycleMethods",
	"Comment": "register a beanpersistcontroller for methods annotated with lifecycle events.",
	"Method": "void addLifecycleMethods(DeployBeanDescriptor<?> deployDesc){\r\n    Method[] methods = deployDesc.getBeanType().getMethods();\r\n    MethodsHolder methodHolder = new MethodsHolder();\r\n    for (Method m : methods) {\r\n        methodHolder.checkMethod(m, postConstructPresent);\r\n    }\r\n    if (methodHolder.hasPersistMethods()) {\r\n        deployDesc.addPersistController(new PersistAdapter(new PersistMethodsHolder(methodHolder)));\r\n    }\r\n    if (!methodHolder.postLoads.isEmpty()) {\r\n        deployDesc.addPostLoad(new PostLoadAdapter(methodHolder.postLoads));\r\n    }\r\n    if (!methodHolder.postConstructs.isEmpty()) {\r\n        deployDesc.addPostConstructListener(new PostConstructAdapter(methodHolder.postConstructs));\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.MTable.compare",
	"Comment": "compare to another version of the same table to perform a diff.",
	"Method": "void compare(ModelDiff modelDiff,MTable newTable){\r\n    if (withHistory != newTable.withHistory) {\r\n        if (withHistory) {\r\n            DropHistoryTable dropHistoryTable = new DropHistoryTable();\r\n            dropHistoryTable.setBaseTable(name);\r\n            modelDiff.addDropHistoryTable(dropHistoryTable);\r\n        } else {\r\n            AddHistoryTable addHistoryTable = new AddHistoryTable();\r\n            addHistoryTable.setBaseTable(name);\r\n            modelDiff.addAddHistoryTable(addHistoryTable);\r\n        }\r\n    }\r\n    compareColumns(modelDiff, newTable);\r\n    if (MColumn.different(comment, newTable.comment)) {\r\n        AddTableComment addTableComment = new AddTableComment();\r\n        addTableComment.setName(name);\r\n        if (newTable.comment == null) {\r\n            addTableComment.setComment(DdlHelp.DROP_COMMENT);\r\n        } else {\r\n            addTableComment.setComment(newTable.comment);\r\n        }\r\n        modelDiff.addTableComment(addTableComment);\r\n    }\r\n    compareCompoundKeys(modelDiff, newTable);\r\n    compareUniqueKeys(modelDiff, newTable);\r\n}"
}, {
	"Path": "cyclops.stream.StreamSource.ofMultiple",
	"Comment": "construct a streamsource that supports multiple readers of the same data backed by a queue createdfrom the supplied queuefactory",
	"Method": "MultipleStreamSource<T> ofMultiple(MultipleStreamSource<T> ofMultiple,int backPressureAfter,MultipleStreamSource<T> ofMultiple,QueueFactory<?> q){\r\n    Objects.requireNonNull(q);\r\n    return new MultipleStreamSource<T>(StreamSource.of(q).createQueue());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.DefaultPersister.createRequestInternal",
	"Comment": "create the persist request object additionally specifying the publish status.",
	"Method": "PersistRequestBean<T> createRequestInternal(T bean,Transaction t,PersistRequest.Type type,int flags){\r\n    BeanManager<T> mgr = getBeanManager(bean);\r\n    if (mgr == null) {\r\n        throw new PersistenceException(errNotRegistered(bean.getClass()));\r\n    }\r\n    return createRequest(bean, t, null, mgr, type, flags);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.ListX.range",
	"Comment": "create a listx that contains the integers between skip and take",
	"Method": "ListX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).listX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanProperty.getSecondaryTable",
	"Comment": "return the secondary table this property is associated with.",
	"Method": "String getSecondaryTable(){\r\n    return secondaryTable;\r\n}"
}, {
	"Path": "io.ebean.Ebean.refresh",
	"Comment": "refresh the values of a bean.note that this resets onetomany and manytomany properties so that if theyare accessed a lazy load will refresh the many property.",
	"Method": "void refresh(Object bean){\r\n    serverMgr.getDefaultServer().refresh(bean);\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.LinkedListX.fill",
	"Comment": "generate a linkedlistx from the provided value up to the provided limit number of times",
	"Method": "LinkedListX<T> fill(long limit,T s){\r\n    return ReactiveSeq.fill(s).limit(limit).to(ReactiveConvertableSequence::converter).linkedListX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.autotune.service.DefaultAutoTuneService.isRuntimeTuningUpdates",
	"Comment": "return true if the tuning should update periodically at runtime.",
	"Method": "boolean isRuntimeTuningUpdates(){\r\n    return profilingUpdateFrequency > 0;\r\n}"
}, {
	"Path": "io.ebeanservice.docstore.api.support.DocStoreBeanBaseAdapter.derive",
	"Comment": "return the supplied value or default to the bean name lower case.",
	"Method": "String derive(BeanType<?> desc,String suppliedValue){\r\n    return (suppliedValue != null && !suppliedValue.isEmpty()) ? suppliedValue : desc.getName().toLowerCase();\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.isUpdatesDeleteMissingChildren",
	"Comment": "return true if updates by default delete missing children when cascading save to a onetomany ormanytomany. when not set this defaults to true.",
	"Method": "boolean isUpdatesDeleteMissingChildren(){\r\n    return updatesDeleteMissingChildren;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.autotune.service.DefaultAutoTuneService.reportProfiling",
	"Comment": "output the profiling.when profiling updates are applied to tuning at runtime this reports all tuning and profiling combined.when profiling is not applied at runtime then this reports the diff report with new and diff entries relativeto the existing tuning.",
	"Method": "void reportProfiling(){\r\n    saveProfilingOnShutdown(false);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanProperty.isEmbedded",
	"Comment": "return true if this is an embedded property. in this case it shares thetable and pk of its owner object.",
	"Method": "boolean isEmbedded(){\r\n    return embedded;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocMany.buildImport",
	"Comment": "set the predicates for lazy loading of the association.handles predicates for both onetomany and manytomany.",
	"Method": "void buildImport(IntersectionRow row,EntityBean otherBean){\r\n    importedId.buildImport(row, otherBean);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.ParamTypeUtil.findParamType",
	"Comment": "find and return the parameter type given a generic interface or class.this assumes there is only one generic parameter.returns null if no match was found.",
	"Method": "Class<?> findParamType(Class<?> cls,Class<?> matchType){\r\n    Type paramType = matchByInterfaces(cls, matchType);\r\n    if (paramType == null) {\r\n        Type genericSuperclass = cls.getGenericSuperclass();\r\n        if (genericSuperclass != null) {\r\n            paramType = matchParamType(genericSuperclass, matchType);\r\n        }\r\n    }\r\n    if (paramType instanceof Class<?>) {\r\n        return (Class<?>) paramType;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQuery.close",
	"Comment": "close the resources.the jdbc resultset and statement need to be closed. its important that this method is called.",
	"Method": "void close(){\r\n    try {\r\n        if (auditFindIterate && auditIds != null && !auditIds.isEmpty()) {\r\n            auditIterateLogMessage();\r\n        }\r\n    } catch (Throwable e) {\r\n        logger.error(\"Error logging read audit logs\", e);\r\n    }\r\n    try {\r\n        if (dataReader != null) {\r\n            dataReader.close();\r\n            dataReader = null;\r\n        }\r\n    } catch (SQLException e) {\r\n        logger.error(\"Error closing dataReader\", e);\r\n    }\r\n    JdbcClose.close(pstmt);\r\n    pstmt = null;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.initialiseAll",
	"Comment": "initialise all the beandescriptors.this occurs after all the beandescriptors have been created. this resolvescircular relationships between beandescriptors.also responsible for creating all the beanmanagers which contain thepersister, listener etc.",
	"Method": "void initialiseAll(){\r\n    BeanDescriptorInitContext initContext = new BeanDescriptorInitContext(asOfTableMap, draftTableMap, asOfViewSuffix);\r\n    for (BeanDescriptor<?> d : descMap.values()) {\r\n        d.initialiseId(initContext);\r\n    }\r\n    for (BeanDescriptor<?> d : descMap.values()) {\r\n        d.initInheritInfo();\r\n    }\r\n    for (BeanDescriptor<?> d : descMap.values()) {\r\n        d.initialiseOther(initContext);\r\n    }\r\n    for (BeanDescriptor<?> d : descMap.values()) {\r\n        d.initialiseDocMapping();\r\n    }\r\n    for (BeanDescriptor<?> d : descMap.values()) {\r\n        d.initLast();\r\n        if (!d.isEmbedded()) {\r\n            BeanManager<?> m = beanManagerFactory.create(d);\r\n            beanManagerMap.put(d.getFullName(), m);\r\n            checkForValidEmbeddedId(d);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanEmbeddedMeta.getProperties",
	"Comment": "return the properties with over ridden mapping information.",
	"Method": "BeanProperty[] getProperties(){\r\n    return properties;\r\n}"
}, {
	"Path": "cyclops.companion.rx2.Singles.fromIterable",
	"Comment": "construct a single from iterable by taking the first value from iterable",
	"Method": "Single<T> fromIterable(Iterable<T> t){\r\n    return Single.fromPublisher(Future.fromIterable(t));\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentQueueX.iterate",
	"Comment": "create a persistentqueuex by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "PersistentQueueX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).persistentQueueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.processViewInvalidation",
	"Comment": "invalidate entity beans based on views via their dependent tables.",
	"Method": "void processViewInvalidation(Set<String> viewInvalidation){\r\n    for (String depTable : viewInvalidation) {\r\n        List<BeanDescriptor<?>> list = tableToViewDescMap.get(depTable.toLowerCase());\r\n        if (list != null) {\r\n            for (BeanDescriptor<?> desc : list) {\r\n                desc.clearQueryCache();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.properties.PropertyEval.evaluateExpression",
	"Comment": "convert the expression using jndi, environment variables, system properties\tor existing an property in systemproperties itself.",
	"Method": "String evaluateExpression(String exp){\r\n    if (isJndiExpression(exp)) {\r\n        String val = getJndiProperty(exp);\r\n        if (val != null) {\r\n            return val;\r\n        }\r\n    }\r\n    String val = System.getProperty(exp);\r\n    if (val == null) {\r\n        val = System.getenv(exp);\r\n    }\r\n    return val;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.OrderedSetX.iterate",
	"Comment": "create a orderedsetx by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "OrderedSetX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).orderedSetX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.JtaTransactionManager.setTransactionManager",
	"Comment": "initialise this with the ebean internal transaction manager.",
	"Method": "void setTransactionManager(Object txnMgr){\r\n    this.transactionManager = (TransactionManager) txnMgr;\r\n    this.serverName = transactionManager.getServerName();\r\n}"
}, {
	"Path": "cyclops.futurestream.Pipes.of",
	"Comment": "construct a pipes instance to manage a predefined map of adapaters",
	"Method": "Pipes<K, V> of(Pipes<K, V> of,Map<K, Adapter<V>> registered){\r\n    Objects.requireNonNull(registered);\r\n    final Pipes<K, V> pipes = new Pipes();\r\n    pipes.registered.putAll(registered);\r\n    return pipes;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.MapX.fromMap",
	"Comment": "wrap a transform in a mapx, also supplying a collector for use in operations",
	"Method": "MapX<K, V> fromMap(Map<? extends K, ? extends V> map,MapX<K, V> fromMap,Collector<Tuple2<? extends K, ? extends V>, ?, Map<K, V>> collector,Map<? extends K, ? extends V> map){\r\n    if (map instanceof MapX)\r\n        return (MapX) map;\r\n    if (map instanceof Map)\r\n        return new MapXImpl<K, V>((Map) map, collector);\r\n    return new MapXImpl<K, V>(Streams.stream(map).map(e -> Tuple.tuple(e.getKey(), e.getValue())).collect(collector), collector);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.InternalConfiguration.changeLogPrepare",
	"Comment": "return the changelogprepare to use with a default implementation if none defined.",
	"Method": "ChangeLogPrepare changeLogPrepare(ChangeLogPrepare prepare){\r\n    return plugin((prepare != null) ? prepare : new DefaultChangeLogPrepare());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocMany.createExported",
	"Comment": "create the array of exportedproperty used to build reference objects.",
	"Method": "ExportedProperty[] createExported(){\r\n    BeanProperty idProp = descriptor.getIdProperty();\r\n    ArrayList<ExportedProperty> list = new ArrayList();\r\n    if (idProp != null && idProp.isEmbedded()) {\r\n        BeanPropertyAssocOne<?> one = (BeanPropertyAssocOne<?>) idProp;\r\n        try {\r\n            for (BeanProperty emId : one.getTargetDescriptor().propertiesBaseScalar()) {\r\n                list.add(findMatch(true, emId));\r\n            }\r\n        } catch (PersistenceException e) {\r\n            logger.error(\"Could not find a exported property?\", e);\r\n        }\r\n    } else {\r\n        if (idProp != null) {\r\n            list.add(findMatch(false, idProp));\r\n        }\r\n    }\r\n    return list.toArray(new ExportedProperty[list.size()]);\r\n}"
}, {
	"Path": "org.dataalgorithms.chap05.mapreduce.PairOfWords.compareTo",
	"Comment": "defines a natural sort order for pairs. pairs are sorted first by the left element, and then by the rightelement.",
	"Method": "int compareTo(PairOfWords pair){\r\n    String pl = pair.getLeftElement();\r\n    String pr = pair.getRightElement();\r\n    if (leftElement.equals(pl)) {\r\n        return rightElement.compareTo(pr);\r\n    }\r\n    return leftElement.compareTo(pl);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.text.json.WriteJson.isIncludeEmpty",
	"Comment": "return true if empty collections should be included in the json output.",
	"Method": "boolean isIncludeEmpty(){\r\n    return include != JsonConfig.Include.NON_EMPTY;\r\n}"
}, {
	"Path": "io.ebean.config.TableName.appendCatalogAndSchema",
	"Comment": "append a catalog and schema prefix if they exist to the string builder.",
	"Method": "void appendCatalogAndSchema(StringBuilder buffer){\r\n    if (catalog != null) {\r\n        buffer.append(catalog).append(\".\");\r\n    }\r\n    if (schema != null) {\r\n        buffer.append(schema).append(\".\");\r\n    }\r\n}"
}, {
	"Path": "io.ebean.EbeanServerFactory.initialiseContainer",
	"Comment": "initialise the container with clustering configuration.call this prior to creating any ebeanserver instances or alternatively set thecontainerconfig on the serverconfig when creating the first ebeanserver instance.",
	"Method": "void initialiseContainer(ContainerConfig containerConfig){\r\n    getContainer(containerConfig);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.parse.ReadAnnotations.readAssociations",
	"Comment": "read and process the associated relationship annotations.these can only be processed after the beantables have been createdthis uses the factory as a call back to get the beantable for a givenassociated bean.",
	"Method": "void readAssociations(DeployBeanInfo<?> info,BeanDescriptorManager factory){\r\n    try {\r\n        new AnnotationAssocOnes(info, readConfig, factory).parse();\r\n        new AnnotationAssocManys(info, readConfig, factory).parse();\r\n        new AnnotationSql(info, readConfig).parse();\r\n        new AnnotationClass(info, readConfig).parseAttributeOverride();\r\n        info.getDescriptor().postAnnotations();\r\n    } catch (RuntimeException e) {\r\n        throw new RuntimeException(\"Error reading annotations for \" + info, e);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.DefaultExpressionFactory.raw",
	"Comment": "add raw expression with an array of parameters.the raw expression should contain the same number of ? as there areparameters.",
	"Method": "Expression raw(String raw,Object value,Expression raw,String raw,Object[] values,Expression raw,String raw){\r\n    return new RawExpression(raw, EMPTY_ARRAY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getSelectLastInsertedId",
	"Comment": "return the sql used to return the last inserted id.this is only used with identity columns and getgeneratedkeys is notsupported.",
	"Method": "String getSelectLastInsertedId(boolean publish){\r\n    return publish ? selectLastInsertedId : selectLastInsertedIdDraft;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.isDirty",
	"Comment": "used to skip updates if we know the bean is not dirty. this is the case for entitybeans thathave not been modified.",
	"Method": "boolean isDirty(){\r\n    return dirty;\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.isLazyLoadFailure",
	"Comment": "return true if the bean is marked as having failed lazy loading.",
	"Method": "boolean isLazyLoadFailure(){\r\n    return lazyLoadFailure;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.VectorX.iterate",
	"Comment": "create a vectorx by iterative application of a function to an initial element up to the supplied limit number of times",
	"Method": "VectorX<T> iterate(long limit,T seed,UnaryOperator<T> f){\r\n    return ReactiveSeq.iterate(seed, f).limit(limit).to(ReactiveConvertableSequence::converter).vectorX(LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.OrmQueryRequest.setCancelableQuery",
	"Comment": "set an query object that owns the preparedstatement that can be cancelled.",
	"Method": "void setCancelableQuery(CancelableQuery cancelableQuery){\r\n    query.setCancelableQuery(cancelableQuery);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanDescriptor.getJacksonAnnotatedClass",
	"Comment": "returns the jackson annotated class, if jackson is present.",
	"Method": "Object getJacksonAnnotatedClass(){\r\n    if (jacksonAnnotatedClass == null) {\r\n        jacksonAnnotatedClass = new DeployBeanObtainJackson(serverConfig, beanType).obtain();\r\n    }\r\n    return jacksonAnnotatedClass;\r\n}"
}, {
	"Path": "io.ebean.TxScope.checkBatchMode",
	"Comment": "check for batchsize being set without batch mode and use this to imply persistbatch.all.",
	"Method": "void checkBatchMode(){\r\n    if (batchSize > 0 && notSet(batch) && notSet(batchOnCascade)) {\r\n        batch = PersistBatch.ALL;\r\n    }\r\n}"
}, {
	"Path": "io.ebean.search.AbstractMatch.isOperatorAnd",
	"Comment": "return true if using the and operator otherwise using the or operator.",
	"Method": "boolean isOperatorAnd(){\r\n    return operatorAnd;\r\n}"
}, {
	"Path": "io.ebean.PrimaryServer.setSkip",
	"Comment": "set whether to skip automatically creating the primary server.",
	"Method": "void setSkip(boolean skip){\r\n    PrimaryServer.skip = skip;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.setEntityBeanClass",
	"Comment": "test the bean type to see if it implements entitybean interface already.",
	"Method": "void setEntityBeanClass(DeployBeanDescriptor<?> desc){\r\n    Class<?> beanClass = desc.getBeanType();\r\n    if (!hasEntityBeanInterface(beanClass)) {\r\n        String msg = \"Bean \" + beanClass + \" is not enhanced? Check packages specified in ebean.mf. If you are running in IDEA or \" + \"Eclipse check that the enhancement plugin is installed. See https://ebean.io/docs/trouble-shooting#not-enhanced\";\r\n        throw new BeanNotEnhancedException(msg);\r\n    }\r\n    checkInheritedClasses(beanClass);\r\n    entityBeanCount++;\r\n}"
}, {
	"Path": "com.oath.cyclops.util.stream.scheduling.cron.CronExpression.isSatisfiedBy",
	"Comment": "indicates whether the given date satisfies the cron expression. note thatmilliseconds are ignored, so two dates falling on different millisecondsof the same second will always have the same result here.",
	"Method": "boolean isSatisfiedBy(Date date){\r\n    final Calendar testDateCal = Calendar.getInstance(getTimeZone());\r\n    testDateCal.setTime(date);\r\n    testDateCal.set(Calendar.MILLISECOND, 0);\r\n    final Date originalDate = testDateCal.getTime();\r\n    testDateCal.add(Calendar.SECOND, -1);\r\n    final Date timeAfter = getTimeAfter(testDateCal.getTime());\r\n    return timeAfter != null && timeAfter.equals(originalDate);\r\n}"
}, {
	"Path": "io.ebean.config.ClassLoadConfig.isJavaxValidationAnnotationsPresent",
	"Comment": "return true if javax validation annotations like size and notnull are present.",
	"Method": "boolean isJavaxValidationAnnotationsPresent(){\r\n    return isPresent(\"javax.validation.constraints.NotNull\");\r\n}"
}, {
	"Path": "io.ebean.util.StringHelper.countOccurances",
	"Comment": "returns the number of times a particular string occurs in another string.e.g. count the number of single quotes.",
	"Method": "int countOccurances(String content,String occurs,int countOccurances,String content,String occurs,int pos,int countSoFar){\r\n    while (true) {\r\n        int equalsPos = content.indexOf(occurs, pos);\r\n        if (equalsPos > -1) {\r\n            countSoFar += 1;\r\n            pos = equalsPos + occurs.length();\r\n        } else {\r\n            return countSoFar;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.build.ModelBuildElementTable.build",
	"Comment": "build and add the mtable model for the elementcollection property.",
	"Method": "void build(ModelBuildContext ctx,BeanPropertyAssocMany<?> manyProp){\r\n    BeanTable beanTable = manyProp.getBeanTable();\r\n    BeanDescriptor<?> targetDescriptor = manyProp.getTargetDescriptor();\r\n    MTable table = new MTable(beanTable.getBaseTable());\r\n    VisitAllUsing.visitOne(targetDescriptor, new ModelBuildPropertyVisitor(ctx, table, targetDescriptor));\r\n    ctx.addTable(table);\r\n}"
}, {
	"Path": "io.ebeaninternal.api.LoadRequest.isLazy",
	"Comment": "return true if this is a lazy load and false if it is a secondary query.",
	"Method": "boolean isLazy(){\r\n    return lazy;\r\n}"
}, {
	"Path": "io.ebean.text.json.JsonReadOptions.setEnableLazyLoading",
	"Comment": "set to true to enable lazy loading on partially populated beans.if this is set to true a persistence context will be created if one hasnot already been supplied.",
	"Method": "JsonReadOptions setEnableLazyLoading(boolean enableLazyLoading){\r\n    this.enableLazyLoading = enableLazyLoading;\r\n    return this;\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachWithError",
	"Comment": "perform a foreach operation over the streamcapturing any elements and errors in the supplied consumers,",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachWithError(FutureStream<T> stream,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    final CompletableFuture<Subscription> subscription = new CompletableFuture();\r\n    final CompletableFuture<Boolean> streamCompleted = new CompletableFuture();\r\n    return tuple(subscription, () -> {\r\n        stream.subscribe(new Subscriber<T>() {\r\n            @Override\r\n            public void onSubscribe(final Subscription s) {\r\n                Objects.requireNonNull(s);\r\n                subscription.complete(s);\r\n                s.request(Long.MAX_VALUE);\r\n            }\r\n            @Override\r\n            public void onNext(final T t) {\r\n                consumerElement.accept(t);\r\n            }\r\n            @Override\r\n            public void onError(final Throwable t) {\r\n                consumerError.accept(t);\r\n            }\r\n            @Override\r\n            public void onComplete() {\r\n                streamCompleted.complete(true);\r\n            }\r\n        });\r\n    }, streamCompleted);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachWithError",
	"Comment": "perform a foreach operation over the streamcapturing any elements and errors in the supplied consumers,",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachWithError(FutureStream<T> stream,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    Objects.requireNonNull(s);\r\n    subscription.complete(s);\r\n    s.request(Long.MAX_VALUE);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachWithError",
	"Comment": "perform a foreach operation over the streamcapturing any elements and errors in the supplied consumers,",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachWithError(FutureStream<T> stream,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    consumerElement.accept(t);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachWithError",
	"Comment": "perform a foreach operation over the streamcapturing any elements and errors in the supplied consumers,",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachWithError(FutureStream<T> stream,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    consumerError.accept(t);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachWithError",
	"Comment": "perform a foreach operation over the streamcapturing any elements and errors in the supplied consumers,",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachWithError(FutureStream<T> stream,Consumer<? super T> consumerElement,Consumer<? super Throwable> consumerError){\r\n    streamCompleted.complete(true);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.DbOffline.asH2",
	"Comment": "bring up the next ebeanserver instance using the h2 platform.",
	"Method": "void asH2(){\r\n    setPlatform(Platform.H2);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQueryPlan.bindEncryptedProperties",
	"Comment": "bind keys for encrypted properties if necessary returning the databind.",
	"Method": "DataBind bindEncryptedProperties(PreparedStatement stmt,Connection conn){\r\n    DataBind dataBind = new DataBind(dataTimeZone, stmt, conn);\r\n    if (encryptedProps != null) {\r\n        for (STreeProperty encryptedProp : encryptedProps) {\r\n            dataBind.setString(encryptedProp.getEncryptKeyAsString());\r\n        }\r\n    }\r\n    return dataBind;\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.setLoadedLazy",
	"Comment": "when finished loading for lazy or refresh on an already partially populatedbean.",
	"Method": "void setLoadedLazy(){\r\n    this.state = STATE_LOADED;\r\n    this.lazyLoadProperty = -1;\r\n}"
}, {
	"Path": "io.ebean.config.PlatformConfig.setAllQuotedIdentifiers",
	"Comment": "set to true if all db column and table names should use quoted identifiers.",
	"Method": "void setAllQuotedIdentifiers(boolean allQuotedIdentifiers){\r\n    this.allQuotedIdentifiers = allQuotedIdentifiers;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.DequeX.generate",
	"Comment": "generate a dequex from the provided supplier up to the provided limit number of times",
	"Method": "DequeX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).dequeX(LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQuery.createPersistenceException",
	"Comment": "create a persistenceexception including interesting information like the bindlog and sql used.",
	"Method": "PersistenceException createPersistenceException(SQLException e){\r\n    return request.translate(bindLog, sql, e);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.dmlbind.BindableIdScalar.deriveConcatenatedId",
	"Comment": "should not be called as this is really only for concatenated keys.",
	"Method": "boolean deriveConcatenatedId(PersistRequestBean<?> persist){\r\n    throw new PersistenceException(\"Should not be called? only for concatinated keys\");\r\n}"
}, {
	"Path": "io.ebeaninternal.server.type.ScalarTypeJsonList.typeFor",
	"Comment": "return the appropriate scalartype based requested dbtype and if postgres.",
	"Method": "ScalarType<?> typeFor(boolean postgres,int dbType,DocPropertyType docType){\r\n    if (postgres) {\r\n        switch(dbType) {\r\n            case DbPlatformType.JSONB:\r\n                return new ScalarTypeJsonList.JsonB(docType);\r\n            case DbPlatformType.JSON:\r\n                return new ScalarTypeJsonList.Json(docType);\r\n        }\r\n    }\r\n    return new ScalarTypeJsonList.Varchar(docType);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setUpdateAllPropertiesInBatch",
	"Comment": "set to false if by default updates in jdbc batch should not include all properties.this mode can be explicitly set per transaction.",
	"Method": "void setUpdateAllPropertiesInBatch(boolean updateAllPropertiesInBatch){\r\n    this.updateAllPropertiesInBatch = updateAllPropertiesInBatch;\r\n}"
}, {
	"Path": "org.dataalgorithms.chapB04.rankproduct.spark.SparkRankProductUsingCombineByKey.computeRankedProductsUsingCombineByKey",
	"Comment": "where n is the number of elements for computing the rankedproduct",
	"Method": "JavaPairRDD<String, Tuple2<Double, Integer>> computeRankedProductsUsingCombineByKey(JavaSparkContext context,JavaPairRDD<String, Long>[] ranks){\r\n    JavaPairRDD<String, Long> unionRDD = context.union(ranks);\r\n    Function<Long, RankProduct> createCombiner = new Function<Long, RankProduct>() {\r\n        @Override\r\n        public RankProduct call(Long x) {\r\n            return new RankProduct(x, 1);\r\n        }\r\n    };\r\n    Function2<RankProduct, Long, RankProduct> addAndCount = new Function2<RankProduct, Long, RankProduct>() {\r\n        @Override\r\n        public RankProduct call(RankProduct a, Long x) {\r\n            a.product *= x;\r\n            a.count += 1;\r\n            return a;\r\n        }\r\n    };\r\n    Function2<RankProduct, RankProduct, RankProduct> mergeCombiners = new Function2<RankProduct, RankProduct, RankProduct>() {\r\n        @Override\r\n        public RankProduct call(RankProduct a, RankProduct b) {\r\n            a.product *= b.product;\r\n            a.count += b.count;\r\n            return a;\r\n        }\r\n    };\r\n    JavaPairRDD<String, RankProduct> combinedByGeneRDD = unionRDD.combineByKey(createCombiner, addAndCount, mergeCombiners);\r\n    JavaPairRDD<String, Tuple2<Double, Integer>> rankedProducts = combinedByGeneRDD.mapValues(new Function<RankProduct, Tuple2<Double, Integer>>() {\r\n        @Override\r\n        public Tuple2<Double, Integer> call(RankProduct value) {\r\n            double theRankedProduct = value.rank();\r\n            return new Tuple2<Double, Integer>(theRankedProduct, value.count);\r\n        }\r\n    });\r\n    return rankedProducts;\r\n}"
}, {
	"Path": "org.dataalgorithms.chapB04.rankproduct.spark.SparkRankProductUsingCombineByKey.computeRankedProductsUsingCombineByKey",
	"Comment": "where n is the number of elements for computing the rankedproduct",
	"Method": "JavaPairRDD<String, Tuple2<Double, Integer>> computeRankedProductsUsingCombineByKey(JavaSparkContext context,JavaPairRDD<String, Long>[] ranks){\r\n    return new RankProduct(x, 1);\r\n}"
}, {
	"Path": "org.dataalgorithms.chapB04.rankproduct.spark.SparkRankProductUsingCombineByKey.computeRankedProductsUsingCombineByKey",
	"Comment": "where n is the number of elements for computing the rankedproduct",
	"Method": "JavaPairRDD<String, Tuple2<Double, Integer>> computeRankedProductsUsingCombineByKey(JavaSparkContext context,JavaPairRDD<String, Long>[] ranks){\r\n    a.product *= x;\r\n    a.count += 1;\r\n    return a;\r\n}"
}, {
	"Path": "org.dataalgorithms.chapB04.rankproduct.spark.SparkRankProductUsingCombineByKey.computeRankedProductsUsingCombineByKey",
	"Comment": "where n is the number of elements for computing the rankedproduct",
	"Method": "JavaPairRDD<String, Tuple2<Double, Integer>> computeRankedProductsUsingCombineByKey(JavaSparkContext context,JavaPairRDD<String, Long>[] ranks){\r\n    a.product *= b.product;\r\n    a.count += b.count;\r\n    return a;\r\n}"
}, {
	"Path": "org.dataalgorithms.chapB04.rankproduct.spark.SparkRankProductUsingCombineByKey.computeRankedProductsUsingCombineByKey",
	"Comment": "where n is the number of elements for computing the rankedproduct",
	"Method": "JavaPairRDD<String, Tuple2<Double, Integer>> computeRankedProductsUsingCombineByKey(JavaSparkContext context,JavaPairRDD<String, Long>[] ranks){\r\n    double theRankedProduct = value.rank();\r\n    return new Tuple2<Double, Integer>(theRankedProduct, value.count);\r\n}"
}, {
	"Path": "org.tests.cache.TestCacheCollectionIds.testUpdatingCollectionCacheForManyToManyRelationsWithinStatelessUpdate",
	"Comment": "when updating a manytomany relations also the collection cache must be updated.",
	"Method": "void testUpdatingCollectionCacheForManyToManyRelationsWithinStatelessUpdate(){\r\n    ResetBasicData.reset();\r\n    OCachedBean cachedBean = new OCachedBean();\r\n    cachedBean.setName(\"cachedBeanTest\");\r\n    cachedBean.getCountries().add(Ebean.find(Country.class, \"NZ\"));\r\n    cachedBean.getCountries().add(Ebean.find(Country.class, \"AU\"));\r\n    Ebean.save(cachedBean);\r\n    ServerCache cachedBeanCountriesCache = cacheManager.getCollectionIdsCache(OCachedBean.class, \"countries\");\r\n    cachedBeanCountriesCache.clear();\r\n    assertEquals(0, cachedBeanCountriesCache.size());\r\n    OCachedBean dummyLoad = Ebean.find(OCachedBean.class, cachedBean.getId());\r\n    List<Country> dummyCountries = dummyLoad.getCountries();\r\n    assertEquals(2, dummyCountries.size());\r\n    assertEquals(\"countries cache now loaded with 1 entry\", 1, cachedBeanCountriesCache.size());\r\n    CachedManyIds dummyEntry = (CachedManyIds) cachedBeanCountriesCache.get(dummyLoad.getId());\r\n    Assert.assertNotNull(dummyEntry);\r\n    assertEquals(\"2 ids in the entry\", 2, dummyEntry.getIdList().size());\r\n    assertTrue(dummyEntry.getIdList().contains(\"NZ\"));\r\n    assertTrue(dummyEntry.getIdList().contains(\"AU\"));\r\n    OCachedBean update = new OCachedBean();\r\n    update.setId(cachedBean.getId());\r\n    update.setName(\"modified\");\r\n    update.getCountries().add(Ebean.find(Country.class, \"AU\"));\r\n    Ebean.update(update);\r\n    awaitL2Cache();\r\n    assertEquals(\"countries entry still there (but updated)\", 1, cachedBeanCountriesCache.size());\r\n    CachedManyIds cachedManyIds = (CachedManyIds) cachedBeanCountriesCache.get(update.getId());\r\n    assertEquals(1, cachedManyIds.getIdList().size());\r\n    assertFalse(cachedManyIds.getIdList().contains(\"NZ\"));\r\n    assertTrue(cachedManyIds.getIdList().contains(\"AU\"));\r\n    OCachedBean result = Ebean.find(OCachedBean.class, cachedBean.getId());\r\n    assertEquals(1, result.getCountries().size());\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.PersistentQueueX.range",
	"Comment": "create a persistentqueuex that contains the integers between skip and take",
	"Method": "PersistentQueueX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).persistentQueueX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.BaseTableDdl.inlineUniqueConstraintSingle",
	"Comment": "write the unique constraint inline with the create table statement.",
	"Method": "void inlineUniqueConstraintSingle(DdlBuffer buffer,Column column){\r\n    String uqName = column.getUnique();\r\n    if (uqName == null) {\r\n        uqName = column.getUniqueOneToOne();\r\n    }\r\n    buffer.append(\",\").newLine();\r\n    buffer.append(\"  constraint \").append(uqName).append(\" unique \");\r\n    buffer.append(\"(\");\r\n    buffer.append(lowerColumnName(column.getName()));\r\n    buffer.append(\")\");\r\n}"
}, {
	"Path": "io.ebeaninternal.server.type.DefaultTypeManager.getScalarType",
	"Comment": "return a scalartype for a given class.used for java.util.date and java.util.calendar which can be mapped todifferent jdbctypes in a single system.",
	"Method": "ScalarType<?> getScalarType(String cast,ScalarType<?> getScalarType,int jdbcType,ScalarType<?> getScalarType,Class<?> type,ScalarType<?> getScalarType,Class<?> type,int jdbcType){\r\n    if (File.class.equals(type)) {\r\n        return fileType;\r\n    }\r\n    ScalarType<?> scalarType = getLobTypes(jdbcType);\r\n    if (scalarType != null) {\r\n        return scalarType;\r\n    }\r\n    scalarType = typeMap.get(type);\r\n    if (scalarType != null) {\r\n        if (jdbcType == 0 || scalarType.getJdbcType() == jdbcType) {\r\n            return scalarType;\r\n        }\r\n    }\r\n    if (type.equals(java.util.Date.class)) {\r\n        return extraTypeFactory.createUtilDate(jsonDateTime, jdbcType);\r\n    }\r\n    if (type.equals(java.util.Calendar.class)) {\r\n        return extraTypeFactory.createCalendar(jsonDateTime, jdbcType);\r\n    }\r\n    throw new IllegalArgumentException(\"Unmatched ScalarType for \" + type + \" jdbcType:\" + jdbcType);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssoc.hasId",
	"Comment": "return true if the unique id properties are all not null for this bean.",
	"Method": "boolean hasId(EntityBean bean){\r\n    BeanDescriptor<?> targetDesc = getTargetDescriptor();\r\n    BeanProperty idProp = targetDesc.getIdProperty();\r\n    if (idProp != null) {\r\n        Object value = idProp.getValue(bean);\r\n        if (value == null) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getBaseTable",
	"Comment": "return the base table. only properties mapped to the base table are bydefault persisted.",
	"Method": "String getBaseTable(String getBaseTable,SpiQuery.TemporalMode mode){\r\n    switch(mode) {\r\n        case DRAFT:\r\n            return draftTable;\r\n        case VERSIONS:\r\n            return baseTableVersionsBetween;\r\n        case AS_OF:\r\n            return baseTableAsOf;\r\n        default:\r\n            return baseTable;\r\n    }\r\n}"
}, {
	"Path": "chapter03linkedlists.DoublyLinkedList.removeHead",
	"Comment": "remove the head value from the list. if the list is empty, do nothing.",
	"Method": "int removeHead(){\r\n    if (length == 0)\r\n        return Integer.MIN_VALUE;\r\n    DLLNode save = head.getNext();\r\n    head.setNext(save.getNext());\r\n    save.getNext().setPrev(head);\r\n    length -= 1;\r\n    return save.getData();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.grammer.EqlAdapter.peekExprList",
	"Comment": "return the current expression list that expressions should be added to.",
	"Method": "ExpressionList<T> peekExprList(){\r\n    if (textMode) {\r\n        return _peekText();\r\n    }\r\n    if (whereStack == null) {\r\n        whereStack = new ArrayStack();\r\n        whereStack.push(query.where());\r\n    }\r\n    return whereStack.peek();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getElPropertyDeploy",
	"Comment": "similar to elpropertyvalue but also uses foreign key shortcuts.the foreign key shortcuts means we can avoid unnecessary joins.",
	"Method": "ElPropertyDeploy getElPropertyDeploy(String propName){\r\n    ElPropertyDeploy elProp = elDeployCache.get(propName);\r\n    if (elProp != null) {\r\n        return elProp;\r\n    }\r\n    if (!propName.contains(\".\")) {\r\n        elProp = getElGetValue(propName);\r\n    } else {\r\n        elProp = buildElGetValue(propName, null, true);\r\n    }\r\n    if (elProp != null) {\r\n        elDeployCache.put(propName, elProp);\r\n    }\r\n    return elProp;\r\n}"
}, {
	"Path": "io.ebean.Ebean.mock",
	"Comment": "backdoor for registering a mock implementation of ebeanserver as the default server.",
	"Method": "EbeanServer mock(String name,EbeanServer server,boolean defaultServer){\r\n    EbeanServer originalPrimaryServer = serverMgr.defaultServer;\r\n    serverMgr.registerWithName(name, server, defaultServer);\r\n    return originalPrimaryServer;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.BagX.generate",
	"Comment": "generate a bagx from the provided supplier up to the provided limit number of times",
	"Method": "BagX<T> generate(long limit,Supplier<T> s){\r\n    return ReactiveSeq.generate(s).limit(limit).to(ReactiveConvertableSequence::converter).bagX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.SqlTreeBuilder.buildExtraJoins",
	"Comment": "build extra joins to support properties used in where clause but notalready in select clause.",
	"Method": "void buildExtraJoins(STreeType desc,List<SqlTreeNode> myList){\r\n    if (rawSql) {\r\n        return;\r\n    }\r\n    Set<String> predicateIncludes = predicates.getPredicateIncludes();\r\n    if (predicateIncludes == null) {\r\n        return;\r\n    }\r\n    predicateIncludes.removeAll(manyWhereJoins.getPropertyNames());\r\n    predicateIncludes.addAll(predicates.getOrderByIncludes());\r\n    IncludesDistiller extraJoinDistill = new IncludesDistiller(desc, selectIncludes, predicateIncludes);\r\n    Collection<SqlTreeNodeExtraJoin> extraJoins = extraJoinDistill.getExtraJoinRootNodes();\r\n    if (!extraJoins.isEmpty()) {\r\n        for (SqlTreeNodeExtraJoin extraJoin : extraJoins) {\r\n            myList.add(extraJoin);\r\n            if (extraJoin.isManyJoin()) {\r\n                query.setSqlDistinct(true);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultServer.deleteAllInternal",
	"Comment": "delete all the beans in the iterator with an explicit transaction.",
	"Method": "int deleteAllInternal(Collection<?> beans,Transaction transaction,boolean permanent){\r\n    if (beans == null || beans.isEmpty()) {\r\n        return 0;\r\n    }\r\n    return executeInTrans((txn) -> {\r\n        txn.checkBatchEscalationOnCollection();\r\n        int deleteCount = 0;\r\n        for (Object bean : beans) {\r\n            persister.delete(checkEntityBean(bean), txn, permanent);\r\n            deleteCount++;\r\n        }\r\n        txn.flushBatchOnCollection();\r\n        return deleteCount;\r\n    }, transaction);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.BaseSimpleReact.fromStream",
	"Comment": "start a reactive dataflow from a stream of completablefutures.",
	"Method": "BaseSimpleReactStream<U> fromStream(Stream<CompletableFuture<U>> stream){\r\n    final Stream s = stream;\r\n    return construct(s);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.checkForVersionProperties",
	"Comment": "search for version properties also including embedded beans.",
	"Method": "boolean checkForVersionProperties(DeployBeanDescriptor<?> desc){\r\n    boolean hasVersionProperty = false;\r\n    List<DeployBeanProperty> props = desc.propertiesBase();\r\n    for (DeployBeanProperty prop : props) {\r\n        if (prop.isVersionColumn()) {\r\n            hasVersionProperty = true;\r\n        }\r\n    }\r\n    return hasVersionProperty;\r\n}"
}, {
	"Path": "cyclops.stream.pushable.MultipleStreamSource.futureStream",
	"Comment": "create a pushable lazyfuturestream using the supplied reactpool",
	"Method": "FutureStream<T> futureStream(LazyReact s){\r\n    return s.fromStream(topic.stream());\r\n}"
}, {
	"Path": "io.ebean.FetchConfig.lazy",
	"Comment": "specify that this path should be lazy loaded with a specified batch size.",
	"Method": "FetchConfig lazy(FetchConfig lazy,int lazyBatchSize){\r\n    this.lazyBatchSize = lazyBatchSize;\r\n    this.queryAll = false;\r\n    return this;\r\n}"
}, {
	"Path": "io.ebeaninternal.api.LoadBeanRequest.getIdList",
	"Comment": "return the list of id values for the beans in the lazy load buffer.",
	"Method": "List<Object> getIdList(int batchSize){\r\n    List<Object> idList = new ArrayList(batchSize);\r\n    BeanDescriptor<?> desc = loadBuffer.getBeanDescriptor();\r\n    for (EntityBeanIntercept ebi : batch) {\r\n        EntityBean bean = ebi.getOwner();\r\n        idList.add(desc.getId(bean));\r\n    }\r\n    if (!desc.isMultiValueIdSupported() && !idList.isEmpty()) {\r\n        int extraIds = batchSize - batch.size();\r\n        if (extraIds > 0) {\r\n            Object firstId = idList.get(0);\r\n            for (int i = 0; i < extraIds; i++) {\r\n                idList.add(firstId);\r\n            }\r\n        }\r\n    }\r\n    return idList;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.id.ImportedIdSimple.sort",
	"Comment": "return the list as an array sorted into the same order as the bean properties.",
	"Method": "ImportedIdSimple[] sort(List<ImportedIdSimple> list){\r\n    ImportedIdSimple[] importedIds = list.toArray(new ImportedIdSimple[list.size()]);\r\n    Arrays.sort(importedIds, COMPARATOR);\r\n    return importedIds;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorCacheHelp.naturalKeyLookup",
	"Comment": "use natural keys to hit the bean cache and return resulting hits.",
	"Method": "BeanCacheResult<T> naturalKeyLookup(PersistenceContext context,Set<Object> keys){\r\n    if (context == null) {\r\n        context = new DefaultPersistenceContext();\r\n    }\r\n    Map<Object, Object> naturalKeyMap = naturalKeyCache.getAll(keys);\r\n    if (natLog.isTraceEnabled()) {\r\n        natLog.trace(\" LOOKUP Many {}({}) - hits:{}\", cacheName, keys, naturalKeyMap);\r\n    }\r\n    BeanCacheResult<T> result = new BeanCacheResult();\r\n    if (naturalKeyMap.isEmpty()) {\r\n        return result;\r\n    }\r\n    Map<Object, Object> reverseMap = new HashMap();\r\n    for (Map.Entry<Object, Object> entry : naturalKeyMap.entrySet()) {\r\n        reverseMap.put(entry.getValue(), entry.getKey());\r\n    }\r\n    Set<Object> ids = new HashSet(naturalKeyMap.values());\r\n    Map<Object, Object> beanDataMap = beanCache.getAll(ids);\r\n    if (beanLog.isTraceEnabled()) {\r\n        beanLog.trace(\"   GET MANY {}({}) - hits:{}\", cacheName, ids, beanDataMap.keySet());\r\n    }\r\n    for (Map.Entry<Object, Object> entry : beanDataMap.entrySet()) {\r\n        Object id = entry.getKey();\r\n        CachedBeanData cachedBeanData = (CachedBeanData) entry.getValue();\r\n        T bean = convertToBean(id, false, context, cachedBeanData);\r\n        Object naturalKey = reverseMap.get(id);\r\n        result.add(bean, naturalKey);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.cluster.ClusterManager.broadcast",
	"Comment": "send the message headers and payload to every server in the cluster.",
	"Method": "void broadcast(RemoteTransactionEvent event){\r\n    if (broadcast != null) {\r\n        if (clusterLogger.isDebugEnabled()) {\r\n            clusterLogger.debug(\"sending: {}\", event);\r\n        }\r\n        broadcast.broadcast(event);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.BaseTableDdl.addTableCommentInline",
	"Comment": "add the table comment inline with the create table statement.",
	"Method": "void addTableCommentInline(DdlBuffer apply,CreateTable createTable){\r\n    if (platformDdl.isInlineComments()) {\r\n        String tableComment = createTable.getComment();\r\n        if (!StringHelper.isNull(tableComment)) {\r\n            platformDdl.inlineTableComment(apply, tableComment);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocOne.setParentBeanToChild",
	"Comment": "set the parent bean to the child bean if it has not already been set.",
	"Method": "void setParentBeanToChild(EntityBean parent,EntityBean child){\r\n    if (primaryKeyExport) {\r\n        Object parentId = descriptor.getId(parent);\r\n        targetDescriptor.convertSetId(parentId, child);\r\n    }\r\n    if (mappedBy != null) {\r\n        BeanProperty beanProperty = targetDescriptor.getBeanProperty(mappedBy);\r\n        if (beanProperty != null && beanProperty.getValue(child) == null) {\r\n            beanProperty.setValue(child, parent);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.SqlErrorCodes.build",
	"Comment": "build and return the sqlcodetranslator with the mapped codes.",
	"Method": "SqlCodeTranslator build(){\r\n    return new SqlCodeTranslator(map);\r\n}"
}, {
	"Path": "cyclops.reactive.ReactiveSeq.rangeLong",
	"Comment": "create an efficiently reversable sequence that produces the integersbetween skip and take",
	"Method": "ReactiveSeq<Long> rangeLong(long start,long step,long end,ReactiveSeq<Long> rangeLong,long start,long end){\r\n    if (start > end)\r\n        return rangeLong(end, start);\r\n    final ReversingRangeLongSpliterator range = new ReversingRangeLongSpliterator(start, end, 1, false);\r\n    return Streams.reactiveSeq(range, Optional.ofNullable(range));\r\n}"
}, {
	"Path": "io.ebean.Pairs.getConcatSeparator",
	"Comment": "return the separator character used with db varchar concatenation to combine the 2 values.",
	"Method": "String getConcatSeparator(){\r\n    return concatSeparator;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.AbstractValueExpression.strValue",
	"Comment": "return the string bind value taking into account named parameters.",
	"Method": "String strValue(){\r\n    return NamedParamHelp.valueAsString(bindValue);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.InternalConfiguration.getSlowQueryListener",
	"Comment": "return the slowquerylistener with a default that logs a warning message.",
	"Method": "SlowQueryListener getSlowQueryListener(){\r\n    long millis = serverConfig.getSlowQueryMillis();\r\n    if (millis < 1) {\r\n        return null;\r\n    }\r\n    SlowQueryListener listener = serverConfig.getSlowQueryListener();\r\n    if (listener == null) {\r\n        listener = serverConfig.service(SlowQueryListener.class);\r\n        if (listener == null) {\r\n            listener = new DefaultSlowQueryListener();\r\n        }\r\n    }\r\n    return listener;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.text.json.ReadJson.forJson",
	"Comment": "return a new instance of readjson using the existing context but with a new jsonparser.",
	"Method": "SpiJsonReader forJson(JsonParser moreJson,boolean resetContext){\r\n    return new ReadJson(moreJson, this, resetContext);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.type.DefaultTypeManager.initialiseCustomScalarTypes",
	"Comment": "automatically find any scalartypes by searching through the class path.in avaje.properties define a list of packages in which scalartypes arefound. this will search for any class that implements the scalartypeinterface and register it with this typemanager.",
	"Method": "void initialiseCustomScalarTypes(BootupClasses bootupClasses){\r\n    for (Class<? extends ScalarType<?>> cls : bootupClasses.getScalarTypes()) {\r\n        try {\r\n            ScalarType<?> scalarType;\r\n            if (objectMapper == null) {\r\n                scalarType = cls.newInstance();\r\n            } else {\r\n                try {\r\n                    Constructor<? extends ScalarType<?>> constructor = cls.getConstructor(ObjectMapper.class);\r\n                    scalarType = constructor.newInstance((ObjectMapper) objectMapper);\r\n                } catch (NoSuchMethodException e) {\r\n                    scalarType = cls.newInstance();\r\n                }\r\n            }\r\n            addCustomType(scalarType);\r\n        } catch (Exception e) {\r\n            String msg = \"Error loading ScalarType [\" + cls.getName() + \"]\";\r\n            logger.error(msg, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssoc.getTargetIdProperty",
	"Comment": "return the id property of the target entity type.this will return null for multiple id properties.",
	"Method": "String getTargetIdProperty(){\r\n    return targetIdProperty;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.MapX.toDequeX",
	"Comment": "convert this mapx to a dequex via the provided transformation function",
	"Method": "DequeX<T> toDequeX(Function<? super Tuple2<? super K, ? super V>, ? extends T> fn){\r\n    return DequeX.narrow(stream().map(fn).to(ReactiveConvertableSequence::converter).dequeX());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.setDeleteMissingChildren",
	"Comment": "set if deletemissingchildren occurs on cascade save to onetomany or manytomany.",
	"Method": "void setDeleteMissingChildren(boolean deleteMissingChildren){\r\n    this.deleteMissingChildren = deleteMissingChildren;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.lib.DaemonExecutorService.shutdown",
	"Comment": "shutdown this thread pool nicely if possible.this will wait a maximum of 20 seconds before terminating any threads stillworking.",
	"Method": "void shutdown(){\r\n    synchronized (this) {\r\n        if (service.isShutdown()) {\r\n            logger.debug(\"DaemonExecutorService[{}] already shut down\", namePrefix);\r\n            return;\r\n        }\r\n        try {\r\n            logger.debug(\"DaemonExecutorService[{}] shutting down...\", namePrefix);\r\n            service.shutdown();\r\n            if (!service.awaitTermination(shutdownWaitSeconds, TimeUnit.SECONDS)) {\r\n                logger.info(\"DaemonExecutorService[{}] shut down timeout exceeded. Terminating running threads.\", namePrefix);\r\n                service.shutdownNow();\r\n            }\r\n        } catch (Exception e) {\r\n            logger.error(\"Error during shutdown of DaemonThreadPool[\" + namePrefix + \"]\", e);\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.DefaultDbMigration.setServerConfig",
	"Comment": "set the serverconfig to use. typically this is not called explicitly.",
	"Method": "void setServerConfig(ServerConfig config){\r\n    if (this.serverConfig == null) {\r\n        this.serverConfig = config;\r\n    }\r\n    if (migrationConfig == null) {\r\n        this.migrationConfig = serverConfig.getMigrationConfig();\r\n    }\r\n    if (constraintNaming == null) {\r\n        this.constraintNaming = serverConfig.getConstraintNaming();\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanPropertyAssocOne.getDeployEmbedded",
	"Comment": "return the deploy information specifically for the deploymentof embedded beans.",
	"Method": "DeployBeanEmbedded getDeployEmbedded(){\r\n    if (deployEmbedded == null) {\r\n        deployEmbedded = new DeployBeanEmbedded();\r\n    }\r\n    return deployEmbedded;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultServer.useTransactionPersistenceContext",
	"Comment": "return true if transactions persistencecontext should be used.",
	"Method": "boolean useTransactionPersistenceContext(SpiQuery<T> query){\r\n    return PersistenceContextScope.TRANSACTION == getPersistenceContextScope(query);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultBeanLoader.executeQuery",
	"Comment": "execute the lazy load query taking into account mysql transaction oddness.",
	"Method": "List<?> executeQuery(LoadRequest loadRequest,SpiQuery<?> query){\r\n    if (onIterateUseExtraTxn && loadRequest.isParentFindIterate()) {\r\n        SpiTransaction extraTxn = server.createQueryTransaction(query.getTenantId());\r\n        try {\r\n            return server.findList(query, extraTxn);\r\n        } finally {\r\n            extraTxn.end();\r\n        }\r\n    } else {\r\n        return server.findList(query, loadRequest.getTransaction());\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.AutoTuneConfig.setProfilingFile",
	"Comment": "set the name of the file that profiling information is written to.",
	"Method": "void setProfilingFile(String profilingFile){\r\n    this.profilingFile = profilingFile;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setChangeLogRegister",
	"Comment": "set the changelogregister which controls which changelogfilter is used for eachbean type and in this way provide fine grained control over which persist requestsare included in the change log.",
	"Method": "void setChangeLogRegister(ChangeLogRegister changeLogRegister){\r\n    this.changeLogRegister = changeLogRegister;\r\n}"
}, {
	"Path": "io.ebean.ProfileLocation.create",
	"Comment": "create and return a new profilelocation with a given linenumber and label.",
	"Method": "ProfileLocation create(ProfileLocation create,int lineNumber,String label){\r\n    return XServiceProvider.profileLocationFactory().create(lineNumber, label);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.generatedproperty.GeneratedCounterInteger.includeInInsert",
	"Comment": "include this in every insert setting initial counter value to 1.",
	"Method": "boolean includeInInsert(){\r\n    return true;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanPropertyAssocMany.getModifyListenMode",
	"Comment": "return the mode for listening to changes to the list set or map.",
	"Method": "ModifyListenMode getModifyListenMode(){\r\n    return modifyListenMode;\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.preGetter",
	"Comment": "method that is called prior to a getter method on the actual entity.",
	"Method": "void preGetter(int propertyIndex){\r\n    preGetterCallback(propertyIndex);\r\n    if (state == STATE_NEW || disableLazyLoad) {\r\n        return;\r\n    }\r\n    if (!isLoadedProperty(propertyIndex)) {\r\n        loadBean(propertyIndex);\r\n    }\r\n    if (nodeUsageCollector != null) {\r\n        nodeUsageCollector.addUsed(getProperty(propertyIndex));\r\n    }\r\n}"
}, {
	"Path": "com.oath.cyclops.types.reactive.QueueBasedSubscriber.subscriber",
	"Comment": "create a queuebasedsubscriber, backed by a queue that will be created with the provided queuefactory",
	"Method": "QueueBasedSubscriber<T> subscriber(Counter counter,int maxConcurrency,QueueBasedSubscriber<T> subscriber,Queue<T> q,Counter counter,int maxConcurrency,QueueBasedSubscriber<T> subscriber,QueueFactory<T> factory,Counter counter,int maxConcurrency){\r\n    return new QueueBasedSubscriber(factory, counter, maxConcurrency);\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.addDirtyPropertyKey",
	"Comment": "add and return a dirty property hash recursing into embedded beans.",
	"Method": "void addDirtyPropertyKey(StringBuilder sb){\r\n    if (sortOrder > 0) {\r\n        sb.append(\"s,\");\r\n    }\r\n    int len = getPropertyLength();\r\n    for (int i = 0; i < len; i++) {\r\n        if ((flags[i] & FLAG_CHANGED_PROP) != 0) {\r\n            sb.append(i).append(',');\r\n        } else if ((flags[i] & FLAG_EMBEDDED_DIRTY) != 0) {\r\n            EntityBean embeddedBean = (EntityBean) owner._ebean_getField(i);\r\n            sb.append(i).append('[');\r\n            embeddedBean._ebean_getIntercept().addDirtyPropertyKey(sb);\r\n            sb.append(']');\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.MCompoundForeignKey.addNameSuffix",
	"Comment": "add a counter to the foreign key and index names to avoid duplication.",
	"Method": "void addNameSuffix(int counter){\r\n    this.name = name + \"_\" + counter;\r\n    this.indexName = indexName + \"_\" + counter;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultServer.getPersistenceContextScope",
	"Comment": "return the persistencecontextscope to use defined at query or server level.",
	"Method": "PersistenceContextScope getPersistenceContextScope(SpiQuery<?> query){\r\n    PersistenceContextScope scope = query.getPersistenceContextScope();\r\n    return (scope != null) ? scope : defaultPersistenceContextScope;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.notifyCache",
	"Comment": "collect l2 cache changes to be applied after the transaction has successfully committed.",
	"Method": "void notifyCache(CacheChangeSet changeSet){\r\n    if (notifyCache) {\r\n        switch(type) {\r\n            case INSERT:\r\n                beanDescriptor.cachePersistInsert(this, changeSet);\r\n                break;\r\n            case UPDATE:\r\n                beanDescriptor.cachePersistUpdate(idValue, this, changeSet);\r\n                break;\r\n            case DELETE:\r\n            case DELETE_SOFT:\r\n                beanDescriptor.cachePersistDelete(idValue, this, changeSet);\r\n                break;\r\n            default:\r\n                throw new IllegalStateException(\"Invalid type \" + type);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.getBeanController",
	"Comment": "return the controller if there is one associated with this type of bean. this returns null ifthere is no controller associated.",
	"Method": "BeanPersistController getBeanController(){\r\n    return controller;\r\n}"
}, {
	"Path": "org.tests.cache.TestCacheCollectionIds.testClearingCollectionCacheOnExternalModification",
	"Comment": "when doing an external modification on a table the collection cache must be cleared.this is true for all changes insert,update, delete. tested for delete here.",
	"Method": "void testClearingCollectionCacheOnExternalModification(){\r\n    ResetBasicData.reset();\r\n    Order order1 = Ebean.find(Order.class, 1L);\r\n    OrderDetail orderDetail1 = order1.getDetails().get(0);\r\n    String updStatement = \"delete from o_order_detail where id = :id\";\r\n    SqlUpdate update = Ebean.createSqlUpdate(updStatement);\r\n    update.setParameter(\"id\", orderDetail1.getId());\r\n    int rows = update.execute();\r\n    assertEquals(1, rows);\r\n    Ebean.externalModification(\"o_order_detail\", false, false, true);\r\n    Order orderFromCache = Ebean.find(Order.class, 1L);\r\n    OrderDetail orderDetailFromCache = orderFromCache.getDetails().get(0);\r\n    orderDetailFromCache.getCretime();\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.BaseSimpleReactStream.freeThread",
	"Comment": "create a sequential synchronous stream that runs on the current thread",
	"Method": "SimpleReactStream<T> freeThread(T value,SimpleReactStream<T> freeThread,T values){\r\n    return new SimpleReact(ThreadPools.getSequential(), false).of(values);\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getJdbcFetchSizeFindList",
	"Comment": "return the default jdbc fetchsize hint for findlist queries.",
	"Method": "int getJdbcFetchSizeFindList(){\r\n    return jdbcFetchSizeFindList;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.InternalConfiguration.getPlugins",
	"Comment": "return the list of plugins we collected during construction.",
	"Method": "List<Plugin> getPlugins(){\r\n    for (Plugin plugin : ServiceLoader.load(Plugin.class)) {\r\n        if (!plugins.contains(plugin)) {\r\n            plugins.add(plugin);\r\n        }\r\n    }\r\n    return plugins;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.LazySimpleReactStream.filterSync",
	"Comment": "synchronous filtering operationremoves elements that do not fold the supplied predicate from thedataflow",
	"Method": "LazySimpleReactStream<U> filterSync(Predicate<? super U> p){\r\n    final Function<PipelineBuilder, PipelineBuilder> fn = ft -> ft.thenApply((in) -> {\r\n        if (!p.test((U) in)) {\r\n            throw new FilteredExecutionPathException();\r\n        }\r\n        return in;\r\n    });\r\n    return this.withLastActive(getLastActive().operation(fn));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.setImportedOrphanForRemoval",
	"Comment": "set an orphan bean that needs to be deleted after the request has persisted.",
	"Method": "void setImportedOrphanForRemoval(BeanPropertyAssocOne<?> prop){\r\n    Object orphan = getOrigValue(prop);\r\n    if (orphan instanceof EntityBean) {\r\n        orphanBean = (EntityBean) orphan;\r\n    }\r\n}"
}, {
	"Path": "io.ebean.Model.db",
	"Comment": "return a named ebeanserver that is typically different to the default server.if you are using multiple databases then each database has a name and maps to a singleebeanserver. you can use this method to get an ebeanserver for another database.",
	"Method": "EbeanServer db(EbeanServer db,String server){\r\n    return Ebean.getServer(server);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.profile.DTimedMetric.getStatistics",
	"Comment": "return the current statistics resetting the internal values if reset is true.",
	"Method": "DTimeMetricStats getStatistics(boolean reset){\r\n    if (reset) {\r\n        final long beans = beanCount.sumThenReset();\r\n        final long maxVal = max.getThenReset();\r\n        final long totalVal = total.sumThenReset();\r\n        final long countVal = count.sumThenReset();\r\n        final long startTimeVal = startTime.getAndSet(System.currentTimeMillis());\r\n        return new DTimeMetricStats(metricType, name, startTimeVal, countVal, totalVal, maxVal, beans);\r\n    } else {\r\n        return new DTimeMetricStats(metricType, name, startTime.get(), count.sum(), total.sum(), max.get(), beanCount.sum());\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.DdlGenerator.runDdl",
	"Comment": "run the ddl drop and ddl create scripts if properties have been set.",
	"Method": "void runDdl(){\r\n    if (runDdl) {\r\n        Connection connection = null;\r\n        try {\r\n            connection = obtainConnection();\r\n            runDdlWith(connection);\r\n        } finally {\r\n            JdbcClose.rollback(connection);\r\n            JdbcClose.close(connection);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebean.bean.NodeUsageCollector.finalize",
	"Comment": "publish the collected usage information when garbage collection occurs.",
	"Method": "void finalize(){\r\n    publishUsageInfo();\r\n    super.finalize();\r\n}"
}, {
	"Path": "io.ebean.config.UnderscoreNamingConvention.isForceUpperCase",
	"Comment": "return true if the result will be upper case.false if it will be lower case.",
	"Method": "boolean isForceUpperCase(){\r\n    return forceUpperCase;\r\n}"
}, {
	"Path": "cyclops.control.Eval.narrowK",
	"Comment": "convert the raw higher kinded type for evals types into the eval interface",
	"Method": "Eval<T> narrowK(Higher<eval, T> future){\r\n    return (Eval<T>) future;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.BaseTableDdl.writeUniqueOneToOneConstraints",
	"Comment": "specific handling of onetoone unique constraints for mssqlserver.for all other db platforms these unique constraints are done inline as per normal.",
	"Method": "void writeUniqueOneToOneConstraints(DdlWrite write,CreateTable createTable){\r\n    String tableName = createTable.getName();\r\n    for (Column col : externalUnique) {\r\n        String uqName = col.getUniqueOneToOne();\r\n        if (uqName == null) {\r\n            uqName = col.getUnique();\r\n        }\r\n        String[] columnNames = { col.getName() };\r\n        write.apply().append(platformDdl.alterTableAddUniqueConstraint(tableName, uqName, columnNames, Boolean.TRUE.equals(col.isNotnull()) ? null : columnNames)).endOfStatement();\r\n        write.dropAllForeignKeys().append(platformDdl.dropIndex(uqName, tableName)).endOfStatement();\r\n    }\r\n    for (UniqueConstraint constraint : externalCompoundUnique) {\r\n        String uqName = constraint.getName();\r\n        String[] columnNames = SplitColumns.split(constraint.getColumnNames());\r\n        String[] nullableColumns = SplitColumns.split(constraint.getNullableColumns());\r\n        write.apply().append(platformDdl.alterTableAddUniqueConstraint(tableName, uqName, columnNames, nullableColumns)).endOfStatement();\r\n        write.dropAllForeignKeys().append(platformDdl.dropIndex(uqName, tableName)).endOfStatement();\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.UnderscoreNamingConvention.getPropertyFromColumn",
	"Comment": "converts underscore based column name to camel case property name.",
	"Method": "String getPropertyFromColumn(Class<?> beanClass,String dbColumnName){\r\n    return toCamelFromUnderscore(dbColumnName);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.DefaultPersister.deleteRecurse",
	"Comment": "recursively delete the bean. this calls back to the ebeanserver.",
	"Method": "int deleteRecurse(EntityBean detailBean,Transaction t,DeleteMode deleteMode){\r\n    return deleteRequest(createRequest(detailBean, t, deleteMode.persistType()));\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.DdlGenerator.generateDdl",
	"Comment": "generate the ddl drop and create scripts if the properties have been set.",
	"Method": "void generateDdl(){\r\n    if (generateDdl) {\r\n        if (!createOnly) {\r\n            writeDrop(getDropFileName());\r\n        }\r\n        writeCreate(getCreateFileName());\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.isAutoCommitMode",
	"Comment": "return true if autocommit mode is on. this indicates to ebean to use autocommit friendly transactions and transactionmanager.",
	"Method": "boolean isAutoCommitMode(){\r\n    return autoCommitMode;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanDescriptor.getBaseTable",
	"Comment": "return the base table. only properties mapped to the base table are bydefault persisted.",
	"Method": "String getBaseTable(){\r\n    return baseTable;\r\n}"
}, {
	"Path": "io.ebean.text.json.JsonWriteOptions.pathProperties",
	"Comment": "construct jsonwriteoptions with the given pathproperties.",
	"Method": "JsonWriteOptions pathProperties(FetchPath pathProperties){\r\n    JsonWriteOptions o = new JsonWriteOptions();\r\n    o.setPathProperties(pathProperties);\r\n    return o;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.DeployDocPropertyOptions.create",
	"Comment": "return the docpropertyoptions with the collected options.",
	"Method": "DocPropertyOptions create(){\r\n    return (mapping == null) ? EMPTY : mapping;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.propertiesBaseScalar",
	"Comment": "scalar properties without the unique id or secondary table properties.",
	"Method": "BeanProperty[] propertiesBaseScalar(){\r\n    return propertiesBaseScalar;\r\n}"
}, {
	"Path": "io.ebean.config.AutoTuneConfig.getMode",
	"Comment": "return the mode used when autotune has not been explicit defined on aquery.",
	"Method": "AutoTuneMode getMode(){\r\n    return mode;\r\n}"
}, {
	"Path": "cyclops.monads.transformers.EvalT.fromAnyM",
	"Comment": "construct an evalwt from an anym that contains a monad type that contains type other than evalthe values in the underlying monad will be mapped to eval",
	"Method": "EvalT<W, A> fromAnyM(AnyM<W, A> anyM){\r\n    return of(anyM.map(Eval::now));\r\n}"
}, {
	"Path": "io.ebean.config.CustomDbTypeMapping.getPlatform",
	"Comment": "return the platform this mapping should apply to. null means it applied to all platforms.",
	"Method": "Platform getPlatform(){\r\n    return platform;\r\n}"
}, {
	"Path": "io.ebean.config.DbMigrationConfig.getPlatform",
	"Comment": "return the db platform to generate migration ddl for.we typically need to explicitly specify this as migration can often be generatedwhen running against h2.",
	"Method": "Platform getPlatform(){\r\n    return platform;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getDatabaseSequenceBatchSize",
	"Comment": "return the number of db sequence values that should be preallocated.",
	"Method": "int getDatabaseSequenceBatchSize(){\r\n    return platformConfig.getDatabaseSequenceBatchSize();\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.parse.DeployBeanInfo.getTableJoin",
	"Comment": "appropriate tablejoin for a property mapped to a secondary table.",
	"Method": "DeployTableJoin getTableJoin(String tableName){\r\n    String key = tableName.toLowerCase();\r\n    DeployTableJoin tableJoin = tableJoinMap.get(key);\r\n    if (tableJoin == null) {\r\n        tableJoin = new DeployTableJoin();\r\n        tableJoin.setTable(tableName);\r\n        tableJoin.setType(SqlJoinType.INNER);\r\n        descriptor.addTableJoin(tableJoin);\r\n        tableJoinMap.put(key, tableJoin);\r\n    }\r\n    return tableJoin;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.DefaultPersister.saveAssocMany",
	"Comment": "save the associated child beans contained in a list.this will automatically copy over any join properties from the parentbean to the child beans.",
	"Method": "void saveAssocMany(PersistRequestBean<?> request){\r\n    EntityBean parentBean = request.getEntityBean();\r\n    BeanDescriptor<?> desc = request.getBeanDescriptor();\r\n    SpiTransaction t = request.getTransaction();\r\n    EntityBean orphanForRemoval = request.getImportedOrphanForRemoval();\r\n    if (orphanForRemoval != null) {\r\n        delete(orphanForRemoval, request.getTransaction(), true);\r\n    }\r\n    for (BeanPropertyAssocOne<?> prop : desc.propertiesOneExportedSave()) {\r\n        if (request.isLoadedProperty(prop)) {\r\n            EntityBean detailBean = prop.getValueAsEntityBean(parentBean);\r\n            if (detailBean != null) {\r\n                if (!prop.isSaveRecurseSkippable(detailBean)) {\r\n                    t.depth(+1);\r\n                    prop.setParentBeanToChild(parentBean, detailBean);\r\n                    saveRecurse(detailBean, t, parentBean, request.getFlags());\r\n                    t.depth(-1);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    boolean insertedParent = request.isInsertedParent();\r\n    for (BeanPropertyAssocMany<?> many : desc.propertiesManySave()) {\r\n        if (request.isLoadedProperty(many) && !many.isSkipSaveBeanCollection(parentBean, insertedParent)) {\r\n            saveMany(insertedParent, many, parentBean, request);\r\n            if (!insertedParent) {\r\n                request.addUpdatedManyProperty(many);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.getDirtyValues",
	"Comment": "return a map of dirty properties with their new and old values.",
	"Method": "Map<String, ValuePair> getDirtyValues(){\r\n    Map<String, ValuePair> dirtyValues = new LinkedHashMap();\r\n    addDirtyPropertyValues(dirtyValues, null);\r\n    return dirtyValues;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.util.ArrayStack.pop",
	"Comment": "removes the object at the top of this stack and returns that object asthe value of this function.",
	"Method": "E pop(){\r\n    int len = list.size();\r\n    if (len == 0) {\r\n        throw new EmptyStackException();\r\n    }\r\n    return list.remove(len - 1);\r\n}"
}, {
	"Path": "io.ebean.Ebean.insert",
	"Comment": "insert the bean. this is useful when you set the id property on a bean andwant to explicitly insert it.",
	"Method": "void insert(Object bean){\r\n    serverMgr.getDefaultServer().insert(bean);\r\n}"
}, {
	"Path": "io.ebean.Model.save",
	"Comment": "insert or update this entity depending on its state.ebean will detect if this is a new bean or a previously fetched bean and perform either aninsert or an update based on that.",
	"Method": "void save(){\r\n    db().save(this);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.ImplicitReadOnlyTransaction.getBatchSize",
	"Comment": "return the batchsize specifically set for this transaction or 0.returning 0 implies to use the system wide default batch size.",
	"Method": "int getBatchSize(){\r\n    return 0;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.LinkedListX.range",
	"Comment": "create a linkedlistx that contains the integers between skip and take",
	"Method": "LinkedListX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).linkedListX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.DdlHelp.isDropDefault",
	"Comment": "return true if the default value is the special drop default value.",
	"Method": "boolean isDropDefault(String value){\r\n    return DROP_DEFAULT.equals(value);\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.isEmbeddedNewOrDirty",
	"Comment": "return true if the embedded bean is new or dirty and hence needs saving.",
	"Method": "boolean isEmbeddedNewOrDirty(Object embeddedBean){\r\n    if (embeddedBean == null) {\r\n        return false;\r\n    }\r\n    if (embeddedBean instanceof EntityBean) {\r\n        return ((EntityBean) embeddedBean)._ebean_getIntercept().isNewOrDirty();\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "io.ebean.TxScope.setFlushOnQuery",
	"Comment": "set flushonquery to be false to stop automatically flushing the jdbc batch buffer when a query is executed.",
	"Method": "TxScope setFlushOnQuery(boolean flushOnQuery){\r\n    this.flushOnQuery = flushOnQuery;\r\n    return this;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultServer.initCallStackFactory",
	"Comment": "create the callstackfactory depending if autotune is being used.",
	"Method": "CallStackFactory initCallStackFactory(ServerConfig serverConfig){\r\n    if (!serverConfig.getAutoTuneConfig().isActive()) {\r\n        return new NoopCallStackFactory();\r\n    }\r\n    return new DefaultCallStackFactory(serverConfig.getMaxCallStack());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.ParamTypeUtil.matchParamType",
	"Comment": "check if the type is a generic one with parameters and of the correct type we aresearching for. return the parameter type if this matches otherwise return null.",
	"Method": "Type matchParamType(Type type,Class<?> matchType){\r\n    if (type instanceof ParameterizedType) {\r\n        ParameterizedType pt = (ParameterizedType) type;\r\n        Type rawType = pt.getRawType();\r\n        boolean isAssignable = matchType.isAssignableFrom((Class<?>) rawType);\r\n        if (isAssignable) {\r\n            Type[] typeArguments = pt.getActualTypeArguments();\r\n            if (typeArguments.length != 1) {\r\n                String m = \"Expecting only 1 generic paramater but got \" + typeArguments.length + \" for \" + type;\r\n                throw new RuntimeException(m);\r\n            }\r\n            return typeArguments[0];\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.id.IdBinderFactory.createIdBinder",
	"Comment": "create the idconvertset for the given type of id properties.",
	"Method": "IdBinder createIdBinder(BeanProperty id){\r\n    if (id == null) {\r\n        return EMPTY;\r\n    }\r\n    if (id.isEmbedded()) {\r\n        return new IdBinderEmbedded(idInExpandedForm, (BeanPropertyAssocOne<?>) id);\r\n    } else {\r\n        return new IdBinderSimple(id, multiValueBind);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.api.ClassUtil.newInstance",
	"Comment": "return a new instance of the class using the default constructor.",
	"Method": "Object newInstance(String className){\r\n    try {\r\n        Class<?> cls = forName(className);\r\n        return cls.newInstance();\r\n    } catch (Exception e) {\r\n        String msg = \"Error constructing \" + className;\r\n        throw new IllegalArgumentException(msg, e);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.BatchedBeanHolder.executeNow",
	"Comment": "execute all the persist requests in this entry.this will batch all the similar requests into one or more batchstatementsand then execute them.",
	"Method": "void executeNow(){\r\n    if (deletes != null && !deletes.isEmpty()) {\r\n        ArrayList<PersistRequest> bufferedDeletes = deletes;\r\n        deletes = new ArrayList();\r\n        control.executeNow(bufferedDeletes);\r\n    }\r\n    if (inserts != null && !inserts.isEmpty()) {\r\n        ArrayList<PersistRequest> bufferedInserts = inserts;\r\n        inserts = new ArrayList();\r\n        control.executeNow(bufferedInserts);\r\n    }\r\n    if (updates != null && !updates.isEmpty()) {\r\n        ArrayList<PersistRequest> bufferedUpdates = updates;\r\n        updates = new ArrayList();\r\n        control.executeNow(bufferedUpdates);\r\n    }\r\n    persistedBeans.clear();\r\n}"
}, {
	"Path": "org.itxtech.daedalus.provider.UdpProvider.handleDnsRequest",
	"Comment": "handles a dns request, by either blocking it or forwarding it to the remote location.",
	"Method": "void handleDnsRequest(byte[] packetData){\r\n    IpPacket parsedPacket;\r\n    try {\r\n        parsedPacket = (IpPacket) IpSelector.newPacket(packetData, 0, packetData.length);\r\n    } catch (Exception e) {\r\n        Log.i(TAG, \"handleDnsRequest: Discarding invalid IP packet\", e);\r\n        return;\r\n    }\r\n    if (!(parsedPacket.getPayload() instanceof UdpPacket)) {\r\n        Log.i(TAG, \"handleDnsRequest: Discarding unknown packet type \" + parsedPacket.getPayload());\r\n        return;\r\n    }\r\n    InetAddress destAddr = parsedPacket.getHeader().getDstAddr();\r\n    if (destAddr == null)\r\n        return;\r\n    try {\r\n        destAddr = InetAddress.getByName(service.dnsServers.get(destAddr.getHostAddress()));\r\n    } catch (Exception e) {\r\n        Logger.logException(e);\r\n        Logger.error(\"handleDnsRequest: DNS server alias query failed for \" + destAddr.getHostAddress());\r\n        return;\r\n    }\r\n    UdpPacket parsedUdp = (UdpPacket) parsedPacket.getPayload();\r\n    if (parsedUdp.getPayload() == null) {\r\n        Log.i(TAG, \"handleDnsRequest: Sending UDP packet without payload: \" + parsedUdp);\r\n        DatagramPacket outPacket = new DatagramPacket(new byte[0], 0, 0, destAddr, DNSServerHelper.getPortOrDefault(destAddr, parsedUdp.getHeader().getDstPort().valueAsInt()));\r\n        forwardPacket(outPacket, null);\r\n        return;\r\n    }\r\n    byte[] dnsRawData = (parsedUdp).getPayload().getRawData();\r\n    DnsMessage dnsMsg;\r\n    try {\r\n        dnsMsg = new DnsMessage(dnsRawData);\r\n        if (Daedalus.getPrefs().getBoolean(\"settings_debug_output\", false)) {\r\n            Logger.debug(\"DnsRequest: \" + dnsMsg.toString());\r\n        }\r\n    } catch (IOException e) {\r\n        Log.i(TAG, \"handleDnsRequest: Discarding non-DNS or invalid packet\", e);\r\n        return;\r\n    }\r\n    if (dnsMsg.getQuestion() == null) {\r\n        Log.i(TAG, \"handleDnsRequest: Discarding DNS packet with no query \" + dnsMsg);\r\n        return;\r\n    }\r\n    if (!resolve(parsedPacket, dnsMsg)) {\r\n        DatagramPacket outPacket = new DatagramPacket(dnsRawData, 0, dnsRawData.length, destAddr, DNSServerHelper.getPortOrDefault(destAddr, parsedUdp.getHeader().getDstPort().valueAsInt()));\r\n        forwardPacket(outPacket, parsedPacket);\r\n    }\r\n}"
}, {
	"Path": "org.dataalgorithms.chapB10.friendrecommendation.mapreduce.PairOfLongs.compareTo",
	"Comment": "defines a natural sort order for pairs. pairs are sorted first by the left element, and then by the right element.",
	"Method": "int compareTo(PairOfLongs pair){\r\n    long L = pair.getLeft();\r\n    long R = pair.getRight();\r\n    if (left == L) {\r\n        if (right < R) {\r\n            return -1;\r\n        }\r\n        if (right > R) {\r\n            return 1;\r\n        }\r\n        return 0;\r\n    }\r\n    if (left < L) {\r\n        return -1;\r\n    }\r\n    return 1;\r\n}"
}, {
	"Path": "io.ebean.util.StringHelper.delimitedToMap",
	"Comment": "parses out a list of name value pairs that are delimited together. willalways return a stringmap. if allnamevaluepairs is null, or no name valuescan be parsed out an empty stringmap is returned.",
	"Method": "Map<String, String> delimitedToMap(String allNameValuePairs,String listDelimiter,String nameValueSeparator){\r\n    HashMap<String, String> params = new HashMap();\r\n    if ((allNameValuePairs == null) || (allNameValuePairs.isEmpty())) {\r\n        return params;\r\n    }\r\n    allNameValuePairs = trimFront(allNameValuePairs, listDelimiter);\r\n    return getKeyValue(params, 0, allNameValuePairs, listDelimiter, nameValueSeparator);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocMany.initialisePostTarget",
	"Comment": "initialise after the target bean descriptors have been all set.",
	"Method": "void initialisePostTarget(){\r\n    if (childMasterProperty != null) {\r\n        BeanProperty masterId = childMasterProperty.getTargetDescriptor().getIdProperty();\r\n        childMasterIdProperty = childMasterProperty.getName() + \".\" + masterId.getName();\r\n    }\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.QueueX.narrowK",
	"Comment": "convert the raw higher kinded type for queue types into the queuetype type definition class",
	"Method": "QueueX<T> narrowK(Higher<queue, T> queue){\r\n    return (QueueX<T>) queue;\r\n}"
}, {
	"Path": "io.ebean.RawSqlBuilder.sqlRow",
	"Comment": "create and return a sqlrow based on the resultset with dbtruevalue and binaryoptimizeduuid options.",
	"Method": "SqlRow sqlRow(ResultSet resultSet,String dbTrueValue,boolean binaryOptimizedUUID){\r\n    return XServiceProvider.rawSql().sqlRow(resultSet, dbTrueValue, binaryOptimizedUUID);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanProperty.getSoftDeleteDbSet",
	"Comment": "return the db literal expression to set the deleted state to true.",
	"Method": "String getSoftDeleteDbSet(){\r\n    return softDeleteDbSet;\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.ListX.narrowK",
	"Comment": "convert the raw higher kinded type for listx types into the listx type definition class",
	"Method": "ListX<T> narrowK(Higher<list, T> list){\r\n    return (ListX<T>) list;\r\n}"
}, {
	"Path": "io.ebeaninternal.api.ScopeTrans.caughtError",
	"Comment": "an error was caught and this always causes a rollback to occur.returns the error and this should be thrown by the calling code.",
	"Method": "Error caughtError(Error e){\r\n    rollback(e);\r\n    return e;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.initialiseOther",
	"Comment": "initialise the exported and imported parts for associated properties.",
	"Method": "void initialiseOther(BeanDescriptorInitContext initContext){\r\n    for (BeanPropertyAssocMany<?> many : propertiesManyToMany) {\r\n        many.registerDraftIntersectionTable(initContext);\r\n    }\r\n    if (historySupport) {\r\n        for (BeanPropertyAssocMany<?> aPropertiesManyToMany : propertiesManyToMany) {\r\n            if (!aPropertiesManyToMany.isExcludedFromHistory()) {\r\n                TableJoin intersectionTableJoin = aPropertiesManyToMany.getIntersectionTableJoin();\r\n                initContext.addHistoryIntersection(intersectionTableJoin.getTable());\r\n            }\r\n        }\r\n    }\r\n    if (!isEmbedded()) {\r\n        for (BeanProperty prop : propertiesAll()) {\r\n            if (!prop.isId()) {\r\n                prop.initialise(initContext);\r\n            }\r\n            prop.registerColumn(this, null);\r\n        }\r\n    }\r\n    if (unidirectional != null) {\r\n        unidirectional.initialise(initContext);\r\n    }\r\n    idBinder.initialise();\r\n    idBinderInLHSSql = idBinder.getBindIdInSql(baseTableAlias);\r\n    idBinderIdSql = idBinder.getBindIdSql(baseTableAlias);\r\n    String idBinderInLHSSqlNoAlias = idBinder.getBindIdInSql(null);\r\n    String idEqualsSql = idBinder.getBindIdSql(null);\r\n    deleteByIdSql = \"delete from \" + baseTable + \" where \" + idEqualsSql;\r\n    whereIdInSql = \" where \" + idBinderInLHSSqlNoAlias + \" \";\r\n    deleteByIdInSql = \"delete from \" + baseTable + whereIdInSql;\r\n    if (softDelete) {\r\n        softDeleteByIdSql = \"update \" + baseTable + \" set \" + getSoftDeleteDbSet() + \" where \" + idEqualsSql;\r\n        softDeleteByIdInSql = \"update \" + baseTable + \" set \" + getSoftDeleteDbSet() + \" where \" + idBinderInLHSSqlNoAlias + \" \";\r\n    } else {\r\n        softDeleteByIdSql = null;\r\n        softDeleteByIdInSql = null;\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DatabasePlatform.getPersistBatchOnCascade",
	"Comment": "return the platform default jdbc batch mode for persist cascade.",
	"Method": "PersistBatch getPersistBatchOnCascade(){\r\n    return persistBatchOnCascade;\r\n}"
}, {
	"Path": "io.ebean.Version.getDiff",
	"Comment": "return the map of differences from this bean to the prior version.",
	"Method": "Map<String, ValuePair> getDiff(){\r\n    return diff;\r\n}"
}, {
	"Path": "io.ebean.config.ProfilingConfig.getMinimumMicros",
	"Comment": "return the minimum transaction execution to be included in profiling.",
	"Method": "long getMinimumMicros(){\r\n    return minimumMicros;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getMappingLocations",
	"Comment": "return mapping locations to search for xml mapping via class path search.",
	"Method": "List<String> getMappingLocations(){\r\n    return mappingLocations;\r\n}"
}, {
	"Path": "io.ebean.text.json.EJson.parseList",
	"Comment": "parse the json returning as a list taking into account the current token.",
	"Method": "List<T> parseList(String json,boolean modifyAware,List<Object> parseList,String json,List<Object> parseList,Reader reader,List<Object> parseList,JsonParser parser,List<T> parseList,JsonParser parser,JsonToken currentToken){\r\n    return plugin.parseList(parser, currentToken);\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.setOriginalValueForce",
	"Comment": "set old value but force it to be set regardless if it already has a value.",
	"Method": "void setOriginalValueForce(int propertyIndex,Object value){\r\n    if (origValues == null) {\r\n        origValues = new Object[owner._ebean_getPropertyNames().length];\r\n    }\r\n    origValues[propertyIndex] = value;\r\n}"
}, {
	"Path": "io.ebean.common.BeanMap.setActualMap",
	"Comment": "set the actual underlying map. used for performing lazy fetch.",
	"Method": "void setActualMap(Map<?, ?> map){\r\n    this.map = (Map<K, E>) map;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.getInheritInfo",
	"Comment": "returns the inheritance mapping information. this will be null if this typeof bean is not involved in any orm inheritance mapping.",
	"Method": "InheritInfo getInheritInfo(){\r\n    return inheritInfo;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanEmbeddedMetaFactory.create",
	"Comment": "create beanproperties for embedded beans using the deployment specific db column name and table alias.",
	"Method": "BeanEmbeddedMeta create(BeanDescriptorMap owner,DeployBeanPropertyAssocOne<?> prop){\r\n    BeanDescriptor<?> targetDesc = owner.getBeanDescriptor(prop.getTargetType());\r\n    if (targetDesc == null) {\r\n        String msg = \"Could not find BeanDescriptor for \" + prop.getTargetType() + \". Perhaps the EmbeddedId class is not registered? See https://ebean.io/docs/trouble-shooting#not-registered\";\r\n        throw new BeanNotRegisteredException(msg);\r\n    }\r\n    String columnPrefix = prop.getColumnPrefix();\r\n    Map<String, String> propColMap = prop.getDeployEmbedded().getPropertyColumnMap();\r\n    BeanProperty[] sourceProperties = targetDesc.propertiesBaseScalar();\r\n    BeanProperty[] embeddedProperties = new BeanProperty[sourceProperties.length];\r\n    for (int i = 0; i < sourceProperties.length; i++) {\r\n        String propertyName = sourceProperties[i].getName();\r\n        String dbColumn = propColMap.get(propertyName);\r\n        if (dbColumn == null) {\r\n            dbColumn = sourceProperties[i].getDbColumn();\r\n            if (columnPrefix != null) {\r\n                dbColumn = columnPrefix + dbColumn;\r\n            }\r\n        }\r\n        BeanPropertyOverride overrides = new BeanPropertyOverride(dbColumn);\r\n        embeddedProperties[i] = new BeanProperty(sourceProperties[i], overrides);\r\n    }\r\n    return new BeanEmbeddedMeta(embeddedProperties);\r\n}"
}, {
	"Path": "cyclops.companion.rx2.Maybes.combine",
	"Comment": "lazily combine this maybe with the supplied maybe via the supplied bifunction",
	"Method": "Maybe<R> combine(Maybe<? extends T1> maybe,Value<? extends T2> app,BiFunction<? super T1, ? super T2, ? extends R> fn,Maybe<R> combine,Maybe<? extends T1> maybe,Maybe<? extends T2> app,BiFunction<? super T1, ? super T2, ? extends R> fn){\r\n    return narrow(Single.fromPublisher(Future.fromPublisher(maybe.toFlowable()).zip(Future.fromPublisher(app.toFlowable()), fn)).toMaybe());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorManager.setBeanReflect",
	"Comment": "set beanreflect beanreflectgetter and beanreflectsetter properties.this sets the implementation of constructing entity beans and the settingand getting of properties. it is generally faster to use code generationrather than reflection to do this.",
	"Method": "void setBeanReflect(DeployBeanDescriptor<?> desc){\r\n    BeanPropertiesReader reflectProps = new BeanPropertiesReader(desc.getBeanType());\r\n    desc.setProperties(reflectProps.getProperties());\r\n    for (DeployBeanProperty prop : desc.propertiesAll()) {\r\n        String propName = prop.getName();\r\n        Integer pos = reflectProps.getPropertyIndex(propName);\r\n        if (pos == null) {\r\n            if (isPersistentField(prop)) {\r\n                throw new IllegalStateException(\"If you are running in an IDE with enhancement plugin try a Build -> Rebuild Project to recompile and enhance all entity beans. \" + \"Error - property \" + propName + \" not found in \" + reflectProps + \" for type \" + desc.getBeanType());\r\n            }\r\n        } else {\r\n            final int propertyIndex = pos;\r\n            prop.setPropertyIndex(propertyIndex);\r\n            prop.setGetter(beanPropertyAccess.getGetter(propertyIndex));\r\n            prop.setSetter(beanPropertyAccess.getSetter(propertyIndex));\r\n            if (prop.isAggregation()) {\r\n                prop.setAggregationPrefix(DetermineAggPath.manyPath(prop.getRawAggregation(), desc));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.loadcontext.DLoadContext.getLoadSecondaryQuery",
	"Comment": "return the loadbeancontext or loadmanycontext for the given path.",
	"Method": "LoadSecondaryQuery getLoadSecondaryQuery(String path){\r\n    LoadSecondaryQuery beanLoad = beanMap.get(path);\r\n    if (beanLoad == null) {\r\n        beanLoad = manyMap.get(path);\r\n    }\r\n    return beanLoad;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.InternalConfiguration.changeLogListener",
	"Comment": "return the changeloglistener to use with a default implementation if none defined.",
	"Method": "ChangeLogListener changeLogListener(ChangeLogListener listener){\r\n    return plugin((listener != null) ? listener : new DefaultChangeLogListener());\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DatabasePlatform.isSequenceBatchMode",
	"Comment": "return true if we are using sequence batch mode rather than step.",
	"Method": "boolean isSequenceBatchMode(){\r\n    return sequenceBatchMode;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.DeleteUnloadedForeignKeys.deleteCascade",
	"Comment": "delete the rows relating to the foreign keys. these deletions occur afterthe parent bean has been deleted.",
	"Method": "void deleteCascade(){\r\n    for (BeanPropertyAssocOne<?> prop : propList) {\r\n        Object detailBean = prop.getValue(beanWithForeignKeys);\r\n        if (detailBean != null && prop.hasId((EntityBean) detailBean)) {\r\n            if (deletePermanent) {\r\n                server.deletePermanent(detailBean, request.getTransaction());\r\n            } else {\r\n                server.delete(detailBean, request.getTransaction());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.IntersectionTable.delete",
	"Comment": "return a sqlupdate for deleting from the intersection table.",
	"Method": "SqlUpdate delete(EbeanServer server,boolean draft){\r\n    return server.createSqlUpdate(draft ? draftDeleteSql : deleteSql);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.InternalConfiguration.initExpressionFactory",
	"Comment": "create and return the expressionfactory based on configuration and database platform.",
	"Method": "ExpressionFactory initExpressionFactory(ServerConfig serverConfig){\r\n    boolean nativeIlike = serverConfig.isExpressionNativeIlike() && databasePlatform.isSupportsNativeIlike();\r\n    return new DefaultExpressionFactory(serverConfig.isExpressionEqualsWithNullAsNoop(), nativeIlike);\r\n}"
}, {
	"Path": "chapter07priorityqueues.BinaryHeap.insert",
	"Comment": "insert into the priority queue, maintaining heap order.duplicates are allowed.",
	"Method": "void insert(AnyType x){\r\n    if (currentSize == A.length - 1)\r\n        enlargeArray(A.length * 2 + 1);\r\n    int hole = ++currentSize;\r\n    for (; hole > 1 && x.compareTo(A[hole / 2]) < 0; hole /= 2) A[hole] = A[hole / 2];\r\n    A[hole] = x;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.model.PendingDrops.registerPendingHistoryDropColumns",
	"Comment": "register pending drop columns on history tables to the new model.",
	"Method": "void registerPendingHistoryDropColumns(ModelContainer newModel){\r\n    for (Entry entry : map.values()) {\r\n        for (ChangeSet changeSet : entry.list) {\r\n            newModel.registerPendingHistoryDropColumns(changeSet);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.MapX.fromStream",
	"Comment": "construct a new mapx with the same collector from the supplied stream",
	"Method": "MapX<K, V> fromStream(ReactiveSeq<Tuple2<K, V>> stream){\r\n    return new MapXImpl<K, V>(stream.toMap(t -> t._1(), t -> t._2()), getCollector());\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.isRegister",
	"Comment": "return true if this server should be registered with the ebean singletonwhen it is created.by default this is set to true.",
	"Method": "boolean isRegister(){\r\n    return register;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.DefaultOrmQuery.setDistinct",
	"Comment": "internally set to use sql distinct on the query but still have id property included.",
	"Method": "DefaultOrmQuery<T> setDistinct(boolean distinct){\r\n    this.distinct = distinct;\r\n    return this;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.isInsertMode",
	"Comment": "return true if this bean should be inserted rather than updated.",
	"Method": "boolean isInsertMode(EntityBeanIntercept ebi,boolean insertMode){\r\n    if (ebi.isLoaded()) {\r\n        return false;\r\n    }\r\n    if (idProperty.isEmbedded()) {\r\n        return !ebi.isLoaded();\r\n    }\r\n    if (!hasIdValue(ebi.getOwner())) {\r\n        return true;\r\n    }\r\n    return insertMode;\r\n}"
}, {
	"Path": "io.ebean.text.csv.DefaultCsvCallback.commitTransactionIfCreated",
	"Comment": "if we created a transaction commit it. we have successfully processed allthe rows.",
	"Method": "void commitTransactionIfCreated(){\r\n    if (createdTransaction) {\r\n        transaction.commit();\r\n        logger.info(\"Committed transaction\");\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.NativeSqlQueryPlanKey.getPartialKey",
	"Comment": "return as a partial key. for rawsql hash the sql is part of the key and as suchneeds to be included in order to have a complete key. typically the md5 of the sqlcan be used as a short form proxy for the actual sql.",
	"Method": "String getPartialKey(){\r\n    return hashCode() + \"_n\";\r\n}"
}, {
	"Path": "cyclops.reactive.collections.immutable.VectorX.narrowK",
	"Comment": "convert the raw higher kinded type for pvector types into the pvectortype type definition class",
	"Method": "VectorX<T> narrowK(Higher<vectorX, T> list){\r\n    return (VectorX<T>) list;\r\n}"
}, {
	"Path": "io.ebean.config.properties.LoadContext.eval",
	"Comment": "evaluate all the expressions and return as a properties object.",
	"Method": "Properties eval(){\r\n    log.info(\"loaded properties from {}\", loadedResources);\r\n    Properties properties = new Properties();\r\n    for (Map.Entry<String, String> entry : map.entrySet()) {\r\n        String key = entry.getKey();\r\n        String value = PropertyEval.eval(entry.getValue());\r\n        properties.setProperty(key, value);\r\n    }\r\n    return properties;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.DatabasePlatform.unQuote",
	"Comment": "remove quoted identifier quotes from the table or column name if present.",
	"Method": "String unQuote(String dbName){\r\n    if (dbName != null && !dbName.isEmpty()) {\r\n        if (dbName.startsWith(openQuote)) {\r\n            return dbName.substring(1, dbName.length() - 1);\r\n        }\r\n    }\r\n    return dbName;\r\n}"
}, {
	"Path": "io.ebean.EbeanServerFactory.create",
	"Comment": "create using the serverconfig object to configure the server.",
	"Method": "EbeanServer create(String name,EbeanServer create,ServerConfig config){\r\n    if (config.getName() == null) {\r\n        throw new PersistenceException(\"The name is null (it is required)\");\r\n    }\r\n    EbeanServer server = createInternal(config);\r\n    if (config.isRegister()) {\r\n        PrimaryServer.setSkip(true);\r\n        Ebean.register(server, config.isDefaultServer());\r\n    }\r\n    return server;\r\n}"
}, {
	"Path": "io.ebean.bean.EntityBeanIntercept.setDisableLazyLoad",
	"Comment": "set true to turn off lazy loading.typically used to disable lazy loading on sql based report beans.",
	"Method": "void setDisableLazyLoad(boolean disableLazyLoad){\r\n    this.disableLazyLoad = disableLazyLoad;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.setUpdatesDeleteMissingChildren",
	"Comment": "set if updates by default delete missing children when cascading save to a onetomany ormanytomany. when not set this defaults to true.",
	"Method": "void setUpdatesDeleteMissingChildren(boolean updatesDeleteMissingChildren){\r\n    this.updatesDeleteMissingChildren = updatesDeleteMissingChildren;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.PersistRequestBean.setGeneratedKey",
	"Comment": "set the generated key back to the bean. only used for inserts with getgeneratedkeys.",
	"Method": "void setGeneratedKey(Object idValue){\r\n    if (idValue != null) {\r\n        this.idValue = beanDescriptor.convertSetId(idValue, entityBean);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.el.ElPropertyChainBuilder.build",
	"Comment": "build the immutable elgetchain from the build information.",
	"Method": "ElPropertyChain build(){\r\n    return new ElPropertyChain(containsMany, embedded, expression, chain.toArray(new ElPropertyValue[chain.size()]));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanProperty.isDiscriminator",
	"Comment": "return true if this property maps to the inheritance discriminator column.s",
	"Method": "boolean isDiscriminator(){\r\n    return discriminator;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.InternalConfiguration.createDocStoreIntegration",
	"Comment": "create the docstoreintegration components for the given server.",
	"Method": "DocStoreIntegration createDocStoreIntegration(SpiServer server){\r\n    return plugin(docStoreFactory.create(server));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.BasicTypeConverter.toTimestamp",
	"Comment": "convert the passed in object to a timestamp. it is expected to be ajava.sql.date really.",
	"Method": "Timestamp toTimestamp(Object value){\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    if (value instanceof Timestamp) {\r\n        return (Timestamp) value;\r\n    } else if (value instanceof java.util.Date) {\r\n        return new Timestamp(((java.util.Date) value).getTime());\r\n    } else if (value instanceof Calendar) {\r\n        return new Timestamp(((Calendar) value).getTime().getTime());\r\n    } else if (value instanceof String) {\r\n        return Timestamp.valueOf((String) value);\r\n    } else if (value instanceof LocalDateTime) {\r\n        return Timestamp.valueOf((LocalDateTime) value);\r\n    } else if (value instanceof Number) {\r\n        return new Timestamp(((Number) value).longValue());\r\n    } else {\r\n        String msg = \"Unable to convert [\" + value.getClass().getName() + \"] into a Timestamp.\";\r\n        throw new RuntimeException(msg);\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.DbConstraintNaming.foreignKeyConstraintName",
	"Comment": "return the foreign key constraint name given a single column foreign key.",
	"Method": "String foreignKeyConstraintName(String tableName,String columnName){\r\n    return fkPrefix + normaliseTable(tableName) + fkMiddle + normaliseColumn(columnName) + fkSuffix;\r\n}"
}, {
	"Path": "io.ebean.config.dbplatform.db2.DB2Platform.createSequenceIdGenerator",
	"Comment": "return a db2 specific sequence idgenerator that supports batch fetchingsequence values.",
	"Method": "PlatformIdGenerator createSequenceIdGenerator(BackgroundExecutor be,DataSource ds,int stepSize,String seqName){\r\n    return new DB2SequenceIdGenerator(be, ds, seqName, sequenceBatchSize);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.SqlTree.addSoftDeletePredicate",
	"Comment": "recurse through the tree adding soft delete predicates as necessary.",
	"Method": "void addSoftDeletePredicate(SpiQuery<?> query){\r\n    rootNode.addSoftDeletePredicate(query);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanPropertyAssocMany.resetMany",
	"Comment": "reset the many properties to be empty and ready for reloading.used in bean refresh.",
	"Method": "void resetMany(EntityBean bean){\r\n    Object value = getValue(bean);\r\n    if (value instanceof BeanCollection) {\r\n        ((BeanCollection<?>) value).reset(bean, name);\r\n    } else {\r\n        createReference(bean);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.persist.BatchedPstmt.add",
	"Comment": "add the batchpostexecute to the list for post execute processing.",
	"Method": "void add(BatchPostExecute batchExecute){\r\n    list.add(batchExecute);\r\n}"
}, {
	"Path": "com.oath.cyclops.util.box.LazyImmutable.flatMap",
	"Comment": "flatmap the value stored in immutable closed value from one value to another if this is an unitiatilised immutableclosedvalue, an uninitialised closed value will be returned instead",
	"Method": "LazyImmutable<? extends R> flatMap(Function<? super T, ? extends LazyImmutable<? extends R>> fn){\r\n    final T val = get();\r\n    if (val == UNSET)\r\n        return (LazyImmutable<R>) this;\r\n    else\r\n        return fn.apply(val);\r\n}"
}, {
	"Path": "com.oath.cyclops.types.traversable.IterableFilterable.removeAll",
	"Comment": "remove all elements in the supplied iterable from this filterable",
	"Method": "Filters<T> removeAll(Iterable<? extends T> it,Filters<T> removeAll,T values){\r\n    return removeStream(Stream.of(values));\r\n}"
}, {
	"Path": "chapter10sorting.ConvertArraytoSawToothWave.converttoSawToothWave",
	"Comment": "sort the array first.then swap every adjacent element to get final result",
	"Method": "void converttoSawToothWave(int A){\r\n    for (int i = 1; i < A.length; i += 2) {\r\n        if (i + 1 < A.length) {\r\n            swap(A, i, i + 1);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.UnderscoreNamingConvention.getColumnFromProperty",
	"Comment": "converts camel case property name to underscore based column name.",
	"Method": "String getColumnFromProperty(Class<?> beanClass,String propertyName){\r\n    return toUnderscoreFromCamel(propertyName);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptor.lazyLoadRegister",
	"Comment": "register all the assoc many properties on this bean that are not populated with the load context.this provides further lazy loading via the load context.",
	"Method": "void lazyLoadRegister(String prefix,EntityBeanIntercept ebi,EntityBean bean,LoadContext loadContext){\r\n    BeanPropertyAssocMany<?>[] manys = propertiesMany();\r\n    for (BeanPropertyAssocMany<?> many : manys) {\r\n        if (!ebi.isLoadedProperty(many.getPropertyIndex())) {\r\n            BeanCollection<?> ref = many.createReferenceIfNull(bean);\r\n            if (ref != null && !ref.isRegisteredWithLoadContext()) {\r\n                String path = SplitName.add(prefix, many.getName());\r\n                loadContext.register(path, ref);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanDescriptor.addTableJoin",
	"Comment": "add a tablejoin to this type of bean. for secondary table properties.",
	"Method": "void addTableJoin(DeployTableJoin join){\r\n    tableJoinList.add(join);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.text.json.ReadJson.persistenceContextPutIfAbsent",
	"Comment": "put the bean into the persistence context. if there is already a matching bean in thepersistence context then return that instance else return null.",
	"Method": "Object persistenceContextPutIfAbsent(Object id,EntityBean bean,BeanDescriptor<?> beanDesc){\r\n    if (persistenceContext == null) {\r\n        return null;\r\n    }\r\n    Object existing = beanDesc.contextPutIfAbsent(persistenceContext, id, bean);\r\n    if (existing != null) {\r\n        beanDesc.merge(bean, (EntityBean) existing);\r\n    } else {\r\n        if (loadContext != null) {\r\n            EntityBeanIntercept ebi = bean._ebean_getIntercept();\r\n            if (ebi.isPartial()) {\r\n                String path = pathStack.peekWithNull();\r\n                loadContext.register(path, ebi);\r\n                beanDesc.lazyLoadRegister(path, ebi, bean, loadContext);\r\n            }\r\n            ebi.setLoaded();\r\n        }\r\n        return null;\r\n    }\r\n    return existing;\r\n}"
}, {
	"Path": "com.oath.cyclops.util.stream.scheduling.cron.CronExpression.setTimeZone",
	"Comment": "sets the time zone for whichthis cronexpressionwill be resolved.",
	"Method": "void setTimeZone(TimeZone timeZone){\r\n    this.timeZone = timeZone;\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachX",
	"Comment": "perform a foreach operation over the stream, without closing it, consuming only the specified number of elements fromthe stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachX(FutureStream<T> stream,long x,Consumer<? super T> consumerElement){\r\n    final CompletableFuture<Subscription> subscription = new CompletableFuture();\r\n    final CompletableFuture<Boolean> streamCompleted = new CompletableFuture();\r\n    return tuple(subscription, () -> {\r\n        stream.subscribe(new Subscriber<T>() {\r\n            @Override\r\n            public void onSubscribe(final Subscription s) {\r\n                Objects.requireNonNull(s);\r\n                if (x != 0)\r\n                    s.request(x);\r\n                subscription.complete(s);\r\n            }\r\n            @Override\r\n            public void onNext(final T t) {\r\n                consumerElement.accept(t);\r\n            }\r\n            @Override\r\n            public void onError(final Throwable t) {\r\n            }\r\n            @Override\r\n            public void onComplete() {\r\n                streamCompleted.complete(true);\r\n            }\r\n        });\r\n    }, streamCompleted);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachX",
	"Comment": "perform a foreach operation over the stream, without closing it, consuming only the specified number of elements fromthe stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachX(FutureStream<T> stream,long x,Consumer<? super T> consumerElement){\r\n    Objects.requireNonNull(s);\r\n    if (x != 0)\r\n        s.request(x);\r\n    subscription.complete(s);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachX",
	"Comment": "perform a foreach operation over the stream, without closing it, consuming only the specified number of elements fromthe stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachX(FutureStream<T> stream,long x,Consumer<? super T> consumerElement){\r\n    consumerElement.accept(t);\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachX",
	"Comment": "perform a foreach operation over the stream, without closing it, consuming only the specified number of elements fromthe stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachX(FutureStream<T> stream,long x,Consumer<? super T> consumerElement){\r\n}"
}, {
	"Path": "com.oath.cyclops.internal.react.stream.traits.future.operators.LazyFutureStreamUtils.forEachX",
	"Comment": "perform a foreach operation over the stream, without closing it, consuming only the specified number of elements fromthe stream, at this time. more elements can be consumed later, by called request on the returned subscription",
	"Method": "Tuple3<CompletableFuture<Subscription>, Runnable, CompletableFuture<Boolean>> forEachX(FutureStream<T> stream,long x,Consumer<? super T> consumerElement){\r\n    streamCompleted.complete(true);\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.DbOffline.setGenerateMigration",
	"Comment": "called when the migration is running is order to stop other pluginslike the full ddl generation from executing.",
	"Method": "void setGenerateMigration(){\r\n    generateMigration = true;\r\n}"
}, {
	"Path": "io.ebean.event.BeanPersistAdapter.preUpdate",
	"Comment": "returns true indicating normal processing should continue.",
	"Method": "boolean preUpdate(BeanPersistRequest<?> request){\r\n    return true;\r\n}"
}, {
	"Path": "io.ebeaninternal.api.BeanIdList.isHasMore",
	"Comment": "return true if max rows was hit and there is more rows to fetch.",
	"Method": "boolean isHasMore(){\r\n    return hasMore;\r\n}"
}, {
	"Path": "chapter03linkedlists.LinkedList.remove",
	"Comment": "if the position is greater than 0, remove the value at the last position.",
	"Method": "void remove(int position){\r\n    if (position < 0) {\r\n        position = 0;\r\n    }\r\n    if (position >= length) {\r\n        position = length - 1;\r\n    }\r\n    if (head == null)\r\n        return;\r\n    if (position == 0) {\r\n        head = head.getNext();\r\n    } else {\r\n        ListNode temp = head;\r\n        for (int i = 1; i < position; i += 1) {\r\n            temp = temp.getNext();\r\n        }\r\n        temp.setNext(temp.getNext().getNext());\r\n    }\r\n    length -= 1;\r\n}"
}, {
	"Path": "io.ebeaninternal.api.ManyWhereJoins.addAggregationJoin",
	"Comment": "ensure we have the join required to support the aggregation properties.",
	"Method": "void addAggregationJoin(String property){\r\n    this.aggregation = true;\r\n    joins.put(property, new PropertyJoin(property, SqlJoinType.INNER));\r\n}"
}, {
	"Path": "io.ebean.config.PlatformConfig.setDatabaseSequenceBatchSize",
	"Comment": "set the number of db sequence values that should be preallocated.",
	"Method": "void setDatabaseSequenceBatchSize(int databaseSequenceBatchSize){\r\n    this.databaseSequenceBatchSize = databaseSequenceBatchSize;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQueryPlan.isEmptyStats",
	"Comment": "return true if there are no statistics collected since the last reset.",
	"Method": "boolean isEmptyStats(){\r\n    return stats.isEmpty();\r\n}"
}, {
	"Path": "io.ebeaninternal.extraddl.model.ExtraDdlXmlReader.buildPartitioning",
	"Comment": "return any extra ddl for supporting partitioning given the database platform.",
	"Method": "String buildPartitioning(String platformName){\r\n    return buildExtra(platformName, false, readBuiltinTablePartitioning());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanDescriptor.setIdGeneratorName",
	"Comment": "set the name of the idgenerator that should be used with this type of bean.",
	"Method": "void setIdGeneratorName(String idGeneratorName){\r\n    this.idGeneratorName = idGeneratorName;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.loadcontext.DLoadContext.isReadOnly",
	"Comment": "return the parent state which defines the sharedinstance and readonly statuswhich needs to be propagated to other beans and collections.",
	"Method": "Boolean isReadOnly(){\r\n    return readOnly;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.querydefn.DefaultOrmQuery.setSqlDistinct",
	"Comment": "internally set to use sql distinct on the query but still have id property included.",
	"Method": "void setSqlDistinct(boolean sqlDistinct){\r\n    this.sqlDistinct = sqlDistinct;\r\n}"
}, {
	"Path": "cyclops.companion.reactor.Monos.combine",
	"Comment": "lazily combine this mono with the supplied mono via the supplied bifunction",
	"Method": "Mono<R> combine(Mono<? extends T1> mono,Value<? extends T2> app,BiFunction<? super T1, ? super T2, ? extends R> fn,Mono<R> combine,Mono<? extends T1> mono,Mono<? extends T2> app,BiFunction<? super T1, ? super T2, ? extends R> fn){\r\n    return Mono.from(Future.of(mono.toFuture()).zip(Future.of(app.toFuture()), fn));\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultServer.processRemoteCacheEvent",
	"Comment": "process a cache event coming from another server in the cluster.",
	"Method": "void processRemoteCacheEvent(RemoteTransactionEvent event){\r\n    RemoteCacheEvent cacheEvent = event.getRemoteCacheEvent();\r\n    if (cacheEvent != null) {\r\n        if (cacheEvent.isClearAll()) {\r\n            serverCacheManager.clearAllLocal();\r\n        } else {\r\n            List<String> caches = cacheEvent.getClearCaches();\r\n            if (caches != null) {\r\n                for (String cache : caches) {\r\n                    try {\r\n                        serverCacheManager.clearLocal(Class.forName(cache));\r\n                    } catch (Exception e) {\r\n                        logger.error(\"Error clearing local cache for type \" + cache, e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "cyclops.monads.transformers.jdk.CompletableFutureT.of",
	"Comment": "construct an futuret from an anym that wraps a monad containingfutures",
	"Method": "CompletableFutureT<W, A> of(AnyM<W, CompletableFuture<A>> monads){\r\n    return new CompletableFutureT(monads);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQuery.isRawSql",
	"Comment": "return true if this is a raw sql query as opposed to ebean generated sql.",
	"Method": "boolean isRawSql(){\r\n    return rawSql;\r\n}"
}, {
	"Path": "com.oath.cyclops.types.futurestream.SimpleReactStream.fromStreamOfFutures",
	"Comment": "construct a simplereactstream from provided stream of completablefutures",
	"Method": "SimpleReactStream<R> fromStreamOfFutures(Stream<CompletableFuture<R>> stream){\r\n    final Stream noType = stream;\r\n    return (SimpleReactStream<R>) this.withLastActive(getLastActive().withNewStream(noType, this.getSimpleReact()));\r\n}"
}, {
	"Path": "com.oath.cyclops.util.ExceptionSoftener.throwIf",
	"Comment": "throw the exception as upwards if the predicate holds, otherwise do nothing",
	"Method": "void throwIf(X e,Predicate<X> p){\r\n    if (p.test(e))\r\n        throw ExceptionSoftener.<RuntimeException>uncheck(e);\r\n}"
}, {
	"Path": "cyclops.companion.rx2.Maybes.fromIterable",
	"Comment": "construct a maybe from iterable by taking the first value from iterable",
	"Method": "Maybe<T> fromIterable(Iterable<T> t){\r\n    return narrow(Single.fromPublisher(Future.fromIterable(t)).toMaybe());\r\n}"
}, {
	"Path": "com.oath.cyclops.types.traversable.IterableFilterable.removeStream",
	"Comment": "remove all elements in the supplied stream from this filterable",
	"Method": "Filters<T> removeStream(Stream<? extends T> stream){\r\n    final Eval<Set<T>> set = Eval.later(() -> stream.collect(Collectors.toSet()));\r\n    return filterNot(i -> set.get().contains(i));\r\n}"
}, {
	"Path": "cyclops.monads.AnyM.ofNullable",
	"Comment": "generate an anym that wraps an optional from the provided nullable object",
	"Method": "AnyMValue<optional, T> ofNullable(T nullable){\r\n    return AnyMFactory.instance.value(Optional.ofNullable(nullable), Witness.optional.INSTANCE);\r\n}"
}, {
	"Path": "io.ebean.cache.ServerCacheStatistics.setEvictByLRU",
	"Comment": "set the count of entries evicted due to time least recently used.",
	"Method": "void setEvictByLRU(long evictByLRU){\r\n    this.evictByLRU = evictByLRU;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.type.ScalarTypeJsonMap.typeFor",
	"Comment": "return the scalartype for the requested dbtype and postgres.",
	"Method": "ScalarTypeJsonMap typeFor(boolean postgres,int dbType){\r\n    switch(dbType) {\r\n        case Types.VARCHAR:\r\n            return VARCHAR;\r\n        case Types.BLOB:\r\n            return BLOB;\r\n        case Types.CLOB:\r\n            return CLOB;\r\n        case DbPlatformType.JSONB:\r\n            return postgres ? JSONB : CLOB;\r\n        case DbPlatformType.JSON:\r\n            return postgres ? JSON : CLOB;\r\n        default:\r\n            throw new IllegalStateException(\"Unknown dbType \" + dbType);\r\n    }\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.isLocalTimeWithNanos",
	"Comment": "return true if localtime should be persisted with nanos precision.",
	"Method": "boolean isLocalTimeWithNanos(){\r\n    return localTimeWithNanos;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getLazyLoadBatchSize",
	"Comment": "return the default batch size for lazy loading of beans and collections.",
	"Method": "int getLazyLoadBatchSize(){\r\n    return lazyLoadBatchSize;\r\n}"
}, {
	"Path": "io.ebeaninternal.api.TransactionEvent.addListenerNotify",
	"Comment": "add post commit listeners. watch this for large transactions.",
	"Method": "void addListenerNotify(PersistRequestBean<?> request){\r\n    if (listenerNotify == null) {\r\n        listenerNotify = new ArrayList();\r\n    }\r\n    listenerNotify.add(request);\r\n}"
}, {
	"Path": "io.ebeaninternal.api.ScopeTrans.caughtThrowable",
	"Comment": "an exception was caught and may or may not cause a rollback to occur.returns the exception and this should be thrown by the calling code.",
	"Method": "T caughtThrowable(T e){\r\n    if (isRollbackThrowable(e)) {\r\n        rollback(e);\r\n    }\r\n    return e;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.bootup.DistillPackages.distill",
	"Comment": "distill the list of packages into distinct top level packages.",
	"Method": "List<String> distill(Collection<String> packages,Collection<String> mfPackages){\r\n    TreeSet<String> treeSet = new TreeSet();\r\n    treeSet.addAll(packages);\r\n    treeSet.addAll(mfPackages);\r\n    List<String> distilled = new ArrayList();\r\n    for (String pack : treeSet) {\r\n        if (notAlreadyContained(distilled, pack)) {\r\n            distilled.add(pack);\r\n        }\r\n    }\r\n    return distilled;\r\n}"
}, {
	"Path": "io.ebean.config.ServerConfig.getObjectMapper",
	"Comment": "return the jackson objectmapper.note that this is not strongly typed as jackson objectmapper is an optional dependency.",
	"Method": "Object getObjectMapper(){\r\n    return objectMapper;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.query.CQuery.auditFind",
	"Comment": "a find bean query with read auditing so build and log the readevent.",
	"Method": "void auditFind(EntityBean bean){\r\n    if (bean != null) {\r\n        desc.readAuditBean(queryPlan.getAuditQueryKey(), bindLog, bean);\r\n    }\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.BeanDescriptorCacheHelp.manyPropLoad",
	"Comment": "try to load the bean collection from cache return true if successful.",
	"Method": "boolean manyPropLoad(BeanPropertyAssocMany<?> many,BeanCollection<?> bc,Object parentId,Boolean readOnly){\r\n    if (many.isElementCollection()) {\r\n        return false;\r\n    }\r\n    CachedManyIds entry = manyPropGet(parentId, many.getName());\r\n    if (entry == null) {\r\n        return false;\r\n    }\r\n    Object ownerBean = bc.getOwnerBean();\r\n    EntityBeanIntercept ebi = ((EntityBean) ownerBean)._ebean_getIntercept();\r\n    PersistenceContext persistenceContext = ebi.getPersistenceContext();\r\n    BeanDescriptor<?> targetDescriptor = many.getTargetDescriptor();\r\n    List<Object> idList = entry.getIdList();\r\n    bc.checkEmptyLazyLoad();\r\n    for (Object id : idList) {\r\n        Object refBean = targetDescriptor.createReference(readOnly, false, id, persistenceContext);\r\n        many.add(bc, (EntityBean) refBean);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.DefaultTransactionThreadLocal.getState",
	"Comment": "return the current transactionstate for a given servername. this is for thelocal thread of course.",
	"Method": "TransactionMap.State getState(String serverName){\r\n    return local.get().getStateWithCreate(serverName);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.transaction.JdbcTransaction.internalBatchFlush",
	"Comment": "flush the jdbc batch and execute derived relationship statements if necessary.",
	"Method": "void internalBatchFlush(){\r\n    batchFlush();\r\n    if (deferredList != null) {\r\n        for (PersistDeferredRelationship deferred : deferredList) {\r\n            deferred.execute(this);\r\n        }\r\n        deferredList.clear();\r\n    }\r\n}"
}, {
	"Path": "cyclops.reactive.collections.mutable.SortedSetX.range",
	"Comment": "create a sortedsetx that contains the integers between skip and take",
	"Method": "SortedSetX<Integer> range(int start,int end){\r\n    return ReactiveSeq.range(start, end).to(ReactiveConvertableSequence::converter).sortedSetX(Evaluation.LAZY);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.OrmQueryRequest.determineMany",
	"Comment": "determine and return the tomany property that is included in the query.",
	"Method": "BeanPropertyAssocMany<?> determineMany(){\r\n    manyProperty = beanDescriptor.getManyProperty(query);\r\n    return manyProperty;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.DefaultContainer.getBootupClasses",
	"Comment": "get the entities, scalartypes, listeners etc combining the class registeredones with the already created instances.",
	"Method": "BootupClasses getBootupClasses(ServerConfig serverConfig){\r\n    BootupClasses bootup = getBootupClasses1(serverConfig);\r\n    bootup.addIdGenerators(serverConfig.getIdGenerators());\r\n    bootup.addPersistControllers(serverConfig.getPersistControllers());\r\n    bootup.addPostLoaders(serverConfig.getPostLoaders());\r\n    bootup.addPostConstructListeners(serverConfig.getPostConstructListeners());\r\n    bootup.addFindControllers(serverConfig.getFindControllers());\r\n    bootup.addPersistListeners(serverConfig.getPersistListeners());\r\n    bootup.addQueryAdapters(serverConfig.getQueryAdapters());\r\n    bootup.addServerConfigStartup(serverConfig.getServerConfigStartupListeners());\r\n    bootup.addChangeLogInstances(serverConfig);\r\n    bootup.runServerConfigStartup(serverConfig);\r\n    return bootup;\r\n}"
}, {
	"Path": "io.ebeaninternal.server.core.BasicTypeConverter.toDouble",
	"Comment": "convert the object to a double. it should be another numberic type.",
	"Method": "Double toDouble(Object value){\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    if (value instanceof Double) {\r\n        return (Double) value;\r\n    }\r\n    if (value instanceof Number) {\r\n        return ((Number) value).doubleValue();\r\n    }\r\n    return Double.valueOf(value.toString());\r\n}"
}, {
	"Path": "io.ebeaninternal.server.expression.DefaultExpressionList.queryPlanHash",
	"Comment": "calculate a hash based on the expressions but excluding the actual bindvalues.",
	"Method": "void queryPlanHash(StringBuilder builder){\r\n    builder.append(\"List[\");\r\n    if (textRoot) {\r\n        builder.append(\"textRoot:true \");\r\n    }\r\n    if (allDocNestedPath != null) {\r\n        builder.append(\"path:\").append(allDocNestedPath).append(\" \");\r\n    }\r\n    for (SpiExpression aList : list) {\r\n        aList.queryPlanHash(builder);\r\n        builder.append(\",\");\r\n    }\r\n    builder.append(\"]\");\r\n}"
}, {
	"Path": "io.ebeaninternal.server.deploy.meta.DeployBeanDescriptor.setBeanFinder",
	"Comment": "set the beanfinder to use for beans of this type. this is set to overridethe finding from the default.",
	"Method": "void setBeanFinder(BeanFindController beanFinder){\r\n    this.beanFinder = beanFinder;\r\n}"
}, {
	"Path": "io.ebeaninternal.dbmigration.ddlgeneration.platform.PlatformDdl.convertDefaultValue",
	"Comment": "convert the db column default literal to platform specific.",
	"Method": "String convertDefaultValue(String dbDefault){\r\n    return dbDefaultValue.convert(dbDefault);\r\n}"
}, {
	"Path": "org.tests.compositekeys.TestCore.testDoubleLazyLoad",
	"Comment": "this partially loads the item and then lazy loads the manytoone assoc",
	"Method": "void testDoubleLazyLoad(){\r\n    ItemKey itemKey = new ItemKey();\r\n    itemKey.setCustomer(2);\r\n    itemKey.setItemNumber(\"ITEM1\");\r\n    Item item = server().find(Item.class).select(\"description\").where().idEq(itemKey).findOne();\r\n    assertNotNull(item);\r\n    assertNotNull(item.getUnits());\r\n    assertEquals(\"P\", item.getUnits());\r\n    Type type = item.getEType();\r\n    assertNotNull(type);\r\n    assertNotNull(type.getDescription());\r\n    SubType subType = type.getSubType();\r\n    assertNotNull(subType);\r\n    assertNotNull(subType.getDescription());\r\n}"
}, {
	"Path": "cyclops.monads.transformers.jdk.OptionalT.fromAnyM",
	"Comment": "construct an optionalwt from an anym that contains a monad type that contains type other than optionalthe values in the underlying monad will be mapped to optional",
	"Method": "OptionalT<W, A> fromAnyM(AnyM<W, A> anyM){\r\n    return of(anyM.map(Optional::ofNullable));\r\n}"
}, {
	"Path": "io.ebeanservice.docstore.api.support.DocStoreDeleteEvent.docStoreUpdate",
	"Comment": "add appropriate json content for sending to the elasticsearch bulk api.",
	"Method": "void docStoreUpdate(DocStoreUpdateContext txn){\r\n    beanType.docStore().deleteById(idValue, txn);\r\n}"
}, {
	"Path": "io.ebeaninternal.server.lib.ShutdownManager.shutdown",
	"Comment": "shutdown gracefully cleaning up any resources as required.this is typically invoked via jvm shutdown hook.",
	"Method": "void shutdown(){\r\n    synchronized (servers) {\r\n        if (stopping) {\r\n            return;\r\n        }\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Shutting down\");\r\n        }\r\n        stopping = true;\r\n        deregisterShutdownHook();\r\n        String shutdownRunner = System.getProperty(\"ebean.shutdown.runnable\");\r\n        if (shutdownRunner != null) {\r\n            try {\r\n                Runnable r = (Runnable) ClassUtil.newInstance(shutdownRunner);\r\n                r.run();\r\n            } catch (Exception e) {\r\n                logger.error(\"Error running custom shutdown runnable\", e);\r\n            }\r\n        }\r\n        if (container != null) {\r\n            container.shutdown();\r\n        }\r\n        for (SpiEbeanServer server : servers) {\r\n            try {\r\n                server.shutdownManaged();\r\n            } catch (Exception ex) {\r\n                logger.error(\"Error executing shutdown runnable\", ex);\r\n                ex.printStackTrace();\r\n            }\r\n        }\r\n        if (\"true\".equalsIgnoreCase(System.getProperty(\"ebean.datasource.deregisterAllDrivers\", \"false\"))) {\r\n            deregisterAllJdbcDrivers();\r\n        }\r\n    }\r\n}"
}]