[{
	"Path": "org.springframework.jdbc.object.RdbmsOperation.getResultSetType",
	"Comment": "return whether statements will return a specific type of resultset.",
	"Method": "int getResultSetType(){\r\n    return this.resultSetType;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.ConfigurationImpl.setMaybeThreshold",
	"Comment": "sets the probability threshold for considering two recordspossibly equivalent. does not have to be set.",
	"Method": "void setMaybeThreshold(double thresholdMaybe){\r\n    this.thresholdMaybe = thresholdMaybe;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.delegates.DelegateMethodCreator.createExpressionStatement",
	"Comment": "creates a new expression statement for the method invocation.",
	"Method": "ExpressionStatement createExpressionStatement(MethodInvocation invocation){\r\n    Assert.isNotNull(invocation);\r\n    return invocation.getAST().newExpressionStatement(invocation);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.util.TextChangeManager.clear",
	"Comment": "clears all associations between resources and text changes.",
	"Method": "void clear(){\r\n    fMap.clear();\r\n}"
}, {
	"Path": "no.priv.garshol.duke.genetic.GeneticAlgorithm.setQuestions",
	"Comment": "sets the number of questions to ask per generation in activelearning mode. default 10.",
	"Method": "void setQuestions(int questions){\r\n    this.questions = questions;\r\n}"
}, {
	"Path": "denominator.model.ResourceRecordSets.soa",
	"Comment": "returns an updated soa rrset, with an incremented serial number and the specified parameters.",
	"Method": "ResourceRecordSet<SOAData> soa(ResourceRecordSet<?> soa,String email,int ttl){\r\n    SOAData soaData = (SOAData) soa.records().get(0);\r\n    soaData = soaData.toBuilder().serial(soaData.serial() + 1).rname(email).build();\r\n    return ResourceRecordSet.<SOAData>builder().name(soa.name()).type(\"SOA\").ttl(ttl).add(soaData).build();\r\n}"
}, {
	"Path": "sx.blah.discord.api.ClientBuilder.setMaxReconnectAttempts",
	"Comment": "configures the max number of attempts shards managed by the client will make to reconnect to discord.",
	"Method": "ClientBuilder setMaxReconnectAttempts(int maxReconnectAttempts){\r\n    this.maxReconnectAttempts = maxReconnectAttempts;\r\n    return this;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.RefactoringSearchEngine2.setWorkingCopies",
	"Comment": "sets the working copies to take precedence during the searches.\tthis method must be called before start searching. the default is to use no working copies",
	"Method": "void setWorkingCopies(ICompilationUnit[] copies){\r\n    Assert.isNotNull(copies);\r\n    fWorkingCopies = new ICompilationUnit[copies.length];\r\n    System.arraycopy(copies, 0, fWorkingCopies, 0, copies.length);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider.isSupportsSchemasInProcedureCalls",
	"Comment": "does the database support the use of schema name in procedure calls",
	"Method": "boolean isSupportsSchemasInProcedureCalls(){\r\n    return this.supportsSchemasInProcedureCalls;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.RowCountCallbackHandler.getColumnTypes",
	"Comment": "return the types of the columns as java.sql.types constants\tvalid after processrow is invoked the first time.",
	"Method": "int[] getColumnTypes(){\r\n    return columnTypes;\r\n}"
}, {
	"Path": "com.yahoo.elide.datastores.hibernate5.HibernateTransaction.getTotalRecords",
	"Comment": "returns the total record count for a root entity and an optional filter expression.",
	"Method": "Long getTotalRecords(Class<T> entityClass,Optional<FilterExpression> filterExpression,EntityDictionary dictionary,Long getTotalRecords,AbstractHQLQueryBuilder.Relationship relationship,Optional<FilterExpression> filterExpression,EntityDictionary dictionary){\r\n    QueryWrapper query = (QueryWrapper) new SubCollectionPageTotalsQueryBuilder(relationship, dictionary, sessionWrapper).withPossibleFilterExpression(filterExpression).build();\r\n    return (Long) query.getQuery().uniqueResult();\r\n}"
}, {
	"Path": "no.priv.garshol.duke.ConfigurationImpl.getMaybeThreshold",
	"Comment": "the probability threshold used to decide whether two records mayrepresent the same entity. if the probability is higher than thisvalue, the two records are considered possible matches. can be 0,in which case no records are considered possible matches.",
	"Method": "double getMaybeThreshold(){\r\n    return thresholdMaybe;\r\n}"
}, {
	"Path": "org.dom4j.DocumentFactory.createQNameCache",
	"Comment": "factory method to create the qnamecache. this method should be overloadedif you wish to use your own derivation of qname.",
	"Method": "QNameCache createQNameCache(){\r\n    return new QNameCache(this);\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.SqlFunction.mapRow",
	"Comment": "this implementation of this method extracts a single value from the\tsingle row returned by the function. if there are a different number\tof rows returned, this is treated as an error.",
	"Method": "T mapRow(ResultSet rs,int rowNum){\r\n    return this.rowMapper.mapRow(rs, rowNum);\r\n}"
}, {
	"Path": "no.priv.garshol.duke.ConfigurationImpl.getThreshold",
	"Comment": "the probability threshold used to decide whether two recordsrepresent the same entity. if the probability is higher than thisvalue, the two records are considered to represent the sameentity.",
	"Method": "double getThreshold(){\r\n    return threshold;\r\n}"
}, {
	"Path": "effectivejava.chapter3.item13.Stack.main",
	"Comment": "to see that clone works, call with several command line arguments",
	"Method": "void main(String[] args){\r\n    Stack stack = new Stack();\r\n    for (String arg : args) stack.push(arg);\r\n    Stack copy = stack.clone();\r\n    while (!stack.isEmpty()) System.out.print(stack.pop() + \" \");\r\n    System.out.println();\r\n    while (!copy.isEmpty()) System.out.print(copy.pop() + \" \");\r\n}"
}, {
	"Path": "denominator.route53.Route53AllProfileResourceRecordSetApi.iterator",
	"Comment": "lists and lazily transforms all record sets who are not aliases into denominator format.",
	"Method": "Iterator<ResourceRecordSet<?>> iterator(){\r\n    return lazyIterateRRSets(api.listResourceRecordSets(zoneId), notAlias());\r\n}"
}, {
	"Path": "no.priv.garshol.duke.comparators.Levenshtein.compactDistance",
	"Comment": "optimized version of the wagner & fischer algorithm that onlykeeps a single column in the matrix in memory at a time. itimplements the simple cutoff, but otherwise computes the entirematrix. it is roughly twice as fast as the original function.",
	"Method": "int compactDistance(String s1,String s2){\r\n    if (s1.length() == 0)\r\n        return s2.length();\r\n    if (s2.length() == 0)\r\n        return s1.length();\r\n    int maxdist = Math.min(s1.length(), s2.length()) / 2;\r\n    int s1len = s1.length();\r\n    int[] column = new int[s1len + 1];\r\n    int ix2 = 0;\r\n    char ch2 = s2.charAt(ix2);\r\n    column[0] = 1;\r\n    for (int ix1 = 1; ix1 <= s1len; ix1++) {\r\n        int cost = s1.charAt(ix1 - 1) == ch2 ? 0 : 1;\r\n        column[ix1] = Math.min(column[ix1 - 1], ix1 - 1) + cost;\r\n    }\r\n    int above = 0;\r\n    for (ix2 = 1; ix2 < s2.length(); ix2++) {\r\n        ch2 = s2.charAt(ix2);\r\n        above = ix2 + 1;\r\n        int smallest = s1len * 2;\r\n        for (int ix1 = 1; ix1 <= s1len; ix1++) {\r\n            int cost = s1.charAt(ix1 - 1) == ch2 ? 0 : 1;\r\n            int value = Math.min(Math.min(above, column[ix1 - 1]), column[ix1]) + cost;\r\n            column[ix1 - 1] = above;\r\n            above = value;\r\n            smallest = Math.min(smallest, value);\r\n        }\r\n        column[s1len] = above;\r\n        if (smallest > maxdist)\r\n            return smallest;\r\n    }\r\n    return above;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils.extractCaseInsensitiveParameterNames",
	"Comment": "create a map of case insensitive parameter names together with the original name.",
	"Method": "Map<String, String> extractCaseInsensitiveParameterNames(SqlParameterSource parameterSource){\r\n    Map<String, String> caseInsensitiveParameterNames = new HashMap<String, String>();\r\n    if (parameterSource instanceof BeanPropertySqlParameterSource) {\r\n        String[] propertyNames = ((BeanPropertySqlParameterSource) parameterSource).getReadablePropertyNames();\r\n        for (int i = 0; i < propertyNames.length; i++) {\r\n            String name = propertyNames[i];\r\n            caseInsensitiveParameterNames.put(name.toLowerCase(), name);\r\n        }\r\n    } else if (parameterSource instanceof MapSqlParameterSource) {\r\n        for (String name : ((MapSqlParameterSource) parameterSource).getValues().keySet()) {\r\n            caseInsensitiveParameterNames.put(name.toLowerCase(), name);\r\n        }\r\n    }\r\n    return caseInsensitiveParameterNames;\r\n}"
}, {
	"Path": "sx.blah.discord.modules.ModuleLoader.findFileForClass",
	"Comment": "gets the jar file which contains a class with the given class name.",
	"Method": "File findFileForClass(List<File> files,String clazz){\r\n    return files.stream().filter((file) -> {\r\n        try {\r\n            JarFile jarFile = new JarFile(file);\r\n            return jarFile.getJarEntry(clazz.replaceAll(\"\\\\.\", File.pathSeparator) + \".class\") != null;\r\n        } catch (IOException e) {\r\n            return false;\r\n        }\r\n    }).findFirst().orElse(null);\r\n}"
}, {
	"Path": "no.priv.garshol.duke.Processor.setThreads",
	"Comment": "sets the number of threads to use for processing. the default is",
	"Method": "void setThreads(int threads){\r\n    this.threads = threads;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.dom.ModifierRewrite.setModifiers",
	"Comment": "sets the included modifiers and removes the excluded modifiers. does not\ttouch other flags and leaves annotations in place.",
	"Method": "PositionInformation setModifiers(int modifiers,TextEditGroup editGroup,PositionInformation setModifiers,int included,int excluded,TextEditGroup editGroup){\r\n    return internalSetModifiers(included, included | excluded, editGroup);\r\n}"
}, {
	"Path": "no.priv.garshol.duke.utils.JDBCUtils.validate",
	"Comment": "verifies that the connection is still alive. returns true if itis, false if it is not. if the connection is broken we tryclosing everything, too, so that the caller need only open a newconnection.",
	"Method": "boolean validate(Statement stmt){\r\n    try {\r\n        Connection conn = stmt.getConnection();\r\n        if (conn == null)\r\n            return false;\r\n        if (!conn.isClosed() && conn.isValid(10))\r\n            return true;\r\n        stmt.close();\r\n        conn.close();\r\n    } catch (SQLException e) {\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "sx.blah.discord.modules.ModuleLoader.loadClass",
	"Comment": "recursively loads the parents of subclasses in order to avoid class loader errors.",
	"Method": "Class loadClass(String clazz){\r\n    if (clazz.contains(\"$\") && clazz.substring(0, clazz.lastIndexOf(\"$\")).length() > 0) {\r\n        try {\r\n            loadClass(clazz.substring(0, clazz.lastIndexOf(\"$\")));\r\n        } catch (ClassNotFoundException ignored) {\r\n        }\r\n    }\r\n    return Class.forName(clazz);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corrections.proposals.MissingReturnTypeCorrectionProposal.evaluateReturnExpressions",
	"Comment": "evaluates possible return expressions. the favourite expression is returned.",
	"Method": "Expression evaluateReturnExpressions(AST ast,ITypeBinding returnBinding,int returnOffset){\r\n    CompilationUnit root = getCU();\r\n    Expression result = null;\r\n    if (returnBinding != null) {\r\n        result = computeProposals(ast, returnBinding, returnOffset, root, result);\r\n    }\r\n    Expression defaultExpression = createDefaultExpression(ast);\r\n    addLinkedPositionProposal(RETURN_EXPRESSION_KEY, ASTNodes.asString(defaultExpression));\r\n    if (result == null) {\r\n        return defaultExpression;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.ResultSetSupportingSqlParameter.getRowCallbackHandler",
	"Comment": "return the rowcallbackhandler held by this parameter, if any.",
	"Method": "RowCallbackHandler getRowCallbackHandler(){\r\n    return this.rowCallbackHandler;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactoryBean.setDatabaseCleaner",
	"Comment": "set a script execution to be run in the bean destruction callback,\tcleaning up the database and leaving it in a known state for others.",
	"Method": "void setDatabaseCleaner(DatabasePopulator databaseCleaner){\r\n    this.databaseCleaner = databaseCleaner;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.DelegatingDataSource.setTargetDataSource",
	"Comment": "set the target datasource that this datasource should delegate to.",
	"Method": "void setTargetDataSource(DataSource targetDataSource){\r\n    Assert.notNull(targetDataSource, \"'targetDataSource' must not be null\");\r\n    this.targetDataSource = targetDataSource;\r\n}"
}, {
	"Path": "sx.blah.discord.util.MessageHistory.getChannel",
	"Comment": "gets the channel the messages were sent in, or null if no messages are present.",
	"Method": "IChannel getChannel(){\r\n    return (backing.length == 0) ? null : backing[0].getChannel();\r\n}"
}, {
	"Path": "sx.blah.discord.util.MessageTokenizer.nextInvite",
	"Comment": "gets the next invite in the content and moves the pointer forward.",
	"Method": "InviteToken nextInvite(){\r\n    if (!hasNextInvite())\r\n        throw new IllegalStateException(\"No more invites found!\");\r\n    Matcher matcher = INVITE_PATTERN.matcher(remaining);\r\n    if (!matcher.find())\r\n        throw new IllegalStateException(\"Couldn't find any matches!\");\r\n    final int start = currentPosition + matcher.start();\r\n    final int end = currentPosition + matcher.end();\r\n    stepTo(end);\r\n    return new InviteToken(this, start, end);\r\n}"
}, {
	"Path": "org.dom4j.rule.RuleManager.getMatchingRule",
	"Comment": "performs an xslt processing model match for the rule which matches thegiven node the best.",
	"Method": "Rule getMatchingRule(String modeName,Node node){\r\n    Mode mode = modes.get(modeName);\r\n    if (mode != null) {\r\n        return mode.getMatchingRule(node);\r\n    } else {\r\n        System.out.println(\"Warning: No Mode for mode: \" + mode);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.CallableStatementCreatorFactory.setUpdatableResults",
	"Comment": "set whether to use prepared statements capable of returning updatable resultsets.",
	"Method": "void setUpdatableResults(boolean updatableResults){\r\n    this.updatableResults = updatableResults;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.util.RefactoringFileBuffers.release",
	"Comment": "releases the text file buffer associated with the compilation unit.",
	"Method": "void release(ICompilationUnit unit){\r\n    Assert.isNotNull(unit);\r\n    final IResource resource = unit.getResource();\r\n    if (resource != null && resource.getType() == IResource.FILE) {\r\n        FileBuffers.getTextFileBufferManager().disconnect(resource.getFullPath(), LocationKind.IFILE, new NullProgressMonitor());\r\n    }\r\n}"
}, {
	"Path": "denominator.route53.Route53ZoneApiMockTest.iterateByNameWhenIrrelevant",
	"Comment": "route53 list by name is only about order. we need to ensure we skip irrelevant zones.",
	"Method": "void iterateByNameWhenIrrelevant(){\r\n    server.enqueue(new MockResponse().setBody(\"<ListHostedZonesByNameResponse xmlns=\\\"https://route53.amazonaws.com/doc/2013-04-01/\\\">\\n\" + \"  <HostedZones>\\n\" + \"    <HostedZone>\\n\" + \"      <Id>/hostedzone/Z2ZEEJCUZCVG56<\/Id>\\n\" + \"      <Name>denominator.io.<\/Name>\\n\" + \"      <CallerReference>Foo<\/CallerReference>\\n\" + \"      <Config>\\n\" + \"        <PrivateZone>false<\/PrivateZone>\\n\" + \"      <\/Config>\\n\" + \"      <ResourceRecordSetCount>3<\/ResourceRecordSetCount>\\n\" + \"    <\/HostedZone>\\n\" + \"  <\/HostedZones>\\n\" + \"  <DNSName>denominator.io.<\/DNSName>\\n\" + \"  <IsTruncated>false<\/IsTruncated>\\n\" + \"  <MaxItems>100<\/MaxItems>\\n\" + \"<\/ListHostedZonesByNameResponse>\"));\r\n    ZoneApi api = server.connect().api().zones();\r\n    assertThat(api.iterateByName(\"denominator.com.\")).isEmpty();\r\n    server.assertRequest().hasMethod(\"GET\").hasPath(\"/2013-04-01/hostedzonesbyname?dnsname=denominator.com.\");\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.SqlQuery.executeByNamedParam",
	"Comment": "central execution method. all named parameter execution goes through this method.",
	"Method": "List<T> executeByNamedParam(Map<String, ?> paramMap,Map<?, ?> context,List<T> executeByNamedParam,Map<String, ?> paramMap){\r\n    return executeByNamedParam(paramMap, null);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.AbstractJdbcCall.getCallString",
	"Comment": "get the call string that should be used based on parameters and meta data.",
	"Method": "String getCallString(){\r\n    return this.callString;\r\n}"
}, {
	"Path": "denominator.route53.AliasTarget.dnsName",
	"Comment": "dns domain name for your cloudfront distribution, amazon s3 bucket, elastic load balancing loadbalancer, or another resource record set in this hosted zone.",
	"Method": "String dnsName(){\r\n    return get(\"DNSName\").toString();\r\n}"
}, {
	"Path": "sx.blah.discord.util.RequestBuilder.andThen",
	"Comment": "sets the new active action which will be executed after the current one succeeds.",
	"Method": "RequestBuilder andThen(IRequestAction action){\r\n    actions.add(activeAction);\r\n    activeAction = new Action();\r\n    activeAction.mode = failOnException ? ActionMode.NEXT : ActionMode.ALWAYS;\r\n    return doAction(action);\r\n}"
}, {
	"Path": "org.dom4j.io.XMLWriter.shouldEncodeChar",
	"Comment": "should the given character be escaped. this depends on the encoding ofthe document.",
	"Method": "boolean shouldEncodeChar(int codepoint){\r\n    int max = getMaximumAllowedCharacter();\r\n    return (max > 0) && (codepoint > max);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider.setStoresLowerCaseIdentifiers",
	"Comment": "specify whether the database uses lower case for identifiers",
	"Method": "void setStoresLowerCaseIdentifiers(boolean storesLowerCaseIdentifiers){\r\n    this.storesLowerCaseIdentifiers = storesLowerCaseIdentifiers;\r\n}"
}, {
	"Path": "org.dom4j.io.DispatchHandler.setDefaultHandler",
	"Comment": "when multiple elementhandler instances have beenregistered, this will set a default elementhandler to becalled for any path which does nothave a handler registered.",
	"Method": "void setDefaultHandler(ElementHandler handler){\r\n    defaultHandler = handler;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.ResultSetSupportingSqlParameter.getResultSetExtractor",
	"Comment": "return the resultsetextractor held by this parameter, if any.",
	"Method": "ResultSetExtractor<?> getResultSetExtractor(){\r\n    return this.resultSetExtractor;\r\n}"
}, {
	"Path": "org.dcm4che3.net.ApplicationEntity.setDevice",
	"Comment": "set the device that is identified by this application entity.",
	"Method": "void setDevice(Device device){\r\n    if (device != null) {\r\n        if (this.device != null)\r\n            throw new IllegalStateException(\"already owned by \" + this.device.getDeviceName());\r\n        for (Connection conn : conns) if (conn.getDevice() != device)\r\n            throw new IllegalStateException(conn + \" not owned by \" + device.getDeviceName());\r\n    }\r\n    this.device = device;\r\n}"
}, {
	"Path": "org.dom4j.tree.AbstractBranch.contentRemoved",
	"Comment": "called when the given list content has been removed so each node shouldhave its parent and document relationships cleared",
	"Method": "void contentRemoved(){\r\n    List<Node> content = contentList();\r\n    for (Node node : content) {\r\n        childRemoved(node);\r\n    }\r\n}"
}, {
	"Path": "com.yahoo.elide.datastores.multiplex.MultiplexWriteTransaction.cloneObject",
	"Comment": "clone contents of object for possible reverse transaction.",
	"Method": "Object cloneObject(Object object){\r\n    if (object == null) {\r\n        return null;\r\n    }\r\n    Class<?> cls = multiplexManager.getDictionary().lookupEntityClass(object.getClass());\r\n    try {\r\n        Object clone = cls.newInstance();\r\n        for (Field field : cls.getFields()) {\r\n            field.set(clone, field.get(object));\r\n        }\r\n        for (Method method : cls.getMethods()) {\r\n            if (method.getName().startsWith(\"set\")) {\r\n                try {\r\n                    Method getMethod = cls.getMethod(\"get\" + method.getName().substring(3));\r\n                    method.invoke(clone, getMethod.invoke(object));\r\n                } catch (IllegalStateException | IllegalArgumentException | ReflectiveOperationException | SecurityException e) {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n        return clone;\r\n    } catch (InstantiationException | IllegalAccessException e) {\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.UpdateOnCreateTest.createPermissionInheritedForAttributeSuccessCase",
	"Comment": "expression for field inherited from class level expression",
	"Method": "void createPermissionInheritedForAttributeSuccessCase(){\r\n    PersistentResource<UpdateAndCreate> created = PersistentResource.createObject(null, UpdateAndCreate.class, userOneScope, Optional.of(\"4\"));\r\n    created.updateAttribute(\"name\", \"\");\r\n    created.getRequestScope().getPermissionExecutor().executeCommitChecks();\r\n}"
}, {
	"Path": "sx.blah.discord.handle.impl.events.guild.channel.message.MessageUpdateEvent.getOldMessage",
	"Comment": "gets the message before it was updated. can be null if there was no previous message to compare to.",
	"Method": "IMessage getOldMessage(){\r\n    return oldMessage;\r\n}"
}, {
	"Path": "sx.blah.discord.api.internal.HeartbeatHandler.getAckResponseTime",
	"Comment": "gets the amount of time it last took discord to respond to a heartbeat with an ack.",
	"Method": "long getAckResponseTime(){\r\n    return ackResponseTime;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.ConnectionHolder.createSavepoint",
	"Comment": "create a new jdbc 3.0 savepoint for the current connection,\tusing generated savepoint names that are unique for the connection.",
	"Method": "Savepoint createSavepoint(){\r\n    this.savepointCounter++;\r\n    return getConnection().setSavepoint(SAVEPOINT_NAME_PREFIX + this.savepointCounter);\r\n}"
}, {
	"Path": "org.dom4j.io.XPP3Reader.addHandler",
	"Comment": "adds the elementhandler to be called when the specifiedpath is encounted.",
	"Method": "void addHandler(String path,ElementHandler handler){\r\n    getDispatchHandler().addHandler(path, handler);\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.DataSourceTransactionManager.doBegin",
	"Comment": "this implementation sets the isolation level but ignores the timeout.",
	"Method": "void doBegin(Object transaction,TransactionDefinition definition){\r\n    DataSourceTransactionObject txObject = (DataSourceTransactionObject) transaction;\r\n    Connection con = null;\r\n    try {\r\n        if (txObject.getConnectionHolder() == null || txObject.getConnectionHolder().isSynchronizedWithTransaction()) {\r\n            Connection newCon = this.dataSource.getConnection();\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Acquired Connection [\" + newCon + \"] for JDBC transaction\");\r\n            }\r\n            txObject.setConnectionHolder(new ConnectionHolder(newCon), true);\r\n        }\r\n        txObject.getConnectionHolder().setSynchronizedWithTransaction(true);\r\n        con = txObject.getConnectionHolder().getConnection();\r\n        Integer previousIsolationLevel = DataSourceUtils.prepareConnectionForTransaction(con, definition);\r\n        txObject.setPreviousIsolationLevel(previousIsolationLevel);\r\n        if (con.getAutoCommit()) {\r\n            txObject.setMustRestoreAutoCommit(true);\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Switching JDBC Connection [\" + con + \"] to manual commit\");\r\n            }\r\n            con.setAutoCommit(false);\r\n        }\r\n        txObject.getConnectionHolder().setTransactionActive(true);\r\n        int timeout = determineTimeout(definition);\r\n        if (timeout != TransactionDefinition.TIMEOUT_DEFAULT) {\r\n            txObject.getConnectionHolder().setTimeoutInSeconds(timeout);\r\n        }\r\n        if (txObject.isNewConnectionHolder()) {\r\n            TransactionSynchronizationManager.bindResource(getDataSource(), txObject.getConnectionHolder());\r\n        }\r\n    } catch (Throwable ex) {\r\n        DataSourceUtils.releaseConnection(con, this.dataSource);\r\n        throw new CannotCreateTransactionException(\"Could not open JDBC Connection for transaction\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.AbstractJdbcInsert.setAccessTableColumnMetaData",
	"Comment": "specify whether the parameter metadata for the call should be used.the default is true.",
	"Method": "void setAccessTableColumnMetaData(boolean accessTableColumnMetaData){\r\n    this.tableMetaDataContext.setAccessTableColumnMetaData(accessTableColumnMetaData);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils.createBatch",
	"Comment": "create an array of beanpropertysqlparametersource objects populated with data\tfrom the values passed in. this will define what is included in a batch operation.",
	"Method": "SqlParameterSource[] createBatch(Map<String, ?>[] valueMaps,SqlParameterSource[] createBatch,Object[] beans){\r\n    BeanPropertySqlParameterSource[] batch = new BeanPropertySqlParameterSource[beans.length];\r\n    for (int i = 0; i < beans.length; i++) {\r\n        Object bean = beans[i];\r\n        batch[i] = new BeanPropertySqlParameterSource(bean);\r\n    }\r\n    return batch;\r\n}"
}, {
	"Path": "org.dom4j.tree.QNameCache.createQName",
	"Comment": "factory method to create a new qname object which can be overloaded tocreate derived qname instances",
	"Method": "QName createQName(String name,QName createQName,String name,Namespace namespace,QName createQName,String name,Namespace namespace,String qualifiedName){\r\n    return new QName(name, namespace, qualifiedName);\r\n}"
}, {
	"Path": "org.dom4j.Namespace.createHashCode",
	"Comment": "factory method to create the hashcode allowing derived classes to changethe behaviour",
	"Method": "int createHashCode(){\r\n    int result = uri.hashCode() ^ prefix.hashCode();\r\n    if (result == 0) {\r\n        result = 0xbabe;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.EntityDictionary.getSubclassingEntities",
	"Comment": "get a list of inherited entities from a particular entity.namely, the list of entities inheriting from the provided class.",
	"Method": "List<Class<?>> getSubclassingEntities(String entityName,List<Class<?>> getSubclassingEntities,Class entityClass){\r\n    return subclassingEntities.computeIfAbsent(entityClass, (unused) -> {\r\n        return entityBindings.keySet().stream().filter(c -> c != entityClass && entityClass.isAssignableFrom(c)).collect(Collectors.toList());\r\n    });\r\n}"
}, {
	"Path": "denominator.model.rdata.SRVData.target",
	"Comment": "the domain name of the target host. there must be one or more address records for this name,the name must not be an alias.",
	"Method": "String target(SRVData.Builder target,String target){\r\n    return get(\"target\").toString();\r\n}"
}, {
	"Path": "org.dcm4che3.net.Connection.setCommonName",
	"Comment": "an arbitrary name for the network connections object. can be a meaningfulname or any unique sequence of characters.",
	"Method": "void setCommonName(String name){\r\n    this.commonName = name;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.filter.FilterPredicate.getAlias",
	"Comment": "returns an alias that uniquely identifies the last collection of entities in the path.",
	"Method": "String getAlias(){\r\n    List<PathElement> elements = path.getPathElements();\r\n    PathElement last = elements.get(elements.size() - 1);\r\n    if (elements.size() == 1) {\r\n        return getTypeAlias(last.getType());\r\n    }\r\n    PathElement previous = elements.get(elements.size() - 2);\r\n    return getTypeAlias(previous.getType()) + UNDERSCORE + previous.getFieldName();\r\n}"
}, {
	"Path": "com.yahoo.elide.jsonapi.document.processors.IncludedProcessor.addIncludedResources",
	"Comment": "adds the requested relation resources to the included block of the jsonapidocument.",
	"Method": "void addIncludedResources(JsonApiDocument jsonApiDocument,PersistentResource rec,List<String> requestedRelationPaths){\r\n    requestedRelationPaths.forEach(pathParam -> {\r\n        List<String> pathList = Arrays.asList(pathParam.split(RELATION_PATH_SEPARATOR));\r\n        pathList.forEach(requestedRelationPath -> {\r\n            List<String> relationPath = Lists.newArrayList(requestedRelationPath.split(RELATION_PATH_DELIMITER));\r\n            addResourcesForPath(jsonApiDocument, rec, relationPath);\r\n        });\r\n    });\r\n}"
}, {
	"Path": "com.yahoo.elide.core.UpdateOnCreateTest.updatePermissionOverwrittenForRelationSuccessCase",
	"Comment": "class level expression overwritten by field level expression",
	"Method": "void updatePermissionOverwrittenForRelationSuccessCase(){\r\n    PersistentResource<UpdateAndCreate> loaded = PersistentResource.loadRecord(UpdateAndCreate.class, \"1\", userThreeScope);\r\n    PersistentResource<Author> loadedAuthor = PersistentResource.loadRecord(Author.class, \"1\", userThreeScope);\r\n    loaded.addRelation(\"author\", loadedAuthor);\r\n    loaded.getRequestScope().getPermissionExecutor().executeCommitChecks();\r\n}"
}, {
	"Path": "org.dom4j.samples.HTMLWriterDemo.createXMLWriter",
	"Comment": "a factory method to create an xmlwriter instance allowingderived classes to change this behaviour",
	"Method": "XMLWriter createXMLWriter(){\r\n    return new HTMLWriter(System.out);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.contentassist.CompletionProposalDescriptionProvider.createMethodProposalDescription",
	"Comment": "creates and returns the method signature suitable for display.",
	"Method": "StringBuilder createMethodProposalDescription(CompletionProposal proposal){\r\n    int kind = proposal.getKind();\r\n    StringBuilder description = new StringBuilder();\r\n    switch(kind) {\r\n        case CompletionProposal.METHOD_REF:\r\n        case CompletionProposal.METHOD_NAME_REFERENCE:\r\n        case CompletionProposal.POTENTIAL_METHOD_DECLARATION:\r\n        case CompletionProposal.CONSTRUCTOR_INVOCATION:\r\n            description.append(proposal.getName());\r\n            description.append('(');\r\n            appendUnboundedParameterList(description, proposal);\r\n            description.append(')');\r\n            if (!proposal.isConstructor()) {\r\n                char[] returnType = createTypeDisplayName(SignatureUtil.getUpperBound(Signature.getReturnType(SignatureUtil.fix83600(proposal.getSignature()))));\r\n                description.append(RETURN_TYPE_SEPARATOR);\r\n                description.append(returnType);\r\n            }\r\n    }\r\n    return description;\r\n}"
}, {
	"Path": "org.dom4j.io.ElementStack.clear",
	"Comment": "peeks at the top element on the stack without changing the contents ofthe stack.",
	"Method": "void clear(){\r\n    lastElementIndex = -1;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.nls.NLSUtil.createNLSEdit",
	"Comment": "creates and returns an nls tag edit for a string that is at the specified position in a\tcompilation unit.",
	"Method": "TextEdit createNLSEdit(ICompilationUnit cu,int position){\r\n    NLSLine nlsLine = scanCurrentLine(cu, position);\r\n    if (nlsLine == null) {\r\n        return null;\r\n    }\r\n    NLSElement element = findElement(nlsLine, position);\r\n    if (element.hasTag()) {\r\n        return null;\r\n    }\r\n    NLSElement[] elements = nlsLine.getElements();\r\n    int indexInElementList = Arrays.asList(elements).indexOf(element);\r\n    int editOffset = computeInsertOffset(elements, indexInElementList, cu);\r\n    String editText = ' ' + NLSElement.createTagText(indexInElementList + 1);\r\n    return new InsertEdit(editOffset, editText);\r\n}"
}, {
	"Path": "org.dom4j.NamespaceTest.testNamespaceUriMap",
	"Comment": "tests the use of namespace uri mapping associated with a documentfactory",
	"Method": "void testNamespaceUriMap(){\r\n    Map<String, String> uris = new HashMap<String, String>();\r\n    uris.put(\"x\", \"fooNamespace\");\r\n    uris.put(\"y\", \"barNamespace\");\r\n    DocumentFactory factory = new DocumentFactory();\r\n    factory.setXPathNamespaceURIs(uris);\r\n    SAXReader reader = new SAXReader();\r\n    reader.setDocumentFactory(factory);\r\n    Document doc = getDocument(\"/xml/test/nestedNamespaces.xml\", reader);\r\n    String value = doc.valueOf(\"/x:pizza/y:cheese/x:pepper\");\r\n    log(\"Found value: \" + value);\r\n    assertEquals(\"XPath used default namesapce URIS\", \"works\", value);\r\n}"
}, {
	"Path": "com.ea.async.instrumentation.Transformer.setErrorListener",
	"Comment": "sets an error listener that gets called for invalid uses of await.",
	"Method": "void setErrorListener(Consumer<String> errorListener){\r\n    this.errorListener = errorListener;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.RowCountCallbackHandler.getColumnNames",
	"Comment": "return the names of the columns.\tvalid after processrow is invoked the first time.",
	"Method": "String[] getColumnNames(){\r\n    return columnNames;\r\n}"
}, {
	"Path": "org.dom4j.tree.NamespaceStack.createNamespace",
	"Comment": "factory method to creeate new namespace instances. by default this methodinterns the namespace",
	"Method": "Namespace createNamespace(String prefix,String namespaceURI){\r\n    return documentFactory.createNamespace(prefix, namespaceURI);\r\n}"
}, {
	"Path": "no.priv.garshol.duke.utils.PropertyUtils.get",
	"Comment": "returns the value of an optional property, if the property isset.if it is not set defval is returned.",
	"Method": "String get(Properties props,String name,String get,Properties props,String name,String defval,int get,Properties props,String name,int defval){\r\n    String value = props.getProperty(name);\r\n    if (value == null)\r\n        return defval;\r\n    return Integer.parseInt(value);\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.JdbcAccessor.isLazyInit",
	"Comment": "return whether to lazily initialize the sqlexceptiontranslator for this accessor.",
	"Method": "boolean isLazyInit(){\r\n    return this.lazyInit;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.hibernate.hql.SubCollectionFetchQueryBuilder.build",
	"Comment": "constructs a query that returns the members of a relationship.",
	"Method": "Query build(){\r\n    if (!filterExpression.isPresent() && !pagination.isPresent() && (!sorting.isPresent() || sorting.get().isDefaultInstance())) {\r\n        return null;\r\n    }\r\n    String childAlias = FilterPredicate.getTypeAlias(relationship.getChildType());\r\n    String parentAlias = FilterPredicate.getTypeAlias(relationship.getParentType()) + \"__fetch\";\r\n    String parentName = relationship.getParentType().getCanonicalName();\r\n    String relationshipName = relationship.getRelationshipName();\r\n    Query query = filterExpression.map(fe -> {\r\n        PredicateExtractionVisitor extractor = new PredicateExtractionVisitor();\r\n        Collection<FilterPredicate> predicates = fe.accept(extractor);\r\n        String filterClause = new HQLFilterOperation().apply(fe, USE_ALIAS);\r\n        String joinClause = getJoinClauseFromFilters(filterExpression.get()) + extractToOneMergeJoins(relationship.getChildType(), childAlias);\r\n        Query q = session.createQuery(SELECT + childAlias + FROM + parentName + SPACE + parentAlias + JOIN + parentAlias + PERIOD + relationshipName + SPACE + childAlias + joinClause + SPACE + filterClause + \" AND \" + parentAlias + \"=:\" + parentAlias + SPACE + getSortClause(sorting, relationship.getChildType(), USE_ALIAS));\r\n        supplyFilterQueryParameters(q, predicates);\r\n        return q;\r\n    }).orElse(session.createQuery(SELECT + childAlias + FROM + parentName + SPACE + parentAlias + JOIN + parentAlias + PERIOD + relationshipName + SPACE + childAlias + extractToOneMergeJoins(relationship.getChildType(), childAlias) + \" WHERE \" + parentAlias + \"=:\" + parentAlias + getSortClause(sorting, relationship.getChildType(), USE_ALIAS)));\r\n    query.setParameter(parentAlias, relationship.getParent());\r\n    addPaginationToQuery(query);\r\n    return query;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.handlers.CompletionHandlerTest.testCompletion_object",
	"Comment": "when running the test class only, completions are always returned.",
	"Method": "void testCompletion_object(){\r\n    ICompilationUnit unit = getWorkingCopy(\"src/java/Foo.java\", \"public class Foo {\\n\" + \"\tvoid foo() {\\n\" + \"\t\tObjec\\n\" + \"\t}\\n\" + \"}\\n\");\r\n    int[] loc = findCompletionLocation(unit, \"Objec\");\r\n    CompletionList list = server.completion(JsonMessageHelper.getParams(createCompletionRequest(unit, loc[0], loc[1]))).join().getRight();\r\n    assertNotNull(list);\r\n    assertFalse(\"No proposals were found\", list.getItems().isEmpty());\r\n    List<CompletionItem> items = list.getItems();\r\n    for (CompletionItem item : items) {\r\n        assertTrue(isNotBlank(item.getLabel()));\r\n        assertNotNull(item.getKind());\r\n        assertTrue(isNotBlank(item.getSortText()));\r\n        assertNull(item.getTextEdit());\r\n        assertTrue(isNotBlank(item.getInsertText()));\r\n        assertNotNull(item.getFilterText());\r\n        assertFalse(item.getFilterText().contains(\" \"));\r\n        assertTrue(item.getLabel().startsWith(item.getFilterText()));\r\n        @SuppressWarnings(\"unchecked\")\r\n        Map<String, String> data = (Map<String, String>) item.getData();\r\n        assertNotNull(data);\r\n        assertTrue(isNotBlank(data.get(CompletionResolveHandler.DATA_FIELD_URI)));\r\n        assertTrue(isNotBlank(data.get(CompletionResolveHandler.DATA_FIELD_PROPOSAL_ID)));\r\n        assertTrue(isNotBlank(data.get(CompletionResolveHandler.DATA_FIELD_REQUEST_ID)));\r\n    }\r\n}"
}, {
	"Path": "com.learn.testdifferentkeyboard.MainActivity.changeKeyboardHeight",
	"Comment": "change height of emoticons keyboard according to height of actual\tkeyboard",
	"Method": "void changeKeyboardHeight(int height){\r\n    if (height > 100) {\r\n        keyboardHeight = height;\r\n        LinearLayout.LayoutParams params = new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT, keyboardHeight);\r\n        emoticonsCover.setLayoutParams(params);\r\n    }\r\n}"
}, {
	"Path": "no.priv.garshol.duke.ConfigurationImpl.getProperties",
	"Comment": "the set of properties duke records can have, and their associatedcleaners, comparators, and probabilities.",
	"Method": "List<Property> getProperties(){\r\n    return proplist;\r\n}"
}, {
	"Path": "japa.parser.JavaParser.insertCommentsInNode",
	"Comment": "this method try to attributes the nodes received to child of the node.it returns the node that were not attributed.",
	"Method": "void insertCommentsInNode(Node node,List<Comment> commentsToAttribute){\r\n    if (commentsToAttribute.size() == 0)\r\n        return;\r\n    List<Node> children = node.getChildrenNodes();\r\n    sortByBeginPosition(children);\r\n    for (Node child : children) {\r\n        List<Comment> commentsInsideChild = new LinkedList<Comment>();\r\n        for (Comment c : commentsToAttribute) {\r\n            if (PositionUtils.nodeContains(child, c, _doNotConsiderAnnotationsAsNodeStartForCodeAttribution)) {\r\n                commentsInsideChild.add(c);\r\n            }\r\n        }\r\n        commentsToAttribute.removeAll(commentsInsideChild);\r\n        insertCommentsInNode(child, commentsInsideChild);\r\n    }\r\n    List<Comment> attributedComments = new LinkedList<Comment>();\r\n    for (Comment comment : commentsToAttribute) {\r\n        if (comment.isLineComment()) {\r\n            for (Node child : children) {\r\n                if (child.getEndLine() == comment.getBeginLine()) {\r\n                    if (attributeLineCommentToNodeOrChild(child, comment.asLineComment())) {\r\n                        attributedComments.add(comment);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Comment previousComment = null;\r\n    attributedComments = new LinkedList<Comment>();\r\n    List<Node> childrenAndComments = new LinkedList<Node>();\r\n    childrenAndComments.addAll(children);\r\n    childrenAndComments.addAll(commentsToAttribute);\r\n    sortByBeginPosition(childrenAndComments, _doNotConsiderAnnotationsAsNodeStartForCodeAttribution);\r\n    for (Node thing : childrenAndComments) {\r\n        if (thing instanceof Comment) {\r\n            previousComment = (Comment) thing;\r\n            if (!previousComment.isOrphan()) {\r\n                previousComment = null;\r\n            }\r\n        } else {\r\n            if (previousComment != null && !thing.hasComment()) {\r\n                if (!_doNotAssignCommentsPreceedingEmptyLines || !thereAreLinesBetween(previousComment, thing)) {\r\n                    thing.setComment(previousComment);\r\n                    attributedComments.add(previousComment);\r\n                    previousComment = null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    commentsToAttribute.removeAll(attributedComments);\r\n    for (Comment c : commentsToAttribute) {\r\n        if (c.isOrphan()) {\r\n            node.addOrphanComment(c);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.dom4j.io.XPPReader.createReader",
	"Comment": "factory method to create a reader from the given inputstream.",
	"Method": "Reader createReader(InputStream in){\r\n    return new BufferedReader(new InputStreamReader(in));\r\n}"
}, {
	"Path": "org.dcm4che3.net.Connection.getCommonName",
	"Comment": "an arbitrary name for the network connections object. can be a meaningfulname or any unique sequence of characters.",
	"Method": "String getCommonName(){\r\n    return commonName;\r\n}"
}, {
	"Path": "org.dom4j.io.SAXContentHandler.setIncludeExternalDTDDeclarations",
	"Comment": "sets whether dtd external declarations should be expanded into thedocumenttype object or not.",
	"Method": "void setIncludeExternalDTDDeclarations(boolean include){\r\n    this.includeExternalDTDDeclarations = include;\r\n}"
}, {
	"Path": "com.dslplatform.json.AbstractAnnotationProcessorTest.compileTestCase",
	"Comment": "attempts to compile the given compilation units using the java compiler api.\tthe compilation units and all their dependencies are expected to be on the classpath.",
	"Method": "List<Diagnostic<? extends JavaFileObject>> compileTestCase(Class<?> compilationUnits,List<Diagnostic<? extends JavaFileObject>> compileTestCase,List<String> compileArguments,Class<?> compilationUnits,List<Diagnostic<? extends JavaFileObject>> compileTestCase,String[] compilationUnitPaths,List<String> arguments,Boolean compileTestCase,String[] compilationUnitPaths,List<String> arguments,List<Diagnostic<? extends JavaFileObject>> diagnostics){\r\n    assert (compilationUnitPaths != null);\r\n    Collection<File> compilationUnits;\r\n    try {\r\n        compilationUnits = findClasspathFiles(compilationUnitPaths);\r\n    } catch (IOException exception) {\r\n        throw new IllegalArgumentException(\"Unable to resolve compilation units \" + Arrays.toString(compilationUnitPaths) + \" due to: \" + exception.getMessage(), exception);\r\n    }\r\n    DiagnosticCollector<JavaFileObject> diagnosticCollector = new DiagnosticCollector<JavaFileObject>();\r\n    StandardJavaFileManager fileManager = COMPILER.getStandardFileManager(diagnosticCollector, null, null);\r\n    ArrayList<String> compileArgs = new ArrayList<String>();\r\n    compileArgs.add(\"-proc:only\");\r\n    compileArgs.add(\"-implicit:class\");\r\n    compileArgs.addAll(arguments);\r\n    CompilationTask task = COMPILER.getTask(null, fileManager, diagnosticCollector, compileArgs, null, fileManager.getJavaFileObjectsFromFiles(compilationUnits));\r\n    task.setProcessors(getProcessors());\r\n    Boolean compilationSuccessful = task.call();\r\n    try {\r\n        fileManager.close();\r\n    } catch (IOException ignore) {\r\n    }\r\n    diagnostics.addAll(diagnosticCollector.getDiagnostics());\r\n    return compilationSuccessful;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.databases.KeyValueDatabase.isInMemory",
	"Comment": "returns true iff the database is held entirely in memory, andthus is not persistent.",
	"Method": "boolean isInMemory(){\r\n    return store.isInMemory();\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.reorg.CreateTargetExecutionLog.markAsCreated",
	"Comment": "logs that the given element got created by the refactoring.",
	"Method": "void markAsCreated(Object selection,Object element){\r\n    fCreations.put(selection, element);\r\n}"
}, {
	"Path": "org.dom4j.dtd.ExternalEntityDeclTest.testPublicIdSystemId",
	"Comment": "tests external entity declaration using both system and publicidentifiers.",
	"Method": "void testPublicIdSystemId(){\r\n    String expectedName = \"anEntity\";\r\n    String expectedPublicID = \"-//dom4j//DTD sample\";\r\n    String expectedSystemID = \"http://www.myorg.org/foo\";\r\n    String expectedText = \"<!ENTITY anEntity \" + \"PUBLIC \\\"-//dom4j//DTD sample\\\" \" + \"\\\"http://www.myorg.org/foo\\\" >\";\r\n    ExternalEntityDecl actual = new ExternalEntityDecl(expectedName, expectedPublicID, expectedSystemID);\r\n    assertEquals(\"name is correct\", expectedName, actual.getName());\r\n    assertEquals(\"publicID is correct\", expectedPublicID, actual.getPublicID());\r\n    assertEquals(\"systemID is correct\", expectedSystemID, actual.getSystemID());\r\n    assertEquals(\"toString() is correct\", expectedText, actual.toString());\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource.getUsername",
	"Comment": "return the jdbc username to use for connecting through the driver.",
	"Method": "String getUsername(){\r\n    return this.username;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.util.TextChangeManager.containsChangesIn",
	"Comment": "returns if any text changes are managed for the specified compilation unit.",
	"Method": "boolean containsChangesIn(ICompilationUnit cu){\r\n    return fMap.containsKey(cu);\r\n}"
}, {
	"Path": "org.dom4j.jaxb.JAXBReader.addHandler",
	"Comment": "adds the elementhandler to be called when the specifiedpath is encounted.",
	"Method": "void addHandler(String path,ElementHandler handler){\r\n    getReader().addHandler(path, handler);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.util.TextChangeManager.manage",
	"Comment": "adds an association between the given compilation unit and the passed change\tto this manager.",
	"Method": "void manage(ICompilationUnit cu,TextChange change){\r\n    fMap.put(cu, change);\r\n}"
}, {
	"Path": "japa.parser.ast.Node.getData",
	"Comment": "use this to retrieve additional information associated to this node.",
	"Method": "Object getData(){\r\n    return data;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.EntityDictionary.getAccessType",
	"Comment": "returns whether the entire entity uses field or property level access.",
	"Method": "AccessType getAccessType(Class<?> entityClass){\r\n    return getEntityBinding(entityClass).getAccessType();\r\n}"
}, {
	"Path": "com.yahoo.elide.standalone.config.ElideStandaloneSettings.getGraphQLApiPathSepc",
	"Comment": "api root path specification for the graphql endpoint. namely, this is the root uri for graphql.",
	"Method": "String getGraphQLApiPathSepc(){\r\n    return \"/graphql/api/v1\";\r\n}"
}, {
	"Path": "no.priv.garshol.duke.comparators.JaroWinkler.similarity",
	"Comment": "returns normalized score, with 0.0 meaning no similarity at all,and 1.0 meaning full equality.",
	"Method": "double similarity(String s1,String s2){\r\n    if (s1.equals(s2))\r\n        return 1.0;\r\n    if (s1.length() > s2.length()) {\r\n        String tmp = s2;\r\n        s2 = s1;\r\n        s1 = tmp;\r\n    }\r\n    boolean[] isCommonCharInS2 = new boolean[s2.length()];\r\n    int maxdist = s2.length() / 2;\r\n    int c = 0;\r\n    int t = 0;\r\n    int prevpos = -1;\r\n    for (int ix = 0; ix < s1.length(); ix++) {\r\n        char ch = s1.charAt(ix);\r\n        for (int ix2 = Math.max(0, ix - maxdist); ix2 < Math.min(s2.length(), ix + maxdist); ix2++) {\r\n            if (ch == s2.charAt(ix2) && !isCommonCharInS2[ix2]) {\r\n                c++;\r\n                isCommonCharInS2[ix2] = true;\r\n                if (prevpos != -1 && ix2 < prevpos)\r\n                    t++;\r\n                prevpos = ix2;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (c == 0)\r\n        return 0.0;\r\n    double score = ((c / (double) s1.length()) + (c / (double) s2.length()) + ((c - t) / (double) c)) / 3.0;\r\n    int p = 0;\r\n    int last = Math.min(4, s1.length());\r\n    for (; p < last && s1.charAt(p) == s2.charAt(p); p++) ;\r\n    score = score + ((p * (1 - score)) / 10);\r\n    return score;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.reorg.CreateTargetExecutionLog.getCreatedElement",
	"Comment": "returns the element which got created for the given selection.",
	"Method": "Object getCreatedElement(Object selection){\r\n    return fCreations.get(selection);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.participants.ResourceModifications.addCopy",
	"Comment": "adds the given resource to the list of resources\tto be copied.",
	"Method": "void addCopy(IResource copy,CopyArguments arguments){\r\n    if (fCopy == null) {\r\n        fCopy = new ArrayList(2);\r\n        fCopyArguments = new ArrayList(2);\r\n    }\r\n    fCopy.add(copy);\r\n    fCopyArguments.add(arguments);\r\n    addCopyDelta(copy, arguments);\r\n}"
}, {
	"Path": "sx.blah.discord.handle.audit.AuditLog.getDiscordObjectEntries",
	"Comment": "gets the entries of the log which have a target which is of the given type.",
	"Method": "Collection<DiscordObjectEntry<?>> getDiscordObjectEntries(Collection<DiscordObjectEntry<T>> getDiscordObjectEntries,Class<T> clazz){\r\n    return getDiscordObjectEntries().stream().filter(entry -> clazz.isAssignableFrom(entry.getTarget().getClass())).map(entry -> (DiscordObjectEntry<T>) entry).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.init.ScriptUtils.containsSqlScriptDelimiters",
	"Comment": "does the provided sql script contain the specified delimiter?",
	"Method": "boolean containsSqlScriptDelimiters(String script,String delim){\r\n    boolean inLiteral = false;\r\n    char[] content = script.toCharArray();\r\n    for (int i = 0; i < script.length(); i++) {\r\n        if (content[i] == '\\'') {\r\n            inLiteral = !inLiteral;\r\n        }\r\n        if (!inLiteral && script.startsWith(delim, i)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.JavaClientConnection.showNotificationMessageRequest",
	"Comment": "sends the message to the client, to be displayed on a ui element.\twaits for an answer from the user and returns the selected\taction.",
	"Method": "MessageActionItem showNotificationMessageRequest(MessageType type,String msg,List<MessageActionItem> actions){\r\n    ShowMessageRequestParams $ = new ShowMessageRequestParams();\r\n    $.setMessage(msg);\r\n    $.setType(type);\r\n    $.setActions(actions);\r\n    return client.showMessageRequest($).join();\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.code.flow.FlowInfo.hasAccessMode",
	"Comment": "checks whether the given local variable binding has the given access\tmode.",
	"Method": "boolean hasAccessMode(FlowContext context,IVariableBinding local,int mode){\r\n    boolean unusedMode = (mode & UNUSED) != 0;\r\n    if (fAccessModes == null && unusedMode) {\r\n        return true;\r\n    }\r\n    int index = context.getIndexFromLocal(local);\r\n    if (index == -1) {\r\n        return unusedMode;\r\n    }\r\n    return (fAccessModes[index] & mode) != 0;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource.getUrl",
	"Comment": "return the jdbc url to use for connecting through the driver.",
	"Method": "String getUrl(){\r\n    return this.url;\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.createCustomException",
	"Comment": "create a custom dataaccessexception, based on a given exception\tclass from a customsqlerrorcodestranslation definition.",
	"Method": "DataAccessException createCustomException(String task,String sql,SQLException sqlEx,Class<?> exceptionClass){\r\n    try {\r\n        int constructorType = 0;\r\n        Constructor<?>[] constructors = exceptionClass.getConstructors();\r\n        for (Constructor<?> constructor : constructors) {\r\n            Class<?>[] parameterTypes = constructor.getParameterTypes();\r\n            if (parameterTypes.length == 1 && parameterTypes[0].equals(String.class)) {\r\n                if (constructorType < MESSAGE_ONLY_CONSTRUCTOR)\r\n                    constructorType = MESSAGE_ONLY_CONSTRUCTOR;\r\n            }\r\n            if (parameterTypes.length == 2 && parameterTypes[0].equals(String.class) && parameterTypes[1].equals(Throwable.class)) {\r\n                if (constructorType < MESSAGE_THROWABLE_CONSTRUCTOR)\r\n                    constructorType = MESSAGE_THROWABLE_CONSTRUCTOR;\r\n            }\r\n            if (parameterTypes.length == 2 && parameterTypes[0].equals(String.class) && parameterTypes[1].equals(SQLException.class)) {\r\n                if (constructorType < MESSAGE_SQLEX_CONSTRUCTOR)\r\n                    constructorType = MESSAGE_SQLEX_CONSTRUCTOR;\r\n            }\r\n            if (parameterTypes.length == 3 && parameterTypes[0].equals(String.class) && parameterTypes[1].equals(String.class) && parameterTypes[2].equals(Throwable.class)) {\r\n                if (constructorType < MESSAGE_SQL_THROWABLE_CONSTRUCTOR)\r\n                    constructorType = MESSAGE_SQL_THROWABLE_CONSTRUCTOR;\r\n            }\r\n            if (parameterTypes.length == 3 && parameterTypes[0].equals(String.class) && parameterTypes[1].equals(String.class) && parameterTypes[2].equals(SQLException.class)) {\r\n                if (constructorType < MESSAGE_SQL_SQLEX_CONSTRUCTOR)\r\n                    constructorType = MESSAGE_SQL_SQLEX_CONSTRUCTOR;\r\n            }\r\n        }\r\n        Constructor<?> exceptionConstructor;\r\n        switch(constructorType) {\r\n            case MESSAGE_SQL_SQLEX_CONSTRUCTOR:\r\n                Class<?>[] messageAndSqlAndSqlExArgsClass = new Class<?>[] { String.class, String.class, SQLException.class };\r\n                Object[] messageAndSqlAndSqlExArgs = new Object[] { task, sql, sqlEx };\r\n                exceptionConstructor = exceptionClass.getConstructor(messageAndSqlAndSqlExArgsClass);\r\n                return (DataAccessException) exceptionConstructor.newInstance(messageAndSqlAndSqlExArgs);\r\n            case MESSAGE_SQL_THROWABLE_CONSTRUCTOR:\r\n                Class<?>[] messageAndSqlAndThrowableArgsClass = new Class<?>[] { String.class, String.class, Throwable.class };\r\n                Object[] messageAndSqlAndThrowableArgs = new Object[] { task, sql, sqlEx };\r\n                exceptionConstructor = exceptionClass.getConstructor(messageAndSqlAndThrowableArgsClass);\r\n                return (DataAccessException) exceptionConstructor.newInstance(messageAndSqlAndThrowableArgs);\r\n            case MESSAGE_SQLEX_CONSTRUCTOR:\r\n                Class<?>[] messageAndSqlExArgsClass = new Class<?>[] { String.class, SQLException.class };\r\n                Object[] messageAndSqlExArgs = new Object[] { task + \": \" + sqlEx.getMessage(), sqlEx };\r\n                exceptionConstructor = exceptionClass.getConstructor(messageAndSqlExArgsClass);\r\n                return (DataAccessException) exceptionConstructor.newInstance(messageAndSqlExArgs);\r\n            case MESSAGE_THROWABLE_CONSTRUCTOR:\r\n                Class<?>[] messageAndThrowableArgsClass = new Class<?>[] { String.class, Throwable.class };\r\n                Object[] messageAndThrowableArgs = new Object[] { task + \": \" + sqlEx.getMessage(), sqlEx };\r\n                exceptionConstructor = exceptionClass.getConstructor(messageAndThrowableArgsClass);\r\n                return (DataAccessException) exceptionConstructor.newInstance(messageAndThrowableArgs);\r\n            case MESSAGE_ONLY_CONSTRUCTOR:\r\n                Class<?>[] messageOnlyArgsClass = new Class<?>[] { String.class };\r\n                Object[] messageOnlyArgs = new Object[] { task + \": \" + sqlEx.getMessage() };\r\n                exceptionConstructor = exceptionClass.getConstructor(messageOnlyArgsClass);\r\n                return (DataAccessException) exceptionConstructor.newInstance(messageOnlyArgs);\r\n            default:\r\n                if (logger.isWarnEnabled()) {\r\n                    logger.warn(\"Unable to find appropriate constructor of custom exception class [\" + exceptionClass.getName() + \"]\");\r\n                }\r\n                return null;\r\n        }\r\n    } catch (Throwable ex) {\r\n        if (logger.isWarnEnabled()) {\r\n            logger.warn(\"Unable to instantiate custom exception class [\" + exceptionClass.getName() + \"]\", ex);\r\n        }\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.util.TextChangeManager.containsChangesIn",
	"Comment": "returns if any text changes are managed for the specified compilation unit.",
	"Method": "boolean containsChangesIn(ICompilationUnit cu){\r\n    return fMap.containsKey(cu);\r\n}"
}, {
	"Path": "japa.parser.ASTHelper.addArgument",
	"Comment": "adds the given argument to the method call. the list of arguments will beinitialized if it is null.",
	"Method": "void addArgument(MethodCallExpr call,Expression arg){\r\n    List<Expression> args = call.getArgs();\r\n    if (args == null) {\r\n        args = new ArrayList<Expression>();\r\n        call.setArgs(args);\r\n    }\r\n    args.add(arg);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.CallMetaDataContext.isAccessCallParameterMetaData",
	"Comment": "check whether call parameter metadata should be accessed.",
	"Method": "boolean isAccessCallParameterMetaData(){\r\n    return this.accessCallParameterMetaData;\r\n}"
}, {
	"Path": "sx.blah.discord.util.MissingPermissionsException.getMessage",
	"Comment": "gets the error message with the missing permissions as a string.",
	"Method": "String getMessage(EnumSet<Permissions> permissions){\r\n    StringJoiner joiner = new StringJoiner(\", \");\r\n    permissions.stream().map(Enum::name).forEach(joiner::add);\r\n    return \"Missing permissions: \" + joiner.toString() + \"!\";\r\n}"
}, {
	"Path": "org.dcm4che3.net.ApplicationEntity.getDevice",
	"Comment": "get the device that is identified by this application entity.",
	"Method": "Device getDevice(){\r\n    return device;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.nls.NLSElement.getTagPosition",
	"Comment": "returns the tag position for this element. the method can return null. in this\tcase no tag has been found for this nls element.",
	"Method": "Region getTagPosition(){\r\n    return fTagPosition;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.DataSourceUtils.connectionEquals",
	"Comment": "determine whether the given two connections are equal, asking the target\tconnection in case of a proxy. used to detect equality even if the\tuser passed in a raw target connection while the held one is a proxy.",
	"Method": "boolean connectionEquals(ConnectionHolder conHolder,Connection passedInCon){\r\n    if (!conHolder.hasConnection()) {\r\n        return false;\r\n    }\r\n    Connection heldCon = conHolder.getConnection();\r\n    return (heldCon == passedInCon || heldCon.equals(passedInCon) || getTargetConnection(heldCon).equals(passedInCon));\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.code.ExtractMethodRefactoring.getMethodName",
	"Comment": "returns the method name to be used for the extracted method.",
	"Method": "String getMethodName(){\r\n    return fMethodName;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.PersistentResource.addToCollection",
	"Comment": "adds a new element to a collection and tests update permission.",
	"Method": "boolean addToCollection(Collection collection,String collectionName,PersistentResource toAdd){\r\n    final Collection singleton = Collections.singleton(toAdd.getObject());\r\n    final Collection original = copyCollection(collection);\r\n    checkFieldAwareDeferPermissions(UpdatePermission.class, collectionName, CollectionUtils.union(CollectionUtils.emptyIfNull(collection), singleton), original);\r\n    if (collection == null) {\r\n        collection = Collections.singleton(toAdd.getObject());\r\n        Object value = getValueUnchecked(collectionName);\r\n        if (!Objects.equals(value, toAdd.getObject())) {\r\n            this.setValueChecked(collectionName, collection);\r\n            return true;\r\n        }\r\n    } else {\r\n        if (!collection.contains(toAdd.getObject())) {\r\n            collection.add(toAdd.getObject());\r\n            auditField(new ChangeSpec(this, collectionName, original, collection));\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.InMemoryClassDatabase.merge",
	"Comment": "merges the two classes into a single class. the smaller class isremoved, while the largest class is kept.",
	"Method": "void merge(Integer cid1,Integer cid2){\r\n    Collection<String> klass1 = classix.get(cid1);\r\n    Collection<String> klass2 = classix.get(cid2);\r\n    if (klass1.size() < klass2.size()) {\r\n        Collection<String> tmp = klass2;\r\n        klass2 = klass1;\r\n        klass1 = tmp;\r\n        Integer itmp = cid2;\r\n        cid2 = cid1;\r\n        cid1 = itmp;\r\n    }\r\n    for (String id : klass2) {\r\n        klass1.add(id);\r\n        recordix.put(id, cid1);\r\n    }\r\n    classix.remove(cid2);\r\n}"
}, {
	"Path": "org.dcm4che3.net.ApplicationEntity.setVendorData",
	"Comment": "set any vendor information or configuration specific to this network ae",
	"Method": "void setVendorData(byte[] vendorData){\r\n    this.vendorData = vendorData;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.JdbcTransactionObjectSupport.createSavepoint",
	"Comment": "this implementation creates a jdbc 3.0 savepoint and returns it.",
	"Method": "Object createSavepoint(){\r\n    ConnectionHolder conHolder = getConnectionHolderForSavepoint();\r\n    try {\r\n        if (!conHolder.supportsSavepoints()) {\r\n            throw new NestedTransactionNotSupportedException(\"Cannot create a nested transaction because savepoints are not supported by your JDBC driver\");\r\n        }\r\n        return conHolder.createSavepoint();\r\n    } catch (SQLException ex) {\r\n        throw new CannotCreateTransactionException(\"Could not create JDBC savepoint\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.StoredProcedure.execute",
	"Comment": "execute the stored procedure with the provided parameter values. this is\ta convenience method where the order of the passed in parameter values\tmust match the order that the parameters where declared in.",
	"Method": "Map<String, Object> execute(Object inParams,Map<String, Object> execute,Map<String, ?> inParams,Map<String, Object> execute,ParameterMapper inParamMapper){\r\n    checkCompiled();\r\n    return getJdbcTemplate().call(newCallableStatementCreator(inParamMapper), getDeclaredParameters());\r\n}"
}, {
	"Path": "com.github.devnied.emvnfccard.parser.EmvParser.readWithPSE",
	"Comment": "read emv card with payment system environment or proximity payment system\tenvironment",
	"Method": "boolean readWithPSE(){\r\n    boolean ret = false;\r\n    if (LOGGER.isDebugEnabled()) {\r\n        LOGGER.debug(\"Try to read card with Payment System Environment\");\r\n    }\r\n    byte[] data = selectPaymentEnvironment();\r\n    if (ResponseUtils.isSucceed(data)) {\r\n        data = parseFCIProprietaryTemplate(data);\r\n        if (ResponseUtils.isSucceed(data)) {\r\n            List<byte[]> aids = getAids(data);\r\n            for (byte[] aid : aids) {\r\n                ret = extractPublicData(aid, extractApplicationLabel(data));\r\n                if (ret == true) {\r\n                    break;\r\n                }\r\n            }\r\n            if (!ret) {\r\n                card.setNfcLocked(true);\r\n            }\r\n        }\r\n    } else if (LOGGER.isDebugEnabled()) {\r\n        LOGGER.debug((contactLess ? \"PPSE\" : \"PSE\") + \" not found -> Use kown AID\");\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.dom4j.tree.NamespaceStack.createQName",
	"Comment": "factory method to creeate new qname instances. by default this methodinterns the qname",
	"Method": "QName createQName(String localName,String qualifiedName,Namespace namespace){\r\n    return documentFactory.createQName(localName, namespace);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.ParameterInfo.createInfoForAddedParameter",
	"Comment": "creates a new parameterinfo. parameter is marked as added and not\tresolvable",
	"Method": "ParameterInfo createInfoForAddedParameter(String type,String name,ParameterInfo createInfoForAddedParameter,String type,String name,String defaultValue,ParameterInfo createInfoForAddedParameter,ITypeBinding typeBinding,String type,String name,String defaultValue){\r\n    ParameterInfo info = new ParameterInfo(null, typeBinding, \"\", \"\", INDEX_FOR_ADDED);\r\n    info.setNewTypeName(type);\r\n    info.setNewName(name);\r\n    info.setDefaultValue(defaultValue);\r\n    return info;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcDaoSupport.initTemplateConfig",
	"Comment": "create a namedparameterjdbctemplate based on the configured jdbctemplate.",
	"Method": "void initTemplateConfig(){\r\n    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(getJdbcTemplate());\r\n}"
}, {
	"Path": "denominator.DNSApiManager.close",
	"Comment": "closes resources associated with the connections, such as thread pools or open files.",
	"Method": "void close(){\r\n    closer.close();\r\n}"
}, {
	"Path": "com.github.devnied.emvnfccard.parser.apdu.annotation.AnnotationUtils.extractAnnotation",
	"Comment": "method to extract all annotation information and store them in the map",
	"Method": "void extractAnnotation(){\r\n    for (Class<? extends IFile> clazz : LISTE_CLASS) {\r\n        Map<ITag, AnnotationData> maps = new HashMap<ITag, AnnotationData>();\r\n        Set<AnnotationData> set = new TreeSet<AnnotationData>();\r\n        Field[] fields = clazz.getDeclaredFields();\r\n        for (Field field : fields) {\r\n            AnnotationData param = new AnnotationData();\r\n            field.setAccessible(true);\r\n            param.setField(field);\r\n            Data annotation = field.getAnnotation(Data.class);\r\n            if (annotation != null) {\r\n                param.initFromAnnotation(annotation);\r\n                maps.put(param.getTag(), param);\r\n                try {\r\n                    set.add((AnnotationData) param.clone());\r\n                } catch (CloneNotSupportedException e) {\r\n                }\r\n            }\r\n        }\r\n        mapSet.put(clazz.getName(), set);\r\n        map.put(clazz.getName(), maps);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.nls.NLSUtil.createNLSEdits",
	"Comment": "creates and returns nls tag edits for strings that are at the specified positions in a\tcompilation unit.",
	"Method": "TextEdit[] createNLSEdits(ICompilationUnit cu,int[] positions){\r\n    List<InsertEdit> result = new ArrayList();\r\n    try {\r\n        NLSLine[] allLines = NLSScanner.scan(cu);\r\n        for (int i = 0; i < allLines.length; i++) {\r\n            NLSLine line = allLines[i];\r\n            NLSElement[] elements = line.getElements();\r\n            for (int j = 0; j < elements.length; j++) {\r\n                NLSElement element = elements[j];\r\n                if (!element.hasTag()) {\r\n                    for (int k = 0; k < positions.length; k++) {\r\n                        if (isPositionInElement(element, positions[k])) {\r\n                            int editOffset;\r\n                            if (j == 0) {\r\n                                if (elements.length > j + 1) {\r\n                                    editOffset = elements[j + 1].getTagPosition().getOffset();\r\n                                } else {\r\n                                    editOffset = findLineEnd(cu, element.getPosition().getOffset());\r\n                                }\r\n                            } else {\r\n                                Region previousPosition = elements[j - 1].getTagPosition();\r\n                                editOffset = previousPosition.getOffset() + previousPosition.getLength();\r\n                            }\r\n                            String editText = ' ' + // tags are 1-based\r\n                            NLSElement.createTagText(j + 1);\r\n                            result.add(new InsertEdit(editOffset, editText));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch (InvalidInputException e) {\r\n        return null;\r\n    } catch (BadLocationException e) {\r\n        return null;\r\n    }\r\n    if (result.isEmpty()) {\r\n        return null;\r\n    }\r\n    return result.toArray(new TextEdit[result.size()]);\r\n}"
}, {
	"Path": "org.dom4j.io.OutputFormat.createPrettyPrint",
	"Comment": "a static helper method to create the default pretty printing format. thisformat consists of an indent of 2 spaces, newlines after each element andall other whitespace trimmed, and xmtml is false.",
	"Method": "OutputFormat createPrettyPrint(){\r\n    OutputFormat format = new OutputFormat();\r\n    format.setIndentSize(2);\r\n    format.setNewlines(true);\r\n    format.setTrimText(true);\r\n    format.setPadText(true);\r\n    return format;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource.setUsername",
	"Comment": "set the jdbc username to use for connecting through the driver.",
	"Method": "void setUsername(String username){\r\n    this.username = username;\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.SqlFunction.setResultType",
	"Comment": "specify the type that the result object is required to match.\tif not specified, the result value will be exposed as\treturned by the jdbc driver.",
	"Method": "void setResultType(Class<T> resultType){\r\n    this.rowMapper.setRequiredType(resultType);\r\n}"
}, {
	"Path": "denominator.CredentialsConfiguration.anonymous",
	"Comment": "used to set a base case where no credentials are available or needed.",
	"Method": "Object anonymous(){\r\n    return credentials(AnonymousCredentials.INSTANCE);\r\n}"
}, {
	"Path": "org.dcm4che3.imageio.plugins.dcm.DicomImageReader.initPixelDataIIS",
	"Comment": "initializes the pixel data reading from an image input stream",
	"Method": "void initPixelDataIIS(DicomInputStream dis){\r\n    if (pixelDataLength == 0)\r\n        return;\r\n    if (pixelDataLength > 0) {\r\n        pixelData = new BulkData(\"pixeldata://\", dis.getPosition(), dis.length(), dis.bigEndian());\r\n        metadata.getAttributes().setValue(Tag.PixelData, pixelDataVR, pixelData);\r\n        return;\r\n    }\r\n    dis.readItemHeader();\r\n    byte[] b = new byte[dis.length()];\r\n    dis.readFully(b);\r\n    long start = dis.getPosition();\r\n    pixelDataFragments = new Fragments(pixelDataVR, dis.bigEndian(), frames);\r\n    pixelDataFragments.add(b);\r\n    generateOffsetLengths(pixelDataFragments, frames, b, start);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.fix.PotentialProgrammingProblemsFix.getDeclarationNode",
	"Comment": "returns the declaration node for the originally selected node.",
	"Method": "ASTNode getDeclarationNode(SimpleName name){\r\n    ASTNode parent = name.getParent();\r\n    if (!(parent instanceof AbstractTypeDeclaration)) {\r\n        parent = parent.getParent();\r\n        if (parent instanceof ParameterizedType || parent instanceof Type) {\r\n            parent = parent.getParent();\r\n        }\r\n        if (parent instanceof ClassInstanceCreation) {\r\n            final ClassInstanceCreation creation = (ClassInstanceCreation) parent;\r\n            parent = creation.getAnonymousClassDeclaration();\r\n        }\r\n    }\r\n    return parent;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.RefactoringScopeFactory.create",
	"Comment": "creates a new search scope with all compilation units possibly referencing\tjavaelement.",
	"Method": "IJavaSearchScope create(IJavaElement javaElement,IJavaSearchScope create,IJavaElement javaElement,boolean considerVisibility,IJavaSearchScope create,IJavaElement javaElement,boolean considerVisibility,boolean sourceReferencesOnly,IJavaSearchScope create,IMember[] members,IJavaSearchScope create,IMember[] members,boolean sourceReferencesOnly){\r\n    Assert.isTrue(members != null && members.length > 0);\r\n    IMember candidate = members[0];\r\n    int visibility = getVisibility(candidate);\r\n    for (int i = 1; i < members.length; i++) {\r\n        int mv = getVisibility(members[i]);\r\n        if (mv > visibility) {\r\n            visibility = mv;\r\n            candidate = members[i];\r\n        }\r\n    }\r\n    return create(candidate, true, sourceReferencesOnly);\r\n}"
}, {
	"Path": "org.dom4j.io.ElementStack.peekElement",
	"Comment": "peeks at the top element on the stack without changing the contents ofthe stack.",
	"Method": "Element peekElement(){\r\n    if (lastElementIndex < 0) {\r\n        return null;\r\n    }\r\n    return stack[lastElementIndex];\r\n}"
}, {
	"Path": "org.dom4j.io.SAXContentHandler.addExternalDTDDeclaration",
	"Comment": "adds an external dtd declaration to the list of declarations",
	"Method": "void addExternalDTDDeclaration(Decl declaration){\r\n    if (externalDTDDeclarations == null) {\r\n        externalDTDDeclarations = new ArrayList<Decl>();\r\n    }\r\n    externalDTDDeclarations.add(declaration);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.PreparedStatementCreatorFactory.setResultSetType",
	"Comment": "set whether to use prepared statements that return a specific type of resultset.",
	"Method": "void setResultSetType(int resultSetType){\r\n    this.resultSetType = resultSetType;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.rename.RenameTypeParameterProcessor.createRenameChanges",
	"Comment": "creates the necessary changes for the renaming of the type parameter.",
	"Method": "RefactoringStatus createRenameChanges(IProgressMonitor monitor){\r\n    Assert.isNotNull(monitor);\r\n    RefactoringStatus status = new RefactoringStatus();\r\n    try {\r\n        monitor.beginTask(RefactoringCoreMessages.RenameTypeParameterRefactoring_searching, 2);\r\n        ICompilationUnit cu = fTypeParameter.getDeclaringMember().getCompilationUnit();\r\n        CompilationUnit root = RefactoringASTParser.parseWithASTProvider(cu, true, null);\r\n        CompilationUnitRewrite rewrite = new CompilationUnitRewrite(cu, root);\r\n        IMember member = fTypeParameter.getDeclaringMember();\r\n        ASTNode declaration = null;\r\n        if (member instanceof IMethod) {\r\n            declaration = ASTNodeSearchUtil.getMethodDeclarationNode((IMethod) member, root);\r\n        } else if (member instanceof IType) {\r\n            declaration = ASTNodeSearchUtil.getAbstractTypeDeclarationNode((IType) member, root);\r\n        } else {\r\n            // $NON-NLS-1$\r\n            JavaLanguageServerPlugin.logError(\"Unexpected sub-type of IMember: \" + member.getClass().getName());\r\n            Assert.isTrue(false);\r\n        }\r\n        monitor.worked(1);\r\n        RenameTypeParameterVisitor visitor = new RenameTypeParameterVisitor(rewrite, fTypeParameter.getNameRange(), status);\r\n        if (declaration != null) {\r\n            declaration.accept(visitor);\r\n        }\r\n        fChange = visitor.getResult();\r\n    } finally {\r\n        monitor.done();\r\n    }\r\n    return status;\r\n}"
}, {
	"Path": "effectivejava.chapter5.item31.Union.main",
	"Comment": "simple program to exercise flexible generic staticfactory",
	"Method": "void main(String[] args){\r\n    Set<Integer> integers = new HashSet();\r\n    integers.add(1);\r\n    integers.add(3);\r\n    integers.add(5);\r\n    Set<Double> doubles = new HashSet();\r\n    doubles.add(2.0);\r\n    doubles.add(4.0);\r\n    doubles.add(6.0);\r\n    Set<Number> numbers = union(integers, doubles);\r\n    System.out.println(numbers);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.namedparam.ParsedSql.getUnnamedParameterCount",
	"Comment": "return the count of all of the unnamed parameters in the sql statement.",
	"Method": "int getUnnamedParameterCount(){\r\n    return this.unnamedParameterCount;\r\n}"
}, {
	"Path": "org.dom4j.io.XMLWriter.writeElementContent",
	"Comment": "outputs the content of the given element. if whitespace trimming isenabled then all adjacent text nodes are appended together before thewhitespace trimming occurs to avoid problems with multiple text nodesbeing created due to text content that spans parser buffers in a saxparser.",
	"Method": "void writeElementContent(Element element){\r\n    boolean trim = format.isTrimText();\r\n    boolean oldPreserve = preserve;\r\n    if (trim) {\r\n        preserve = isElementSpacePreserved(element);\r\n        trim = !preserve;\r\n    }\r\n    if (trim) {\r\n        Text lastTextNode = null;\r\n        StringBuilder buff = null;\r\n        boolean textOnly = true;\r\n        for (Node node : element.content()) {\r\n            if (node instanceof Text) {\r\n                if (lastTextNode == null) {\r\n                    lastTextNode = (Text) node;\r\n                } else {\r\n                    if (buff == null) {\r\n                        buff = new StringBuilder(lastTextNode.getText());\r\n                    }\r\n                    buff.append((node).getText());\r\n                }\r\n            } else {\r\n                if (!textOnly && format.isPadText()) {\r\n                    final boolean startsWithWhitespace;\r\n                    if (buff != null) {\r\n                        startsWithWhitespace = startsWithWhitespace(buff);\r\n                    } else if (lastTextNode != null) {\r\n                        startsWithWhitespace = startsWithWhitespace(lastTextNode.getText());\r\n                    } else {\r\n                        startsWithWhitespace = false;\r\n                    }\r\n                    if (startsWithWhitespace) {\r\n                        writer.write(PAD_TEXT);\r\n                    }\r\n                }\r\n                if (lastTextNode != null) {\r\n                    if (buff != null) {\r\n                        writeString(buff.toString());\r\n                        buff = null;\r\n                    } else {\r\n                        writeString(lastTextNode.getText());\r\n                    }\r\n                    if (format.isPadText()) {\r\n                        final boolean endsWithWhitespace;\r\n                        if (buff != null) {\r\n                            endsWithWhitespace = endsWithWhitespace(buff);\r\n                        } else {\r\n                            endsWithWhitespace = endsWithWhitespace(lastTextNode.getText());\r\n                        }\r\n                        if (endsWithWhitespace) {\r\n                            writer.write(PAD_TEXT);\r\n                        }\r\n                    }\r\n                    lastTextNode = null;\r\n                }\r\n                textOnly = false;\r\n                writeNode(node);\r\n            }\r\n        }\r\n        if (lastTextNode != null) {\r\n            if (!textOnly && format.isPadText()) {\r\n                final boolean startsWithWhitespace;\r\n                if (buff != null) {\r\n                    startsWithWhitespace = startsWithWhitespace(buff);\r\n                } else {\r\n                    startsWithWhitespace = startsWithWhitespace(lastTextNode.getText());\r\n                }\r\n                if (startsWithWhitespace) {\r\n                    writer.write(PAD_TEXT);\r\n                }\r\n            }\r\n            if (buff != null) {\r\n                writeString(buff.toString());\r\n                buff = null;\r\n            } else {\r\n                writeString(lastTextNode.getText());\r\n            }\r\n            lastTextNode = null;\r\n        }\r\n    } else {\r\n        Node lastTextNode = null;\r\n        for (Node node : element.content()) {\r\n            if (node instanceof Text) {\r\n                writeNode(node);\r\n                lastTextNode = node;\r\n            } else {\r\n                if ((lastTextNode != null) && format.isPadText()) {\r\n                    if (endsWithWhitespace(lastTextNode.getText())) {\r\n                        writer.write(PAD_TEXT);\r\n                    }\r\n                }\r\n                writeNode(node);\r\n                lastTextNode = null;\r\n            }\r\n        }\r\n    }\r\n    preserve = oldPreserve;\r\n}"
}, {
	"Path": "org.dom4j.bean.BeanMetaData.get",
	"Comment": "static helper method to find and cache meta data objects for bean types",
	"Method": "BeanMetaData get(Class<?> beanClass){\r\n    BeanMetaData answer = singletonCache.get(beanClass);\r\n    if (answer == null) {\r\n        answer = new BeanMetaData(beanClass);\r\n        singletonCache.put(beanClass, answer);\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.sort.Sorting.parseQueryParams",
	"Comment": "given the query params on the get request, collect possible sorting rules.",
	"Method": "Sorting parseQueryParams(MultivaluedMap<String, String> queryParams){\r\n    List<String> sortRules = queryParams.entrySet().stream().filter(entry -> entry.getKey().equals(\"sort\")).map(entry -> entry.getValue().get(0)).collect(Collectors.toList());\r\n    return parseSortRules(sortRules);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.handlers.BundleUtils.loadBundles",
	"Comment": "load a collection of bundle based on the provided file path locations.",
	"Method": "void loadBundles(Collection<String> bundleLocations){\r\n    if (bundleLocations == null || bundleLocations.isEmpty()) {\r\n        return;\r\n    }\r\n    BundleContext context = JavaLanguageServerPlugin.getBundleContext();\r\n    MultiStatus status = new MultiStatus(context.getBundle().getSymbolicName(), IStatus.OK, \"Load bundle list\", null);\r\n    Collection<Bundle> bundlesToStart = new ArrayList();\r\n    for (String bundleLocation : bundleLocations) {\r\n        try {\r\n            if (StringUtils.isEmpty(bundleLocation)) {\r\n                JavaLanguageServerPlugin.logError(\"Empty bundle location\");\r\n                continue;\r\n            }\r\n            String location = getBundleLocation(bundleLocation, true);\r\n            BundleInfo bundleInfo = getBundleInfo(bundleLocation);\r\n            if (bundleInfo == null) {\r\n                status.add(new Status(IStatus.ERROR, context.getBundle().getSymbolicName(), \"Failed to get bundleInfo for bundle from \" + bundleLocation, null));\r\n                continue;\r\n            }\r\n            Bundle bundle = Platform.getBundle(bundleInfo.getSymbolicName());\r\n            if (bundle != null) {\r\n                if (bundle.getLocation().equals(location) && bundle.getVersion().equals(Version.parseVersion(bundleInfo.getVersion()))) {\r\n                    continue;\r\n                }\r\n                bundle.uninstall();\r\n            }\r\n            bundle = context.installBundle(location);\r\n            JavaLanguageServerPlugin.logInfo(\"Installed \" + bundle.getLocation());\r\n            bundlesToStart.add(bundle);\r\n        } catch (BundleException e) {\r\n            status.add(new Status(IStatus.ERROR, context.getBundle().getSymbolicName(), \"Install bundle failure \" + bundleLocation, e));\r\n        } catch (MalformedURLException ex) {\r\n            status.add(new Status(IStatus.ERROR, context.getBundle().getSymbolicName(), \"Bundle location format is not correct \" + bundleLocation, ex));\r\n        } catch (IOException e) {\r\n            status.add(new Status(IStatus.ERROR, context.getBundle().getSymbolicName(), \"Cannot extract bundle symbolicName or version \" + bundleLocation, e));\r\n        }\r\n    }\r\n    status.addAll(startBundles(bundlesToStart));\r\n    if (status.getChildren().length > 0) {\r\n        throw new CoreException(status);\r\n    }\r\n}"
}, {
	"Path": "com.yahoo.elide.core.UpdateOnCreateTest.createPermissionOverwrittenForAttributeSuccessCase",
	"Comment": "class level expression overwritten by field level expression",
	"Method": "void createPermissionOverwrittenForAttributeSuccessCase(){\r\n    PersistentResource<UpdateAndCreate> created = PersistentResource.createObject(null, UpdateAndCreate.class, userThreeScope, Optional.of(\"6\"));\r\n    created.updateAttribute(\"alias\", \"\");\r\n    created.getRequestScope().getPermissionExecutor().executeCommitChecks();\r\n}"
}, {
	"Path": "org.dcm4che3.net.Connection.getDevice",
	"Comment": "get the device object that this network connection belongsto.",
	"Method": "Device getDevice(){\r\n    return device;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corrections.proposals.ASTRewriteCorrectionProposal.createImportRewrite",
	"Comment": "creates and sets the import rewrite used for this compilation unit.",
	"Method": "ImportRewrite createImportRewrite(CompilationUnit astRoot){\r\n    fImportRewrite = CodeStyleConfiguration.createImportRewrite(astRoot, true);\r\n    return fImportRewrite;\r\n}"
}, {
	"Path": "org.dom4j.io.DispatchHandler.onStart",
	"Comment": "the following methods implement the elementhandler interface",
	"Method": "void onStart(ElementPath elementPath){\r\n    Element element = elementPath.getCurrent();\r\n    pathStack.add(path);\r\n    if (atRoot) {\r\n        path = path + element.getName();\r\n        atRoot = false;\r\n    } else {\r\n        path = path + \"/\" + element.getName();\r\n    }\r\n    if ((handlers != null) && (handlers.containsKey(path))) {\r\n        ElementHandler handler = handlers.get(path);\r\n        handlerStack.add(handler);\r\n        handler.onStart(elementPath);\r\n    } else {\r\n        if (handlerStack.isEmpty() && (defaultHandler != null)) {\r\n            defaultHandler.onStart(elementPath);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.dragonet.common.maths.Vector3.getIntermediateWithZValue",
	"Comment": "returns a new vector with z value equal to the second parameter, along the line between this vector and thepassed in vector, or null if not possible.",
	"Method": "Vector3 getIntermediateWithZValue(Vector3 v,double z){\r\n    double xDiff = v.x - this.x;\r\n    double yDiff = v.y - this.y;\r\n    double zDiff = v.z - this.z;\r\n    if (zDiff * zDiff < 0.0000001) {\r\n        return null;\r\n    }\r\n    double f = (z - this.z) / zDiff;\r\n    if (f < 0 || f > 1) {\r\n        return null;\r\n    } else {\r\n        return new Vector3(this.x + xDiff * f, this.y + yDiff * f, this.z + zDiff * f);\r\n    }\r\n}"
}, {
	"Path": "org.dcm4che3.net.Connection.setHostname",
	"Comment": "this is the dns name for this particular connection. this is used toobtain the current ip address for connections. hostname must besufficiently qualified to be unambiguous for any client dns user.",
	"Method": "void setHostname(String hostname){\r\n    if (hostname != null ? hostname.equals(this.hostname) : this.hostname == null)\r\n        return;\r\n    this.hostname = hostname;\r\n    needRebind();\r\n}"
}, {
	"Path": "com.yahoo.elide.core.EntityDictionary.walkEntityGraph",
	"Comment": "walks the entity graph and performs a transform function on each element.",
	"Method": "List<T> walkEntityGraph(Set<Class<?>> entities,Function<Class<?>, T> transform){\r\n    ArrayList<T> results = new ArrayList();\r\n    Queue<Class<?>> toVisit = new ArrayDeque(entities);\r\n    Set<Class<?>> visited = new HashSet();\r\n    while (!toVisit.isEmpty()) {\r\n        Class<?> clazz = toVisit.remove();\r\n        results.add(transform.apply(clazz));\r\n        visited.add(clazz);\r\n        for (String relationship : getElideBoundRelationships(clazz)) {\r\n            Class<?> relationshipClass = getParameterizedType(clazz, relationship);\r\n            try {\r\n                lookupEntityClass(relationshipClass);\r\n            } catch (IllegalArgumentException e) {\r\n                continue;\r\n            }\r\n            if (!visited.contains(relationshipClass)) {\r\n                toVisit.add(relationshipClass);\r\n            }\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.databases.LuceneDatabase.isInMemory",
	"Comment": "returns true iff the lucene index is held in memory rather thanon disk.",
	"Method": "boolean isInMemory(){\r\n    return (directory instanceof RAMDirectory);\r\n}"
}, {
	"Path": "com.yahoo.elide.core.PersistentResource.delFromCollection",
	"Comment": "deletes an existing element in a collection and tests update and delete permissions.",
	"Method": "void delFromCollection(Collection collection,String collectionName,PersistentResource toDelete,boolean isInverseCheck){\r\n    final Collection original = copyCollection(collection);\r\n    checkFieldAwareDeferPermissions(UpdatePermission.class, collectionName, CollectionUtils.disjunction(collection, Collections.singleton(toDelete.getObject())), original);\r\n    String inverseField = getInverseRelationField(collectionName);\r\n    if (!isInverseCheck && !inverseField.isEmpty()) {\r\n        final Object originalValue = toDelete.getValueUnchecked(inverseField);\r\n        final Collection originalBidirectional;\r\n        if (originalValue instanceof Collection) {\r\n            originalBidirectional = copyCollection((Collection) originalValue);\r\n        } else {\r\n            originalBidirectional = Collections.singleton(originalValue);\r\n        }\r\n        final Collection removedBidrectional = CollectionUtils.disjunction(Collections.singleton(this.getObject()), originalBidirectional);\r\n        toDelete.checkFieldAwareDeferPermissions(UpdatePermission.class, inverseField, removedBidrectional, originalBidirectional);\r\n    }\r\n    if (collection == null) {\r\n        return;\r\n    }\r\n    collection.remove(toDelete.getObject());\r\n    auditField(new ChangeSpec(this, collectionName, original, collection));\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.BeanPropertyRowMapper.mapRow",
	"Comment": "extract the values for all columns in the current row.\tutilizes public setters and result set metadata.",
	"Method": "T mapRow(ResultSet rs,int rowNumber){\r\n    Assert.state(this.mappedClass != null, \"Mapped class was not specified\");\r\n    T mappedObject = BeanUtils.instantiate(this.mappedClass);\r\n    BeanWrapper bw = PropertyAccessorFactory.forBeanPropertyAccess(mappedObject);\r\n    initBeanWrapper(bw);\r\n    ResultSetMetaData rsmd = rs.getMetaData();\r\n    int columnCount = rsmd.getColumnCount();\r\n    Set<String> populatedProperties = (isCheckFullyPopulated() ? new HashSet<String>() : null);\r\n    for (int index = 1; index <= columnCount; index++) {\r\n        String column = JdbcUtils.lookupColumnName(rsmd, index);\r\n        PropertyDescriptor pd = this.mappedFields.get(column.replaceAll(\" \", \"\").toLowerCase());\r\n        if (pd != null) {\r\n            try {\r\n                Object value = getColumnValue(rs, index, pd);\r\n                if (logger.isDebugEnabled() && rowNumber == 0) {\r\n                    logger.debug(\"Mapping column '\" + column + \"' to property '\" + pd.getName() + \"' of type \" + pd.getPropertyType());\r\n                }\r\n                try {\r\n                    bw.setPropertyValue(pd.getName(), value);\r\n                } catch (TypeMismatchException e) {\r\n                    if (value == null && primitivesDefaultedForNullValue) {\r\n                        logger.debug(\"Intercepted TypeMismatchException for row \" + rowNumber + \" and column '\" + column + \"' with value \" + value + \" when setting property '\" + pd.getName() + \"' of type \" + pd.getPropertyType() + \" on object: \" + mappedObject);\r\n                    } else {\r\n                        throw e;\r\n                    }\r\n                }\r\n                if (populatedProperties != null) {\r\n                    populatedProperties.add(pd.getName());\r\n                }\r\n            } catch (NotWritablePropertyException ex) {\r\n                throw new DataRetrievalFailureException(\"Unable to map column \" + column + \" to property \" + pd.getName(), ex);\r\n            }\r\n        }\r\n    }\r\n    if (populatedProperties != null && !populatedProperties.equals(this.mappedProperties)) {\r\n        throw new InvalidDataAccessApiUsageException(\"Given ResultSet does not contain all fields \" + \"necessary to populate object of class [\" + this.mappedClass + \"]: \" + this.mappedProperties);\r\n    }\r\n    return mappedObject;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulator.setSqlScriptEncoding",
	"Comment": "specify the encoding for the configured sql scripts, if different from the\tplatform encoding.",
	"Method": "void setSqlScriptEncoding(String sqlScriptEncoding){\r\n    this.sqlScriptEncoding = StringUtils.hasText(sqlScriptEncoding) ? sqlScriptEncoding : null;\r\n}"
}, {
	"Path": "org.dom4j.rule.Rule.compareTo",
	"Comment": "compares two rules in xslt processing model order assuming that the modes\tare equal.",
	"Method": "int compareTo(Rule that){\r\n    int answer = compareInt(this.importPrecedence, that.importPrecedence);\r\n    if (answer == 0) {\r\n        answer = Double.compare(this.priority, that.priority);\r\n        if (answer == 0) {\r\n            answer = compareInt(this.appearenceCount, that.appearenceCount);\r\n        }\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "org.dom4j.io.SAXHelper.createXMLReader",
	"Comment": "creats a default xmlreader via the org.xml.sax.driver system property orjaxp if the system property is not set.",
	"Method": "XMLReader createXMLReader(boolean validating){\r\n    XMLReader reader = null;\r\n    if (reader == null) {\r\n        reader = createXMLReaderViaJAXP(validating, true);\r\n    }\r\n    if (reader == null) {\r\n        try {\r\n            reader = XMLReaderFactory.createXMLReader();\r\n        } catch (Exception e) {\r\n            if (isVerboseErrorReporting()) {\r\n                System.out.println(\"Warning: Caught exception attempting \" + \"to use SAX to load a SAX XMLReader \");\r\n                System.out.println(\"Warning: Exception was: \" + e);\r\n                System.out.println(\"Warning: I will print the stack trace \" + \"then carry on using the default \" + \"SAX parser\");\r\n                e.printStackTrace();\r\n            }\r\n            throw new SAXException(e);\r\n        }\r\n    }\r\n    if (reader == null) {\r\n        throw new SAXException(\"Couldn't create SAX reader\");\r\n    }\r\n    SAXHelper.setParserFeature(reader, \"http://xml.org/sax/features/namespaces\", true);\r\n    SAXHelper.setParserFeature(reader, \"http://xml.org/sax/features/namespace-prefixes\", false);\r\n    SAXHelper.setParserFeature(reader, \"http://xml.org/sax/properties/external-general-entities\", false);\r\n    SAXHelper.setParserFeature(reader, \"http://xml.org/sax/properties/external-parameter-entities\", false);\r\n    SAXHelper.setParserFeature(reader, \"http://apache.org/xml/features/nonvalidating/load-external-dtd\", false);\r\n    SAXHelper.setParserFeature(reader, \"http://xml.org/sax/features/use-locator2\", true);\r\n    return reader;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.rename.RenamingNameSuggestor.startsNewHunk",
	"Comment": "true if the string is the beginning of a new camel case hunk. false if it\tis not.",
	"Method": "boolean startsNewHunk(String string){\r\n    if (string.length() == 0) {\r\n        return true;\r\n    }\r\n    return isLegalChar(string.charAt(0));\r\n}"
}, {
	"Path": "sx.blah.discord.util.RequestBuilder.setAsync",
	"Comment": "sets whether the request should be executed asynchronously. this is false by default.",
	"Method": "RequestBuilder setAsync(boolean isAsync){\r\n    this.isAsync = isAsync;\r\n    return this;\r\n}"
}, {
	"Path": "com.yahoo.elide.datastores.multiplex.MultiplexWriteTransaction.reverseTransactions",
	"Comment": "attempt to reverse changes of last commit since not all transactions successfully committed.",
	"Method": "void reverseTransactions(ArrayList<DataStore> restoreList,Throwable cause,RequestScope requestScope){\r\n    for (DataStore dataStore : restoreList) {\r\n        try (DataStoreTransaction transaction = dataStore.beginTransaction()) {\r\n            List<Object> list = dirtyObjects.get(dataStore);\r\n            for (Object dirtyObject : list == null ? Collections.emptyList() : list) {\r\n                Object cloned = clonedObjects.get(dirtyObject);\r\n                if (cloned == NEWLY_CREATED_OBJECT) {\r\n                    transaction.delete(dirtyObject, requestScope);\r\n                } else {\r\n                    transaction.save(cloned, requestScope);\r\n                }\r\n            }\r\n            transaction.commit(requestScope);\r\n        } catch (RuntimeException | IOException e) {\r\n            cause.addSuppressed(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.dom4j.samples.AbstractDemo.createXMLWriter",
	"Comment": "a factory method to create an xmlwriter instance allowingderived classes to change this behaviour",
	"Method": "XMLWriter createXMLWriter(){\r\n    return new XMLWriter(System.out, format);\r\n}"
}, {
	"Path": "org.dom4j.samples.dom.RoundTripDemo.process",
	"Comment": "outputs the document to dom, parse it back again then output it",
	"Method": "void process(Document document){\r\n    System.out.println(\"about to output: \" + document);\r\n    DOMWriter writer = new DOMWriter();\r\n    org.w3c.dom.Document domDocument = writer.write(document);\r\n    DOMReader reader = new DOMReader();\r\n    Document doc2 = reader.read(domDocument);\r\n    System.out.println(\"parsed back again: \" + doc2);\r\n    XMLWriter xmlWriter = new XMLWriter(System.out);\r\n    xmlWriter.write(doc2);\r\n}"
}, {
	"Path": "com.yahoo.elide.core.PersistentResource.addInverseRelation",
	"Comment": "if a bidirectional relationship exists, attempts to add itself to the inverserelationship. given a to b as the relationship, a corresponds to this and b is the inverse.",
	"Method": "void addInverseRelation(String relationName,Object inverseObj){\r\n    String inverseName = dictionary.getRelationInverse(obj.getClass(), relationName);\r\n    if (!\"\".equals(inverseName)) {\r\n        Class<?> inverseType = dictionary.getType(inverseObj.getClass(), inverseName);\r\n        String uuid = requestScope.getUUIDFor(inverseObj);\r\n        PersistentResource inverseResource = new PersistentResource(inverseObj, this, uuid, requestScope);\r\n        Object inverseRelation = inverseResource.getValueUnchecked(inverseName);\r\n        if (Collection.class.isAssignableFrom(inverseType)) {\r\n            if (inverseRelation != null) {\r\n                inverseResource.addToCollection((Collection) inverseRelation, inverseName, this);\r\n            } else {\r\n                inverseResource.setValueChecked(inverseName, Collections.singleton(this.getObject()));\r\n            }\r\n        } else if (inverseType.isAssignableFrom(this.getResourceClass())) {\r\n            inverseResource.setValueChecked(inverseName, this.getObject());\r\n        } else {\r\n            throw new InternalServerErrorException(\"Relationship type mismatch\");\r\n        }\r\n        inverseResource.markDirty();\r\n        RelationshipType inverseRelationType = inverseResource.getRelationshipType(inverseName);\r\n        if (inverseRelationType.isToOne()) {\r\n            transaction.updateToOneRelation(transaction, inverseObj, inverseName, obj, requestScope);\r\n        } else {\r\n            assert (inverseRelation == null || inverseRelation instanceof Collection) : inverseName + \" not a collection\";\r\n            transaction.updateToManyRelation(transaction, inverseObj, inverseName, Sets.newHashSet(obj), new LinkedHashSet(), requestScope);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sx.blah.discord.util.MessageTokenizer.nextMention",
	"Comment": "gets the next mention in the content and moves the pointer forward.",
	"Method": "MentionToken nextMention(){\r\n    if (!hasNextMention())\r\n        throw new IllegalStateException(\"No more mentions found!\");\r\n    Token t = nextRegex(ANY_MENTION_PATTERN);\r\n    final int lessThan = t.getStartIndex();\r\n    final int greaterThan = t.getEndIndex();\r\n    final String matched = t.getContent();\r\n    final char type = matched.charAt(1);\r\n    if (type == '@') {\r\n        if (matched.charAt(2) == '&') {\r\n            return new RoleMentionToken(this, lessThan, greaterThan);\r\n        }\r\n        return new UserMentionToken(this, lessThan, greaterThan);\r\n    } else if (type == '#') {\r\n        return new ChannelMentionToken(this, lessThan, greaterThan);\r\n    }\r\n    throw new IllegalStateException(\"Couldn't find a mention even though it was found!\");\r\n}"
}, {
	"Path": "sx.blah.discord.util.EmbedBuilder.build",
	"Comment": "builds an embed with the configuration specified by the builder.",
	"Method": "EmbedObject build(){\r\n    generateWarnings();\r\n    throwExceptionForCharacterLimit(0);\r\n    return new EmbedObject(embed.title, \"rich\", embed.description, embed.url, embed.timestamp, color == null ? embed.color : ((color.getRed() & 0xFF) << 16) | ((color.getGreen() & 0xFF) << 8) | (color.getBlue() & 0xFF), embed.footer, embed.image, embed.thumbnail, embed.video, embed.provider, embed.author, fields.toArray(new EmbedObject.EmbedFieldObject[fields.size()]));\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.JdbcUtils.closeResultSet",
	"Comment": "close the given jdbc resultset and ignore any thrown exception.\tthis is useful for typical finally blocks in manual jdbc code.",
	"Method": "void closeResultSet(ResultSet rs){\r\n    if (rs != null) {\r\n        try {\r\n            rs.close();\r\n        } catch (SQLException ex) {\r\n            logger.trace(\"Could not close JDBC ResultSet\", ex);\r\n        } catch (Throwable ex) {\r\n            logger.trace(\"Unexpected exception on closing JDBC ResultSet\", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.yahoo.elide.core.EntityPermissions.hasChecksForPermission",
	"Comment": "does this permission check annotation exist for this entity or any field?",
	"Method": "boolean hasChecksForPermission(Class<? extends Annotation> annotationClass){\r\n    return bindings.containsKey(annotationClass);\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.MappingSqlQuery.mapRow",
	"Comment": "this method is implemented to invoke the simpler maprow\ttemplate method, ignoring parameters.",
	"Method": "T mapRow(ResultSet rs,int rowNum,Object[] parameters,Map<?, ?> context,T mapRow,ResultSet rs,int rowNum){\r\n    return mapRow(rs, rowNum);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.PreparedStatementCreatorFactory.addParameter",
	"Comment": "add a new declared parameter.\torder of parameter addition is significant.",
	"Method": "void addParameter(SqlParameter param){\r\n    this.declaredParameters.add(param);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.preferences.PreferenceManager.initialize",
	"Comment": "initialize default preference values of used bundles to match server\tfunctionality.",
	"Method": "void initialize(){\r\n    Hashtable<String, String> javaCoreOptions = JavaCore.getOptions();\r\n    javaCoreOptions.put(JavaCore.CODEASSIST_VISIBILITY_CHECK, JavaCore.ENABLED);\r\n    javaCoreOptions.put(JavaCore.COMPILER_RELEASE, JavaCore.ENABLED);\r\n    javaCoreOptions.put(DefaultCodeFormatterConstants.FORMATTER_USE_ON_OFF_TAGS, DefaultCodeFormatterConstants.TRUE);\r\n    JavaCore.setOptions(javaCoreOptions);\r\n    IEclipsePreferences defEclipsePrefs = DefaultScope.INSTANCE.getNode(IConstants.PLUGIN_ID);\r\n    defEclipsePrefs.put(\"org.eclipse.jdt.ui.typefilter.enabled\", \"\");\r\n    defEclipsePrefs.put(CodeStyleConfiguration.ORGIMPORTS_IMPORTORDER, String.join(\";\", Preferences.JAVA_IMPORT_ORDER_DEFAULT));\r\n    defEclipsePrefs.put(CodeStyleConfiguration.ORGIMPORTS_ONDEMANDTHRESHOLD, \"99\");\r\n    defEclipsePrefs.put(CodeStyleConfiguration.ORGIMPORTS_STATIC_ONDEMANDTHRESHOLD, \"99\");\r\n    defEclipsePrefs.put(MembersOrderPreferenceCacheCommon.APPEARANCE_MEMBER_SORT_ORDER, \"T,SF,SI,SM,F,I,C,M\");\r\n    defEclipsePrefs.put(StubUtility.CODEGEN_KEYWORD_THIS, Boolean.FALSE.toString());\r\n    defEclipsePrefs.put(StubUtility.CODEGEN_IS_FOR_GETTERS, Boolean.TRUE.toString());\r\n    defEclipsePrefs.put(StubUtility.CODEGEN_EXCEPTION_VAR_NAME, \"e\");\r\n    defEclipsePrefs.put(StubUtility.CODEGEN_ADD_COMMENTS, Boolean.FALSE.toString());\r\n    IEclipsePreferences m2eAptPrefs = DefaultScope.INSTANCE.getNode(M2E_APT_ID);\r\n    if (m2eAptPrefs != null) {\r\n        m2eAptPrefs.put(M2E_APT_ID + \".mode\", \"jdt_apt\");\r\n    }\r\n    initializeMavenPreferences();\r\n    Template[] templates = new Template[] { CodeGenerationTemplate.FIELDCOMMENT.createTemplate(null), CodeGenerationTemplate.METHODCOMMENT.createTemplate(null), CodeGenerationTemplate.CONSTRUCTORCOMMENT.createTemplate(null), CodeGenerationTemplate.CONSTRUCTORBODY.createTemplate(null), CodeGenerationTemplate.DELEGATECOMMENT.createTemplate(null), CodeGenerationTemplate.OVERRIDECOMMENT.createTemplate(null), CodeGenerationTemplate.TYPECOMMENT.createTemplate(null), CodeGenerationTemplate.GETTERCOMMENT.createTemplate(null), CodeGenerationTemplate.SETTERCOMMENT.createTemplate(null), CodeGenerationTemplate.GETTERBODY.createTemplate(null), CodeGenerationTemplate.SETTERBOY.createTemplate(null), CodeGenerationTemplate.CATCHBODY.createTemplate(null), CodeGenerationTemplate.METHODBODY.createTemplate(null) };\r\n    TemplatePersistenceData[] templateData = Arrays.asList(templates).stream().map(t -> new TemplatePersistenceData(t, true, t.getDescription())).collect(Collectors.toList()).toArray(new TemplatePersistenceData[0]);\r\n    TemplateReaderWriter trw = new TemplateReaderWriter();\r\n    try (Writer wrt = new StringWriter()) {\r\n        trw.save(templateData, wrt);\r\n        defEclipsePrefs.put(CUSTOM_CODE_TEMPLATES, wrt.toString());\r\n    } catch (IOException e) {\r\n    }\r\n    ContextTypeRegistry registry = new ContextTypeRegistry();\r\n    CodeTemplateContextType.registerContextTypes(registry);\r\n    registry.addContextType(new CodeTemplateContextType(CodeTemplatePreferences.CLASSSNIPPET_CONTEXTTYPE));\r\n    registry.addContextType(new CodeTemplateContextType(CodeTemplatePreferences.INTERFACESNIPPET_CONTEXTTYPE));\r\n    TemplateStoreCore tscore = new TemplateStoreCore(defEclipsePrefs, CUSTOM_CODE_TEMPLATES);\r\n    try {\r\n        tscore.load();\r\n    } catch (IOException e) {\r\n    }\r\n    JavaManipulation.setCodeTemplateStore(tscore);\r\n    JavaManipulation.setCodeTemplateContextRegistry(registry);\r\n}"
}, {
	"Path": "com.yahoo.elide.core.PersistentResource.addRelation",
	"Comment": "add relation link from a given parent resource to a child resource.",
	"Method": "void addRelation(String fieldName,PersistentResource newRelation){\r\n    checkSharePermission(Collections.singleton(newRelation));\r\n    Object relation = this.getValueUnchecked(fieldName);\r\n    if (relation instanceof Collection) {\r\n        if (addToCollection((Collection) relation, fieldName, newRelation)) {\r\n            this.markDirty();\r\n        }\r\n        transaction.updateToManyRelation(transaction, obj, fieldName, Sets.newHashSet(newRelation.getObject()), new LinkedHashSet(), requestScope);\r\n        addInverseRelation(fieldName, newRelation.getObject());\r\n    } else {\r\n        updateRelation(fieldName, Collections.singleton(newRelation));\r\n    }\r\n}"
}, {
	"Path": "sx.blah.discord.util.RequestBuilder.doActionAfter",
	"Comment": "sets the currently active action to execute after the specified event filter is passed.",
	"Method": "RequestBuilder doActionAfter(Predicate<T> eventFilter,RequestBuilder doActionAfter,Predicate<T> eventFilter,long time,RequestBuilder doActionAfter,Predicate<T> eventFilter,long time,TimeUnit unit){\r\n    activeAction.waitBefore = eventFilter;\r\n    activeAction.waitBeforeTimeout = unit.toMillis(time);\r\n    return this;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.hibernate.hql.AbstractHQLQueryBuilder.getJoinClauseFromFilters",
	"Comment": "extracts all the hql join clauses from given filter expression.",
	"Method": "String getJoinClauseFromFilters(FilterExpression filterExpression){\r\n    PredicateExtractionVisitor visitor = new PredicateExtractionVisitor(new ArrayList());\r\n    Collection<FilterPredicate> predicates = filterExpression.accept(visitor);\r\n    Set<String> alreadyJoined = new HashSet();\r\n    return predicates.stream().map(predicate -> extractJoinClause(predicate, alreadyJoined)).collect(Collectors.joining(SPACE));\r\n}"
}, {
	"Path": "no.priv.garshol.duke.ConfigurationImpl.getPropertyByName",
	"Comment": "returns the property with the given name, or null if there is nosuch property.",
	"Method": "Property getPropertyByName(String name){\r\n    return properties.get(name);\r\n}"
}, {
	"Path": "com.ea.async.Task.cast",
	"Comment": "wraps a completionstage as a task or just casts it if it is already a task.",
	"Method": "Task<T> cast(CompletionStage<T> stage){\r\n    if (stage instanceof Task) {\r\n        return (Task<T>) stage;\r\n    }\r\n    final Task<T> t = new Task();\r\n    stage.whenComplete((T v, Throwable ex) -> {\r\n        if (ex != null) {\r\n            t.completeExceptionally(ex);\r\n        } else {\r\n            t.complete(v);\r\n        }\r\n    });\r\n    return t;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.PropertyImpl.setHighProbability",
	"Comment": "sets the high probability used for this property. note thatchanging this while duke is processing may have unpredictableconsequences.",
	"Method": "void setHighProbability(double high){\r\n    this.high = high;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corrections.proposals.LinkedCorrectionProposal.setEndPosition",
	"Comment": "sets the end position of the linked mode to the end of the passed range.",
	"Method": "void setEndPosition(ITrackedNodePosition position){\r\n    getLinkedProposalModel().setEndPosition(position);\r\n}"
}, {
	"Path": "example.FunWithPermissions.getField8",
	"Comment": "verifies a chain of checks where all can fail or the last can succeed.",
	"Method": "String getField8(){\r\n    return field8;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.JdbcTransactionObjectSupport.rollbackToSavepoint",
	"Comment": "this implementation rolls back to the given jdbc 3.0 savepoint.",
	"Method": "void rollbackToSavepoint(Object savepoint){\r\n    try {\r\n        getConnectionHolderForSavepoint().getConnection().rollback((Savepoint) savepoint);\r\n    } catch (Throwable ex) {\r\n        throw new TransactionSystemException(\"Could not roll back to JDBC savepoint\", ex);\r\n    }\r\n}"
}, {
	"Path": "sx.blah.discord.api.ClientBuilder.withPingTimeout",
	"Comment": "configures the max number of heartbeats discord can not respond to before a reconnect is initiated.",
	"Method": "ClientBuilder withPingTimeout(int maxMissedPings){\r\n    this.maxMissedPings = maxMissedPings;\r\n    return this;\r\n}"
}, {
	"Path": "japa.parser.ast.Node.setParentNode",
	"Comment": "assign a new parent to this node, removing itfrom the list of children of the previous parent, if any.",
	"Method": "void setParentNode(Node parentNode){\r\n    if (this.parentNode != null) {\r\n        this.parentNode.childrenNodes.remove(this);\r\n    }\r\n    this.parentNode = parentNode;\r\n    if (this.parentNode != null) {\r\n        this.parentNode.childrenNodes.add(this);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.SingleColumnRowMapper.setRequiredType",
	"Comment": "set the type that each result object is expected to match.\tif not specified, the column value will be exposed as\treturned by the jdbc driver.",
	"Method": "void setRequiredType(Class<T> requiredType){\r\n    this.requiredType = requiredType;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.RowCountCallbackHandler.getRowCount",
	"Comment": "return the row count of this resultset\tonly valid after processing is complete",
	"Method": "int getRowCount(){\r\n    return rowCount;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.TableMetaDataContext.matchInParameterValuesWithInsertColumns",
	"Comment": "match the provided column names and values with the list of columns used.",
	"Method": "List<Object> matchInParameterValuesWithInsertColumns(SqlParameterSource parameterSource,List<Object> matchInParameterValuesWithInsertColumns,Map<String, Object> inParameters){\r\n    List<Object> values = new ArrayList<Object>();\r\n    Map<String, Object> source = new HashMap<String, Object>();\r\n    for (String key : inParameters.keySet()) {\r\n        source.put(key.toLowerCase(), inParameters.get(key));\r\n    }\r\n    for (String column : this.tableColumns) {\r\n        values.add(source.get(column.toLowerCase()));\r\n    }\r\n    return values;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.rename.MethodChecks.getTopmostMethod",
	"Comment": "locates the topmost method of an override ripple and returns it. if none\tis found, null is returned.",
	"Method": "IMethod getTopmostMethod(IMethod method,ITypeHierarchy typeHierarchy,IProgressMonitor monitor){\r\n    Assert.isNotNull(method);\r\n    ITypeHierarchy hierarchy = typeHierarchy;\r\n    IMethod topmostMethod = null;\r\n    final IType declaringType = method.getDeclaringType();\r\n    if (!declaringType.isInterface()) {\r\n        if ((hierarchy == null) || !declaringType.equals(hierarchy.getType())) {\r\n            hierarchy = declaringType.newTypeHierarchy(monitor);\r\n        }\r\n        IMethod inInterface = isDeclaredInInterface(method, hierarchy, monitor);\r\n        if (inInterface != null && !inInterface.equals(method)) {\r\n            topmostMethod = inInterface;\r\n        }\r\n    }\r\n    if (topmostMethod == null) {\r\n        if (hierarchy == null) {\r\n            hierarchy = declaringType.newSupertypeHierarchy(monitor);\r\n        }\r\n        IMethod overrides = overridesAnotherMethod(method, hierarchy);\r\n        if (overrides != null && !overrides.equals(method)) {\r\n            topmostMethod = overrides;\r\n        }\r\n    }\r\n    return topmostMethod;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.rename.RenamingNameSuggestor.isUpperCaseCamelCaseHunk",
	"Comment": "true if hunk is longer than 1 character and all letters in the hunk are\tuppercase. false if not.",
	"Method": "boolean isUpperCaseCamelCaseHunk(String hunk){\r\n    if (hunk.length() < 2) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < hunk.length(); i++) {\r\n        if (!isLegalChar(hunk.charAt(i))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.rename.RenameTypeProcessor.analyzeAffectedCompilationUnits",
	"Comment": "analyzes all compilation units in which type is referenced",
	"Method": "RefactoringStatus analyzeAffectedCompilationUnits(IProgressMonitor pm){\r\n    RefactoringStatus result = new RefactoringStatus();\r\n    result.merge(Checks.checkCompileErrorsInAffectedFiles(fReferences, fType.getResource()));\r\n    pm.beginTask(\"\", fReferences.length);\r\n    result.merge(checkConflictingTypes(pm));\r\n    return result;\r\n}"
}, {
	"Path": "sx.blah.discord.handle.impl.events.guild.GuildUnavailableEvent.getOptionalGuild",
	"Comment": "gets the guild that became unavailable. this is not present if the guild was not previously cached.",
	"Method": "Optional<IGuild> getOptionalGuild(){\r\n    return Optional.ofNullable(getGuild());\r\n}"
}, {
	"Path": "com.yahoo.elide.core.EntityDictionary.getAttributeOrRelationAnnotations",
	"Comment": "return multiple annotations from field or accessor method.",
	"Method": "A[] getAttributeOrRelationAnnotations(Class<?> entityClass,Class<A> annotationClass,String identifier){\r\n    AccessibleObject fieldOrMethod = getEntityBinding(entityClass).fieldsToValues.get(identifier);\r\n    if (fieldOrMethod == null) {\r\n        return null;\r\n    }\r\n    return fieldOrMethod.getAnnotationsByType(annotationClass);\r\n}"
}, {
	"Path": "org.dom4j.io.SAXContentHandler.setStripWhitespaceText",
	"Comment": "sets whether whitespace between element start and end tags should beignored.",
	"Method": "void setStripWhitespaceText(boolean stripWhitespaceText){\r\n    this.stripWhitespaceText = stripWhitespaceText;\r\n}"
}, {
	"Path": "sx.blah.discord.util.audio.providers.ProviderQueue.findSuitableProvider",
	"Comment": "gets the first provider in the queue that can provide audio.",
	"Method": "IAudioProvider findSuitableProvider(){\r\n    IAudioProvider usableProvider = null;\r\n    for (IAudioProvider provider : providers) {\r\n        if (!provider.isReady()) {\r\n            providers.remove(provider);\r\n        } else {\r\n            usableProvider = provider;\r\n            break;\r\n        }\r\n    }\r\n    if (usableProvider == null)\r\n        usableProvider = new DefaultProvider();\r\n    return usableProvider;\r\n}"
}, {
	"Path": "org.dom4j.io.DOMSAXContentHandler.isStripWhitespaceText",
	"Comment": "sets whether whitespace between element start and end tags should beignored",
	"Method": "boolean isStripWhitespaceText(){\r\n    return stripWhitespaceText;\r\n}"
}, {
	"Path": "org.dom4j.swing.BranchTreeNode.createChildTreeNode",
	"Comment": "factory method to create child tree nodes for a given xml node type",
	"Method": "TreeNode createChildTreeNode(Node xmlNode){\r\n    if (xmlNode instanceof Branch) {\r\n        return new BranchTreeNode(this, (Branch) xmlNode);\r\n    } else {\r\n        return new LeafTreeNode(this, xmlNode);\r\n    }\r\n}"
}, {
	"Path": "org.dom4j.io.STAXEventReader.createCharacterData",
	"Comment": "constructs a new dom4j text or cdata object from the provided charactersevent.",
	"Method": "CharacterData createCharacterData(Characters characters){\r\n    String data = characters.getData();\r\n    if (characters.isCData()) {\r\n        return factory.createCDATA(data);\r\n    } else {\r\n        return factory.createText(data);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.managers.FormatterManager.readSettingsFromStream",
	"Comment": "load profiles from a xml stream and add them to a map or null if the source is not a profile store.",
	"Method": "Map<String, String> readSettingsFromStream(InputSource inputSource,String profileName){\r\n    final ProfileDefaultHandler handler = new ProfileDefaultHandler(profileName);\r\n    try {\r\n        final SAXParserFactory factory = SAXParserFactory.newInstance();\r\n        final SAXParser parser = factory.newSAXParser();\r\n        parser.parse(inputSource, handler);\r\n    } catch (Exception e) {\r\n        throw new CoreException(new Status(IStatus.WARNING, IConstants.PLUGIN_ID, e.getMessage(), e));\r\n    }\r\n    return handler.getSettings();\r\n}"
}, {
	"Path": "com.github.devnied.emvnfccard.parser.EmvParser.getAids",
	"Comment": "method used to get the aid list, if the kernel identifier is defined, \tthis value need to be appended to the adf name in the data field of \tthe select command.",
	"Method": "List<byte[]> getAids(byte[] pData){\r\n    List<byte[]> ret = new ArrayList<byte[]>();\r\n    List<TLV> listTlv = TlvUtil.getlistTLV(pData, EmvTags.AID_CARD, EmvTags.KERNEL_IDENTIFIER);\r\n    for (TLV tlv : listTlv) {\r\n        if (tlv.getTag() == EmvTags.KERNEL_IDENTIFIER && ret.size() != 0) {\r\n            ret.add(ArrayUtils.addAll(ret.get(ret.size() - 1), tlv.getValueBytes()));\r\n        } else {\r\n            ret.add(tlv.getValueBytes());\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "denominator.model.ResourceRecordSet.name",
	"Comment": "an owner name, i.e., the name of the node to which this resource record pertains.",
	"Method": "String name(){\r\n    return name;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.rename.RenameFieldProcessor.getDelegateCount",
	"Comment": "returns the maximum number of delegates which can\tbe created for the input elements of this refactoring.",
	"Method": "int getDelegateCount(){\r\n    int count = 0;\r\n    try {\r\n        if (RefactoringAvailabilityTester.isDelegateCreationAvailable(getField())) {\r\n            count++;\r\n        }\r\n        if (fRenameGetter && getGetter() != null) {\r\n            count++;\r\n        }\r\n        if (fRenameSetter && getSetter() != null) {\r\n            count++;\r\n        }\r\n    } catch (CoreException e) {\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "effectivejava.chapter8.item56.DocExamples.get",
	"Comment": "returns the element at the specified position in this list.this method is not guaranteed to run in constanttime. in some implementations it may run in time proportionalto the element position.",
	"Method": "E get(int index){\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.RdbmsOperation.setUpdatableResults",
	"Comment": "set whether to use statements that are capable of returning\tupdatable resultsets.",
	"Method": "void setUpdatableResults(boolean updatableResults){\r\n    if (isCompiled()) {\r\n        throw new InvalidDataAccessApiUsageException(\"The updateableResults flag must be set before the operation is compiled\");\r\n    }\r\n    this.updatableResults = updatableResults;\r\n}"
}, {
	"Path": "org.dcm4che3.net.ApplicationEntity.getApplicationClusters",
	"Comment": "get the locally defined names for a subset of related applications. e.g.neuroradiology.",
	"Method": "String[] getApplicationClusters(){\r\n    return applicationClusters;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.genetic.GeneticAlgorithm.evaluate",
	"Comment": "evaluates the given configuration, storing the score on the object.",
	"Method": "double evaluate(GeneticConfiguration config,MatchListener listener){\r\n    Configuration cconfig = config.getConfiguration();\r\n    Processor proc = new Processor(cconfig, database);\r\n    TestFileListener eval = makeEval(cconfig, testdb, proc);\r\n    if (active || incomplete)\r\n        eval.setPessimistic(false);\r\n    proc.addMatchListener(eval);\r\n    TestFileListener seval = null;\r\n    if (scientific) {\r\n        seval = makeEval(cconfig, ((LinkFileOracle) oracle).getLinkDatabase(), proc);\r\n        seval.setPessimistic(true);\r\n        proc.addMatchListener(seval);\r\n    }\r\n    if (listener != null)\r\n        proc.addMatchListener(listener);\r\n    if (cconfig.isDeduplicationMode())\r\n        proc.linkRecords(cconfig.getDataSources());\r\n    else\r\n        proc.linkRecords(cconfig.getDataSources(2), false);\r\n    if (seval != null)\r\n        sciencetracker.put(config, seval.getFNumber());\r\n    config.setFNumber(eval.getFNumber());\r\n    return eval.getFNumber();\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.SingleConnectionDataSource.destroy",
	"Comment": "close the underlying connection.\tthe provider of this datasource needs to care for proper shutdown.\tas this bean implements disposablebean, a bean factory will\tautomatically invoke this on destruction of its cached singletons.",
	"Method": "void destroy(){\r\n    synchronized (this.connectionMonitor) {\r\n        closeConnection();\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.JsonMessageHelper.getParams",
	"Comment": "returns the deserialized params attribute of a json message payload",
	"Method": "T getParams(CharSequence jsonPayload){\r\n    Message message = handler.parseMessage(jsonPayload);\r\n    Method getParam = null;\r\n    try {\r\n        getParam = message.getClass().getMethod(\"getParams\");\r\n        Object params = getParam.invoke(message);\r\n        return (T) params;\r\n    } catch (Exception e) {\r\n        throw new UnsupportedOperationException(\"Can't deserialize into class\");\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.rename.RefactoringHandleTransplanter.transplantHandle",
	"Comment": "converts the handle. handle need not exist, but must be a source\treference.",
	"Method": "IMember transplantHandle(IMember handle){\r\n    final LinkedList<IMember> oldElements = new LinkedList();\r\n    addElements(handle, oldElements);\r\n    final IMember[] newElements = convertElements(oldElements.toArray(new IMember[0]));\r\n    return newElements[newElements.length - 1];\r\n}"
}, {
	"Path": "sx.blah.discord.util.MessageHistory.contains",
	"Comment": "gets whether the collection contains a message with the given id.",
	"Method": "boolean contains(long id){\r\n    return Arrays.stream(backing).anyMatch(msg -> msg.getLongID() == id);\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.SqlOperation.newPreparedStatementCreator",
	"Comment": "return a preparedstatementcreator to perform an operation\twith the given parameters.",
	"Method": "PreparedStatementCreator newPreparedStatementCreator(Object[] params,PreparedStatementCreator newPreparedStatementCreator,String sqlToUse,Object[] params){\r\n    return this.preparedStatementFactory.newPreparedStatementCreator(sqlToUse, params);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.text.JavaWordIterator.isDelimiter",
	"Comment": "returns true if the given sequence into the underlying text\trepresents a delimiter, false otherwise.",
	"Method": "boolean isDelimiter(int offset,int exclusiveEnd){\r\n    if (exclusiveEnd == DONE || offset == DONE) {\r\n        return false;\r\n    }\r\n    Assert.isTrue(offset >= 0);\r\n    Assert.isTrue(exclusiveEnd <= getText().getEndIndex());\r\n    Assert.isTrue(exclusiveEnd > offset);\r\n    CharSequence seq = fIterator.fText;\r\n    while (offset < exclusiveEnd) {\r\n        char ch = seq.charAt(offset);\r\n        if (ch != '\\n' && ch != '\\r') {\r\n            return false;\r\n        }\r\n        offset++;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.EntityDictionary.getRelationInverse",
	"Comment": "if a relationship is bidirectional, returns the name of the peer relationship in the peer entity.",
	"Method": "String getRelationInverse(Class<?> cls,String relation){\r\n    final EntityBinding clsBinding = getEntityBinding(cls);\r\n    final ConcurrentHashMap<String, String> mappings = clsBinding.relationshipToInverse;\r\n    if (mappings != null) {\r\n        final String mapping = mappings.get(relation);\r\n        if (mapping != null && !\"\".equals(mapping)) {\r\n            return mapping;\r\n        }\r\n    }\r\n    final Class<?> inverseType = getParameterizedType(cls, relation);\r\n    final ConcurrentHashMap<String, String> inverseMappings = getEntityBinding(inverseType).relationshipToInverse;\r\n    for (Map.Entry<String, String> inverseMapping : inverseMappings.entrySet()) {\r\n        String inverseRelationName = inverseMapping.getKey();\r\n        String inverseMappedBy = inverseMapping.getValue();\r\n        if (relation.equals(inverseMappedBy) && getParameterizedType(inverseType, inverseRelationName).equals(clsBinding.entityClass)) {\r\n            return inverseRelationName;\r\n        }\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "com.yahoo.elide.jsonapi.document.processors.IncludedProcessor.addResourcesForPath",
	"Comment": "adds all the relation resources for a given relation path to the included block of thejsonapidocument.",
	"Method": "void addResourcesForPath(JsonApiDocument jsonApiDocument,PersistentResource<?> rec,List<String> relationPath){\r\n    String relation = relationPath.remove(0);\r\n    Optional<FilterExpression> filterExpression = rec.getRequestScope().getExpressionForRelation(rec, relation);\r\n    Set<PersistentResource> collection;\r\n    try {\r\n        collection = rec.getRelationCheckedFiltered(relation, filterExpression, Optional.empty(), Optional.empty());\r\n    } catch (ForbiddenAccessException e) {\r\n        return;\r\n    }\r\n    collection.forEach(resource -> {\r\n        jsonApiDocument.addIncluded(resource.toResource());\r\n        if (!relationPath.isEmpty()) {\r\n            addResourcesForPath(jsonApiDocument, resource, new ArrayList(relationPath));\r\n        }\r\n    });\r\n}"
}, {
	"Path": "no.priv.garshol.duke.PropertyImpl.isIgnoreProperty",
	"Comment": "iff true the property should not be used for comparing records.",
	"Method": "boolean isIgnoreProperty(){\r\n    return ignore || high == 0.0;\r\n}"
}, {
	"Path": "org.dom4j.xpath.DefaultXPath.getText",
	"Comment": "retrieve the textual xpath string used to initialize this object",
	"Method": "String getText(){\r\n    return text;\r\n}"
}, {
	"Path": "sx.blah.discord.util.EmbedBuilder.withFooterIcon",
	"Comment": "sets the footer icon. footer text must be present for the footer icon to appear.",
	"Method": "EmbedBuilder withFooterIcon(String iconUrl){\r\n    if (embed.footer == null)\r\n        embed.footer = new EmbedObject.FooterObject(null, null, null);\r\n    embed.footer.icon_url = iconUrl;\r\n    return this;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.sort.Sorting.getValidSortingRules",
	"Comment": "given the sorting rules validate sorting rules against the entities bound to the entityclass.",
	"Method": "Map<Path, SortOrder> getValidSortingRules(Class<T> entityClass,EntityDictionary dictionary){\r\n    Map<Path, SortOrder> returnMap = new LinkedHashMap();\r\n    for (Map.Entry<String, SortOrder> entry : replaceIdRule(dictionary.getIdFieldName(entityClass)).entrySet()) {\r\n        String dotSeparatedPath = entry.getKey();\r\n        SortOrder order = entry.getValue();\r\n        Path path = new Path(entityClass, dictionary, dotSeparatedPath);\r\n        if (!isValidSortRulePath(path, dictionary)) {\r\n            throw new InvalidValueException(\"Cannot sort across a to-many relationship: \" + path.getFieldPath());\r\n        }\r\n        returnMap.put(path, order);\r\n    }\r\n    return returnMap;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.DataSourceUtils.getConnectionSynchronizationOrder",
	"Comment": "determine the connection synchronization order to use for the given\tdatasource. decreased for every level of nesting that a datasource\thas, checked through the level of delegatingdatasource nesting.",
	"Method": "int getConnectionSynchronizationOrder(DataSource dataSource){\r\n    int order = CONNECTION_SYNCHRONIZATION_ORDER;\r\n    DataSource currDs = dataSource;\r\n    while (currDs instanceof DelegatingDataSource) {\r\n        order--;\r\n        currDs = ((DelegatingDataSource) currDs).getTargetDataSource();\r\n    }\r\n    return order;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.PersistentResource.toResourceWithSortingAndPagination",
	"Comment": "fetch a resource with support for lambda function for getting relationships and attributes.",
	"Method": "Resource toResourceWithSortingAndPagination(){\r\n    return toResource(this::getRelationshipsWithSortingAndPagination, this::getAttributes);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.rename.MethodChecks.isVirtual",
	"Comment": "returns true iff the method could be a virtual method,\ti.e. if it is not a constructor, is private, or is static.",
	"Method": "boolean isVirtual(IMethod method,boolean isVirtual,IMethodBinding methodBinding){\r\n    if (methodBinding.isConstructor()) {\r\n        return false;\r\n    }\r\n    if (Modifier.isPrivate(methodBinding.getModifiers())) {\r\n        return false;\r\n    }\r\n    if (Modifier.isStatic(methodBinding.getModifiers())) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.javadoc.JavadocContentAccess2.findAttachedDocInHierarchy",
	"Comment": "finds the first available attached javadoc in the hierarchy of the given\tmethod.",
	"Method": "String findAttachedDocInHierarchy(IMethod method){\r\n    IType type = method.getDeclaringType();\r\n    ITypeHierarchy hierarchy = SuperTypeHierarchyCache.getTypeHierarchy(type);\r\n    final MethodOverrideTester tester = SuperTypeHierarchyCache.getMethodOverrideTester(type);\r\n    return (String) new InheritDocVisitor() {\r\n        @Override\r\n        public Object visit(IType currType) throws JavaModelException {\r\n            IMethod overridden = tester.findOverriddenMethodInType(currType, method);\r\n            if (overridden == null) {\r\n                return InheritDocVisitor.CONTINUE;\r\n            }\r\n            if (overridden.getOpenable().getBuffer() == null) {\r\n                String attachedJavadoc = overridden.getAttachedJavadoc(null);\r\n                if (attachedJavadoc != null) {\r\n                    String baseURL = JavaDocLocations.getBaseURL(overridden, overridden.isBinary());\r\n                    if (baseURL != null) {\r\n                        attachedJavadoc = BASE_URL_COMMENT_INTRO + baseURL + \"\\\"--> \" + attachedJavadoc;\r\n                    }\r\n                    return attachedJavadoc;\r\n                }\r\n            }\r\n            return CONTINUE;\r\n        }\r\n    }.visitInheritDoc(type, hierarchy);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.javadoc.JavadocContentAccess2.findAttachedDocInHierarchy",
	"Comment": "finds the first available attached javadoc in the hierarchy of the given\tmethod.",
	"Method": "String findAttachedDocInHierarchy(IMethod method){\r\n    IMethod overridden = tester.findOverriddenMethodInType(currType, method);\r\n    if (overridden == null) {\r\n        return InheritDocVisitor.CONTINUE;\r\n    }\r\n    if (overridden.getOpenable().getBuffer() == null) {\r\n        String attachedJavadoc = overridden.getAttachedJavadoc(null);\r\n        if (attachedJavadoc != null) {\r\n            String baseURL = JavaDocLocations.getBaseURL(overridden, overridden.isBinary());\r\n            if (baseURL != null) {\r\n                attachedJavadoc = BASE_URL_COMMENT_INTRO + baseURL + \"\\\"--> \" + attachedJavadoc;\r\n            }\r\n            return attachedJavadoc;\r\n        }\r\n    }\r\n    return CONTINUE;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corrections.proposals.ChangeCorrectionProposal.performChange",
	"Comment": "performs the change associated with this proposal.\tsubclasses may extend, but must call the super implementation.",
	"Method": "void performChange(){\r\n    Change change = null;\r\n    try {\r\n        change = getChange();\r\n        if (change != null) {\r\n            change.initializeValidationData(new NullProgressMonitor());\r\n            RefactoringStatus valid = change.isValid(new NullProgressMonitor());\r\n            if (valid.hasFatalError()) {\r\n                IStatus status = new Status(IStatus.ERROR, JavaLanguageServerPlugin.PLUGIN_ID, IStatus.ERROR, valid.getMessageMatchingSeverity(RefactoringStatus.FATAL), null);\r\n                throw new CoreException(status);\r\n            } else {\r\n                IUndoManager manager = RefactoringCore.getUndoManager();\r\n                Change undoChange;\r\n                boolean successful = false;\r\n                try {\r\n                    manager.aboutToPerformChange(change);\r\n                    undoChange = change.perform(new NullProgressMonitor());\r\n                    successful = true;\r\n                } finally {\r\n                    manager.changePerformed(change, successful);\r\n                }\r\n                if (undoChange != null) {\r\n                    undoChange.initializeValidationData(new NullProgressMonitor());\r\n                    manager.addUndo(getName(), undoChange);\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        if (change != null) {\r\n            change.dispose();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.JdbcTemplate.getNativeJdbcExtractor",
	"Comment": "return the current nativejdbcextractor implementation.",
	"Method": "NativeJdbcExtractor getNativeJdbcExtractor(){\r\n    return this.nativeJdbcExtractor;\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.BatchSqlUpdate.getQueueCount",
	"Comment": "return the current number of statements or statement parameters\tin the queue.",
	"Method": "int getQueueCount(){\r\n    return this.parameterQueue.size();\r\n}"
}, {
	"Path": "org.dom4j.util.StringUtils.startsWithWhitespace",
	"Comment": "finds out if the given character sequence starts with a whitespacecharacter.",
	"Method": "boolean startsWithWhitespace(CharSequence charSeq){\r\n    if (charSeq.length() == 0) {\r\n        return false;\r\n    }\r\n    return Character.isWhitespace(charSeq.charAt(0));\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.contentassist.CompletionProposalDescriptionProvider.setDeclarationSignature",
	"Comment": "sets the declaration signature to data that is used on the resolve call.",
	"Method": "void setDeclarationSignature(CompletionItem item,String signature){\r\n    ((Map<String, String>) item.getData()).put(CompletionResolveHandler.DATA_FIELD_DECLARATION_SIGNATURE, String.valueOf(signature));\r\n}"
}, {
	"Path": "org.dom4j.io.SAXHelper.createXMLReaderViaJAXP",
	"Comment": "this method attempts to use jaxp to locate the sax2 xmlreaderimplementation. this method uses reflection to avoid being dependentdirectly on the jaxp classes.",
	"Method": "XMLReader createXMLReaderViaJAXP(boolean validating,boolean namespaceAware){\r\n    try {\r\n        return JAXPHelper.createXMLReader(validating, namespaceAware);\r\n    } catch (Throwable e) {\r\n        if (!loggedWarning) {\r\n            loggedWarning = true;\r\n            if (isVerboseErrorReporting()) {\r\n                System.out.println(\"Warning: Caught exception attempting \" + \"to use JAXP to load a SAX XMLReader\");\r\n                System.out.println(\"Warning: Exception was: \" + e);\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.Link.overrides",
	"Comment": "returns true if the information in this link should takeprecedence over the information in the other link.",
	"Method": "boolean overrides(Link other){\r\n    if (other.getStatus() == LinkStatus.ASSERTED && status != LinkStatus.ASSERTED)\r\n        return false;\r\n    else if (status == LinkStatus.ASSERTED && other.getStatus() != LinkStatus.ASSERTED)\r\n        return true;\r\n    return timestamp > other.getTimestamp();\r\n}"
}, {
	"Path": "org.dcm4che3.net.ApplicationEntity.isAssociationInitiator",
	"Comment": "determine whether or not this network ae can initiate associations.",
	"Method": "boolean isAssociationInitiator(){\r\n    return initiator;\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.DatabaseStartupValidator.afterPropertiesSet",
	"Comment": "check whether the validation query can be executed on a connection\tfrom the specified datasource, with the specified interval between\tchecks, until the specified timeout.",
	"Method": "void afterPropertiesSet(){\r\n    if (this.dataSource == null) {\r\n        throw new IllegalArgumentException(\"dataSource is required\");\r\n    }\r\n    if (this.validationQuery == null) {\r\n        throw new IllegalArgumentException(\"validationQuery is required\");\r\n    }\r\n    try {\r\n        boolean validated = false;\r\n        long beginTime = System.currentTimeMillis();\r\n        long deadLine = beginTime + this.timeout * 1000;\r\n        SQLException latestEx = null;\r\n        while (!validated && System.currentTimeMillis() < deadLine) {\r\n            Connection con = null;\r\n            Statement stmt = null;\r\n            try {\r\n                con = this.dataSource.getConnection();\r\n                stmt = con.createStatement();\r\n                stmt.execute(this.validationQuery);\r\n                validated = true;\r\n            } catch (SQLException ex) {\r\n                latestEx = ex;\r\n                logger.debug(\"Validation query [\" + this.validationQuery + \"] threw exception\", ex);\r\n                float rest = ((float) (deadLine - System.currentTimeMillis())) / 1000;\r\n                if (rest > this.interval) {\r\n                    logger.warn(\"Database has not started up yet - retrying in \" + this.interval + \" seconds (timeout in \" + rest + \" seconds)\");\r\n                }\r\n            } finally {\r\n                JdbcUtils.closeStatement(stmt);\r\n                JdbcUtils.closeConnection(con);\r\n            }\r\n            if (!validated) {\r\n                Thread.sleep(this.interval * 1000);\r\n            }\r\n        }\r\n        if (!validated) {\r\n            throw new CannotGetJdbcConnectionException(\"Database has not started up within \" + this.timeout + \" seconds\", latestEx);\r\n        }\r\n        float duration = (System.currentTimeMillis() - beginTime) / 1000;\r\n        if (logger.isInfoEnabled()) {\r\n            logger.info(\"Database startup detected after \" + duration + \" seconds\");\r\n        }\r\n    } catch (InterruptedException ex) {\r\n        Thread.currentThread().interrupt();\r\n    }\r\n}"
}, {
	"Path": "sx.blah.discord.util.Image.forData",
	"Comment": "generates an avatar image from bytes representing an image.",
	"Method": "Image forData(String imageType,byte[] data){\r\n    return () -> String.format(\"data:image/%s;base64,%s\", imageType, Base64.encodeBase64String(data));\r\n}"
}, {
	"Path": "japa.parser.ASTHelper.addMember",
	"Comment": "adds the given declaration to the specified type. the list of memberswill be initialized if it is null.",
	"Method": "void addMember(TypeDeclaration type,BodyDeclaration decl){\r\n    List<BodyDeclaration> members = type.getMembers();\r\n    if (members == null) {\r\n        members = new ArrayList<BodyDeclaration>();\r\n        type.setMembers(members);\r\n    }\r\n    members.add(decl);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.dom.ModifierRewrite.setVisibility",
	"Comment": "sets the included visibility modifiers and removes existing visibility\tmodifiers. does not touch other flags and leaves annotations in place.",
	"Method": "PositionInformation setVisibility(int visibilityFlags,TextEditGroup editGroup){\r\n    return internalSetModifiers(visibilityFlags, VISIBILITY_MODIFIERS, editGroup);\r\n}"
}, {
	"Path": "com.dslplatform.json.JsonWriter.getByteBuffer",
	"Comment": "current buffer.\tif buffer grows, a new instance will be created and old one will not be used anymore.",
	"Method": "byte[] getByteBuffer(){\r\n    return buffer;\r\n}"
}, {
	"Path": "sx.blah.discord.util.EmbedBuilder.withAuthorUrl",
	"Comment": "sets the author url. author name must be present for the url to work.",
	"Method": "EmbedBuilder withAuthorUrl(String url){\r\n    if (embed.author == null)\r\n        embed.author = new EmbedObject.AuthorObject(null, null, null, null);\r\n    embed.author.url = url;\r\n    return this;\r\n}"
}, {
	"Path": "org.dom4j.io.DOMSAXContentHandler.isMergeAdjacentText",
	"Comment": "returns whether adjacent text nodes should be merged together.",
	"Method": "boolean isMergeAdjacentText(){\r\n    return mergeAdjacentText;\r\n}"
}, {
	"Path": "org.dcm4che3.net.Connection.setPort",
	"Comment": "the tcp port that the ae is listening on or 0 for a network connection that only initiates associations.a valid port value is between 0 and 65535.",
	"Method": "void setPort(int port){\r\n    if (this.port == port)\r\n        return;\r\n    if ((port <= 0 || port > 0xFFFF) && port != NOT_LISTENING)\r\n        throw new IllegalArgumentException(\"port out of range:\" + port);\r\n    this.port = port;\r\n    needRebind();\r\n}"
}, {
	"Path": "org.dom4j.io.DOMSAXContentHandler.getDocument",
	"Comment": "retrieves w3c document object built via generated sax events.",
	"Method": "org.w3c.dom.Document getDocument(){\r\n    if (document == null) {\r\n        document = createDocument();\r\n    }\r\n    return (org.w3c.dom.Document) document;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder.addScript",
	"Comment": "add an sql script to execute to initialize or populate the database.",
	"Method": "EmbeddedDatabaseBuilder addScript(String script){\r\n    this.databasePopulator.addScript(this.resourceLoader.getResource(script));\r\n    return this;\r\n}"
}, {
	"Path": "sx.blah.discord.modules.ModuleLoader.getModules",
	"Comment": "gets the module classes which will be or have been loaded. these may or may not be enabled in a given module\tinstance.",
	"Method": "List<Class<? extends IModule>> getModules(){\r\n    return modules;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.Path.getAlias",
	"Comment": "returns an alias that uniquely identifies the last collection of entities in the path.",
	"Method": "String getAlias(){\r\n    if (pathElements.size() < 2) {\r\n        return lastElement().map(e -> getTypeAlias(e.getType())).orElse(null);\r\n    }\r\n    PathElement previous = pathElements.get(pathElements.size() - 2);\r\n    return getTypeAlias(previous.getType()) + UNDERSCORE + previous.getFieldName();\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.JdbcUtils.closeStatement",
	"Comment": "close the given jdbc statement and ignore any thrown exception.\tthis is useful for typical finally blocks in manual jdbc code.",
	"Method": "void closeStatement(Statement stmt){\r\n    if (stmt != null) {\r\n        try {\r\n            stmt.close();\r\n        } catch (SQLException ex) {\r\n            logger.trace(\"Could not close JDBC Statement\", ex);\r\n        } catch (Throwable ex) {\r\n            logger.trace(\"Unexpected exception on closing JDBC Statement\", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.managers.FormatterManager.readSettingsFromFile",
	"Comment": "read the available profiles from the internal xml file and return them as\tcollection or null if the file is not a profile file.",
	"Method": "Map<String, String> readSettingsFromFile(File file,String profileName){\r\n    try (FileInputStream reader = new FileInputStream(file)) {\r\n        return readSettingsFromStream(new InputSource(reader), profileName);\r\n    } catch (IOException e) {\r\n        throw new CoreException(new Status(IStatus.WARNING, IConstants.PLUGIN_ID, e.getMessage(), e));\r\n    }\r\n}"
}, {
	"Path": "org.dom4j.io.SAXContentHandler.setIncludeInternalDTDDeclarations",
	"Comment": "sets whether internal dtd declarations should be expanded into thedocumenttype object or not.",
	"Method": "void setIncludeInternalDTDDeclarations(boolean include){\r\n    this.includeInternalDTDDeclarations = include;\r\n}"
}, {
	"Path": "org.dom4j.io.DispatchHandler.resetHandlers",
	"Comment": "used to remove all the element handlers and return things back to the waythey were when object was created.",
	"Method": "void resetHandlers(){\r\n    atRoot = true;\r\n    path = \"/\";\r\n    pathStack.clear();\r\n    handlerStack.clear();\r\n    handlers.clear();\r\n    defaultHandler = null;\r\n}"
}, {
	"Path": "japa.parser.ast.CompilationUnit.getTypes",
	"Comment": "return the list of types declared in this compilation unit.if there is no types declared, null is returned.",
	"Method": "List<TypeDeclaration> getTypes(){\r\n    return types;\r\n}"
}, {
	"Path": "org.dom4j.samples.jaxp.RoundTripDemo.process",
	"Comment": "outputs the document to a buffer, parse it back again then output it",
	"Method": "void process(Document document){\r\n    System.out.println(\"about to output: \" + document);\r\n    StringWriter out = new StringWriter();\r\n    outputDocument(document, out);\r\n    Document doc2 = parseDocument(new StringReader(out.toString()));\r\n    System.out.println(\"parsed back again: \" + doc2);\r\n    System.out.println(\"Writing it out...\");\r\n    XMLWriter writer = new XMLWriter(System.out);\r\n    writer.write(doc2);\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.JdbcUtils.closeConnection",
	"Comment": "close the given jdbc connection and ignore any thrown exception.\tthis is useful for typical finally blocks in manual jdbc code.",
	"Method": "void closeConnection(Connection con){\r\n    if (con != null) {\r\n        try {\r\n            con.close();\r\n        } catch (SQLException ex) {\r\n            logger.debug(\"Could not close JDBC Connection\", ex);\r\n        } catch (Throwable ex) {\r\n            logger.debug(\"Unexpected exception on closing JDBC Connection\", ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.fix.CleanUpRequirements.requiresFreshAST",
	"Comment": "tells whether a fresh ast, containing all the changes from previous clean\tups, will be needed.",
	"Method": "boolean requiresFreshAST(){\r\n    return fRequiresFreshAST;\r\n}"
}, {
	"Path": "org.dom4j.io.SAXContentHandler.completeCurrentTextNode",
	"Comment": "if the current text buffer contains any text then create a new text nodewith it and add it to the current element",
	"Method": "void completeCurrentTextNode(){\r\n    if (stripWhitespaceText) {\r\n        boolean whitespace = true;\r\n        for (int i = 0, size = textBuffer.length(); i < size; i++) {\r\n            if (!Character.isWhitespace(textBuffer.charAt(i))) {\r\n                whitespace = false;\r\n                break;\r\n            }\r\n        }\r\n        if (!whitespace) {\r\n            currentElement.addText(textBuffer.toString());\r\n        }\r\n    } else {\r\n        currentElement.addText(textBuffer.toString());\r\n    }\r\n    textBuffer.setLength(0);\r\n    textInTextBuffer = false;\r\n}"
}, {
	"Path": "org.dom4j.tree.AbstractBranch.createResultList",
	"Comment": "a factory method pattern which creates a backedlist implementation usedto store results of a filtered content query.",
	"Method": "BackedList<T> createResultList(){\r\n    return new BackedList<T>(this, contentList());\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.AbstractJdbcCall.doExecute",
	"Comment": "method that provides execution of the call using the passed in map of parameters",
	"Method": "Map<String, Object> doExecute(SqlParameterSource parameterSource,Map<String, Object> doExecute,Object[] args,Map<String, Object> doExecute,Map<String, ?> args){\r\n    checkCompiled();\r\n    Map<String, ?> params = matchInParameterValuesWithCallParameters(args);\r\n    return executeCallInternal(params);\r\n}"
}, {
	"Path": "no.priv.garshol.duke.databases.InMemoryDatabase.isInMemory",
	"Comment": "returns true iff the database is held entirely in memory, andthus is not persistent.",
	"Method": "boolean isInMemory(){\r\n    return true;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.genetic.GeneticConfiguration.mateWith",
	"Comment": "mates this configuration with another configuration.randomlysets half the aspects of this configuration to those we alreadyhave, and the other half to those of the other configuration.",
	"Method": "void mateWith(GeneticConfiguration other){\r\n    for (Aspect aspect : aspects) if (Math.random() < 0.5)\r\n        aspect.setFromOther(this, other);\r\n}"
}, {
	"Path": "sx.blah.discord.util.EmbedBuilder.getTotalVisibleCharacters",
	"Comment": "gets the total number of characters that will be visible in the embed in the discord client.",
	"Method": "int getTotalVisibleCharacters(){\r\n    return (embed.title == null ? 0 : embed.title.length()) + (embed.description == null ? 0 : embed.description.length()) + (embed.footer == null ? 0 : (embed.footer.text == null ? 0 : embed.footer.text.length())) + (embed.author == null ? 0 : (embed.author.name == null ? 0 : embed.author.name.length())) + (fields.stream().mapToInt(efo -> (efo.name == null ? 0 : efo.name.length()) + (efo.value == null ? 0 : efo.value.length())).sum());\r\n}"
}, {
	"Path": "org.dom4j.io.DispatchHandler.removeHandler",
	"Comment": "removes the elementhandler from the event based processor,for the specified path.",
	"Method": "ElementHandler removeHandler(String handlerPath){\r\n    return handlers.remove(handlerPath);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.participants.ResourceModifications.addDelete",
	"Comment": "adds the given resource to the list of resources\tto be deleted.",
	"Method": "void addDelete(IResource delete){\r\n    if (fDelete == null)\r\n        fDelete = new ArrayList(2);\r\n    fDelete.add(delete);\r\n    if (fIgnoreCount == 0) {\r\n        internalAdd(new DeleteDescription(delete));\r\n    }\r\n}"
}, {
	"Path": "org.dom4j.io.XPPReader.addHandler",
	"Comment": "adds the elementhandler to be called when the specifiedpath is encounted.",
	"Method": "void addHandler(String path,ElementHandler handler){\r\n    getDispatchHandler().addHandler(path, handler);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.RefactoringScopeFactory.createReferencedScope",
	"Comment": "creates a new search scope with all projects possibly referenced from the\tgiven javaelements.",
	"Method": "IJavaSearchScope createReferencedScope(IJavaElement[] javaElements,IJavaSearchScope createReferencedScope,IJavaElement[] javaElements,int includeMask){\r\n    Set<IJavaProject> projects = new HashSet();\r\n    for (int i = 0; i < javaElements.length; i++) {\r\n        projects.add(javaElements[i].getJavaProject());\r\n    }\r\n    IJavaProject[] prj = projects.toArray(new IJavaProject[projects.size()]);\r\n    return SearchEngine.createJavaSearchScope(prj, includeMask);\r\n}"
}, {
	"Path": "org.dom4j.swing.XMLTableModel.getSource",
	"Comment": "getter for the xml source, which is usually a node or list of nodes.",
	"Method": "Object getSource(){\r\n    return source;\r\n}"
}, {
	"Path": "sx.blah.discord.util.PermissionUtils.getModifiedPermissions",
	"Comment": "gets the permissions a user has after applying specific and role overrides.",
	"Method": "EnumSet<Permissions> getModifiedPermissions(IUser user,IGuild guild,Cache<PermissionOverride> userOverrides,Cache<PermissionOverride> roleOverrides,EnumSet<Permissions> getModifiedPermissions,IRole role,Cache<PermissionOverride> roleOverrides){\r\n    EnumSet<Permissions> base = role.getPermissions();\r\n    PermissionOverride override = roleOverrides.get(role.getLongID());\r\n    if (override == null) {\r\n        if ((override = roleOverrides.get(role.getGuild().getEveryoneRole().getLongID())) == null)\r\n            return base;\r\n    }\r\n    base.addAll(new ArrayList(override.allow()));\r\n    override.deny().forEach(base::remove);\r\n    return base;\r\n}"
}, {
	"Path": "com.dslplatform.json.DslJson.canDeserialize",
	"Comment": "check if dsljson knows how to deserialize a type.\tit will check if a reader for such type exists or can be used.",
	"Method": "boolean canDeserialize(Type manifest){\r\n    if (tryFindReader(manifest) != null) {\r\n        return true;\r\n    }\r\n    if (manifest instanceof Class<?>) {\r\n        final Class<?> objectType = (Class<?>) manifest;\r\n        if (objectType.isArray()) {\r\n            return !objectType.getComponentType().isArray() && !Collection.class.isAssignableFrom(objectType.getComponentType()) && canDeserialize(objectType.getComponentType());\r\n        }\r\n    }\r\n    if (manifest instanceof ParameterizedType) {\r\n        final ParameterizedType pt = (ParameterizedType) manifest;\r\n        if (pt.getActualTypeArguments().length == 1) {\r\n            final Class<?> container = (Class<?>) pt.getRawType();\r\n            if (container.isArray() || Collection.class.isAssignableFrom(container)) {\r\n                final Type content = pt.getActualTypeArguments()[0];\r\n                if (tryFindReader(content) != null) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    } else if (manifest instanceof GenericArrayType) {\r\n        final Type content = ((GenericArrayType) manifest).getGenericComponentType();\r\n        return tryFindReader(content) != null;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.dcm4che3.data.Attributes.containsTagInRange",
	"Comment": "test whether at least one tag within the given range is contained.",
	"Method": "boolean containsTagInRange(int firstTag,int lastTag){\r\n    final int indexFirstTag = indexForInsertOf(firstTag);\r\n    if (indexFirstTag >= 0) {\r\n        return true;\r\n    }\r\n    int insertIndex = -indexFirstTag - 1;\r\n    return insertIndex < size && tags[insertIndex] <= lastTag;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.JdbcTemplate.isResultsMapCaseInsensitive",
	"Comment": "return whether execution of a callablestatement will return the results in a map\tthat uses case insensitive names for the parameters.",
	"Method": "boolean isResultsMapCaseInsensitive(){\r\n    return this.resultsMapCaseInsensitive;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.databases.LuceneDatabase.setBoostMode",
	"Comment": "tells the database to boost lucene fields when searching forcandidate matches, depending on their probabilities. this canhelp lucene better pick the most interesting candidates.",
	"Method": "void setBoostMode(BoostMode boost_mode){\r\n    this.boost_mode = boost_mode;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.nls.NLSUtil.getInsertionPosition",
	"Comment": "determine a good insertion position for key into the list of given\tkeys.",
	"Method": "int getInsertionPosition(String key,List<String> keys){\r\n    int result = 0;\r\n    int invertDistance = Integer.MIN_VALUE;\r\n    int i = 0;\r\n    for (Iterator<String> iterator = keys.iterator(); iterator.hasNext(); ) {\r\n        String string = iterator.next();\r\n        int currentInvertDistance = invertDistance(key, string);\r\n        if (currentInvertDistance > invertDistance) {\r\n            invertDistance = currentInvertDistance;\r\n            if (Collator.getInstance().compare(key, string) >= 0) {\r\n                result = i;\r\n            } else {\r\n                result = i - 1;\r\n            }\r\n        } else if (currentInvertDistance == invertDistance) {\r\n            if (Collator.getInstance().compare(key, string) >= 0) {\r\n                result = i;\r\n            }\r\n        }\r\n        i++;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.dom4j.tree.AbstractBranch.createEmptyList",
	"Comment": "a factory method pattern which creates an empty a backedlistimplementation",
	"Method": "List<T> createEmptyList(){\r\n    return new BackedList<T>(this, contentList(), 0);\r\n}"
}, {
	"Path": "com.yahoo.elide.graphql.GraphQLConversionUtils.attributeToQueryObject",
	"Comment": "helper function which converts an attribute of an entity to a graphql query type.",
	"Method": "GraphQLOutputType attributeToQueryObject(Class<?> parentClass,Class<?> attributeClass,String attribute,DataFetcher fetcher,GraphQLOutputType attributeToQueryObject,Class<?> parentClass,Class<?> attributeClass,String attribute,DataFetcher fetcher,EntityDictionary dictionary){\r\n    if (outputConversions.containsKey(attributeClass)) {\r\n        return outputConversions.get(attributeClass);\r\n    }\r\n    if (enumConversions.containsKey(attributeClass)) {\r\n        return enumConversions.get(attributeClass);\r\n    }\r\n    if (Class.class.isAssignableFrom(attributeClass)) {\r\n        return null;\r\n    }\r\n    if (Map.class.isAssignableFrom(attributeClass)) {\r\n        Class<?> keyType = dictionary.getParameterizedType(parentClass, attribute, 0);\r\n        Class<?> valueType = dictionary.getParameterizedType(parentClass, attribute, 1);\r\n        return classToQueryMap(keyType, valueType, fetcher);\r\n    } else if (Collection.class.isAssignableFrom(attributeClass)) {\r\n        Class<?> listType = dictionary.getParameterizedType(parentClass, attribute, 0);\r\n        return new GraphQLList(fetchScalarOrObjectOutput(listType, fetcher));\r\n    }\r\n    return fetchScalarOrObjectOutput(attributeClass, fetcher);\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.SqlUpdate.setRequiredRowsAffected",
	"Comment": "set the exact number of rows that must be affected by this update.\tthe default value is 0, which allows any number of rows to be affected.\tthis is an alternative to setting the maximum number of rows\tthat may be affected.",
	"Method": "void setRequiredRowsAffected(int requiredRowsAffected){\r\n    this.requiredRowsAffected = requiredRowsAffected;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.dom.fragments.AssociativeInfixExpressionFragment.getAssociatedNode",
	"Comment": "note that this fragment does not directly represent this node, but rather a\tparticular sort of part of its subtree.",
	"Method": "ASTNode getAssociatedNode(){\r\n    return fGroupRoot;\r\n}"
}, {
	"Path": "org.dom4j.io.STAXEventReader.createEntity",
	"Comment": "constructs a new dom4j entity from the provided stax entityreferenceevent.",
	"Method": "org.dom4j.Entity createEntity(EntityReference entityRef){\r\n    return factory.createEntity(entityRef.getName(), entityRef.getDeclaration().getReplacementText());\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.ChangeUtil.convertResourceChange",
	"Comment": "converts changes to resource operations if resource operations are supported\tby the client otherwise converts to textedit changes.",
	"Method": "void convertResourceChange(ResourceChange resourceChange,WorkspaceEdit edit){\r\n    if (!JavaLanguageServerPlugin.getPreferencesManager().getClientPreferences().isResourceOperationSupported()) {\r\n        return;\r\n    }\r\n    List<Either<TextDocumentEdit, ResourceOperation>> changes = edit.getDocumentChanges();\r\n    if (changes == null) {\r\n        changes = new LinkedList();\r\n        edit.setDocumentChanges(changes);\r\n    }\r\n    if (resourceChange instanceof RenameCompilationUnitChange) {\r\n        convertCUResourceChange(edit, (RenameCompilationUnitChange) resourceChange);\r\n    } else if (resourceChange instanceof RenamePackageChange) {\r\n        convertRenamePackcageChange(edit, (RenamePackageChange) resourceChange);\r\n    }\r\n}"
}, {
	"Path": "org.dcm4che3.net.ApplicationEntity.setAssociationInitiator",
	"Comment": "set whether or not this network ae can initiate associations.",
	"Method": "void setAssociationInitiator(boolean initiator){\r\n    this.initiator = initiator;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.DataSourceUtils.prepareConnectionForTransaction",
	"Comment": "prepare the given connection with the given transaction semantics.",
	"Method": "Integer prepareConnectionForTransaction(Connection con,TransactionDefinition definition){\r\n    Assert.notNull(con, \"No Connection specified\");\r\n    if (definition != null && definition.isReadOnly()) {\r\n        try {\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"Setting JDBC Connection [\" + con + \"] read-only\");\r\n            }\r\n            con.setReadOnly(true);\r\n        } catch (SQLException ex) {\r\n            Throwable exToCheck = ex;\r\n            while (exToCheck != null) {\r\n                if (exToCheck.getClass().getSimpleName().contains(\"Timeout\")) {\r\n                    throw ex;\r\n                }\r\n                exToCheck = exToCheck.getCause();\r\n            }\r\n            logger.debug(\"Could not set JDBC Connection read-only\", ex);\r\n        } catch (RuntimeException ex) {\r\n            Throwable exToCheck = ex;\r\n            while (exToCheck != null) {\r\n                if (exToCheck.getClass().getSimpleName().contains(\"Timeout\")) {\r\n                    throw ex;\r\n                }\r\n                exToCheck = exToCheck.getCause();\r\n            }\r\n            logger.debug(\"Could not set JDBC Connection read-only\", ex);\r\n        }\r\n    }\r\n    Integer previousIsolationLevel = null;\r\n    if (definition != null && definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Changing isolation level of JDBC Connection [\" + con + \"] to \" + definition.getIsolationLevel());\r\n        }\r\n        int currentIsolation = con.getTransactionIsolation();\r\n        if (currentIsolation != definition.getIsolationLevel()) {\r\n            previousIsolationLevel = currentIsolation;\r\n            con.setTransactionIsolation(definition.getIsolationLevel());\r\n        }\r\n    }\r\n    return previousIsolationLevel;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.search.text.TextSearchEngine.createPattern",
	"Comment": "creates a pattern for the given search string and the given options.",
	"Method": "Pattern createPattern(String pattern,boolean isCaseSensitive,boolean isRegex){\r\n    return PatternConstructor.createPattern(pattern, isRegex, true, isCaseSensitive, false);\r\n}"
}, {
	"Path": "com.yahoo.elide.core.PersistentResource.toResource",
	"Comment": "fetch a resource with support for lambda function for getting relationships and attributes.",
	"Method": "Resource toResource(Resource toResource,Supplier<Map<String, Relationship>> relationshipSupplier,Supplier<Map<String, Object>> attributeSupplier){\r\n    final Resource resource = new Resource(type, (obj == null) ? uuid.orElseThrow(() -> new InvalidEntityBodyException(\"No id found on object\")) : dictionary.getId(obj));\r\n    resource.setRelationships(relationshipSupplier.get());\r\n    resource.setAttributes(attributeSupplier.get());\r\n    return resource;\r\n}"
}, {
	"Path": "sx.blah.discord.api.internal.ReconnectManager.beginNewReconnect",
	"Comment": "starts the reconnect process for the next websocket in the queue.",
	"Method": "void beginNewReconnect(){\r\n    if (websockets.size() == 0)\r\n        throw new IllegalStateException(\"Attempt to begin reconnect process with no websockets in queue.\");\r\n    Discord4J.LOGGER.info(LogMarkers.RECONNECTS, \"Beginning reconnect for shard {}.\", websockets.peek().shard.getInfo()[0]);\r\n    performReconnect();\r\n}"
}, {
	"Path": "com.yahoo.elide.core.PersistentResource.getPermissionFilterExpression",
	"Comment": "get a filterexpression parsed from filterexpressioncheck.",
	"Method": "Optional<FilterExpression> getPermissionFilterExpression(Class<T> loadClass,RequestScope requestScope){\r\n    try {\r\n        return requestScope.getPermissionExecutor().getReadPermissionFilter(loadClass);\r\n    } catch (ForbiddenAccessException e) {\r\n        return Optional.empty();\r\n    }\r\n}"
}, {
	"Path": "com.yahoo.elide.core.EntityBinding.bindEntityFields",
	"Comment": "bind fields of an entity including the id field, attributes, and relationships.",
	"Method": "void bindEntityFields(Class<?> cls,String type,Collection<AccessibleObject> fieldOrMethodList){\r\n    for (AccessibleObject fieldOrMethod : fieldOrMethodList) {\r\n        bindTriggerIfPresent(OnCreatePreSecurity.class, fieldOrMethod);\r\n        bindTriggerIfPresent(OnDeletePreSecurity.class, fieldOrMethod);\r\n        bindTriggerIfPresent(OnUpdatePreSecurity.class, fieldOrMethod);\r\n        bindTriggerIfPresent(OnReadPreSecurity.class, fieldOrMethod);\r\n        bindTriggerIfPresent(OnCreatePreCommit.class, fieldOrMethod);\r\n        bindTriggerIfPresent(OnDeletePreCommit.class, fieldOrMethod);\r\n        bindTriggerIfPresent(OnUpdatePreCommit.class, fieldOrMethod);\r\n        bindTriggerIfPresent(OnReadPreCommit.class, fieldOrMethod);\r\n        bindTriggerIfPresent(OnCreatePostCommit.class, fieldOrMethod);\r\n        bindTriggerIfPresent(OnDeletePostCommit.class, fieldOrMethod);\r\n        bindTriggerIfPresent(OnUpdatePostCommit.class, fieldOrMethod);\r\n        bindTriggerIfPresent(OnReadPostCommit.class, fieldOrMethod);\r\n        if (fieldOrMethod.isAnnotationPresent(Id.class)) {\r\n            bindEntityId(cls, type, fieldOrMethod);\r\n        } else if (fieldOrMethod.isAnnotationPresent(Transient.class) && !fieldOrMethod.isAnnotationPresent(ComputedAttribute.class) && !fieldOrMethod.isAnnotationPresent(ComputedRelationship.class)) {\r\n            continue;\r\n        } else if (!fieldOrMethod.isAnnotationPresent(Exclude.class)) {\r\n            if (fieldOrMethod instanceof Field && Modifier.isTransient(((Field) fieldOrMethod).getModifiers())) {\r\n                continue;\r\n            }\r\n            if (fieldOrMethod instanceof Method && Modifier.isTransient(((Method) fieldOrMethod).getModifiers())) {\r\n                continue;\r\n            }\r\n            if (fieldOrMethod instanceof Field && !fieldOrMethod.isAnnotationPresent(Column.class) && Modifier.isStatic(((Field) fieldOrMethod).getModifiers())) {\r\n                continue;\r\n            }\r\n            bindAttrOrRelation(fieldOrMethod);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.dcm4che3.net.Connection.setDevice",
	"Comment": "set the device object that this network connection belongsto.",
	"Method": "void setDevice(Device device){\r\n    if (device != null && this.device != null)\r\n        throw new IllegalStateException(\"already owned by \" + device);\r\n    this.device = device;\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.JdbcAccessor.afterPropertiesSet",
	"Comment": "eagerly initialize the exception translator, if demanded,\tcreating a default one for the specified datasource if none set.",
	"Method": "void afterPropertiesSet(){\r\n    if (getDataSource() == null) {\r\n        throw new IllegalArgumentException(\"Property 'dataSource' is required\");\r\n    }\r\n    if (!isLazyInit()) {\r\n        getExceptionTranslator();\r\n    }\r\n}"
}, {
	"Path": "org.dom4j.io.STAXEventWriter.getEventFactory",
	"Comment": "returns a reference to the event factory used to construct stax events.",
	"Method": "XMLEventFactory getEventFactory(){\r\n    return factory;\r\n}"
}, {
	"Path": "org.dom4j.ThreadingTest.fetchValue",
	"Comment": "this method creates a value that can be expected during a test",
	"Method": "String fetchValue(QName qn){\r\n    String value = null;\r\n    StringBuffer sb = new StringBuffer();\r\n    sb.append(\"<\");\r\n    String prefix = qn.getNamespacePrefix();\r\n    if ((prefix != null) && (prefix.length() > 0)) {\r\n        sb.append(prefix).append(\":\");\r\n    }\r\n    sb.append(qn.getName());\r\n    String uri = qn.getNamespaceURI();\r\n    if ((uri != null) && (uri.length() > 0)) {\r\n        sb.append(\" xmlns\");\r\n        if ((prefix != null) && (prefix.length() > 0)) {\r\n            sb.append(\":\").append(prefix);\r\n        }\r\n        sb.append(\"=\\\"\").append(uri).append(\"\\\"\");\r\n    }\r\n    sb.append(\"/>\");\r\n    value = sb.toString();\r\n    return value;\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.BatchSqlUpdate.reset",
	"Comment": "reset the statement parameter queue, the rows affected cache,\tand the execution count.",
	"Method": "void reset(){\r\n    this.parameterQueue.clear();\r\n    this.rowsAffected.clear();\r\n}"
}, {
	"Path": "org.dom4j.Namespace.equals",
	"Comment": "checks whether this namespace equals the given namespace. two namespacesare equals if their uri and prefix are equal.",
	"Method": "boolean equals(Object object){\r\n    if (this == object) {\r\n        return true;\r\n    } else if (object instanceof Namespace) {\r\n        Namespace that = (Namespace) object;\r\n        if (hashCode() == that.hashCode()) {\r\n            return uri.equals(that.getURI()) && prefix.equals(that.getPrefix());\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corrections.NameMatcher.isSimilarName",
	"Comment": "returns a similarity value of the two names.\tthe range of is from 0 to 256. no similarity is negative",
	"Method": "boolean isSimilarName(String name1,String name2){\r\n    return getSimilarity(name1, name2) >= 0;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.CallableStatementCreatorFactory.setNativeJdbcExtractor",
	"Comment": "specify the nativejdbcextractor to use for unwrapping callablestatements, if any.",
	"Method": "void setNativeJdbcExtractor(NativeJdbcExtractor nativeJdbcExtractor){\r\n    this.nativeJdbcExtractor = nativeJdbcExtractor;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corrections.proposals.ASTRewriteCorrectionProposal.getRewrite",
	"Comment": "returns the rewrite that has been passed in the constructor. implementors can override this\tmethod to create the rewrite lazily. this method will only be called once.",
	"Method": "ASTRewrite getRewrite(){\r\n    if (fRewrite == null) {\r\n        IStatus status = StatusFactory.newErrorStatus(\"Rewrite not initialized\", null);\r\n        throw new CoreException(status);\r\n    }\r\n    return fRewrite;\r\n}"
}, {
	"Path": "sx.blah.discord.api.internal.DispatchHandler.handle",
	"Comment": "deserializes the given payload and passes it to the appropriate method depending on the event name.",
	"Method": "void handle(JsonNode event){\r\n    dispatchExecutor.submit(() -> {\r\n        boolean locked = false;\r\n        if (!client.isReady()) {\r\n            startupLock.lock();\r\n            locked = true;\r\n        }\r\n        try {\r\n            String type = event.get(\"t\").asText();\r\n            JsonNode json = event.get(\"d\");\r\n            switch(type) {\r\n                case \"RESUMED\":\r\n                    resumed();\r\n                    break;\r\n                case \"READY\":\r\n                    ready(MAPPER.treeToValue(json, ReadyResponse.class));\r\n                    break;\r\n                case \"MESSAGE_CREATE\":\r\n                    messageCreate(MAPPER.treeToValue(json, MessageObject.class));\r\n                    break;\r\n                case \"TYPING_START\":\r\n                    typingStart(MAPPER.treeToValue(json, TypingEventResponse.class));\r\n                    break;\r\n                case \"GUILD_CREATE\":\r\n                    guildCreate(MAPPER.treeToValue(json, GuildObject.class));\r\n                    break;\r\n                case \"GUILD_MEMBER_ADD\":\r\n                    guildMemberAdd(MAPPER.treeToValue(json, GuildMemberAddEventResponse.class));\r\n                    break;\r\n                case \"GUILD_MEMBER_REMOVE\":\r\n                    guildMemberRemove(MAPPER.treeToValue(json, GuildMemberRemoveEventResponse.class));\r\n                    break;\r\n                case \"GUILD_MEMBER_UPDATE\":\r\n                    guildMemberUpdate(MAPPER.treeToValue(json, GuildMemberUpdateEventResponse.class));\r\n                    break;\r\n                case \"MESSAGE_UPDATE\":\r\n                    messageUpdate(MAPPER.treeToValue(json, MessageObject.class));\r\n                    break;\r\n                case \"MESSAGE_DELETE\":\r\n                    messageDelete(MAPPER.treeToValue(json, MessageDeleteEventResponse.class));\r\n                    break;\r\n                case \"MESSAGE_DELETE_BULK\":\r\n                    messageDeleteBulk(MAPPER.treeToValue(json, MessageDeleteBulkEventResponse.class));\r\n                    break;\r\n                case \"PRESENCE_UPDATE\":\r\n                    presenceUpdate(MAPPER.treeToValue(json, PresenceUpdateEventResponse.class));\r\n                    break;\r\n                case \"GUILD_DELETE\":\r\n                    guildDelete(MAPPER.treeToValue(json, GuildObject.class));\r\n                    break;\r\n                case \"CHANNEL_CREATE\":\r\n                    channelCreate(MAPPER.treeToValue(json, ChannelObject.class));\r\n                    break;\r\n                case \"CHANNEL_DELETE\":\r\n                    channelDelete(MAPPER.treeToValue(json, ChannelObject.class));\r\n                    break;\r\n                case \"CHANNEL_PINS_UPDATE\":\r\n                    break;\r\n                case \"CHANNEL_PINS_ACK\":\r\n                    break;\r\n                case \"USER_UPDATE\":\r\n                    userUpdate(MAPPER.treeToValue(json, UserUpdateEventResponse.class));\r\n                    break;\r\n                case \"CHANNEL_UPDATE\":\r\n                    channelUpdate(MAPPER.treeToValue(json, ChannelObject.class));\r\n                    break;\r\n                case \"GUILD_MEMBERS_CHUNK\":\r\n                    guildMembersChunk(MAPPER.treeToValue(json, GuildMemberChunkEventResponse.class));\r\n                    break;\r\n                case \"GUILD_UPDATE\":\r\n                    guildUpdate(MAPPER.treeToValue(json, GuildObject.class));\r\n                    break;\r\n                case \"GUILD_ROLE_CREATE\":\r\n                    guildRoleCreate(MAPPER.treeToValue(json, GuildRoleEventResponse.class));\r\n                    break;\r\n                case \"GUILD_ROLE_UPDATE\":\r\n                    guildRoleUpdate(MAPPER.treeToValue(json, GuildRoleEventResponse.class));\r\n                    break;\r\n                case \"GUILD_ROLE_DELETE\":\r\n                    guildRoleDelete(MAPPER.treeToValue(json, GuildRoleDeleteEventResponse.class));\r\n                    break;\r\n                case \"GUILD_BAN_ADD\":\r\n                    guildBanAdd(MAPPER.treeToValue(json, GuildBanEventResponse.class));\r\n                    break;\r\n                case \"GUILD_BAN_REMOVE\":\r\n                    guildBanRemove(MAPPER.treeToValue(json, GuildBanEventResponse.class));\r\n                    break;\r\n                case \"GUILD_EMOJIS_UPDATE\":\r\n                    guildEmojisUpdate(MAPPER.treeToValue(json, GuildEmojiUpdateResponse.class));\r\n                    break;\r\n                case \"GUILD_INTEGRATIONS_UPDATE\":\r\n                    break;\r\n                case \"VOICE_STATE_UPDATE\":\r\n                    voiceStateUpdate(MAPPER.treeToValue(json, VoiceStateObject.class));\r\n                    break;\r\n                case \"VOICE_SERVER_UPDATE\":\r\n                    voiceServerUpdate(MAPPER.treeToValue(json, VoiceUpdateResponse.class));\r\n                    break;\r\n                case \"MESSAGE_REACTION_ADD\":\r\n                    reactionAdd(MAPPER.treeToValue(json, ReactionEventResponse.class));\r\n                    break;\r\n                case \"MESSAGE_REACTION_REMOVE\":\r\n                    reactionRemove(MAPPER.treeToValue(json, ReactionEventResponse.class));\r\n                    break;\r\n                case \"MESSAGE_REACTION_REMOVE_ALL\":\r\n                    break;\r\n                case \"WEBHOOKS_UPDATE\":\r\n                    webhookUpdate(MAPPER.treeToValue(json, WebhookObject.class));\r\n                    break;\r\n                case \"PRESENCES_REPLACE\":\r\n                    break;\r\n                default:\r\n                    Discord4J.LOGGER.warn(LogMarkers.WEBSOCKET, \"Unknown message received: {}, REPORT THIS TO THE DISCORD4J DEV!\", type);\r\n            }\r\n        } catch (Exception e) {\r\n            Discord4J.LOGGER.error(LogMarkers.WEBSOCKET, \"Unable to process JSON!\", e);\r\n        } finally {\r\n            if (locked)\r\n                startupLock.unlock();\r\n        }\r\n    });\r\n}"
}, {
	"Path": "sx.blah.discord.util.RequestBuilder.elseDo",
	"Comment": "sets the new active action which will be executed after the current one succeeds.\tthis new action cannot have a following action, the following action would occur after the current one\tsucceeds.",
	"Method": "RequestBuilder elseDo(IRequestAction action){\r\n    actions.add(activeAction);\r\n    activeAction = new Action();\r\n    activeAction.mode = ActionMode.ELSE;\r\n    return doAction(action);\r\n}"
}, {
	"Path": "org.dom4j.io.STAXEventWriter.getConsumer",
	"Comment": "returns a reference to the underlying event consumer to which events arewritten.",
	"Method": "XMLEventConsumer getConsumer(){\r\n    return consumer;\r\n}"
}, {
	"Path": "org.dcm4che3.net.ApplicationEntity.isAssociationAcceptor",
	"Comment": "determine whether or not this network ae can accept associations.",
	"Method": "boolean isAssociationAcceptor(){\r\n    return acceptor;\r\n}"
}, {
	"Path": "com.yahoo.elide.standalone.config.ElideStandaloneSettings.enableJSONAPI",
	"Comment": "enable the jsonapi endpoint. if false, the endpoint will be disabled.",
	"Method": "boolean enableJSONAPI(){\r\n    return true;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.participants.ResourceModifications.willExist",
	"Comment": "checks if the resource will exist in the future based on\tthe recorded resource modifications.",
	"Method": "boolean willExist(IResource resource){\r\n    if (fDeltaDescriptions == null)\r\n        return false;\r\n    IPath fullPath = resource.getFullPath();\r\n    for (Iterator<DeltaDescription> iter = fDeltaDescriptions.iterator(); iter.hasNext(); ) {\r\n        DeltaDescription delta = iter.next();\r\n        if (fullPath.equals(delta.getDestinationPath()))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.StatementCreatorUtils.isStringValue",
	"Comment": "check whether the given value can be treated as a string value.",
	"Method": "boolean isStringValue(Class<?> inValueType){\r\n    return (CharSequence.class.isAssignableFrom(inValueType) || StringWriter.class.isAssignableFrom(inValueType));\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder.addScripts",
	"Comment": "add multiple sql scripts to execute to initialize or populate the database.",
	"Method": "EmbeddedDatabaseBuilder addScripts(String scripts){\r\n    for (String script : scripts) {\r\n        addScript(script);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.dom4j.io.DispatchHandler.addHandler",
	"Comment": "adds the elementhandler to be called when the specifiedpath is encounted.",
	"Method": "void addHandler(String handlerPath,ElementHandler handler){\r\n    handlers.put(handlerPath, handler);\r\n}"
}, {
	"Path": "com.ea.async.test.BaseTest.getBlockedFuture",
	"Comment": "creates and an uncompleted future and adds it the the queue for later completion.to help with the tests",
	"Method": "CompletableFuture<T> getBlockedFuture(T value,CompletableFuture<T> getBlockedFuture){\r\n    return getBlockedFuture(null);\r\n}"
}, {
	"Path": "org.dcm4che3.imageio.codec.mpeg.MPEGHeader.toAttributes",
	"Comment": "return corresponding image pixel description macro attributes",
	"Method": "Attributes toAttributes(Attributes attrs,long length){\r\n    if (seqHeaderOffset == -1)\r\n        return null;\r\n    if (attrs == null)\r\n        attrs = new Attributes(15);\r\n    int off = seqHeaderOffset;\r\n    int x = ((data[off + 1] & 0xFF) << 4) | ((data[off + 2] & 0xF0) >> 4);\r\n    int y = ((data[off + 2] & 0x0F) << 8) | (data[off + 3] & 0xFF);\r\n    int aspectRatio = (data[off + 4] >> 4) & 0x0F;\r\n    int frameRate = data[off + 4] & 0x0F;\r\n    int bitRate = ((data[off + 5] & 0xFF) << 10) | ((data[off + 6] & 0xFF) << 2) | ((data[off + 7] & 0xC0) >> 6);\r\n    int numFrames = 9999;\r\n    if (frameRate > 0 && frameRate < 9) {\r\n        int frameRate2 = (frameRate - 1) << 1;\r\n        attrs.setInt(Tag.CineRate, VR.IS, FPS[frameRate2]);\r\n        attrs.setFloat(Tag.FrameTime, VR.DS, ((float) FPS[frameRate2 + 1]) / FPS[frameRate2]);\r\n        if (bitRate > 0)\r\n            numFrames = (int) (20 * length * FPS[frameRate2] / FPS[frameRate2 + 1] / bitRate);\r\n    }\r\n    attrs.setInt(Tag.SamplesPerPixel, VR.US, 3);\r\n    attrs.setString(Tag.PhotometricInterpretation, VR.CS, \"YBR_PARTIAL_420\");\r\n    attrs.setInt(Tag.PlanarConfiguration, VR.US, 0);\r\n    attrs.setInt(Tag.FrameIncrementPointer, VR.AT, Tag.FrameTime);\r\n    attrs.setInt(Tag.NumberOfFrames, VR.IS, numFrames);\r\n    attrs.setInt(Tag.Rows, VR.US, y);\r\n    attrs.setInt(Tag.Columns, VR.US, x);\r\n    if (aspectRatio > 0 && aspectRatio < 5)\r\n        attrs.setString(Tag.PixelAspectRatio, VR.IS, ASPECT_RATIOS[aspectRatio - 1]);\r\n    attrs.setInt(Tag.BitsAllocated, VR.US, 8);\r\n    attrs.setInt(Tag.BitsStored, VR.US, 8);\r\n    attrs.setInt(Tag.HighBit, VR.US, 7);\r\n    attrs.setInt(Tag.PixelRepresentation, VR.US, 0);\r\n    attrs.setString(Tag.LossyImageCompression, VR.CS, \"01\");\r\n    return attrs;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.SingleConnectionDataSource.initConnection",
	"Comment": "initialize the underlying connection via the drivermanager.",
	"Method": "void initConnection(){\r\n    if (getUrl() == null) {\r\n        throw new IllegalStateException(\"'url' property is required for lazily initializing a Connection\");\r\n    }\r\n    synchronized (this.connectionMonitor) {\r\n        closeConnection();\r\n        this.target = getConnectionFromDriver(getUsername(), getPassword());\r\n        prepareConnection(this.target);\r\n        if (logger.isInfoEnabled()) {\r\n            logger.info(\"Established shared JDBC Connection: \" + this.target);\r\n        }\r\n        this.connection = (isSuppressClose() ? getCloseSuppressingConnectionProxy(this.target) : this.target);\r\n    }\r\n}"
}, {
	"Path": "japa.parser.ast.CompilationUnit.getImports",
	"Comment": "retrieves the list of imports declared in this compilation unit ornull if there is no import.",
	"Method": "List<ImportDeclaration> getImports(){\r\n    return imports;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.filter.dialect.MultipleFilterDialectTest.testGlobalExpressionParseFailure",
	"Comment": "verify that the last error is returned when all dialects fail.",
	"Method": "void testGlobalExpressionParseFailure(){\r\n    JoinFilterDialect dialect1 = mock(JoinFilterDialect.class);\r\n    JoinFilterDialect dialect2 = mock(JoinFilterDialect.class);\r\n    MultipleFilterDialect dialect = new MultipleFilterDialect(Lists.newArrayList(dialect1, dialect2), Collections.EMPTY_LIST);\r\n    MultivaluedMap<String, String> queryParams = new MultivaluedHashMap();\r\n    queryParams.add(\"filter[author.books.title][in]\", \"foo,bar,baz\");\r\n    queryParams.add(\"filter[author.name][infix]\", \"Hemingway\");\r\n    when(dialect1.parseGlobalExpression(\"/author\", queryParams)).thenThrow(new ParseException(\"one\"));\r\n    when(dialect2.parseGlobalExpression(\"/author\", queryParams)).thenThrow(new ParseException(\"two\"));\r\n    try {\r\n        dialect.parseGlobalExpression(\"/author\", queryParams);\r\n    } catch (ParseException e) {\r\n        Assert.assertEquals(e.getMessage(), \"two\\none\");\r\n    }\r\n}"
}, {
	"Path": "org.dom4j.datatype.SchemaParser.onSchemaError",
	"Comment": "called when there is a problem with the schema and the builder cannothandle the xml schema data types correctly",
	"Method": "void onSchemaError(String message){\r\n    throw new InvalidSchemaException(message);\r\n}"
}, {
	"Path": "japa.parser.ast.CompilationUnit.setImports",
	"Comment": "sets the list of imports of this compilation unit. the list is initiallynull.",
	"Method": "void setImports(List<ImportDeclaration> imports){\r\n    this.imports = imports;\r\n    setAsParentNodeOf(this.imports);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcDaoSupport.getNamedParameterJdbcTemplate",
	"Comment": "return a namedparameterjdbctemplate wrapping the configured jdbctemplate.",
	"Method": "NamedParameterJdbcTemplate getNamedParameterJdbcTemplate(){\r\n    return namedParameterJdbcTemplate;\r\n}"
}, {
	"Path": "sx.blah.discord.util.MessageTokenizer.nextEmoji",
	"Comment": "gets the next custom emoji in the content and moves the pointer forward.",
	"Method": "CustomEmojiToken nextEmoji(){\r\n    if (!hasNextEmoji())\r\n        throw new IllegalStateException(\"No more custom server emojis found!\");\r\n    Token t = nextRegex(CUSTOM_EMOJI_PATTERN);\r\n    final int lessThan = t.getStartIndex();\r\n    final int greaterThan = t.getEndIndex();\r\n    return new CustomEmojiToken(this, lessThan, greaterThan);\r\n}"
}, {
	"Path": "sx.blah.discord.util.MessageTokenizer.nextChar",
	"Comment": "gets the next character in the content and moves the pointer forward.",
	"Method": "char nextChar(){\r\n    if (!hasNextChar())\r\n        throw new IllegalStateException(\"Reached end of string!\");\r\n    char c = content.charAt(currentPosition);\r\n    stepForward(1);\r\n    return c;\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.lob.LobCreatorUtils.registerTransactionSynchronization",
	"Comment": "register a transaction synchronization for closing the given lobcreator,\tpreferring spring transaction synchronization and falling back to\tplain jta transaction synchronization.",
	"Method": "void registerTransactionSynchronization(LobCreator lobCreator,TransactionManager jtaTransactionManager){\r\n    if (TransactionSynchronizationManager.isSynchronizationActive()) {\r\n        logger.debug(\"Registering Spring transaction synchronization for LobCreator\");\r\n        TransactionSynchronizationManager.registerSynchronization(new SpringLobCreatorSynchronization(lobCreator));\r\n    } else {\r\n        if (jtaTransactionManager != null) {\r\n            try {\r\n                int jtaStatus = jtaTransactionManager.getStatus();\r\n                if (jtaStatus == Status.STATUS_ACTIVE || jtaStatus == Status.STATUS_MARKED_ROLLBACK) {\r\n                    logger.debug(\"Registering JTA transaction synchronization for LobCreator\");\r\n                    jtaTransactionManager.getTransaction().registerSynchronization(new JtaLobCreatorSynchronization(lobCreator));\r\n                    return;\r\n                }\r\n            } catch (Throwable ex) {\r\n                throw new TransactionSystemException(\"Could not register synchronization with JTA TransactionManager\", ex);\r\n            }\r\n        }\r\n        throw new IllegalStateException(\"Active Spring transaction synchronization or active \" + \"JTA transaction with specified [javax.transaction.TransactionManager] required\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.getSqlErrorCodes",
	"Comment": "return the error codes used by this translator.\tusually determined via a datasource.",
	"Method": "SQLErrorCodes getSqlErrorCodes(){\r\n    return this.sqlErrorCodes;\r\n}"
}, {
	"Path": "org.dom4j.dtd.ExternalEntityDeclTest.testSystemId",
	"Comment": "tests external entity declaration using only the system identifier.",
	"Method": "void testSystemId(){\r\n    String expectedName = \"anEntity\";\r\n    String expectedPublicID = null;\r\n    String expectedSystemID = \"http://www.myorg.org/foo\";\r\n    String expectedText = \"<!ENTITY anEntity \" + \"SYSTEM \\\"http://www.myorg.org/foo\\\" >\";\r\n    ExternalEntityDecl actual = new ExternalEntityDecl(expectedName, expectedPublicID, expectedSystemID);\r\n    assertEquals(\"name is correct\", expectedName, actual.getName());\r\n    assertEquals(\"publicID is correct\", expectedPublicID, actual.getPublicID());\r\n    assertEquals(\"systemID is correct\", expectedSystemID, actual.getSystemID());\r\n    assertEquals(\"toString() is correct\", expectedText, actual.toString());\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.SimpleDriverDataSource.setDriverClass",
	"Comment": "specify the jdbc driver implementation class to use.\tan instance of this driver class will be created and held\twithin the simpledriverdatasource.",
	"Method": "void setDriverClass(Class<? extends Driver> driverClass){\r\n    this.driver = BeanUtils.instantiateClass(driverClass);\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.UserCredentialsDataSourceAdapter.removeCredentialsFromCurrentThread",
	"Comment": "remove any user credentials for this proxy from the current thread.\tstatically specified user credentials apply again afterwards.",
	"Method": "void removeCredentialsFromCurrentThread(){\r\n    this.threadBoundCredentials.remove();\r\n}"
}, {
	"Path": "org.dom4j.DocumentFactory.setXPathNamespaceURIs",
	"Comment": "sets the namespace uris to be used by xpath expressions created by thisfactory or by nodes associated with this factory. the keys are namespaceprefixes and the values are namespace uris.",
	"Method": "void setXPathNamespaceURIs(Map<String, String> namespaceURIs){\r\n    this.xpathNamespaceURIs = namespaceURIs;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.databases.MapDBBlockingDatabase.setCacheSize",
	"Comment": "sets the size of the mapdb instance cache. bigger values givebetter speed, but require more memory. default is 32768.",
	"Method": "void setCacheSize(int cache_size){\r\n    this.cache_size = cache_size;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.PersistentResource.checkRelation",
	"Comment": "check the permissions of the relationship, and return true or false.",
	"Method": "boolean checkRelation(String relationName){\r\n    List<String> relations = dictionary.getRelationships(obj);\r\n    String realName = dictionary.getNameFromAlias(obj, relationName);\r\n    relationName = (realName == null) ? relationName : realName;\r\n    if (relationName == null || relations == null || !relations.contains(relationName)) {\r\n        throw new InvalidAttributeException(relationName, type);\r\n    }\r\n    checkFieldAwareDeferPermissions(ReadPermission.class, relationName, null, null);\r\n    return !shouldSkipCollection(dictionary.getParameterizedType(obj, relationName), ReadPermission.class, requestScope);\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.SqlQuery.execute",
	"Comment": "convenient method to execute with a single string parameter.",
	"Method": "List<T> execute(Object[] params,Map<?, ?> context,List<T> execute,Object params,List<T> execute,Map<?, ?> context,List<T> execute,List<T> execute,int p1,Map<?, ?> context,List<T> execute,int p1,List<T> execute,int p1,int p2,Map<?, ?> context,List<T> execute,int p1,int p2,List<T> execute,long p1,Map<?, ?> context,List<T> execute,long p1,List<T> execute,String p1,Map<?, ?> context,List<T> execute,String p1){\r\n    return execute(p1, null);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.RefactoringSearchEngine2.setFiltering",
	"Comment": "determines how search matches are filtered.\tthis method must be called before start searching. the default is to filter inaccurate matches only.",
	"Method": "void setFiltering(boolean inaccurate,boolean binary){\r\n    fInaccurate = inaccurate;\r\n    fBinary = binary;\r\n}"
}, {
	"Path": "sx.blah.discord.util.BotInviteBuilder.build",
	"Comment": "builds the invite url with the configuration specified by the builder.",
	"Method": "String build(){\r\n    String url = DiscordEndpoints.AUTHORIZE + \"?client_id=%s&scope=bot\";\r\n    if (permissions != null)\r\n        url += \"&permissions=\" + Permissions.generatePermissionsNumber(permissions);\r\n    if (guild != null)\r\n        url += \"&guild_id=\" + guild.getStringID();\r\n    try {\r\n        return String.format(url, clientIDOverride == null ? client.getApplicationClientID() : clientIDOverride);\r\n    } catch (DiscordException e) {\r\n        Discord4J.LOGGER.error(LogMarkers.UTIL, \"Discord4J Internal Exception\", e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.dragonet.common.maths.ChunkPos.getBlockInChunk",
	"Comment": "get the chunk coordinates of the block with the given world coordinatesrelative to this chunk",
	"Method": "BlockPosition getBlockInChunk(int x,int y,int z){\r\n    BlockPosition pos = new BlockPosition(x % 16, y % 16, z % 16);\r\n    if (pos.x < 0)\r\n        pos.x = -pos.x;\r\n    if (pos.y < 0)\r\n        pos.y = -pos.y;\r\n    if (pos.z < 0)\r\n        pos.z = -pos.z;\r\n    return pos;\r\n}"
}, {
	"Path": "org.dom4j.tree.DefaultNamespace.equals",
	"Comment": "implements an identity based comparsion using the parent element as wellas the prefix and uri",
	"Method": "boolean equals(Object object){\r\n    if (object instanceof DefaultNamespace) {\r\n        DefaultNamespace that = (DefaultNamespace) object;\r\n        if (that.parent == parent) {\r\n            return super.equals(object);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.github.devnied.emvnfccard.parser.EmvParser.extractAfl",
	"Comment": "extract list of application file locator from afl response",
	"Method": "List<Afl> extractAfl(byte[] pAfl){\r\n    List<Afl> list = new ArrayList<Afl>();\r\n    ByteArrayInputStream bai = new ByteArrayInputStream(pAfl);\r\n    while (bai.available() >= 4) {\r\n        Afl afl = new Afl();\r\n        afl.setSfi(bai.read() >> 3);\r\n        afl.setFirstRecord(bai.read());\r\n        afl.setLastRecord(bai.read());\r\n        afl.setOfflineAuthentication(bai.read() == 1);\r\n        list.add(afl);\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "sx.blah.discord.SpoofBot.canBeRandomized",
	"Comment": "checks if the class is supported to be randomized without recursion.",
	"Method": "boolean canBeRandomized(Class clazz){\r\n    return ClassUtils.isPrimitiveOrWrapper(clazz) || clazz.equals(String.class) || clazz.equals(IDiscordClient.class);\r\n}"
}, {
	"Path": "com.ea.async.test.BaseTest.completeFutures",
	"Comment": "complete all the blocked futures, even new ones created while executing this method",
	"Method": "void completeFutures(){\r\n    while (blockedFutures.size() > 0) {\r\n        final Pair<CompletableFuture, Object> pair = blockedFutures.poll();\r\n        if (pair != null) {\r\n            pair.getKey().complete(pair.getValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.dom4j.io.StaxTest.testEncoding",
	"Comment": "tests that the encoding specified in the xml declaration is exposed inthe document read via stax, and also that it gets output when writing.",
	"Method": "void testEncoding(){\r\n    try {\r\n        XMLInputFactory.newInstance();\r\n    } catch (javax.xml.stream.FactoryConfigurationError e) {\r\n        return;\r\n    }\r\n    try {\r\n        File file = getFile(\"/xml/russArticle.xml\");\r\n        STAXEventReader xmlReader = new STAXEventReader();\r\n        Document doc = xmlReader.readDocument(new FileReader(file));\r\n        assertEquals(\"russArticle.xml encoding wasn't correct\", \"koi8-r\", doc.getXMLEncoding());\r\n        StringWriter writer = new StringWriter();\r\n        STAXEventWriter xmlWriter = new STAXEventWriter(writer);\r\n        xmlWriter.writeDocument(doc);\r\n        String output = writer.toString();\r\n        String xmlDecl = output.substring(0, output.indexOf(\"?>\") + 2);\r\n        String expected = \"<?xml version=\\'1.0\\' encoding=\\'koi8-r\\'?>\";\r\n        assertEquals(\"Unexpected xml declaration\", expected, xmlDecl);\r\n        System.out.println(output);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        fail(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.dslplatform.json.DslJson.deserialize",
	"Comment": "deserialize api for working with bytes.\tdeserialize provided byte input into target object.\tsince json is often though of as a series of char,\tmost libraries will convert inputs into a sequence of chars and do processing on them.\tdsljson will treat input as a sequence of bytes which allows for various optimizations.",
	"Method": "Object deserialize(TContext context,Type manifest,byte[] body,int size,Object deserialize,TContext context,Type manifest,InputStream stream,T deserialize,JsonReader.ReadObject<T> converter,JsonReader<TContext> input,TResult deserialize,Class<TResult> manifest,byte[] body,int size,Object deserialize,Type manifest,byte[] body,int size,TResult deserialize,Class<TResult> manifest,InputStream stream,byte[] buffer,TResult deserialize,Class<TResult> manifest,InputStream stream,TResult deserialize,Class<TResult> manifest,JsonReader json,InputStream stream,Object deserialize,Type manifest,InputStream stream,byte[] buffer,Object deserialize,Type manifest,InputStream stream){\r\n    if (manifest instanceof Class<?>) {\r\n        return deserialize((Class<?>) manifest, stream);\r\n    }\r\n    if (manifest == null) {\r\n        throw new IllegalArgumentException(\"manifest can't be null\");\r\n    }\r\n    if (stream == null) {\r\n        throw new IllegalArgumentException(\"stream can't be null\");\r\n    }\r\n    final JsonReader json = localReader.get().process(stream);\r\n    try {\r\n        json.getNextToken();\r\n        final Object result = deserializeWith(manifest, json);\r\n        if (result != unknownValue)\r\n            return result;\r\n        if (fallback != null) {\r\n            return fallback.deserialize(context, manifest, new RereadStream(json.buffer, stream));\r\n        }\r\n        throw new IOException(\"Unable to find reader for provided type: \" + manifest + \" and fallback serialization is not registered.\\n\" + \"Try initializing DslJson with custom fallback in case of unsupported objects or register specified type using registerReader into \" + getClass());\r\n    } finally {\r\n        json.reset();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.CallMetaDataContext.getCallParameters",
	"Comment": "get the list of sqlparameter objects to be used in call execution.",
	"Method": "List<SqlParameter> getCallParameters(){\r\n    return this.callParameters;\r\n}"
}, {
	"Path": "org.dcm4che3.net.Connection.isInstalled",
	"Comment": "true if the network connection is installed on the network. if notpresent, information about the installed status of the network connectionis inherited from the device.",
	"Method": "boolean isInstalled(){\r\n    return device != null && device.isInstalled() && (installed == null || installed.booleanValue());\r\n}"
}, {
	"Path": "no.priv.garshol.duke.genetic.GeneticConfiguration.getRank",
	"Comment": "returns the ranking of this configuration within its generation.1 means it was the best.",
	"Method": "int getRank(){\r\n    return rank;\r\n}"
}, {
	"Path": "japa.parser.ast.CompilationUnit.setPackage",
	"Comment": "sets or clear the package declarations of this compilation unit.",
	"Method": "void setPackage(PackageDeclaration pakage){\r\n    this.pakage = pakage;\r\n    setAsParentNodeOf(this.pakage);\r\n}"
}, {
	"Path": "denominator.model.rdata.SOAData.retry",
	"Comment": "time interval that should elapse before a failed refresh should be retried",
	"Method": "int retry(SOAData.Builder retry,int retry){\r\n    return Integer.class.cast(get(\"retry\"));\r\n}"
}, {
	"Path": "sx.blah.discord.api.internal.DiscordWS.invalidate",
	"Comment": "invalidates all information of this connection and associated shard.",
	"Method": "void invalidate(){\r\n    this.isReady = false;\r\n    this.hasReceivedReady = false;\r\n    this.seq = 0;\r\n    this.sessionId = null;\r\n    this.shard.guildCache.clear();\r\n    this.shard.privateChannels.clear();\r\n}"
}, {
	"Path": "sx.blah.discord.handle.impl.obj.ReactionEmoji.getName",
	"Comment": "gets the name of the emoji. if the emoji is a unicode emoji, it returns the unicode character.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "sx.blah.discord.handle.impl.obj.Role.setPermissions",
	"Comment": "sets the cached permissions by the raw permissions number.",
	"Method": "void setPermissions(int permissions){\r\n    this.permissions = Permissions.getAllowedPermissionsForNumber(permissions);\r\n}"
}, {
	"Path": "japa.parser.JavaParser.insertCommentsInCu",
	"Comment": "comments are attributed to the thing the comment and are removed fromallcomments.",
	"Method": "void insertCommentsInCu(CompilationUnit cu,CommentsCollection commentsCollection){\r\n    if (commentsCollection.size() == 0)\r\n        return;\r\n    List<Comment> comments = commentsCollection.getAll();\r\n    sortByBeginPosition(comments);\r\n    List<Node> children = cu.getChildrenNodes();\r\n    sortByBeginPosition(children);\r\n    if (cu.getPackage() != null && (children.size() == 0 || areInOrder(comments.get(0), children.get(0)))) {\r\n        cu.setComment(comments.get(0));\r\n        comments.remove(0);\r\n    }\r\n    insertCommentsInNode(cu, comments);\r\n}"
}, {
	"Path": "org.dom4j.GetQNamesTest.testRename",
	"Comment": "test the element rename functionality which was lacking as spotted by roblebowitz",
	"Method": "void testRename(){\r\n    Document doc = DocumentHelper.createDocument();\r\n    Element root = doc.addElement(\"foo\");\r\n    assertEquals(\"named correctly\", \"foo\", root.getName());\r\n    root.setName(\"bar\");\r\n    assertEquals(\"named correctly\", \"bar\", root.getName());\r\n    QName xyz = root.getQName(\"xyz\");\r\n    root.setQName(xyz);\r\n    assertEquals(\"QNamed correctly\", xyz, root.getQName());\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.util.TextChangeManager.manage",
	"Comment": "adds an association between the given compilation unit and the passed\tchange to this manager.",
	"Method": "void manage(ICompilationUnit cu,TextChange change){\r\n    fMap.put(cu, change);\r\n}"
}, {
	"Path": "org.dom4j.io.STAXEventReader.createElement",
	"Comment": "constructs a new dom4j element from the provided startelement event. allattributes and namespaces will be added to the returned element.",
	"Method": "Element createElement(StartElement startEvent){\r\n    QName qname = startEvent.getName();\r\n    org.dom4j.QName elemName = createQName(qname);\r\n    Element elem = factory.createElement(elemName);\r\n    for (Iterator<Attribute> i = startEvent.getAttributes(); i.hasNext(); ) {\r\n        Attribute attr = i.next();\r\n        elem.addAttribute(createQName(attr.getName()), attr.getValue());\r\n    }\r\n    for (Iterator<Namespace> i = startEvent.getNamespaces(); i.hasNext(); ) {\r\n        Namespace ns = i.next();\r\n        elem.addNamespace(ns.getPrefix(), ns.getNamespaceURI());\r\n    }\r\n    return elem;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.code.ExtractMethodRefactoring.checkInitialConditions",
	"Comment": "checks if the refactoring can be activated. activation typically means,\tif a corresponding menu entry can be added to the ui.",
	"Method": "RefactoringStatus checkInitialConditions(IProgressMonitor pm){\r\n    RefactoringStatus result = new RefactoringStatus();\r\n    pm.beginTask(\"\", 100);\r\n    if (fSelectionStart < 0 || fSelectionLength == 0) {\r\n        return mergeTextSelectionStatus(result);\r\n    }\r\n    IFile[] changedFiles = ResourceUtil.getFiles(new ICompilationUnit[] { fCUnit });\r\n    result.merge(Checks.validateModifiesFiles(changedFiles, getValidationContext()));\r\n    if (result.hasFatalError()) {\r\n        return result;\r\n    }\r\n    result.merge(ResourceChangeChecker.checkFilesToBeChanged(changedFiles, new SubProgressMonitor(pm, 1)));\r\n    if (fRoot == null) {\r\n        fRoot = RefactoringASTParser.parseWithASTProvider(fCUnit, true, new SubProgressMonitor(pm, 99));\r\n    }\r\n    fImportRewriter = CodeStyleConfiguration.createImportRewrite(fRoot, true);\r\n    fAST = fRoot.getAST();\r\n    fRoot.accept(createVisitor());\r\n    fSelectionStart = fAnalyzer.getSelection().getOffset();\r\n    fSelectionLength = fAnalyzer.getSelection().getLength();\r\n    result.merge(fAnalyzer.checkInitialConditions(fImportRewriter));\r\n    if (result.hasFatalError()) {\r\n        return result;\r\n    }\r\n    if (fVisibility == -1) {\r\n        setVisibility(Modifier.PRIVATE);\r\n    }\r\n    initializeParameterInfos();\r\n    initializeUsedNames();\r\n    initializeDuplicates();\r\n    initializeDestinations();\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulator.addScript",
	"Comment": "add a script to execute to initialize or clean up the database.",
	"Method": "void addScript(Resource script){\r\n    Assert.notNull(script, \"Script must not be null\");\r\n    getScripts().add(script);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.AbstractJdbcCall.getCallParameters",
	"Comment": "get a list of all the call parameters to be used for call. this includes any parameters added\tbased on meta data processing.",
	"Method": "List<SqlParameter> getCallParameters(){\r\n    return this.callMetaDataContext.getCallParameters();\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.SQLErrorCodes.setDatabaseProductNames",
	"Comment": "set this property to specify multiple database names that contains spaces,\tin which case we can not use bean names for lookup.",
	"Method": "void setDatabaseProductNames(String[] databaseProductNames){\r\n    this.databaseProductNames = databaseProductNames;\r\n}"
}, {
	"Path": "org.dom4j.samples.RoundTripDemo.process",
	"Comment": "outputs the document to a buffer, parse it back again then output it",
	"Method": "void process(Document document){\r\n    System.out.println(\"about to output: \" + document);\r\n    StringWriter out = new StringWriter();\r\n    XMLWriter writer = new XMLWriter(out);\r\n    writer.write(document);\r\n    writer.close();\r\n    StringReader in = new StringReader(out.toString());\r\n    SAXReader reader = new SAXReader();\r\n    Document doc2 = reader.read(in);\r\n    System.out.println(\"parsed back again: \" + doc2);\r\n    writer.setOutputStream(System.out);\r\n    writer.write(doc2);\r\n}"
}, {
	"Path": "org.dragonet.proxy.network.cache.WindowCache.cacheWindow",
	"Comment": "we do not do translations here, do it in inventorytranslatorregister",
	"Method": "void cacheWindow(CachedWindow win){\r\n    windows.put(win.windowId, win);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.AbstractJdbcInsert.doExecute",
	"Comment": "method that provides execution of the insert using the passed in map of parameters",
	"Method": "int doExecute(Map<String, Object> args,int doExecute,SqlParameterSource parameterSource){\r\n    checkCompiled();\r\n    List<Object> values = matchInParameterValuesWithInsertColumns(parameterSource);\r\n    return executeInsertInternal(values);\r\n}"
}, {
	"Path": "sx.blah.discord.api.events.EventDispatcher.waitFor",
	"Comment": "this causes the currently executing thread to wait until the specified event is dispatched.",
	"Method": "T waitFor(Class<T> eventClass,T waitFor,Class<T> eventClass,long time,T waitFor,Class<T> eventClass,long time,TimeUnit unit,T waitFor,Predicate<T> filter,T waitFor,Predicate<T> filter,long time,T waitFor,Predicate<T> filter,long time,TimeUnit unit){\r\n    SynchronousQueue<T> result = new SynchronousQueue();\r\n    Class<?> filterRawType = TypeResolver.resolveRawArgument(Predicate.class, filter.getClass());\r\n    registerListener(callingThreadExecutor, new IListener<T>() {\r\n        @Override\r\n        public void handle(T event) {\r\n            if (filterRawType.isInstance(event) && filter.test(event)) {\r\n                unregisterListener(this);\r\n                result.offer(event);\r\n            }\r\n        }\r\n    });\r\n    return result.poll(time, unit);\r\n}"
}, {
	"Path": "sx.blah.discord.api.events.EventDispatcher.waitFor",
	"Comment": "this causes the currently executing thread to wait until the specified event is dispatched.",
	"Method": "T waitFor(Class<T> eventClass,T waitFor,Class<T> eventClass,long time,T waitFor,Class<T> eventClass,long time,TimeUnit unit,T waitFor,Predicate<T> filter,T waitFor,Predicate<T> filter,long time,T waitFor,Predicate<T> filter,long time,TimeUnit unit){\r\n    if (filterRawType.isInstance(event) && filter.test(event)) {\r\n        unregisterListener(this);\r\n        result.offer(event);\r\n    }\r\n}"
}, {
	"Path": "no.priv.garshol.duke.databases.es.ElasticSearchDatabase.isInMemory",
	"Comment": "returns true if the es index is held in memory rather than on disk.",
	"Method": "boolean isInMemory(){\r\n    return this.storageType == StorageType.MEMORY;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.UpdateOnCreateTest.updatePermissionInheritedForAttributeSuccessCase",
	"Comment": "expression for field inherited from class level expression",
	"Method": "void updatePermissionInheritedForAttributeSuccessCase(){\r\n    PersistentResource<UpdateAndCreate> loaded = PersistentResource.loadRecord(UpdateAndCreate.class, \"1\", userTwoScope);\r\n    loaded.updateAttribute(\"name\", \"\");\r\n    loaded.getRequestScope().getPermissionExecutor().executeCommitChecks();\r\n}"
}, {
	"Path": "japa.parser.ast.visitor.EqualsVisitor.commonNodeEquality",
	"Comment": "check for equality that can be applied to each kind of node,to not repeat it in every method we store that here.",
	"Method": "boolean commonNodeEquality(Node n1,Node n2){\r\n    if (!nodeEquals(n1.getComment(), n2.getComment())) {\r\n        return false;\r\n    }\r\n    if (!nodesEquals(n1.getOrphanComments(), n2.getOrphanComments())) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.dcm4che3.net.ApplicationEntity.isInstalled",
	"Comment": "determine whether or not this network ae is installed on a network.",
	"Method": "boolean isInstalled(){\r\n    return device != null && device.isInstalled() && (installed == null || installed.booleanValue());\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.util.RefactoringFileBuffers.getTextFileBuffer",
	"Comment": "returns the text file buffer for the specified compilation unit.",
	"Method": "ITextFileBuffer getTextFileBuffer(ICompilationUnit unit){\r\n    Assert.isNotNull(unit);\r\n    final IResource resource = unit.getResource();\r\n    if (resource == null || resource.getType() != IResource.FILE) {\r\n        return null;\r\n    }\r\n    return FileBuffers.getTextFileBufferManager().getTextFileBuffer(resource.getFullPath(), LocationKind.IFILE);\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.setDatabaseProductName",
	"Comment": "set the database product name for this translator.\tsetting this property will avoid obtaining a connection from the datasource\tto get the metadata.",
	"Method": "void setDatabaseProductName(String dbName){\r\n    this.sqlErrorCodes = SQLErrorCodesFactory.getInstance().getErrorCodes(dbName);\r\n}"
}, {
	"Path": "sx.blah.discord.api.ClientBuilder.withToken",
	"Comment": "configures the bot token used for authentication with discord.",
	"Method": "ClientBuilder withToken(String token){\r\n    this.botToken = token;\r\n    return this;\r\n}"
}, {
	"Path": "sx.blah.discord.api.internal.HeartbeatHandler.shutdown",
	"Comment": "stops the sending of heartbeats and resets stored heartbeat information.",
	"Method": "void shutdown(){\r\n    missedPings.set(0);\r\n    waitingForAck.set(false);\r\n    keepAlive.shutdown();\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.AbstractJdbcCall.matchInParameterValuesWithCallParameters",
	"Comment": "match the provided in parameter values with registered parameters and\tparameters defined via metadata processing.",
	"Method": "Map<String, Object> matchInParameterValuesWithCallParameters(SqlParameterSource parameterSource,Map<String, ?> matchInParameterValuesWithCallParameters,Object[] args,Map<String, ?> matchInParameterValuesWithCallParameters,Map<String, ?> args){\r\n    return this.callMetaDataContext.matchInParameterValuesWithCallParameters(args);\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.SqlUpdate.update",
	"Comment": "convenient method to execute an update given two string args.",
	"Method": "int update(Object params,int update,Object[] params,KeyHolder generatedKeyHolder,int update,int update,int p1,int update,int p1,int p2,int update,long p1,int update,long p1,long p2,int update,String p,int update,String p1,String p2){\r\n    return update(new Object[] { p1, p2 });\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.handlers.JDTLanguageServer.syncCapabilitiesToSettings",
	"Comment": "toggles the server capabilities according to user preferences.",
	"Method": "void syncCapabilitiesToSettings(){\r\n    if (preferenceManager.getClientPreferences().isCompletionDynamicRegistered()) {\r\n        toggleCapability(preferenceManager.getPreferences().isCompletionEnabled(), Preferences.COMPLETION_ID, Preferences.COMPLETION, CompletionHandler.DEFAULT_COMPLETION_OPTIONS);\r\n    }\r\n    if (preferenceManager.getClientPreferences().isFormattingDynamicRegistrationSupported()) {\r\n        toggleCapability(preferenceManager.getPreferences().isJavaFormatEnabled(), Preferences.FORMATTING_ID, Preferences.TEXT_DOCUMENT_FORMATTING, null);\r\n    }\r\n    if (preferenceManager.getClientPreferences().isRangeFormattingDynamicRegistrationSupported()) {\r\n        toggleCapability(preferenceManager.getPreferences().isJavaFormatEnabled(), Preferences.FORMATTING_RANGE_ID, Preferences.TEXT_DOCUMENT_RANGE_FORMATTING, null);\r\n    }\r\n    if (preferenceManager.getClientPreferences().isOnTypeFormattingDynamicRegistrationSupported()) {\r\n        toggleCapability(preferenceManager.getPreferences().isJavaFormatOnTypeEnabled(), Preferences.FORMATTING_ON_TYPE_ID, Preferences.TEXT_DOCUMENT_ON_TYPE_FORMATTING, new DocumentOnTypeFormattingOptions(\";\", Arrays.asList(\"\\n\", \"}\")));\r\n    }\r\n    if (preferenceManager.getClientPreferences().isCodeLensDynamicRegistrationSupported()) {\r\n        toggleCapability(preferenceManager.getPreferences().isCodeLensEnabled(), Preferences.CODE_LENS_ID, Preferences.TEXT_DOCUMENT_CODE_LENS, new CodeLensOptions(true));\r\n    }\r\n    if (preferenceManager.getClientPreferences().isSignatureHelpDynamicRegistrationSupported()) {\r\n        toggleCapability(preferenceManager.getPreferences().isSignatureHelpEnabled(), Preferences.SIGNATURE_HELP_ID, Preferences.TEXT_DOCUMENT_SIGNATURE_HELP, SignatureHelpHandler.createOptions());\r\n    }\r\n    if (preferenceManager.getClientPreferences().isRenameDynamicRegistrationSupported()) {\r\n        toggleCapability(preferenceManager.getPreferences().isRenameEnabled(), Preferences.RENAME_ID, Preferences.TEXT_DOCUMENT_RENAME, RenameHandler.createOptions());\r\n    }\r\n    if (preferenceManager.getClientPreferences().isExecuteCommandDynamicRegistrationSupported()) {\r\n        toggleCapability(preferenceManager.getPreferences().isExecuteCommandEnabled(), Preferences.EXECUTE_COMMAND_ID, Preferences.WORKSPACE_EXECUTE_COMMAND, new ExecuteCommandOptions(new ArrayList(WorkspaceExecuteCommandHandler.getCommands())));\r\n    }\r\n    if (preferenceManager.getClientPreferences().isCodeActionDynamicRegistered()) {\r\n        toggleCapability(preferenceManager.getClientPreferences().isCodeActionDynamicRegistered(), Preferences.CODE_ACTION_ID, Preferences.CODE_ACTION, getCodeActionOptions());\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.support.AbstractLobStreamingResultSetExtractor.extractData",
	"Comment": "delegates to handlenorowfound, handlemultiplerowsfound and streamdata,\taccording to the resultset state. converts an ioexception thrown by\tstreamdata to a lobretrievalfailureexception.",
	"Method": "T extractData(ResultSet rs){\r\n    if (!rs.next()) {\r\n        handleNoRowFound();\r\n    } else {\r\n        try {\r\n            streamData(rs);\r\n            if (rs.next()) {\r\n                handleMultipleRowsFound();\r\n            }\r\n        } catch (IOException ex) {\r\n            throw new LobRetrievalFailureException(\"Couldn't stream LOB content\", ex);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.yahoo.elide.standalone.config.ElideStandaloneSettings.getElideSettings",
	"Comment": "elide settings to be used for bootstrapping the elide service. by default, this method constructs anelidesettings object using the application overrides provided in this class. if this method is overridden,the returned settings object is used over any additional elide setting overrides.that is to say, if you intend to override this method, expect to fully configure the elidesettings object toyour needs.",
	"Method": "ElideSettings getElideSettings(ServiceLocator injector){\r\n    DataStore dataStore = new InjectionAwareHibernateStore(injector, Util.getSessionFactory(getHibernate5ConfigPath(), getModelPackageName()));\r\n    EntityDictionary dictionary = new EntityDictionary(getCheckMappings());\r\n    ElideSettingsBuilder builder = new ElideSettingsBuilder(dataStore).withUseFilterExpressions(true).withEntityDictionary(dictionary).withJoinFilterDialect(new RSQLFilterDialect(dictionary)).withSubqueryFilterDialect(new RSQLFilterDialect(dictionary));\r\n    if (enableIS06081Dates()) {\r\n        builder = builder.withISO8601Dates(\"yyyy-MM-dd'T'HH:mm'Z'\", TimeZone.getTimeZone(\"UTC\"));\r\n    }\r\n    return builder.build();\r\n}"
}, {
	"Path": "sx.blah.discord.util.audio.AudioPlayer.getAudioPlayerForAudioManager",
	"Comment": "gets an audio player for the given audio manager. it will first attempt to find an injected player cached in the\tinternal map, otherwise it will construct a new instance.",
	"Method": "AudioPlayer getAudioPlayerForAudioManager(IAudioManager manager){\r\n    return getAudioPlayerForGuild(manager.getGuild());\r\n}"
}, {
	"Path": "sx.blah.discord.handle.audit.entry.change.AuditLogChange.getNewValue",
	"Comment": "the new value, if it exists.\tthis will not be present on action types like entity deletion.",
	"Method": "Optional<T> getNewValue(){\r\n    return Optional.ofNullable(newValue);\r\n}"
}, {
	"Path": "org.dom4j.io.JAXPHelper.createXMLReader",
	"Comment": "this method attempts to use jaxp to locate the sax2 xmlreaderimplementation. this method uses reflection to avoid being dependentdirectly on the jaxp classes.",
	"Method": "XMLReader createXMLReader(boolean validating,boolean namespaceAware){\r\n    SAXParserFactory factory = SAXParserFactory.newInstance();\r\n    factory.setValidating(validating);\r\n    factory.setNamespaceAware(namespaceAware);\r\n    SAXParser parser = factory.newSAXParser();\r\n    return parser.getXMLReader();\r\n}"
}, {
	"Path": "sx.blah.discord.api.ClientBuilder.setMaxMessageCacheCount",
	"Comment": "configures the max number of messages which are cached for each channel.",
	"Method": "ClientBuilder setMaxMessageCacheCount(int maxCacheCount){\r\n    this.maxCacheCount = maxCacheCount;\r\n    return this;\r\n}"
}, {
	"Path": "japa.parser.ast.Node.getAllContainedComments",
	"Comment": "this is the list of comment which are contained in the node either becausethey are properly associated to one of its children or because they are floatingaround inside the node.",
	"Method": "List<Comment> getAllContainedComments(){\r\n    List<Comment> comments = new LinkedList<Comment>();\r\n    comments.addAll(getOrphanComments());\r\n    for (Node child : getChildrenNodes()) {\r\n        if (child.getComment() != null) {\r\n            comments.add(child.getComment());\r\n        }\r\n        comments.addAll(child.getAllContainedComments());\r\n    }\r\n    return comments;\r\n}"
}, {
	"Path": "org.dcm4che3.net.Connection.setInstalled",
	"Comment": "true if the network connection is installed on the network. if notpresent, information about the installed status of the network connectionis inherited from the device.",
	"Method": "void setInstalled(Boolean installed){\r\n    if (this.installed == installed)\r\n        return;\r\n    boolean prev = isInstalled();\r\n    this.installed = installed;\r\n    if (isInstalled() != prev)\r\n        needRebind();\r\n}"
}, {
	"Path": "com.yahoo.elide.standalone.config.ElideStandaloneSettings.enableGraphQL",
	"Comment": "enable the graphql endpoint. if false, the endpoint will be disabled.",
	"Method": "boolean enableGraphQL(){\r\n    return true;\r\n}"
}, {
	"Path": "sx.blah.discord.util.audio.processors.MultiProcessor.buildFinalProcessor",
	"Comment": "sets the providers of processors in the queue to the previous processor and builds the final processor which\tprovides from all processors in the queue.",
	"Method": "void buildFinalProcessor(){\r\n    finalProcessor = null;\r\n    if (processors.size() == 0) {\r\n        finalProcessor = new DefaultProcessor();\r\n        finalProcessor.setProvider(provider);\r\n    } else {\r\n        processors.forEach(processor -> {\r\n            if (processor.setProvider(finalProcessor == null ? provider : finalProcessor)) {\r\n                finalProcessor = processor;\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "org.dom4j.jaxb.JAXBWriter.startDocument",
	"Comment": "start a document by writing the initial xml declaration to the output.this must be done prior to writing any other elements.",
	"Method": "void startDocument(){\r\n    getWriter().startDocument();\r\n}"
}, {
	"Path": "no.priv.garshol.duke.ConfigurationImpl.getDataSources",
	"Comment": "returns the data sources belonging to a particular group of datasources. data sources are grouped in record linkage mode, but notin deduplication mode, so only use this method in record linkagemode.",
	"Method": "Collection<DataSource> getDataSources(Collection<DataSource> getDataSources,int groupno){\r\n    if (groupno == 1)\r\n        return group1;\r\n    else if (groupno == 2)\r\n        return group2;\r\n    else\r\n        throw new DukeConfigException(\"Invalid group number: \" + groupno);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.namedparam.NamedParameterUtils.parseSqlStatement",
	"Comment": "parse the sql statement and locate any placeholders or named parameters.\tnamed parameters are substituted for a jdbc placeholder.",
	"Method": "ParsedSql parseSqlStatement(String sql){\r\n    Assert.notNull(sql, \"SQL must not be null\");\r\n    Set<String> namedParameters = new HashSet<String>();\r\n    String sqlToUse = sql;\r\n    List<ParameterHolder> parameterList = new ArrayList<ParameterHolder>();\r\n    char[] statement = sql.toCharArray();\r\n    int namedParameterCount = 0;\r\n    int unnamedParameterCount = 0;\r\n    int totalParameterCount = 0;\r\n    int escapes = 0;\r\n    int i = 0;\r\n    while (i < statement.length) {\r\n        int skipToPosition = i;\r\n        while (i < statement.length) {\r\n            skipToPosition = skipCommentsAndQuotes(statement, i);\r\n            if (i == skipToPosition) {\r\n                break;\r\n            } else {\r\n                i = skipToPosition;\r\n            }\r\n        }\r\n        if (i >= statement.length) {\r\n            break;\r\n        }\r\n        char c = statement[i];\r\n        if (c == ':' || c == '&') {\r\n            int j = i + 1;\r\n            if (j < statement.length && statement[j] == ':' && c == ':') {\r\n                i = i + 2;\r\n                continue;\r\n            }\r\n            String parameter = null;\r\n            if (j < statement.length && c == ':' && statement[j] == '{') {\r\n                while (j < statement.length && !('}' == statement[j])) {\r\n                    j++;\r\n                    if (':' == statement[j] || '{' == statement[j]) {\r\n                        throw new InvalidDataAccessApiUsageException(\"Parameter name contains invalid character '\" + statement[j] + \"' at position \" + i + \" in statement: \" + sql);\r\n                    }\r\n                }\r\n                if (j >= statement.length) {\r\n                    throw new InvalidDataAccessApiUsageException(\"Non-terminated named parameter declaration at position \" + i + \" in statement: \" + sql);\r\n                }\r\n                if (j - i > 3) {\r\n                    parameter = sql.substring(i + 2, j);\r\n                    namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter);\r\n                    totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j + 1, parameter);\r\n                }\r\n                j++;\r\n            } else {\r\n                while (j < statement.length && !isParameterSeparator(statement[j])) {\r\n                    j++;\r\n                }\r\n                if (j - i > 1) {\r\n                    parameter = sql.substring(i + 1, j);\r\n                    namedParameterCount = addNewNamedParameter(namedParameters, namedParameterCount, parameter);\r\n                    totalParameterCount = addNamedParameter(parameterList, totalParameterCount, escapes, i, j, parameter);\r\n                }\r\n            }\r\n            i = j - 1;\r\n        } else {\r\n            if (c == '\\\\') {\r\n                int j = i + 1;\r\n                if (j < statement.length && statement[j] == ':') {\r\n                    sqlToUse = sqlToUse.substring(0, i - escapes) + sqlToUse.substring(i - escapes + 1);\r\n                    escapes++;\r\n                    i = i + 2;\r\n                    continue;\r\n                }\r\n            }\r\n            if (c == '?') {\r\n                unnamedParameterCount++;\r\n                totalParameterCount++;\r\n            }\r\n        }\r\n        i++;\r\n    }\r\n    ParsedSql parsedSql = new ParsedSql(sqlToUse);\r\n    for (ParameterHolder ph : parameterList) {\r\n        parsedSql.addNamedParameter(ph.getParameterName(), ph.getStartIndex(), ph.getEndIndex());\r\n    }\r\n    parsedSql.setNamedParameterCount(namedParameterCount);\r\n    parsedSql.setUnnamedParameterCount(unnamedParameterCount);\r\n    parsedSql.setTotalParameterCount(totalParameterCount);\r\n    return parsedSql;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.SingleConnectionDataSource.resetConnection",
	"Comment": "reset the underlying shared connection, to be reinitialized on next access.",
	"Method": "void resetConnection(){\r\n    synchronized (this.connectionMonitor) {\r\n        closeConnection();\r\n        this.target = null;\r\n        this.connection = null;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource.setPassword",
	"Comment": "set the jdbc password to use for connecting through the driver.",
	"Method": "void setPassword(String password){\r\n    this.password = password;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.SimpleJdbcTemplate.getArguments",
	"Comment": "considers an object array passed into a varargs parameter as\tcollection of arguments rather than as single argument.",
	"Method": "Object[] getArguments(Object[] varArgs){\r\n    if (varArgs.length == 1 && varArgs[0] instanceof Object[]) {\r\n        return (Object[]) varArgs[0];\r\n    } else {\r\n        return varArgs;\r\n    }\r\n}"
}, {
	"Path": "denominator.TestGraph.manager",
	"Comment": "returns null if the manager could not be initialized. override to lazy initialize, for example if you are using tls certificate auth.",
	"Method": "DNSApiManager manager(){\r\n    return manager;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.preferences.PreferenceManager.isClientSupportsCompletionDocumentationMarkDown",
	"Comment": "checks whether the client supports markdown in completion",
	"Method": "boolean isClientSupportsCompletionDocumentationMarkDown(){\r\n    return getClientPreferences() != null && getClientPreferences().isSupportsCompletionDocumentationMarkdown();\r\n}"
}, {
	"Path": "sx.blah.discord.util.RequestBuilder.shouldBufferRequests",
	"Comment": "sets whether the request should be buffered for rate limits. false by default.",
	"Method": "RequestBuilder shouldBufferRequests(boolean shouldBuffer){\r\n    this.bufferRequests = shouldBuffer;\r\n    return this;\r\n}"
}, {
	"Path": "com.yahoo.elide.security.PermissionExecutor.isVerbose",
	"Comment": "whether or not the permission executor will return verbose logging to the requesting user in the response.",
	"Method": "boolean isVerbose(){\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.RefactoringScopeFactory.createRelatedProjectsScope",
	"Comment": "creates a new search scope containing all projects which reference or are\treferenced by the specified project.",
	"Method": "IJavaSearchScope createRelatedProjectsScope(IJavaProject project,int includeMask){\r\n    IJavaProject[] projects = getRelatedProjects(project);\r\n    return SearchEngine.createJavaSearchScope(projects, includeMask);\r\n}"
}, {
	"Path": "org.dom4j.io.DocumentInputSource.getCharacterStream",
	"Comment": "note this method is quite inefficent, it turns the in memory xml treeobject model into a single block of text which can then be read by otherxml parsers. should only be used with care.",
	"Method": "Reader getCharacterStream(){\r\n    try {\r\n        StringWriter out = new StringWriter();\r\n        XMLWriter writer = new XMLWriter(out);\r\n        writer.write(document);\r\n        writer.flush();\r\n        return new StringReader(out.toString());\r\n    } catch (final IOException e) {\r\n        return new Reader() {\r\n            public int read(char[] ch, int offset, int length) throws IOException {\r\n                throw e;\r\n            }\r\n            public void close() throws IOException {\r\n            }\r\n        };\r\n    }\r\n}"
}, {
	"Path": "org.dom4j.io.DocumentInputSource.getCharacterStream",
	"Comment": "note this method is quite inefficent, it turns the in memory xml treeobject model into a single block of text which can then be read by otherxml parsers. should only be used with care.",
	"Method": "Reader getCharacterStream(){\r\n    throw e;\r\n}"
}, {
	"Path": "org.dom4j.io.DocumentInputSource.getCharacterStream",
	"Comment": "note this method is quite inefficent, it turns the in memory xml treeobject model into a single block of text which can then be read by otherxml parsers. should only be used with care.",
	"Method": "Reader getCharacterStream(){\r\n}"
}, {
	"Path": "org.dom4j.Namespace.get",
	"Comment": "a helper method to return the namespace instance for no prefix and theuri",
	"Method": "Namespace get(String prefix,String uri,Namespace get,String uri){\r\n    return CACHE.get(uri);\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.CustomSQLExceptionTranslatorRegistry.registerTranslator",
	"Comment": "register a new custom translator for the specified database name.",
	"Method": "void registerTranslator(String dbName,SQLExceptionTranslator translator){\r\n    SQLExceptionTranslator replaced = translatorMap.put(dbName, translator);\r\n    if (replaced != null) {\r\n        logger.warn(\"Replacing custom translator [\" + replaced + \"] for database '\" + dbName + \"' with [\" + translator + \"]\");\r\n    } else {\r\n        logger.info(\"Adding custom translator of type [\" + translator.getClass().getName() + \"] for database '\" + dbName + \"'\");\r\n    }\r\n}"
}, {
	"Path": "sx.blah.discord.util.AttachmentPartEntry.from",
	"Comment": "creates an array of attachment part entries from an array of files.",
	"Method": "AttachmentPartEntry from(File file,AttachmentPartEntry[] from,File files){\r\n    AttachmentPartEntry[] entries = new AttachmentPartEntry[files.length];\r\n    for (int i = 0; i < files.length; i++) {\r\n        entries[i] = from(files[i]);\r\n    }\r\n    return entries;\r\n}"
}, {
	"Path": "sx.blah.discord.util.RoleBuilder.build",
	"Comment": "builds a role with the configuration specified by the builder.",
	"Method": "IRole build(){\r\n    if (guild == null)\r\n        throw new RuntimeException(\"A guild must be set to create a role.\");\r\n    Role role = (Role) guild.createRole();\r\n    role.edit(color != null ? color : role.getColor(), hoist, name != null ? name : role.getName(), permissions != null ? permissions : role.getPermissions(), mentionable);\r\n    return role;\r\n}"
}, {
	"Path": "com.yahoo.elide.contrib.swagger.SwaggerBuilder.withGlobalResponse",
	"Comment": "decorates every operation on every path with the given response.",
	"Method": "SwaggerBuilder withGlobalResponse(int code,Response response){\r\n    globalResponses.put(code, response);\r\n    return this;\r\n}"
}, {
	"Path": "co.aikar.timings.TimingsManager.tick",
	"Comment": "called every tick to count the number of times a timer caused tps loss.",
	"Method": "void tick(){\r\n    if (Timings.isTimingsEnabled()) {\r\n        boolean violated = Timings.fullServerTickTimer.isViolated();\r\n        for (Timing timing : TIMINGS) {\r\n            if (timing.isSpecial()) {\r\n                continue;\r\n            }\r\n            timing.tick(violated);\r\n        }\r\n        TimingsHistory.playerTicks += DragonProxy.getInstance().getSessionRegister().getOnlineCount();\r\n        TimingsHistory.timedTicks++;\r\n    }\r\n}"
}, {
	"Path": "no.priv.garshol.duke.PropertyImpl.setComparator",
	"Comment": "sets the comparator used for this property. note that changingthis while duke is processing may have unpredictableconsequences.",
	"Method": "void setComparator(Comparator comparator){\r\n    this.comparator = comparator;\r\n}"
}, {
	"Path": "org.dom4j.io.SAXContentHandler.setMergeAdjacentText",
	"Comment": "sets whether or not adjacent text nodes should be merged together whenparsing.",
	"Method": "void setMergeAdjacentText(boolean mergeAdjacentText){\r\n    this.mergeAdjacentText = mergeAdjacentText;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.namedparam.AbstractSqlParameterSource.getSqlType",
	"Comment": "return the sql type for the given parameter, if registered.",
	"Method": "int getSqlType(String paramName){\r\n    Assert.notNull(paramName, \"Parameter name must not be null\");\r\n    Integer sqlType = this.sqlTypes.get(paramName);\r\n    if (sqlType != null) {\r\n        return sqlType;\r\n    }\r\n    return TYPE_UNKNOWN;\r\n}"
}, {
	"Path": "sx.blah.discord.util.MessageTokenizer.nextRegex",
	"Comment": "gets the next string of the content that matches the given pattern as a token.",
	"Method": "Token nextRegex(Pattern pattern){\r\n    if (!hasNextRegex(pattern))\r\n        throw new IllegalStateException(\"No more occurrences found!\");\r\n    Matcher matcher = pattern.matcher(remaining);\r\n    if (!matcher.find())\r\n        throw new IllegalStateException(\"Couldn't find any matches!\");\r\n    final int start = currentPosition + matcher.start();\r\n    final int end = currentPosition + matcher.end();\r\n    stepTo(end);\r\n    return new Token(this, start, end);\r\n}"
}, {
	"Path": "sx.blah.discord.util.Image.forStream",
	"Comment": "generates an avatar image from an input stream representing an image.",
	"Method": "Image forStream(String imageType,InputStream stream){\r\n    return () -> {\r\n        try {\r\n            Image image = forData(imageType, IOUtils.toByteArray(stream));\r\n            stream.close();\r\n            return image.getData();\r\n        } catch (Exception e) {\r\n            Discord4J.LOGGER.error(LogMarkers.UTIL, \"Discord4J Internal Exception\", e);\r\n        }\r\n        return defaultAvatar().getData();\r\n    };\r\n}"
}, {
	"Path": "sx.blah.discord.util.EmbedBuilder.withAuthorIcon",
	"Comment": "sets the author icon. author name must be present for the author icon to appear.",
	"Method": "EmbedBuilder withAuthorIcon(String url){\r\n    if (embed.author == null)\r\n        embed.author = new EmbedObject.AuthorObject(null, null, null, null);\r\n    embed.author.icon_url = url;\r\n    return this;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.ConfigurationImpl.validate",
	"Comment": "validates the configuration to verify that it makes sense.rejects configurations that will fail during runtime.",
	"Method": "void validate(){\r\n    if (properties == null || properties.isEmpty())\r\n        throw new DukeConfigException(\"Configuration has no properties at all\");\r\n    double prob = 0.5;\r\n    for (Property prop : properties.values()) {\r\n        if (prop.getHighProbability() == 0.0)\r\n            continue;\r\n        prob = Utils.computeBayes(prob, prop.getHighProbability());\r\n    }\r\n    if (prob < threshold)\r\n        throw new DukeConfigException(\"Maximum possible probability is \" + prob + \", which is below threshold (\" + threshold + \"), which means no duplicates will ever \" + \"be found\");\r\n    if (getIdentityProperties().isEmpty())\r\n        throw new DukeConfigException(\"No ID properties.\");\r\n    if (getIdentityProperties().size() > 1)\r\n        throw new DukeConfigException(\"Can only have one ID property.\");\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.nls.NLSElement.setTagPosition",
	"Comment": "sets the tag position if one is associated with the nls element.",
	"Method": "void setTagPosition(int start,int length){\r\n    fTagPosition = new Region(start, length);\r\n}"
}, {
	"Path": "sx.blah.discord.util.RequestBuilder.isDone",
	"Comment": "gets whether the request is finished executing or cancelled.",
	"Method": "boolean isDone(){\r\n    return isDone || isCancelled();\r\n}"
}, {
	"Path": "no.priv.garshol.duke.ConfigurationImpl.setThreshold",
	"Comment": "sets the probability threshold for considering two recordsequivalent.",
	"Method": "void setThreshold(double threshold){\r\n    this.threshold = threshold;\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.SqlUpdate.updateByNamedParam",
	"Comment": "method to execute the update given arguments and\tretrieve the generated keys using a keyholder.",
	"Method": "int updateByNamedParam(Map<String, ?> paramMap,int updateByNamedParam,Map<String, ?> paramMap,KeyHolder generatedKeyHolder){\r\n    validateNamedParameters(paramMap);\r\n    ParsedSql parsedSql = getParsedSql();\r\n    MapSqlParameterSource paramSource = new MapSqlParameterSource(paramMap);\r\n    String sqlToUse = NamedParameterUtils.substituteNamedParameters(parsedSql, paramSource);\r\n    Object[] params = NamedParameterUtils.buildValueArray(parsedSql, paramSource, getDeclaredParameters());\r\n    int rowsAffected = getJdbcTemplate().update(newPreparedStatementCreator(sqlToUse, params), generatedKeyHolder);\r\n    checkRowsAffected(rowsAffected);\r\n    return rowsAffected;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.getParsedSql",
	"Comment": "obtain a parsed representation of the given sql statement.\tthe default implementation uses an lru cache with an upper limit\tof 256 entries.",
	"Method": "ParsedSql getParsedSql(String sql){\r\n    if (getCacheLimit() <= 0) {\r\n        return NamedParameterUtils.parseSqlStatement(sql);\r\n    }\r\n    synchronized (this.parsedSqlCache) {\r\n        ParsedSql parsedSql = this.parsedSqlCache.get(sql);\r\n        if (parsedSql == null) {\r\n            parsedSql = NamedParameterUtils.parseSqlStatement(sql);\r\n            this.parsedSqlCache.put(sql, parsedSql);\r\n        }\r\n        return parsedSql;\r\n    }\r\n}"
}, {
	"Path": "no.priv.garshol.duke.comparators.Levenshtein.distance",
	"Comment": "this is the original, naive implementation, using the wagner &fischer algorithm from 1974. it uses a flattened matrix forspeed, but still computes the entire matrix.",
	"Method": "int distance(String s1,String s2){\r\n    if (s1.length() == 0)\r\n        return s2.length();\r\n    if (s2.length() == 0)\r\n        return s1.length();\r\n    int s1len = s1.length();\r\n    int[] matrix = new int[(s1len + 1) * (s2.length() + 1)];\r\n    for (int col = 0; col <= s2.length(); col++) matrix[col * s1len] = col;\r\n    for (int row = 0; row <= s1len; row++) matrix[row] = row;\r\n    for (int ix1 = 0; ix1 < s1len; ix1++) {\r\n        char ch1 = s1.charAt(ix1);\r\n        for (int ix2 = 0; ix2 < s2.length(); ix2++) {\r\n            int cost;\r\n            if (ch1 == s2.charAt(ix2))\r\n                cost = 0;\r\n            else\r\n                cost = 1;\r\n            int left = matrix[ix1 + ((ix2 + 1) * s1len)] + 1;\r\n            int above = matrix[ix1 + 1 + (ix2 * s1len)] + 1;\r\n            int aboveleft = matrix[ix1 + (ix2 * s1len)] + cost;\r\n            matrix[ix1 + 1 + ((ix2 + 1) * s1len)] = Math.min(left, Math.min(above, aboveleft));\r\n        }\r\n    }\r\n    return matrix[s1len + (s2.length() * s1len)];\r\n}"
}, {
	"Path": "sx.blah.discord.handle.impl.obj.Message.getRawMentionsLong",
	"Comment": "gets a list of the unique snowflake ids of the users mentioned in the message.",
	"Method": "List<Long> getRawMentionsLong(){\r\n    return mentions;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.rename.RenameTypeProcessor.initializeReferences",
	"Comment": "initializes the references to the type and the similarly named elements. this\tmethod creates both the freferences and the fpreloadedelementtoname fields.\tmay be called from the ui.",
	"Method": "RefactoringStatus initializeReferences(IProgressMonitor monitor){\r\n    Assert.isNotNull(fType);\r\n    Assert.isNotNull(getNewElementName());\r\n    if (fReferences != null && (getNewElementName().equals(fCachedNewName)) && (fCachedRenameSimilarElements == getUpdateSimilarDeclarations()) && (fCachedRenamingStrategy == fRenamingStrategy)) {\r\n        return fCachedRefactoringStatus;\r\n    }\r\n    fCachedNewName = getNewElementName();\r\n    fCachedRenameSimilarElements = fUpdateSimilarElements;\r\n    fCachedRenamingStrategy = fRenamingStrategy;\r\n    fCachedRefactoringStatus = new RefactoringStatus();\r\n    try {\r\n        SearchPattern pattern = SearchPattern.createPattern(fType, IJavaSearchConstants.REFERENCES, SearchUtils.GENERICS_AGNOSTIC_MATCH_RULE);\r\n        String binaryRefsDescription = Messages.format(RefactoringCoreMessages.ReferencesInBinaryContext_ref_in_binaries_description, BasicElementLabels.getJavaElementName(fType.getElementName()));\r\n        ReferencesInBinaryContext binaryRefs = new ReferencesInBinaryContext(binaryRefsDescription);\r\n        fReferences = RefactoringSearchEngine.search(pattern, RefactoringScopeFactory.create(fType, true, false), new TypeOccurrenceCollector(fType, binaryRefs), monitor, fCachedRefactoringStatus);\r\n        binaryRefs.addErrorIfNecessary(fCachedRefactoringStatus);\r\n        fReferences = Checks.excludeCompilationUnits(fReferences, fCachedRefactoringStatus);\r\n        fPreloadedElementToName = new LinkedHashMap();\r\n        fPreloadedElementToSelection = new HashMap();\r\n        final String unQualifiedTypeName = fType.getElementName();\r\n        monitor.beginTask(\"\", fReferences.length);\r\n        if (getUpdateSimilarDeclarations()) {\r\n            RenamingNameSuggestor sugg = new RenamingNameSuggestor(fRenamingStrategy);\r\n            for (int i = 0; i < fReferences.length; i++) {\r\n                final ICompilationUnit cu = fReferences[i].getCompilationUnit();\r\n                if (cu == null) {\r\n                    continue;\r\n                }\r\n                final SearchMatch[] results = fReferences[i].getSearchResults();\r\n                for (int j = 0; j < results.length; j++) {\r\n                    if (!(results[j] instanceof TypeReferenceMatch)) {\r\n                        continue;\r\n                    }\r\n                    final TypeReferenceMatch match = (TypeReferenceMatch) results[j];\r\n                    final List<IJavaElement> matches = new ArrayList();\r\n                    if (match.getLocalElement() != null) {\r\n                        if (match.getLocalElement() instanceof ILocalVariable) {\r\n                            matches.add(match.getLocalElement());\r\n                        }\r\n                    } else {\r\n                        matches.add((IJavaElement) match.getElement());\r\n                    }\r\n                    final IJavaElement[] others = match.getOtherElements();\r\n                    if (others != null) {\r\n                        matches.addAll(Arrays.asList(others));\r\n                    }\r\n                    for (Iterator<IJavaElement> iter = matches.iterator(); iter.hasNext(); ) {\r\n                        final IJavaElement element = iter.next();\r\n                        if (!(element instanceof IMethod) && !(element instanceof IField) && !(element instanceof ILocalVariable)) {\r\n                            continue;\r\n                        }\r\n                        if (!isInDeclaredType(match.getOffset(), element)) {\r\n                            continue;\r\n                        }\r\n                        if (element instanceof IField) {\r\n                            final IField currentField = (IField) element;\r\n                            final String newFieldName = sugg.suggestNewFieldName(currentField.getJavaProject(), currentField.getElementName(), Flags.isStatic(currentField.getFlags()), unQualifiedTypeName, getNewElementName());\r\n                            if (newFieldName != null) {\r\n                                fPreloadedElementToName.put(currentField, newFieldName);\r\n                            }\r\n                        } else if (element instanceof IMethod) {\r\n                            final IMethod currentMethod = (IMethod) element;\r\n                            addMethodRename(unQualifiedTypeName, sugg, currentMethod);\r\n                        } else if (element instanceof ILocalVariable) {\r\n                            final ILocalVariable currentLocal = (ILocalVariable) element;\r\n                            final boolean isParameter;\r\n                            if (currentLocal.isParameter()) {\r\n                                addMethodRename(unQualifiedTypeName, sugg, (IMethod) currentLocal.getParent());\r\n                                isParameter = true;\r\n                            } else {\r\n                                isParameter = false;\r\n                            }\r\n                            final String newLocalName = sugg.suggestNewLocalName(currentLocal.getJavaProject(), currentLocal.getElementName(), isParameter, unQualifiedTypeName, getNewElementName());\r\n                            if (newLocalName != null) {\r\n                                fPreloadedElementToName.put(currentLocal, newLocalName);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                if (monitor.isCanceled()) {\r\n                    throw new OperationCanceledException();\r\n                }\r\n            }\r\n        }\r\n        for (Iterator<IJavaElement> iter = fPreloadedElementToName.keySet().iterator(); iter.hasNext(); ) {\r\n            IJavaElement element = iter.next();\r\n            fPreloadedElementToSelection.put(element, Boolean.TRUE);\r\n        }\r\n        fPreloadedElementToNameDefault = new LinkedHashMap(fPreloadedElementToName);\r\n    } catch (OperationCanceledException e) {\r\n        fReferences = null;\r\n        fPreloadedElementToName = null;\r\n        throw new OperationCanceledException();\r\n    }\r\n    return fCachedRefactoringStatus;\r\n}"
}, {
	"Path": "org.dom4j.tree.AbstractBranch.createSingleResultList",
	"Comment": "a factory method pattern which creates a backedlist implementation whichcontains a single result",
	"Method": "List<T> createSingleResultList(T result){\r\n    BackedList<T> list = new BackedList<T>(this, contentList(), 1);\r\n    list.addLocal(result);\r\n    return list;\r\n}"
}, {
	"Path": "sx.blah.discord.util.MessageHistory.getGuild",
	"Comment": "the parent guild of the channel the messages were sent in, or null if no messages are present.",
	"Method": "IGuild getGuild(){\r\n    final IChannel channel = getChannel();\r\n    return (channel == null) ? null : (channel.isPrivate() ? null : channel.getGuild());\r\n}"
}, {
	"Path": "com.dslplatform.json.DslJson.canSerialize",
	"Comment": "check if dsljson knows how to serialize a type.\tit will check if a writer for such type exists or can be used.",
	"Method": "boolean canSerialize(Type manifest){\r\n    JsonWriter.WriteObject writer = writers.get(manifest);\r\n    if (writer != null)\r\n        return true;\r\n    if (manifest instanceof Class<?>) {\r\n        final Class<?> content = (Class<?>) manifest;\r\n        if (JsonObject.class.isAssignableFrom(content)) {\r\n            return true;\r\n        }\r\n        if (JsonObject[].class.isAssignableFrom(content)) {\r\n            return true;\r\n        }\r\n        if (tryFindWriter(manifest) != null) {\r\n            return true;\r\n        }\r\n        if (content.isArray()) {\r\n            return !content.getComponentType().isArray() && !Collection.class.isAssignableFrom(content.getComponentType()) && canSerialize(content.getComponentType());\r\n        }\r\n    }\r\n    if (manifest instanceof ParameterizedType) {\r\n        final ParameterizedType pt = (ParameterizedType) manifest;\r\n        if (pt.getActualTypeArguments().length == 1) {\r\n            final Class<?> container = (Class<?>) pt.getRawType();\r\n            if (container.isArray() || Collection.class.isAssignableFrom(container)) {\r\n                final Type content = pt.getActualTypeArguments()[0];\r\n                return content instanceof Class<?> && JsonObject.class.isAssignableFrom((Class<?>) content) || tryFindWriter(content) != null;\r\n            }\r\n        }\r\n    } else if (manifest instanceof GenericArrayType) {\r\n        final GenericArrayType gat = (GenericArrayType) manifest;\r\n        return gat.getGenericComponentType() instanceof Class<?> && JsonObject.class.isAssignableFrom((Class<?>) gat.getGenericComponentType()) || tryFindWriter(gat.getGenericComponentType()) != null;\r\n    }\r\n    for (ConverterFactory<JsonWriter.WriteObject> wrt : writerFactories) {\r\n        if (wrt.tryCreate(manifest, this) != null) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.contentassist.CompletionProposalDescriptionProvider.extractDeclaringTypeFQN",
	"Comment": "extracts the fully qualified name of the declaring type of a method\treference.",
	"Method": "String extractDeclaringTypeFQN(CompletionProposal methodProposal){\r\n    char[] declaringTypeSignature = methodProposal.getDeclarationSignature();\r\n    if (declaringTypeSignature == null) {\r\n        return OBJECT;\r\n    }\r\n    return SignatureUtil.stripSignatureToFQN(String.valueOf(declaringTypeSignature));\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.RefactoringSearchEngine2.setScope",
	"Comment": "sets the search scope for this search engine.\tthis method must be called before start searching. the default is the entire workspace as search scope.",
	"Method": "void setScope(IJavaSearchScope scope){\r\n    Assert.isNotNull(scope);\r\n    fScope = scope;\r\n}"
}, {
	"Path": "denominator.model.rdata.MXData.preference",
	"Comment": "specifies the preference given to this rr among others at the same owner. lower values arepreferred.",
	"Method": "int preference(){\r\n    return Integer.class.cast(get(\"preference\"));\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.SQLErrorCodesFactoryTests.testDefaultInstanceWithNoSuchDatabase",
	"Comment": "check that a default instance returns empty error codes for an unknown database.",
	"Method": "void testDefaultInstanceWithNoSuchDatabase(){\r\n    SQLErrorCodes sec = SQLErrorCodesFactory.getInstance().getErrorCodes(\"xx\");\r\n    assertTrue(sec.getBadSqlGrammarCodes().length == 0);\r\n    assertTrue(sec.getDataIntegrityViolationCodes().length == 0);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.fix.AbstractMultiFix.filter",
	"Comment": "returns unique problem locations. all locations in result have an id element\tproblemids.",
	"Method": "IProblemLocationCore[] filter(IProblemLocationCore[] problems,int[] problemIds){\r\n    ArrayList<IProblemLocationCore> result = new ArrayList();\r\n    for (int i = 0; i < problems.length; i++) {\r\n        IProblemLocationCore problem = problems[i];\r\n        if (contains(problemIds, problem.getProblemId()) && !contains(result, problem)) {\r\n            result.add(problem);\r\n        }\r\n    }\r\n    return result.toArray(new IProblemLocationCore[result.size()]);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.CallMetaDataContext.matchInParameterValuesWithCallParameters",
	"Comment": "match input parameter values with the parameters declared to be used in the call.",
	"Method": "Map<String, Object> matchInParameterValuesWithCallParameters(SqlParameterSource parameterSource,Map<String, ?> matchInParameterValuesWithCallParameters,Map<String, ?> inParameters,Map<String, ?> matchInParameterValuesWithCallParameters,Object[] parameterValues){\r\n    Map<String, Object> matchedParameters = new HashMap<String, Object>(parameterValues.length);\r\n    int i = 0;\r\n    for (SqlParameter parameter : this.callParameters) {\r\n        if (parameter.isInputValueProvided()) {\r\n            String parameterName = parameter.getName();\r\n            matchedParameters.put(parameterName, parameterValues[i++]);\r\n        }\r\n    }\r\n    return matchedParameters;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.SingleConnectionDataSource.getCloseSuppressingConnectionProxy",
	"Comment": "wrap the given connection with a proxy that delegates every method call to it\tbut suppresses close calls.",
	"Method": "Connection getCloseSuppressingConnectionProxy(Connection target){\r\n    return (Connection) Proxy.newProxyInstance(ConnectionProxy.class.getClassLoader(), new Class<?>[] { ConnectionProxy.class }, new CloseSuppressingInvocationHandler(target));\r\n}"
}, {
	"Path": "org.dom4j.util.StringUtils.endsWithWhitespace",
	"Comment": "finds out if the given character sequence ends with a whitespacecharacter.",
	"Method": "boolean endsWithWhitespace(CharSequence charSeq){\r\n    if (charSeq.length() == 0) {\r\n        return false;\r\n    }\r\n    return Character.isWhitespace(charSeq.charAt(charSeq.length() - 1));\r\n}"
}, {
	"Path": "org.dom4j.util.IndexedElement.createIndex",
	"Comment": "factory method to return a new map implementation for indices",
	"Method": "Map<Object, T> createIndex(){\r\n    return new HashMap<Object, T>();\r\n}"
}, {
	"Path": "com.yahoo.elide.contrib.swagger.SwaggerBuilder.withExplicitClassList",
	"Comment": "the classes for which api paths will be generated.all paths that include other entitiesare dropped.",
	"Method": "SwaggerBuilder withExplicitClassList(Set<Class<?>> classes){\r\n    allClasses = new HashSet(classes);\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.ConnectionHolder.getConnectionHandle",
	"Comment": "return the connectionhandle held by this connectionholder.",
	"Method": "ConnectionHandle getConnectionHandle(){\r\n    return this.connectionHandle;\r\n}"
}, {
	"Path": "denominator.model.ResourceRecordSets.alwaysVisible",
	"Comment": "returns true if the input has no visibility qualifier. typically indicates a basic record set.",
	"Method": "Filter<ResourceRecordSet<?>> alwaysVisible(){\r\n    return new Filter<ResourceRecordSet<?>>() {\r\n        @Override\r\n        public boolean apply(ResourceRecordSet<?> in) {\r\n            return in != null && in.qualifier() == null;\r\n        }\r\n        @Override\r\n        public String toString() {\r\n            return \"alwaysVisible()\";\r\n        }\r\n    };\r\n}"
}, {
	"Path": "denominator.model.ResourceRecordSets.alwaysVisible",
	"Comment": "returns true if the input has no visibility qualifier. typically indicates a basic record set.",
	"Method": "Filter<ResourceRecordSet<?>> alwaysVisible(){\r\n    return in != null && in.qualifier() == null;\r\n}"
}, {
	"Path": "denominator.model.ResourceRecordSets.alwaysVisible",
	"Comment": "returns true if the input has no visibility qualifier. typically indicates a basic record set.",
	"Method": "Filter<ResourceRecordSet<?>> alwaysVisible(){\r\n    return \"alwaysVisible()\";\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.rename.RenameTypeProcessor.checkForWarnings",
	"Comment": "if one of the methods of this ripple was deselected or renamed by\tthe user, deselect the whole chain and add warnings.",
	"Method": "boolean checkForWarnings(Set<Warning> warnings,String newName,IMethod[] ripples){\r\n    boolean addSelectionWarning = false;\r\n    boolean addNameWarning = false;\r\n    for (int i = 0; i < ripples.length; i++) {\r\n        String newNameOfRipple = fPreloadedElementToName.get(ripples[i]);\r\n        Boolean selected = fPreloadedElementToSelection.get(ripples[i]);\r\n        if (selected == null) {\r\n            continue;\r\n        }\r\n        if (!selected.booleanValue()) {\r\n            addSelectionWarning = true;\r\n        }\r\n        if (!newName.equals(newNameOfRipple)) {\r\n            addNameWarning = true;\r\n        }\r\n    }\r\n    if (addSelectionWarning || addNameWarning) {\r\n        warnings.add(new Warning(ripples, addSelectionWarning, addNameWarning));\r\n    }\r\n    return (addSelectionWarning || addNameWarning);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.code.flow.FlowInfo.getAccessMode",
	"Comment": "returns the access mode of the local variable identified by the given\tbinding.",
	"Method": "int getAccessMode(FlowContext context,IVariableBinding local){\r\n    if (fAccessModes == null) {\r\n        return UNUSED;\r\n    }\r\n    int index = context.getIndexFromLocal(local);\r\n    if (index == -1) {\r\n        return UNUSED;\r\n    }\r\n    return fAccessModes[index];\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corrections.proposals.CUCorrectionProposal.getPreviewContent",
	"Comment": "creates a preview of the content of the compilation unit after applying the change.",
	"Method": "String getPreviewContent(){\r\n    return getTextChange().getPreviewContent(new NullProgressMonitor());\r\n}"
}, {
	"Path": "com.yahoo.elide.core.EntityDictionary.cascadeDeletes",
	"Comment": "returns true if the relationship cascades deletes and false otherwise.",
	"Method": "boolean cascadeDeletes(Class<?> targetClass,String fieldName){\r\n    CascadeType[] cascadeTypes = getEntityBinding(targetClass).relationshipToCascadeTypes.getOrDefault(fieldName, new CascadeType[0]);\r\n    for (CascadeType cascadeType : cascadeTypes) {\r\n        if (cascadeType == CascadeType.ALL || cascadeType == CascadeType.REMOVE) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "sx.blah.discord.handle.impl.events.guild.channel.message.MessageEvent.getMessageID",
	"Comment": "gets the id of the message involved in the event. this is always present.",
	"Method": "long getMessageID(){\r\n    return messageID;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.handlers.WorkspaceExecuteCommandHandler.executeCommand",
	"Comment": "execute workspace command and invoke language server delegate command\thandler for matching command",
	"Method": "Object executeCommand(ExecuteCommandParams params,IProgressMonitor monitor){\r\n    if (params == null || params.getCommand() == null) {\r\n        String errorMessage = \"The workspace/executeCommand has empty params or command\";\r\n        JavaLanguageServerPlugin.logError(errorMessage);\r\n        throw new ResponseErrorException(new ResponseError(ResponseErrorCode.InvalidParams, errorMessage, null));\r\n    }\r\n    Set<DelegateCommandHandlerDescriptor> handlers = getDelegateCommandHandlerDescriptors();\r\n    Collection<DelegateCommandHandlerDescriptor> candidates = handlers.stream().filter(desc -> desc.getCommands().contains(params.getCommand())).collect(Collectors.toSet());\r\n    if (candidates.size() > 1) {\r\n        Exception ex = new IllegalStateException(String.format(\"Found multiple delegateCommandHandlers (%s) matching command %s\", candidates, params.getCommand()));\r\n        throw new ResponseErrorException(new ResponseError(ResponseErrorCode.InternalError, ex.getMessage(), ex));\r\n    }\r\n    if (monitor.isCanceled()) {\r\n        return \"\";\r\n    }\r\n    if (candidates.isEmpty()) {\r\n        throw new ResponseErrorException(new ResponseError(ResponseErrorCode.MethodNotFound, String.format(\"No delegateCommandHandler for %s\", params.getCommand()), null));\r\n    }\r\n    final Object[] resultValues = new Object[1];\r\n    SafeRunner.run(new ISafeRunnable() {\r\n        @Override\r\n        public void run() throws Exception {\r\n            final IDelegateCommandHandler delegateCommandHandler = candidates.iterator().next().getDelegateCommandHandler();\r\n            if (delegateCommandHandler != null) {\r\n                List<Object> args = Collections.emptyList();\r\n                if (params.getArguments() != null) {\r\n                    args = params.getArguments().stream().map((element) -> {\r\n                        return JSONUtility.toModel(element, Object.class);\r\n                    }).collect(Collectors.toList());\r\n                }\r\n                resultValues[0] = delegateCommandHandler.executeCommand(params.getCommand(), args, monitor);\r\n            }\r\n        }\r\n        @Override\r\n        public void handleException(Throwable ex) {\r\n            IStatus status = new Status(IStatus.ERROR, JavaLanguageServerPlugin.PLUGIN_ID, IStatus.OK, \"Error in calling delegate command handler\", ex);\r\n            JavaLanguageServerPlugin.log(status);\r\n            if (ex instanceof ResponseErrorException) {\r\n                throw (ResponseErrorException) ex;\r\n            }\r\n            throw new ResponseErrorException(new ResponseError(ResponseErrorCode.UnknownErrorCode, ex.getMessage(), ex));\r\n        }\r\n    });\r\n    return resultValues[0];\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.handlers.WorkspaceExecuteCommandHandler.executeCommand",
	"Comment": "execute workspace command and invoke language server delegate command\thandler for matching command",
	"Method": "Object executeCommand(ExecuteCommandParams params,IProgressMonitor monitor){\r\n    final IDelegateCommandHandler delegateCommandHandler = candidates.iterator().next().getDelegateCommandHandler();\r\n    if (delegateCommandHandler != null) {\r\n        List<Object> args = Collections.emptyList();\r\n        if (params.getArguments() != null) {\r\n            args = params.getArguments().stream().map((element) -> {\r\n                return JSONUtility.toModel(element, Object.class);\r\n            }).collect(Collectors.toList());\r\n        }\r\n        resultValues[0] = delegateCommandHandler.executeCommand(params.getCommand(), args, monitor);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.handlers.WorkspaceExecuteCommandHandler.executeCommand",
	"Comment": "execute workspace command and invoke language server delegate command\thandler for matching command",
	"Method": "Object executeCommand(ExecuteCommandParams params,IProgressMonitor monitor){\r\n    IStatus status = new Status(IStatus.ERROR, JavaLanguageServerPlugin.PLUGIN_ID, IStatus.OK, \"Error in calling delegate command handler\", ex);\r\n    JavaLanguageServerPlugin.log(status);\r\n    if (ex instanceof ResponseErrorException) {\r\n        throw (ResponseErrorException) ex;\r\n    }\r\n    throw new ResponseErrorException(new ResponseError(ResponseErrorCode.UnknownErrorCode, ex.getMessage(), ex));\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.RefactoringScopeFactory.getReferencingClassPathEntry",
	"Comment": "finds, if possible, a classpathentry in one given project such that this classpath entry references another given project. if more than one entry exists for the referenced project and at least one is exported, then an exported entry will be returned.",
	"Method": "IClasspathEntry getReferencingClassPathEntry(IJavaProject referencingProject,IJavaProject referencedProject){\r\n    IClasspathEntry result = null;\r\n    IPath path = referencedProject.getProject().getFullPath();\r\n    IClasspathEntry[] classpath = referencingProject.getResolvedClasspath(true);\r\n    for (int i = 0; i < classpath.length; i++) {\r\n        IClasspathEntry entry = classpath[i];\r\n        if (entry.getEntryKind() == IClasspathEntry.CPE_PROJECT && path.equals(entry.getPath())) {\r\n            if (entry.isExported()) {\r\n                return entry;\r\n            }\r\n            result = entry;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.code.ExtractMethodRefactoring.setThrowRuntimeExceptions",
	"Comment": "sets whether the new method signature throws runtime exceptions.",
	"Method": "void setThrowRuntimeExceptions(boolean throwRuntimeExceptions){\r\n    fThrowRuntimeExceptions = throwRuntimeExceptions;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.PropertyImpl.setLowProbability",
	"Comment": "sets the low probability used for this property. note thatchanging this while duke is processing may have unpredictableconsequences.",
	"Method": "void setLowProbability(double low){\r\n    this.low = low;\r\n}"
}, {
	"Path": "org.dcm4che3.net.Device.getInstitutionAddresses",
	"Comment": "set the address of the institution which operates this device.",
	"Method": "String[] getInstitutionAddresses(){\r\n    return institutionAddresses;\r\n}"
}, {
	"Path": "denominator.model.rdata.SOAData.expire",
	"Comment": "time value that specifies the upper limit on the time interval that can elapse before the zoneis no longer authoritative.",
	"Method": "int expire(SOAData.Builder expire,int expire){\r\n    return Integer.class.cast(get(\"expire\"));\r\n}"
}, {
	"Path": "org.dom4j.tree.FlyweightEntity.setText",
	"Comment": "sets the value of the entity if it is not defined yet otherwise anunsupportedoperationexception is thrown as this class isread only.",
	"Method": "void setText(String text){\r\n    if (this.text != null) {\r\n        this.text = text;\r\n    } else {\r\n        throw new UnsupportedOperationException(\"This Entity is read-only. \" + \"It cannot be modified\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.RdbmsOperation.setResultSetType",
	"Comment": "set whether to use statements that return a specific type of resultset.",
	"Method": "void setResultSetType(int resultSetType){\r\n    this.resultSetType = resultSetType;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource.getConnectionProperties",
	"Comment": "return the connection properties to be passed to the driver, if any.",
	"Method": "Properties getConnectionProperties(){\r\n    return this.connectionProperties;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.EntityDictionary.getFirstAnnotation",
	"Comment": "return first matching annotation from class, parents or package.",
	"Method": "Annotation getFirstAnnotation(Class<?> entityClass,List<Class<? extends Annotation>> annotationClassList){\r\n    Annotation annotation = null;\r\n    for (Class<?> cls = entityClass; annotation == null && cls != null; cls = cls.getSuperclass()) {\r\n        for (Class<? extends Annotation> annotationClass : annotationClassList) {\r\n            annotation = cls.getAnnotation(annotationClass);\r\n            if (annotation != null) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    for (Package pkg = entityClass.getPackage(); annotation == null && pkg != null; pkg = getParentPackage(pkg)) {\r\n        for (Class<? extends Annotation> annotationClass : annotationClassList) {\r\n            annotation = pkg.getAnnotation(annotationClass);\r\n            if (annotation != null) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return annotation;\r\n}"
}, {
	"Path": "org.dom4j.jaxb.JAXBWriter.endDocument",
	"Comment": "stop writing the document to the output. this must be done when all otherelements are finished.",
	"Method": "void endDocument(){\r\n    getWriter().endDocument();\r\n}"
}, {
	"Path": "com.yahoo.elide.core.PersistentResource.deleteInverseRelation",
	"Comment": "if a bidirectional relationship exists, attempts to delete itself from the inverserelationship. given a to b as the relationship, a corresponds to this and b is the inverse.",
	"Method": "void deleteInverseRelation(String relationName,Object inverseEntity){\r\n    String inverseField = getInverseRelationField(relationName);\r\n    if (!\"\".equals(inverseField)) {\r\n        Class<?> inverseType = dictionary.getType(inverseEntity.getClass(), inverseField);\r\n        String uuid = requestScope.getUUIDFor(inverseEntity);\r\n        PersistentResource inverseResource = new PersistentResource(inverseEntity, this, uuid, requestScope);\r\n        Object inverseRelation = inverseResource.getValueUnchecked(inverseField);\r\n        if (inverseRelation == null) {\r\n            return;\r\n        }\r\n        if (inverseRelation instanceof Collection) {\r\n            inverseResource.delFromCollection((Collection) inverseRelation, inverseField, this, true);\r\n        } else if (inverseType.isAssignableFrom(this.getResourceClass())) {\r\n            inverseResource.nullValue(inverseField, this);\r\n        } else {\r\n            throw new InternalServerErrorException(\"Relationship type mismatch\");\r\n        }\r\n        inverseResource.markDirty();\r\n        RelationshipType inverseRelationType = inverseResource.getRelationshipType(inverseField);\r\n        if (inverseRelationType.isToOne()) {\r\n            transaction.updateToOneRelation(transaction, inverseEntity, inverseField, null, requestScope);\r\n        } else {\r\n            assert (inverseRelation == null || inverseRelation instanceof Collection) : inverseField + \" not a collection\";\r\n            transaction.updateToManyRelation(transaction, inverseEntity, inverseField, new LinkedHashSet(), Sets.newHashSet(obj), requestScope);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.dom4j.tree.AbstractBranch.createContentList",
	"Comment": "a factory method pattern which creates a list implementation used tostore content",
	"Method": "List<Node> createContentList(List<Node> createContentList,int size){\r\n    return new ArrayList<Node>(size);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.namedparam.ParsedSql.getTotalParameterCount",
	"Comment": "return the total count of all of the parameters in the sql statement.\trepeated occurrences of the same parameter name do count here.",
	"Method": "int getTotalParameterCount(){\r\n    return this.totalParameterCount;\r\n}"
}, {
	"Path": "org.dom4j.rule.Mode.getMatchingRule",
	"Comment": "performs an xslt processing model match for the rule which matches thegiven node the best.",
	"Method": "Rule getMatchingRule(Node node){\r\n    int matchType = node.getNodeType();\r\n    if (matchType == Node.ELEMENT_NODE) {\r\n        if (elementNameRuleSets != null) {\r\n            String name = node.getName();\r\n            RuleSet ruleSet = (RuleSet) elementNameRuleSets.get(name);\r\n            if (ruleSet != null) {\r\n                Rule answer = ruleSet.getMatchingRule(node);\r\n                if (answer != null) {\r\n                    return answer;\r\n                }\r\n            }\r\n        }\r\n    } else if (matchType == Node.ATTRIBUTE_NODE) {\r\n        if (attributeNameRuleSets != null) {\r\n            String name = node.getName();\r\n            RuleSet ruleSet = (RuleSet) attributeNameRuleSets.get(name);\r\n            if (ruleSet != null) {\r\n                Rule answer = ruleSet.getMatchingRule(node);\r\n                if (answer != null) {\r\n                    return answer;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if ((matchType < 0) || (matchType >= ruleSets.length)) {\r\n        matchType = Pattern.ANY_NODE;\r\n    }\r\n    Rule answer = null;\r\n    RuleSet ruleSet = ruleSets[matchType];\r\n    if (ruleSet != null) {\r\n        answer = ruleSet.getMatchingRule(node);\r\n    }\r\n    if ((answer == null) && (matchType != Pattern.ANY_NODE)) {\r\n        ruleSet = ruleSets[Pattern.ANY_NODE];\r\n        if (ruleSet != null) {\r\n            answer = ruleSet.getMatchingRule(node);\r\n        }\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.Processor.getDatabase",
	"Comment": "returns the database in which the duke index is stored for thegiven group in record linkage mode. this will be the lucene indexif you are using the lucene database.",
	"Method": "Database getDatabase(Database getDatabase,int group){\r\n    if (group == 1)\r\n        return database1;\r\n    else if (group == 2)\r\n        return database2;\r\n    throw new DukeException(\"Unknown group \" + group);\r\n}"
}, {
	"Path": "sx.blah.discord.util.audio.providers.ProviderQueue.indexOf",
	"Comment": "gets the position of the given provider in the provider queue.",
	"Method": "int indexOf(IAudioProvider provider){\r\n    return providers.indexOf(provider);\r\n}"
}, {
	"Path": "org.dragonet.protocol.type.transaction.action.InventoryAction.getSourceItem",
	"Comment": "returns the item that was present before the action took place.",
	"Method": "Slot getSourceItem(){\r\n    return sourceItem.clone();\r\n}"
}, {
	"Path": "sx.blah.discord.handle.audit.entry.change.AuditLogChange.getOldValue",
	"Comment": "the old value, if it existed.\tthis will not be present on action types like entity creations.",
	"Method": "Optional<T> getOldValue(){\r\n    return Optional.ofNullable(oldValue);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.hover.JavaElementLabelComposer.appendElementLabel",
	"Comment": "appends the label for a java element with the flags as defined by this class.",
	"Method": "void appendElementLabel(IJavaElement element,long flags){\r\n    int type = element.getElementType();\r\n    IPackageFragmentRoot root = null;\r\n    if (type != IJavaElement.JAVA_MODEL && type != IJavaElement.JAVA_PROJECT && type != IJavaElement.PACKAGE_FRAGMENT_ROOT) {\r\n        root = JavaModelUtil.getPackageFragmentRoot(element);\r\n    }\r\n    if (root != null && getFlag(flags, JavaElementLabels.PREPEND_ROOT_PATH)) {\r\n        appendPackageFragmentRootLabel(root, JavaElementLabels.ROOT_QUALIFIED);\r\n        fBuilder.append(JavaElementLabels.CONCAT_STRING);\r\n    }\r\n    switch(type) {\r\n        case IJavaElement.METHOD:\r\n            appendMethodLabel((IMethod) element, flags);\r\n            break;\r\n        case IJavaElement.FIELD:\r\n            appendFieldLabel((IField) element, flags);\r\n            break;\r\n        case IJavaElement.LOCAL_VARIABLE:\r\n            appendLocalVariableLabel((ILocalVariable) element, flags);\r\n            break;\r\n        case IJavaElement.TYPE_PARAMETER:\r\n            appendTypeParameterLabel((ITypeParameter) element, flags);\r\n            break;\r\n        case IJavaElement.INITIALIZER:\r\n            appendInitializerLabel((IInitializer) element, flags);\r\n            break;\r\n        case IJavaElement.TYPE:\r\n            appendTypeLabel((IType) element, flags);\r\n            break;\r\n        case IJavaElement.CLASS_FILE:\r\n            appendClassFileLabel((IClassFile) element, flags);\r\n            break;\r\n        case IJavaElement.COMPILATION_UNIT:\r\n            appendCompilationUnitLabel((ICompilationUnit) element, flags);\r\n            break;\r\n        case IJavaElement.PACKAGE_FRAGMENT:\r\n            appendPackageFragmentLabel((IPackageFragment) element, flags);\r\n            break;\r\n        case IJavaElement.PACKAGE_FRAGMENT_ROOT:\r\n            appendPackageFragmentRootLabel((IPackageFragmentRoot) element, flags);\r\n            break;\r\n        case IJavaElement.IMPORT_CONTAINER:\r\n        case IJavaElement.IMPORT_DECLARATION:\r\n        case IJavaElement.PACKAGE_DECLARATION:\r\n            appendDeclarationLabel(element, flags);\r\n            break;\r\n        case IJavaElement.JAVA_PROJECT:\r\n        case IJavaElement.JAVA_MODEL:\r\n            fBuilder.append(element.getElementName());\r\n            break;\r\n        default:\r\n            fBuilder.append(element.getElementName());\r\n    }\r\n    if (root != null && getFlag(flags, JavaElementLabels.APPEND_ROOT_PATH)) {\r\n        fBuilder.append(JavaElementLabels.CONCAT_STRING);\r\n        appendPackageFragmentRootLabel(root, JavaElementLabels.ROOT_QUALIFIED);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.hover.JavaElementLabelComposer.appendTypeParametersLabels",
	"Comment": "appends labels for type parameters from type binding array.",
	"Method": "void appendTypeParametersLabels(ITypeParameter[] typeParameters,long flags){\r\n    if (typeParameters.length > 0) {\r\n        fBuilder.append(getLT());\r\n        for (int i = 0; i < typeParameters.length; i++) {\r\n            if (i > 0) {\r\n                fBuilder.append(JavaElementLabels.COMMA_STRING);\r\n            }\r\n            appendTypeParameterWithBounds(typeParameters[i], flags);\r\n        }\r\n        fBuilder.append(getGT());\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.search.text.FileNamePatternSearchScope.matchesFileName",
	"Comment": "tests if a file name matches to the file name patterns contained in the scope",
	"Method": "boolean matchesFileName(String fileName){\r\n    return getFileNameMatcher().reset(fileName).matches();\r\n}"
}, {
	"Path": "com.yahoo.elide.graphql.GraphQLConversionUtils.classToInputObject",
	"Comment": "converts a non elide object into a input query object.any attribute which cannot be converted is skipped.",
	"Method": "GraphQLInputObjectType classToInputObject(Class<?> clazz){\r\n    log.info(\"Building input object for type: {}\", clazz.getName());\r\n    if (!nonEntityDictionary.hasBinding(clazz)) {\r\n        nonEntityDictionary.bindEntity(clazz);\r\n    }\r\n    if (inputConversions.containsKey(clazz)) {\r\n        return inputConversions.get(clazz);\r\n    }\r\n    GraphQLInputObjectType.Builder objectBuilder = newInputObject();\r\n    objectBuilder.name(toValidNameName(\"__input__\" + clazz.getName()));\r\n    for (String attribute : nonEntityDictionary.getAttributes(clazz)) {\r\n        log.info(\"Building input object attribute: {}\", attribute);\r\n        Class<?> attributeClass = nonEntityDictionary.getType(clazz, attribute);\r\n        GraphQLInputObjectField.Builder fieldBuilder = newInputObjectField().name(attribute);\r\n        GraphQLInputType attributeType = attributeToInputObject(clazz, attributeClass, attribute, nonEntityDictionary);\r\n        if (attributeType == null) {\r\n            continue;\r\n        }\r\n        fieldBuilder.type(attributeType);\r\n        objectBuilder.field(fieldBuilder);\r\n    }\r\n    GraphQLInputObjectType object = objectBuilder.build();\r\n    inputConversions.put(clazz, object);\r\n    return object;\r\n}"
}, {
	"Path": "org.dcm4che3.net.TransferCapability.getCommonName",
	"Comment": "get the name of the transfer capability object. can be a meaningful nameor any unique sequence of characters.",
	"Method": "String getCommonName(){\r\n    return commonName;\r\n}"
}, {
	"Path": "sx.blah.discord.util.RequestBuilder.onTimeout",
	"Comment": "sets the handler for when the current action times out on doactionbefore or doactionafter.",
	"Method": "RequestBuilder onTimeout(Procedure timeoutProcedure){\r\n    activeAction.timeoutHandler = timeoutProcedure;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.JdbcTemplate.getSingleColumnRowMapper",
	"Comment": "create a new rowmapper for reading result objects from a single column.",
	"Method": "RowMapper<T> getSingleColumnRowMapper(Class<T> requiredType){\r\n    return new SingleColumnRowMapper<T>(requiredType);\r\n}"
}, {
	"Path": "com.yahoo.elide.core.pagination.Pagination.getPagination",
	"Comment": "construct a pagination object from page data and elide settings.",
	"Method": "Pagination getPagination(Map<PaginationKey, Integer> pageData,ElideSettings elideSettings){\r\n    Pagination result = new Pagination(pageData, elideSettings.getDefaultMaxPageSize(), elideSettings.getDefaultPageSize());\r\n    result.offset = 0;\r\n    result.limit = elideSettings.getDefaultPageSize();\r\n    return result;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.UpdateOnCreateTest.updatePermissionInheritedForRelationSuccessCase",
	"Comment": "expression for relation inherited from class level expression",
	"Method": "void updatePermissionInheritedForRelationSuccessCase(){\r\n    PersistentResource<UpdateAndCreate> loaded = PersistentResource.loadRecord(UpdateAndCreate.class, \"1\", userTwoScope);\r\n    PersistentResource<Book> loadedBook = PersistentResource.loadRecord(Book.class, \"1\", userTwoScope);\r\n    loaded.addRelation(\"books\", loadedBook);\r\n    loaded.getRequestScope().getPermissionExecutor().executeCommitChecks();\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.SqlOperation.newPreparedStatementSetter",
	"Comment": "return a preparedstatementsetter to perform an operation\twith the given parameters.",
	"Method": "PreparedStatementSetter newPreparedStatementSetter(Object[] params){\r\n    return this.preparedStatementFactory.newPreparedStatementSetter(params);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.JavaClientConnection.showNotificationMessage",
	"Comment": "sends the message to the client, to be displayed on a ui element.",
	"Method": "void showNotificationMessage(MessageType type,String msg){\r\n    MessageParams $ = new MessageParams();\r\n    $.setMessage(msg);\r\n    $.setType(type);\r\n    client.showMessage($);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.TableMetaDataContext.setOverrideIncludeSynonymsDefault",
	"Comment": "specify whether we should override default for accessing synonyms.",
	"Method": "void setOverrideIncludeSynonymsDefault(boolean override){\r\n    this.overrideIncludeSynonymsDefault = override;\r\n}"
}, {
	"Path": "org.dom4j.DocumentFactory.getInstance",
	"Comment": "access to singleton implementation of documentfactory which is used if nodocumentfactory is specified when building using the standard builders.",
	"Method": "DocumentFactory getInstance(){\r\n    if (singleton == null) {\r\n        singleton = createSingleton();\r\n    }\r\n    return singleton.instance();\r\n}"
}, {
	"Path": "org.dom4j.io.STAXEventReader.createNamespace",
	"Comment": "constructs a new dom4j namespace from the provided stax namespace event.",
	"Method": "org.dom4j.Namespace createNamespace(Namespace ns){\r\n    return factory.createNamespace(ns.getPrefix(), ns.getNamespaceURI());\r\n}"
}, {
	"Path": "denominator.model.rdata.SOAData.minimum",
	"Comment": "minimum ttl field that should be exported with any rr from this zone.",
	"Method": "int minimum(SOAData.Builder minimum,int minimum){\r\n    return Integer.class.cast(get(\"minimum\"));\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.ParentProcessWatcher.parentProcessStillRunning",
	"Comment": "checks whether the parent process is still running.\tif not, then we assume it has crashed, and we have to terminate the java language server.",
	"Method": "boolean parentProcessStillRunning(){\r\n    final long pid = server.getParentProcessId();\r\n    if (pid == 0 || lastActivityTime > (System.currentTimeMillis() - INACTIVITY_DELAY_SECS)) {\r\n        return true;\r\n    }\r\n    String command;\r\n    if (Platform.OS_WIN32.equals(Platform.getOS())) {\r\n        command = \"cmd /c \\\"tasklist /FI \\\"PID eq \" + pid + \"\\\" | findstr \" + pid + \"\\\"\";\r\n    } else {\r\n        command = \"ps -p \" + pid;\r\n    }\r\n    try {\r\n        Process process = Runtime.getRuntime().exec(command);\r\n        int processResult = process.waitFor();\r\n        return processResult == 0;\r\n    } catch (IOException | InterruptedException e) {\r\n        JavaLanguageServerPlugin.logException(e.getMessage(), e);\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.dom4j.util.XMLErrorHandler.addException",
	"Comment": "adds the given parse exception information to the given element instance",
	"Method": "void addException(Element element,SAXParseException e){\r\n    element.addAttribute(\"column\", Integer.toString(e.getColumnNumber()));\r\n    element.addAttribute(\"line\", Integer.toString(e.getLineNumber()));\r\n    String publicID = e.getPublicId();\r\n    if ((publicID != null) && (publicID.length() > 0)) {\r\n        element.addAttribute(\"publicID\", publicID);\r\n    }\r\n    String systemID = e.getSystemId();\r\n    if ((systemID != null) && (systemID.length() > 0)) {\r\n        element.addAttribute(\"systemID\", systemID);\r\n    }\r\n    element.addText(e.getMessage());\r\n}"
}, {
	"Path": "org.dom4j.io.DTDTest.testMixedDTDSubset",
	"Comment": "test verifies correct identification of the internal and external dtdsubsets.",
	"Method": "void testMixedDTDSubset(){\r\n    DocumentType expected = new DefaultDocumentType(\"another-greeting\", null, DTD_SYSTEM_ID);\r\n    expected.setInternalDeclarations(getInternalDeclarations());\r\n    expected.setExternalDeclarations(getExternalDeclarations());\r\n    assertSameDocumentType(expected, readDocument(XML_MIXED, true, true).getDocType());\r\n}"
}, {
	"Path": "com.ea.async.Async.init",
	"Comment": "ensure that if no pre instrumentation was done, that the async runtime instrumentation is running.attention! the build time instrumentation will remove calls to this method.",
	"Method": "void init(){\r\n    InitializeAsync.init();\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.SimpleJdbcDaoSupport.getSimpleJdbcTemplate",
	"Comment": "return a simplejdbctemplate wrapping the configured jdbctemplate.",
	"Method": "SimpleJdbcTemplate getSimpleJdbcTemplate(){\r\n    return this.simpleJdbcTemplate;\r\n}"
}, {
	"Path": "org.dragonet.common.maths.Vector3.getIntermediateWithXValue",
	"Comment": "returns a new vector with x value equal to the second parameter, along the line between this vector and thepassed in vector, or null if not possible.",
	"Method": "Vector3 getIntermediateWithXValue(Vector3 v,double x){\r\n    double xDiff = v.x - this.x;\r\n    double yDiff = v.y - this.y;\r\n    double zDiff = v.z - this.z;\r\n    if (xDiff * xDiff < 0.0000001) {\r\n        return null;\r\n    }\r\n    double f = (x - this.x) / xDiff;\r\n    if (f < 0 || f > 1) {\r\n        return null;\r\n    } else {\r\n        return new Vector3(this.x + xDiff * f, this.y + yDiff * f, this.z + zDiff * f);\r\n    }\r\n}"
}, {
	"Path": "sx.blah.discord.handle.impl.obj.Message.getRawRoleMentionsLong",
	"Comment": "gets a list of the unique snowflake ids of the roles mentioned in the message.",
	"Method": "List<Long> getRawRoleMentionsLong(){\r\n    return roleMentions;\r\n}"
}, {
	"Path": "org.dom4j.io.OutputFormat.setAttributeQuoteCharacter",
	"Comment": "sets the character used to quote attribute values. the specifiedcharacter must be a valid xml attribute quote character, otherwise anillegalargumentexception will be thrown.",
	"Method": "void setAttributeQuoteCharacter(char quoteChar){\r\n    if ((quoteChar == '\\'') || (quoteChar == '\"')) {\r\n        attributeQuoteChar = quoteChar;\r\n    } else {\r\n        throw new IllegalArgumentException(\"Invalid attribute quote \" + \"character (\" + quoteChar + \")\");\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.AbstractJdbcInsert.doExecuteAndReturnKeyHolder",
	"Comment": "method that provides execution of the insert using the passed in map of parameters\tand returning all generated keys",
	"Method": "KeyHolder doExecuteAndReturnKeyHolder(Map<String, Object> args,KeyHolder doExecuteAndReturnKeyHolder,SqlParameterSource parameterSource){\r\n    checkCompiled();\r\n    List<Object> values = matchInParameterValuesWithInsertColumns(parameterSource);\r\n    return executeInsertAndReturnKeyHolderInternal(values);\r\n}"
}, {
	"Path": "org.dcm4che3.net.Connection.bind",
	"Comment": "bind this network connection to a tcp port and start a server socketaccept loop.",
	"Method": "boolean bind(){\r\n    if (!(isInstalled() && isServer())) {\r\n        rebindNeeded = false;\r\n        return false;\r\n    }\r\n    if (device == null)\r\n        throw new IllegalStateException(\"Not attached to Device\");\r\n    if (isListening())\r\n        throw new IllegalStateException(\"Already listening - \" + listener);\r\n    if (protocol.isTCP()) {\r\n        TCPProtocolHandler handler = tcpHandlers.get(protocol);\r\n        if (handler == null) {\r\n            LOG.info(\"No TCP Protocol Handler for protocol {}\", protocol);\r\n            return false;\r\n        }\r\n        listener = new TCPListener(this, handler);\r\n    } else {\r\n        UDPProtocolHandler handler = udpHandlers.get(protocol);\r\n        if (handler == null) {\r\n            LOG.info(\"No UDP Protocol Handler for protocol {}\", protocol);\r\n            return false;\r\n        }\r\n        listener = new UDPListener(this, handler);\r\n    }\r\n    rebindNeeded = false;\r\n    return true;\r\n}"
}, {
	"Path": "org.dcm4che3.imageio.plugins.dcm.DicomImageReader.getStreamMetadata",
	"Comment": "gets the stream metadata.may not contain post pixel data unlessthere are no images or the getstreammetadata has been called with the post pixel data node being specified.",
	"Method": "DicomMetaData getStreamMetadata(DicomMetaData getStreamMetadata,String formatName,Set<String> nodeNames){\r\n    DicomMetaData ret = getStreamMetadata();\r\n    if (nodeNames != null && nodeNames.contains(POST_PIXEL_DATA)) {\r\n        readPostPixeldata();\r\n        return getStreamMetadata();\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.dom4j.io.SAXWriter.startPrefixMapping",
	"Comment": "fires a sax startprefixmapping event for all the namespacestack whichhave just come into scope",
	"Method": "AttributesImpl startPrefixMapping(Element element,NamespaceStack namespaceStack){\r\n    AttributesImpl namespaceAttributes = null;\r\n    Namespace elementNamespace = element.getNamespace();\r\n    if ((elementNamespace != null) && !isIgnoreableNamespace(elementNamespace, namespaceStack)) {\r\n        namespaceStack.push(elementNamespace);\r\n        contentHandler.startPrefixMapping(elementNamespace.getPrefix(), elementNamespace.getURI());\r\n        namespaceAttributes = addNamespaceAttribute(namespaceAttributes, elementNamespace);\r\n    }\r\n    List<Namespace> declaredNamespaces = element.declaredNamespaces();\r\n    for (Namespace namespace : declaredNamespaces) {\r\n        if (!isIgnoreableNamespace(namespace, namespaceStack)) {\r\n            namespaceStack.push(namespace);\r\n            contentHandler.startPrefixMapping(namespace.getPrefix(), namespace.getURI());\r\n            namespaceAttributes = addNamespaceAttribute(namespaceAttributes, namespace);\r\n        }\r\n    }\r\n    return namespaceAttributes;\r\n}"
}, {
	"Path": "org.bstats.Metrics.startSubmitting",
	"Comment": "starts the scheduler which submits our data every 30 minutes.",
	"Method": "void startSubmitting(){\r\n    final Timer timer = new Timer(true);\r\n    timer.scheduleAtFixedRate(new TimerTask() {\r\n        @Override\r\n        public void run() {\r\n            submitData();\r\n        }\r\n    }, 1000 * 60 * 5, 1000 * 60 * 30);\r\n}"
}, {
	"Path": "org.bstats.Metrics.startSubmitting",
	"Comment": "starts the scheduler which submits our data every 30 minutes.",
	"Method": "void startSubmitting(){\r\n    submitData();\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.ChangeUtil.convertCompositeChange",
	"Comment": "converts changes to resource operations if resource operations are supported\tby the client otherwise converts to textedit changes.",
	"Method": "void convertCompositeChange(Change change,WorkspaceEdit edit){\r\n    if (!(change instanceof CompositeChange)) {\r\n        return;\r\n    }\r\n    Change[] changes = ((CompositeChange) change).getChildren();\r\n    for (Change ch : changes) {\r\n        if (ch instanceof DynamicValidationRefactoringChange) {\r\n            CompositeChange compositeChange = (CompositeChange) ch;\r\n            for (Change child : compositeChange.getChildren()) {\r\n                doConvertCompositeChange(child, edit);\r\n            }\r\n        } else {\r\n            doConvertCompositeChange(ch, edit);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "sx.blah.discord.util.PermissionUtils.hasPermissions",
	"Comment": "determines if the given set of permissions has all of the required permissions.",
	"Method": "boolean hasPermissions(IGuild guild,IUser user,Permissions required,boolean hasPermissions,IGuild guild,IUser user,EnumSet<Permissions> required,boolean hasPermissions,IChannel channel,IUser user,Permissions required,boolean hasPermissions,IChannel channel,IUser user,EnumSet<Permissions> required,boolean hasPermissions,EnumSet<Permissions> permissions,EnumSet<Permissions> required){\r\n    return permissions.containsAll(required);\r\n}"
}, {
	"Path": "org.dom4j.io.XMLWriter.setEscapeText",
	"Comment": "sets whether text output should be escaped or not. this is enabled bydefault. it could be disabled if the output format is textual, like inxslt where we can have xml, html or text output.",
	"Method": "void setEscapeText(boolean escapeText){\r\n    this.escapeText = escapeText;\r\n}"
}, {
	"Path": "sx.blah.discord.api.ClientBuilder.set5xxRetryCount",
	"Comment": "configures the number of retries that should be attempted for http requests to discord in the case of a 5xx\tresponse code.",
	"Method": "ClientBuilder set5xxRetryCount(int retryCount){\r\n    this.retryCount = retryCount;\r\n    return this;\r\n}"
}, {
	"Path": "example.Parent.getSpecialAttribute",
	"Comment": "special attribute is to catch a corner case for patch extension",
	"Method": "String getSpecialAttribute(){\r\n    return specialAttribute;\r\n}"
}, {
	"Path": "org.dom4j.swing.XMLTableDefinition.load",
	"Comment": "loads an xml table definition from an xml definition document",
	"Method": "XMLTableDefinition load(Document definition,XMLTableDefinition load,Element definition){\r\n    XMLTableDefinition answer = new XMLTableDefinition();\r\n    answer.setRowExpression(definition.attributeValue(\"select\"));\r\n    for (Iterator<Element> iter = definition.elementIterator(\"column\"); iter.hasNext(); ) {\r\n        Element element = iter.next();\r\n        String expression = element.attributeValue(\"select\");\r\n        String name = element.getText();\r\n        String typeName = element.attributeValue(\"type\", \"string\");\r\n        String columnXPath = element.attributeValue(\"columnNameXPath\");\r\n        int type = XMLTableColumnDefinition.parseType(typeName);\r\n        if (columnXPath != null) {\r\n            answer.addColumnWithXPathName(columnXPath, expression, type);\r\n        } else {\r\n            answer.addColumn(name, expression, type);\r\n        }\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "japa.parser.ASTHelper.addTypeDeclaration",
	"Comment": "adds the given type declaration to the compilation unit. the list oftypes will be initialized if it is null.",
	"Method": "void addTypeDeclaration(CompilationUnit cu,TypeDeclaration type){\r\n    List<TypeDeclaration> types = cu.getTypes();\r\n    if (types == null) {\r\n        types = new ArrayList<TypeDeclaration>();\r\n        cu.setTypes(types);\r\n    }\r\n    types.add(type);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.AbstractJdbcCall.getScalarOutParameterName",
	"Comment": "get the name of a single out parameter or return value.\tused for functions or procedures with one out parameter.",
	"Method": "String getScalarOutParameterName(){\r\n    return this.callMetaDataContext.getScalarOutParameterName();\r\n}"
}, {
	"Path": "org.dcm4che3.data.Attributes.getModified",
	"Comment": "add attributes of this data set which were replaced inthe specified other data set into the result data set.if no result data set is passed, a new result set will be instantiated.",
	"Method": "Attributes getModified(Attributes other,Attributes result){\r\n    if (result == null)\r\n        result = new Attributes(other.size);\r\n    int creatorTag = -1;\r\n    int prevOtherCreatorTag = -1;\r\n    int otherCreatorTag = -1;\r\n    String privateCreator = null;\r\n    for (int i = 0; i < other.size; i++) {\r\n        int tag = other.tags[i];\r\n        if ((tag & 0x00010000) != 0) {\r\n            if ((tag & 0x0000ff00) == 0)\r\n                continue;\r\n            otherCreatorTag = TagUtils.creatorTagOf(tag);\r\n            if (prevOtherCreatorTag != otherCreatorTag) {\r\n                prevOtherCreatorTag = otherCreatorTag;\r\n                creatorTag = -1;\r\n                int k = other.indexOf(otherCreatorTag);\r\n                if (k >= 0) {\r\n                    Object o = other.decodeStringValue(k);\r\n                    if (o instanceof String) {\r\n                        privateCreator = (String) o;\r\n                        creatorTag = creatorTagOf(privateCreator, tag, false);\r\n                    }\r\n                }\r\n            }\r\n            if (creatorTag == -1)\r\n                continue;\r\n            tag = TagUtils.toPrivateTag(creatorTag, tag);\r\n        } else {\r\n            privateCreator = null;\r\n        }\r\n        int j = indexOf(tag);\r\n        if (j < 0)\r\n            continue;\r\n        Object origValue = values[j];\r\n        if (origValue instanceof Value && ((Value) origValue).isEmpty())\r\n            continue;\r\n        if (equalValues(other, j, i))\r\n            continue;\r\n        if (origValue instanceof Sequence) {\r\n            result.set(privateCreator, tag, (Sequence) origValue, null);\r\n        } else if (origValue instanceof Fragments) {\r\n            result.set(privateCreator, tag, (Fragments) origValue);\r\n        } else {\r\n            result.set(privateCreator, tag, vrs[i], origValue);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.RefactoringSearchEngine2.getAffectedCompilationUnits",
	"Comment": "returns the affected compilation units of the previous search queries.\tin order to retrieve the compilation units, grouping by resource must have been enabled before searching.",
	"Method": "ICompilationUnit[] getAffectedCompilationUnits(){\r\n    if (fGranularity == GRANULARITY_COMPILATION_UNIT) {\r\n        final Collection<?> collection = getCollector().getCollectedMatches();\r\n        final ICompilationUnit[] units = new ICompilationUnit[collection.size()];\r\n        int index = 0;\r\n        for (final Iterator<?> iterator = collection.iterator(); iterator.hasNext(); index++) {\r\n            units[index] = (ICompilationUnit) iterator.next();\r\n        }\r\n        return units;\r\n    } else {\r\n        final SearchResultGroup[] groups = getGroupedMatches();\r\n        final ICompilationUnit[] units = new ICompilationUnit[groups.length];\r\n        for (int index = 0; index < groups.length; index++) {\r\n            units[index] = groups[index].getCompilationUnit();\r\n        }\r\n        return units;\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.text.JavaBreakIterator.consumeRun",
	"Comment": "consumes a run of characters at the limits of which we introduce a break.",
	"Method": "Run consumeRun(int offset){\r\n    char ch = fText.charAt(offset);\r\n    int length = fText.length();\r\n    Run run = getRun(ch);\r\n    while (run.consume(ch) && offset < length - 1) {\r\n        offset++;\r\n        ch = fText.charAt(offset);\r\n    }\r\n    return run;\r\n}"
}, {
	"Path": "japa.parser.ast.PackageDeclaration.getAnnotations",
	"Comment": "retrieves the list of annotations declared before the packagedeclaration. return null if there are no annotations.",
	"Method": "List<AnnotationExpr> getAnnotations(){\r\n    return annotations;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.namedparam.ParsedSql.getParameterIndexes",
	"Comment": "return the parameter indexes for the specified parameter.",
	"Method": "int[] getParameterIndexes(int parameterPosition){\r\n    return this.parameterIndexes.get(parameterPosition);\r\n}"
}, {
	"Path": "denominator.model.rdata.SRVData.weight",
	"Comment": "the weight field specifies a relative weight for entries with the same priority. larger weightsshould be given a proportionately higher probability of being selected.",
	"Method": "int weight(SRVData.Builder weight,int weight){\r\n    return Integer.class.cast(get(\"weight\"));\r\n}"
}, {
	"Path": "no.priv.garshol.duke.Processor.registerNoMatchFor",
	"Comment": "notifies listeners that we found no matches for this record.",
	"Method": "void registerNoMatchFor(Record current){\r\n    long start = System.currentTimeMillis();\r\n    for (MatchListener listener : listeners) listener.noMatchFor(current);\r\n    callbacks += (System.currentTimeMillis() - start);\r\n}"
}, {
	"Path": "effectivejava.chapter2.item7.Stack.ensureCapacity",
	"Comment": "ensure space for at least one more element, roughlydoubling the capacity each time the array needs to grow.",
	"Method": "void ensureCapacity(){\r\n    if (elements.length == size)\r\n        elements = Arrays.copyOf(elements, 2 * size + 1);\r\n}"
}, {
	"Path": "org.dragonet.common.utilities.BinaryStream.putAttributeList",
	"Comment": "writes a list of attributes to the packet buffer using the standardformat.",
	"Method": "void putAttributeList(PEEntityAttribute[] attributes){\r\n    this.putUnsignedVarInt(attributes.length);\r\n    for (PEEntityAttribute attribute : attributes) {\r\n        this.putString(attribute.name);\r\n        this.putLFloat(attribute.min);\r\n        this.putLFloat(attribute.currentValue);\r\n        this.putLFloat(attribute.max);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulator.addScripts",
	"Comment": "add multiple scripts to execute to initialize or clean up the database.",
	"Method": "void addScripts(Resource scripts){\r\n    assertContentsOfScriptArray(scripts);\r\n    getScripts().addAll(Arrays.asList(scripts));\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.JdbcTemplate.getQueryTimeout",
	"Comment": "return the query timeout for statements that this jdbctemplate executes.",
	"Method": "int getQueryTimeout(){\r\n    return this.queryTimeout;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.support.JdbcBeanDefinitionReader.loadBeanDefinitions",
	"Comment": "load bean definitions from the database via the given sql string.",
	"Method": "void loadBeanDefinitions(String sql){\r\n    Assert.notNull(this.jdbcTemplate, \"Not fully configured - specify DataSource or JdbcTemplate\");\r\n    final Properties props = new Properties();\r\n    this.jdbcTemplate.query(sql, new RowCallbackHandler() {\r\n        @Override\r\n        public void processRow(ResultSet rs) throws SQLException {\r\n            String beanName = rs.getString(1);\r\n            String property = rs.getString(2);\r\n            String value = rs.getString(3);\r\n            props.setProperty(beanName + \".\" + property, value);\r\n        }\r\n    });\r\n    this.propReader.registerBeanDefinitions(props);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.support.JdbcBeanDefinitionReader.loadBeanDefinitions",
	"Comment": "load bean definitions from the database via the given sql string.",
	"Method": "void loadBeanDefinitions(String sql){\r\n    String beanName = rs.getString(1);\r\n    String property = rs.getString(2);\r\n    String value = rs.getString(3);\r\n    props.setProperty(beanName + \".\" + property, value);\r\n}"
}, {
	"Path": "no.priv.garshol.duke.utils.StringUtils.normalizeWS",
	"Comment": "removes trailing and leading whitespace, and also reduces eachsequence of internal whitespace to a single space.",
	"Method": "String normalizeWS(String value){\r\n    char[] tmp = new char[value.length()];\r\n    int pos = 0;\r\n    boolean prevws = false;\r\n    for (int ix = 0; ix < tmp.length; ix++) {\r\n        char ch = value.charAt(ix);\r\n        if (ch != ' ' && ch != '\\t' && ch != '\\n' && ch != '\\r') {\r\n            if (prevws && pos != 0)\r\n                tmp[pos++] = ' ';\r\n            tmp[pos++] = ch;\r\n            prevws = false;\r\n        } else\r\n            prevws = true;\r\n    }\r\n    return new String(tmp, 0, pos);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.javadoc.JavaDocCommentReader.getOffset",
	"Comment": "returns the offset of the last read character in the passed buffer.",
	"Method": "int getOffset(){\r\n    return fCurrPos;\r\n}"
}, {
	"Path": "org.dcm4che3.net.Connection.getHostname",
	"Comment": "this is the dns name for this particular connection. this is used toobtain the current ip address for connections. hostname must besufficiently qualified to be unambiguous for any client dns user.",
	"Method": "String getHostname(){\r\n    return hostname;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.EntityDictionary.getFieldsOfType",
	"Comment": "retrieve fields from an object containing a particular type.",
	"Method": "Set<String> getFieldsOfType(Class<?> targetClass,Class<?> targetType){\r\n    HashSet<String> fields = new HashSet();\r\n    for (String field : getAllFields(targetClass)) {\r\n        if (getParameterizedType(targetClass, field).equals(targetType)) {\r\n            fields.add(field);\r\n        }\r\n    }\r\n    return fields;\r\n}"
}, {
	"Path": "com.ea.async.instrumentation.Transformer.replaceObjectInitialization",
	"Comment": "replacing only the initialization of objects that are uninitialized at the moment of an await call.",
	"Method": "void replaceObjectInitialization(MethodNode methodNode,Frame<BasicValue>[] frames,Set<AbstractInsnNode> objectCreationNodes){\r\n    int originalLocals = methodNode.maxLocals;\r\n    final Set<AbstractInsnNode> uninitializedObjects = objectCreationNodes != null ? objectCreationNodes : Stream.of(methodNode.instructions.toArray()).filter(new Predicate<AbstractInsnNode>() {\r\n        @Override\r\n        public boolean test(final AbstractInsnNode i) {\r\n            return i.getOpcode() == NEW;\r\n        }\r\n    }).collect(Collectors.toSet());\r\n    int index = 0;\r\n    for (AbstractInsnNode insnNode = methodNode.instructions.getFirst(); insnNode != null; index++, insnNode = insnNode.getNext()) {\r\n        if (insnNode instanceof FrameNode) {\r\n            FrameNode frameNode = (FrameNode) insnNode;\r\n            frameNode.stack = replaceUninitializedFrameValues(uninitializedObjects, frameNode.stack);\r\n            frameNode.local = replaceUninitializedFrameValues(uninitializedObjects, frameNode.local);\r\n        } else if (insnNode.getOpcode() == INVOKESPECIAL) {\r\n            MethodInsnNode methodInsnNode = (MethodInsnNode) insnNode;\r\n            if (methodInsnNode.name.equals(\"<init>\")) {\r\n                insnNode = replaceConstructorCall(methodNode, frames[index], uninitializedObjects, originalLocals, methodInsnNode);\r\n            }\r\n        }\r\n    }\r\n    for (AbstractInsnNode insnNode = methodNode.instructions.getFirst(); insnNode != null; insnNode = insnNode.getNext()) {\r\n        if (insnNode.getOpcode() == NEW && (uninitializedObjects.contains(insnNode))) {\r\n            InsnNode newInsn = new InsnNode(ACONST_NULL);\r\n            methodNode.instructions.insertBefore(insnNode, newInsn);\r\n            methodNode.instructions.remove(insnNode);\r\n            insnNode = newInsn;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.ea.async.instrumentation.Transformer.replaceObjectInitialization",
	"Comment": "replacing only the initialization of objects that are uninitialized at the moment of an await call.",
	"Method": "void replaceObjectInitialization(MethodNode methodNode,Frame<BasicValue>[] frames,Set<AbstractInsnNode> objectCreationNodes){\r\n    return i.getOpcode() == NEW;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.RefactoringSearchEngine2.setGrouping",
	"Comment": "determines how search matches are grouped.\tthis method must be called before start searching. the default is to group by containing resource.",
	"Method": "void setGrouping(boolean grouping){\r\n    fGrouping = grouping;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.util.TextChangeManager.clear",
	"Comment": "clears all associations between resources and text changes.",
	"Method": "void clear(){\r\n    fMap.clear();\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.RefactoringSearchEngine2.getGroupedMatches",
	"Comment": "returns the found search matches in grouped by their containing resource.",
	"Method": "SearchResultGroup[] getGroupedMatches(){\r\n    final Map<IResource, List<SearchMatch>> grouped = new HashMap();\r\n    List<SearchMatch> matches = null;\r\n    IResource resource = null;\r\n    SearchMatch match = null;\r\n    for (final Iterator<?> iterator = getSearchMatches().iterator(); iterator.hasNext(); ) {\r\n        match = (SearchMatch) iterator.next();\r\n        resource = match.getResource();\r\n        if (!grouped.containsKey(resource)) {\r\n            grouped.put(resource, new ArrayList<SearchMatch>(4));\r\n        }\r\n        matches = grouped.get(resource);\r\n        matches.add(match);\r\n    }\r\n    if (fBinary) {\r\n        final Collection<IResource> collection = getCollector().getBinaryResources();\r\n        for (final Iterator<IResource> iterator = grouped.keySet().iterator(); iterator.hasNext(); ) {\r\n            resource = iterator.next();\r\n            if (collection.contains(resource)) {\r\n                iterator.remove();\r\n            }\r\n        }\r\n    }\r\n    final SearchResultGroup[] result = new SearchResultGroup[grouped.keySet().size()];\r\n    int index = 0;\r\n    for (final Iterator<IResource> iterator = grouped.keySet().iterator(); iterator.hasNext(); ) {\r\n        resource = iterator.next();\r\n        matches = grouped.get(resource);\r\n        result[index++] = new SearchResultGroup(resource, matches.toArray(new SearchMatch[matches.size()]));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "sx.blah.discord.util.MessageHistory.getClient",
	"Comment": "gets the client the history belongs to, or null if no messages are present.",
	"Method": "IDiscordClient getClient(){\r\n    final IChannel channel = getChannel();\r\n    return (channel == null) ? null : channel.getClient();\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.dom.fragments.AssociativeInfixExpressionFragment.getAssociatedExpression",
	"Comment": "note that this fragment does not directly represent this expression node, but\trather a part of it.",
	"Method": "Expression getAssociatedExpression(){\r\n    return fGroupRoot;\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.SqlQuery.findObject",
	"Comment": "convenient method to find a single object given a single string parameter.",
	"Method": "T findObject(Object[] params,Map<?, ?> context,T findObject,Object params,T findObject,int p1,Map<?, ?> context,T findObject,int p1,T findObject,int p1,int p2,Map<?, ?> context,T findObject,int p1,int p2,T findObject,long p1,Map<?, ?> context,T findObject,long p1,T findObject,String p1,Map<?, ?> context,T findObject,String p1){\r\n    return findObject(p1, null);\r\n}"
}, {
	"Path": "com.yahoo.elide.graphql.GraphQLConversionUtils.attributeToInputObject",
	"Comment": "helper function which converts an attribute of an entity to a graphql input type.",
	"Method": "GraphQLInputType attributeToInputObject(Class<?> parentClass,Class<?> attributeClass,String attribute,GraphQLInputType attributeToInputObject,Class<?> parentClass,Class<?> attributeClass,String attribute,EntityDictionary dictionary){\r\n    if (inputConversions.containsKey(attributeClass)) {\r\n        return inputConversions.get(attributeClass);\r\n    }\r\n    if (enumConversions.containsKey(attributeClass)) {\r\n        return enumConversions.get(attributeClass);\r\n    }\r\n    if (Class.class.isAssignableFrom(attributeClass)) {\r\n        return null;\r\n    }\r\n    if (Map.class.isAssignableFrom(attributeClass)) {\r\n        Class<?> keyType = dictionary.getParameterizedType(parentClass, attribute, 0);\r\n        Class<?> valueType = dictionary.getParameterizedType(parentClass, attribute, 1);\r\n        return classToInputMap(keyType, valueType);\r\n    } else if (Collection.class.isAssignableFrom(attributeClass)) {\r\n        Class<?> listType = dictionary.getParameterizedType(parentClass, attribute, 0);\r\n        return new GraphQLList(fetchScalarOrObjectInput(listType));\r\n    }\r\n    return fetchScalarOrObjectInput(attributeClass);\r\n}"
}, {
	"Path": "org.dom4j.io.SAXContentHandler.isIgnorableEntity",
	"Comment": "a strategy method to determine if a given entity name is ignorable",
	"Method": "boolean isIgnorableEntity(String name){\r\n    return \"amp\".equals(name) || \"apos\".equals(name) || \"gt\".equals(name) || \"lt\".equals(name) || \"quot\".equals(name);\r\n}"
}, {
	"Path": "no.priv.garshol.duke.genetic.GeneticAlgorithm.setMutationRate",
	"Comment": "sets the number of mutations to perform on each new configurationfor each generation. if not set, the algorithm will evolve amutation rate.",
	"Method": "void setMutationRate(int mutation_rate){\r\n    population.setMutationRate(mutation_rate);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.JavaClientConnection.applyWorkspaceEdit",
	"Comment": "sends a message to client to apply the given workspace edit.\tthis is available since lsp v3.0 should be used\tonly by checking the clientcapabilities.",
	"Method": "boolean applyWorkspaceEdit(WorkspaceEdit edit){\r\n    ApplyWorkspaceEditParams $ = new ApplyWorkspaceEditParams();\r\n    $.setEdit(edit);\r\n    ApplyWorkspaceEditResponse response = client.applyEdit($).join();\r\n    return response.isApplied();\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.search.text.FileNamePatternSearchScope.getFileNamePatternDescription",
	"Comment": "returns a description for the file name patterns in the scope",
	"Method": "String getFileNamePatternDescription(){\r\n    String[] ext = fFileNamePatterns.toArray(new String[fFileNamePatterns.size()]);\r\n    Arrays.sort(ext);\r\n    StringBuilder buf = new StringBuilder();\r\n    for (int i = 0; i < ext.length; i++) {\r\n        if (i > 0) {\r\n            // $NON-NLS-1$\r\n            buf.append(\", \");\r\n        }\r\n        buf.append(ext[i]);\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "com.yahoo.elide.parsers.expression.CanPaginateVisitor.canPaginate",
	"Comment": "determines whether a data store can correctly paginate a collection of resources of a givenclass for a requested set of fields.",
	"Method": "boolean canPaginate(Class<?> resourceClass,EntityDictionary dictionary,RequestScope scope){\r\n    CanPaginateVisitor visitor = new CanPaginateVisitor(dictionary, scope);\r\n    Class<? extends Annotation> annotationClass = ReadPermission.class;\r\n    ParseTree classPermissions = dictionary.getPermissionsForClass(resourceClass, annotationClass);\r\n    PaginationStatus canPaginateClass = PaginationStatus.CAN_PAGINATE;\r\n    if (classPermissions != null) {\r\n        canPaginateClass = visitor.visit(classPermissions);\r\n    }\r\n    List<String> fields = dictionary.getAllFields(resourceClass);\r\n    String resourceName = dictionary.getJsonAliasFor(resourceClass);\r\n    Set<String> requestedFields = scope.getSparseFields().getOrDefault(resourceName, Collections.EMPTY_SET);\r\n    boolean canPaginate = true;\r\n    for (String field : fields) {\r\n        if (!requestedFields.isEmpty() && !requestedFields.contains(field)) {\r\n            continue;\r\n        }\r\n        PaginationStatus canPaginateField = canPaginateClass;\r\n        ParseTree fieldPermissions = dictionary.getPermissionsForField(resourceClass, field, annotationClass);\r\n        if (fieldPermissions != null) {\r\n            canPaginateField = visitor.visit(fieldPermissions);\r\n        }\r\n        if (canPaginateField == PaginationStatus.USER_CHECK_TRUE) {\r\n            return true;\r\n        }\r\n        if (canPaginateField == PaginationStatus.CANNOT_PAGINATE) {\r\n            canPaginate = false;\r\n        }\r\n    }\r\n    return canPaginate;\r\n}"
}, {
	"Path": "sx.blah.discord.util.EmbedBuilder.withUrl",
	"Comment": "sets the url of the embed. title must be present for the url to work.",
	"Method": "EmbedBuilder withUrl(String url){\r\n    embed.url = url;\r\n    return this;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.databases.KeyValueDatabase.collectCandidates",
	"Comment": "goes through the first buckets, picking out candidate records andtallying up their scores.",
	"Method": "int collectCandidates(Map<Long, Score> candidates,List<Bucket> buckets,int threshold){\r\n    int ix;\r\n    for (ix = 0; ix < threshold && candidates.size() < (CUTOFF_FACTOR_1 * max_search_hits); ix++) {\r\n        Bucket b = buckets.get(ix);\r\n        long[] ids = b.records;\r\n        double score = b.getScore();\r\n        for (int ix2 = 0; ix2 < b.nextfree; ix2++) {\r\n            Score s = candidates.get(ids[ix2]);\r\n            if (s == null) {\r\n                s = new Score(ids[ix2]);\r\n                candidates.put(ids[ix2], s);\r\n            }\r\n            s.score += score;\r\n        }\r\n        if (DEBUG)\r\n            System.out.println(\"Bucket \" + b.nextfree + \" -> \" + candidates.size());\r\n    }\r\n    return ix;\r\n}"
}, {
	"Path": "org.dom4j.io.STAXEventReader.createProcessingInstruction",
	"Comment": "constructs a new dom4j processinginstruction from the provided staxprocessinginstruction event.",
	"Method": "org.dom4j.ProcessingInstruction createProcessingInstruction(ProcessingInstruction pi){\r\n    return factory.createProcessingInstruction(pi.getTarget(), pi.getData());\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.SqlCall.newCallableStatementCreator",
	"Comment": "return a callablestatementcreator to perform an operation\twith the parameters returned from this parametermapper.",
	"Method": "CallableStatementCreator newCallableStatementCreator(Map<String, ?> inParams,CallableStatementCreator newCallableStatementCreator,ParameterMapper inParamMapper){\r\n    return this.callableStatementFactory.newCallableStatementCreator(inParamMapper);\r\n}"
}, {
	"Path": "org.dragonet.common.maths.ChunkPos.getBlock",
	"Comment": "get the world coordinates of the block with the given chunk coordinatesrelative to this chunk",
	"Method": "BlockPosition getBlock(int x,int y,int z){\r\n    return new BlockPosition((this.chunkXPos << 4) + x, y, (this.chunkZPos << 4) + z);\r\n}"
}, {
	"Path": "org.dom4j.io.SAXValidator.createXMLReader",
	"Comment": "factory method to allow alternate methods of creating and configuringxmlreader objects",
	"Method": "XMLReader createXMLReader(){\r\n    return SAXHelper.createXMLReader(true);\r\n}"
}, {
	"Path": "com.dslplatform.json.JsonReader.read",
	"Comment": "read next byte from the json input.\tif buffer has been read in full ioexception will be thrown",
	"Method": "byte read(T read,JsonReader reader){\r\n    if (stream != null && currentIndex > readLimit) {\r\n        prepareNextBlock();\r\n    }\r\n    if (currentIndex >= length) {\r\n        throw new IOException(\"Unexpected end of JSON input\");\r\n    }\r\n    return last = buffer[currentIndex++];\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.SqlFunction.runGeneric",
	"Comment": "convenient method to run the function with a single int argument.",
	"Method": "Object runGeneric(Object runGeneric,int parameter,Object runGeneric,Object[] parameters){\r\n    return findObject(parameters);\r\n}"
}, {
	"Path": "com.yahoo.elide.core.hibernate.hql.AbstractHQLQueryBuilder.supplyFilterQueryParameters",
	"Comment": "given a collection of filter predicates and a hibernate query, populates the named parameters in thehibernate query.",
	"Method": "void supplyFilterQueryParameters(Query query,Collection<FilterPredicate> predicates){\r\n    for (FilterPredicate filterPredicate : predicates) {\r\n        if (filterPredicate.getOperator().isParameterized()) {\r\n            boolean shouldEscape = filterPredicate.isMatchingOperator();\r\n            filterPredicate.getParameters().forEach(param -> {\r\n                query.setParameter(param.getName(), shouldEscape ? param.escapeMatching() : param.getValue());\r\n            });\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.dom4j.io.SAXContentHandler.error",
	"Comment": "this method is called when an error is detected during parsing such as avalidation error. this method rethrows the exception",
	"Method": "void error(SAXParseException exception){\r\n    throw exception;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.preferences.PreferenceManager.addPreferencesChangeListener",
	"Comment": "register the given listener for notification of preferences changes. calling\tthis method multiple times with the same listener has no effect. the given\tlistener argument must not be null.",
	"Method": "void addPreferencesChangeListener(IPreferencesChangeListener listener){\r\n    preferencesChangeListeners.add(listener);\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.DataSourceTransactionManager.getDataSource",
	"Comment": "return the jdbc datasource that this instance manages transactions for.",
	"Method": "DataSource getDataSource(){\r\n    return this.dataSource;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.AbstractJdbcInsert.doExecuteAndReturnKey",
	"Comment": "method that provides execution of the insert using the passed in map of parameters\tand returning a generated key",
	"Method": "Number doExecuteAndReturnKey(Map<String, Object> args,Number doExecuteAndReturnKey,SqlParameterSource parameterSource){\r\n    checkCompiled();\r\n    List<Object> values = matchInParameterValuesWithInsertColumns(parameterSource);\r\n    return executeInsertAndReturnKeyInternal(values);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.code.ExtractConstantRefactoring.checkConstantNameOnChange",
	"Comment": "this method performs checks on the constant name which are quick enough to be\tperformed every time the ui input component contents are changed.",
	"Method": "RefactoringStatus checkConstantNameOnChange(){\r\n    if (Arrays.asList(getExcludedVariableNames()).contains(fConstantName)) {\r\n        return RefactoringStatus.createErrorStatus(Messages.format(RefactoringCoreMessages.ExtractConstantRefactoring_another_variable, BasicElementLabels.getJavaElementName(getConstantName())));\r\n    }\r\n    return Checks.checkConstantName(fConstantName, fCu);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.dom.ModifierRewrite.internalSetModifiers",
	"Comment": "sets the given modifiers and removes all other modifiers that match the\tconsideredflags mask. does not touch other flags and leaves annotations in\tplace.",
	"Method": "PositionInformation internalSetModifiers(int modifiers,int consideredFlags,TextEditGroup editGroup){\r\n    int newModifiers = modifiers & consideredFlags;\r\n    ITrackedNodePosition trackedFallback = null;\r\n    List<ITrackedNodePosition> trackedNodes = new ArrayList();\r\n    List<IExtendedModifier> originalList = fModifierRewrite.getOriginalList();\r\n    for (int i = 0; i < originalList.size(); i++) {\r\n        ASTNode curr = (ASTNode) originalList.get(i);\r\n        if (curr instanceof Modifier) {\r\n            int flag = ((Modifier) curr).getKeyword().toFlagValue();\r\n            if ((consideredFlags & flag) != 0) {\r\n                if ((newModifiers & flag) == 0) {\r\n                    fModifierRewrite.remove(curr, editGroup);\r\n                    if (trackedFallback == null) {\r\n                        trackedFallback = fModifierRewrite.getASTRewrite().track(curr);\r\n                    }\r\n                }\r\n                newModifiers &= ~flag;\r\n            }\r\n        }\r\n    }\r\n    IExtendedModifier lastAnnotation = null;\r\n    List<IExtendedModifier> extendedList = fModifierRewrite.getRewrittenList();\r\n    for (int i = 0; i < extendedList.size(); i++) {\r\n        IExtendedModifier curr = extendedList.get(i);\r\n        if (curr.isAnnotation()) {\r\n            lastAnnotation = curr;\r\n        }\r\n    }\r\n    List<Modifier> newNodes = ASTNodeFactory.newModifiers(fAst, newModifiers);\r\n    for (int i = 0; i < newNodes.size(); i++) {\r\n        Modifier curr = newNodes.get(i);\r\n        if ((curr.getKeyword().toFlagValue() & VISIBILITY_MODIFIERS) != 0) {\r\n            if (lastAnnotation != null) {\r\n                fModifierRewrite.insertAfter(curr, (ASTNode) lastAnnotation, editGroup);\r\n            } else {\r\n                fModifierRewrite.insertFirst(curr, editGroup);\r\n            }\r\n        } else {\r\n            fModifierRewrite.insertLast(curr, editGroup);\r\n        }\r\n        trackedNodes.add(fModifierRewrite.getASTRewrite().track(curr));\r\n    }\r\n    if (trackedNodes.isEmpty()) {\r\n        if (trackedFallback == null) {\r\n            trackedFallback = fModifierRewrite.getASTRewrite().track(fModifierRewrite.getParent());\r\n        }\r\n        return new LinkedProposalPositionGroupCore.StartPositionInformation(trackedFallback);\r\n    } else {\r\n        return new LinkedProposalPositionGroupCore.TrackedNodesPosition(trackedNodes);\r\n    }\r\n}"
}, {
	"Path": "sx.blah.discord.handle.audit.entry.AuditLogEntry.getResponsibleUser",
	"Comment": "gets the user responsible for the action represented by the entry.",
	"Method": "IUser getResponsibleUser(){\r\n    return user;\r\n}"
}, {
	"Path": "sx.blah.discord.util.audio.processors.MultiProcessor.indexOf",
	"Comment": "gets the position of the provided processor in the processor queue.",
	"Method": "int indexOf(IAudioProcessor processor){\r\n    return processors.indexOf(processor);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.PreparedStatementCreatorFactory.newPreparedStatementSetter",
	"Comment": "return a new preparedstatementsetter for the given parameters.",
	"Method": "PreparedStatementSetter newPreparedStatementSetter(List<?> params,PreparedStatementSetter newPreparedStatementSetter,Object[] params){\r\n    return new PreparedStatementCreatorImpl(params != null ? Arrays.asList(params) : Collections.emptyList());\r\n}"
}, {
	"Path": "denominator.route53.AliasTarget.hostedZoneId",
	"Comment": "hosted zone id for your cloudfront distribution, amazon s3 bucket, elastic load balancing loadbalancer, or route 53 hosted zone.",
	"Method": "String hostedZoneId(){\r\n    return get(\"HostedZoneId\").toString();\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.participants.ResourceModifications.addMove",
	"Comment": "adds the given resource to the list of resources\tto be moved.",
	"Method": "void addMove(IResource move,MoveArguments arguments){\r\n    if (fMove == null) {\r\n        fMove = new ArrayList(2);\r\n        fMoveArguments = new ArrayList(2);\r\n    }\r\n    fMove.add(move);\r\n    fMoveArguments.add(arguments);\r\n    if (fIgnoreCount == 0) {\r\n        IPath destination = ((IResource) arguments.getDestination()).getFullPath().append(move.getName());\r\n        internalAdd(new MoveDescription(move, destination));\r\n    }\r\n}"
}, {
	"Path": "org.dom4j.io.STAXEventReader.createAttribute",
	"Comment": "constructs a new dom4j attribute from the provided stax attribute event.",
	"Method": "org.dom4j.Attribute createAttribute(Element elem,Attribute attr){\r\n    return factory.createAttribute(elem, createQName(attr.getName()), attr.getValue());\r\n}"
}, {
	"Path": "com.yahoo.elide.core.EntityDictionary.getAllFields",
	"Comment": "get a list of all fields including both relationships and attributes.",
	"Method": "List<String> getAllFields(Class<?> entityClass,List<String> getAllFields,Object entity){\r\n    return getAllFields(entity.getClass());\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corrections.NameMatcher.getSimilarity",
	"Comment": "returns a similarity value of the two names.\tthe range of is from 0 to 256. no similarity is negative",
	"Method": "int getSimilarity(String name1,String name2){\r\n    if (name1.length() > name2.length()) {\r\n        String tmp = name1;\r\n        name1 = name2;\r\n        name2 = tmp;\r\n    }\r\n    int name1len = name1.length();\r\n    int name2len = name2.length();\r\n    int nMatched = 0;\r\n    int i = 0;\r\n    while (i < name1len && isSimilarChar(name1.charAt(i), name2.charAt(i))) {\r\n        i++;\r\n        nMatched++;\r\n    }\r\n    int k = name1len;\r\n    int diff = name2len - name1len;\r\n    while (k > i && isSimilarChar(name1.charAt(k - 1), name2.charAt(k + diff - 1))) {\r\n        k--;\r\n        nMatched++;\r\n    }\r\n    if (nMatched == name2len) {\r\n        return 200;\r\n    }\r\n    if (name2len - nMatched > nMatched) {\r\n        return -1;\r\n    }\r\n    int tolerance = name2len / 4 + 1;\r\n    return (tolerance - (k - i)) * 256 / tolerance;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseFactory.setDatabaseConfigurer",
	"Comment": "set the strategy that will be used to configure the embedded database instance.\tcall this when you wish to use an embedded database type not already supported.",
	"Method": "void setDatabaseConfigurer(EmbeddedDatabaseConfigurer configurer){\r\n    this.databaseConfigurer = configurer;\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.StoredProcedure.allowsUnusedParameters",
	"Comment": "storedprocedure parameter maps are by default allowed to contain\tadditional entries that are not actually used as parameters.",
	"Method": "boolean allowsUnusedParameters(){\r\n    return true;\r\n}"
}, {
	"Path": "denominator.cli.Denominator.logModule",
	"Comment": "returns a log configuration module or null if none is needed.",
	"Method": "Object logModule(boolean quiet,boolean verbose){\r\n    checkArgument(!(quiet && verbose), \"quiet and verbose flags cannot be used at the same time!\");\r\n    Logger.Level logLevel;\r\n    if (quiet) {\r\n        return null;\r\n    } else if (verbose) {\r\n        logLevel = Logger.Level.FULL;\r\n    } else {\r\n        logLevel = Logger.Level.BASIC;\r\n    }\r\n    return new LogModule(logLevel);\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.JdbcAccessor.setDatabaseProductName",
	"Comment": "specify the database product name for the datasource that this accessor uses.\tthis allows to initialize a sqlerrorcodesqlexceptiontranslator without\tobtaining a connection from the datasource to get the metadata.",
	"Method": "void setDatabaseProductName(String dbName){\r\n    this.exceptionTranslator = new SQLErrorCodeSQLExceptionTranslator(dbName);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.AbstractJdbcInsert.checkIfConfigurationModificationIsAllowed",
	"Comment": "method to check whether we are allowed to make any configuration changes at this time.\tif the class has been compiled, then no further changes to the configuration are allowed.",
	"Method": "void checkIfConfigurationModificationIsAllowed(){\r\n    if (isCompiled()) {\r\n        throw new InvalidDataAccessApiUsageException(\"Configuration can't be altered once the class has been compiled or used\");\r\n    }\r\n}"
}, {
	"Path": "sx.blah.discord.util.cache.Cache.forEachWhile",
	"Comment": "performs the given action for each pair of key and value in the cache while the function returns true.",
	"Method": "boolean forEachWhile(LongObjPredicate<? super T> predicate,boolean forEachWhile,LongObjPredicate<? super T> predicate,boolean forEachWhile,LongObjPredicate<? super T> predicate){\r\n    return delegate.forEachWhile(predicate);\r\n}"
}, {
	"Path": "sx.blah.discord.util.EmbedBuilder.setLenient",
	"Comment": "sets whether the builder should sanitize input to prevent errors automatically.",
	"Method": "EmbedBuilder setLenient(boolean lenient){\r\n    this.lenient = lenient;\r\n    return this;\r\n}"
}, {
	"Path": "org.dom4j.ThreadingTest.testQNameCache",
	"Comment": "this test isolates qnamecache in a multithreaded environment.",
	"Method": "void testQNameCache(){\r\n    int loop = 100;\r\n    try {\r\n        long begin = System.currentTimeMillis();\r\n        String value = null;\r\n        String expected = null;\r\n        String xml = null;\r\n        Document doc = null;\r\n        Element root = null;\r\n        Element item = null;\r\n        Element newItem = null;\r\n        QName qn = null;\r\n        Namespace ns = null;\r\n        long now = 0;\r\n        xml = \"<ROOT xmlns:t0=\\\"http://www.lse.com/t0\\\" >\" + \"  <ctx><type>Context<\/type><\/ctx>\" + \"  <A><B><C><D>This is a TEST<\/D><\/C><\/B><\/A>\" + \"  <t0:Signon><A>xyz<\/A><t0:Cust>customer<\/t0:Cust>\" + \"<\/t0:Signon><\/ROOT>\";\r\n        for (int i = 0; i < loop; i++) {\r\n            doc = DocumentHelper.parseText(xml);\r\n            root = doc.getRootElement();\r\n            qn = DocumentHelper.createQName(\"test\");\r\n            value = fetchValue(qn);\r\n            expected = \"<test/>\";\r\n            assertEquals(\"test test \", expected, value);\r\n            qn = DocumentHelper.createQName(\"test\");\r\n            value = fetchValue(qn);\r\n            expected = \"<test/>\";\r\n            assertEquals(\"test test again \", expected, value);\r\n            qn = root.getQName(\"t0:Signon\");\r\n            value = fetchValue(qn);\r\n            expected = \"<t0:Signon xmlns:t0=\\\"http://www.lse.com/t0\\\"/>\";\r\n            assertEquals(\"test t0:Signon \", expected, value);\r\n        }\r\n        double duration = System.currentTimeMillis() - begin;\r\n        double avg = duration / loop;\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        assertTrue(\"Exception in test: \" + e.getMessage(), false);\r\n    }\r\n}"
}, {
	"Path": "no.priv.garshol.duke.ConfigurationImpl.getIdentityProperties",
	"Comment": "the properties which are used to identify records, rather thancompare them.",
	"Method": "Collection<Property> getIdentityProperties(){\r\n    Collection<Property> ids = new ArrayList();\r\n    for (Property p : getProperties()) if (p.isIdProperty())\r\n        ids.add(p);\r\n    return ids;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.support.JdbcDaoSupport.setJdbcTemplate",
	"Comment": "set the jdbctemplate for this dao explicitly,\tas an alternative to specifying a datasource.",
	"Method": "void setJdbcTemplate(JdbcTemplate jdbcTemplate){\r\n    this.jdbcTemplate = jdbcTemplate;\r\n    initTemplateConfig();\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.contentassist.ParameterGuesser.parameterProposals",
	"Comment": "returns the matches for the type and name argument, ordered by match quality.",
	"Method": "String parameterProposals(String expectedType,String paramName,IJavaElement[] suggestions){\r\n    List<Variable> typeMatches = evaluateVisibleMatches(expectedType, suggestions);\r\n    orderMatches(typeMatches, paramName);\r\n    String[] ret = new String[typeMatches.size()];\r\n    if (typeMatches.size() > 0) {\r\n        int i = 0;\r\n        for (Iterator<Variable> it = typeMatches.iterator(); it.hasNext(); ) {\r\n            Variable v = it.next();\r\n            if (i == 0) {\r\n                fAlreadyMatchedNames.add(v.name);\r\n            }\r\n            ret[i++] = v.name;\r\n        }\r\n        return ret[0];\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "sx.blah.discord.api.ClientBuilder.withShards",
	"Comment": "configures the number of shards the client should create and manage.",
	"Method": "ClientBuilder withShards(int shardCount){\r\n    this.shardCount = shardCount;\r\n    return this;\r\n}"
}, {
	"Path": "com.yahoo.elide.datastores.multiplex.MultiplexManager.getSubManager",
	"Comment": "lookup subordinate database manager for provided entity class.",
	"Method": "DataStore getSubManager(Class<T> cls){\r\n    Class<T> type = (Class<T>) dictionary.lookupEntityClass(cls);\r\n    return dataStoreMap.get(type);\r\n}"
}, {
	"Path": "org.dom4j.jaxb.JAXBReader.removeHandler",
	"Comment": "removes the elementhandler from the event based processor,for the specified path.",
	"Method": "void removeHandler(String path){\r\n    getReader().removeHandler(path);\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.SqlCall.compileInternal",
	"Comment": "overridden method to configure the callablestatementcreatorfactory\tbased on our declared parameters.",
	"Method": "void compileInternal(){\r\n    if (isSqlReadyForUse()) {\r\n        this.callString = getSql();\r\n    } else {\r\n        List<SqlParameter> parameters = getDeclaredParameters();\r\n        int parameterCount = 0;\r\n        if (isFunction()) {\r\n            this.callString = \"{? = call \" + getSql() + \"(\";\r\n            parameterCount = -1;\r\n        } else {\r\n            this.callString = \"{call \" + getSql() + \"(\";\r\n        }\r\n        for (SqlParameter parameter : parameters) {\r\n            if (!(parameter.isResultsParameter())) {\r\n                if (parameterCount > 0) {\r\n                    this.callString += \", \";\r\n                }\r\n                if (parameterCount >= 0) {\r\n                    this.callString += \"?\";\r\n                }\r\n                parameterCount++;\r\n            }\r\n        }\r\n        this.callString += \")}\";\r\n    }\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Compiled stored procedure. Call string is [\" + getCallString() + \"]\");\r\n    }\r\n    this.callableStatementFactory = new CallableStatementCreatorFactory(getCallString(), getDeclaredParameters());\r\n    this.callableStatementFactory.setResultSetType(getResultSetType());\r\n    this.callableStatementFactory.setUpdatableResults(isUpdatableResults());\r\n    this.callableStatementFactory.setNativeJdbcExtractor(getJdbcTemplate().getNativeJdbcExtractor());\r\n    onCompileInternal();\r\n}"
}, {
	"Path": "org.dom4j.tree.BackedList.addLocal",
	"Comment": "performs a local addition which is not forward through to the branch orbacking list",
	"Method": "void addLocal(T node){\r\n    super.add(node);\r\n}"
}, {
	"Path": "org.dom4j.io.SAXWriter.endPrefixMapping",
	"Comment": "fires a sax endprefixmapping event for all the namespacestack which havegone out of scope",
	"Method": "void endPrefixMapping(NamespaceStack stack,int stackSize){\r\n    while (stack.size() > stackSize) {\r\n        Namespace namespace = stack.pop();\r\n        if (namespace != null) {\r\n            contentHandler.endPrefixMapping(namespace.getPrefix());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.CallableStatementCreatorFactory.newCallableStatementCreator",
	"Comment": "return a new callablestatementcreator instance given this parameter mapper.",
	"Method": "CallableStatementCreator newCallableStatementCreator(Map<String, ?> params,CallableStatementCreator newCallableStatementCreator,ParameterMapper inParamMapper){\r\n    return new CallableStatementCreatorImpl(inParamMapper);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider.setSupportsSchemasInProcedureCalls",
	"Comment": "specify whether the database supports the use of schema name in procedure calls",
	"Method": "void setSupportsSchemasInProcedureCalls(boolean supportsSchemasInProcedureCalls){\r\n    this.supportsSchemasInProcedureCalls = supportsSchemasInProcedureCalls;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.DataSourceUtils.applyTransactionTimeout",
	"Comment": "apply the current transaction timeout, if any,\tto the given jdbc statement object.",
	"Method": "void applyTransactionTimeout(Statement stmt,DataSource dataSource){\r\n    applyTimeout(stmt, dataSource, 0);\r\n}"
}, {
	"Path": "com.dslplatform.json.JsonReader.readKey",
	"Comment": "read key value of json input.\tif key cache is used, it will be looked up from there.",
	"Method": "String readKey(){\r\n    final int len = parseString();\r\n    final String key = keyCache != null ? keyCache.get(chars, len) : new String(chars, 0, len);\r\n    if (getNextToken() != ':') {\r\n        throw new IOException(\"Expecting ':' \" + positionDescription() + \". Found \" + (char) last);\r\n    }\r\n    getNextToken();\r\n    return key;\r\n}"
}, {
	"Path": "org.dragonet.protocol.type.transaction.action.InventoryAction.getTargetItem",
	"Comment": "returns the item that the action attempted to replace the source item with.",
	"Method": "Slot getTargetItem(){\r\n    return targetItem.clone();\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.PreparedStatementCreatorFactory.setNativeJdbcExtractor",
	"Comment": "specify the nativejdbcextractor to use for unwrapping preparedstatements, if any.",
	"Method": "void setNativeJdbcExtractor(NativeJdbcExtractor nativeJdbcExtractor){\r\n    this.nativeJdbcExtractor = nativeJdbcExtractor;\r\n}"
}, {
	"Path": "denominator.clouddns.CloudDNSResourceRecordSetApi.getPriority",
	"Comment": "has the side effect of removing the priority from the mutablerdata.",
	"Method": "Integer getPriority(Map<String, Object> mutableRData){\r\n    Integer priority = null;\r\n    if (mutableRData.containsKey(\"priority\")) {\r\n        priority = Integer.class.cast(mutableRData.remove(\"priority\"));\r\n    } else if (mutableRData.containsKey(\"preference\")) {\r\n        priority = Integer.class.cast(mutableRData.remove(\"preference\"));\r\n    }\r\n    return priority;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider.setStoresUpperCaseIdentifiers",
	"Comment": "specify whether the database uses upper case for identifiers",
	"Method": "void setStoresUpperCaseIdentifiers(boolean storesUpperCaseIdentifiers){\r\n    this.storesUpperCaseIdentifiers = storesUpperCaseIdentifiers;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.AbstractJdbcCall.setAccessCallParameterMetaData",
	"Comment": "specify whether the parameter metadata for the call should be used. the default is true.",
	"Method": "void setAccessCallParameterMetaData(boolean accessCallParameterMetaData){\r\n    this.callMetaDataContext.setAccessCallParameterMetaData(accessCallParameterMetaData);\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder.setScriptEncoding",
	"Comment": "specify the character encoding used in all sql scripts, if different from\tthe platform encoding.",
	"Method": "EmbeddedDatabaseBuilder setScriptEncoding(String scriptEncoding){\r\n    this.databasePopulator.setSqlScriptEncoding(scriptEncoding);\r\n    return this;\r\n}"
}, {
	"Path": "org.dom4j.swing.XMLTableModel.setSource",
	"Comment": "setter for the xml source, which is usually a node or list of nodes.",
	"Method": "void setSource(Object source){\r\n    this.source = source;\r\n    this.rows = null;\r\n}"
}, {
	"Path": "sx.blah.discord.api.ClientBuilder.withRecommendedShardCount",
	"Comment": "configures whether the client should request the number of shards to login with from discord.",
	"Method": "ClientBuilder withRecommendedShardCount(boolean useRecommended,ClientBuilder withRecommendedShardCount){\r\n    return withRecommendedShardCount(true);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.highlighting.SemanticHighlightingService.getIndex",
	"Comment": "returns with the scope for the index. if not found, throws an exception.",
	"Method": "int getIndex(List<String> scopes){\r\n    Integer index = LOOKUP_TABLE.inverse().get(scopes);\r\n    Assert.isNotNull(index, \"Cannot get index for scopes: \" + Iterables.toString(scopes));\r\n    return index;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.CallMetaDataProviderFactory.createMetaDataProvider",
	"Comment": "create a callmetadataprovider based on the database metadata",
	"Method": "CallMetaDataProvider createMetaDataProvider(DataSource dataSource,CallMetaDataContext context){\r\n    try {\r\n        return (CallMetaDataProvider) JdbcUtils.extractDatabaseMetaData(dataSource, new DatabaseMetaDataCallback() {\r\n            @Override\r\n            public Object processMetaData(DatabaseMetaData databaseMetaData) throws SQLException, MetaDataAccessException {\r\n                String databaseProductName = JdbcUtils.commonDatabaseName(databaseMetaData.getDatabaseProductName());\r\n                boolean accessProcedureColumnMetaData = context.isAccessCallParameterMetaData();\r\n                if (context.isFunction()) {\r\n                    if (!supportedDatabaseProductsForFunctions.contains(databaseProductName)) {\r\n                        if (logger.isWarnEnabled()) {\r\n                            logger.warn(databaseProductName + \" is not one of the databases fully supported for function calls \" + \"-- supported are: \" + supportedDatabaseProductsForFunctions);\r\n                        }\r\n                        if (accessProcedureColumnMetaData) {\r\n                            logger.warn(\"Metadata processing disabled - you must specify all parameters explicitly\");\r\n                            accessProcedureColumnMetaData = false;\r\n                        }\r\n                    }\r\n                } else {\r\n                    if (!supportedDatabaseProductsForProcedures.contains(databaseProductName)) {\r\n                        if (logger.isWarnEnabled()) {\r\n                            logger.warn(databaseProductName + \" is not one of the databases fully supported for procedure calls \" + \"-- supported are: \" + supportedDatabaseProductsForProcedures);\r\n                        }\r\n                        if (accessProcedureColumnMetaData) {\r\n                            logger.warn(\"Metadata processing disabled - you must specify all parameters explicitly\");\r\n                            accessProcedureColumnMetaData = false;\r\n                        }\r\n                    }\r\n                }\r\n                CallMetaDataProvider provider;\r\n                if (\"Oracle\".equals(databaseProductName)) {\r\n                    provider = new OracleCallMetaDataProvider(databaseMetaData);\r\n                } else if (\"DB2\".equals(databaseProductName)) {\r\n                    provider = new Db2CallMetaDataProvider((databaseMetaData));\r\n                } else if (\"Apache Derby\".equals(databaseProductName)) {\r\n                    provider = new DerbyCallMetaDataProvider((databaseMetaData));\r\n                } else if (\"PostgreSQL\".equals(databaseProductName)) {\r\n                    provider = new PostgresCallMetaDataProvider((databaseMetaData));\r\n                } else if (\"Sybase\".equals(databaseProductName)) {\r\n                    provider = new SybaseCallMetaDataProvider((databaseMetaData));\r\n                } else if (\"Microsoft SQL Server\".equals(databaseProductName)) {\r\n                    provider = new SqlServerCallMetaDataProvider((databaseMetaData));\r\n                } else {\r\n                    provider = new GenericCallMetaDataProvider(databaseMetaData);\r\n                }\r\n                if (logger.isDebugEnabled()) {\r\n                    logger.debug(\"Using \" + provider.getClass().getName());\r\n                }\r\n                provider.initializeWithMetaData(databaseMetaData);\r\n                if (accessProcedureColumnMetaData) {\r\n                    provider.initializeWithProcedureColumnMetaData(databaseMetaData, context.getCatalogName(), context.getSchemaName(), context.getProcedureName());\r\n                }\r\n                return provider;\r\n            }\r\n        });\r\n    } catch (MetaDataAccessException ex) {\r\n        throw new DataAccessResourceFailureException(\"Error retreiving database metadata\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.CallMetaDataProviderFactory.createMetaDataProvider",
	"Comment": "create a callmetadataprovider based on the database metadata",
	"Method": "CallMetaDataProvider createMetaDataProvider(DataSource dataSource,CallMetaDataContext context){\r\n    String databaseProductName = JdbcUtils.commonDatabaseName(databaseMetaData.getDatabaseProductName());\r\n    boolean accessProcedureColumnMetaData = context.isAccessCallParameterMetaData();\r\n    if (context.isFunction()) {\r\n        if (!supportedDatabaseProductsForFunctions.contains(databaseProductName)) {\r\n            if (logger.isWarnEnabled()) {\r\n                logger.warn(databaseProductName + \" is not one of the databases fully supported for function calls \" + \"-- supported are: \" + supportedDatabaseProductsForFunctions);\r\n            }\r\n            if (accessProcedureColumnMetaData) {\r\n                logger.warn(\"Metadata processing disabled - you must specify all parameters explicitly\");\r\n                accessProcedureColumnMetaData = false;\r\n            }\r\n        }\r\n    } else {\r\n        if (!supportedDatabaseProductsForProcedures.contains(databaseProductName)) {\r\n            if (logger.isWarnEnabled()) {\r\n                logger.warn(databaseProductName + \" is not one of the databases fully supported for procedure calls \" + \"-- supported are: \" + supportedDatabaseProductsForProcedures);\r\n            }\r\n            if (accessProcedureColumnMetaData) {\r\n                logger.warn(\"Metadata processing disabled - you must specify all parameters explicitly\");\r\n                accessProcedureColumnMetaData = false;\r\n            }\r\n        }\r\n    }\r\n    CallMetaDataProvider provider;\r\n    if (\"Oracle\".equals(databaseProductName)) {\r\n        provider = new OracleCallMetaDataProvider(databaseMetaData);\r\n    } else if (\"DB2\".equals(databaseProductName)) {\r\n        provider = new Db2CallMetaDataProvider((databaseMetaData));\r\n    } else if (\"Apache Derby\".equals(databaseProductName)) {\r\n        provider = new DerbyCallMetaDataProvider((databaseMetaData));\r\n    } else if (\"PostgreSQL\".equals(databaseProductName)) {\r\n        provider = new PostgresCallMetaDataProvider((databaseMetaData));\r\n    } else if (\"Sybase\".equals(databaseProductName)) {\r\n        provider = new SybaseCallMetaDataProvider((databaseMetaData));\r\n    } else if (\"Microsoft SQL Server\".equals(databaseProductName)) {\r\n        provider = new SqlServerCallMetaDataProvider((databaseMetaData));\r\n    } else {\r\n        provider = new GenericCallMetaDataProvider(databaseMetaData);\r\n    }\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Using \" + provider.getClass().getName());\r\n    }\r\n    provider.initializeWithMetaData(databaseMetaData);\r\n    if (accessProcedureColumnMetaData) {\r\n        provider.initializeWithProcedureColumnMetaData(databaseMetaData, context.getCatalogName(), context.getSchemaName(), context.getProcedureName());\r\n    }\r\n    return provider;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.support.JdbcDaoSupport.createJdbcTemplate",
	"Comment": "create a jdbctemplate for the given datasource.\tonly invoked if populating the dao with a datasource reference!\tcan be overridden in subclasses to provide a jdbctemplate instance\twith different configuration, or a custom jdbctemplate subclass.",
	"Method": "JdbcTemplate createJdbcTemplate(DataSource dataSource){\r\n    return new JdbcTemplate(dataSource);\r\n}"
}, {
	"Path": "org.dragonet.common.maths.ChunkPos.getCenterBlock",
	"Comment": "get the coordinates of the block in the center of this chunk with thegiven y coordinate",
	"Method": "BlockPosition getCenterBlock(int y){\r\n    return new BlockPosition(this.getCenterXPos(), y, this.getCenterZPosition());\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.util.TextChangeManager.get",
	"Comment": "returns the textchange associated with the given compilation\tunit. if the manager does not already manage an association it creates a one.",
	"Method": "TextChange get(ICompilationUnit cu){\r\n    TextChange result = fMap.get(cu);\r\n    if (result == null) {\r\n        result = new CompilationUnitChange(cu.getElementName(), cu);\r\n        result.setKeepPreviewEdits(fKeepExecutedTextEdits);\r\n        fMap.put(cu, result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.namedparam.NamedParameterJdbcTemplate.getJdbcOperations",
	"Comment": "expose the classic spring jdbctemplate to allow invocation of\tless commonly used methods.",
	"Method": "JdbcOperations getJdbcOperations(){\r\n    return this.classicJdbcTemplate;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.UpdateOnCreateTest.createPermissionOverwrittenForRelationSuccessCase",
	"Comment": "class level expression overwritten by field level expression",
	"Method": "void createPermissionOverwrittenForRelationSuccessCase(){\r\n    PersistentResource<UpdateAndCreate> created = PersistentResource.createObject(null, UpdateAndCreate.class, userTwoScope, Optional.of(\"10\"));\r\n    PersistentResource<Author> loadedAuthor = PersistentResource.loadRecord(Author.class, \"1\", userTwoScope);\r\n    created.addRelation(\"author\", loadedAuthor);\r\n    created.getRequestScope().getPermissionExecutor().executeCommitChecks();\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider.isSupportsCatalogsInProcedureCalls",
	"Comment": "does the database support the use of catalog name in procedure calls",
	"Method": "boolean isSupportsCatalogsInProcedureCalls(){\r\n    return this.supportsCatalogsInProcedureCalls;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.databases.KeyValueDatabase.lookup",
	"Comment": "tokenizes lookup fields and returns all matching buckets in theindex.",
	"Method": "List<Bucket> lookup(Record record){\r\n    List<Bucket> buckets = new ArrayList();\r\n    for (Property p : config.getLookupProperties()) {\r\n        String propname = p.getName();\r\n        Collection<String> values = record.getValues(propname);\r\n        if (values == null)\r\n            continue;\r\n        for (String value : values) {\r\n            String[] tokens = StringUtils.split(value);\r\n            for (int ix = 0; ix < tokens.length; ix++) {\r\n                Bucket b = store.lookupToken(propname, tokens[ix]);\r\n                if (b == null || b.records == null)\r\n                    continue;\r\n                long[] ids = b.records;\r\n                if (DEBUG)\r\n                    System.out.println(propname + \", \" + tokens[ix] + \": \" + b.nextfree + \" (\" + b.getScore() + \")\");\r\n                buckets.add(b);\r\n            }\r\n        }\r\n    }\r\n    return buckets;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.delegates.DelegateMethodCreator.createMethodInvocation",
	"Comment": "creates the corresponding statement for the method invocation, based on\tthe return type.",
	"Method": "Statement createMethodInvocation(MethodDeclaration declaration,MethodInvocation invocation){\r\n    Assert.isNotNull(declaration);\r\n    Assert.isNotNull(invocation);\r\n    Statement statement = null;\r\n    final Type type = declaration.getReturnType2();\r\n    if (type == null) {\r\n        statement = createExpressionStatement(invocation);\r\n    } else {\r\n        if (type instanceof PrimitiveType) {\r\n            final PrimitiveType primitive = (PrimitiveType) type;\r\n            if (primitive.getPrimitiveTypeCode().equals(PrimitiveType.VOID)) {\r\n                statement = createExpressionStatement(invocation);\r\n            } else {\r\n                statement = createReturnStatement(invocation);\r\n            }\r\n        } else {\r\n            statement = createReturnStatement(invocation);\r\n        }\r\n    }\r\n    return statement;\r\n}"
}, {
	"Path": "com.yahoo.elide.standalone.config.ElideStandaloneSettings.getApplicationConfigurator",
	"Comment": "supplemental resource configuration for elide application. this should be a fully qualified class name.before calling the consumer, the class will be injected by the servicelocator.",
	"Method": "Consumer<ResourceConfig> getApplicationConfigurator(){\r\n    return (x) -> {\r\n    };\r\n}"
}, {
	"Path": "sx.blah.discord.util.cache.Cache.getOrElseGet",
	"Comment": "gets an object by its unique snowflake id. if no object is found, the supplier must supply the object instead.",
	"Method": "T getOrElseGet(Object key,Supplier<? extends T> supplier,T getOrElseGet,long key,Supplier<? extends T> supplier){\r\n    T val = get(key);\r\n    return val == null ? supplier.get() : val;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.text.correction.QuickAssistProcessor.convertMethodRefernceToLambda",
	"Comment": "converts and replaces the given method reference with corresponding lambda\texpression in the given astrewrite.",
	"Method": "LambdaExpression convertMethodRefernceToLambda(MethodReference methodReference,IMethodBinding functionalMethod,CompilationUnit astRoot,ASTRewrite rewrite,LinkedProposalModelCore linkedProposalModel,boolean createBlockBody){\r\n    AST ast = astRoot.getAST();\r\n    LambdaExpression lambda = ast.newLambdaExpression();\r\n    String[] lambdaParamNames = getUniqueParameterNames(methodReference, functionalMethod);\r\n    List<VariableDeclaration> lambdaParameters = lambda.parameters();\r\n    for (int i = 0; i < lambdaParamNames.length; i++) {\r\n        String paramName = lambdaParamNames[i];\r\n        VariableDeclarationFragment lambdaParameter = ast.newVariableDeclarationFragment();\r\n        SimpleName name = ast.newSimpleName(paramName);\r\n        lambdaParameter.setName(name);\r\n        lambdaParameters.add(lambdaParameter);\r\n        if (linkedProposalModel != null) {\r\n            linkedProposalModel.getPositionGroup(name.getIdentifier(), true).addPosition(rewrite.track(name), i == 0);\r\n        }\r\n    }\r\n    int noOfLambdaParameters = lambdaParamNames.length;\r\n    lambda.setParentheses(noOfLambdaParameters != 1);\r\n    ITypeBinding returnTypeBinding = functionalMethod.getReturnType();\r\n    IMethodBinding referredMethodBinding = methodReference.resolveMethodBinding();\r\n    if (methodReference instanceof CreationReference) {\r\n        CreationReference creationRef = (CreationReference) methodReference;\r\n        Type type = creationRef.getType();\r\n        if (type instanceof ArrayType) {\r\n            ArrayCreation arrayCreation = ast.newArrayCreation();\r\n            if (createBlockBody) {\r\n                Block blockBody = getBlockBodyForLambda(arrayCreation, returnTypeBinding, ast);\r\n                lambda.setBody(blockBody);\r\n            } else {\r\n                lambda.setBody(arrayCreation);\r\n            }\r\n            ArrayType arrayType = (ArrayType) type;\r\n            Type copiedElementType = (Type) rewrite.createCopyTarget(arrayType.getElementType());\r\n            arrayCreation.setType(ast.newArrayType(copiedElementType, arrayType.getDimensions()));\r\n            SimpleName name = ast.newSimpleName(lambdaParamNames[0]);\r\n            arrayCreation.dimensions().add(name);\r\n            if (linkedProposalModel != null) {\r\n                linkedProposalModel.getPositionGroup(name.getIdentifier(), false).addPosition(rewrite.track(name), LinkedPositionGroup.NO_STOP);\r\n            }\r\n        } else {\r\n            ClassInstanceCreation cic = ast.newClassInstanceCreation();\r\n            if (createBlockBody) {\r\n                Block blockBody = getBlockBodyForLambda(cic, returnTypeBinding, ast);\r\n                lambda.setBody(blockBody);\r\n            } else {\r\n                lambda.setBody(cic);\r\n            }\r\n            ITypeBinding typeBinding = type.resolveBinding();\r\n            if (!(type instanceof ParameterizedType) && typeBinding != null && typeBinding.getTypeDeclaration().isGenericType()) {\r\n                cic.setType(ast.newParameterizedType((Type) rewrite.createCopyTarget(type)));\r\n            } else {\r\n                cic.setType((Type) rewrite.createCopyTarget(type));\r\n            }\r\n            List<SimpleName> invocationArgs = getInvocationArguments(ast, 0, noOfLambdaParameters, lambdaParamNames);\r\n            cic.arguments().addAll(invocationArgs);\r\n            if (linkedProposalModel != null) {\r\n                for (SimpleName name : invocationArgs) {\r\n                    linkedProposalModel.getPositionGroup(name.getIdentifier(), false).addPosition(rewrite.track(name), LinkedPositionGroup.NO_STOP);\r\n                }\r\n            }\r\n            cic.typeArguments().addAll(getCopiedTypeArguments(rewrite, methodReference.typeArguments()));\r\n        }\r\n    } else if (referredMethodBinding != null && Modifier.isStatic(referredMethodBinding.getModifiers())) {\r\n        MethodInvocation methodInvocation = ast.newMethodInvocation();\r\n        if (createBlockBody) {\r\n            Block blockBody = getBlockBodyForLambda(methodInvocation, returnTypeBinding, ast);\r\n            lambda.setBody(blockBody);\r\n        } else {\r\n            lambda.setBody(methodInvocation);\r\n        }\r\n        Expression expr = null;\r\n        boolean hasConflict = hasConflict(methodReference.getStartPosition(), referredMethodBinding, ScopeAnalyzer.METHODS | ScopeAnalyzer.CHECK_VISIBILITY, astRoot);\r\n        if (hasConflict || !Bindings.isSuperType(referredMethodBinding.getDeclaringClass(), ASTNodes.getEnclosingType(methodReference)) || methodReference.typeArguments().size() != 0) {\r\n            if (methodReference instanceof ExpressionMethodReference) {\r\n                ExpressionMethodReference expressionMethodReference = (ExpressionMethodReference) methodReference;\r\n                expr = (Expression) rewrite.createCopyTarget(expressionMethodReference.getExpression());\r\n            } else if (methodReference instanceof TypeMethodReference) {\r\n                Type type = ((TypeMethodReference) methodReference).getType();\r\n                ITypeBinding typeBinding = type.resolveBinding();\r\n                if (typeBinding != null) {\r\n                    ImportRewrite importRewrite = CodeStyleConfiguration.createImportRewrite(astRoot, true);\r\n                    expr = ast.newName(importRewrite.addImport(typeBinding));\r\n                }\r\n            }\r\n        }\r\n        methodInvocation.setExpression(expr);\r\n        SimpleName methodName = getMethodInvocationName(methodReference);\r\n        methodInvocation.setName((SimpleName) rewrite.createCopyTarget(methodName));\r\n        List<SimpleName> invocationArgs = getInvocationArguments(ast, 0, noOfLambdaParameters, lambdaParamNames);\r\n        methodInvocation.arguments().addAll(invocationArgs);\r\n        if (linkedProposalModel != null) {\r\n            for (SimpleName name : invocationArgs) {\r\n                linkedProposalModel.getPositionGroup(name.getIdentifier(), false).addPosition(rewrite.track(name), LinkedPositionGroup.NO_STOP);\r\n            }\r\n        }\r\n        methodInvocation.typeArguments().addAll(getCopiedTypeArguments(rewrite, methodReference.typeArguments()));\r\n    } else if (methodReference instanceof SuperMethodReference) {\r\n        SuperMethodInvocation superMethodInvocation = ast.newSuperMethodInvocation();\r\n        if (createBlockBody) {\r\n            Block blockBody = getBlockBodyForLambda(superMethodInvocation, returnTypeBinding, ast);\r\n            lambda.setBody(blockBody);\r\n        } else {\r\n            lambda.setBody(superMethodInvocation);\r\n        }\r\n        Name superQualifier = ((SuperMethodReference) methodReference).getQualifier();\r\n        if (superQualifier != null) {\r\n            superMethodInvocation.setQualifier((Name) rewrite.createCopyTarget(superQualifier));\r\n        }\r\n        SimpleName methodName = getMethodInvocationName(methodReference);\r\n        superMethodInvocation.setName((SimpleName) rewrite.createCopyTarget(methodName));\r\n        List<SimpleName> invocationArgs = getInvocationArguments(ast, 0, noOfLambdaParameters, lambdaParamNames);\r\n        superMethodInvocation.arguments().addAll(invocationArgs);\r\n        if (linkedProposalModel != null) {\r\n            for (SimpleName name : invocationArgs) {\r\n                linkedProposalModel.getPositionGroup(name.getIdentifier(), false).addPosition(rewrite.track(name), LinkedPositionGroup.NO_STOP);\r\n            }\r\n        }\r\n        superMethodInvocation.typeArguments().addAll(getCopiedTypeArguments(rewrite, methodReference.typeArguments()));\r\n    } else {\r\n        MethodInvocation methodInvocation = ast.newMethodInvocation();\r\n        if (createBlockBody) {\r\n            Block blockBody = getBlockBodyForLambda(methodInvocation, returnTypeBinding, ast);\r\n            lambda.setBody(blockBody);\r\n        } else {\r\n            lambda.setBody(methodInvocation);\r\n        }\r\n        boolean isTypeReference = isTypeReferenceToInstanceMethod(methodReference);\r\n        if (isTypeReference) {\r\n            SimpleName name = ast.newSimpleName(lambdaParamNames[0]);\r\n            methodInvocation.setExpression(name);\r\n            if (linkedProposalModel != null) {\r\n                linkedProposalModel.getPositionGroup(name.getIdentifier(), false).addPosition(rewrite.track(name), LinkedPositionGroup.NO_STOP);\r\n            }\r\n        } else {\r\n            Expression expr = ((ExpressionMethodReference) methodReference).getExpression();\r\n            if (!(expr instanceof ThisExpression && methodReference.typeArguments().size() == 0)) {\r\n                methodInvocation.setExpression((Expression) rewrite.createCopyTarget(expr));\r\n            }\r\n        }\r\n        SimpleName methodName = getMethodInvocationName(methodReference);\r\n        methodInvocation.setName((SimpleName) rewrite.createCopyTarget(methodName));\r\n        List<SimpleName> invocationArgs = getInvocationArguments(ast, isTypeReference ? 1 : 0, noOfLambdaParameters, lambdaParamNames);\r\n        methodInvocation.arguments().addAll(invocationArgs);\r\n        if (linkedProposalModel != null) {\r\n            for (SimpleName name : invocationArgs) {\r\n                linkedProposalModel.getPositionGroup(name.getIdentifier(), false).addPosition(rewrite.track(name), LinkedPositionGroup.NO_STOP);\r\n            }\r\n        }\r\n        methodInvocation.typeArguments().addAll(getCopiedTypeArguments(rewrite, methodReference.typeArguments()));\r\n    }\r\n    rewrite.replace(methodReference, lambda, null);\r\n    return lambda;\r\n}"
}, {
	"Path": "org.dcm4che3.data.BulkData.longLength",
	"Comment": "gets the actual length as a long so it can represent the 2 gb to 4 gb range of lengths",
	"Method": "long longLength(){\r\n    if (length == -1)\r\n        return -1;\r\n    return length & 0xFFFFFFFFl;\r\n}"
}, {
	"Path": "org.dom4j.tree.AbstractElement.createAttributeList",
	"Comment": "a factory method pattern which creates a list implementation used to\tstore attributes",
	"Method": "List<Attribute> createAttributeList(List<Attribute> createAttributeList,int size){\r\n    return new ArrayList<Attribute>(size);\r\n}"
}, {
	"Path": "org.dom4j.io.DOMSAXContentHandler.fatalError",
	"Comment": "this method is called when a fatal error occurs during parsing. thismethod rethrows the exception",
	"Method": "void fatalError(SAXParseException exception){\r\n    throw exception;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.filter.dialect.DefaultFilterDialect.extractPredicates",
	"Comment": "converts the query parameters to a list of predicates that are then conjoined or organized by type.",
	"Method": "List<FilterPredicate> extractPredicates(MultivaluedMap<String, String> queryParams){\r\n    List<FilterPredicate> filterPredicates = new ArrayList();\r\n    Pattern pattern = Pattern.compile(\"filter\\\\[([^\\\\]]+)\\\\](\\\\[([^\\\\]]+)\\\\])?\");\r\n    for (MultivaluedMap.Entry<String, List<String>> entry : queryParams.entrySet()) {\r\n        String paramName = entry.getKey();\r\n        List<String> paramValues = entry.getValue();\r\n        Matcher matcher = pattern.matcher(paramName);\r\n        if (!matcher.find()) {\r\n            throw new ParseException(\"Invalid filter format: \" + paramName);\r\n        }\r\n        final String[] keyParts = matcher.group(1).split(\"\\\\.\");\r\n        if (keyParts.length < 2) {\r\n            throw new ParseException(\"Invalid filter format: \" + paramName);\r\n        }\r\n        final Operator operator = (matcher.group(3) == null) ? Operator.IN : Operator.fromString(matcher.group(3));\r\n        Path path = getPath(keyParts);\r\n        List<Path.PathElement> elements = path.getPathElements();\r\n        Path.PathElement last = elements.get(elements.size() - 1);\r\n        final List<Object> values = new ArrayList();\r\n        if (operator.isParameterized()) {\r\n            for (String valueParams : paramValues) {\r\n                for (String valueParam : valueParams.split(\",\")) {\r\n                    values.add(CoerceUtil.coerce(valueParam, last.getFieldType()));\r\n                }\r\n            }\r\n        }\r\n        FilterPredicate filterPredicate = new FilterPredicate(path, operator, values);\r\n        filterPredicates.add(filterPredicate);\r\n    }\r\n    return filterPredicates;\r\n}"
}, {
	"Path": "org.dcm4che3.data.Attributes.getRemovedOrModified",
	"Comment": "returns attributes of this data set which were removed or replaced inthe specified other data set.",
	"Method": "Attributes getRemovedOrModified(Attributes other){\r\n    Attributes modified = new Attributes(size);\r\n    int creatorTag = -1;\r\n    int prevCreatorTag = -1;\r\n    int otherCreatorTag = 0;\r\n    String privateCreator = null;\r\n    for (int i = 0; i < size; i++) {\r\n        int tag = tags[i];\r\n        if ((tag & 0x00010000) != 0) {\r\n            if ((tag & 0x0000ff00) == 0)\r\n                continue;\r\n            creatorTag = TagUtils.creatorTagOf(tag);\r\n            if (prevCreatorTag != creatorTag) {\r\n                prevCreatorTag = creatorTag;\r\n                otherCreatorTag = -1;\r\n                privateCreator = null;\r\n                int k = indexOf(creatorTag);\r\n                if (k >= 0) {\r\n                    Object o = decodeStringValue(k);\r\n                    if (o instanceof String) {\r\n                        privateCreator = (String) o;\r\n                        otherCreatorTag = other.creatorTagOf(privateCreator, tag, false);\r\n                    }\r\n                }\r\n            }\r\n            if (privateCreator == null)\r\n                continue;\r\n            if (otherCreatorTag != -1)\r\n                tag = TagUtils.toPrivateTag(otherCreatorTag, tag);\r\n        } else {\r\n            otherCreatorTag = 0;\r\n            privateCreator = null;\r\n        }\r\n        Object origValue = values[i];\r\n        if (origValue instanceof Value && ((Value) origValue).isEmpty())\r\n            continue;\r\n        if (otherCreatorTag >= 0) {\r\n            int j = other.indexOf(tag);\r\n            if (j >= 0 && equalValues(other, i, j))\r\n                continue;\r\n        }\r\n        if (origValue instanceof Sequence) {\r\n            modified.set(privateCreator, tag, (Sequence) origValue, null);\r\n        } else if (origValue instanceof Fragments) {\r\n            modified.set(privateCreator, tag, (Fragments) origValue);\r\n        } else {\r\n            modified.set(privateCreator, tag, vrs[i], origValue);\r\n        }\r\n    }\r\n    return modified;\r\n}"
}, {
	"Path": "sx.blah.discord.util.audio.AudioPlayer.getAudioPlayerForGuild",
	"Comment": "gets an audio player for the given guild. it will first attempt to find an injected player cached in the internal\tmap, otherwise it will construct a new instance.",
	"Method": "AudioPlayer getAudioPlayerForGuild(IGuild guild){\r\n    if (playerInstances.containsKey(guild)) {\r\n        return playerInstances.get(guild);\r\n    } else {\r\n        return new AudioPlayer(guild);\r\n    }\r\n}"
}, {
	"Path": "sx.blah.discord.handle.audio.IAudioProvider.getChannels",
	"Comment": "gets the number of channels in the audio being provided by the provider. by default, 2.",
	"Method": "int getChannels(){\r\n    return 2;\r\n}"
}, {
	"Path": "org.dom4j.tree.NamespaceStack.findDefaultNamespace",
	"Comment": "attempts to find the current default namespace on the stack right now orreturns null if one could not be found",
	"Method": "Namespace findDefaultNamespace(){\r\n    for (int i = namespaceStack.size() - 1; i >= 0; i--) {\r\n        Namespace namespace = namespaceStack.get(i);\r\n        if (namespace != null) {\r\n            String prefix = namespace.getPrefix();\r\n            if ((prefix == null) || (namespace.getPrefix().length() == 0)) {\r\n                return namespace;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.StoredProcedureTests.testStoredProcedureConfiguredViaJdbcTemplateWithCustomExceptionTranslator",
	"Comment": "confirm no connection was used to get metadata. does not use superclass replay\tmechanism.",
	"Method": "void testStoredProcedureConfiguredViaJdbcTemplateWithCustomExceptionTranslator(){\r\n    given(callableStatement.execute()).willReturn(false);\r\n    given(callableStatement.getUpdateCount()).willReturn(-1);\r\n    given(callableStatement.getObject(2)).willReturn(5);\r\n    given(connection.prepareCall(\"{call \" + StoredProcedureConfiguredViaJdbcTemplate.SQL + \"(?, ?)}\")).willReturn(callableStatement);\r\n    class TestJdbcTemplate extends JdbcTemplate {\r\n        int calls;\r\n        @Override\r\n        public Map<String, Object> call(CallableStatementCreator csc, List<SqlParameter> declaredParameters) throws DataAccessException {\r\n            calls++;\r\n            return super.call(csc, declaredParameters);\r\n        }\r\n    }\r\n    TestJdbcTemplate t = new TestJdbcTemplate();\r\n    t.setDataSource(dataSource);\r\n    t.setExceptionTranslator(new SQLStateSQLExceptionTranslator());\r\n    StoredProcedureConfiguredViaJdbcTemplate sp = new StoredProcedureConfiguredViaJdbcTemplate(t);\r\n    assertEquals(sp.execute(11), 5);\r\n    assertEquals(1, t.calls);\r\n    verify(callableStatement).setObject(1, 11, Types.INTEGER);\r\n    verify(callableStatement).registerOutParameter(2, Types.INTEGER);\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.StoredProcedureTests.testStoredProcedureConfiguredViaJdbcTemplateWithCustomExceptionTranslator",
	"Comment": "confirm no connection was used to get metadata. does not use superclass replay\tmechanism.",
	"Method": "void testStoredProcedureConfiguredViaJdbcTemplateWithCustomExceptionTranslator(){\r\n    calls++;\r\n    return super.call(csc, declaredParameters);\r\n}"
}, {
	"Path": "no.priv.garshol.duke.utils.Utils.createTempDirectory",
	"Comment": "creates a temporary folder using the given prefix to generate its name.",
	"Method": "File createTempDirectory(String prefix){\r\n    File temp = null;\r\n    try {\r\n        temp = File.createTempFile(prefix != null ? prefix : \"temp\", Long.toString(System.nanoTime()));\r\n        if (!(temp.delete())) {\r\n            throw new IOException(\"Could not delete temp file: \" + temp.getAbsolutePath());\r\n        }\r\n        if (!(temp.mkdir())) {\r\n            throw new IOException(\"Could not create temp directory: \" + temp.getAbsolutePath());\r\n        }\r\n    } catch (IOException e) {\r\n        throw new DukeException(\"Unable to create temporary directory with prefix \" + prefix, e);\r\n    }\r\n    return temp;\r\n}"
}, {
	"Path": "org.dragonet.protocol.type.transaction.action.SlotChangeAction.getSlot",
	"Comment": "returns the inventoryslot in the inventory which this action modified.",
	"Method": "int getSlot(){\r\n    return inventorySlot;\r\n}"
}, {
	"Path": "org.dom4j.io.HTMLWriter.prettyPrintXHTML",
	"Comment": "convenience method to just get a string result, but as xhtml .",
	"Method": "String prettyPrintXHTML(String html){\r\n    return prettyPrintHTML(html, true, true, true, false);\r\n}"
}, {
	"Path": "com.dslplatform.json.DslJson.tryFindWriter",
	"Comment": "try to find registered writer for provided type.\tif writer is not found, null will be returned.\tif writer for exact type is not found, type hierarchy will be scanned for base writer.\twriter is used for conversion from object instance into json representation.",
	"Method": "JsonWriter.WriteObject<?> tryFindWriter(Type manifest,JsonWriter.WriteObject<T> tryFindWriter,Class<T> manifest){\r\n    return (JsonWriter.WriteObject<T>) tryFindWriter((Type) manifest);\r\n}"
}, {
	"Path": "no.priv.garshol.duke.genetic.GeneticAlgorithm.setConfigOutput",
	"Comment": "set the file to write the best configuration to. theconfiguration gets written at the end of each generation.",
	"Method": "void setConfigOutput(String output){\r\n    this.outfile = output;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.contentassist.CompletionProposalReplacementProvider.updateReplacement",
	"Comment": "updates the replacement and any additional replacement for the given item.",
	"Method": "void updateReplacement(CompletionProposal proposal,CompletionItem item,char trigger){\r\n    this.importRewrite = TypeProposalUtils.createImportRewrite(compilationUnit);\r\n    List<org.eclipse.lsp4j.TextEdit> additionalTextEdits = new ArrayList();\r\n    StringBuilder completionBuffer = new StringBuilder();\r\n    Range range = null;\r\n    if (isSupportingRequiredProposals(proposal)) {\r\n        CompletionProposal[] requiredProposals = proposal.getRequiredProposals();\r\n        if (requiredProposals != null) {\r\n            for (CompletionProposal requiredProposal : requiredProposals) {\r\n                switch(requiredProposal.getKind()) {\r\n                    case CompletionProposal.TYPE_IMPORT:\r\n                    case CompletionProposal.METHOD_IMPORT:\r\n                    case CompletionProposal.FIELD_IMPORT:\r\n                        appendImportProposal(completionBuffer, requiredProposal, proposal.getKind());\r\n                        break;\r\n                    case CompletionProposal.TYPE_REF:\r\n                        org.eclipse.lsp4j.TextEdit edit = toRequiredTypeEdit(requiredProposal, trigger, proposal.canUseDiamond(context));\r\n                        if (proposal.getKind() == CompletionProposal.CONSTRUCTOR_INVOCATION || proposal.getKind() == CompletionProposal.ANONYMOUS_CLASS_CONSTRUCTOR_INVOCATION || proposal.getKind() == CompletionProposal.ANONYMOUS_CLASS_DECLARATION) {\r\n                            completionBuffer.append(edit.getNewText());\r\n                            range = edit.getRange();\r\n                        } else {\r\n                            additionalTextEdits.add(edit);\r\n                        }\r\n                        break;\r\n                    default:\r\n                        Assert.isTrue(false);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (range == null) {\r\n        PreferenceManager preferenceManager = JavaLanguageServerPlugin.getPreferencesManager();\r\n        boolean completionOverwrite = preferenceManager == null || preferenceManager.getPreferences().isCompletionOverwrite();\r\n        if (!completionOverwrite && (proposal.getKind() == CompletionProposal.METHOD_REF || proposal.getKind() == CompletionProposal.LOCAL_VARIABLE_REF || proposal.getKind() == CompletionProposal.FIELD_REF)) {\r\n            int end = proposal.getReplaceEnd();\r\n            if (end > offset) {\r\n                proposal.setReplaceRange(proposal.getReplaceStart(), offset);\r\n            }\r\n        }\r\n        range = toReplacementRange(proposal);\r\n    }\r\n    if (proposal.getKind() == CompletionProposal.METHOD_DECLARATION) {\r\n        appendMethodOverrideReplacement(completionBuffer, proposal);\r\n    } else if (proposal.getKind() == CompletionProposal.POTENTIAL_METHOD_DECLARATION && proposal instanceof GetterSetterCompletionProposal) {\r\n        appendMethodPotentialReplacement(completionBuffer, (GetterSetterCompletionProposal) proposal);\r\n    } else if (proposal.getKind() == CompletionProposal.ANONYMOUS_CLASS_CONSTRUCTOR_INVOCATION || proposal.getKind() == CompletionProposal.ANONYMOUS_CLASS_DECLARATION) {\r\n        appendAnonymousClass(completionBuffer, proposal, range);\r\n    } else {\r\n        appendReplacementString(completionBuffer, proposal);\r\n    }\r\n    if (client.isCompletionSnippetsSupported()) {\r\n        item.setInsertTextFormat(InsertTextFormat.Snippet);\r\n    } else {\r\n        item.setInsertTextFormat(InsertTextFormat.PlainText);\r\n    }\r\n    String text = completionBuffer.toString();\r\n    if (range != null) {\r\n        item.setTextEdit(new org.eclipse.lsp4j.TextEdit(range, text));\r\n    } else {\r\n        item.setInsertText(text);\r\n    }\r\n    addImports(additionalTextEdits);\r\n    if (!additionalTextEdits.isEmpty()) {\r\n        item.setAdditionalTextEdits(additionalTextEdits);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.PreparedStatementCreatorFactory.newPreparedStatementCreator",
	"Comment": "return a new preparedstatementcreator for the given parameters.",
	"Method": "PreparedStatementCreator newPreparedStatementCreator(List<?> params,PreparedStatementCreator newPreparedStatementCreator,Object[] params,PreparedStatementCreator newPreparedStatementCreator,String sqlToUse,Object[] params){\r\n    return new PreparedStatementCreatorImpl(sqlToUse, params != null ? Arrays.asList(params) : Collections.emptyList());\r\n}"
}, {
	"Path": "org.dom4j.DocumentFactory.getQNames",
	"Comment": "returns a list of all the qname instances currently used by this documentfactory",
	"Method": "List<QName> getQNames(){\r\n    return cache.getQNames();\r\n}"
}, {
	"Path": "org.dom4j.io.SAXContentHandler.addDTDDeclaration",
	"Comment": "adds an internal dtd declaration to the list of declarations",
	"Method": "void addDTDDeclaration(Decl declaration){\r\n    if (internalDTDDeclarations == null) {\r\n        internalDTDDeclarations = new ArrayList<Decl>();\r\n    }\r\n    internalDTDDeclarations.add(declaration);\r\n}"
}, {
	"Path": "org.dom4j.io.SAXContentHandler.fatalError",
	"Comment": "this method is called when a fatal error occurs during parsing. thismethod rethrows the exception",
	"Method": "void fatalError(SAXParseException exception){\r\n    throw exception;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.CallableStatementCreatorFactory.addParameter",
	"Comment": "add a new declared parameter.\torder of parameter addition is significant.",
	"Method": "void addParameter(SqlParameter param){\r\n    this.declaredParameters.add(param);\r\n}"
}, {
	"Path": "org.dom4j.io.XPP3Reader.createReader",
	"Comment": "factory method to create a reader from the given inputstream.",
	"Method": "Reader createReader(InputStream in){\r\n    return new BufferedReader(new InputStreamReader(in));\r\n}"
}, {
	"Path": "no.priv.garshol.duke.Processor.removeMatchListener",
	"Comment": "removes a listener from being notified of the processing events.",
	"Method": "boolean removeMatchListener(MatchListener listener){\r\n    if (listener != null)\r\n        return listeners.remove(listener);\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.customTranslate",
	"Comment": "subclasses can override this method to attempt a custom mapping from sqlexception\tto dataaccessexception.",
	"Method": "DataAccessException customTranslate(String task,String sql,SQLException sqlEx){\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.JdbcTemplate.getMaxRows",
	"Comment": "return the maximum number of rows specified for this jdbctemplate.",
	"Method": "int getMaxRows(){\r\n    return this.maxRows;\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.JdbcUtils.extractDatabaseMetaData",
	"Comment": "call the specified method on databasemetadata for the given datasource,\tand extract the invocation result.",
	"Method": "Object extractDatabaseMetaData(DataSource dataSource,DatabaseMetaDataCallback action,Object extractDatabaseMetaData,DataSource dataSource,String metaDataMethodName){\r\n    return extractDatabaseMetaData(dataSource, new DatabaseMetaDataCallback() {\r\n        @Override\r\n        public Object processMetaData(DatabaseMetaData dbmd) throws SQLException, MetaDataAccessException {\r\n            try {\r\n                Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null);\r\n                return method.invoke(dbmd, (Object[]) null);\r\n            } catch (NoSuchMethodException ex) {\r\n                throw new MetaDataAccessException(\"No method named '\" + metaDataMethodName + \"' found on DatabaseMetaData instance [\" + dbmd + \"]\", ex);\r\n            } catch (IllegalAccessException ex) {\r\n                throw new MetaDataAccessException(\"Could not access DatabaseMetaData method '\" + metaDataMethodName + \"'\", ex);\r\n            } catch (InvocationTargetException ex) {\r\n                if (ex.getTargetException() instanceof SQLException) {\r\n                    throw (SQLException) ex.getTargetException();\r\n                }\r\n                throw new MetaDataAccessException(\"Invocation of DatabaseMetaData method '\" + metaDataMethodName + \"' failed\", ex);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.JdbcUtils.extractDatabaseMetaData",
	"Comment": "call the specified method on databasemetadata for the given datasource,\tand extract the invocation result.",
	"Method": "Object extractDatabaseMetaData(DataSource dataSource,DatabaseMetaDataCallback action,Object extractDatabaseMetaData,DataSource dataSource,String metaDataMethodName){\r\n    try {\r\n        Method method = DatabaseMetaData.class.getMethod(metaDataMethodName, (Class[]) null);\r\n        return method.invoke(dbmd, (Object[]) null);\r\n    } catch (NoSuchMethodException ex) {\r\n        throw new MetaDataAccessException(\"No method named '\" + metaDataMethodName + \"' found on DatabaseMetaData instance [\" + dbmd + \"]\", ex);\r\n    } catch (IllegalAccessException ex) {\r\n        throw new MetaDataAccessException(\"Could not access DatabaseMetaData method '\" + metaDataMethodName + \"'\", ex);\r\n    } catch (InvocationTargetException ex) {\r\n        if (ex.getTargetException() instanceof SQLException) {\r\n            throw (SQLException) ex.getTargetException();\r\n        }\r\n        throw new MetaDataAccessException(\"Invocation of DatabaseMetaData method '\" + metaDataMethodName + \"' failed\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.dom4j.XPathBugTest.testStefan",
	"Comment": "a bug found by stefan which results in indexoutofboundsexception forempty results",
	"Method": "void testStefan(){\r\n    String text = \"<foo>hello<\/foo>\";\r\n    Document document = DocumentHelper.parseText(text);\r\n    XPath xpath = DocumentHelper.createXPath(\"/x\");\r\n    Object value = xpath.evaluate(document);\r\n}"
}, {
	"Path": "no.priv.garshol.duke.genetic.GeneticAlgorithm.setQuiet",
	"Comment": "tells the genetic algorithm not to output more than necessary.",
	"Method": "void setQuiet(boolean quiet){\r\n    this.quiet = quiet;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.CallMetaDataContext.processParameters",
	"Comment": "process the list of parameters provided, and if procedure column metadata is used,\tthe parameters will be matched against the metadata information and any missing\tones will be automatically included.",
	"Method": "void processParameters(List<SqlParameter> parameters){\r\n    this.callParameters = reconcileParameters(parameters);\r\n}"
}, {
	"Path": "org.dom4j.rule.Stylesheet.setModeName",
	"Comment": "sets the name of the mode that the stylesheet uses by default.",
	"Method": "void setModeName(String modeName){\r\n    this.modeName = modeName;\r\n}"
}, {
	"Path": "org.dom4j.rule.RuleSet.getMatchingRule",
	"Comment": "performs an xslt processing model match for the rule which matches thegiven node the best.",
	"Method": "Rule getMatchingRule(Node node){\r\n    Rule[] matches = getRuleArray();\r\n    for (int i = matches.length - 1; i >= 0; i--) {\r\n        Rule rule = matches[i];\r\n        if (rule.matches(node)) {\r\n            return rule;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.namedparam.BeanPropertySqlParameterSource.getSqlType",
	"Comment": "derives a default sql type from the corresponding property type.",
	"Method": "int getSqlType(String paramName){\r\n    int sqlType = super.getSqlType(paramName);\r\n    if (sqlType != TYPE_UNKNOWN) {\r\n        return sqlType;\r\n    }\r\n    Class<?> propType = this.beanWrapper.getPropertyType(paramName);\r\n    return StatementCreatorUtils.javaTypeToSqlParameterType(propType);\r\n}"
}, {
	"Path": "sx.blah.discord.TestBot.main",
	"Comment": "starts the bot. this can be done any place you want.\tthe main method is for demonstration.",
	"Method": "void main(String args){\r\n    try {\r\n        if (Discord4J.LOGGER instanceof Discord4J.Discord4JLogger) {\r\n            ((Discord4J.Discord4JLogger) Discord4J.LOGGER).setLevel(Discord4J.Discord4JLogger.Level.TRACE);\r\n        }\r\n        Configuration.LOAD_EXTERNAL_MODULES = false;\r\n        boolean isTesting = args[args.length - 1].equals(\"CITest\");\r\n        IDiscordClient client = new ClientBuilder().withToken(args[0]).withPingTimeout(1).build();\r\n        client.getDispatcher().registerListener((IListener<DisconnectedEvent>) (event) -> {\r\n            Discord4J.LOGGER.warn(\"Client disconnected for reason: {}\", event.getReason());\r\n        });\r\n        if (isTesting) {\r\n            Discord4J.LOGGER.debug(\"CI Test Initiated\");\r\n            Discord4J.LOGGER.debug(\"Discord API has a response time of {}ms\", DiscordStatus.getAPIResponseTimeForDay());\r\n            for (DiscordStatus.Maintenance maintenance : DiscordStatus.getUpcomingMaintenances()) {\r\n                Discord4J.LOGGER.warn(\"Discord has upcoming maintenance: {} on {}\", maintenance.getName(), maintenance.getStart().toString());\r\n            }\r\n            client.login();\r\n            final AtomicBoolean didTest = new AtomicBoolean(false);\r\n            client.getDispatcher().registerListener(new IListener<ReadyEvent>() {\r\n                @Override\r\n                public void handle(ReadyEvent readyEvent) {\r\n                    try {\r\n                        final IChannel testChannel = client.getChannelByID(Long.parseUnsignedLong(System.getenv(\"CHANNEL\")));\r\n                        final IChannel spoofChannel = client.getChannelByID(Long.parseUnsignedLong(System.getenv(\"SPOOF_CHANNEL\")));\r\n                        String buildNumber = System.getenv(\"BUILD_ID\");\r\n                        IVoiceChannel channel = client.getVoiceChannels().stream().filter(voiceChannel -> voiceChannel.getName().equalsIgnoreCase(\"Annoying Shit\")).findFirst().orElse(null);\r\n                        if (channel != null) {\r\n                            channel.join();\r\n                            // Mono test\r\n                            AudioPlayer.getAudioPlayerForGuild(channel.getGuild()).queue(new File(\"./test.mp3\"));\r\n                            // Mono test\r\n                            AudioPlayer.getAudioPlayerForGuild(channel.getGuild()).queue(new File(\"./test.flac\"));\r\n                            // Stereo test\r\n                            AudioPlayer.getAudioPlayerForGuild(channel.getGuild()).queue(new File(\"./test2.mp3\"));\r\n                            // Stereo test\r\n                            AudioPlayer.getAudioPlayerForGuild(channel.getGuild()).queue(new File(\"./test2.flac\"));\r\n                        }\r\n                        new MessageBuilder(client).withChannel(testChannel).withContent(\"Initiating Discord4J Unit Tests for Build #\" + buildNumber, MessageBuilder.Styles.BOLD).build();\r\n                        synchronized (client) {\r\n                            for (IMessage message : spoofChannel.getMessageHistory()) {\r\n                                RequestBuffer.request(() -> {\r\n                                    try {\r\n                                        message.delete();\r\n                                    } catch (MissingPermissionsException | DiscordException e) {\r\n                                        e.printStackTrace();\r\n                                    }\r\n                                });\r\n                            }\r\n                        }\r\n                        SpoofBot spoofBot = new SpoofBot(client, System.getenv(\"SPOOF\"), Long.parseUnsignedLong(System.getenv(\"SPOOF_CHANNEL\")));\r\n                        final long now = System.currentTimeMillis();\r\n                        new Thread(() -> {\r\n                            while (!didTest.get()) {\r\n                                if (now + MAX_TEST_TIME <= System.currentTimeMillis()) {\r\n                                    synchronized (client) {\r\n                                        try {\r\n                                            new MessageBuilder(client).withChannel(testChannel).withContent(\"Success! The build is complete. See the log here: \" + CI_URL + buildNumber, MessageBuilder.Styles.BOLD).build();\r\n                                        } catch (RateLimitException | MissingPermissionsException | DiscordException e) {\r\n                                            e.printStackTrace();\r\n                                        }\r\n                                    }\r\n                                    didTest.set(true);\r\n                                }\r\n                            }\r\n                        }).start();\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n            });\r\n            while (!didTest.get()) {\r\n            }\r\n        } else {\r\n            client.login();\r\n            client.getDispatcher().registerListener(new IListener<ReadyEvent>() {\r\n                @Override\r\n                public void handle(ReadyEvent event) {\r\n                    Discord4J.LOGGER.info(\"Connected to {} guilds.\", event.getClient().getGuilds().size());\r\n                }\r\n            });\r\n            client.getDispatcher().registerListener(new IListener<MessageReceivedEvent>() {\r\n                @Override\r\n                public void handle(MessageReceivedEvent messageReceivedEvent) {\r\n                    try {\r\n                        IMessage m = messageReceivedEvent.getMessage();\r\n                        if (m.getAuthor().equals(client.getApplicationOwner())) {\r\n                            if (m.getContent().startsWith(\".meme\") || m.getContent().startsWith(\".nicememe\")) {\r\n                                try {\r\n                                    new MessageBuilder(client).appendContent(\"MEMES REQUESTED:\", MessageBuilder.Styles.UNDERLINE_BOLD_ITALICS).appendContent(\" http://niceme.me/\").withChannel(messageReceivedEvent.getMessage().getChannel()).build();\r\n                                } catch (RateLimitException | DiscordException | MissingPermissionsException e) {\r\n                                    e.printStackTrace();\r\n                                }\r\n                            } else if (m.getContent().startsWith(\".clear\")) {\r\n                                IChannel c = client.getChannelByID(m.getChannel().getLongID());\r\n                                if (null != c) {\r\n                                    c.getMessageHistory().stream().filter(message -> message.getAuthor().getLongID() == client.getOurUser().getLongID()).forEach(message -> {\r\n                                        try {\r\n                                            Discord4J.LOGGER.debug(\"Attempting deletion of message {} by \\\"{}\\\" ({})\", message.getStringID(), message.getAuthor().getName(), message.getContent());\r\n                                            message.delete();\r\n                                        } catch (MissingPermissionsException | RateLimitException | DiscordException e) {\r\n                                            e.printStackTrace();\r\n                                        }\r\n                                    });\r\n                                }\r\n                            } else if (m.getContent().startsWith(\".name \")) {\r\n                                String s = m.getContent().split(\" \", 2)[1];\r\n                                try {\r\n                                    client.changeUsername(s);\r\n                                    m.reply(\"is this better?\");\r\n                                } catch (RateLimitException | MissingPermissionsException | DiscordException e) {\r\n                                    e.printStackTrace();\r\n                                }\r\n                            } else if (m.getContent().startsWith(\".pm\")) {\r\n                                try {\r\n                                    IPrivateChannel channel = client.getOrCreatePMChannel(m.getAuthor());\r\n                                    new MessageBuilder(client).withChannel(channel).withContent(\"SUP DUDE\").build();\r\n                                } catch (Exception e) {\r\n                                    e.printStackTrace();\r\n                                }\r\n                            } else if (m.getContent().startsWith(\".presence\")) {\r\n                                client.changePresence(StatusType.IDLE);\r\n                            } else if (m.getContent().startsWith(\".game\")) {\r\n                                String game = m.getContent().length() > 6 ? m.getContent().substring(6) : null;\r\n                                client.changePresence(StatusType.ONLINE, ActivityType.PLAYING, game);\r\n                            } else if (m.getContent().startsWith(\".type\")) {\r\n                                m.getChannel().toggleTypingStatus();\r\n                            } else if (m.getContent().startsWith(\".invite\")) {\r\n                                try {\r\n                                    m.reply(\"http://discord.gg/\" + m.getChannel().createInvite(1800, 0, false, false).getCode());\r\n                                } catch (MissingPermissionsException | RateLimitException | DiscordException e) {\r\n                                    e.printStackTrace();\r\n                                }\r\n                            } else if (m.getContent().startsWith(\".avatar\")) {\r\n                                try {\r\n                                    if (m.getContent().split(\" \").length > 1) {\r\n                                        String url = m.getContent().split(\" \")[1];\r\n                                        client.changeAvatar(Image.forUrl(url.substring(url.lastIndexOf('.')), url));\r\n                                    } else {\r\n                                        client.changeAvatar(Image.defaultAvatar());\r\n                                    }\r\n                                } catch (Exception e) {\r\n                                    e.printStackTrace();\r\n                                }\r\n                            } else if (m.getContent().startsWith(\".permissions\")) {\r\n                                if (m.getMentions().size() < 1)\r\n                                    return;\r\n                                StringJoiner roleJoiner = new StringJoiner(\", \");\r\n                                StringJoiner permissionsJoiner = new StringJoiner(\", \");\r\n                                for (IRole role : m.getMentions().get(0).getRolesForGuild(m.getChannel().getGuild())) {\r\n                                    Discord4J.LOGGER.info(\"{}\", role.getStringID());\r\n                                    for (Permissions permissions : role.getPermissions()) {\r\n                                        permissionsJoiner.add(permissions.toString());\r\n                                    }\r\n                                    roleJoiner.add(role.getName() + \" (\" + permissionsJoiner.toString() + \")\");\r\n                                    permissionsJoiner = new StringJoiner(\", \");\r\n                                }\r\n                                try {\r\n                                    Discord4J.LOGGER.info(\"{}\", m.getAuthor().getStringID());\r\n                                    m.reply(\"This user has the following roles and permissions: \" + roleJoiner.toString());\r\n                                } catch (MissingPermissionsException | RateLimitException | DiscordException e) {\r\n                                    e.printStackTrace();\r\n                                }\r\n                            } else if (m.getContent().startsWith(\".join\")) {\r\n                                IVoiceChannel channel = m.getGuild().getVoiceChannelsByName(m.getContent().split(\" \")[1]).get(0);\r\n                                channel.join();\r\n                            } else if (m.getContent().startsWith(\".leave\")) {\r\n                                IVoiceChannel channel = m.getGuild().getVoiceChannelsByName(m.getContent().split(\" \")[1]).get(0);\r\n                                channel.leave();\r\n                            } else if (m.getContent().startsWith(\".play\")) {\r\n                                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                                player.queue(new File(\"./test.mp3\"));\r\n                                player.queue(new File(\"./test.flac\"));\r\n                                player.queue(new File(\"./test2.mp3\"));\r\n                                player.queue(new File(\"./test2.flac\"));\r\n                            } else if (m.getContent().startsWith(\".pause\")) {\r\n                                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                                player.setPaused(true);\r\n                            } else if (m.getContent().startsWith(\".resume\")) {\r\n                                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                                player.setPaused(false);\r\n                            } else if (m.getContent().startsWith(\".volume\")) {\r\n                                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                                player.setVolume(Float.parseFloat(m.getContent().split(\" \")[1]));\r\n                            } else if (m.getContent().startsWith(\".stop\")) {\r\n                                client.getConnectedVoiceChannels().stream().filter((IVoiceChannel channel) -> channel.getGuild().equals(m.getGuild())).findFirst().ifPresent(IVoiceChannel::leave);\r\n                            } else if (m.getContent().startsWith(\".skip\")) {\r\n                                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                                player.skip();\r\n                            } else if (m.getContent().startsWith(\".toggleloop\")) {\r\n                                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                                player.setLoop(!player.isLooping());\r\n                            } else if (m.getContent().startsWith(\".rewind\")) {\r\n                                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                                player.getCurrentTrack().rewind(Long.parseLong(m.getContent().split(\" \")[1]));\r\n                            } else if (m.getContent().startsWith(\".forward\")) {\r\n                                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                                player.getCurrentTrack().fastForward(Long.parseLong(m.getContent().split(\" \")[1]));\r\n                            } else if (m.getContent().startsWith(\".shuffle\")) {\r\n                                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                                player.shuffle();\r\n                            } else if (m.getContent().startsWith(\".spam\")) {\r\n                                new Timer().scheduleAtFixedRate(new TimerTask() {\r\n                                    @Override\r\n                                    public void run() {\r\n                                        RequestBuffer.request(() -> {\r\n                                            try {\r\n                                                return m.getChannel().sendMessage(\"spam\");\r\n                                            } catch (MissingPermissionsException | DiscordException e) {\r\n                                                e.printStackTrace();\r\n                                            }\r\n                                            return null;\r\n                                        });\r\n                                    }\r\n                                }, 0, 50);\r\n                            } else if (m.getContent().startsWith(\".move \")) {\r\n                                String target = m.getContent().split(\" \")[1];\r\n                                try {\r\n                                    client.getOurUser().moveToVoiceChannel(m.getGuild().getVoiceChannels().stream().filter((IVoiceChannel channel) -> channel.getName().equals(target)).findFirst().orElseGet(null));\r\n                                } catch (DiscordException | RateLimitException | MissingPermissionsException e) {\r\n                                    e.printStackTrace();\r\n                                }\r\n                            } else if (m.getContent().startsWith(\".logout\")) {\r\n                                client.logout();\r\n                            } else if (m.getContent().startsWith(\".test\")) {\r\n                                test(m);\r\n                            }\r\n                        }\r\n                    } catch (Exception e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                }\r\n                private void test(IMessage message) throws Exception {\r\n                    message.reply(message.getClient().fetchUser(Long.parseUnsignedLong(message.getContent().split(\" \")[1])).mention());\r\n                }\r\n            });\r\n        }\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "sx.blah.discord.TestBot.main",
	"Comment": "starts the bot. this can be done any place you want.\tthe main method is for demonstration.",
	"Method": "void main(String args){\r\n    try {\r\n        final IChannel testChannel = client.getChannelByID(Long.parseUnsignedLong(System.getenv(\"CHANNEL\")));\r\n        final IChannel spoofChannel = client.getChannelByID(Long.parseUnsignedLong(System.getenv(\"SPOOF_CHANNEL\")));\r\n        String buildNumber = System.getenv(\"BUILD_ID\");\r\n        IVoiceChannel channel = client.getVoiceChannels().stream().filter(voiceChannel -> voiceChannel.getName().equalsIgnoreCase(\"Annoying Shit\")).findFirst().orElse(null);\r\n        if (channel != null) {\r\n            channel.join();\r\n            // Mono test\r\n            AudioPlayer.getAudioPlayerForGuild(channel.getGuild()).queue(new File(\"./test.mp3\"));\r\n            // Mono test\r\n            AudioPlayer.getAudioPlayerForGuild(channel.getGuild()).queue(new File(\"./test.flac\"));\r\n            // Stereo test\r\n            AudioPlayer.getAudioPlayerForGuild(channel.getGuild()).queue(new File(\"./test2.mp3\"));\r\n            // Stereo test\r\n            AudioPlayer.getAudioPlayerForGuild(channel.getGuild()).queue(new File(\"./test2.flac\"));\r\n        }\r\n        new MessageBuilder(client).withChannel(testChannel).withContent(\"Initiating Discord4J Unit Tests for Build #\" + buildNumber, MessageBuilder.Styles.BOLD).build();\r\n        synchronized (client) {\r\n            for (IMessage message : spoofChannel.getMessageHistory()) {\r\n                RequestBuffer.request(() -> {\r\n                    try {\r\n                        message.delete();\r\n                    } catch (MissingPermissionsException | DiscordException e) {\r\n                        e.printStackTrace();\r\n                    }\r\n                });\r\n            }\r\n        }\r\n        SpoofBot spoofBot = new SpoofBot(client, System.getenv(\"SPOOF\"), Long.parseUnsignedLong(System.getenv(\"SPOOF_CHANNEL\")));\r\n        final long now = System.currentTimeMillis();\r\n        new Thread(() -> {\r\n            while (!didTest.get()) {\r\n                if (now + MAX_TEST_TIME <= System.currentTimeMillis()) {\r\n                    synchronized (client) {\r\n                        try {\r\n                            new MessageBuilder(client).withChannel(testChannel).withContent(\"Success! The build is complete. See the log here: \" + CI_URL + buildNumber, MessageBuilder.Styles.BOLD).build();\r\n                        } catch (RateLimitException | MissingPermissionsException | DiscordException e) {\r\n                            e.printStackTrace();\r\n                        }\r\n                    }\r\n                    didTest.set(true);\r\n                }\r\n            }\r\n        }).start();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "sx.blah.discord.TestBot.main",
	"Comment": "starts the bot. this can be done any place you want.\tthe main method is for demonstration.",
	"Method": "void main(String args){\r\n    Discord4J.LOGGER.info(\"Connected to {} guilds.\", event.getClient().getGuilds().size());\r\n}"
}, {
	"Path": "sx.blah.discord.TestBot.main",
	"Comment": "starts the bot. this can be done any place you want.\tthe main method is for demonstration.",
	"Method": "void main(String args){\r\n    try {\r\n        IMessage m = messageReceivedEvent.getMessage();\r\n        if (m.getAuthor().equals(client.getApplicationOwner())) {\r\n            if (m.getContent().startsWith(\".meme\") || m.getContent().startsWith(\".nicememe\")) {\r\n                try {\r\n                    new MessageBuilder(client).appendContent(\"MEMES REQUESTED:\", MessageBuilder.Styles.UNDERLINE_BOLD_ITALICS).appendContent(\" http://niceme.me/\").withChannel(messageReceivedEvent.getMessage().getChannel()).build();\r\n                } catch (RateLimitException | DiscordException | MissingPermissionsException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            } else if (m.getContent().startsWith(\".clear\")) {\r\n                IChannel c = client.getChannelByID(m.getChannel().getLongID());\r\n                if (null != c) {\r\n                    c.getMessageHistory().stream().filter(message -> message.getAuthor().getLongID() == client.getOurUser().getLongID()).forEach(message -> {\r\n                        try {\r\n                            Discord4J.LOGGER.debug(\"Attempting deletion of message {} by \\\"{}\\\" ({})\", message.getStringID(), message.getAuthor().getName(), message.getContent());\r\n                            message.delete();\r\n                        } catch (MissingPermissionsException | RateLimitException | DiscordException e) {\r\n                            e.printStackTrace();\r\n                        }\r\n                    });\r\n                }\r\n            } else if (m.getContent().startsWith(\".name \")) {\r\n                String s = m.getContent().split(\" \", 2)[1];\r\n                try {\r\n                    client.changeUsername(s);\r\n                    m.reply(\"is this better?\");\r\n                } catch (RateLimitException | MissingPermissionsException | DiscordException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            } else if (m.getContent().startsWith(\".pm\")) {\r\n                try {\r\n                    IPrivateChannel channel = client.getOrCreatePMChannel(m.getAuthor());\r\n                    new MessageBuilder(client).withChannel(channel).withContent(\"SUP DUDE\").build();\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n            } else if (m.getContent().startsWith(\".presence\")) {\r\n                client.changePresence(StatusType.IDLE);\r\n            } else if (m.getContent().startsWith(\".game\")) {\r\n                String game = m.getContent().length() > 6 ? m.getContent().substring(6) : null;\r\n                client.changePresence(StatusType.ONLINE, ActivityType.PLAYING, game);\r\n            } else if (m.getContent().startsWith(\".type\")) {\r\n                m.getChannel().toggleTypingStatus();\r\n            } else if (m.getContent().startsWith(\".invite\")) {\r\n                try {\r\n                    m.reply(\"http://discord.gg/\" + m.getChannel().createInvite(1800, 0, false, false).getCode());\r\n                } catch (MissingPermissionsException | RateLimitException | DiscordException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            } else if (m.getContent().startsWith(\".avatar\")) {\r\n                try {\r\n                    if (m.getContent().split(\" \").length > 1) {\r\n                        String url = m.getContent().split(\" \")[1];\r\n                        client.changeAvatar(Image.forUrl(url.substring(url.lastIndexOf('.')), url));\r\n                    } else {\r\n                        client.changeAvatar(Image.defaultAvatar());\r\n                    }\r\n                } catch (Exception e) {\r\n                    e.printStackTrace();\r\n                }\r\n            } else if (m.getContent().startsWith(\".permissions\")) {\r\n                if (m.getMentions().size() < 1)\r\n                    return;\r\n                StringJoiner roleJoiner = new StringJoiner(\", \");\r\n                StringJoiner permissionsJoiner = new StringJoiner(\", \");\r\n                for (IRole role : m.getMentions().get(0).getRolesForGuild(m.getChannel().getGuild())) {\r\n                    Discord4J.LOGGER.info(\"{}\", role.getStringID());\r\n                    for (Permissions permissions : role.getPermissions()) {\r\n                        permissionsJoiner.add(permissions.toString());\r\n                    }\r\n                    roleJoiner.add(role.getName() + \" (\" + permissionsJoiner.toString() + \")\");\r\n                    permissionsJoiner = new StringJoiner(\", \");\r\n                }\r\n                try {\r\n                    Discord4J.LOGGER.info(\"{}\", m.getAuthor().getStringID());\r\n                    m.reply(\"This user has the following roles and permissions: \" + roleJoiner.toString());\r\n                } catch (MissingPermissionsException | RateLimitException | DiscordException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            } else if (m.getContent().startsWith(\".join\")) {\r\n                IVoiceChannel channel = m.getGuild().getVoiceChannelsByName(m.getContent().split(\" \")[1]).get(0);\r\n                channel.join();\r\n            } else if (m.getContent().startsWith(\".leave\")) {\r\n                IVoiceChannel channel = m.getGuild().getVoiceChannelsByName(m.getContent().split(\" \")[1]).get(0);\r\n                channel.leave();\r\n            } else if (m.getContent().startsWith(\".play\")) {\r\n                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                player.queue(new File(\"./test.mp3\"));\r\n                player.queue(new File(\"./test.flac\"));\r\n                player.queue(new File(\"./test2.mp3\"));\r\n                player.queue(new File(\"./test2.flac\"));\r\n            } else if (m.getContent().startsWith(\".pause\")) {\r\n                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                player.setPaused(true);\r\n            } else if (m.getContent().startsWith(\".resume\")) {\r\n                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                player.setPaused(false);\r\n            } else if (m.getContent().startsWith(\".volume\")) {\r\n                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                player.setVolume(Float.parseFloat(m.getContent().split(\" \")[1]));\r\n            } else if (m.getContent().startsWith(\".stop\")) {\r\n                client.getConnectedVoiceChannels().stream().filter((IVoiceChannel channel) -> channel.getGuild().equals(m.getGuild())).findFirst().ifPresent(IVoiceChannel::leave);\r\n            } else if (m.getContent().startsWith(\".skip\")) {\r\n                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                player.skip();\r\n            } else if (m.getContent().startsWith(\".toggleloop\")) {\r\n                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                player.setLoop(!player.isLooping());\r\n            } else if (m.getContent().startsWith(\".rewind\")) {\r\n                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                player.getCurrentTrack().rewind(Long.parseLong(m.getContent().split(\" \")[1]));\r\n            } else if (m.getContent().startsWith(\".forward\")) {\r\n                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                player.getCurrentTrack().fastForward(Long.parseLong(m.getContent().split(\" \")[1]));\r\n            } else if (m.getContent().startsWith(\".shuffle\")) {\r\n                AudioPlayer player = AudioPlayer.getAudioPlayerForGuild(m.getGuild());\r\n                player.shuffle();\r\n            } else if (m.getContent().startsWith(\".spam\")) {\r\n                new Timer().scheduleAtFixedRate(new TimerTask() {\r\n                    @Override\r\n                    public void run() {\r\n                        RequestBuffer.request(() -> {\r\n                            try {\r\n                                return m.getChannel().sendMessage(\"spam\");\r\n                            } catch (MissingPermissionsException | DiscordException e) {\r\n                                e.printStackTrace();\r\n                            }\r\n                            return null;\r\n                        });\r\n                    }\r\n                }, 0, 50);\r\n            } else if (m.getContent().startsWith(\".move \")) {\r\n                String target = m.getContent().split(\" \")[1];\r\n                try {\r\n                    client.getOurUser().moveToVoiceChannel(m.getGuild().getVoiceChannels().stream().filter((IVoiceChannel channel) -> channel.getName().equals(target)).findFirst().orElseGet(null));\r\n                } catch (DiscordException | RateLimitException | MissingPermissionsException e) {\r\n                    e.printStackTrace();\r\n                }\r\n            } else if (m.getContent().startsWith(\".logout\")) {\r\n                client.logout();\r\n            } else if (m.getContent().startsWith(\".test\")) {\r\n                test(m);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "sx.blah.discord.TestBot.main",
	"Comment": "starts the bot. this can be done any place you want.\tthe main method is for demonstration.",
	"Method": "void main(String args){\r\n    RequestBuffer.request(() -> {\r\n        try {\r\n            return m.getChannel().sendMessage(\"spam\");\r\n        } catch (MissingPermissionsException | DiscordException e) {\r\n            e.printStackTrace();\r\n        }\r\n        return null;\r\n    });\r\n}"
}, {
	"Path": "sx.blah.discord.TestBot.main",
	"Comment": "starts the bot. this can be done any place you want.\tthe main method is for demonstration.",
	"Method": "void main(String args){\r\n    message.reply(message.getClient().fetchUser(Long.parseUnsignedLong(message.getContent().split(\" \")[1])).mention());\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.code.flow.FlowInfo.get",
	"Comment": "returns an array of ivariablebinding that conform to the\tgiven access mode mode.",
	"Method": "IVariableBinding[] get(FlowContext context,int mode){\r\n    List<IVariableBinding> result = new ArrayList();\r\n    int[] locals = getAccessModes();\r\n    if (locals == null) {\r\n        return EMPTY_ARRAY;\r\n    }\r\n    for (int i = 0; i < locals.length; i++) {\r\n        int accessMode = locals[i];\r\n        if ((accessMode & mode) != 0) {\r\n            result.add(context.getLocalFromIndex(i));\r\n        }\r\n    }\r\n    return result.toArray(new IVariableBinding[result.size()]);\r\n}"
}, {
	"Path": "org.dcm4che3.imageio.codec.jpeg.JPEGHeader.toAttributes",
	"Comment": "return corresponding image pixel description macro attributes",
	"Method": "Attributes toAttributes(Attributes attrs){\r\n    int offsetSOF = offsetSOF();\r\n    if (offsetSOF == -1)\r\n        return null;\r\n    if (attrs == null)\r\n        attrs = new Attributes(10);\r\n    int sof = data[offsetSOF] & 255;\r\n    int p = data[offsetSOF + 3] & 0xff;\r\n    int y = ((data[offsetSOF + 3 + 1] & 0xff) << 8) | (data[offsetSOF + 3 + 2] & 0xff);\r\n    int x = ((data[offsetSOF + 3 + 3] & 0xff) << 8) | (data[offsetSOF + 3 + 4] & 0xff);\r\n    int nf = data[offsetSOF + 3 + 5] & 0xff;\r\n    attrs.setInt(Tag.SamplesPerPixel, VR.US, nf);\r\n    if (nf == 3) {\r\n        attrs.setString(Tag.PhotometricInterpretation, VR.CS, sof == JPEG.SOF0 ? \"YBR_FULL_422\" : \"RGB\");\r\n        attrs.setInt(Tag.PlanarConfiguration, VR.US, 0);\r\n    } else {\r\n        attrs.setString(Tag.PhotometricInterpretation, VR.CS, \"MONOCHROME2\");\r\n    }\r\n    attrs.setInt(Tag.Rows, VR.US, y);\r\n    attrs.setInt(Tag.Columns, VR.US, x);\r\n    attrs.setInt(Tag.BitsAllocated, VR.US, p > 8 ? 16 : 8);\r\n    attrs.setInt(Tag.BitsStored, VR.US, p);\r\n    attrs.setInt(Tag.HighBit, VR.US, p - 1);\r\n    attrs.setInt(Tag.PixelRepresentation, VR.US, 0);\r\n    if (!(sof == JPEG.SOF3 || (sof == JPEG.SOF55 && ss() == 0)))\r\n        attrs.setString(Tag.LossyImageCompression, VR.CS, \"01\");\r\n    return attrs;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.CallMetaDataContext.getScalarOutParameterName",
	"Comment": "get the name of the single out parameter for this call.\tif there are multiple parameters, the name of the first one will be returned.",
	"Method": "String getScalarOutParameterName(){\r\n    if (isFunction()) {\r\n        return getFunctionReturnName();\r\n    } else {\r\n        if (this.outParameterNames.size() > 1) {\r\n            logger.warn(\"Accessing single output value when procedure has more than one output parameter\");\r\n        }\r\n        return (this.outParameterNames.size() > 0 ? this.outParameterNames.get(0) : null);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.SQLErrorCodeSQLExceptionTranslator.setDataSource",
	"Comment": "set the datasource for this translator.\tsetting this property will cause a connection to be obtained from\tthe datasource to get the metadata.",
	"Method": "void setDataSource(DataSource dataSource){\r\n    this.sqlErrorCodes = SQLErrorCodesFactory.getInstance().getErrorCodes(dataSource);\r\n}"
}, {
	"Path": "sx.blah.discord.Discord4J.isSLF4JImplementationPresent",
	"Comment": "gets whether an slf4j implementation is present on the classpath.",
	"Method": "boolean isSLF4JImplementationPresent(){\r\n    try {\r\n        Class.forName(\"org.slf4j.impl.StaticLoggerBinder\");\r\n        return !(LoggerFactory.getILoggerFactory() instanceof NOPLoggerFactory);\r\n    } catch (ClassNotFoundException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.yahoo.elide.core.EntityDictionary.getAccessibleObject",
	"Comment": "retrieve the accessible object for a field from a target object.",
	"Method": "AccessibleObject getAccessibleObject(Object target,String fieldName,AccessibleObject getAccessibleObject,Class<?> targetClass,String fieldName){\r\n    return getEntityBinding(targetClass).fieldsToValues.get(fieldName);\r\n}"
}, {
	"Path": "sx.blah.discord.util.RequestBuilder.doActionBefore",
	"Comment": "sets the currently active action to execute before the specified event filer is passed.",
	"Method": "RequestBuilder doActionBefore(Predicate<T> eventFilter,RequestBuilder doActionBefore,Predicate<T> eventFilter,long time,RequestBuilder doActionBefore,Predicate<T> eventFilter,long time,TimeUnit unit){\r\n    activeAction.waitAfter = eventFilter;\r\n    activeAction.waitAfterTimeout = unit.toMillis(time);\r\n    return this;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.genetic.GeneticConfiguration.makeCopy",
	"Comment": "returns a copy of the configuration where the strategy parametersare randomized, but the rest is untouched.",
	"Method": "GeneticConfiguration makeCopy(){\r\n    GeneticConfiguration copy = new GeneticConfiguration(this);\r\n    for (Aspect aspect : aspects) if (aspect instanceof RecombinationRateAspect || aspect instanceof MutationRateAspect)\r\n        aspect.setRandomly(copy);\r\n    return copy;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.search.text.TextSearchScope.newSearchScope",
	"Comment": "creates a scope that consists of all files that match the filenamepattern and that\teither are one of the roots, or have one of the roots in their parent chain.\tif visitderivedresources is not enabled, all files that are marked derived or\thave a derived container in their parent chain are not part of the scope.",
	"Method": "TextSearchScope newSearchScope(IResource[] rootResources,Pattern fileNamePattern,boolean visitDerivedResources){\r\n    FileNamePatternSearchScope scope = FileNamePatternSearchScope.newSearchScope(\"\", rootResources, visitDerivedResources);\r\n    scope.setFileNamePattern(fileNamePattern);\r\n    return scope;\r\n}"
}, {
	"Path": "denominator.model.rdata.SSHFPData.algorithm",
	"Comment": "this algorithm number octet describes the algorithm of the public key.",
	"Method": "int algorithm(SSHFPData.Builder algorithm,int algorithm){\r\n    return Integer.class.cast(get(\"algorithm\"));\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.nativejdbc.CommonsDbcpNativeJdbcExtractor.getInnermostDelegate",
	"Comment": "extracts the innermost delegate from the given commons dbcp object.\tfalls back to the given object if no underlying object found.",
	"Method": "Object getInnermostDelegate(Object obj){\r\n    if (obj == null) {\r\n        return null;\r\n    }\r\n    try {\r\n        Class<?> classToAnalyze = obj.getClass();\r\n        while (!Modifier.isPublic(classToAnalyze.getModifiers())) {\r\n            classToAnalyze = classToAnalyze.getSuperclass();\r\n            if (classToAnalyze == null) {\r\n                return obj;\r\n            }\r\n        }\r\n        Method getInnermostDelegate = classToAnalyze.getMethod(GET_INNERMOST_DELEGATE_METHOD_NAME, (Class[]) null);\r\n        Object delegate = ReflectionUtils.invokeJdbcMethod(getInnermostDelegate, obj);\r\n        return (delegate != null ? delegate : obj);\r\n    } catch (NoSuchMethodException ex) {\r\n        return obj;\r\n    } catch (SecurityException ex) {\r\n        throw new IllegalStateException(\"Commons DBCP getInnermostDelegate method is not accessible: \" + ex);\r\n    }\r\n}"
}, {
	"Path": "sx.blah.discord.util.cache.Cache.putIfAbsent",
	"Comment": "puts an object into the cache if there is not already a value associated with the given key.",
	"Method": "T putIfAbsent(String id,Supplier<T> valueSupplier,T putIfAbsent,long id,Supplier<T> valueSupplier){\r\n    if (containsKey(id))\r\n        return null;\r\n    else\r\n        return put(valueSupplier.get());\r\n}"
}, {
	"Path": "sx.blah.discord.util.BotInviteBuilder.withClientID",
	"Comment": "sets the client id for the invite. this overrides the client id from the given client.",
	"Method": "BotInviteBuilder withClientID(String id){\r\n    this.clientIDOverride = id;\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.namedparam.ParsedSql.setTotalParameterCount",
	"Comment": "set the total count of all of the parameters in the sql statement.\trepeated occurrences of the same parameter name do count here.",
	"Method": "void setTotalParameterCount(int totalParameterCount){\r\n    this.totalParameterCount = totalParameterCount;\r\n}"
}, {
	"Path": "com.yahoo.elide.contrib.swagger.SwaggerBuilder.withFilterOps",
	"Comment": "assigns a subset of the complete set of filter operations to support for each get operation.",
	"Method": "SwaggerBuilder withFilterOps(Set<Operator> ops){\r\n    filterOperators = new HashSet(ops);\r\n    return this;\r\n}"
}, {
	"Path": "org.dom4j.bean.BeanElement.createAttributeList",
	"Comment": "a factory method pattern which lazily creates a list implementation usedto store content",
	"Method": "List<Attribute> createAttributeList(List<Attribute> createAttributeList,int size){\r\n    return new BeanAttributeList(this);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.javadoc.JavadocContentAccess.containsOnlyInheritDoc",
	"Comment": "checks whether the given reader only returns\tthe inheritdoc tag.",
	"Method": "boolean containsOnlyInheritDoc(Reader reader,int length){\r\n    char[] content = new char[length];\r\n    try {\r\n        reader.read(content, 0, length);\r\n    } catch (IOException e) {\r\n        return false;\r\n    }\r\n    return new String(content).trim().equals(\"{@inheritDoc}\");\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.dom.LocalVariableIndex.perform",
	"Comment": "computes the maximum number of local variable declarations in the given\tbody declaration.",
	"Method": "int perform(BodyDeclaration declaration){\r\n    Assert.isTrue(declaration != null);\r\n    switch(declaration.getNodeType()) {\r\n        case ASTNode.METHOD_DECLARATION:\r\n        case ASTNode.FIELD_DECLARATION:\r\n        case ASTNode.INITIALIZER:\r\n            return internalPerform(declaration);\r\n        default:\r\n            throw new IllegalArgumentException(declaration.toString());\r\n    }\r\n}"
}, {
	"Path": "com.yahoo.elide.core.UpdateOnCreateTest.createPermissionInheritedForRelationSuccessCase",
	"Comment": "expression for relation inherited from class level expression",
	"Method": "void createPermissionInheritedForRelationSuccessCase(){\r\n    PersistentResource<UpdateAndCreate> created = PersistentResource.createObject(null, UpdateAndCreate.class, userOneScope, Optional.of(\"8\"));\r\n    PersistentResource<Book> loadedBook = PersistentResource.loadRecord(Book.class, \"1\", userOneScope);\r\n    created.addRelation(\"books\", loadedBook);\r\n    created.getRequestScope().getPermissionExecutor().executeCommitChecks();\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.BeanPropertyRowMapper.underscoreName",
	"Comment": "convert a name in camelcase to an underscored name in lower case.\tany upper case letters are converted to lower case with a preceding underscore.",
	"Method": "String underscoreName(String name){\r\n    if (!StringUtils.hasLength(name)) {\r\n        return \"\";\r\n    }\r\n    StringBuilder result = new StringBuilder();\r\n    result.append(name.substring(0, 1).toLowerCase());\r\n    for (int i = 1; i < name.length(); i++) {\r\n        String s = name.substring(i, i + 1);\r\n        String slc = s.toLowerCase();\r\n        if (!s.equals(slc)) {\r\n            result.append(\"_\").append(slc);\r\n        } else {\r\n            result.append(s);\r\n        }\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "org.dom4j.io.SAXContentHandler.isMergeAdjacentText",
	"Comment": "returns whether adjacent text nodes should be merged together.",
	"Method": "boolean isMergeAdjacentText(){\r\n    return mergeAdjacentText;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.Environment.get",
	"Comment": "retrieves environment variable or system property value for given name.\tchecks the environment value first.",
	"Method": "String get(String name,String get,String name,String defaultValue){\r\n    String value = get(name);\r\n    if (value == null) {\r\n        value = defaultValue;\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.CheckInstantiator.getCheck",
	"Comment": "gets a check instance by first checking the entity dictionary for a mapping on the provided identifier.in the event that no such mapping is found the identifier is used as a canonical name.",
	"Method": "Check getCheck(EntityDictionary dictionary,String checkName){\r\n    Class<? extends Check> checkCls = dictionary.getCheck(checkName);\r\n    return instantiateCheck(checkCls);\r\n}"
}, {
	"Path": "org.dom4j.io.SAXWriter.setFeature",
	"Comment": "this implementation does actually use any features but just stores themfor later retrieval",
	"Method": "void setFeature(String name,boolean value){\r\n    if (FEATURE_NAMESPACE_PREFIXES.equals(name)) {\r\n        setDeclareNamespaceAttributes(value);\r\n    } else if (FEATURE_NAMESPACE_PREFIXES.equals(name)) {\r\n        if (!value) {\r\n            String msg = \"Namespace feature is always supported in dom4j\";\r\n            throw new SAXNotSupportedException(msg);\r\n        }\r\n    }\r\n    features.put(name, (value) ? Boolean.TRUE : Boolean.FALSE);\r\n}"
}, {
	"Path": "org.dom4j.io.XPPReader.removeHandler",
	"Comment": "removes the elementhandler from the event based processor,for the specified path.",
	"Method": "void removeHandler(String path){\r\n    getDispatchHandler().removeHandler(path);\r\n}"
}, {
	"Path": "com.yahoo.elide.security.permissions.expressions.CheckExpression.computeCheck",
	"Comment": "actually compute the result of the check without caching concerns.",
	"Method": "ExpressionResult computeCheck(){\r\n    Object entity = (resource == null) ? null : resource.getObject();\r\n    result = check.ok(entity, requestScope, changeSpec) ? PASS : FAIL;\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.AbstractJdbcInsert.prepareStatementForGeneratedKeys",
	"Comment": "create the preparedstatement to be used for insert that have generated keys",
	"Method": "PreparedStatement prepareStatementForGeneratedKeys(Connection con){\r\n    if (getGeneratedKeyNames().length < 1) {\r\n        throw new InvalidDataAccessApiUsageException(\"Generated Key Name(s) not specificed. \" + \"Using the generated keys features requires specifying the name(s) of the generated column(s)\");\r\n    }\r\n    PreparedStatement ps;\r\n    if (this.tableMetaDataContext.isGeneratedKeysColumnNameArraySupported()) {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Using generated keys support with array of column names.\");\r\n        }\r\n        ps = con.prepareStatement(getInsertString(), getGeneratedKeyNames());\r\n    } else {\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Using generated keys support with Statement.RETURN_GENERATED_KEYS.\");\r\n        }\r\n        ps = con.prepareStatement(getInsertString(), Statement.RETURN_GENERATED_KEYS);\r\n    }\r\n    return ps;\r\n}"
}, {
	"Path": "com.yahoo.elide.standalone.config.ElideStandaloneSettings.getUserExtractionFunction",
	"Comment": "the function used to extract a user from the securitycontext.",
	"Method": "DefaultOpaqueUserFunction getUserExtractionFunction(){\r\n    return SecurityContext::getUserPrincipal;\r\n}"
}, {
	"Path": "sx.blah.discord.handle.audit.AuditLog.getEntriesByTarget",
	"Comment": "gets the entries which have a target which have the given unique snowflake id.",
	"Method": "List<TargetedEntry> getEntriesByTarget(long targetID){\r\n    return getEntries().stream().filter(TargetedEntry.class::isInstance).map(TargetedEntry.class::cast).filter(entry -> entry.getTargetID() == targetID).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.dom4j.swing.BranchTreeNode.getChildList",
	"Comment": "uses lazy initialization pattern to create a list of children",
	"Method": "List<TreeNode> getChildList(){\r\n    if (children == null) {\r\n        children = createChildList();\r\n    }\r\n    return children;\r\n}"
}, {
	"Path": "org.dcm4che3.imageio.stream.SegmentedInputImageStream.transferTo",
	"Comment": "reads all bytes from this input stream and writes the bytes to the given output stream. this methoddoes not close either stream.",
	"Method": "long transferTo(OutputStream out){\r\n    Objects.requireNonNull(out, \"out\");\r\n    long transferred = 0;\r\n    byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];\r\n    int read;\r\n    while ((read = this.read(buffer, 0, DEFAULT_BUFFER_SIZE)) > 0) {\r\n        out.write(buffer, 0, read);\r\n        transferred += read;\r\n    }\r\n    return transferred;\r\n}"
}, {
	"Path": "org.dom4j.io.DOMSAXContentHandler.error",
	"Comment": "this method is called when an error is detected during parsing such as avalidation error. this method rethrows the exception",
	"Method": "void error(SAXParseException exception){\r\n    throw exception;\r\n}"
}, {
	"Path": "japa.parser.ASTHelper.addParameter",
	"Comment": "adds the given parameter to the method. the list of parameters will beinitialized if it is null.",
	"Method": "void addParameter(MethodDeclaration method,Parameter parameter){\r\n    List<Parameter> parameters = method.getParameters();\r\n    if (parameters == null) {\r\n        parameters = new ArrayList<Parameter>();\r\n        method.setParameters(parameters);\r\n    }\r\n    parameters.add(parameter);\r\n}"
}, {
	"Path": "org.dcm4che3.net.ApplicationEntity.getVendorData",
	"Comment": "get any vendor information or configuration specific to this network ae.",
	"Method": "byte[][] getVendorData(){\r\n    return vendorData;\r\n}"
}, {
	"Path": "com.dslplatform.json.JsonWriter.size",
	"Comment": "current position in the buffer. when stream is not used, this is also equivalent\tto the size of the resulting json in bytes",
	"Method": "int size(){\r\n    return position;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.namedparam.SqlParameterSourceUtils.getTypedValue",
	"Comment": "create a wrapped value if parameter has type information, plain object if not.",
	"Method": "Object getTypedValue(SqlParameterSource source,String parameterName){\r\n    int sqlType = source.getSqlType(parameterName);\r\n    if (sqlType != SqlParameterSource.TYPE_UNKNOWN) {\r\n        if (source.getTypeName(parameterName) != null) {\r\n            return new SqlParameterValue(sqlType, source.getTypeName(parameterName), source.getValue(parameterName));\r\n        } else {\r\n            return new SqlParameterValue(sqlType, source.getValue(parameterName));\r\n        }\r\n    } else {\r\n        return source.getValue(parameterName);\r\n    }\r\n}"
}, {
	"Path": "com.yahoo.elide.core.PersistentResource.filterInMemory",
	"Comment": "filters a relationship collection in memory for scenarios where the data store transaction cannot do it.",
	"Method": "Collection<T> filterInMemory(Collection<T> collection,Optional<FilterExpression> filterExpression){\r\n    if (!filterExpression.isPresent()) {\r\n        return collection;\r\n    }\r\n    InMemoryFilterVisitor inMemoryFilterVisitor = new InMemoryFilterVisitor(requestScope);\r\n    @SuppressWarnings(\"unchecked\")\r\n    Predicate<T> inMemoryFilterFn = filterExpression.get().accept(inMemoryFilterVisitor);\r\n    return collection.stream().filter(e -> requestScope.isNewResource(e) || inMemoryFilterFn.test(e)).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.SQLStateExceptionTranslatorTests.testMalformedSqlStateCodes",
	"Comment": "postgresql can return null\tsap db can apparently return empty sql code\tbug 729170",
	"Method": "void testMalformedSqlStateCodes(){\r\n    SQLException sex = new SQLException(\"Message\", null, 1);\r\n    testMalformedSqlStateCode(sex);\r\n    sex = new SQLException(\"Message\", \"\", 1);\r\n    testMalformedSqlStateCode(sex);\r\n    sex = new SQLException(\"Message\", \"I\", 1);\r\n    testMalformedSqlStateCode(sex);\r\n}"
}, {
	"Path": "com.github.devnied.emvnfccard.utils.TlvUtil.getlistTLV",
	"Comment": "method used to get the list of tlv corresponding to tags specified in parameters",
	"Method": "List<TLV> getlistTLV(byte[] pData,ITag pTag,boolean pAdd,List<TLV> getlistTLV,byte[] pData,ITag pTag){\r\n    List<TLV> list = new ArrayList<TLV>();\r\n    ByteArrayInputStream stream = new ByteArrayInputStream(pData);\r\n    while (stream.available() > 0) {\r\n        TLV tlv = TlvUtil.getNextTLV(stream);\r\n        if (ArrayUtils.contains(pTag, tlv.getTag())) {\r\n            list.add(tlv);\r\n        } else if (tlv.getTag().isConstructed()) {\r\n            list.addAll(TlvUtil.getlistTLV(tlv.getValueBytes(), pTag));\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.SimpleJdbcDaoSupport.initTemplateConfig",
	"Comment": "create a simplejdbctemplate based on the configured jdbctemplate.",
	"Method": "void initTemplateConfig(){\r\n    this.simpleJdbcTemplate = new SimpleJdbcTemplate(getJdbcTemplate());\r\n}"
}, {
	"Path": "sx.blah.discord.util.MessageHistory.delete",
	"Comment": "deletes the message with the given id. the deleted message is not removed from the collection.",
	"Method": "IMessage delete(int index,IMessage delete,long id){\r\n    IMessage message = get(id);\r\n    if (message == null)\r\n        return null;\r\n    message.delete();\r\n    return message;\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.SqlQuery.setRowsExpected",
	"Comment": "set the number of rows expected.\tthis can be used to ensure efficient storage of results. the\tdefault behavior is not to expect any specific number of rows.",
	"Method": "void setRowsExpected(int rowsExpected){\r\n    this.rowsExpected = rowsExpected;\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.SqlUpdate.checkRowsAffected",
	"Comment": "check the given number of affected rows against the\tspecified maximum number or required number.",
	"Method": "void checkRowsAffected(int rowsAffected){\r\n    if (this.maxRowsAffected > 0 && rowsAffected > this.maxRowsAffected) {\r\n        throw new JdbcUpdateAffectedIncorrectNumberOfRowsException(getSql(), this.maxRowsAffected, rowsAffected);\r\n    }\r\n    if (this.requiredRowsAffected > 0 && rowsAffected != this.requiredRowsAffected) {\r\n        throw new JdbcUpdateAffectedIncorrectNumberOfRowsException(getSql(), this.requiredRowsAffected, rowsAffected);\r\n    }\r\n}"
}, {
	"Path": "no.priv.garshol.duke.genetic.GeneticAlgorithm.setEvolveComparators",
	"Comment": "if true, the algorithm will not evolve the comparators, but onlythe other aspects of the configuration. the default is to evolvecomparators, too.",
	"Method": "void setEvolveComparators(boolean evolve_comparators){\r\n    population.setEvolveComparators(evolve_comparators);\r\n}"
}, {
	"Path": "com.yahoo.elide.core.UpdateOnCreateTest.updatePermissionOverwrittenForAttributeSuccessCase",
	"Comment": "class level expression overwritten by field level expression",
	"Method": "void updatePermissionOverwrittenForAttributeSuccessCase(){\r\n    PersistentResource<UpdateAndCreate> loaded = PersistentResource.loadRecord(UpdateAndCreate.class, \"1\", userFourScope);\r\n    loaded.updateAttribute(\"alias\", \"\");\r\n    loaded.getRequestScope().getPermissionExecutor().executeCommitChecks();\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.SqlRowSetResultSetExtractor.createSqlRowSet",
	"Comment": "create a sqlrowset that wraps the given resultset,\trepresenting its data in a disconnected fashion.\tthis implementation creates a spring resultsetwrappingsqlrowset\tinstance that wraps a standard jdbc cachedrowset instance.\tcan be overridden to use a different implementation.",
	"Method": "SqlRowSet createSqlRowSet(ResultSet rs){\r\n    CachedRowSet rowSet = newCachedRowSet();\r\n    rowSet.populate(rs);\r\n    return new ResultSetWrappingSqlRowSet(rowSet);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.JdbcTemplate.setResultsMapCaseInsensitive",
	"Comment": "set whether execution of a callablestatement will return the results in a map\tthat uses case insensitive names for the parameters.",
	"Method": "void setResultsMapCaseInsensitive(boolean resultsMapCaseInsensitive){\r\n    this.resultsMapCaseInsensitive = resultsMapCaseInsensitive;\r\n}"
}, {
	"Path": "org.dom4j.io.HTMLWriter.loadOmitElementCloseSet",
	"Comment": "if you change this, change the javadoc for getomitelementcloseset.",
	"Method": "void loadOmitElementCloseSet(Set<String> set){\r\n    set.add(\"AREA\");\r\n    set.add(\"BASE\");\r\n    set.add(\"BR\");\r\n    set.add(\"COL\");\r\n    set.add(\"HR\");\r\n    set.add(\"IMG\");\r\n    set.add(\"INPUT\");\r\n    set.add(\"LINK\");\r\n    set.add(\"META\");\r\n    set.add(\"P\");\r\n    set.add(\"PARAM\");\r\n}"
}, {
	"Path": "org.dom4j.io.XPP3Reader.removeHandler",
	"Comment": "removes the elementhandler from the event based processor,for the specified path.",
	"Method": "void removeHandler(String path){\r\n    getDispatchHandler().removeHandler(path);\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder.setType",
	"Comment": "set the type of embedded database.\tdefaults to hsql if not called.",
	"Method": "EmbeddedDatabaseBuilder setType(EmbeddedDatabaseType databaseType){\r\n    this.databaseFactory.setDatabaseType(databaseType);\r\n    return this;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.participants.ResourceModifications.addCreate",
	"Comment": "adds the given resource to the list of resources\tto be created.",
	"Method": "void addCreate(IResource create){\r\n    if (fCreate == null)\r\n        fCreate = new ArrayList(2);\r\n    fCreate.add(create);\r\n    if (fIgnoreCount == 0) {\r\n        internalAdd(new CreateDescription(create));\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.handlers.ImplementationCollector.isFullHierarchyNeeded",
	"Comment": "checks whether a full type hierarchy is needed to search for implementors.",
	"Method": "boolean isFullHierarchyNeeded(IProgressMonitor monitor,IMethod method,IType receiverType){\r\n    ITypeHierarchy superTypeHierarchy = receiverType.newSupertypeHierarchy(monitor);\r\n    MethodOverrideTester methodOverrideTester = new MethodOverrideTester(receiverType, superTypeHierarchy);\r\n    return methodOverrideTester.findOverriddenMethodInType(receiverType, method) == null;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.AbstractDriverBasedDataSource.getConnectionFromDriver",
	"Comment": "obtain a connection using the given properties.\ttemplate method to be implemented by subclasses.",
	"Method": "Connection getConnectionFromDriver(String username,String password,Connection getConnectionFromDriver,Properties props){\r\n    Properties mergedProps = new Properties();\r\n    Properties connProps = getConnectionProperties();\r\n    if (connProps != null) {\r\n        mergedProps.putAll(connProps);\r\n    }\r\n    if (username != null) {\r\n        mergedProps.setProperty(\"user\", username);\r\n    }\r\n    if (password != null) {\r\n        mergedProps.setProperty(\"password\", password);\r\n    }\r\n    return getConnectionFromDriver(mergedProps);\r\n}"
}, {
	"Path": "no.priv.garshol.duke.genetic.GeneticPopulation.runTournament",
	"Comment": "runs a tournament among k individuals to find the most fitindividual.",
	"Method": "GeneticConfiguration runTournament(int k){\r\n    GeneticConfiguration best = pickRandomConfig();\r\n    for (int ix = 1; ix < k; ix++) {\r\n        GeneticConfiguration candidate = pickRandomConfig();\r\n        if (candidate.getFNumber() > best.getFNumber())\r\n            best = candidate;\r\n    }\r\n    return best;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.RefactoringSearchEngine2.getAffectedProjects",
	"Comment": "returns the affected java projects of the previous search queries.\tin order to retrieve the java projects, grouping by resource must have been enabled before searching.",
	"Method": "Map<IJavaProject, ? extends Set<?>> getAffectedProjects(){\r\n    IJavaProject project = null;\r\n    ICompilationUnit unit = null;\r\n    if (fGranularity == GRANULARITY_COMPILATION_UNIT) {\r\n        final Map<IJavaProject, Set<ICompilationUnit>> map = new HashMap();\r\n        final ICompilationUnit[] units = getAffectedCompilationUnits();\r\n        for (int index = 0; index < units.length; index++) {\r\n            unit = units[index];\r\n            project = unit.getJavaProject();\r\n            if (project != null) {\r\n                Set<ICompilationUnit> set = map.get(project);\r\n                if (set == null) {\r\n                    set = new HashSet();\r\n                    map.put(project, set);\r\n                }\r\n                set.add(unit);\r\n            }\r\n        }\r\n        return map;\r\n    } else {\r\n        final Map<IJavaProject, Set<SearchResultGroup>> map = new HashMap();\r\n        final SearchResultGroup[] groups = getGroupedMatches();\r\n        SearchResultGroup group = null;\r\n        for (int index = 0; index < groups.length; index++) {\r\n            group = groups[index];\r\n            unit = group.getCompilationUnit();\r\n            if (unit != null) {\r\n                project = unit.getJavaProject();\r\n                if (project != null) {\r\n                    Set<SearchResultGroup> set = map.get(project);\r\n                    if (set == null) {\r\n                        set = new HashSet();\r\n                        map.put(project, set);\r\n                    }\r\n                    set.add(group);\r\n                }\r\n            }\r\n        }\r\n        return map;\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.DriverManagerDataSource.getConnectionFromDriverManager",
	"Comment": "getting a connection using the nasty static from drivermanager is extracted\tinto a protected method to allow for easy unit testing.",
	"Method": "Connection getConnectionFromDriverManager(String url,Properties props){\r\n    return DriverManager.getConnection(url, props);\r\n}"
}, {
	"Path": "org.dom4j.DocumentFactory.createSingleton",
	"Comment": "createsingleton creates the singleton instance from thegiven class name.",
	"Method": "SingletonStrategy<DocumentFactory> createSingleton(DocumentFactory createSingleton,String className){\r\n    try {\r\n        Class<DocumentFactory> theClass = (Class<DocumentFactory>) Class.forName(className, true, DocumentFactory.class.getClassLoader());\r\n        return theClass.newInstance();\r\n    } catch (Throwable e) {\r\n        System.out.println(\"WARNING: Cannot load DocumentFactory: \" + className);\r\n        return new DocumentFactory();\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.SimpleJdbcTemplate.getJdbcOperations",
	"Comment": "expose the classic spring jdbctemplate to allow invocation of\tless commonly used methods.",
	"Method": "JdbcOperations getJdbcOperations(){\r\n    return this.namedParameterJdbcOperations.getJdbcOperations();\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.init.ResourceDatabasePopulator.setScripts",
	"Comment": "set the scripts to execute to initialize or clean up the database,\treplacing any previously added scripts.",
	"Method": "void setScripts(Resource scripts){\r\n    assertContentsOfScriptArray(scripts);\r\n    this.scripts = new ArrayList<Resource>(Arrays.asList(scripts));\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corrections.proposals.CUCorrectionProposal.getTextChange",
	"Comment": "returns the text change that is invoked when the change is applied.",
	"Method": "TextChange getTextChange(){\r\n    return (TextChange) getChange();\r\n}"
}, {
	"Path": "org.dom4j.rule.RuleSet.addAll",
	"Comment": "adds all the rules to this ruleset from the given other rule set.",
	"Method": "void addAll(RuleSet that){\r\n    rules.addAll(that.rules);\r\n    ruleArray = null;\r\n}"
}, {
	"Path": "com.dslplatform.json.JsonReader.next",
	"Comment": "will advance to next token and bind the json to provided instance",
	"Method": "T next(Class<T> manifest,T next,ReadObject<T> reader,T next,Class<T> manifest,T instance,T next,BindObject<T> binder,T instance,T next,T next){\r\n    if (binder == null)\r\n        throw new IllegalArgumentException(\"binder can't be null\");\r\n    if (instance == null)\r\n        throw new IllegalArgumentException(\"instance can't be null\");\r\n    if (this.getNextToken() == 'n') {\r\n        if (!wasNull())\r\n            throw new IllegalArgumentException(\"Invalid JSON detected \" + positionDescription());\r\n        return null;\r\n    }\r\n    return binder.bind(this, instance);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.StatementCreatorUtils.setParameterValueInternal",
	"Comment": "set the value for a parameter. the method used is based on the sql type\tof the parameter and we can handle complex types like arrays and lobs.",
	"Method": "void setParameterValueInternal(PreparedStatement ps,int paramIndex,int sqlType,String typeName,Integer scale,Object inValue){\r\n    String typeNameToUse = typeName;\r\n    int sqlTypeToUse = sqlType;\r\n    Object inValueToUse = inValue;\r\n    if (inValue instanceof SqlParameterValue) {\r\n        SqlParameterValue parameterValue = (SqlParameterValue) inValue;\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"Overriding type info with runtime info from SqlParameterValue: column index \" + paramIndex + \", SQL type \" + parameterValue.getSqlType() + \", type name \" + parameterValue.getTypeName());\r\n        }\r\n        if (parameterValue.getSqlType() != SqlTypeValue.TYPE_UNKNOWN) {\r\n            sqlTypeToUse = parameterValue.getSqlType();\r\n        }\r\n        if (parameterValue.getTypeName() != null) {\r\n            typeNameToUse = parameterValue.getTypeName();\r\n        }\r\n        inValueToUse = parameterValue.getValue();\r\n    }\r\n    if (logger.isTraceEnabled()) {\r\n        logger.trace(\"Setting SQL statement parameter value: column index \" + paramIndex + \", parameter value [\" + inValueToUse + \"], value class [\" + (inValueToUse != null ? inValueToUse.getClass().getName() : \"null\") + \"], SQL type \" + (sqlTypeToUse == SqlTypeValue.TYPE_UNKNOWN ? \"unknown\" : Integer.toString(sqlTypeToUse)));\r\n    }\r\n    if (inValueToUse == null) {\r\n        setNull(ps, paramIndex, sqlTypeToUse, typeNameToUse);\r\n    } else {\r\n        setValue(ps, paramIndex, sqlTypeToUse, typeNameToUse, scale, inValueToUse);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.support.AbstractLobStreamingResultSetExtractor.handleMultipleRowsFound",
	"Comment": "handle the case where the resultset contains multiple rows.",
	"Method": "void handleMultipleRowsFound(){\r\n    throw new IncorrectResultSizeDataAccessException(\"LobStreamingResultSetExtractor found multiple rows in database\", 1);\r\n}"
}, {
	"Path": "no.priv.garshol.duke.server.CommonJTimer.stop",
	"Comment": "stops the background thread. it can be restarted with a new callto spawnthread.",
	"Method": "void stop(){\r\n    timer.cancel();\r\n    timer = null;\r\n}"
}, {
	"Path": "org.dom4j.tree.AbstractDocumentType.getText",
	"Comment": "returns the text format of the declarations if applicable, or the emptystring",
	"Method": "String getText(){\r\n    List<Decl> list = getInternalDeclarations();\r\n    if ((list != null) && (list.size() > 0)) {\r\n        StringBuilder buffer = new StringBuilder();\r\n        Iterator<Decl> iter = list.iterator();\r\n        if (iter.hasNext()) {\r\n            Decl decl = iter.next();\r\n            buffer.append(decl.toString());\r\n            while (iter.hasNext()) {\r\n                decl = iter.next();\r\n                buffer.append(\"\\n\");\r\n                buffer.append(decl.toString());\r\n            }\r\n        }\r\n        return buffer.toString();\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "com.yahoo.elide.standalone.config.ElideStandaloneSettings.getCheckMappings",
	"Comment": "a map containing check mappings for security across elide. if not provided, then an empty map is used.in case of an empty map, checks can be referenced by their fully qualified class names.",
	"Method": "Map<String, Class<? extends Check>> getCheckMappings(){\r\n    return Collections.emptyMap();\r\n}"
}, {
	"Path": "org.dom4j.io.XPP3Reader.setDefaultHandler",
	"Comment": "when multiple elementhandler instances have beenregistered, this will set a default elementhandler to becalled for any path which does nothave a handler registered.",
	"Method": "void setDefaultHandler(ElementHandler handler){\r\n    getDispatchHandler().setDefaultHandler(handler);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.TableMetaDataContext.reconcileColumnsToUse",
	"Comment": "compare columns created from metadata with declared columns and return a reconciled list.",
	"Method": "List<String> reconcileColumnsToUse(List<String> declaredColumns,String[] generatedKeyNames){\r\n    if (generatedKeyNames.length > 0) {\r\n        this.generatedKeyColumnsUsed = true;\r\n    }\r\n    if (declaredColumns.size() > 0) {\r\n        return new ArrayList<String>(declaredColumns);\r\n    }\r\n    Set<String> keys = new HashSet<String>(generatedKeyNames.length);\r\n    for (String key : generatedKeyNames) {\r\n        keys.add(key.toUpperCase());\r\n    }\r\n    List<String> columns = new ArrayList<String>();\r\n    for (TableParameterMetaData meta : metaDataProvider.getTableParameterMetaData()) {\r\n        if (!keys.contains(meta.getParameterName().toUpperCase())) {\r\n            columns.add(meta.getParameterName());\r\n        }\r\n    }\r\n    return columns;\r\n}"
}, {
	"Path": "com.yahoo.elide.datastores.multiplex.MultiplexWriteTransaction.hold",
	"Comment": "save cloned copy of object for possible reverse transaction.",
	"Method": "Iterable<T> hold(DataStoreTransaction transaction,Iterable<T> list,T hold,DataStoreTransaction subTransaction,T object){\r\n    if (subTransaction != lastDataStoreTransaction) {\r\n        clonedObjects.put(object, cloneObject(object));\r\n    }\r\n    return object;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.genetic.GeneticConfiguration.getParent",
	"Comment": "returns the configuration this configuration was derived from, ifany.",
	"Method": "GeneticConfiguration getParent(){\r\n    return parent;\r\n}"
}, {
	"Path": "sx.blah.discord.modules.ModuleLoader.hasDependency",
	"Comment": "gets whether the given list of modules has a module with the given class name.",
	"Method": "boolean hasDependency(List<IModule> modules,String className){\r\n    for (IModule module : modules) if (module.getClass().getName().equals(className))\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.CallableStatementCreatorFactory.setResultSetType",
	"Comment": "set whether to use prepared statements that return a specific type of resultset.\tspecific type of resultset.",
	"Method": "void setResultSetType(int resultSetType){\r\n    this.resultSetType = resultSetType;\r\n}"
}, {
	"Path": "org.dom4j.io.SAXValidator.validate",
	"Comment": "validates the given document by writing it to a validatingsax parser.",
	"Method": "void validate(Document document){\r\n    if (document != null) {\r\n        XMLReader reader = getXMLReader();\r\n        if (errorHandler != null) {\r\n            reader.setErrorHandler(errorHandler);\r\n        }\r\n        try {\r\n            reader.parse(new DocumentInputSource(document));\r\n        } catch (IOException e) {\r\n            throw new RuntimeException(\"Caught and exception that should \" + \"never happen: \" + e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "no.priv.garshol.duke.Link.retract",
	"Comment": "changes the link status to retracted, and updates the timestamp.does not write to the database. sets the confidence to0.0.",
	"Method": "void retract(){\r\n    status = LinkStatus.RETRACTED;\r\n    confidence = 0.0;\r\n    timestamp = System.currentTimeMillis();\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.RdbmsOperation.isUpdatableResults",
	"Comment": "return whether statements will return updatable resultsets.",
	"Method": "boolean isUpdatableResults(){\r\n    return this.updatableResults;\r\n}"
}, {
	"Path": "com.yahoo.elide.security.executors.ActivePermissionExecutor.checkPermission",
	"Comment": "check permission on class. checking on sharepermission falls to check readpermission.",
	"Method": "ExpressionResult checkPermission(Class<A> annotationClass,PersistentResource resource,ExpressionResult checkPermission,Class<A> annotationClass,PersistentResource resource,ChangeSpec changeSpec){\r\n    Supplier<Expression> expressionSupplier = () -> {\r\n        if (SharePermission.class == annotationClass) {\r\n            if (requestScope.getDictionary().isShareable(resource.getResourceClass())) {\r\n                return expressionBuilder.buildAnyFieldExpressions(resource, ReadPermission.class, changeSpec);\r\n            } else {\r\n                return PermissionExpressionBuilder.FAIL_EXPRESSION;\r\n            }\r\n        }\r\n        return expressionBuilder.buildAnyFieldExpressions(resource, annotationClass, changeSpec);\r\n    };\r\n    Function<Expression, ExpressionResult> expressionExecutor = (expression) -> {\r\n        if (requestScope.getNewPersistentResources().contains(resource)) {\r\n            return executeUserChecksDeferInline(annotationClass, expression);\r\n        }\r\n        return executeExpressions(expression, annotationClass, Expression.EvaluationMode.INLINE_CHECKS_ONLY);\r\n    };\r\n    return checkPermissions(resource.getResourceClass(), annotationClass, Optional.empty(), expressionSupplier, expressionExecutor);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.JavaClientConnection.logMessage",
	"Comment": "sends the logmessage message back to the client as a notification",
	"Method": "void logMessage(MessageType type,String msg){\r\n    MessageParams $ = new MessageParams();\r\n    $.setMessage(msg);\r\n    $.setType(type);\r\n    client.logMessage($);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.ColumnMapRowMapper.getColumnKey",
	"Comment": "determine the key to use for the given column in the column map.",
	"Method": "String getColumnKey(String columnName){\r\n    return columnName;\r\n}"
}, {
	"Path": "com.dslplatform.json.JsonReader.readSimpleString",
	"Comment": "read simple ascii string. will not use values cache to create instance.",
	"Method": "String readSimpleString(){\r\n    if (last != '\"') {\r\n        throw new IOException(\"Expecting '\\\"' \" + positionDescription() + \". Found \" + (char) last);\r\n    }\r\n    int i = 0;\r\n    int ci = currentIndex;\r\n    try {\r\n        while (i < tmp.length) {\r\n            final byte bb = buffer[ci++];\r\n            if (bb == '\"')\r\n                break;\r\n            tmp[i++] = (char) bb;\r\n        }\r\n    } catch (ArrayIndexOutOfBoundsException ignore) {\r\n        throw new IOException(\"JSON string was not closed with a double quote \" + positionDescription());\r\n    }\r\n    if (ci > length) {\r\n        throw new IOException(\"JSON string was not closed with a double quote at: \" + (currentPosition + length));\r\n    }\r\n    currentIndex = ci;\r\n    return new String(tmp, 0, i);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.CallMetaDataContext.createCallString",
	"Comment": "build the call string based on configuration and metadata information.",
	"Method": "String createCallString(){\r\n    String callString;\r\n    int parameterCount = 0;\r\n    String catalogNameToUse;\r\n    String schemaNameToUse;\r\n    if (this.metaDataProvider.isSupportsSchemasInProcedureCalls() && !this.metaDataProvider.isSupportsCatalogsInProcedureCalls()) {\r\n        schemaNameToUse = this.metaDataProvider.catalogNameToUse(this.getCatalogName());\r\n        catalogNameToUse = this.metaDataProvider.schemaNameToUse(this.getSchemaName());\r\n    } else {\r\n        catalogNameToUse = this.metaDataProvider.catalogNameToUse(this.getCatalogName());\r\n        schemaNameToUse = this.metaDataProvider.schemaNameToUse(this.getSchemaName());\r\n    }\r\n    String procedureNameToUse = this.metaDataProvider.procedureNameToUse(this.getProcedureName());\r\n    if (this.isFunction() || this.isReturnValueRequired()) {\r\n        callString = \"{? = call \" + (StringUtils.hasLength(catalogNameToUse) ? catalogNameToUse + \".\" : \"\") + (StringUtils.hasLength(schemaNameToUse) ? schemaNameToUse + \".\" : \"\") + procedureNameToUse + \"(\";\r\n        parameterCount = -1;\r\n    } else {\r\n        callString = \"{call \" + (StringUtils.hasLength(catalogNameToUse) ? catalogNameToUse + \".\" : \"\") + (StringUtils.hasLength(schemaNameToUse) ? schemaNameToUse + \".\" : \"\") + procedureNameToUse + \"(\";\r\n    }\r\n    for (SqlParameter parameter : this.callParameters) {\r\n        if (!(parameter.isResultsParameter())) {\r\n            if (parameterCount > 0) {\r\n                callString += \", \";\r\n            }\r\n            if (parameterCount >= 0) {\r\n                callString += \"?\";\r\n            }\r\n            parameterCount++;\r\n        }\r\n    }\r\n    callString += \")}\";\r\n    return callString;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.TableMetaDataProviderFactory.createMetaDataProvider",
	"Comment": "create a tablemetadataprovider based on the database metedata",
	"Method": "TableMetaDataProvider createMetaDataProvider(DataSource dataSource,TableMetaDataContext context,TableMetaDataProvider createMetaDataProvider,DataSource dataSource,TableMetaDataContext context,NativeJdbcExtractor nativeJdbcExtractor){\r\n    try {\r\n        return (TableMetaDataProvider) JdbcUtils.extractDatabaseMetaData(dataSource, new DatabaseMetaDataCallback() {\r\n            @Override\r\n            public Object processMetaData(DatabaseMetaData databaseMetaData) throws SQLException {\r\n                String databaseProductName = JdbcUtils.commonDatabaseName(databaseMetaData.getDatabaseProductName());\r\n                boolean accessTableColumnMetaData = context.isAccessTableColumnMetaData();\r\n                TableMetaDataProvider provider;\r\n                if (\"Oracle\".equals(databaseProductName)) {\r\n                    provider = new OracleTableMetaDataProvider(databaseMetaData, context.isOverrideIncludeSynonymsDefault());\r\n                } else if (\"HSQL Database Engine\".equals(databaseProductName)) {\r\n                    provider = new HsqlTableMetaDataProvider(databaseMetaData);\r\n                } else if (\"PostgreSQL\".equals(databaseProductName)) {\r\n                    provider = new PostgresTableMetaDataProvider(databaseMetaData);\r\n                } else if (\"Apache Derby\".equals(databaseProductName)) {\r\n                    provider = new DerbyTableMetaDataProvider(databaseMetaData);\r\n                } else {\r\n                    provider = new GenericTableMetaDataProvider(databaseMetaData);\r\n                }\r\n                if (nativeJdbcExtractor != null) {\r\n                    provider.setNativeJdbcExtractor(nativeJdbcExtractor);\r\n                }\r\n                if (logger.isDebugEnabled()) {\r\n                    logger.debug(\"Using \" + provider.getClass().getSimpleName());\r\n                }\r\n                provider.initializeWithMetaData(databaseMetaData);\r\n                if (accessTableColumnMetaData) {\r\n                    provider.initializeWithTableColumnMetaData(databaseMetaData, context.getCatalogName(), context.getSchemaName(), context.getTableName());\r\n                }\r\n                return provider;\r\n            }\r\n        });\r\n    } catch (MetaDataAccessException ex) {\r\n        throw new DataAccessResourceFailureException(\"Error retrieving database metadata\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.TableMetaDataProviderFactory.createMetaDataProvider",
	"Comment": "create a tablemetadataprovider based on the database metedata",
	"Method": "TableMetaDataProvider createMetaDataProvider(DataSource dataSource,TableMetaDataContext context,TableMetaDataProvider createMetaDataProvider,DataSource dataSource,TableMetaDataContext context,NativeJdbcExtractor nativeJdbcExtractor){\r\n    String databaseProductName = JdbcUtils.commonDatabaseName(databaseMetaData.getDatabaseProductName());\r\n    boolean accessTableColumnMetaData = context.isAccessTableColumnMetaData();\r\n    TableMetaDataProvider provider;\r\n    if (\"Oracle\".equals(databaseProductName)) {\r\n        provider = new OracleTableMetaDataProvider(databaseMetaData, context.isOverrideIncludeSynonymsDefault());\r\n    } else if (\"HSQL Database Engine\".equals(databaseProductName)) {\r\n        provider = new HsqlTableMetaDataProvider(databaseMetaData);\r\n    } else if (\"PostgreSQL\".equals(databaseProductName)) {\r\n        provider = new PostgresTableMetaDataProvider(databaseMetaData);\r\n    } else if (\"Apache Derby\".equals(databaseProductName)) {\r\n        provider = new DerbyTableMetaDataProvider(databaseMetaData);\r\n    } else {\r\n        provider = new GenericTableMetaDataProvider(databaseMetaData);\r\n    }\r\n    if (nativeJdbcExtractor != null) {\r\n        provider.setNativeJdbcExtractor(nativeJdbcExtractor);\r\n    }\r\n    if (logger.isDebugEnabled()) {\r\n        logger.debug(\"Using \" + provider.getClass().getSimpleName());\r\n    }\r\n    provider.initializeWithMetaData(databaseMetaData);\r\n    if (accessTableColumnMetaData) {\r\n        provider.initializeWithTableColumnMetaData(databaseMetaData, context.getCatalogName(), context.getSchemaName(), context.getTableName());\r\n    }\r\n    return provider;\r\n}"
}, {
	"Path": "com.yahoo.elide.extensions.JsonApiPatch.throwErrorResponse",
	"Comment": "turn an exception into a proper error response from patch extension.",
	"Method": "void throwErrorResponse(){\r\n    ObjectNode errorContainer = getErrorContainer();\r\n    ArrayNode errorList = (ArrayNode) errorContainer.get(\"errors\");\r\n    boolean failed = false;\r\n    for (PatchAction action : actions) {\r\n        failed = processAction(errorList, failed, action);\r\n    }\r\n    throw new JsonPatchExtensionException(HttpStatus.SC_BAD_REQUEST, errorContainer);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.AbstractJdbcInsert.setOverrideIncludeSynonymsDefault",
	"Comment": "specify whether the default for including synonyms should be changed.the default is false.",
	"Method": "void setOverrideIncludeSynonymsDefault(boolean override){\r\n    this.tableMetaDataContext.setOverrideIncludeSynonymsDefault(override);\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.RdbmsOperation.validateParameterCount",
	"Comment": "validate the given parameter count against the given declared parameters.",
	"Method": "void validateParameterCount(int suppliedParamCount,int declaredInParamCount){\r\n    if (suppliedParamCount < declaredInParamCount) {\r\n        throw new InvalidDataAccessApiUsageException(suppliedParamCount + \" parameters were supplied, but \" + declaredInParamCount + \" in parameters were declared in class [\" + getClass().getName() + \"]\");\r\n    }\r\n    if (suppliedParamCount > this.declaredParameters.size() && !allowsUnusedParameters()) {\r\n        throw new InvalidDataAccessApiUsageException(suppliedParamCount + \" parameters were supplied, but \" + declaredInParamCount + \" parameters were declared in class [\" + getClass().getName() + \"]\");\r\n    }\r\n}"
}, {
	"Path": "org.dom4j.io.STAXEventReader.createComment",
	"Comment": "constructs a new dom4j comment from the provided stax comment event.",
	"Method": "org.dom4j.Comment createComment(Comment comment){\r\n    return factory.createComment(comment.getText());\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.SqlUpdate.setMaxRowsAffected",
	"Comment": "set the maximum number of rows that may be affected by this update.\tthe default value is 0, which does not limit the number of rows affected.",
	"Method": "void setMaxRowsAffected(int maxRowsAffected){\r\n    this.maxRowsAffected = maxRowsAffected;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.rename.RenamingNameSuggestor.isLegalChar",
	"Comment": "false if the character is a letter and it is lowercase. true in all other\tcases.",
	"Method": "boolean isLegalChar(char c){\r\n    if (Character.isLetter(c)) {\r\n        return Character.isUpperCase(c);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.CallMetaDataContext.setAccessCallParameterMetaData",
	"Comment": "specify whether call parameter metadata should be accessed.",
	"Method": "void setAccessCallParameterMetaData(boolean accessCallParameterMetaData){\r\n    this.accessCallParameterMetaData = accessCallParameterMetaData;\r\n}"
}, {
	"Path": "com.yahoo.elide.core.filter.dialect.MultipleFilterDialectTest.testTypedExpressionParseFailure",
	"Comment": "verify that the last error is returned when all dialects fail.",
	"Method": "void testTypedExpressionParseFailure(){\r\n    SubqueryFilterDialect dialect1 = mock(SubqueryFilterDialect.class);\r\n    SubqueryFilterDialect dialect2 = mock(SubqueryFilterDialect.class);\r\n    MultipleFilterDialect dialect = new MultipleFilterDialect(Collections.EMPTY_LIST, Lists.newArrayList(dialect1, dialect2));\r\n    MultivaluedMap<String, String> queryParams = new MultivaluedHashMap();\r\n    queryParams.add(\"filter[author.books.title][in]\", \"foo,bar,baz\");\r\n    queryParams.add(\"filter[author.name][infix]\", \"Hemingway\");\r\n    when(dialect1.parseTypedExpression(\"/author\", queryParams)).thenThrow(new ParseException(\"one\"));\r\n    when(dialect2.parseTypedExpression(\"/author\", queryParams)).thenThrow(new ParseException(\"two\"));\r\n    try {\r\n        dialect.parseTypedExpression(\"/author\", queryParams);\r\n    } catch (ParseException e) {\r\n        Assert.assertEquals(e.getMessage(), \"two\\none\");\r\n    }\r\n}"
}, {
	"Path": "com.yahoo.elide.core.pagination.Pagination.evaluate",
	"Comment": "evaluates the pagination variables. uses the paginate annotation if it has been set for the entity to bequeried.",
	"Method": "Pagination evaluate(int defaultLimit,int maxLimit,Pagination evaluate,Class entityClass){\r\n    Paginate paginate = entityClass != null ? (Paginate) entityClass.getAnnotation(Paginate.class) : null;\r\n    int defaultLimit = paginate != null ? paginate.defaultLimit() : defaultPageSize;\r\n    int maxLimit = paginate != null ? paginate.maxLimit() : defaultMaxPageSize;\r\n    evaluate(defaultLimit, maxLimit);\r\n    generateTotals = generateTotals && (paginate == null || paginate.countable());\r\n    return this;\r\n}"
}, {
	"Path": "org.springframework.jdbc.object.RdbmsOperation.compile",
	"Comment": "compile this query.\tignores subsequent attempts to compile.",
	"Method": "void compile(){\r\n    if (!isCompiled()) {\r\n        if (getSql() == null) {\r\n            throw new InvalidDataAccessApiUsageException(\"Property 'sql' is required\");\r\n        }\r\n        try {\r\n            this.jdbcTemplate.afterPropertiesSet();\r\n        } catch (IllegalArgumentException ex) {\r\n            throw new InvalidDataAccessApiUsageException(ex.getMessage());\r\n        }\r\n        compileInternal();\r\n        this.compiled = true;\r\n        if (logger.isDebugEnabled()) {\r\n            logger.debug(\"RdbmsOperation with SQL [\" + getSql() + \"] compiled\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.JdbcTemplate.extractReturnedResults",
	"Comment": "extract returned resultsets from the completed stored procedure.",
	"Method": "Map<String, Object> extractReturnedResults(CallableStatement cs,List<SqlParameter> updateCountParameters,List<SqlParameter> resultSetParameters,int updateCount){\r\n    Map<String, Object> returnedResults = new HashMap<String, Object>();\r\n    int rsIndex = 0;\r\n    int updateIndex = 0;\r\n    boolean moreResults;\r\n    if (!this.skipResultsProcessing) {\r\n        do {\r\n            if (updateCount == -1) {\r\n                if (resultSetParameters != null && resultSetParameters.size() > rsIndex) {\r\n                    SqlReturnResultSet declaredRsParam = (SqlReturnResultSet) resultSetParameters.get(rsIndex);\r\n                    returnedResults.putAll(processResultSet(cs.getResultSet(), declaredRsParam));\r\n                    rsIndex++;\r\n                } else {\r\n                    if (!this.skipUndeclaredResults) {\r\n                        String rsName = RETURN_RESULT_SET_PREFIX + (rsIndex + 1);\r\n                        SqlReturnResultSet undeclaredRsParam = new SqlReturnResultSet(rsName, new ColumnMapRowMapper());\r\n                        if (logger.isDebugEnabled()) {\r\n                            logger.debug(\"Added default SqlReturnResultSet parameter named '\" + rsName + \"'\");\r\n                        }\r\n                        returnedResults.putAll(processResultSet(cs.getResultSet(), undeclaredRsParam));\r\n                        rsIndex++;\r\n                    }\r\n                }\r\n            } else {\r\n                if (updateCountParameters != null && updateCountParameters.size() > updateIndex) {\r\n                    SqlReturnUpdateCount ucParam = (SqlReturnUpdateCount) updateCountParameters.get(updateIndex);\r\n                    String declaredUcName = ucParam.getName();\r\n                    returnedResults.put(declaredUcName, updateCount);\r\n                    updateIndex++;\r\n                } else {\r\n                    if (!this.skipUndeclaredResults) {\r\n                        String undeclaredName = RETURN_UPDATE_COUNT_PREFIX + (updateIndex + 1);\r\n                        if (logger.isDebugEnabled()) {\r\n                            logger.debug(\"Added default SqlReturnUpdateCount parameter named '\" + undeclaredName + \"'\");\r\n                        }\r\n                        returnedResults.put(undeclaredName, updateCount);\r\n                        updateIndex++;\r\n                    }\r\n                }\r\n            }\r\n            moreResults = cs.getMoreResults();\r\n            updateCount = cs.getUpdateCount();\r\n            if (logger.isDebugEnabled()) {\r\n                logger.debug(\"CallableStatement.getUpdateCount() returned \" + updateCount);\r\n            }\r\n        } while (moreResults || updateCount != -1);\r\n    }\r\n    return returnedResults;\r\n}"
}, {
	"Path": "org.dom4j.io.HTMLWriter.writeClose",
	"Comment": "overriden method to not close certain element names to avoid wierdbehaviour from browsers for versions up to 5.x",
	"Method": "void writeClose(String qualifiedName){\r\n    if (!omitElementClose(qualifiedName)) {\r\n        super.writeClose(qualifiedName);\r\n    }\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.util.TextChangeManager.get",
	"Comment": "returns the textchange associated with the given compilation unit.\tif the manager does not already manage an association it creates a one.",
	"Method": "TextChange get(ICompilationUnit cu){\r\n    TextChange result = fMap.get(cu);\r\n    if (result == null) {\r\n        result = new CompilationUnitChange(cu.getElementName(), cu);\r\n        result.setKeepPreviewEdits(fKeepExecutedTextEdits);\r\n        fMap.put(cu, result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "sx.blah.discord.util.MessageHistory.deepCopy",
	"Comment": "creates a copy of the collection made up of copies of the individual messages in the collection.",
	"Method": "MessageHistory deepCopy(){\r\n    IMessage[] copied = new IMessage[backing.length];\r\n    for (int i = 0; i < backing.length; i++) copied[i] = backing[i].copy();\r\n    return new MessageHistory(copied);\r\n}"
}, {
	"Path": "sx.blah.discord.util.MessageBuilder.appendQuote",
	"Comment": "appends a multiline code block with no language highlighting to the message.",
	"Method": "MessageBuilder appendQuote(String content){\r\n    return appendCode(\"\", content);\r\n}"
}, {
	"Path": "no.priv.garshol.duke.PropertyImpl.compare",
	"Comment": "returns the probability that the records v1 and v2 came fromrepresent the same entity, based on high and low probabilitysettings etc.",
	"Method": "double compare(String v1,String v2){\r\n    if (comparator == null)\r\n        return 0.5;\r\n    double sim = comparator.compare(v1, v2);\r\n    if (sim >= 0.5)\r\n        return ((high - 0.5) * (sim * sim)) + 0.5;\r\n    else\r\n        return low;\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.DelegatingDataSource.getTargetDataSource",
	"Comment": "return the target datasource that this datasource should delegate to.",
	"Method": "DataSource getTargetDataSource(){\r\n    return this.targetDataSource;\r\n}"
}, {
	"Path": "org.springframework.jdbc.support.SQLErrorCodes.setDatabaseProductName",
	"Comment": "set this property if the database name contains spaces,\tin which case we can not use the bean name for lookup.",
	"Method": "void setDatabaseProductName(String databaseProductName){\r\n    this.databaseProductNames = new String[] { databaseProductName };\r\n}"
}, {
	"Path": "org.dom4j.io.XPPReader.setDefaultHandler",
	"Comment": "when multiple elementhandler instances have beenregistered, this will set a default elementhandler to becalled for any path which does nothave a handler registered.",
	"Method": "void setDefaultHandler(ElementHandler handler){\r\n    getDispatchHandler().setDefaultHandler(handler);\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corrections.proposals.ASTRewriteCorrectionProposal.getImportRewrite",
	"Comment": "returns the import rewrite used for this compilation unit.",
	"Method": "ImportRewrite getImportRewrite(){\r\n    return fImportRewrite;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.rename.RenameTypeProcessor.initializeSimilarElementsRenameProcessors",
	"Comment": "creates and initializes the refactoring processors for similarly named\telements",
	"Method": "RefactoringStatus initializeSimilarElementsRenameProcessors(IProgressMonitor progressMonitor,CheckConditionsContext context){\r\n    Assert.isNotNull(fPreloadedElementToName);\r\n    Assert.isNotNull(fPreloadedElementToSelection);\r\n    final RefactoringStatus status = new RefactoringStatus();\r\n    final Set<IMethod> handledTopLevelMethods = new HashSet();\r\n    final Set<Warning> warnings = new HashSet();\r\n    final List<RefactoringProcessor> processors = new ArrayList();\r\n    fFinalSimilarElementToName = new HashMap();\r\n    CompilationUnit currentResolvedCU = null;\r\n    ICompilationUnit currentCU = null;\r\n    int current = 0;\r\n    final int max = fPreloadedElementToName.size();\r\n    progressMonitor.beginTask(\"\", max * 3);\r\n    progressMonitor.setTaskName(RefactoringCoreMessages.RenameTypeProcessor_checking_similarly_named_declarations_refactoring_conditions);\r\n    for (Iterator<IJavaElement> iter = fPreloadedElementToName.keySet().iterator(); iter.hasNext(); ) {\r\n        final IJavaElement element = iter.next();\r\n        current++;\r\n        progressMonitor.worked(3);\r\n        if (!(fPreloadedElementToSelection.get(element)).booleanValue()) {\r\n            continue;\r\n        }\r\n        if (fFinalSimilarElementToName.containsKey(element)) {\r\n            continue;\r\n        }\r\n        ICompilationUnit newCU = (ICompilationUnit) element.getAncestor(IJavaElement.COMPILATION_UNIT);\r\n        if (!newCU.equals(currentCU)) {\r\n            checkCUCompleteConditions(status, currentResolvedCU, currentCU, processors);\r\n            if (status.hasFatalError()) {\r\n                return status;\r\n            }\r\n            currentResolvedCU = null;\r\n            currentCU = newCU;\r\n            processors.clear();\r\n        }\r\n        final String newName = fPreloadedElementToName.get(element);\r\n        RefactoringProcessor processor = null;\r\n        if (element instanceof ILocalVariable) {\r\n            final ILocalVariable currentLocal = (ILocalVariable) element;\r\n            if (currentResolvedCU == null) {\r\n                currentResolvedCU = new RefactoringASTParser(IASTSharedValues.SHARED_AST_LEVEL).parse(currentCU, true);\r\n            }\r\n            processor = createLocalRenameProcessor(currentLocal, newName, currentResolvedCU);\r\n            if (status.hasFatalError()) {\r\n                return status;\r\n            }\r\n            fFinalSimilarElementToName.put(currentLocal, newName);\r\n        }\r\n        if (element instanceof IField) {\r\n            final IField currentField = (IField) element;\r\n            processor = createFieldRenameProcessor(currentField, newName);\r\n            status.merge(checkForConflictingRename(currentField, newName));\r\n            if (status.hasFatalError()) {\r\n                return status;\r\n            }\r\n            fFinalSimilarElementToName.put(currentField, newName);\r\n        }\r\n        if (element instanceof IMethod) {\r\n            IMethod currentMethod = (IMethod) element;\r\n            if (MethodChecks.isVirtual(currentMethod)) {\r\n                final IType declaringType = currentMethod.getDeclaringType();\r\n                ITypeHierarchy hierarchy = null;\r\n                if (!declaringType.isInterface()) {\r\n                    hierarchy = declaringType.newTypeHierarchy(new NullProgressMonitor());\r\n                }\r\n                final IMethod topmost = MethodChecks.getTopmostMethod(currentMethod, hierarchy, new NullProgressMonitor());\r\n                if (topmost != null) {\r\n                    currentMethod = topmost;\r\n                }\r\n                if (handledTopLevelMethods.contains(currentMethod)) {\r\n                    continue;\r\n                }\r\n                handledTopLevelMethods.add(currentMethod);\r\n                final IMethod[] ripples = RippleMethodFinder2.getRelatedMethods(currentMethod, new NullProgressMonitor(), null);\r\n                if (checkForWarnings(warnings, newName, ripples)) {\r\n                    continue;\r\n                }\r\n                status.merge(checkForConflictingRename(ripples, newName));\r\n                if (status.hasFatalError()) {\r\n                    return status;\r\n                }\r\n                processor = createVirtualMethodRenameProcessor(currentMethod, newName, ripples, hierarchy);\r\n                fFinalSimilarElementToName.put(currentMethod, newName);\r\n                for (int i = 0; i < ripples.length; i++) {\r\n                    fFinalSimilarElementToName.put(ripples[i], newName);\r\n                }\r\n            } else {\r\n                status.merge(checkForConflictingRename(new IMethod[] { currentMethod }, newName));\r\n                if (status.hasFatalError()) {\r\n                    break;\r\n                }\r\n                fFinalSimilarElementToName.put(currentMethod, newName);\r\n                processor = createNonVirtualMethodRenameProcessor(currentMethod, newName);\r\n            }\r\n        }\r\n        progressMonitor.subTask(Messages.format(RefactoringCoreMessages.RenameTypeProcessor_progress_current_total, new Object[] { String.valueOf(current), String.valueOf(max) }));\r\n        status.merge(processor.checkInitialConditions(new NoOverrideProgressMonitor(progressMonitor, 1)));\r\n        if (status.hasFatalError()) {\r\n            return status;\r\n        }\r\n        status.merge(processor.checkFinalConditions(new NoOverrideProgressMonitor(progressMonitor, 1), context));\r\n        if (status.hasFatalError()) {\r\n            return status;\r\n        }\r\n        processors.add(processor);\r\n        progressMonitor.worked(1);\r\n        if (progressMonitor.isCanceled()) {\r\n            throw new OperationCanceledException();\r\n        }\r\n    }\r\n    checkCUCompleteConditions(status, currentResolvedCU, currentCU, processors);\r\n    status.merge(addWarnings(warnings));\r\n    progressMonitor.done();\r\n    return status;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.simple.AbstractJdbcInsert.matchInParameterValuesWithInsertColumns",
	"Comment": "match the provided in parameter values with regitered parameters and parameters defined\tvia metadata processing.",
	"Method": "List<Object> matchInParameterValuesWithInsertColumns(SqlParameterSource parameterSource,List<Object> matchInParameterValuesWithInsertColumns,Map<String, Object> args){\r\n    return this.tableMetaDataContext.matchInParameterValuesWithInsertColumns(args);\r\n}"
}, {
	"Path": "org.springframework.jdbc.datasource.AbstractDataSource.getLoginTimeout",
	"Comment": "returns 0, indicating the default system timeout is to be used.",
	"Method": "int getLoginTimeout(){\r\n    return 0;\r\n}"
}, {
	"Path": "sx.blah.discord.util.audio.AudioPlayer.setLoop",
	"Comment": "sets whether the player should loop its queue. this is disabled by default.",
	"Method": "void setLoop(boolean loop){\r\n    if (this.loop != loop) {\r\n        this.loop = loop;\r\n        client.getDispatcher().dispatch(new LoopStateChangeEvent(this, loop));\r\n    }\r\n}"
}, {
	"Path": "no.priv.garshol.duke.genetic.GeneticAlgorithm.setGenerations",
	"Comment": "sets the number of generations to run the algorithm for. default100.",
	"Method": "void setGenerations(int generations){\r\n    this.generations = generations;\r\n}"
}, {
	"Path": "com.yahoo.elide.utils.ClassScanner.getAnnotatedClasses",
	"Comment": "scans all classes accessible from the context class loader which belong to the given package and subpackages.",
	"Method": "List<Class<?>> getAnnotatedClasses(Package pckg,Class<? extends Annotation> annotation){\r\n    final AnnotationAcceptingListener annotationAcceptingListener = new AnnotationAcceptingListener(annotation);\r\n    try (final PackageNamesScanner scanner = new PackageNamesScanner(new String[] { pckg.getName() }, true)) {\r\n        while (scanner.hasNext()) {\r\n            final String next = scanner.next();\r\n            if (annotationAcceptingListener.accept(next)) {\r\n                try (final InputStream in = scanner.open()) {\r\n                    annotationAcceptingListener.process(next, in);\r\n                } catch (IOException e) {\r\n                    throw new RuntimeException(\"AnnotationAcceptingListener failed to process scanned resource: \" + next);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return annotationAcceptingListener.getAnnotatedClasses().stream().collect(Collectors.toCollection(ArrayList::new));\r\n}"
}, {
	"Path": "com.yahoo.elide.core.pagination.Pagination.fromOffsetAndFirst",
	"Comment": "given an offset and first parameter from graphql, generate page and pagesize values.",
	"Method": "Optional<Pagination> fromOffsetAndFirst(Optional<String> firstOpt,Optional<String> offsetOpt,boolean generatePageTotals,ElideSettings elideSettings){\r\n    return firstOpt.map(firstString -> {\r\n        int offset;\r\n        int first;\r\n        try {\r\n            offset = offsetOpt.map(Integer::parseInt).orElse(0);\r\n            first = Integer.parseInt(firstString);\r\n        } catch (NumberFormatException e) {\r\n            throw new InvalidValueException(\"Offset and first must be numeric values.\");\r\n        }\r\n        if (offset < 0) {\r\n            throw new InvalidValueException(\"Offset values must be non-negative.\");\r\n        } else if (first < 1) {\r\n            throw new InvalidValueException(\"Limit values must be positive.\");\r\n        }\r\n        ImmutableMap.Builder<PaginationKey, Integer> pageData = ImmutableMap.<PaginationKey, Integer>builder().put(PAGE_KEYS.get(PAGE_OFFSET_KEY), offset).put(PAGE_KEYS.get(PAGE_LIMIT_KEY), first);\r\n        if (generatePageTotals) {\r\n            pageData.put(PAGE_KEYS.get(PAGE_TOTALS_KEY), 1);\r\n        }\r\n        return Optional.of(getPagination(pageData.build(), elideSettings));\r\n    }).orElseGet(() -> {\r\n        if (generatePageTotals) {\r\n            Pagination pagination = getDefaultPagination(elideSettings);\r\n            pagination.pageData.put(PAGE_KEYS.get(PAGE_TOTALS_KEY), 1);\r\n            return Optional.of(pagination);\r\n        }\r\n        return Optional.empty();\r\n    });\r\n}"
}, {
	"Path": "org.dom4j.io.STAXEventWriter.setConsumer",
	"Comment": "sets the underlying event consumer to which events are written.",
	"Method": "void setConsumer(XMLEventConsumer consumer){\r\n    this.consumer = consumer;\r\n}"
}, {
	"Path": "com.dslplatform.json.DslJson.deserializeList",
	"Comment": "convenient deserialize list api for working with bytes.\tdeserialize provided byte input into target object.\tsince json is often though of as a series of char,\tmost libraries will convert inputs into a sequence of chars and do processing on them.\tdsljson will treat input as a sequence of bytes which allows for various optimizations.",
	"Method": "ArrayList<Object> deserializeList(JsonReader reader,List<TResult> deserializeList,Class<TResult> manifest,byte[] body,int size,List<TResult> deserializeList,Class<TResult> manifest,InputStream stream,byte[] buffer,List<TResult> deserializeList,Class<TResult> manifest,InputStream stream,List<TResult> deserializeList,Class<TResult> manifest,JsonReader<TContext> json,InputStream stream){\r\n    if (json.getNextToken() != '[') {\r\n        if (json.wasNull()) {\r\n            return null;\r\n        }\r\n        throw json.expecting(\"[\");\r\n    }\r\n    if (json.getNextToken() == ']') {\r\n        return new ArrayList<TResult>(0);\r\n    }\r\n    if (JsonObject.class.isAssignableFrom(manifest)) {\r\n        final JsonReader.ReadJsonObject<JsonObject> reader = getObjectReader(manifest);\r\n        if (reader != null) {\r\n            return (List<TResult>) json.deserializeNullableCollection(reader);\r\n        }\r\n    }\r\n    final JsonReader.ReadObject simpleReader = tryFindReader(manifest);\r\n    if (simpleReader != null) {\r\n        return json.deserializeNullableCollection(simpleReader);\r\n    }\r\n    if (fallback != null) {\r\n        final Object array = Array.newInstance(manifest, 0);\r\n        final TResult[] result = (TResult[]) fallback.deserialize(context, array.getClass(), new RereadStream(json.buffer, stream));\r\n        if (result == null) {\r\n            return null;\r\n        }\r\n        final ArrayList<TResult> list = new ArrayList<TResult>(result.length);\r\n        for (TResult aResult : result) {\r\n            list.add(aResult);\r\n        }\r\n        return list;\r\n    }\r\n    throw createErrorMessage(manifest);\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.support.JdbcBeanDefinitionReader.setJdbcTemplate",
	"Comment": "set the jdbctemplate to be used by this bean factory.\tcontains settings for datasource, sqlexceptiontranslator, nativejdbcextractor, etc.",
	"Method": "void setJdbcTemplate(JdbcTemplate jdbcTemplate){\r\n    Assert.notNull(jdbcTemplate, \"JdbcTemplate must not be null\");\r\n    this.jdbcTemplate = jdbcTemplate;\r\n}"
}, {
	"Path": "sx.blah.discord.util.MessageBuilder.withQuote",
	"Comment": "sets the content to a multiline code block with no language highlighting.",
	"Method": "MessageBuilder withQuote(String content){\r\n    return withCode(\"\", content);\r\n}"
}, {
	"Path": "org.dom4j.samples.applets.SimpleAppletDemo.start",
	"Comment": "called after init. demonstrates the simplicity of parsing in applets.",
	"Method": "void start(){\r\n    try {\r\n        demoDocument = DocumentHelper.parseText(DEMO_XML);\r\n        new XMLWriter(OutputFormat.createPrettyPrint()).write(demoDocument);\r\n    } catch (DocumentException documentEx) {\r\n        documentEx.printStackTrace();\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n    }\r\n    demoXPath();\r\n    repaint();\r\n}"
}, {
	"Path": "org.dom4j.io.STAXEventReader.setDocumentFactory",
	"Comment": "sets the documentfactory to be used when constructing dom4j nodes.",
	"Method": "void setDocumentFactory(DocumentFactory documentFactory){\r\n    if (documentFactory != null) {\r\n        this.factory = documentFactory;\r\n    } else {\r\n        this.factory = DocumentFactory.getInstance();\r\n    }\r\n}"
}, {
	"Path": "no.priv.garshol.duke.AbstractCmdlineTool.init",
	"Comment": "these exact lines are shared between three different tools, sothey have been moved here to reduce code duplication.",
	"Method": "String[] init(String[] argv,int min,int max,Collection<CommandLineParser.Option> options){\r\n    parser = new CommandLineParser();\r\n    parser.setMinimumArguments(min);\r\n    parser.setMaximumArguments(max);\r\n    parser.registerOption(new CommandLineParser.BooleanOption(\"reindex\", 'I'));\r\n    if (options != null)\r\n        for (CommandLineParser.Option option : options) parser.registerOption(option);\r\n    try {\r\n        argv = parser.parse(argv);\r\n    } catch (CommandLineParser.CommandLineParserException e) {\r\n        System.err.println(\"ERROR: \" + e.getMessage());\r\n        usage();\r\n        System.exit(1);\r\n    }\r\n    boolean reindex = parser.getOptionState(\"reindex\");\r\n    config = ConfigLoader.load(argv[0]);\r\n    database = config.getDatabase(reindex);\r\n    if (database.isInMemory())\r\n        reindex = true;\r\n    if (reindex)\r\n        reindex(config, database);\r\n    return argv;\r\n}"
}, {
	"Path": "org.dom4j.io.DOMSAXContentHandler.setMergeAdjacentText",
	"Comment": "sets whether or not adjacent text nodes should be merged together whenparsing.",
	"Method": "void setMergeAdjacentText(boolean mergeAdjacentText){\r\n    this.mergeAdjacentText = mergeAdjacentText;\r\n}"
}, {
	"Path": "com.yahoo.elide.graphql.GraphQLConversionUtils.classToQueryObject",
	"Comment": "converts a non elide object into a graphql query object.any attribute which cannot be converted is skipped.",
	"Method": "GraphQLObjectType classToQueryObject(Class<?> clazz,DataFetcher fetcher){\r\n    log.info(\"Building query object for type: {}\", clazz.getName());\r\n    if (!nonEntityDictionary.hasBinding(clazz)) {\r\n        nonEntityDictionary.bindEntity(clazz);\r\n    }\r\n    if (outputConversions.containsKey(clazz)) {\r\n        return outputConversions.get(clazz);\r\n    }\r\n    GraphQLObjectType.Builder objectBuilder = newObject();\r\n    objectBuilder.name(toValidNameName(clazz.getName()));\r\n    for (String attribute : nonEntityDictionary.getAttributes(clazz)) {\r\n        Class<?> attributeClass = nonEntityDictionary.getType(clazz, attribute);\r\n        GraphQLFieldDefinition.Builder fieldBuilder = newFieldDefinition().name(attribute).dataFetcher(fetcher);\r\n        GraphQLOutputType attributeType = attributeToQueryObject(clazz, attributeClass, attribute, fetcher, nonEntityDictionary);\r\n        if (attributeType == null) {\r\n            continue;\r\n        }\r\n        fieldBuilder.type(attributeType);\r\n        objectBuilder.field(fieldBuilder);\r\n    }\r\n    GraphQLObjectType object = objectBuilder.build();\r\n    outputConversions.put(clazz, object);\r\n    return object;\r\n}"
}, {
	"Path": "sx.blah.discord.util.MessageTokenizer.nextWord",
	"Comment": "gets the next word in the content and moves the pointer forward.",
	"Method": "Token nextWord(){\r\n    if (!hasNextWord())\r\n        throw new IllegalStateException(\"No more words found!\");\r\n    {\r\n        Matcher matcher = WORD_PATTERN.matcher(remaining);\r\n        if (matcher.find()) {\r\n            if (matcher.start() == 0) {\r\n                stepTo(currentPosition + matcher.end());\r\n            }\r\n        }\r\n    }\r\n    Matcher matcher = WORD_PATTERN.matcher(remaining);\r\n    final int end;\r\n    boolean found = true;\r\n    if (!matcher.find()) {\r\n        end = content.length();\r\n        found = false;\r\n    } else {\r\n        end = currentPosition + matcher.start();\r\n    }\r\n    Token token = new Token(this, currentPosition, end);\r\n    stepTo(found ? (currentPosition + matcher.end()) : content.length());\r\n    return token;\r\n}"
}, {
	"Path": "org.eclipse.jdt.ls.core.internal.corext.refactoring.RefactoringSearchEngine2.setOwner",
	"Comment": "sets the working copy owner to use during search.\tthis method must be called before start searching. the default is to use no working copy owner.",
	"Method": "void setOwner(WorkingCopyOwner owner){\r\n    fOwner = owner;\r\n}"
}, {
	"Path": "org.dom4j.DocumentFactory.createXPath",
	"Comment": "createxpath parses an xpath expression and creates a newxpath xpath instance.",
	"Method": "XPath createXPath(String xpathExpression,XPath createXPath,String xpathExpression,VariableContext variableContext){\r\n    XPath xpath = createXPath(xpathExpression);\r\n    xpath.setVariableContext(variableContext);\r\n    return xpath;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.databases.LuceneDatabase.setFuzzySearch",
	"Comment": "controls whether to use fuzzy searches for properties that havefuzzy comparators. true by default.",
	"Method": "void setFuzzySearch(boolean fuzzy_search){\r\n    this.fuzzy_search = fuzzy_search;\r\n}"
}, {
	"Path": "org.springframework.jdbc.core.metadata.GenericCallMetaDataProvider.setSupportsCatalogsInProcedureCalls",
	"Comment": "specify whether the database supports the use of catalog name in procedure calls",
	"Method": "void setSupportsCatalogsInProcedureCalls(boolean supportsCatalogsInProcedureCalls){\r\n    this.supportsCatalogsInProcedureCalls = supportsCatalogsInProcedureCalls;\r\n}"
}, {
	"Path": "no.priv.garshol.duke.genetic.GeneticAlgorithm.setCopiesOfOriginal",
	"Comment": "sets how many copies of the original configuration to keep in thefirst generation. the default is 0, meaning the first generationwill be entirely random, but with this option you can make thegenetic algorithm start from your existing configuration.",
	"Method": "void setCopiesOfOriginal(int copies){\r\n    population.setCopiesOfOriginal(copies);\r\n}"
}]