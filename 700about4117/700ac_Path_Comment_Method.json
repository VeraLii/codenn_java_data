[{
	"Path": "com.google.firebase.storage.FirebaseStorage.setMaxDownloadRetryTimeMillis",
	"Comment": "sets the maximum time to retry a download if a failure occurs.",
	"Method": "void setMaxDownloadRetryTimeMillis(long maxTransferRetryMillis){\r\n    sMaxDownloadRetry = maxTransferRetryMillis;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.SourceLocation.getEndTokenPos",
	"Comment": "the last token of the location if this is a range.can return null.",
	"Method": "int getEndTokenPos(){\r\n    return json.get(\"endTokenPos\") == null ? -1 : json.get(\"endTokenPos\").getAsInt();\r\n}"
}, {
	"Path": "com.google.firebase.database.core.RandomViewProcessorTest.randomOperations",
	"Comment": "activate the test if you want to do some more soul searching...",
	"Method": "void randomOperations(){\r\n    for (int i = 0; i < NUM_TESTS; i++) {\r\n        RandomOperationGenerator generator = new RandomOperationGenerator();\r\n        QueryParams params = generator.nextRandomParams();\r\n        generator.listen(new QuerySpec(Path.getEmptyPath(), params));\r\n        System.out.println(\"Test \" + i);\r\n        System.out.println(\"==========\");\r\n        System.out.println(\"Running with seed \" + generator.getSeed());\r\n        System.out.println(\"Query params: \" + params);\r\n        ViewProcessor processor = new ViewProcessor(params.getNodeFilter());\r\n        CacheNode emptyCacheNode = new CacheNode(IndexedNode.from(EmptyNode.Empty(), params.getIndex()), false, false);\r\n        Node currentChangeNode = EmptyNode.Empty();\r\n        Node currentValueNode = null;\r\n        ViewCache viewCache = new ViewCache(emptyCacheNode, emptyCacheNode);\r\n        for (int j = 0; j < OPERATIONS_PER_TEST; j++) {\r\n            Operation op = generator.nextOperation();\r\n            System.out.println(j + \": Applying \" + op);\r\n            WriteTreeRef writeTreeRef = new WriteTreeRef(Path.getEmptyPath(), generator.getWriteTree());\r\n            ViewProcessor.ProcessorResult result = processor.applyOperation(viewCache, op, writeTreeRef, null);\r\n            viewCache = result.viewCache;\r\n            for (Change change : result.changes) {\r\n                if (change.getEventType() == Event.EventType.VALUE) {\r\n                    currentValueNode = change.getIndexedNode().getNode();\r\n                } else {\r\n                    currentChangeNode = applyChange(currentChangeNode, change);\r\n                }\r\n            }\r\n            CacheNode expectedSnap = generator.getExpectedClientState(params);\r\n            Node expectedNodeWithoutPriorities = expectedSnap.getNode().updatePriority(PriorityUtilities.NullPriority());\r\n            CacheNode actualSnap = viewCache.getEventCache();\r\n            Assert.assertTrue(\"Event snap should be indexed\", viewCache.getEventCache().getIndexedNode().hasIndex(params.getIndex()));\r\n            if (expectedSnap.getNode().isLeafNode()) {\r\n                assertNodesMatch(\"Cache event snap did not equal expected event snap\", expectedSnap.getNode(), actualSnap.getNode(), false);\r\n                assertNodesMatch(\"Value event snap did not match expected event snap\", expectedSnap.getNode(), currentValueNode, false);\r\n                Assert.assertTrue(\"Change node did not remove all children for leaf node\", currentChangeNode.isEmpty());\r\n            } else {\r\n                assertNodesMatch(\"Cache event snap did not equal expected event snap\", expectedSnap.getNode(), actualSnap.getNode(), false);\r\n                assertNodesMatch(\"Applying changes caused a diverge from the expected snap\", expectedNodeWithoutPriorities, currentChangeNode, false);\r\n                if (expectedSnap.isFullyInitialized()) {\r\n                    assertNodesMatch(\"Value event snap did not match expected snap\", expectedSnap.getNode(), currentValueNode, false);\r\n                } else {\r\n                    Assert.assertNull(\"We shouldn't have gotten a value node yet!\", currentValueNode);\r\n                }\r\n                Assert.assertEquals(expectedSnap.isFullyInitialized(), actualSnap.isFullyInitialized());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.ObjectSet.shrink",
	"Comment": "reduces the size of the backing arrays to be the specified capacity or less. if the capacity is already less, nothing isdone. if the set contains more items than the specified capacity, the next highest power of two capacity is used instead.",
	"Method": "void shrink(int maximumCapacity){\r\n    if (maximumCapacity < 0)\r\n        throw new IllegalArgumentException(\"maximumCapacity must be >= 0: \" + maximumCapacity);\r\n    if (size > maximumCapacity)\r\n        maximumCapacity = size;\r\n    if (capacity <= maximumCapacity)\r\n        return;\r\n    maximumCapacity = FXGLMath.nextPowerOfTwo(maximumCapacity);\r\n    resize(maximumCapacity);\r\n}"
}, {
	"Path": "io.flutter.FlutterUtils.isFlutterPlugin",
	"Comment": "returns true if the passed pubspec indicates that it is a flutter plugin.",
	"Method": "boolean isFlutterPlugin(VirtualFile pubspec){\r\n    try {\r\n        final String contents = new String(pubspec.contentsToByteArray(true));\r\n        final Map<String, Object> yaml = loadPubspecInfo(contents);\r\n        if (yaml == null) {\r\n            return false;\r\n        }\r\n        final Object flutterEntry = yaml.get(\"flutter\");\r\n        if (flutterEntry instanceof Map) {\r\n            return ((Map) flutterEntry).containsKey(\"plugin\");\r\n        }\r\n        return false;\r\n    } catch (IOException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.Array.newArray",
	"Comment": "creates a new array with the specified component type and length.",
	"Method": "Object newArray(Class c,int size){\r\n    return java.lang.reflect.Array.newInstance(c, size);\r\n}"
}, {
	"Path": "com.almasb.fxgl.extra.entity.components.RechargeableComponent.damagePercentageMax",
	"Comment": "damage component by given percentage. the percentage is calculated frommax value.",
	"Method": "void damagePercentageMax(double value){\r\n    damage(value / 100 * maxValue);\r\n}"
}, {
	"Path": "com.google.firebase.database.core.CompoundWrite.isEmpty",
	"Comment": "returns true if this compoundwrite is empty and therefore does not modify any nodes.",
	"Method": "boolean isEmpty(){\r\n    return this.writeTree.isEmpty();\r\n}"
}, {
	"Path": "com.google.firebase.database.FirebaseDatabase.getApp",
	"Comment": "returns the firebaseapp instance to which this firebasedatabase belongs.",
	"Method": "FirebaseApp getApp(){\r\n    return this.app;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.TargetState.isPending",
	"Comment": "whether this target has pending target adds or target removes.",
	"Method": "boolean isPending(){\r\n    return outstandingResponses != 0;\r\n}"
}, {
	"Path": "org.fluentlenium.core.filter.FilterBuilder.containsWord",
	"Comment": "builds a filter that match when selection contains a given word.",
	"Method": "AttributeFilter containsWord(String word){\r\n    return new AttributeFilter(attribute, new ContainsWordMatcher(word));\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.QuickSelect.medianOfThreePivot",
	"Comment": "median of three has the potential to outperform a random pivot, especially for partially sorted arrays",
	"Method": "int medianOfThreePivot(int leftIdx,int rightIdx){\r\n    T left = array[leftIdx];\r\n    int midIdx = (leftIdx + rightIdx) / 2;\r\n    T mid = array[midIdx];\r\n    T right = array[rightIdx];\r\n    if (comp.compare(left, mid) > 0) {\r\n        if (comp.compare(mid, right) > 0) {\r\n            return midIdx;\r\n        } else if (comp.compare(left, right) > 0) {\r\n            return rightIdx;\r\n        } else {\r\n            return leftIdx;\r\n        }\r\n    } else {\r\n        if (comp.compare(left, right) > 0) {\r\n            return leftIdx;\r\n        } else if (comp.compare(mid, right) > 0) {\r\n            return rightIdx;\r\n        } else {\r\n            return midIdx;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.dartlang.analysis.server.protocol.FlutterOutlineAttribute.getLiteralValueBoolean",
	"Comment": "the boolean literal value of the attribute. this field is absent if the value is not a booleanliteral.",
	"Method": "Boolean getLiteralValueBoolean(){\r\n    return literalValueBoolean;\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.beforeNavigateTo",
	"Comment": "add a listener that will be invoked before navigating to an url.",
	"Method": "EventsRegistry beforeNavigateTo(NavigateToListener listener){\r\n    beforeNavigateTo.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteSerializer.decodeResourceName",
	"Comment": "decodes a fully qualified resource name into a resource path and validates that there is aproject and database encoded in the path. there are no guarantees that a local path is alsoencoded in this resource name.",
	"Method": "ResourcePath decodeResourceName(String encoded){\r\n    ResourcePath resource = ResourcePath.fromString(encoded);\r\n    Assert.hardAssert(isValidResourceName(resource), \"Tried to deserialize invalid key %s\", resource);\r\n    return resource;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.ExponentialBackoff.backoffAndRun",
	"Comment": "waits for currentdelayms, increases the delay and runs the specified task. if there was apending backoff task waiting to run already, it will be canceled.",
	"Method": "void backoffAndRun(Runnable task){\r\n    cancel();\r\n    long desiredDelayWithJitterMs = currentBaseMs + jitterDelayMs();\r\n    long delaySoFarMs = Math.max(0, new Date().getTime() - lastAttemptTime);\r\n    long remainingDelayMs = Math.max(0, desiredDelayWithJitterMs - delaySoFarMs);\r\n    if (currentBaseMs > 0) {\r\n        Logger.debug(getClass().getSimpleName(), \"Backing off for %d ms (\" + \"base delay: %d ms, \" + \"delay with jitter: %d ms, \" + \"last attempt: %d ms ago)\", remainingDelayMs, currentBaseMs, desiredDelayWithJitterMs, delaySoFarMs);\r\n    }\r\n    timerTask = queue.enqueueAfterDelay(this.timerId, remainingDelayMs, () -> {\r\n        lastAttemptTime = new Date().getTime();\r\n        task.run();\r\n    });\r\n    currentBaseMs = (long) (currentBaseMs * backoffFactor);\r\n    if (currentBaseMs < initialDelayMs) {\r\n        currentBaseMs = initialDelayMs;\r\n    } else if (currentBaseMs > maxDelayMs) {\r\n        currentBaseMs = maxDelayMs;\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.QueryDocumentSnapshot.getData",
	"Comment": "returns the fields of the document as a map. field values will be converted to their nativejava representation.",
	"Method": "Map<String, Object> getData(Map<String, Object> getData,ServerTimestampBehavior serverTimestampBehavior){\r\n    checkNotNull(serverTimestampBehavior, \"Provided serverTimestampBehavior value must not be null.\");\r\n    Map<String, Object> result = super.getData(serverTimestampBehavior);\r\n    Assert.hardAssert(result != null, \"Data in a QueryDocumentSnapshot should be non-null\");\r\n    return result;\r\n}"
}, {
	"Path": "org.springframework.web.servlet.tags.BindErrorsTag.getErrors",
	"Comment": "retrieve the errors instance that this tag is currently bound to.intended for cooperating nesting tags.",
	"Method": "Errors getErrors(){\r\n    return null;\r\n}"
}, {
	"Path": "com.google.firebase.storage.StorageTask.addOnSuccessListener",
	"Comment": "adds a listener that is called if the task completes successfully.if multiple listeners are added, they will be called in the order in which they were added.if the task has already completed successfully, a call to the listener will be immediatelyscheduled.",
	"Method": "StorageTask<TResult> addOnSuccessListener(OnSuccessListener<? super TResult> listener,StorageTask<TResult> addOnSuccessListener,Executor executor,OnSuccessListener<? super TResult> listener,StorageTask<TResult> addOnSuccessListener,Activity activity,OnSuccessListener<? super TResult> listener){\r\n    Preconditions.checkNotNull(activity);\r\n    Preconditions.checkNotNull(listener);\r\n    successManager.addListener(activity, null, listener);\r\n    return this;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.VmServiceBase.localConnect",
	"Comment": "connect to the vm observatory service on the given local port.",
	"Method": "VmService localConnect(int port){\r\n    return connect(\"ws://localhost:\" + port + \"/ws\");\r\n}"
}, {
	"Path": "com.almasb.fxgl.app.AppStateMachine.setState",
	"Comment": "can only be called when no substates are present.can only be called by internal fxgl api.",
	"Method": "void setState(AppState newState){\r\n    if (!subStates.isEmpty()) {\r\n        log.warning(\"Cannot change states with active substates\");\r\n        return;\r\n    }\r\n    AppState prevState = appState;\r\n    prevState.exit();\r\n    for (StateChangeListener listener : listeners) listener.beforeExit(prevState);\r\n    for (StateChangeListener listener : listeners) listener.beforeEnter(newState);\r\n    appState = newState;\r\n    log.debug(prevState + \" -> \" + newState);\r\n    for (StateChangeListener listener : listeners) listener.exited(prevState);\r\n    for (StateChangeListener listener : listeners) listener.entered(newState);\r\n    appState.enter(prevState);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.SyncEngine.transaction",
	"Comment": "takes an updatefunction in which a set of reads and writes can be performed atomically. in theupdatefunction, the client can read and write values using the supplied transaction object.after the updatefunction, all changes will be committed. if some other client has changed anyof the data referenced, then the updatefunction will be called again. if the updatefunctionstill fails after the given number of retries, then the transaction will be rejected.the transaction object passed to the updatefunction contains methods for accessing documentsand collections. unlike other datastore access, data accessed with the transaction will notreflect local changes that have not been committed. for this reason, it is required that allreads are performed before any writes. transactions must be performed while online.the task returned is resolved when the transaction is fully committed.",
	"Method": "Task<TResult> transaction(AsyncQueue asyncQueue,Function<Transaction, Task<TResult>> updateFunction,int retries){\r\n    hardAssert(retries >= 0, \"Got negative number of retries for transaction.\");\r\n    final Transaction transaction = remoteStore.createTransaction();\r\n    return updateFunction.apply(transaction).continueWithTask(asyncQueue.getExecutor(), userTask -> {\r\n        if (!userTask.isSuccessful()) {\r\n            return userTask;\r\n        }\r\n        return transaction.commit().continueWithTask(asyncQueue.getExecutor(), commitTask -> {\r\n            if (commitTask.isSuccessful()) {\r\n                return Tasks.forResult(userTask.getResult());\r\n            }\r\n            if (retries == 0) {\r\n                Exception e = new FirebaseFirestoreException(\"Transaction failed all retries.\", Code.ABORTED, commitTask.getException());\r\n                return Tasks.forException(e);\r\n            }\r\n            return transaction(asyncQueue, updateFunction, retries - 1);\r\n        });\r\n    });\r\n}"
}, {
	"Path": "com.google.firebase.storage.StorageTask.cancel",
	"Comment": "attempts to cancel the task. a canceled task cannot be resumed later.",
	"Method": "boolean cancel(){\r\n    return tryChangeState(new int[] { INTERNAL_STATE_CANCELED, INTERNAL_STATE_CANCELING }, true);\r\n}"
}, {
	"Path": "org.fluentlenium.core.wait.FluentWaitPageConditions.isLoaded",
	"Comment": "check if the current browser page is loaded.requires javascript to be enabled. throw an unsupportedoperationexception if not.",
	"Method": "boolean isLoaded(){\r\n    if (webDriver instanceof JavascriptExecutor) {\r\n        Predicate<FluentControl> isLoaded = fluent -> {\r\n            Object result = fluent.executeScript(\"if (document.readyState) return document.readyState;\").getStringResult();\r\n            return result != null && \"complete\".equals(result);\r\n        };\r\n        until(wait, isLoaded, String.format(\"Page %s should be loaded.\", webDriver.getCurrentUrl()));\r\n    } else {\r\n        throw new UnsupportedOperationException(\"Driver must support javascript execution to use this feature\");\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.google.firebase.storage.network.NetworkRequest.getResultBody",
	"Comment": "returns the resulting body in jsonobject form, if it could be parsed.",
	"Method": "JSONObject getResultBody(){\r\n    JSONObject resultBody;\r\n    if (!TextUtils.isEmpty(rawStringResponse)) {\r\n        try {\r\n            resultBody = new JSONObject(rawStringResponse);\r\n        } catch (JSONException e) {\r\n            Log.e(TAG, \"error parsing result into JSON:\" + rawStringResponse, e);\r\n            resultBody = new JSONObject();\r\n        }\r\n    } else {\r\n        resultBody = new JSONObject();\r\n    }\r\n    return resultBody;\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.Array.setSize",
	"Comment": "sets the array size, leaving any values beyond the current size null.",
	"Method": "T[] setSize(int newSize,T[] setSize,int newSize){\r\n    truncate(newSize);\r\n    if (newSize > items.length)\r\n        resize(Math.max(8, newSize));\r\n    size = newSize;\r\n    return items;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.ValidationTest.verifyFieldPathThrows",
	"Comment": "tests a field path with all of our apis that accept field paths and ensures they fail with thespecified reason.",
	"Method": "void verifyFieldPathThrows(String path,String reason){\r\n    DocumentReference docRef = testDocument();\r\n    waitFor(docRef.set(map(\"test\", 1)));\r\n    DocumentSnapshot snapshot = waitFor(docRef.get());\r\n    expectError(() -> snapshot.get(path), reason);\r\n    CollectionReference coll = testCollection();\r\n    expectError(() -> coll.whereEqualTo(path, 1), reason);\r\n    expectError(() -> coll.orderBy(path), reason);\r\n    expectError(() -> docRef.update(path, 1), reason);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.World.createBody",
	"Comment": "create a rigid body given a definition.no reference to the definition is retained.this function is locked during callbacks.",
	"Method": "Body createBody(BodyDef def){\r\n    assertNotLocked();\r\n    Body b = new Body(def, this);\r\n    bodies.add(b);\r\n    return b;\r\n}"
}, {
	"Path": "io.flutter.pub.PubRoot.isFlutterPlugin",
	"Comment": "returns true if the pubspec indicates that it is a flutter plugin.",
	"Method": "boolean isFlutterPlugin(){\r\n    return FlutterUtils.isFlutterPlugin(pubspec);\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.math.FXGLMath.lerpAngle",
	"Comment": "linearly interpolates between two angles in radians.takes into account that angles wrap at two pi and always takes thedirection with the smallest delta angle.",
	"Method": "double lerpAngle(double fromRadians,double toRadians,double progress){\r\n    double delta = ((toRadians - fromRadians + PI2 + PI) % PI2) - PI;\r\n    return (fromRadians + delta * progress + PI2) % PI2;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.View.computeDocChanges",
	"Comment": "iterates over a set of doc changes, applies the query limit, and computes what the new resultsshould be, what the changes were, and whether we may need to go back to the local cache formore results. does not make any changes to the view.",
	"Method": "DocumentChanges computeDocChanges(ImmutableSortedMap<DocumentKey, D> docChanges,DocumentChanges computeDocChanges,ImmutableSortedMap<DocumentKey, D> docChanges,DocumentChanges previousChanges){\r\n    DocumentViewChangeSet changeSet = previousChanges != null ? previousChanges.changeSet : new DocumentViewChangeSet();\r\n    DocumentSet oldDocumentSet = previousChanges != null ? previousChanges.documentSet : documentSet;\r\n    ImmutableSortedSet<DocumentKey> newMutatedKeys = previousChanges != null ? previousChanges.mutatedKeys : mutatedKeys;\r\n    DocumentSet newDocumentSet = oldDocumentSet;\r\n    boolean needsRefill = false;\r\n    Document lastDocInLimit = (query.hasLimit() && oldDocumentSet.size() == query.getLimit()) ? oldDocumentSet.getLastDocument() : null;\r\n    for (Map.Entry<DocumentKey, ? extends MaybeDocument> entry : docChanges) {\r\n        DocumentKey key = entry.getKey();\r\n        Document oldDoc = oldDocumentSet.getDocument(key);\r\n        Document newDoc = null;\r\n        MaybeDocument maybeDoc = entry.getValue();\r\n        if (maybeDoc instanceof Document) {\r\n            newDoc = (Document) maybeDoc;\r\n        }\r\n        if (newDoc != null) {\r\n            hardAssert(key.equals(newDoc.getKey()), \"Mismatching key in doc change %s != %s\", key, newDoc.getKey());\r\n            if (!query.matches(newDoc)) {\r\n                newDoc = null;\r\n            }\r\n        }\r\n        boolean oldDocHadPendingMutations = oldDoc != null && this.mutatedKeys.contains(oldDoc.getKey());\r\n        boolean newDocHasPendingMutations = newDoc != null && (newDoc.hasLocalMutations() || (this.mutatedKeys.contains(newDoc.getKey()) && newDoc.hasCommittedMutations()));\r\n        boolean changeApplied = false;\r\n        if (oldDoc != null && newDoc != null) {\r\n            boolean docsEqual = oldDoc.getData().equals(newDoc.getData());\r\n            if (!docsEqual) {\r\n                if (!shouldWaitForSyncedDocument(oldDoc, newDoc)) {\r\n                    changeSet.addChange(DocumentViewChange.create(Type.MODIFIED, newDoc));\r\n                    changeApplied = true;\r\n                    if (lastDocInLimit != null && query.comparator().compare(newDoc, lastDocInLimit) > 0) {\r\n                        needsRefill = true;\r\n                    }\r\n                }\r\n            } else if (oldDocHadPendingMutations != newDocHasPendingMutations) {\r\n                changeSet.addChange(DocumentViewChange.create(Type.METADATA, newDoc));\r\n                changeApplied = true;\r\n            }\r\n        } else if (oldDoc == null && newDoc != null) {\r\n            changeSet.addChange(DocumentViewChange.create(Type.ADDED, newDoc));\r\n            changeApplied = true;\r\n        } else if (oldDoc != null && newDoc == null) {\r\n            changeSet.addChange(DocumentViewChange.create(Type.REMOVED, oldDoc));\r\n            changeApplied = true;\r\n            if (lastDocInLimit != null) {\r\n                needsRefill = true;\r\n            }\r\n        }\r\n        if (changeApplied) {\r\n            if (newDoc != null) {\r\n                newDocumentSet = newDocumentSet.add(newDoc);\r\n                if (newDoc.hasLocalMutations()) {\r\n                    newMutatedKeys = newMutatedKeys.insert(newDoc.getKey());\r\n                } else {\r\n                    newMutatedKeys = newMutatedKeys.remove(newDoc.getKey());\r\n                }\r\n            } else {\r\n                newDocumentSet = newDocumentSet.remove(key);\r\n                newMutatedKeys = newMutatedKeys.remove(key);\r\n            }\r\n        }\r\n    }\r\n    if (query.hasLimit()) {\r\n        for (long i = newDocumentSet.size() - this.query.getLimit(); i > 0; --i) {\r\n            Document oldDoc = newDocumentSet.getLastDocument();\r\n            newDocumentSet = newDocumentSet.remove(oldDoc.getKey());\r\n            newMutatedKeys = newMutatedKeys.remove(oldDoc.getKey());\r\n            changeSet.addChange(DocumentViewChange.create(Type.REMOVED, oldDoc));\r\n        }\r\n    }\r\n    hardAssert(!needsRefill || previousChanges == null, \"View was refilled using docs that themselves needed refilling.\");\r\n    return new DocumentChanges(newDocumentSet, changeSet, newMutatedKeys, needsRefill);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.TargetIdGenerator.forSyncEngine",
	"Comment": "creates and returns the targetidgenerator for the sync engine.",
	"Method": "TargetIdGenerator forSyncEngine(){\r\n    return new TargetIdGenerator(SYNC_ENGINE_ID, 1);\r\n}"
}, {
	"Path": "io.flutter.run.daemon.DeviceSelection.withDevices",
	"Comment": "returns a new snapshot with the devices changed and the selection updated appropriately.",
	"Method": "DeviceSelection withDevices(List<FlutterDevice> newDevices){\r\n    final String selectedId = selection == null ? null : selection.deviceId();\r\n    final Optional<FlutterDevice> selectedDevice = findById(newDevices, selectedId);\r\n    final FlutterDevice selectionOrDefault = selectedDevice.orElse(newDevices.size() > 0 ? newDevices.get(0) : null);\r\n    return new DeviceSelection(ImmutableList.copyOf(newDevices), selectionOrDefault);\r\n}"
}, {
	"Path": "org.fluentlenium.core.filter.FilterBuilder.contains",
	"Comment": "builds a filter that match when selection contains to a given pattern.",
	"Method": "AttributeFilter contains(String value,AttributeFilter contains,Pattern pattern){\r\n    return new AttributeFilter(attribute, new ContainsMatcher(pattern));\r\n}"
}, {
	"Path": "com.baidu.unbiz.fluentvalidator.util.Preconditions.checkNotNull",
	"Comment": "ensures that an object reference passed as a parameter to the calling method is not null.",
	"Method": "T checkNotNull(T reference,T checkNotNull,T reference,Object errorMessage,T checkNotNull,T reference,String errorMessageTemplate,Object errorMessageArgs){\r\n    if (reference == null) {\r\n        throw new NullPointerException(format(errorMessageTemplate, errorMessageArgs));\r\n    }\r\n    return reference;\r\n}"
}, {
	"Path": "com.google.cloud.datastore.core.number.IndexNumberDecoder.isResultLong",
	"Comment": "returns whether the decoded number is representable as a long.",
	"Method": "boolean isResultLong(){\r\n    updateResultLongState();\r\n    return longResultRepProblemMessage.isEmpty();\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.BoundVariable.getScopeStartTokenPos",
	"Comment": "the first token position where this variable is visible to the scope.",
	"Method": "int getScopeStartTokenPos(){\r\n    return json.get(\"scopeStartTokenPos\") == null ? -1 : json.get(\"scopeStartTokenPos\").getAsInt();\r\n}"
}, {
	"Path": "org.inferred.freebuilder.processor.util.testing.TypeMirrors.checkArgReferences",
	"Comment": "checks that all %d references in the given type snippet are within bounds.",
	"Method": "void checkArgReferences(String typeSnippet,int numberOfArgs){\r\n    Matcher argRefMatcher = ARG_REF_PATTERN.matcher(typeSnippet);\r\n    while (argRefMatcher.find()) {\r\n        int index = Integer.parseInt(argRefMatcher.group(1), 10) - 1;\r\n        Preconditions.checkArgument(index >= 0, \"%s not allowed, indices start at 1\", argRefMatcher.group(0));\r\n        Preconditions.checkArgument(index < numberOfArgs, \"%s too large for number of provided type mirrors\", argRefMatcher.group(0));\r\n    }\r\n}"
}, {
	"Path": "com.example.firebase.fiamui.ScreenShotter.getScreenshotFileName",
	"Comment": "construct a screenshot file name from the specified screenshot name",
	"Method": "String getScreenshotFileName(String screenshotName){\r\n    for (StackTraceElement element : Thread.currentThread().getStackTrace()) {\r\n        String elementClassName = element.getClassName();\r\n        String elementMethodName = element.getMethodName();\r\n        if (elementMethodName.startsWith(\"test\") || isJUnit4Test(elementClassName, elementMethodName)) {\r\n            if (!elementClassName.equals(lastClassName) || !elementMethodName.equals(lastMethodName)) {\r\n                counter = new AtomicInteger(0);\r\n            }\r\n            lastClassName = elementClassName;\r\n            lastMethodName = elementMethodName;\r\n            String filename = elementClassName + FILE_NAME_DELIMITER + elementMethodName + FILE_NAME_DELIMITER + screenshotName + FILE_NAME_DELIMITER + counter.incrementAndGet();\r\n            return filename;\r\n        }\r\n    }\r\n    lastClassName = \"\";\r\n    lastMethodName = \"\";\r\n    return \"UnknownTestClass\" + FILE_NAME_DELIMITER + \"unknownTestMethod\" + FILE_NAME_DELIMITER + screenshotName + FILE_NAME_DELIMITER + counter.incrementAndGet();\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Body.setAwake",
	"Comment": "set the sleep state of the body.a sleeping body has very low cpu cost.",
	"Method": "void setAwake(boolean flag){\r\n    if (flag) {\r\n        if ((m_flags & e_awakeFlag) == 0) {\r\n            m_flags |= e_awakeFlag;\r\n            sleepTime = 0.0f;\r\n        }\r\n    } else {\r\n        m_flags &= ~e_awakeFlag;\r\n        sleepTime = 0.0f;\r\n        m_linearVelocity.setZero();\r\n        m_angularVelocity = 0.0f;\r\n        m_force.setZero();\r\n        m_torque = 0.0f;\r\n    }\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.UnresolvedSourceLocation.getScript",
	"Comment": "the script containing the source location if the script has been loaded.can return null.",
	"Method": "ScriptRef getScript(){\r\n    return json.get(\"script\") == null ? null : new ScriptRef((JsonObject) json.get(\"script\"));\r\n}"
}, {
	"Path": "org.fluentlenium.utils.ReflectionUtils.newInstanceOptionalArgs",
	"Comment": "creates a new instance by trying every possible constructors with provided args.",
	"Method": "T newInstanceOptionalArgs(Class<T> cls,Object args,T newInstanceOptionalArgs,int mandatoryCount,Class<T> cls,Object args){\r\n    while (true) {\r\n        try {\r\n            return newInstance(cls, args);\r\n        } catch (NoSuchMethodException e) {\r\n            if (args.length == mandatoryCount) {\r\n                break;\r\n            }\r\n            args = Arrays.copyOf(args, args.length - 1);\r\n        }\r\n    }\r\n    throw new NoSuchMethodException(\"Can't find any valid constructor.\");\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.World.destroyJoint",
	"Comment": "destroy a joint. this may cause the connected bodies to begin colliding.this function is locked during callbacks.",
	"Method": "void destroyJoint(Joint j){\r\n    assertNotLocked();\r\n    boolean collideConnected = j.getCollideConnected();\r\n    if (j.m_prev != null) {\r\n        j.m_prev.m_next = j.m_next;\r\n    }\r\n    if (j.m_next != null) {\r\n        j.m_next.m_prev = j.m_prev;\r\n    }\r\n    if (j == m_jointList) {\r\n        m_jointList = j.m_next;\r\n    }\r\n    Body bodyA = j.getBodyA();\r\n    Body bodyB = j.getBodyB();\r\n    bodyA.setAwake(true);\r\n    bodyB.setAwake(true);\r\n    if (j.m_edgeA.prev != null) {\r\n        j.m_edgeA.prev.next = j.m_edgeA.next;\r\n    }\r\n    if (j.m_edgeA.next != null) {\r\n        j.m_edgeA.next.prev = j.m_edgeA.prev;\r\n    }\r\n    if (j.m_edgeA == bodyA.m_jointList) {\r\n        bodyA.m_jointList = j.m_edgeA.next;\r\n    }\r\n    j.m_edgeA.prev = null;\r\n    j.m_edgeA.next = null;\r\n    if (j.m_edgeB.prev != null) {\r\n        j.m_edgeB.prev.next = j.m_edgeB.next;\r\n    }\r\n    if (j.m_edgeB.next != null) {\r\n        j.m_edgeB.next.prev = j.m_edgeB.prev;\r\n    }\r\n    if (j.m_edgeB == bodyB.m_jointList) {\r\n        bodyB.m_jointList = j.m_edgeB.next;\r\n    }\r\n    j.m_edgeB.prev = null;\r\n    j.m_edgeB.next = null;\r\n    Joint.destroy(j);\r\n    assert (jointCount > 0);\r\n    --jointCount;\r\n    if (!collideConnected) {\r\n        ContactEdge edge = bodyB.getContactList();\r\n        while (edge != null) {\r\n            if (edge.other == bodyA) {\r\n                edge.contact.flagForFiltering();\r\n            }\r\n            edge = edge.next;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.cloud.datastore.core.number.NumberParts.significand",
	"Comment": "the value of the significand in the floating point encoding, left justified, with a hiddenleading one bit.",
	"Method": "long significand(){\r\n    return significand;\r\n}"
}, {
	"Path": "org.fluentlenium.utils.ReflectionUtils.newInstance",
	"Comment": "creates a new instance matching possible constructors with provided args.",
	"Method": "T newInstance(Class<T> cls,Object args){\r\n    Constructor<T> declaredConstructor = args.length == 0 ? getConstructor(cls) : getConstructor(cls, args);\r\n    boolean accessible = declaredConstructor.isAccessible();\r\n    if (accessible) {\r\n        return declaredConstructor.newInstance(args);\r\n    } else {\r\n        declaredConstructor.setAccessible(true);\r\n        try {\r\n            return declaredConstructor.newInstance(args);\r\n        } finally {\r\n            declaredConstructor.setAccessible(accessible);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.database.core.WriteTreeRef.calcCompleteEventCache",
	"Comment": "if possible, returns a complete event cache, using the underlying server data if possible. inaddition, can be used to get a cache that includes hidden writes, and excludes arbitrarywrites. note that customizing the returned node can lead to a more expensive calculation.",
	"Method": "Node calcCompleteEventCache(Node completeServerCache,Node calcCompleteEventCache,Node completeServerCache,List<Long> writeIdsToExclude,Node calcCompleteEventCache,Node completeServerCache,List<Long> writeIdsToExclude,boolean includeHiddenWrites){\r\n    return this.writeTree.calcCompleteEventCache(this.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);\r\n}"
}, {
	"Path": "com.google.firebase.database.core.RepoManager.getRepo",
	"Comment": "used for legacy unit tests. the public api should go through firebasedatabase which callscreaterepo.",
	"Method": "Repo getRepo(Context ctx,RepoInfo info){\r\n    return instance.getLocalRepo(ctx, info);\r\n}"
}, {
	"Path": "com.google.firebase.inappmessaging.display.internal.FiamWindowManager.getDisplaySize",
	"Comment": "get the total size of the display in pixels, with no exclusions. for example on a pixel thiswould return 1920x1080 rather than the content frame which gives up 63 pixels to the status barand 126 pixels to the navigation bar.",
	"Method": "Point getDisplaySize(Activity activity){\r\n    Point size = new Point();\r\n    Display display = getWindowManager(activity).getDefaultDisplay();\r\n    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1) {\r\n        display.getRealSize(size);\r\n    } else {\r\n        display.getSize(size);\r\n    }\r\n    return size;\r\n}"
}, {
	"Path": "org.inferred.freebuilder.processor.util.ParameterizedType.typeParametersOrDiamondOperator",
	"Comment": "returns a source excerpt of the type parameters of this type, including angle brackets, unlessthe diamond operator is available, in which case only the angle brackets will be emitted.",
	"Method": "Excerpt typeParametersOrDiamondOperator(){\r\n    return isParameterized() ? diamondOperator(Excerpts.join(\", \", typeParameters)) : Excerpts.empty();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.ServerTimestampTest.verifyTimestampsAreResolved",
	"Comment": "verifies a snapshot containing setdata but with resolved server timestamps.",
	"Method": "void verifyTimestampsAreResolved(DocumentSnapshot snapshot){\r\n    assertTrue(snapshot.exists());\r\n    Timestamp when = snapshot.getTimestamp(\"when\");\r\n    assertNotNull(when);\r\n    int deltaSec = 48 * 60 * 60;\r\n    Timestamp now = Timestamp.now();\r\n    assertTrue(\"resolved timestamp (\" + when + \") should be within \" + deltaSec + \"s of now (\" + now + \")\", Math.abs(when.getSeconds() - now.getSeconds()) < deltaSec);\r\n    assertEquals(expectedDataWithTimestamp(when), snapshot.getData());\r\n}"
}, {
	"Path": "com.google.firebase.firestore.QuerySnapshot.getDocuments",
	"Comment": "returns the documents in this querysnapshot as a list in order of the query.",
	"Method": "List<DocumentSnapshot> getDocuments(){\r\n    List<DocumentSnapshot> res = new ArrayList(snapshot.getDocuments().size());\r\n    for (com.google.firebase.firestore.model.Document doc : snapshot.getDocuments()) {\r\n        res.add(convertDocument(doc));\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "org.fluentlenium.core.filter.MatcherConstructor.notEndsWith",
	"Comment": "create a matcher filtering by a string that not ends with the pattern params",
	"Method": "AbstractMatcher notEndsWith(String matcher,AbstractMatcher notEndsWith,Pattern pattern){\r\n    return new NotEndsWithMatcher(pattern);\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.beforeAlertAccept",
	"Comment": "add a listener that will be invoked before an alert is accepted.",
	"Method": "EventsRegistry beforeAlertAccept(AlertListener listener){\r\n    beforeAlertAccept.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.afterAlertDismiss",
	"Comment": "add a listener that will be invoked after an alert is dismissed.",
	"Method": "EventsRegistry afterAlertDismiss(AlertListener listener){\r\n    afterAlertDismiss.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.vladmihalcea.flexypool.strategy.IncrementPoolOnTimeoutConnectionAcquiringStrategy.incrementPoolSize",
	"Comment": "attempt to increment the pool size. if the maxsize changes, it skips the incrementing process.",
	"Method": "boolean incrementPoolSize(int expectingMaxSize){\r\n    Integer maxSize = null;\r\n    long currentOverflowPoolSize;\r\n    try {\r\n        lock.lockInterruptibly();\r\n        int currentMaxSize = poolAdapter.getMaxPoolSize();\r\n        boolean incrementMaxPoolSize = currentMaxSize < maxOverflowPoolSize;\r\n        if (currentMaxSize > expectingMaxSize) {\r\n            LOGGER.info(\"Pool size changed by other thread, expected {} and actual value {}\", expectingMaxSize, currentMaxSize);\r\n            return incrementMaxPoolSize;\r\n        }\r\n        if (!incrementMaxPoolSize) {\r\n            return false;\r\n        }\r\n        currentOverflowPoolSize = overflowPoolSize.incrementAndGet();\r\n        poolAdapter.setMaxPoolSize(++currentMaxSize);\r\n        maxSize = currentMaxSize;\r\n    } catch (InterruptedException e) {\r\n        Thread.currentThread().interrupt();\r\n        return false;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n    LOGGER.info(\"Pool size changed from previous value {} to {}\", expectingMaxSize, maxSize);\r\n    maxPoolSizeHistogram.update(maxSize);\r\n    overflowPoolSizeHistogram.update(currentOverflowPoolSize);\r\n    return true;\r\n}"
}, {
	"Path": "com.google.firebase.database.core.persistence.PersistenceTest.deepUpdateTest",
	"Comment": "this tests that a persisted deep update will be properly applied by the server.",
	"Method": "void deepUpdateTest(){\r\n    PersistenceManager manager = newTestPersistenceManager();\r\n    DatabaseConfig cfg1 = newFrozenTestConfig();\r\n    DatabaseReference ref1 = refWithConfig(cfg1, manager).push();\r\n    goOffline(cfg1);\r\n    Map<String, Object> updates = new HashMap<String, Object>();\r\n    updates.put(\"foo/deep/update\", \"bar\");\r\n    ref1.updateChildren(updates);\r\n    waitForQueue(ref1);\r\n    DatabaseConfig cfg2 = newFrozenTestConfig();\r\n    DatabaseReference ref2 = refWithConfig(cfg2, manager);\r\n    ref2 = ref2.child(ref1.getKey());\r\n    Object value = new ReadFuture(ref2).waitForLastValue();\r\n    assertEquals(value, fromSingleQuotedString(\"{ 'foo': { 'deep': { 'update': 'bar' } } }\"));\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Isolate.getStartTime",
	"Comment": "the time that the vm started in milliseconds since the epoch.suitable to pass to datetime.frommillisecondssinceepoch.",
	"Method": "int getStartTime(){\r\n    return json.get(\"startTime\") == null ? -1 : json.get(\"startTime\").getAsInt();\r\n}"
}, {
	"Path": "com.vladmihalcea.flexypool.util.LazyJndiResolver.invoke",
	"Comment": "resolves the jndi object upon invoking any method on the associated proxy",
	"Method": "Object invoke(Object proxy,Method method,Object[] args){\r\n    if (target == null) {\r\n        target = JndiUtils.lookup(name);\r\n    }\r\n    return method.invoke(target, args);\r\n}"
}, {
	"Path": "com.google.firebase.database.core.WriteTreeRef.calcCompleteChild",
	"Comment": "returns a complete child for a given server snap after applying all user writes or null ifthere is no complete child for this childkey.",
	"Method": "Node calcCompleteChild(ChildKey childKey,CacheNode existingServerCache){\r\n    return this.writeTree.calcCompleteChild(this.treePath, childKey, existingServerCache);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.DocumentReference.collection",
	"Comment": "gets a collectionreference instance that refers to the subcollection at the specified pathrelative to this document.",
	"Method": "CollectionReference collection(String collectionPath){\r\n    checkNotNull(collectionPath, \"Provided collection path must not be null.\");\r\n    return new CollectionReference(key.getPath().append(ResourcePath.fromString(collectionPath)), firestore);\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.IntMap.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding manyitems to avoid multiple backing array resizes.",
	"Method": "void ensureCapacity(int additionalCapacity){\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded >= threshold)\r\n        resize(FXGLMath.nextPowerOfTwo((int) Math.ceil(sizeNeeded / loadFactor)));\r\n}"
}, {
	"Path": "org.inferred.freebuilder.processor.util.testing.SourceBuilder.getTypeNameFromSource",
	"Comment": "parses the given source code and returns the name of the type it defines.",
	"Method": "String getTypeNameFromSource(CharSequence source){\r\n    Matcher packageMatcher = SourceBuilder.PACKAGE_PATTERN.matcher(source);\r\n    Matcher typeNameMatcher = SourceBuilder.TYPE_NAME_PATTERN.matcher(source);\r\n    checkArgument(packageMatcher.find(), \"Source contains no package definition\");\r\n    checkArgument(typeNameMatcher.find(), \"Source contains no type definition\");\r\n    String typeName = packageMatcher.group(1) + \".\" + typeNameMatcher.group(2);\r\n    typeName = typeName.replaceAll(\"\\\\s+\", \"\");\r\n    return typeName;\r\n}"
}, {
	"Path": "com.google.firebase.database.core.persistence.DefaultPersistenceManager.serverCache",
	"Comment": "returns any cached node or children as a cachenode. the query isused to filter the nodebut rather to determine if it can be considered complete.",
	"Method": "CacheNode serverCache(QuerySpec query){\r\n    Set<ChildKey> trackedKeys;\r\n    boolean complete;\r\n    if (this.trackedQueryManager.isQueryComplete(query)) {\r\n        complete = true;\r\n        TrackedQuery trackedQuery = this.trackedQueryManager.findTrackedQuery(query);\r\n        if (!query.loadsAllData() && trackedQuery != null && trackedQuery.complete) {\r\n            trackedKeys = this.storageLayer.loadTrackedQueryKeys(trackedQuery.id);\r\n        } else {\r\n            trackedKeys = null;\r\n        }\r\n    } else {\r\n        complete = false;\r\n        trackedKeys = trackedQueryManager.getKnownCompleteChildren(query.getPath());\r\n    }\r\n    Node serverCacheNode = storageLayer.serverCache(query.getPath());\r\n    if (trackedKeys != null) {\r\n        Node filteredNode = EmptyNode.Empty();\r\n        for (ChildKey key : trackedKeys) {\r\n            filteredNode = filteredNode.updateImmediateChild(key, serverCacheNode.getImmediateChild(key));\r\n        }\r\n        return new CacheNode(IndexedNode.from(filteredNode, query.getIndex()), complete, true);\r\n    } else {\r\n        return new CacheNode(IndexedNode.from(serverCacheNode, query.getIndex()), complete, false);\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.Datastore.createWriteStream",
	"Comment": "creates a new writestream that is still unstarted but uses a common shared channel",
	"Method": "WriteStream createWriteStream(WriteStream.Callback listener){\r\n    return new WriteStream(channel, workerQueue, serializer, listener);\r\n}"
}, {
	"Path": "io.flutter.inspector.DiagnosticsNode.getEmptyBodyDescription",
	"Comment": "description to show if the node has no displayed properties or children.",
	"Method": "String getEmptyBodyDescription(){\r\n    return getStringMember(\"emptyBodyDescription\");\r\n}"
}, {
	"Path": "com.google.cloud.datastore.core.number.NumberParts.representableAsDouble",
	"Comment": "returns whether or not this numberparts can be represented as a double without loss ofprecision.",
	"Method": "boolean representableAsDouble(){\r\n    return doubleRepresentationError() == null;\r\n}"
}, {
	"Path": "com.google.firebase.database.Query.limitToFirst",
	"Comment": "create a query with limit and anchor it to the start of the window",
	"Method": "Query limitToFirst(int limit){\r\n    if (limit <= 0) {\r\n        throw new IllegalArgumentException(\"Limit must be a positive integer!\");\r\n    }\r\n    if (params.hasLimit()) {\r\n        throw new IllegalArgumentException(\"Can't call limitToLast on query with previously set limit!\");\r\n    }\r\n    return new Query(repo, path, params.limitToFirst(limit), orderByCalled);\r\n}"
}, {
	"Path": "com.almasb.fxgl.ai.btree.Task.cancel",
	"Comment": "terminates this task and all its running children.this method must be called only if this task is running.",
	"Method": "void cancel(){\r\n    cancelRunningChildren(0);\r\n    Status previousStatus = status;\r\n    status = Status.CANCELLED;\r\n    if (tree.listeners != null && tree.listeners.size() > 0)\r\n        tree.notifyStatusUpdated(this, previousStatus);\r\n    end();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteStore.raiseWatchSnapshot",
	"Comment": "takes a batch of changes from the datastore, repackages them as a remoteevent, and passes thaton to the listener, which is typically the syncengine.",
	"Method": "void raiseWatchSnapshot(SnapshotVersion snapshotVersion){\r\n    hardAssert(!snapshotVersion.equals(SnapshotVersion.NONE), \"Can't raise event for unknown SnapshotVersion\");\r\n    RemoteEvent remoteEvent = watchChangeAggregator.createRemoteEvent(snapshotVersion);\r\n    for (Entry<Integer, TargetChange> entry : remoteEvent.getTargetChanges().entrySet()) {\r\n        TargetChange targetChange = entry.getValue();\r\n        if (!targetChange.getResumeToken().isEmpty()) {\r\n            int targetId = entry.getKey();\r\n            QueryData queryData = this.listenTargets.get(targetId);\r\n            if (queryData != null) {\r\n                this.listenTargets.put(targetId, queryData.copy(snapshotVersion, targetChange.getResumeToken(), queryData.getSequenceNumber()));\r\n            }\r\n        }\r\n    }\r\n    for (int targetId : remoteEvent.getTargetMismatches()) {\r\n        QueryData queryData = this.listenTargets.get(targetId);\r\n        if (queryData != null) {\r\n            this.listenTargets.put(targetId, queryData.copy(queryData.getSnapshotVersion(), ByteString.EMPTY, queryData.getSequenceNumber()));\r\n            this.sendUnwatchRequest(targetId);\r\n            QueryData requestQueryData = new QueryData(queryData.getQuery(), targetId, queryData.getSequenceNumber(), QueryPurpose.EXISTENCE_FILTER_MISMATCH);\r\n            this.sendWatchRequest(requestQueryData);\r\n        }\r\n    }\r\n    remoteStoreCallback.handleRemoteEvent(remoteEvent);\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Breakpoint.getLocation",
	"Comment": "sourcelocation when breakpoint is resolved, unresolvedsourcelocation when a breakpoint is notresolved.",
	"Method": "Object getLocation(){\r\n    JsonObject elem = (JsonObject) json.get(\"location\");\r\n    if (elem == null)\r\n        return null;\r\n    if (elem.get(\"type\").getAsString().equals(\"SourceLocation\"))\r\n        return new SourceLocation(elem);\r\n    if (elem.get(\"type\").getAsString().equals(\"UnresolvedSourceLocation\"))\r\n        return new UnresolvedSourceLocation(elem);\r\n    return null;\r\n}"
}, {
	"Path": "com.almasb.fxgl.particle.ParticleEmitter.emit",
	"Comment": "emits a single particle with index i.x and y are coordinates of the particle entity this emitter is attached to.",
	"Method": "Array<Particle> emit(double x,double y,Particle emit,int i,double x,double y){\r\n    Particle particle = Pools.obtain(Particle.class);\r\n    particle.init(getControl(), sourceImage, spawnPointFunction.apply(i).add(x, y), velocityFunction.apply(i), accelerationFunction.get(), getRandomSize(), scaleFunction.apply(i), expireFunction.apply(i), getStartColor(), getEndColor(), getBlendMode(), getInterpolator(), isAllowParticleRotation(), getParametricEquation());\r\n    return particle;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.Query.orderBy",
	"Comment": "creates a new query with an additional ordering constraint.",
	"Method": "Query orderBy(OrderBy order){\r\n    if (DocumentKey.isDocumentKey(path)) {\r\n        throw Assert.fail(\"No ordering is allowed for document query\");\r\n    }\r\n    if (explicitSortOrder.isEmpty()) {\r\n        FieldPath inequality = inequalityField();\r\n        if (inequality != null && !inequality.equals(order.field)) {\r\n            throw Assert.fail(\"First orderBy must match inequality field\");\r\n        }\r\n    }\r\n    List<OrderBy> updatedSortOrder = new ArrayList(explicitSortOrder);\r\n    updatedSortOrder.add(order);\r\n    return new Query(path, filters, updatedSortOrder, limit, startAt, endAt);\r\n}"
}, {
	"Path": "io.flutter.inspector.InspectorTree.immediateScrollRectToVisible",
	"Comment": "escape hatch for cases where need to immediately scroll a rectangle tovisible instead of performing an animated transition.",
	"Method": "void immediateScrollRectToVisible(Rectangle rect){\r\n    super.scrollRectToVisible(rect);\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.reflect.ClassReflection.newInstance",
	"Comment": "creates a new instance of the class represented by the supplied class.",
	"Method": "T newInstance(Class<T> c){\r\n    try {\r\n        return c.newInstance();\r\n    } catch (InstantiationException e) {\r\n        throw new ReflectionException(\"Could not instantiate instance of class: \" + c.getName(), e);\r\n    } catch (IllegalAccessException e) {\r\n        throw new ReflectionException(\"Could not instantiate instance of class: \" + c.getName(), e);\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.World.getContactList",
	"Comment": "get the world contact list. with the returned contact, use contact.getnext to get the nextcontact in the world list. a null contact indicates the end of the list.contacts are created and destroyed in the middle of a time step.use contactlistener to avoid missing contacts.",
	"Method": "Contact getContactList(){\r\n    return contactManager.contactList;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteStore.handleWriteStreamMutationResults",
	"Comment": "handles a successful streamingwriteresponse from the server that contains a mutation result.",
	"Method": "void handleWriteStreamMutationResults(SnapshotVersion commitVersion,List<MutationResult> results){\r\n    MutationBatch batch = writePipeline.poll();\r\n    MutationBatchResult mutationBatchResult = MutationBatchResult.create(batch, commitVersion, results, writeStream.getLastStreamToken());\r\n    remoteStoreCallback.handleSuccessfulWrite(mutationBatchResult);\r\n    fillWritePipeline();\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.IsolateRef.getId",
	"Comment": "the id which is passed to the getisolate rpc to load this isolate.",
	"Method": "String getId(){\r\n    return json.get(\"id\").getAsString();\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.IntArray.setSize",
	"Comment": "sets the array size, leaving any values beyond the current size undefined.",
	"Method": "int[] setSize(int newSize){\r\n    if (newSize > items.length)\r\n        resize(Math.max(8, newSize));\r\n    size = newSize;\r\n    return items;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.PhysicsComponent.setBodyDef",
	"Comment": "set custom body definition to describe a generatedbody for this physics entity.",
	"Method": "void setBodyDef(BodyDef def){\r\n    bodyDef = def;\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.TimSort.gallopRight",
	"Comment": "like gallopleft, except that if the range contains an element equal to key, gallopright returns the index after therightmost equal element.",
	"Method": "int gallopRight(T key,T[] a,int base,int len,int hint,Comparator<? super T> c){\r\n    if (DEBUG)\r\n        assert len > 0 && hint >= 0 && hint < len;\r\n    int ofs = 1;\r\n    int lastOfs = 0;\r\n    if (c.compare(key, a[base + hint]) < 0) {\r\n        int maxOfs = hint + 1;\r\n        while (ofs < maxOfs && c.compare(key, a[base + hint - ofs]) < 0) {\r\n            lastOfs = ofs;\r\n            ofs = (ofs << 1) + 1;\r\n            if (ofs <= 0)\r\n                ofs = maxOfs;\r\n        }\r\n        if (ofs > maxOfs)\r\n            ofs = maxOfs;\r\n        int tmp = lastOfs;\r\n        lastOfs = hint - ofs;\r\n        ofs = hint - tmp;\r\n    } else {\r\n        int maxOfs = len - hint;\r\n        while (ofs < maxOfs && c.compare(key, a[base + hint + ofs]) >= 0) {\r\n            lastOfs = ofs;\r\n            ofs = (ofs << 1) + 1;\r\n            if (ofs <= 0)\r\n                ofs = maxOfs;\r\n        }\r\n        if (ofs > maxOfs)\r\n            ofs = maxOfs;\r\n        lastOfs += hint;\r\n        ofs += hint;\r\n    }\r\n    if (DEBUG)\r\n        assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;\r\n    lastOfs++;\r\n    while (lastOfs < ofs) {\r\n        int m = lastOfs + ((ofs - lastOfs) >>> 1);\r\n        if (c.compare(key, a[base + m]) < 0)\r\n            ofs = m;\r\n        else\r\n            lastOfs = m + 1;\r\n    }\r\n    if (DEBUG)\r\n        assert lastOfs == ofs;\r\n    return ofs;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.World.setParticleGravityScale",
	"Comment": "change the particle gravity scale. adjusts the effect of the global gravity vector onparticles. default value is 1.0f.",
	"Method": "void setParticleGravityScale(float gravityScale){\r\n    particleSystem.setParticleGravityScale(gravityScale);\r\n}"
}, {
	"Path": "org.fluentlenium.core.proxy.LocatorProxies.last",
	"Comment": "creates a proxy element matching the last element of the list.",
	"Method": "WebElement last(List<WebElement> proxy){\r\n    LocatorHandler locatorHandler = getLocatorHandler(proxy);\r\n    return createWebElement(new LastElementLocator(locatorHandler.getLocator()));\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Fixture.getUserData",
	"Comment": "the same as in the fixture definition, unless explicitly changed.use this to store your application specific data.",
	"Method": "Object getUserData(){\r\n    return userData;\r\n}"
}, {
	"Path": "io.flutter.run.MainFile.getAppDir",
	"Comment": "returns the closest ancestor directory containing a pubspec.yaml, build, or .packages file.",
	"Method": "VirtualFile getAppDir(){\r\n    return appDir;\r\n}"
}, {
	"Path": "io.flutter.perf.PerfTip.getConfidence",
	"Comment": "confidence between zero and 1 that the rule should be applied.",
	"Method": "double getConfidence(){\r\n    return confidence;\r\n}"
}, {
	"Path": "com.google.firebase.auth.FirebaseAuthException.getErrorCode",
	"Comment": "returns an error code that may provide more information about the error.",
	"Method": "String getErrorCode(){\r\n    return errorCode;\r\n}"
}, {
	"Path": "io.flutter.run.daemon.DeviceService.addListener",
	"Comment": "adds a callback for any changes to the status, device list, or selection.",
	"Method": "void addListener(Runnable callback){\r\n    listeners.updateAndGet((old) -> {\r\n        final List<Runnable> changed = new ArrayList(old);\r\n        changed.add(callback);\r\n        return ImmutableSet.copyOf(changed);\r\n    });\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.value.ObjectValue.value",
	"Comment": "recursively converts the map into the value that users will see in document snapshots.",
	"Method": "Map<String, Object> value(Map<String, Object> value,FieldValueOptions options){\r\n    Map<String, Object> res = new HashMap();\r\n    for (Map.Entry<String, FieldValue> entry : internalValue) {\r\n        res.put(entry.getKey(), entry.getValue().value(options));\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Transaction.getAsync",
	"Comment": "reads the document referenced by the provided documentreference",
	"Method": "Task<DocumentSnapshot> getAsync(DocumentReference documentRef){\r\n    return transaction.lookup(Collections.singletonList(documentRef.getKey())).continueWith(Executors.DIRECT_EXECUTOR, task -> {\r\n        if (!task.isSuccessful()) {\r\n            throw task.getException();\r\n        }\r\n        List<MaybeDocument> docs = task.getResult();\r\n        if (docs.size() != 1) {\r\n            throw fail(\"Mismatch in docs returned from document lookup.\");\r\n        }\r\n        MaybeDocument doc = docs.get(0);\r\n        if (doc instanceof Document) {\r\n            return DocumentSnapshot.fromDocument(firestore, (Document) doc, false, false);\r\n        } else if (doc instanceof NoDocument) {\r\n            return DocumentSnapshot.fromNoDocument(firestore, doc.getKey(), false, false);\r\n        } else {\r\n            throw fail(\"BatchGetDocumentsRequest returned unexpected document type: \" + doc.getClass().getCanonicalName());\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.BoundVariable.getScopeEndTokenPos",
	"Comment": "the last token position where this variable is visible to the scope.",
	"Method": "int getScopeEndTokenPos(){\r\n    return json.get(\"scopeEndTokenPos\") == null ? -1 : json.get(\"scopeEndTokenPos\").getAsInt();\r\n}"
}, {
	"Path": "com.vladsch.flexmark.docx.converter.util.DocxHelper.getExplicitRPr",
	"Comment": "only gets character style properties and basedon style treedoes not use doc defaults or ppr properties.use this for rpr cleaning",
	"Method": "RPr getExplicitRPr(RPrAbstract rPr,PPr pPr,RPr getExplicitRPr,RPr rPr){\r\n    RPr styledRPr = myFactory.createRPr();\r\n    ArrayList<Style> styles = new ArrayList<Style>();\r\n    final RStyle pStyle = rPr.getRStyle();\r\n    if (pStyle != null) {\r\n        String styleId = pStyle.getVal();\r\n        Style style = getStyle(styleId);\r\n        while (style != null) {\r\n            styles.add(style);\r\n            Style.BasedOn basedOn = style.getBasedOn();\r\n            style = null;\r\n            if (basedOn != null) {\r\n                styleId = basedOn.getVal();\r\n                if (styleId != null) {\r\n                    style = getStyle(basedOn.getVal());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    int iMax = styles.size();\r\n    for (int i = iMax; i-- > 0; ) {\r\n        Style style = styles.get(i);\r\n        StyleUtil.apply(style.getRPr(), styledRPr);\r\n    }\r\n    StyleUtil.apply(rPr, styledRPr);\r\n    return styledRPr;\r\n}"
}, {
	"Path": "com.google.firebase.database.InternalHelpers.createDatabaseForTests",
	"Comment": "so repo can create firebasedatabase objects to keep legacy tests working.",
	"Method": "FirebaseDatabase createDatabaseForTests(FirebaseApp app,RepoInfo repoInfo,DatabaseConfig config){\r\n    return FirebaseDatabase.createForTests(app, repoInfo, config);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.QueryData.copy",
	"Comment": "creates a new query data instance with an updated snapshot version and resume token.",
	"Method": "QueryData copy(SnapshotVersion snapshotVersion,ByteString resumeToken,long sequenceNumber){\r\n    return new QueryData(query, targetId, sequenceNumber, purpose, snapshotVersion, resumeToken);\r\n}"
}, {
	"Path": "io.flutter.run.PositionMapper.onLibrariesDownloaded",
	"Comment": "just after connecting, the debugger downloads the list of dart libraries from observatory and reports it here.",
	"Method": "void onLibrariesDownloaded(Iterable<LibraryRef> libraries){\r\n    for (LibraryRef library : libraries) {\r\n        final String remoteUri = library.getUri();\r\n        if (remoteUri.startsWith(DartUrlResolver.DART_PREFIX))\r\n            continue;\r\n        if (remoteUri.startsWith(DartUrlResolver.PACKAGE_PREFIX))\r\n            continue;\r\n        remoteSourceRoot = findRemoteSourceRoot(remoteUri);\r\n        if (remoteSourceRoot != null)\r\n            return;\r\n    }\r\n}"
}, {
	"Path": "com.vladsch.flexmark.internal.InlineParserImpl.spnlUrl",
	"Comment": "parse zero or more space characters, including at one newline.",
	"Method": "boolean spnlUrl(){\r\n    return match(myParsing.SPNL_URL) != null;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact.mixRestitution",
	"Comment": "restitution mixing law.the idea is allow for anything to bounce off an inelastic surface.for example, a superball bounces on anything.",
	"Method": "float mixRestitution(float restitution1,float restitution2){\r\n    return restitution1 > restitution2 ? restitution1 : restitution2;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LocalSerializer.encodeMutationBatch",
	"Comment": "encodes a mutationbatch model for local storage in the mutation queue.",
	"Method": "com.google.firebase.firestore.proto.WriteBatch encodeMutationBatch(MutationBatch batch){\r\n    com.google.firebase.firestore.proto.WriteBatch.Builder result = com.google.firebase.firestore.proto.WriteBatch.newBuilder();\r\n    result.setBatchId(batch.getBatchId());\r\n    result.setLocalWriteTime(rpcSerializer.encodeTimestamp(batch.getLocalWriteTime()));\r\n    for (Mutation mutation : batch.getMutations()) {\r\n        result.addWrites(rpcSerializer.encodeMutation(mutation));\r\n    }\r\n    return result.build();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.DocumentSnapshot.getBoolean",
	"Comment": "returns the value of the field as a boolean. if the value is not a boolean this will throw aruntime exception.",
	"Method": "Boolean getBoolean(String field){\r\n    return getTypedValue(field, Boolean.class);\r\n}"
}, {
	"Path": "com.vladsch.flexmark.parser.block.AbstractBlockParser.isPropagatingLastBlankLine",
	"Comment": "should be overridden in blockquote, fencedcode and listitem",
	"Method": "boolean isPropagatingLastBlankLine(BlockParser lastMatchedBlockParser){\r\n    return true;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Fixture.containsPoint",
	"Comment": "test a point for containment in this fixture.this only works for convex shapes.",
	"Method": "boolean containsPoint(Vec2 p){\r\n    return shape.testPoint(body.m_xf, p);\r\n}"
}, {
	"Path": "com.google.cloud.datastore.core.number.IndexNumberEncoder.encodeLong",
	"Comment": "writes bytes encoding the long to the buffer at the offset, in the order specified bydescending, and returns the number of bytes written.",
	"Method": "int encodeLong(boolean descending,long value,byte[] buffer,int offset){\r\n    if (value == 0) {\r\n        return encodeZero(buffer, offset);\r\n    }\r\n    boolean negative = descending;\r\n    if (value < 0) {\r\n        negative = !negative;\r\n        value = -value;\r\n    }\r\n    int leadingZeros = Long.numberOfLeadingZeros(value);\r\n    int exponent = SIGNIFICAND_BITS - 1 - leadingZeros;\r\n    long significand = value & ~(1L << exponent);\r\n    significand <<= leadingZeros + 1;\r\n    return encodeNumber(negative, exponent, significand, buffer, offset);\r\n}"
}, {
	"Path": "com.almasb.fxgl.util.Optional.ifPresent",
	"Comment": "if a value is present, invoke the specified consumer with the value,otherwise do nothing.",
	"Method": "void ifPresent(Consumer<? super T> consumer){\r\n    if (value != null)\r\n        consumer.accept(value);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.SQLiteMutationQueue.loadNextBatchIdAcrossAllUsers",
	"Comment": "returns one larger than the largest batch id that has been stored. if there are no mutationsreturns 0. note that batch ids are global.",
	"Method": "void loadNextBatchIdAcrossAllUsers(){\r\n    List<String> uids = new ArrayList();\r\n    db.query(\"SELECT uid FROM mutation_queues\").forEach(row -> uids.add(row.getString(0)));\r\n    nextBatchId = 0;\r\n    for (String uid : uids) {\r\n        db.query(\"SELECT MAX(batch_id) FROM mutations WHERE uid = ?\").binding(uid).forEach(row -> nextBatchId = Math.max(nextBatchId, row.getInt(0)));\r\n    }\r\n    nextBatchId += 1;\r\n}"
}, {
	"Path": "org.fluentlenium.core.filter.matcher.CalculateService.equal",
	"Comment": "check if the current value is equal the patternvalue or the referencevalue",
	"Method": "boolean equal(Pattern patternValue,String referenceValue,String currentValue){\r\n    if (currentValue == null) {\r\n        return false;\r\n    }\r\n    if (patternValue == null) {\r\n        return currentValue.equals(referenceValue);\r\n    }\r\n    return patternValue.matcher(currentValue).matches();\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.graph.GraphBuilder.hasRelationship",
	"Comment": "look at the cache relationship. this method assume relationship were created using the createrelationship method.",
	"Method": "boolean hasRelationship(Node fromNode,Node toNode,RelationshipType rt,String sourceCall){\r\n    Set<String> relationshipCache = graphDb.getRelationshipCache();\r\n    String key = getKey(fromNode, toNode, rt, sourceCall);\r\n    return relationshipCache.contains(key);\r\n}"
}, {
	"Path": "org.fluentlenium.core.proxy.LocatorProxies.getLocatorResult",
	"Comment": "get the underlying result of a proxy, through locator handler.",
	"Method": "T getLocatorResult(T proxy){\r\n    LocatorHandler<?> componentHandler = getLocatorHandler(proxy);\r\n    if (componentHandler != null) {\r\n        return (T) componentHandler.getLocatorResult();\r\n    }\r\n    return proxy;\r\n}"
}, {
	"Path": "io.flutter.dart.DartPlugin.getAnalysisService",
	"Comment": "return the dartanalysisserverservice instance. this handles the older case where the service was appbased, and the newer case where the service is project based.",
	"Method": "DartAnalysisServerService getAnalysisService(Project project){\r\n    return ServiceManager.getService(project, DartAnalysisServerService.class);\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.reflect.Constructor.getDeclaringClass",
	"Comment": "returns the class object representing the class or interface that declares the constructor.",
	"Method": "Class getDeclaringClass(){\r\n    return constructor.getDeclaringClass();\r\n}"
}, {
	"Path": "com.google.firebase.database.collection.ArraySortedMap.findKeyOrInsertPosition",
	"Comment": "this does a linear scan which is simpler than a binary search. for a small collection size thisstill should be as fast a as binary search.",
	"Method": "int findKeyOrInsertPosition(K key){\r\n    int newPos = 0;\r\n    while (newPos < this.keys.length && this.comparator.compare(this.keys[newPos], key) < 0) {\r\n        newPos++;\r\n    }\r\n    return newPos;\r\n}"
}, {
	"Path": "com.bartoszlipinski.flippablestackview.OrientedViewPager.getOffscreenPageLimit",
	"Comment": "returns the number of pages that will be retained to either side of thecurrent page in the view hierarchy in an idle state. defaults to 1.",
	"Method": "int getOffscreenPageLimit(){\r\n    return mOffscreenPageLimit;\r\n}"
}, {
	"Path": "org.inferred.freebuilder.processor.DefaultedPropertiesSourceTest.testJ6_noGuava_oneDefaultProperty",
	"Comment": "test the separators are correctly conditioned in the tostring method for a complex example.",
	"Method": "void testJ6_noGuava_oneDefaultProperty(){\r\n    QualifiedName person = QualifiedName.of(\"com.example\", \"Person\");\r\n    TypeMirror string = newTopLevelClass(\"java.lang.String\");\r\n    QualifiedName generatedBuilder = QualifiedName.of(\"com.example\", \"Person_Builder\");\r\n    Property name = new Property.Builder().setAllCapsName(\"NAME\").setBoxedType(string).setCapitalizedName(\"Name\").setFullyCheckedCast(true).setGetterName(\"getName\").setName(\"name\").setType(string).setUsingBeanConvention(true).build();\r\n    Property age = new Property.Builder().setAllCapsName(\"AGE\").setBoxedType(newTopLevelClass(\"java.lang.Integer\")).setCapitalizedName(\"Age\").setFullyCheckedCast(true).setGetterName(\"getAge\").setName(\"age\").setType(INT).setUsingBeanConvention(true).build();\r\n    Property shoeSize = new Property.Builder().setAllCapsName(\"SHOE_SIZE\").setBoxedType(newTopLevelClass(\"java.lang.Integer\")).setCapitalizedName(\"ShoeSize\").setFullyCheckedCast(true).setGetterName(\"getShoeSize\").setName(\"shoeSize\").setType(INT).setUsingBeanConvention(true).build();\r\n    Metadata metadata = new Metadata.Builder().setBuilder(person.nestedType(\"Builder\").withParameters()).setExtensible(true).setBuilderFactory(BuilderFactory.NO_ARGS_CONSTRUCTOR).setBuilderSerializable(false).setGeneratedBuilder(generatedBuilder.withParameters()).setInterfaceType(false).setPartialType(generatedBuilder.nestedType(\"Partial\").withParameters()).addProperties(name, age, shoeSize).setPropertyEnum(generatedBuilder.nestedType(\"Property\").withParameters()).setType(person.withParameters()).setValueType(generatedBuilder.nestedType(\"Value\").withParameters()).build();\r\n    Metadata metadataWithCodeGenerators = metadata.toBuilder().clearProperties().addProperties(name.toBuilder().setCodeGenerator(new DefaultProperty(metadata, name, false)).build()).addProperties(age.toBuilder().setCodeGenerator(new DefaultProperty(metadata, age, true)).build()).addProperties(shoeSize.toBuilder().setCodeGenerator(new DefaultProperty(metadata, shoeSize, false)).build()).build();\r\n    assertThat(generateSource(metadataWithCodeGenerators)).isEqualTo(Joiner.on('\\n').join(\"/** Auto-generated superclass of {@link Person.Builder}, \" + \"derived from the API of {@link Person}. */\", \"@Generated(\\\"org.inferred.freebuilder.processor.CodeGenerator\\\")\", \"abstract class Person_Builder {\", \"\", \"  /** Creates a new builder using {@code value} as a template. */\", \"  public static Person.Builder from(Person value) {\", \"    return new Person.Builder().mergeFrom(value);\", \"  }\", \"\", \"  private enum Property {\", \"    NAME(\\\"name\\\"),\", \"    SHOE_SIZE(\\\"shoeSize\\\"),\", \"    ;\", \"\", \"    private final String name;\", \"\", \"    private Property(String name) {\", \"      this.name = name;\", \"    }\", \"\", \"    @Override\", \"    public String toString() {\", \"      return name;\", \"    }\", \"  }\", \"\", \"  private String name;\", \"  private int age;\", \"  private int shoeSize;\", \"  private final EnumSet<Person_Builder.Property> _unsetProperties =\", \"      EnumSet.allOf(Person_Builder.Property.class);\", \"\", \"  /**\", \"   * Sets the value to be returned by {@link Person#getName()}.\", \"   *\", \"   * @return this {@code Builder} object\", \"   * @throws NullPointerException if {@code name} is null\", \"   */\", \"  public Person.Builder setName(String name) {\", \"    if (name == null) {\", \"      throw new NullPointerException();\", \"    }\", \"    this.name = name;\", \"    _unsetProperties.remove(Person_Builder.Property.NAME);\", \"    return (Person.Builder) this;\", \"  }\", \"\", \"  /**\", \"   * Returns the value that will be returned by {@link Person#getName()}.\", \"   *\", \"   * @throws IllegalStateException if the field has not been set\", \"   */\", \"  public String getName() {\", \"    if (_unsetProperties.contains(Person_Builder.Property.NAME)) {\", \"      throw new IllegalStateException(\\\"name not set\\\");\", \"    }\", \"    return name;\", \"  }\", \"\", \"  /**\", \"   * Sets the value to be returned by {@link Person#getAge()}.\", \"   *\", \"   * @return this {@code Builder} object\", \"   */\", \"  public Person.Builder setAge(int age) {\", \"    this.age = age;\", \"    return (Person.Builder) this;\", \"  }\", \"\", \"  /** Returns the value that will be returned by {@link Person#getAge()}. */\", \"  public int getAge() {\", \"    return age;\", \"  }\", \"\", \"  /**\", \"   * Sets the value to be returned by {@link Person#getShoeSize()}.\", \"   *\", \"   * @return this {@code Builder} object\", \"   */\", \"  public Person.Builder setShoeSize(int shoeSize) {\", \"    this.shoeSize = shoeSize;\", \"    _unsetProperties.remove(Person_Builder.Property.SHOE_SIZE);\", \"    return (Person.Builder) this;\", \"  }\", \"\", \"  /**\", \"   * Returns the value that will be returned by {@link Person#getShoeSize()}.\", \"   *\", \"   * @throws IllegalStateException if the field has not been set\", \"   */\", \"  public int getShoeSize() {\", \"    if (_unsetProperties.contains(Person_Builder.Property.SHOE_SIZE)) {\", \"      throw new IllegalStateException(\\\"shoeSize not set\\\");\", \"    }\", \"    return shoeSize;\", \"  }\", \"\", \"  /** Sets all property values using the given {@code Person} as a template. */\", \"  public Person.Builder mergeFrom(Person value) {\", \"    Person_Builder _defaults = new Person.Builder();\", \"    if (_defaults._unsetProperties.contains(Person_Builder.Property.NAME)\", \"        || !value.getName().equals(_defaults.getName())) {\", \"      setName(value.getName());\", \"    }\", \"    if (value.getAge() != _defaults.getAge()) {\", \"      setAge(value.getAge());\", \"    }\", \"    if (_defaults._unsetProperties.contains(Person_Builder.Property.SHOE_SIZE)\", \"        || value.getShoeSize() != _defaults.getShoeSize()) {\", \"      setShoeSize(value.getShoeSize());\", \"    }\", \"    return (Person.Builder) this;\", \"  }\", \"\", \"  /**\", \"   * Copies values from the given {@code Builder}. \" + \"Does not affect any properties not set on the\", \"   * input.\", \"   */\", \"  public Person.Builder mergeFrom(Person.Builder template) {\", \"    // Upcast to access private fields; otherwise, oddly, we get an access violation.\", \"    Person_Builder base = template;\", \"    Person_Builder _defaults = new Person.Builder();\", \"    if (!base._unsetProperties.contains(Person_Builder.Property.NAME)\", \"        && (_defaults._unsetProperties.contains(Person_Builder.Property.NAME)\", \"            || !template.getName().equals(_defaults.getName()))) {\", \"      setName(template.getName());\", \"    }\", \"    if (template.getAge() != _defaults.getAge()) {\", \"      setAge(template.getAge());\", \"    }\", \"    if (!base._unsetProperties.contains(Person_Builder.Property.SHOE_SIZE)\", \"        && (_defaults._unsetProperties.contains(Person_Builder.Property.SHOE_SIZE)\", \"            || template.getShoeSize() != _defaults.getShoeSize())) {\", \"      setShoeSize(template.getShoeSize());\", \"    }\", \"    return (Person.Builder) this;\", \"  }\", \"\", \"  /** Resets the state of this builder. */\", \"  public Person.Builder clear() {\", \"    Person_Builder _defaults = new Person.Builder();\", \"    name = _defaults.name;\", \"    age = _defaults.age;\", \"    shoeSize = _defaults.shoeSize;\", \"    _unsetProperties.clear();\", \"    _unsetProperties.addAll(_defaults._unsetProperties);\", \"    return (Person.Builder) this;\", \"  }\", \"\", \"  /**\", \"   * Returns a newly-created {@link Person} based on the contents of the {@code Builder}.\", \"   *\", \"   * @throws IllegalStateException if any field has not been set\", \"   */\", \"  public Person build() {\", \"    if (!_unsetProperties.isEmpty()) {\", \"      throw new IllegalStateException(\\\"Not set: \\\" + _unsetProperties);\", \"    }\", \"    return new Person_Builder.Value(this);\", \"  }\", \"\", \"  /**\", \"   * Returns a newly-created partial {@link Person} for use in unit tests. \" + \"State checking will not\", \"   * be performed. Unset properties will throw an {@link UnsupportedOperationException} \" + \"when\", \"   * accessed via the partial object.\", \"   *\", \"   * <p>Partials should only ever be used in tests. \" + \"They permit writing robust test cases that won't\", \"   * fail if this type gains more application-level constraints \" + \"(e.g. new required fields) in\", \"   * future. If you require partially complete values in production code, \" + \"consider using a Builder.\", \"   */\", \"  public Person buildPartial() {\", \"    return new Person_Builder.Partial(this);\", \"  }\", \"\", \"  private static final class Value extends Person {\", \"    private final String name;\", \"    private final int age;\", \"    private final int shoeSize;\", \"\", \"    private Value(Person_Builder builder) {\", \"      this.name = builder.name;\", \"      this.age = builder.age;\", \"      this.shoeSize = builder.shoeSize;\", \"    }\", \"\", \"    @Override\", \"    public String getName() {\", \"      return name;\", \"    }\", \"\", \"    @Override\", \"    public int getAge() {\", \"      return age;\", \"    }\", \"\", \"    @Override\", \"    public int getShoeSize() {\", \"      return shoeSize;\", \"    }\", \"\", \"    @Override\", \"    public boolean equals(Object obj) {\", \"      if (!(obj instanceof Person_Builder.Value)) {\", \"        return false;\", \"      }\", \"      Person_Builder.Value other = (Person_Builder.Value) obj;\", \"      if (!name.equals(other.name)) {\", \"        return false;\", \"      }\", \"      if (age != other.age) {\", \"        return false;\", \"      }\", \"      if (shoeSize != other.shoeSize) {\", \"        return false;\", \"      }\", \"      return true;\", \"    }\", \"\", \"    @Override\", \"    public int hashCode() {\", \"      return Arrays.hashCode(new Object[] {name, age, shoeSize});\", \"    }\", \"\", \"    @Override\", \"    public String toString() {\", \"      return \\\"Person{\\\" + \\\"name=\\\" + name + \\\", \\\" + \\\"age=\\\" + age + \\\", \\\" \" + \"+ \\\"shoeSize=\\\" + shoeSize + \\\"}\\\";\", \"    }\", \"  }\", \"\", \"  private static final class Partial extends Person {\", \"    private final String name;\", \"    private final int age;\", \"    private final int shoeSize;\", \"    private final EnumSet<Person_Builder.Property> _unsetProperties;\", \"\", \"    Partial(Person_Builder builder) {\", \"      this.name = builder.name;\", \"      this.age = builder.age;\", \"      this.shoeSize = builder.shoeSize;\", \"      this._unsetProperties = builder._unsetProperties.clone();\", \"    }\", \"\", \"    @Override\", \"    public String getName() {\", \"      if (_unsetProperties.contains(Person_Builder.Property.NAME)) {\", \"        throw new UnsupportedOperationException(\\\"name not set\\\");\", \"      }\", \"      return name;\", \"    }\", \"\", \"    @Override\", \"    public int getAge() {\", \"      return age;\", \"    }\", \"\", \"    @Override\", \"    public int getShoeSize() {\", \"      if (_unsetProperties.contains(Person_Builder.Property.SHOE_SIZE)) {\", \"        throw new UnsupportedOperationException(\\\"shoeSize not set\\\");\", \"      }\", \"      return shoeSize;\", \"    }\", \"\", \"    @Override\", \"    public boolean equals(Object obj) {\", \"      if (!(obj instanceof Person_Builder.Partial)) {\", \"        return false;\", \"      }\", \"      Person_Builder.Partial other = (Person_Builder.Partial) obj;\", \"      if (name != other.name && (name == null || !name.equals(other.name))) {\", \"        return false;\", \"      }\", \"      if (age != other.age) {\", \"        return false;\", \"      }\", \"      if (shoeSize != other.shoeSize) {\", \"        return false;\", \"      }\", \"      return _unsetProperties.equals(other._unsetProperties);\", \"    }\", \"\", \"    @Override\", \"    public int hashCode() {\", \"      return Arrays.hashCode(new Object[] {name, age, shoeSize, _unsetProperties});\", \"    }\", \"\", \"    @Override\", \"    public String toString() {\", \"      StringBuilder result = new StringBuilder(\\\"partial Person{\\\");\", \"      if (!_unsetProperties.contains(Person_Builder.Property.NAME)) {\", \"        result.append(\\\"name=\\\").append(name);\", \"        result.append(\\\", \\\");\", \"      }\", \"      result.append(\\\"age=\\\").append(age);\", \"      if (!_unsetProperties.contains(Person_Builder.Property.SHOE_SIZE)) {\", \"        result.append(\\\", \\\");\", \"        result.append(\\\"shoeSize=\\\").append(shoeSize);\", \"      }\", \"      result.append(\\\"}\\\");\", \"      return result.toString();\", \"    }\", \"  }\", \"}\\n\"));\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Query.whereLessThan",
	"Comment": "creates and returns a new query with the additional filter that documents must contain thespecified field and the value should be less than the specified value.",
	"Method": "Query whereLessThan(String field,Object value,Query whereLessThan,FieldPath fieldPath,Object value){\r\n    return whereHelper(fieldPath, Operator.LESS_THAN, value);\r\n}"
}, {
	"Path": "org.fluentlenium.core.action.MouseElementActions.moveToElement",
	"Comment": "moves the mouse to the middle of the element. the element is scrolled into view and itslocation is calculated using getboundingclientrect.",
	"Method": "MouseElementActions moveToElement(MouseElementActions moveToElement,int xOffset,int yOffset){\r\n    actions().moveToElement(element, xOffset, yOffset).perform();\r\n    return this;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Event.getExtensionKind",
	"Comment": "the extension event kind.this is provided for the extension event.can return null.",
	"Method": "String getExtensionKind(){\r\n    return json.get(\"extensionKind\") == null ? null : json.get(\"extensionKind\").getAsString();\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.Array.resize",
	"Comment": "creates a new backing array with the specified size containing the current items.",
	"Method": "T[] resize(int newSize,T[] resize,int newSize){\r\n    T[] items = this.items;\r\n    T[] newItems = (T[]) newArray(items.getClass().getComponentType(), newSize);\r\n    System.arraycopy(items, 0, newItems, 0, Math.min(size, newItems.length));\r\n    this.items = newItems;\r\n    return newItems;\r\n}"
}, {
	"Path": "com.google.firebase.inappmessaging.display.FirebaseInAppMessagingDisplayTest.streamListener_whenImageLoadFails_stopsImpressionTimer",
	"Comment": "not strictly necessary since in practice, the timer should not have been started",
	"Method": "void streamListener_whenImageLoadFails_stopsImpressionTimer(){\r\n    startActivity();\r\n    listener.displayMessage(IMAGE_ONLY_MESSAGE, callbacks);\r\n    verify(fakeRequestCreator).into(any(ImageView.class), callbackArgCaptor.capture());\r\n    callbackArgCaptor.getValue().onError();\r\n    verify(impressionTimer).cancel();\r\n}"
}, {
	"Path": "com.almasb.fxgl.ai.btree.decorator.SemaphoreGuard.end",
	"Comment": "releases the semaphore.\tthis method is called when the task exits.",
	"Method": "void end(){\r\n    if (semaphoreAcquired) {\r\n        if (semaphore == null) {\r\n            semaphore = NonBlockingSemaphoreRepository.getSemaphore(name);\r\n        }\r\n        semaphore.release();\r\n        semaphoreAcquired = false;\r\n    }\r\n    super.end();\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.reflect.ClassReflection.forName",
	"Comment": "returns the class object associated with the class or interface with the supplied string name.",
	"Method": "Class forName(String name){\r\n    try {\r\n        return Class.forName(name);\r\n    } catch (ClassNotFoundException e) {\r\n        throw new ReflectionException(\"Class not found: \" + name, e);\r\n    }\r\n}"
}, {
	"Path": "com.vladsch.flexmark.convert.html.FlexmarkHtmlParser.parse",
	"Comment": "parse html with default options and max trailing blank lines",
	"Method": "void parse(FormattingAppendable out,String html,String parse,String html,String parse,String html,int maxBlankLines,String parse,String html,int maxBlankLines,DataHolder options){\r\n    FormattingAppendableImpl out = new FormattingAppendableImpl(FormattingAppendable.SUPPRESS_TRAILING_WHITESPACE | FormattingAppendable.COLLAPSE_WHITESPACE);\r\n    FlexmarkHtmlParser parser = new FlexmarkHtmlParser(options);\r\n    parser.parse(out, html);\r\n    return out.getText(maxBlankLines);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.spec.SpecTestCase.parseList",
	"Comment": "deeply parses a jsonarray into a list, recursively parsing its children.",
	"Method": "List<Object> parseList(JSONArray arr){\r\n    List<Object> result = new ArrayList(arr.length());\r\n    for (int i = 0; i < arr.length(); ++i) {\r\n        result.add(parseObject(arr.get(i)));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.DocumentReference.getFirestore",
	"Comment": "gets the firestore instance associated with this document reference.",
	"Method": "FirebaseFirestore getFirestore(){\r\n    return firestore;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Body.setType",
	"Comment": "set the type of this body.this may alter the mass and velocity.",
	"Method": "void setType(BodyType type){\r\n    world.assertNotLocked();\r\n    if (this.type == type) {\r\n        return;\r\n    }\r\n    this.type = type;\r\n    resetMassData();\r\n    if (this.type == BodyType.STATIC) {\r\n        m_linearVelocity.setZero();\r\n        m_angularVelocity = 0.0f;\r\n        m_sweep.a0 = m_sweep.a;\r\n        m_sweep.c0.set(m_sweep.c);\r\n        synchronizeFixtures();\r\n    }\r\n    setAwake(true);\r\n    m_force.setZero();\r\n    m_torque = 0.0f;\r\n    destroyAttachedContacts();\r\n    BroadPhase broadPhase = world.getContactManager().broadPhase;\r\n    for (Fixture f : fixtures) {\r\n        int proxyCount = f.getProxyCount();\r\n        for (int i = 0; i < proxyCount; ++i) {\r\n            broadPhase.touchProxy(f.getProxyId(i));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact.mixFriction",
	"Comment": "friction mixing law.the idea is to allow either fixture to drive the restitution to zero.for example, anything slides on ice.",
	"Method": "float mixFriction(float friction1,float friction2){\r\n    return JBoxUtils.sqrt(friction1 * friction2);\r\n}"
}, {
	"Path": "org.apache.commons.io.input.ClassLoaderObjectInputStream.resolveProxyClass",
	"Comment": "create a proxy class that implements the specified interfaces usingthe specified classloader or the super classloader.",
	"Method": "Class<?> resolveProxyClass(String[] interfaces){\r\n    final Class<?>[] interfaceClasses = new Class[interfaces.length];\r\n    for (int i = 0; i < interfaces.length; i++) {\r\n        interfaceClasses[i] = Class.forName(interfaces[i], false, classLoader);\r\n    }\r\n    try {\r\n        return Proxy.getProxyClass(classLoader, interfaceClasses);\r\n    } catch (final IllegalArgumentException e) {\r\n        return super.resolveProxyClass(interfaces);\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.DocumentKey.fromSegments",
	"Comment": "creates and returns a new document key with the given segments.",
	"Method": "DocumentKey fromSegments(List<String> segments){\r\n    return new DocumentKey(ResourcePath.fromSegments(segments));\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LocalStore.readDocument",
	"Comment": "returns the current value of a document with a given key, or null if not found.",
	"Method": "MaybeDocument readDocument(DocumentKey key){\r\n    return localDocuments.getDocument(key);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.MutationQueueTestCase.addMutationBatch",
	"Comment": "creates a new mutationbatch with the given key, the next batch id and a set of dummy mutations.",
	"Method": "MutationBatch addMutationBatch(MutationBatch addMutationBatch,String key){\r\n    SetMutation mutation = setMutation(key, map(\"a\", 1));\r\n    return persistence.runTransaction(\"New mutation batch\", () -> mutationQueue.addMutationBatch(Timestamp.now(), asList(mutation)));\r\n}"
}, {
	"Path": "com.google.firebase.database.core.persistence.TrackedQueryManager.getKnownCompleteChildren",
	"Comment": "uses our tracked queries to figure out what complete children we have.",
	"Method": "Set<ChildKey> getKnownCompleteChildren(Path path){\r\n    assert !this.isQueryComplete(QuerySpec.defaultQueryAtPath(path)) : \"Path is fully complete.\";\r\n    Set<ChildKey> completeChildren = new HashSet<ChildKey>();\r\n    Set<Long> queryIds = filteredQueryIdsAtPath(path);\r\n    if (!queryIds.isEmpty()) {\r\n        completeChildren.addAll(storageLayer.loadTrackedQueryKeys(queryIds));\r\n    }\r\n    for (Map.Entry<ChildKey, ImmutableTree<Map<QueryParams, TrackedQuery>>> childEntry : this.trackedQueryTree.subtree(path).getChildren()) {\r\n        ChildKey childKey = childEntry.getKey();\r\n        ImmutableTree<Map<QueryParams, TrackedQuery>> childTree = childEntry.getValue();\r\n        if (childTree.getValue() != null && HAS_DEFAULT_COMPLETE_PREDICATE.evaluate(childTree.getValue())) {\r\n            completeChildren.add(childKey);\r\n        }\r\n    }\r\n    return completeChildren;\r\n}"
}, {
	"Path": "io.flutter.inspector.DiagnosticsNode.isSummaryTree",
	"Comment": "whether this node is being displayed as a full tree or a filtered tree.",
	"Method": "boolean isSummaryTree(){\r\n    return getBooleanMember(\"summaryTree\", false);\r\n}"
}, {
	"Path": "org.fluentlenium.assertj.custom.FluentListAssert.hasText",
	"Comment": "check if at least one element of the fluentlist contains the text",
	"Method": "FluentListAssert hasText(String textToFind){\r\n    List<String> actualTexts = actual.texts();\r\n    for (String text : actualTexts) {\r\n        if (text.contains(textToFind)) {\r\n            return this;\r\n        }\r\n    }\r\n    super.failWithMessage(\"No selected elements contains text: \" + textToFind + \" . Actual texts found : \" + actualTexts);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.ServerTimestampTest.expectedDataWithTimestamp",
	"Comment": "returns the expected data, with an arbitrary timestamp substituted in.",
	"Method": "Map<String, Object> expectedDataWithTimestamp(Object timestamp){\r\n    return map(\"a\", 42L, \"when\", timestamp, \"deep\", map(\"when\", timestamp));\r\n}"
}, {
	"Path": "io.flutter.testing.TestDir.pathAt",
	"Comment": "given a path relative to the temp directory, returns the absolute path.",
	"Method": "String pathAt(String path){\r\n    return fixture.getTempDirPath() + \"/\" + path;\r\n}"
}, {
	"Path": "io.flutter.run.daemon.FlutterDevice.getUniqueName",
	"Comment": "given a collection of devices, return a unique name for this device.",
	"Method": "String getUniqueName(Collection<FlutterDevice> devices){\r\n    for (final FlutterDevice other : devices) {\r\n        if (other == this) {\r\n            continue;\r\n        }\r\n        if (other.deviceName().equals(deviceName())) {\r\n            return deviceName() + \" (\" + deviceId() + \")\";\r\n        }\r\n    }\r\n    return deviceName();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LocalSerializer.encodeDocument",
	"Comment": "encodes a document for local storage. this differs from the v1beta1 rpc serializer fordocuments in that it preserves the updatetime, which is considered an output only value by theserver.",
	"Method": "com.google.firestore.v1beta1.Document encodeDocument(Document document){\r\n    com.google.firestore.v1beta1.Document.Builder builder = com.google.firestore.v1beta1.Document.newBuilder();\r\n    builder.setName(rpcSerializer.encodeKey(document.getKey()));\r\n    ObjectValue value = document.getData();\r\n    for (Map.Entry<String, FieldValue> entry : value.getInternalValue()) {\r\n        builder.putFields(entry.getKey(), rpcSerializer.encodeValue(entry.getValue()));\r\n    }\r\n    Timestamp updateTime = document.getVersion().getTimestamp();\r\n    builder.setUpdateTime(rpcSerializer.encodeTimestamp(updateTime));\r\n    return builder.build();\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.AnnotationNavigateToListener.getArgsFunction",
	"Comment": "get a function that retrieves argument value based on argument class.",
	"Method": "Function<Class<?>, Object> getArgsFunction(String url,WebDriver driver){\r\n    return input -> {\r\n        if (input.isAssignableFrom(String.class)) {\r\n            return url;\r\n        }\r\n        if (input.isAssignableFrom(WebDriver.class)) {\r\n            return driver;\r\n        }\r\n        return null;\r\n    };\r\n}"
}, {
	"Path": "com.google.firebase.firestore.QuerySnapshot.isEmpty",
	"Comment": "returns true if there are no documents in the querysnapshot.",
	"Method": "boolean isEmpty(){\r\n    return snapshot.getDocuments().isEmpty();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.WatchChangeAggregator.handleTargetChange",
	"Comment": "processes and adds the watchtargetchange to the current set of changes.",
	"Method": "void handleTargetChange(WatchTargetChange targetChange){\r\n    for (int targetId : getTargetIds(targetChange)) {\r\n        TargetState targetState = ensureTargetState(targetId);\r\n        switch(targetChange.getChangeType()) {\r\n            case NoChange:\r\n                if (isActiveTarget(targetId)) {\r\n                    targetState.updateResumeToken(targetChange.getResumeToken());\r\n                }\r\n                break;\r\n            case Added:\r\n                targetState.recordTargetResponse();\r\n                if (!targetState.isPending()) {\r\n                    targetState.clearChanges();\r\n                }\r\n                targetState.updateResumeToken(targetChange.getResumeToken());\r\n                break;\r\n            case Removed:\r\n                targetState.recordTargetResponse();\r\n                if (!targetState.isPending()) {\r\n                    removeTarget(targetId);\r\n                }\r\n                hardAssert(targetChange.getCause() == null, \"WatchChangeAggregator does not handle errored targets\");\r\n                break;\r\n            case Current:\r\n                if (isActiveTarget(targetId)) {\r\n                    targetState.markCurrent();\r\n                    targetState.updateResumeToken(targetChange.getResumeToken());\r\n                }\r\n                break;\r\n            case Reset:\r\n                if (isActiveTarget(targetId)) {\r\n                    resetTarget(targetId);\r\n                    targetState.updateResumeToken(targetChange.getResumeToken());\r\n                }\r\n                break;\r\n            default:\r\n                throw fail(\"Unknown target watch change state: %s\", targetChange.getChangeType());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Isolate.getExtensionRPCs",
	"Comment": "the list of service extension rpcs that are registered for this isolate, if any.can return null.",
	"Method": "List<String> getExtensionRPCs(){\r\n    return json.get(\"extensionRPCs\") == null ? null : getListString(\"extensionRPCs\");\r\n}"
}, {
	"Path": "com.google.firebase.firestore.FirebaseFirestore.validateReference",
	"Comment": "helper to validate a documentreference. used by writebatch and transaction.",
	"Method": "void validateReference(DocumentReference docRef){\r\n    checkNotNull(docRef, \"Provided DocumentReference must not be null.\");\r\n    if (docRef.getFirestore() != this) {\r\n        throw new IllegalArgumentException(\"Provided document reference is from a different Firestore instance.\");\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.net.NetworkConnection.addParser",
	"Comment": "register a parser for specified class. the parserwill be called back when an instance of the classarrives from the other end of connection",
	"Method": "void addParser(Class<T> cl,DataParser<T> parser){\r\n    parsers.put(cl, (DataParser<? super Serializable>) parser);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact.getManifold",
	"Comment": "get the contact manifold. do not set the point count to zero. instead call disable.",
	"Method": "Manifold getManifold(){\r\n    return m_manifold;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.DocumentReference.getParent",
	"Comment": "gets a collectionreference to the collection that contains this document.",
	"Method": "CollectionReference getParent(){\r\n    return new CollectionReference(key.getPath().popLast(), firestore);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.FieldPath.of",
	"Comment": "creates a fieldpath from the provided field names. if more than one field name is provided, thepath will point to a nested field in a document.",
	"Method": "FieldPath of(String fieldNames){\r\n    checkArgument(fieldNames.length > 0, \"Invalid field path. Provided path must not be empty.\");\r\n    for (int i = 0; i < fieldNames.length; ++i) {\r\n        checkArgument(fieldNames[i] != null && !fieldNames[i].isEmpty(), \"Invalid field name at argument \" + (i + 1) + \". Field names must not be null or empty.\");\r\n    }\r\n    return new FieldPath(Arrays.asList(fieldNames));\r\n}"
}, {
	"Path": "com.google.firebase.inappmessaging.display.FirebaseInAppMessagingDisplayTest.streamListener_whenImageLoadFails_stopsDismissTimer",
	"Comment": "not strictly necessary since in practice, the timer should not have been started",
	"Method": "void streamListener_whenImageLoadFails_stopsDismissTimer(){\r\n    startActivity();\r\n    listener.displayMessage(BANNER_MESSAGE, callbacks);\r\n    verify(fakeRequestCreator).into(any(ImageView.class), callbackArgCaptor.capture());\r\n    callbackArgCaptor.getValue().onError();\r\n    verify(autoDismissTimer).cancel();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.CustomClassMapper.convertToCustomClass",
	"Comment": "converts a standard library java representation of json data to an object of the providedclass.",
	"Method": "T convertToCustomClass(Object object,Class<T> clazz){\r\n    return deserializeToClass(object, clazz, ErrorPath.EMPTY);\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.SourceReportRange.getCoverage",
	"Comment": "code coverage information for this range.provided only when the coverage report has beenrequested and the range has been compiled.can return null.",
	"Method": "SourceReportCoverage getCoverage(){\r\n    return json.get(\"coverage\") == null ? null : new SourceReportCoverage((JsonObject) json.get(\"coverage\"));\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Fixture.setUserData",
	"Comment": "set the user data.use this to store your application specific data.",
	"Method": "void setUserData(Object data){\r\n    userData = data;\r\n}"
}, {
	"Path": "com.google.firebase.auth.GetTokenResult.getToken",
	"Comment": "firebase auth id token. useful for authenticating calls against your own backend. verify theintegrity and validity of the token in your server either by using our server sdks or followingthe documentation.",
	"Method": "String getToken(){\r\n    return token;\r\n}"
}, {
	"Path": "org.fluentlenium.core.proxy.LocatorProxies.createWebElementList",
	"Comment": "create a list of webelement proxies from a locator of element list.",
	"Method": "List<WebElement> createWebElementList(List<WebElement> elements,List<WebElement> createWebElementList,Supplier<List<WebElement>> elementsSupplier,List<WebElement> createWebElementList,ElementLocator locator){\r\n    ListHandler handler = new ListHandler(locator);\r\n    List<WebElement> proxy = (List<WebElement>) Proxy.newProxyInstance(locator.getClass().getClassLoader(), new Class[] { List.class, WrapsElements.class }, handler);\r\n    handler.setProxy(proxy);\r\n    return proxy;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.value.ObjectValue.delete",
	"Comment": "returns an objectvalue with the field path deleted. if there is no field at the specified pathnothing is changed.",
	"Method": "ObjectValue delete(FieldPath path){\r\n    hardAssert(!path.isEmpty(), \"Cannot delete field for empty path on ObjectValue\");\r\n    String childName = path.getFirstSegment();\r\n    if (path.length() == 1) {\r\n        return fromImmutableMap(internalValue.remove(childName));\r\n    } else {\r\n        FieldValue child = internalValue.get(childName);\r\n        if (child instanceof ObjectValue) {\r\n            ObjectValue newChild = ((ObjectValue) child).delete(path.popFirst());\r\n            return setChild(childName, newChild);\r\n        } else {\r\n            return this;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.flutter.perf.FlutterWidgetPerfManager.init",
	"Comment": "initialize the rebuild count manager for the given project.",
	"Method": "void init(Project project){\r\n    getInstance(project);\r\n}"
}, {
	"Path": "io.flutter.utils.AsyncUtils.whenCompleteUiThread",
	"Comment": "helper to get the value of a future on the ui thread.the action will never be called if the future is cancelled.",
	"Method": "void whenCompleteUiThread(CompletableFuture<T> future,BiConsumer<? super T, ? super Throwable> action){\r\n    future.whenCompleteAsync((T value, Throwable throwable) -> {\r\n        if (throwable instanceof CancellationException) {\r\n            return;\r\n        }\r\n        invokeLater(() -> action.accept(value, throwable));\r\n    });\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LocalStore.getNextMutationBatch",
	"Comment": "returns the mutation batch after the passed in batchid in the mutation queue or null if empty.",
	"Method": "MutationBatch getNextMutationBatch(int afterBatchId){\r\n    return mutationQueue.getNextMutationBatchAfterBatchId(afterBatchId);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LocalStore.getLastStreamToken",
	"Comment": "returns the last recorded stream token for the current user.",
	"Method": "ByteString getLastStreamToken(){\r\n    return mutationQueue.getLastStreamToken();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteSerializer.decodeValue",
	"Comment": "converts from the proto value format to the model fieldvalue format",
	"Method": "FieldValue decodeValue(com.google.firestore.v1beta1.Value proto){\r\n    switch(proto.getValueTypeCase()) {\r\n        case NULL_VALUE:\r\n            return NullValue.nullValue();\r\n        case BOOLEAN_VALUE:\r\n            return BooleanValue.valueOf(proto.getBooleanValue());\r\n        case INTEGER_VALUE:\r\n            return IntegerValue.valueOf(proto.getIntegerValue());\r\n        case DOUBLE_VALUE:\r\n            return DoubleValue.valueOf(proto.getDoubleValue());\r\n        case TIMESTAMP_VALUE:\r\n            Timestamp timestamp = decodeTimestamp(proto.getTimestampValue());\r\n            return TimestampValue.valueOf(timestamp);\r\n        case GEO_POINT_VALUE:\r\n            LatLng latLng = proto.getGeoPointValue();\r\n            return GeoPointValue.valueOf(decodeGeoPoint(latLng));\r\n        case BYTES_VALUE:\r\n            ByteString bytes = proto.getBytesValue();\r\n            return BlobValue.valueOf(Blob.fromByteString(bytes));\r\n        case REFERENCE_VALUE:\r\n            ResourcePath resourceName = decodeResourceName(proto.getReferenceValue());\r\n            DatabaseId id = DatabaseId.forDatabase(resourceName.getSegment(1), resourceName.getSegment(3));\r\n            DocumentKey key = DocumentKey.fromPath(extractLocalPathFromResourceName(resourceName));\r\n            return ReferenceValue.valueOf(id, key);\r\n        case STRING_VALUE:\r\n            return StringValue.valueOf(proto.getStringValue());\r\n        case ARRAY_VALUE:\r\n            return decodeArrayValue(proto.getArrayValue());\r\n        case MAP_VALUE:\r\n            return decodeMapValue(proto.getMapValue());\r\n        default:\r\n            throw fail(\"Unknown value %s\", proto);\r\n    }\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.AnnotationFindByListener.getArgsFunction",
	"Comment": "get a function that retrieves argument value based on argument class.",
	"Method": "Function<Class<?>, Object> getArgsFunction(By by,FluentWebElement element,WebDriver driver){\r\n    return input -> {\r\n        if (input.isAssignableFrom(FluentWebElement.class)) {\r\n            return element;\r\n        }\r\n        if (input.isAssignableFrom(By.class)) {\r\n            return by;\r\n        }\r\n        if (input.isAssignableFrom(WebDriver.class)) {\r\n            return driver;\r\n        }\r\n        return null;\r\n    };\r\n}"
}, {
	"Path": "org.fluentlenium.core.conditions.message.MessageBuilderInvocationHandler.buildMessage",
	"Comment": "build the message based on annotations from methods called previously.",
	"Method": "String buildMessage(){\r\n    StringBuilder messageBuilder = new StringBuilder();\r\n    for (MessageBuilderCall call : calls) {\r\n        if (call.getContext() != null) {\r\n            if (messageBuilder.length() > 0) {\r\n                messageBuilder.append(' ');\r\n            }\r\n            messageBuilder.append(call.getContext());\r\n        }\r\n    }\r\n    boolean negation = false;\r\n    for (MessageBuilderCall call : calls) {\r\n        if (call.isNegation()) {\r\n            negation = !negation;\r\n        }\r\n    }\r\n    List<MessageBuilderCall> reversedCalls = new ArrayList(calls);\r\n    Collections.reverse(reversedCalls);\r\n    for (MessageBuilderCall call : reversedCalls) {\r\n        String validationMessage = negation ? call.getMessage() : call.getNotMessage();\r\n        if (validationMessage == null) {\r\n            continue;\r\n        }\r\n        validationMessage = MessageFormat.format(validationMessage, call.getArgs());\r\n        messageBuilder.append(' ');\r\n        messageBuilder.append(validationMessage);\r\n        return messageBuilder.toString();\r\n    }\r\n    throw new IllegalStateException(\"No @Message/@NotMessage annotation found in the calls.\");\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Query.endBefore",
	"Comment": "creates and returns a new query that ends before the provided fields relative to the order ofthe query. the order of the field values must match the order of the order by clauses of thequery.",
	"Method": "Query endBefore(DocumentSnapshot snapshot,Query endBefore,Object fieldValues){\r\n    Bound bound = boundFromFields(\"endBefore\", fieldValues, true);\r\n    return new Query(query.endAt(bound), firestore);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.PhysicsComponent.applyBodyTorque",
	"Comment": "apply a torque. this affects the angular velocity without affecting the linear velocity of the center of mass. this wakes up the body.",
	"Method": "void applyBodyTorque(float torque){\r\n    getBody().applyTorque(torque);\r\n}"
}, {
	"Path": "fr.pilato.elasticsearch.crawler.fs.test.integration.AbstractITCase.split",
	"Comment": "split a string at the first occurrence of the delimiter.does not include the delimiter in the result.",
	"Method": "String[] split(String toSplit,String delimiter){\r\n    int offset = toSplit.indexOf(delimiter);\r\n    String beforeDelimiter = toSplit.substring(0, offset);\r\n    String afterDelimiter = toSplit.substring(offset + delimiter.length());\r\n    return new String[] { beforeDelimiter, afterDelimiter };\r\n}"
}, {
	"Path": "com.google.firebase.firestore.WriteBatch.set",
	"Comment": "overwrites the document referred to by the provided documentreference. if the document does notyet exist, it will be created. if a document already exists, it will be overwritten.",
	"Method": "WriteBatch set(DocumentReference documentRef,Map<String, Object> data,WriteBatch set,DocumentReference documentRef,Map<String, Object> data,SetOptions options,WriteBatch set,DocumentReference documentRef,Object pojo,WriteBatch set,DocumentReference documentRef,Object pojo,SetOptions options){\r\n    return set(documentRef, firestore.getDataConverter().convertPOJO(pojo), options);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.collision.Collision.findMaxSeparation",
	"Comment": "find the max separation between poly1 and poly2 using edge normals from poly1.",
	"Method": "void findMaxSeparation(EdgeResults results,PolygonShape poly1,Transform xf1,PolygonShape poly2,Transform xf2){\r\n    int count1 = poly1.getVertexCount();\r\n    int count2 = poly2.getVertexCount();\r\n    Vec2[] n1s = poly1.m_normals;\r\n    Vec2[] v1s = poly1.m_vertices;\r\n    Vec2[] v2s = poly2.m_vertices;\r\n    Transform.mulTransToOutUnsafe(xf2, xf1, xf);\r\n    final Rotation xfq = xf.q;\r\n    int bestIndex = 0;\r\n    float maxSeparation = -Float.MAX_VALUE;\r\n    for (int i = 0; i < count1; i++) {\r\n        Rotation.mulToOutUnsafe(xfq, n1s[i], n);\r\n        Transform.mulToOutUnsafe(xf, v1s[i], v1);\r\n        float si = Float.MAX_VALUE;\r\n        for (int j = 0; j < count2; ++j) {\r\n            Vec2 v2sj = v2s[j];\r\n            float sij = n.x * (v2sj.x - v1.x) + n.y * (v2sj.y - v1.y);\r\n            if (sij < si) {\r\n                si = sij;\r\n            }\r\n        }\r\n        if (si > maxSeparation) {\r\n            maxSeparation = si;\r\n            bestIndex = i;\r\n        }\r\n    }\r\n    results.edgeIndex = bestIndex;\r\n    results.separation = maxSeparation;\r\n}"
}, {
	"Path": "com.bartoszlipinski.flippablestackview.OrientedViewPager.onRequestFocusInDescendants",
	"Comment": "we only want the current page that is being shown to be focusable.",
	"Method": "boolean onRequestFocusInDescendants(int direction,Rect previouslyFocusedRect){\r\n    int index;\r\n    int increment;\r\n    int end;\r\n    int count = getChildCount();\r\n    if ((direction & FOCUS_FORWARD) != 0) {\r\n        index = 0;\r\n        increment = 1;\r\n        end = count;\r\n    } else {\r\n        index = count - 1;\r\n        increment = -1;\r\n        end = -1;\r\n    }\r\n    for (int i = index; i != end; i += increment) {\r\n        View child = getChildAt(i);\r\n        if (child.getVisibility() == VISIBLE) {\r\n            ItemInfo ii = infoForChild(child);\r\n            if (ii != null && ii.position == mCurItem) {\r\n                if (child.requestFocus(direction, previouslyFocusedRect)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.flutter.profiler.FlutterStudioMonitorStageView.addPlaceHodlerNode",
	"Comment": "node place holder for an object that we have not yet ask the vm to interrogated viewing its values.",
	"Method": "DefaultMutableTreeNode addPlaceHodlerNode(DefaultMutableTreeNode parent,String objectRefName){\r\n    final DefaultMutableTreeNode node = new DefaultMutableTreeNode(objectRefName);\r\n    SwingUtilities.invokeLater(() -> {\r\n        parent.insert(node, parent.getChildCount());\r\n        DefaultTreeModel model = (DefaultTreeModel) instanceObjects.getModel();\r\n        model.reload(node);\r\n    });\r\n    return node;\r\n}"
}, {
	"Path": "com.google.firebase.FirebaseOptions.getApplicationId",
	"Comment": "the google app id that is used to uniquely identify an instance of an app.",
	"Method": "String getApplicationId(){\r\n    return applicationId;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteStore.fillWritePipeline",
	"Comment": "attempts to fill our write pipeline with writes from the localstore.called internally to bootstrap or refill the write pipeline and by syncengine whenever thereare new mutations to process.starts the write stream if necessary.",
	"Method": "void fillWritePipeline(){\r\n    int lastBatchIdRetrieved = writePipeline.isEmpty() ? MutationBatch.UNKNOWN : writePipeline.getLast().getBatchId();\r\n    while (canAddToWritePipeline()) {\r\n        MutationBatch batch = localStore.getNextMutationBatch(lastBatchIdRetrieved);\r\n        if (batch == null) {\r\n            if (writePipeline.size() == 0) {\r\n                writeStream.markIdle();\r\n            }\r\n            break;\r\n        }\r\n        addToWritePipeline(batch);\r\n        lastBatchIdRetrieved = batch.getBatchId();\r\n    }\r\n    if (shouldStartWriteStream()) {\r\n        startWriteStream();\r\n    }\r\n}"
}, {
	"Path": "io.flutter.run.daemon.DeviceService.refreshDeviceDaemon",
	"Comment": "updates the device daemon to what it should be based on current configuration.this might mean starting it, stopping it, or restarting it.",
	"Method": "void refreshDeviceDaemon(){\r\n    if (project.isDisposed())\r\n        return;\r\n    deviceDaemon.refresh(this::chooseNextDaemon);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Body.setBullet",
	"Comment": "should this body be treated like a bullet for continuous collision detection?",
	"Method": "void setBullet(boolean flag){\r\n    if (flag) {\r\n        m_flags |= e_bulletFlag;\r\n    } else {\r\n        m_flags &= ~e_bulletFlag;\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.SyncEngine.handleRemoteEvent",
	"Comment": "called by firestoreclient to notify us of a new remote event.",
	"Method": "void handleRemoteEvent(RemoteEvent event){\r\n    assertCallback(\"handleRemoteEvent\");\r\n    for (Map.Entry<Integer, TargetChange> entry : event.getTargetChanges().entrySet()) {\r\n        Integer targetId = entry.getKey();\r\n        TargetChange targetChange = entry.getValue();\r\n        LimboResolution limboResolution = limboResolutionsByTarget.get(targetId);\r\n        if (limboResolution != null) {\r\n            hardAssert(targetChange.getAddedDocuments().size() + targetChange.getModifiedDocuments().size() + targetChange.getRemovedDocuments().size() <= 1, \"Limbo resolution for single document contains multiple changes.\");\r\n            if (targetChange.getAddedDocuments().size() > 0) {\r\n                limboResolution.receivedDocument = true;\r\n            } else if (targetChange.getModifiedDocuments().size() > 0) {\r\n                hardAssert(limboResolution.receivedDocument, \"Received change for limbo target document without add.\");\r\n            } else if (targetChange.getRemovedDocuments().size() > 0) {\r\n                hardAssert(limboResolution.receivedDocument, \"Received remove for limbo target document without add.\");\r\n                limboResolution.receivedDocument = false;\r\n            } else {\r\n            }\r\n        }\r\n    }\r\n    ImmutableSortedMap<DocumentKey, MaybeDocument> changes = localStore.applyRemoteEvent(event);\r\n    emitNewSnapsAndNotifyLocalStore(changes, event);\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Obj.getId",
	"Comment": "a unique identifier for an object. passed to the getobject rpc to reload this object.some objects may get a new id when they are reloaded.",
	"Method": "String getId(){\r\n    return json.get(\"id\").getAsString();\r\n}"
}, {
	"Path": "com.almasb.fxgl.extra.ai.pathfinding.AStarLogic.getPath",
	"Comment": "since the equality check is based on references,start and target must be elements of the array.",
	"Method": "List<AStarNode> getPath(AStarNode[][] grid,AStarNode start,AStarNode target,AStarNode busyNodes){\r\n    if (target.getState() == NodeState.NOT_WALKABLE)\r\n        return Collections.emptyList();\r\n    for (int y = 0; y < grid[0].length; y++) {\r\n        for (int x = 0; x < grid.length; x++) {\r\n            grid[x][y].setHCost(Math.abs(target.getX() - x) + Math.abs(target.getY() - y));\r\n        }\r\n    }\r\n    List<AStarNode> open = new ArrayList();\r\n    List<AStarNode> closed = new ArrayList();\r\n    AStarNode current = start;\r\n    boolean found = false;\r\n    while (!found && !closed.contains(target)) {\r\n        for (AStarNode neighbor : getValidNeighbors(current, grid, busyNodes)) {\r\n            if (neighbor == target) {\r\n                target.setParent(current);\r\n                found = true;\r\n                closed.add(target);\r\n                break;\r\n            }\r\n            if (!closed.contains(neighbor)) {\r\n                if (open.contains(neighbor)) {\r\n                    int newG = current.getGCost() + 10;\r\n                    if (newG < neighbor.getGCost()) {\r\n                        neighbor.setParent(current);\r\n                        neighbor.setGCost(newG);\r\n                    }\r\n                } else {\r\n                    neighbor.setParent(current);\r\n                    neighbor.setGCost(current.getGCost() + 10);\r\n                    open.add(neighbor);\r\n                }\r\n            }\r\n        }\r\n        if (!found) {\r\n            closed.add(current);\r\n            open.remove(current);\r\n            if (open.isEmpty())\r\n                return Collections.emptyList();\r\n            AStarNode acc = open.get(0);\r\n            for (AStarNode a : open) {\r\n                acc = a.getFCost() < acc.getFCost() ? a : acc;\r\n            }\r\n            current = acc;\r\n        }\r\n    }\r\n    return buildPath(start, target);\r\n}"
}, {
	"Path": "io.flutter.server.vmService.VMServiceManager.getCurrentFlutterIsolate",
	"Comment": "returns a streamsubscription providing the current flutter isolate.the current value of the subscription can be null occasionally during initial application startup and for a brief time when doing ahot restart.",
	"Method": "StreamSubscription<IsolateRef> getCurrentFlutterIsolate(Consumer<IsolateRef> onValue,boolean onUIThread){\r\n    return flutterIsolateRefStream.listen(onValue, onUIThread);\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.Array.shrink",
	"Comment": "reduces the size of the backing array to the size of the actual items.this is useful to release memory when many itemshave been removed, or if it is known that more items will not be added.",
	"Method": "T[] shrink(){\r\n    if (items.length != size)\r\n        resize(size);\r\n    return items;\r\n}"
}, {
	"Path": "org.inferred.freebuilder.processor.util.testing.SharedBehaviorTesting.getSharedCompilers",
	"Comment": "determines how many compilers we need and which children to pass them to.",
	"Method": "Queue<SharedCompiler> getSharedCompilers(RunNotifier notifier){\r\n    notifier.fireTestStarted(introspection);\r\n    try {\r\n        List<Child> children = getChildMetadata();\r\n        Queue<SharedCompiler> sharedCompilers = shareCompilers(children);\r\n        verifyCompilerShared(notifier, children.size(), sharedCompilers.size());\r\n        notifier.fireTestFinished(introspection);\r\n        return sharedCompilers;\r\n    } catch (Throwable t) {\r\n        notifier.fireTestFailure(new Failure(introspection, t));\r\n        throw t;\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.storage.StorageTask.onSuccessTask",
	"Comment": "returns a new task that will be completed with the result of applying the specifiedsuccesscontinuation to this task when this task completes successfully. if the previous taskfails, the onsuccesstask completion will be skipped and failure listeners will be invoked.if the previous task is canceled, the returned task will also be canceled and thesuccesscontinuation would not execute.",
	"Method": "Task<TContinuationResult> onSuccessTask(SuccessContinuation<TResult, TContinuationResult> continuation,Task<TContinuationResult> onSuccessTask,Executor executor,SuccessContinuation<TResult, TContinuationResult> continuation){\r\n    return successTaskImpl(executor, continuation);\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.ObjectMap.put",
	"Comment": "returns the old value associated with the specified key, or null.",
	"Method": "V put(K key,V value){\r\n    if (key == null)\r\n        throw new IllegalArgumentException(\"key cannot be null.\");\r\n    return putInternal(key, value);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.World.destroyBody",
	"Comment": "destroy a rigid body.this automatically deletes all associated shapes and joints.this function is locked during callbacks.",
	"Method": "void destroyBody(Body body){\r\n    assertNotLocked();\r\n    body.destroy();\r\n    bodies.removeValueByIdentity(body);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.Query.getLimit",
	"Comment": "the maximum number of results to return. if there is no limit on the query, then this willcause an assertion failure.",
	"Method": "long getLimit(){\r\n    hardAssert(hasLimit(), \"Called getLimit when no limit was set\");\r\n    return limit;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.FieldsTest.testTimestampsInSnapshots",
	"Comment": "is unaffected by the current default value in firebasefirestoresettings.",
	"Method": "void testTimestampsInSnapshots(){\r\n    Timestamp originalTimestamp = new Timestamp(100, 123456789);\r\n    Timestamp truncatedTimestamp = new Timestamp(originalTimestamp.getSeconds(), originalTimestamp.getNanoseconds() / 1000 * 1000);\r\n    DocumentReference docRef = testCollection().document();\r\n    waitFor(docRef.set(objectWithTimestamp(originalTimestamp)));\r\n    DocumentSnapshot snapshot = waitFor(docRef.get());\r\n    Map<String, Object> data = snapshot.getData();\r\n    Timestamp readTimestamp = (Timestamp) snapshot.get(\"timestamp\");\r\n    assertThat(readTimestamp).isEqualTo(truncatedTimestamp);\r\n    assertThat(readTimestamp).isEqualTo(data.get(\"timestamp\"));\r\n    Timestamp readNestedTimestamp = (Timestamp) snapshot.get(\"nested.timestamp2\");\r\n    assertThat(readNestedTimestamp).isEqualTo(truncatedTimestamp);\r\n    @SuppressWarnings(\"unchecked\")\r\n    Map<String, Object> nestedObject = (Map<String, Object>) data.get(\"nested\");\r\n    assertThat(nestedObject.get(\"timestamp2\")).isEqualTo(readNestedTimestamp);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.ContactManager.collide",
	"Comment": "this is the top level collision call for the time step. here all the narrow phase collision isprocessed for the world contact list.",
	"Method": "void collide(){\r\n    Contact c = contactList;\r\n    while (c != null) {\r\n        Fixture fixtureA = c.getFixtureA();\r\n        Fixture fixtureB = c.getFixtureB();\r\n        int indexA = c.getChildIndexA();\r\n        int indexB = c.getChildIndexB();\r\n        Body bodyA = fixtureA.getBody();\r\n        Body bodyB = fixtureB.getBody();\r\n        if ((c.m_flags & Contact.FILTER_FLAG) == Contact.FILTER_FLAG) {\r\n            if (!bodyB.shouldCollide(bodyA)) {\r\n                Contact cNuke = c;\r\n                c = cNuke.getNext();\r\n                destroy(cNuke);\r\n                continue;\r\n            }\r\n            if (contactFilter != null && !contactFilter.shouldCollide(fixtureA, fixtureB)) {\r\n                Contact cNuke = c;\r\n                c = cNuke.getNext();\r\n                destroy(cNuke);\r\n                continue;\r\n            }\r\n            c.m_flags &= ~Contact.FILTER_FLAG;\r\n        }\r\n        boolean activeA = bodyA.isAwake() && bodyA.getType() != BodyType.STATIC;\r\n        boolean activeB = bodyB.isAwake() && bodyB.getType() != BodyType.STATIC;\r\n        if (!activeA && !activeB) {\r\n            c = c.getNext();\r\n            continue;\r\n        }\r\n        int proxyIdA = fixtureA.getProxyId(indexA);\r\n        int proxyIdB = fixtureB.getProxyId(indexB);\r\n        boolean overlap = broadPhase.testOverlap(proxyIdA, proxyIdB);\r\n        if (!overlap) {\r\n            Contact cNuke = c;\r\n            c = cNuke.getNext();\r\n            destroy(cNuke);\r\n            continue;\r\n        }\r\n        c.update(contactListener);\r\n        c = c.getNext();\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.contacts.Contact.flagForFiltering",
	"Comment": "flag this contact for filtering. filtering will occur the next time step.",
	"Method": "void flagForFiltering(){\r\n    m_flags |= FILTER_FLAG;\r\n}"
}, {
	"Path": "com.google.firebase.functions.FirebaseFunctions.getInstance",
	"Comment": "creates a cloud functions client with the default app and given region.",
	"Method": "FirebaseFunctions getInstance(FirebaseApp app,String region,FirebaseFunctions getInstance,FirebaseApp app,FirebaseFunctions getInstance,String region,FirebaseFunctions getInstance){\r\n    return getInstance(FirebaseApp.getInstance(), \"us-central1\");\r\n}"
}, {
	"Path": "fr.pilato.elasticsearch.crawler.fs.tika.TikaInstance.initTika",
	"Comment": "this initialize if needed a parser and a parse context for tika",
	"Method": "void initTika(Fs fs){\r\n    initParser(fs);\r\n    initContext(fs);\r\n}"
}, {
	"Path": "com.google.cloud.datastore.core.number.IndexNumberDecoder.isResultDouble",
	"Comment": "returns whether the decoded number is representable as a double.",
	"Method": "boolean isResultDouble(){\r\n    updateResultDoubleState();\r\n    return doubleResultRepProblemMessage.isEmpty();\r\n}"
}, {
	"Path": "org.dartlang.analysis.server.protocol.FlutterOutlineAttribute.getLiteralValueString",
	"Comment": "the string literal value of the attribute. this field is absent if the value is not a stringliteral.",
	"Method": "String getLiteralValueString(){\r\n    return literalValueString;\r\n}"
}, {
	"Path": "org.fluentlenium.core.proxy.AbstractLocatorHandler.getLocatorResult",
	"Comment": "get the actual result of the locator, if result is not defined and not stale.it also raise events.",
	"Method": "T getLocatorResult(){\r\n    synchronized (this) {\r\n        if (result != null && isStale()) {\r\n            result = null;\r\n        }\r\n        if (result == null) {\r\n            fireProxyElementSearch();\r\n            result = getLocatorResultImpl();\r\n            fireProxyElementFound(result);\r\n        }\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteSerializer.encodeValue",
	"Comment": "converts the fieldvalue model passed into the value proto equivalent.",
	"Method": "com.google.firestore.v1beta1.Value encodeValue(FieldValue value){\r\n    com.google.firestore.v1beta1.Value.Builder builder = com.google.firestore.v1beta1.Value.newBuilder();\r\n    if (value instanceof NullValue) {\r\n        builder.setNullValueValue(0);\r\n        return builder.build();\r\n    }\r\n    Object encodedValue = value.value();\r\n    hardAssert(encodedValue != null, \"Encoded field value should not be null.\");\r\n    if (value instanceof BooleanValue) {\r\n        builder.setBooleanValue((Boolean) encodedValue);\r\n    } else if (value instanceof IntegerValue) {\r\n        builder.setIntegerValue((Long) encodedValue);\r\n    } else if (value instanceof DoubleValue) {\r\n        builder.setDoubleValue((Double) encodedValue);\r\n    } else if (value instanceof StringValue) {\r\n        builder.setStringValue((String) encodedValue);\r\n    } else if (value instanceof ArrayValue) {\r\n        builder.setArrayValue(encodeArrayValue((ArrayValue) value));\r\n    } else if (value instanceof ObjectValue) {\r\n        builder.setMapValue(encodeMapValue((ObjectValue) value));\r\n    } else if (value instanceof TimestampValue) {\r\n        Timestamp t = ((TimestampValue) value).getInternalValue();\r\n        builder.setTimestampValue(encodeTimestamp(t));\r\n    } else if (value instanceof GeoPointValue) {\r\n        GeoPoint geoPoint = (GeoPoint) encodedValue;\r\n        builder.setGeoPointValue(encodeGeoPoint(geoPoint));\r\n    } else if (value instanceof BlobValue) {\r\n        builder.setBytesValue(((Blob) encodedValue).toByteString());\r\n    } else if (value instanceof ReferenceValue) {\r\n        ReferenceValue ref = (ReferenceValue) value;\r\n        DatabaseId id = ref.getDatabaseId();\r\n        DocumentKey key = (DocumentKey) encodedValue;\r\n        builder.setReferenceValue(encodeResourceName(id, key.getPath()));\r\n    } else {\r\n        throw fail(\"Can't serialize %s\", value);\r\n    }\r\n    return builder.build();\r\n}"
}, {
	"Path": "com.almasb.fxgl.saving.SaveLoadManager.saveTask",
	"Comment": "save serializable data onto a disk file system under saves directory,which is created if necessary in the directory where the game is start from.all extra directories will also be created if necessary.",
	"Method": "IOTask<Void> saveTask(DataFile dataFile,SaveFile saveFile){\r\n    log.debug(\"Saving data: \" + saveFile.getName());\r\n    return FS.writeDataTask(saveFile, saveDir() + saveFile.getName() + SAVE_FILE_EXT).then(n -> FS.writeDataTask(dataFile, saveDir() + saveFile.getName() + DATA_FILE_EXT)).then(n -> IOTask.ofVoid(\"updateSaves\", () -> {\r\n        Async.startFX(() -> {\r\n            saveFiles.add(saveFile);\r\n            Collections.sort(saveFiles, SaveFile.RECENT_FIRST);\r\n        });\r\n    }));\r\n}"
}, {
	"Path": "com.almasb.fxgl.scene.FXGLMenu.fireSave",
	"Comment": "can only be fired from game menu.saves current state of the game with given file name.",
	"Method": "void fireSave(){\r\n    log.debug(\"fireSave()\");\r\n    listener.onSave();\r\n}"
}, {
	"Path": "com.google.firebase.internal.FirebaseAppHelper.addIdTokenListener",
	"Comment": "exposes addidtokenlistener on firebaseapp in an unobfuscated manner.",
	"Method": "void addIdTokenListener(FirebaseApp app,IdTokenListener listener){\r\n    app.addIdTokenListener(listener);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.WatchChangeAggregator.handleDocumentChange",
	"Comment": "processes and adds the documentwatchchange to the current set of changes.",
	"Method": "void handleDocumentChange(DocumentChange documentChange){\r\n    MaybeDocument document = documentChange.getNewDocument();\r\n    DocumentKey documentKey = documentChange.getDocumentKey();\r\n    for (int targetId : documentChange.getUpdatedTargetIds()) {\r\n        if (document instanceof Document) {\r\n            addDocumentToTarget(targetId, document);\r\n        } else if (document instanceof NoDocument) {\r\n            removeDocumentFromTarget(targetId, documentKey, document);\r\n        }\r\n    }\r\n    for (int targetId : documentChange.getRemovedTargetIds()) {\r\n        removeDocumentFromTarget(targetId, documentKey, documentChange.getNewDocument());\r\n    }\r\n}"
}, {
	"Path": "io.flutter.inspector.InspectorService.hasServiceMethod",
	"Comment": "use this method to write code that is backwards compatible with versionsof flutter that are too old to contain specific service methods.",
	"Method": "boolean hasServiceMethod(String methodName){\r\n    return supportedServiceMethods.contains(methodName);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteEvent.getResolvedLimboDocuments",
	"Comment": "returns the set of document updates that are due only to limbo resolution targets.",
	"Method": "Set<DocumentKey> getResolvedLimboDocuments(){\r\n    return resolvedLimboDocuments;\r\n}"
}, {
	"Path": "com.google.firebase.Timestamp.toDate",
	"Comment": "returns a new date corresponding to this timestamp. this may lose precision.",
	"Method": "Date toDate(){\r\n    return new Date(seconds * 1000 + (nanoseconds / 1000000));\r\n}"
}, {
	"Path": "io.flutter.run.test.TestFields.getTestDir",
	"Comment": "the directory containing the tests to run, or null if we are running tests in a file.",
	"Method": "String getTestDir(){\r\n    return testDir;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Message.getHandler",
	"Comment": "a reference to the function that will be invoked to handle this message.can return null.",
	"Method": "FuncRef getHandler(){\r\n    return json.get(\"handler\") == null ? null : new FuncRef((JsonObject) json.get(\"handler\"));\r\n}"
}, {
	"Path": "io.flutter.dart.DartSyntax.findEnclosingFunctionCall",
	"Comment": "finds the enclosing function call where the function being called has the given name.returns null if not found.",
	"Method": "DartCallExpression findEnclosingFunctionCall(PsiElement elt,String functionName){\r\n    while (elt != null) {\r\n        if (elt instanceof DartCallExpression) {\r\n            final DartCallExpression call = (DartCallExpression) elt;\r\n            final String name = getCalledFunctionName(call);\r\n            if (name != null && name.equals(functionName)) {\r\n                return call;\r\n            }\r\n        }\r\n        elt = elt.getParent();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.FirebaseFirestore.getApp",
	"Comment": "returns the firebaseapp instance to which this firebasefirestore belongs.",
	"Method": "FirebaseApp getApp(){\r\n    return firebaseApp;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.spec.SpecTestCase.initClient",
	"Comment": "sets up a new client. is used to initially setup the client initially and after every restart.",
	"Method": "void initClient(){\r\n    localPersistence = getPersistence(garbageCollectionEnabled);\r\n    LocalStore localStore = new LocalStore(localPersistence, currentUser);\r\n    queue = new AsyncQueue();\r\n    datastore = new MockDatastore(queue, RuntimeEnvironment.application);\r\n    remoteStore = new RemoteStore(this, localStore, datastore, queue);\r\n    syncEngine = new SyncEngine(localStore, remoteStore, currentUser);\r\n    eventManager = new EventManager(syncEngine);\r\n    localStore.start();\r\n    remoteStore.start();\r\n}"
}, {
	"Path": "com.almasb.fxgl.entity.Entity.setOnNotActive",
	"Comment": "set a callback for when entity is removed from world.the callback will not be executed if entity is already removed from the world.",
	"Method": "void setOnNotActive(Runnable action){\r\n    onNotActive = action;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.ReferenceSet.referencesForId",
	"Comment": "returns all of the document keys that have had references added for the given id.",
	"Method": "ImmutableSortedSet<DocumentKey> referencesForId(int target){\r\n    DocumentKey emptyKey = DocumentKey.empty();\r\n    DocumentReference startRef = new DocumentReference(emptyKey, target);\r\n    Iterator<DocumentReference> iterator = referencesByTarget.iteratorFrom(startRef);\r\n    ImmutableSortedSet<DocumentKey> keys = DocumentKey.emptyKeySet();\r\n    while (iterator.hasNext()) {\r\n        DocumentReference reference = iterator.next();\r\n        if (reference.getId() == target) {\r\n            keys = keys.insert(reference.getKey());\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    return keys;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.PersistenceTestHelpers.createEagerGCMemoryPersistence",
	"Comment": "creates and starts a new memorypersistence instance for testing.",
	"Method": "MemoryPersistence createEagerGCMemoryPersistence(){\r\n    MemoryPersistence persistence = MemoryPersistence.createEagerGcMemoryPersistence();\r\n    persistence.start();\r\n    return persistence;\r\n}"
}, {
	"Path": "com.google.firebase.storage.StorageTask.addOnProgressListener",
	"Comment": "adds a listener that is called periodically while the controllabletask executes.",
	"Method": "StorageTask<TResult> addOnProgressListener(OnProgressListener<? super TResult> listener,StorageTask<TResult> addOnProgressListener,Executor executor,OnProgressListener<? super TResult> listener,StorageTask<TResult> addOnProgressListener,Activity activity,OnProgressListener<? super TResult> listener){\r\n    Preconditions.checkNotNull(listener);\r\n    Preconditions.checkNotNull(activity);\r\n    progressManager.addListener(activity, null, listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.TargetState.hasChanges",
	"Comment": "whether we have modified any state that should trigger a snapshot.",
	"Method": "boolean hasChanges(){\r\n    return hasChanges;\r\n}"
}, {
	"Path": "com.google.firebase.auth.GetTokenResult.getIssuedAtTimestamp",
	"Comment": "returns the issued at timestamp in milliseconds since epoch. this is the time the id token waslast refreshed and not the authentication timestamp.",
	"Method": "long getIssuedAtTimestamp(){\r\n    return getLongFromClaimsSafely(ISSUED_AT_TIMESTAMP);\r\n}"
}, {
	"Path": "org.fluentlenium.core.action.FillSelect.withText",
	"Comment": "select all options that display text matching the argument for the select element.",
	"Method": "FillSelect withText(String text){\r\n    FluentList<E> elements = getElements();\r\n    if (elements.size() == 0) {\r\n        throw new NoSuchElementException(\"No select element found\");\r\n    }\r\n    for (FluentWebElement element : elements) {\r\n        Select select = new Select(element.getElement());\r\n        select.selectByVisibleText(text);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "io.flutter.inspector.DiagnosticsNode.getIsQuoted",
	"Comment": "whether the description is enclosed in double quotes.only relevant for string properties.",
	"Method": "boolean getIsQuoted(){\r\n    return getBooleanMember(\"quoted\", false);\r\n}"
}, {
	"Path": "io.flutter.run.test.TestFields.getTestFile",
	"Comment": "the dart file containing the tests to run, or null if we are running tests in a directory.",
	"Method": "String getTestFile(){\r\n    return testFile;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.ErrorObj.getException",
	"Comment": "if this error is due to an unhandled exception, this is the exception thrown.can return null.",
	"Method": "InstanceRef getException(){\r\n    return json.get(\"exception\") == null ? null : new InstanceRef((JsonObject) json.get(\"exception\"));\r\n}"
}, {
	"Path": "com.google.firebase.inappmessaging.display.FirebaseInAppMessagingDisplay.testMessage",
	"Comment": "method that can be used to test the appearance of an in app message",
	"Method": "void testMessage(Activity activity,InAppMessage inAppMessage,FirebaseInAppMessagingDisplayCallbacks callbacks){\r\n    this.inAppMessage = inAppMessage;\r\n    this.callbacks = callbacks;\r\n    showActiveFiam(activity);\r\n}"
}, {
	"Path": "com.google.firebase.FirebaseAppTest.createForwardingMockContext",
	"Comment": "returns mock context that forwards calls to targetcontext and localbroadcastmanager.",
	"Method": "Context createForwardingMockContext(){\r\n    final ContextWrapper applicationContextWrapper = new ContextWrapper(targetContext) {\r\n        @Override\r\n        public boolean isDeviceProtectedStorage() {\r\n            return isDeviceProtectedStorage.get();\r\n        }\r\n        @Override\r\n        public Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter) {\r\n            localBroadcastManager.registerReceiver(receiver, filter);\r\n            return null;\r\n        }\r\n        @Override\r\n        public void unregisterReceiver(BroadcastReceiver receiver) {\r\n            localBroadcastManager.unregisterReceiver(receiver);\r\n        }\r\n    };\r\n    ContextWrapper contextWrapper = new ContextWrapper(targetContext) {\r\n        @Override\r\n        public Context getApplicationContext() {\r\n            return applicationContextWrapper;\r\n        }\r\n    };\r\n    return contextWrapper;\r\n}"
}, {
	"Path": "com.google.firebase.FirebaseAppTest.createForwardingMockContext",
	"Comment": "returns mock context that forwards calls to targetcontext and localbroadcastmanager.",
	"Method": "Context createForwardingMockContext(){\r\n    return isDeviceProtectedStorage.get();\r\n}"
}, {
	"Path": "com.google.firebase.FirebaseAppTest.createForwardingMockContext",
	"Comment": "returns mock context that forwards calls to targetcontext and localbroadcastmanager.",
	"Method": "Context createForwardingMockContext(){\r\n    localBroadcastManager.registerReceiver(receiver, filter);\r\n    return null;\r\n}"
}, {
	"Path": "com.google.firebase.FirebaseAppTest.createForwardingMockContext",
	"Comment": "returns mock context that forwards calls to targetcontext and localbroadcastmanager.",
	"Method": "Context createForwardingMockContext(){\r\n    localBroadcastManager.unregisterReceiver(receiver);\r\n}"
}, {
	"Path": "com.google.firebase.FirebaseAppTest.createForwardingMockContext",
	"Comment": "returns mock context that forwards calls to targetcontext and localbroadcastmanager.",
	"Method": "Context createForwardingMockContext(){\r\n    return applicationContextWrapper;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Query.boundFromDocumentSnapshot",
	"Comment": "create a bound from a query given the document.note that the bound will always include the key of the document and so only the provideddocument will compare equal to the returned position.will throw if the document does not contain all fields of the order by of the query or ifany of the fields in the order by are an uncommitted server timestamp.",
	"Method": "Bound boundFromDocumentSnapshot(String methodName,DocumentSnapshot snapshot,boolean before){\r\n    checkNotNull(snapshot, \"Provided snapshot must not be null.\");\r\n    if (!snapshot.exists()) {\r\n        throw new IllegalArgumentException(\"Can't use a DocumentSnapshot for a document that doesn't exist for \" + methodName + \"().\");\r\n    }\r\n    Document document = snapshot.getDocument();\r\n    List<FieldValue> components = new ArrayList();\r\n    for (OrderBy orderBy : query.getOrderBy()) {\r\n        if (orderBy.getField().equals(com.google.firebase.firestore.model.FieldPath.KEY_PATH)) {\r\n            components.add(ReferenceValue.valueOf(firestore.getDatabaseId(), document.getKey()));\r\n        } else {\r\n            FieldValue value = document.getField(orderBy.getField());\r\n            if (value instanceof ServerTimestampValue) {\r\n                throw new IllegalArgumentException(\"Invalid query. You are trying to start or end a query using a document for which \" + \"the field '\" + orderBy.getField() + \"' is an uncommitted server timestamp. (Since the value of this field is \" + \"unknown, you cannot start/end a query with it.)\");\r\n            } else if (value != null) {\r\n                components.add(value);\r\n            } else {\r\n                throw new IllegalArgumentException(\"Invalid query. You are trying to start or end a query using a document for which \" + \"the field '\" + orderBy.getField() + \"' (used as the orderBy) does not exist.\");\r\n            }\r\n        }\r\n    }\r\n    return new Bound(components, before);\r\n}"
}, {
	"Path": "fr.pilato.elasticsearch.crawler.fs.client.ESVersion.fromString",
	"Comment": "returns the version given its string representation, current version if the argument is null or empty",
	"Method": "ESVersion fromString(String version){\r\n    String lVersion = version;\r\n    final boolean snapshot = lVersion.endsWith(\"-SNAPSHOT\");\r\n    if (snapshot) {\r\n        lVersion = lVersion.substring(0, lVersion.length() - 9);\r\n    }\r\n    String[] parts = lVersion.split(\"[.-]\");\r\n    if (parts.length < 3 || parts.length > 4) {\r\n        throw new IllegalArgumentException(\"the lVersion needs to contain major, minor, and revision, and optionally the build: \" + lVersion);\r\n    }\r\n    try {\r\n        final int rawMajor = Integer.parseInt(parts[0]);\r\n        if (rawMajor >= 5 && snapshot) {\r\n            throw new IllegalArgumentException(\"illegal lVersion format - snapshots are only supported until lVersion 2.x\");\r\n        }\r\n        final int betaOffset = rawMajor < 5 ? 0 : 25;\r\n        final int major = rawMajor * 1000000;\r\n        final int minor = Integer.parseInt(parts[1]) * 10000;\r\n        final int revision = Integer.parseInt(parts[2]) * 100;\r\n        int build = 99;\r\n        if (parts.length == 4) {\r\n            String buildStr = parts[3];\r\n            if (buildStr.startsWith(\"alpha\")) {\r\n                assert rawMajor >= 5 : \"major must be >= 5 but was \" + major;\r\n                build = Integer.parseInt(buildStr.substring(5));\r\n                assert build < 25 : \"expected a beta build but \" + build + \" >= 25\";\r\n            } else if (buildStr.startsWith(\"Beta\") || buildStr.startsWith(\"beta\")) {\r\n                build = betaOffset + Integer.parseInt(buildStr.substring(4));\r\n                assert build < 50 : \"expected a beta build but \" + build + \" >= 50\";\r\n            } else if (buildStr.startsWith(\"RC\") || buildStr.startsWith(\"rc\")) {\r\n                build = Integer.parseInt(buildStr.substring(2)) + 50;\r\n            } else {\r\n                throw new IllegalArgumentException(\"unable to parse lVersion \" + lVersion);\r\n            }\r\n        }\r\n        return new ESVersion(major + minor + revision + build);\r\n    } catch (NumberFormatException e) {\r\n        throw new IllegalArgumentException(\"unable to parse lVersion \" + lVersion, e);\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.auth.GetTokenResult.getExpirationTimestamp",
	"Comment": "returns the time in milliseconds since epoch at which this id token will expire",
	"Method": "long getExpirationTimestamp(){\r\n    return getLongFromClaimsSafely(EXPIRATION_TIMESTAMP);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.DocumentReference.addSnapshotListener",
	"Comment": "starts listening to the document referenced by this documentreference with the given options.",
	"Method": "ListenerRegistration addSnapshotListener(EventListener<DocumentSnapshot> listener,ListenerRegistration addSnapshotListener,Executor executor,EventListener<DocumentSnapshot> listener,ListenerRegistration addSnapshotListener,Activity activity,EventListener<DocumentSnapshot> listener,ListenerRegistration addSnapshotListener,MetadataChanges metadataChanges,EventListener<DocumentSnapshot> listener,ListenerRegistration addSnapshotListener,Executor executor,MetadataChanges metadataChanges,EventListener<DocumentSnapshot> listener,ListenerRegistration addSnapshotListener,Activity activity,MetadataChanges metadataChanges,EventListener<DocumentSnapshot> listener){\r\n    checkNotNull(activity, \"Provided activity must not be null.\");\r\n    checkNotNull(metadataChanges, \"Provided MetadataChanges value must not be null.\");\r\n    checkNotNull(listener, \"Provided EventListener must not be null.\");\r\n    return addSnapshotListenerInternal(Executors.DEFAULT_CALLBACK_EXECUTOR, internalOptions(metadataChanges), activity, listener);\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.AnnotationNavigateListener.getArgsFunction",
	"Comment": "get a function that retrieves argument value based on argument class.",
	"Method": "Function<Class<?>, Object> getArgsFunction(WebDriver driver){\r\n    return input -> {\r\n        if (input.isAssignableFrom(WebDriver.class)) {\r\n            return driver;\r\n        }\r\n        return null;\r\n    };\r\n}"
}, {
	"Path": "com.google.firebase.database.FirebaseDatabase.getInstance",
	"Comment": "gets a firebasedatabase instance for the specified url, using the specified firebaseapp.",
	"Method": "FirebaseDatabase getInstance(FirebaseDatabase getInstance,String url,FirebaseDatabase getInstance,FirebaseApp app,FirebaseDatabase getInstance,FirebaseApp app,String url){\r\n    if (TextUtils.isEmpty(url)) {\r\n        throw new DatabaseException(\"Failed to get FirebaseDatabase instance: Specify DatabaseURL within \" + \"FirebaseApp or from your getInstance() call.\");\r\n    }\r\n    Map<RepoInfo, FirebaseDatabase> instances = databaseInstances.get(app.getName());\r\n    if (instances == null) {\r\n        instances = new HashMap();\r\n        databaseInstances.put(app.getName(), instances);\r\n    }\r\n    ParsedUrl parsedUrl = Utilities.parseUrl(url);\r\n    if (!parsedUrl.path.isEmpty()) {\r\n        throw new DatabaseException(\"Specified Database URL '\" + url + \"' is invalid. It should point to the root of a \" + \"Firebase Database but it includes a path: \" + parsedUrl.path.toString());\r\n    }\r\n    FirebaseDatabase database = instances.get(parsedUrl.repoInfo);\r\n    if (database == null) {\r\n        DatabaseConfig config = new DatabaseConfig();\r\n        if (!app.isDefaultApp()) {\r\n            config.setSessionPersistenceKey(app.getName());\r\n        }\r\n        config.setFirebaseApp(app);\r\n        database = new FirebaseDatabase(app, parsedUrl.repoInfo, config);\r\n        instances.put(parsedUrl.repoInfo, database);\r\n    }\r\n    return database;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LruGarbageCollector.removeTargets",
	"Comment": "removes targets with a sequence number equal to or less than the given upper bound, and removesdocument associations with those targets.",
	"Method": "int removeTargets(long upperBound,SparseArray<?> activeTargetIds){\r\n    return delegate.removeTargets(upperBound, activeTargetIds);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.AsyncQueue.enqueue",
	"Comment": "queue and run this runnable task immediately after every other already queued task.",
	"Method": "Task<T> enqueue(Callable<T> task,Task<Void> enqueue,Runnable task){\r\n    return enqueue(() -> {\r\n        task.run();\r\n        return null;\r\n    });\r\n}"
}, {
	"Path": "org.fluentlenium.core.action.Fill.with",
	"Comment": "set the values params as text for the fluentlist or search a new list with the css selector and filters and add thevalues param on it",
	"Method": "Fill with(String textValues){\r\n    getElements().write(textValues);\r\n    return this;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.VmServiceBase.processMessage",
	"Comment": "process the response from the vm service and forward that response to the consumer associatedwith the response id.",
	"Method": "void processMessage(String jsonText){\r\n    if (jsonText == null || jsonText.isEmpty()) {\r\n        return;\r\n    }\r\n    JsonObject json;\r\n    try {\r\n        json = (JsonObject) new JsonParser().parse(jsonText);\r\n    } catch (Exception e) {\r\n        Logging.getLogger().logError(\"Parse message failed: \" + jsonText, e);\r\n        return;\r\n    }\r\n    if (json.has(\"method\")) {\r\n        if (!json.has(PARAMS)) {\r\n            final String message = \"Missing \" + PARAMS;\r\n            Logging.getLogger().logError(message);\r\n            final JsonObject response = new JsonObject();\r\n            response.addProperty(JSONRPC, JSONRPC_VERSION);\r\n            final JsonObject error = new JsonObject();\r\n            error.addProperty(CODE, INVALID_REQUEST);\r\n            error.addProperty(MESSAGE, message);\r\n            response.add(ERROR, error);\r\n            requestSink.add(response);\r\n            return;\r\n        }\r\n        if (json.has(\"id\")) {\r\n            processRequest(json);\r\n        } else {\r\n            processNotification(json);\r\n        }\r\n    } else if (json.has(\"result\") || json.has(\"error\")) {\r\n        processResponse(json);\r\n    } else {\r\n        Logging.getLogger().logError(\"Malformed message\");\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.database.core.view.CacheNode.isFiltered",
	"Comment": "returns whether this node is potentially missing children due to a filter applied to the node",
	"Method": "boolean isFiltered(){\r\n    return this.filtered;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.TargetChange.getRemovedDocuments",
	"Comment": "returns the set of documents that were removed from this target as part of this remote event.",
	"Method": "ImmutableSortedSet<DocumentKey> getRemovedDocuments(){\r\n    return removedDocuments;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Body.getWorldPoint",
	"Comment": "get the world coordinates of a point given the local coordinates.",
	"Method": "Vec2 getWorldPoint(Vec2 localPoint){\r\n    Vec2 v = new Vec2();\r\n    getWorldPointToOut(localPoint, v);\r\n    return v;\r\n}"
}, {
	"Path": "com.android.tools.idea.tests.gui.framework.fixture.IdeaFrameFixture.waitAndInvokeMenuPath",
	"Comment": "wait till an path is enabled then invokes the action. used for menu options that might be disabled or not available at first",
	"Method": "IdeaFrameFixture waitAndInvokeMenuPath(String path){\r\n    Wait.seconds(10).expecting(\"Wait until the path \" + Arrays.toString(path) + \" is ready.\").until(() -> getMenuFixture().isMenuPathEnabled(path));\r\n    getMenuFixture().invokeMenuPath(path);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.DocumentChange.getDocument",
	"Comment": "returns the newly added or modified document if this documentchange is for an updated document.returns the deleted document if this document change represents a removal.",
	"Method": "QueryDocumentSnapshot getDocument(){\r\n    return document;\r\n}"
}, {
	"Path": "io.flutter.bazel.Workspace.getDependencies",
	"Comment": "returns relative paths to the files within the workspace that it depends on.when they change, the workspace should be reloaded.",
	"Method": "Set<String> getDependencies(){\r\n    return ImmutableSet.of(\"WORKSPACE\", PLUGIN_CONFIG_PATH);\r\n}"
}, {
	"Path": "com.almasb.fxgl.ai.btree.Task.cancelRunningChildren",
	"Comment": "terminates the running children of this task starting from the specified index up to the end.",
	"Method": "void cancelRunningChildren(int startIndex){\r\n    for (int i = startIndex, n = getChildCount(); i < n; i++) {\r\n        Task<E> child = getChild(i);\r\n        if (child.status == Status.RUNNING)\r\n            child.cancel();\r\n    }\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.AnnotationScriptListener.getArgsFunction",
	"Comment": "get a function that retrieves argument value based on argument class.",
	"Method": "Function<Class<?>, Object> getArgsFunction(String script,WebDriver driver){\r\n    return input -> {\r\n        if (input.isAssignableFrom(String.class)) {\r\n            return script;\r\n        }\r\n        if (input.isAssignableFrom(WebDriver.class)) {\r\n            return driver;\r\n        }\r\n        return null;\r\n    };\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.Array.removeAll",
	"Comment": "removes from this array all of elements contained in the specified array.",
	"Method": "boolean removeAll(Array<? extends T> array,boolean identity){\r\n    int size = this.size;\r\n    int startSize = size;\r\n    T[] items = this.items;\r\n    if (identity) {\r\n        for (int i = 0, n = array.size; i < n; i++) {\r\n            T item = array.get(i);\r\n            for (int ii = 0; ii < size; ii++) {\r\n                if (item == items[ii]) {\r\n                    removeIndex(ii);\r\n                    size--;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = 0, n = array.size; i < n; i++) {\r\n            T item = array.get(i);\r\n            for (int ii = 0; ii < size; ii++) {\r\n                if (item.equals(items[ii])) {\r\n                    removeIndex(ii);\r\n                    size--;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return size != startSize;\r\n}"
}, {
	"Path": "com.vladmihalcea.flexypool.metric.MetricsFactoryResolver.resolve",
	"Comment": "resolve metricsfactory from the service provider interface configuration",
	"Method": "MetricsFactory resolve(){\r\n    for (MetricsFactoryService metricsFactoryService : serviceLoader) {\r\n        MetricsFactory metricsFactory = metricsFactoryService.load();\r\n        if (metricsFactory != null) {\r\n            return metricsFactory;\r\n        }\r\n    }\r\n    throw new IllegalStateException(\"No MetricsFactory could be loaded!\");\r\n}"
}, {
	"Path": "org.inferred.freebuilder.processor.util.testing.Model.jvmDebugging",
	"Comment": "returns true if the jvm is likely to be being debugged, so we can adjust timeouts.",
	"Method": "boolean jvmDebugging(){\r\n    return ManagementFactory.getRuntimeMXBean().getInputArguments().toString().contains(\"-agentlib:jdwp\");\r\n}"
}, {
	"Path": "io.flutter.utils.Refreshable.close",
	"Comment": "asynchronously shuts down the refreshable.sets the published value to null and cancels any background tasks.also sets the state to closed and notifies subscribers. removes subscribers after delivering the last event.",
	"Method": "void close(boolean close){\r\n    if (!publisher.close()) {\r\n        return;\r\n    }\r\n    schedule.reschedule(null);\r\n    Disposer.dispose(disposeNode);\r\n}"
}, {
	"Path": "io.flutter.view.MultiIconSimpleColoredComponent.findFragmentAt",
	"Comment": "returns the index of text fragment at the specified x offset.",
	"Method": "int findFragmentAt(int x){\r\n    float curX = myIpad.left;\r\n    if (myBorder != null) {\r\n        curX += myBorder.getBorderInsets(this).left;\r\n    }\r\n    curX += computeTextAlignShift();\r\n    Font font = getBaseFont();\r\n    int baseSize = font.getSize();\r\n    boolean wasSmaller = false;\r\n    int i = 0;\r\n    int iconIndex = 0;\r\n    while (true) {\r\n        while (iconIndex < myIcons.size() && myIcons.get(iconIndex).index <= i) {\r\n            final int iconWidth = myIcons.get(iconIndex).icon.getIconWidth() + myIconTextGap * 2;\r\n            if (x >= curX && x < curX + iconWidth) {\r\n                return FRAGMENT_ICON - iconIndex;\r\n            }\r\n            curX += iconWidth;\r\n            iconIndex++;\r\n        }\r\n        if (i >= myAttributes.size()) {\r\n            break;\r\n        }\r\n        SimpleTextAttributes attributes = myAttributes.get(i);\r\n        boolean isSmaller = attributes.isSmaller();\r\n        if (font.getStyle() != attributes.getFontStyle() || isSmaller != wasSmaller) {\r\n            font = font.deriveFont(attributes.getFontStyle(), isSmaller ? UIUtil.getFontSize(UIUtil.FontSize.SMALL) : baseSize);\r\n        }\r\n        wasSmaller = isSmaller;\r\n        final float curWidth = computeStringWidth(i, font);\r\n        if (x >= curX && x < curX + curWidth) {\r\n            return i;\r\n        }\r\n        curX += curWidth;\r\n        final int fragmentPadding = myFragmentPadding.get(i);\r\n        if (fragmentPadding > 0 && curX < fragmentPadding) {\r\n            curX = fragmentPadding;\r\n        }\r\n        i++;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.google.firebase.storage.StorageTask.pause",
	"Comment": "attempts to pause the task. a paused task can later be resumed.",
	"Method": "boolean pause(){\r\n    return tryChangeState(new int[] { INTERNAL_STATE_PAUSED, INTERNAL_STATE_PAUSING }, true);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.MutationQueueTestCase.batchCount",
	"Comment": "returns the number of mutation batches in the mutation queue.",
	"Method": "int batchCount(){\r\n    return mutationQueue.getAllMutationBatches().size();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Query.startAfter",
	"Comment": "creates and returns a new query that starts after the provided fields relative to the order ofthe query. the order of the field values must match the order of the order by clauses of thequery.",
	"Method": "Query startAfter(DocumentSnapshot snapshot,Query startAfter,Object fieldValues){\r\n    Bound bound = boundFromFields(\"startAfter\", fieldValues, false);\r\n    return new Query(query.startAt(bound), firestore);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.Query.matchesOrderBy",
	"Comment": "a document must have a value for every ordering clause in order to show up in the results.",
	"Method": "boolean matchesOrderBy(Document doc){\r\n    for (OrderBy order : explicitSortOrder) {\r\n        if (!order.getField().equals(FieldPath.KEY_PATH) && (doc.getField(order.field) == null)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "io.flutter.sdk.FlutterSdk.getFlutterSdk",
	"Comment": "return the fluttersdk for the given project.returns null if the dart sdk is not set or does not exist.",
	"Method": "FlutterSdk getFlutterSdk(Project project){\r\n    if (project.isDisposed()) {\r\n        return null;\r\n    }\r\n    final DartSdk dartSdk = DartPlugin.getDartSdk(project);\r\n    if (dartSdk == null) {\r\n        return null;\r\n    }\r\n    final String dartPath = dartSdk.getHomePath();\r\n    if (!dartPath.endsWith(DART_SDK_SUFFIX)) {\r\n        return null;\r\n    }\r\n    final String sdkPath = dartPath.substring(0, dartPath.length() - DART_SDK_SUFFIX.length());\r\n    final String cacheKey = project.getLocationHash() + \":\" + sdkPath;\r\n    return projectSdkCache.computeIfAbsent(cacheKey, s -> forPath(sdkPath));\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.WatchChangeAggregator.getCurrentDocumentCountForTarget",
	"Comment": "returns the current count of documents in the target. this includes both the number ofdocuments that the localstore considers to be part of the target as well as any accumulatedchanges.",
	"Method": "int getCurrentDocumentCountForTarget(int targetId){\r\n    TargetState targetState = ensureTargetState(targetId);\r\n    TargetChange targetChange = targetState.toTargetChange();\r\n    return (targetMetadataProvider.getRemoteKeysForTarget(targetId).size() + targetChange.getAddedDocuments().size() - targetChange.getRemovedDocuments().size());\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.mutation.Precondition.updateTime",
	"Comment": "creates a new precondition based on a version a document exists at.",
	"Method": "Precondition updateTime(SnapshotVersion version){\r\n    return new Precondition(version, null);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.PhysicsWorld.initContactListener",
	"Comment": "registers contact listener to jbox2d world so that collisions areregistered for subsequent notification.only collidable entities are checked.",
	"Method": "void initContactListener(){\r\n    jboxWorld.setContactListener(this);\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.IntArray.removeAll",
	"Comment": "removes from this array all of elements contained in the specified array.",
	"Method": "boolean removeAll(IntArray array){\r\n    int size = this.size;\r\n    int startSize = size;\r\n    int[] items = this.items;\r\n    for (int i = 0, n = array.size; i < n; i++) {\r\n        int item = array.get(i);\r\n        for (int ii = 0; ii < size; ii++) {\r\n            if (item == items[ii]) {\r\n                removeIndex(ii);\r\n                size--;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return size != startSize;\r\n}"
}, {
	"Path": "com.vladmihalcea.flexypool.connection.ConnectionProxyFactory.newInstance",
	"Comment": "creates a connectionproxy for the specified target and attaching thefollowing callback.",
	"Method": "Connection newInstance(Connection target,ConnectionPoolCallback connectionPoolCallback){\r\n    return proxyConnection(target, new ConnectionCallback(connectionPoolCallback));\r\n}"
}, {
	"Path": "com.google.firebase.database.android.SqlPersistenceStorageEngine.saveNested",
	"Comment": "this method saves a node into the database. if a children node is above the split threshold,every child will be saved separately. the child might be split again. this method returns thenumber of rows saved to the database.",
	"Method": "int saveNested(Path path,Node node){\r\n    long estimatedSize = NodeSizeEstimator.estimateSerializedNodeSize(node);\r\n    if (node instanceof ChildrenNode && estimatedSize > CHILDREN_NODE_SPLIT_SIZE_THRESHOLD) {\r\n        if (logger.logsDebug()) {\r\n            logger.debug(String.format(\"Node estimated serialized size at path %s of %d bytes exceeds limit of %d bytes. \" + \"Splitting up.\", path, estimatedSize, CHILDREN_NODE_SPLIT_SIZE_THRESHOLD));\r\n        }\r\n        int sum = 0;\r\n        for (NamedNode child : node) {\r\n            sum += saveNested(path.child(child.getName()), child.getNode());\r\n        }\r\n        if (!node.getPriority().isEmpty()) {\r\n            saveNode(path.child(ChildKey.getPriorityKey()), node.getPriority());\r\n            sum++;\r\n        }\r\n        saveNode(path, EmptyNode.Empty());\r\n        sum++;\r\n        return sum;\r\n    } else {\r\n        saveNode(path, node);\r\n        return 1;\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.QuerySnapshot.toObjects",
	"Comment": "returns the contents of the documents in the querysnapshot, converted to the provided class, asa list.",
	"Method": "List<T> toObjects(Class<T> clazz,List<T> toObjects,Class<T> clazz,DocumentSnapshot.ServerTimestampBehavior serverTimestampBehavior){\r\n    checkNotNull(clazz, \"Provided POJO type must not be null.\");\r\n    List<T> res = new ArrayList();\r\n    for (DocumentSnapshot d : this) {\r\n        res.add(d.toObject(clazz, serverTimestampBehavior));\r\n    }\r\n    return res;\r\n}"
}, {
	"Path": "com.almasb.fxgl.particle.ParticleEmitter.setVelocityFunction",
	"Comment": "set initial velocity function. particles when spawned will use the functionto obtain initial velocity.",
	"Method": "void setVelocityFunction(Function<Integer, Point2D> velocityFunction){\r\n    this.velocityFunction = velocityFunction;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.SQLiteSchema.ensureSequenceNumbers",
	"Comment": "ensures that each entry in the remote document cache has a corresponding sentinel row. anyentries that lack a sentinel row are given one with the sequence number set to the highestrecorded sequence number from the target metadata.",
	"Method": "void ensureSequenceNumbers(){\r\n    SQLitePersistence.Query sequenceNumberQuery = new SQLitePersistence.Query(db, \"SELECT highest_listen_sequence_number FROM target_globals LIMIT 1\");\r\n    Long boxedSequenceNumber = sequenceNumberQuery.firstValue(c -> c.getLong(0));\r\n    hardAssert(boxedSequenceNumber != null, \"Missing highest sequence number\");\r\n    long sequenceNumber = boxedSequenceNumber;\r\n    SQLiteStatement tagDocument = db.compileStatement(\"INSERT INTO target_documents (target_id, path, sequence_number) VALUES (0, ?, ?)\");\r\n    SQLitePersistence.Query untaggedDocumentsQuery = new SQLitePersistence.Query(db, \"SELECT RD.path FROM remote_documents AS RD WHERE NOT EXISTS (SELECT TD.path FROM target_documents AS TD WHERE RD.path = TD.path AND TD.target_id = 0)\");\r\n    untaggedDocumentsQuery.forEach(row -> {\r\n        tagDocument.clearBindings();\r\n        tagDocument.bindString(1, row.getString(0));\r\n        tagDocument.bindLong(2, sequenceNumber);\r\n        hardAssert(tagDocument.executeInsert() != -1, \"Failed to insert a sentinel row\");\r\n    });\r\n}"
}, {
	"Path": "com.google.firebase.storage.FirebaseStorage.setMaxOperationRetryTimeMillis",
	"Comment": "sets the maximum time to retry operations other than upload and download if a failure occurs.",
	"Method": "void setMaxOperationRetryTimeMillis(long maxTransferRetryMillis){\r\n    sMaxQueryRetry = maxTransferRetryMillis;\r\n}"
}, {
	"Path": "com.google.firebase.storage.StorageReference.getPath",
	"Comment": "returns the full path to this object, not including the google cloud storage bucket.",
	"Method": "String getPath(){\r\n    String path = mStorageUri.getPath();\r\n    assert path != null;\r\n    return path;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.joints.DistanceJointDef.initialize",
	"Comment": "initialize the bodies, anchors, and length using the world anchors.",
	"Method": "void initialize(Body b1,Body b2,Vec2 anchor1,Vec2 anchor2){\r\n    bodyA = b1;\r\n    bodyB = b2;\r\n    localAnchorA.set(bodyA.getLocalPoint(anchor1));\r\n    localAnchorB.set(bodyB.getLocalPoint(anchor2));\r\n    Vec2 d = anchor2.sub(anchor1);\r\n    length = d.length();\r\n}"
}, {
	"Path": "io.flutter.android.IntelliJAndroidSdk.chooseAndroidHome",
	"Comment": "returns the best value of the android sdk location to use, including possibly querying flutter tools for it.",
	"Method": "String chooseAndroidHome(Project project,boolean askFlutterTools){\r\n    if (project == null) {\r\n        return EnvironmentUtil.getValue(\"ANDROID_HOME\");\r\n    }\r\n    final IntelliJAndroidSdk intelliJAndroidSdk = fromProject(project);\r\n    if (intelliJAndroidSdk != null) {\r\n        return intelliJAndroidSdk.getHome().getPath();\r\n    }\r\n    if (askFlutterTools) {\r\n        final FlutterSdk flutterSdk = FlutterSdk.getFlutterSdk(project);\r\n        if (flutterSdk != null) {\r\n            final String androidSdkLocation = flutterSdk.queryFlutterConfig(\"android-sdk\", true);\r\n            if (androidSdkLocation != null) {\r\n                return androidSdkLocation;\r\n            }\r\n        }\r\n    }\r\n    return EnvironmentUtil.getValue(\"ANDROID_HOME\");\r\n}"
}, {
	"Path": "com.google.firebase.Timestamp.now",
	"Comment": "creates a new timestamp with the current date, with millisecond precision.",
	"Method": "Timestamp now(){\r\n    return new Timestamp(new Date());\r\n}"
}, {
	"Path": "org.dartlang.analysis.server.protocol.FlutterOutline.getClassName",
	"Comment": "if the node creates a new class instance, or a reference to an instance, this field has the nameof the class.",
	"Method": "String getClassName(){\r\n    return className;\r\n}"
}, {
	"Path": "io.flutter.inspector.DiagnosticsNode.getValues",
	"Comment": "value as a list of strings.the raw value can always be extracted with the regular observatory protocol.only applies to iterableproperty.",
	"Method": "ArrayList<String> getValues(){\r\n    if (!json.has(\"values\")) {\r\n        return null;\r\n    }\r\n    final JsonArray rawValues = json.getAsJsonArray(\"values\");\r\n    final ArrayList<String> values = new ArrayList(rawValues.size());\r\n    for (int i = 0; i < rawValues.size(); ++i) {\r\n        values.add(rawValues.get(i).getAsString());\r\n    }\r\n    return values;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LocalStoreTestCase.assertContains",
	"Comment": "asserts that the given local store contains the given document.",
	"Method": "void assertContains(MaybeDocument expected){\r\n    MaybeDocument actual = localStore.readDocument(expected.getKey());\r\n    assertEquals(expected, actual);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Body.applyTorque",
	"Comment": "apply a torque.this affects the angular velocity without affecting the linear velocity of the center of mass.this wakes up the body.",
	"Method": "void applyTorque(float torque){\r\n    if (type != BodyType.DYNAMIC) {\r\n        return;\r\n    }\r\n    if (!isAwake()) {\r\n        setAwake(true);\r\n    }\r\n    m_torque += torque;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.SourceReportCoverage.getHits",
	"Comment": "a list of token positions in a sourcereportrange which have been executed.the list issorted.",
	"Method": "List<Integer> getHits(){\r\n    return getListInt(\"hits\");\r\n}"
}, {
	"Path": "com.vladsch.flexmark.internal.DocumentParser.incorporateLine",
	"Comment": "analyze a line of text and update the document appropriately. we parse markdown text by calling this on eachline of input, then finalizing the document.",
	"Method": "void incorporateLine(BasedSequence ln){\r\n    line = ln;\r\n    index = 0;\r\n    column = 0;\r\n    columnIsInTab = false;\r\n    if (trackDocumentLines)\r\n        lineSegments.add(lineWithEOL);\r\n    int matches = 1;\r\n    Block blankLine = null;\r\n    if (blankLinesInAst) {\r\n        findNextNonSpace();\r\n        if (blank) {\r\n            blankLine = new BlankLine(lineWithEOL);\r\n            documentBlockParser.getBlock().appendChild(blankLine);\r\n        }\r\n    }\r\n    for (BlockParser blockParser : activeBlockParsers.subList(1, activeBlockParsers.size())) {\r\n        findNextNonSpace();\r\n        if (blankLinesInAst) {\r\n            if (blank && blankLine == null) {\r\n                blankLine = new BlankLine(lineWithEOL);\r\n                documentBlockParser.getBlock().appendChild(blankLine);\r\n            }\r\n        }\r\n        BlockContinue result = blockParser.tryContinue(this);\r\n        if (result instanceof BlockContinueImpl) {\r\n            BlockContinueImpl blockContinue = (BlockContinueImpl) result;\r\n            if (blockContinue.isFinalize()) {\r\n                finalize(blockParser);\r\n                return;\r\n            } else {\r\n                if (blockContinue.getNewIndex() != -1) {\r\n                    setNewIndex(blockContinue.getNewIndex());\r\n                } else if (blockContinue.getNewColumn() != -1) {\r\n                    setNewColumn(blockContinue.getNewColumn());\r\n                }\r\n                matches++;\r\n                if (blankLine != null) {\r\n                    if (blockParser.getBlock() instanceof BlankLineContainer) {\r\n                        blankLine.unlink();\r\n                        blockParser.getBlock().appendChild(blankLine);\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    List<BlockParser> unmatchedBlockParsers = new ArrayList<BlockParser>(activeBlockParsers.subList(matches, activeBlockParsers.size()));\r\n    BlockParser lastMatchedBlockParser = activeBlockParsers.get(matches - 1);\r\n    BlockParser blockParser = lastMatchedBlockParser;\r\n    boolean allClosed = unmatchedBlockParsers.isEmpty();\r\n    if (blank && isLastLineBlank(blockParser.getBlock())) {\r\n        List<BlockParser> matchedBlockParsers = new ArrayList<BlockParser>(activeBlockParsers.subList(0, matches));\r\n        breakOutOfLists(matchedBlockParsers);\r\n    }\r\n    boolean tryBlockStarts = blockParser.isInterruptible() || blockParser.isContainer();\r\n    while (tryBlockStarts) {\r\n        findNextNonSpace();\r\n        if (blank || (indent < myParsing.CODE_BLOCK_INDENT && Parsing.isLetter(line, nextNonSpace))) {\r\n            setNewIndex(nextNonSpace);\r\n            break;\r\n        }\r\n        BlockStartImpl blockStart = findBlockStart(blockParser);\r\n        if (blockStart == null) {\r\n            if (!(blockParser.isRawText() && blockParser.isInterruptible()))\r\n                setNewIndex(nextNonSpace);\r\n            break;\r\n        }\r\n        if (!allClosed) {\r\n            finalizeBlocks(unmatchedBlockParsers);\r\n            allClosed = true;\r\n        }\r\n        if (blockStart.getNewIndex() != -1) {\r\n            setNewIndex(blockStart.getNewIndex());\r\n        } else if (blockStart.getNewColumn() != -1) {\r\n            setNewColumn(blockStart.getNewColumn());\r\n        }\r\n        if (blockStart.isReplaceActiveBlockParser()) {\r\n            removeActiveBlockParser();\r\n        }\r\n        for (BlockParser newBlockParser : blockStart.getBlockParsers()) {\r\n            blockParser = addChild(newBlockParser);\r\n            tryBlockStarts = newBlockParser.isContainer();\r\n        }\r\n    }\r\n    if (!allClosed && !blank && getActiveBlockParser().isParagraphParser()) {\r\n        addLine();\r\n    } else {\r\n        if (!allClosed) {\r\n            finalizeBlocks(unmatchedBlockParsers);\r\n        }\r\n        propagateLastLineBlank(blockParser, lastMatchedBlockParser);\r\n        if (!blockParser.isContainer()) {\r\n            addLine();\r\n        } else if (!blank) {\r\n            addChild(new ParagraphParser());\r\n            addLine();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.Array.removeValueByEquality",
	"Comment": "removes the first instance of the specified value in the array.",
	"Method": "boolean removeValueByEquality(T value){\r\n    return removeValue(value, false);\r\n}"
}, {
	"Path": "io.flutter.inspector.DiagnosticsNode.getValueRef",
	"Comment": "returns a reference to the value the diagnosticsnode object is describing.",
	"Method": "InspectorInstanceRef getValueRef(){\r\n    final JsonElement valueId = json.get(\"valueId\");\r\n    return new InspectorInstanceRef(valueId.isJsonNull() ? null : valueId.getAsString());\r\n}"
}, {
	"Path": "io.flutter.pub.PubRoot.hasTests",
	"Comment": "returns true if the given file is a directory that contains tests.",
	"Method": "boolean hasTests(VirtualFile dir){\r\n    if (!dir.isDirectory())\r\n        return false;\r\n    if (getRoot().equals(dir))\r\n        return true;\r\n    final VirtualFile wanted = getTestDir();\r\n    if (wanted == null)\r\n        return false;\r\n    while (dir != null) {\r\n        if (wanted.equals(dir))\r\n            return true;\r\n        dir = dir.getParent();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.fluentlenium.core.filter.MatcherConstructor.notStartsWith",
	"Comment": "create a matcher filtering by a string that not starts with the string params",
	"Method": "AbstractMatcher notStartsWith(String matcher,AbstractMatcher notStartsWith,Pattern pattern){\r\n    return new NotStartsWithMatcher(pattern);\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.reflect.ClassReflection.isAssignableFrom",
	"Comment": "determines if the class or interface represented by first class parameter is either the same as, or is a superclass orsuperinterface of, the class or interface represented by the second class parameter.",
	"Method": "boolean isAssignableFrom(Class c1,Class c2){\r\n    return c1.isAssignableFrom(c2);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.World.setAutoClearForces",
	"Comment": "set flag to control automatic clearing of forces after each time step.",
	"Method": "void setAutoClearForces(boolean flag){\r\n    autoClearForces = flag;\r\n}"
}, {
	"Path": "com.almasb.fxgl.extra.entity.components.RechargeableComponent.damagePercentageCurrent",
	"Comment": "damage component by given percentage. the percentage is calculated fromcurrent value.",
	"Method": "void damagePercentageCurrent(double value){\r\n    damage(value / 100 * getValue());\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Isolate.getPauseEvent",
	"Comment": "the last pause event delivered to the isolate. if the isolate is running, this will be aresume event.",
	"Method": "Event getPauseEvent(){\r\n    return new Event((JsonObject) json.get(\"pauseEvent\"));\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.SyncEngine.logErrorIfInteresting",
	"Comment": "logs the error as a warnings if it likely represents a developer mistake such as forgetting tocreate an index or permission denied.",
	"Method": "void logErrorIfInteresting(Status error,String contextString,Object contextArgs){\r\n    if (errorIsInteresting(error)) {\r\n        String context = String.format(contextString, contextArgs);\r\n        Logger.warn(\"Firestore\", \"%s: %s\", context, error);\r\n    }\r\n}"
}, {
	"Path": "io.flutter.preview.RenderHelper.getContainingWidgetOutline",
	"Comment": "return the outline for the widget class that is associated with the given offset.return null if there is no associated widget class outline.",
	"Method": "FlutterOutline getContainingWidgetOutline(int offset){\r\n    if (myFileOutline != null && myFileOutline.getChildren() != null) {\r\n        for (FlutterOutline outline : myFileOutline.getChildren()) {\r\n            final int outlineStart = getConvertedFileOffset(outline.getOffset());\r\n            final int outlineEnd = getConvertedFileOffset(outline.getOffset() + outline.getLength());\r\n            int stateStart = -1;\r\n            int stateEnd = -1;\r\n            if (outline.getStateOffset() != null && outline.getStateLength() != null) {\r\n                stateStart = getConvertedFileOffset(outline.getStateOffset());\r\n                stateEnd = getConvertedFileOffset(outline.getStateOffset() + outline.getStateLength());\r\n            }\r\n            if (outlineStart < offset && offset < outlineEnd || stateStart < offset && offset < stateEnd) {\r\n                if (outline.isWidgetClass()) {\r\n                    return outline;\r\n                } else {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.SQLiteLruReferenceDelegate.mutationQueuesContainKey",
	"Comment": "returns true if any mutation queue contains the given document.",
	"Method": "boolean mutationQueuesContainKey(DocumentKey key){\r\n    return !persistence.query(\"SELECT 1 FROM document_mutations WHERE path = ?\").binding(EncodedPath.encode(key.getPath())).isEmpty();\r\n}"
}, {
	"Path": "io.flutter.run.FlutterRunConfigurationProducer.isConfigurationFromContext",
	"Comment": "returns true if an existing sdkrunconfig points to the current dart file.",
	"Method": "boolean isConfigurationFromContext(SdkRunConfig configuration,ConfigurationContext context){\r\n    return hasDartFile(context, configuration.getFields().getFilePath());\r\n}"
}, {
	"Path": "fr.pilato.elasticsearch.crawler.fs.test.integration.AbstractITCase.copyTestDocumentsToTargetDir",
	"Comment": "copy test documents to the test dir so we will be able to run tests against them",
	"Method": "void copyTestDocumentsToTargetDir(Path target,String sourceDirName,String marker){\r\n    URL resource = AbstractFSCrawlerTestCase.class.getResource(marker);\r\n    switch(resource.getProtocol()) {\r\n        case \"file\":\r\n            {\r\n                Path finalTarget = target.resolve(sourceDirName);\r\n                if (Files.notExists(finalTarget)) {\r\n                    staticLogger.debug(\"  --> Creating test dir named [{}]\", finalTarget);\r\n                    Files.createDirectory(finalTarget);\r\n                }\r\n                Path source = Paths.get(resource.getPath()).getParent().resolve(sourceDirName);\r\n                if (Files.notExists(source)) {\r\n                    staticLogger.error(\"directory [{}] should be copied to [{}]\", source, target);\r\n                    throw new RuntimeException(source + \" doesn't seem to exist. Check your JUnit tests.\");\r\n                }\r\n                staticLogger.info(\"-> Copying test documents from [{}] to [{}]\", source, finalTarget);\r\n                copyDirs(source, finalTarget);\r\n                break;\r\n            }\r\n        case \"jar\":\r\n            {\r\n                if (Files.notExists(target)) {\r\n                    staticLogger.debug(\"  --> Creating test dir named [{}]\", target);\r\n                    Files.createDirectory(target);\r\n                }\r\n                String fileInJar = resource.getPath();\r\n                int i = fileInJar.indexOf(\"!/\");\r\n                String jarFile = fileInJar.substring(0, i);\r\n                staticLogger.info(\"-> Unzipping test documents from [{}] to [{}]\", jarFile, target);\r\n                unzip(jarFile, target);\r\n                break;\r\n            }\r\n        default:\r\n            fail(\"Unknown protocol for IT document sources: \" + resource.getProtocol());\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.fluentlenium.configuration.PropertiesBackendConfiguration.getPropertyImpl",
	"Comment": "get the property value used by underlying property storage.",
	"Method": "String getPropertyImpl(String propertyName){\r\n    return propertiesBackend.getProperty(propertyName);\r\n}"
}, {
	"Path": "org.dartlang.analysis.server.protocol.FlutterOutline.getChildren",
	"Comment": "the children of the node. the field will be omitted if the node has no children.",
	"Method": "List<FlutterOutline> getChildren(){\r\n    return children;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.World.setParticleDamping",
	"Comment": "damping is used to reduce the velocity of particles. the damping parameter can be larger than1.0f but the damping effect becomes sensitive to the time step when the damping parameter islarge.",
	"Method": "void setParticleDamping(float damping){\r\n    particleSystem.setParticleDamping(damping);\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Event.getTimelineEvents",
	"Comment": "an array of timelineeventsthis is provided for the timelineevents event.can return null.",
	"Method": "ElementList<TimelineEvent> getTimelineEvents(){\r\n    if (json.get(\"timelineEvents\") == null)\r\n        return null;\r\n    return new ElementList<TimelineEvent>(json.get(\"timelineEvents\").getAsJsonArray()) {\r\n        @Override\r\n        protected TimelineEvent basicGet(JsonArray array, int index) {\r\n            return new TimelineEvent(array.get(index).getAsJsonObject());\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Event.getTimelineEvents",
	"Comment": "an array of timelineeventsthis is provided for the timelineevents event.can return null.",
	"Method": "ElementList<TimelineEvent> getTimelineEvents(){\r\n    return new TimelineEvent(array.get(index).getAsJsonObject());\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.World.getParticleFlagsBuffer",
	"Comment": "get the particle data. returns the pointer to the head of the particle data.",
	"Method": "int[] getParticleFlagsBuffer(){\r\n    return particleSystem.getParticleFlagsBuffer();\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.UnresolvedSourceLocation.getLine",
	"Comment": "an approximate line number for the source location. this may change when the location isresolved.can return null.",
	"Method": "int getLine(){\r\n    return json.get(\"line\") == null ? -1 : json.get(\"line\").getAsInt();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Query.whereGreaterThan",
	"Comment": "creates and returns a new query with the additional filter that documents must contain thespecified field and the value should be greater than the specified value.",
	"Method": "Query whereGreaterThan(String field,Object value,Query whereGreaterThan,FieldPath fieldPath,Object value){\r\n    return whereHelper(fieldPath, Operator.GREATER_THAN, value);\r\n}"
}, {
	"Path": "com.google.firebase.storage.FirebaseStorage.getMaxDownloadRetryTimeMillis",
	"Comment": "returns the maximum time to retry a download if a failure occurs.",
	"Method": "long getMaxDownloadRetryTimeMillis(){\r\n    return sMaxDownloadRetry;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.ServerTimestampTest.writeInitialData",
	"Comment": "writes initialdata and waits for the corresponding snapshot.",
	"Method": "void writeInitialData(){\r\n    waitFor(docRef.set(initialData));\r\n    DocumentSnapshot initialDataSnap = accumulator.await();\r\n    assertEquals(initialData, initialDataSnap.getData());\r\n    initialDataSnap = accumulator.await();\r\n    assertEquals(initialData, initialDataSnap.getData());\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.IntArray.truncate",
	"Comment": "reduces the size of the array to the specified size. if the array is already smaller than the specified size, no action istaken.",
	"Method": "void truncate(int newSize){\r\n    if (size > newSize)\r\n        size = newSize;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LocalStore.executeQuery",
	"Comment": "runs the given query against all the documents in the local store and returns the results.",
	"Method": "ImmutableSortedMap<DocumentKey, Document> executeQuery(Query query){\r\n    return queryEngine.getDocumentsMatchingQuery(query);\r\n}"
}, {
	"Path": "com.google.firebase.database.DataSnapshot.hasChild",
	"Comment": "can be used to determine if this datasnapshot has data at a particular location",
	"Method": "boolean hasChild(String path){\r\n    if (query.getParent() == null) {\r\n        Validation.validateRootPathString(path);\r\n    } else {\r\n        Validation.validatePathString(path);\r\n    }\r\n    return !node.getNode().getChild(new Path(path)).isEmpty();\r\n}"
}, {
	"Path": "org.fluentlenium.core.domain.FluentWebElement.isInputOfTypeFile",
	"Comment": "this method return true if the current fluentwebelement is an input of type file",
	"Method": "boolean isInputOfTypeFile(){\r\n    return \"input\".equalsIgnoreCase(tagName()) && \"file\".equalsIgnoreCase(attribute(\"type\"));\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Field.getLocation",
	"Comment": "the location of this field in the source code.can return null.",
	"Method": "SourceLocation getLocation(){\r\n    return json.get(\"location\") == null ? null : new SourceLocation((JsonObject) json.get(\"location\"));\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.ClassObj.getFunctions",
	"Comment": "a list of functions in this class. does not include functions from superclasses.",
	"Method": "ElementList<FuncRef> getFunctions(){\r\n    return new ElementList<FuncRef>(json.get(\"functions\").getAsJsonArray()) {\r\n        @Override\r\n        protected FuncRef basicGet(JsonArray array, int index) {\r\n            return new FuncRef(array.get(index).getAsJsonObject());\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.ClassObj.getFunctions",
	"Comment": "a list of functions in this class. does not include functions from superclasses.",
	"Method": "ElementList<FuncRef> getFunctions(){\r\n    return new FuncRef(array.get(index).getAsJsonObject());\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.AsyncQueue.createAndScheduleDelayedTask",
	"Comment": "creates and returns a delayedtask that has been scheduled to be executed on the provided queueafter the provided delayms.",
	"Method": "DelayedTask createAndScheduleDelayedTask(TimerId timerId,long delayMs,Runnable task){\r\n    long targetTimeMs = System.currentTimeMillis() + delayMs;\r\n    DelayedTask delayedTask = new DelayedTask(timerId, targetTimeMs, task);\r\n    delayedTask.start(delayMs);\r\n    return delayedTask;\r\n}"
}, {
	"Path": "com.bartoszlipinski.flippablestackview.OrientedViewPager.canScroll",
	"Comment": "tests scrollability within child views of v given a delta of dx.",
	"Method": "boolean canScroll(View v,boolean checkV,int delta,int x,int y,boolean canScroll){\r\n    if (v instanceof ViewGroup) {\r\n        final ViewGroup group = (ViewGroup) v;\r\n        final int scrollX = v.getScrollX();\r\n        final int scrollY = v.getScrollY();\r\n        final int count = group.getChildCount();\r\n        for (int i = count - 1; i >= 0; i--) {\r\n            final View child = group.getChildAt(i);\r\n            if (mOrientation == Orientation.VERTICAL) {\r\n                if (y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && canScroll(child, true, delta, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {\r\n                    return true;\r\n                }\r\n            } else {\r\n                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop() && y + scrollY < child.getBottom() && canScroll(child, true, delta, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return checkV && ViewCompat.canScrollVertically(v, -delta);\r\n}"
}, {
	"Path": "com.google.firebase.components.Component.isAlwaysEager",
	"Comment": "returns whether a component is always eager.meaning that it will be instantiated upon application startup.",
	"Method": "boolean isAlwaysEager(){\r\n    return instantiation == Instantiation.ALWAYS_EAGER;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.TargetState.updateResumeToken",
	"Comment": "applies the resume token to the targetchange, but only when it has a new value. emptyresumetokens are discarded.",
	"Method": "void updateResumeToken(ByteString resumeToken){\r\n    if (!resumeToken.isEmpty()) {\r\n        hasChanges = true;\r\n        this.resumeToken = resumeToken;\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.testutil.IntegrationTestUtil.testFirestore",
	"Comment": "initializes a new firestore instance that can be used in testing. it is guaranteed to not sharestate with other instances returned from this call.",
	"Method": "FirebaseFirestore testFirestore(FirebaseFirestore testFirestore,FirebaseFirestoreSettings settings,FirebaseFirestore testFirestore,String projectId,Logger.Level logLevel,FirebaseFirestoreSettings settings){\r\n    Logger.setLogLevel(logLevel);\r\n    Persistence.INDEXING_SUPPORT_ENABLED = true;\r\n    Context context = InstrumentationRegistry.getContext();\r\n    DatabaseId databaseId = DatabaseId.forDatabase(projectId, DatabaseId.DEFAULT_DATABASE_ID);\r\n    String persistenceKey = \"db\" + firestoreStatus.size();\r\n    clearPersistence(context, databaseId, persistenceKey);\r\n    AsyncQueue asyncQueue = null;\r\n    try {\r\n        asyncQueue = new AsyncQueue();\r\n    } catch (Exception e) {\r\n        fail(\"Failed to initialize AsyncQueue:\" + e);\r\n    }\r\n    FirebaseFirestore firestore = AccessHelper.newFirebaseFirestore(context, databaseId, persistenceKey, new EmptyCredentialsProvider(), asyncQueue, null);\r\n    firestore.setFirestoreSettings(settings);\r\n    firestoreStatus.put(firestore, true);\r\n    return firestore;\r\n}"
}, {
	"Path": "com.google.firebase.database.DataSnapshot.getRef",
	"Comment": "used to obtain a reference to the source location for this snapshot.",
	"Method": "DatabaseReference getRef(){\r\n    return query;\r\n}"
}, {
	"Path": "io.flutter.run.daemon.DeviceService.chooseNextDaemon",
	"Comment": "returns the device daemon that should be running.starts it if needed. if null is returned then the previous daemon will be shut down.",
	"Method": "DeviceDaemon chooseNextDaemon(Refreshable.Request<DeviceDaemon> request){\r\n    final DeviceDaemon.Command nextCommand = DeviceDaemon.chooseCommand(project);\r\n    if (nextCommand == null) {\r\n        return null;\r\n    }\r\n    final DeviceDaemon previous = request.getPrevious();\r\n    if (previous != null && !previous.needRestart(nextCommand)) {\r\n        return previous;\r\n    }\r\n    try {\r\n        Thread.sleep(100);\r\n    } catch (InterruptedException e) {\r\n        return previous;\r\n    }\r\n    if (request.isCancelled()) {\r\n        return previous;\r\n    }\r\n    try {\r\n        return nextCommand.start(request::isCancelled, this::refreshDeviceSelection, this::daemonStopped);\r\n    } catch (ExecutionException e) {\r\n        LOG.error(e);\r\n        return previous;\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.database.DatabaseError.toException",
	"Comment": "can be used if a third party needs an exception from firebase database for integrationpurposes.",
	"Method": "DatabaseException toException(){\r\n    return new DatabaseException(\"Firebase Database error: \" + message);\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.beforeFindBy",
	"Comment": "add a listener that will be invoked before finding an element.",
	"Method": "EventsRegistry beforeFindBy(FindByListener listener){\r\n    beforeFindBy.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.WatchStream.watchQuery",
	"Comment": "registers interest in the results of the given query. if the query includes a resumetoken itwill be included in the request. results that affect the query will be streamed back aswatchchange messages that reference the targetid included in query.",
	"Method": "void watchQuery(QueryData queryData){\r\n    hardAssert(isOpen(), \"Watching queries requires an open stream\");\r\n    ListenRequest.Builder request = ListenRequest.newBuilder().setDatabase(serializer.databaseName()).setAddTarget(serializer.encodeTarget(queryData));\r\n    Map<String, String> labels = serializer.encodeListenRequestLabels(queryData);\r\n    if (labels != null) {\r\n        request.putAllLabels(labels);\r\n    }\r\n    writeRequest(request.build());\r\n}"
}, {
	"Path": "io.flutter.run.ObservatoryFile.createPositionMap",
	"Comment": "unpacks a position token table into a map from position id to position.see docs.",
	"Method": "TIntObjectHashMap<Position> createPositionMap(List<List<Integer>> table){\r\n    final TIntObjectHashMap<Position> result = new TIntObjectHashMap();\r\n    for (List<Integer> line : table) {\r\n        final Iterator<Integer> items = line.iterator();\r\n        final int lineNumber = Math.max(0, items.next() - 1);\r\n        while (items.hasNext()) {\r\n            final int tokenId = items.next();\r\n            final int column = Math.max(0, items.next() - 1);\r\n            result.put(tokenId, new Position(lineNumber, column));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.MockDatastore.activeTargets",
	"Comment": "returns the map of active targets on the watch stream, keyed by target id.",
	"Method": "Map<Integer, QueryData> activeTargets(){\r\n    return new HashMap(watchStream.activeTargets);\r\n}"
}, {
	"Path": "org.dartlang.analysis.server.protocol.FlutterOutline.getStateClassName",
	"Comment": "if the node is a statefulwidget, and its state class is defined in the same file, the name ofthe state class.",
	"Method": "String getStateClassName(){\r\n    return stateClassName;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.ClassObj.getError",
	"Comment": "the error which occurred during class finalization, if it exists.can return null.",
	"Method": "ErrorRef getError(){\r\n    return json.get(\"error\") == null ? null : new ErrorRef((JsonObject) json.get(\"error\"));\r\n}"
}, {
	"Path": "com.almasb.fxgl.extra.ui.Vignette.applyChanges",
	"Comment": "this must be called on any property change sincegradient is effectively immutable.",
	"Method": "void applyChanges(){\r\n    region.setFill(new RadialGradient(0, 0, region.getWidth() / 2, region.getHeight() / 2, radius, false, CycleMethod.NO_CYCLE, new Stop(0, Color.TRANSPARENT), new Stop(1, Color.color(color.getRed(), color.getGreen(), color.getBlue(), intensity))));\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.TimSort.ensureCapacity",
	"Comment": "ensures that the external array tmp has at least the specified number of elements, increasing its size if necessary. thesize increases exponentially to ensure amortized linear time complexity.",
	"Method": "T[] ensureCapacity(int minCapacity){\r\n    tmpCount = Math.max(tmpCount, minCapacity);\r\n    if (tmp.length < minCapacity) {\r\n        int newSize = minCapacity;\r\n        newSize |= newSize >> 1;\r\n        newSize |= newSize >> 2;\r\n        newSize |= newSize >> 4;\r\n        newSize |= newSize >> 8;\r\n        newSize |= newSize >> 16;\r\n        newSize++;\r\n        if (newSize < 0)\r\n            newSize = minCapacity;\r\n        else\r\n            newSize = Math.min(newSize, a.length >>> 1);\r\n        T[] newArray = (T[]) new Object[newSize];\r\n        tmp = newArray;\r\n    }\r\n    return tmp;\r\n}"
}, {
	"Path": "io.flutter.FlutterUtils.isXcodeProjectFileName",
	"Comment": "checks whether a given file name is an xcode project filename.",
	"Method": "boolean isXcodeProjectFileName(String name){\r\n    return name.endsWith(\".xcodeproj\");\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.Query.limit",
	"Comment": "returns a new query with the given limit on how many results can be returned.",
	"Method": "Query limit(long limit){\r\n    return new Query(path, filters, explicitSortOrder, limit, startAt, endAt);\r\n}"
}, {
	"Path": "io.flutter.actions.FlutterSdkAction.enableActionInBazelContext",
	"Comment": "by default this method returns false. for actions which can be used in the bazel context this method should return true.",
	"Method": "boolean enableActionInBazelContext(){\r\n    return false;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Query.whereHelper",
	"Comment": "creates and returns a new query with the additional filter that documents must contain thespecified field and the value should satisfy the relation constraint provided.",
	"Method": "Query whereHelper(FieldPath fieldPath,Operator op,Object value){\r\n    checkNotNull(fieldPath, \"Provided field path must not be null.\");\r\n    checkNotNull(op, \"Provided op must not be null.\");\r\n    FieldValue fieldValue;\r\n    com.google.firebase.firestore.model.FieldPath internalPath = fieldPath.getInternalPath();\r\n    if (internalPath.isKeyField()) {\r\n        if (op == Operator.ARRAY_CONTAINS) {\r\n            throw new IllegalArgumentException(\"Invalid query. You can't perform array-contains queries on FieldPath.documentId() \" + \"since document IDs are not arrays.\");\r\n        }\r\n        if (value instanceof String) {\r\n            String documentKey = (String) value;\r\n            if (documentKey.contains(\"/\")) {\r\n                throw new IllegalArgumentException(\"Invalid query. When querying with FieldPath.documentId() you must provide a valid \" + \"document ID, but '\" + documentKey + \"' contains a '/' character.\");\r\n            } else if (documentKey.isEmpty()) {\r\n                throw new IllegalArgumentException(\"Invalid query. When querying with FieldPath.documentId() you must provide a valid \" + \"document ID, but it was an empty string.\");\r\n            }\r\n            ResourcePath path = this.query.getPath().append(documentKey);\r\n            hardAssert(path.length() % 2 == 0, \"Path should be a document key\");\r\n            fieldValue = ReferenceValue.valueOf(this.getFirestore().getDatabaseId(), DocumentKey.fromPath(path));\r\n        } else if (value instanceof DocumentReference) {\r\n            DocumentReference ref = (DocumentReference) value;\r\n            fieldValue = ReferenceValue.valueOf(this.getFirestore().getDatabaseId(), ref.getKey());\r\n        } else {\r\n            throw new IllegalArgumentException(\"Invalid query. When querying with FieldPath.documentId() you must provide a valid \" + \"String or DocumentReference, but it was of type: \" + Util.typeName(value));\r\n        }\r\n    } else {\r\n        fieldValue = firestore.getDataConverter().parseQueryValue(value);\r\n    }\r\n    Filter filter = Filter.create(fieldPath.getInternalPath(), op, fieldValue);\r\n    validateNewFilter(filter);\r\n    return new Query(query.filter(filter), firestore);\r\n}"
}, {
	"Path": "io.flutter.preview.PreviewArea.show",
	"Comment": "rendering finished, the new outline and rendering information is available.show the rendered outlines.",
	"Method": "void show(FlutterOutline unitOutline,FlutterOutline widgetOutline,JsonObject renderObject){\r\n    isBeingRendered = false;\r\n    idToOutline.clear();\r\n    fillIdToOutline(unitOutline);\r\n    fillIdToRenderObject(renderObject);\r\n    primaryLayer.removeAll();\r\n    primaryLayer.setLayout(null);\r\n    final FlutterOutline rootOutline = idToOutline.get(rootWidgetId);\r\n    if (rootOutline == null) {\r\n        clear(NO_WIDGET_MESSAGE);\r\n        return;\r\n    }\r\n    final Element widgetClassElement = widgetOutline.getDartElement();\r\n    if (widgetClassElement != null) {\r\n        final String widgetClassName = widgetClassElement.getName();\r\n        final String stateClassName = widgetOutline.getStateClassName();\r\n        final String title = widgetClassName + (stateClassName != null ? \" > \" + stateClassName : \"\");\r\n        setToolbarTitle(title);\r\n    } else {\r\n        setToolbarTitle(null);\r\n    }\r\n    outlineToComponent.clear();\r\n    widgetIndex = 0;\r\n    renderWidgetOutline(rootOutline);\r\n    window.revalidate();\r\n    window.repaint();\r\n}"
}, {
	"Path": "org.inferred.freebuilder.processor.util.testing.TestBuilder.rootTestClassName",
	"Comment": "creates a unique test class name. once no longer referenced, it can subsequently be reused,to keep compiler errors and stack traces cleaner.",
	"Method": "String rootTestClassName(String originalClassName){\r\n    int periodIndex = originalClassName.lastIndexOf('.');\r\n    if (periodIndex != -1) {\r\n        return originalClassName.substring(0, periodIndex) + \".generatedcode\" + originalClassName.substring(periodIndex);\r\n    } else {\r\n        return \"com.example.test.generatedcode.Test\";\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.mutation.MutationBatch.applyToRemoteDocument",
	"Comment": "applies all the mutations in this mutationbatch to the specified document to create a newremote document.",
	"Method": "MaybeDocument applyToRemoteDocument(DocumentKey documentKey,MaybeDocument maybeDoc,MutationBatchResult batchResult){\r\n    if (maybeDoc != null) {\r\n        hardAssert(maybeDoc.getKey().equals(documentKey), \"applyToRemoteDocument: key %s doesn't match maybeDoc key %s\", documentKey, maybeDoc.getKey());\r\n    }\r\n    int size = mutations.size();\r\n    List<MutationResult> mutationResults = batchResult.getMutationResults();\r\n    hardAssert(mutationResults.size() == size, \"Mismatch between mutations length (%d) and results length (%d)\", size, mutationResults.size());\r\n    for (int i = 0; i < size; i++) {\r\n        Mutation mutation = mutations.get(i);\r\n        if (mutation.getKey().equals(documentKey)) {\r\n            MutationResult mutationResult = mutationResults.get(i);\r\n            maybeDoc = mutation.applyToRemoteDocument(maybeDoc, mutationResult);\r\n        }\r\n    }\r\n    return maybeDoc;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.Datastore.createWatchStream",
	"Comment": "creates a new watchstream that is still unstarted but uses a common shared channel",
	"Method": "WatchStream createWatchStream(WatchStream.Callback listener){\r\n    return new WatchStream(channel, workerQueue, serializer, listener);\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.SourceReportRange.getScriptIndex",
	"Comment": "an index into the script table of the sourcereport, indicating which script contains thisrange of code.",
	"Method": "int getScriptIndex(){\r\n    return json.get(\"scriptIndex\") == null ? -1 : json.get(\"scriptIndex\").getAsInt();\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.ObjRef.getId",
	"Comment": "a unique identifier for an object. passed to the getobject rpc to load this object.",
	"Method": "String getId(){\r\n    return json.get(\"id\").getAsString();\r\n}"
}, {
	"Path": "org.inferred.freebuilder.processor.util.testing.SharedBehaviorTesting.childrenInvoker",
	"Comment": "returns a statement that runs all children with compilations coalesced for performance.",
	"Method": "Statement childrenInvoker(RunNotifier notifier){\r\n    return new Statement() {\r\n        @Override\r\n        public void evaluate() throws Throwable {\r\n            runChildren(notifier);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.inferred.freebuilder.processor.util.testing.SharedBehaviorTesting.childrenInvoker",
	"Comment": "returns a statement that runs all children with compilations coalesced for performance.",
	"Method": "Statement childrenInvoker(RunNotifier notifier){\r\n    runChildren(notifier);\r\n}"
}, {
	"Path": "org.fluentlenium.core.FluentDriver.quit",
	"Comment": "quit the underlying web driver and release fluent driver resources.",
	"Method": "void quit(){\r\n    if (getDriver() != null) {\r\n        getDriver().quit();\r\n    }\r\n    releaseFluent();\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.World.getJointList",
	"Comment": "get the world joint list. with the returned joint, use joint.getnext to get the next joint inthe world list. a null joint indicates the end of the list.",
	"Method": "Joint getJointList(){\r\n    return m_jointList;\r\n}"
}, {
	"Path": "com.almasb.fxgl.ai.btree.BehaviorTree.addChildToTask",
	"Comment": "this method will add a child, namely the root, to this behavior tree.",
	"Method": "int addChildToTask(Task<E> child,int addChildToTask,Task<E> child){\r\n    if (this.rootTask != null)\r\n        throw new IllegalStateException(\"A behavior tree cannot have more than one root task\");\r\n    this.rootTask = child;\r\n    return 0;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.joints.PulleyJointDef.initialize",
	"Comment": "initialize the bodies, anchors, lengths, max lengths, and ratio using the world anchors.",
	"Method": "void initialize(Body b1,Body b2,Vec2 ga1,Vec2 ga2,Vec2 anchor1,Vec2 anchor2,float r){\r\n    bodyA = b1;\r\n    bodyB = b2;\r\n    groundAnchorA = ga1;\r\n    groundAnchorB = ga2;\r\n    localAnchorA = bodyA.getLocalPoint(anchor1);\r\n    localAnchorB = bodyB.getLocalPoint(anchor2);\r\n    Vec2 d1 = anchor1.sub(ga1);\r\n    lengthA = d1.length();\r\n    Vec2 d2 = anchor2.sub(ga2);\r\n    lengthB = d2.length();\r\n    ratio = r;\r\n    assert (ratio > JBoxSettings.EPSILON);\r\n}"
}, {
	"Path": "io.flutter.sdk.FlutterSdkUtil.guessFlutterSdkFromPackagesFile",
	"Comment": "parse any .packages file and infer the location of the flutter sdk from that.",
	"Method": "String guessFlutterSdkFromPackagesFile(Module module){\r\n    for (PubRoot pubRoot : PubRoots.forModule(module)) {\r\n        final VirtualFile packagesFile = pubRoot.getPackagesFile();\r\n        if (packagesFile == null) {\r\n            continue;\r\n        }\r\n        try {\r\n            final String contents = new String(packagesFile.contentsToByteArray(true));\r\n            return parseFlutterSdkPath(contents);\r\n        } catch (IOException ignored) {\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "io.flutter.run.daemon.DeviceService.getConnectedDevices",
	"Comment": "returns the currently connected devices, sorted by device name.",
	"Method": "Collection<FlutterDevice> getConnectedDevices(){\r\n    return deviceSelection.get().getDevices();\r\n}"
}, {
	"Path": "org.springframework.web.servlet.tags.BindTag.getErrors",
	"Comment": "retrieve the errors instance that this tag is currently bound to.intended for cooperating nesting tags.",
	"Method": "Errors getErrors(){\r\n    return null;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Event.getExtensionRPC",
	"Comment": "the rpc name of the extension that was added.this is provided for the serviceextensionadded event.can return null.",
	"Method": "String getExtensionRPC(){\r\n    return json.get(\"extensionRPC\") == null ? null : json.get(\"extensionRPC\").getAsString();\r\n}"
}, {
	"Path": "com.google.firebase.database.Query.addListenerForSingleValueEvent",
	"Comment": "add a listener for a single change in the data at this location. this listener will betriggered once with the value of the data at the location.",
	"Method": "void addListenerForSingleValueEvent(ValueEventListener listener){\r\n    addEventRegistration(new ValueEventRegistration(repo, new ValueEventListener() {\r\n        @Override\r\n        public void onDataChange(DataSnapshot snapshot) {\r\n            removeEventListener(this);\r\n            listener.onDataChange(snapshot);\r\n        }\r\n        @Override\r\n        public void onCancelled(DatabaseError error) {\r\n            listener.onCancelled(error);\r\n        }\r\n    }, getSpec()));\r\n}"
}, {
	"Path": "com.google.firebase.database.Query.addListenerForSingleValueEvent",
	"Comment": "add a listener for a single change in the data at this location. this listener will betriggered once with the value of the data at the location.",
	"Method": "void addListenerForSingleValueEvent(ValueEventListener listener){\r\n    removeEventListener(this);\r\n    listener.onDataChange(snapshot);\r\n}"
}, {
	"Path": "com.google.firebase.database.Query.addListenerForSingleValueEvent",
	"Comment": "add a listener for a single change in the data at this location. this listener will betriggered once with the value of the data at the location.",
	"Method": "void addListenerForSingleValueEvent(ValueEventListener listener){\r\n    listener.onCancelled(error);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.spec.SpecTestCase.validateNextWriteSent",
	"Comment": "validates that a write was sent and matches the expected write.",
	"Method": "void validateNextWriteSent(Mutation expectedWrite){\r\n    List<Mutation> request = datastore.waitForWriteSend();\r\n    assertEquals(1, request.size());\r\n    Mutation actualWrite = request.get(0);\r\n    assertEquals(expectedWrite, actualWrite);\r\n    log(\"      This write was sent: \" + actualWrite);\r\n}"
}, {
	"Path": "io.flutter.sdk.FlutterSdkUtil.addKnownSDKPathsToCombo",
	"Comment": "adds the current path and other known paths to the combo, most recently used first.",
	"Method": "void addKnownSDKPathsToCombo(JComboBox combo){\r\n    final Set<String> pathsToShow = new LinkedHashSet();\r\n    final String currentPath = combo.getEditor().getItem().toString().trim();\r\n    if (!currentPath.isEmpty()) {\r\n        pathsToShow.add(currentPath);\r\n    }\r\n    final String[] knownPaths = getKnownFlutterSdkPaths();\r\n    for (String path : knownPaths) {\r\n        if (FlutterSdk.forPath(path) != null) {\r\n            pathsToShow.add(FileUtil.toSystemDependentName(path));\r\n        }\r\n    }\r\n    combo.setModel(new DefaultComboBoxModel(ArrayUtil.toStringArray(pathsToShow)));\r\n    if (combo.getSelectedIndex() == -1 && combo.getItemCount() > 0) {\r\n        combo.setSelectedIndex(0);\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.concurrent.IOTask.run",
	"Comment": "executes this task synchronously on this thread.all callbacks will be called on this thread.",
	"Method": "T run(){\r\n    try {\r\n        T value = onExecute();\r\n        succeed(value);\r\n        return value;\r\n    } catch (Exception e) {\r\n        fail(e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.vladmihalcea.flexypool.adaptor.AbstractPoolAdapter.getTargetDataSource",
	"Comment": "get the target data source. this is the connection pool actual data source.",
	"Method": "T getTargetDataSource(){\r\n    return targetDataSource;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.DocumentSet.remove",
	"Comment": "returns a new documentset with the document for the provided key removed.",
	"Method": "DocumentSet remove(DocumentKey key){\r\n    Document document = keyIndex.get(key);\r\n    if (document == null) {\r\n        return this;\r\n    }\r\n    ImmutableSortedMap<DocumentKey, Document> newKeyIndex = keyIndex.remove(key);\r\n    ImmutableSortedSet<Document> newSortedSet = sortedSet.remove(document);\r\n    return new DocumentSet(newKeyIndex, newSortedSet);\r\n}"
}, {
	"Path": "org.fluentlenium.core.inject.ContainerFluentControl.setContext",
	"Comment": "define the container context of this container fluent control interface.",
	"Method": "void setContext(ContainerContext context){\r\n    this.context = context;\r\n}"
}, {
	"Path": "com.google.firebase.storage.StorageTask.continueWith",
	"Comment": "returns a new task that will be completed with the result of applying the specifiedcontinuation to this task.",
	"Method": "Task<TContinuationResult> continueWith(Continuation<TResult, TContinuationResult> continuation,Task<TContinuationResult> continueWith,Executor executor,Continuation<TResult, TContinuationResult> continuation){\r\n    return continueWithImpl(executor, continuation);\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.Array.truncate",
	"Comment": "reduces the size of the array to the specified size.if the array is already smaller than the specified size, no action is taken.",
	"Method": "void truncate(int newSize){\r\n    if (size <= newSize)\r\n        return;\r\n    for (int i = newSize; i < size; i++) items[i] = null;\r\n    size = newSize;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.mutation.MutationBatch.getKeys",
	"Comment": "returns the set of unique keys referenced by all mutations in the batch.",
	"Method": "Set<DocumentKey> getKeys(){\r\n    HashSet<DocumentKey> set = new HashSet();\r\n    for (Mutation mutation : mutations) {\r\n        set.add(mutation.getKey());\r\n    }\r\n    return set;\r\n}"
}, {
	"Path": "com.google.firebase.database.core.view.CacheNode.isFullyInitialized",
	"Comment": "returns whether this node was fully initialized with either server data or a complete overwriteby the client",
	"Method": "boolean isFullyInitialized(){\r\n    return this.fullyInitialized;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.HitBox.translateXFlipped",
	"Comment": "computes new bounds based on translated x and yof an entity with x axis being flipped.",
	"Method": "Bounds translateXFlipped(double x,double y,double entityWidth){\r\n    return new BoundingBox(x + entityWidth - bounds.getMinX() - bounds.getWidth(), y + bounds.getMinY(), bounds.getWidth(), bounds.getHeight());\r\n}"
}, {
	"Path": "com.google.firebase.database.core.WriteTree.childWrites",
	"Comment": "create a new writetreeref for the given path. for use with a new sync point at the given path.",
	"Method": "WriteTreeRef childWrites(Path path){\r\n    return new WriteTreeRef(path, this);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.ReferenceSet.removeReferences",
	"Comment": "removes references to the given document keys for the given id.",
	"Method": "void removeReferences(ImmutableSortedSet<DocumentKey> keys,int targetOrBatchId){\r\n    for (DocumentKey key : keys) {\r\n        removeReference(key, targetOrBatchId);\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.particle.ParticleEmitter.setControl",
	"Comment": "set control function to override velocity and accelerationof each particle.",
	"Method": "void setControl(Consumer<Particle> control){\r\n    this.control = control;\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.beforeNavigateForward",
	"Comment": "add a listener that will be invoked before navigating forward.",
	"Method": "EventsRegistry beforeNavigateForward(NavigateListener listener){\r\n    beforeNavigateForward.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.MockDatastore.failWrite",
	"Comment": "injects a failed write response as though it had come from the backend.",
	"Method": "void failWrite(Status status){\r\n    writeStream.failStream(status);\r\n}"
}, {
	"Path": "org.fluentlenium.core.components.ComponentsManager.getInstantiator",
	"Comment": "get the component instantiator used by this components manager.",
	"Method": "ComponentInstantiator getInstantiator(){\r\n    return instantiator;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.EncodedPath.encodeSegment",
	"Comment": "encodes a single segment of a path into the given stringbuilder.",
	"Method": "void encodeSegment(String segment,StringBuilder result){\r\n    for (int i = 0, length = segment.length(); i < length; i++) {\r\n        char c = segment.charAt(i);\r\n        switch(c) {\r\n            case '\\0':\r\n                result.append(ESCAPE).append(ENCODED_NUL);\r\n                break;\r\n            case ESCAPE:\r\n                result.append(ESCAPE).append(ENCODED_ESCAPE);\r\n                break;\r\n            default:\r\n                result.append(c);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.flutter.project.ProjectWatch.subscribe",
	"Comment": "subscribes to project changes. this includes module root changes and closing the project.",
	"Method": "ProjectWatch subscribe(Project project,Runnable callback){\r\n    return new ProjectWatch(project, callback);\r\n}"
}, {
	"Path": "com.almasb.fxgl.ai.btree.Task.getEntity",
	"Comment": "returns the blackboard object of the behavior tree this task belongs to.",
	"Method": "E getEntity(){\r\n    if (tree == null)\r\n        throw new IllegalStateException(\"This task has never run\");\r\n    return tree.getEntity();\r\n}"
}, {
	"Path": "com.almasb.fxgl.entity.Entity.load",
	"Comment": "load entity state from a bundle.only serializable components will be read.if an entity has a serializable type that is not present in the bundle,a warning will be logged but no exception thrown.",
	"Method": "void load(Bundle bundle){\r\n    EntitySerializer.INSTANCE.load(this, bundle);\r\n}"
}, {
	"Path": "com.vladsch.flexmark.internal.InlineParserImpl.parseBackticks",
	"Comment": "attempt to parse backticks, adding either a backtick code span or a literal sequence of backticks.",
	"Method": "boolean parseBackticks(){\r\n    BasedSequence ticks = match(myParsing.TICKS_HERE);\r\n    if (ticks == null) {\r\n        return false;\r\n    }\r\n    int afterOpenTicks = index;\r\n    BasedSequence matched;\r\n    while ((matched = match(myParsing.TICKS)) != null) {\r\n        if (matched.equals(ticks)) {\r\n            int ticksLength = ticks.length();\r\n            BasedSequence content = input.subSequence(afterOpenTicks - ticksLength, index - ticksLength);\r\n            final BasedSequence codeText = input.subSequence(afterOpenTicks, index - ticksLength);\r\n            Code node = new Code(input.subSequence(afterOpenTicks - ticksLength, afterOpenTicks), codeText, input.subSequence(index - ticksLength, index));\r\n            if (options.codeSoftLineBreaks) {\r\n                final int length = codeText.length();\r\n                int lastPos = 0;\r\n                while (lastPos < length) {\r\n                    int softBreak = codeText.indexOfAny(\"\\n\\r\", lastPos);\r\n                    int pos = softBreak == -1 ? length : softBreak;\r\n                    int lineBreak = pos;\r\n                    final Text textNode = new Text(codeText.subSequence(lastPos, pos));\r\n                    node.appendChild(textNode);\r\n                    lastPos = pos;\r\n                    if (lastPos >= length)\r\n                        break;\r\n                    if (codeText.charAt(lastPos) == '\\r') {\r\n                        lastPos++;\r\n                        if (lastPos >= length)\r\n                            break;\r\n                        if (codeText.charAt(lastPos) == '\\n')\r\n                            lastPos++;\r\n                    } else {\r\n                        lastPos++;\r\n                    }\r\n                    if (lastPos >= length)\r\n                        break;\r\n                    if (lineBreak < lastPos) {\r\n                        SoftLineBreak softLineBreak = new SoftLineBreak(codeText.subSequence(softBreak, lastPos));\r\n                        node.appendChild(softLineBreak);\r\n                    }\r\n                }\r\n            } else {\r\n                final Text textNode = new Text(codeText);\r\n                node.appendChild(textNode);\r\n            }\r\n            appendNode(node);\r\n            return true;\r\n        }\r\n    }\r\n    index = afterOpenTicks;\r\n    appendText(ticks);\r\n    return true;\r\n}"
}, {
	"Path": "com.google.firebase.database.core.CompoundWrite.apply",
	"Comment": "applies this compoundwrite to a node. the node is returned with all writes from thiscompoundwrite applied to the node",
	"Method": "Node apply(Node node){\r\n    return applySubtreeWrite(Path.getEmptyPath(), this.writeTree, node);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.MemoryEagerReferenceDelegate.onTransactionCommitted",
	"Comment": "in eager garbage collection, collection is run on transaction commit.",
	"Method": "void onTransactionCommitted(){\r\n    MemoryRemoteDocumentCache remoteDocuments = persistence.getRemoteDocumentCache();\r\n    for (DocumentKey key : orphanedDocuments) {\r\n        if (!isReferenced(key)) {\r\n            remoteDocuments.remove(key);\r\n        }\r\n    }\r\n    orphanedDocuments = null;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteStore.stopListening",
	"Comment": "stops listening to the target with the given target id.if this is called with the last active targetid, the watch stream enters idle mode and willbe torn down after one minute of inactivity.",
	"Method": "void stopListening(int targetId){\r\n    QueryData queryData = listenTargets.remove(targetId);\r\n    hardAssert(queryData != null, \"stopListening called on target no currently watched: %d\", targetId);\r\n    if (watchStream.isOpen()) {\r\n        sendUnwatchRequest(targetId);\r\n    }\r\n    if (listenTargets.isEmpty()) {\r\n        if (watchStream.isOpen()) {\r\n            watchStream.markIdle();\r\n        } else if (this.canUseNetwork()) {\r\n            this.onlineStateTracker.updateState(OnlineState.UNKNOWN);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.storage.network.NetworkRequest.getOutputRaw",
	"Comment": "can be overridden to return a byte array to populate the request body.",
	"Method": "byte[] getOutputRaw(){\r\n    return null;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.FuncRef.getOwner",
	"Comment": "the owner of this function, which can be a library, class, or a function.",
	"Method": "Object getOwner(){\r\n    JsonObject elem = (JsonObject) json.get(\"owner\");\r\n    if (elem == null)\r\n        return null;\r\n    if (elem.get(\"type\").getAsString().equals(\"@Library\"))\r\n        return new LibraryRef(elem);\r\n    if (elem.get(\"type\").getAsString().equals(\"@Class\"))\r\n        return new ClassRef(elem);\r\n    if (elem.get(\"type\").getAsString().equals(\"@Func\"))\r\n        return new FuncRef(elem);\r\n    return null;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.PhysicsComponent.applyBodyForce",
	"Comment": "apply a force at a world point. if the force is not applied at the center of mass, it will generate a torque and affect the angular velocity. this wakes up the body.",
	"Method": "void applyBodyForce(Vec2 force,Vec2 point){\r\n    getBody().applyForce(force, point);\r\n}"
}, {
	"Path": "org.inferred.freebuilder.processor.Declarations.freshBuilder",
	"Comment": "declares a fresh builder to copy default property values from.",
	"Method": "Optional<Excerpt> freshBuilder(Block block,Metadata metadata){\r\n    if (!metadata.getBuilderFactory().isPresent()) {\r\n        return Optional.absent();\r\n    }\r\n    Excerpt defaults = block.declare(metadata.getGeneratedBuilder(), \"_defaults\", metadata.getBuilderFactory().get().newBuilder(metadata.getBuilder(), TypeInference.INFERRED_TYPES));\r\n    return Optional.of(defaults);\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.afterFindBy",
	"Comment": "add a listener that will be invoked after finding an element.",
	"Method": "EventsRegistry afterFindBy(FindByListener listener){\r\n    afterFindBy.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.database.Query.addValueEventListener",
	"Comment": "add a listener for changes in the data at this location. each time time the data changes, yourlistener will be called with an immutable snapshot of the data.",
	"Method": "ValueEventListener addValueEventListener(ValueEventListener listener){\r\n    addEventRegistration(new ValueEventRegistration(repo, listener, getSpec()));\r\n    return listener;\r\n}"
}, {
	"Path": "org.dartlang.analysis.server.protocol.FlutterOutline.getLabel",
	"Comment": "the text label of the node children of the node. it is provided for anyflutteroutlinekind.generic node, where better information is not available.",
	"Method": "String getLabel(){\r\n    return label;\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.reflect.Field.getDeclaringClass",
	"Comment": "returns the class object representing the class or interface that declares the field.",
	"Method": "Class getDeclaringClass(){\r\n    return field.getDeclaringClass();\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.AnnotationElementListener.getArgsFunction",
	"Comment": "get a function that retrieves argument value based on argument type.",
	"Method": "Function<Class<?>, Object> getArgsFunction(FluentWebElement element,WebDriver driver){\r\n    return input -> {\r\n        if (input.isAssignableFrom(FluentWebElement.class)) {\r\n            return element;\r\n        }\r\n        if (input.isAssignableFrom(WebDriver.class)) {\r\n            return driver;\r\n        }\r\n        return null;\r\n    };\r\n}"
}, {
	"Path": "com.google.firebase.database.DeepEquals.compareOrdered",
	"Comment": "compare two collections that must be same length and in same order.",
	"Method": "boolean compareOrdered(DualKey dualKey,LinkedList<DualKey> stack,Collection visited){\r\n    Collection col1 = (Collection) dualKey.key1;\r\n    Collection col2 = (Collection) dualKey.key2;\r\n    if (col1.size() != col2.size()) {\r\n        return false;\r\n    }\r\n    Iterator i1 = col1.iterator();\r\n    Iterator i2 = col2.iterator();\r\n    while (i1.hasNext()) {\r\n        DualKey dk = new DualKey(i1.next(), i2.next());\r\n        if (!visited.contains(dk)) {\r\n            stack.addFirst(dk);\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.Array.removeValueByIdentity",
	"Comment": "removes the first instance of the specified value in the array.",
	"Method": "boolean removeValueByIdentity(T value){\r\n    return removeValue(value, true);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.BoundingShape.box",
	"Comment": "constructs new rectangular bounding shape with given width and height.",
	"Method": "BoundingShape box(double width,double height){\r\n    return new BoundingShape(ShapeType.POLYGON, new Dimension2D(width, height), new Dimension2D(width, height));\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.mutation.PatchMutation.patchDocument",
	"Comment": "patches the data of document if available or creates a new document. note that this does notcheck whether or not the precondition of this patch holds.",
	"Method": "ObjectValue patchDocument(MaybeDocument maybeDoc){\r\n    ObjectValue data;\r\n    if (maybeDoc instanceof Document) {\r\n        data = ((Document) maybeDoc).getData();\r\n    } else {\r\n        data = ObjectValue.emptyObject();\r\n    }\r\n    return patchObject(data);\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Isolate.getId",
	"Comment": "the id which is passed to the getisolate rpc to reload this isolate.",
	"Method": "String getId(){\r\n    return json.get(\"id\").getAsString();\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.math.FXGLMath.lerpAngleDeg",
	"Comment": "linearly interpolates between two angles in degrees.takes into account that angles wrap at 360 degrees and always takesthe direction with the smallest delta angle.",
	"Method": "double lerpAngleDeg(double fromDegrees,double toDegrees,double progress){\r\n    double delta = ((toDegrees - fromDegrees + 360 + 180) % 360) - 180;\r\n    return (fromDegrees + delta * progress + 360) % 360;\r\n}"
}, {
	"Path": "com.google.firebase.database.Query.addChildEventListener",
	"Comment": "add a listener for child events occurring at this location. when child locations are added,removed, changed, or moved, the listener will be triggered for the appropriate event",
	"Method": "ChildEventListener addChildEventListener(ChildEventListener listener){\r\n    addEventRegistration(new ChildEventRegistration(repo, listener, getSpec()));\r\n    return listener;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.World.step",
	"Comment": "take a time step.this performs collision detection, integration, and constraint solution.",
	"Method": "void step(float dt,int velocityIterations,int positionIterations){\r\n    if (newFixture) {\r\n        contactManager.findNewContacts();\r\n        newFixture = false;\r\n    }\r\n    locked = true;\r\n    step.dt = dt;\r\n    step.velocityIterations = velocityIterations;\r\n    step.positionIterations = positionIterations;\r\n    if (dt > 0.0f) {\r\n        step.inv_dt = 1.0f / dt;\r\n    } else {\r\n        step.inv_dt = 0.0f;\r\n    }\r\n    step.dtRatio = dtInverse * dt;\r\n    step.warmStarting = warmStarting;\r\n    contactManager.collide();\r\n    if (step.dt > 0) {\r\n        if (stepComplete) {\r\n            particleSystem.solve(step);\r\n            solve(step);\r\n        }\r\n        if (continuousPhysics) {\r\n            solveTOI(step);\r\n        }\r\n        dtInverse = step.inv_dt;\r\n    }\r\n    if (isAutoClearForces()) {\r\n        clearForces();\r\n    }\r\n    locked = false;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.MutationQueueTestCase.removeFirstBatches",
	"Comment": "removes the first n entries from the given batches and returns them.",
	"Method": "List<MutationBatch> removeFirstBatches(int n,List<MutationBatch> batches){\r\n    List<MutationBatch> removed = new ArrayList();\r\n    for (int i = 0; i < n; i++) {\r\n        MutationBatch batch = batches.get(0);\r\n        removeMutationBatches(batch);\r\n        batches.remove(0);\r\n        removed.add(batch);\r\n    }\r\n    return removed;\r\n}"
}, {
	"Path": "com.almasb.fxgl.entity.EntityEvent.getTargetEntity",
	"Comment": "returns entity that was target of the event.note that if there is no target entity then it is the same as trigger entity.",
	"Method": "Entity getTargetEntity(){\r\n    return targetEntity;\r\n}"
}, {
	"Path": "com.google.firebase.storage.StorageTask.addOnFailureListener",
	"Comment": "adds a listener that is called if the task fails.if the task has already failed, a call to the listener will be immediately scheduled. ifmultiple listeners are added, they will be called in the order in which they were added.",
	"Method": "StorageTask<TResult> addOnFailureListener(OnFailureListener listener,StorageTask<TResult> addOnFailureListener,Executor executor,OnFailureListener listener,StorageTask<TResult> addOnFailureListener,Activity activity,OnFailureListener listener){\r\n    Preconditions.checkNotNull(listener);\r\n    Preconditions.checkNotNull(activity);\r\n    failureManager.addListener(activity, null, listener);\r\n    return this;\r\n}"
}, {
	"Path": "testcasesupport.IO.getDBConnection",
	"Comment": "use this method to get a database connection for use in sql injection and other test cases that use a database.",
	"Method": "Connection getDBConnection(){\r\n    return DriverManager.getConnection(dbUrl, dbUsername, dbPassword);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.FirebaseFirestoreException.getCode",
	"Comment": "gets the error code for the firestore operation that failed.",
	"Method": "Code getCode(){\r\n    return code;\r\n}"
}, {
	"Path": "io.flutter.bazel.Workspace.findWorkspaceFile",
	"Comment": "returns the bazel workspace file for a project, or null if not using bazel.at least one content root must be within the workspace, and the project cannot havecontent roots in more than one workspace.",
	"Method": "VirtualFile findWorkspaceFile(Project p){\r\n    final Computable<VirtualFile> readAction = () -> {\r\n        final Map<String, VirtualFile> candidates = new HashMap();\r\n        for (VirtualFile contentRoot : ProjectRootManager.getInstance(p).getContentRoots()) {\r\n            final VirtualFile wf = findContainingWorkspaceFile(contentRoot);\r\n            if (wf != null) {\r\n                candidates.put(wf.getPath(), wf);\r\n            }\r\n        }\r\n        if (candidates.size() == 1) {\r\n            return candidates.values().iterator().next();\r\n        }\r\n        return null;\r\n    };\r\n    return ApplicationManager.getApplication().runReadAction(readAction);\r\n}"
}, {
	"Path": "io.flutter.run.bazelTest.BazelTestFields.getEntryFile",
	"Comment": "the file containing the main function that starts the flutter app.",
	"Method": "String getEntryFile(){\r\n    return entryFile;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.WatchChangeAggregator.targetContainsDocument",
	"Comment": "returns whether the localstore considers the document to be part of the specified target.",
	"Method": "boolean targetContainsDocument(int targetId,DocumentKey key){\r\n    ImmutableSortedSet<DocumentKey> existingKeys = targetMetadataProvider.getRemoteKeysForTarget(targetId);\r\n    return existingKeys.contains(key);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.TargetChange.getModifiedDocuments",
	"Comment": "returns the set of documents that were already assigned to this target but received an updateduring this remote event.",
	"Method": "ImmutableSortedSet<DocumentKey> getModifiedDocuments(){\r\n    return modifiedDocuments;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Blob.fromBytes",
	"Comment": "creates a new blob instance from the provided bytes. will make a copy of the bytes passed in.",
	"Method": "Blob fromBytes(byte[] bytes){\r\n    checkNotNull(bytes, \"Provided bytes array must not be null.\");\r\n    return new Blob(ByteString.copyFrom(bytes));\r\n}"
}, {
	"Path": "com.almasb.fxgl.ai.btree.decorator.Random.start",
	"Comment": "draws a value from the distribution that determines the success probability.\tthis method is called when the task is entered.",
	"Method": "void start(){\r\n    p = success.nextFloat();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.AsyncQueue.enqueueAfterDelay",
	"Comment": "schedule a task after the specified delay.the returned delayedtask can be used to cancel the task prior to its running.",
	"Method": "DelayedTask enqueueAfterDelay(TimerId timerId,long delayMs,Runnable task){\r\n    hardAssert(!containsDelayedTask(timerId), \"Attempted to schedule multiple operations with timer id %s.\", timerId);\r\n    DelayedTask delayedTask = createAndScheduleDelayedTask(timerId, delayMs, task);\r\n    delayedTasks.add(delayedTask);\r\n    return delayedTask;\r\n}"
}, {
	"Path": "com.almasb.fxgl.particle.ParticleEmitter.setScaleFunction",
	"Comment": "scale function defines how the size of particles change over time.",
	"Method": "void setScaleFunction(Function<Integer, Point2D> scaleFunction){\r\n    this.scaleFunction = scaleFunction;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.DocumentSet.emptySet",
	"Comment": "returns an empty documentset sorted by the given comparator, then by keys.",
	"Method": "DocumentSet emptySet(Comparator<Document> comparator){\r\n    Comparator<Document> adjustedComparator = (left, right) -> {\r\n        int comparison = comparator.compare(left, right);\r\n        if (comparison == 0) {\r\n            return Document.keyComparator().compare(left, right);\r\n        } else {\r\n            return comparison;\r\n        }\r\n    };\r\n    return new DocumentSet(emptyDocumentMap(), new ImmutableSortedSet(Collections.emptyList(), adjustedComparator));\r\n}"
}, {
	"Path": "com.vladsch.flexmark.util.html.Attributes.replaceValue",
	"Comment": "attribute dependent value replacementclass and style append new values to existing onesothers set it to the new value",
	"Method": "Attribute replaceValue(Attribute attribute,Attribute replaceValue,CharSequence key,CharSequence value){\r\n    String useKey = String.valueOf(key);\r\n    Attribute attribute;\r\n    if (myAttributes == null) {\r\n        attribute = AttributeImpl.of(useKey, value);\r\n    } else {\r\n        attribute = myAttributes.get(useKey);\r\n        if (attribute != null)\r\n            attribute = attribute.replaceValue(value);\r\n        else\r\n            attribute = AttributeImpl.of(useKey, value);\r\n    }\r\n    getAttributes().put(useKey, attribute);\r\n    return attribute;\r\n}"
}, {
	"Path": "com.google.firebase.storage.StorageTask.addOnCompleteListener",
	"Comment": "adds a listener that is called when the task succeeds or fails.if the task has already failed, a call to the listener will be immediately scheduled. ifmultiple listeners are added, they will be called in the order in which they were added.",
	"Method": "StorageTask<TResult> addOnCompleteListener(OnCompleteListener<TResult> listener,StorageTask<TResult> addOnCompleteListener,Executor executor,OnCompleteListener<TResult> listener,StorageTask<TResult> addOnCompleteListener,Activity activity,OnCompleteListener<TResult> listener){\r\n    Preconditions.checkNotNull(listener);\r\n    Preconditions.checkNotNull(activity);\r\n    completeListener.addListener(activity, null, listener);\r\n    return this;\r\n}"
}, {
	"Path": "io.flutter.AbstractDartElementTest.setUpDartElement",
	"Comment": "creates the syntax tree for a dart file and returns the innermost element with the given text.",
	"Method": "E setUpDartElement(String fileText,String elementText,Class<E> expectedClass){\r\n    final int offset = fileText.indexOf(elementText);\r\n    if (offset < 0) {\r\n        throw new IllegalArgumentException(\"'\" + elementText + \"' not found in '\" + fileText + \"'\");\r\n    }\r\n    final PsiFile file = PsiFileFactory.getInstance(fixture.getProject()).createFileFromText(DartLanguage.INSTANCE, fileText);\r\n    PsiElement elt = file.findElementAt(offset);\r\n    while (elt != null) {\r\n        if (elementText.equals(elt.getText())) {\r\n            return expectedClass.cast(elt);\r\n        }\r\n        elt = elt.getParent();\r\n    }\r\n    throw new RuntimeException(\"unable to find element with text: \" + elementText);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.ValidationTest.expectSetError",
	"Comment": "performs a write using each set api and makes sure it fails with the expected reason.",
	"Method": "void expectSetError(Object data,String reason){\r\n    expectWriteError(data, reason, true, false);\r\n}"
}, {
	"Path": "com.vladmihalcea.flexypool.FlexyPoolDataSource.getConnection",
	"Comment": "try to obtain a connection by going through all available strategies",
	"Method": "Connection getConnection(Connection getConnection,String username,String password,Connection getConnection,ConnectionRequestContext context){\r\n    concurrentConnectionRequestCountHistogram.update(concurrentConnectionRequestCount.incrementAndGet());\r\n    long startNanos = System.nanoTime();\r\n    try {\r\n        Connection connection = null;\r\n        if (!connectionAcquiringStrategies.isEmpty()) {\r\n            for (ConnectionAcquiringStrategy strategy : connectionAcquiringStrategies) {\r\n                try {\r\n                    connection = strategy.getConnection(context);\r\n                    break;\r\n                } catch (AcquireTimeoutException e) {\r\n                    LOGGER.warn(\"Couldn't retrieve connection from strategy {} with context {}\", strategy, context);\r\n                }\r\n            }\r\n        } else {\r\n            connection = poolAdapter.getConnection(context);\r\n        }\r\n        if (connection != null) {\r\n            return connectionProxyFactory.newInstance(connection, this);\r\n        } else {\r\n            throw new CantAcquireConnectionException(\"Couldn't acquire connection for current strategies: \" + connectionAcquiringStrategies);\r\n        }\r\n    } finally {\r\n        long endNanos = System.nanoTime();\r\n        long acquireDurationMillis = TimeUnit.NANOSECONDS.toMillis(endNanos - startNanos);\r\n        connectionAcquireTotalTimer.update(acquireDurationMillis, TimeUnit.MILLISECONDS);\r\n        concurrentConnectionRequestCountHistogram.update(concurrentConnectionRequestCount.decrementAndGet());\r\n        if (acquireDurationMillis > connectionAcquireTimeThresholdMillis) {\r\n            eventPublisher.publish(new ConnectionAcquireTimeThresholdExceededEvent(uniqueName, connectionAcquireTimeThresholdMillis, acquireDurationMillis));\r\n            LOGGER.info(\"Connection acquired in {} millis, while threshold is set to {} in {} FlexyPoolDataSource\", acquireDurationMillis, connectionAcquireTimeThresholdMillis, uniqueName);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.vladsch.flexmark.internal.DocumentParser.processInlines",
	"Comment": "walk through a block & children recursively, parsing string content into inline content where appropriate.",
	"Method": "void processInlines(){\r\n    for (BlockParser blockParser : blockTracker.allBlockParsers()) {\r\n        blockParser.parseInlines(inlineParser);\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.PhysicsComponent.applyBodyLinearImpulse",
	"Comment": "apply an impulse at a point. this immediately modifies the velocity. it also modifies the angular velocity if the point of application is not at the center of mass. this wakes up the body.",
	"Method": "void applyBodyLinearImpulse(Vec2 impulse,Vec2 point,boolean wake){\r\n    getBody().applyLinearImpulse(impulse, point, wake);\r\n}"
}, {
	"Path": "org.dartlang.analysis.server.protocol.FlutterOutline.getRenderConstructor",
	"Comment": "if the node is a widget class that can be rendered for ide, the name of the constructor thatshould be used to instantiate the widget. empty string for default constructor. absent if thenode is not a widget class that can be rendered.",
	"Method": "String getRenderConstructor(){\r\n    return renderConstructor;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.PhysicsComponent.setBodyType",
	"Comment": "a convenience method to avoid setting body definitionif only a change of body type is required.",
	"Method": "void setBodyType(BodyType type){\r\n    bodyDef.setType(type);\r\n}"
}, {
	"Path": "com.google.cloud.datastore.core.number.NumberParts.exponent",
	"Comment": "the actual value of the binary exponent in the floating point encoding.",
	"Method": "int exponent(){\r\n    return exponent;\r\n}"
}, {
	"Path": "com.almasb.fxgl.scene.FXGLMenu.fireMultiplayer",
	"Comment": "call multiplayer access in main menu.currently not supported.",
	"Method": "void fireMultiplayer(){\r\n    log.debug(\"fireMultiplayer()\");\r\n    listener.onMultiplayer();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.Filter.create",
	"Comment": "gets a filter instance for the provided path, operator, and value.note that if the relation operator is equal and the value is null or nan, this will returnthe appropriate nullfilter or nanfilter class instead of a relationfilter.",
	"Method": "Filter create(FieldPath path,Operator operator,FieldValue value){\r\n    if (value.equals(NullValue.nullValue())) {\r\n        if (operator != Filter.Operator.EQUAL) {\r\n            throw new IllegalArgumentException(\"Invalid Query. You can only perform equality comparisons on null (via \" + \"whereEqualTo()).\");\r\n        }\r\n        return new NullFilter(path);\r\n    } else if (value.equals(DoubleValue.NaN)) {\r\n        if (operator != Filter.Operator.EQUAL) {\r\n            throw new IllegalArgumentException(\"Invalid Query. You can only perform equality comparisons on NaN (via \" + \"whereEqualTo()).\");\r\n        }\r\n        return new NaNFilter(path);\r\n    } else {\r\n        return new RelationFilter(path, operator, value);\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.scene.GameScene.setUIMouseTransparent",
	"Comment": "set true if ui elements should forward mouse eventsto the game layer.",
	"Method": "void setUIMouseTransparent(boolean b){\r\n    uiRoot.setMouseTransparent(b);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.TestUtil.querySnapshot",
	"Comment": "a convenience method for creating a particular query snapshot for tests.",
	"Method": "QuerySnapshot querySnapshot(String path,Map<String, ObjectValue> oldDocs,Map<String, ObjectValue> docsToAdd,boolean hasPendingWrites,boolean isFromCache){\r\n    DocumentSet oldDocuments = docSet(Document.keyComparator());\r\n    ImmutableSortedSet<DocumentKey> mutatedKeys = DocumentKey.emptyKeySet();\r\n    for (Map.Entry<String, ObjectValue> pair : oldDocs.entrySet()) {\r\n        String docKey = path + \"/\" + pair.getKey();\r\n        oldDocuments = oldDocuments.add(doc(docKey, 1L, pair.getValue(), hasPendingWrites ? Document.DocumentState.SYNCED : Document.DocumentState.LOCAL_MUTATIONS));\r\n        if (hasPendingWrites) {\r\n            mutatedKeys = mutatedKeys.insert(key(docKey));\r\n        }\r\n    }\r\n    DocumentSet newDocuments = docSet(Document.keyComparator());\r\n    List<DocumentViewChange> documentChanges = new ArrayList();\r\n    for (Map.Entry<String, ObjectValue> pair : docsToAdd.entrySet()) {\r\n        String docKey = path + \"/\" + pair.getKey();\r\n        Document docToAdd = doc(docKey, 1L, pair.getValue(), hasPendingWrites ? Document.DocumentState.SYNCED : Document.DocumentState.LOCAL_MUTATIONS);\r\n        newDocuments = newDocuments.add(docToAdd);\r\n        documentChanges.add(DocumentViewChange.create(Type.ADDED, docToAdd));\r\n        if (hasPendingWrites) {\r\n            mutatedKeys = mutatedKeys.insert(key(docKey));\r\n        }\r\n    }\r\n    ViewSnapshot viewSnapshot = new ViewSnapshot(com.google.firebase.firestore.testutil.TestUtil.query(path), newDocuments, oldDocuments, documentChanges, isFromCache, mutatedKeys, true, false);\r\n    return new QuerySnapshot(query(path), viewSnapshot, FIRESTORE);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.DocumentReference.internalOptions",
	"Comment": "converts the public api metadatachanges object to the internal options object.",
	"Method": "ListenOptions internalOptions(MetadataChanges metadataChanges){\r\n    ListenOptions internalOptions = new ListenOptions();\r\n    internalOptions.includeDocumentMetadataChanges = (metadataChanges == MetadataChanges.INCLUDE);\r\n    internalOptions.includeQueryMetadataChanges = (metadataChanges == MetadataChanges.INCLUDE);\r\n    internalOptions.waitForSyncWhenOnline = false;\r\n    return internalOptions;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.MutationTest.testCreateArrayUnionTransform",
	"Comment": "tests for it currently. we could consider removing this test once we have integration tests.",
	"Method": "void testCreateArrayUnionTransform(){\r\n    TransformMutation transform = transformMutation(\"collection/key\", map(\"a\", FieldValue.arrayUnion(\"tag\"), \"bar.baz\", FieldValue.arrayUnion(true, map(\"nested\", map(\"a\", Arrays.asList(1, 2))))));\r\n    assertEquals(2, transform.getFieldTransforms().size());\r\n    FieldTransform first = transform.getFieldTransforms().get(0);\r\n    assertEquals(field(\"a\"), first.getFieldPath());\r\n    assertEquals(new ArrayTransformOperation.Union(Collections.singletonList(wrap(\"tag\"))), first.getOperation());\r\n    FieldTransform second = transform.getFieldTransforms().get(1);\r\n    assertEquals(field(\"bar.baz\"), second.getFieldPath());\r\n    assertEquals(new ArrayTransformOperation.Union(Arrays.asList(wrap(true), wrapObject(map(\"nested\", map(\"a\", Arrays.asList(1, 2)))))), second.getOperation());\r\n}"
}, {
	"Path": "org.dartlang.analysis.server.protocol.FlutterOutline.getOffset",
	"Comment": "the offset of the first character of the element. this is different than the offset in theelement, which is the offset of the name of the element. it can be used, for example, to maplocations in the file back to an outline.",
	"Method": "int getOffset(){\r\n    return offset;\r\n}"
}, {
	"Path": "com.google.firebase.storage.network.NetworkRequest.getOutputJSON",
	"Comment": "can be overridden to return a jsonobject to populate the request body.",
	"Method": "JSONObject getOutputJSON(){\r\n    return null;\r\n}"
}, {
	"Path": "com.vladmihalcea.flexypool.metric.codahale.Slf4jMetricReporter.init",
	"Comment": "create a log reporter and activate it if the metriclogreportermillis property is greater than zero.",
	"Method": "Slf4jMetricReporter init(ConfigurationProperties configurationProperties,MetricRegistry metricRegistry){\r\n    metricLogReporterMillis = configurationProperties.getMetricLogReporterMillis();\r\n    if (metricLogReporterMillis > 0) {\r\n        this.slf4jReporter = Slf4jReporter.forRegistry(metricRegistry).outputTo(LOGGER).build();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.Util.convertThrowableToException",
	"Comment": "turns a throwable into an exception, converting it from a statusexception if necessary.",
	"Method": "Exception convertThrowableToException(Throwable t){\r\n    if (t instanceof Exception) {\r\n        return Util.convertStatusException((Exception) t);\r\n    } else {\r\n        return new Exception(t);\r\n    }\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.ContainerAnnotationsEventsRegistry.close",
	"Comment": "release resources associated with this component event registrations.",
	"Method": "void close(){\r\n    registry.unregisterContainer(container);\r\n}"
}, {
	"Path": "com.google.firebase.database.core.WriteTreeRef.calcCompleteEventChildren",
	"Comment": "if possible, returns a children node containing all of the complete children we have data for.the returned data is a mix of the given server data and write data.",
	"Method": "Node calcCompleteEventChildren(Node completeServerChildren){\r\n    return this.writeTree.calcCompleteEventChildren(this.treePath, completeServerChildren);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.WatchChangeAggregator.createRemoteEvent",
	"Comment": "converts the currently accumulated state into a remote event at the provided snapshot version.resets the accumulated changes before returning.",
	"Method": "RemoteEvent createRemoteEvent(SnapshotVersion snapshotVersion){\r\n    Map<Integer, TargetChange> targetChanges = new HashMap();\r\n    for (Map.Entry<Integer, TargetState> entry : targetStates.entrySet()) {\r\n        int targetId = entry.getKey();\r\n        TargetState targetState = entry.getValue();\r\n        QueryData queryData = queryDataForActiveTarget(targetId);\r\n        if (queryData != null) {\r\n            if (targetState.isCurrent() && queryData.getQuery().isDocumentQuery()) {\r\n                DocumentKey key = DocumentKey.fromPath(queryData.getQuery().getPath());\r\n                if (pendingDocumentUpdates.get(key) == null && !targetContainsDocument(targetId, key)) {\r\n                    removeDocumentFromTarget(targetId, key, new NoDocument(key, snapshotVersion, false));\r\n                }\r\n            }\r\n            if (targetState.hasChanges()) {\r\n                targetChanges.put(targetId, targetState.toTargetChange());\r\n                targetState.clearChanges();\r\n            }\r\n        }\r\n    }\r\n    Set<DocumentKey> resolvedLimboDocuments = new HashSet();\r\n    for (Map.Entry<DocumentKey, Set<Integer>> entry : pendingDocumentTargetMapping.entrySet()) {\r\n        DocumentKey key = entry.getKey();\r\n        Set<Integer> targets = entry.getValue();\r\n        boolean isOnlyLimboTarget = true;\r\n        for (int targetId : targets) {\r\n            QueryData queryData = queryDataForActiveTarget(targetId);\r\n            if (queryData != null && !queryData.getPurpose().equals(QueryPurpose.LIMBO_RESOLUTION)) {\r\n                isOnlyLimboTarget = false;\r\n                break;\r\n            }\r\n        }\r\n        if (isOnlyLimboTarget) {\r\n            resolvedLimboDocuments.add(key);\r\n        }\r\n    }\r\n    RemoteEvent remoteEvent = new RemoteEvent(snapshotVersion, Collections.unmodifiableMap(targetChanges), Collections.unmodifiableSet(pendingTargetResets), Collections.unmodifiableMap(pendingDocumentUpdates), Collections.unmodifiableSet(resolvedLimboDocuments));\r\n    pendingDocumentUpdates = new HashMap();\r\n    pendingDocumentTargetMapping = new HashMap();\r\n    pendingTargetResets = new HashSet();\r\n    return remoteEvent;\r\n}"
}, {
	"Path": "io.flutter.FlutterUtils.declaresFlutter",
	"Comment": "returns true if passed pubspec declares a flutter dependency.",
	"Method": "boolean declaresFlutter(VirtualFile pubspec){\r\n    try {\r\n        final String contents = new String(pubspec.contentsToByteArray(true));\r\n        final Map<String, Object> yaml = loadPubspecInfo(contents);\r\n        if (yaml == null) {\r\n            return false;\r\n        }\r\n        final Object name = yaml.get(\"name\");\r\n        if (\"flutter\".equals(name)) {\r\n            return true;\r\n        }\r\n        final Object dependencies = yaml.get(\"dependencies\");\r\n        if (dependencies instanceof Map) {\r\n            return ((Map) dependencies).containsKey(\"flutter\");\r\n        }\r\n        return false;\r\n    } catch (IOException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.vladsch.flexmark.samples.CustomLinkResolverSample.main",
	"Comment": "use the parser to parse and renderer to render with pegdown compatibility",
	"Method": "void main(String[] args){\r\n    Node document = PARSER.parse(\"This is *Sparta* [[document]] and this is not a link [bar](/url)\");\r\n    String html = RENDERER.render(document);\r\n    System.out.println(html);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteSerializer.extractLocalPathFromResourceName",
	"Comment": "decodes a fully qualified resource name into a resource path and validates that there is aproject and database encoded in the path along with a local path.",
	"Method": "ResourcePath extractLocalPathFromResourceName(ResourcePath resourceName){\r\n    Assert.hardAssert(resourceName.length() > 4 && resourceName.getSegment(4).equals(\"documents\"), \"Tried to deserialize invalid key %s\", resourceName);\r\n    return resourceName.popFirst(5);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LruGarbageCollector.nthSequenceNumber",
	"Comment": "returns the nth sequence number, counting in order from the smallest.",
	"Method": "long nthSequenceNumber(int count){\r\n    if (count == 0) {\r\n        return ListenSequence.INVALID;\r\n    }\r\n    RollingSequenceNumberBuffer buffer = new RollingSequenceNumberBuffer(count);\r\n    delegate.forEachTarget(queryData -> buffer.addElement(queryData.getSequenceNumber()));\r\n    delegate.forEachOrphanedDocumentSequenceNumber(buffer::addElement);\r\n    return buffer.getMaxValue();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.EventManager.removeQueryListener",
	"Comment": "removes a previously added listener and returns true if the listener was found.",
	"Method": "boolean removeQueryListener(QueryListener listener){\r\n    Query query = listener.getQuery();\r\n    QueryListenersInfo queryInfo = queries.get(query);\r\n    boolean lastListen = false;\r\n    boolean found = false;\r\n    if (queryInfo != null) {\r\n        found = queryInfo.listeners.remove(listener);\r\n        lastListen = queryInfo.listeners.isEmpty();\r\n    }\r\n    if (lastListen) {\r\n        queries.remove(query);\r\n        syncEngine.stopListening(query);\r\n    }\r\n    return found;\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.AnnotationNavigateAllListener.getArgsFunction",
	"Comment": "get a function that retrieves argument value based on argument class.",
	"Method": "Function<Class<?>, Object> getArgsFunction(String url,WebDriver driver,Direction direction){\r\n    return input -> {\r\n        if (input.isAssignableFrom(String.class)) {\r\n            return url;\r\n        }\r\n        if (input.isAssignableFrom(WebDriver.class)) {\r\n            return driver;\r\n        }\r\n        if (input.isAssignableFrom(Direction.class)) {\r\n            return direction;\r\n        }\r\n        return null;\r\n    };\r\n}"
}, {
	"Path": "io.flutter.run.FlutterRunConfigurationProducer.getDartFile",
	"Comment": "returns the dart file at the current location, or null if not a match.",
	"Method": "DartFile getDartFile(ConfigurationContext context){\r\n    return FlutterUtils.getDartFile(context.getPsiLocation());\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.SyncEngine.stopListening",
	"Comment": "stops listening to a query previously listened to via listen.",
	"Method": "void stopListening(Query query){\r\n    assertCallback(\"stopListening\");\r\n    QueryView queryView = queryViewsByQuery.get(query);\r\n    hardAssert(queryView != null, \"Trying to stop listening to a query not found\");\r\n    localStore.releaseQuery(query);\r\n    remoteStore.stopListening(queryView.getTargetId());\r\n    removeAndCleanupQuery(queryView);\r\n}"
}, {
	"Path": "io.flutter.preview.RenderHelper.setOffset",
	"Comment": "set the offset in the current file, and render if a new widget.",
	"Method": "void setOffset(int offset){\r\n    final FlutterOutline previousWidgetOutline = myWidgetOutline;\r\n    myWidgetOutline = getContainingWidgetOutline(offset);\r\n    if (myWidgetOutline == null) {\r\n        myRenderThread.setRequest(null);\r\n        myListener.onFailure(RenderProblemKind.NO_WIDGET, null);\r\n    } else if (myWidgetOutline.getRenderConstructor() == null) {\r\n        myRenderThread.setRequest(null);\r\n        myListener.onFailure(RenderProblemKind.NOT_RENDERABLE_WIDGET, myWidgetOutline);\r\n        myWidgetOutline = null;\r\n    } else if (myWidgetOutline != previousWidgetOutline) {\r\n        myListener.onRenderableWidget(myWidgetOutline);\r\n        scheduleRendering();\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.database.core.utilities.encoding.CustomClassMapper.convertToCustomClass",
	"Comment": "converts a standard library java representation of json data to an object of the class providedthrough the generictypeindicator",
	"Method": "T convertToCustomClass(Object object,Class<T> clazz,T convertToCustomClass,Object object,GenericTypeIndicator<T> typeIndicator){\r\n    Class<?> clazz = typeIndicator.getClass();\r\n    Type genericTypeIndicatorType = clazz.getGenericSuperclass();\r\n    if (genericTypeIndicatorType instanceof ParameterizedType) {\r\n        ParameterizedType parameterizedType = (ParameterizedType) genericTypeIndicatorType;\r\n        if (!parameterizedType.getRawType().equals(GenericTypeIndicator.class)) {\r\n            throw new DatabaseException(\"Not a direct subclass of GenericTypeIndicator: \" + genericTypeIndicatorType);\r\n        }\r\n        Type type = parameterizedType.getActualTypeArguments()[0];\r\n        return deserializeToType(object, type);\r\n    } else {\r\n        throw new DatabaseException(\"Not a direct subclass of GenericTypeIndicator: \" + genericTypeIndicatorType);\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LocalStoreTestCase.assertNotContains",
	"Comment": "asserts that the given local store does not contain the given document.",
	"Method": "void assertNotContains(String keyPathString){\r\n    DocumentKey key = DocumentKey.fromPathString(keyPathString);\r\n    MaybeDocument actual = localStore.readDocument(key);\r\n    assertNull(actual);\r\n}"
}, {
	"Path": "org.fluentlenium.core.proxy.LocatorProxies.first",
	"Comment": "creates a proxy element matching the first element of the list.",
	"Method": "WebElement first(List<WebElement> proxy){\r\n    LocatorHandler locatorHandler = getLocatorHandler(proxy);\r\n    return createWebElement(new FirstElementLocator(locatorHandler.getLocator()));\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.SQLiteSchema.ifTablesDontExist",
	"Comment": "used to assert that a set of tables either all exist or not. the supplied function is run ifnone of the tables exist. use this method to create a set of tables at once.if some but not all of the tables exist, an exception will be thrown.",
	"Method": "void ifTablesDontExist(String[] tables,Runnable fn){\r\n    boolean tablesFound = false;\r\n    String allTables = \"[\" + TextUtils.join(\", \", tables) + \"]\";\r\n    for (int i = 0; i < tables.length; i++) {\r\n        String table = tables[i];\r\n        boolean tableFound = tableExists(table);\r\n        if (i == 0) {\r\n            tablesFound = tableFound;\r\n        } else if (tableFound != tablesFound) {\r\n            String msg = \"Expected all of \" + allTables + \" to either exist or not, but \";\r\n            if (tablesFound) {\r\n                msg += tables[0] + \" exists and \" + table + \" does not\";\r\n            } else {\r\n                msg += tables[0] + \" does not exist and \" + table + \" does\";\r\n            }\r\n            throw new IllegalStateException(msg);\r\n        }\r\n    }\r\n    if (!tablesFound) {\r\n        fn.run();\r\n    } else {\r\n        Log.d(\"SQLiteSchema\", \"Skipping migration because all of \" + allTables + \" already exist\");\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.ComparableTimSort.gallopRight",
	"Comment": "like gallopleft, except that if the range contains an element equal to key, gallopright returns the index after therightmost equal element.",
	"Method": "int gallopRight(Comparable<Object> key,Object[] a,int base,int len,int hint){\r\n    if (DEBUG)\r\n        assert len > 0 && hint >= 0 && hint < len;\r\n    int ofs = 1;\r\n    int lastOfs = 0;\r\n    if (key.compareTo(a[base + hint]) < 0) {\r\n        int maxOfs = hint + 1;\r\n        while (ofs < maxOfs && key.compareTo(a[base + hint - ofs]) < 0) {\r\n            lastOfs = ofs;\r\n            ofs = (ofs << 1) + 1;\r\n            if (ofs <= 0)\r\n                ofs = maxOfs;\r\n        }\r\n        if (ofs > maxOfs)\r\n            ofs = maxOfs;\r\n        int tmp = lastOfs;\r\n        lastOfs = hint - ofs;\r\n        ofs = hint - tmp;\r\n    } else {\r\n        int maxOfs = len - hint;\r\n        while (ofs < maxOfs && key.compareTo(a[base + hint + ofs]) >= 0) {\r\n            lastOfs = ofs;\r\n            ofs = (ofs << 1) + 1;\r\n            if (ofs <= 0)\r\n                ofs = maxOfs;\r\n        }\r\n        if (ofs > maxOfs)\r\n            ofs = maxOfs;\r\n        lastOfs += hint;\r\n        ofs += hint;\r\n    }\r\n    if (DEBUG)\r\n        assert -1 <= lastOfs && lastOfs < ofs && ofs <= len;\r\n    lastOfs++;\r\n    while (lastOfs < ofs) {\r\n        int m = lastOfs + ((ofs - lastOfs) >>> 1);\r\n        if (key.compareTo(a[base + m]) < 0)\r\n            ofs = m;\r\n        else\r\n            lastOfs = m + 1;\r\n    }\r\n    if (DEBUG)\r\n        assert lastOfs == ofs;\r\n    return ofs;\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.ObjectMap.shrink",
	"Comment": "reduces the size of the backing arrays to be the specified capacity or less. if the capacity is already less, nothing isdone. if the map contains more items than the specified capacity, the next highest power of two capacity is used instead.",
	"Method": "void shrink(int maximumCapacity){\r\n    if (maximumCapacity < 0)\r\n        throw new IllegalArgumentException(\"maximumCapacity must be >= 0: \" + maximumCapacity);\r\n    if (size > maximumCapacity)\r\n        maximumCapacity = size;\r\n    if (capacity <= maximumCapacity)\r\n        return;\r\n    maximumCapacity = FXGLMath.nextPowerOfTwo(maximumCapacity);\r\n    resize(maximumCapacity);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.DocumentSnapshot.contains",
	"Comment": "returns whether or not the field exists in the document. returns false if the document does notexist.",
	"Method": "boolean contains(String field,boolean contains,FieldPath fieldPath){\r\n    checkNotNull(fieldPath, \"Provided field path must not be null.\");\r\n    return (doc != null) && (doc.getField(fieldPath.getInternalPath()) != null);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.RemoteDocumentCacheTestCase.testSetAndReadLotsOfDocuments",
	"Comment": "implementation of getall might split the input into several queries.",
	"Method": "void testSetAndReadLotsOfDocuments(){\r\n    int lotsOfDocuments = 2000;\r\n    List<String> paths = new ArrayList();\r\n    Map<DocumentKey, MaybeDocument> expected = new HashMap();\r\n    for (int i = 0; i < lotsOfDocuments; i++) {\r\n        String path = \"foo/\" + String.valueOf(i);\r\n        paths.add(path);\r\n        expected.put(DocumentKey.fromPathString(path), addTestDocumentAtPath(path));\r\n    }\r\n    Map<DocumentKey, MaybeDocument> read = getAll(paths);\r\n    assertEquals(expected, read);\r\n}"
}, {
	"Path": "org.inferred.freebuilder.processor.Declarations.upcastToGeneratedBuilder",
	"Comment": "upcasts a builder instance to the generated superclass, to allow access to private fields.",
	"Method": "Excerpt upcastToGeneratedBuilder(Block block,Metadata metadata,String builder){\r\n    return block.declare(Excerpts.add(\"// Upcast to access private fields; otherwise, oddly, we get an access violation.%n%s\", metadata.getGeneratedBuilder()), \"base\", Excerpts.add(builder));\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.ObjectMap.get",
	"Comment": "returns the value for the specified key, or the default value if the key is not in the map.",
	"Method": "V get(K key,V get,K key,V defaultValue){\r\n    int hashCode = key.hashCode();\r\n    int index = hashCode & mask;\r\n    if (!key.equals(keyTable[index])) {\r\n        index = hash2(hashCode);\r\n        if (!key.equals(keyTable[index])) {\r\n            index = hash3(hashCode);\r\n            if (!key.equals(keyTable[index]))\r\n                return getStash(key, defaultValue);\r\n        }\r\n    }\r\n    return valueTable[index];\r\n}"
}, {
	"Path": "org.fluentlenium.core.action.Fill.withText",
	"Comment": "set the values params as text for the fluentlist or search a new list with the css selector and filters and add thevalues param on it",
	"Method": "Fill withText(String textValues){\r\n    return with(textValues);\r\n}"
}, {
	"Path": "io.flutter.view.InspectorPanel.showDetailSubtrees",
	"Comment": "show the details subtree starting with node subtreeroot highlightingnode subtreeselection.",
	"Method": "void showDetailSubtrees(DiagnosticsNode subtreeRoot,DiagnosticsNode subtreeSelection){\r\n    assert (!legacyMode);\r\n    this.subtreeRoot = subtreeRoot;\r\n    myRootsTree.setHighlightedRoot(getSubtreeRootNode());\r\n    if (subtreePanel != null) {\r\n        subtreePanel.setSubtreeRoot(subtreeRoot, subtreeSelection);\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.ai.btree.decorator.SemaphoreGuard.start",
	"Comment": "acquires the semaphore. also, the first execution of this method retrieves the semaphore by name and stores it locally.\tthis method is called when the task is entered.",
	"Method": "void start(){\r\n    if (semaphore == null) {\r\n        semaphore = NonBlockingSemaphoreRepository.getSemaphore(name);\r\n    }\r\n    semaphoreAcquired = semaphore.acquire();\r\n    super.start();\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.reflect.Field.getType",
	"Comment": "returns a class object that identifies the declared type for the field.",
	"Method": "Class getType(){\r\n    return field.getType();\r\n}"
}, {
	"Path": "io.flutter.bazel.Workspace.getLaunchScript",
	"Comment": "returns the script that runs the bazel target for a flutter app, or null if not configured.",
	"Method": "String getLaunchScript(){\r\n    return (config == null) ? null : config.getLaunchScript();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.QueryCacheTestCase.removeQueryData",
	"Comment": "removes the given query data from the querycache under test, committing immediately.",
	"Method": "void removeQueryData(QueryData queryData){\r\n    persistence.runTransaction(\"removeQueryData\", () -> queryCache.removeQueryData(queryData));\r\n}"
}, {
	"Path": "io.flutter.run.test.TestFields.getPubRoot",
	"Comment": "returns the pubroot containing the file or directory being tested, or null if none.",
	"Method": "PubRoot getPubRoot(Project project){\r\n    final VirtualFile dir = getFileOrDir();\r\n    final PubRoot root = PubRoot.forFile(dir);\r\n    return root != null ? root : PubRoot.forDescendant(dir, project);\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.ClassObj.getFields",
	"Comment": "a list of fields in this class. does not include fields from superclasses.",
	"Method": "ElementList<FieldRef> getFields(){\r\n    return new ElementList<FieldRef>(json.get(\"fields\").getAsJsonArray()) {\r\n        @Override\r\n        protected FieldRef basicGet(JsonArray array, int index) {\r\n            return new FieldRef(array.get(index).getAsJsonObject());\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.ClassObj.getFields",
	"Comment": "a list of fields in this class. does not include fields from superclasses.",
	"Method": "ElementList<FieldRef> getFields(){\r\n    return new FieldRef(array.get(index).getAsJsonObject());\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Query.startAt",
	"Comment": "creates and returns a new query that starts at the provided fields relative to the order of thequery. the order of the field values must match the order of the order by clauses of the query.",
	"Method": "Query startAt(DocumentSnapshot snapshot,Query startAt,Object fieldValues){\r\n    Bound bound = boundFromFields(\"startAt\", fieldValues, true);\r\n    return new Query(query.startAt(bound), firestore);\r\n}"
}, {
	"Path": "org.fluentlenium.core.domain.FluentWebElement.displayed",
	"Comment": "return true if the element is displayed, other way return false",
	"Method": "boolean displayed(){\r\n    return webElement.isDisplayed();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.MaybeDocument.getVersion",
	"Comment": "returns the version of this document if it exists or a version at which this document wasguaranteed to not exist.",
	"Method": "SnapshotVersion getVersion(){\r\n    return version;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.VM.getStartTime",
	"Comment": "the time that the vm started in milliseconds since the epoch.suitable to pass to datetime.frommillisecondssinceepoch.",
	"Method": "int getStartTime(){\r\n    return json.get(\"startTime\") == null ? -1 : json.get(\"startTime\").getAsInt();\r\n}"
}, {
	"Path": "io.flutter.module.FlutterModuleBuilder.runFlutterCreateWithProgress",
	"Comment": "runs flutter create without showing a console, but with an indeterminate progress dialog.returns the pubroot if successful.",
	"Method": "PubRoot runFlutterCreateWithProgress(VirtualFile baseDir,FlutterSdk sdk,Project project,ProcessListener processListener,FlutterCreateAdditionalSettings additionalSettings){\r\n    final ProgressManager progress = ProgressManager.getInstance();\r\n    final AtomicReference<PubRoot> result = new AtomicReference(null);\r\n    FlutterUtils.disableGradleProjectMigrationNotification(project);\r\n    progress.runProcessWithProgressSynchronously(() -> {\r\n        progress.getProgressIndicator().setIndeterminate(true);\r\n        result.set(sdk.createFiles(baseDir, null, processListener, additionalSettings));\r\n    }, \"Creating Flutter Project\", false, project);\r\n    return result.get();\r\n}"
}, {
	"Path": "com.google.cloud.datastore.core.number.IndexNumberDecoder.resultAsDouble",
	"Comment": "returns the decoded number as a double, or throws illegalargumentexception if not possible.",
	"Method": "double resultAsDouble(){\r\n    updateResultDoubleState();\r\n    if (!doubleResultRepProblemMessage.isEmpty()) {\r\n        throw new IllegalArgumentException(doubleResultRepProblemMessage);\r\n    }\r\n    return resultAsDouble;\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.IntArray.shrink",
	"Comment": "reduces the size of the backing array to the size of the actual items. this is useful to release memory when many itemshave been removed, or if it is known that more items will not be added.",
	"Method": "int[] shrink(){\r\n    if (items.length != size)\r\n        resize(size);\r\n    return items;\r\n}"
}, {
	"Path": "io.flutter.dart.FlutterDartAnalysisServer.getOriginalOffset",
	"Comment": "must use it right before sending any offsets and lengths to the analysisserver.",
	"Method": "int getOriginalOffset(VirtualFile file,int convertedOffset){\r\n    final Method method = ReflectionUtil.getDeclaredMethod(analysisService.getClass(), \"getOriginalOffset\", VirtualFile.class, int.class);\r\n    if (method != null) {\r\n        try {\r\n            return (Integer) method.invoke(analysisService, file, convertedOffset);\r\n        } catch (Throwable ignored) {\r\n        }\r\n    }\r\n    return convertedOffset;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.World.createParticleGroup",
	"Comment": "create a particle group whose properties have been defined. no reference to the definition isretained. this function is locked during callbacks.",
	"Method": "ParticleGroup createParticleGroup(ParticleGroupDef def){\r\n    assertNotLocked();\r\n    return particleSystem.createParticleGroup(def);\r\n}"
}, {
	"Path": "org.inferred.freebuilder.processor.util.testing.Model.start",
	"Comment": "starts up the compiler thread and waits for it to return the processing environment.",
	"Method": "void start(){\r\n    checkState(executorService == null, \"Cannot restart a Model\");\r\n    executorService = Executors.newSingleThreadExecutor();\r\n    requestQueue = new SynchronousQueue<GenerationRequest>();\r\n    CompilerRunner compilerRunner = new CompilerRunner();\r\n    executorService.execute(compilerRunner);\r\n    processingEnv = compilerRunner.getProcessingEnvironment();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Query.whereGreaterThanOrEqualTo",
	"Comment": "creates and returns a new query with the additional filter that documents must contain thespecified field and the value should be greater than or equal to the specified value.",
	"Method": "Query whereGreaterThanOrEqualTo(String field,Object value,Query whereGreaterThanOrEqualTo,FieldPath fieldPath,Object value){\r\n    return whereHelper(fieldPath, Operator.GREATER_THAN_OR_EQUAL, value);\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.graph.util.GraphQueryUtil.getNodeCount",
	"Comment": "execute a query with the number of nodes group matching the query.with the option to specify bind parameters.",
	"Method": "int getNodeCount(String query,GraphDatabaseService db,int getNodeCount,String query,Map<String, Object> params,GraphDatabaseService db){\r\n    Result resNodes = db.execute(query, params);\r\n    int count = 0;\r\n    for (Map<String, Object> node : iterable(resNodes)) {\r\n        count++;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Breakpoint.getIsSyntheticAsyncContinuation",
	"Comment": "is this a breakpoint that was added synthetically as part of a step overasyncsuspension resumecommand?can return null.",
	"Method": "boolean getIsSyntheticAsyncContinuation(){\r\n    return json.get(\"isSyntheticAsyncContinuation\") == null ? false : json.get(\"isSyntheticAsyncContinuation\").getAsBoolean();\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Event.getBytes",
	"Comment": "an array of bytes, encoded as a base64 string.this is provided for the writeevent event.can return null.",
	"Method": "String getBytes(){\r\n    return json.get(\"bytes\") == null ? null : json.get(\"bytes\").getAsString();\r\n}"
}, {
	"Path": "com.google.firebase.components.Component.isLazy",
	"Comment": "returns whether a component is lazy.meaning that it will be instantiated only when it is requested.",
	"Method": "boolean isLazy(){\r\n    return instantiation == Instantiation.LAZY;\r\n}"
}, {
	"Path": "io.flutter.FlutterUtils.getDartFile",
	"Comment": "returns the dart file for the given psielement, or null if not a match.",
	"Method": "DartFile getDartFile(PsiElement elt){\r\n    if (elt == null)\r\n        return null;\r\n    final PsiFile psiFile = elt.getContainingFile();\r\n    if (!(psiFile instanceof DartFile))\r\n        return null;\r\n    return (DartFile) psiFile;\r\n}"
}, {
	"Path": "com.baidu.unbiz.fluentvalidator.FluentValidator.doOn",
	"Comment": "todo that would be much more easier if leveraging java8 lambda feature",
	"Method": "MultiValidatorElement doOn(T t){\r\n    if (registry == null) {\r\n        throw new RuntimeValidateException(\"When annotation-based validation enabled, one must use configure\" + \"(Registry) method to let FluentValidator know where to search and get validator instances\");\r\n    }\r\n    List<AnnotationValidator> anntValidatorsOfAllFields = AnnotationValidatorCache.getAnnotationValidator(registry, t);\r\n    if (CollectionUtil.isEmpty(anntValidatorsOfAllFields)) {\r\n        return new MultiValidatorElement(Collections.EMPTY_LIST);\r\n    }\r\n    List<ValidatorElement> elementList = CollectionUtil.createArrayList();\r\n    for (final AnnotationValidator anntValidatorOfOneField : anntValidatorsOfAllFields) {\r\n        Object realTarget = ReflectionUtil.invokeMethod(anntValidatorOfOneField.getMethod(), t);\r\n        if (!CollectionUtil.isEmpty(anntValidatorOfOneField.getValidators())) {\r\n            if (!ArrayUtil.hasIntersection(anntValidatorOfOneField.getGroups(), groups)) {\r\n                LOGGER.debug(String.format(\"Current groups: %s not match %s\", Arrays.toString(groups), anntValidatorOfOneField));\r\n                continue;\r\n            }\r\n            if (!ArrayUtil.isEmpty(excludeGroups)) {\r\n                if (ArrayUtil.hasIntersection(anntValidatorOfOneField.getGroups(), excludeGroups)) {\r\n                    LOGGER.debug(String.format(\"Current groups: %s will be ignored because you specify %s\", Arrays.toString(excludeGroups), anntValidatorOfOneField));\r\n                    continue;\r\n                }\r\n            }\r\n            for (final Validator v : anntValidatorOfOneField.getValidators()) {\r\n                elementList.add(new ValidatorElement(realTarget, v, new ToStringable() {\r\n                    @Override\r\n                    public String toString() {\r\n                        return String.format(\"%s#%s@%s\", t.getClass().getSimpleName(), anntValidatorOfOneField.getField().getName(), v);\r\n                    }\r\n                }));\r\n            }\r\n        }\r\n        if (anntValidatorOfOneField.isCascade()) {\r\n            Field field = anntValidatorOfOneField.getField();\r\n            if (Collection.class.isAssignableFrom(field.getType())) {\r\n                onEach((Collection) realTarget);\r\n            } else if (field.getType().isArray()) {\r\n                onEach(ArrayUtil.toWrapperIfPrimitive(realTarget));\r\n            } else {\r\n                on(realTarget);\r\n            }\r\n        }\r\n    }\r\n    MultiValidatorElement m = new MultiValidatorElement(elementList);\r\n    validatorElementList.add(m);\r\n    return m;\r\n}"
}, {
	"Path": "com.baidu.unbiz.fluentvalidator.FluentValidator.doOn",
	"Comment": "todo that would be much more easier if leveraging java8 lambda feature",
	"Method": "MultiValidatorElement doOn(T t){\r\n    return String.format(\"%s#%s@%s\", t.getClass().getSimpleName(), anntValidatorOfOneField.getField().getName(), v);\r\n}"
}, {
	"Path": "com.almasb.fxgl.particle.ParticleEmitter.setExpireFunction",
	"Comment": "expire function is used to obtain expire time for particles.",
	"Method": "void setExpireFunction(Function<Integer, Duration> expireFunction){\r\n    this.expireFunction = expireFunction;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.ApiUtil.newInstance",
	"Comment": "creates a new instance of the type from the given constructor, converting checked exceptions tounchecked.",
	"Method": "T newInstance(Constructor<T> constructor){\r\n    try {\r\n        return constructor.newInstance();\r\n    } catch (InstantiationException e) {\r\n        throw new RuntimeException(e);\r\n    } catch (IllegalAccessException e) {\r\n        throw new RuntimeException(e);\r\n    } catch (InvocationTargetException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.PhysicsComponent.applyForce",
	"Comment": "apply a force at a world point. if the force is not applied at the center of mass, it will generate a torque and affect the angular velocity. this wakes up the body.",
	"Method": "void applyForce(Point2D force,Point2D point){\r\n    applyBodyForce(physicsWorld.toVector(force), physicsWorld.toPoint(point));\r\n}"
}, {
	"Path": "com.almasb.fxgl.extra.entity.components.RechargeableComponent.restorePercentageCurrent",
	"Comment": "restore component by given percentage. the percentage is calculated fromcurrent value.",
	"Method": "void restorePercentageCurrent(double value){\r\n    restore(value / 100 * getValue());\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.onException",
	"Comment": "add a listener that will be invoked after an exception occurred.",
	"Method": "EventsRegistry onException(ExceptionListener listener){\r\n    onException.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.Array.removeValue",
	"Comment": "removes the first instance of the specified value in the array.",
	"Method": "boolean removeValue(T value,boolean identity){\r\n    T[] items = this.items;\r\n    if (identity || value == null) {\r\n        for (int i = 0, n = size; i < n; i++) {\r\n            if (items[i] == value) {\r\n                removeIndex(i);\r\n                return true;\r\n            }\r\n        }\r\n    } else {\r\n        for (int i = 0, n = size; i < n; i++) {\r\n            if (value.equals(items[i])) {\r\n                removeIndex(i);\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.WriteStream.setLastStreamToken",
	"Comment": "sets the last received stream token from the server, replacing any value the stream has trackedfor itself.",
	"Method": "void setLastStreamToken(ByteString streamToken){\r\n    this.lastStreamToken = checkNotNull(streamToken);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.Query.getOrderBy",
	"Comment": "returns the full list of ordering constraints on the query.this might include additional sort orders added implicitly to match the backend behavior.",
	"Method": "List<OrderBy> getOrderBy(){\r\n    if (memoizedOrderBy == null) {\r\n        FieldPath inequalityField = inequalityField();\r\n        FieldPath firstOrderByField = getFirstOrderByField();\r\n        if (inequalityField != null && firstOrderByField == null) {\r\n            if (inequalityField.isKeyField()) {\r\n                this.memoizedOrderBy = Collections.singletonList(KEY_ORDERING_ASC);\r\n            } else {\r\n                memoizedOrderBy = Arrays.asList(OrderBy.getInstance(Direction.ASCENDING, inequalityField), KEY_ORDERING_ASC);\r\n            }\r\n        } else {\r\n            List<OrderBy> res = new ArrayList();\r\n            boolean foundKeyOrdering = false;\r\n            for (OrderBy explicit : explicitSortOrder) {\r\n                res.add(explicit);\r\n                if (explicit.getField().equals(FieldPath.KEY_PATH)) {\r\n                    foundKeyOrdering = true;\r\n                }\r\n            }\r\n            if (!foundKeyOrdering) {\r\n                Direction lastDirection = explicitSortOrder.size() > 0 ? explicitSortOrder.get(explicitSortOrder.size() - 1).getDirection() : Direction.ASCENDING;\r\n                res.add(lastDirection.equals(Direction.ASCENDING) ? KEY_ORDERING_ASC : KEY_ORDERING_DESC);\r\n            }\r\n            memoizedOrderBy = res;\r\n        }\r\n    }\r\n    return memoizedOrderBy;\r\n}"
}, {
	"Path": "io.flutter.run.daemon.FlutterApp.shutdownAsync",
	"Comment": "starts shutting down the process.if possible, we want to shut down gracefully by sending a stop command to the application.",
	"Method": "Future shutdownAsync(){\r\n    final FutureTask done = new FutureTask(() -> null);\r\n    if (!changeState(State.TERMINATING)) {\r\n        done.run();\r\n        return done;\r\n    }\r\n    if (myResume != null) {\r\n        myResume.run();\r\n    }\r\n    final String appId = myAppId;\r\n    if (appId == null) {\r\n        myProcessHandler.destroyProcess();\r\n        done.run();\r\n        return done;\r\n    }\r\n    AppExecutorUtil.getAppExecutorService().submit(() -> {\r\n        final Future stopDone = myDaemonApi.stopApp(appId);\r\n        final Stopwatch watch = Stopwatch.createStarted();\r\n        while (watch.elapsed(TimeUnit.SECONDS) < 10 && getState() == State.TERMINATING) {\r\n            try {\r\n                stopDone.get(100, TimeUnit.MILLISECONDS);\r\n                break;\r\n            } catch (TimeoutException e) {\r\n            } catch (Exception e) {\r\n                LOG.warn(e);\r\n                break;\r\n            }\r\n        }\r\n        myProcessHandler.destroyProcess();\r\n        myDaemonApi.cancelPending();\r\n        done.run();\r\n    });\r\n    return done;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.WriteBatch.update",
	"Comment": "updates fields in the document referred to by the provided documentreference. if no documentexists yet, the update will fail.",
	"Method": "WriteBatch update(DocumentReference documentRef,Map<String, Object> data,WriteBatch update,DocumentReference documentRef,String field,Object value,Object moreFieldsAndValues,WriteBatch update,DocumentReference documentRef,FieldPath fieldPath,Object value,Object moreFieldsAndValues,WriteBatch update,DocumentReference documentRef,ParsedUpdateData updateData){\r\n    firestore.validateReference(documentRef);\r\n    verifyNotCommitted();\r\n    mutations.addAll(updateData.toMutationList(documentRef.getKey(), Precondition.exists(true)));\r\n    return this;\r\n}"
}, {
	"Path": "org.fluentlenium.core.filter.matcher.CalculateService.contains",
	"Comment": "check if the current value contains the patternvalue or the referencevalue",
	"Method": "boolean contains(Pattern patternValue,String referenceValue,String currentValue){\r\n    if (currentValue == null) {\r\n        return false;\r\n    }\r\n    if (patternValue == null) {\r\n        return currentValue.contains(referenceValue);\r\n    }\r\n    return patternValue.matcher(currentValue).find();\r\n}"
}, {
	"Path": "com.google.firebase.database.core.WriteTree.layerTree",
	"Comment": "static method. given an array of writerecords, a filter for which ones to include, and a path,construct a merge at that path.",
	"Method": "CompoundWrite layerTree(List<UserWriteRecord> writes,Predicate<UserWriteRecord> filter,Path treeRoot){\r\n    CompoundWrite compoundWrite = CompoundWrite.emptyWrite();\r\n    for (UserWriteRecord write : writes) {\r\n        if (filter.evaluate(write)) {\r\n            Path writePath = write.getPath();\r\n            if (write.isOverwrite()) {\r\n                if (treeRoot.contains(writePath)) {\r\n                    Path relativePath = Path.getRelative(treeRoot, writePath);\r\n                    compoundWrite = compoundWrite.addWrite(relativePath, write.getOverwrite());\r\n                } else if (writePath.contains(treeRoot)) {\r\n                    compoundWrite = compoundWrite.addWrite(Path.getEmptyPath(), write.getOverwrite().getChild(Path.getRelative(writePath, treeRoot)));\r\n                } else {\r\n                }\r\n            } else {\r\n                if (treeRoot.contains(writePath)) {\r\n                    Path relativePath = Path.getRelative(treeRoot, writePath);\r\n                    compoundWrite = compoundWrite.addWrites(relativePath, write.getMerge());\r\n                } else if (writePath.contains(treeRoot)) {\r\n                    Path relativePath = Path.getRelative(writePath, treeRoot);\r\n                    if (relativePath.isEmpty()) {\r\n                        compoundWrite = compoundWrite.addWrites(Path.getEmptyPath(), write.getMerge());\r\n                    } else {\r\n                        Node deepNode = write.getMerge().getCompleteNode(relativePath);\r\n                        if (deepNode != null) {\r\n                            compoundWrite = compoundWrite.addWrite(Path.getEmptyPath(), deepNode);\r\n                        }\r\n                    }\r\n                } else {\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return compoundWrite;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.value.ObjectValue.set",
	"Comment": "returns a new objectvalue with the field at the named path set to value.",
	"Method": "ObjectValue set(FieldPath path,FieldValue value){\r\n    hardAssert(!path.isEmpty(), \"Cannot set field for empty path on ObjectValue\");\r\n    String childName = path.getFirstSegment();\r\n    if (path.length() == 1) {\r\n        return setChild(childName, value);\r\n    } else {\r\n        FieldValue child = internalValue.get(childName);\r\n        ObjectValue obj;\r\n        if (child instanceof ObjectValue) {\r\n            obj = (ObjectValue) child;\r\n        } else {\r\n            obj = emptyObject();\r\n        }\r\n        ObjectValue newChild = obj.set(path.popFirst(), value);\r\n        return setChild(childName, newChild);\r\n    }\r\n}"
}, {
	"Path": "io.flutter.run.LaunchState.getRunningAppProcess",
	"Comment": "returns the currently running app for the given runconfig, if any.",
	"Method": "ProcessHandler getRunningAppProcess(RunConfig config){\r\n    final Project project = config.getProject();\r\n    final List<RunContentDescriptor> runningProcesses = ExecutionManager.getInstance(project).getContentManager().getAllDescriptors();\r\n    for (RunContentDescriptor descriptor : runningProcesses) {\r\n        final ProcessHandler process = descriptor.getProcessHandler();\r\n        if (process != null && !process.isProcessTerminated() && process.getUserData(FLUTTER_RUN_CONFIG_KEY) == config) {\r\n            return process;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.Array.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items.useful before adding many items to avoid multiple backing array resizes.",
	"Method": "T[] ensureCapacity(int additionalCapacity,T[] ensureCapacity,int additionalCapacity){\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded > items.length)\r\n        resize(Math.max(8, sizeNeeded));\r\n    return items;\r\n}"
}, {
	"Path": "io.flutter.run.daemon.DeviceSelection.withSelection",
	"Comment": "returns a new snapshot with the given device id selected, if possible.",
	"Method": "DeviceSelection withSelection(String id){\r\n    return new DeviceSelection(devices, findById(devices, id).orElse(selection));\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Query.endAt",
	"Comment": "creates and returns a new query that ends at the provided fields relative to the order of thequery. the order of the field values must match the order of the order by clauses of the query.",
	"Method": "Query endAt(DocumentSnapshot snapshot,Query endAt,Object fieldValues){\r\n    Bound bound = boundFromFields(\"endAt\", fieldValues, false);\r\n    return new Query(query.endAt(bound), firestore);\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.beforeAlertDismiss",
	"Comment": "add a listener that will be invoked before an alert is dismissed.",
	"Method": "EventsRegistry beforeAlertDismiss(AlertListener listener){\r\n    beforeAlertDismiss.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.AsyncQueue.runDelayedTasksUntil",
	"Comment": "runs some or all delayed tasks early, blocking until completion.",
	"Method": "void runDelayedTasksUntil(TimerId lastTimerId){\r\n    runSync(() -> {\r\n        hardAssert(lastTimerId == TimerId.ALL || containsDelayedTask(lastTimerId), \"Attempted to run tasks until missing TimerId: %s\", lastTimerId);\r\n        Collections.sort(delayedTasks, (a, b) -> Long.compare(a.targetTimeMs, b.targetTimeMs));\r\n        for (DelayedTask delayedTask : new ArrayList(delayedTasks)) {\r\n            delayedTask.skipDelay();\r\n            if (lastTimerId != TimerId.ALL && delayedTask.timerId == lastTimerId) {\r\n                break;\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.google.firebase.firestore.CollectionReference.document",
	"Comment": "gets a documentreference instance that refers to the document at the specified path within thiscollection.",
	"Method": "DocumentReference document(DocumentReference document,String documentPath){\r\n    checkNotNull(documentPath, \"Provided document path must not be null.\");\r\n    return DocumentReference.forPath(query.getPath().append(ResourcePath.fromString(documentPath)), firestore);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.Bound.sortsBeforeDocument",
	"Comment": "returns true if a document sorts before a bound using the provided sort order.",
	"Method": "boolean sortsBeforeDocument(List<OrderBy> orderBy,Document document){\r\n    hardAssert(position.size() <= orderBy.size(), \"Bound has more components than query's orderBy\");\r\n    int comparison = 0;\r\n    for (int i = 0; i < position.size(); i++) {\r\n        OrderBy orderByComponent = orderBy.get(i);\r\n        FieldValue component = position.get(i);\r\n        if (orderByComponent.field.equals(FieldPath.KEY_PATH)) {\r\n            Object refValue = component.value();\r\n            hardAssert(refValue instanceof DocumentKey, \"Bound has a non-key value where the key path is being used %s\", component);\r\n            comparison = ((DocumentKey) refValue).compareTo(document.getKey());\r\n        } else {\r\n            FieldValue docValue = document.getField(orderByComponent.getField());\r\n            hardAssert(docValue != null, \"Field should exist since document matched the orderBy already.\");\r\n            comparison = component.compareTo(docValue);\r\n        }\r\n        if (orderByComponent.getDirection().equals(Direction.DESCENDING)) {\r\n            comparison = comparison * -1;\r\n        }\r\n        if (comparison != 0) {\r\n            break;\r\n        }\r\n    }\r\n    return before ? comparison <= 0 : comparison < 0;\r\n}"
}, {
	"Path": "com.google.firebase.database.core.SyncTree.applyTaggedQueryMerge",
	"Comment": "apply server data to be merged in for the specified tagged query.",
	"Method": "List<? extends Event> applyTaggedQueryMerge(Path path,Map<Path, Node> changedChildren,Tag tag){\r\n    return persistenceManager.runInTransaction(new Callable<List<? extends Event>>() {\r\n        @Override\r\n        public List<? extends Event> call() {\r\n            QuerySpec query = queryForTag(tag);\r\n            if (query != null) {\r\n                Path relativePath = Path.getRelative(query.getPath(), path);\r\n                CompoundWrite merge = CompoundWrite.fromPathMerge(changedChildren);\r\n                persistenceManager.updateServerCache(path, merge);\r\n                Operation op = new Merge(OperationSource.forServerTaggedQuery(query.getParams()), relativePath, merge);\r\n                return applyTaggedOperation(query, op);\r\n            } else {\r\n                return Collections.emptyList();\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.google.firebase.database.core.SyncTree.applyTaggedQueryMerge",
	"Comment": "apply server data to be merged in for the specified tagged query.",
	"Method": "List<? extends Event> applyTaggedQueryMerge(Path path,Map<Path, Node> changedChildren,Tag tag){\r\n    QuerySpec query = queryForTag(tag);\r\n    if (query != null) {\r\n        Path relativePath = Path.getRelative(query.getPath(), path);\r\n        CompoundWrite merge = CompoundWrite.fromPathMerge(changedChildren);\r\n        persistenceManager.updateServerCache(path, merge);\r\n        Operation op = new Merge(OperationSource.forServerTaggedQuery(query.getParams()), relativePath, merge);\r\n        return applyTaggedOperation(query, op);\r\n    } else {\r\n        return Collections.emptyList();\r\n    }\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Field.getOwner",
	"Comment": "the owner of this field, which can be either a library or a class.",
	"Method": "ObjRef getOwner(){\r\n    return new ObjRef((JsonObject) json.get(\"owner\"));\r\n}"
}, {
	"Path": "io.flutter.pub.PubRoot.isFlutterModule",
	"Comment": "returns true if the directory content looks like a flutter module.",
	"Method": "boolean isFlutterModule(){\r\n    return root.findChild(\".android\") != null;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.IsolateRef.getNumber",
	"Comment": "a numeric id for this isolate, represented as a string. unique.",
	"Method": "String getNumber(){\r\n    return json.get(\"number\").getAsString();\r\n}"
}, {
	"Path": "org.fluentlenium.utils.ReflectionUtils.getConstructor",
	"Comment": "retrieve the constructor of a class for given argument types.",
	"Method": "Constructor<T> getConstructor(Class<T> cls,Object args,Constructor<T> getConstructor,Class<T> cls,Class<?> argsTypes){\r\n    if (argsTypes == null || argsTypes.length == 0) {\r\n        return cls.getDeclaredConstructor();\r\n    }\r\n    try {\r\n        return cls.getDeclaredConstructor(argsTypes);\r\n    } catch (NoSuchMethodException e) {\r\n        for (Constructor<?> constructor : cls.getDeclaredConstructors()) {\r\n            if (isMatchingConstructor(constructor, argsTypes)) {\r\n                return (Constructor<T>) constructor;\r\n            }\r\n        }\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "org.dartlang.analysis.server.protocol.FlutterOutlineAttribute.getLiteralValueInteger",
	"Comment": "the integer literal value of the attribute. this field is absent if the value is not an integerliteral.",
	"Method": "Integer getLiteralValueInteger(){\r\n    return literalValueInteger;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.World.setContactListener",
	"Comment": "register a contact event listener. the listener is owned by you and must remain in scope.",
	"Method": "void setContactListener(ContactListener listener){\r\n    contactManager.setContactListener(listener);\r\n}"
}, {
	"Path": "com.almasb.fxgl.scene.FXGLMenu.fireResume",
	"Comment": "can only be fired from game menu.will close the menu and unpause the game.",
	"Method": "void fireResume(){\r\n    log.debug(\"fireResume()\");\r\n    listener.onResume();\r\n}"
}, {
	"Path": "io.flutter.view.MultiIconSimpleColoredComponent.setIcon",
	"Comment": "adds the icon at the beginning of the line unlike addicon, which adds theicon after the already appended text.",
	"Method": "void setIcon(Icon icon){\r\n    assert (myIcons.size() == 0);\r\n    if (icon == null) {\r\n        return;\r\n    }\r\n    myIcons.add(new PositionedIcon(icon, 0));\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Func.getOwner",
	"Comment": "the owner of this function, which can be a library, class, or a function.",
	"Method": "Object getOwner(){\r\n    JsonObject elem = (JsonObject) json.get(\"owner\");\r\n    if (elem == null)\r\n        return null;\r\n    if (elem.get(\"type\").getAsString().equals(\"@Library\"))\r\n        return new LibraryRef(elem);\r\n    if (elem.get(\"type\").getAsString().equals(\"@Class\"))\r\n        return new ClassRef(elem);\r\n    if (elem.get(\"type\").getAsString().equals(\"@Func\"))\r\n        return new FuncRef(elem);\r\n    return null;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.UnresolvedSourceLocation.getTokenPos",
	"Comment": "an approximate token position for the source location. this may change when the location isresolved.can return null.",
	"Method": "int getTokenPos(){\r\n    return json.get(\"tokenPos\") == null ? -1 : json.get(\"tokenPos\").getAsInt();\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.joints.FrictionJointDef.initialize",
	"Comment": "initialize the bodies, anchors, axis, and reference angle using the world anchor and worldaxis.",
	"Method": "void initialize(Body bA,Body bB,Vec2 anchor){\r\n    bodyA = bA;\r\n    bodyB = bB;\r\n    bA.getLocalPointToOut(anchor, localAnchorA);\r\n    bB.getLocalPointToOut(anchor, localAnchorB);\r\n}"
}, {
	"Path": "com.google.cloud.datastore.core.number.NumberParts.representableAsLong",
	"Comment": "returns whether or not this numberparts can be represented as a long without loss of precision.",
	"Method": "boolean representableAsLong(){\r\n    return longRepresentationError() == null;\r\n}"
}, {
	"Path": "org.fluentlenium.assertj.custom.FluentListSizeBuilder.lessThanOrEqualTo",
	"Comment": "assert that actual list size is less than or equal to given size.",
	"Method": "Object lessThanOrEqualTo(int size){\r\n    if (actualSize > size) {\r\n        listAssert.failWithMessage(ACTUAL_SIZE + actualSize + \" is not less than or equal to: \" + size);\r\n    }\r\n    return listAssert;\r\n}"
}, {
	"Path": "com.google.firebase.database.core.WriteTree.calcCompleteChild",
	"Comment": "returns a complete child for a given server snap after applying all user writes or null ifthere is no complete child for this childkey.",
	"Method": "Node calcCompleteChild(Path treePath,ChildKey childKey,CacheNode existingServerSnap){\r\n    Path path = treePath.child(childKey);\r\n    Node shadowingNode = this.visibleWrites.getCompleteNode(path);\r\n    if (shadowingNode != null) {\r\n        return shadowingNode;\r\n    } else {\r\n        if (existingServerSnap.isCompleteForChild(childKey)) {\r\n            CompoundWrite childMerge = this.visibleWrites.childCompoundWrite(path);\r\n            return childMerge.apply(existingServerSnap.getNode().getImmediateChild(childKey));\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.fluentlenium.core.filter.MatcherConstructor.endsWith",
	"Comment": "create a matcher filtering by a string that ends with the matcher",
	"Method": "AbstractMatcher endsWith(String matcher,AbstractMatcher endsWith,Pattern pattern){\r\n    return new EndsWithMatcher(pattern);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.WriteBatch.commit",
	"Comment": "commits all of the writes in this write batch as a single atomic unit.",
	"Method": "Task<Void> commit(){\r\n    verifyNotCommitted();\r\n    committed = true;\r\n    if (mutations.size() > 0) {\r\n        return firestore.getClient().write(mutations);\r\n    } else {\r\n        return Tasks.forResult(null);\r\n    }\r\n}"
}, {
	"Path": "com.bartoszlipinski.flippablestackview.OrientedViewPager.addTouchables",
	"Comment": "we only want the current page that is being shown to be touchable.",
	"Method": "void addTouchables(ArrayList<View> views){\r\n    for (int i = 0; i < getChildCount(); i++) {\r\n        final View child = getChildAt(i);\r\n        if (child.getVisibility() == VISIBLE) {\r\n            ItemInfo ii = infoForChild(child);\r\n            if (ii != null && ii.position == mCurItem) {\r\n                child.addTouchables(views);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.FieldRef.getOwner",
	"Comment": "the owner of this field, which can be either a library or a class.",
	"Method": "ObjRef getOwner(){\r\n    return new ObjRef((JsonObject) json.get(\"owner\"));\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.Util.convertStatusException",
	"Comment": "if an exception is a statusexception, convert it to a firebasefirestoreexception. otherwise,leave it untouched.",
	"Method": "Exception convertStatusException(Exception e){\r\n    if (e instanceof StatusException) {\r\n        StatusException statusException = (StatusException) e;\r\n        return exceptionFromStatus(statusException.getStatus());\r\n    } else if (e instanceof StatusRuntimeException) {\r\n        StatusRuntimeException statusRuntimeException = (StatusRuntimeException) e;\r\n        return exceptionFromStatus(statusRuntimeException.getStatus());\r\n    } else {\r\n        return e;\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.FirebaseFirestore.getFirestoreSettings",
	"Comment": "returns the settings used by this firebasefirestore object.",
	"Method": "FirebaseFirestoreSettings getFirestoreSettings(){\r\n    return settings;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.AsyncQueue.removeDelayedTask",
	"Comment": "called by delayedtask to remove itself from our list of pending delayed tasks.",
	"Method": "void removeDelayedTask(DelayedTask task){\r\n    boolean found = delayedTasks.remove(task);\r\n    hardAssert(found, \"Delayed task not found.\");\r\n}"
}, {
	"Path": "com.vladsch.flexmark.ast.Node.getLastBlankLineChild",
	"Comment": "overridden by listblock and any others whose children propagate their blank line to parent",
	"Method": "Node getLastBlankLineChild(){\r\n    return null;\r\n}"
}, {
	"Path": "org.fluentlenium.core.filter.FilterBuilder.endsWith",
	"Comment": "builds a filter that match when selection ends with to a given pattern.",
	"Method": "AttributeFilter endsWith(String value,AttributeFilter endsWith,Pattern pattern){\r\n    return new AttributeFilter(attribute, new EndsWithMatcher(pattern));\r\n}"
}, {
	"Path": "io.flutter.view.MultiIconSimpleColoredComponent.setFocusBorderAroundIcon",
	"Comment": "sets whether focus border extends to icon or not. if so thencomponent also extends the selection.",
	"Method": "void setFocusBorderAroundIcon(boolean focusBorderAroundIcon){\r\n    myFocusBorderAroundIcon = focusBorderAroundIcon;\r\n    repaint();\r\n}"
}, {
	"Path": "com.almasb.fxgl.extra.entity.components.RechargeableComponent.isZero",
	"Comment": "check if value is 0. note that because internal value is a double,value of 0.xx will not return true.",
	"Method": "boolean isZero(){\r\n    return getValue() == 0;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.ErrorObj.getStacktrace",
	"Comment": "if this error is due to an unhandled exception, this is the stacktrace object.can return null.",
	"Method": "InstanceRef getStacktrace(){\r\n    return json.get(\"stacktrace\") == null ? null : new InstanceRef((JsonObject) json.get(\"stacktrace\"));\r\n}"
}, {
	"Path": "org.fluentlenium.core.filter.FilterBuilder.equalTo",
	"Comment": "builds a filter that match when selection is equal to a given value.",
	"Method": "AttributeFilter equalTo(String value){\r\n    return new AttributeFilter(attribute, new EqualMatcher(value));\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.beforeChangeValueOf",
	"Comment": "add a listener that will be invoked before changing value of an element.",
	"Method": "EventsRegistry beforeChangeValueOf(ElementListener listener){\r\n    beforeChangeValueOf.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "io.flutter.run.test.TestFields.getTestName",
	"Comment": "if not null, tests will only be run if their name contains this string.",
	"Method": "String getTestName(){\r\n    return testName;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.Datastore.overrideChannelBuilder",
	"Comment": "helper function to globally override the channel that rpcs use. useful for testing when youwant to bypass ssl certificate checking.",
	"Method": "void overrideChannelBuilder(Supplier<ManagedChannelBuilder<?>> channelBuilderSupplier){\r\n    Datastore.overrideChannelBuilderSupplier = channelBuilderSupplier;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Transaction.set",
	"Comment": "overwrites the document referred to by the provided documentreference. if the document does notyet exist, it will be created. if a document already exists, it will be overwritten.",
	"Method": "Transaction set(DocumentReference documentRef,Map<String, Object> data,Transaction set,DocumentReference documentRef,Map<String, Object> data,SetOptions options,Transaction set,DocumentReference documentRef,Object pojo,Transaction set,DocumentReference documentRef,Object pojo,SetOptions options){\r\n    return set(documentRef, firestore.getDataConverter().convertPOJO(pojo), options);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.MutationQueueTestCase.createBatches",
	"Comment": "creates a list of batches containing number dummy mutationbatches. each has adifferent batchid.",
	"Method": "List<MutationBatch> createBatches(int number){\r\n    List<MutationBatch> batches = new ArrayList(number);\r\n    for (int i = 0; i < number; i++) {\r\n        batches.add(addMutationBatch());\r\n    }\r\n    return batches;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.Logger.isDebugEnabled",
	"Comment": "returns true iff the logger is logging at debug level or above.",
	"Method": "boolean isDebugEnabled(){\r\n    return Logger.logLevel.ordinal() >= Level.DEBUG.ordinal();\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Isolate.getRootLib",
	"Comment": "the root library for this isolate.guaranteed to be initialized when the isolaterunnable event fires.can return null.",
	"Method": "LibraryRef getRootLib(){\r\n    return json.get(\"rootLib\") == null ? null : new LibraryRef((JsonObject) json.get(\"rootLib\"));\r\n}"
}, {
	"Path": "com.google.firebase.database.core.CompoundWrite.getCompleteChildren",
	"Comment": "returns all children that are guaranteed to be a complete overwrite.",
	"Method": "List<NamedNode> getCompleteChildren(){\r\n    List<NamedNode> children = new ArrayList<NamedNode>();\r\n    if (this.writeTree.getValue() != null) {\r\n        for (NamedNode entry : this.writeTree.getValue()) {\r\n            children.add(new NamedNode(entry.getName(), entry.getNode()));\r\n        }\r\n    } else {\r\n        for (Map.Entry<ChildKey, ImmutableTree<Node>> entry : this.writeTree.getChildren()) {\r\n            ImmutableTree<Node> childTree = entry.getValue();\r\n            if (childTree.getValue() != null) {\r\n                children.add(new NamedNode(entry.getKey(), childTree.getValue()));\r\n            }\r\n        }\r\n    }\r\n    return children;\r\n}"
}, {
	"Path": "testcode.sqli.stringbuilder.StringBuilderSuspicious.queryUnknownTransformation",
	"Comment": "i think this should be reported with low priority only, everything visible is constant",
	"Method": "UserEntity queryUnknownTransformation(String username,String onlyActive){\r\n    StringBuilder sql = new StringBuilder(\"select * from Users where name = usernameParam\");\r\n    sql.append(\" and active = true\");\r\n    modifyMe(sql);\r\n    return em.createQuery(sql.toString(), UserEntity.class).setParameter(\"usernameParam\", username).getSingleResult();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.mutation.MutationResult.getTransformResults",
	"Comment": "the resulting fields returned from the backend after a transformmutation has been committed.contains one fieldvalue for each fieldtransform that was in the mutation.will be null if the mutation was not a transformmutation.",
	"Method": "List<FieldValue> getTransformResults(){\r\n    return transformResults;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.WriteStream.isHandshakeComplete",
	"Comment": "tracks whether or not a handshake has been successfully exchanged and the stream is ready toaccept mutations.",
	"Method": "boolean isHandshakeComplete(){\r\n    return handshakeComplete;\r\n}"
}, {
	"Path": "testcasesupport.AbstractTestCaseServletBase.runTestSolo",
	"Comment": "this method runs a test on its own, creating a full html documentit is called from doget and dopost in this file",
	"Method": "void runTestSolo(HttpServletRequest request,HttpServletResponse response){\r\n    response.getWriter().println(\"<html><body>\");\r\n    runTest(request, response);\r\n    response.getWriter().println(\"<\/body><\/html>\");\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteStore.shutdown",
	"Comment": "shuts down the remote store, tearing down connections and otherwise cleaning up. this is notreversible and renders the remote store unusable.",
	"Method": "void shutdown(){\r\n    Logger.debug(LOG_TAG, \"Shutting down\");\r\n    networkEnabled = false;\r\n    this.disableNetworkInternal();\r\n    datastore.shutdown();\r\n    onlineStateTracker.updateState(OnlineState.UNKNOWN);\r\n}"
}, {
	"Path": "org.fluentlenium.utils.ReflectionUtils.getDeclaredMethodsWithAnnotation",
	"Comment": "get declared methods that have the given annotation defined.",
	"Method": "List<Method> getDeclaredMethodsWithAnnotation(Object object,Class<? extends Annotation> annotation,List<Method> getDeclaredMethodsWithAnnotation,Class<?> objectClass,Class<? extends Annotation> annotation){\r\n    List<Method> methods = new ArrayList();\r\n    if (objectClass == null) {\r\n        return methods;\r\n    }\r\n    ClassAnnotationKey cacheKey = new ClassAnnotationKey(objectClass, annotation);\r\n    if (DECLARED_METHODS_CACHE.containsKey(cacheKey)) {\r\n        return DECLARED_METHODS_CACHE.get(cacheKey);\r\n    }\r\n    Method[] declaredMethods = objectClass.getDeclaredMethods();\r\n    for (Method method : declaredMethods) {\r\n        if (method.isAnnotationPresent(annotation)) {\r\n            methods.add(method);\r\n        }\r\n    }\r\n    DECLARED_METHODS_CACHE.put(cacheKey, methods);\r\n    return methods;\r\n}"
}, {
	"Path": "testcode.xxe.DocumentBuilderSafeProperty.safeManualConfiguration",
	"Comment": "this implementation allow dtd but disable all its dangerous features.not sure it can still do something useful with dtd ...",
	"Method": "void safeManualConfiguration(){\r\n    DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\r\n    dbf.setFeature(\"http://xml.org/sax/features/external-general-entities\", true);\r\n    dbf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", true);\r\n    dbf.setXIncludeAware(false);\r\n    dbf.setExpandEntityReferences(false);\r\n    DocumentBuilder db = dbf.newDocumentBuilder();\r\n    Document doc = db.parse(getInputFile());\r\n    print(doc);\r\n}"
}, {
	"Path": "com.vladsch.flexmark.internal.InlineParserImpl.parseDelimiters",
	"Comment": "attempt to parse delimiters like emphasis, strong emphasis or custom delimiters.",
	"Method": "boolean parseDelimiters(DelimiterProcessor delimiterProcessor,char delimiterChar){\r\n    DelimiterData res = scanDelimiters(delimiterProcessor, delimiterChar);\r\n    if (res == null) {\r\n        return false;\r\n    }\r\n    int numDelims = res.count;\r\n    int startIndex = index;\r\n    index += numDelims;\r\n    Text node = appendSeparateText(input.subSequence(startIndex, index));\r\n    this.lastDelimiter = new Delimiter(input, node, delimiterChar, res.canOpen, res.canClose, this.lastDelimiter, startIndex);\r\n    this.lastDelimiter.numDelims = numDelims;\r\n    if (this.lastDelimiter.previous != null) {\r\n        this.lastDelimiter.previous.next = this.lastDelimiter;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.WatchStream.unwatchTarget",
	"Comment": "unregisters interest in the results of the query associated with the given target id.",
	"Method": "void unwatchTarget(int targetId){\r\n    hardAssert(isOpen(), \"Unwatching targets requires an open stream\");\r\n    ListenRequest request = ListenRequest.newBuilder().setDatabase(serializer.databaseName()).setRemoveTarget(targetId).build();\r\n    writeRequest(request);\r\n}"
}, {
	"Path": "io.flutter.pub.PubRoot.getRelativePath",
	"Comment": "returns the relative path to a file or directory within this pubroot.returns null for the pub root directory, or it not within the pub root.",
	"Method": "String getRelativePath(VirtualFile file){\r\n    final String root = this.root.getPath();\r\n    final String path = file.getPath();\r\n    if (!path.startsWith(root) || path.length() < root.length() + 2) {\r\n        return null;\r\n    }\r\n    return path.substring(root.length() + 1);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.AbstractStream.handleServerClose",
	"Comment": "called when grpc closes the stream, which should always be due to some error.",
	"Method": "void handleServerClose(Status status){\r\n    hardAssert(isStarted(), \"Can't handle server close on non-started stream!\");\r\n    close(State.Error, status);\r\n}"
}, {
	"Path": "com.google.firebase.storage.StorageReference.getDownloadUrl",
	"Comment": "asynchronously retrieves a long lived download url with a revokable token. this can be used toshare the file with others, but can be revoked by a developer in the firebase console ifdesired.",
	"Method": "Task<Uri> getDownloadUrl(){\r\n    TaskCompletionSource<Uri> pendingResult = new TaskCompletionSource();\r\n    StorageTaskScheduler.getInstance().scheduleCommand(new GetDownloadUrlTask(this, pendingResult));\r\n    return pendingResult.getTask();\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Body.applyForce",
	"Comment": "apply a force at a world point.if the force is not applied at the center of mass, it will generate a torque and affect the angular velocity.this wakes up the body.",
	"Method": "void applyForce(Vec2 force,Vec2 point){\r\n    applyForceToCenter(force);\r\n    m_torque += (point.x - m_sweep.c.x) * force.y - (point.y - m_sweep.c.y) * force.x;\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.afterAlertAccept",
	"Comment": "add a listener that will be invoked after an alert is accepted.",
	"Method": "EventsRegistry afterAlertAccept(AlertListener listener){\r\n    afterAlertAccept.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LocalStore.writeLocally",
	"Comment": "accepts locally generated mutations and commits them to storage.",
	"Method": "LocalWriteResult writeLocally(List<Mutation> mutations){\r\n    Timestamp localWriteTime = Timestamp.now();\r\n    MutationBatch batch = persistence.runTransaction(\"Locally write mutations\", () -> mutationQueue.addMutationBatch(localWriteTime, mutations));\r\n    Set<DocumentKey> keys = batch.getKeys();\r\n    ImmutableSortedMap<DocumentKey, MaybeDocument> changedDocuments = localDocuments.getDocuments(keys);\r\n    return new LocalWriteResult(batch.getBatchId(), changedDocuments);\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.IntArray.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding manyitems to avoid multiple backing array resizes.",
	"Method": "int[] ensureCapacity(int additionalCapacity){\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded > items.length)\r\n        resize(Math.max(8, sizeNeeded));\r\n    return items;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteStore.handleCredentialChange",
	"Comment": "tells the remotestore that the currently authenticated user has changed.in response the remote store tears down streams and clears up any tracked operations thatshould not persist across users. restarts the streams if appropriate.",
	"Method": "void handleCredentialChange(){\r\n    if (canUseNetwork()) {\r\n        Logger.debug(LOG_TAG, \"Restarting streams for new credential.\");\r\n        networkEnabled = false;\r\n        disableNetworkInternal();\r\n        onlineStateTracker.updateState(OnlineState.UNKNOWN);\r\n        enableNetwork();\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.storage.FirebaseStorage.getMaxUploadRetryTimeMillis",
	"Comment": "returns the maximum time to retry an upload if a failure occurs.",
	"Method": "long getMaxUploadRetryTimeMillis(){\r\n    return sMaxUploadRetry;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.DocumentReference.update",
	"Comment": "updates fields in the document referred to by this documentreference. if no document existsyet, the update will fail.",
	"Method": "Task<Void> update(Map<String, Object> data,Task<Void> update,String field,Object value,Object moreFieldsAndValues,Task<Void> update,FieldPath fieldPath,Object value,Object moreFieldsAndValues,Task<Void> update,ParsedUpdateData parsedData){\r\n    return firestore.getClient().write(parsedData.toMutationList(key, Precondition.exists(true))).continueWith(Executors.DIRECT_EXECUTOR, voidErrorTransformer());\r\n}"
}, {
	"Path": "com.vladmihalcea.flexypool.util.ClassLoaderUtils.findClass",
	"Comment": "find if class denoted by the given string representation is loadable",
	"Method": "boolean findClass(String className){\r\n    try {\r\n        return getClassLoader().loadClass(className) != null;\r\n    } catch (ClassNotFoundException e) {\r\n        return false;\r\n    } catch (NoClassDefFoundError e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "io.flutter.inspector.DiagnosticsNode.getValueProperties",
	"Comment": "returns a list of raw dart property values of the dart value of thisproperty that are useful for custom display of the property value.for example, get the red, green, and blue components of color.unfortunately we cannot just use the list of fields from the observatoryinstance object for the dart value because much of the relevantinformation to display good visualizations of flutter values is storedin properties not in fields.",
	"Method": "CompletableFuture<Map<String, InstanceRef>> getValueProperties(){\r\n    final InspectorInstanceRef valueRef = getValueRef();\r\n    if (valueProperties == null) {\r\n        if (getPropertyType() == null || valueRef == null || valueRef.getId() == null) {\r\n            valueProperties = CompletableFuture.completedFuture(null);\r\n            return valueProperties;\r\n        }\r\n        if (isEnumProperty()) {\r\n            valueProperties = inspectorService.getEnumPropertyValues(getValueRef());\r\n            return valueProperties;\r\n        }\r\n        final String[] propertyNames;\r\n        switch(getPropertyType()) {\r\n            case \"Color\":\r\n                propertyNames = new String[] { \"red\", \"green\", \"blue\", \"alpha\" };\r\n                break;\r\n            case \"IconData\":\r\n                propertyNames = new String[] { \"codePoint\" };\r\n                break;\r\n            default:\r\n                valueProperties = CompletableFuture.completedFuture(null);\r\n                return valueProperties;\r\n        }\r\n        valueProperties = inspectorService.getDartObjectProperties(getValueRef(), propertyNames);\r\n    }\r\n    return valueProperties;\r\n}"
}, {
	"Path": "org.inferred.freebuilder.processor.PropertyCodeGenerator.getType",
	"Comment": "returns whether the property is required, optional, or has a default.",
	"Method": "Type getType(){\r\n    return Type.HAS_DEFAULT;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Body.getUserData",
	"Comment": "get the user data pointer that was provided in the body definition.",
	"Method": "Object getUserData(){\r\n    return userData;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Body.getMassData",
	"Comment": "get the mass data of the body.the rotational inertia is relative to the center of mass.fills in a struct containing the mass, inertia and center of the body.",
	"Method": "void getMassData(MassData data){\r\n    data.mass = m_mass;\r\n    data.I = getInertia();\r\n    data.center.set(m_sweep.localCenter);\r\n}"
}, {
	"Path": "com.google.firebase.storage.StorageTask.addOnCanceledListener",
	"Comment": "adds a listener that is called if the task is canceled.if the task has already been canceled, a call to the listener will be immediately scheduled.if multiple listeners are added, they will be called in the order in which they were added.",
	"Method": "StorageTask<TResult> addOnCanceledListener(OnCanceledListener listener,StorageTask<TResult> addOnCanceledListener,Executor executor,OnCanceledListener listener,StorageTask<TResult> addOnCanceledListener,Activity activity,OnCanceledListener listener){\r\n    Preconditions.checkNotNull(listener);\r\n    Preconditions.checkNotNull(activity);\r\n    cancelManager.addListener(activity, null, listener);\r\n    return this;\r\n}"
}, {
	"Path": "org.fluentlenium.assertj.custom.FluentWebElementAssert.failWithMessage",
	"Comment": "secure failwithmessage by escaping string.format tokens when called without arguments.",
	"Method": "void failWithMessage(String errorMessage){\r\n    super.failWithMessage(errorMessage.replaceAll(\"(?:[^%]|\\\\A)%(?:[^%]|\\\\z)\", \"%%\"));\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.World.setParticleRadius",
	"Comment": "change the particle radius. you should set this only once, on world start. if you change theradius during execution, existing particles may explode, shrink, or behave unexpectedly.",
	"Method": "void setParticleRadius(float radius){\r\n    particleSystem.setParticleRadius(radius);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.SyncEngine.emitNewSnapsAndNotifyLocalStore",
	"Comment": "computes a new snapshot from the changes and calls the registered callback with the newsnapshot.",
	"Method": "void emitNewSnapsAndNotifyLocalStore(ImmutableSortedMap<DocumentKey, MaybeDocument> changes,RemoteEvent remoteEvent){\r\n    List<ViewSnapshot> newSnapshots = new ArrayList();\r\n    List<LocalViewChanges> documentChangesInAllViews = new ArrayList();\r\n    for (Map.Entry<Query, QueryView> entry : queryViewsByQuery.entrySet()) {\r\n        QueryView queryView = entry.getValue();\r\n        View view = queryView.getView();\r\n        View.DocumentChanges viewDocChanges = view.computeDocChanges(changes);\r\n        if (viewDocChanges.needsRefill()) {\r\n            ImmutableSortedMap<DocumentKey, Document> docs = localStore.executeQuery(queryView.getQuery());\r\n            viewDocChanges = view.computeDocChanges(docs, viewDocChanges);\r\n        }\r\n        TargetChange targetChange = remoteEvent == null ? null : remoteEvent.getTargetChanges().get(queryView.getTargetId());\r\n        ViewChange viewChange = queryView.getView().applyChanges(viewDocChanges, targetChange);\r\n        updateTrackedLimboDocuments(viewChange.getLimboChanges(), queryView.getTargetId());\r\n        if (viewChange.getSnapshot() != null) {\r\n            newSnapshots.add(viewChange.getSnapshot());\r\n            LocalViewChanges docChanges = LocalViewChanges.fromViewSnapshot(queryView.getTargetId(), viewChange.getSnapshot());\r\n            documentChangesInAllViews.add(docChanges);\r\n        }\r\n    }\r\n    syncEngineListener.onViewSnapshots(newSnapshots);\r\n    localStore.notifyLocalViewChanges(documentChangesInAllViews);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.FirestoreClient.transaction",
	"Comment": "tries to execute the transaction in updatefunction up to retries times.",
	"Method": "Task<TResult> transaction(Function<Transaction, Task<TResult>> updateFunction,int retries){\r\n    return AsyncQueue.callTask(asyncQueue.getExecutor(), () -> syncEngine.transaction(asyncQueue, updateFunction, retries));\r\n}"
}, {
	"Path": "com.google.firebase.firestore.SmokeTest.testGetCollectionQueryByFieldAndOrdering",
	"Comment": "this broken because it requires a composite index on filter,sort",
	"Method": "void testGetCollectionQueryByFieldAndOrdering(){\r\n    Map<String, Map<String, Object>> testData = map(\"1\", map(\"sort\", 1.0, \"filter\", true, \"key\", \"1\"), \"2\", map(\"sort\", 2.0, \"filter\", true, \"key\", \"2\"), \"3\", map(\"sort\", 2.0, \"filter\", true, \"key\", \"3\"), \"4\", map(\"sort\", 3.0, \"filter\", false, \"key\", \"4\"));\r\n    CollectionReference collection = testCollection();\r\n    List<Task<Void>> tasks = new ArrayList();\r\n    for (Map.Entry<String, Map<String, Object>> entry : testData.entrySet()) {\r\n        tasks.add(collection.document(entry.getKey()).set(entry.getValue()));\r\n    }\r\n    waitFor(Tasks.whenAll(tasks));\r\n    Query query = collection.whereEqualTo(\"filter\", true).orderBy(\"sort\", Direction.DESCENDING);\r\n    QuerySnapshot set = waitFor(query.get());\r\n    List<DocumentSnapshot> documents = set.getDocuments();\r\n    assertEquals(3, documents.size());\r\n    assertEquals(testData.get(\"2\"), documents.get(0).getData());\r\n    assertEquals(testData.get(\"3\"), documents.get(1).getData());\r\n    assertEquals(testData.get(\"1\"), documents.get(2).getData());\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LocalSerializer.encodeMaybeDocument",
	"Comment": "encodes a maybedocument model to the equivalent protocol buffer for local storage.",
	"Method": "com.google.firebase.firestore.proto.MaybeDocument encodeMaybeDocument(MaybeDocument document){\r\n    com.google.firebase.firestore.proto.MaybeDocument.Builder builder = com.google.firebase.firestore.proto.MaybeDocument.newBuilder();\r\n    if (document instanceof NoDocument) {\r\n        NoDocument noDocument = (NoDocument) document;\r\n        builder.setNoDocument(encodeNoDocument(noDocument));\r\n        builder.setHasCommittedMutations(noDocument.hasCommittedMutations());\r\n    } else if (document instanceof Document) {\r\n        Document existingDocument = (Document) document;\r\n        if (existingDocument.getProto() != null) {\r\n            builder.setDocument(existingDocument.getProto());\r\n        } else {\r\n            builder.setDocument(encodeDocument(existingDocument));\r\n        }\r\n        builder.setHasCommittedMutations(existingDocument.hasCommittedMutations());\r\n    } else if (document instanceof UnknownDocument) {\r\n        builder.setUnknownDocument(encodeUnknownDocument((UnknownDocument) document));\r\n        builder.setHasCommittedMutations(true);\r\n    } else {\r\n        throw fail(\"Unknown document type %s\", document.getClass().getCanonicalName());\r\n    }\r\n    return builder.build();\r\n}"
}, {
	"Path": "com.example.firebase.fiamui.ScreenShotter.takeScreenshotInternal",
	"Comment": "take a screenshot on a device and save it as the specified file name.",
	"Method": "void takeScreenshotInternal(String fileName){\r\n    ScreenCapture capture = Screenshot.capture();\r\n    Bitmap bitmap = capture.getBitmap();\r\n    File imageFolder = new File(SCREENSHOT_PATH);\r\n    imageFolder.mkdirs();\r\n    File imageFile = new File(imageFolder, fileName + \".\" + IMAGE_TYPE);\r\n    OutputStream out = null;\r\n    try {\r\n        out = new FileOutputStream(imageFile);\r\n        bitmap.compress(Bitmap.CompressFormat.JPEG, 90, out);\r\n        out.flush();\r\n    } catch (IOException e) {\r\n        Log.e(LOG_TAG, \"Exception taking screenshot: \" + e.toString());\r\n    } finally {\r\n        try {\r\n            if (out != null) {\r\n                out.close();\r\n            }\r\n        } catch (IOException e) {\r\n            Log.e(LOG_TAG, \"There was an error closing the FileOutputStream \" + e.toString());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteSerializer.isValidResourceName",
	"Comment": "validates that a path has a prefix that looks like a valid encoded databaseid.",
	"Method": "boolean isValidResourceName(ResourcePath path){\r\n    return path.length() >= 4 && path.getSegment(0).equals(\"projects\") && path.getSegment(2).equals(\"databases\");\r\n}"
}, {
	"Path": "com.google.firebase.firestore.ArrayTransformsTest.writeInitialData",
	"Comment": "writes some initialdata and consumes the events generated.",
	"Method": "void writeInitialData(Map<String, Object> initialData){\r\n    waitFor(docRef.set(initialData));\r\n    expectLocalAndRemoteEvent(initialData);\r\n}"
}, {
	"Path": "com.google.firebase.database.Query.orderByChild",
	"Comment": "create a query in which child nodes are ordered by the values of the specified path.",
	"Method": "Query orderByChild(String path){\r\n    if (path == null) {\r\n        throw new NullPointerException(\"Key can't be null\");\r\n    }\r\n    if (path.equals(\"$key\") || path.equals(\".key\")) {\r\n        throw new IllegalArgumentException(\"Can't use '\" + path + \"' as path, please use orderByKey() instead!\");\r\n    }\r\n    if (path.equals(\"$priority\") || path.equals(\".priority\")) {\r\n        throw new IllegalArgumentException(\"Can't use '\" + path + \"' as path, please use orderByPriority() instead!\");\r\n    }\r\n    if (path.equals(\"$value\") || path.equals(\".value\")) {\r\n        throw new IllegalArgumentException(\"Can't use '\" + path + \"' as path, please use orderByValue() instead!\");\r\n    }\r\n    Validation.validatePathString(path);\r\n    validateNoOrderByCall();\r\n    Path indexPath = new Path(path);\r\n    if (indexPath.size() == 0) {\r\n        throw new IllegalArgumentException(\"Can't use empty path, use orderByValue() instead!\");\r\n    }\r\n    Index index = new PathIndex(indexPath);\r\n    return new Query(repo, this.path, params.orderBy(index), true);\r\n}"
}, {
	"Path": "com.google.firebase.database.core.WriteTree.shadowingWrite",
	"Comment": "returns a node if there is a complete overwrite for this path. more specifically, if there is awrite at a higher path, this will return the child of that write relative to the write and thispath. returns null if there is no write at this path.",
	"Method": "Node shadowingWrite(Path path){\r\n    return this.visibleWrites.getCompleteNode(path);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.Transaction.precondition",
	"Comment": "returns version of this doc when it was read in this transaction as a precondition, or noprecondition if it was not read.",
	"Method": "Precondition precondition(DocumentKey key){\r\n    @Nullable\r\n    SnapshotVersion version = readVersions.get(key);\r\n    if (version != null) {\r\n        return Precondition.updateTime(version);\r\n    } else {\r\n        return Precondition.NONE;\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.MemoryEagerReferenceDelegate.isReferenced",
	"Comment": "returns true if the given document is referenced by anything.",
	"Method": "boolean isReferenced(DocumentKey key){\r\n    if (persistence.getQueryCache().containsKey(key)) {\r\n        return true;\r\n    }\r\n    if (mutationQueuesContainKey(key)) {\r\n        return true;\r\n    }\r\n    if (inMemoryPins != null && inMemoryPins.containsKey(key)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.fluentlenium.core.proxy.LocatorProxies.noSuchElement",
	"Comment": "build a nosuchelementexception using message provided by proxy.",
	"Method": "NoSuchElementException noSuchElement(Object proxy){\r\n    LocatorHandler locatorHandler = getLocatorHandler(proxy);\r\n    if (locatorHandler == null) {\r\n        return new NoSuchElementException(\"No such element\");\r\n    }\r\n    return locatorHandler.noSuchElement();\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.ClassObj.getLocation",
	"Comment": "the location of this class in the source code.can return null.",
	"Method": "SourceLocation getLocation(){\r\n    return json.get(\"location\") == null ? null : new SourceLocation((JsonObject) json.get(\"location\"));\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.SQLiteLruReferenceDelegate.isPinned",
	"Comment": "returns true if anything would prevent this document from being garbage collected, given thatthe document in question is not present in any targets and has a sequence number less than orequal to the upper bound for the collection run.",
	"Method": "boolean isPinned(DocumentKey key){\r\n    if (inMemoryPins.containsKey(key)) {\r\n        return true;\r\n    }\r\n    return mutationQueuesContainKey(key);\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.afterNavigateForward",
	"Comment": "add a listener that will be invoked after navigating forward.",
	"Method": "EventsRegistry afterNavigateForward(NavigateListener listener){\r\n    afterNavigateForward.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.functions.FirebaseFunctions.getHttpsCallable",
	"Comment": "returns a reference to the callable https trigger with the given name.",
	"Method": "HttpsCallableReference getHttpsCallable(String name){\r\n    return new HttpsCallableReference(this, name);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LocalStore.setLastStreamToken",
	"Comment": "sets the stream token for the current user without acknowledging any mutation batch. this isusually only useful after a stream handshake or in response to an error that requires clearingthe stream token.",
	"Method": "void setLastStreamToken(ByteString streamToken){\r\n    persistence.runTransaction(\"Set stream token\", () -> mutationQueue.setLastStreamToken(streamToken));\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Event.getExtensionData",
	"Comment": "the extension event data.this is provided for the extension event.can return null.",
	"Method": "ExtensionData getExtensionData(){\r\n    return json.get(\"extensionData\") == null ? null : new ExtensionData((JsonObject) json.get(\"extensionData\"));\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.Query.getExplicitOrderBy",
	"Comment": "returns the list of ordering constraints that were explicitly requested on the query by theuser.note that the actual query performed might add additional sort orders to match the behaviorof the backend.",
	"Method": "List<OrderBy> getExplicitOrderBy(){\r\n    return explicitSortOrder;\r\n}"
}, {
	"Path": "com.google.firebase.FirebaseOptions.getApiKey",
	"Comment": "api key used for authenticating requests from your app, e.g.aizasyddvgkwhzl0stttlz7itmt1r3n2cjlnadk, used to identify your app to google servers.",
	"Method": "String getApiKey(){\r\n    return apiKey;\r\n}"
}, {
	"Path": "io.flutter.inspector.DiagnosticsPathNode.getChildIndex",
	"Comment": "returns the index of the child that continues the path if any.",
	"Method": "int getChildIndex(){\r\n    final JsonElement childIndex = json.get(\"childIndex\");\r\n    if (childIndex.isJsonNull()) {\r\n        return -1;\r\n    }\r\n    return childIndex.getAsInt();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.spec.SpecTestCase.parseMap",
	"Comment": "deeply parses a jsonobject into a map, recursively parsing its children.",
	"Method": "Map<String, Object> parseMap(JSONObject obj){\r\n    Map<String, Object> values = new HashMap();\r\n    Iterator<String> keys = obj.keys();\r\n    while (keys.hasNext()) {\r\n        String key = keys.next();\r\n        values.put(key, parseObject(obj.get(key)));\r\n    }\r\n    return values;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LocalStore.rejectBatch",
	"Comment": "removes mutations from the mutationqueue for the specified batch. localdocuments will berecalculated.",
	"Method": "ImmutableSortedMap<DocumentKey, MaybeDocument> rejectBatch(int batchId){\r\n    return persistence.runTransaction(\"Reject batch\", () -> {\r\n        MutationBatch toReject = mutationQueue.lookupMutationBatch(batchId);\r\n        hardAssert(toReject != null, \"Attempt to reject nonexistent batch!\");\r\n        mutationQueue.removeMutationBatch(toReject);\r\n        mutationQueue.performConsistencyCheck();\r\n        return localDocuments.getDocuments(toReject.getKeys());\r\n    });\r\n}"
}, {
	"Path": "org.fluentlenium.core.action.MouseActions.release",
	"Comment": "releases the depressed left mouse button at the current mouse location.",
	"Method": "MouseActions release(){\r\n    actions().release().perform();\r\n    return this;\r\n}"
}, {
	"Path": "org.fluentlenium.core.action.WindowAction.switchToLast",
	"Comment": "switches to lastly opened window excluding the one provided as a parameter.",
	"Method": "WindowAction switchToLast(WindowAction switchToLast,String nameOrHandleToExclude){\r\n    List<String> windowHandles = new ArrayList(driver.getWindowHandles());\r\n    if (windowHandles.size() > 1) {\r\n        windowHandles.remove(nameOrHandleToExclude);\r\n    }\r\n    driver.switchTo().window(windowHandles.get(windowHandles.size() - 1));\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.value.FieldValue.value",
	"Comment": "converts a fieldvalue into the value that users will see in document snapshots using theprovided deserialization options.",
	"Method": "Object value(Object value,FieldValueOptions options){\r\n    return value();\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.beforeScript",
	"Comment": "add a listener that will be invoked before executing a script.",
	"Method": "EventsRegistry beforeScript(ScriptListener listener){\r\n    beforeScript.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.CollectionReference.add",
	"Comment": "adds a new document to this collection with the specified pojo as contents, assigning it adocument id automatically.",
	"Method": "Task<DocumentReference> add(Map<String, Object> data,Task<DocumentReference> add,Object pojo){\r\n    return add(firestore.getDataConverter().convertPOJO(pojo));\r\n}"
}, {
	"Path": "com.google.firebase.FirebaseApp.setAutomaticResourceManagementEnabled",
	"Comment": "if set to true it indicates that firebase should close database connections automatically whenthe app is in the background. disabled by default.",
	"Method": "void setAutomaticResourceManagementEnabled(boolean enabled){\r\n    checkNotDeleted();\r\n    boolean updated = automaticResourceManagementEnabled.compareAndSet(!enabled, enabled);\r\n    if (updated) {\r\n        boolean inBackground = BackgroundDetector.getInstance().isInBackground();\r\n        if (enabled && inBackground) {\r\n            notifyBackgroundStateChangeListeners(true);\r\n        } else if (!enabled && inBackground) {\r\n            notifyBackgroundStateChangeListeners(false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.AsyncQueue.shutdown",
	"Comment": "shuts down the asyncqueue and releases resources after which no progress will ever be madeagain.",
	"Method": "void shutdown(){\r\n    executor.setCorePoolSize(0);\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Isolate.getNumber",
	"Comment": "a numeric id for this isolate, represented as a string. unique.",
	"Method": "String getNumber(){\r\n    return json.get(\"number\").getAsString();\r\n}"
}, {
	"Path": "com.google.firebase.database.tubesock.WebSocket.blockClose",
	"Comment": "blocks until both threads exit. the actual close must be triggered separately. this is just aconvenience method to make sure everything shuts down, if desired.",
	"Method": "void blockClose(){\r\n    if (writer.getInnerThread().getState() != Thread.State.NEW) {\r\n        writer.getInnerThread().join();\r\n    }\r\n    getInnerThread().join();\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.IntArray.removeRange",
	"Comment": "removes the items between the specified indices, inclusive.",
	"Method": "void removeRange(int start,int end){\r\n    if (end >= size)\r\n        throw new IndexOutOfBoundsException(\"end can't be >= size: \" + end + \" >= \" + size);\r\n    if (start > end)\r\n        throw new IndexOutOfBoundsException(\"start can't be > end: \" + start + \" > \" + end);\r\n    int[] items = this.items;\r\n    int count = end - start + 1;\r\n    if (ordered)\r\n        System.arraycopy(items, start + count, items, start, size - (start + count));\r\n    else {\r\n        int lastIndex = this.size - 1;\r\n        for (int i = 0; i < count; i++) items[start + i] = items[lastIndex - i];\r\n    }\r\n    size -= count;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Body.setUserData",
	"Comment": "set the user data. use this to store your application specific data.",
	"Method": "void setUserData(Object data){\r\n    userData = data;\r\n}"
}, {
	"Path": "com.almasb.fxgl.app.GameApplication.internalInitGame",
	"Comment": "callback to finalize init game.the data file to load will be set before this call.",
	"Method": "void internalInitGame(){\r\n    if (loadDataFile == DataFile.getEMPTY()) {\r\n        initGame();\r\n    } else {\r\n        loadState(loadDataFile);\r\n    }\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Isolate.getError",
	"Comment": "the error that is causing this isolate to exit, if applicable.can return null.",
	"Method": "ErrorObj getError(){\r\n    return json.get(\"error\") == null ? null : new ErrorObj((JsonObject) json.get(\"error\"));\r\n}"
}, {
	"Path": "com.google.firebase.database.core.CompoundWrite.removeWrite",
	"Comment": "will remove a write at the given path and deeper paths. this will not modify a writeat a higher location, which must be removed by calling this method with that path.",
	"Method": "CompoundWrite removeWrite(Path path){\r\n    if (path.isEmpty()) {\r\n        return EMPTY;\r\n    } else {\r\n        ImmutableTree<Node> newWriteTree = writeTree.setTree(path, ImmutableTree.<Node>emptyInstance());\r\n        return new CompoundWrite(newWriteTree);\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Query.get",
	"Comment": "executes the query and returns the results as a querysnapshot.",
	"Method": "Task<QuerySnapshot> get(Task<QuerySnapshot> get,Source source){\r\n    if (source == Source.CACHE) {\r\n        return firestore.getClient().getDocumentsFromLocalCache(query).continueWith(Executors.DIRECT_EXECUTOR, (Task<ViewSnapshot> viewSnap) -> new QuerySnapshot(new Query(query, firestore), viewSnap.getResult(), firestore));\r\n    } else {\r\n        return getViaSnapshotListener(source);\r\n    }\r\n}"
}, {
	"Path": "io.flutter.utils.EventStream.listen",
	"Comment": "listens for changes to the value tracked by the eventstream.ondata is always called immediately with the current value specifiedby the eventstream.",
	"Method": "StreamSubscription<T> listen(Consumer<T> onData,StreamSubscription<T> listen,Consumer<T> onData,boolean onUIThread){\r\n    final StreamSubscription<T> subscription = new StreamSubscription(onData, onUIThread, this);\r\n    final T cachedCurrentValue;\r\n    synchronized (this) {\r\n        cachedCurrentValue = currentValue;\r\n        subscriptions.add(subscription);\r\n    }\r\n    onData.accept(cachedCurrentValue);\r\n    return subscription;\r\n}"
}, {
	"Path": "com.google.firebase.functions.HttpsCallableResult.getData",
	"Comment": "returns the data that was returned from the callable https trigger.the data is in the form of native java objects. for example, if your trigger returned anarray, this object would be a list. if your trigger returned a javascript object withkeys and values, this object would be a map.",
	"Method": "Object getData(){\r\n    return data;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.ServerTimestampTest.verifyTimestampsAreNull",
	"Comment": "verifies a snapshot containing setdata but with null for the timestamps.",
	"Method": "void verifyTimestampsAreNull(DocumentSnapshot snapshot){\r\n    assertEquals(expectedDataWithTimestamp(null), snapshot.getData());\r\n}"
}, {
	"Path": "com.vladmihalcea.flexypool.metric.codahale.JmxMetricReporter.init",
	"Comment": "the jmx reporter is activated only if the jmxenabled property is set. if the jmxautostart property is enabled,the jmx reporter will start automatically.",
	"Method": "JmxMetricReporter init(ConfigurationProperties configurationProperties,MetricRegistry metricRegistry){\r\n    if (configurationProperties.isJmxEnabled()) {\r\n        jmxReporter = JmxReporter.forRegistry(metricRegistry).inDomain(MetricRegistry.name(getClass(), configurationProperties.getUniqueName())).build();\r\n    }\r\n    if (configurationProperties.isJmxAutoStart()) {\r\n        start();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.testutil.TestUtil.values",
	"Comment": "converts the values of an immutablesortedmap into a list, preserving key order.",
	"Method": "List<T> values(ImmutableSortedMap<?, T> map){\r\n    List<T> result = new ArrayList();\r\n    for (Map.Entry<?, T> entry : map) {\r\n        result.add(entry.getValue());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Transaction.update",
	"Comment": "updates fields in the document referred to by the provided documentreference. if no documentexists yet, the update will fail.",
	"Method": "Transaction update(DocumentReference documentRef,Map<String, Object> data,Transaction update,DocumentReference documentRef,String field,Object value,Object moreFieldsAndValues,Transaction update,DocumentReference documentRef,FieldPath fieldPath,Object value,Object moreFieldsAndValues,Transaction update,DocumentReference documentRef,ParsedUpdateData updateData){\r\n    firestore.validateReference(documentRef);\r\n    transaction.update(documentRef.getKey(), updateData);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.FieldsTest.dottedObject",
	"Comment": "creates test data with special characters in field names. datastore currently prohibits mixingnested data with special characters so tests that use this data must be separate.",
	"Method": "Map<String, Object> dottedObject(int number){\r\n    return map(\"field\", String.format(\"field %d\", number), \"field.dot\", (double) number, \"field\\\\slash\", (double) number);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.AsyncQueue.containsDelayedTask",
	"Comment": "determines if a delayed task with a particular timerid exists.",
	"Method": "boolean containsDelayedTask(TimerId timerId){\r\n    for (DelayedTask delayedTask : delayedTasks) {\r\n        if (delayedTask.timerId == timerId) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.flutter.inspector.EvalOnDartLibrary.addRequest",
	"Comment": "public so that other related classes such as inspectorservice can ensure theirrequests are in a consistent order with requests which eliminates otherwisesurprising timing bugs such as if a request to dispose aninspectorservice.objectgroup was issued after a request to read propertiesfrom an object in a group but the request to dispose the object groupoccurred first.the design is we have at most 1 pending request at a time. this sacrificessome throughput with the advantage of predictable semantics and the benefitthat we are able to skip large numbers of requests if they happen to befrom groups of objects that should no longer be kept alive.the optional objectgroup specified by isalive, indicates whether therequest is still relevant or should be cancelled. this is an optimizationfor the inspector to avoid overloading the service with stale requests ifthe user is quickly navigating through the ui generating lots of stalerequests to view specific details subtrees.",
	"Method": "CompletableFuture<T> addRequest(InspectorService.ObjectGroup isAlive,Producer<CompletableFuture<T>> request){\r\n    if (isAlive != null && isAlive.isDisposed()) {\r\n        return CompletableFuture.completedFuture(null);\r\n    }\r\n    final CompletableFuture<T> response = new CompletableFuture();\r\n    final Runnable wrappedRequest = () -> {\r\n        if (isAlive != null && isAlive.isDisposed()) {\r\n            response.complete(null);\r\n            return;\r\n        }\r\n        final CompletableFuture<T> future = request.produce();\r\n        future.whenCompleteAsync((v, t) -> {\r\n            if (t != null) {\r\n                response.completeExceptionally(t);\r\n            } else {\r\n                response.complete(v);\r\n            }\r\n        });\r\n    };\r\n    synchronized (pendingRequestLock) {\r\n        if (allPendingRequestsDone == null || allPendingRequestsDone.isDone()) {\r\n            allPendingRequestsDone = response;\r\n            myRequestsScheduler.addRequest(wrappedRequest, 0);\r\n        } else {\r\n            final CompletableFuture<?> previousDone = allPendingRequestsDone;\r\n            allPendingRequestsDone = response;\r\n            previousDone.whenCompleteAsync((v, error) -> {\r\n                myRequestsScheduler.addRequest(wrappedRequest, 0);\r\n            });\r\n        }\r\n    }\r\n    return response;\r\n}"
}, {
	"Path": "com.google.firebase.storage.internal.AdaptiveStreamBuffer.isFinished",
	"Comment": "whether we have reached the end of the stream and there is no more data to put into the buffer.",
	"Method": "boolean isFinished(){\r\n    return reachedEnd;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.DocumentReference.delete",
	"Comment": "deletes the document referred to by this documentreference.",
	"Method": "Task<Void> delete(){\r\n    return firestore.getClient().write(singletonList(new DeleteMutation(key, Precondition.NONE))).continueWith(Executors.DIRECT_EXECUTOR, voidErrorTransformer());\r\n}"
}, {
	"Path": "com.vladmihalcea.flexypool.metric.dropwizard.Slf4jMetricReporter.init",
	"Comment": "create a log reporter and activate it if the metriclogreportermillis property is greater than zero.",
	"Method": "Slf4jMetricReporter init(ConfigurationProperties configurationProperties,MetricRegistry metricRegistry){\r\n    metricLogReporterMillis = configurationProperties.getMetricLogReporterMillis();\r\n    if (metricLogReporterMillis > 0) {\r\n        this.slf4jReporter = Slf4jReporter.forRegistry(metricRegistry).outputTo(LOGGER).build();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.internal.FirebaseAppHelper.getToken",
	"Comment": "exposes gettoken on firebaseapp in an unobfuscated manner.",
	"Method": "Task<GetTokenResult> getToken(FirebaseApp app,boolean forceRefresh){\r\n    return app.getToken(forceRefresh);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Query.internalOptions",
	"Comment": "converts the public api options object to the internal options object.",
	"Method": "ListenOptions internalOptions(MetadataChanges metadataChanges){\r\n    ListenOptions internalOptions = new ListenOptions();\r\n    internalOptions.includeDocumentMetadataChanges = (metadataChanges == MetadataChanges.INCLUDE);\r\n    internalOptions.includeQueryMetadataChanges = (metadataChanges == MetadataChanges.INCLUDE);\r\n    internalOptions.waitForSyncWhenOnline = false;\r\n    return internalOptions;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.Transaction.preconditionForUpdate",
	"Comment": "returns the precondition for a document if the operation is an update, based on the providedupdateoptions.",
	"Method": "Precondition preconditionForUpdate(DocumentKey key){\r\n    @Nullable\r\n    SnapshotVersion version = this.readVersions.get(key);\r\n    if (version != null && version.equals(SnapshotVersion.NONE)) {\r\n        throw new IllegalStateException(\"Can't update a document that doesn't exist.\");\r\n    } else if (version != null) {\r\n        return Precondition.updateTime(version);\r\n    } else {\r\n        return Precondition.exists(true);\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.joints.RevoluteJointDef.initialize",
	"Comment": "initialize the bodies, anchors, and reference angle using the world anchor.",
	"Method": "void initialize(Body b1,Body b2,Vec2 anchor){\r\n    bodyA = b1;\r\n    bodyB = b2;\r\n    bodyA.getLocalPointToOut(anchor, localAnchorA);\r\n    bodyB.getLocalPointToOut(anchor, localAnchorB);\r\n    referenceAngle = bodyB.getAngle() - bodyA.getAngle();\r\n}"
}, {
	"Path": "org.dartlang.analysis.server.protocol.FlutterOutline.getStateOffset",
	"Comment": "if the node is a statefulwidget that can be rendered, and its state class is defined in the samefile, the offset of the state class code in the file.",
	"Method": "Integer getStateOffset(){\r\n    return stateOffset;\r\n}"
}, {
	"Path": "com.google.firebase.database.FirebaseDatabase.createForTests",
	"Comment": "this exists so repo can create firebasedatabase objects to keep legacy tests working.",
	"Method": "FirebaseDatabase createForTests(FirebaseApp app,RepoInfo repoInfo,DatabaseConfig config){\r\n    FirebaseDatabase db = new FirebaseDatabase(app, repoInfo, config);\r\n    db.ensureRepo();\r\n    return db;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Breakpoint.getResolved",
	"Comment": "has this breakpoint been assigned to a specific program location?",
	"Method": "boolean getResolved(){\r\n    return json.get(\"resolved\").getAsBoolean();\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Fixture.setFilterData",
	"Comment": "set the contact filtering data.this will not update contacts until the next time step when either parent body is awake.this automatically calls refilter.this is an expensive operation and should not be called frequently.",
	"Method": "void setFilterData(Filter filter){\r\n    this.filter.set(filter);\r\n    refilter();\r\n}"
}, {
	"Path": "org.inferred.freebuilder.processor.util.ParameterizedType.declarationParameters",
	"Comment": "returns a source excerpt of the type parameters of this type, including bounds and anglebrackets.",
	"Method": "Excerpt declarationParameters(){\r\n    return new DeclarationParameters(typeParameters);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.FirestoreChannel.shutdown",
	"Comment": "shuts down the grpc channel. this is not reversible and renders the firestorechannel unusable.",
	"Method": "void shutdown(){\r\n    channel.shutdown();\r\n    try {\r\n        if (!channel.awaitTermination(1, TimeUnit.SECONDS)) {\r\n            Logger.debug(FirestoreChannel.class.getSimpleName(), \"Unable to gracefully shutdown the gRPC ManagedChannel. Will attempt an immediate shutdown.\");\r\n            channel.shutdownNow();\r\n            if (!channel.awaitTermination(60, TimeUnit.SECONDS)) {\r\n                Logger.warn(FirestoreChannel.class.getSimpleName(), \"Unable to forcefully shutdown the gRPC ManagedChannel.\");\r\n            }\r\n        }\r\n    } catch (InterruptedException e) {\r\n        channel.shutdownNow();\r\n        Logger.warn(FirestoreChannel.class.getSimpleName(), \"Interrupted while shutting down the gRPC Managed Channel\");\r\n        Thread.currentThread().interrupt();\r\n    }\r\n}"
}, {
	"Path": "io.flutter.inspector.DiagnosticsNode.isStateful",
	"Comment": "whether this node is being displayed as a full tree or a filtered tree.",
	"Method": "boolean isStateful(){\r\n    return getBooleanMember(\"stateful\", false);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.TargetIdGenerator.forQueryCache",
	"Comment": "creates and returns the targetidgenerator for the local store.",
	"Method": "TargetIdGenerator forQueryCache(int after){\r\n    TargetIdGenerator generator = new TargetIdGenerator(QUERY_CACHE_ID, after);\r\n    generator.nextId();\r\n    return generator;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.MutationQueueTestCase.removeMutationBatches",
	"Comment": "calls removemutationbatches on the mutation queue in a new transaction and commits.",
	"Method": "void removeMutationBatches(MutationBatch batches){\r\n    persistence.runTransaction(\"Remove mutation batches\", () -> {\r\n        for (MutationBatch batch : batches) {\r\n            mutationQueue.removeMutationBatch(batch);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.almasb.fxgl.entity.Entity.translateTowards",
	"Comment": "instantly moves this entity distance units towards given point.",
	"Method": "void translateTowards(Point2D point,double distance){\r\n    position.translateTowards(point, distance);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.testutil.TestUtil.assertFails",
	"Comment": "asserts that the given runnable block fails with an internal error.",
	"Method": "void assertFails(Runnable block){\r\n    try {\r\n        block.run();\r\n    } catch (AssertionError e) {\r\n        assertThat(e).hasMessageThat().startsWith(\"INTERNAL ASSERTION FAILED:\");\r\n        return;\r\n    }\r\n    fail(\"Should have failed\");\r\n}"
}, {
	"Path": "com.google.firebase.internal.FirebaseAppHelper.removeIdTokenListener",
	"Comment": "exposes removeidtokenlistener on firebaseapp in an unobfuscated manner.",
	"Method": "void removeIdTokenListener(FirebaseApp app,IdTokenListener listener){\r\n    app.removeIdTokenListener(listener);\r\n}"
}, {
	"Path": "com.google.firebase.storage.StorageTask.getSnapshot",
	"Comment": "returns the current state of the task. this method will return state at any point of the tasksexecution and may not be the final result..",
	"Method": "TResult getSnapshot(){\r\n    return snapState();\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.AnnotationGetScreenshotAsListener.getArgsFunction",
	"Comment": "get a function that retrieves argument value based on argument class.",
	"Method": "Function<Class<?>, Object> getArgsFunction(OutputType outputType,Function<Class<?>, Object> getArgsFunction,OutputType outputType,Object o){\r\n    return input -> {\r\n        if (input.isAssignableFrom(OutputType.class)) {\r\n            return outputType;\r\n        }\r\n        if (input.isAssignableFrom(Object.class)) {\r\n            return o;\r\n        }\r\n        return null;\r\n    };\r\n}"
}, {
	"Path": "io.flutter.view.DiagnosticsTreeCellRenderer.appendFragmentsForSpeedSearch",
	"Comment": "generally duplicated from speedsearchutil.appendfragmentsforspeedsearch",
	"Method": "void appendFragmentsForSpeedSearch(JComponent speedSearchEnabledComponent,String text,SimpleTextAttributes attributes,boolean selected,MultiIconSimpleColoredComponent simpleColoredComponent){\r\n    final SpeedSearchSupply speedSearch = SpeedSearchSupply.getSupply(speedSearchEnabledComponent);\r\n    if (speedSearch != null) {\r\n        final Iterable<TextRange> fragments = speedSearch.matchingFragments(text);\r\n        if (fragments != null) {\r\n            final Color fg = attributes.getFgColor();\r\n            final Color bg = selected ? UIUtil.getTreeSelectionBackground() : UIUtil.getTreeTextBackground();\r\n            final int style = attributes.getStyle();\r\n            final SimpleTextAttributes plain = new SimpleTextAttributes(style, fg);\r\n            final SimpleTextAttributes highlighted = new SimpleTextAttributes(bg, fg, null, style | SimpleTextAttributes.STYLE_SEARCH_MATCH);\r\n            appendColoredFragments(simpleColoredComponent, text, fragments, plain, highlighted);\r\n            return;\r\n        }\r\n    }\r\n    simpleColoredComponent.append(text, attributes);\r\n}"
}, {
	"Path": "io.flutter.run.bazelTest.BazelTestRunner.canRun",
	"Comment": "only allow this runner to execute for the run and debug executors.",
	"Method": "boolean canRun(String executorId,RunProfile profile){\r\n    return (DefaultRunExecutor.EXECUTOR_ID.equals(executorId) || DefaultDebugExecutor.EXECUTOR_ID.equals(executorId)) && profile instanceof BazelTestConfig;\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.ObjectMap.findKey",
	"Comment": "returns the key for the specified value, or null if it is not in the map. note this traverses the entire map and comparesevery value, which may be an expensive operation.",
	"Method": "K findKey(Object value,boolean identity){\r\n    V[] valueTable = this.valueTable;\r\n    if (value == null) {\r\n        K[] keyTable = this.keyTable;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != null && valueTable[i] == null)\r\n            return keyTable[i];\r\n    } else if (identity) {\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (valueTable[i] == value)\r\n            return keyTable[i];\r\n    } else {\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (value.equals(valueTable[i]))\r\n            return keyTable[i];\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Version.getMajor",
	"Comment": "the major version number is incremented when the protocol is changed in a potentiallyincompatible way.",
	"Method": "int getMajor(){\r\n    return json.get(\"major\") == null ? -1 : json.get(\"major\").getAsInt();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.Query.getCanonicalId",
	"Comment": "returns a canonical string representing this query. this should match the ios and androidcanonical ids for a query exactly.",
	"Method": "String getCanonicalId(){\r\n    StringBuilder builder = new StringBuilder();\r\n    builder.append(getPath().canonicalString());\r\n    builder.append(\"|f:\");\r\n    for (Filter filter : getFilters()) {\r\n        builder.append(filter.getCanonicalId());\r\n    }\r\n    builder.append(\"|ob:\");\r\n    for (OrderBy orderBy : getOrderBy()) {\r\n        builder.append(orderBy.getField().canonicalString());\r\n        builder.append(orderBy.getDirection().equals(Direction.ASCENDING) ? \"asc\" : \"desc\");\r\n    }\r\n    if (hasLimit()) {\r\n        builder.append(\"|l:\");\r\n        builder.append(getLimit());\r\n    }\r\n    if (startAt != null) {\r\n        builder.append(\"|lb:\");\r\n        builder.append(startAt.canonicalString());\r\n    }\r\n    if (endAt != null) {\r\n        builder.append(\"|ub:\");\r\n        builder.append(endAt.canonicalString());\r\n    }\r\n    return builder.toString();\r\n}"
}, {
	"Path": "com.google.firebase.database.core.SyncTree.queryForTag",
	"Comment": "return the query associated with the given tag, if we have one",
	"Method": "QuerySpec queryForTag(Tag tag){\r\n    return this.tagToQueryMap.get(tag);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.CollectionReference.getParent",
	"Comment": "gets a documentreference to the document that contains this collection. only subcollections arecontained in a document. for root collections, returns null.",
	"Method": "DocumentReference getParent(){\r\n    ResourcePath parentPath = query.getPath().popLast();\r\n    if (parentPath.isEmpty()) {\r\n        return null;\r\n    } else {\r\n        return new DocumentReference(DocumentKey.fromPath(parentPath), firestore);\r\n    }\r\n}"
}, {
	"Path": "io.flutter.run.bazel.BazelFields.getAppDir",
	"Comment": "returns the app directory that corresponds to the entryfile and the given project.",
	"Method": "VirtualFile getAppDir(Project project){\r\n    return MainFile.verify(entryFile, project).get().getAppDir();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.Query.matches",
	"Comment": "returns true if the document matches the constraints of this query.",
	"Method": "boolean matches(Document doc){\r\n    return matchesPath(doc) && matchesOrderBy(doc) && matchesFilters(doc) && matchesBounds(doc);\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.beforeClickOn",
	"Comment": "add a listener that will be invoked before clicking an element.",
	"Method": "EventsRegistry beforeClickOn(ElementListener listener){\r\n    beforeClickOn.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.beforeGetText",
	"Comment": "add a listener that will be invoked before get text of an element.",
	"Method": "EventsRegistry beforeGetText(ElementListener listener){\r\n    beforeGetText.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "io.flutter.FlutterUtils.isXcodeFileName",
	"Comment": "checks whether a given filename is an xcode metadata file, suitable for opening externally.",
	"Method": "boolean isXcodeFileName(String name){\r\n    return isXcodeProjectFileName(name) || isXcodeWorkspaceFileName(name);\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.AnnotationSwitchToWindowListener.getArgsFunction",
	"Comment": "get a function that retrieves argument value based on argument class.",
	"Method": "Function<Class<?>, Object> getArgsFunction(String s,WebDriver driver){\r\n    return input -> {\r\n        if (input.isAssignableFrom(String.class)) {\r\n            return s;\r\n        }\r\n        if (input.isAssignableFrom(WebDriver.class)) {\r\n            return driver;\r\n        }\r\n        return null;\r\n    };\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.World.setDestructionListener",
	"Comment": "register a destruction listener. the listener is owned by you and must remain in scope.",
	"Method": "void setDestructionListener(DestructionListener listener){\r\n    destructionListener = listener;\r\n}"
}, {
	"Path": "org.fluentlenium.assertj.custom.FluentListSizeBuilder.greaterThanOrEqualTo",
	"Comment": "assert that actual list size is greater than or equal to given size.",
	"Method": "Object greaterThanOrEqualTo(int size){\r\n    if (actualSize < size) {\r\n        listAssert.failWithMessage(ACTUAL_SIZE + actualSize + \" is not greater than or equal to: \" + size);\r\n    }\r\n    return listAssert;\r\n}"
}, {
	"Path": "com.vladmihalcea.flexypool.metric.codahale.CodahaleMetricsFactoryService.load",
	"Comment": "load codahalemetrics factory if the codahale metrics is available at runtime",
	"Method": "MetricsFactory load(){\r\n    return ClassLoaderUtils.findClass(METRICS_CLASS_NAME) ? CodahaleMetrics.FACTORY : null;\r\n}"
}, {
	"Path": "io.flutter.android.IntelliJAndroidSdk.fromHome",
	"Comment": "returns the android sdk for the given home directory, or null if no sdk matches.",
	"Method": "IntelliJAndroidSdk fromHome(VirtualFile file){\r\n    for (IntelliJAndroidSdk candidate : findAll()) {\r\n        if (file.equals(candidate.getHome())) {\r\n            return candidate;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.almasb.fxgl.extra.ai.pathfinding.maze.Maze.getPath",
	"Comment": "returns shortest path between two cells in the maze.if no path found, empty list is returned",
	"Method": "List<MazeCell> getPath(int startX,int startY,int targetX,int targetY){\r\n    AStarGrid grid = new AStarGrid(width, height);\r\n    for (int y = 0; y < height; y++) {\r\n        for (int x = 0; x < width; x++) {\r\n            grid.getNode(x, y).setUserData(getMazeCell(x, y));\r\n        }\r\n    }\r\n    List<MazeCell> list = new ArrayList();\r\n    List<AStarNode> nodes = new MazeSolver().getPath(grid.getGrid(), grid.getNode(startX, startY), grid.getNode(targetX, targetY));\r\n    for (AStarNode node : nodes) {\r\n        MazeCell cell = (MazeCell) node.getUserData();\r\n        list.add(cell);\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.World.joinParticleGroups",
	"Comment": "join two particle groups. this function is locked during callbacks.",
	"Method": "void joinParticleGroups(ParticleGroup groupA,ParticleGroup groupB){\r\n    assertNotLocked();\r\n    particleSystem.joinParticleGroups(groupA, groupB);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteSerializer.encodedDatabaseId",
	"Comment": "creates the prefix for a fully qualified resource path, without a local path on the end.",
	"Method": "ResourcePath encodedDatabaseId(DatabaseId databaseId){\r\n    return ResourcePath.fromSegments(Arrays.asList(\"projects\", databaseId.getProjectId(), \"databases\", databaseId.getDatabaseId()));\r\n}"
}, {
	"Path": "com.bartoszlipinski.flippablestackview.OrientedViewPager.setAdapter",
	"Comment": "set a pageradapter that will supply views for this pager as needed.",
	"Method": "void setAdapter(PagerAdapter adapter){\r\n    if (mAdapter != null) {\r\n        mAdapter.unregisterDataSetObserver(mObserver);\r\n        mAdapter.startUpdate(this);\r\n        for (int i = 0; i < mItems.size(); i++) {\r\n            final ItemInfo ii = mItems.get(i);\r\n            mAdapter.destroyItem(this, ii.position, ii.object);\r\n        }\r\n        mAdapter.finishUpdate(this);\r\n        mItems.clear();\r\n        removeNonDecorViews();\r\n        mCurItem = 0;\r\n        scrollTo(0, 0);\r\n    }\r\n    final PagerAdapter oldAdapter = mAdapter;\r\n    mAdapter = adapter;\r\n    mExpectedAdapterCount = 0;\r\n    if (mAdapter != null) {\r\n        if (mObserver == null) {\r\n            mObserver = new PagerObserver();\r\n        }\r\n        mAdapter.registerDataSetObserver(mObserver);\r\n        mPopulatePending = false;\r\n        final boolean wasFirstLayout = mFirstLayout;\r\n        mFirstLayout = true;\r\n        mExpectedAdapterCount = mAdapter.getCount();\r\n        if (mRestoredCurItem >= 0) {\r\n            mAdapter.restoreState(mRestoredAdapterState, mRestoredClassLoader);\r\n            setCurrentItemInternal(mRestoredCurItem, false, true);\r\n            mRestoredCurItem = -1;\r\n            mRestoredAdapterState = null;\r\n            mRestoredClassLoader = null;\r\n        } else if (!wasFirstLayout) {\r\n            populate();\r\n        } else {\r\n            requestLayout();\r\n        }\r\n    }\r\n    if (mAdapterChangeListener != null && oldAdapter != adapter) {\r\n        mAdapterChangeListener.onAdapterChanged(oldAdapter, adapter);\r\n    }\r\n}"
}, {
	"Path": "org.fluentlenium.core.filter.MatcherConstructor.startsWith",
	"Comment": "create a matcher filtering by a string that start with the matcher",
	"Method": "AbstractMatcher startsWith(String matcher,AbstractMatcher startsWith,Pattern pattern){\r\n    return new StartsWithMatcher(pattern);\r\n}"
}, {
	"Path": "fr.pilato.elasticsearch.crawler.fs.test.integration.AbstractITCase.countTestHelper",
	"Comment": "check that we have the expected number of docs or at least one if expected is null",
	"Method": "ESSearchResponse countTestHelper(ESSearchRequest request,Long expected,Path path,ESSearchResponse countTestHelper,ESSearchRequest request,Long expected,Path path,TimeValue timeout){\r\n    final ESSearchResponse[] response = new ESSearchResponse[1];\r\n    staticLogger.info(\"  ---> Waiting up to {} for {} documents in {}\", timeout.toString(), expected == null ? \"some\" : expected, request.getIndex());\r\n    long hits = awaitBusy(() -> {\r\n        long totalHits;\r\n        try {\r\n            response[0] = esClient.search(request);\r\n        } catch (IOException e) {\r\n            staticLogger.warn(\"error caught\", e);\r\n            return -1;\r\n        }\r\n        staticLogger.trace(\"result {}\", response[0].toString());\r\n        totalHits = response[0].getTotalHits();\r\n        staticLogger.debug(\"got so far [{}] hits on expected [{}]\", totalHits, expected);\r\n        return totalHits;\r\n    }, expected, timeout.millis(), TimeUnit.MILLISECONDS);\r\n    Matcher<Long> matcher;\r\n    if (expected == null) {\r\n        matcher = greaterThan(0L);\r\n    } else {\r\n        matcher = equalTo(expected);\r\n    }\r\n    if (matcher.matches(hits)) {\r\n        staticLogger.debug(\"     ---> expecting [{}] and got [{}] documents in {}\", expected, hits, request.getIndex());\r\n        logContentOfDir(path, Level.DEBUG);\r\n    } else {\r\n        staticLogger.warn(\"     ---> expecting [{}] but got [{}] documents in {}\", expected, hits, request.getIndex());\r\n        logContentOfDir(path, Level.WARN);\r\n    }\r\n    assertThat(hits, matcher);\r\n    return response[0];\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.Array.removeRange",
	"Comment": "removes the items between the specified indices, inclusive.",
	"Method": "void removeRange(int start,int end){\r\n    checkRange(end);\r\n    if (start > end)\r\n        throw new IndexOutOfBoundsException(\"start can't be > end: \" + start + \" > \" + end);\r\n    T[] items = this.items;\r\n    int count = end - start + 1;\r\n    if (ordered) {\r\n        System.arraycopy(items, start + count, items, start, size - (start + count));\r\n    } else {\r\n        int lastIndex = this.size - 1;\r\n        for (int i = 0; i < count; i++) items[start + i] = items[lastIndex - i];\r\n    }\r\n    size -= count;\r\n}"
}, {
	"Path": "io.flutter.run.bazel.BazelFields.getEntryFile",
	"Comment": "the file containing the main function that starts the flutter app.",
	"Method": "String getEntryFile(){\r\n    return entryFile;\r\n}"
}, {
	"Path": "com.almasb.fxgl.extra.entity.action.ActionComponent.removeCurrentAction",
	"Comment": "remove current executing action.if there are more actions pending, the first pending action becomes current.",
	"Method": "void removeCurrentAction(){\r\n    if (currentAction != null) {\r\n        actionsObservable.remove(currentAction);\r\n        currentAction.setEntity(null);\r\n        currentAction = null;\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.ServerTimestampTest.verifyTimestampsAreEstimates",
	"Comment": "verifies a snapshot containing setdata but with local estimates for server timestamps.",
	"Method": "void verifyTimestampsAreEstimates(DocumentSnapshot snapshot){\r\n    assertTrue(snapshot.exists());\r\n    Timestamp when = snapshot.getTimestamp(\"when\", ServerTimestampBehavior.ESTIMATE);\r\n    assertNotNull(when);\r\n    assertEquals(expectedDataWithTimestamp(when), snapshot.getData(ServerTimestampBehavior.ESTIMATE));\r\n}"
}, {
	"Path": "io.flutter.actions.OpenInAndroidStudioAction.isExampleWithAndroidWithApp",
	"Comment": "android directory with an app. the example app directory name is not specified in case it gets renamed.",
	"Method": "boolean isExampleWithAndroidWithApp(VirtualFile file){\r\n    boolean hasPubspec = false;\r\n    boolean hasAndroid = false;\r\n    for (VirtualFile candidate : file.getChildren()) {\r\n        if (isAndroidWithApp(candidate))\r\n            hasAndroid = true;\r\n        if (candidate.getName().equals(\"pubspec.yaml\"))\r\n            hasPubspec = true;\r\n        if (hasAndroid && hasPubspec) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.inferred.freebuilder.processor.util.ParameterizedType.typeParameters",
	"Comment": "returns a source excerpt of the type parameters of this type, including angle brackets.",
	"Method": "Excerpt typeParameters(){\r\n    if (typeParameters.isEmpty()) {\r\n        return Excerpts.empty();\r\n    } else {\r\n        return Excerpts.add(\"<%s>\", Excerpts.join(\", \", typeParameters));\r\n    }\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.SourceReportRange.getPossibleBreakpoints",
	"Comment": "possible breakpoint information for this range, represented as a sorted list of tokenpositions.provided only when the when the possiblebreakpoint report has been requested andthe range has been compiled.can return null.",
	"Method": "List<Integer> getPossibleBreakpoints(){\r\n    return getListInt(\"possibleBreakpoints\");\r\n}"
}, {
	"Path": "com.vladmihalcea.flexypool.FlexyPoolDataSource.getParentLogger",
	"Comment": "jdbc 4.1 method, available to work with both java 1.6 and java 1.7",
	"Method": "Logger getParentLogger(){\r\n    return Logger.getLogger(Logger.GLOBAL_LOGGER_NAME);\r\n}"
}, {
	"Path": "org.fluentlenium.core.domain.FluentWebElement.enabled",
	"Comment": "return true if the element is enabled, other way return false",
	"Method": "boolean enabled(){\r\n    return webElement.isEnabled();\r\n}"
}, {
	"Path": "com.google.firebase.storage.StorageReference.getBucket",
	"Comment": "return the google cloud storage bucket that holds this object.",
	"Method": "String getBucket(){\r\n    return mStorageUri.getAuthority();\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Flag.getValueAsString",
	"Comment": "the value of this flag as a string.if this property is absent, then the value of the flag was null.can return null.",
	"Method": "String getValueAsString(){\r\n    return json.get(\"valueAsString\") == null ? null : json.get(\"valueAsString\").getAsString();\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.joints.WeldJointDef.initialize",
	"Comment": "initialize the bodies, anchors, and reference angle using a world anchor point.",
	"Method": "void initialize(Body bA,Body bB,Vec2 anchor){\r\n    bodyA = bA;\r\n    bodyB = bB;\r\n    bodyA.getLocalPointToOut(anchor, localAnchorA);\r\n    bodyB.getLocalPointToOut(anchor, localAnchorB);\r\n    referenceAngle = bodyB.getAngle() - bodyA.getAngle();\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Body.getLinearVelocityFromWorldPoint",
	"Comment": "get the world linear velocity of a world point attached to this body.",
	"Method": "Vec2 getLinearVelocityFromWorldPoint(Vec2 worldPoint){\r\n    Vec2 out = new Vec2();\r\n    getLinearVelocityFromWorldPointToOut(worldPoint, out);\r\n    return out;\r\n}"
}, {
	"Path": "io.flutter.run.test.TestConfigProducer.setupConfigurationFromContext",
	"Comment": "if the current file looks like a flutter test, initializes the run config to run it.returns true if successfully set up.",
	"Method": "boolean setupConfigurationFromContext(TestConfig config,ConfigurationContext context,Ref<PsiElement> sourceElement){\r\n    if (!isFlutterContext(context))\r\n        return false;\r\n    final PsiElement elt = context.getPsiLocation();\r\n    if (elt instanceof PsiDirectory) {\r\n        return setupForDirectory(config, (PsiDirectory) elt);\r\n    }\r\n    final DartFile file = FlutterRunConfigurationProducer.getDartFile(context);\r\n    if (file == null) {\r\n        return false;\r\n    }\r\n    if (supportsFiltering(config.getSdk())) {\r\n        final String testName = TestConfigUtils.findTestName(elt);\r\n        if (testName != null) {\r\n            return setupForSingleTest(config, context, file, testName);\r\n        }\r\n    }\r\n    return setupForDartFile(config, context, file);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.AsyncQueue.callTask",
	"Comment": "executes the given callable on a specific executor and returns a task that completes when thetask returned from the callable completes. similar to tasks.call, but takes a function thatreturns a task.",
	"Method": "Task<TResult> callTask(Executor executor,Callable<Task<TResult>> task){\r\n    TaskCompletionSource<TResult> tcs = new TaskCompletionSource();\r\n    executor.execute(() -> {\r\n        try {\r\n            task.call().continueWith(executor, (Continuation<TResult, Void>) task1 -> {\r\n                if (task1.isSuccessful()) {\r\n                    tcs.setResult(task1.getResult());\r\n                } else {\r\n                    tcs.setException(task1.getException());\r\n                }\r\n                return null;\r\n            });\r\n        } catch (Exception e) {\r\n            tcs.setException(e);\r\n        } catch (Throwable t) {\r\n            Exception e = new IllegalStateException(\"Unhandled throwable in callTask.\", t);\r\n            tcs.setException(e);\r\n        }\r\n    });\r\n    return tcs.getTask();\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.UnresolvedSourceLocation.getScriptUri",
	"Comment": "the uri of the script containing the source location if the script has yet to be loaded.can return null.",
	"Method": "String getScriptUri(){\r\n    return json.get(\"scriptUri\") == null ? null : json.get(\"scriptUri\").getAsString();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.ServerTimestampTest.verifyTimestampsUsePreviousValue",
	"Comment": "verifies a snapshot containing setdata but using the previous field value for the timestamps.",
	"Method": "void verifyTimestampsUsePreviousValue(DocumentSnapshot current,DocumentSnapshot previous){\r\n    assertTrue(current.exists());\r\n    if (previous != null) {\r\n        Timestamp when = previous.getTimestamp(\"when\");\r\n        assertNotNull(when);\r\n        assertEquals(expectedDataWithTimestamp(when), current.getData(ServerTimestampBehavior.PREVIOUS));\r\n    } else {\r\n        assertEquals(expectedDataWithTimestamp(null), current.getData(ServerTimestampBehavior.PREVIOUS));\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.Sort.instance",
	"Comment": "returns a sort instance for convenience. multiple threads must not use this instance at the same time.",
	"Method": "Sort instance(){\r\n    if (instance == null)\r\n        instance = new Sort();\r\n    return instance;\r\n}"
}, {
	"Path": "com.google.firebase.database.collection.ArraySortedMap.findKey",
	"Comment": "this does a linear scan which is simpler than a binary search. for a small collection size thisstill should be as fast a as binary search.",
	"Method": "int findKey(K key){\r\n    int i = 0;\r\n    for (K otherKey : this.keys) {\r\n        if (this.comparator.compare(key, otherKey) == 0) {\r\n            return i;\r\n        }\r\n        i++;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.AnnotationAlertListener.getArgsFunction",
	"Comment": "get a function that retrieves argument value based on argument class.",
	"Method": "Function<Class<?>, Object> getArgsFunction(WebDriver driver){\r\n    return input -> {\r\n        if (input.isAssignableFrom(WebDriver.class)) {\r\n            return driver;\r\n        }\r\n        return null;\r\n    };\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Func.getLocation",
	"Comment": "the location of this function in the source code.can return null.",
	"Method": "SourceLocation getLocation(){\r\n    return json.get(\"location\") == null ? null : new SourceLocation((JsonObject) json.get(\"location\"));\r\n}"
}, {
	"Path": "com.google.cloud.datastore.core.number.IndexNumberDecoder.resultAsLong",
	"Comment": "returns the decoded number as a long, or throws illegalargumentexception if not possible.",
	"Method": "long resultAsLong(){\r\n    updateResultLongState();\r\n    if (!longResultRepProblemMessage.isEmpty()) {\r\n        throw new IllegalArgumentException(longResultRepProblemMessage);\r\n    }\r\n    return resultAsLong;\r\n}"
}, {
	"Path": "org.dartlang.analysis.server.protocol.FlutterOutline.getVariableName",
	"Comment": "if flutteroutlinekind.variable, the name of the variable.",
	"Method": "String getVariableName(){\r\n    return variableName;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Isolate.getName",
	"Comment": "a name identifying this isolate. not guaranteed to be unique.",
	"Method": "String getName(){\r\n    return json.get(\"name\").getAsString();\r\n}"
}, {
	"Path": "org.fluentlenium.core.domain.FluentWebElement.conditions",
	"Comment": "get a conditions object used to verify condition on this element.",
	"Method": "FluentConditions conditions(){\r\n    return conditions;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.joints.MotorJoint.getLinearOffset",
	"Comment": "get the target linear offset, in frame a, in meters. do not modify.",
	"Method": "void getLinearOffset(Vec2 out,Vec2 getLinearOffset){\r\n    return linearOffset;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LocalStoreTestCase.assertChanged",
	"Comment": "asserts that a the lastchanges contain the docs in the given array.",
	"Method": "void assertChanged(MaybeDocument expected){\r\n    assertNotNull(lastChanges);\r\n    List<MaybeDocument> actualList = Lists.newArrayList(Iterables.transform(lastChanges, Entry::getValue));\r\n    assertEquals(asList(expected), actualList);\r\n    lastChanges = null;\r\n}"
}, {
	"Path": "com.google.firebase.components.ComponentSorter.sorted",
	"Comment": "given a list of components, returns a sorted permutation of it.",
	"Method": "List<Component<?>> sorted(List<Component<?>> components){\r\n    Set<ComponentNode> graph = toGraph(components);\r\n    Set<ComponentNode> roots = getRoots(graph);\r\n    List<Component<?>> result = new ArrayList();\r\n    while (!roots.isEmpty()) {\r\n        ComponentNode node = roots.iterator().next();\r\n        roots.remove(node);\r\n        result.add(node.getComponent());\r\n        for (ComponentNode dependent : node.getDependencies()) {\r\n            dependent.removeDependent(node);\r\n            if (dependent.isRoot()) {\r\n                roots.add(dependent);\r\n            }\r\n        }\r\n    }\r\n    if (result.size() == components.size()) {\r\n        Collections.reverse(result);\r\n        return result;\r\n    }\r\n    List<Component<?>> componentsInCycle = new ArrayList();\r\n    for (ComponentNode node : graph) {\r\n        if (!node.isRoot() && !node.isLeaf()) {\r\n            componentsInCycle.add(node.getComponent());\r\n        }\r\n    }\r\n    throw new DependencyCycleException(componentsInCycle);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.ApiUtil.invoke",
	"Comment": "invokes the given method on the given instance with the given arguments, converting checkedexceptions to unchecked.",
	"Method": "Object invoke(Method method,Object instance,Object args){\r\n    try {\r\n        return method.invoke(instance, args);\r\n    } catch (IllegalAccessException e) {\r\n        throw new RuntimeException(e);\r\n    } catch (InvocationTargetException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.WriteStream.getLastStreamToken",
	"Comment": "returns the last received stream token from the server, used to acknowledge which responses theclient has processed. stream tokens are opaque checkpoint markers whose only real value istheir inclusion in the next request.writestream implementations manage propagating this value from responses to the nextrequest.",
	"Method": "ByteString getLastStreamToken(){\r\n    return lastStreamToken;\r\n}"
}, {
	"Path": "com.vladmihalcea.flexypool.metric.dropwizard.DropwizardMetricsFactoryService.load",
	"Comment": "load dropwizardmetrics factory if the dropwizard metrics is available at runtime",
	"Method": "MetricsFactory load(){\r\n    return ClassLoaderUtils.findClass(METRICS_CLASS_NAME) ? DropwizardMetrics.FACTORY : null;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.PhysicsComponent.setOnPhysicsInitialized",
	"Comment": "set a callback to run when this entity has been added to physics world.",
	"Method": "void setOnPhysicsInitialized(Runnable code){\r\n    onInitPhysics = code;\r\n}"
}, {
	"Path": "org.dartlang.analysis.server.protocol.FlutterOutline.getAttributes",
	"Comment": "additional attributes for this node, which might be interesting to display on the client. theseattributes are usually arguments for the instance creation or the invocation that created thewidget.",
	"Method": "List<FlutterOutlineAttribute> getAttributes(){\r\n    return attributes;\r\n}"
}, {
	"Path": "org.dartlang.analysis.server.protocol.FlutterOutline.getStateLength",
	"Comment": "if the node is a statefulwidget that can be rendered, and its state class is defined in the samefile, the length of the state class code in the file.",
	"Method": "Integer getStateLength(){\r\n    return stateLength;\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.ComparableTimSort.mergeForceCollapse",
	"Comment": "merges all runs on the stack until only one remains. this method is called once, to complete the sort.",
	"Method": "void mergeForceCollapse(){\r\n    while (stackSize > 1) {\r\n        int n = stackSize - 2;\r\n        if (n > 0 && runLen[n - 1] < runLen[n + 1])\r\n            n--;\r\n        mergeAt(n);\r\n    }\r\n}"
}, {
	"Path": "io.flutter.sdk.FlutterSdk.createFiles",
	"Comment": "runs flutter create and waits for it to finish.shows output in a console unless the module parameter is null.notifies process listener if one is specified.returns the pubroot if successful.",
	"Method": "PubRoot createFiles(VirtualFile baseDir,Module module,ProcessListener listener,FlutterCreateAdditionalSettings additionalSettings){\r\n    final Process process;\r\n    if (module == null) {\r\n        process = flutterCreate(baseDir, additionalSettings).start(null, listener);\r\n    } else {\r\n        process = flutterCreate(baseDir, additionalSettings).startInModuleConsole(module, null, listener);\r\n    }\r\n    if (process == null) {\r\n        return null;\r\n    }\r\n    try {\r\n        if (process.waitFor() != 0) {\r\n            return null;\r\n        }\r\n    } catch (InterruptedException e) {\r\n        LOG.warn(e);\r\n        return null;\r\n    }\r\n    if (EdtInvocationManager.getInstance().isEventDispatchThread()) {\r\n        VfsUtil.markDirtyAndRefresh(false, true, true, baseDir);\r\n    } else {\r\n        baseDir.refresh(false, true);\r\n    }\r\n    return PubRoot.forDirectory(baseDir);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.MemoryMutationQueue.indexOfExistingBatchId",
	"Comment": "finds the index of the given batchid in the mutation queue and asserts that the resulting indexis within the bounds of the queue.",
	"Method": "int indexOfExistingBatchId(int batchId,String action){\r\n    int index = indexOfBatchId(batchId);\r\n    hardAssert(index >= 0 && index < queue.size(), \"Batches must exist to be %s\", action);\r\n    return index;\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.afterChangeValueOf",
	"Comment": "add a listener that will be invoked after changing value of an element.",
	"Method": "EventsRegistry afterChangeValueOf(ElementListener listener){\r\n    afterChangeValueOf.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.database.Query.orderByKey",
	"Comment": "create a query in which child nodes are ordered by their keys.",
	"Method": "Query orderByKey(){\r\n    validateNoOrderByCall();\r\n    QueryParams newParams = this.params.orderBy(KeyIndex.getInstance());\r\n    validateQueryEndpoints(newParams);\r\n    return new Query(repo, path, newParams, true);\r\n}"
}, {
	"Path": "io.flutter.run.daemon.DeviceDaemon.getDevices",
	"Comment": "returns the current devices.this is calculated based on add and remove events seen since the process started.",
	"Method": "ImmutableList<FlutterDevice> getDevices(){\r\n    return devices.get();\r\n}"
}, {
	"Path": "org.dartlang.analysis.server.protocol.FlutterOutlineAttribute.getLabel",
	"Comment": "the label of the attribute value, usually the dart code. it might be quite long, the clientshould abbreviate as needed.",
	"Method": "String getLabel(){\r\n    return label;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.QueryCacheTestCase.addQueryData",
	"Comment": "adds the given query data to the querycache under test, committing immediately.",
	"Method": "QueryData addQueryData(QueryData queryData){\r\n    persistence.runTransaction(\"addQueryData\", () -> queryCache.addQueryData(queryData));\r\n    return queryData;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.QueryCacheTestCase.newQueryData",
	"Comment": "creates a new querydata object from the the given parameters, synthesizing a resume token fromthe snapshot version.",
	"Method": "QueryData newQueryData(Query query,int targetId,long version){\r\n    long sequenceNumber = ++previousSequenceNumber;\r\n    return new QueryData(query, targetId, sequenceNumber, QueryPurpose.LISTEN, version(version), resumeToken(version));\r\n}"
}, {
	"Path": "io.flutter.inspector.DiagnosticsNode.getType",
	"Comment": "dart class defining the diagnostic node.for example, diagnosticproperty, intproperty, stringproperty, etc.this should rarely be required except for cases where custom rendering is desiredof a specific dart diagnostic class.",
	"Method": "String getType(){\r\n    return getStringMember(\"type\");\r\n}"
}, {
	"Path": "com.google.firebase.storage.network.NetworkRequest.getQueryParameters",
	"Comment": "if overridden, returns the query parameters to send on the rest request.",
	"Method": "String getQueryParameters(){\r\n    return null;\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.ObjectSet.ensureCapacity",
	"Comment": "increases the size of the backing array to accommodate the specified number of additional items. useful before adding manyitems to avoid multiple backing array resizes.",
	"Method": "void ensureCapacity(int additionalCapacity){\r\n    int sizeNeeded = size + additionalCapacity;\r\n    if (sizeNeeded >= threshold)\r\n        resize(FXGLMath.nextPowerOfTwo((int) Math.ceil(sizeNeeded / loadFactor)));\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteEventTest.createRemoteEvent",
	"Comment": "creates a single remote event that includes target changes for all provided watchchanges.",
	"Method": "RemoteEvent createRemoteEvent(long snapshotVersion,Map<Integer, QueryData> targetMap,Map<Integer, Integer> outstandingResponses,ImmutableSortedSet<DocumentKey> existingKeys,WatchChange watchChanges){\r\n    WatchChangeAggregator aggregator = createAggregator(targetMap, outstandingResponses, existingKeys, watchChanges);\r\n    return aggregator.createRemoteEvent(version(snapshotVersion));\r\n}"
}, {
	"Path": "org.fluentlenium.utils.ReflectionUtils.getConstructorOptional",
	"Comment": "retrieve the constructor of a class for given optional argument types, considering mandatory values at thebeginning of the given types.",
	"Method": "Constructor<T> getConstructorOptional(Class<T> cls,Class<?> argsTypes,Constructor<T> getConstructorOptional,int mandatoryCount,Class<T> cls,Class<?> argsTypes){\r\n    while (true) {\r\n        try {\r\n            return getConstructor(cls, argsTypes);\r\n        } catch (NoSuchMethodException e) {\r\n            if (argsTypes.length == mandatoryCount) {\r\n                break;\r\n            }\r\n            argsTypes = Arrays.copyOf(argsTypes, argsTypes.length - 1);\r\n        }\r\n    }\r\n    throw new NoSuchMethodException(\"Can't find any valid constructor.\");\r\n}"
}, {
	"Path": "io.flutter.bazel.Workspace.getContentPaths",
	"Comment": "returns the path to each content root within the module that is below the workspace root.each path will be relative to the workspace root directory.",
	"Method": "ImmutableSet<String> getContentPaths(Module module){\r\n    final VirtualFile[] contentRoots = ModuleRootManager.getInstance(module).getContentRoots();\r\n    final ImmutableSet.Builder<String> result = ImmutableSet.builder();\r\n    for (VirtualFile root : contentRoots) {\r\n        final String path = getRelativePath(root);\r\n        if (path != null) {\r\n            result.add(path);\r\n        }\r\n    }\r\n    return result.build();\r\n}"
}, {
	"Path": "com.almasb.fxgl.ai.btree.decorator.Repeat.start",
	"Comment": "draws a value from the distribution that determines how many times the wrapped task must be repeated. any negative value\tmeans forever.\tthis method is called when the task is entered.",
	"Method": "void start(){\r\n    count = times.nextInt();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.SyncEngine.handleRejectedListen",
	"Comment": "called by firestoreclient to notify us of a rejected listen.",
	"Method": "void handleRejectedListen(int targetId,Status error){\r\n    assertCallback(\"handleRejectedListen\");\r\n    LimboResolution limboResolution = limboResolutionsByTarget.get(targetId);\r\n    DocumentKey limboKey = limboResolution != null ? limboResolution.key : null;\r\n    if (limboKey != null) {\r\n        limboTargetsByKey.remove(limboKey);\r\n        limboResolutionsByTarget.remove(targetId);\r\n        Map<DocumentKey, MaybeDocument> documentUpdates = Collections.singletonMap(limboKey, new NoDocument(limboKey, SnapshotVersion.NONE, false));\r\n        Set<DocumentKey> limboDocuments = Collections.singleton(limboKey);\r\n        RemoteEvent event = new RemoteEvent(SnapshotVersion.NONE, Collections.emptyMap(), Collections.emptySet(), documentUpdates, limboDocuments);\r\n        handleRemoteEvent(event);\r\n    } else {\r\n        QueryView queryView = queryViewsByTarget.get(targetId);\r\n        hardAssert(queryView != null, \"Unknown target: %s\", targetId);\r\n        Query query = queryView.getQuery();\r\n        localStore.releaseQuery(query);\r\n        removeAndCleanupQuery(queryView);\r\n        logErrorIfInteresting(error, \"Listen for %s failed\", query);\r\n        syncEngineListener.onError(query, error);\r\n    }\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.beforeGetScreenshotAs",
	"Comment": "add a listener that will be invoked before getscreenshotas.",
	"Method": "EventsRegistry beforeGetScreenshotAs(GetScreenshotAsListener listener){\r\n    beforeGetScreenshotAs.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.inappmessaging.display.internal.layout.util.VerticalViewGroupMeasure.allocateSpace",
	"Comment": "given a certain amount of space left, allocate the space proportionally among all flexiblechildren.",
	"Method": "void allocateSpace(int flexAvail){\r\n    List<ViewMeasure> flexVms = new ArrayList();\r\n    for (ViewMeasure vm : vms) {\r\n        if (vm.isFlex()) {\r\n            flexVms.add(vm);\r\n        }\r\n    }\r\n    Collections.sort(flexVms, new Comparator<ViewMeasure>() {\r\n        @Override\r\n        public int compare(ViewMeasure o1, ViewMeasure o2) {\r\n            if (o1.getDesiredHeight() > o2.getDesiredHeight()) {\r\n                return -1;\r\n            } else if (o1.getDesiredHeight() < o2.getDesiredHeight()) {\r\n                return 1;\r\n            }\r\n            return 0;\r\n        }\r\n    });\r\n    int flexSum = 0;\r\n    for (ViewMeasure vm : flexVms) {\r\n        flexSum += vm.getDesiredHeight();\r\n    }\r\n    int flexCount = flexVms.size();\r\n    if (flexCount >= 6) {\r\n        throw new IllegalStateException(\"VerticalViewGroupMeasure only supports up to 5 children\");\r\n    }\r\n    float minFrac = 0.20f;\r\n    float maxFrac = 1.0f - ((flexCount - 1) * minFrac);\r\n    Logging.logdPair(\"VVGM (minFrac, maxFrac)\", minFrac, maxFrac);\r\n    float extraFracPool = 0f;\r\n    for (ViewMeasure vm : flexVms) {\r\n        float desiredFrac = (float) vm.getDesiredHeight() / flexSum;\r\n        float grantedFrac = desiredFrac;\r\n        if (desiredFrac > maxFrac) {\r\n            extraFracPool += (grantedFrac - maxFrac);\r\n            grantedFrac = maxFrac;\r\n        }\r\n        if (desiredFrac < minFrac) {\r\n            float remainder = minFrac - desiredFrac;\r\n            float addOn = Math.min(remainder, extraFracPool);\r\n            grantedFrac = desiredFrac + addOn;\r\n            extraFracPool -= addOn;\r\n        }\r\n        Logging.logdPair(\"\\t(desired, granted)\", desiredFrac, grantedFrac);\r\n        int maxHeight = (int) (grantedFrac * flexAvail);\r\n        vm.setMaxDimens(w, maxHeight);\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.inappmessaging.display.internal.layout.util.VerticalViewGroupMeasure.allocateSpace",
	"Comment": "given a certain amount of space left, allocate the space proportionally among all flexiblechildren.",
	"Method": "void allocateSpace(int flexAvail){\r\n    if (o1.getDesiredHeight() > o2.getDesiredHeight()) {\r\n        return -1;\r\n    } else if (o1.getDesiredHeight() < o2.getDesiredHeight()) {\r\n        return 1;\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "com.vladsch.flexmark.internal.InlineParserImpl.spnl",
	"Comment": "parse zero or more space characters, including at most one newline and zero or more spaces.",
	"Method": "boolean spnl(){\r\n    match(myParsing.SPNL);\r\n    return true;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Field.getStaticValue",
	"Comment": "the value of this field, if the field is static.can return null.",
	"Method": "InstanceRef getStaticValue(){\r\n    return json.get(\"staticValue\") == null ? null : new InstanceRef((JsonObject) json.get(\"staticValue\"));\r\n}"
}, {
	"Path": "com.google.firebase.database.Query.validateLimit",
	"Comment": "this method validates that limit has been called with the correct combination or parameters",
	"Method": "void validateLimit(QueryParams params){\r\n    if (params.hasStart() && params.hasEnd() && params.hasLimit() && !params.hasAnchoredLimit()) {\r\n        throw new IllegalArgumentException(\"Can't combine startAt(), endAt() and limit(). \" + \"Use limitToFirst() or limitToLast() instead\");\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Body.shouldCollide",
	"Comment": "this is used to prevent connected bodies from colliding.it may lie, depending on the collideconnected flag.",
	"Method": "boolean shouldCollide(Body other){\r\n    if (type != BodyType.DYNAMIC && other.type != BodyType.DYNAMIC) {\r\n        return false;\r\n    }\r\n    for (JointEdge jn = m_jointList; jn != null; jn = jn.next) {\r\n        if (jn.other == other) {\r\n            if (!jn.joint.getCollideConnected()) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Response.getType",
	"Comment": "every response returned by the vm service has the type property. this allows the clientdistinguish between different kinds of responses.",
	"Method": "String getType(){\r\n    return json.get(\"type\").getAsString();\r\n}"
}, {
	"Path": "com.google.firebase.database.tubesock.WebSocket.close",
	"Comment": "close down the socket. will trigger the onclose handler if the socket has not been previouslyclosed.",
	"Method": "void close(){\r\n    switch(state) {\r\n        case NONE:\r\n            state = State.DISCONNECTED;\r\n            return;\r\n        case CONNECTING:\r\n            closeSocket();\r\n            return;\r\n        case CONNECTED:\r\n            sendCloseHandshake();\r\n            return;\r\n        case DISCONNECTING:\r\n            return;\r\n        case DISCONNECTED:\r\n            return;\r\n    }\r\n}"
}, {
	"Path": "com.bartoszlipinski.flippablestackview.OrientedViewPager.setInternalPageChangeListener",
	"Comment": "set a separate onpagechangelistener for internal use by the support library.",
	"Method": "ViewPager.OnPageChangeListener setInternalPageChangeListener(ViewPager.OnPageChangeListener listener){\r\n    ViewPager.OnPageChangeListener oldListener = mInternalPageChangeListener;\r\n    mInternalPageChangeListener = listener;\r\n    return oldListener;\r\n}"
}, {
	"Path": "io.flutter.bazel.Workspace.findContainingWorkspaceFile",
	"Comment": "returns the closest workspace file within or above the given directory, or null if not found.",
	"Method": "VirtualFile findContainingWorkspaceFile(VirtualFile dir){\r\n    while (dir != null) {\r\n        final VirtualFile child = dir.findChild(\"WORKSPACE\");\r\n        if (child != null && child.exists() && !child.isDirectory()) {\r\n            return child;\r\n        }\r\n        dir = dir.getParent();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.google.firebase.storage.network.NetworkRequest.getException",
	"Comment": "if an error has occurred, returns the exception. otherwise null.",
	"Method": "Exception getException(){\r\n    return mException;\r\n}"
}, {
	"Path": "com.vladsch.flexmark.samples.FormatterWithMods.main",
	"Comment": "use the parser to parse and renderer to parse pegdown indentation rules and render commonmark",
	"Method": "void main(String[] args){\r\n    final String original = \"#Heading\\n\" + \"-----\\n\" + \"paragraph text \\n\" + \"[Not Changed](https://example.com#23)\\n\" + \"lazy continuation\\n\" + \"[Changed](https://replace.com#abc)\\n\" + \"\\n\" + \"[reference not changed]: https://example.com#23\\n\" + \"[reference changed]: https://replace.com#abc\\n\" + \"\\n\" + \"\";\r\n    System.out.println(\"original\\n\");\r\n    System.out.println(original);\r\n    Node document = PARSER.parse(original);\r\n    LinkNodeVisitor visitor = new LinkNodeVisitor();\r\n    visitor.replaceUrl(document);\r\n    String commonmark = RENDERER.render(document);\r\n    System.out.println(\"\\n\\nCommonMark\\n\");\r\n    System.out.println(commonmark);\r\n}"
}, {
	"Path": "com.vladsch.flexmark.test.RenderingTestCase.getOptions",
	"Comment": "process comma separated list of option sets and combine them for final set to use",
	"Method": "DataHolder getOptions(SpecExample example,String optionSets){\r\n    if (optionSets == null)\r\n        return null;\r\n    String[] optionNames = optionSets.replace('?', ' ').split(\",\");\r\n    DataHolder options = null;\r\n    boolean isFirst = true;\r\n    for (String optionName : optionNames) {\r\n        String option = optionName.trim();\r\n        if (option.isEmpty() || option.startsWith(\"-\"))\r\n            continue;\r\n        if (option.equals(IGNORE_OPTION_NAME)) {\r\n            throwIgnoredOption(example, optionSets, option);\r\n        } else if (option.equals(FAIL_OPTION_NAME)) {\r\n            options = addOption(options, FAIL, true);\r\n        } else if (option.equals(NO_FILE_EOL_OPTION_NAME)) {\r\n            options = addOption(options, NO_FILE_EOL, true);\r\n        } else if (option.equals(FILE_EOL_OPTION_NAME)) {\r\n            options = addOption(options, NO_FILE_EOL, false);\r\n        } else if (option.equals(TIMED_OPTION_NAME)) {\r\n            options = addOption(options, TIMED, true);\r\n        } else if (option.equals(EMBED_TIMED_OPTION_NAME)) {\r\n            options = addOption(options, EMBED_TIMED, true);\r\n        } else {\r\n            if (options == null) {\r\n                options = options(option);\r\n                if (options == null) {\r\n                    throw new IllegalStateException(\"Option \" + option + \" is not implemented in the RenderingTestCase subclass\");\r\n                }\r\n            } else {\r\n                DataHolder dataSet = options(option);\r\n                if (dataSet != null) {\r\n                    if (isFirst) {\r\n                        options = new MutableDataSet(options);\r\n                        isFirst = false;\r\n                    }\r\n                    ((MutableDataSet) options).setAll(dataSet);\r\n                } else {\r\n                    throw new IllegalStateException(\"Option \" + option + \" is not implemented in the RenderingTestCase subclass\");\r\n                }\r\n            }\r\n            if (IGNORE.getFrom(options)) {\r\n                throwIgnoredOption(example, optionSets, option);\r\n            }\r\n        }\r\n    }\r\n    return options;\r\n}"
}, {
	"Path": "io.flutter.run.daemon.FlutterApp.maybeCallBooleanExtension",
	"Comment": "call a boolean service extension only if it is already present, skippingotherwise.only use this method if you are confident there will not be a racecondition where the service extension is registered shortly afterthis method is called.",
	"Method": "CompletableFuture<Boolean> maybeCallBooleanExtension(String methodName,boolean enabled){\r\n    if (getVMServiceManager().hasServiceExtensionNow(methodName)) {\r\n        return callBooleanExtension(methodName, enabled);\r\n    }\r\n    return CompletableFuture.completedFuture(false);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.mutation.PatchMutation.getValue",
	"Comment": "returns the fields and associated values to use when patching the document.",
	"Method": "ObjectValue getValue(){\r\n    return value;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Message.getMessageObjectId",
	"Comment": "an instance id for the decoded message. this id can be passed to other rpcs, for example,getobject or evaluate.",
	"Method": "String getMessageObjectId(){\r\n    return json.get(\"messageObjectId\").getAsString();\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.common.Mat22.abs",
	"Comment": "return the matrix composed of the absolute values of all elements.",
	"Method": "Mat22 abs(Mat22 abs,Mat22 R){\r\n    return R.abs();\r\n}"
}, {
	"Path": "com.vladsch.flexmark.docx.converter.util.DocxHelper.inheritPBdr",
	"Comment": "try to keep the border of the parent and offset the left border by the difference in indentation between the two so the border staysaligned with the parent. max offset for border is 31pt or 620twif the child has its own left border then nothing is doneother borders are not affectedmust be called after the child indent is set",
	"Method": "void inheritPBdr(PPr child,PPr parent){\r\n    parent = getResolver().getEffectivePPr(parent);\r\n    PPr styledChild = getResolver().getEffectivePPr(child);\r\n    if (has(parent.getPBdr()) && (!has(styledChild.getPBdr()) || !has(styledChild.getPBdr().getLeft()) && has(parent.getPBdr().getLeft()))) {\r\n        PPrBase.Ind cInd = getCopy(styledChild.getInd(), true);\r\n        PPrBase.Ind pInd = getCopy(parent.getInd(), false);\r\n        CTBorder leftBorder = getCopy(parent.getPBdr().getLeft(), true);\r\n        final PPrBase.NumPr numPr = styledChild.getNumPr();\r\n        if (numPr != null) {\r\n            NumberingDefinitionsPart ndp = myDocumentPart.getNumberingDefinitionsPart();\r\n            if (ndp != null) {\r\n                final PPrBase.Ind ndpInd = ndp.getInd(numPr);\r\n                if (ndpInd != null) {\r\n                    if (cInd.getLeft() == null && ndpInd.getLeft() != null) {\r\n                        cInd.setLeft(ndpInd.getLeft());\r\n                    }\r\n                    if (cInd.getRight() == null && ndpInd.getRight() != null) {\r\n                        cInd.setRight(ndpInd.getRight());\r\n                    }\r\n                    if (cInd.getHanging() == null && ndpInd.getHanging() != null) {\r\n                        cInd.setHanging(ndpInd.getHanging());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        final BigInteger indentDiff = safeIndLeft(cInd).subtract(safeIndHanging(cInd)).subtract(safeIndLeft(pInd));\r\n        if (indentDiff.compareTo(ZERO) > 0) {\r\n            final BigInteger[] divideAndRemainder = indentDiff.divideAndRemainder(BigInteger.valueOf(20));\r\n            BigInteger space = safeBigInt(leftBorder.getSpace()).add(divideAndRemainder[0]).min(BigInteger.valueOf(31));\r\n            leftBorder.setSpace(space);\r\n            int remainder = divideAndRemainder[1].intValue();\r\n            if (remainder > 0) {\r\n                ensureInd(child);\r\n                child.getInd().setLeft(ZERO.max(safeIndLeft(cInd).subtract(BigInteger.valueOf(remainder))));\r\n            }\r\n        }\r\n        ensurePBdr(child).setLeft(leftBorder);\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteStore.handleWriteStreamHandshakeComplete",
	"Comment": "handles a successful handshake response from the server, which is our cue to send any pendingwrites.",
	"Method": "void handleWriteStreamHandshakeComplete(){\r\n    localStore.setLastStreamToken(writeStream.getLastStreamToken());\r\n    for (MutationBatch batch : writePipeline) {\r\n        writeStream.writeMutations(batch.getMutations());\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Body.setFixedRotation",
	"Comment": "set this body to have fixed rotation. this causes the mass to be reset.",
	"Method": "void setFixedRotation(boolean flag){\r\n    if (flag) {\r\n        m_flags |= e_fixedRotationFlag;\r\n    } else {\r\n        m_flags &= ~e_fixedRotationFlag;\r\n    }\r\n    resetMassData();\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.particle.ParticleGroupDef.setAngle",
	"Comment": "the world angle of the group in radians. rotates the shape by an angle equal to the value ofangle.",
	"Method": "void setAngle(float angle){\r\n    this.angle = angle;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LruGarbageCollector.calculateQueryCount",
	"Comment": "given a percentile of target to collect, returns the number of targets to collect.",
	"Method": "int calculateQueryCount(int percentile){\r\n    long targetCount = delegate.getTargetCount();\r\n    return (int) ((percentile / 100.0f) * targetCount);\r\n}"
}, {
	"Path": "com.almasb.fxgl.extra.entity.components.RechargeableComponent.restorePercentageMax",
	"Comment": "restore by given percentage. the percentage is calculated frommax value.",
	"Method": "void restorePercentageMax(double value){\r\n    restore(value / 100 * maxValue);\r\n}"
}, {
	"Path": "com.almasb.fxgl.saving.SaveLoadManager.loadTask",
	"Comment": "load serializable data from externalfile on disk file system from saves directory which isin the directory where the game is start from.",
	"Method": "IOTask<DataFile> loadTask(SaveFile saveFile){\r\n    log.debug(\"Loading data: \" + saveFile.getName());\r\n    return FS.<DataFile>readDataTask(saveDir() + saveFile.getName() + DATA_FILE_EXT);\r\n}"
}, {
	"Path": "io.flutter.run.daemon.DeviceService.getStatus",
	"Comment": "returns whether the device list is inactive, loading, or ready.",
	"Method": "State getStatus(){\r\n    final DeviceDaemon daemon = deviceDaemon.getNow();\r\n    if (daemon != null && daemon.isRunning()) {\r\n        return State.READY;\r\n    } else if (deviceDaemon.getState() == Refreshable.State.BUSY) {\r\n        return State.LOADING;\r\n    } else {\r\n        return State.INACTIVE;\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.FirebaseFirestore.batch",
	"Comment": "creates a write batch, used for performing multiple writes as a single atomic operation.",
	"Method": "WriteBatch batch(){\r\n    ensureClientConfigured();\r\n    return new WriteBatch(this);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.WriteBatch.delete",
	"Comment": "deletes the document referred to by the provided documentreference.",
	"Method": "WriteBatch delete(DocumentReference documentRef){\r\n    firestore.validateReference(documentRef);\r\n    verifyNotCommitted();\r\n    mutations.add(new DeleteMutation(documentRef.getKey(), Precondition.NONE));\r\n    return this;\r\n}"
}, {
	"Path": "org.fluentlenium.core.hook.BaseHook.getElement",
	"Comment": "get the underlying element of the hook.can be another hook, or a real element.",
	"Method": "WebElement getElement(){\r\n    return elementSupplier.get();\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.afterScript",
	"Comment": "add a listener that will be invoked after executing a script.",
	"Method": "EventsRegistry afterScript(ScriptListener listener){\r\n    afterScript.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.storage.StorageTask.continueWithTask",
	"Comment": "returns a new task that will be completed with the result of applying the specifiedcontinuation to this task.",
	"Method": "Task<TContinuationResult> continueWithTask(Continuation<TResult, Task<TContinuationResult>> continuation,Task<TContinuationResult> continueWithTask,Executor executor,Continuation<TResult, Task<TContinuationResult>> continuation){\r\n    return continueWithTaskImpl(executor, continuation);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.DocumentReference.set",
	"Comment": "overwrites the document referred to by this documentreference. if the document does not yetexist, it will be created. if a document already exists, it will be overwritten.",
	"Method": "Task<Void> set(Map<String, Object> data,Task<Void> set,Map<String, Object> data,SetOptions options,Task<Void> set,Object pojo,Task<Void> set,Object pojo,SetOptions options){\r\n    return set(firestore.getDataConverter().convertPOJO(pojo), options);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.AbstractStream.handleIdleCloseTimer",
	"Comment": "called by the idle timer when the stream should close due to inactivity.",
	"Method": "void handleIdleCloseTimer(){\r\n    if (this.isOpen()) {\r\n        close(State.Initial, Status.OK);\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.FirebaseFirestore.collection",
	"Comment": "gets a collectionreference instance that refers to the collection at the specified path withinthe database.",
	"Method": "CollectionReference collection(String collectionPath){\r\n    checkNotNull(collectionPath, \"Provided collection path must not be null.\");\r\n    ensureClientConfigured();\r\n    return new CollectionReference(ResourcePath.fromString(collectionPath), this);\r\n}"
}, {
	"Path": "com.google.cloud.datastore.core.number.NumberParts.fromDouble",
	"Comment": "returns the numberparts representation of the given double.",
	"Method": "NumberParts fromDouble(double value){\r\n    long doubleBits = Double.doubleToLongBits(value);\r\n    boolean negative = value < 0.0;\r\n    int exponent = (int) ((doubleBits >>> DOUBLE_SIGNIFICAND_BITS) & 0x7FF) - DOUBLE_EXPONENT_BIAS;\r\n    long significand = doubleBits & ~(-1L << DOUBLE_SIGNIFICAND_BITS);\r\n    if (exponent < DOUBLE_MIN_EXPONENT) {\r\n        if (significand == 0) {\r\n            return NumberParts.create(false, NEGATIVE_INFINITE_EXPONENT, 0);\r\n        } else {\r\n            int leadingZeros = Long.numberOfLeadingZeros(significand);\r\n            int binaryExponent = SIGNIFICAND_BITS - 1 - leadingZeros;\r\n            significand &= ~(1L << binaryExponent);\r\n            significand <<= leadingZeros + 1;\r\n            int adjustment = leadingZeros - (SIGNIFICAND_BITS - DOUBLE_SIGNIFICAND_BITS);\r\n            exponent -= adjustment;\r\n        }\r\n    } else if (exponent > DOUBLE_EXPONENT_BIAS) {\r\n        return significand == 0 ? (negative ? NumberParts.create(true, POSITIVE_INFINITE_EXPONENT, 0) : NumberParts.create(false, POSITIVE_INFINITE_EXPONENT, 0)) : NumberParts.create(true, POSITIVE_INFINITE_EXPONENT, 1);\r\n    } else {\r\n        significand <<= SIGNIFICAND_BITS - DOUBLE_SIGNIFICAND_BITS;\r\n    }\r\n    return NumberParts.create(negative, exponent, significand);\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.IsolateRef.getName",
	"Comment": "a name identifying this isolate. not guaranteed to be unique.",
	"Method": "String getName(){\r\n    return json.get(\"name\").getAsString();\r\n}"
}, {
	"Path": "com.vladmihalcea.flexypool.metric.dropwizard.JmxMetricReporter.init",
	"Comment": "the jmx reporter is activated only if the jmxenabled property is set. if the jmxautostart property is enabled,the jmx reporter will start automatically.",
	"Method": "JmxMetricReporter init(ConfigurationProperties configurationProperties,MetricRegistry metricRegistry){\r\n    if (configurationProperties.isJmxEnabled()) {\r\n        jmxReporter = JmxReporter.forRegistry(metricRegistry).inDomain(getClass().getName() + \".\" + configurationProperties.getUniqueName()).build();\r\n    }\r\n    if (configurationProperties.isJmxAutoStart()) {\r\n        start();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Transaction.delete",
	"Comment": "deletes the document referred to by the provided documentreference.",
	"Method": "Transaction delete(DocumentReference documentRef){\r\n    firestore.validateReference(documentRef);\r\n    transaction.delete(documentRef.getKey());\r\n    return this;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Body.getWorldVector",
	"Comment": "get the world coordinates of a vector given the local coordinates.",
	"Method": "Vec2 getWorldVector(Vec2 localVector){\r\n    Vec2 out = new Vec2();\r\n    getWorldVectorToOut(localVector, out);\r\n    return out;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.ViewSnapshot.fromInitialDocuments",
	"Comment": "returns a view snapshot as if all documents in the snapshot were added.",
	"Method": "ViewSnapshot fromInitialDocuments(Query query,DocumentSet documents,ImmutableSortedSet<DocumentKey> mutatedKeys,boolean fromCache,boolean excludesMetadataChanges){\r\n    List<DocumentViewChange> viewChanges = new ArrayList();\r\n    for (Document doc : documents) {\r\n        viewChanges.add(DocumentViewChange.create(DocumentViewChange.Type.ADDED, doc));\r\n    }\r\n    return new ViewSnapshot(query, documents, DocumentSet.emptySet(query.comparator()), viewChanges, fromCache, mutatedKeys, true, excludesMetadataChanges);\r\n}"
}, {
	"Path": "com.google.firebase.database.DeepEquals.compareUnordered",
	"Comment": "deeply compare the two sets referenced by dualkey. this method attempts to quickly determineinequality by length, then hash, and finally does a deepequals on each element if the two setspassed by the prior tests.",
	"Method": "boolean compareUnordered(Collection col1,Collection col2,Set visited){\r\n    if (col1.size() != col2.size()) {\r\n        return false;\r\n    }\r\n    int h1 = deepHashCode(col1);\r\n    int h2 = deepHashCode(col2);\r\n    if (h1 != h2) {\r\n        return false;\r\n    }\r\n    List copy = new ArrayList(col2);\r\n    for (Object element1 : col1) {\r\n        int len = copy.size();\r\n        for (int i = 0; i < len; i++) {\r\n            if (deepEquals(element1, copy.get(i), visited)) {\r\n                copy.remove(i);\r\n                break;\r\n            }\r\n        }\r\n        if (len == copy.size()) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.almasb.fxgl.util.Optional.orElseThrow",
	"Comment": "return the contained value, if present, otherwise throw an exceptionto be created by the provided supplier.",
	"Method": "T orElseThrow(Supplier<? extends X> exceptionSupplier){\r\n    if (value != null) {\r\n        return value;\r\n    } else {\r\n        throw exceptionSupplier.get();\r\n    }\r\n}"
}, {
	"Path": "io.flutter.run.test.TestForm.updateFields",
	"Comment": "when switching between file and directory scope, update the next field toa suitable default.",
	"Method": "void updateFields(Scope next){\r\n    if (next == Scope.DIRECTORY && displayedScope != Scope.DIRECTORY) {\r\n        final String sep = String.valueOf(File.separatorChar);\r\n        final String path = testFile.getText();\r\n        if (path.contains(sep) && path.endsWith(\".dart\")) {\r\n            testDir.setText(path.substring(0, path.lastIndexOf(sep) + 1));\r\n        } else if (testDir.getText().isEmpty()) {\r\n            testDir.setText(path);\r\n        }\r\n    } else if (next != Scope.DIRECTORY && displayedScope == Scope.DIRECTORY) {\r\n        if (testFile.getText().isEmpty()) {\r\n            testFile.setText(testDir.getText());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.BasePath.append",
	"Comment": "returns a new path whose segments are the current path plus the passed in path",
	"Method": "B append(String segment,B append,B path){\r\n    List<String> newPath = new ArrayList(segments);\r\n    newPath.addAll(path.segments);\r\n    return createPathWithSegments(newPath);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteStore.start",
	"Comment": "starts up the remote store, creating streams, restoring state from localstore, etc. this shouldcalled before using any other api endpoints in this class.",
	"Method": "void start(){\r\n    enableNetwork();\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Event.getException",
	"Comment": "the exception associated with this event, if this is a pauseexception event.can return null.",
	"Method": "InstanceRef getException(){\r\n    return json.get(\"exception\") == null ? null : new InstanceRef((JsonObject) json.get(\"exception\"));\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.PhysicsComponent.applyTorque",
	"Comment": "apply a torque. this affects the angular velocity without affecting the linear velocity of the center of mass. this wakes up the body.",
	"Method": "void applyTorque(float torque){\r\n    applyBodyTorque(physicsWorld.toMetersF(torque));\r\n}"
}, {
	"Path": "org.inferred.freebuilder.processor.util.testing.SharedBehaviorTesting.runChildren",
	"Comment": "runs all children with compilations coalesced for performance.",
	"Method": "void runChildren(RunNotifier notifier){\r\n    if (superDescription.get().getChildren().size() > 1) {\r\n        Queue<SharedCompiler> sharedCompilers = getSharedCompilers(notifier);\r\n        while (!sharedCompilers.isEmpty()) {\r\n            SharedCompiler sharedCompiler = sharedCompilers.remove();\r\n            for (FrameworkMethod child : sharedCompiler.children) {\r\n                runChild(notifier, sharedCompiler, child);\r\n            }\r\n        }\r\n    } else {\r\n        tester = BehaviorTester.create(features);\r\n        try {\r\n            superChildrenInvoker.apply(notifier).evaluate();\r\n        } finally {\r\n            tester = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.storage.FirebaseStorage.getMaxOperationRetryTimeMillis",
	"Comment": "returns the maximum time to retry operations other than upload and download if a failureoccurs.",
	"Method": "long getMaxOperationRetryTimeMillis(){\r\n    return sMaxQueryRetry;\r\n}"
}, {
	"Path": "io.flutter.server.vmService.VMServiceManager.hasServiceExtensionNow",
	"Comment": "returns whether a service extension matching the specified name hasalready been registered.if the service extension may be registered at some point in the future itis bests use hasserviceextension as well to listen for changes in whetherthe extension is present.",
	"Method": "boolean hasServiceExtensionNow(String name){\r\n    synchronized (serviceExtensions) {\r\n        final EventStream<Boolean> stream = serviceExtensions.get(name);\r\n        return stream != null && stream.getValue() == Boolean.TRUE;\r\n    }\r\n}"
}, {
	"Path": "org.fluentlenium.configuration.ConfigurationFactoryProvider.getConfigurationFactory",
	"Comment": "provides the configuration factory for a given container, base on configuration of this configuration.",
	"Method": "ConfigurationFactory getConfigurationFactory(Class<?> container){\r\n    ConfigurationProperties configuration = BOOTSTRAP_FACTORY.newConfiguration(container, new ConfigurationDefaults());\r\n    Class<? extends ConfigurationFactory> configurationFactoryClass = configuration.getConfigurationFactory();\r\n    if (configurationFactoryClass != null) {\r\n        try {\r\n            return ReflectionUtils.newInstance(configurationFactoryClass);\r\n        } catch (InstantiationException | IllegalAccessException | NoSuchMethodException | InvocationTargetException e) {\r\n            throw new ConfigurationException(\"Can't initialize ConfigurationFactory \" + configurationFactoryClass.getName(), e);\r\n        }\r\n    }\r\n    return BOOTSTRAP_FACTORY;\r\n}"
}, {
	"Path": "testcode.script.ScriptEngineSample.scriptingSafe",
	"Comment": "the potential injection will require manual review of the code flow but some false positive can be avoid.",
	"Method": "void scriptingSafe(){\r\n    ScriptEngineManager scriptEngineManager = new ScriptEngineManager();\r\n    ScriptEngine scriptEngine = scriptEngineManager.getEngineByExtension(\"js\");\r\n    String code = \"var test=3;test=test*2;\";\r\n    Object result = scriptEngine.eval(code);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteSerializer.encodeKey",
	"Comment": "encodes the given document key as a fully qualified name. this includes the databaseid from theconstructor and the key path.",
	"Method": "String encodeKey(DocumentKey key){\r\n    return encodeResourceName(databaseId, key.getPath());\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.graph.GraphBuilder.createNode",
	"Comment": "this function is creating a node if does not exist already.it use an map to keep track of previously loaded node rather communicating with neo4j.",
	"Method": "Node createNode(Label lbl,String properties){\r\n    Map<String, Node> cache = graphDb.getNodesCache();\r\n    Map<String, String> props = build(properties);\r\n    String name = props.get(\"name\");\r\n    Node node = cache.get(name);\r\n    if (node == null) {\r\n        node = graphDb.getDb().createNode(lbl);\r\n        for (Map.Entry<String, String> prop : props.entrySet()) {\r\n            node.setProperty(prop.getKey(), prop.getValue());\r\n        }\r\n        cache.put(name, node);\r\n    }\r\n    return node;\r\n}"
}, {
	"Path": "org.fluentlenium.core.action.MouseActions.click",
	"Comment": "clicks at the current mouse location. useful when combined with",
	"Method": "MouseActions click(){\r\n    actions().click().perform();\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.FirebaseFirestore.setFirestoreSettings",
	"Comment": "sets any custom settings used to configure this firebasefirestore object. this method can onlybe called before calling any other methods on this object.",
	"Method": "void setFirestoreSettings(FirebaseFirestoreSettings settings){\r\n    synchronized (databaseId) {\r\n        checkNotNull(settings, \"Provided settings must not be null.\");\r\n        if (client != null && !this.settings.equals(settings)) {\r\n            throw new IllegalStateException(\"FirebaseFirestore has already been started and its settings can no longer be changed. \" + \"You can only call setFirestoreSettings() before calling any other methods on a \" + \"FirebaseFirestore object.\");\r\n        }\r\n        this.settings = settings;\r\n    }\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Func.getCode",
	"Comment": "the compiled code associated with this function.can return null.",
	"Method": "CodeRef getCode(){\r\n    return json.get(\"code\") == null ? null : new CodeRef((JsonObject) json.get(\"code\"));\r\n}"
}, {
	"Path": "io.flutter.FlutterUtils.isInFlutterProject",
	"Comment": "test if the given element is contained in a module with a pub root that declares a flutter dependency.",
	"Method": "boolean isInFlutterProject(PsiElement element){\r\n    final Module module = ModuleUtil.findModuleForPsiElement(element);\r\n    return module != null && FlutterModuleUtils.declaresFlutter(module);\r\n}"
}, {
	"Path": "com.almasb.fxgl.entity.Entities.makeScreenBounds",
	"Comment": "create an entity with a bounding box around the screen with given thickness.",
	"Method": "Entity makeScreenBounds(double thickness){\r\n    double w = FXGL.getSettings().getWidth();\r\n    double h = FXGL.getSettings().getHeight();\r\n    return builder().bbox(new HitBox(\"LEFT\", new Point2D(-thickness, 0), box(thickness, h))).bbox(new HitBox(\"RIGHT\", new Point2D(w, 0), box(thickness, h))).bbox(new HitBox(\"TOP\", new Point2D(0, -thickness), box(w, thickness))).bbox(new HitBox(\"BOT\", new Point2D(0, h), box(w, thickness))).with(new PhysicsComponent()).build();\r\n}"
}, {
	"Path": "io.flutter.run.daemon.DaemonApi.listen",
	"Comment": "receive responses and events from a process until it shuts down.",
	"Method": "void listen(ProcessHandler process,DaemonEvent.Listener listener){\r\n    process.addProcessListener(new ProcessAdapter() {\r\n        @Override\r\n        public void onTextAvailable(@NotNull ProcessEvent event, @NotNull Key outputType) {\r\n            if (outputType.equals(ProcessOutputTypes.STDERR)) {\r\n                final String last = stderr.peekLast();\r\n                if (last != null && !last.endsWith(\"\\n\")) {\r\n                    stderr.removeLast();\r\n                    stderr.add(last + event.getText());\r\n                } else {\r\n                    stderr.add(event.getText());\r\n                }\r\n                while (stderr.size() > STDERR_LINES_TO_KEEP) {\r\n                    stderr.removeFirst();\r\n                }\r\n            } else if (outputType.equals(ProcessOutputTypes.STDOUT)) {\r\n                final String text = event.getText();\r\n                if (FlutterSettings.getInstance().isVerboseLogging()) {\r\n                    LOG.info(\"[<-- \" + text.trim() + \"]\");\r\n                }\r\n                stdoutParser.appendOutput(text);\r\n                for (String line : stdoutParser.getAvailableLines()) {\r\n                    final JsonObject obj = parseAndValidateDaemonEvent(line);\r\n                    if (obj != null) {\r\n                        dispatch(obj, listener);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        @Override\r\n        public void processWillTerminate(@NotNull ProcessEvent event, boolean willBeDestroyed) {\r\n            listener.processWillTerminate();\r\n        }\r\n        @Override\r\n        public void processTerminated(@NotNull ProcessEvent event) {\r\n            listener.processTerminated(event.getExitCode());\r\n        }\r\n    });\r\n    process.startNotify();\r\n}"
}, {
	"Path": "io.flutter.run.daemon.DaemonApi.listen",
	"Comment": "receive responses and events from a process until it shuts down.",
	"Method": "void listen(ProcessHandler process,DaemonEvent.Listener listener){\r\n    if (outputType.equals(ProcessOutputTypes.STDERR)) {\r\n        final String last = stderr.peekLast();\r\n        if (last != null && !last.endsWith(\"\\n\")) {\r\n            stderr.removeLast();\r\n            stderr.add(last + event.getText());\r\n        } else {\r\n            stderr.add(event.getText());\r\n        }\r\n        while (stderr.size() > STDERR_LINES_TO_KEEP) {\r\n            stderr.removeFirst();\r\n        }\r\n    } else if (outputType.equals(ProcessOutputTypes.STDOUT)) {\r\n        final String text = event.getText();\r\n        if (FlutterSettings.getInstance().isVerboseLogging()) {\r\n            LOG.info(\"[<-- \" + text.trim() + \"]\");\r\n        }\r\n        stdoutParser.appendOutput(text);\r\n        for (String line : stdoutParser.getAvailableLines()) {\r\n            final JsonObject obj = parseAndValidateDaemonEvent(line);\r\n            if (obj != null) {\r\n                dispatch(obj, listener);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "io.flutter.run.daemon.DaemonApi.listen",
	"Comment": "receive responses and events from a process until it shuts down.",
	"Method": "void listen(ProcessHandler process,DaemonEvent.Listener listener){\r\n    listener.processWillTerminate();\r\n}"
}, {
	"Path": "io.flutter.run.daemon.DaemonApi.listen",
	"Comment": "receive responses and events from a process until it shuts down.",
	"Method": "void listen(ProcessHandler process,DaemonEvent.Listener listener){\r\n    listener.processTerminated(event.getExitCode());\r\n}"
}, {
	"Path": "io.flutter.utils.Refreshable.runInBackground",
	"Comment": "runs requests until there are no more requests. publishes the last successful response.",
	"Method": "void runInBackground(){\r\n    try {\r\n        publisher.setState(State.BUSY);\r\n        for (Request<T> request = schedule.next(); request != null; request = schedule.next()) {\r\n            try {\r\n                final T value = request.callback.call(request);\r\n                publisher.reschedule(value);\r\n            } catch (CancellationException e) {\r\n            } catch (Exception e) {\r\n                if (!Objects.equal(e.getMessage(), \"expected failure in test\")) {\r\n                    LOG.warn(\"Callback threw an exception while updating a Refreshable\", e);\r\n                }\r\n            } finally {\r\n                schedule.done(request);\r\n            }\r\n            try {\r\n                SwingUtilities.invokeAndWait(() -> {\r\n                    if (!schedule.hasNext()) {\r\n                        if (publisher.publish()) {\r\n                            publisher.fireEvent();\r\n                        }\r\n                    }\r\n                });\r\n            } catch (Exception e) {\r\n                LOG.warn(\"Unable to publish a value while updating a Refreshable\", e);\r\n            }\r\n        }\r\n    } finally {\r\n        publisher.setState(State.IDLE);\r\n        backgroundTask.set(null);\r\n    }\r\n}"
}, {
	"Path": "io.flutter.run.test.TestFields.forTestName",
	"Comment": "creates settings for running tests with the given name within a dart file.",
	"Method": "TestFields forTestName(String testName,String path){\r\n    return new TestFields(testName, path, null);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.FirebaseFirestore.runTransaction",
	"Comment": "executes the given updatefunction and then attempts to commit the changes applied within thetransaction. if any document read within the transaction has changed, the updatefunction willbe retried. if it fails to commit after 5 attempts, the transaction will fail.",
	"Method": "Task<TResult> runTransaction(Transaction.Function<TResult> updateFunction,Executor executor,Task<TResult> runTransaction,Transaction.Function<TResult> updateFunction){\r\n    checkNotNull(updateFunction, \"Provided transaction update function must not be null.\");\r\n    return runTransaction(updateFunction, com.google.firebase.firestore.core.Transaction.getDefaultExecutor());\r\n}"
}, {
	"Path": "com.google.firebase.functions.FirebaseFunctionsException.fromResponse",
	"Comment": "takes an http response and returns the corresponding exception if any.",
	"Method": "FirebaseFunctionsException fromResponse(Code code,String body,Serializer serializer){\r\n    String description = code.name();\r\n    Object details = null;\r\n    try {\r\n        JSONObject json = new JSONObject(body);\r\n        JSONObject error = json.getJSONObject(\"error\");\r\n        if (error.opt(\"status\") instanceof String) {\r\n            code = Code.valueOf(error.getString(\"status\"));\r\n            description = code.name();\r\n        }\r\n        if (error.opt(\"message\") instanceof String) {\r\n            description = error.getString(\"message\");\r\n        }\r\n        details = error.opt(\"details\");\r\n        if (details != null) {\r\n            details = serializer.decode(details);\r\n        }\r\n    } catch (IllegalArgumentException iae) {\r\n        code = Code.INTERNAL;\r\n        description = code.name();\r\n    } catch (JSONException ioe) {\r\n    }\r\n    if (code == Code.OK) {\r\n        return null;\r\n    }\r\n    return new FirebaseFunctionsException(description, code, details);\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.IntMap.shrink",
	"Comment": "reduces the size of the backing arrays to be the specified capacity or less. if the capacity is already less, nothing isdone. if the map contains more items than the specified capacity, the next highest power of two capacity is used instead.",
	"Method": "void shrink(int maximumCapacity){\r\n    if (maximumCapacity < 0)\r\n        throw new IllegalArgumentException(\"maximumCapacity must be >= 0: \" + maximumCapacity);\r\n    if (size > maximumCapacity)\r\n        maximumCapacity = size;\r\n    if (capacity <= maximumCapacity)\r\n        return;\r\n    maximumCapacity = FXGLMath.nextPowerOfTwo(maximumCapacity);\r\n    resize(maximumCapacity);\r\n}"
}, {
	"Path": "io.flutter.actions.DeviceSelectorAction.getPreselectCondition",
	"Comment": "show the current device as selected when the combo box menu opens.",
	"Method": "Condition<AnAction> getPreselectCondition(){\r\n    return action -> action == selectedDeviceAction;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteStore.addToWritePipeline",
	"Comment": "queues additional writes to be sent to the write stream, sending them immediately if the writestream is established.",
	"Method": "void addToWritePipeline(MutationBatch mutationBatch){\r\n    hardAssert(canAddToWritePipeline(), \"addToWritePipeline called when pipeline is full\");\r\n    writePipeline.add(mutationBatch);\r\n    if (writeStream.isOpen() && writeStream.isHandshakeComplete()) {\r\n        writeStream.writeMutations(mutationBatch.getMutations());\r\n    }\r\n}"
}, {
	"Path": "io.flutter.run.daemon.DeviceDaemon.chooseCommand",
	"Comment": "returns the appropriate command to start the device daemon, if any.a null means the device daemon should be shut down.",
	"Method": "Command chooseCommand(Project project){\r\n    if (!usesFlutter(project)) {\r\n        return null;\r\n    }\r\n    final String androidHome = IntelliJAndroidSdk.chooseAndroidHome(project, false);\r\n    final Workspace workspace = WorkspaceCache.getInstance(project).getNow();\r\n    if (workspace != null) {\r\n        final String script = workspace.getDaemonScript();\r\n        if (script != null) {\r\n            return new Command(workspace.getRoot().getPath(), script, ImmutableList.of(), androidHome);\r\n        }\r\n    }\r\n    final FlutterSdk sdk = FlutterSdk.getFlutterSdk(project);\r\n    if (sdk == null) {\r\n        return null;\r\n    }\r\n    try {\r\n        final String path = FlutterSdkUtil.pathToFlutterTool(sdk.getHomePath());\r\n        return new Command(sdk.getHomePath(), path, ImmutableList.of(\"daemon\"), androidHome);\r\n    } catch (ExecutionException e) {\r\n        LOG.warn(\"Unable to calculate command to watch Flutter devices\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.PersistenceTestHelpers.createSQLitePersistence",
	"Comment": "creates and starts a new sqlitepersistence instance for testing.",
	"Method": "SQLitePersistence createSQLitePersistence(){\r\n    return openSQLitePersistence(nextSQLiteDatabaseName());\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.ContainerAnnotationsEventsRegistry.getListenerCount",
	"Comment": "number of listener associated with the underlying container.",
	"Method": "int getListenerCount(){\r\n    return listenerCount;\r\n}"
}, {
	"Path": "com.almasb.fxgl.entity.Entity.setOnActive",
	"Comment": "set a callback for when entity is added to world.the callback will not be executed if entity is already in the world.",
	"Method": "void setOnActive(Runnable action){\r\n    onActive = action;\r\n}"
}, {
	"Path": "com.google.firebase.database.core.WriteTreeRef.calcNextNodeAfterPost",
	"Comment": "this method is used when processing child remove events on a query. if we can, we pull inchildren that were outside the window, but may now be in the window",
	"Method": "NamedNode calcNextNodeAfterPost(Node completeServerData,NamedNode startPost,boolean reverse,Index index){\r\n    return this.writeTree.calcNextNodeAfterPost(this.treePath, completeServerData, startPost, reverse, index);\r\n}"
}, {
	"Path": "com.google.firebase.database.core.WriteTree.calcNextNodeAfterPost",
	"Comment": "this method is used when processing child remove events on a query. if we can, we pull inchildren that were outside the window, but may now be in the window.",
	"Method": "NamedNode calcNextNodeAfterPost(Path treePath,Node completeServerData,NamedNode post,boolean reverse,Index index){\r\n    Node toIterate;\r\n    CompoundWrite merge = this.visibleWrites.childCompoundWrite(treePath);\r\n    Node shadowingNode = merge.getCompleteNode(Path.getEmptyPath());\r\n    if (shadowingNode != null) {\r\n        toIterate = shadowingNode;\r\n    } else if (completeServerData != null) {\r\n        toIterate = merge.apply(completeServerData);\r\n    } else {\r\n        return null;\r\n    }\r\n    NamedNode currentNext = null;\r\n    for (NamedNode node : toIterate) {\r\n        if (index.compare(node, post, reverse) > 0 && (currentNext == null || index.compare(node, currentNext, reverse) < 0)) {\r\n            currentNext = node;\r\n        }\r\n    }\r\n    return currentNext;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.Query.whereLessThanOrEqualTo",
	"Comment": "creates and returns a new query with the additional filter that documents must contain thespecified field and the value should be less than or equal to the specified value.",
	"Method": "Query whereLessThanOrEqualTo(String field,Object value,Query whereLessThanOrEqualTo,FieldPath fieldPath,Object value){\r\n    return whereHelper(fieldPath, Operator.LESS_THAN_OR_EQUAL, value);\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.afterGetText",
	"Comment": "add a listener that will be invoked after get text of an element.",
	"Method": "EventsRegistry afterGetText(ElementListener listener){\r\n    afterGetText.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.firebase.database.Query.equalTo",
	"Comment": "create a query constrained to only return the child node with the given key and value. notethat there is at most one such child as keys are unique.",
	"Method": "Query equalTo(String value,Query equalTo,double value,Query equalTo,boolean value,Query equalTo,String value,String key,Query equalTo,double value,String key,Query equalTo,boolean value,String key){\r\n    validateEqualToCall();\r\n    return this.startAt(value, key).endAt(value, key);\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Script.getTokenPosTable",
	"Comment": "a table encoding a mapping from token position to line and column.",
	"Method": "List<List<Integer>> getTokenPosTable(){\r\n    return getListListInt(\"tokenPosTable\");\r\n}"
}, {
	"Path": "io.flutter.sdk.FlutterCommand.getDisplayCommand",
	"Comment": "returns a displayable version of the command that will be run.",
	"Method": "String getDisplayCommand(){\r\n    final List<String> words = new ArrayList();\r\n    words.add(\"flutter\");\r\n    words.addAll(type.subCommand);\r\n    words.addAll(args);\r\n    return String.join(\" \", words);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.BasePath.isImmediateParentOf",
	"Comment": "returns true if the given argument is a direct child of this path.empty path is a parent of any path that consists of a single segment.",
	"Method": "boolean isImmediateParentOf(B potentialChild){\r\n    if (length() + 1 != potentialChild.length()) {\r\n        return false;\r\n    }\r\n    for (int i = 0; i < length(); i++) {\r\n        if (!getSegment(i).equals(potentialChild.getSegment(i))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.SourceReportCoverage.getMisses",
	"Comment": "a list of token positions in a sourcereportrange which have not been executed.the list issorted.",
	"Method": "List<Integer> getMisses(){\r\n    return getListInt(\"misses\");\r\n}"
}, {
	"Path": "fr.pilato.elasticsearch.crawler.fs.framework.StreamsUtil.copy",
	"Comment": "copies all bytes from the input stream to the output stream.does not close or flush either stream.",
	"Method": "long copy(InputStream from,OutputStream to){\r\n    assert from != null;\r\n    assert to != null;\r\n    byte[] buf = new byte[BUF_SIZE];\r\n    long total = 0;\r\n    while (true) {\r\n        int r = from.read(buf);\r\n        if (r == -1) {\r\n            break;\r\n        }\r\n        to.write(buf, 0, r);\r\n        total += r;\r\n    }\r\n    return total;\r\n}"
}, {
	"Path": "io.flutter.inspector.DiagnosticsNode.getDartDiagnosticRef",
	"Comment": "reference the actual dart diagnosticsnode object this object is referencing.",
	"Method": "InspectorInstanceRef getDartDiagnosticRef(){\r\n    final JsonElement objectId = json.get(\"objectId\");\r\n    return new InspectorInstanceRef(objectId.isJsonNull() ? null : objectId.getAsString());\r\n}"
}, {
	"Path": "io.flutter.preview.PreviewArea.renderingStarted",
	"Comment": "a new outline was received, and we started rendering.until rendering is finished, the area is inconsistent with the new outline.it should not ignore incoming events and should not send its events to the listener.",
	"Method": "void renderingStarted(){\r\n    isBeingRendered = true;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteStore.shouldStartWatchStream",
	"Comment": "returns true if the network is enabled, the watch stream has not yet been started and there areactive watch targets.",
	"Method": "boolean shouldStartWatchStream(){\r\n    return canUseNetwork() && !watchStream.isStarted() && !listenTargets.isEmpty();\r\n}"
}, {
	"Path": "io.flutter.run.test.TestConfigProducer.isConfigurationFromContext",
	"Comment": "returns true if a run config was already created for this file. if so we will reuse it.",
	"Method": "boolean isConfigurationFromContext(TestConfig config,ConfigurationContext context){\r\n    final VirtualFile fileOrDir = config.getFields().getFileOrDir();\r\n    if (fileOrDir == null)\r\n        return false;\r\n    final PsiElement target = context.getPsiLocation();\r\n    if (target instanceof PsiDirectory) {\r\n        return ((PsiDirectory) target).getVirtualFile().equals(fileOrDir);\r\n    }\r\n    if (!FlutterRunConfigurationProducer.hasDartFile(context, fileOrDir.getPath()))\r\n        return false;\r\n    final String testName = TestConfigUtils.findTestName(context.getPsiLocation());\r\n    if (config.getFields().getScope() == TestFields.Scope.NAME) {\r\n        return testName != null && testName.equals(config.getFields().getTestName());\r\n    } else {\r\n        return testName == null;\r\n    }\r\n}"
}, {
	"Path": "io.flutter.utils.FlutterModuleUtils.ensureRunConfigSelected",
	"Comment": "ensures a flutter run configuration is selected in the run pull down.",
	"Method": "void ensureRunConfigSelected(Project project){\r\n    final FlutterRunConfigurationType configType = FlutterRunConfigurationType.getInstance();\r\n    final RunManager runManager = RunManager.getInstance(project);\r\n    if (!runManager.getConfigurationsList(configType).isEmpty()) {\r\n        if (runManager.getSelectedConfiguration() == null) {\r\n            final List<RunnerAndConfigurationSettings> flutterConfigs = runManager.getConfigurationSettingsList(configType);\r\n            if (!flutterConfigs.isEmpty()) {\r\n                runManager.setSelectedConfiguration(flutterConfigs.get(0));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.h3xstream.findsecbugs.taintanalysis.BaseConfigValidation.validateClass",
	"Comment": "validate if the class name exists.it is expecting that api will be in the classpath. the class are either part of the dependencies or in mostcases the stubs",
	"Method": "void validateClass(String className,String origfileName){\r\n    if (classesDeprecatedInJava8.contains(className))\r\n        return;\r\n    if (classesDeprecatedInJava9.contains(className))\r\n        return;\r\n    if (className.endsWith(\"$\"))\r\n        return;\r\n    if (className.startsWith(\"play.\"))\r\n        return;\r\n    if (className.startsWith(\"anorm\"))\r\n        return;\r\n    if (className.startsWith(\"slick\"))\r\n        return;\r\n    if (className.contains(\".log\"))\r\n        return;\r\n    if (className.contains(\".Log\"))\r\n        return;\r\n    if (className.equals(\"javax.naming.directory.Context\"))\r\n        return;\r\n    try {\r\n        Class.forName(className);\r\n    } catch (ClassNotFoundException e) {\r\n        String classNotFound = String.format(\"[!] Class not found %s (%s)\", className, origfileName);\r\n        fail(\"Configurations were added for a class that does not exist. It is likely a typographical error or because the API was not tested. \" + classNotFound);\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.database.Query.limitToLast",
	"Comment": "create a query with limit and anchor it to the end of the window",
	"Method": "Query limitToLast(int limit){\r\n    if (limit <= 0) {\r\n        throw new IllegalArgumentException(\"Limit must be a positive integer!\");\r\n    }\r\n    if (params.hasLimit()) {\r\n        throw new IllegalArgumentException(\"Can't call limitToLast on query with previously set limit!\");\r\n    }\r\n    return new Query(repo, path, params.limitToLast(limit), orderByCalled);\r\n}"
}, {
	"Path": "com.vladsch.flexmark.samples.PegdownCustomLinkResolverOptions.main",
	"Comment": "use the parser to parse and renderer to render with pegdown compatibility",
	"Method": "void main(String[] args){\r\n    Node document = PARSER.parse(\"This is *Sparta* [[document]] and this is not a link [bar](/url)\");\r\n    String html = RENDERER.render(document);\r\n    System.out.println(html);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Body.setSleepingAllowed",
	"Comment": "you can disable sleeping on this body.if you disable sleeping, the body will be woken.",
	"Method": "void setSleepingAllowed(boolean flag){\r\n    if (flag) {\r\n        m_flags |= e_autoSleepFlag;\r\n    } else {\r\n        m_flags &= ~e_autoSleepFlag;\r\n        setAwake(true);\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.joints.PrismaticJointDef.initialize",
	"Comment": "initialize the bodies, anchors, axis, and reference angle using the world anchor and worldaxis.",
	"Method": "void initialize(Body b1,Body b2,Vec2 anchor,Vec2 axis){\r\n    bodyA = b1;\r\n    bodyB = b2;\r\n    bodyA.getLocalPointToOut(anchor, localAnchorA);\r\n    bodyB.getLocalPointToOut(anchor, localAnchorB);\r\n    bodyA.getLocalVectorToOut(axis, localAxisA);\r\n    referenceAngle = bodyB.getAngle() - bodyA.getAngle();\r\n}"
}, {
	"Path": "com.google.firebase.firestore.core.Transaction.lookup",
	"Comment": "takes a set of keys and asynchronously attempts to fetch all the documents from the backend,ignoring any local changes.",
	"Method": "Task<List<MaybeDocument>> lookup(List<DocumentKey> keys){\r\n    if (committed) {\r\n        return Tasks.forException(new FirebaseFirestoreException(\"Transaction has already completed.\", Code.FAILED_PRECONDITION));\r\n    }\r\n    if (mutations.size() != 0) {\r\n        return Tasks.forException(new FirebaseFirestoreException(\"Transactions lookups are invalid after writes.\", Code.FAILED_PRECONDITION));\r\n    }\r\n    return datastore.lookup(keys).continueWithTask(Executors.DIRECT_EXECUTOR, task -> {\r\n        if (task.isSuccessful()) {\r\n            for (MaybeDocument doc : task.getResult()) {\r\n                recordVersion(doc);\r\n            }\r\n        }\r\n        return task;\r\n    });\r\n}"
}, {
	"Path": "com.google.firebase.FirebaseApp.getInstance",
	"Comment": "returns the instance identified by the unique name, or throws if it does not exist.",
	"Method": "FirebaseApp getInstance(FirebaseApp getInstance,String name){\r\n    synchronized (LOCK) {\r\n        FirebaseApp firebaseApp = INSTANCES.get(normalize(name));\r\n        if (firebaseApp != null) {\r\n            return firebaseApp;\r\n        }\r\n        List<String> availableAppNames = getAllAppNames();\r\n        String availableAppNamesMessage;\r\n        if (availableAppNames.isEmpty()) {\r\n            availableAppNamesMessage = \"\";\r\n        } else {\r\n            availableAppNamesMessage = \"Available app names: \" + TextUtils.join(\", \", availableAppNames);\r\n        }\r\n        String errorMessage = String.format(\"FirebaseApp with name %s doesn't exist. %s\", name, availableAppNamesMessage);\r\n        throw new IllegalStateException(errorMessage);\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.functions.FirebaseFunctionsException.getDetails",
	"Comment": "gets the details object, if one was included in the error response.",
	"Method": "Object getDetails(){\r\n    return details;\r\n}"
}, {
	"Path": "com.google.firebase.storage.internal.SmartHandler.callBack",
	"Comment": "calls back the runnable on the thread loop when this handler was created. if there was noinstalled looper, then the threadpool is used.",
	"Method": "void callBack(Runnable runnable){\r\n    Preconditions.checkNotNull(runnable);\r\n    if (handler == null) {\r\n        if (executor != null) {\r\n            executor.execute(runnable);\r\n        } else {\r\n            StorageTaskScheduler.getInstance().scheduleCallback(runnable);\r\n        }\r\n    } else {\r\n        handler.post(runnable);\r\n    }\r\n}"
}, {
	"Path": "io.flutter.run.PositionMapper.findLocalFile",
	"Comment": "attempt to find a local dart file corresponding to a script in observatory.",
	"Method": "VirtualFile findLocalFile(ScriptRef scriptRef,VirtualFile findLocalFile,Script script,VirtualFile findLocalFile,String uri){\r\n    return ApplicationManager.getApplication().runReadAction((Computable<VirtualFile>) () -> {\r\n        final String remote = uri;\r\n        if (remoteSourceRoot != null && remote.startsWith(remoteSourceRoot)) {\r\n            final String rootUri = StringUtil.trimEnd(resolver.getDartUrlForFile(sourceRoot), '/');\r\n            final String suffix = remote.substring(remoteSourceRoot.length());\r\n            return resolver.findFileByDartUrl(rootUri + suffix);\r\n        }\r\n        if (remoteBaseUri != null && remote.startsWith(remoteBaseUri)) {\r\n            final String rootUri = StringUtil.trimEnd(resolver.getDartUrlForFile(sourceRoot), '/');\r\n            final String suffix = remote.substring(remoteBaseUri.length());\r\n            return resolver.findFileByDartUrl(rootUri + suffix);\r\n        }\r\n        final String remoteUri;\r\n        if (remote.startsWith(\"/\")) {\r\n            remoteUri = new File(remote).toURI().toString();\r\n        } else {\r\n            remoteUri = remote;\r\n        }\r\n        if (analyzer != null && !isDartPatchUri(remoteUri)) {\r\n            final String path = analyzer.getAbsolutePath(remoteUri);\r\n            if (path != null) {\r\n                return LocalFileSystem.getInstance().findFileByPath(path);\r\n            }\r\n        }\r\n        return resolver.findFileByDartUrl(remoteUri);\r\n    });\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.CollisionHandler.copyFor",
	"Comment": "returns a copy of the collision handler with different entity types.this allows convenient use of the same handler code formultiple entity types.",
	"Method": "CollisionHandler copyFor(Object a,Object b){\r\n    CollisionHandler copy = this;\r\n    return new CollisionHandler(a, b) {\r\n        @Override\r\n        protected void onHitBoxTrigger(Entity a, Entity b, HitBox boxA, HitBox boxB) {\r\n            copy.onHitBoxTrigger(a, b, boxA, boxB);\r\n        }\r\n        @Override\r\n        protected void onCollisionBegin(Entity a, Entity b) {\r\n            copy.onCollisionBegin(a, b);\r\n        }\r\n        @Override\r\n        protected void onCollision(Entity a, Entity b) {\r\n            copy.onCollision(a, b);\r\n        }\r\n        @Override\r\n        protected void onCollisionEnd(Entity a, Entity b) {\r\n            copy.onCollisionEnd(a, b);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.CollisionHandler.copyFor",
	"Comment": "returns a copy of the collision handler with different entity types.this allows convenient use of the same handler code formultiple entity types.",
	"Method": "CollisionHandler copyFor(Object a,Object b){\r\n    copy.onHitBoxTrigger(a, b, boxA, boxB);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.CollisionHandler.copyFor",
	"Comment": "returns a copy of the collision handler with different entity types.this allows convenient use of the same handler code formultiple entity types.",
	"Method": "CollisionHandler copyFor(Object a,Object b){\r\n    copy.onCollisionBegin(a, b);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.CollisionHandler.copyFor",
	"Comment": "returns a copy of the collision handler with different entity types.this allows convenient use of the same handler code formultiple entity types.",
	"Method": "CollisionHandler copyFor(Object a,Object b){\r\n    copy.onCollision(a, b);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.CollisionHandler.copyFor",
	"Comment": "returns a copy of the collision handler with different entity types.this allows convenient use of the same handler code formultiple entity types.",
	"Method": "CollisionHandler copyFor(Object a,Object b){\r\n    copy.onCollisionEnd(a, b);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.DocumentSet.contains",
	"Comment": "returns true iff this set contains a document with the given key.",
	"Method": "boolean contains(DocumentKey key){\r\n    return keyIndex.containsKey(key);\r\n}"
}, {
	"Path": "io.flutter.view.FlutterViewToggleableAction.setEnabledStateValue",
	"Comment": "overrides the default enabledstatevalue for actions whose enabled value is not a boolean.",
	"Method": "void setEnabledStateValue(Object enabledStateValue){\r\n    this.enabledStateValue = enabledStateValue;\r\n}"
}, {
	"Path": "org.fluentlenium.configuration.AbstractFactoryRegistryImpl.getDefault",
	"Comment": "get the default factory from given list of available factories.",
	"Method": "T getDefault(T getDefault,List<T> filteredFactories){\r\n    List<T> factoriesList;\r\n    synchronized (this) {\r\n        factoriesList = new ArrayList(factories.values());\r\n    }\r\n    Collections.sort(factoriesList, new Comparator<T>() {\r\n        @Override\r\n        public int compare(T o1, T o2) {\r\n            FactoryPriority annotation1 = o1.getClass().getAnnotation(FactoryPriority.class);\r\n            int p1 = annotation1 == null ? 0 : annotation1.value();\r\n            FactoryPriority annotation2 = o2.getClass().getAnnotation(FactoryPriority.class);\r\n            int p2 = annotation2 == null ? 0 : annotation2.value();\r\n            return Integer.compare(p2, p1);\r\n        }\r\n    });\r\n    List<T> filteredFactories = new ArrayList();\r\n    for (T factory : factoriesList) {\r\n        if (factory instanceof ReflectiveFactory) {\r\n            if (((ReflectiveFactory) factory).isAvailable()) {\r\n                filteredFactories.add(factory);\r\n            }\r\n        } else {\r\n            filteredFactories.add(factory);\r\n        }\r\n    }\r\n    return getDefault(filteredFactories);\r\n}"
}, {
	"Path": "org.fluentlenium.configuration.AbstractFactoryRegistryImpl.getDefault",
	"Comment": "get the default factory from given list of available factories.",
	"Method": "T getDefault(T getDefault,List<T> filteredFactories){\r\n    FactoryPriority annotation1 = o1.getClass().getAnnotation(FactoryPriority.class);\r\n    int p1 = annotation1 == null ? 0 : annotation1.value();\r\n    FactoryPriority annotation2 = o2.getClass().getAnnotation(FactoryPriority.class);\r\n    int p2 = annotation2 == null ? 0 : annotation2.value();\r\n    return Integer.compare(p2, p1);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.joints.DistanceJoint.getReactionTorque",
	"Comment": "get the reaction torque given the inverse time step. unit is nm. this is always zero for adistance joint.",
	"Method": "float getReactionTorque(float inv_dt){\r\n    return 0.0f;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.PhysicsComponent.setFixtureDef",
	"Comment": "set custom fixture definition to describe a generatedfixture for this physics entity.",
	"Method": "void setFixtureDef(FixtureDef def){\r\n    fixtureDef = def;\r\n}"
}, {
	"Path": "fr.pilato.elasticsearch.crawler.fs.rest.TimeBasedUUIDGenerator.putLong",
	"Comment": "puts the lower numberoflongbytes from l into the array, starting index pos.",
	"Method": "void putLong(byte[] array,long l,int pos,int numberOfLongBytes){\r\n    for (int i = 0; i < numberOfLongBytes; ++i) {\r\n        array[pos + numberOfLongBytes - i - 1] = (byte) (l >>> (i * 8));\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.PhysicsComponent.applyLinearImpulse",
	"Comment": "apply an impulse at a point. this immediately modifies the velocity. it also modifies the angular velocity if the point of application is not at the center of mass. this wakes up the body.",
	"Method": "void applyLinearImpulse(Point2D impulse,Point2D point,boolean wake){\r\n    applyBodyLinearImpulse(physicsWorld.toVector(impulse), physicsWorld.toPoint(point), wake);\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.math.Vec2.getLengthAndNormalize",
	"Comment": "normalize this vector and return the length before normalization.alters this vector.",
	"Method": "float getLengthAndNormalize(){\r\n    float length = length();\r\n    if (length < FXGLMath.EPSILON) {\r\n        return 0f;\r\n    }\r\n    float invLength = 1.0f / length;\r\n    x *= invLength;\r\n    y *= invLength;\r\n    return length;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.RemoteStore.shouldStartWriteStream",
	"Comment": "returns true if the network is enabled, the write stream has not yet been started and there arepending writes.",
	"Method": "boolean shouldStartWriteStream(){\r\n    return canUseNetwork() && !writeStream.isStarted() && !writePipeline.isEmpty();\r\n}"
}, {
	"Path": "com.bartoszlipinski.flippablestackview.OrientedViewPager.addFocusables",
	"Comment": "we only want the current page that is being shown to be focusable.",
	"Method": "void addFocusables(ArrayList<View> views,int direction,int focusableMode){\r\n    final int focusableCount = views.size();\r\n    final int descendantFocusability = getDescendantFocusability();\r\n    if (descendantFocusability != FOCUS_BLOCK_DESCENDANTS) {\r\n        for (int i = 0; i < getChildCount(); i++) {\r\n            final View child = getChildAt(i);\r\n            if (child.getVisibility() == VISIBLE) {\r\n                ItemInfo ii = infoForChild(child);\r\n                if (ii != null && ii.position == mCurItem) {\r\n                    child.addFocusables(views, direction, focusableMode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (descendantFocusability != FOCUS_AFTER_DESCENDANTS || (focusableCount == views.size())) {\r\n        if (!isFocusable()) {\r\n            return;\r\n        }\r\n        if ((focusableMode & FOCUSABLES_TOUCH_MODE) == FOCUSABLES_TOUCH_MODE && isInTouchMode() && !isFocusableInTouchMode()) {\r\n            return;\r\n        }\r\n        if (views != null) {\r\n            views.add(this);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.ObjectSet.add",
	"Comment": "returns true if the key was not already in the set. if this set already contains the key, the call leaves the set unchangedand returns false.",
	"Method": "boolean add(T key){\r\n    if (key == null)\r\n        throw new IllegalArgumentException(\"key cannot be null.\");\r\n    T[] keyTable = this.keyTable;\r\n    int hashCode = key.hashCode();\r\n    int index1 = hashCode & mask;\r\n    T key1 = keyTable[index1];\r\n    if (key.equals(key1))\r\n        return false;\r\n    int index2 = hash2(hashCode);\r\n    T key2 = keyTable[index2];\r\n    if (key.equals(key2))\r\n        return false;\r\n    int index3 = hash3(hashCode);\r\n    T key3 = keyTable[index3];\r\n    if (key.equals(key3))\r\n        return false;\r\n    for (int i = capacity, n = i + stashSize; i < n; i++) if (key.equals(keyTable[i]))\r\n        return false;\r\n    if (key1 == null) {\r\n        keyTable[index1] = key;\r\n        if (size++ >= threshold)\r\n            resize(capacity << 1);\r\n        return true;\r\n    }\r\n    if (key2 == null) {\r\n        keyTable[index2] = key;\r\n        if (size++ >= threshold)\r\n            resize(capacity << 1);\r\n        return true;\r\n    }\r\n    if (key3 == null) {\r\n        keyTable[index3] = key;\r\n        if (size++ >= threshold)\r\n            resize(capacity << 1);\r\n        return true;\r\n    }\r\n    push(key, index1, key1, index2, key2, index3, key3);\r\n    return true;\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.IntArray.random",
	"Comment": "returns a random item from the array, or zero if the array is empty.",
	"Method": "int random(){\r\n    if (size == 0)\r\n        return 0;\r\n    return items[FXGLMath.random(0, size - 1)];\r\n}"
}, {
	"Path": "com.google.firebase.storage.network.NetworkRequest.getResultHeaders",
	"Comment": "if overridden, returns the headers to send on the rest request.",
	"Method": "Map<String, String> getResultHeaders(){\r\n    return requestHeaders;\r\n}"
}, {
	"Path": "org.fluentlenium.core.events.EventsRegistry.afterClickOn",
	"Comment": "add a listener that will be invoked after clicking an element.",
	"Method": "EventsRegistry afterClickOn(ElementListener listener){\r\n    afterClickOn.add(listener);\r\n    return this;\r\n}"
}, {
	"Path": "io.flutter.run.test.TestFields.getRelativePath",
	"Comment": "returns the relative path to the file or directory from the pub root, or null if not in a pub root.",
	"Method": "String getRelativePath(Project project){\r\n    final PubRoot root = getPubRoot(project);\r\n    if (root == null)\r\n        return null;\r\n    final VirtualFile fileOrDir = getFileOrDir();\r\n    if (fileOrDir == null)\r\n        return null;\r\n    return root.getRelativePath(fileOrDir);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.collision.shapes.Shape.getType",
	"Comment": "get the type of this shape. you can use this to down cast to the concrete shape.",
	"Method": "ShapeType getType(){\r\n    return type;\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.collision.shapes.Shape.setRadius",
	"Comment": "sets the radius of the underlying shape. this can refer to different things depending on theimplementation.",
	"Method": "void setRadius(float radius){\r\n    this.radius = radius;\r\n}"
}, {
	"Path": "com.google.firebase.database.Query.orderByPriority",
	"Comment": "create a query in which child nodes are ordered by their priorities.",
	"Method": "Query orderByPriority(){\r\n    validateNoOrderByCall();\r\n    QueryParams newParams = params.orderBy(PriorityIndex.getInstance());\r\n    validateQueryEndpoints(newParams);\r\n    return new Query(repo, path, newParams, true);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.PhysicsWorld.clear",
	"Comment": "clears collidable entities and active collisions.does not clear collision handlers.",
	"Method": "void clear(){\r\n    log.debug(\"Clearing physics world\");\r\n    entities.clear();\r\n    collisions.clear();\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.UnresolvedSourceLocation.getColumn",
	"Comment": "an approximate column number for the source location. this may change when the location isresolved.can return null.",
	"Method": "int getColumn(){\r\n    return json.get(\"column\") == null ? -1 : json.get(\"column\").getAsInt();\r\n}"
}, {
	"Path": "io.flutter.inspector.DiagnosticsNode.safeWhenComplete",
	"Comment": "await a future invoking the callback on completion on the ui thread only if theinspectorservice group is still alive when the future completes.",
	"Method": "void safeWhenComplete(CompletableFuture<T> future,BiConsumer<? super T, ? super Throwable> action){\r\n    inspectorService.safeWhenComplete(future, action);\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.IntMap.containsValue",
	"Comment": "returns true if the specified value is in the map. note this traverses the entire map and compares every value, which may bean expensive operation.",
	"Method": "boolean containsValue(Object value,boolean identity){\r\n    V[] valueTable = this.valueTable;\r\n    if (value == null) {\r\n        if (hasZeroValue && zeroValue == null)\r\n            return true;\r\n        int[] keyTable = this.keyTable;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != EMPTY && valueTable[i] == null)\r\n            return true;\r\n    } else if (identity) {\r\n        if (value == zeroValue)\r\n            return true;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (valueTable[i] == value)\r\n            return true;\r\n    } else {\r\n        if (hasZeroValue && value.equals(zeroValue))\r\n            return true;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (value.equals(valueTable[i]))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "io.flutter.sdk.FlutterCommand.startProcess",
	"Comment": "starts a process that runs a flutter command, unless one is already running.returns the handler if successfully started.",
	"Method": "OSProcessHandler startProcess(boolean sendAnalytics,FlutterCommandStartResult startProcess,Project project){\r\n    if (!inProgress.compareAndSet(null, this)) {\r\n        return new FlutterCommandStartResult(FlutterCommandStartResultStatus.ANOTHER_RUNNING);\r\n    }\r\n    if (isPubRelatedCommand()) {\r\n        DartPlugin.setPubActionInProgress(true);\r\n    }\r\n    final OSProcessHandler handler;\r\n    try {\r\n        final GeneralCommandLine commandLine = createGeneralCommandLine(project);\r\n        LOG.info(commandLine.toString());\r\n        handler = new OSProcessHandler(commandLine);\r\n        handler.addProcessListener(new ProcessAdapter() {\r\n            @Override\r\n            public void processTerminated(@NotNull final ProcessEvent event) {\r\n                inProgress.compareAndSet(FlutterCommand.this, null);\r\n                if (isPubRelatedCommand()) {\r\n                    DartPlugin.setPubActionInProgress(false);\r\n                }\r\n            }\r\n        });\r\n        type.sendAnalyticsEvent();\r\n        return new FlutterCommandStartResult(handler);\r\n    } catch (ExecutionException e) {\r\n        inProgress.compareAndSet(this, null);\r\n        if (isPubRelatedCommand()) {\r\n            DartPlugin.setPubActionInProgress(false);\r\n        }\r\n        return new FlutterCommandStartResult(e);\r\n    }\r\n}"
}, {
	"Path": "io.flutter.sdk.FlutterCommand.startProcess",
	"Comment": "starts a process that runs a flutter command, unless one is already running.returns the handler if successfully started.",
	"Method": "OSProcessHandler startProcess(boolean sendAnalytics,FlutterCommandStartResult startProcess,Project project){\r\n    inProgress.compareAndSet(FlutterCommand.this, null);\r\n    if (isPubRelatedCommand()) {\r\n        DartPlugin.setPubActionInProgress(false);\r\n    }\r\n}"
}, {
	"Path": "org.dartlang.vm.service.VmService.collectAllGarbage",
	"Comment": "trigger a full gc, collecting all unreachable or weakly reachable objects.",
	"Method": "void collectAllGarbage(String isolateId,SuccessConsumer consumer){\r\n    JsonObject params = new JsonObject();\r\n    params.addProperty(\"isolateId\", isolateId);\r\n    request(\"_collectAllGarbage\", params, consumer);\r\n}"
}, {
	"Path": "com.google.firebase.components.Component.isEagerInDefaultApp",
	"Comment": "returns whether a component is eager in default app.meaning that it will be instantiated upon startup of the default application.",
	"Method": "boolean isEagerInDefaultApp(){\r\n    return instantiation == Instantiation.EAGER_IN_DEFAULT_APP;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.local.LruGarbageCollector.removeOrphanedDocuments",
	"Comment": "removes documents that have a sequence number equal to or less than the upper bound and are nototherwise pinned.",
	"Method": "int removeOrphanedDocuments(long upperBound){\r\n    return delegate.removeOrphanedDocuments(upperBound);\r\n}"
}, {
	"Path": "com.jakewharton.fliptables.FlipTableConverters.fromIterable",
	"Comment": "create a table from a group of objects. public accessor methods on the class type with noarguments will be used as the columns.",
	"Method": "String fromIterable(Iterable<T> rows,Class<T> rowType){\r\n    if (rows == null)\r\n        throw new NullPointerException(\"rows == null\");\r\n    if (rowType == null)\r\n        throw new NullPointerException(\"rowType == null\");\r\n    Method[] declaredMethods = rowType.getDeclaredMethods();\r\n    Arrays.sort(declaredMethods, METHOD_COMPARATOR);\r\n    List<Method> methods = new ArrayList();\r\n    List<String> headers = new ArrayList();\r\n    for (Method declaratedMethod : declaredMethods) {\r\n        if (declaratedMethod.getParameterTypes().length > 0)\r\n            continue;\r\n        if (declaratedMethod.getReturnType() == void.class)\r\n            continue;\r\n        Matcher matcher = METHOD.matcher(declaratedMethod.getName());\r\n        if (!matcher.matches())\r\n            continue;\r\n        declaratedMethod.setAccessible(true);\r\n        methods.add(declaratedMethod);\r\n        headers.add(matcher.group(1));\r\n    }\r\n    int columnCount = methods.size();\r\n    List<String[]> data = new ArrayList();\r\n    for (T row : rows) {\r\n        String[] rowData = new String[columnCount];\r\n        for (int column = 0; column < columnCount; column++) {\r\n            try {\r\n                rowData[column] = String.valueOf(methods.get(column).invoke(row));\r\n            } catch (Exception e) {\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n        data.add(rowData);\r\n    }\r\n    String[] headerArray = headers.toArray(new String[headers.size()]);\r\n    String[][] dataArray = data.toArray(new String[data.size()][]);\r\n    return FlipTable.of(headerArray, dataArray);\r\n}"
}, {
	"Path": "org.dartlang.analysis.server.protocol.FlutterOutline.getId",
	"Comment": "if the node is a widget, and it is instrumented, the unique identifier of this widget, that canbe used to associate rendering information with this node.",
	"Method": "Integer getId(){\r\n    return id;\r\n}"
}, {
	"Path": "io.flutter.utils.RefreshableTest.startRefresh",
	"Comment": "starts running a refresh, but block until the test tells it to finish.the caller should invoke release on the returned semaphore to unblockthe refresh callback.",
	"Method": "Semaphore startRefresh(String newValue){\r\n    final Semaphore start = new Semaphore(0);\r\n    final Semaphore finish = new Semaphore(0);\r\n    value.refresh(() -> {\r\n        log(\"entered refresh\");\r\n        start.release();\r\n        finish.acquire();\r\n        log(\"exited refresh: \" + newValue);\r\n        return newValue;\r\n    });\r\n    start.acquire();\r\n    return finish;\r\n}"
}, {
	"Path": "fr.pilato.elasticsearch.crawler.fs.beans.FsJobParserTest.testDateTimeSerialization",
	"Comment": "we check that the date which is generated on disk does not change when we read it again",
	"Method": "void testDateTimeSerialization(){\r\n    LocalDateTime now = LocalDateTime.now();\r\n    FsJob job = FsJob.builder().setLastrun(now).build();\r\n    String json = FsJobParser.toJson(job);\r\n    FsJob generated = FsJobParser.fromJson(json);\r\n    assertThat(generated.getLastrun(), is(now));\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.dynamics.Fixture.getShape",
	"Comment": "you can modify the child shape, however you should not change the numberof vertices because this will crash some collision caching mechanisms.",
	"Method": "Shape getShape(){\r\n    return shape;\r\n}"
}, {
	"Path": "org.fluentlenium.core.action.FillSelect.withValue",
	"Comment": "select all options that have a value matching the argument for the select element.",
	"Method": "FillSelect withValue(String value){\r\n    FluentList<E> elements = getElements();\r\n    if (elements.size() == 0) {\r\n        throw new NoSuchElementException(\"No select element found\");\r\n    }\r\n    for (FluentWebElement element : elements) {\r\n        Select select = new Select(element.getElement());\r\n        select.selectByValue(value);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "io.flutter.utils.ThreadUtil.getThreadList",
	"Comment": "return the list of thread in the given array, which ends with null.",
	"Method": "List<Thread> getThreadList(Thread[] threads){\r\n    final List<Thread> result = new ArrayList(threads.length);\r\n    for (Thread thread : threads) {\r\n        if (thread == null) {\r\n            break;\r\n        }\r\n        result.add(thread);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "io.flutter.dart.DartSyntax.isCallToFunctionNamed",
	"Comment": "check if an element is a call to a function with the given name.",
	"Method": "boolean isCallToFunctionNamed(DartCallExpression element,String function){\r\n    final String name = getCalledFunctionName(element);\r\n    return Objects.equals(name, function);\r\n}"
}, {
	"Path": "com.google.firebase.database.Query.validateQueryEndpoints",
	"Comment": "this method validates that key index has been called with the correct combination of parameters",
	"Method": "void validateQueryEndpoints(QueryParams params){\r\n    if (params.getIndex().equals(KeyIndex.getInstance())) {\r\n        String message = \"You must use startAt(String value), endAt(String value) or \" + \"equalTo(String value) in combination with orderByKey(). Other type of values or \" + \"using the version with 2 parameters is not supported\";\r\n        if (params.hasStart()) {\r\n            Node startNode = params.getIndexStartValue();\r\n            ChildKey startName = params.getIndexStartName();\r\n            if (!Objects.equal(startName, ChildKey.getMinName()) || !(startNode instanceof StringNode)) {\r\n                throw new IllegalArgumentException(message);\r\n            }\r\n        }\r\n        if (params.hasEnd()) {\r\n            Node endNode = params.getIndexEndValue();\r\n            ChildKey endName = params.getIndexEndName();\r\n            if (!endName.equals(ChildKey.getMaxName()) || !(endNode instanceof StringNode)) {\r\n                throw new IllegalArgumentException(message);\r\n            }\r\n        }\r\n    } else if (params.getIndex().equals(PriorityIndex.getInstance())) {\r\n        if ((params.hasStart() && !PriorityUtilities.isValidPriority(params.getIndexStartValue())) || (params.hasEnd() && !PriorityUtilities.isValidPriority(params.getIndexEndValue()))) {\r\n            throw new IllegalArgumentException(\"When using orderByPriority(), values provided to startAt(), \" + \"endAt(), or equalTo() must be valid priorities.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.almasb.fxgl.entity.Entity.save",
	"Comment": "save entity state into bundle.only serializable components will be written.",
	"Method": "void save(Bundle bundle){\r\n    EntitySerializer.INSTANCE.save(this, bundle);\r\n}"
}, {
	"Path": "com.google.firebase.database.DatabaseReference.getDefaultConfig",
	"Comment": "legacy method for legacy creation of databasereference for tests.",
	"Method": "DatabaseConfig getDefaultConfig(){\r\n    if (defaultConfig == null) {\r\n        defaultConfig = new DatabaseConfig();\r\n    }\r\n    return defaultConfig;\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Isolate.getLibraries",
	"Comment": "a list of all libraries for this isolate.guaranteed to be initialized when the isolaterunnable event fires.",
	"Method": "ElementList<LibraryRef> getLibraries(){\r\n    return new ElementList<LibraryRef>(json.get(\"libraries\").getAsJsonArray()) {\r\n        @Override\r\n        protected LibraryRef basicGet(JsonArray array, int index) {\r\n            return new LibraryRef(array.get(index).getAsJsonObject());\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Isolate.getLibraries",
	"Comment": "a list of all libraries for this isolate.guaranteed to be initialized when the isolaterunnable event fires.",
	"Method": "ElementList<LibraryRef> getLibraries(){\r\n    return new LibraryRef(array.get(index).getAsJsonObject());\r\n}"
}, {
	"Path": "org.fluentlenium.core.search.Search.find",
	"Comment": "central methods to find elements on the page. can provide some filters. able to use css1, css2, css3, see webdriverrestrictions",
	"Method": "FluentList<FluentWebElement> find(String selector,SearchFilter filters,FluentList<FluentWebElement> find,SearchFilter filters,FluentList<FluentWebElement> find,By locator,SearchFilter filters,FluentList<FluentWebElement> find,List<WebElement> rawElements){\r\n    FluentList<FluentWebElement> postFilteredList = instantiator.asFluentList(rawElements);\r\n    injectControl.injectComponent(postFilteredList, container, searchContext);\r\n    return postFilteredList;\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.reflect.ClassReflection.getSimpleName",
	"Comment": "returns the simple name of the underlying class as supplied in the source code.",
	"Method": "String getSimpleName(Class c){\r\n    return c.getSimpleName();\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.ComparableTimSort.ensureCapacity",
	"Comment": "ensures that the external array tmp has at least the specified number of elements, increasing its size if necessary. thesize increases exponentially to ensure amortized linear time complexity.",
	"Method": "Object[] ensureCapacity(int minCapacity){\r\n    tmpCount = Math.max(tmpCount, minCapacity);\r\n    if (tmp.length < minCapacity) {\r\n        int newSize = minCapacity;\r\n        newSize |= newSize >> 1;\r\n        newSize |= newSize >> 2;\r\n        newSize |= newSize >> 4;\r\n        newSize |= newSize >> 8;\r\n        newSize |= newSize >> 16;\r\n        newSize++;\r\n        if (newSize < 0)\r\n            newSize = minCapacity;\r\n        else\r\n            newSize = Math.min(newSize, a.length >>> 1);\r\n        Object[] newArray = new Object[newSize];\r\n        tmp = newArray;\r\n    }\r\n    return tmp;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.ValidationTest.expectUpdateError",
	"Comment": "performs a write using each update api and makes sure it fails with the expected reason.",
	"Method": "void expectUpdateError(Map<String, Object> data,String reason){\r\n    expectWriteError(data, reason, false, true);\r\n}"
}, {
	"Path": "testcasesupport.AbstractTestCaseServlet.runTest",
	"Comment": "this method runs the tests, but assumes that the html document has alreadybeen started.it is called by runtestsolo and by servletmain",
	"Method": "void runTest(HttpServletRequest request,HttpServletResponse response){\r\n    String className = this.getClass().getName();\r\n    int lastDotInClassName = className.lastIndexOf('.');\r\n    String servletName = className.substring(lastDotInClassName + 1);\r\n    response.getWriter().println(\"<br><br>Starting tests for Servlet \" + servletName);\r\n    try {\r\n        good(request, response);\r\n        response.getWriter().println(\"<br>Completed good() without Throwable for Servlet \" + servletName);\r\n    } catch (Throwable throwableException) {\r\n        response.getWriter().println(\"<br>Caught thowable from good() in Servlet \" + servletName);\r\n        response.getWriter().println(\"<br>Throwable's message = \" + throwableException.getMessage());\r\n        response.getWriter().println(\"<br><br>Stack trace below\");\r\n        StackTraceElement[] stackTraceElements = throwableException.getStackTrace();\r\n        for (StackTraceElement stackTraceElement : stackTraceElements) {\r\n            response.getWriter().println(\"<br>\" + stackTraceElement.toString());\r\n        }\r\n    }\r\n    try {\r\n        bad(request, response);\r\n        response.getWriter().println(\"<br>Completed bad() without Throwable in Servlet \" + servletName);\r\n    } catch (Throwable throwableException) {\r\n        response.getWriter().println(\"<br>Caught thowable from bad() in Servlet \" + servletName);\r\n        response.getWriter().println(\"<br>Throwable's message = \" + throwableException.getMessage());\r\n        response.getWriter().println(\"<br><br>Stack trace below\");\r\n        StackTraceElement[] stackTraceElements = throwableException.getStackTrace();\r\n        for (StackTraceElement stackTraceElement : stackTraceElements) {\r\n            response.getWriter().println(\"<br>\" + stackTraceElement.toString());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.dartlang.vm.service.element.Version.getMinor",
	"Comment": "the minor version number is incremented when the protocol is changed in a backwards compatibleway.",
	"Method": "int getMinor(){\r\n    return json.get(\"minor\") == null ? -1 : json.get(\"minor\").getAsInt();\r\n}"
}, {
	"Path": "org.fluentlenium.core.filter.FilterBuilder.startsWith",
	"Comment": "builds a filter that match when selection starts with to a given pattern.",
	"Method": "AttributeFilter startsWith(String value,AttributeFilter startsWith,Pattern pattern){\r\n    return new AttributeFilter(attribute, new StartsWithMatcher(pattern));\r\n}"
}, {
	"Path": "io.flutter.inspector.InspectorService.isWidgetTreeReady",
	"Comment": "if the widget tree is not ready, the application should wait for the nextflutter.frame event before attempting to display the widget tree. if theapplication is ready, the next flutter.frame event may never come as nonew frames will be triggered to draw unless something changes in the ui.",
	"Method": "CompletableFuture<Boolean> isWidgetTreeReady(){\r\n    if (useDaemonApi()) {\r\n        return invokeServiceMethodDaemonNoGroup(\"isWidgetTreeReady\", new HashMap()).thenApplyAsync((JsonElement element) -> element.getAsBoolean() == true);\r\n    } else {\r\n        return invokeServiceMethodObservatoryNoGroup(\"isWidgetTreeReady\").thenApplyAsync((InstanceRef ref) -> \"true\".equals(ref.getValueAsString()));\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.remote.TargetChange.getAddedDocuments",
	"Comment": "returns the set of documents that were newly assigned to this target as part of this remoteevent.",
	"Method": "ImmutableSortedSet<DocumentKey> getAddedDocuments(){\r\n    return addedDocuments;\r\n}"
}, {
	"Path": "com.google.firebase.database.core.DatabaseConfig.setSessionPersistenceKey",
	"Comment": "sets the session identifier for this firebase database connection.use session identifiers to enable multiple persisted authentication sessions on the samedevice. there is no need to use this method if there will only be one user per device.",
	"Method": "void setSessionPersistenceKey(String sessionKey){\r\n    assertUnfrozen();\r\n    if (sessionKey == null || sessionKey.isEmpty()) {\r\n        throw new IllegalArgumentException(\"Session identifier is not allowed to be empty or null!\");\r\n    }\r\n    this.persistenceKey = sessionKey;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.AsyncQueue.verifyIsCurrentThread",
	"Comment": "verifies that the current thread is the managed asyncqueue thread.",
	"Method": "void verifyIsCurrentThread(){\r\n    Thread current = Thread.currentThread();\r\n    if (thread != current) {\r\n        throw fail(\"We are running on the wrong thread. Expected to be on the AsyncQueue \" + \"thread %s/%d but was %s/%d\", thread.getName(), thread.getId(), current.getName(), current.getId());\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.database.DatabaseReference.getDatabase",
	"Comment": "gets the database instance associated with this reference.",
	"Method": "FirebaseDatabase getDatabase(){\r\n    return this.repo.getDatabase();\r\n}"
}, {
	"Path": "org.apache.commons.io.input.ClassLoaderObjectInputStream.resolveClass",
	"Comment": "resolve a class specified by the descriptor using thespecified classloader or the super classloader.",
	"Method": "Class<?> resolveClass(ObjectStreamClass objectStreamClass){\r\n    try {\r\n        return Class.forName(objectStreamClass.getName(), false, classLoader);\r\n    } catch (final ClassNotFoundException cnfe) {\r\n        return super.resolveClass(objectStreamClass);\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.database.Query.startAt",
	"Comment": "create a query constrained to only return child nodes with a value greater than or equal to thegiven value, using the given orderby directive or priority as default, and additionally onlychild nodes with a key greater than or equal to the given key.",
	"Method": "Query startAt(String value,Query startAt,double value,Query startAt,boolean value,Query startAt,String value,String key,Query startAt,double value,String key,Query startAt,boolean value,String key,Query startAt,Node node,String key){\r\n    Validation.validateNullableKey(key);\r\n    if (!(node.isLeafNode() || node.isEmpty())) {\r\n        throw new IllegalArgumentException(\"Can only use simple values for startAt()\");\r\n    }\r\n    if (params.hasStart()) {\r\n        throw new IllegalArgumentException(\"Can't call startAt() or equalTo() multiple times\");\r\n    }\r\n    ChildKey childKey = key != null ? ChildKey.fromString(key) : null;\r\n    QueryParams newParams = params.startAt(node, childKey);\r\n    validateLimit(newParams);\r\n    validateQueryEndpoints(newParams);\r\n    assert newParams.isValid();\r\n    return new Query(repo, path, newParams, orderByCalled);\r\n}"
}, {
	"Path": "org.fluentlenium.core.wait.FluentWaitElementList.untilEach",
	"Comment": "get a conditions object used to wait for condition on current elements.each element must verify the condition to be verified.",
	"Method": "FluentConditions untilEach(FluentListConditions untilEach,List<? extends FluentWebElement> elements){\r\n    return controlWait.untilEach(elements);\r\n}"
}, {
	"Path": "org.fluentlenium.assertj.custom.FluentListAssert.hasClass",
	"Comment": "check if at least one element of the fluentlist contains the text",
	"Method": "FluentListAssert hasClass(String classToFind){\r\n    List<String> classes = (List<String>) actual.attributes(\"class\");\r\n    for (String classesStr : classes) {\r\n        List<String> classesLst = Arrays.asList(classesStr.split(\" \"));\r\n        if (classesLst.contains(classToFind)) {\r\n            return this;\r\n        }\r\n    }\r\n    StringBuilder builder = new StringBuilder();\r\n    for (String classFromElement : classes) {\r\n        if (builder.length() > 0) {\r\n            builder.append(\", \");\r\n        }\r\n        builder.append(classFromElement);\r\n    }\r\n    super.failWithMessage(\"No selected elements has class: \" + classToFind + \" . Actual classes found : \" + builder.toString());\r\n    return this;\r\n}"
}, {
	"Path": "io.flutter.inspector.DiagnosticsNode.getIfEmpty",
	"Comment": "description if the property description would otherwise be empty.consider showing the property value in gray in an ide if the description matchesifempty.",
	"Method": "String getIfEmpty(){\r\n    return getStringMember(\"ifEmpty\");\r\n}"
}, {
	"Path": "com.google.firebase.database.MutableData.child",
	"Comment": "used to obtain a mutabledata instance that encapsulates the data and priority at the givenrelative path.",
	"Method": "MutableData child(String path){\r\n    Validation.validatePathString(path);\r\n    return new MutableData(holder, prefixPath.child(new Path(path)));\r\n}"
}, {
	"Path": "com.google.firebase.firestore.FieldPath.documentId",
	"Comment": "returns a special sentinel fieldpath to refer to the id of a document. it can be used inqueries to sort or filter by the document id.",
	"Method": "FieldPath documentId(){\r\n    return DOCUMENT_ID_INSTANCE;\r\n}"
}, {
	"Path": "com.google.firebase.inappmessaging.display.internal.FiamWindowManager.getSwipeListener",
	"Comment": "get a swipe listener, using knowledge of the layoutconfig to dictate the behavior.",
	"Method": "SwipeDismissTouchListener getSwipeListener(InAppMessageLayoutConfig layoutConfig,BindingWrapper bindingWrapper,WindowManager windowManager,WindowManager.LayoutParams layoutParams){\r\n    SwipeDismissTouchListener.DismissCallbacks callbacks = new SwipeDismissTouchListener.DismissCallbacks() {\r\n        @Override\r\n        public boolean canDismiss(Object token) {\r\n            return true;\r\n        }\r\n        @Override\r\n        public void onDismiss(View view, Object token) {\r\n            if (bindingWrapper.getDismissListener() != null) {\r\n                bindingWrapper.getDismissListener().onClick(view);\r\n            }\r\n        }\r\n    };\r\n    if (layoutConfig.windowWidth() == ViewGroup.LayoutParams.MATCH_PARENT) {\r\n        return new SwipeDismissTouchListener(bindingWrapper.getDialogView(), null, callbacks);\r\n    } else {\r\n        return new SwipeDismissTouchListener(bindingWrapper.getDialogView(), null, callbacks) {\r\n            @Override\r\n            protected float getTranslationX() {\r\n                return layoutParams.x;\r\n            }\r\n            @Override\r\n            protected void setTranslationX(float translationX) {\r\n                layoutParams.x = (int) translationX;\r\n                windowManager.updateViewLayout(bindingWrapper.getRootView(), layoutParams);\r\n            }\r\n        };\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.inappmessaging.display.internal.FiamWindowManager.getSwipeListener",
	"Comment": "get a swipe listener, using knowledge of the layoutconfig to dictate the behavior.",
	"Method": "SwipeDismissTouchListener getSwipeListener(InAppMessageLayoutConfig layoutConfig,BindingWrapper bindingWrapper,WindowManager windowManager,WindowManager.LayoutParams layoutParams){\r\n    return true;\r\n}"
}, {
	"Path": "com.google.firebase.inappmessaging.display.internal.FiamWindowManager.getSwipeListener",
	"Comment": "get a swipe listener, using knowledge of the layoutconfig to dictate the behavior.",
	"Method": "SwipeDismissTouchListener getSwipeListener(InAppMessageLayoutConfig layoutConfig,BindingWrapper bindingWrapper,WindowManager windowManager,WindowManager.LayoutParams layoutParams){\r\n    if (bindingWrapper.getDismissListener() != null) {\r\n        bindingWrapper.getDismissListener().onClick(view);\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.inappmessaging.display.internal.FiamWindowManager.getSwipeListener",
	"Comment": "get a swipe listener, using knowledge of the layoutconfig to dictate the behavior.",
	"Method": "SwipeDismissTouchListener getSwipeListener(InAppMessageLayoutConfig layoutConfig,BindingWrapper bindingWrapper,WindowManager windowManager,WindowManager.LayoutParams layoutParams){\r\n    return layoutParams.x;\r\n}"
}, {
	"Path": "com.google.firebase.inappmessaging.display.internal.FiamWindowManager.getSwipeListener",
	"Comment": "get a swipe listener, using knowledge of the layoutconfig to dictate the behavior.",
	"Method": "SwipeDismissTouchListener getSwipeListener(InAppMessageLayoutConfig layoutConfig,BindingWrapper bindingWrapper,WindowManager windowManager,WindowManager.LayoutParams layoutParams){\r\n    layoutParams.x = (int) translationX;\r\n    windowManager.updateViewLayout(bindingWrapper.getRootView(), layoutParams);\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.pool.Pool.freeAll",
	"Comment": "puts the specified objects in the pool.null objects within the array are silently ignored.",
	"Method": "void freeAll(Array<T> objects){\r\n    if (objects == null)\r\n        throw new IllegalArgumentException(\"objects cannot be null.\");\r\n    Array<T> freeObjects = this.freeObjects;\r\n    int max = this.max;\r\n    for (int i = 0; i < objects.size(); i++) {\r\n        T object = objects.get(i);\r\n        if (object == null)\r\n            continue;\r\n        if (freeObjects.size() < max)\r\n            freeObjects.add(object);\r\n        reset(object);\r\n    }\r\n    peak = Math.max(peak, freeObjects.size());\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.DocumentSet.add",
	"Comment": "returns a new documentset that contains the given document, replacing any old document with thesame key.",
	"Method": "DocumentSet add(Document document){\r\n    DocumentSet removed = remove(document.getKey());\r\n    ImmutableSortedMap<DocumentKey, Document> newKeyIndex = removed.keyIndex.insert(document.getKey(), document);\r\n    ImmutableSortedSet<Document> newSortedSet = removed.sortedSet.insert(document);\r\n    return new DocumentSet(newKeyIndex, newSortedSet);\r\n}"
}, {
	"Path": "com.google.firebase.firestore.util.Util.typeName",
	"Comment": "describes the type of an object, handling null objects gracefully.",
	"Method": "String typeName(Object obj){\r\n    return obj == null ? \"null\" : obj.getClass().getName();\r\n}"
}, {
	"Path": "com.vladmihalcea.flexypool.connection.ConnectionDecoratorFactoryResolver.resolve",
	"Comment": "resolve connectiondecoratorfactory from the service provider interface configuration",
	"Method": "ConnectionDecoratorFactory resolve(){\r\n    int loadingIndex = Integer.MIN_VALUE;\r\n    ConnectionDecoratorFactory connectionDecoratorFactory = null;\r\n    Iterator<ConnectionDecoratorFactoryService> connectionDecoratorFactoryServiceIterator = serviceLoader.iterator();\r\n    while (connectionDecoratorFactoryServiceIterator.hasNext()) {\r\n        try {\r\n            ConnectionDecoratorFactoryService connectionDecoratorFactoryService = connectionDecoratorFactoryServiceIterator.next();\r\n            int currentLoadingIndex = connectionDecoratorFactoryService.loadingIndex();\r\n            if (currentLoadingIndex > loadingIndex) {\r\n                ConnectionDecoratorFactory currentConnectionDecoratorFactory = connectionDecoratorFactoryService.load();\r\n                if (currentConnectionDecoratorFactory != null) {\r\n                    connectionDecoratorFactory = currentConnectionDecoratorFactory;\r\n                    loadingIndex = currentLoadingIndex;\r\n                }\r\n            }\r\n        } catch (LinkageError e) {\r\n            LOGGER.info(\"Couldn't load ConnectionDecoratorFactoryService on the current JVM\", e);\r\n        }\r\n    }\r\n    if (connectionDecoratorFactory != null) {\r\n        return connectionDecoratorFactory;\r\n    }\r\n    throw new IllegalStateException(\"No ConnectionDecoratorFactory could be loaded!\");\r\n}"
}, {
	"Path": "io.flowing.retail.order.messages.MessageListener.messageReceived",
	"Comment": "very generic listener for simplicity. it takes all events and checks, if a flow instance is interested. if yes, they are correlated, otherwise they are just discarded.it might make more sense to handle each and every message type individually.",
	"Method": "void messageReceived(String messageJson){\r\n    // \r\n    Message<JsonNode> message = // \r\n    new ObjectMapper().readValue(messageJson, new TypeReference<Message<JsonNode>>() {\r\n    });\r\n    // \r\n    long correlatingInstances = // \r\n    camunda.getRuntimeService().createExecutionQuery().messageEventSubscriptionName(// \r\n    message.getMessageType()).processInstanceBusinessKey(message.getTraceId()).count();\r\n    if (correlatingInstances == 1) {\r\n        System.out.println(\"Correlating \" + message + \" to waiting flow instance\");\r\n        // \r\n        camunda.getRuntimeService().createMessageCorrelation(message.getMessageType()).processInstanceBusinessKey(message.getTraceId()).setVariable(\"PAYLOAD_\" + message.getMessageType(), SpinValues.jsonValue(message.getPayload().toString()).create()).correlateWithResult();\r\n    }\r\n}"
}, {
	"Path": "io.flutter.inspector.TreeScrollAnimator.clampInterval",
	"Comment": "determines the best interval that does not exceed clamplengthand includes the required interval and as much content fromthe ideal interval as possible. the clamped interval is expandedproportionally in both directions to reach the size of the idealinterval.the required interval must be inside the ideal interval.",
	"Method": "Interval clampInterval(Interval required,Interval ideal,int clampLength){\r\n    if (required.start < ideal.start || required.start + required.length > ideal.start + ideal.length || required.length < 0 || ideal.length < 0 || clampLength < 0) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    if (ideal.length <= clampLength) {\r\n        return ideal;\r\n    }\r\n    final double extraSpace = clampLength - required.length;\r\n    if (extraSpace <= 0) {\r\n        return new Interval(required.start, clampLength);\r\n    }\r\n    final double desiredSpace = ideal.length - required.length;\r\n    return new Interval(Curves.LINEAR.interpolate(required.start, ideal.start, extraSpace / desiredSpace), clampLength);\r\n}"
}, {
	"Path": "com.google.firebase.database.Query.endAt",
	"Comment": "create a query constrained to only return child nodes with a value less than or equal to thegiven value, using the given orderby directive or priority as default, and additionally onlychild nodes with a key less than or equal to the given key.",
	"Method": "Query endAt(String value,Query endAt,double value,Query endAt,boolean value,Query endAt,String value,String key,Query endAt,double value,String key,Query endAt,boolean value,String key,Query endAt,Node node,String key){\r\n    Validation.validateNullableKey(key);\r\n    if (!(node.isLeafNode() || node.isEmpty())) {\r\n        throw new IllegalArgumentException(\"Can only use simple values for endAt()\");\r\n    }\r\n    ChildKey childKey = key != null ? ChildKey.fromString(key) : null;\r\n    if (params.hasEnd()) {\r\n        throw new IllegalArgumentException(\"Can't call endAt() or equalTo() multiple times\");\r\n    }\r\n    QueryParams newParams = params.endAt(node, childKey);\r\n    validateLimit(newParams);\r\n    validateQueryEndpoints(newParams);\r\n    assert newParams.isValid();\r\n    return new Query(repo, path, newParams, orderByCalled);\r\n}"
}, {
	"Path": "com.vladsch.flexmark.docx.converter.util.BlockFormatProviderBase.inheritBdr",
	"Comment": "inherit left bordermust be called after ind has been determined",
	"Method": "void inheritBdr(PPr pPr,PPr parentPPr){\r\n    myDocx.getHelper().inheritPBdr(pPr, parentPPr);\r\n}"
}, {
	"Path": "com.almasb.fxgl.physics.box2d.collision.shapes.Shape.getRadius",
	"Comment": "the radius of the underlying shape. this can refer to different things depending on the shapeimplementation.",
	"Method": "float getRadius(){\r\n    return radius;\r\n}"
}, {
	"Path": "com.vladmihalcea.flexypool.connection.ConnectionCallback.close",
	"Comment": "calculates the connection lease nanos and propagates it to the connection pool callback.",
	"Method": "void close(){\r\n    long endNanos = System.nanoTime();\r\n    long durationNanos = endNanos - startNanos;\r\n    connectionPoolCallback.releaseConnection(durationNanos);\r\n}"
}, {
	"Path": "com.bartoszlipinski.flippablestackview.OrientedViewPager.executeKeyEvent",
	"Comment": "you can call this function yourself to have the scroll view performscrolling from a key event, just as if the event had been dispatched toit by the view hierarchy.",
	"Method": "boolean executeKeyEvent(KeyEvent event){\r\n    boolean handled = false;\r\n    if (event.getAction() == KeyEvent.ACTION_DOWN) {\r\n        switch(event.getKeyCode()) {\r\n            case KeyEvent.KEYCODE_DPAD_LEFT:\r\n                handled = arrowScroll(FOCUS_LEFT);\r\n                break;\r\n            case KeyEvent.KEYCODE_DPAD_RIGHT:\r\n                handled = arrowScroll(FOCUS_RIGHT);\r\n                break;\r\n            case KeyEvent.KEYCODE_TAB:\r\n                if (Build.VERSION.SDK_INT >= 11) {\r\n                    if (KeyEventCompat.hasNoModifiers(event)) {\r\n                        handled = arrowScroll(FOCUS_FORWARD);\r\n                    } else if (KeyEventCompat.hasModifiers(event, KeyEvent.META_SHIFT_ON)) {\r\n                        handled = arrowScroll(FOCUS_BACKWARD);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    return handled;\r\n}"
}, {
	"Path": "io.flutter.perf.PerfTip.getLocations",
	"Comment": "locations within the application that called the tip to trigger.",
	"Method": "List<Location> getLocations(){\r\n    return locations;\r\n}"
}, {
	"Path": "com.google.firebase.database.core.WriteTreeRef.shadowingWrite",
	"Comment": "returns a node if there is a complete overwrite for this path. more specifically, if there is awrite at a higher path, this will return the child of that write relative to the write and thispath. returns null if there is no write at this path.",
	"Method": "Node shadowingWrite(Path path){\r\n    return this.writeTree.shadowingWrite(this.treePath.child(path));\r\n}"
}, {
	"Path": "io.flutter.bazel.WorkspaceCache.refreshAsync",
	"Comment": "triggers a cache refresh.if a refresh is already in progress, schedules another one.",
	"Method": "void refreshAsync(){\r\n    cache.refresh(() -> Workspace.load(project));\r\n}"
}, {
	"Path": "com.almasb.fxgl.core.collection.ObjectMap.containsValue",
	"Comment": "returns true if the specified value is in the map. note this traverses the entire map and compares every value, which maybe an expensive operation.",
	"Method": "boolean containsValue(Object value,boolean identity){\r\n    V[] valueTable = this.valueTable;\r\n    if (value == null) {\r\n        K[] keyTable = this.keyTable;\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (keyTable[i] != null && valueTable[i] == null)\r\n            return true;\r\n    } else if (identity) {\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (valueTable[i] == value)\r\n            return true;\r\n    } else {\r\n        for (int i = capacity + stashSize; i-- > 0; ) if (value.equals(valueTable[i]))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.google.firebase.database.Query.validateNoOrderByCall",
	"Comment": "this method validates that only one order by call has been made",
	"Method": "void validateNoOrderByCall(){\r\n    if (this.orderByCalled) {\r\n        throw new IllegalArgumentException(\"You can't combine multiple orderBy calls!\");\r\n    }\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.mutation.TransformMutation.requireDocument",
	"Comment": "asserts that the given maybedocument is actually a document and verifies that it matches thekey for this mutation. since we only support transformations with precondition exists thismethod is guaranteed to be safe.",
	"Method": "Document requireDocument(MaybeDocument maybeDoc){\r\n    hardAssert(maybeDoc instanceof Document, \"Unknown MaybeDocument type %s\", maybeDoc);\r\n    Document doc = (Document) maybeDoc;\r\n    hardAssert(doc.getKey().equals(getKey()), \"Can only transform a document with the same key\");\r\n    return doc;\r\n}"
}, {
	"Path": "com.google.firebase.firestore.model.mutation.MutationBatch.applyToLocalView",
	"Comment": "computes the local view of a document given all the mutations in this batch.",
	"Method": "MaybeDocument applyToLocalView(DocumentKey documentKey,MaybeDocument maybeDoc){\r\n    if (maybeDoc != null) {\r\n        hardAssert(maybeDoc.getKey().equals(documentKey), \"applyToRemoteDocument: key %s doesn't match maybeDoc key %s\", documentKey, maybeDoc.getKey());\r\n    }\r\n    MaybeDocument baseDoc = maybeDoc;\r\n    for (int i = 0; i < mutations.size(); i++) {\r\n        Mutation mutation = mutations.get(i);\r\n        if (mutation.getKey().equals(documentKey)) {\r\n            maybeDoc = mutation.applyToLocalView(maybeDoc, baseDoc, localWriteTime);\r\n        }\r\n    }\r\n    return maybeDoc;\r\n}"
}]