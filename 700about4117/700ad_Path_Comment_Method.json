[{
	"Path": "org.hibernate.validator.cdi.ValidationExtension.beforeBeanDiscovery",
	"Comment": "used to register the method validation interceptor binding annotation.",
	"Method": "void beforeBeanDiscovery(BeforeBeanDiscovery beforeBeanDiscoveryEvent,BeanManager beanManager){\r\n    Contracts.assertNotNull(beforeBeanDiscoveryEvent, \"The BeforeBeanDiscovery event cannot be null\");\r\n    Contracts.assertNotNull(beanManager, \"The BeanManager cannot be null\");\r\n    AnnotatedType<ValidationInterceptor> annotatedType = beanManager.createAnnotatedType(ValidationInterceptor.class);\r\n    beforeBeanDiscoveryEvent.addAnnotatedType(annotatedType, ValidationInterceptor.class.getName());\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Wander.getInternalTargetPosition",
	"Comment": "returns the current position of the wander target. this method is useful for debug purpose.",
	"Method": "T getInternalTargetPosition(){\r\n    return internalTargetPosition;\r\n}"
}, {
	"Path": "com.hypertrack.hyperlog.LogFormat.formatLogMessage",
	"Comment": "implement this method to override the default log message format.",
	"Method": "String formatLogMessage(int logLevel,String tag,String message){\r\n    String timeStamp = HLDateTimeUtility.getCurrentTime();\r\n    String senderName = BuildConfig.VERSION_NAME;\r\n    String osVersion = \"Android-\" + Build.VERSION.RELEASE;\r\n    String logLevelName = getLogLevelName(logLevel);\r\n    return getFormattedLogMessage(logLevelName, tag, message, timeStamp, senderName, osVersion, deviceUUID);\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.GlobalDataAccessService.postConstruct",
	"Comment": "is executed after dependency injection is done to perform any initialization.",
	"Method": "void postConstruct(){\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"|-Global Data Access Service active...\");\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.RaycastObstacleAvoidance.setDistanceFromBoundary",
	"Comment": "sets the distance from boundary, i.e. the minimum distance to an obstacle.",
	"Method": "RaycastObstacleAvoidance<T> setDistanceFromBoundary(float distanceFromBoundary){\r\n    this.distanceFromBoundary = distanceFromBoundary;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.msg.MessageDispatcher.addListener",
	"Comment": "registers a listener for the specified message code. messages without an explicit receiver are broadcasted to all its\tregistered listeners.",
	"Method": "void addListener(Telegraph listener,int msg){\r\n    Array<Telegraph> listeners = msgListeners.get(msg);\r\n    if (listeners == null) {\r\n        listeners = new Array<Telegraph>(false, 16);\r\n        msgListeners.put(msg, listeners);\r\n    }\r\n    listeners.add(listener);\r\n    Array<TelegramProvider> providers = msgProviders.get(msg);\r\n    if (providers != null) {\r\n        for (int i = 0, n = providers.size; i < n; i++) {\r\n            TelegramProvider provider = providers.get(i);\r\n            Object info = provider.provideMessageInfo(msg, listener);\r\n            if (info != null) {\r\n                Telegraph sender = ClassReflection.isInstance(Telegraph.class, provider) ? (Telegraph) provider : null;\r\n                dispatchMessage(0, sender, listener, msg, info, false);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.AbstractObjectSizes.getSizeOfHashMapEntry",
	"Comment": "returns the size of a hashmap entry. not that the key and value objects are not in this size.\tif hashset is used the hashmapentry value object will be a simple object, thus this size has\tto be added to the hashset.",
	"Method": "long getSizeOfHashMapEntry(){\r\n    long size = this.getSizeOfObjectHeader();\r\n    size += this.getPrimitiveTypesSize(3, 0, 1, 0, 0, 0);\r\n    return alignTo8Bytes(size);\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.btree.Task.getObject",
	"Comment": "returns the blackboard object of the behavior tree this task belongs to.",
	"Method": "E getObject(){\r\n    if (tree == null)\r\n        throw new IllegalStateException(\"This task has never run\");\r\n    return tree.getObject();\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeStack.pushAll",
	"Comment": "pushes all elements from another iterable to the top of the stack.",
	"Method": "int pushAll(KTypeContainer<? extends KType> container,int pushAll,Iterable<? extends KTypeCursor<? extends KType>> iterable){\r\n    return addAll(iterable);\r\n}"
}, {
	"Path": "com.alorma.github.inapp.Security.verify",
	"Comment": "verifies that the signature from the server matches the computedsignature on the data.returns true if the data is correctly signed.",
	"Method": "boolean verify(PublicKey publicKey,String signedData,String signature){\r\n    Signature sig;\r\n    try {\r\n        sig = Signature.getInstance(SIGNATURE_ALGORITHM);\r\n        sig.initVerify(publicKey);\r\n        sig.update(signedData.getBytes());\r\n        if (!sig.verify(Base64.decode(signature))) {\r\n            Log.e(TAG, \"Signature verification failed.\");\r\n            return false;\r\n        }\r\n        return true;\r\n    } catch (NoSuchAlgorithmException e) {\r\n        Log.e(TAG, \"NoSuchAlgorithmException.\");\r\n    } catch (InvalidKeyException e) {\r\n        Log.e(TAG, \"Invalid key specification.\");\r\n    } catch (SignatureException e) {\r\n        Log.e(TAG, \"Signature exception.\");\r\n    } catch (Base64DecoderException e) {\r\n        Log.e(TAG, \"Base64 decoding failed.\");\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.ValidatorImpl.getValueContextForPropertyValidation",
	"Comment": "returns a value context pointing to the given property path relative to the specified root class for a given\tvalue.",
	"Method": "ValueContext<?, V> getValueContextForPropertyValidation(BaseBeanValidationContext<?> validationContext,PathImpl propertyPath){\r\n    Class<?> clazz = validationContext.getRootBeanClass();\r\n    BeanMetaData<?> beanMetaData = validationContext.getRootBeanMetaData();\r\n    Object value = validationContext.getRootBean();\r\n    PropertyMetaData propertyMetaData = null;\r\n    Iterator<Path.Node> propertyPathIter = propertyPath.iterator();\r\n    while (propertyPathIter.hasNext()) {\r\n        NodeImpl propertyPathNode = (NodeImpl) propertyPathIter.next();\r\n        propertyMetaData = getBeanPropertyMetaData(beanMetaData, propertyPathNode);\r\n        if (propertyPathIter.hasNext()) {\r\n            if (!propertyMetaData.isCascading()) {\r\n                throw LOG.getInvalidPropertyPathException(validationContext.getRootBeanClass(), propertyPath.asString());\r\n            }\r\n            value = getCascadableValue(validationContext, value, propertyMetaData.getCascadables().iterator().next());\r\n            if (value == null) {\r\n                throw LOG.getUnableToReachPropertyToValidateException(validationContext.getRootBean(), propertyPath);\r\n            }\r\n            clazz = value.getClass();\r\n            if (propertyPathNode.isIterable()) {\r\n                propertyPathNode = (NodeImpl) propertyPathIter.next();\r\n                if (propertyPathNode.getIndex() != null) {\r\n                    value = ReflectionHelper.getIndexedValue(value, propertyPathNode.getIndex());\r\n                } else if (propertyPathNode.getKey() != null) {\r\n                    value = ReflectionHelper.getMappedValue(value, propertyPathNode.getKey());\r\n                } else {\r\n                    throw LOG.getPropertyPathMustProvideIndexOrMapKeyException();\r\n                }\r\n                if (value == null) {\r\n                    throw LOG.getUnableToReachPropertyToValidateException(validationContext.getRootBean(), propertyPath);\r\n                }\r\n                clazz = value.getClass();\r\n                beanMetaData = beanMetaDataManager.getBeanMetaData(clazz);\r\n                propertyMetaData = getBeanPropertyMetaData(beanMetaData, propertyPathNode);\r\n            } else {\r\n                beanMetaData = beanMetaDataManager.getBeanMetaData(clazz);\r\n            }\r\n        }\r\n    }\r\n    if (propertyMetaData == null) {\r\n        throw LOG.getInvalidPropertyPathException(clazz, propertyPath.asString());\r\n    }\r\n    propertyPath.removeLeafNode();\r\n    return ValueContext.getLocalExecutionContext(validatorScopedContext.getParameterNameProvider(), value, beanMetaData, propertyPath);\r\n}"
}, {
	"Path": "org.influxdb.UDPInfluxDBTest.testWriteStringDataThroughUDP",
	"Comment": "test writing to the database using string protocol through udp.",
	"Method": "void testWriteStringDataThroughUDP(){\r\n    String measurement = TestUtils.getRandomMeasurement();\r\n    this.influxDB.write(UDP_PORT, measurement + \",atag=test idle=90,usertime=9,system=1\");\r\n    Thread.sleep(2000);\r\n    Query query = new Query(\"SELECT * FROM \" + measurement + \" GROUP BY *\", UDP_DATABASE);\r\n    QueryResult result = this.influxDB.query(query);\r\n    Assertions.assertFalse(result.getResults().get(0).getSeries().get(0).getTags().isEmpty());\r\n}"
}, {
	"Path": "org.kohsuke.github.GHPullRequestReviewComment.getParent",
	"Comment": "gets the pull request to which this review comment is associated.",
	"Method": "GHPullRequest getParent(){\r\n    return owner;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Separation.getDecayCoefficient",
	"Comment": "returns the coefficient of decay for the inverse square law force.",
	"Method": "float getDecayCoefficient(){\r\n    return decayCoefficient;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.metadata.core.ConstraintHelper.isMultiValueConstraint",
	"Comment": "checks whether a given annotation is a multi value constraint or not.",
	"Method": "boolean isMultiValueConstraint(Class<? extends Annotation> annotationType){\r\n    if (isJdkAnnotation(annotationType)) {\r\n        return false;\r\n    }\r\n    return multiValueConstraints.computeIfAbsent(annotationType, a -> {\r\n        boolean isMultiValueConstraint = false;\r\n        final Method method = run(GetMethod.action(a, \"value\"));\r\n        if (method != null) {\r\n            Class<?> returnType = method.getReturnType();\r\n            if (returnType.isArray() && returnType.getComponentType().isAnnotation()) {\r\n                @SuppressWarnings(\"unchecked\")\r\n                Class<? extends Annotation> componentType = (Class<? extends Annotation>) returnType.getComponentType();\r\n                if (isConstraintAnnotation(componentType)) {\r\n                    isMultiValueConstraint = Boolean.TRUE;\r\n                } else {\r\n                    isMultiValueConstraint = Boolean.FALSE;\r\n                }\r\n            }\r\n        }\r\n        return isMultiValueConstraint;\r\n    });\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Wander.getWanderCenter",
	"Comment": "returns the current center of the wander circle. this method is useful for debug purpose.",
	"Method": "T getWanderCenter(){\r\n    return wanderCenter;\r\n}"
}, {
	"Path": "org.hibernate.validator.test.internal.engine.methodvalidation.cascadedgroupvalidation.CascadedMethodLevelValidationGroupSequenceTest.cascadedConstraintViolationInSecondGroupOnly",
	"Comment": "expect a single constraint violation from the second validation group.",
	"Method": "void cascadedConstraintViolationInSecondGroupOnly(){\r\n    setUpValidatorForGroups(CompoundGroup.class);\r\n    try {\r\n        entityRepository.store(new CompoundEntity(new Entity(\"value\", null)));\r\n        fail(\"Expected MethodConstraintViolationException wasn't thrown.\");\r\n    } catch (ConstraintViolationException e) {\r\n        assertThat(e.getConstraintViolations()).containsOnlyViolations(violationOf(NotNull.class).withMessage(\"must not be null\").withInvalidValue(null).withRootBeanClass(CompoundEntityRepositoryImpl.class));\r\n        ConstraintViolation<?> constraintViolation = e.getConstraintViolations().iterator().next();\r\n        assertEquals(constraintViolation.getConstraintDescriptor().getGroups().iterator().next(), ValidationGroup2.class);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.alerting.action.AlertingActionService.alertOngoing",
	"Comment": "this method is called when an active alert is still violating its threshold.",
	"Method": "void alertOngoing(AlertingState alertingState,double violationValue){\r\n    if (alertingState == null) {\r\n        throw new IllegalArgumentException(\"The given alerting state may not be null.\");\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"Alert definition '{}' is ongoing.\", alertingState.getAlertingDefinition().getName());\r\n    }\r\n    if (alertingState.getAlertingDefinition().getThresholdType() == ThresholdType.UPPER_THRESHOLD) {\r\n        alertingState.setExtremeValue(Math.max(violationValue, alertingState.getExtremeValue()));\r\n    } else {\r\n        alertingState.setExtremeValue(Math.min(violationValue, alertingState.getExtremeValue()));\r\n    }\r\n    for (IAlertAction alertAction : alertActions) {\r\n        alertAction.onOngoing(alertingState);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.BufferPropertiesTest.parametrizedExpansionRateTest",
	"Comment": "general parameterized test to assure that no matter how big buffer size is, expansion rate\twill be between min and max related.",
	"Method": "void parametrizedExpansionRateTest(long bufferSize){\r\n    float expansionRate = bufferProperties.getObjectSecurityExpansionRate(bufferSize);\r\n    assertThat(expansionRate, is(lessThanOrEqualTo(bufferProperties.getMaxObjectExpansionRate())));\r\n    assertThat(expansionRate, is(greaterThanOrEqualTo(bufferProperties.getMinObjectExpansionRate())));\r\n    float relatedToSize = bufferProperties.getObjectSecurityExpansionRateBufferSize(bufferSize);\r\n    float relatedToOccupancy = bufferProperties.getObjectSecurityExpansionRateBufferOccupancy(bufferSize, bufferProperties.getOldGenMax());\r\n    assertThat(expansionRate, is(equalTo((relatedToSize + relatedToOccupancy) / 2)));\r\n}"
}, {
	"Path": "org.kohsuke.github.GHPerson.getGravatarId",
	"Comment": "gravatar id of this user, like 0cb9832a01c22c083390f3c5dcb64105",
	"Method": "String getGravatarId(){\r\n    return gravatar_id;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Arrive.getArrivalTolerance",
	"Comment": "returns the tolerance for arriving at the target. it lets the owner get near enough to the target without letting small\terrors keep it in motion.",
	"Method": "float getArrivalTolerance(){\r\n    return arrivalTolerance;\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeVTypeHashMap.verifyLoadFactor",
	"Comment": "validate load factor range and return it. override and suppress if you needinsane load factors.",
	"Method": "double verifyLoadFactor(double loadFactor){\r\n    checkLoadFactor(loadFactor, MIN_LOAD_FACTOR, MAX_LOAD_FACTOR);\r\n    return loadFactor;\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.AgentService.postConstruct",
	"Comment": "is executed after dependency injection is done to perform any initialization.",
	"Method": "void postConstruct(){\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"|-AgentService active...\");\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.dao.impl.TimerDataAggregator.getAlteredTimestamp",
	"Comment": "returns the value of the time stamp based on a aggregation period.",
	"Method": "long getAlteredTimestamp(TimerData timerData){\r\n    long timestampValue = timerData.getTimeStamp().getTime();\r\n    long newTimestampValue = timestampValue - (timestampValue % aggregationPeriod);\r\n    return newTimestampValue;\r\n}"
}, {
	"Path": "org.influxdb.impl.BatchProcessor.builder",
	"Comment": "static method to create the builder for this batchprocessor.",
	"Method": "Builder builder(InfluxDB influxDB){\r\n    return new Builder(influxDB);\r\n}"
}, {
	"Path": "rocks.inspectit.server.ci.event.ProfileUpdateEvent.isProfileDeactivated",
	"Comment": "if profile was deactivated as the result of the update action.",
	"Method": "boolean isProfileDeactivated(){\r\n    return before.isActive() && !after.isActive();\r\n}"
}, {
	"Path": "org.kohsuke.github.GHTreeEntry.asBlob",
	"Comment": "if this tree entry represents a file, then return its information.otherwise null.",
	"Method": "GHBlob asBlob(){\r\n    if (type.equals(\"blob\"))\r\n        return tree.repo.getBlob(sha);\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "org.influxdb.InfluxDBTest.testCreateEmptyNamedDatabase",
	"Comment": "test that creating database which name is empty will throw expected exception",
	"Method": "void testCreateEmptyNamedDatabase(){\r\n    String emptyName = \"\";\r\n    Assertions.assertThrows(IllegalArgumentException.class, () -> {\r\n        this.influxDB.createDatabase(emptyName);\r\n    });\r\n}"
}, {
	"Path": "rocks.inspectit.server.mail.EMailSender.parseAdditionalPropertiesString",
	"Comment": "unwrap the comma separated list string of additional properties into real properties object.",
	"Method": "void parseAdditionalPropertiesString(){\r\n    additionalProperties.clear();\r\n    if (null != smtpPropertiesString) {\r\n        String[] strArray = smtpPropertiesString.split(\",\");\r\n        for (String property : strArray) {\r\n            int equalsIndex = property.indexOf('=');\r\n            if ((equalsIndex > 0) && (equalsIndex < (property.length() - 1))) {\r\n                additionalProperties.put(property.substring(0, equalsIndex).trim(), property.substring(equalsIndex + 1).trim());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.sched.PriorityScheduler.run",
	"Comment": "executes scheduled tasks based on their frequency and phase. this method must be called once per frame.",
	"Method": "void run(long timeToRun){\r\n    frame++;\r\n    runList.size = 0;\r\n    float totalPriority = 0;\r\n    for (int i = 0; i < schedulableRecords.size; i++) {\r\n        PrioritySchedulableRecord record = schedulableRecords.get(i);\r\n        if ((frame + record.phase) % record.frequency == 0) {\r\n            runList.add(record);\r\n            totalPriority += record.priority;\r\n        }\r\n    }\r\n    long lastTime = TimeUtils.nanoTime();\r\n    int numToRun = runList.size;\r\n    for (int i = 0; i < numToRun; i++) {\r\n        long currentTime = TimeUtils.nanoTime();\r\n        timeToRun -= currentTime - lastTime;\r\n        PrioritySchedulableRecord record = runList.get(i);\r\n        long availableTime = (long) (timeToRun * record.priority / totalPriority);\r\n        record.schedulable.run(availableTime);\r\n        lastTime = currentTime;\r\n    }\r\n}"
}, {
	"Path": "com.alorma.github.presenter.BaseRxPresenter.subscribe",
	"Comment": "creates internal subscriber and attaches it to observable argument.",
	"Method": "void subscribe(Observable<SdkItem<RESPONSE>> observable,boolean isFromPaginated){\r\n    if (!isViewAttached())\r\n        return;\r\n    getView().showLoading();\r\n    unsubscribe();\r\n    subscriber = new Subscriber<RESPONSE>() {\r\n        @Override\r\n        public void onCompleted() {\r\n            BaseRxPresenter.this.onCompleted();\r\n        }\r\n        @Override\r\n        public void onError(Throwable e) {\r\n            BaseRxPresenter.this.onError(e);\r\n        }\r\n        @Override\r\n        public void onNext(RESPONSE response) {\r\n            BaseRxPresenter.this.onNext(response, isFromPaginated);\r\n        }\r\n    };\r\n    observable.subscribeOn(ioScheduler).observeOn(mainScheduler).timeout(20, TimeUnit.SECONDS).retry(3).map(obs -> {\r\n        if (obs.getPage() != null && obs.getPage() > 0) {\r\n            this.page = obs.getPage();\r\n        } else {\r\n            this.page = null;\r\n        }\r\n        return obs.getK();\r\n    }).subscribe(subscriber);\r\n}"
}, {
	"Path": "com.alorma.github.presenter.BaseRxPresenter.subscribe",
	"Comment": "creates internal subscriber and attaches it to observable argument.",
	"Method": "void subscribe(Observable<SdkItem<RESPONSE>> observable,boolean isFromPaginated){\r\n    BaseRxPresenter.this.onCompleted();\r\n}"
}, {
	"Path": "com.alorma.github.presenter.BaseRxPresenter.subscribe",
	"Comment": "creates internal subscriber and attaches it to observable argument.",
	"Method": "void subscribe(Observable<SdkItem<RESPONSE>> observable,boolean isFromPaginated){\r\n    BaseRxPresenter.this.onError(e);\r\n}"
}, {
	"Path": "com.alorma.github.presenter.BaseRxPresenter.subscribe",
	"Comment": "creates internal subscriber and attaches it to observable argument.",
	"Method": "void subscribe(Observable<SdkItem<RESPONSE>> observable,boolean isFromPaginated){\r\n    BaseRxPresenter.this.onNext(response, isFromPaginated);\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManagerTest.canNotStartRecordingWhenAlreadyRunning",
	"Comment": "tests that recording can not be started if it s already running.",
	"Method": "void canNotStartRecordingWhenAlreadyRunning(){\r\n    storageData = new StorageData();\r\n    storageData.setName(\"Test\");\r\n    RecordingProperties recordingProperties = mock(RecordingProperties.class);\r\n    storageManager.startOrScheduleRecording(storageData, recordingProperties);\r\n    when(storageRecorder.isRecordingOn()).thenReturn(true);\r\n    when(storageRecorder.getRecordingState()).thenReturn(RecordingState.ON);\r\n    when(storageRecorder.getRecordingProperties()).thenReturn(recordingProperties);\r\n    when(storageRecorder.getStorageWriter()).thenReturn(storageWriter);\r\n    verify(storageRecorder, times(1)).startOrScheduleRecording(storageWriter, recordingProperties);\r\n    storageManager.startOrScheduleRecording(storageData, recordingProperties);\r\n    verify(storageRecorder, times(1)).startOrScheduleRecording(storageWriter, recordingProperties);\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider.findConstraints",
	"Comment": "finds all constraint annotations defined for the given constrainable and returns them in a list of constraint\tdescriptors.",
	"Method": "List<ConstraintDescriptorImpl<?>> findConstraints(JavaBeanAnnotatedConstrainable constrainable,ConstraintLocationKind kind,List<ConstraintDescriptorImpl<?>> findConstraints,Constrainable constrainable,JavaBeanAnnotatedElement annotatedElement,ConstraintLocationKind kind,List<ConstraintDescriptorImpl<?>> findConstraints,Constrainable constrainable,Annotation[] annotations,ConstraintLocationKind kind){\r\n    if (annotations.length == 0) {\r\n        return Collections.emptyList();\r\n    }\r\n    List<ConstraintDescriptorImpl<?>> metaData = newArrayList();\r\n    for (Annotation annotation : annotations) {\r\n        metaData.addAll(findConstraintAnnotations(constrainable, annotation, kind));\r\n    }\r\n    return metaData;\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManagerTest.stopRecordingWhenCanNotWriteMore",
	"Comment": "tests that stop recording will be executed if manager reports that can not write more on\tdisk.",
	"Method": "void stopRecordingWhenCanNotWriteMore(){\r\n    storageManager = spy(storageManager);\r\n    DefaultData defaultData = mock(DefaultData.class);\r\n    when(storageManager.canWriteMore()).thenReturn(false);\r\n    when(storageRecorder.isRecordingOn()).thenReturn(true);\r\n    Mockito.doNothing().when(storageManager).stopRecording();\r\n    storageManager.record(defaultData);\r\n    verify(storageManager, times(1)).stopRecording();\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.constraintvalidators.bv.time.AbstractJavaTimeValidator.isValid",
	"Comment": "returns whether the result of the comparison between the validated value and the time reference is considered\tvalid.",
	"Method": "boolean isValid(T value,ConstraintValidatorContext context,boolean isValid,int result){\r\n    if (value == null) {\r\n        return true;\r\n    }\r\n    int result = value.compareTo(getReferenceValue(referenceClock));\r\n    return isValid(result);\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.AtomicBuffer.getAnalyzedElements",
	"Comment": "returns the number of analyzed elements since the buffer has been created.",
	"Method": "long getAnalyzedElements(){\r\n    return elementsAnalyzed.get();\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.checks.AnnotationTypeMemberCheck.isEmptyArray",
	"Comment": "checks whether the given annotation value is an empty array or not.",
	"Method": "boolean isEmptyArray(AnnotationValue annotationValue){\r\n    return annotationValue != null && Boolean.TRUE.equals(annotationValue.accept(new SimpleAnnotationValueVisitor8<Boolean, Void>() {\r\n        @Override\r\n        public Boolean visitArray(List<? extends AnnotationValue> values, Void p) {\r\n            return values.size() == 0;\r\n        }\r\n    }, null));\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.checks.AnnotationTypeMemberCheck.isEmptyArray",
	"Comment": "checks whether the given annotation value is an empty array or not.",
	"Method": "boolean isEmptyArray(AnnotationValue annotationValue){\r\n    return values.size() == 0;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHContent.getDownloadUrl",
	"Comment": "url to retrieve the raw content of the file. null if this is a directory.",
	"Method": "String getDownloadUrl(){\r\n    populate();\r\n    return download_url;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.path.PathImpl.isValidJavaIdentifier",
	"Comment": "validate that the given identifier is a valid java identifier according to the java language specification,\tchapter 3.8",
	"Method": "boolean isValidJavaIdentifier(String identifier){\r\n    Contracts.assertNotNull(identifier, \"identifier param cannot be null\");\r\n    if (identifier.length() == 0 || !Character.isJavaIdentifierStart((int) identifier.charAt(0))) {\r\n        return false;\r\n    }\r\n    for (int i = 1; i < identifier.length(); i++) {\r\n        if (!Character.isJavaIdentifierPart((int) identifier.charAt(i))) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sdk.opentracing.internal.impl.SpanBuilderImpl.withBaggageFrom",
	"Comment": "collects baggage from parent. copied from the io.opentracing implementation.",
	"Method": "void withBaggageFrom(SpanContext from){\r\n    Iterable<Entry<String, String>> baggageItems = from.baggageItems();\r\n    if ((null == baggageItems) || (null == baggageItems.iterator())) {\r\n        return;\r\n    }\r\n    for (Entry<String, String> baggageItem : baggageItems) {\r\n        baggage.put(baggageItem.getKey(), baggageItem.getValue());\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Seek.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum linear acceleration.",
	"Method": "Seek<T> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.connection.impl.KeepAliveManager.sendKeepAlive",
	"Comment": "sends keep alive signal if connection to the server exists. otherwise does try to reconnect\tin the exponential waiting manner.",
	"Method": "void sendKeepAlive(){\r\n    try {\r\n        if (connection.isConnected()) {\r\n            connection.sendKeepAlive(platformManager.getPlatformId());\r\n        } else {\r\n            if (shouldReconnect()) {\r\n                log.info(\"Trying to reconnect to the server.\");\r\n                try {\r\n                    connection.reconnect();\r\n                    nextReconnectAt = 2;\r\n                } catch (ConnectException e) {\r\n                    if (log.isDebugEnabled()) {\r\n                        log.debug(\"Reconnection failed, next attempt in \" + TimeUnit.MILLISECONDS.toSeconds(IKeepAliveService.KA_PERIOD * (nextReconnectAt - noConnectionCount)) + \" seconds.\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch (ServerUnavailableException e) {\r\n        if (log.isDebugEnabled()) {\r\n            if (e.isServerTimeout()) {\r\n                log.debug(\"Keep-alive signal could not be sent. Server timeout.\", e);\r\n            } else {\r\n                log.debug(\"Keep-alive signal could not be sent. Server not available.\", e);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.proxy.impl.RuntimeLinker.getActualClassLoader",
	"Comment": "returns the system classloader if the given classloader is null. otherwise just returns the\tsupplied classloader.",
	"Method": "ClassLoader getActualClassLoader(ClassLoader cl){\r\n    if (cl == null) {\r\n        return ClassLoader.getSystemClassLoader();\r\n    } else {\r\n        return cl;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.special.EUMInstrumentationHook.interceptRequest",
	"Comment": "lets inspecit decide whether it will intercept the request. if the request is intercepted,\tinspectit will write the response of this request to the client and the application server\twill not process this request any further.",
	"Method": "boolean interceptRequest(Object requestObj,Object responseObj){\r\n    boolean performCheck = !interceptionCheckPerformed.isMarkerSet();\r\n    interceptionCheckPerformed.markCall();\r\n    if (performCheck && configurationValid) {\r\n        try {\r\n            if (!WHttpServletRequest.isInstance(requestObj) || !WHttpServletResponse.isInstance(responseObj)) {\r\n                return false;\r\n            }\r\n            WHttpServletRequest req = WHttpServletRequest.wrap(requestObj);\r\n            WHttpServletResponse res = WHttpServletResponse.wrap(responseObj);\r\n            String path = req.getRequestURI();\r\n            Matcher beaconURLMatcher = beaconURLRegEx.matcher(path);\r\n            if (beaconURLMatcher.matches()) {\r\n                receiveBeacon(req, res);\r\n                return true;\r\n            }\r\n            Matcher agentURLMatcher = jsAgentURLRegEx.matcher(path);\r\n            if (agentURLMatcher.matches()) {\r\n                String modules = agentURLMatcher.group(AGENT_MODULES_GROUP_INDEX).toLowerCase();\r\n                sendScript(res, modules);\r\n                return true;\r\n            }\r\n            return false;\r\n        } catch (Throwable e) {\r\n            LOG.error(\"Error intercepting request.\", e);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHPullRequestReviewBuilder.commitId",
	"Comment": "the sha of the commit that needs a review. not using the latest commit sha may render your review comment outdated if a subsequent commit modifies the line you specify as the position. defaults to the most recent commit in the pull request when you do not specify a value.",
	"Method": "GHPullRequestReviewBuilder commitId(String commitId){\r\n    builder.with(\"commit_id\", commitId);\r\n    return this;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.valueextraction.ValueExtractorResolver.getMaximallySpecificAndContainerElementCompliantValueExtractor",
	"Comment": "used to find the maximally specific and container element compliant value extractor based on the declared type\tand the type parameter.\tused for container element constraints.",
	"Method": "ValueExtractorDescriptor getMaximallySpecificAndContainerElementCompliantValueExtractor(Class<?> declaredType,TypeVariable<?> typeParameter){\r\n    return getUniqueValueExtractorOrThrowException(declaredType, getRuntimeAndContainerElementCompliantValueExtractorsFromPossibleCandidates(declaredType, typeParameter, declaredType, registeredValueExtractors));\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.engine.session.SessionPerfTest.getRecursiveInvocationSequence",
	"Comment": "creates an invocationsequence with recursive invocations.",
	"Method": "InvocationSequenceData getRecursiveInvocationSequence(InvocationSequenceData leaf,int currentHight,int maxHeight){\r\n    if (currentHight >= maxHeight) {\r\n        return leaf;\r\n    } else {\r\n        InvocationSequenceData parent = new InvocationSequenceData(new Timestamp(System.currentTimeMillis() + (leaf.getTimeStamp().getTime() - 100)), 0, 0, leaf.getMethodIdent());\r\n        leaf.setParentSequence(parent);\r\n        parent.setDuration(leaf.getDuration() + EXCLUSIVE_DURATION_OF_PARENT);\r\n        TimerData timerData = new TimerData(parent.getTimeStamp(), parent.getPlatformIdent(), parent.getSensorTypeIdent(), parent.getMethodIdent());\r\n        timerData.addDuration(leaf.getDuration() + EXCLUSIVE_DURATION_OF_PARENT);\r\n        timerData.setExclusiveDuration(EXCLUSIVE_DURATION_OF_PARENT);\r\n        timerData.addCpuDuration(20);\r\n        timerData.calculateExclusiveMin(EXCLUSIVE_DURATION_OF_PARENT);\r\n        parent.setTimerData(timerData);\r\n        parent.getNestedSequences().add(leaf);\r\n        return getRecursiveInvocationSequence(parent, currentHight + 1, maxHeight);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.instrumentation.asm.MethodInstrumenter.generateAfterBodyCall",
	"Comment": "generates code for the after body call. this method expects the result of the method call on\tthe stack that can be consumed.",
	"Method": "void generateAfterBodyCall(String method,boolean exception){\r\n    prepareAfterBodyCall();\r\n    push(exception);\r\n    mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, IInstrumenterConstant.IHOOK_DISPATCHER_INTERNAL_NAME, method, IInstrumenterConstant.DISPATCH_METHOD_AFTER_BODY_DESCRIPTOR, true);\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Jump.setTakeoffTolerance",
	"Comment": "sets the the tolerance used to check if the owner has reached the takeoff location with the required velocity.",
	"Method": "Jump<T> setTakeoffTolerance(float takeoffTolerance){\r\n    setTakeoffPositionTolerance(takeoffTolerance);\r\n    setTakeoffVelocityTolerance(takeoffTolerance);\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.getRecordingProperties",
	"Comment": "returns the properties used for the current recording on the cmr.",
	"Method": "RecordingProperties getRecordingProperties(){\r\n    return storageRecorder.getRecordingProperties();\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageRecorder.stopRecording",
	"Comment": "stops recording by flushing all the recording processors.",
	"Method": "void stopRecording(){\r\n    if (isRecordingOn()) {\r\n        if (null != stopRecordingFuture) {\r\n            if (!stopRecordingFuture.isDone() && !stopRecordingFuture.isCancelled()) {\r\n                stopRecordingFuture.cancel(false);\r\n            }\r\n            stopRecordingFuture = null;\r\n        }\r\n        Collection<AbstractDataProcessor> recordingDataProcessors = recordingProperties.getRecordingDataProcessors();\r\n        if (null != recordingDataProcessors) {\r\n            for (AbstractDataProcessor abstractDataProcessor : recordingDataProcessors) {\r\n                abstractDataProcessor.flush();\r\n            }\r\n        }\r\n        if (!involvedAgentsSet.isEmpty()) {\r\n            List<SystemInformationData> toRecord = storageDataDao.getSystemInformationData(involvedAgentsSet);\r\n            for (SystemInformationData defaultData : toRecord) {\r\n                record(defaultData);\r\n            }\r\n        }\r\n        involvedAgentsSet.clear();\r\n        if (log.isDebugEnabled()) {\r\n            log.info(\"Recording stopped for storage: \" + getStorageData());\r\n        }\r\n    } else if (isRecordingScheduled()) {\r\n        if (null != startRecordingFuture) {\r\n            if (!startRecordingFuture.isDone() && !startRecordingFuture.isCancelled()) {\r\n                startRecordingFuture.cancel(false);\r\n            }\r\n            startRecordingFuture = null;\r\n        }\r\n    }\r\n    storageWriter = null;\r\n    recordingProperties = null;\r\n    recordingState = RecordingState.OFF;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.connection.RetryStrategy.remoteExceptionOccured",
	"Comment": "called when a remote exception occured at the server. two options are available here, the\tfirst is to raise an exception, and the second is to wait till we are going for a retry.",
	"Method": "void remoteExceptionOccured(){\r\n    numberOfTriesLeft--;\r\n    if (!shouldRetry()) {\r\n        throw new RetryException();\r\n    }\r\n    waitUntilNextTry();\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.http.HttpHook.providesHttpResponseMetrics",
	"Comment": "checks if the given class is realizing the httpservletresponse interface directly or\tindirectly. only if this interface is realized, we can get http metric information.",
	"Method": "boolean providesHttpResponseMetrics(Class<?> c){\r\n    return implementsInterface(c, HTTP_SERVLET_RESPONSE_CLASS, HTTP_RESPONSE_WHITE_LIST, HTTP_RESPONSE_BLACK_LIST);\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.invocationsequence.InvocationSequenceHookTest.minDuration",
	"Comment": "tests that invocation will not be saved if the duration is below min duration specified in\tthe rsc settings.",
	"Method": "void minDuration(){\r\n    long platformId = 1L;\r\n    long methodId = 3L;\r\n    long sensorTypeId = 11L;\r\n    Object object = mock(Object.class);\r\n    Object[] parameters = new Object[0];\r\n    Object result = mock(Object.class);\r\n    when(platformManager.getPlatformId()).thenReturn(platformId);\r\n    double firstTimerValue = 1000.0d;\r\n    double secondTimerValue = 1200.0d;\r\n    Long minDuration = 201L;\r\n    when(timer.getCurrentTime()).thenReturn(firstTimerValue, secondTimerValue);\r\n    Map<String, Object> map = new HashMap<String, Object>();\r\n    map.put(\"minduration\", minDuration);\r\n    when(rsc.getSettings()).thenReturn(map);\r\n    when(rsc.getMethodSensors()).thenReturn(Collections.singletonList(methodSensor));\r\n    when(methodSensor.getSensorTypeConfig()).thenReturn(methodSensorTypeConfig);\r\n    invocationSequenceHook.beforeBody(methodId, sensorTypeId, object, parameters, rsc);\r\n    invocationSequenceHook.firstAfterBody(methodId, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.secondAfterBody(coreService, methodId, sensorTypeId, object, parameters, result, false, rsc);\r\n    verify(timer, times(2)).getCurrentTime();\r\n    verifyZeroInteractions(coreService);\r\n    secondTimerValue = 1202.0d;\r\n    when(timer.getCurrentTime()).thenReturn(firstTimerValue, secondTimerValue);\r\n    invocationSequenceHook.beforeBody(methodId, sensorTypeId, object, parameters, rsc);\r\n    invocationSequenceHook.firstAfterBody(methodId, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.secondAfterBody(coreService, methodId, sensorTypeId, object, parameters, result, false, rsc);\r\n    verify(timer, times(4)).getCurrentTime();\r\n    verify(coreService, times(1)).addDefaultData(Matchers.<InvocationSequenceData>anyObject());\r\n    verifyZeroInteractions(realCoreService);\r\n}"
}, {
	"Path": "org.kohsuke.github.GHPullRequestReview.listReviewComments",
	"Comment": "obtains all the review comments associated with this pull request review.",
	"Method": "PagedIterable<GHPullRequestReviewComment> listReviewComments(){\r\n    return new PagedIterable<GHPullRequestReviewComment>() {\r\n        public PagedIterator<GHPullRequestReviewComment> _iterator(int pageSize) {\r\n            return new PagedIterator<GHPullRequestReviewComment>(owner.root.retrieve().asIterator(getApiRoute() + \"/comments\", GHPullRequestReviewComment[].class, pageSize)) {\r\n                protected void wrapUp(GHPullRequestReviewComment[] page) {\r\n                    for (GHPullRequestReviewComment c : page) c.wrapUp(owner);\r\n                }\r\n            };\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.kohsuke.github.GHPullRequestReview.listReviewComments",
	"Comment": "obtains all the review comments associated with this pull request review.",
	"Method": "PagedIterable<GHPullRequestReviewComment> listReviewComments(){\r\n    return new PagedIterator<GHPullRequestReviewComment>(owner.root.retrieve().asIterator(getApiRoute() + \"/comments\", GHPullRequestReviewComment[].class, pageSize)) {\r\n        protected void wrapUp(GHPullRequestReviewComment[] page) {\r\n            for (GHPullRequestReviewComment c : page) c.wrapUp(owner);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.kohsuke.github.GHPullRequestReview.listReviewComments",
	"Comment": "obtains all the review comments associated with this pull request review.",
	"Method": "PagedIterable<GHPullRequestReviewComment> listReviewComments(){\r\n    for (GHPullRequestReviewComment c : page) c.wrapUp(owner);\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManagerTest.deleteStorage",
	"Comment": "after processing to delete storage that might be created in the test.",
	"Method": "void deleteStorage(){\r\n    if (null != storageData) {\r\n        if (storageManager.getRecordingState() == RecordingState.ON) {\r\n            storageManager.stopRecording();\r\n        }\r\n        if (!storageManager.isStorageClosed(storageData)) {\r\n            storageManager.closeStorage(storageData);\r\n        }\r\n        storageManager.deleteStorage(storageData);\r\n        storageData = null;\r\n    }\r\n    assertThat(storageManager.getExistingStorages(), is(empty()));\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.startOrScheduleRecording",
	"Comment": "starts recording on the provided storage if recording is not active. if storage is not\tcreated it will be. if it is not open, it will be.",
	"Method": "void startOrScheduleRecording(StorageData storageData,RecordingProperties recordingProperties){\r\n    if (!isStorageExisting(storageData)) {\r\n        this.createStorage(storageData);\r\n    }\r\n    StorageData local = getLocalStorageDataObject(storageData);\r\n    if (!isStorageOpen(local)) {\r\n        this.openStorage(local);\r\n    }\r\n    synchronized (this) {\r\n        if (!storageRecorder.isRecordingOn() && !storageRecorder.isRecordingScheduled()) {\r\n            StorageWriter storageWriter = openedStoragesMap.remove(local);\r\n            storageRecorder.startOrScheduleRecording(storageWriter, recordingProperties);\r\n            recorderStorageData = local;\r\n            recorderStorageData.markRecording();\r\n            writeStorageDataToDisk(recorderStorageData);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth.OAuthParameters.escape",
	"Comment": "returns the escaped form of the given value using oauth escaping rules.",
	"Method": "String escape(String value){\r\n    return ESCAPER.escape(value);\r\n}"
}, {
	"Path": "com.hypertrack.hyperlog.HyperLog.getExpiryTime",
	"Comment": "call this method to get a expiry time of logs. expiry time is in seconds.",
	"Method": "long getExpiryTime(){\r\n    return EXPIRY_TIME;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHObject.toString",
	"Comment": "string representation to assist debugging and inspection. the output format of this stringis not a committed part of the api and is subject to change.",
	"Method": "String toString(){\r\n    return new ReflectionToStringBuilder(this, TOSTRING_STYLE, null, null, false, false) {\r\n        @Override\r\n        protected boolean accept(Field field) {\r\n            return super.accept(field) && !field.isAnnotationPresent(SkipFromToString.class);\r\n        }\r\n    }.toString();\r\n}"
}, {
	"Path": "org.kohsuke.github.GHObject.toString",
	"Comment": "string representation to assist debugging and inspection. the output format of this stringis not a committed part of the api and is subject to change.",
	"Method": "String toString(){\r\n    return super.accept(field) && !field.isAnnotationPresent(SkipFromToString.class);\r\n}"
}, {
	"Path": "com.alorma.github.ui.view.CircularImageView.setSelectorStrokeColor",
	"Comment": "sets the stroke color to be drawn around the circularimageviewduring click events when the selector is enabled.",
	"Method": "void setSelectorStrokeColor(int selectorStrokeColor){\r\n    if (paintSelectorBorder != null)\r\n        paintSelectorBorder.setColor(selectorStrokeColor);\r\n    this.invalidate();\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.classchecks.ParametersMethodOverrideCheck.hasAnnotationsOnParameters",
	"Comment": "checks if a given method has any constraint or cascaded validation annotations on its parameters.",
	"Method": "boolean hasAnnotationsOnParameters(ExecutableElement method){\r\n    for (VariableElement parameter : method.getParameters()) {\r\n        for (AnnotationMirror annotationMirror : parameter.getAnnotationMirrors()) {\r\n            ConstraintHelper.AnnotationType annotationType = constraintHelper.getAnnotationType(annotationMirror);\r\n            if (ConstraintHelper.AnnotationType.CONSTRAINT_ANNOTATION.equals(annotationType) || ConstraintHelper.AnnotationType.MULTI_VALUED_CONSTRAINT_ANNOTATION.equals(annotationType) || ConstraintHelper.AnnotationType.GRAPH_VALIDATION_ANNOTATION.equals(annotationType)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.hypertrack.hyperlog.HyperLog.setURL",
	"Comment": "call this method to set a valid end point url where logs need to be pushed.",
	"Method": "void setURL(String url){\r\n    if (TextUtils.isEmpty(url))\r\n        throw new IllegalArgumentException(\"API URL cannot be null or empty\");\r\n    URL = url;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.metadata.core.ConstraintHelper.findValidatorDescriptors",
	"Comment": "returns those validator descriptors for the given constraint annotation\tmatching the given target.",
	"Method": "List<ConstraintValidatorDescriptor<A>> findValidatorDescriptors(Class<A> annotationType,ValidationTarget validationTarget){\r\n    return getAllValidatorDescriptors(annotationType).stream().filter(d -> supportsValidationTarget(d, validationTarget)).collect(Collectors.toList());\r\n}"
}, {
	"Path": "org.hibernate.validator.test.internal.engine.methodvalidation.cascadedgroupvalidation.CascadedMethodLevelValidationGroupSequenceTest.cascadedReturnValueConstraintInFirstGroup",
	"Comment": "expect a single constraint violation from the first validation group.",
	"Method": "void cascadedReturnValueConstraintInFirstGroup(){\r\n    setUpValidatorForGroups(CompoundGroup.class);\r\n    try {\r\n        entityRepository.getEntity(new CompoundEntity(new Entity(null, \"value\")));\r\n        fail(\"Expected MethodConstraintViolationException wasn't thrown.\");\r\n    } catch (ConstraintViolationException e) {\r\n        assertThat(e.getConstraintViolations()).containsOnlyViolations(violationOf(NotNull.class).withMessage(\"must not be null\").withInvalidValue(null).withRootBeanClass(CompoundEntityRepositoryImpl.class));\r\n        ConstraintViolation<?> constraintViolation = e.getConstraintViolations().iterator().next();\r\n        assertEquals(constraintViolation.getConstraintDescriptor().getGroups().iterator().next(), ValidationGroup1.class);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.analyzer.impl.ByteCodeAnalyzer.analyzeDependingTypes",
	"Comment": "analyze the depending types of the given type and sends the results to the server if needed.",
	"Method": "void analyzeDependingTypes(Type type,ClassLoader classLoader){\r\n    Collection<Type> dependingTypes = type.getDependingTypes();\r\n    if (CollectionUtils.isNotEmpty(dependingTypes)) {\r\n        for (Type dependingType : dependingTypes) {\r\n            if (!classHashHelper.isAnalyzed(dependingType.getFQN())) {\r\n                analyzeAndInstrumentInternal(null, dependingType.getFQN(), classLoader, false);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.reflection.CachedMethod.call",
	"Comment": "calls the target method, but does not catch any exceptions. note that even checked exceptions\tare thrown, even though this method declares no checked exceptions!.",
	"Method": "R call(Object instance,Object parameters){\r\n    ClassLoader cl = instance.getClass().getClassLoader();\r\n    Method methodToCall = findMethod(cl);\r\n    if (methodToCall == null) {\r\n        throw new RuntimeException(\"Method \" + methodName + \" not found on \" + instance.getClass().getName());\r\n    } else {\r\n        try {\r\n            return (R) methodToCall.invoke(instance, parameters);\r\n        } catch (InvocationTargetException exc) {\r\n            Throwable cause = exc.getCause();\r\n            throwUnchecked(cause);\r\n            return null;\r\n        } catch (Throwable t) {\r\n            throwUnchecked(t);\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.hypertrack.hyperlog.HLHTTPMultiPartPostRequest.getDecompressed",
	"Comment": "utility method to decompress gzip. to be used when we start sending gzip responses.",
	"Method": "String getDecompressed(byte[] compressed){\r\n    try {\r\n        final int BUFFER_SIZE = 32;\r\n        ByteArrayInputStream is = new ByteArrayInputStream(compressed);\r\n        GZIPInputStream gis = new GZIPInputStream(is, BUFFER_SIZE);\r\n        StringBuilder string = new StringBuilder();\r\n        byte[] data = new byte[BUFFER_SIZE];\r\n        int bytesRead;\r\n        while ((bytesRead = gis.read(data)) != -1) {\r\n            string.append(new String(data, 0, bytesRead));\r\n        }\r\n        gis.close();\r\n        is.close();\r\n        return string.toString();\r\n    } catch (Exception exception) {\r\n        HyperLog.e(TAG, \"Exception occurred while getDecompressed: \" + exception);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.server.processor.impl.InvocationModifierCmrProcessor.extractDataFromInvocation",
	"Comment": "extract data from the invocation in the way that timer data is saved to the db, while sql\tstatements and exceptions are indexed into the root branch.",
	"Method": "void extractDataFromInvocation(EntityManager entityManager,InvocationSequenceData invData,InvocationSequenceData topInvocationParent){\r\n    double exclusiveDurationDelta = 0d;\r\n    for (InvocationSequenceData child : invData.getNestedSequences()) {\r\n        passToChainedProcessors(child, entityManager);\r\n        if (null != child.getTimerData()) {\r\n            exclusiveDurationDelta += child.getTimerData().getDuration();\r\n        } else if (null != child.getSqlStatementData()) {\r\n            exclusiveDurationDelta += child.getSqlStatementData().getDuration();\r\n        } else {\r\n            exclusiveDurationDelta += InvocationSequenceDataHelper.computeNestedDuration(child);\r\n        }\r\n        extractDataFromInvocation(entityManager, child, topInvocationParent);\r\n    }\r\n    processSqlStatementData(entityManager, invData, topInvocationParent);\r\n    processTimerData(entityManager, invData, topInvocationParent, exclusiveDurationDelta);\r\n    processExceptionSensorData(entityManager, invData, topInvocationParent);\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.loadAllExistingStorages",
	"Comment": "loads all existing storages by walking through the default storage directory.",
	"Method": "void loadAllExistingStorages(){\r\n    existingStoragesSet = Collections.newSetFromMap(new ConcurrentHashMap<StorageData, Boolean>());\r\n    Path defaultDirectory = Paths.get(getStorageDefaultFolder());\r\n    if (!Files.isDirectory(defaultDirectory)) {\r\n        return;\r\n    }\r\n    final ISerializer serializer = getSerializationManagerProvider().createSerializer();\r\n    try {\r\n        Files.walkFileTree(defaultDirectory, new SimpleFileVisitor<Path>() {\r\n            @Override\r\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\r\n                if (file.toString().endsWith(StorageFileType.STORAGE_FILE.getExtension())) {\r\n                    InputStream inputStream = null;\r\n                    Input input = null;\r\n                    try {\r\n                        inputStream = Files.newInputStream(file, StandardOpenOption.READ);\r\n                        input = new Input(inputStream);\r\n                        Object deserialized = serializer.deserialize(input);\r\n                        if (deserialized instanceof StorageData) {\r\n                            StorageData storageData = (StorageData) deserialized;\r\n                            if (storageData.getState() == StorageState.CLOSED) {\r\n                                printStorageCmrVersionWarn(storageData);\r\n                                existingStoragesSet.add(storageData);\r\n                            }\r\n                        }\r\n                    } catch (IOException e) {\r\n                        log.error(\"Error reading existing storage data file. File path: \" + file.toString() + \".\", e);\r\n                    } catch (SerializationException e) {\r\n                        log.error(\"Error deserializing existing storage binary data in file:\" + file.toString() + \".\", e);\r\n                    } finally {\r\n                        if (null != input) {\r\n                            input.close();\r\n                        }\r\n                    }\r\n                }\r\n                return FileVisitResult.CONTINUE;\r\n            }\r\n        });\r\n    } catch (IOException e) {\r\n        log.error(\"Error exploring default storage directory. Directory path: \" + defaultDirectory.toString() + \".\", e);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.loadAllExistingStorages",
	"Comment": "loads all existing storages by walking through the default storage directory.",
	"Method": "void loadAllExistingStorages(){\r\n    if (file.toString().endsWith(StorageFileType.STORAGE_FILE.getExtension())) {\r\n        InputStream inputStream = null;\r\n        Input input = null;\r\n        try {\r\n            inputStream = Files.newInputStream(file, StandardOpenOption.READ);\r\n            input = new Input(inputStream);\r\n            Object deserialized = serializer.deserialize(input);\r\n            if (deserialized instanceof StorageData) {\r\n                StorageData storageData = (StorageData) deserialized;\r\n                if (storageData.getState() == StorageState.CLOSED) {\r\n                    printStorageCmrVersionWarn(storageData);\r\n                    existingStoragesSet.add(storageData);\r\n                }\r\n            }\r\n        } catch (IOException e) {\r\n            log.error(\"Error reading existing storage data file. File path: \" + file.toString() + \".\", e);\r\n        } catch (SerializationException e) {\r\n            log.error(\"Error deserializing existing storage binary data in file:\" + file.toString() + \".\", e);\r\n        } finally {\r\n            if (null != input) {\r\n                input.close();\r\n            }\r\n        }\r\n    }\r\n    return FileVisitResult.CONTINUE;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sdk.opentracing.internal.util.ConversionUtils.parseHexStringSafe",
	"Comment": "parses a hexadecimal string. if passed string is null, then 0 will\tbe returned.",
	"Method": "long parseHexStringSafe(String s){\r\n    if (null == s) {\r\n        return 0;\r\n    }\r\n    return Long.parseLong(s, 16);\r\n}"
}, {
	"Path": "rocks.inspectit.server.processor.impl.InvocationModifierCmrProcessor.processTimerData",
	"Comment": "process timer data if one exists in the invdata object and passes it to the chained\tprocessors.",
	"Method": "void processTimerData(EntityManager entityManager,InvocationSequenceData invData,InvocationSequenceData topInvocationParent,double exclusiveDurationDelta){\r\n    TimerData timerData = invData.getTimerData();\r\n    if (null != timerData) {\r\n        double exclusiveTime = invData.getTimerData().getDuration() - exclusiveDurationDelta;\r\n        timerData.setExclusiveCount(1L);\r\n        timerData.setExclusiveDuration(exclusiveTime);\r\n        timerData.calculateExclusiveMax(exclusiveTime);\r\n        timerData.calculateExclusiveMin(exclusiveTime);\r\n        timerData.addInvocationParentId(topInvocationParent.getId());\r\n        passToChainedProcessors(invData.getTimerData(), entityManager);\r\n    }\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.BitSet.getAndSet",
	"Comment": "sets a bit and returns the previous value. the index should be less than the bitsetsize.",
	"Method": "boolean getAndSet(int index,boolean getAndSet,long index){\r\n    int wordNum = (int) (index >> 6);\r\n    int bit = (int) index & 0x3f;\r\n    long bitmask = 1L << bit;\r\n    boolean val = (bits[wordNum] & bitmask) != 0;\r\n    bits[wordNum] |= bitmask;\r\n    return val;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.invocationsequence.InvocationSequenceHookTest.fixChildrenOnRemoval",
	"Comment": "checks if there is a correct order of children when one in the middle is removed.",
	"Method": "void fixChildrenOnRemoval(){\r\n    long platformId = 1L;\r\n    long sensorTypeId = 11L;\r\n    long methodId1 = 3L;\r\n    long methodId2 = 23L;\r\n    long methodId3 = 31L;\r\n    Object object = mock(Object.class);\r\n    Object[] parameters = new Object[0];\r\n    Object result = mock(Object.class);\r\n    when(platformManager.getPlatformId()).thenReturn(platformId);\r\n    double firstTimerValue = 1000.0d;\r\n    double secondTimerValue = 1323.0d;\r\n    double thirdTimerValue = 1881.0d;\r\n    double fourthTimerValue = 2562.0d;\r\n    double fifthTimerValue = 3221.0d;\r\n    when(timer.getCurrentTime()).thenReturn(firstTimerValue, secondTimerValue, thirdTimerValue, fourthTimerValue, fifthTimerValue);\r\n    RegisteredSensorConfig removingRsc = mock(RegisteredSensorConfig.class);\r\n    MethodSensorTypeConfig exceptionSensorConfig = mock(MethodSensorTypeConfig.class);\r\n    when(exceptionSensorConfig.getClassName()).thenReturn(ExceptionSensor.class.getName());\r\n    when(rsc.getMethodSensors()).thenReturn(Collections.<IMethodSensor>emptyList());\r\n    when(removingRsc.getMethodSensors()).thenReturn(Collections.singletonList(methodSensor));\r\n    when(methodSensor.getSensorTypeConfig()).thenReturn(exceptionSensorConfig);\r\n    TimerData timerData = new TimerData();\r\n    invocationSequenceHook.beforeBody(methodId1, sensorTypeId, object, parameters, rsc);\r\n    invocationSequenceHook.beforeBody(methodId2, sensorTypeId, object, parameters, removingRsc);\r\n    invocationSequenceHook.beforeBody(methodId3, sensorTypeId, object, parameters, rsc);\r\n    invocationSequenceHook.addDefaultData(timerData);\r\n    invocationSequenceHook.firstAfterBody(methodId3, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.secondAfterBody(coreService, methodId3, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.firstAfterBody(methodId2, sensorTypeId, object, parameters, result, false, removingRsc);\r\n    invocationSequenceHook.secondAfterBody(coreService, methodId2, sensorTypeId, object, parameters, result, false, removingRsc);\r\n    invocationSequenceHook.firstAfterBody(methodId1, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.secondAfterBody(coreService, methodId1, sensorTypeId, object, parameters, result, false, rsc);\r\n    verify(timer, times(5)).getCurrentTime();\r\n    ArgumentCaptor<InvocationSequenceData> captor = ArgumentCaptor.forClass(InvocationSequenceData.class);\r\n    verify(coreService, times(1)).addDefaultData(captor.capture());\r\n    InvocationSequenceData invocation = captor.getValue();\r\n    assertThat(invocation.getPlatformIdent(), is(platformId));\r\n    assertThat(invocation.getMethodIdent(), is(methodId1));\r\n    assertThat(invocation.getSensorTypeIdent(), is(sensorTypeId));\r\n    assertThat(invocation.getDuration(), is(fifthTimerValue - firstTimerValue));\r\n    assertThat(invocation.getNestedSequences(), hasSize(1));\r\n    assertThat(invocation.getChildCount(), is(1L));\r\n    InvocationSequenceData child = invocation.getNestedSequences().iterator().next();\r\n    assertThat(child.getPlatformIdent(), is(platformId));\r\n    assertThat(child.getMethodIdent(), is(methodId3));\r\n    assertThat(child.getSensorTypeIdent(), is(sensorTypeId));\r\n    assertThat(child.getDuration(), is(fourthTimerValue - thirdTimerValue));\r\n    assertThat(child.getNestedSequences(), is(empty()));\r\n    assertThat(child.getParentSequence(), is(invocation));\r\n    assertThat(child.getChildCount(), is(0L));\r\n    verifyZeroInteractions(realCoreService);\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.http.StartEndMarker.markCall",
	"Comment": "increase the counter. use this at the point that you want marked.",
	"Method": "void markCall(){\r\n    super.get().increase();\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.util.MessagerAdapter.report",
	"Comment": "reports the given issue. message parameters will be put into the template\tretrieved from the resource bundle if applicable.",
	"Method": "void report(ConstraintCheckIssue issue,Kind kind){\r\n    String message = errorMessages.getString(issue.getMessageKey());\r\n    if (issue.getMessageParameters() != null) {\r\n        MessageFormat messageFormat = new MessageFormat(message, Locale.getDefault());\r\n        message = messageFormat.format(issue.getMessageParameters());\r\n    }\r\n    messager.printMessage(kind, message, issue.getElement(), issue.getAnnotationMirror());\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.proxy.impl.ASMProxyBuilder.getInternalNames",
	"Comment": "utility function for retrieving the internal names for a set of classes.",
	"Method": "String[] getInternalNames(Collection<Class<?>> classes){\r\n    String[] names = new String[classes.size()];\r\n    int i = 0;\r\n    for (Class<?> clazz : classes) {\r\n        names[i] = Type.getInternalName(clazz);\r\n        i++;\r\n    }\r\n    return names;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.FollowPath.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum linear speed and\tacceleration. however the maximum linear speed is not required for a closed path.",
	"Method": "FollowPath<T, P> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.server.influx.dao.InfluxDBDao.createDatabaseIfNotExistent",
	"Comment": "creates the configured database in influx if it does not exist yet.",
	"Method": "void createDatabaseIfNotExistent(){\r\n    if (!isDatabaseAvailable(database)) {\r\n        createDatabase(database);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.PrioritySteering.setEpsilon",
	"Comment": "sets the threshold of the steering acceleration magnitude below which a steering behavior is considered to have given no\toutput.",
	"Method": "PrioritySteering<T> setEpsilon(float epsilon){\r\n    this.epsilon = epsilon;\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.BufferProperties.getObjectSecurityExpansionRate",
	"Comment": "returns object security expansion rate based on the property set and given buffer size.",
	"Method": "float getObjectSecurityExpansionRate(long bufferSize){\r\n    return (getObjectSecurityExpansionRateBufferSize(bufferSize) + getObjectSecurityExpansionRateBufferOccupancy(bufferSize, getOldGenMax())) / 2;\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.BitSet.bits2words",
	"Comment": "returns the number of 64 bit words it would take to hold numbits",
	"Method": "int bits2words(long numBits){\r\n    return (int) (((numBits - 1) >>> 6) + 1);\r\n}"
}, {
	"Path": "rocks.inspectit.server.ci.event.ProfileUpdateEvent.isProfileActivated",
	"Comment": "if profile was activated as the result of the update action.",
	"Method": "boolean isProfileActivated(){\r\n    return !before.isActive() && after.isActive();\r\n}"
}, {
	"Path": "com.alorma.github.inapp.IabHelper.getResponseCodeFromBundle",
	"Comment": "workaround to bug where sometimes response codes come as long instead of integer",
	"Method": "int getResponseCodeFromBundle(Bundle b){\r\n    Object o = b.get(RESPONSE_CODE);\r\n    if (o == null) {\r\n        logDebug(\"Bundle with null response code, assuming OK (known issue)\");\r\n        return BILLING_RESPONSE_RESULT_OK;\r\n    } else if (o instanceof Integer) {\r\n        return ((Integer) o).intValue();\r\n    } else if (o instanceof Long) {\r\n        return (int) ((Long) o).longValue();\r\n    } else {\r\n        logError(\"Unexpected type for bundle response code.\");\r\n        logError(o.getClass().getName());\r\n        throw new RuntimeException(\"Unexpected type for bundle response code: \" + o.getClass().getName());\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.btree.BehaviorTree.addChildToTask",
	"Comment": "this method will add a child, namely the root, to this behavior tree.",
	"Method": "int addChildToTask(Task<E> child,int addChildToTask,Task<E> child){\r\n    if (this.rootTask != null)\r\n        throw new IllegalStateException(\"A behavior tree cannot have more than one root task\");\r\n    this.rootTask = child;\r\n    return 0;\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth2.TokenRequest.setTokenServerUrl",
	"Comment": "sets the token server url.overriding is only supported for the purpose of calling the super implementation and changingthe return type, but nothing else.",
	"Method": "TokenRequest setTokenServerUrl(GenericUrl tokenServerUrl){\r\n    this.tokenServerUrl = tokenServerUrl;\r\n    Preconditions.checkArgument(tokenServerUrl.getFragment() == null);\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.rest.AlertRestfulService.handleException",
	"Comment": "handling of all the exceptions happening in this controller.",
	"Method": "ModelAndView handleException(Exception exception){\r\n    return new JsonError(exception).asModelAndView();\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.metadata.core.ConstraintHelper.getDefaultValidatorDescriptors",
	"Comment": "returns the default validators for the given constraint type.",
	"Method": "List<ConstraintValidatorDescriptor<A>> getDefaultValidatorDescriptors(Class<A> annotationType){\r\n    final List<ConstraintValidatorDescriptor<A>> builtInValidators = (List<ConstraintValidatorDescriptor<A>>) builtinConstraints.get(annotationType);\r\n    if (builtInValidators != null) {\r\n        return builtInValidators;\r\n    }\r\n    Class<? extends ConstraintValidator<A, ?>>[] validatedBy = (Class<? extends ConstraintValidator<A, ?>>[]) annotationType.getAnnotation(Constraint.class).validatedBy();\r\n    return Stream.of(validatedBy).map(c -> ConstraintValidatorDescriptor.forClass(c, annotationType)).collect(Collectors.collectingAndThen(Collectors.toList(), CollectionHelper::toImmutableList));\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Arrive.setArrivalTolerance",
	"Comment": "sets the tolerance for arriving at the target. it lets the owner get near enough to the target without letting small errors\tkeep it in motion.",
	"Method": "Arrive<T> setArrivalTolerance(float arrivalTolerance){\r\n    this.arrivalTolerance = arrivalTolerance;\r\n    return this;\r\n}"
}, {
	"Path": "com.anthonycr.grant.PermissionsResultAction.registerPermissions",
	"Comment": "this method registers the permissionsresultaction object for the specified permissionsso that it will know which permissions to look for changes to. the permissionsresultactionwill then know to look out for changes to these permissions.",
	"Method": "void registerPermissions(String[] perms){\r\n    Collections.addAll(mPermissions, perms);\r\n}"
}, {
	"Path": "com.google.api.client.auth.openidconnect.IdToken.parse",
	"Comment": "parses the given id token string and returns the parsed id token.",
	"Method": "IdToken parse(JsonFactory jsonFactory,String idTokenString){\r\n    JsonWebSignature jws = JsonWebSignature.parser(jsonFactory).setPayloadClass(Payload.class).parse(idTokenString);\r\n    return new IdToken(jws.getHeader(), (Payload) jws.getPayload(), jws.getSignatureBytes(), jws.getSignedContentBytes());\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.btree.utils.PooledBehaviorTreeLibrary.getPool",
	"Comment": "retrieve pool by tree reference, create it if not already exists.",
	"Method": "Pool<BehaviorTree> getPool(String treeReference){\r\n    Pool<BehaviorTree> treePool = pools.get(treeReference);\r\n    if (treePool == null) {\r\n        treePool = new Pool<BehaviorTree>() {\r\n            @Override\r\n            protected BehaviorTree newObject() {\r\n                return newBehaviorTree(treeReference);\r\n            }\r\n        };\r\n        pools.put(treeReference, treePool);\r\n    }\r\n    return treePool;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.btree.utils.PooledBehaviorTreeLibrary.getPool",
	"Comment": "retrieve pool by tree reference, create it if not already exists.",
	"Method": "Pool<BehaviorTree> getPool(String treeReference){\r\n    return newBehaviorTree(treeReference);\r\n}"
}, {
	"Path": "rocks.inspectit.server.jetty.JettyWebApplicationContextInitializer.postConstruct",
	"Comment": "performs initialization of the web context binding it to jetty.",
	"Method": "void postConstruct(){\r\n    ServletContext servletContext = jettyContext.getServletContext();\r\n    GenericWebApplicationContext webCtx = new GenericWebApplicationContext();\r\n    webCtx.setServletContext(servletContext);\r\n    webCtx.setParent(ctx);\r\n    webCtx.refresh();\r\n    servletContext.setAttribute(contextAttribute, webCtx);\r\n    jettyContext.start();\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"| Jetty Web Application Context started!\");\r\n    }\r\n}"
}, {
	"Path": "com.alorma.github.presenter.BasePresenter.getView",
	"Comment": "returns view that was previously attached to this presenter.",
	"Method": "VIEW getView(){\r\n    return weakView == null ? null : weakView.get();\r\n}"
}, {
	"Path": "com.anthonycr.grant.PermissionsResultAction.shouldIgnorePermissionNotFound",
	"Comment": "this method is used to determine if a permission notbeing present on the current android platform shouldaffect whether the permissionsresultaction should continuelistening for events. by default, it returns true and willsimply ignore the permission that did not exist. usually this willwork fine since most new permissions are introduced torestrict what was previously allowed without permission.if that is not the case for your particular permission yourequest, override this method and return false to result in theaction being denied.",
	"Method": "boolean shouldIgnorePermissionNotFound(String permission){\r\n    Log.d(TAG, \"Permission not found: \" + permission);\r\n    return true;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.getTeams",
	"Comment": "if this repository belongs to an organization, return a set of teams.",
	"Method": "Set<GHTeam> getTeams(){\r\n    return Collections.unmodifiableSet(new HashSet<GHTeam>(Arrays.asList(GHTeam.wrapUp(root.retrieve().to(getApiTailUrl(\"teams\"), GHTeam[].class), root.getOrganization(getOwnerName())))));\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.spring.SpringConfiguration.registerBeanDefinitionAndInitialize",
	"Comment": "creates bean definition for the given class name, registers the definition in the registry\tand immediately invokes the initialization of the bean.\tthis is the only way to initialize the bean definitions that no other component has\tdependency to, since we add the definitions in the moment when the lookup has been finished\tand bean creation has started.",
	"Method": "void registerBeanDefinitionAndInitialize(String beanName,String className){\r\n    Class<?> clazz = Class.forName(className);\r\n    GenericBeanDefinition definition = new GenericBeanDefinition();\r\n    definition.setBeanClass(clazz);\r\n    definition.setAutowireMode(AbstractBeanDefinition.AUTOWIRE_BY_TYPE);\r\n    definition.setAutowireCandidate(true);\r\n    registry.registerBeanDefinition(beanName, definition);\r\n    beanFactory.getBean(beanName, clazz);\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Cohesion.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum linear acceleration.",
	"Method": "Cohesion<T> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.util.ConcurrentReferenceHashMap.putAll",
	"Comment": "copies all of the mappings from the specified map to this one.\tthese mappings replace any mappings that this map had for any of the\tkeys currently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> m){\r\n    for (Map.Entry<? extends K, ? extends V> e : m.entrySet()) put(e.getKey(), e.getValue());\r\n}"
}, {
	"Path": "com.google.api.client.auth.openidconnect.IdToken.verifyAudience",
	"Comment": "returns whether the audience in the payload contains only client ids that are trusted asspecified in step 2 of id tokenvalidation.",
	"Method": "boolean verifyAudience(Collection<String> trustedClientIds){\r\n    Collection<String> audience = getPayload().getAudienceAsList();\r\n    if (audience.isEmpty()) {\r\n        return false;\r\n    }\r\n    return trustedClientIds.containsAll(audience);\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.removeLabelFromStorage",
	"Comment": "removes label from storage and saves new state of the storage data to the disk.",
	"Method": "boolean removeLabelFromStorage(StorageData storageData,AbstractStorageLabel<?> storageLabel){\r\n    StorageData local = getLocalStorageDataObject(storageData);\r\n    boolean removed = local.removeLabel(storageLabel);\r\n    writeStorageDataToDisk(local);\r\n    return removed;\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.BufferProperties.getMaxObjectExpansionRate",
	"Comment": "returns maximum security object expansion rate in percentages.",
	"Method": "float getMaxObjectExpansionRate(){\r\n    return maxObjectExpansionRate;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.msg.MessageDispatcher.clearQueue",
	"Comment": "removes all the telegrams from the queue and releases them to the internal pool.",
	"Method": "void clearQueue(){\r\n    for (int i = 0; i < queue.size(); i++) {\r\n        POOL.free(queue.get(i));\r\n    }\r\n    queue.clear();\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.invocationsequence.InvocationSequenceHook.saveDataObject",
	"Comment": "save the data objects which are coming from all the different sensor types in the current\tinvocation tracer context.",
	"Method": "void saveDataObject(DefaultData dataObject){\r\n    InvocationSequenceData invocationSequenceData = threadLocalInvocationData.get();\r\n    if (dataObject.getClass().equals(SqlStatementData.class)) {\r\n        if (null == invocationSequenceData.getSqlStatementData()) {\r\n            invocationSequenceData.setSqlStatementData((SqlStatementData) dataObject);\r\n        }\r\n    }\r\n    if (dataObject.getClass().equals(HttpTimerData.class)) {\r\n        if ((null == invocationSequenceData.getTimerData()) || invocationSequenceData.getTimerData().getClass().equals(TimerData.class)) {\r\n            invocationSequenceData.setTimerData((HttpTimerData) dataObject);\r\n        }\r\n    }\r\n    if (dataObject.getClass().equals(TimerData.class)) {\r\n        if (null == invocationSequenceData.getTimerData()) {\r\n            invocationSequenceData.setTimerData((TimerData) dataObject);\r\n        }\r\n    }\r\n    if (dataObject.getClass().equals(ExceptionSensorData.class)) {\r\n        ExceptionSensorData exceptionSensorData = (ExceptionSensorData) dataObject;\r\n        invocationSequenceData.addExceptionSensorData(exceptionSensorData);\r\n    }\r\n    if (dataObject.getClass().equals(LoggingData.class)) {\r\n        LoggingData loggingData = (LoggingData) dataObject;\r\n        invocationSequenceData.setLoggingData(loggingData);\r\n    }\r\n    if (AbstractSpan.class.isAssignableFrom(dataObject.getClass())) {\r\n        AbstractSpan span = (AbstractSpan) dataObject;\r\n        invocationSequenceData.setSpanIdent(span.getSpanIdent());\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth2.PasswordTokenRequest.setUsername",
	"Comment": "sets the resource owner username.overriding is only supported for the purpose of calling the super implementation and changingthe return type, but nothing else.",
	"Method": "PasswordTokenRequest setUsername(String username){\r\n    this.username = Preconditions.checkNotNull(username);\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.AbstractObjectSizes.getSizeOfHighScaleLibCounter",
	"Comment": "returns size of the counter object used in the high scale lib nonblockinghashmaplong.",
	"Method": "long getSizeOfHighScaleLibCounter(){\r\n    long size = this.getSizeOfObjectHeader();\r\n    size += this.getPrimitiveTypesSize(1, 0, 0, 0, 0, 0);\r\n    size = alignTo8Bytes(size);\r\n    size += this.getSizeOfHighScaleLibCAT();\r\n    return size;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.msg.PriorityQueue.clear",
	"Comment": "removes all of the elements from this priority queue. the queue will be empty after this call returns.",
	"Method": "void clear(){\r\n    for (int i = 0; i < size; i++) queue[i] = null;\r\n    size = 0;\r\n    set.clear();\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.config.impl.PropertyAccessor.isAcceptedMethod",
	"Comment": "checks whether or not the method may be called within the parameter storage algorithm.",
	"Method": "boolean isAcceptedMethod(String method){\r\n    for (String allowed : ALLOWED_METHODS) {\r\n        if (allowed.equals(method)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "rocks.inspectit.server.util.JpaUtil.delete",
	"Comment": "small util to correctly delete object from database. if object is not contained in the\tcurrent session denoted by given entity manager it will be merged first.",
	"Method": "void delete(EntityManager entityManager,T object){\r\n    if (entityManager.contains(object)) {\r\n        entityManager.remove(object);\r\n    } else {\r\n        T merged = entityManager.merge(object);\r\n        entityManager.remove(merged);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.msg.PriorityQueue.setUniqueness",
	"Comment": "sets a flag indicating whether only unique elements are allowed to be inserted.",
	"Method": "void setUniqueness(boolean uniqueness){\r\n    this.uniqueness = uniqueness;\r\n}"
}, {
	"Path": "org.influxdb.InfluxDBException.buildExceptionForErrorState",
	"Comment": "create corresponding influxdbexception from the message pack error body.",
	"Method": "InfluxDBException buildExceptionForErrorState(String errorBody,InfluxDBException buildExceptionForErrorState,InputStream messagePackErrorBody){\r\n    try {\r\n        MessageUnpacker unpacker = MessagePack.newDefaultUnpacker(messagePackErrorBody);\r\n        ImmutableMapValue mapVal = (ImmutableMapValue) unpacker.unpackValue();\r\n        return InfluxDBException.buildExceptionFromErrorMessage(mapVal.map().get(new ImmutableStringValueImpl(\"error\")).toString());\r\n    } catch (Exception e) {\r\n        return new InfluxDBException(e);\r\n    }\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeHashSet.verifyLoadFactor",
	"Comment": "validate load factor range and return it. override and suppress if you needinsane load factors.",
	"Method": "double verifyLoadFactor(double loadFactor){\r\n    checkLoadFactor(loadFactor, MIN_LOAD_FACTOR, MAX_LOAD_FACTOR);\r\n    return loadFactor;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.utils.CircularBuffer.setResizable",
	"Comment": "sets the flag specifying whether this circular buffer can be resized or not.",
	"Method": "void setResizable(boolean resizable){\r\n    this.resizable = resizable;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.special.EUMInstrumentationHook.initConfig",
	"Comment": "initializes the url configuration using the given configuration storage.",
	"Method": "void initConfig(IConfigurationStorage configurationStorage){\r\n    try {\r\n        AgentEndUserMonitoringConfig endUserMonitoringConfig = configurationStorage.getEndUserMonitoringConfig();\r\n        String base = endUserMonitoringConfig.getScriptBaseUrl();\r\n        beaconURLRegEx = Pattern.compile(Pattern.quote(base + JSAgentModule.BEACON_SUB_PATH), Pattern.CASE_INSENSITIVE);\r\n        StringBuilder modulesRegex = new StringBuilder(\"(\");\r\n        for (JSAgentModule module : JSAgentModule.values()) {\r\n            if (modulesRegex.length() > 1) {\r\n                modulesRegex.append('|');\r\n            }\r\n            modulesRegex.append(Pattern.quote(String.valueOf(module.getIdentifier())));\r\n        }\r\n        modulesRegex.append(\")*\");\r\n        String pattern = Pattern.quote(base + JSAgentModule.JAVASCRIPT_URL_PREFIX) + \"\\\\d+_\" + \"(\" + modulesRegex.toString() + \")\\\\.js\";\r\n        jsAgentURLRegEx = Pattern.compile(pattern, Pattern.CASE_INSENSITIVE);\r\n        scriptTags = new EumScriptTagPrinter();\r\n        StringBuilder beaconPath = new StringBuilder();\r\n        beaconPath.append('\\\"').append(base).append(JSAgentModule.BEACON_SUB_PATH).append('\\\"');\r\n        StringBuilder scriptSrcURL = new StringBuilder();\r\n        scriptSrcURL.append(base).append(JSAgentModule.JAVASCRIPT_URL_PREFIX);\r\n        scriptSrcURL.append(JSAgentModule.JS_AGENT_REVISION).append('_');\r\n        scriptSrcURL.append(configurationStorage.getEndUserMonitoringConfig().getActiveModules());\r\n        scriptSrcURL.append(\".js\");\r\n        scriptTags.setScriptSourceURL(scriptSrcURL.toString());\r\n        scriptTags.setSetting(\"eumManagementServer\", beaconPath.toString());\r\n        scriptTags.setSetting(\"relevancyThreshold\", String.valueOf(endUserMonitoringConfig.getRelevancyThreshold()));\r\n        scriptTags.setSetting(\"allowListenerInstrumentation\", String.valueOf(endUserMonitoringConfig.isListenerInstrumentationAllowed()));\r\n        configurationValid = true;\r\n    } catch (StorageException e) {\r\n        configurationValid = false;\r\n    }\r\n}"
}, {
	"Path": "com.alorma.github.inapp.Security.verifyPurchase",
	"Comment": "verifies that the data was signed with the given signature, and returnsthe verified purchase. the data is in json format and signedwith a private key. the data also contains theand product id of the purchase.",
	"Method": "boolean verifyPurchase(String base64PublicKey,String signedData,String signature){\r\n    if (TextUtils.isEmpty(signedData) || TextUtils.isEmpty(base64PublicKey) || TextUtils.isEmpty(signature)) {\r\n        Log.e(TAG, \"Purchase verification failed: missing data.\");\r\n        return false;\r\n    }\r\n    PublicKey key = Security.generatePublicKey(base64PublicKey);\r\n    return Security.verify(key, signedData, signature);\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.AtomicBuffer.postConstruct",
	"Comment": "is executed after dependency injection is done to perform any initialization.",
	"Method": "void postConstruct(){\r\n    this.maxSize = new AtomicLong(bufferProperties.getInitialBufferSize());\r\n    this.evictionOccupancyPercentage = new AtomicInteger(Float.floatToIntBits(bufferProperties.getEvictionOccupancyPercentage()));\r\n    this.objectSizes.setObjectSecurityExpansionRate(bufferProperties.getObjectSecurityExpansionRate(maxSize.get()));\r\n    this.first = new AtomicReference<IBufferElement<E>>(emptyBufferElement);\r\n    this.last = new AtomicReference<IBufferElement<E>>(emptyBufferElement);\r\n    this.lastAnalyzed = new AtomicReference<IBufferElement<E>>(emptyBufferElement);\r\n    this.lastIndexed = new AtomicReference<IBufferElement<E>>(emptyBufferElement);\r\n    this.indexingTreeCleaningExecutorService = Executors.newFixedThreadPool(bufferProperties.getIndexingTreeCleaningThreads());\r\n    this.flagsSetOnBytes = bufferProperties.getFlagsSetOnBytes(this.maxSize.get());\r\n    this.analyzeProcessor = new AnalyzeBufferElementProcessor(this, lastAnalyzed, analyzeLock, nothingToAnalyze);\r\n    this.indexProcessor = new IndexBufferElementProcessor(this, lastIndexed, indexingLock, nothingToIndex);\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"|-Using buffer with maximum size \" + NumberFormat.getInstance().format(maxSize) + \" bytes...\");\r\n        log.info(\"|-Indexing tree maintenance on \" + NumberFormat.getInstance().format(flagsSetOnBytes) + \" bytes added/removed...\");\r\n        log.info(\"|-Using object expansion rate of \" + NumberFormat.getInstance().format(objectSizes.getObjectSecurityExpansionRate() * 100) + \"%\");\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.util.CharacterRingBuffer.ensureCapacity",
	"Comment": "ensures that the buffer has enough capacity, resizing it if necessary.",
	"Method": "void ensureCapacity(int requiredCapacity){\r\n    int cap = buffer.length;\r\n    if (cap > requiredCapacity) {\r\n        return;\r\n    }\r\n    while (cap <= requiredCapacity) {\r\n        cap *= 2;\r\n    }\r\n    char[] newBuffer = new char[cap];\r\n    if (length > 0) {\r\n        int charsCountA = Math.min(beginOffset + length, buffer.length) - beginOffset;\r\n        int charsCountB = length - charsCountA;\r\n        System.arraycopy(buffer, beginOffset, newBuffer, 0, charsCountA);\r\n        if (charsCountB > 0) {\r\n            System.arraycopy(buffer, 0, newBuffer, charsCountA, charsCountB);\r\n        }\r\n    }\r\n    beginOffset = 0;\r\n    this.buffer = newBuffer;\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.classcache.ClassCacheModification.mergeAnnotationAsInterface",
	"Comment": "merges given annotation when it exist in the structure as interface.",
	"Method": "void mergeAnnotationAsInterface(AnnotationType given,InterfaceType existing,Events events){\r\n    for (ClassType classType : existing.getRealizingClasses()) {\r\n        classType.addInterface(given);\r\n    }\r\n    fireAndSave(new NodeEvent(given, NodeEventType.NEW, NodeEventDetails.INITIALIZED), events);\r\n}"
}, {
	"Path": "org.kohsuke.github.GitHub.isPrivateModeEnabled",
	"Comment": "ensures if a github enterprise server is configured in private mode.",
	"Method": "boolean isPrivateModeEnabled(){\r\n    try {\r\n        HttpURLConnection uc = getConnector().connect(getApiURL(\"/\"));\r\n        try {\r\n            return uc.getResponseCode() == HTTP_UNAUTHORIZED && uc.getHeaderField(\"X-GitHub-Media-Type\") != null;\r\n        } finally {\r\n            try {\r\n                IOUtils.closeQuietly(uc.getInputStream());\r\n            } catch (IOException ignore) {\r\n            }\r\n            IOUtils.closeQuietly(uc.getErrorStream());\r\n        }\r\n    } catch (IOException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.kohsuke.github.GHThread.getBoundPullRequest",
	"Comment": "if this thread is about a pull request, return that pull request.",
	"Method": "GHPullRequest getBoundPullRequest(){\r\n    if (!\"PullRequest\".equals(subject.type))\r\n        return null;\r\n    return repository.getPullRequest(Integer.parseInt(subject.url.substring(subject.url.lastIndexOf('/') + 1)));\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.msg.PriorityQueue.getUniqueness",
	"Comment": "returns a value indicating whether only unique elements are allowed to be inserted.",
	"Method": "boolean getUniqueness(){\r\n    return uniqueness;\r\n}"
}, {
	"Path": "org.hibernate.validator.test.internal.engine.methodvalidation.cascadedgroupvalidation.CascadedMethodLevelValidationGroupSequenceTest.cascadedConstraintViolationInFirstGroupOnly",
	"Comment": "expect a single constraint violation from the first violation group.",
	"Method": "void cascadedConstraintViolationInFirstGroupOnly(){\r\n    setUpValidatorForGroups(CompoundGroup.class);\r\n    try {\r\n        entityRepository.store(new CompoundEntity(new Entity(null, \"value\")));\r\n        fail(\"Expected MethodConstraintViolationException wasn't thrown.\");\r\n    } catch (ConstraintViolationException e) {\r\n        assertThat(e.getConstraintViolations()).containsOnlyViolations(violationOf(NotNull.class).withMessage(\"must not be null\").withInvalidValue(null).withRootBeanClass(CompoundEntityRepositoryImpl.class));\r\n        ConstraintViolation<?> constraintViolation = e.getConstraintViolations().iterator().next();\r\n        assertEquals(constraintViolation.getConstraintDescriptor().getGroups().iterator().next(), ValidationGroup1.class);\r\n    }\r\n}"
}, {
	"Path": "org.kohsuke.github.GHNotificationStream.read",
	"Comment": "should the stream include notifications that are already read?",
	"Method": "GHNotificationStream read(boolean v){\r\n    all = v;\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.jdbc.PreparedStatementParameterHookTest.methodWithBigData",
	"Comment": "tests that the methods with big data structures will not set the complete structure, but a\tsimple marker instead.",
	"Method": "void methodWithBigData(String methodName){\r\n    List<String> parameterTypes = Mockito.mock(List.class);\r\n    Mockito.when(parameterTypes.size()).thenReturn(2);\r\n    Mockito.when(parameterTypes.get(0)).thenReturn(\"int\");\r\n    Mockito.when(rsc.getParameterTypes()).thenReturn(parameterTypes);\r\n    Mockito.when(rsc.getTargetMethodName()).thenReturn(methodName);\r\n    Object[] parameters = new Object[] { 1, \"Value\" };\r\n    Object object = new Object();\r\n    preparedStatementParameterHook.beforeBody(0, 0, object, parameters, rsc);\r\n    preparedStatementParameterHook.firstAfterBody(0, 0, object, parameters, null, false, rsc);\r\n    preparedStatementParameterHook.secondAfterBody(coreService, 0, 0, object, parameters, null, false, rsc);\r\n    String expected = \"[\" + methodName.substring(\"set\".length()) + \"]\";\r\n    Mockito.verify(statementStorage, Mockito.times(1)).addParameter(object, 0, expected);\r\n    Mockito.verifyNoMoreInteractions(statementStorage);\r\n    Mockito.verifyZeroInteractions(coreService);\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.getRef",
	"Comment": "retrive a ref of the given type for the current github repository.",
	"Method": "GHRef getRef(String refName){\r\n    refName = refName.replaceAll(\"#\", \"#\");\r\n    return root.retrieve().to(String.format(\"/repos/%s/%s/git/refs/%s\", getOwnerName(), name, refName), GHRef.class).wrap(root);\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeArrayList.forEach",
	"Comment": "applies predicate to a slice of the list,fromindex, inclusive, to toindex, exclusive, oruntil predicate returns false.",
	"Method": "T forEach(T procedure,T forEach,T procedure,int fromIndex,int toIndex,T forEach,T predicate,T forEach,T predicate,int fromIndex,int toIndex){\r\n    assert (fromIndex >= 0 && fromIndex <= size()) : \"Index \" + fromIndex + \" out of bounds [\" + 0 + \", \" + size() + \").\";\r\n    assert (toIndex >= 0 && toIndex <= size()) : \"Index \" + toIndex + \" out of bounds [\" + 0 + \", \" + size() + \"].\";\r\n    assert fromIndex <= toIndex : \"fromIndex must be <= toIndex: \" + fromIndex + \", \" + toIndex;\r\n    final KType[] buffer = Intrinsics.<KType[]>cast(this.buffer);\r\n    for (int i = fromIndex; i < toIndex; i++) {\r\n        if (!predicate.apply(buffer[i]))\r\n            break;\r\n    }\r\n    return predicate;\r\n}"
}, {
	"Path": "org.influxdb.InfluxDBTest.testWriteMultipleStringDataLinesSimple",
	"Comment": "test writing multiple separate records to the database using string protocol with simpler interface.",
	"Method": "void testWriteMultipleStringDataLinesSimple(){\r\n    String dbName = \"write_unittest_\" + System.currentTimeMillis();\r\n    this.influxDB.createDatabase(dbName);\r\n    String rp = TestUtils.defaultRetentionPolicy(this.influxDB.version());\r\n    this.influxDB.setDatabase(dbName);\r\n    this.influxDB.setRetentionPolicy(rp);\r\n    this.influxDB.write(Arrays.asList(\"cpu,atag=test1 idle=100,usertime=10,system=1\", \"cpu,atag=test2 idle=200,usertime=20,system=2\", \"cpu,atag=test3 idle=300,usertime=30,system=3\"));\r\n    Query query = new Query(\"SELECT * FROM cpu GROUP BY *\", dbName);\r\n    QueryResult result = this.influxDB.query(query);\r\n    Assertions.assertEquals(result.getResults().get(0).getSeries().size(), 3);\r\n    Assertions.assertEquals(\"test1\", result.getResults().get(0).getSeries().get(0).getTags().get(\"atag\"));\r\n    Assertions.assertEquals(\"test2\", result.getResults().get(0).getSeries().get(1).getTags().get(\"atag\"));\r\n    Assertions.assertEquals(\"test3\", result.getResults().get(0).getSeries().get(2).getTags().get(\"atag\"));\r\n    this.influxDB.deleteDatabase(dbName);\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.tests.steer.box2d.Box2dSquareAABBProximity.setDetectionRadius",
	"Comment": "sets the detection radius that is half the side of the square aabb.",
	"Method": "void setDetectionRadius(float detectionRadius){\r\n    this.detectionRadius = detectionRadius;\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.util.AnnotationApiHelper.getMirror",
	"Comment": "returns that mirror from the given list of annotation mirrors that\trepresents the annotation type specified by the given class.",
	"Method": "AnnotationMirror getMirror(List<? extends AnnotationMirror> annotationMirrors,Class<? extends Annotation> annotationClazz,AnnotationMirror getMirror,List<? extends AnnotationMirror> annotationMirrors,String annotationTypeName){\r\n    if (annotationMirrors == null || annotationTypeName == null) {\r\n        return null;\r\n    }\r\n    TypeElement typeElement = elementUtils.getTypeElement(annotationTypeName);\r\n    if (typeElement == null) {\r\n        return null;\r\n    }\r\n    for (AnnotationMirror oneAnnotationMirror : annotationMirrors) {\r\n        if (typeUtils.isSameType(oneAnnotationMirror.getAnnotationType(), typeElement.asType())) {\r\n            return oneAnnotationMirror;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.listAssignees",
	"Comment": "lists all the available assigneesto which issues may be assigned.",
	"Method": "PagedIterable<GHUser> listAssignees(){\r\n    return listUsers(\"assignees\");\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.utils.rays.CentralRayWithWhiskersConfiguration.getWhiskerAngle",
	"Comment": "returns the angle in radians of the whiskers from the central ray.",
	"Method": "float getWhiskerAngle(){\r\n    return whiskerAngle;\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeArrayDeque.clone",
	"Comment": "clone this object. the returned clone will reuse the same hash function andarray resizing strategy.",
	"Method": "KTypeArrayDeque<KType> clone(){\r\n    try {\r\n        @SuppressWarnings(\"unchecked\")\r\n        KTypeArrayDeque<KType> cloned = (KTypeArrayDeque<KType>) super.clone();\r\n        cloned.buffer = buffer.clone();\r\n        return cloned;\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.CMR.checkForCorrectJvmVersion",
	"Comment": "this method checks if the jvm the cmr is started on is compatible.",
	"Method": "void checkForCorrectJvmVersion(){\r\n    String version = System.getProperty(\"java.version\");\r\n    Matcher matcher = Pattern.compile(\"(\\\\d+)\\\\.(\\\\d+)\\\\.(\\\\d+)[_-]u?(\\\\d+)\").matcher(version);\r\n    boolean correctVersion = true;\r\n    if (matcher.find() && (matcher.groupCount() >= 4)) {\r\n        try {\r\n            int majorFirst = Integer.parseInt(matcher.group(1));\r\n            int majorSecond = Integer.parseInt(matcher.group(2));\r\n            int minor = Integer.parseInt(matcher.group(3));\r\n            int update = Integer.parseInt(matcher.group(4));\r\n            if ((majorFirst != 1) || (majorSecond != 8) || (minor != 0)) {\r\n                correctVersion = false;\r\n            }\r\n            if (update < 131) {\r\n                correctVersion = false;\r\n            }\r\n        } catch (NumberFormatException e) {\r\n            correctVersion = false;\r\n        }\r\n    } else {\r\n        correctVersion = false;\r\n    }\r\n    if (!correctVersion) {\r\n        LOGGER.warn(\"ATTENTION: The version of this JVM (\" + version + \") is not compatible with the CMR! Please use the JVM that is provided with the installation!\");\r\n    } else {\r\n        LOGGER.info(\"The version of this JVM (\" + version + \") is compatible with the CMR.\");\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.ClassVisitor.visitExecutableAsMethod",
	"Comment": "checks whether the constraints of the given method are valid.",
	"Method": "Void visitExecutableAsMethod(ExecutableElement element,Void aVoid){\r\n    processClassChecks(element);\r\n    return null;\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.Intrinsics.cast",
	"Comment": "a template cast to the given type t. with type erasure it should workinternally just fine and it simplifies code. the cast will be erased forprimitive types.",
	"Method": "T cast(Object value){\r\n    return (T) value;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.tests.steer.box2d.Box2dSteeringTest.createWorld",
	"Comment": "instantiate a new world with the given gravity and tell it to sleep when possible.",
	"Method": "World createWorld(World createWorld,float y){\r\n    return new World(new Vector2(0, y), true);\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.util.ReflectionHelper.getMappedValue",
	"Comment": "tries to retrieve the mapped value from the specified object.",
	"Method": "Object getMappedValue(Object value,Object key){\r\n    if (!(value instanceof Map)) {\r\n        return null;\r\n    }\r\n    Map<?, ?> map = (Map<?, ?>) value;\r\n    return map.get(key);\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.ValidatorImpl.validateCascadedConstraints",
	"Comment": "validates all cascaded constraints for the given bean using the current group set in the execution context.\tthis method must always be called after validateconstraints for the same context.",
	"Method": "void validateCascadedConstraints(BaseBeanValidationContext<?> validationContext,ValueContext<?, Object> valueContext){\r\n    Validatable validatable = valueContext.getCurrentValidatable();\r\n    ValueContext.ValueState<Object> originalValueState = valueContext.getCurrentValueState();\r\n    for (Cascadable cascadable : validatable.getCascadables()) {\r\n        valueContext.appendNode(cascadable);\r\n        if (isCascadeRequired(validationContext, valueContext.getCurrentBean(), valueContext.getPropertyPath(), cascadable.getConstraintLocationKind())) {\r\n            Object value = getCascadableValue(validationContext, valueContext.getCurrentBean(), cascadable);\r\n            CascadingMetaData cascadingMetaData = cascadable.getCascadingMetaData();\r\n            if (value != null) {\r\n                CascadingMetaData effectiveCascadingMetaData = cascadingMetaData.addRuntimeContainerSupport(valueExtractorManager, value.getClass());\r\n                if (effectiveCascadingMetaData.isCascading()) {\r\n                    validateCascadedAnnotatedObjectForCurrentGroup(value, validationContext, valueContext, effectiveCascadingMetaData);\r\n                }\r\n                if (effectiveCascadingMetaData.isContainer()) {\r\n                    ContainerCascadingMetaData containerCascadingMetaData = effectiveCascadingMetaData.as(ContainerCascadingMetaData.class);\r\n                    if (containerCascadingMetaData.hasContainerElementsMarkedForCascading()) {\r\n                        validateCascadedContainerElementsForCurrentGroup(value, validationContext, valueContext, containerCascadingMetaData.getContainerElementTypesCascadingMetaData());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        valueContext.resetValueState(originalValueState);\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.test.internal.engine.methodvalidation.MethodLevelValidationGroupSequenceTest.processingOfDefaultSequenceStopsAfterFirstErroneousGroup",
	"Comment": "only one constraint violation is expected, as processing should stop after the\tfirst erroneous group of the default sequence.",
	"Method": "void processingOfDefaultSequenceStopsAfterFirstErroneousGroup(){\r\n    try {\r\n        customerRepository.constraintInLaterPartOfDefaultSequence(1);\r\n        fail(\"Expected MethodConstraintViolationException wasn't thrown.\");\r\n    } catch (ConstraintViolationException e) {\r\n        assertThat(e.getConstraintViolations()).containsOnlyViolations(violationOf(Min.class).withMessage(\"must be greater than or equal to 5\").withInvalidValue(1).withRootBeanClass(CustomerRepositoryWithRedefinedDefaultGroupImpl.class));\r\n        ConstraintViolation<?> constraintViolation = e.getConstraintViolations().iterator().next();\r\n        assertEquals(constraintViolation.getConstraintDescriptor().getGroups().iterator().next(), ValidationGroup1.class);\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.classchecks.ClassCheckFactory.getClassChecks",
	"Comment": "provides a collections of checks to be performed on a given element.",
	"Method": "Collection<ClassCheck> getClassChecks(Element element){\r\n    switch(element.getKind()) {\r\n        case METHOD:\r\n            return methodChecks;\r\n        default:\r\n            return Collections.emptySet();\r\n    }\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.TestUtils.reverse",
	"Comment": "reverse the order of elements in an array. returns the array argumentfor easier chaining.",
	"Method": "Object[] reverse(Object[] array,byte[] reverse,byte[] array,char[] reverse,char[] array,short[] reverse,short[] array,int[] reverse,int[] array,float[] reverse,float[] array,double[] reverse,double[] array,long[] reverse,long[] array){\r\n    for (int i = 0, mid = array.length / 2, j = array.length - 1; i < mid; i++, j--) {\r\n        long t = array[i];\r\n        array[i] = array[j];\r\n        array[j] = t;\r\n    }\r\n    return array;\r\n}"
}, {
	"Path": "org.hibernate.validator.test.internal.engine.methodvalidation.cascadedgroupvalidation.CascadedMethodLevelValidationGroupSequenceTest.cascadedConstraintViolationInBothGroups",
	"Comment": "expect a single constraint violation in the first group. the second group should not be\tvalidated due to the violation in the first group.",
	"Method": "void cascadedConstraintViolationInBothGroups(){\r\n    setUpValidatorForGroups(CompoundGroup.class);\r\n    try {\r\n        entityRepository.store(new CompoundEntity(new Entity(null, null)));\r\n        fail(\"Expected MethodConstraintViolationException wasn't thrown.\");\r\n    } catch (ConstraintViolationException e) {\r\n        assertThat(e.getConstraintViolations()).containsOnlyViolations(violationOf(NotNull.class).withMessage(\"must not be null\").withInvalidValue(null).withRootBeanClass(CompoundEntityRepositoryImpl.class));\r\n        ConstraintViolation<?> constraintViolation = e.getConstraintViolations().iterator().next();\r\n        assertEquals(constraintViolation.getConstraintDescriptor().getGroups().iterator().next(), ValidationGroup1.class);\r\n    }\r\n}"
}, {
	"Path": "com.hypertrack.hyperlog.HyperLog.hasPendingDeviceLogs",
	"Comment": "call this method to check whether any device logs are available.",
	"Method": "boolean hasPendingDeviceLogs(){\r\n    if (!isInitialize())\r\n        return false;\r\n    long deviceLogsCount = mDeviceLogList.count();\r\n    return deviceLogsCount > 0L;\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.StorageService.openStorage",
	"Comment": "opens an already existing storage in means that it prepares it for write.",
	"Method": "void openStorage(StorageData storageData){\r\n    if (!storageManager.isStorageExisting(storageData)) {\r\n        throw new BusinessException(\"Open the storage \" + storageData + \".\", StorageErrorCodeEnum.STORAGE_DOES_NOT_EXIST);\r\n    }\r\n    try {\r\n        storageManager.openStorage(storageData);\r\n    } catch (SerializationException e) {\r\n        throw new TechnicalException(\"Open the storage \" + storageData + \".\", StorageErrorCodeEnum.SERIALIZATION_FAILED, e);\r\n    } catch (IOException e) {\r\n        throw new TechnicalException(\"Open the storage \" + storageData + \".\", StorageErrorCodeEnum.INPUT_OUTPUT_OPERATION_FAILED, e);\r\n    }\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeArrayDeque.ensureCapacity",
	"Comment": "ensure this container can hold at least the given number of elementswithout resizing its buffers.",
	"Method": "void ensureCapacity(int expectedElements){\r\n    ensureBufferSpace(expectedElements - size());\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.BitSet.flipAndGet",
	"Comment": "flips a bit and returns the resulting bit value. the index should be less than thebitset size.",
	"Method": "boolean flipAndGet(int index,boolean flipAndGet,long index){\r\n    int wordNum = (int) (index >> 6);\r\n    int bit = (int) index & 0x3f;\r\n    long bitmask = 1L << bit;\r\n    bits[wordNum] ^= bitmask;\r\n    return (bits[wordNum] & bitmask) != 0;\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.ServerStatusService.postConstruct",
	"Comment": "is executed after dependency injection is done to perform any initialization.",
	"Method": "void postConstruct(){\r\n    status = ServerStatus.SERVER_ONLINE;\r\n    status.setRegistrationIdsValidationKey(UUID.randomUUID().toString());\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"|-Server Status Service active...\");\r\n    }\r\n}"
}, {
	"Path": "org.influxdb.InfluxDBTest.testMessagePackOnOldDbVersion",
	"Comment": "test initialize influxdbimpl with messagepack format for influxdb versions before 1.4 will throw exception",
	"Method": "void testMessagePackOnOldDbVersion(){\r\n    Assertions.assertThrows(UnsupportedOperationException.class, () -> {\r\n        InfluxDB influxDB = TestUtils.connectToInfluxDB(ResponseFormat.MSGPACK);\r\n        influxDB.describeDatabases();\r\n    });\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.config.job.AbstractConfigurationChangeJob.processAddedAssignments",
	"Comment": "process the added assignments. new instrumentation points will be added to all the classes in\tthe class cache that fit to the given assignments.",
	"Method": "Collection<ImmutableClassType> processAddedAssignments(Collection<? extends AbstractClassSensorAssignment<?>> classSensorAssignments){\r\n    Collection<ImmutableClassType> changedClassTypes = new ArrayList();\r\n    for (AbstractClassSensorAssignment<?> assignment : classSensorAssignments) {\r\n        Collection<? extends ImmutableClassType> classTypes = classCacheSearchNarrower.narrowByClassSensorAssignment(getClassCache(), assignment);\r\n        IInstrumentationApplier instrumentationApplier = configurationResolver.getInstrumentationApplier(assignment, getEnvironment());\r\n        Collection<? extends ImmutableClassType> instrumentedClassTypes = getClassCache().getInstrumentationService().addInstrumentationPoints(classTypes, getAgentConfiguration(), Collections.singleton(instrumentationApplier));\r\n        changedClassTypes.addAll(instrumentedClassTypes);\r\n    }\r\n    return changedClassTypes;\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageRecorderTest.scheduleRecordingStop",
	"Comment": "test that recording will be stopped if recording duration is set.",
	"Method": "void scheduleRecordingStop(){\r\n    cmrStorageRecorder = spy(cmrStorageRecorder);\r\n    long recordingDuration = 1000L;\r\n    when(recordingProperties.getRecordingDataProcessors()).thenReturn(Collections.singleton(dataProcessor));\r\n    when(recordingProperties.getRecordDuration()).thenReturn(recordingDuration);\r\n    cmrStorageRecorder.startOrScheduleRecording(storageWriter, recordingProperties);\r\n    assertThat(cmrStorageRecorder.isRecordingOn(), is(true));\r\n    assertThat(cmrStorageRecorder.isRecordingScheduled(), is(false));\r\n    ArgumentCaptor<Runnable> captor = ArgumentCaptor.forClass(Runnable.class);\r\n    verify(executorService, times(1)).schedule(captor.capture(), eq(recordingDuration), eq(TimeUnit.MILLISECONDS));\r\n    captor.getValue().run();\r\n    verify(cmrStorageManager, times(1)).stopRecording();\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.RegistrationService.postConstruct",
	"Comment": "is executed after dependency injection is done to perform any initialization.",
	"Method": "void postConstruct(){\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"|-Registration Service active...\");\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.http.HttpInformationExtractor.getRequestUri",
	"Comment": "reads the request uri from the given httpservletrequest object and stores it\twith the given httptimerdata object.",
	"Method": "String getRequestUri(Class<?> httpServletRequestClass,Object httpServletRequest){\r\n    Method m = retrieveMethod(HttpMethods.SERVLET_REQUEST_URI, httpServletRequestClass);\r\n    if (null == m) {\r\n        return HttpInfo.UNDEFINED;\r\n    }\r\n    try {\r\n        String uri = (String) m.invoke(httpServletRequest, (Object[]) null);\r\n        if (null != uri) {\r\n            return uri;\r\n        } else {\r\n            return HttpInfo.UNDEFINED;\r\n        }\r\n    } catch (Exception e) {\r\n        LOG.error(\"Invocation on given object failed.\", e);\r\n        return HttpInfo.UNDEFINED;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.influx.dao.InfluxDBDao.isConnected",
	"Comment": "indicates whether the influxdb service is connected to a running influxdb instance.",
	"Method": "boolean isConnected(){\r\n    return getServiceStatus() == ExternalServiceStatus.CONNECTED;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.spring.SpringConfiguration.registerComponents",
	"Comment": "registers components needed by the configuration to the spring container.",
	"Method": "void registerComponents(IConfigurationStorage configurationStorage){\r\n    String className = configurationStorage.getDisruptorStrategyConfig().getClassName();\r\n    String beanName = \"disruptorStrategy[\" + className + \"]\";\r\n    registerBeanDefinitionAndInitialize(beanName, className);\r\n    for (AbstractSensorTypeConfig platformSensorTypeConfig : configurationStorage.getPlatformSensorTypes()) {\r\n        className = platformSensorTypeConfig.getClassName();\r\n        beanName = \"platformSensorType[\" + className + \"]\";\r\n        registerBeanDefinitionAndInitialize(beanName, className);\r\n    }\r\n    for (JmxSensorTypeConfig jmxSensorTypeConfig : configurationStorage.getJmxSensorTypes()) {\r\n        className = jmxSensorTypeConfig.getClassName();\r\n        beanName = \"jmxSensorType[\" + className + \"]\";\r\n        registerBeanDefinitionAndInitialize(beanName, className);\r\n    }\r\n    for (AbstractSensorTypeConfig methodSensorTypeConfig : configurationStorage.getMethodSensorTypes()) {\r\n        className = methodSensorTypeConfig.getClassName();\r\n        beanName = \"methodSensorType[\" + className + \"]\";\r\n        registerBeanDefinitionAndInitialize(beanName, className);\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.cdi.internal.InheritedMethodsHelper.getAllMethods",
	"Comment": "get a list of all methods which the given class declares, implements,\toverrides or inherits. methods are added by adding first all methods of\tthe class itself and its implemented interfaces, then the super class and\tits interfaces, etc.",
	"Method": "List<Method> getAllMethods(Class<?> clazz){\r\n    Contracts.assertNotNull(clazz);\r\n    List<Method> methods = newArrayList();\r\n    for (Class<?> hierarchyClass : ClassHierarchyHelper.getHierarchy(clazz)) {\r\n        Collections.addAll(methods, run(GetMethods.action(hierarchyClass)));\r\n    }\r\n    return methods;\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth2.AuthorizationCodeTokenRequest.getCode",
	"Comment": "returns the authorization code generated by the authorization server.",
	"Method": "String getCode(){\r\n    return code;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.proxy.CorrectProxySubject.throwException",
	"Comment": "overwrite itnerface mthod with more specific exception and throw it",
	"Method": "void throwException(){\r\n    throw new FileNotFoundException(\"testtext\");\r\n}"
}, {
	"Path": "rocks.inspectit.server.dao.impl.AbstractBufferDataDao.executeQuery",
	"Comment": "executes the query on the indexing tree. results can be sorted by comparator. furthermore the\tresult list can be limited.",
	"Method": "List<E> executeQuery(IIndexQuery indexQuery,boolean useForkJoin,List<E> executeQuery,IIndexQuery indexQuery,IAggregator<E> aggregator,boolean useForkJoin,List<E> executeQuery,IIndexQuery indexQuery,Comparator<? super E> comparator,boolean useForkJoin,List<E> executeQuery,IIndexQuery indexQuery,int limit,boolean useForkJoin,List<E> executeQuery,IIndexQuery indexQuery,IAggregator<E> aggregator,Comparator<? super E> comparator,boolean useForkJoin,List<E> executeQuery,IIndexQuery indexQuery,IAggregator<E> aggregator,int limit,boolean useForkJoin,List<E> executeQuery,IIndexQuery indexQuery,Comparator<? super E> comparator,int limit,boolean useForkJoin,List<E> executeQuery,IIndexQuery indexQuery,IAggregator<E> aggregator,Comparator<? super E> comparator,int limit,boolean useForkJoin){\r\n    List<E> data;\r\n    if (useForkJoin) {\r\n        data = indexingTree.query(indexQuery, forkJoinPool);\r\n    } else {\r\n        data = indexingTree.query(indexQuery);\r\n    }\r\n    if (null != aggregator) {\r\n        AggregationPerformer<E> aggregationPerformer = new AggregationPerformer(aggregator);\r\n        aggregationPerformer.processCollection(data);\r\n        data = aggregationPerformer.getResultList();\r\n    }\r\n    if (null != comparator) {\r\n        Collections.sort(data, comparator);\r\n    }\r\n    if ((limit > -1) && (data.size() > limit)) {\r\n        data = new ArrayList(data.subList(0, limit));\r\n    }\r\n    return data;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHBranch.getProtectionUrl",
	"Comment": "returns api url that deals with the protection of this branch.",
	"Method": "URL getProtectionUrl(){\r\n    return GitHub.parseURL(protection_url);\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.connection.impl.KryoNetConnection.getNetworkInterfaces",
	"Comment": "loads all the network interfaces and transforms the enumeration to the list of strings\tcontaining all addresses.",
	"Method": "List<String> getNetworkInterfaces(){\r\n    Enumeration<NetworkInterface> interfaces = NetworkInterface.getNetworkInterfaces();\r\n    List<String> networkInterfaces = new ArrayList<String>();\r\n    while (interfaces.hasMoreElements()) {\r\n        NetworkInterface networkInterface = interfaces.nextElement();\r\n        Enumeration<InetAddress> addresses = networkInterface.getInetAddresses();\r\n        while (addresses.hasMoreElements()) {\r\n            InetAddress address = addresses.nextElement();\r\n            networkInterfaces.add(address.getHostAddress());\r\n        }\r\n    }\r\n    return networkInterfaces;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.ReachOrientation.getAlignTolerance",
	"Comment": "returns the tolerance for aligning to the target without letting small errors keep the owner swinging.",
	"Method": "float getAlignTolerance(){\r\n    return alignTolerance;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHMyself.listRepositories",
	"Comment": "list repositories of a certain type that are accessible by current authenticated user using the specified page size.",
	"Method": "PagedIterable<GHRepository> listRepositories(PagedIterable<GHRepository> listRepositories,int pageSize,PagedIterable<GHRepository> listRepositories,int pageSize,RepositoryListFilter repoType){\r\n    return new PagedIterable<GHRepository>() {\r\n        public PagedIterator<GHRepository> _iterator(int pageSize) {\r\n            return new PagedIterator<GHRepository>(root.retrieve().with(\"type\", repoType).asIterator(\"/user/repos\", GHRepository[].class, pageSize)) {\r\n                @Override\r\n                protected void wrapUp(GHRepository[] page) {\r\n                    for (GHRepository c : page) c.wrap(root);\r\n                }\r\n            };\r\n        }\r\n    }.withPageSize(pageSize);\r\n}"
}, {
	"Path": "org.kohsuke.github.GHMyself.listRepositories",
	"Comment": "list repositories of a certain type that are accessible by current authenticated user using the specified page size.",
	"Method": "PagedIterable<GHRepository> listRepositories(PagedIterable<GHRepository> listRepositories,int pageSize,PagedIterable<GHRepository> listRepositories,int pageSize,RepositoryListFilter repoType){\r\n    return new PagedIterator<GHRepository>(root.retrieve().with(\"type\", repoType).asIterator(\"/user/repos\", GHRepository[].class, pageSize)) {\r\n        @Override\r\n        protected void wrapUp(GHRepository[] page) {\r\n            for (GHRepository c : page) c.wrap(root);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.kohsuke.github.GHMyself.listRepositories",
	"Comment": "list repositories of a certain type that are accessible by current authenticated user using the specified page size.",
	"Method": "PagedIterable<GHRepository> listRepositories(PagedIterable<GHRepository> listRepositories,int pageSize,PagedIterable<GHRepository> listRepositories,int pageSize,RepositoryListFilter repoType){\r\n    for (GHRepository c : page) c.wrap(root);\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth.AbstractOAuthGetToken.createParameters",
	"Comment": "returns a new instance of the oauth authentication provider. subclasses may override by callingthis super implementation and then adding oauth parameters.",
	"Method": "OAuthParameters createParameters(){\r\n    OAuthParameters result = new OAuthParameters();\r\n    result.consumerKey = consumerKey;\r\n    result.signer = signer;\r\n    return result;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHOrganization.hasPublicMember",
	"Comment": "checks if this organization has the specified user as a public member.",
	"Method": "boolean hasPublicMember(GHUser user){\r\n    try {\r\n        root.retrieve().to(\"/orgs/\" + login + \"/public_members/\" + user.getLogin());\r\n        return true;\r\n    } catch (IOException ignore) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.alorma.github.inapp.IabHelper.startSetup",
	"Comment": "starts the setup process. this will start up the setup process asynchronously.you will be notified through the listener when the setup process is complete.this method is safe to call from a ui thread.",
	"Method": "void startSetup(OnIabSetupFinishedListener listener){\r\n    checkNotDisposed();\r\n    if (mSetupDone)\r\n        throw new IllegalStateException(\"IAB helper is already set up.\");\r\n    logDebug(\"Starting in-app billing setup.\");\r\n    mServiceConn = new ServiceConnection() {\r\n        @Override\r\n        public void onServiceDisconnected(ComponentName name) {\r\n            logDebug(\"Billing service disconnected.\");\r\n            mService = null;\r\n        }\r\n        @Override\r\n        public void onServiceConnected(ComponentName name, IBinder service) {\r\n            if (mDisposed)\r\n                return;\r\n            logDebug(\"Billing service connected.\");\r\n            mService = IInAppBillingService.Stub.asInterface(service);\r\n            String packageName = mContext.getPackageName();\r\n            try {\r\n                logDebug(\"Checking for in-app billing 3 support.\");\r\n                int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);\r\n                if (response != BILLING_RESPONSE_RESULT_OK) {\r\n                    if (listener != null) {\r\n                        listener.onIabSetupFinished(new IabResult(response, \"Error checking for billing v3 support.\"));\r\n                    }\r\n                    mSubscriptionsSupported = false;\r\n                    return;\r\n                }\r\n                logDebug(\"In-app billing version 3 supported for \" + packageName);\r\n                response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);\r\n                if (response == BILLING_RESPONSE_RESULT_OK) {\r\n                    logDebug(\"Subscriptions AVAILABLE.\");\r\n                    mSubscriptionsSupported = true;\r\n                } else {\r\n                    logDebug(\"Subscriptions NOT AVAILABLE. Response: \" + response);\r\n                }\r\n                mSetupDone = true;\r\n            } catch (RemoteException e) {\r\n                if (listener != null) {\r\n                    listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION, \"RemoteException while setting up in-app billing.\"));\r\n                }\r\n                e.printStackTrace();\r\n                return;\r\n            }\r\n            if (listener != null) {\r\n                listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, \"Setup successful.\"));\r\n            }\r\n        }\r\n    };\r\n    Intent serviceIntent = new Intent(\"com.android.vending.billing.InAppBillingService.BIND\");\r\n    serviceIntent.setPackage(\"com.android.vending\");\r\n    if (!mContext.getPackageManager().queryIntentServices(serviceIntent, 0).isEmpty()) {\r\n        mContext.bindService(serviceIntent, mServiceConn, Context.BIND_AUTO_CREATE);\r\n    } else {\r\n        if (listener != null) {\r\n            listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE, \"Billing service unavailable on device.\"));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.alorma.github.inapp.IabHelper.startSetup",
	"Comment": "starts the setup process. this will start up the setup process asynchronously.you will be notified through the listener when the setup process is complete.this method is safe to call from a ui thread.",
	"Method": "void startSetup(OnIabSetupFinishedListener listener){\r\n    logDebug(\"Billing service disconnected.\");\r\n    mService = null;\r\n}"
}, {
	"Path": "com.alorma.github.inapp.IabHelper.startSetup",
	"Comment": "starts the setup process. this will start up the setup process asynchronously.you will be notified through the listener when the setup process is complete.this method is safe to call from a ui thread.",
	"Method": "void startSetup(OnIabSetupFinishedListener listener){\r\n    if (mDisposed)\r\n        return;\r\n    logDebug(\"Billing service connected.\");\r\n    mService = IInAppBillingService.Stub.asInterface(service);\r\n    String packageName = mContext.getPackageName();\r\n    try {\r\n        logDebug(\"Checking for in-app billing 3 support.\");\r\n        int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);\r\n        if (response != BILLING_RESPONSE_RESULT_OK) {\r\n            if (listener != null) {\r\n                listener.onIabSetupFinished(new IabResult(response, \"Error checking for billing v3 support.\"));\r\n            }\r\n            mSubscriptionsSupported = false;\r\n            return;\r\n        }\r\n        logDebug(\"In-app billing version 3 supported for \" + packageName);\r\n        response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);\r\n        if (response == BILLING_RESPONSE_RESULT_OK) {\r\n            logDebug(\"Subscriptions AVAILABLE.\");\r\n            mSubscriptionsSupported = true;\r\n        } else {\r\n            logDebug(\"Subscriptions NOT AVAILABLE. Response: \" + response);\r\n        }\r\n        mSetupDone = true;\r\n    } catch (RemoteException e) {\r\n        if (listener != null) {\r\n            listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION, \"RemoteException while setting up in-app billing.\"));\r\n        }\r\n        e.printStackTrace();\r\n        return;\r\n    }\r\n    if (listener != null) {\r\n        listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, \"Setup successful.\"));\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.ReachOrientation.setAlignTolerance",
	"Comment": "sets the tolerance for aligning to the target without letting small errors keep the owner swinging.",
	"Method": "ReachOrientation<T> setAlignTolerance(float alignTolerance){\r\n    this.alignTolerance = alignTolerance;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Wander.setWanderRate",
	"Comment": "sets the rate, expressed in radian per second, at which the wander orientation can change.",
	"Method": "Wander<T> setWanderRate(float wanderRate){\r\n    this.wanderRate = wanderRate;\r\n    return this;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHCommitQueryBuilder.author",
	"Comment": "github login or email address by which to filter by commit author.",
	"Method": "GHCommitQueryBuilder author(String author){\r\n    req.with(\"author\", author);\r\n    return this;\r\n}"
}, {
	"Path": "org.kohsuke.github.Requester.to",
	"Comment": "sends a request to the specified url, and parses the response into the given type via databinding.",
	"Method": "void to(String tailApiUrl,T to,String tailApiUrl,Class<T> type,T to,String tailApiUrl,T existingInstance,T to,String tailApiUrl,Class<T> type,String method){\r\n    return method(method).to(tailApiUrl, type);\r\n}"
}, {
	"Path": "com.alorma.github.presenter.BaseRxPresenter.executePaginated",
	"Comment": "executes paginated request, automagically assigns next page if is requested more than one time.",
	"Method": "void executePaginated(REQUEST request){\r\n    if (!isViewAttached() || page == null || page <= 0)\r\n        return;\r\n    SdkItem<REQUEST> sdkItem = new SdkItem(request);\r\n    sdkItem.setPage(page);\r\n    subscribe(genericRepository.execute(sdkItem), true);\r\n}"
}, {
	"Path": "org.kohsuke.github.GHUser.isPublicMemberOf",
	"Comment": "returns true if this user belongs to the specified organization as a public member.",
	"Method": "boolean isPublicMemberOf(GHOrganization org){\r\n    return org.hasPublicMember(this);\r\n}"
}, {
	"Path": "org.influxdb.InfluxDBTest.testWriteMultipleStringDataLines",
	"Comment": "test writing multiple separate records to the database using string protocol.",
	"Method": "void testWriteMultipleStringDataLines(){\r\n    String dbName = \"write_unittest_\" + System.currentTimeMillis();\r\n    this.influxDB.createDatabase(dbName);\r\n    String rp = TestUtils.defaultRetentionPolicy(this.influxDB.version());\r\n    this.influxDB.write(dbName, rp, InfluxDB.ConsistencyLevel.ONE, Arrays.asList(\"cpu,atag=test1 idle=100,usertime=10,system=1\", \"cpu,atag=test2 idle=200,usertime=20,system=2\", \"cpu,atag=test3 idle=300,usertime=30,system=3\"));\r\n    Query query = new Query(\"SELECT * FROM cpu GROUP BY *\", dbName);\r\n    QueryResult result = this.influxDB.query(query);\r\n    Assertions.assertEquals(result.getResults().get(0).getSeries().size(), 3);\r\n    Assertions.assertEquals(\"test1\", result.getResults().get(0).getSeries().get(0).getTags().get(\"atag\"));\r\n    Assertions.assertEquals(\"test2\", result.getResults().get(0).getSeries().get(1).getTags().get(\"atag\"));\r\n    Assertions.assertEquals(\"test3\", result.getResults().get(0).getSeries().get(2).getTags().get(\"atag\"));\r\n    this.influxDB.deleteDatabase(dbName);\r\n}"
}, {
	"Path": "rocks.inspectit.server.ci.ConfigurationInterfaceManager.importProfile",
	"Comment": "imports the profile. note that if profile with the same id already exists it will be\toverwritten.",
	"Method": "Profile importProfile(Profile profile){\r\n    if (null == profile.getId()) {\r\n        throw new BusinessException(\"Import the profile '\" + profile.getName() + \"'.\", ConfigurationInterfaceErrorCodeEnum.IMPORT_DATA_NOT_VALID);\r\n    }\r\n    profile.setImportDate(new Date());\r\n    if (existingProfiles.containsKey(profile.getId())) {\r\n        Profile old = existingProfiles.replace(profile.getId(), profile);\r\n        Files.deleteIfExists(pathResolver.getProfileFilePath(old));\r\n    } else {\r\n        existingProfiles.put(profile.getId(), profile);\r\n    }\r\n    saveProfile(profile);\r\n    return profile;\r\n}"
}, {
	"Path": "com.firebase.geofire.GeoFire.getLocation",
	"Comment": "gets the current location for a key and calls the callback with the current value.",
	"Method": "void getLocation(String key,LocationCallback callback){\r\n    DatabaseReference keyRef = this.getDatabaseRefForKey(key);\r\n    LocationValueEventListener valueListener = new LocationValueEventListener(callback);\r\n    keyRef.addListenerForSingleValueEvent(valueListener);\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.http.HttpInformationExtractor.getParameterMap",
	"Comment": "reads all request parameters from the given httpservletrequest object and stores\tthem with the given httptimerdata object.",
	"Method": "Map<String, String[]> getParameterMap(Class<?> httpServletRequestClass,Object httpServletRequest){\r\n    Method m = retrieveMethod(HttpMethods.SERVLET_GET_PARAMETER_MAP, httpServletRequestClass);\r\n    if (null == m) {\r\n        return null;\r\n    }\r\n    try {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Map<String, String[]> parameterMap = (Map<String, String[]>) m.invoke(httpServletRequest, (Object[]) null);\r\n        if ((null == parameterMap) || parameterMap.isEmpty()) {\r\n            return null;\r\n        }\r\n        return strConstraint.crop(parameterMap);\r\n    } catch (Exception e) {\r\n        LOG.error(\"Invocation on given object failed.\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.influxdb.UDPInfluxDBTest.testWriteMultipleStringDataLinesThroughUDP",
	"Comment": "test writing multiple separate records to the database using stringprotocol through udp.",
	"Method": "void testWriteMultipleStringDataLinesThroughUDP(){\r\n    String measurement = TestUtils.getRandomMeasurement();\r\n    this.influxDB.write(UDP_PORT, Arrays.asList(measurement + \",atag=test1 idle=100,usertime=10,system=1\", measurement + \",atag=test2 idle=200,usertime=20,system=2\", measurement + \",atag=test3 idle=300,usertime=30,system=3\"));\r\n    Thread.sleep(2000);\r\n    Query query = new Query(\"SELECT * FROM \" + measurement + \" GROUP BY *\", UDP_DATABASE);\r\n    QueryResult result = this.influxDB.query(query);\r\n    Assertions.assertEquals(3, result.getResults().get(0).getSeries().size());\r\n    Assertions.assertEquals(\"test1\", result.getResults().get(0).getSeries().get(0).getTags().get(\"atag\"));\r\n    Assertions.assertEquals(\"test2\", result.getResults().get(0).getSeries().get(1).getTags().get(\"atag\"));\r\n    Assertions.assertEquals(\"test3\", result.getResults().get(0).getSeries().get(2).getTags().get(\"atag\"));\r\n}"
}, {
	"Path": "rocks.inspectit.server.ci.ConfigurationInterfaceManager.importEnvironment",
	"Comment": "imports the environment. note that if environment with the same id already exists it will be\toverwritten.",
	"Method": "Environment importEnvironment(Environment environment){\r\n    if (null == environment.getId()) {\r\n        throw new BusinessException(\"Import the environment '\" + environment.getName() + \"'.\", ConfigurationInterfaceErrorCodeEnum.IMPORT_DATA_NOT_VALID);\r\n    }\r\n    environment.setImportDate(new Date());\r\n    if (existingEnvironments.containsKey(environment.getId())) {\r\n        Environment old = existingEnvironments.replace(environment.getId(), environment);\r\n        Files.deleteIfExists(pathResolver.getEnvironmentFilePath(old));\r\n    } else {\r\n        existingEnvironments.put(environment.getId(), environment);\r\n    }\r\n    checkProfiles(environment);\r\n    saveEnvironment(environment);\r\n    return environment;\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.config.ConfigurationCreator.environmentToConfiguration",
	"Comment": "returns proper configuration for the agent with the correctly set ids for the agent and\tsensors.",
	"Method": "AgentConfig environmentToConfiguration(Environment environment,long platformId){\r\n    AgentConfig agentConfiguration = new AgentConfig();\r\n    agentConfiguration.setPlatformId(platformId);\r\n    if (CollectionUtils.isNotEmpty(environment.getPlatformSensorConfigs())) {\r\n        Collection<PlatformSensorTypeConfig> platformSensorTypeConfigs = new ArrayList();\r\n        for (IPlatformSensorConfig platformSensorConfig : environment.getPlatformSensorConfigs()) {\r\n            if (platformSensorConfig.isActive()) {\r\n                platformSensorTypeConfigs.add(getPlatformSensorTypeConfig(platformId, platformSensorConfig));\r\n            }\r\n        }\r\n        agentConfiguration.setPlatformSensorTypeConfigs(platformSensorTypeConfigs);\r\n    } else {\r\n        agentConfiguration.setPlatformSensorTypeConfigs(Collections.<PlatformSensorTypeConfig>emptyList());\r\n    }\r\n    if (CollectionUtils.isNotEmpty(environment.getMethodSensorConfigs())) {\r\n        Collection<MethodSensorTypeConfig> methodSensorTypeConfigs = new ArrayList();\r\n        for (IMethodSensorConfig methodSensorConfig : environment.getMethodSensorConfigs()) {\r\n            methodSensorTypeConfigs.add(getMethodSensorTypeConfig(platformId, methodSensorConfig));\r\n        }\r\n        agentConfiguration.setMethodSensorTypeConfigs(methodSensorTypeConfigs);\r\n    } else {\r\n        agentConfiguration.setMethodSensorTypeConfigs(Collections.<MethodSensorTypeConfig>emptyList());\r\n    }\r\n    IExceptionSensorConfig exceptionSensorConfig = environment.getExceptionSensorConfig();\r\n    if (null != exceptionSensorConfig) {\r\n        agentConfiguration.setExceptionSensorTypeConfig(getExceptionSensorTypeConfig(platformId, exceptionSensorConfig));\r\n    }\r\n    JmxSensorConfig jmxSensorConfig = environment.getJmxSensorConfig();\r\n    if ((null != jmxSensorConfig) && jmxSensorConfig.isActive()) {\r\n        agentConfiguration.setJmxSensorTypeConfig(getJmxSensorTypeConfig(platformId, jmxSensorConfig));\r\n    }\r\n    EndUserMonitoringConfig eumConf = environment.getEumConfig();\r\n    agentConfiguration.setEumConfig(new AgentEndUserMonitoringConfig(eumConf.isEumEnabled(), eumConf.getScriptBaseUrl(), eumConf.getActiveModules(), eumConf.getRelevancyThreshold(), eumConf.isListenerInstrumentationAllowed(), eumConf.isAgentMinificationEnabled()));\r\n    Collection<MethodSensorTypeConfig> specialMethodSensorTypeConfigs = new ArrayList(0);\r\n    if (environment.isClassLoadingDelegation()) {\r\n        specialMethodSensorTypeConfigs.add(getMethodSensorTypeConfig(platformId, ClassLoadingDelegationSensorConfig.INSTANCE));\r\n    }\r\n    if ((null != jmxSensorConfig) && jmxSensorConfig.isActive()) {\r\n        specialMethodSensorTypeConfigs.add(getMethodSensorTypeConfig(platformId, MBeanServerInterceptorSensorConfig.INSTANCE));\r\n    }\r\n    if (eumConf.isEumEnabled()) {\r\n        specialMethodSensorTypeConfigs.add(getMethodSensorTypeConfig(platformId, EUMInstrumentationSensorConfig.INSTANCE));\r\n    }\r\n    specialMethodSensorTypeConfigs.add(getMethodSensorTypeConfig(platformId, ExecutorIntercepterSensorConfig.INSTANCE));\r\n    specialMethodSensorTypeConfigs.add(getMethodSensorTypeConfig(platformId, CloseableHttpAsyncClientSensorConfig.INSTANCE));\r\n    agentConfiguration.setSpecialMethodSensorTypeConfigs(specialMethodSensorTypeConfigs);\r\n    IStrategyConfig disruptorStrategyConfig = environment.getDisruptorStrategyConfig();\r\n    agentConfiguration.setDisruptorStrategyConfig(new StrategyConfig(disruptorStrategyConfig.getClassName(), disruptorStrategyConfig.getSettings()));\r\n    agentConfiguration.setRetransformationStrategy(environment.getRetransformationStrategy());\r\n    Collection<ExcludeRule> excludeRules = configurationResolver.getAllExcludeRules(environment);\r\n    if (CollectionUtils.isNotEmpty(excludeRules)) {\r\n        Collection<IMatchPattern> excludeClassesPatterns = new ArrayList();\r\n        for (ExcludeRule excludeRule : excludeRules) {\r\n            excludeClassesPatterns.add(PatternFactory.getPattern(excludeRule.getClassName()));\r\n        }\r\n        agentConfiguration.setExcludeClassesPatterns(excludeClassesPatterns);\r\n    } else {\r\n        agentConfiguration.setExcludeClassesPatterns(Collections.<IMatchPattern>emptyList());\r\n    }\r\n    agentConfiguration.setConfigurationInfo(configurationResolver.getConfigurationInfo(environment));\r\n    return agentConfiguration;\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.AbstractObjectSizes.getMapCapacityFromSize",
	"Comment": "returns the capacity of the hashmap from it size. the calculations take the default capacity\tof 16 and default load factor of 0.75.",
	"Method": "int getMapCapacityFromSize(int hashMapSize,int initialCapacity){\r\n    if (hashMapSize == 0) {\r\n        return 0;\r\n    }\r\n    int capacity = 1;\r\n    if (initialCapacity > 0) {\r\n        capacity = initialCapacity;\r\n    }\r\n    float loadFactor = 0.75f;\r\n    int threshold = (int) (capacity * loadFactor);\r\n    while (threshold < hashMapSize) {\r\n        capacity *= 2;\r\n        threshold = (int) (capacity * loadFactor);\r\n    }\r\n    return capacity;\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageRecorderTest.scheduleRecording",
	"Comment": "tests that the recording will be scheduled if start delay is specified.",
	"Method": "void scheduleRecording(){\r\n    cmrStorageRecorder = spy(cmrStorageRecorder);\r\n    long recordingDelay = 1000L;\r\n    when(recordingProperties.getRecordingDataProcessors()).thenReturn(Collections.singleton(dataProcessor));\r\n    when(recordingProperties.getStartDelay()).thenReturn(recordingDelay);\r\n    cmrStorageRecorder.startOrScheduleRecording(storageWriter, recordingProperties);\r\n    assertThat(cmrStorageRecorder.isRecordingOn(), is(false));\r\n    assertThat(cmrStorageRecorder.isRecordingScheduled(), is(true));\r\n    ArgumentCaptor<Runnable> captor = ArgumentCaptor.forClass(Runnable.class);\r\n    verify(executorService, times(1)).schedule(captor.capture(), eq(recordingDelay), eq(TimeUnit.MILLISECONDS));\r\n}"
}, {
	"Path": "org.hibernate.validator.integration.wildfly.jpa.CustomValidatorFactoryInPersistenceUnitIT.testValidatorFactoryPassedToPersistenceUnitIsContributedFromPortableExtensionOfCurrentModuleZip",
	"Comment": "todo how to make that work reliably also after a hv upgrade within wf?",
	"Method": "void testValidatorFactoryPassedToPersistenceUnitIsContributedFromPortableExtensionOfCurrentModuleZip(){\r\n    log.debug(\"Running testValidatorFactoryPassedToPersistenceUnitIsContributedFromPortableExtensionOfCurrentModuleZip...\");\r\n    try {\r\n        magicianService.storeWand();\r\n        fail(\"Expected exception wasn't raised\");\r\n    } catch (Exception e) {\r\n        Throwable rootException = getRootException(e);\r\n        assertThat(rootException).isExactlyInstanceOf(ConstraintViolationException.class);\r\n        ConstraintViolationException constraintViolationException = (ConstraintViolationException) rootException;\r\n        assertThat(constraintViolationException.getConstraintViolations()).hasSize(1);\r\n        assertThat(constraintViolationException.getConstraintViolations().iterator().next().getMessage()).isEqualTo(\"size must be between 5 and 2147483647\");\r\n    }\r\n    log.debug(\"testValidatorFactoryPassedToPersistenceUnitIsContributedFromPortableExtensionOfCurrentModuleZip completed\");\r\n}"
}, {
	"Path": "com.alorma.github.ui.view.CircularImageView.setSelectorColor",
	"Comment": "sets the color of the selector to be draw over thecircularimageview. be sure to provide some opacity.",
	"Method": "void setSelectorColor(int selectorColor){\r\n    this.selectorFilter = new PorterDuffColorFilter(selectorColor, PorterDuff.Mode.SRC_ATOP);\r\n    this.invalidate();\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Flee.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum linear acceleration.",
	"Method": "Flee<T> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.server.template.EMailTemplateResolver.createPropertiesMap",
	"Comment": "creates a map containing available values which are used to replace corresponding\tplaceholder.",
	"Method": "Map<String, String> createPropertiesMap(AlertingState alertingState,boolean isText){\r\n    if (alertingState == null) {\r\n        throw new IllegalArgumentException(\"The given alerting state may not be null.\");\r\n    }\r\n    Map<String, String> properties = new HashMap();\r\n    NumberFormat numberFormat = new DecimalFormat(NUMBER_FORMAT);\r\n    SimpleDateFormat dateFormat = new SimpleDateFormat(DATE_FORMAT);\r\n    Alert alert = alertingState.getAlert();\r\n    AlertingDefinition definition = alertingState.getAlertingDefinition();\r\n    properties.put(Placeholders.ALERT_DEFINITION_NAME, definition.getName());\r\n    properties.put(Placeholders.MEASUREMENT, definition.getMeasurement());\r\n    properties.put(Placeholders.FIELD, definition.getField());\r\n    properties.put(Placeholders.THRESHOLD, numberFormat.format(definition.getThreshold()));\r\n    properties.put(Placeholders.THRESHOLD_TYPE, definition.getThresholdType().getName());\r\n    properties.put(Placeholders.START_TIME, String.valueOf(dateFormat.format(new Date(alert.getStartTimestamp()))));\r\n    properties.put(Placeholders.VIOLATION_VALUE, numberFormat.format(alertingState.getExtremeValue()));\r\n    properties.put(Placeholders.CURRENT_TIME, String.valueOf(new Date(System.currentTimeMillis())));\r\n    properties.put(Placeholders.ALERT_ID, alert.getId());\r\n    properties.put(Placeholders.EXTREME_VALUE, numberFormat.format(alertingState.getExtremeValue()));\r\n    if (AlertingUtils.isBusinessTransactionAlert(definition)) {\r\n        String applicationName = AlertingUtils.retrieveApplicaitonName(definition);\r\n        if (null == applicationName) {\r\n            applicationName = \"All\";\r\n        }\r\n        properties.put(AlertEMailTemplateType.Placeholders.APPLICATION_NAME, applicationName);\r\n        String businessTxName = AlertingUtils.retrieveBusinessTransactionName(definition);\r\n        if (null == businessTxName) {\r\n            businessTxName = \"All\";\r\n        }\r\n        properties.put(AlertEMailTemplateType.Placeholders.BUSINESS_TX_NAME, businessTxName);\r\n    }\r\n    if (alert.getStopTimestamp() > 0) {\r\n        properties.put(AlertEMailTemplateType.Placeholders.END_TIME, dateFormat.format(new Date(alert.getStopTimestamp())));\r\n        properties.put(AlertEMailTemplateType.Placeholders.CLOSING_REASON, alert.getClosingReason().toString());\r\n    }\r\n    if (isText) {\r\n        properties.put(Placeholders.TAGS, convertTagsToTextProperty(definition.getTags()));\r\n    } else {\r\n        properties.put(Placeholders.TAGS, convertTagsToHtmlTextProperty(definition.getTags()));\r\n    }\r\n    return properties;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.RaycastObstacleAvoidance.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum linear acceleration.",
	"Method": "RaycastObstacleAvoidance<T> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.html.CharSequenceUtils.checkEqualIgnoreCase",
	"Comment": "performs a case insensitive comparison of the given substrings.",
	"Method": "boolean checkEqualIgnoreCase(CharSequence a,int offsetA,int lenA,CharSequence b,int offsetB,int lenB,boolean checkEqualIgnoreCase,CharSequence a,CharSequence b){\r\n    return checkEqualIgnoreCase(a, 0, a.length(), b, 0, b.length());\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.pfa.PathFinderRequestControl.execute",
	"Comment": "executes the given pathfinding request resuming it if needed.",
	"Method": "boolean execute(PathFinderRequest<N> request){\r\n    request.executionFrames++;\r\n    while (true) {\r\n        if (DEBUG)\r\n            GdxAI.getLogger().debug(TAG, \"------\");\r\n        if (request.status == PathFinderRequest.SEARCH_NEW) {\r\n            long currentTime = TimeUtils.nanoTime();\r\n            timeToRun -= currentTime - lastTime;\r\n            if (timeToRun <= timeTolerance)\r\n                return false;\r\n            if (DEBUG)\r\n                GdxAI.getLogger().debug(TAG, \"search begin\");\r\n            if (!request.initializeSearch(timeToRun))\r\n                return false;\r\n            request.changeStatus(PathFinderRequest.SEARCH_INITIALIZED);\r\n            lastTime = currentTime;\r\n        }\r\n        if (request.status == PathFinderRequest.SEARCH_INITIALIZED) {\r\n            long currentTime = TimeUtils.nanoTime();\r\n            timeToRun -= currentTime - lastTime;\r\n            if (timeToRun <= timeTolerance)\r\n                return false;\r\n            if (DEBUG)\r\n                GdxAI.getLogger().debug(TAG, \"search path\");\r\n            if (!request.search(pathFinder, timeToRun))\r\n                return false;\r\n            request.changeStatus(PathFinderRequest.SEARCH_DONE);\r\n            lastTime = currentTime;\r\n        }\r\n        if (request.status == PathFinderRequest.SEARCH_DONE) {\r\n            long currentTime = TimeUtils.nanoTime();\r\n            timeToRun -= currentTime - lastTime;\r\n            if (timeToRun <= timeTolerance)\r\n                return false;\r\n            if (DEBUG)\r\n                GdxAI.getLogger().debug(TAG, \"search end\");\r\n            if (!request.finalizeSearch(timeToRun))\r\n                return false;\r\n            request.changeStatus(PathFinderRequest.SEARCH_FINALIZED);\r\n            if (server != null) {\r\n                MessageDispatcher dispatcher = request.dispatcher != null ? request.dispatcher : MessageManager.getInstance();\r\n                dispatcher.dispatchMessage(server, request.client, request.responseMessageCode, request);\r\n            }\r\n            lastTime = currentTime;\r\n            if (request.statusChanged && request.status == PathFinderRequest.SEARCH_NEW) {\r\n                if (DEBUG)\r\n                    GdxAI.getLogger().debug(TAG, \"search renew\");\r\n                continue;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.jmx.JmxSensor.collectData",
	"Comment": "collects the data from the mbean server in the holder and sends it to the cmr.",
	"Method": "void collectData(MBeanServerHolder holder,ICoreService coreService,long sensorTypeIdent){\r\n    MBeanServer mBeanServer = holder.mBeanServer;\r\n    Map<JmxAttributeDescriptor, Boolean> activeAttributes = holder.activeAttributes;\r\n    Map<String, ObjectName> nameStringToObjectName = holder.nameStringToObjectName;\r\n    Timestamp timestamp = new Timestamp(Calendar.getInstance().getTime().getTime());\r\n    for (Iterator<JmxAttributeDescriptor> iterator = activeAttributes.keySet().iterator(); iterator.hasNext(); ) {\r\n        JmxAttributeDescriptor descriptor = iterator.next();\r\n        try {\r\n            ObjectName objectName = nameStringToObjectName.get(descriptor.getmBeanObjectName());\r\n            Object collectedValue = mBeanServer.getAttribute(objectName, descriptor.getAttributeName());\r\n            String value;\r\n            if (null == collectedValue) {\r\n                value = \"null\";\r\n            } else if (collectedValue.getClass().isArray()) {\r\n                value = getArrayValue(collectedValue);\r\n            } else {\r\n                value = collectedValue.toString();\r\n            }\r\n            long platformid = platformManager.getPlatformId();\r\n            JmxSensorValueData jsvd = new JmxSensorValueData(descriptor.getId(), value, timestamp, platformid, sensorTypeIdent);\r\n            coreService.addDefaultData(jsvd);\r\n        } catch (Exception e) {\r\n            iterator.remove();\r\n            log.warn(\"JMX::Exception. An exception has been thrown during attempt to fetch the attribute \" + descriptor.getAttributeName() + \" from the MBean \" + descriptor.getmBeanObjectName() + \". Attribute removed from the actively read list.\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.processor.impl.CmrDataProcessorsTest.invocationProcessorNotCreatedExceptionData",
	"Comment": "when we have not created exception event in exception object.",
	"Method": "void invocationProcessorNotCreatedExceptionData(){\r\n    InvocationModifierCmrProcessor processor = new InvocationModifierCmrProcessor(Collections.singletonList(chainedProcessor));\r\n    ExceptionMessageCmrProcessor exceptionMessageCmrProcessor = mock(ExceptionMessageCmrProcessor.class);\r\n    processor.exceptionMessageCmrProcessor = exceptionMessageCmrProcessor;\r\n    InvocationSequenceData parent = new InvocationSequenceData();\r\n    parent.setId(10L);\r\n    InvocationSequenceData child = new InvocationSequenceData();\r\n    child.setId(20L);\r\n    ExceptionSensorData exceptionSensorData = new ExceptionSensorData();\r\n    exceptionSensorData.setExceptionEvent(ExceptionEvent.PASSED);\r\n    exceptionSensorData.setThrowableIdentityHashCode(1L);\r\n    child.setExceptionSensorDataObjects(Collections.singletonList(exceptionSensorData));\r\n    child.setParentSequence(parent);\r\n    parent.setNestedSequences(Collections.singletonList(child));\r\n    processor.process(parent, entityManager);\r\n    verify(chainedProcessor, times(1)).process(child, entityManager);\r\n    verify(chainedProcessor, times(0)).process(exceptionSensorData, entityManager);\r\n    verify(exceptionMessageCmrProcessor, times(0)).process(exceptionSensorData, entityManager);\r\n    verifyNoMoreInteractions(chainedProcessor, exceptionMessageCmrProcessor);\r\n    verifyZeroInteractions(entityManager);\r\n    assertThat(parent.isNestedExceptions(), is(nullValue()));\r\n    assertThat(exceptionSensorData.isOnlyFoundInInvocations(), is(false));\r\n    assertThat(exceptionSensorData.getInvocationParentsIdSet(), is(empty()));\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.rest.CmrRestfulService.handleAllException",
	"Comment": "handling of all the exceptions happening in this controller.",
	"Method": "ModelAndView handleAllException(Exception exception){\r\n    return new JsonError(exception).asModelAndView();\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.printStorageCmrVersionWarn",
	"Comment": "prints the warnings if the cmr version saved in the storage does not exists or is different\tfrom the current cmr version.",
	"Method": "void printStorageCmrVersionWarn(IStorageData storageData){\r\n    if (null == storageData.getCmrVersion()) {\r\n        log.warn(\"The storage \" + storageData + \" does not define the CMR version. The storage might be unstable on the CMR version \" + cmrVersion + \".\");\r\n    } else if (!Objects.equals(storageData.getCmrVersion(), cmrVersion)) {\r\n        log.warn(\"The storage \" + storageData + \" has different CMR version (\" + storageData.getCmrVersion() + \") than the current CMR version(\" + cmrVersion + \"). The storage might be unstable.\");\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageRecorder.startOrScheduleRecording",
	"Comment": "starts or schedules the recording. if the recording properties define the start date that is\tafter current time, recording will be scheduled. otherwise it is started right away.",
	"Method": "void startOrScheduleRecording(StorageWriter stWriter,RecordingProperties recProperties){\r\n    if (!isRecordingOn() && !isRecordingScheduled()) {\r\n        if (null == stWriter) {\r\n            throw new IllegalArgumentException(\"Storage writer can not be null. Recording will not be started.\");\r\n        } else if (!stWriter.isWritingOn()) {\r\n            throw new IllegalArgumentException(\"Storage writer must be prepared for write. Recording will not be started.\");\r\n        } else if (null == recProperties) {\r\n            throw new IllegalArgumentException(\"Recording properties can not be null. Recording will not be started.\");\r\n        } else if (CollectionUtils.isEmpty(recProperties.getRecordingDataProcessors())) {\r\n            throw new IllegalArgumentException(\"Recording data processor must be provided for recording.\");\r\n        }\r\n        storageWriter = stWriter;\r\n        recordingProperties = recProperties;\r\n        long startDelay = recProperties.getStartDelay();\r\n        if (startDelay > 0) {\r\n            recordingState = RecordingState.SCHEDULED;\r\n            Runnable startRecordingRunnable = new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    CmrStorageRecorder.this.startRecording(storageWriter, recordingProperties);\r\n                }\r\n            };\r\n            startRecordingFuture = executorService.schedule(startRecordingRunnable, startDelay, TimeUnit.MILLISECONDS);\r\n            Date recordStartDate = new Date(System.currentTimeMillis() + startDelay);\r\n            recordingProperties.setRecordStartDate(recordStartDate);\r\n        } else {\r\n            startRecording(storageWriter, recordingProperties);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageRecorder.startOrScheduleRecording",
	"Comment": "starts or schedules the recording. if the recording properties define the start date that is\tafter current time, recording will be scheduled. otherwise it is started right away.",
	"Method": "void startOrScheduleRecording(StorageWriter stWriter,RecordingProperties recProperties){\r\n    CmrStorageRecorder.this.startRecording(storageWriter, recordingProperties);\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.SteeringAcceleration.add",
	"Comment": "adds the given steering acceleration to this steering acceleration.",
	"Method": "SteeringAcceleration<T> add(SteeringAcceleration<T> steering){\r\n    linear.add(steering.linear);\r\n    angular += steering.angular;\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.server.messaging.AgentMessageProvider.clear",
	"Comment": "removes all available messages of the agent with the given id.",
	"Method": "void clear(long platformId){\r\n    List<IAgentMessage<?>> messages = agentMessageMap.get(platformId);\r\n    if (CollectionUtils.isNotEmpty(messages)) {\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Clearing messages of agent {}.\", platformId);\r\n        }\r\n        messages.clear();\r\n    }\r\n}"
}, {
	"Path": "com.alorma.github.ui.view.CircularImageView.refreshBitmapShader",
	"Comment": "reinitializes the shader texture used to fill inthe circle upon drawing.",
	"Method": "void refreshBitmapShader(){\r\n    shader = new BitmapShader(Bitmap.createScaledBitmap(image, canvasSize, canvasSize, false), Shader.TileMode.CLAMP, Shader.TileMode.CLAMP);\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.reflection.CachedConstructor.newInstanceSafe",
	"Comment": "invokes the constructor in the given classloader context. catches any occurring exceptions.",
	"Method": "Object newInstanceSafe(ClassLoader env,Object parameters){\r\n    try {\r\n        return newInstance(env, parameters);\r\n    } catch (Exception e) {\r\n        LOG.error(\"Exception invoking constructor on \" + className + \": \" + e.getClass());\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.instrumentation.asm.AsmUtil.getAsmInternalName",
	"Comment": "returns asm internal name of the class giving the class fqn.",
	"Method": "String getAsmInternalName(String fqn){\r\n    return fqn.replace('.', '/');\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.BufferProperties.getObjectSecurityExpansionRateBufferSize",
	"Comment": "returns object security expansion rate based on the property set and given buffer size.",
	"Method": "float getObjectSecurityExpansionRateBufferSize(long bufferSize){\r\n    if (bufferSize > minObjectExpansionRateActiveFromBufferSize) {\r\n        return minObjectExpansionRate;\r\n    } else if (bufferSize < maxObjectExpansionRateActiveTillBufferSize) {\r\n        return maxObjectExpansionRate;\r\n    } else {\r\n        float delta = (maxObjectExpansionRate - minObjectExpansionRate) * ((float) (bufferSize - maxObjectExpansionRateActiveTillBufferSize) / (minObjectExpansionRateActiveFromBufferSize - maxObjectExpansionRateActiveTillBufferSize));\r\n        return maxObjectExpansionRate - delta;\r\n    }\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeArrayList.ensureBufferSpace",
	"Comment": "ensures the internal buffer has enough free slots to storeexpectedadditions. increases internal buffer size if needed.",
	"Method": "void ensureBufferSpace(int expectedAdditions){\r\n    final int bufferLen = (buffer == null ? 0 : buffer.length);\r\n    if (elementsCount + expectedAdditions > bufferLen) {\r\n        final int newSize = resizer.grow(bufferLen, elementsCount, expectedAdditions);\r\n        assert newSize >= elementsCount + expectedAdditions : \"Resizer failed to\" + \" return sensible new size: \" + newSize + \" <= \" + (elementsCount + expectedAdditions);\r\n        this.buffer = Arrays.copyOf(buffer, newSize);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.btree.decorator.SemaphoreGuard.start",
	"Comment": "acquires the semaphore. also, the first execution of this method retrieves the semaphore by name and stores it locally.\tthis method is called when the task is entered.",
	"Method": "void start(){\r\n    if (semaphore == null) {\r\n        semaphore = NonBlockingSemaphoreRepository.getSemaphore(name);\r\n    }\r\n    semaphoreAcquired = semaphore.acquire();\r\n    super.start();\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth2.AuthorizationCodeTokenRequest.setCode",
	"Comment": "sets the authorization code generated by the authorization server.overriding is only supported for the purpose of calling the super implementation and changingthe return type, but nothing else.",
	"Method": "AuthorizationCodeTokenRequest setCode(String code){\r\n    this.code = Preconditions.checkNotNull(code);\r\n    return this;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider.findTypeUseConstraints",
	"Comment": "finds type use annotation constraints defined on the type argument.",
	"Method": "Set<MetaConstraint<?>> findTypeUseConstraints(Constrainable constrainable,AnnotatedType typeArgument,TypeVariable<?> typeVariable,TypeArgumentLocation location,Type type){\r\n    List<ConstraintDescriptorImpl<?>> constraintDescriptors = findConstraints(constrainable, typeArgument.getAnnotations(), ConstraintLocationKind.TYPE_USE);\r\n    if (constraintDescriptors.isEmpty()) {\r\n        return Collections.emptySet();\r\n    }\r\n    Set<MetaConstraint<?>> constraints = newHashSet(constraintDescriptors.size());\r\n    ConstraintLocation constraintLocation = ConstraintLocation.forTypeArgument(location.toConstraintLocation(), typeVariable, type);\r\n    for (ConstraintDescriptorImpl<?> constraintDescriptor : constraintDescriptors) {\r\n        constraints.add(MetaConstraints.create(typeResolutionHelper, valueExtractorManager, constraintDescriptor, constraintLocation));\r\n    }\r\n    return constraints;\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.classcache.ClassCacheModification.getOrAddReferredType",
	"Comment": "checks the current class cache if the given type is already available. in this case, the\tavailable type is returned. if the type is not available, the given type is added to the\tstructure and returned.\tif the type exists in the cache then the check against given checkclass will be performed. if\tthe in structure type is assignable to the given class it will be returned. otherwise it will\tbe removed.",
	"Method": "T getOrAddReferredType(T given,Events events,Class<? super T> checkClass){\r\n    if (given.isInitialized()) {\r\n        log.warn(\"We found that the given structure also has the second level initialized. This use case is currently not addressed by the merger. We thus interpret the given 2nd level as uninitialized and will add it as such if no entry exists.\");\r\n    }\r\n    Object inStructure = lookup.findByFQN(given.getFQN());\r\n    if (null == inStructure) {\r\n        fireAndSave(new NodeEvent(given, NodeEventType.NEW, NodeEventDetails.NOT_INITIALIZED), events);\r\n        return given;\r\n    } else {\r\n        if (checkClass.isAssignableFrom(inStructure.getClass())) {\r\n            return (T) inStructure;\r\n        } else {\r\n            removeDueToTypeChange((Type) inStructure, events);\r\n            fireAndSave(new NodeEvent(given, NodeEventType.NEW, NodeEventDetails.NOT_INITIALIZED), events);\r\n            return given;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.Symfony2InterfacesUtil.getMultiResolvedMethod",
	"Comment": "single resolve doesnt work if we have non unique class names in project context,so try a multiresolve and use first matched method",
	"Method": "Method getMultiResolvedMethod(PsiReference psiReference){\r\n    PsiElement resolvedReference = psiReference.resolve();\r\n    if (resolvedReference instanceof Method) {\r\n        return (Method) resolvedReference;\r\n    }\r\n    if (psiReference instanceof PsiPolyVariantReference) {\r\n        for (ResolveResult resolveResult : ((PsiPolyVariantReference) psiReference).multiResolve(false)) {\r\n            PsiElement element = resolveResult.getElement();\r\n            if (element instanceof Method) {\r\n                return (Method) element;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider.findTypeAnnotationConstraints",
	"Comment": "finds type arguments constraints for method return values.",
	"Method": "Set<MetaConstraint<?>> findTypeAnnotationConstraints(JavaBeanField javaBeanField,Set<MetaConstraint<?>> findTypeAnnotationConstraints,JavaBeanExecutable<?> javaBeanExecutable){\r\n    return findTypeArgumentsConstraints(javaBeanExecutable, new TypeArgumentReturnValueLocation(javaBeanExecutable), javaBeanExecutable.getAnnotatedType());\r\n}"
}, {
	"Path": "ch.hsr.geohash.GeoHash.withCharacterPrecision",
	"Comment": "this method uses the given number of characters as the desired precision\tvalue. the hash can only be 64bits long, thus a maximum precision of 12\tcharacters can be achieved.",
	"Method": "GeoHash withCharacterPrecision(double latitude,double longitude,int numberOfCharacters){\r\n    if (numberOfCharacters > MAX_CHARACTER_PRECISION) {\r\n        throw new IllegalArgumentException(\"A geohash can only be \" + MAX_CHARACTER_PRECISION + \" character long.\");\r\n    }\r\n    int desiredPrecision = (numberOfCharacters * 5 <= 60) ? numberOfCharacters * 5 : 60;\r\n    return new GeoHash(latitude, longitude, desiredPrecision);\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.JmxDataAccessService.postConstruct",
	"Comment": "is executed after dependency injection is done to perform any initialization.",
	"Method": "void postConstruct(){\r\n    log.info(\"|-Jmx Sensor Data Access Service active...\");\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.instrumentation.TagInjectionResponseWrapper.setContentLength",
	"Comment": "overrides setcontentlength to consume the call and to postpone it. when we inject our script\ttag, the content length is not known beforehand. therefore, in case we perform an injection,\twe have to force chunked encoding by not setting any content length.",
	"Method": "void setContentLength(int len){\r\n    contentLengthHeaderModifications.add(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            wrappedResponse.setContentLength(len);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.instrumentation.TagInjectionResponseWrapper.setContentLength",
	"Comment": "overrides setcontentlength to consume the call and to postpone it. when we inject our script\ttag, the content length is not known beforehand. therefore, in case we perform an injection,\twe have to force chunked encoding by not setting any content length.",
	"Method": "void setContentLength(int len){\r\n    wrappedResponse.setContentLength(len);\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.constraintvalidators.bv.time.AbstractEpochBasedTimeValidator.isValid",
	"Comment": "returns whether the result of the comparison between the validated value and the time reference is considered\tvalid.",
	"Method": "boolean isValid(T value,ConstraintValidatorContext context,boolean isValid,int result){\r\n    if (value == null) {\r\n        return true;\r\n    }\r\n    int result = Long.compare(getEpochMillis(value, referenceClock), referenceClock.millis());\r\n    return isValid(result);\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Face.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum angular speed and\tacceleration.",
	"Method": "Face<T> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.BufferPropertiesTest.parametrizedExpansionRateTestBufferSize",
	"Comment": "parameterized test to assure that no matter how big buffer size is, expansion rate will be\tbetween min and max related to buffers size.",
	"Method": "void parametrizedExpansionRateTestBufferSize(long bufferSize){\r\n    float expansionRate = bufferProperties.getObjectSecurityExpansionRateBufferSize(bufferSize);\r\n    assertThat(expansionRate, is(lessThanOrEqualTo(bufferProperties.getMaxObjectExpansionRate())));\r\n    assertThat(expansionRate, is(greaterThanOrEqualTo(bufferProperties.getMinObjectExpansionRate())));\r\n    if ((bufferSize > bufferProperties.getMaxObjectExpansionRateActiveTillBufferSize()) && (bufferSize < bufferProperties.getMinObjectExpansionRateActiveFromBufferSize())) {\r\n        assertThat(expansionRate, is(lessThan(bufferProperties.getMaxObjectExpansionRate())));\r\n        assertThat(expansionRate, is(greaterThan(bufferProperties.getMinObjectExpansionRate())));\r\n    }\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.getLicense",
	"Comment": "gets the basic license details for the repository.this is a preview item and subject to change.",
	"Method": "GHLicense getLicense(){\r\n    GHContentWithLicense lic = getLicenseContent_();\r\n    return lic != null ? lic.license : null;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.http.HttpHook.providesHttpRequestMetrics",
	"Comment": "checks if the given class is realizing the httpservletrequest interface directly or\tindirectly. only if this interface is realized, we can get http metric information.",
	"Method": "boolean providesHttpRequestMetrics(Class<?> c){\r\n    return implementsInterface(c, HTTP_SERVLET_REQUEST_CLASS, HTTP_REQUEST_WHITE_LIST, HTTP_REQUEST_BLACK_LIST);\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.groups.DefaultValidationOrder.assertDefaultGroupSequenceIsExpandable",
	"Comment": "asserts that the default group sequence of the validated bean can be expanded into the sequences which needs to\tbe validated.",
	"Method": "void assertDefaultGroupSequenceIsExpandable(List<Class<?>> defaultGroupSequence){\r\n    if (sequenceMap == null) {\r\n        return;\r\n    }\r\n    for (Map.Entry<Class<?>, Sequence> entry : sequenceMap.entrySet()) {\r\n        List<Group> sequenceGroups = entry.getValue().getComposingGroups();\r\n        int defaultGroupIndex = sequenceGroups.indexOf(Group.DEFAULT_GROUP);\r\n        if (defaultGroupIndex != -1) {\r\n            List<Group> defaultGroupList = buildTempGroupList(defaultGroupSequence);\r\n            ensureDefaultGroupSequenceIsExpandable(sequenceGroups, defaultGroupList, defaultGroupIndex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.ci.ConfigurationInterfaceManager.getExportData",
	"Comment": "returns the bytes for the given import data consisted out of given environments and profiles.\tthese bytes can be saved directly to export file.",
	"Method": "byte[] getExportData(Collection<Environment> environments,Collection<Profile> profiles){\r\n    ConfigurationInterfaceImportData importData = new ConfigurationInterfaceImportData();\r\n    if (CollectionUtils.isNotEmpty(environments)) {\r\n        Collection<Environment> exportedEnvironments = new ArrayList(environments.size());\r\n        for (Environment environment : environments) {\r\n            try {\r\n                exportedEnvironments.add(getEnvironment(environment.getId()));\r\n            } catch (BusinessException e) {\r\n                log.warn(\"Environment trying to export does not exists.\", e);\r\n            }\r\n        }\r\n        importData.setEnvironments(exportedEnvironments);\r\n    }\r\n    if (CollectionUtils.isNotEmpty(profiles)) {\r\n        Collection<Profile> exportedProfiles = new ArrayList(profiles.size());\r\n        for (Profile profile : profiles) {\r\n            try {\r\n                exportedProfiles.add(getProfile(profile.getId()));\r\n            } catch (BusinessException e) {\r\n                log.warn(\"Profile trying to export does not exists.\", e);\r\n            }\r\n        }\r\n        importData.setProfiles(exportedProfiles);\r\n    }\r\n    return transformator.marshall(importData, null, ISchemaVersionAware.ConfigurationInterface.SCHEMA_VERSION);\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.reflection.CachedMethod.throwUnchecked",
	"Comment": "throws the given exception or error without the need to declare it.",
	"Method": "void throwUnchecked(Throwable throwable){\r\n    CachedMethod.<RuntimeException>throwGeneric(throwable);\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.ValidatorImpl.validateInContext",
	"Comment": "validates the given object using the available context information.",
	"Method": "Set<ConstraintViolation<T>> validateInContext(BaseBeanValidationContext<T> validationContext,ValueContext<U, Object> valueContext,ValidationOrder validationOrder){\r\n    if (valueContext.getCurrentBean() == null) {\r\n        return Collections.emptySet();\r\n    }\r\n    BeanMetaData<U> beanMetaData = valueContext.getCurrentBeanMetaData();\r\n    if (beanMetaData.isDefaultGroupSequenceRedefined()) {\r\n        validationOrder.assertDefaultGroupSequenceIsExpandable(beanMetaData.getDefaultGroupSequence(valueContext.getCurrentBean()));\r\n    }\r\n    Iterator<Group> groupIterator = validationOrder.getGroupIterator();\r\n    while (groupIterator.hasNext()) {\r\n        Group group = groupIterator.next();\r\n        valueContext.setCurrentGroup(group.getDefiningClass());\r\n        validateConstraintsForCurrentGroup(validationContext, valueContext);\r\n        if (shouldFailFast(validationContext)) {\r\n            return validationContext.getFailingConstraints();\r\n        }\r\n    }\r\n    groupIterator = validationOrder.getGroupIterator();\r\n    while (groupIterator.hasNext()) {\r\n        Group group = groupIterator.next();\r\n        valueContext.setCurrentGroup(group.getDefiningClass());\r\n        validateCascadedConstraints(validationContext, valueContext);\r\n        if (shouldFailFast(validationContext)) {\r\n            return validationContext.getFailingConstraints();\r\n        }\r\n    }\r\n    Iterator<Sequence> sequenceIterator = validationOrder.getSequenceIterator();\r\n    while (sequenceIterator.hasNext()) {\r\n        Sequence sequence = sequenceIterator.next();\r\n        for (GroupWithInheritance groupOfGroups : sequence) {\r\n            int numberOfViolations = validationContext.getFailingConstraints().size();\r\n            for (Group group : groupOfGroups) {\r\n                valueContext.setCurrentGroup(group.getDefiningClass());\r\n                validateConstraintsForCurrentGroup(validationContext, valueContext);\r\n                if (shouldFailFast(validationContext)) {\r\n                    return validationContext.getFailingConstraints();\r\n                }\r\n                validateCascadedConstraints(validationContext, valueContext);\r\n                if (shouldFailFast(validationContext)) {\r\n                    return validationContext.getFailingConstraints();\r\n                }\r\n            }\r\n            if (validationContext.getFailingConstraints().size() > numberOfViolations) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return validationContext.getFailingConstraints();\r\n}"
}, {
	"Path": "rocks.inspectit.server.processor.impl.InvocationModifierCmrProcessor.processExceptionSensorData",
	"Comment": "process all the exceptions in the invdata and passes exceptions to the chained processors.\tnote also that only exception data with created event are processed, since the passed and\thandled should be connected as children to the created one.",
	"Method": "void processExceptionSensorData(EntityManager entityManager,InvocationSequenceData invData,InvocationSequenceData topInvocationParent){\r\n    if (CollectionUtils.isNotEmpty(invData.getExceptionSensorDataObjects())) {\r\n        for (ExceptionSensorData exceptionData : invData.getExceptionSensorDataObjects()) {\r\n            if (exceptionData.getExceptionEvent() == ExceptionEvent.CREATED) {\r\n                topInvocationParent.setNestedExceptions(Boolean.TRUE);\r\n                exceptionMessageCmrProcessor.process(exceptionData, entityManager);\r\n                exceptionData.addInvocationParentId(topInvocationParent.getId());\r\n                passToChainedProcessors(exceptionData, entityManager);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.kohsuke.github.GHReleaseBuilder.commitish",
	"Comment": "specifies the commitish value that determines where the git tag is created from. can be any branch orcommit sha.",
	"Method": "GHReleaseBuilder commitish(String commitish){\r\n    builder.with(\"target_commitish\", commitish);\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.classcache.ClassCache.getModificationService",
	"Comment": "returns the modification service. the modification service provides a set of services that\tallow to change the class cache in a safe way.",
	"Method": "ClassCacheModification getModificationService(){\r\n    return modificationService;\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeArrayList.ensureCapacity",
	"Comment": "ensure this container can hold at least the given number of elementswithout resizing its buffers.",
	"Method": "void ensureCapacity(int expectedElements){\r\n    final int bufferLen = (buffer == null ? 0 : buffer.length);\r\n    if (expectedElements > bufferLen) {\r\n        ensureBufferSpace(expectedElements - size());\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.rest.StorageRestfulService.handleAllException",
	"Comment": "handling of all the exceptions happening in this controller.",
	"Method": "ModelAndView handleAllException(Exception exception){\r\n    return new JsonError(exception).asModelAndView();\r\n}"
}, {
	"Path": "org.kohsuke.github.GHTreeEntry.readAsBlob",
	"Comment": "if this tree entry represents a file, then return its content.otherwise null.",
	"Method": "InputStream readAsBlob(){\r\n    if (type.equals(\"blob\"))\r\n        return tree.repo.readBlob(sha);\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeArrayList.release",
	"Comment": "sets the number of stored elements to zero and releases the internalstorage array.",
	"Method": "void release(){\r\n    this.buffer = Intrinsics.<KType[]>cast(EMPTY_ARRAY);\r\n    this.elementsCount = 0;\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth2.TokenResponse.getAccessToken",
	"Comment": "returns the access token issued by the authorization server.",
	"Method": "String getAccessToken(){\r\n    return accessToken;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.util.TypeHelper.genericArrayType",
	"Comment": "creates a generic array type for the specified component type.",
	"Method": "GenericArrayType genericArrayType(Type componentType){\r\n    return new GenericArrayType() {\r\n        @Override\r\n        public Type getGenericComponentType() {\r\n            return componentType;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.util.TypeHelper.genericArrayType",
	"Comment": "creates a generic array type for the specified component type.",
	"Method": "GenericArrayType genericArrayType(Type componentType){\r\n    return componentType;\r\n}"
}, {
	"Path": "org.influxdb.InfluxDBTest.testWriteMultipleStringDataSimple",
	"Comment": "test writing multiple records to the database using string protocol with simpler interface.",
	"Method": "void testWriteMultipleStringDataSimple(){\r\n    String dbName = \"write_unittest_\" + System.currentTimeMillis();\r\n    this.influxDB.createDatabase(dbName);\r\n    String rp = TestUtils.defaultRetentionPolicy(this.influxDB.version());\r\n    this.influxDB.setDatabase(dbName);\r\n    this.influxDB.setRetentionPolicy(rp);\r\n    this.influxDB.write(\"cpu,atag=test1 idle=100,usertime=10,system=1\\ncpu,atag=test2 idle=200,usertime=20,system=2\\ncpu,atag=test3 idle=300,usertime=30,system=3\");\r\n    Query query = new Query(\"SELECT * FROM cpu GROUP BY *\", dbName);\r\n    QueryResult result = this.influxDB.query(query);\r\n    Assertions.assertEquals(result.getResults().get(0).getSeries().size(), 3);\r\n    Assertions.assertEquals(\"test1\", result.getResults().get(0).getSeries().get(0).getTags().get(\"atag\"));\r\n    Assertions.assertEquals(\"test2\", result.getResults().get(0).getSeries().get(1).getTags().get(\"atag\"));\r\n    Assertions.assertEquals(\"test3\", result.getResults().get(0).getSeries().get(2).getTags().get(\"atag\"));\r\n    this.influxDB.deleteDatabase(dbName);\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth2.AuthorizationCodeFlow.getRefreshListeners",
	"Comment": "returns the unmodifiable list of listeners for refresh token results.",
	"Method": "Collection<CredentialRefreshListener> getRefreshListeners(Collection<CredentialRefreshListener> getRefreshListeners){\r\n    return refreshListeners;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.jdbc.ConnectionMetaDataStorage.populate",
	"Comment": "populates the given sql statement data with the meta information from the storage if this\tdata exist.",
	"Method": "void populate(SqlStatementData sqlData,Object connection){\r\n    ConnectionMetaData connectionMetaData = get(connection);\r\n    if ((null != connectionMetaData) && (EMPTY != connectionMetaData)) {\r\n        sqlData.setDatabaseProductName(connectionMetaData.product);\r\n        sqlData.setDatabaseProductVersion(connectionMetaData.version);\r\n        sqlData.setDatabaseUrl(connectionMetaData.url);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.utils.CircularBuffer.resize",
	"Comment": "creates a new backing array with the specified capacity containing the current items.",
	"Method": "void resize(int newCapacity){\r\n    @SuppressWarnings(\"unchecked\")\r\n    T[] newItems = (T[]) ArrayReflection.newInstance(items.getClass().getComponentType(), newCapacity);\r\n    if (tail > head) {\r\n        System.arraycopy(items, head, newItems, 0, size);\r\n    } else if (size > 0) {\r\n        System.arraycopy(items, head, newItems, 0, items.length - head);\r\n        System.arraycopy(items, 0, newItems, items.length - head, tail);\r\n    }\r\n    head = 0;\r\n    tail = size;\r\n    items = newItems;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.http.HttpInformationExtractor.getServerPort",
	"Comment": "reads the server port from the httpservletrequest object.",
	"Method": "int getServerPort(Class<?> httpServletRequestClass,Object httpServletRequest){\r\n    Method m = retrieveMethod(HttpMethods.RESPONSE_GET_SERVER_PORT, httpServletRequestClass);\r\n    if (null == m) {\r\n        return 0;\r\n    }\r\n    try {\r\n        return (Integer) m.invoke(httpServletRequest, (Object[]) null);\r\n    } catch (Exception e) {\r\n        LOG.error(\"Invocation on given object failed.\", e);\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.BufferPropertiesTest.getRandomLong",
	"Comment": "returns random positive long number smaller than given max value.",
	"Method": "long getRandomLong(long max){\r\n    long value = (long) (Math.random() * max);\r\n    return (value - (value % 10)) + 10;\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.rest.BusinessContextRestfultService.handleAllException",
	"Comment": "handling of all the exceptions happening in this controller.",
	"Method": "ModelAndView handleAllException(Exception exception){\r\n    return new JsonError(exception).asModelAndView();\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.util.ClassUtil.searchInterface",
	"Comment": "search if class implements the specified interface. if so it returns the class representing\tthe interface. this is recursive method, so it searches also all the superclasses of the\tgiven class and all the superinterfaces of directly implemented interfaces.",
	"Method": "Class<?> searchInterface(Class<?> clazz,String interfaceName,Class<?> searchInterface,Class<?> clazz,String interfaceName,List<Class<?>> searched){\r\n    try {\r\n        if ((clazz != null) && !clazz.equals(Object.class)) {\r\n            Class<?>[] interfaces = clazz.getInterfaces();\r\n            for (Class<?> interf : interfaces) {\r\n                if (!searched.contains(interf)) {\r\n                    if (interf.getName().equals(interfaceName)) {\r\n                        return interf;\r\n                    }\r\n                    searched.add(interf);\r\n                    Class<?> found = searchInterface(interf, interfaceName, searched);\r\n                    if (null != found) {\r\n                        return found;\r\n                    }\r\n                }\r\n            }\r\n            return searchInterface(clazz.getSuperclass(), interfaceName, searched);\r\n        }\r\n        return null;\r\n    } catch (Throwable t) {\r\n        LOG.warn(\"Unexpected error occurred checking the \" + clazz.getName() + \" for interface \" + interfaceName + \".\");\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "hprose.server.HproseTcpServer.isThreadPoolEnabled",
	"Comment": "is thread pool enabled.this thread pool is not for the service threads, it is for the user service method.the default value is false.",
	"Method": "boolean isThreadPoolEnabled(){\r\n    return threadPoolEnabled;\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.BufferProperties.getEvictionFragmentSizePercentage",
	"Comment": "returns size of the eviction fragment in percentages, in relation to the max buffer size.",
	"Method": "float getEvictionFragmentSizePercentage(){\r\n    return evictionFragmentSizePercentage;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.metadata.raw.ConstrainedParameter.merge",
	"Comment": "creates a new constrained parameter object by merging this and the given\tother parameter.",
	"Method": "ConstrainedParameter merge(ConstrainedParameter other){\r\n    ConfigurationSource mergedSource = ConfigurationSource.max(source, other.source);\r\n    Set<MetaConstraint<?>> mergedConstraints = newHashSet(constraints);\r\n    mergedConstraints.addAll(other.constraints);\r\n    Set<MetaConstraint<?>> mergedTypeArgumentConstraints = new HashSet(typeArgumentConstraints);\r\n    mergedTypeArgumentConstraints.addAll(other.typeArgumentConstraints);\r\n    CascadingMetaDataBuilder mergedCascadingMetaData = cascadingMetaDataBuilder.merge(other.cascadingMetaDataBuilder);\r\n    return new ConstrainedParameter(mergedSource, callable, type, index, mergedConstraints, mergedTypeArgumentConstraints, mergedCascadingMetaData);\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider.findExecutableMetaData",
	"Comment": "finds all constraint annotations defined for the given method or constructor.",
	"Method": "ConstrainedExecutable findExecutableMetaData(Executable executable){\r\n    JavaBeanExecutable<?> javaBeanExecutable = javaBeanHelper.executable(executable);\r\n    List<ConstrainedParameter> parameterConstraints = getParameterMetaData(javaBeanExecutable);\r\n    Map<ConstraintType, List<ConstraintDescriptorImpl<?>>> executableConstraints = findConstraints(javaBeanExecutable, ConstraintLocationKind.of(javaBeanExecutable.getConstrainedElementKind())).stream().collect(Collectors.groupingBy(ConstraintDescriptorImpl::getConstraintType));\r\n    Set<MetaConstraint<?>> crossParameterConstraints;\r\n    if (annotationProcessingOptions.areCrossParameterConstraintsIgnoredFor(javaBeanExecutable)) {\r\n        crossParameterConstraints = Collections.emptySet();\r\n    } else {\r\n        crossParameterConstraints = convertToMetaConstraints(executableConstraints.get(ConstraintType.CROSS_PARAMETER), javaBeanExecutable);\r\n    }\r\n    Set<MetaConstraint<?>> returnValueConstraints;\r\n    Set<MetaConstraint<?>> typeArgumentsConstraints;\r\n    CascadingMetaDataBuilder cascadingMetaDataBuilder;\r\n    if (annotationProcessingOptions.areReturnValueConstraintsIgnoredFor(javaBeanExecutable)) {\r\n        returnValueConstraints = Collections.emptySet();\r\n        typeArgumentsConstraints = Collections.emptySet();\r\n        cascadingMetaDataBuilder = CascadingMetaDataBuilder.nonCascading();\r\n    } else {\r\n        typeArgumentsConstraints = findTypeAnnotationConstraints(javaBeanExecutable);\r\n        returnValueConstraints = convertToMetaConstraints(executableConstraints.get(ConstraintType.GENERIC), javaBeanExecutable);\r\n        cascadingMetaDataBuilder = findCascadingMetaData(javaBeanExecutable);\r\n    }\r\n    return new ConstrainedExecutable(ConfigurationSource.ANNOTATION, javaBeanExecutable, parameterConstraints, crossParameterConstraints, returnValueConstraints, typeArgumentsConstraints, cascadingMetaDataBuilder);\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.createStorageFromUploadedDir",
	"Comment": "creates a storage form the uploaded local storage directory.",
	"Method": "void createStorageFromUploadedDir(IStorageData localStorageData){\r\n    long storageBytesLeft = getBytesHardDriveOccupancyLeft();\r\n    if (localStorageData.getDiskSize() > storageBytesLeft) {\r\n        throw new BusinessException(\"Create the uploaded storage \" + localStorageData + \".\", StorageErrorCodeEnum.LOW_DISK_SPACE);\r\n    }\r\n    Path uploadPath = Paths.get(this.getStorageUploadsFolder());\r\n    if (Files.notExists(uploadPath)) {\r\n        throw new IOException(\"Can not perform storage unpacking. The main upload path \" + uploadPath.toString() + \" does not exist.\");\r\n    } else {\r\n        final MutableObject storageUploadPath = new MutableObject();\r\n        final MutableObject uploadedStorageData = new MutableObject();\r\n        final ISerializer serializer = getSerializationManagerProvider().createSerializer();\r\n        Files.walkFileTree(uploadPath, new SimpleFileVisitor<Path>() {\r\n            @Override\r\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\r\n                if (!file.toString().endsWith(localStorageData.getId() + StorageFileType.LOCAL_STORAGE_FILE.getExtension())) {\r\n                    return FileVisitResult.CONTINUE;\r\n                }\r\n                InputStream inputStream = null;\r\n                Input input = null;\r\n                try {\r\n                    inputStream = Files.newInputStream(file, StandardOpenOption.READ);\r\n                    input = new Input(inputStream);\r\n                    Object deserialized = serializer.deserialize(input);\r\n                    if (Objects.equals(deserialized, localStorageData)) {\r\n                        uploadedStorageData.setValue(new StorageData(localStorageData));\r\n                        storageUploadPath.setValue(file.toAbsolutePath().getParent());\r\n                        return FileVisitResult.TERMINATE;\r\n                    }\r\n                } catch (SerializationException e) {\r\n                    log.warn(\"Error de-serializing local storage file.\", e);\r\n                } finally {\r\n                    if (null != input) {\r\n                        input.close();\r\n                    }\r\n                }\r\n                return FileVisitResult.CONTINUE;\r\n            }\r\n        });\r\n        Path parentDir = (Path) storageUploadPath.getValue();\r\n        StorageData storageData = (StorageData) uploadedStorageData.getValue();\r\n        if ((null != storageData) && (null != parentDir)) {\r\n            Path storageDir = getStoragePath(storageData);\r\n            if (existingStoragesSet.add(storageData)) {\r\n                if (Files.notExists(storageDir)) {\r\n                    printStorageCmrVersionWarn(storageData);\r\n                    Files.walkFileTree(parentDir, new CopyMoveFileVisitor(parentDir, storageDir, true));\r\n                    Path localInformation = getStoragePath(storageData).resolve(storageData.getId() + StorageFileType.LOCAL_STORAGE_FILE.getExtension());\r\n                    Files.deleteIfExists(localInformation);\r\n                    writeStorageDataToDisk(storageData);\r\n                } else {\r\n                    throw new IOException(\"Directory to place uploaded storage already exists.\");\r\n                }\r\n            } else {\r\n                log.info(\"Uploaded storage on path \" + parentDir.toString() + \" contains the storage that is already available on the CMR. Dir will be deleted.\");\r\n                Files.walkFileTree(parentDir, new DeleteFileVisitor());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.createStorageFromUploadedDir",
	"Comment": "creates a storage form the uploaded local storage directory.",
	"Method": "void createStorageFromUploadedDir(IStorageData localStorageData){\r\n    if (!file.toString().endsWith(localStorageData.getId() + StorageFileType.LOCAL_STORAGE_FILE.getExtension())) {\r\n        return FileVisitResult.CONTINUE;\r\n    }\r\n    InputStream inputStream = null;\r\n    Input input = null;\r\n    try {\r\n        inputStream = Files.newInputStream(file, StandardOpenOption.READ);\r\n        input = new Input(inputStream);\r\n        Object deserialized = serializer.deserialize(input);\r\n        if (Objects.equals(deserialized, localStorageData)) {\r\n            uploadedStorageData.setValue(new StorageData(localStorageData));\r\n            storageUploadPath.setValue(file.toAbsolutePath().getParent());\r\n            return FileVisitResult.TERMINATE;\r\n        }\r\n    } catch (SerializationException e) {\r\n        log.warn(\"Error de-serializing local storage file.\", e);\r\n    } finally {\r\n        if (null != input) {\r\n            input.close();\r\n        }\r\n    }\r\n    return FileVisitResult.CONTINUE;\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth2.TokenResponse.setAccessToken",
	"Comment": "sets the access token issued by the authorization server.overriding is only supported for the purpose of calling the super implementation and changingthe return type, but nothing else.",
	"Method": "TokenResponse setAccessToken(String accessToken){\r\n    this.accessToken = Preconditions.checkNotNull(accessToken);\r\n    return this;\r\n}"
}, {
	"Path": "org.hibernate.validator.test.internal.engine.methodvalidation.MethodLevelValidationGroupSequenceTest.processingOfDefaultSequenceForReturnValueStopsAfterFirstErroneousGroup",
	"Comment": "only one constraint violation is expected, as processing should stop after the\tfirst erroneous group of the default sequence.",
	"Method": "void processingOfDefaultSequenceForReturnValueStopsAfterFirstErroneousGroup(){\r\n    try {\r\n        customerRepository.constraintsInAllPartOfDefaultSequence();\r\n        fail(\"Expected MethodConstraintViolationException wasn't thrown.\");\r\n    } catch (ConstraintViolationException e) {\r\n        assertThat(e.getConstraintViolations()).containsOnlyViolations(violationOf(Min.class).withMessage(\"must be greater than or equal to 5\").withInvalidValue(1).withRootBeanClass(CustomerRepositoryWithRedefinedDefaultGroupImpl.class));\r\n        ConstraintViolation<?> constraintViolation = e.getConstraintViolations().iterator().next();\r\n        assertEquals(constraintViolation.getConstraintDescriptor().getGroups().iterator().next(), ValidationGroup1.class);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.classcache.ClassCacheInstrumentation.getInstrumentationResults",
	"Comment": "collects instrumentation points for given types in the given class cache. only initialized\tclass types will be checked.",
	"Method": "Collection<InstrumentationDefinition> getInstrumentationResults(Collection<InstrumentationDefinition> getInstrumentationResults,Collection<? extends ImmutableType> types){\r\n    if (CollectionUtils.isEmpty(types)) {\r\n        return Collections.emptyList();\r\n    }\r\n    try {\r\n        return classCache.executeWithReadLock(new Callable<Collection<InstrumentationDefinition>>() {\r\n            @Override\r\n            public Collection<InstrumentationDefinition> call() throws Exception {\r\n                Collection<InstrumentationDefinition> results = new ArrayList();\r\n                for (ImmutableType type : types) {\r\n                    if (type.isInitialized() && type.isClass()) {\r\n                        ImmutableClassType immutableClassType = type.castToClass();\r\n                        InstrumentationDefinition instrumentationResult = createInstrumentationResult(immutableClassType);\r\n                        if (null != instrumentationResult) {\r\n                            results.add(instrumentationResult);\r\n                        }\r\n                    }\r\n                }\r\n                return results;\r\n            }\r\n        });\r\n    } catch (Exception e) {\r\n        log.error(\"Error occurred while trying to collect instrumentation results from the class cache.\", e);\r\n        return Collections.emptyList();\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.classcache.ClassCacheInstrumentation.getInstrumentationResults",
	"Comment": "collects instrumentation points for given types in the given class cache. only initialized\tclass types will be checked.",
	"Method": "Collection<InstrumentationDefinition> getInstrumentationResults(Collection<InstrumentationDefinition> getInstrumentationResults,Collection<? extends ImmutableType> types){\r\n    Collection<InstrumentationDefinition> results = new ArrayList();\r\n    for (ImmutableType type : types) {\r\n        if (type.isInitialized() && type.isClass()) {\r\n            ImmutableClassType immutableClassType = type.castToClass();\r\n            InstrumentationDefinition instrumentationResult = createInstrumentationResult(immutableClassType);\r\n            if (null != instrumentationResult) {\r\n                results.add(instrumentationResult);\r\n            }\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "com.anthonycr.grant.PermissionsResultAction.onResult",
	"Comment": "this method is called when a particular permission has changed.this method will be called for all permissions, so this method determinesif the permission affects the state or not and whether it can proceed withcalling ongranted or if ondenied should be called.",
	"Method": "boolean onResult(String permission,int result,boolean onResult,String permission,Permissions result){\r\n    mPermissions.remove(permission);\r\n    if (result == Permissions.GRANTED) {\r\n        if (mPermissions.isEmpty()) {\r\n            new Handler(mLooper).post(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    onGranted();\r\n                }\r\n            });\r\n            return true;\r\n        }\r\n    } else if (result == Permissions.DENIED) {\r\n        new Handler(mLooper).post(new Runnable() {\r\n            @Override\r\n            public void run() {\r\n                onDenied(permission);\r\n            }\r\n        });\r\n        return true;\r\n    } else if (result == Permissions.NOT_FOUND) {\r\n        if (shouldIgnorePermissionNotFound(permission)) {\r\n            if (mPermissions.isEmpty()) {\r\n                new Handler(mLooper).post(new Runnable() {\r\n                    @Override\r\n                    public void run() {\r\n                        onGranted();\r\n                    }\r\n                });\r\n                return true;\r\n            }\r\n        } else {\r\n            new Handler(mLooper).post(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    onDenied(permission);\r\n                }\r\n            });\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.anthonycr.grant.PermissionsResultAction.onResult",
	"Comment": "this method is called when a particular permission has changed.this method will be called for all permissions, so this method determinesif the permission affects the state or not and whether it can proceed withcalling ongranted or if ondenied should be called.",
	"Method": "boolean onResult(String permission,int result,boolean onResult,String permission,Permissions result){\r\n    onGranted();\r\n}"
}, {
	"Path": "com.anthonycr.grant.PermissionsResultAction.onResult",
	"Comment": "this method is called when a particular permission has changed.this method will be called for all permissions, so this method determinesif the permission affects the state or not and whether it can proceed withcalling ongranted or if ondenied should be called.",
	"Method": "boolean onResult(String permission,int result,boolean onResult,String permission,Permissions result){\r\n    onDenied(permission);\r\n}"
}, {
	"Path": "com.anthonycr.grant.PermissionsResultAction.onResult",
	"Comment": "this method is called when a particular permission has changed.this method will be called for all permissions, so this method determinesif the permission affects the state or not and whether it can proceed withcalling ongranted or if ondenied should be called.",
	"Method": "boolean onResult(String permission,int result,boolean onResult,String permission,Permissions result){\r\n    onGranted();\r\n}"
}, {
	"Path": "com.anthonycr.grant.PermissionsResultAction.onResult",
	"Comment": "this method is called when a particular permission has changed.this method will be called for all permissions, so this method determinesif the permission affects the state or not and whether it can proceed withcalling ongranted or if ondenied should be called.",
	"Method": "boolean onResult(String permission,int result,boolean onResult,String permission,Permissions result){\r\n    onDenied(permission);\r\n}"
}, {
	"Path": "com.firebase.geofire.testing.GeoFireTestingRule.newTestGeoFire",
	"Comment": "this will return you a new geofire instance that can be used for testing.",
	"Method": "GeoFire newTestGeoFire(){\r\n    return new GeoFire(databaseReference.child(randomAlphaNumericString(16)));\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.engine.session.SessionPerfTest.testDiagnosisServiceWithNplusOneProblem",
	"Comment": "tests the rules with an iterative call, which includes a nplusone. database call.",
	"Method": "void testDiagnosisServiceWithNplusOneProblem(){\r\n    session.activate(rootNplusOneAwareInvocationSequenceData, Collections.singletonMap(RuleConstants.DIAGNOSIS_VAR_BASELINE, DIAGNOSIS_BASELINE));\r\n    DefaultSessionResult<InvocationSequenceData> sdfsdf = session.call();\r\n    sdfsdf.getEndTags();\r\n    session.passivate();\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.jmx.JmxSensor.registerMBeans",
	"Comment": "registers all attributes of all object names that are returned as the result of querying with\tthe given mbeanname on the server in the given holder.",
	"Method": "void registerMBeans(MBeanServerHolder holder,ObjectName mBeanName){\r\n    MBeanServer mBeanServer = holder.mBeanServer;\r\n    Map<JmxAttributeDescriptor, Boolean> activeAttributes = holder.activeAttributes;\r\n    Map<String, ObjectName> nameStringToObjectName = holder.nameStringToObjectName;\r\n    if (!connection.isConnected()) {\r\n        return;\r\n    }\r\n    List<JmxAttributeDescriptor> descriptors = new ArrayList<JmxAttributeDescriptor>();\r\n    Set<ObjectName> allNames = mBeanServer.queryNames(mBeanName, null);\r\n    for (ObjectName objectName : allNames) {\r\n        try {\r\n            MBeanAttributeInfo[] attributeInfos = mBeanServer.getMBeanInfo(objectName).getAttributes();\r\n            for (MBeanAttributeInfo mBeanAttributeInfo : attributeInfos) {\r\n                JmxAttributeDescriptor descriptor = new JmxAttributeDescriptor();\r\n                descriptor.setmBeanObjectName(objectName.toString());\r\n                descriptor.setAttributeName(mBeanAttributeInfo.getName());\r\n                descriptor.setmBeanAttributeDescription(mBeanAttributeInfo.getDescription());\r\n                descriptor.setmBeanAttributeIsIs(mBeanAttributeInfo.isIs());\r\n                descriptor.setmBeanAttributeIsReadable(mBeanAttributeInfo.isReadable());\r\n                descriptor.setmBeanAttributeIsWritable(mBeanAttributeInfo.isWritable());\r\n                descriptor.setmBeanAttributeType(mBeanAttributeInfo.getType());\r\n                descriptors.add(descriptor);\r\n            }\r\n        } catch (IntrospectionException e) {\r\n            continue;\r\n        } catch (InstanceNotFoundException e) {\r\n            continue;\r\n        } catch (ReflectionException e) {\r\n            continue;\r\n        }\r\n    }\r\n    try {\r\n        Collection<JmxAttributeDescriptor> toMonitor = connection.analyzeJmxAttributes(platformManager.getPlatformId(), descriptors);\r\n        for (JmxAttributeDescriptor descriptor : toMonitor) {\r\n            activeAttributes.put(descriptor, Boolean.FALSE);\r\n        }\r\n        for (ObjectName name : allNames) {\r\n            nameStringToObjectName.put(name.toString(), name);\r\n        }\r\n    } catch (ServerUnavailableException e) {\r\n        if (log.isWarnEnabled()) {\r\n            log.warn(\"Error registering JMX attributes on the server.\", e);\r\n        }\r\n    } catch (BusinessException e) {\r\n        if (AgentManagementErrorCodeEnum.AGENT_DOES_NOT_EXIST.equals(e.getErrorCode())) {\r\n            agentStatisticsLogger.noClassCacheAvailable();\r\n        } else {\r\n            log.warn(\"Error registering JMX attributes on the server.\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.test.internal.engine.methodvalidation.MethodLevelValidationGroupSequenceTest.processingOfGroupSequenceStopsAfterFirstErroneousGroup",
	"Comment": "only one constraint violation is expected, as processing should stop after the\tfirst erroneous group of the validated sequence.",
	"Method": "void processingOfGroupSequenceStopsAfterFirstErroneousGroup(){\r\n    setUpValidatorForGroups(ValidationSequence.class);\r\n    try {\r\n        customerRepository.constraintInLaterPartOfGroupSequence(1);\r\n        fail(\"Expected MethodConstraintViolationException wasn't thrown.\");\r\n    } catch (ConstraintViolationException e) {\r\n        assertThat(e.getConstraintViolations()).containsOnlyViolations(violationOf(Min.class).withMessage(\"must be greater than or equal to 5\").withInvalidValue(1).withRootBeanClass(CustomerRepositoryWithRedefinedDefaultGroupImpl.class));\r\n        ConstraintViolation<?> constraintViolation = e.getConstraintViolations().iterator().next();\r\n        assertEquals(constraintViolation.getConstraintDescriptor().getGroups().iterator().next(), ValidationGroup2.class);\r\n    }\r\n}"
}, {
	"Path": "com.hypertrack.hyperlog.HyperLog.getDeviceLogsInFile",
	"Comment": "call this method to get a stored device logs as a file object.a text file will create in the app folder containing all logs.",
	"Method": "File getDeviceLogsInFile(Context mContext,File getDeviceLogsInFile,Context mContext,boolean deleteLogs,File getDeviceLogsInFile,Context mContext,String fileName,File getDeviceLogsInFile,Context mContext,String fileName,boolean deleteLogs){\r\n    if (!isInitialize())\r\n        return null;\r\n    File file = null;\r\n    if (TextUtils.isEmpty(fileName)) {\r\n        fileName = HLDateTimeUtility.getCurrentTime() + \".txt\";\r\n        fileName = fileName.replaceAll(\"[^a-zA-Z0-9_\\\\\\\\-\\\\\\\\.]\", \"_\");\r\n    }\r\n    int logsBatchCount = getDeviceLogBatchCount();\r\n    while (logsBatchCount != 0) {\r\n        List<DeviceLogModel> deviceLogList = getDeviceLogs(deleteLogs);\r\n        if (deviceLogList != null && !deviceLogList.isEmpty()) {\r\n            file = Utils.writeStringsToFile(mContext, getDeviceLogsAsStringList(deviceLogList), fileName);\r\n            if (file != null) {\r\n                if (deleteLogs)\r\n                    mDeviceLogList.clearDeviceLogs(deviceLogList);\r\n                HyperLog.i(TAG, \"Log File has been created at \" + file.getAbsolutePath());\r\n            }\r\n        }\r\n        logsBatchCount--;\r\n    }\r\n    return file;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.pfa.PathSmoother.smoothPath",
	"Comment": "smoothes in place the path specified by the given request, possibly over multiple consecutive frames.",
	"Method": "int smoothPath(SmoothableGraphPath<N, V> path,boolean smoothPath,PathSmootherRequest<N, V> request,long timeToRun){\r\n    long lastTime = TimeUtils.nanoTime();\r\n    SmoothableGraphPath<N, V> path = request.path;\r\n    int inputPathLength = path.getCount();\r\n    if (inputPathLength <= 2)\r\n        return true;\r\n    if (request.isNew) {\r\n        request.isNew = false;\r\n        if (this.ray == null) {\r\n            V vec = request.path.getNodePosition(0);\r\n            this.ray = new Ray<V>(vec.cpy(), vec.cpy());\r\n        }\r\n        request.outputIndex = 1;\r\n        request.inputIndex = 2;\r\n    }\r\n    while (request.inputIndex < inputPathLength) {\r\n        long currentTime = TimeUtils.nanoTime();\r\n        timeToRun -= currentTime - lastTime;\r\n        if (timeToRun <= PathFinderQueue.TIME_TOLERANCE)\r\n            return false;\r\n        ray.start.set(path.getNodePosition(request.outputIndex - 1));\r\n        ray.end.set(path.getNodePosition(request.inputIndex));\r\n        boolean collided = raycastCollisionDetector.collides(ray);\r\n        if (collided) {\r\n            path.swapNodes(request.outputIndex, request.inputIndex - 1);\r\n            request.outputIndex++;\r\n        }\r\n        request.inputIndex++;\r\n        lastTime = currentTime;\r\n    }\r\n    path.swapNodes(request.outputIndex, request.inputIndex - 1);\r\n    path.truncatePath(request.outputIndex + 1);\r\n    return true;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.FollowFlowField.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum linear speed and\tacceleration.",
	"Method": "FollowFlowField<T> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHPerson.listRepositories",
	"Comment": "lists up all the repositories using the specified page size.",
	"Method": "PagedIterable<GHRepository> listRepositories(PagedIterable<GHRepository> listRepositories,int pageSize){\r\n    return new PagedIterable<GHRepository>() {\r\n        public PagedIterator<GHRepository> _iterator(int pageSize) {\r\n            return new PagedIterator<GHRepository>(root.retrieve().asIterator(\"/users/\" + login + \"/repos\", GHRepository[].class, pageSize)) {\r\n                @Override\r\n                protected void wrapUp(GHRepository[] page) {\r\n                    for (GHRepository c : page) c.wrap(root);\r\n                }\r\n            };\r\n        }\r\n    }.withPageSize(pageSize);\r\n}"
}, {
	"Path": "org.kohsuke.github.GHPerson.listRepositories",
	"Comment": "lists up all the repositories using the specified page size.",
	"Method": "PagedIterable<GHRepository> listRepositories(PagedIterable<GHRepository> listRepositories,int pageSize){\r\n    return new PagedIterator<GHRepository>(root.retrieve().asIterator(\"/users/\" + login + \"/repos\", GHRepository[].class, pageSize)) {\r\n        @Override\r\n        protected void wrapUp(GHRepository[] page) {\r\n            for (GHRepository c : page) c.wrap(root);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.kohsuke.github.GHPerson.listRepositories",
	"Comment": "lists up all the repositories using the specified page size.",
	"Method": "PagedIterable<GHRepository> listRepositories(PagedIterable<GHRepository> listRepositories,int pageSize){\r\n    for (GHRepository c : page) c.wrap(root);\r\n}"
}, {
	"Path": "org.kohsuke.github.GHUser.isMemberOf",
	"Comment": "returns true if this user belongs to the specified organization.",
	"Method": "boolean isMemberOf(GHOrganization org,boolean isMemberOf,GHTeam team){\r\n    return team.hasMember(this);\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.BufferProperties.getMinObjectExpansionRate",
	"Comment": "returns minimum security object expansion rate in percentages.",
	"Method": "float getMinObjectExpansionRate(){\r\n    return minObjectExpansionRate;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.html.StreamedHtmlScriptInjector.performInjection",
	"Comment": "tries to perform an injection on the given source code. \tthe html file may be split arbitrarily by calling this method for each part of the code in\torder. if the injector has already finished, it returns immediately without additional\toverhead.",
	"Method": "String performInjection(CharSequence htmlData){\r\n    if (hasTerminated()) {\r\n        return null;\r\n    }\r\n    Caret caret = tokenParser.getCaret();\r\n    int sourceAppendPos = htmlSource.length();\r\n    htmlSource.append(htmlData);\r\n    while (!hasTerminated()) {\r\n        Result tokenParsingResult = tokenParser.parseToken();\r\n        switch(tokenParsingResult) {\r\n            case FAILURE:\r\n                abortInjectionPointSearch();\r\n                return null;\r\n            case INCOMPLETE:\r\n                return null;\r\n            case SUCCESS:\r\n                processToken();\r\n                if (status == Status.INJECTION_POINT_FOUND) {\r\n                    String returnValue;\r\n                    if (!caret.startsWithCheckCase(tagToInject)) {\r\n                        StringBuilder newHtmlData = new StringBuilder();\r\n                        int normalizedCaretPos = caret.getOffset() - sourceAppendPos;\r\n                        newHtmlData.append(htmlData.subSequence(0, normalizedCaretPos));\r\n                        newHtmlData.append(tagToInject);\r\n                        newHtmlData.append(htmlData.subSequence(normalizedCaretPos, htmlData.length()));\r\n                        returnValue = newHtmlData.toString();\r\n                    } else {\r\n                        returnValue = null;\r\n                    }\r\n                    abortInjectionPointSearch();\r\n                    return returnValue;\r\n                } else if (status != Status.TERMINATED) {\r\n                    htmlSource.erase(caret.getOffset());\r\n                    sourceAppendPos -= caret.getOffset();\r\n                    caret.goTo(0);\r\n                    tokenParser.resetState();\r\n                }\r\n                break;\r\n            default:\r\n                throw new RuntimeException(\"Unhandled token parsing result: \" + tokenParsingResult);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHTree.isTruncated",
	"Comment": "returns true if the number of items in the tree array exceeded the github maximum limit.",
	"Method": "boolean isTruncated(){\r\n    return truncated;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.http.HttpInformationExtractor.getHeaders",
	"Comment": "reads all headers from the given httpservletrequest object and stores them with\tthe given httptimerdata object.",
	"Method": "Map<String, String> getHeaders(Class<?> httpServletRequestClass,Object httpServletRequest){\r\n    Method headerNamesMethod = retrieveMethod(HttpMethods.SERVLET_GET_HEADER_NAMES, httpServletRequestClass);\r\n    if (null == headerNamesMethod) {\r\n        return null;\r\n    }\r\n    Method headerValueMethod = retrieveMethod(HttpMethods.SERVLET_GET_HEADER, httpServletRequestClass);\r\n    if (null == headerValueMethod) {\r\n        return null;\r\n    }\r\n    try {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Enumeration<String> headers = (Enumeration<String>) headerNamesMethod.invoke(httpServletRequest, (Object[]) null);\r\n        Map<String, String> headersResult = new HashMap<String, String>();\r\n        if (headers != null) {\r\n            while (headers.hasMoreElements()) {\r\n                String headerName = headers.nextElement();\r\n                String headerValue = (String) headerValueMethod.invoke(httpServletRequest, new Object[] { headerName });\r\n                headersResult.put(headerName, strConstraint.crop(headerValue));\r\n            }\r\n            return headersResult;\r\n        }\r\n    } catch (Exception e) {\r\n        LOG.error(\"Invocation of to get attributes on given object failed.\", e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.instrumentation.TagInjectionResponseWrapper.setTraceCorrelationInformation",
	"Comment": "sets the information for correlating the initial request.",
	"Method": "void setTraceCorrelationInformation(){\r\n    SpanContextImpl context = tracer.getCurrentContext();\r\n    if (context != null) {\r\n        String traceID = ConversionUtils.toHexString(context.getTraceId());\r\n        tagToInject.setSetting(JSAgentBuilder.TRACEID_CORRELATION_SETTING, \"\\\"\" + traceID + \"\\\"\");\r\n        ClassLoader cl = wrappedResponse.getWrappedElement().getClass().getClassLoader();\r\n        Object cookie = WCookie.newInstance(cl, JSAgentBuilder.TRACEID_CORRELATION_COOKIE_PREFIX + traceID, \"1\");\r\n        WCookie wrappedCookie = WCookie.wrap(cookie);\r\n        wrappedCookie.setPath(\"/\");\r\n        wrappedCookie.setMaxAge(2 * 60);\r\n        wrappedResponse.addCookie(cookie);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.SteeringBehavior.calculateSteering",
	"Comment": "if this behavior is enabled calculates the steering acceleration and writes it to the given steering output. if it is\tdisabled the steering output is set to zero.",
	"Method": "SteeringAcceleration<T> calculateSteering(SteeringAcceleration<T> steering){\r\n    return isEnabled() ? calculateRealSteering(steering) : steering.setZero();\r\n}"
}, {
	"Path": "com.hypertrack.hyperlog.HyperLog.getDeviceLogsAsStringList",
	"Comment": "call this method to get a list of stored device logs.device logs will gets deleted from device after fetching.",
	"Method": "List<String> getDeviceLogsAsStringList(List<String> getDeviceLogsAsStringList,boolean deleteLogs,List<String> getDeviceLogsAsStringList,boolean deleteLogs,int batchNo,List<String> getDeviceLogsAsStringList,List<DeviceLogModel> deviceLogList){\r\n    List<String> logsList = new ArrayList();\r\n    if (deviceLogList == null) {\r\n        return logsList;\r\n    }\r\n    for (DeviceLogModel deviceLog : deviceLogList) {\r\n        logsList.add(deviceLog.getDeviceLog());\r\n    }\r\n    return logsList;\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.StorageService.postConstruct",
	"Comment": "is executed after dependency injection is done to perform any initialization.",
	"Method": "void postConstruct(){\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"|-Storage Service active...\");\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth2.AuthorizationCodeFlow.loadCredential",
	"Comment": "loads the credential of the given user id from the credential store.",
	"Method": "Credential loadCredential(String userId){\r\n    if (isNullOrEmpty(userId)) {\r\n        return null;\r\n    }\r\n    if (credentialDataStore == null && credentialStore == null) {\r\n        return null;\r\n    }\r\n    Credential credential = newCredential(userId);\r\n    if (credentialDataStore != null) {\r\n        StoredCredential stored = credentialDataStore.get(userId);\r\n        if (stored == null) {\r\n            return null;\r\n        }\r\n        credential.setAccessToken(stored.getAccessToken());\r\n        credential.setRefreshToken(stored.getRefreshToken());\r\n        credential.setExpirationTimeMilliseconds(stored.getExpirationTimeMilliseconds());\r\n    } else if (!credentialStore.load(userId, credential)) {\r\n        return null;\r\n    }\r\n    return credential;\r\n}"
}, {
	"Path": "hprose.server.HproseTcpServer.setThreadPool",
	"Comment": "set the thread pool.this thread pool is not for the service threads, it is for the user service method.set it to null will disable thread pool.",
	"Method": "void setThreadPool(ExecutorService value){\r\n    threadPool = value;\r\n    threadPoolEnabled = (value != null);\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.platform.provider.ibm.IbmJava6OperatingSystemInfoProvider.initAndCheckEnvironment",
	"Comment": "initializes the class and checks if every method needed to be accessed with reflection is\tavailable and is returning the correct value.",
	"Method": "void initAndCheckEnvironment(){\r\n    Class<?> ibmOperatingSystemMxBeanClass = Class.forName(IBM_OPERATING_SYSTEM_MX_BEAN_CLASS);\r\n    if (null != ibmOperatingSystemMxBeanClass) {\r\n        Method getInstanceMethod = ibmOperatingSystemMxBeanClass.getDeclaredMethod(\"getInstance\");\r\n        getInstanceMethod.setAccessible(true);\r\n        if (null != getInstanceMethod) {\r\n            ibmOperatingSystemMxBeanInstance = getInstanceMethod.invoke(null);\r\n        }\r\n        if (null != ibmOperatingSystemMxBeanInstance) {\r\n            committedVirtualMemorySizeMethod = getMethod(ibmOperatingSystemMxBeanClass, \"getProcessVirtualMemorySize\");\r\n            Object result = getValueFromMethodInvocation(ibmOperatingSystemMxBeanInstance, committedVirtualMemorySizeMethod);\r\n            if (!(result instanceof Number)) {\r\n                throw new Exception(\"Result of getProcessVirtualMemorySize() method invocation is not a number. Result was: \" + result);\r\n            }\r\n            freePhysicalMemorySizeMethod = getMethod(ibmOperatingSystemMxBeanClass, \"getFreePhysicalMemorySize\");\r\n            result = getValueFromMethodInvocation(ibmOperatingSystemMxBeanInstance, freePhysicalMemorySizeMethod);\r\n            if (!(result instanceof Number)) {\r\n                throw new Exception(\"Result of getFreePhysicalMemorySize() method invocation is not a number. Result was: \" + result);\r\n            }\r\n            processCpuTimeMethod = getMethod(ibmOperatingSystemMxBeanClass, \"getProcessCpuTime\");\r\n            result = getValueFromMethodInvocation(ibmOperatingSystemMxBeanInstance, processCpuTimeMethod);\r\n            if (!(result instanceof Number)) {\r\n                throw new Exception(\"Result of getProcessCpuTime() method invocation is not a number. Result was: \" + result);\r\n            }\r\n            totalPhysicalMemorySizeMethod = getMethod(ibmOperatingSystemMxBeanClass, \"getTotalPhysicalMemory\");\r\n            result = getValueFromMethodInvocation(ibmOperatingSystemMxBeanInstance, totalPhysicalMemorySizeMethod);\r\n            if (!(result instanceof Number)) {\r\n                throw new Exception(\"Result of getTotalPhysicalMemory() method invocation is not a number. Result was: \" + result);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.util.StringHelper.isNullOrEmptyString",
	"Comment": "indicates if the string is null or is empty ie only contains whitespaces.",
	"Method": "boolean isNullOrEmptyString(String value){\r\n    return value == null || value.trim().isEmpty();\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.logging.severity.SeverityHelper.getMinimumLevel",
	"Comment": "returns the configured minimum logging level for this severity checker.",
	"Method": "String getMinimumLevel(){\r\n    return minimumLevel;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHOrganization.listRepositories",
	"Comment": "lists up all the repositories using the specified page size.",
	"Method": "PagedIterable<GHRepository> listRepositories(int pageSize){\r\n    return new PagedIterable<GHRepository>() {\r\n        public PagedIterator<GHRepository> _iterator(int pageSize) {\r\n            return new PagedIterator<GHRepository>(root.retrieve().asIterator(\"/orgs/\" + login + \"/repos\", GHRepository[].class, pageSize)) {\r\n                @Override\r\n                protected void wrapUp(GHRepository[] page) {\r\n                    for (GHRepository c : page) c.wrap(root);\r\n                }\r\n            };\r\n        }\r\n    }.withPageSize(pageSize);\r\n}"
}, {
	"Path": "org.kohsuke.github.GHOrganization.listRepositories",
	"Comment": "lists up all the repositories using the specified page size.",
	"Method": "PagedIterable<GHRepository> listRepositories(int pageSize){\r\n    return new PagedIterator<GHRepository>(root.retrieve().asIterator(\"/orgs/\" + login + \"/repos\", GHRepository[].class, pageSize)) {\r\n        @Override\r\n        protected void wrapUp(GHRepository[] page) {\r\n            for (GHRepository c : page) c.wrap(root);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.kohsuke.github.GHOrganization.listRepositories",
	"Comment": "lists up all the repositories using the specified page size.",
	"Method": "PagedIterable<GHRepository> listRepositories(int pageSize){\r\n    for (GHRepository c : page) c.wrap(root);\r\n}"
}, {
	"Path": "org.kohsuke.github.GHBranch.isProtected",
	"Comment": "returns true if the push to this branch is restricted via branch protection.",
	"Method": "boolean isProtected(){\r\n    return protection;\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.getFilesHttpLocation",
	"Comment": "returns list of files paths with given extension for a storage in http form.",
	"Method": "Map<String, Long> getFilesHttpLocation(StorageData storageData,String extension){\r\n    Path storagePath = getStoragePath(storageData);\r\n    if ((storagePath == null) || !Files.isDirectory(storagePath)) {\r\n        return Collections.emptyMap();\r\n    }\r\n    final List<Path> filesPaths = new ArrayList();\r\n    Files.walkFileTree(storagePath, new SimpleFileVisitor<Path>() {\r\n        @Override\r\n        public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\r\n            if (file.toString().endsWith(extension)) {\r\n                filesPaths.add(file);\r\n            }\r\n            return super.visitFile(file, attrs);\r\n        }\r\n    });\r\n    Map<String, Long> result = new HashMap();\r\n    for (Path path : filesPaths) {\r\n        result.put(getPathAsHttp(path), Files.size(path));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.getFilesHttpLocation",
	"Comment": "returns list of files paths with given extension for a storage in http form.",
	"Method": "Map<String, Long> getFilesHttpLocation(StorageData storageData,String extension){\r\n    if (file.toString().endsWith(extension)) {\r\n        filesPaths.add(file);\r\n    }\r\n    return super.visitFile(file, attrs);\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeArrayDeque.ensureBufferSpace",
	"Comment": "ensures the internal buffer has enough free slots to storeexpectedadditions. increases internal buffer size if needed.",
	"Method": "void ensureBufferSpace(int expectedAdditions){\r\n    final int bufferLen = buffer.length;\r\n    final int elementsCount = size();\r\n    if (elementsCount + expectedAdditions >= bufferLen) {\r\n        final int emptySlot = 1;\r\n        final int newSize = resizer.grow(bufferLen, elementsCount + emptySlot, expectedAdditions);\r\n        assert newSize >= (elementsCount + expectedAdditions + emptySlot) : \"Resizer failed to\" + \" return sensible new size: \" + newSize + \" <= \" + (elementsCount + expectedAdditions);\r\n        try {\r\n            final KType[] newBuffer = Intrinsics.<KType>newArray(newSize);\r\n            if (bufferLen > 0) {\r\n                toArray(newBuffer);\r\n                tail = elementsCount;\r\n                head = 0;\r\n            }\r\n            this.buffer = newBuffer;\r\n        } catch (OutOfMemoryError e) {\r\n            throw new BufferAllocationException(\"Not enough memory to allocate new buffers: %,d -> %,d\", e, bufferLen, newSize);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeHashSet.ensureCapacity",
	"Comment": "ensure this container can hold at least thegiven number of elements without resizing its buffers.",
	"Method": "void ensureCapacity(int expectedElements){\r\n    if (expectedElements > resizeAt || keys == null) {\r\n        final KType[] prevKeys = Intrinsics.<KType[]>cast(this.keys);\r\n        allocateBuffers(minBufferSize(expectedElements, loadFactor));\r\n        if (prevKeys != null && !isEmpty()) {\r\n            rehash(prevKeys);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.proxy.impl.ProxyBuildPlanImpl.getLowestClassLoader",
	"Comment": "returns the lowest class loader from the given set of classloaders.",
	"Method": "ClassLoader getLowestClassLoader(Set<ClassLoader> loaders){\r\n    if (loaders.isEmpty() || ((loaders.size() == 1) && loaders.contains(null))) {\r\n        return ClassLoader.getSystemClassLoader();\r\n    }\r\n    for (ClassLoader cl : loaders) {\r\n        HashSet<ClassLoader> leftLoaders = new HashSet<ClassLoader>(loaders);\r\n        leftLoaders.remove(null);\r\n        ClassLoader it = cl;\r\n        while (it != null) {\r\n            leftLoaders.remove(it);\r\n            it = it.getParent();\r\n        }\r\n        if (leftLoaders.isEmpty()) {\r\n            return cl;\r\n        }\r\n    }\r\n    throw new InvalidProxyDescriptionException(\"The given loaders are not on a single path towards the bootstrap loader!\");\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.fma.Formation.removeMember",
	"Comment": "removes a member from its slot and updates slot assignments.",
	"Method": "void removeMember(FormationMember<T> member){\r\n    int slot = findMemberSlot(member);\r\n    if (slot >= 0) {\r\n        slotAssignmentStrategy.removeSlotAssignment(slotAssignments, slot);\r\n        updateSlotAssignments();\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.javaagent.JavaAgent.preloadClasses",
	"Comment": "preload some classes to prevent errors in the running application.",
	"Method": "void preloadClasses(){\r\n    LOGGER.info(\"Preloading classes ...\");\r\n    StringIndexOutOfBoundsException.class.getClass();\r\n    LOGGER.info(\"Preloading classes complete...\");\r\n}"
}, {
	"Path": "org.hibernate.validator.test.internal.engine.groups.sequence.SequenceOfSequencesTest.defaultGroupSequenceContainsOtherGroupSequences",
	"Comment": "a sequence of sequences is used as the default group sequence.",
	"Method": "void defaultGroupSequenceContainsOtherGroupSequences(){\r\n    Validator validator = ValidatorUtil.getValidator();\r\n    PlushCrocodile crocodile = new PlushCrocodile();\r\n    Set<ConstraintViolation<PlushCrocodile>> violations = validator.validate(crocodile);\r\n    assertThat(violations).containsOnlyViolations(violationOf(NotNull.class).withProperty(\"name\"));\r\n    crocodile.name = \"Ruben\";\r\n    violations = validator.validate(crocodile, AllConstraints.class);\r\n    assertThat(violations).containsOnlyViolations(violationOf(NotNull.class).withProperty(\"highestEducationalDegree\"));\r\n    crocodile.highestEducationalDegree = \"PhD\";\r\n    violations = validator.validate(crocodile, AllConstraints.class);\r\n    assertThat(violations).containsOnlyViolations(violationOf(NotNull.class).withProperty(\"length\"));\r\n    crocodile.length = 540;\r\n    violations = validator.validate(crocodile, AllConstraints.class);\r\n    assertThat(violations).containsOnlyViolations(violationOf(NotNull.class).withProperty(\"age\"));\r\n}"
}, {
	"Path": "org.kohsuke.github.GHPullRequest.getHead",
	"Comment": "the change that should be pulled. the tip of the commits to merge.",
	"Method": "GHCommitPointer getHead(){\r\n    return head;\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.CmrManagementService.postConstruct",
	"Comment": "is executed after dependency injection is done to perform any initialization.",
	"Method": "void postConstruct(){\r\n    timeStarted = System.currentTimeMillis();\r\n    dateStarted = new Date(timeStarted);\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"|-CMR Management Service active...\");\r\n    }\r\n}"
}, {
	"Path": "ch.hsr.geohash.GeoHash.within",
	"Comment": "returns true iff this is within the given geohash bounding box.",
	"Method": "boolean within(GeoHash boundingBox){\r\n    return (bits & boundingBox.mask()) == boundingBox.bits;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.valueextraction.ValueExtractorResolver.getValueExtractorCandidatesForCascadedValidation",
	"Comment": "used to determine the value extractor candidates valid for a declared type and type variable.\tthe effective value extractor will be narrowed from these candidates using the runtime type.\tused to optimize the choice of the value extractor in the case of cascading validation.",
	"Method": "Set<ValueExtractorDescriptor> getValueExtractorCandidatesForCascadedValidation(Type declaredType,TypeVariable<?> typeParameter){\r\n    Set<ValueExtractorDescriptor> valueExtractorDescriptors = new HashSet();\r\n    valueExtractorDescriptors.addAll(getRuntimeAndContainerElementCompliantValueExtractorsFromPossibleCandidates(declaredType, typeParameter, TypeHelper.getErasedReferenceType(declaredType), registeredValueExtractors));\r\n    valueExtractorDescriptors.addAll(getPotentiallyRuntimeTypeCompliantAndContainerElementCompliantValueExtractors(declaredType, typeParameter));\r\n    return CollectionHelper.toImmutableSet(valueExtractorDescriptors);\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.classcache.ClassCacheModification.removeDueToTypeChange",
	"Comment": "removes the given type from the cache by firing the remove event and cleaning all existing\treferences.",
	"Method": "void removeDueToTypeChange(Type existingType,Events events){\r\n    existingType.removeReferences();\r\n    fireAndSave(new NodeEvent(existingType, NodeEventType.REMOVED, null), events);\r\n    log.warn(\"Type \" + existingType + \" removed from the class-cache as it changed the base type.\");\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.AtomicBufferTest.analysisAndSize",
	"Comment": "tests that size of the elements is correctly analyzed and added to the buffer size.",
	"Method": "void analysisAndSize(){\r\n    Random random = new Random();\r\n    long elements = 3 + random.nextInt(10000);\r\n    elements += elements % 2;\r\n    int analyzers = 1 + random.nextInt(3);\r\n    when(bufferProperties.getInitialBufferSize()).thenReturn(elements);\r\n    when(bufferProperties.getEvictionOccupancyPercentage()).thenReturn(0.99f);\r\n    buffer.postConstruct();\r\n    DefaultData defaultData = mock(DefaultData.class);\r\n    when(defaultData.getObjectSize(objectSizes)).thenReturn(1L);\r\n    BufferAnalyzer[] analyzerArray = new BufferAnalyzer[analyzers];\r\n    for (int i = 0; i < analyzers; i++) {\r\n        BufferAnalyzer bufferAnalyzer = new BufferAnalyzer(buffer);\r\n        bufferAnalyzer.start();\r\n        analyzerArray[i] = bufferAnalyzer;\r\n    }\r\n    IBufferElement<DefaultData> first = null;\r\n    long firstRunElements = (long) (elements * 0.99f) - 1;\r\n    for (int i = 0; i < firstRunElements; i++) {\r\n        IBufferElement<DefaultData> bufferElement = new BufferElement(defaultData);\r\n        if (0 == i) {\r\n            first = bufferElement;\r\n        }\r\n        buffer.put(bufferElement);\r\n    }\r\n    while (buffer.getAnalyzedElements() < firstRunElements) {\r\n        Thread.sleep(50);\r\n    }\r\n    assertThat(buffer.getCurrentSize(), is(firstRunElements));\r\n    assertThat(buffer.getOccupancyPercentage(), is((float) firstRunElements / elements));\r\n    assertThat(buffer.shouldEvict(), is(false));\r\n    for (int i = 0; i < (elements - firstRunElements); i++) {\r\n        IBufferElement<DefaultData> bufferElement = new BufferElement(defaultData);\r\n        buffer.put(bufferElement);\r\n    }\r\n    while (buffer.getAnalyzedElements() < elements) {\r\n        Thread.sleep(50);\r\n    }\r\n    for (BufferAnalyzer bufferAnalyzer : analyzerArray) {\r\n        bufferAnalyzer.interrupt();\r\n    }\r\n    assertThat(buffer.getCurrentSize(), is(elements));\r\n    assertThat(buffer.getOccupancyPercentage(), is(1f));\r\n    assertThat(buffer.shouldEvict(), is(true));\r\n    assertThat(buffer.getAnalyzedElements(), is(elements));\r\n    for (int i = 0; i < elements; i++) {\r\n        assertThat(first.isAnalyzed(), is(true));\r\n        first = first.getNextElement();\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.invocationsequence.InvocationSequenceHookTest.noRemoveExceptionDelegation",
	"Comment": "no removing exception delegation done cause there is exception object.",
	"Method": "void noRemoveExceptionDelegation(){\r\n    long platformId = 1L;\r\n    long methodId1 = 3L;\r\n    long sensorTypeId = 11L;\r\n    long methodId2 = 23L;\r\n    Object object = mock(Object.class);\r\n    Object[] parameters = new Object[0];\r\n    Object result = mock(Object.class);\r\n    when(platformManager.getPlatformId()).thenReturn(platformId);\r\n    double firstTimerValue = 1000.0d;\r\n    double secondTimerValue = 1323.0d;\r\n    double thirdTimerValue = 1881.0d;\r\n    double fourthTimerValue = 2562.0d;\r\n    when(timer.getCurrentTime()).thenReturn(firstTimerValue, secondTimerValue, thirdTimerValue, fourthTimerValue);\r\n    RegisteredSensorConfig removingRsc = mock(RegisteredSensorConfig.class);\r\n    MethodSensorTypeConfig exceptionSensorConfig = mock(MethodSensorTypeConfig.class);\r\n    when(exceptionSensorConfig.getClassName()).thenReturn(ExceptionSensor.class.getName());\r\n    when(rsc.getMethodSensors()).thenReturn(Collections.<IMethodSensor>emptyList());\r\n    when(removingRsc.getMethodSensors()).thenReturn(Collections.singletonList(methodSensor));\r\n    when(methodSensor.getSensorTypeConfig()).thenReturn(exceptionSensorConfig);\r\n    invocationSequenceHook.beforeBody(methodId1, sensorTypeId, object, parameters, rsc);\r\n    invocationSequenceHook.beforeBody(methodId2, sensorTypeId, object, parameters, removingRsc);\r\n    ExceptionSensorData exceptionData = new ExceptionSensorData();\r\n    invocationSequenceHook.addDefaultData(exceptionData);\r\n    invocationSequenceHook.firstAfterBody(methodId2, sensorTypeId, object, parameters, result, false, removingRsc);\r\n    invocationSequenceHook.secondAfterBody(coreService, methodId2, sensorTypeId, object, parameters, result, false, removingRsc);\r\n    invocationSequenceHook.firstAfterBody(methodId1, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.secondAfterBody(coreService, methodId1, sensorTypeId, object, parameters, result, false, rsc);\r\n    verify(timer, times(4)).getCurrentTime();\r\n    ArgumentCaptor<InvocationSequenceData> captor = ArgumentCaptor.forClass(InvocationSequenceData.class);\r\n    verify(coreService, times(1)).addDefaultData(captor.capture());\r\n    InvocationSequenceData invocation = captor.getValue();\r\n    assertThat(invocation.getPlatformIdent(), is(platformId));\r\n    assertThat(invocation.getMethodIdent(), is(methodId1));\r\n    assertThat(invocation.getSensorTypeIdent(), is(sensorTypeId));\r\n    assertThat(invocation.getDuration(), is(fourthTimerValue - firstTimerValue));\r\n    assertThat(invocation.getNestedSequences(), hasSize(1));\r\n    assertThat(invocation.getChildCount(), is(1L));\r\n    InvocationSequenceData child = invocation.getNestedSequences().iterator().next();\r\n    assertThat(child.getPlatformIdent(), is(platformId));\r\n    assertThat(child.getMethodIdent(), is(methodId2));\r\n    assertThat(child.getSensorTypeIdent(), is(sensorTypeId));\r\n    assertThat(child.getDuration(), is(thirdTimerValue - secondTimerValue));\r\n    assertThat(child.getNestedSequences(), is(empty()));\r\n    assertThat(child.getParentSequence(), is(invocation));\r\n    assertThat(child.getChildCount(), is(0L));\r\n    assertThat(child.getExceptionSensorDataObjects(), is(Collections.singletonList(exceptionData)));\r\n    verifyZeroInteractions(realCoreService);\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.proxy.CorrectProxySubject.sayHello",
	"Comment": "test object return type and proxying of methods with limited visibility",
	"Method": "String sayHello(){\r\n    return \"Hello!\";\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.InvocationDataAccessService.postConstruct",
	"Comment": "is executed after dependency injection is done to perform any initialization.",
	"Method": "void postConstruct(){\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"|-Invocation Data Access Service active...\");\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.AtomicBuffer.getEvictedElemenets",
	"Comment": "returns the number of evicted elements since the buffer has been created.",
	"Method": "long getEvictedElemenets(){\r\n    return elementsEvicted.get();\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.reflection.CachedConstructor.findConstructor",
	"Comment": "fetches the constructor based from the context of the given classloader. caches the\tconstructor.",
	"Method": "Constructor<?> findConstructor(ClassLoader cl){\r\n    try {\r\n        return cachedConstructors.get(cl);\r\n    } catch (ExecutionException e) {\r\n        LOG.error(\"Could not locate constructor\", e.getCause());\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.queryCommits",
	"Comment": "search commits by specifying filters through a builder pattern.",
	"Method": "GHCommitQueryBuilder queryCommits(){\r\n    return new GHCommitQueryBuilder(this);\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.config.ConfigurationResolver.getInstrumentationAppliers",
	"Comment": "returns all instrumentation appliers for one environment.",
	"Method": "Collection<IInstrumentationApplier> getInstrumentationAppliers(Environment environment){\r\n    if (null == environment) {\r\n        return Collections.emptyList();\r\n    }\r\n    Collection<IInstrumentationApplier> appliers = new ArrayList();\r\n    for (String profileId : environment.getProfileIds()) {\r\n        try {\r\n            Profile profile = configurationInterfaceManager.getProfile(profileId);\r\n            if (!profile.isActive()) {\r\n                continue;\r\n            }\r\n            AbstractProfileData<?> profileData = profile.getProfileData();\r\n            if (profileData.isOfType(SensorAssignmentProfileData.class)) {\r\n                List<? extends AbstractClassSensorAssignment<?>> assignments = profileData.getData(SensorAssignmentProfileData.class);\r\n                if (CollectionUtils.isNotEmpty(assignments)) {\r\n                    for (AbstractClassSensorAssignment<?> assignment : assignments) {\r\n                        appliers.add(getInstrumentationApplier(assignment, environment));\r\n                    }\r\n                }\r\n            }\r\n        } catch (BusinessException e) {\r\n            if (log.isDebugEnabled()) {\r\n                log.debug(\"Profile with id \" + profileId + \" ignored during collecting method sensor assignments due to the exception.\", e);\r\n            }\r\n            continue;\r\n        }\r\n    }\r\n    for (SpecialMethodSensorAssignment functionalAssignment : specialAssignmentFactory.getSpecialAssignments(environment)) {\r\n        appliers.add(getInstrumentationApplier(functionalAssignment, environment));\r\n    }\r\n    return appliers;\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.copyBufferToStorage",
	"Comment": "copies the content of the current cmr buffer to the storage.",
	"Method": "void copyBufferToStorage(StorageData storageData,List<Long> platformIdents,Collection<AbstractDataProcessor> dataProcessors,boolean autoFinalize){\r\n    if (!isStorageExisting(storageData)) {\r\n        this.createStorage(storageData);\r\n    }\r\n    StorageData local = getLocalStorageDataObject(storageData);\r\n    if (!isStorageOpen(local)) {\r\n        this.openStorage(local);\r\n    }\r\n    DefaultData oldestBufferElement = buffer.getOldestElement();\r\n    if (null != oldestBufferElement) {\r\n        Date fromDate = new Date(oldestBufferElement.getTimeStamp().getTime());\r\n        Date toDate = null;\r\n        for (AbstractDataProcessor dataProcessor : dataProcessors) {\r\n            if (dataProcessor instanceof TimeFrameDataProcessor) {\r\n                TimeFrameDataProcessor timeFrameDataProcessor = (TimeFrameDataProcessor) dataProcessor;\r\n                if (timeFrameDataProcessor.getFromDate().after(fromDate)) {\r\n                    fromDate = timeFrameDataProcessor.getFromDate();\r\n                }\r\n                toDate = timeFrameDataProcessor.getToDate();\r\n                break;\r\n            }\r\n        }\r\n        for (Long platformId : platformIdents) {\r\n            List<DefaultData> toWriteList = storageDataDao.getAllDefaultDataForAgent(platformId.longValue(), fromDate, toDate);\r\n            this.writeToStorage(local, toWriteList, dataProcessors, true);\r\n        }\r\n    }\r\n    if (autoFinalize) {\r\n        this.closeStorage(local);\r\n    }\r\n    updateExistingStorageSize(local);\r\n}"
}, {
	"Path": "org.kohsuke.github.GHCommit.getLastStatus",
	"Comment": "gets the last status of this commit, which is what gets shown in the ui.",
	"Method": "GHCommitStatus getLastStatus(){\r\n    return owner.getLastCommitStatus(sha);\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.invocationsequence.InvocationSequenceHookTest.startEndInvocationWithActiveServerSpan",
	"Comment": "tests that the correct time and ids will be set on the invocation.",
	"Method": "void startEndInvocationWithActiveServerSpan(){\r\n    long platformId = 1L;\r\n    long methodId = 3L;\r\n    long sensorTypeId = 11L;\r\n    Object object = mock(Object.class);\r\n    Object[] parameters = new Object[0];\r\n    Object result = mock(Object.class);\r\n    SpanContextImpl context = SpanContextImpl.build();\r\n    when(tracer.getCurrentContext()).thenReturn(context);\r\n    when(tracer.isCurrentContextExisting()).thenReturn(true);\r\n    when(platformManager.getPlatformId()).thenReturn(platformId);\r\n    double firstTimerValue = 1000.0d;\r\n    double secondTimerValue = 1323.0d;\r\n    when(timer.getCurrentTime()).thenReturn(firstTimerValue, secondTimerValue);\r\n    when(rsc.getMethodSensors()).thenReturn(Collections.singletonList(methodSensor));\r\n    when(methodSensor.getSensorTypeConfig()).thenReturn(methodSensorTypeConfig);\r\n    invocationSequenceHook.beforeBody(methodId, sensorTypeId, object, parameters, rsc);\r\n    invocationSequenceHook.firstAfterBody(methodId, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.secondAfterBody(coreService, methodId, sensorTypeId, object, parameters, result, false, rsc);\r\n    verify(timer, times(2)).getCurrentTime();\r\n    ArgumentCaptor<InvocationSequenceData> captor = ArgumentCaptor.forClass(InvocationSequenceData.class);\r\n    verify(coreService, times(1)).addDefaultData(captor.capture());\r\n    InvocationSequenceData invocation = captor.getValue();\r\n    assertThat(invocation.getPlatformIdent(), is(platformId));\r\n    assertThat(invocation.getMethodIdent(), is(methodId));\r\n    assertThat(invocation.getSensorTypeIdent(), is(sensorTypeId));\r\n    assertThat(invocation.getDuration(), is(secondTimerValue - firstTimerValue));\r\n    assertThat(invocation.getNestedSequences(), is(empty()));\r\n    assertThat(invocation.getChildCount(), is(0L));\r\n    assertThat(invocation.getSpanIdent(), is(SpanContextTransformer.transformSpanContext(context)));\r\n    verifyZeroInteractions(realCoreService);\r\n}"
}, {
	"Path": "rocks.inspectit.server.util.AgentStatusDataProvider.registerDataSent",
	"Comment": "registers the time when last data was received for a given platform ident.",
	"Method": "void registerDataSent(long platformIdent){\r\n    AgentStatusData agentStatusData = agentStatusDataMap.get(platformIdent);\r\n    if (null != agentStatusData) {\r\n        agentStatusData.setLastDataSendTimestamp(System.currentTimeMillis());\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.StorageIntegrationTest.readUsingExtendedByteBufferInputStream",
	"Comment": "tests reading of data from created storage using our extendedbytebufferinputstream.",
	"Method": "void readUsingExtendedByteBufferInputStream(){\r\n    if (storageIndexingTree == null) {\r\n        return;\r\n    }\r\n    StorageIndexQuery query = new StorageIndexQuery();\r\n    List<Class<?>> searchedClasses = new ArrayList();\r\n    searchedClasses.add(InvocationSequenceData.class);\r\n    query.setObjectClasses(searchedClasses);\r\n    List<IStorageDescriptor> descriptors = storageIndexingTree.query(query);\r\n    assertThat(\"Amount of descriptors is less than the amount of invocations saved.\", descriptors.size(), is(equalTo(createdInvocations.size())));\r\n    for (IStorageDescriptor descriptor : descriptors) {\r\n        assertThat(\"position of descriptor is negative.\", descriptor.getPosition(), is(greaterThanOrEqualTo(0L)));\r\n        assertThat(\"Size of the descriptor is wrong.\", descriptor.getSize(), is(greaterThan(0L)));\r\n    }\r\n    int count = 0;\r\n    try (InputStream result = inputStreamProvider.getExtendedByteBufferInputStream(storageData, descriptors)) {\r\n        Input input = new Input(result);\r\n        while (KryoUtil.hasMoreBytes(input)) {\r\n            Object invocation = serializer.deserialize(input);\r\n            assertThat(invocation, is(instanceOf(InvocationSequenceData.class)));\r\n            assertThat(createdInvocations, hasItem((InvocationSequenceData) invocation));\r\n            count++;\r\n        }\r\n    }\r\n    assertThat(\"Amount of de-serialize objects is less than the amount of invocations saved.\", count, is(equalTo(createdInvocations.size())));\r\n}"
}, {
	"Path": "org.influxdb.InfluxDBTest.testWriteMultipleStringData",
	"Comment": "test writing multiple records to the database using string protocol.",
	"Method": "void testWriteMultipleStringData(){\r\n    String dbName = \"write_unittest_\" + System.currentTimeMillis();\r\n    this.influxDB.createDatabase(dbName);\r\n    String rp = TestUtils.defaultRetentionPolicy(this.influxDB.version());\r\n    this.influxDB.write(dbName, rp, InfluxDB.ConsistencyLevel.ONE, \"cpu,atag=test1 idle=100,usertime=10,system=1\\ncpu,atag=test2 idle=200,usertime=20,system=2\\ncpu,atag=test3 idle=300,usertime=30,system=3\");\r\n    Query query = new Query(\"SELECT * FROM cpu GROUP BY *\", dbName);\r\n    QueryResult result = this.influxDB.query(query);\r\n    Assertions.assertEquals(result.getResults().get(0).getSeries().size(), 3);\r\n    Assertions.assertEquals(\"test1\", result.getResults().get(0).getSeries().get(0).getTags().get(\"atag\"));\r\n    Assertions.assertEquals(\"test2\", result.getResults().get(0).getSeries().get(1).getTags().get(\"atag\"));\r\n    Assertions.assertEquals(\"test3\", result.getResults().get(0).getSeries().get(2).getTags().get(\"atag\"));\r\n    this.influxDB.deleteDatabase(dbName);\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.constraintdefinition.ConstraintDefinitionContribution.getValidatorDescriptors",
	"Comment": "returns a list of constraint validator descriptors for the constraint type of this instance.",
	"Method": "List<ConstraintValidatorDescriptor<A>> getValidatorDescriptors(){\r\n    return validatorDescriptors;\r\n}"
}, {
	"Path": "org.hibernate.validator.testutil.ConstraintViolationAssert.assertCorrectPropertyPathStringRepresentations",
	"Comment": "asserts that the given list of constraint violation paths matches the list of expected property paths.",
	"Method": "void assertCorrectPropertyPathStringRepresentations(Set<? extends ConstraintViolation<?>> violations,String expectedPropertyPaths){\r\n    List<String> actualPaths = violations.stream().map(ConstraintViolation::getPropertyPath).map(Path::toString).collect(Collectors.toList());\r\n    Assertions.assertThat(actualPaths).containsExactlyInAnyOrder(expectedPropertyPaths);\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeVTypeHashMap.putOrAdd",
	"Comment": "if key exists, putvalue is inserted into the map,otherwise any existing value is incremented by additionvalue.",
	"Method": "VType putOrAdd(KType key,VType putValue,VType incrementValue){\r\n    assert assigned < mask + 1;\r\n    int keyIndex = indexOf(key);\r\n    if (indexExists(keyIndex)) {\r\n        putValue = Intrinsics.<VType>add(Intrinsics.<VType>cast(values[keyIndex]), incrementValue);\r\n        indexReplace(keyIndex, putValue);\r\n    } else {\r\n        indexInsert(keyIndex, key, putValue);\r\n    }\r\n    return putValue;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.CollisionAvoidance.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum linear acceleration.",
	"Method": "CollisionAvoidance<T> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.html.HtmlTokenParser.getCaret",
	"Comment": "returns the current reading position. this caret may be modified, but only if the parser is\tfinished with the current token!",
	"Method": "Caret getCaret(){\r\n    return caret;\r\n}"
}, {
	"Path": "rocks.inspectit.server.ci.event.EnvironmentUpdateEvent.getFunctionalAssignmentsDifference",
	"Comment": "returns the difference from the functional assignments for the two environments. the\tresulting collection will include the assignments that exist in first environment and do not\texist in the second environment.",
	"Method": "Collection<? extends AbstractClassSensorAssignment<?>> getFunctionalAssignmentsDifference(SpecialMethodSensorAssignmentFactory factory,Environment e1,Environment e2){\r\n    Collection<SpecialMethodSensorAssignment> functionalAssignments1 = factory.getSpecialAssignments(e1);\r\n    Collection<SpecialMethodSensorAssignment> functionalAssignments2 = factory.getSpecialAssignments(e2);\r\n    return CollectionSubtractUtils.subtractSafe(functionalAssignments1, functionalAssignments2);\r\n}"
}, {
	"Path": "org.kohsuke.github.GHOrganization.hasMember",
	"Comment": "checks if this organization has the specified user as a member.",
	"Method": "boolean hasMember(GHUser user){\r\n    try {\r\n        root.retrieve().to(\"/orgs/\" + login + \"/members/\" + user.getLogin());\r\n        return true;\r\n    } catch (IOException ignore) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.util.ReflectionHelper.getIndexedValue",
	"Comment": "tries to retrieve the indexed value from the specified object.",
	"Method": "Object getIndexedValue(Object value,int index){\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    Iterable<?> iterable;\r\n    Type type = value.getClass();\r\n    if (isIterable(type)) {\r\n        iterable = ((Iterable<?>) value);\r\n    } else if (TypeHelper.isArray(type)) {\r\n        iterable = CollectionHelper.iterableFromArray(value);\r\n    } else {\r\n        return null;\r\n    }\r\n    int i = 0;\r\n    for (Object o : iterable) {\r\n        if (i == index) {\r\n            return o;\r\n        }\r\n        i++;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHPerson.populate",
	"Comment": "fully populate the data by retrieving missing data.depending on the original api call where this object is created, it may not contain everything.",
	"Method": "void populate(){\r\n    if (created_at != null) {\r\n        return;\r\n    }\r\n    if (root == null || root.isOffline()) {\r\n        return;\r\n    }\r\n    root.retrieve().to(url, this);\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.html.DecodingHtmlScriptInjector.fetchCoders",
	"Comment": "tries to fetch the decoders for the charset if this was not done yet.",
	"Method": "void fetchCoders(){\r\n    if (!codersInitialized()) {\r\n        try {\r\n            Charset chars = Charset.forName(charSet);\r\n            charEncoder = chars.newEncoder();\r\n            charDecoder = chars.newDecoder();\r\n        } catch (Exception e) {\r\n            LOG.error(\"Error fetching decoder for charset \" + charSet, e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.test.internal.engine.methodvalidation.AnnotationBasedMethodValidationTest.iterableParameterWithCascadingTypeParameter",
	"Comment": "todo move up once xml support is there for type level cascades",
	"Method": "void iterableParameterWithCascadingTypeParameter(){\r\n    Customer customer = new Customer(null);\r\n    List<Customer> customers = Arrays.asList(null, customer);\r\n    try {\r\n        customerRepository.iterableParameterWithCascadingTypeParameter(customers);\r\n        fail(\"Expected ConstraintViolationException wasn't thrown.\");\r\n    } catch (ConstraintViolationException e) {\r\n        assertEquals(e.getConstraintViolations().size(), 1);\r\n        ConstraintViolation<?> constraintViolation = e.getConstraintViolations().iterator().next();\r\n        assertEquals(constraintViolation.getMessage(), messagePrefix() + \"must not be null\");\r\n        assertMethod(constraintViolation, \"iterableParameterWithCascadingTypeParameter\", List.class);\r\n        assertParameterIndex(constraintViolation, 0);\r\n        assertMethodValidationType(constraintViolation, ElementKind.PARAMETER);\r\n        assertEquals(constraintViolation.getPropertyPath().toString(), \"iterableParameterWithCascadingTypeParameter.customer[1].name\");\r\n        assertEquals(constraintViolation.getRootBeanClass(), CustomerRepositoryImpl.class);\r\n        assertEquals(constraintViolation.getRootBean(), customerRepository);\r\n        assertEquals(constraintViolation.getLeafBean(), customer);\r\n        assertEquals(constraintViolation.getInvalidValue(), null);\r\n        assertEquals(constraintViolation.getExecutableParameters(), new Object[] { customers });\r\n        assertEquals(constraintViolation.getExecutableReturnValue(), null);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.rest.InvocationSequenceRestfulService.handleAllException",
	"Comment": "handling of all the exceptions happening in this controller.",
	"Method": "ModelAndView handleAllException(Exception exception){\r\n    return new JsonError(exception).asModelAndView();\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.instrumentation.asm.SpecialMethodInstrumenter.generateParameterSubstitutionIfResultNotNull",
	"Comment": "generates call to substitute the parameters of the method if the result on stack is a not\tnull array.",
	"Method": "void generateParameterSubstitutionIfResultNotNull(){\r\n    if (ArrayUtils.isEmpty(argumentTypes)) {\r\n        return;\r\n    }\r\n    for (int index = 0; index < argumentTypes.length; index++) {\r\n        loadLocal(passedArgumentsLocal);\r\n        push(index);\r\n        arrayLoad(IInstrumenterConstant.OBJECT_TYPE);\r\n        int local = newLocal(IInstrumenterConstant.OBJECT_TYPE);\r\n        storeLocal(local);\r\n        Type type = argumentTypes[index];\r\n        Label continueExecution = new Label();\r\n        loadLocal(local);\r\n        instanceOfSafe(type);\r\n        ifZCmp(EQ, continueExecution);\r\n        loadLocal(local);\r\n        unbox(type);\r\n        storeArg(index);\r\n        visitLabel(continueExecution);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.proxy.impl.ASMProxyBuilder.injectDelegationTargetFields",
	"Comment": "after the proxy class has been generated and injected, the static fields storing the\tdelegation targets have to be injected. this is done by this method.",
	"Method": "void injectDelegationTargetFields(IProxyBuildPlan plan,Map<IMethodBuildPlan, String> methodFields,Class<?> proxyClass){\r\n    try {\r\n        for (IMethodBuildPlan mplan : plan.getMethods()) {\r\n            Field f = proxyClass.getDeclaredField(methodFields.get(mplan));\r\n            f.setAccessible(true);\r\n            f.set(null, mplan.getTargetMethod());\r\n        }\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.connection.impl.KeepAliveManager.shouldReconnect",
	"Comment": "checks whether an attempt to reconnect should be executed. this method also handles the\tcounter variables to keep track of the state.",
	"Method": "boolean shouldReconnect(){\r\n    noConnectionCount++;\r\n    boolean shouldReconnect = noConnectionCount >= nextReconnectAt;\r\n    if (shouldReconnect) {\r\n        noConnectionCount = 0;\r\n        increaseNextReconnectAt();\r\n    }\r\n    return shouldReconnect;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.FollowPath.setPathOffset",
	"Comment": "sets the path offset to generate the target. can be negative if the owner has to move along the reverse direction.",
	"Method": "FollowPath<T, P> setPathOffset(float pathOffset){\r\n    this.pathOffset = pathOffset;\r\n    return this;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.xml.config.ValidationXmlParser.parseValidationXml",
	"Comment": "tries to check whether a validation.xml file exists and parses it.",
	"Method": "BootstrapConfiguration parseValidationXml(){\r\n    InputStream in = getValidationXmlInputStream();\r\n    if (in == null) {\r\n        return BootstrapConfigurationImpl.getDefaultBootstrapConfiguration();\r\n    }\r\n    ClassLoader previousTccl = run(GetClassLoader.fromContext());\r\n    try {\r\n        run(SetContextClassLoader.action(ValidationXmlParser.class.getClassLoader()));\r\n        XmlParserHelper xmlParserHelper = new XmlParserHelper();\r\n        in.mark(Integer.MAX_VALUE);\r\n        XMLEventReader xmlEventReader = xmlParserHelper.createXmlEventReader(VALIDATION_XML_FILE, new CloseIgnoringInputStream(in));\r\n        String schemaVersion = xmlParserHelper.getSchemaVersion(VALIDATION_XML_FILE, xmlEventReader);\r\n        xmlEventReader.close();\r\n        in.reset();\r\n        Schema schema = getSchema(xmlParserHelper, schemaVersion);\r\n        Validator validator = schema.newValidator();\r\n        validator.validate(new StreamSource(new CloseIgnoringInputStream(in)));\r\n        in.reset();\r\n        xmlEventReader = xmlParserHelper.createXmlEventReader(VALIDATION_XML_FILE, new CloseIgnoringInputStream(in));\r\n        ValidationConfigStaxBuilder validationConfigStaxBuilder = new ValidationConfigStaxBuilder(xmlEventReader);\r\n        xmlEventReader.close();\r\n        in.reset();\r\n        return validationConfigStaxBuilder.build();\r\n    } catch (XMLStreamException | IOException | SAXException e) {\r\n        throw LOG.getUnableToParseValidationXmlFileException(VALIDATION_XML_FILE, e);\r\n    } finally {\r\n        run(SetContextClassLoader.action(previousTccl));\r\n        closeStream(in);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.btree.decorator.SemaphoreGuard.end",
	"Comment": "releases the semaphore.\tthis method is called when the task exits.",
	"Method": "void end(){\r\n    if (semaphoreAcquired) {\r\n        if (semaphore == null) {\r\n            semaphore = NonBlockingSemaphoreRepository.getSemaphore(name);\r\n        }\r\n        semaphore.release();\r\n        semaphoreAcquired = false;\r\n    }\r\n    super.end();\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.proxy.impl.RuntimeLinker.createProxy",
	"Comment": "creates a proxy for a given proxysubject instance. the proxysubject is the object that\trecives the calls, the proxy redirects them to it.",
	"Method": "Object createProxy(Class<T> proxySubjectType,T proxySubject,ClassLoader context){\r\n    IProxyClassInfo proxyClassInfo = getProxyClass(proxySubjectType, context, true);\r\n    if (proxyClassInfo == null) {\r\n        return null;\r\n    } else {\r\n        try {\r\n            Object proxy = proxyClassInfo.createProxy(proxySubject);\r\n            proxySubject.proxyLinked(proxy, this);\r\n            return proxy;\r\n        } catch (Exception e) {\r\n            log.error(\"Error creating proxy: \" + e.getMessage());\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.instrumentation.TagInjectionResponseWrapper.setSessionIDCookie",
	"Comment": "generates and sets the cookie for tracking the user session.",
	"Method": "void setSessionIDCookie(){\r\n    Object[] cookies = wrappedRequest.getCookies();\r\n    if (cookies != null) {\r\n        for (Object cookieObj : cookies) {\r\n            WCookie cookie = WCookie.wrap(cookieObj);\r\n            if (JSAgentBuilder.SESSION_ID_COOKIE_NAME.equals(cookie.getName())) {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    String sessionID = ConversionUtils.toHexString(RandomUtils.randomLong());\r\n    ClassLoader cl = wrappedResponse.getWrappedElement().getClass().getClassLoader();\r\n    Object cookie = WCookie.newInstance(cl, JSAgentBuilder.SESSION_ID_COOKIE_NAME, sessionID);\r\n    WCookie wrappedCookie = WCookie.wrap(cookie);\r\n    wrappedCookie.setPath(\"/\");\r\n    wrappedResponse.addCookie(cookie);\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.classchecks.ParametersMethodOverrideCheck.getEnclosingTypeElementQualifiedNames",
	"Comment": "provides a formatted string containing qualified names of enclosing types of provided methods.",
	"Method": "String getEnclosingTypeElementQualifiedNames(Set<ExecutableElement> methods){\r\n    List<String> enclosingTypeElementQualifiedNames = CollectionHelper.newArrayList();\r\n    for (ExecutableElement method : methods) {\r\n        enclosingTypeElementQualifiedNames.add(getEnclosingTypeElementQualifiedName(method));\r\n    }\r\n    Collections.sort(enclosingTypeElementQualifiedNames);\r\n    return StringHelper.join(enclosingTypeElementQualifiedNames, \", \");\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.constraintdefinition.ConstraintDefinitionContribution.getConstraintType",
	"Comment": "returns the constraint annotation type for which this instance provides constraint validator instances.",
	"Method": "Class<A> getConstraintType(){\r\n    return constraintType;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.listRefs",
	"Comment": "retrieves all refs of the given type for the current github repository.",
	"Method": "PagedIterable<GHRef> listRefs(PagedIterable<GHRef> listRefs,String refType){\r\n    final String url = String.format(\"/repos/%s/%s/git/refs/%s\", getOwnerName(), name, refType);\r\n    return new PagedIterable<GHRef>() {\r\n        public PagedIterator<GHRef> _iterator(int pageSize) {\r\n            return new PagedIterator<GHRef>(root.retrieve().asIterator(url, GHRef[].class, pageSize)) {\r\n                protected void wrapUp(GHRef[] page) {\r\n                }\r\n            };\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.listRefs",
	"Comment": "retrieves all refs of the given type for the current github repository.",
	"Method": "PagedIterable<GHRef> listRefs(PagedIterable<GHRef> listRefs,String refType){\r\n    return new PagedIterator<GHRef>(root.retrieve().asIterator(url, GHRef[].class, pageSize)) {\r\n        protected void wrapUp(GHRef[] page) {\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.listRefs",
	"Comment": "retrieves all refs of the given type for the current github repository.",
	"Method": "PagedIterable<GHRef> listRefs(PagedIterable<GHRef> listRefs,String refType){\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.constraintvalidators.hv.ISBNValidator.checkChecksumISBN10",
	"Comment": "check the digits for isbn 10 using algorithm from\twikipedia.",
	"Method": "boolean checkChecksumISBN10(String isbn){\r\n    int sum = 0;\r\n    for (int i = 0; i < isbn.length() - 1; i++) {\r\n        sum += (isbn.charAt(i) - '0') * (i + 1);\r\n    }\r\n    char checkSum = isbn.charAt(9);\r\n    return sum % 11 == (checkSum == 'X' ? 10 : checkSum - '0');\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.analyzer.impl.ClassHashHelper.registerInstrumentationDefinition",
	"Comment": "registers the instrumentation result for the class with the given fqn.",
	"Method": "void registerInstrumentationDefinition(String fqn,InstrumentationDefinition instrumentationResult){\r\n    ClassEntry entry = getOrCreateEntry(fqn);\r\n    if ((null != instrumentationResult) && !instrumentationResult.isEmpty()) {\r\n        entry.setInstrumentationResult(instrumentationResult);\r\n    } else {\r\n        // NOPMD\r\n        entry.setInstrumentationResult(null);\r\n    }\r\n}"
}, {
	"Path": "org.kohsuke.github.GHTreeEntry.asTree",
	"Comment": "if this tree entry represents a directory, then return it.otherwise null.",
	"Method": "GHTree asTree(){\r\n    if (type.equals(\"tree\"))\r\n        return tree.repo.getTree(sha);\r\n    else\r\n        return null;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.constraintvalidators.hv.ISBNValidator.checkChecksumISBN13",
	"Comment": "check the digits for isbn 13 using algorithm from\twikipedia.",
	"Method": "boolean checkChecksumISBN13(String isbn){\r\n    int sum = 0;\r\n    for (int i = 0; i < isbn.length() - 1; i++) {\r\n        sum += (isbn.charAt(i) - '0') * (i % 2 == 0 ? 1 : 3);\r\n    }\r\n    char checkSum = isbn.charAt(12);\r\n    return 10 - sum % 10 == (checkSum - '0');\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.messageinterpolation.parser.TokenIterator.replaceCurrentInterpolationTerm",
	"Comment": "replaces the current interpolation term with the given string.",
	"Method": "void replaceCurrentInterpolationTerm(String replacement){\r\n    Token token = new Token(replacement);\r\n    token.terminate();\r\n    tokenList.set(currentPosition - 1, token);\r\n}"
}, {
	"Path": "ch.hsr.geohash.GeoHash.geoHashStringWithCharacterPrecision",
	"Comment": "this method uses the given number of characters as the desired precision\tvalue. the hash can only be 64bits long, thus a maximum precision of 12\tcharacters can be achieved.",
	"Method": "String geoHashStringWithCharacterPrecision(double latitude,double longitude,int numberOfCharacters){\r\n    GeoHash hash = withCharacterPrecision(latitude, longitude, numberOfCharacters);\r\n    return hash.toBase32();\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.classchecks.AbstractMethodOverrideCheck.collectOverriddenMethods",
	"Comment": "collect all the overridden elements of the inheritance tree.",
	"Method": "void collectOverriddenMethods(ExecutableElement overridingMethod,TypeElement currentTypeElement,MethodInheritanceTree.Builder methodInheritanceTreeBuilder){\r\n    if (isJavaLangObjectOrNull(currentTypeElement)) {\r\n        return;\r\n    }\r\n    collectOverriddenMethodsInInterfaces(overridingMethod, currentTypeElement, methodInheritanceTreeBuilder);\r\n    TypeElement superclassTypeElement = (TypeElement) typeUtils.asElement(currentTypeElement.getSuperclass());\r\n    if (superclassTypeElement == null) {\r\n        return;\r\n    }\r\n    ExecutableElement overriddenMethod = getOverriddenMethod(overridingMethod, superclassTypeElement);\r\n    if (overriddenMethod != null) {\r\n        methodInheritanceTreeBuilder.addOverriddenMethod(overridingMethod, overriddenMethod);\r\n        overridingMethod = overriddenMethod;\r\n    }\r\n    collectOverriddenMethods(overridingMethod, superclassTypeElement, methodInheritanceTreeBuilder);\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.DiagnosisCmrConfiguration.getDiagnosisService",
	"Comment": "gets the diagnosis service initializing it with the configurations established.",
	"Method": "IDiagnosisService getDiagnosisService(DiagnosisCmrProcessor processor){\r\n    List<String> rulesPackages = new ArrayList();\r\n    rulesPackages.add(RULES_PACKAGE);\r\n    IDiagnosisService diagnosisService = new DiagnosisService(this, rulesPackages, 2, 10L, 2);\r\n    processor.setDiagnosisService(diagnosisService);\r\n    return diagnosisService;\r\n}"
}, {
	"Path": "org.influxdb.impl.BatchProcessor.flushAndShutdown",
	"Comment": "flush the current open writes to influxdb and end stop the reaper thread. this should only becalled if no batch processing is needed anymore.",
	"Method": "void flushAndShutdown(){\r\n    this.write();\r\n    this.scheduler.shutdown();\r\n    this.batchWriter.close();\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.BufferProperties.postConstruct",
	"Comment": "is executed after dependency injection is done to perform any initialization.",
	"Method": "void postConstruct(){\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"|-Buffer properties initialized with following values:\");\r\n        log.info(\"||-Eviction occupancy percentage: \" + NumberFormat.getInstance().format(evictionOccupancyPercentage * 100) + \"%\");\r\n        log.info(\"||-Eviction fragment size percentage: \" + NumberFormat.getInstance().format(evictionFragmentSizePercentage * 100) + \"%\");\r\n        log.info(\"||-Indexing tree cleaning threads: \" + NumberFormat.getInstance().format(indexingTreeCleaningThreads));\r\n        log.info(\"||-Indexing waiting time: \" + NumberFormat.getInstance().format(indexingWaitTime) + \" ms\");\r\n        log.info(\"||-Min old generation occupancy percentage active till: \" + NumberFormat.getInstance().format(minOldSpaceOccupancyActiveTillOldGenSize) + \" bytes\");\r\n        log.info(\"||-Max old generation occupancy percentage active from: \" + NumberFormat.getInstance().format(maxOldSpaceOccupancyActiveFromOldGenSize) + \" bytes\");\r\n        log.info(\"||-Min old generation occupancy percentage: \" + NumberFormat.getInstance().format(minOldSpaceOccupancy * 100) + \"%\");\r\n        log.info(\"||-Max old generation occupancy percentage: \" + NumberFormat.getInstance().format(maxOldSpaceOccupancy * 100) + \"%\");\r\n        log.info(\"||-Max object size expansion: \" + NumberFormat.getInstance().format(maxObjectExpansionRate * 100) + \"%\");\r\n        log.info(\"||-Min object size expansion: \" + NumberFormat.getInstance().format(minObjectExpansionRate * 100) + \"%\");\r\n        log.info(\"||-Max object size expansion active from buffer occupancy: \" + NumberFormat.getInstance().format(maxObjectExpansionRateActiveFromOccupancy * 100) + \"%\");\r\n        log.info(\"||-Min object size expansion active till buffer occupancy: \" + NumberFormat.getInstance().format(minObjectExpansionRateActiveTillOccupancy * 100) + \" %\");\r\n        log.info(\"||-Max object size expansion active till buffer size: \" + NumberFormat.getInstance().format(maxObjectExpansionRateActiveTillBufferSize) + \" bytes\");\r\n        log.info(\"||-Min object size expansion active from buffer size: \" + NumberFormat.getInstance().format(minObjectExpansionRateActiveFromBufferSize) + \" bytes\");\r\n    }\r\n    if ((this.evictionOccupancyPercentage < 0) || (this.evictionOccupancyPercentage > 1)) {\r\n        throw new BeanInitializationException(\"Buffer properties initialization error: Eviction occupancy must be a percentage value between 0 and 1. Initialization value is: \" + evictionOccupancyPercentage);\r\n    }\r\n    if ((this.evictionFragmentSizePercentage < 0.01) || (this.evictionFragmentSizePercentage > 0.5)) {\r\n        throw new BeanInitializationException(\"Buffer properties initialization error: Eviction fragment size must be a percentage value between 0.01 and 0.5. Initialization value is: \" + evictionFragmentSizePercentage);\r\n    }\r\n    if (this.minObjectExpansionRateActiveFromBufferSize < this.maxObjectExpansionRateActiveTillBufferSize) {\r\n        throw new BeanInitializationException(\"Buffer properties initialization error: Buffer size from which minimum object expansion rate is active can not be lower than buffer size till which maximum object expansion rate is active. Initialization values are: \" + minObjectExpansionRateActiveFromBufferSize + \" (buffer size for min object expansion rate) and \" + maxObjectExpansionRateActiveTillBufferSize + \" (buffer size for max object expansion rate)\");\r\n    }\r\n    if (this.minObjectExpansionRateActiveTillOccupancy > this.maxObjectExpansionRateActiveFromOccupancy) {\r\n        throw new BeanInitializationException(\"Buffer properties initialization error: Buffer occupancy till which minimum object expansion rate is active can not be higher than buffer occupancy from which maximum object expansion rate is active. Initialization values are: \" + minObjectExpansionRateActiveTillOccupancy + \" (buffer occupancy for min object expansion rate) and \" + maxObjectExpansionRateActiveFromOccupancy + \" (buffer occupnacy for max object expansion rate)\");\r\n    }\r\n    if ((this.minObjectExpansionRateActiveTillOccupancy <= 0) || (this.minObjectExpansionRateActiveTillOccupancy > 1)) {\r\n        throw new BeanInitializationException(\"Buffer properties initialization error: The min object expansion rate till buffer old space gen occupancy can not be less or equal than zero, nor greater that one. Initialization value is: \" + this.minObjectExpansionRateActiveTillOccupancy);\r\n    }\r\n    if ((this.maxObjectExpansionRateActiveFromOccupancy <= 0) || (this.maxObjectExpansionRateActiveFromOccupancy > 1)) {\r\n        throw new BeanInitializationException(\"Buffer properties initialization error: The max object expansion rate from buffer old space gen occupancy can not be less or equal than zero, nor greater that one. Initialization value is: \" + this.maxObjectExpansionRateActiveFromOccupancy);\r\n    }\r\n    if ((this.getBytesMaintenancePercentage() <= 0) && (this.getBytesMaintenancePercentage() > this.getEvictionOccupancyPercentage())) {\r\n        throw new BeanInitializationException(\"Buffer properties initialization error: The buffer bytes maintenance percentage that activate the clean and update of the indexing tree can not be less or equal than zero nor bigger that eviction occupancy percentage. Initialization value is: \" + this.getBytesMaintenancePercentage());\r\n    }\r\n    if (this.getIndexingTreeCleaningThreads() <= 0) {\r\n        throw new BeanInitializationException(\"Buffer properties initialization error: The number of indexing tree cleaning threads can not be less or equal than zero. Initialization value is: \" + this.getIndexingTreeCleaningThreads());\r\n    }\r\n    if (this.indexingWaitTime <= 0) {\r\n        throw new BeanInitializationException(\"Buffer properties initialization error: The indexing wait time can not be less or equal than zero. Initialization value is: \" + this.indexingWaitTime);\r\n    }\r\n    if (this.minOldSpaceOccupancyActiveTillOldGenSize <= 0) {\r\n        throw new BeanInitializationException(\"Buffer properties initialization error: The min buffer occupancy percentage of the old generation heap space active till old generation size value can not be less or equal than zero. Initialization value is: \" + this.minOldSpaceOccupancyActiveTillOldGenSize);\r\n    }\r\n    if (this.maxOldSpaceOccupancyActiveFromOldGenSize <= 0) {\r\n        throw new BeanInitializationException(\"Buffer properties initialization error: The max buffer occupancy percentage of the old generation heap space active till old generation size value can not be less or equal than zero. Initialization value is: \" + this.maxOldSpaceOccupancyActiveFromOldGenSize);\r\n    }\r\n    if (this.minOldSpaceOccupancy > this.maxOldSpaceOccupancy) {\r\n        throw new BeanInitializationException(\"Buffer properties initialization error: The min buffer occupancy percentage of the old generation heap space can not be higer than max buffer occupancy percentage of the old generation. Initialization values are: \" + this.minOldSpaceOccupancy + \"(min), \" + this.maxOldSpaceOccupancy + \"(max)\");\r\n    }\r\n    if ((this.minOldSpaceOccupancy <= 0) || (this.minOldSpaceOccupancy > 1)) {\r\n        throw new BeanInitializationException(\"Buffer properties initialization error: The min buffer occupancy percentage of the old generation heap space can not be less or equal than zero, nor greater that one. Initialization value is: \" + this.minOldSpaceOccupancy);\r\n    }\r\n    if ((this.maxOldSpaceOccupancy <= 0) || (this.maxOldSpaceOccupancy > 1)) {\r\n        throw new BeanInitializationException(\"Buffer properties initialization error: The max buffer occupancy percentage of the old generation heap space can not be less or equal than zero, nor greater that one. Initialization value is: \" + this.maxOldSpaceOccupancy);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Interpose.getInternalTargetPosition",
	"Comment": "returns the current position of the internal target. this method is useful for debug purpose.",
	"Method": "T getInternalTargetPosition(){\r\n    return internalTargetPosition;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHLicense.populate",
	"Comment": "fully populate the data by retrieving missing data.depending on the original api call where this object is created, it may not contain everything.",
	"Method": "void populate(){\r\n    if (description != null)\r\n        return;\r\n    root.retrieve().withPreview(DRAX).to(url, this);\r\n}"
}, {
	"Path": "rocks.inspectit.server.influx.util.QueryResultWrapper.get",
	"Comment": "returns the object located in the specified row in the specified column or null\tif the series contains no data.",
	"Method": "Object get(int rowIndex,int columnIndex){\r\n    if (currentSeries == null) {\r\n        return null;\r\n    } else if ((rowIndex < 0) || (rowIndex > getRowCount())) {\r\n        throw new IndexOutOfBoundsException(\"The specified row '\" + rowIndex + \"' is out of bounds.\");\r\n    } else if ((columnIndex < 0) || (columnIndex > getColumnCount())) {\r\n        throw new IndexOutOfBoundsException(\"The specified column '\" + columnIndex + \"' is out of bounds.\");\r\n    } else {\r\n        return currentSeries.getValues().get(rowIndex).get(columnIndex);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.classcache.ClassCache.informReferenceChange",
	"Comment": "inform the registered listeners about changes to the class reference structure.\tnote that this method is synchronized. as it is ensured that only one thread can actively\tchange the structure this synchronization does not really hinder us. but is provides an\tadditional level of safety as the indexers can assume that they are only called single\tthreaded for sure.",
	"Method": "void informReferenceChange(ReferenceEvent e){\r\n    for (INodeChangeListener listener : nodeChangeListeners) {\r\n        listener.informReferenceChange(e);\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.classchecks.AbstractMethodOverrideCheck.getOverriddenMethod",
	"Comment": "find a method that is overridden by the one passed to this function.",
	"Method": "ExecutableElement getOverriddenMethod(ExecutableElement currentMethod,TypeElement typeElement){\r\n    if (typeElement == null) {\r\n        return null;\r\n    }\r\n    TypeElement enclosingTypeElement = getEnclosingTypeElement(currentMethod);\r\n    for (Element element : elementUtils.getAllMembers(typeElement)) {\r\n        if (!element.getKind().equals(ElementKind.METHOD)) {\r\n            continue;\r\n        }\r\n        if (elementUtils.overrides(currentMethod, (ExecutableElement) element, enclosingTypeElement)) {\r\n            return (ExecutableElement) element;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth2.ClientParametersAuthentication.getClientId",
	"Comment": "returns the client identifier issued to the client during the registration process.",
	"Method": "String getClientId(){\r\n    return clientId;\r\n}"
}, {
	"Path": "com.alorma.github.inapp.IabHelper.getResponseCodeFromIntent",
	"Comment": "workaround to bug where sometimes response codes come as long instead of integer",
	"Method": "int getResponseCodeFromIntent(Intent i){\r\n    Object o = i.getExtras().get(RESPONSE_CODE);\r\n    if (o == null) {\r\n        logError(\"Intent with no response code, assuming OK (known issue)\");\r\n        return BILLING_RESPONSE_RESULT_OK;\r\n    } else if (o instanceof Integer) {\r\n        return ((Integer) o).intValue();\r\n    } else if (o instanceof Long) {\r\n        return (int) ((Long) o).longValue();\r\n    } else {\r\n        logError(\"Unexpected type for intent response code.\");\r\n        logError(o.getClass().getName());\r\n        throw new RuntimeException(\"Unexpected type for intent response code: \" + o.getClass().getName());\r\n    }\r\n}"
}, {
	"Path": "org.kohsuke.github.GHCreateRepositoryBuilder.team",
	"Comment": "the team that gets granted access to this repository. only valid for creating a repository inan organization.",
	"Method": "GHCreateRepositoryBuilder team(GHTeam team){\r\n    if (team != null)\r\n        this.builder.with(\"team_id\", team.getId());\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.html.StreamedHtmlScriptInjector.scanHtmlPreamble",
	"Comment": "scans for an opening html tag, skipping preamble tags like or !doctype.",
	"Method": "void scanHtmlPreamble(){\r\n    if (CharSequenceUtils.checkEqualIgnoreCase(tokenParser.getTagType(), \"!DOCTYPE\")) {\r\n        if (tokenParser.getParsedTokenType() != Token.START_TAG) {\r\n            abortInjectionPointSearch();\r\n            return;\r\n        }\r\n        if (!CharSequenceUtils.checkEqualIgnoreCase(tokenParser.getTagArguments(), 0, 4, \"html\", 0, 4)) {\r\n            abortInjectionPointSearch();\r\n            return;\r\n        }\r\n        status = Status.SCAN_FOR_HTML_TAG;\r\n    } else {\r\n        status = Status.SCAN_FOR_HTML_TAG;\r\n        processToken();\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.unpackUploadedStorage",
	"Comment": "checks for the uploaded files in the storage uploads folder and tries to extract data to the\tdefault storage folder.",
	"Method": "void unpackUploadedStorage(IStorageData packedStorageData){\r\n    long storageBytesLeft = getBytesHardDriveOccupancyLeft();\r\n    if (packedStorageData.getDiskSize() > storageBytesLeft) {\r\n        throw new BusinessException(\"Unpack the uploaded storage \" + packedStorageData + \".\", StorageErrorCodeEnum.LOW_DISK_SPACE);\r\n    }\r\n    Path uploadPath = Paths.get(this.getStorageUploadsFolder());\r\n    if (Files.notExists(uploadPath)) {\r\n        throw new IOException(\"Can not perform storage unpacking. The main upload path \" + uploadPath.toString() + \" does not exist.\");\r\n    } else {\r\n        Files.walkFileTree(uploadPath, new SimpleFileVisitor<Path>() {\r\n            @Override\r\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\r\n                try {\r\n                    if (!file.toString().endsWith(StorageFileType.ZIP_STORAGE_FILE.getExtension())) {\r\n                        return FileVisitResult.CONTINUE;\r\n                    }\r\n                    IStorageData storageData = getStorageDataFromZip(file);\r\n                    if (!Objects.equals(packedStorageData, storageData)) {\r\n                        return FileVisitResult.CONTINUE;\r\n                    }\r\n                    if (null != storageData) {\r\n                        StorageData importedStorageData = new StorageData(storageData);\r\n                        if (existingStoragesSet.add(importedStorageData)) {\r\n                            printStorageCmrVersionWarn(storageData);\r\n                            unzipStorageData(file, getStoragePath(importedStorageData));\r\n                            Path localInformation = getStoragePath(importedStorageData).resolve(importedStorageData.getId() + StorageFileType.LOCAL_STORAGE_FILE.getExtension());\r\n                            Files.deleteIfExists(localInformation);\r\n                            writeStorageDataToDisk(importedStorageData);\r\n                        } else {\r\n                            log.info(\"Uploaded storage file \" + file.toString() + \" contains the storage that is already available on the CMR. File will be deleted.\");\r\n                        }\r\n                    }\r\n                    Files.deleteIfExists(file);\r\n                } catch (Exception e) {\r\n                    log.warn(\"Uploaded storage file \" + file.toString() + \" is not of correct type and can not be extracted. File will be deleted.\", e);\r\n                }\r\n                return FileVisitResult.CONTINUE;\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.unpackUploadedStorage",
	"Comment": "checks for the uploaded files in the storage uploads folder and tries to extract data to the\tdefault storage folder.",
	"Method": "void unpackUploadedStorage(IStorageData packedStorageData){\r\n    try {\r\n        if (!file.toString().endsWith(StorageFileType.ZIP_STORAGE_FILE.getExtension())) {\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n        IStorageData storageData = getStorageDataFromZip(file);\r\n        if (!Objects.equals(packedStorageData, storageData)) {\r\n            return FileVisitResult.CONTINUE;\r\n        }\r\n        if (null != storageData) {\r\n            StorageData importedStorageData = new StorageData(storageData);\r\n            if (existingStoragesSet.add(importedStorageData)) {\r\n                printStorageCmrVersionWarn(storageData);\r\n                unzipStorageData(file, getStoragePath(importedStorageData));\r\n                Path localInformation = getStoragePath(importedStorageData).resolve(importedStorageData.getId() + StorageFileType.LOCAL_STORAGE_FILE.getExtension());\r\n                Files.deleteIfExists(localInformation);\r\n                writeStorageDataToDisk(importedStorageData);\r\n            } else {\r\n                log.info(\"Uploaded storage file \" + file.toString() + \" contains the storage that is already available on the CMR. File will be deleted.\");\r\n            }\r\n        }\r\n        Files.deleteIfExists(file);\r\n    } catch (Exception e) {\r\n        log.warn(\"Uploaded storage file \" + file.toString() + \" is not of correct type and can not be extracted. File will be deleted.\", e);\r\n    }\r\n    return FileVisitResult.CONTINUE;\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.AtomicBufferTest.indexingTreeMaintenance",
	"Comment": "tests that the tree size calculations and maintenance is done.",
	"Method": "void indexingTreeMaintenance(){\r\n    Random random = new Random();\r\n    long flagsSetOnBytes = 30L;\r\n    long elements = 1 + random.nextInt(10000);\r\n    when(bufferProperties.getInitialBufferSize()).thenReturn(elements);\r\n    when(bufferProperties.getEvictionOccupancyPercentage()).thenReturn(0.5f);\r\n    when(bufferProperties.getEvictionFragmentSizePercentage()).thenReturn(0.35f);\r\n    when(bufferProperties.getFlagsSetOnBytes(anyLong())).thenReturn(flagsSetOnBytes);\r\n    when(bufferProperties.getIndexingWaitTime()).thenReturn(10L);\r\n    when(indexingTree.getComponentSize(objectSizes)).thenReturn(10L);\r\n    buffer.postConstruct();\r\n    DefaultData defaultData = mock(DefaultData.class);\r\n    when(defaultData.getObjectSize(objectSizes)).thenReturn(1L);\r\n    BufferAnalyzer bufferAnalyzer = new BufferAnalyzer(buffer);\r\n    bufferAnalyzer.start();\r\n    BufferIndexer bufferIndexer = new BufferIndexer(buffer);\r\n    bufferIndexer.start();\r\n    for (int i = 0; i < elements; i++) {\r\n        IBufferElement<DefaultData> bufferElement = new BufferElement(defaultData);\r\n        buffer.put(bufferElement);\r\n    }\r\n    while ((buffer.getAnalyzedElements() < elements) || (buffer.getIndexedElements() < elements)) {\r\n        Thread.sleep(50);\r\n    }\r\n    if (elements > flagsSetOnBytes) {\r\n        assertThat(buffer.getCurrentSize(), is(elements + 10L));\r\n        verify(indexingTree, atLeast(1)).getComponentSize(objectSizes);\r\n    } else {\r\n        assertThat(buffer.getCurrentSize(), is(elements));\r\n        verify(indexingTree, times(0)).getComponentSize(objectSizes);\r\n    }\r\n    assertThat(buffer.shouldEvict(), is(true));\r\n    buffer.evict();\r\n    long evicted = buffer.getEvictedElemenets();\r\n    buffer.put(new BufferElement(defaultData));\r\n    buffer.put(new BufferElement(defaultData));\r\n    while ((buffer.getAnalyzedElements() < (elements + 2)) || (buffer.getIndexedElements() < (elements + 2))) {\r\n        Thread.sleep(50);\r\n    }\r\n    bufferAnalyzer.interrupt();\r\n    bufferIndexer.interrupt();\r\n    if (evicted > flagsSetOnBytes) {\r\n        verify(indexingTree, times(1)).cleanWithRunnable(Matchers.<ExecutorService>anyObject());\r\n    } else {\r\n        verify(indexingTree, times(0)).cleanWithRunnable(Matchers.<ExecutorService>anyObject());\r\n    }\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.listForks",
	"Comment": "lists all the direct forks of this repository, sorted by the given sort order.",
	"Method": "PagedIterable<GHRepository> listForks(PagedIterable<GHRepository> listForks,ForkSort sort){\r\n    return new PagedIterable<GHRepository>() {\r\n        public PagedIterator<GHRepository> _iterator(int pageSize) {\r\n            return new PagedIterator<GHRepository>(root.retrieve().with(\"sort\", sort).asIterator(getApiTailUrl(\"forks\"), GHRepository[].class, pageSize)) {\r\n                @Override\r\n                protected void wrapUp(GHRepository[] page) {\r\n                    for (GHRepository c : page) {\r\n                        c.wrap(root);\r\n                    }\r\n                }\r\n            };\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.listForks",
	"Comment": "lists all the direct forks of this repository, sorted by the given sort order.",
	"Method": "PagedIterable<GHRepository> listForks(PagedIterable<GHRepository> listForks,ForkSort sort){\r\n    return new PagedIterator<GHRepository>(root.retrieve().with(\"sort\", sort).asIterator(getApiTailUrl(\"forks\"), GHRepository[].class, pageSize)) {\r\n        @Override\r\n        protected void wrapUp(GHRepository[] page) {\r\n            for (GHRepository c : page) {\r\n                c.wrap(root);\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.listForks",
	"Comment": "lists all the direct forks of this repository, sorted by the given sort order.",
	"Method": "PagedIterable<GHRepository> listForks(PagedIterable<GHRepository> listForks,ForkSort sort){\r\n    for (GHRepository c : page) {\r\n        c.wrap(root);\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth2.Credential.setRefreshToken",
	"Comment": "sets the refresh token.overriding is only supported for the purpose of calling the super implementation and changingthe return type, but nothing else.",
	"Method": "Credential setRefreshToken(String refreshToken){\r\n    lock.lock();\r\n    try {\r\n        if (refreshToken != null) {\r\n            Preconditions.checkArgument(jsonFactory != null && transport != null && clientAuthentication != null && tokenServerEncodedUrl != null, \"Please use the Builder and call setJsonFactory, setTransport, setClientAuthentication\" + \" and setTokenServerUrl/setTokenServerEncodedUrl\");\r\n        }\r\n        this.refreshToken = refreshToken;\r\n    } finally {\r\n        lock.unlock();\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.getRecordingStorage",
	"Comment": "if the recording is active, returns the storage that is used for storing recording data.",
	"Method": "StorageData getRecordingStorage(){\r\n    return recorderStorageData;\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeVTypeIdentityHashMapTest.newvArray",
	"Comment": "create a new array of a given type and copy the arguments to this array.",
	"Method": "VType[] newvArray(VType elements){\r\n    return elements;\r\n}"
}, {
	"Path": "org.influxdb.InfluxDBTest.testWriteEnableGzip",
	"Comment": "test writing multiple separate records to the database by gzip compress",
	"Method": "void testWriteEnableGzip(){\r\n    InfluxDB influxDBForTestGzip = InfluxDBFactory.connect(\"http://\" + TestUtils.getInfluxIP() + \":\" + TestUtils.getInfluxPORT(true), \"admin\", \"admin\");\r\n    String dbName = \"write_unittest_\" + System.currentTimeMillis();\r\n    try {\r\n        influxDBForTestGzip.setLogLevel(LogLevel.NONE);\r\n        influxDBForTestGzip.enableGzip();\r\n        influxDBForTestGzip.createDatabase(dbName);\r\n        String rp = TestUtils.defaultRetentionPolicy(this.influxDB.version());\r\n        influxDBForTestGzip.write(dbName, rp, InfluxDB.ConsistencyLevel.ONE, Arrays.asList(\"cpu,atag=test1 idle=100,usertime=10,system=1\", \"cpu,atag=test2 idle=200,usertime=20,system=2\", \"cpu,atag=test3 idle=300,usertime=30,system=3\"));\r\n        Query query = new Query(\"SELECT * FROM cpu GROUP BY *\", dbName);\r\n        QueryResult result = influxDBForTestGzip.query(query);\r\n        Assertions.assertEquals(result.getResults().get(0).getSeries().size(), 3);\r\n        Assertions.assertEquals(\"test1\", result.getResults().get(0).getSeries().get(0).getTags().get(\"atag\"));\r\n        Assertions.assertEquals(\"test2\", result.getResults().get(0).getSeries().get(1).getTags().get(\"atag\"));\r\n        Assertions.assertEquals(\"test3\", result.getResults().get(0).getSeries().get(2).getTags().get(\"atag\"));\r\n    } finally {\r\n        influxDBForTestGzip.deleteDatabase(dbName);\r\n        influxDBForTestGzip.close();\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.influx.util.InfluxQueryFactory.buildTraceIdForAlertQuery",
	"Comment": "creates a influxdb query for the given alert id. the query retrieves the ids of the\tinvocation sequences that constitute the alert.",
	"Method": "String buildTraceIdForAlertQuery(Alert alert){\r\n    StringBuilder builder = new StringBuilder();\r\n    builder.append(\"SELECT \\\"\").append(Series.BusinessTransaction.FIELD_TRACE_ID).append(\"\\\" FROM \\\"\").append(Series.BusinessTransaction.NAME);\r\n    builder.append(\"\\\" WHERE time >= \").append(alert.getStartTimestamp()).append(\"ms\");\r\n    if (alert.getStopTimestamp() >= 0) {\r\n        builder.append(\" AND time < \").append(alert.getStopTimestamp()).append(\"ms\");\r\n    }\r\n    for (Entry<String, String> entry : alert.getAlertingDefinition().getTags().entrySet()) {\r\n        builder.append(\" AND \\\"\").append(entry.getKey()).append(\"\\\" = '\").append(entry.getValue()).append('\\'');\r\n    }\r\n    builder.append(\" AND \\\"\").append(Series.BusinessTransaction.FIELD_DURATION).append(\"\\\" >= \").append(alert.getAlertingDefinition().getThreshold());\r\n    return builder.toString();\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.proxy.impl.ProxyBuildPlanImpl.computeTargetClassLoader",
	"Comment": "computes the target classloader to place the proxy in based on the used dependencies.",
	"Method": "void computeTargetClassLoader(){\r\n    HashSet<ClassLoader> dependencies = new HashSet<ClassLoader>();\r\n    dependencies.add(getSuperClass().getClassLoader());\r\n    for (Class<?> interf : getImplementedInterfaces()) {\r\n        dependencies.add(interf.getClassLoader());\r\n    }\r\n    for (MethodBuildPlanImpl meth : getMethods()) {\r\n        dependencies.add(meth.getReturnType().getClassLoader());\r\n        for (Class<?> type : meth.getParameterTypes()) {\r\n            dependencies.add(type.getClassLoader());\r\n        }\r\n    }\r\n    targetClassLoader = getLowestClassLoader(dependencies);\r\n}"
}, {
	"Path": "org.influxdb.dto.QueryTest.testGetCommandWithUrlEncoded",
	"Comment": "test getcommandwithurlencoded does what it is supposed to do.",
	"Method": "void testGetCommandWithUrlEncoded(){\r\n    String queryString1 = \"CREATE DATABASE \\\"testdb\\\"\";\r\n    String queryString2 = \"SELECT * FROM cpu;SELECT * FROM cpu;\";\r\n    String queryString3 = \";+%\";\r\n    String queryString4 = \"non_escape\";\r\n    String database = \"testdb\";\r\n    Query query1 = new Query(queryString1, database);\r\n    Query query2 = new Query(queryString2, database);\r\n    Query query3 = new Query(queryString3, database);\r\n    Query query4 = new Query(queryString4, database);\r\n    assertThat(query1.getCommandWithUrlEncoded()).isNotEqualTo(query1.getCommand());\r\n    assertThat(decode(query1.getCommandWithUrlEncoded())).isEqualTo(query1.getCommand());\r\n    assertThat(query2.getCommandWithUrlEncoded()).isNotEqualTo(query2.getCommand());\r\n    assertThat(decode(query2.getCommandWithUrlEncoded())).isEqualTo(query2.getCommand());\r\n    assertThat(query3.getCommandWithUrlEncoded()).isNotEqualTo(query3.getCommand());\r\n    assertThat(decode(query3.getCommandWithUrlEncoded())).isEqualTo(query3.getCommand());\r\n    assertThat(query4.getCommandWithUrlEncoded()).isEqualTo(query4.getCommand());\r\n    assertThat(decode(query4.getCommandWithUrlEncoded())).isEqualTo(query4.getCommand());\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.http.HttpInformationExtractor.getSessionAttributes",
	"Comment": "reads all session attributes from the httpsession of the given\thttpservletrequest object and stores them with the given\thttptimerdata object. this method ensures that no new session will be created.",
	"Method": "Map<String, String> getSessionAttributes(Class<?> httpServletRequestClass,Object httpServletRequest){\r\n    Method getSessionMethod = retrieveMethod(HttpMethods.SERVLET_GET_SESSION, httpServletRequestClass);\r\n    if (null == getSessionMethod) {\r\n        return null;\r\n    }\r\n    Object httpSession;\r\n    Class<?> httpSessionClass;\r\n    try {\r\n        httpSession = getSessionMethod.invoke(httpServletRequest, new Object[] { Boolean.FALSE });\r\n        if (httpSession == null) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"No session can be found\");\r\n            }\r\n            return null;\r\n        }\r\n        httpSessionClass = httpSession.getClass();\r\n    } catch (Exception e) {\r\n        LOG.error(\"Invocation of to get attributes on given object failed.\", e);\r\n        return null;\r\n    }\r\n    Method getAttributeNamesSession = retrieveMethod(HttpMethods.SESSION_GET_ATTRIBUTE_NAMES, httpSessionClass);\r\n    if (null == getAttributeNamesSession) {\r\n        return null;\r\n    }\r\n    Method getAttributeValueSession = retrieveMethod(HttpMethods.SESSION_GET_ATTRIBUTE, httpSessionClass);\r\n    if (null == getAttributeValueSession) {\r\n        return null;\r\n    }\r\n    try {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Enumeration<String> sessionAttr = (Enumeration<String>) getAttributeNamesSession.invoke(httpSession, (Object[]) null);\r\n        Map<String, String> sessionAttributes = new HashMap<String, String>();\r\n        if (null != sessionAttr) {\r\n            while (sessionAttr.hasMoreElements()) {\r\n                String sessionAtt = sessionAttr.nextElement();\r\n                Object sessionValue = getAttributeValueSession.invoke(httpSession, sessionAtt);\r\n                sessionAttributes.put(sessionAtt, strConstraint.crop(getAttributeValue(sessionValue)));\r\n            }\r\n            return sessionAttributes;\r\n        }\r\n    } catch (Exception e) {\r\n        LOG.error(\"Invocation of to get attributes on given object failed.\", e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.msg.MessageDispatcher.clear",
	"Comment": "removes all the telegrams from the queue and the registered listeners for all the messages.",
	"Method": "void clear(){\r\n    clearQueue();\r\n    clearListeners();\r\n    clearProviders();\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeArrayList.clone",
	"Comment": "clone this object. the returned clone will reuse the same hash function andarray resizing strategy.",
	"Method": "KTypeArrayList<KType> clone(){\r\n    try {\r\n        @SuppressWarnings(\"unchecked\")\r\n        final KTypeArrayList<KType> cloned = (KTypeArrayList<KType>) super.clone();\r\n        cloned.buffer = buffer.clone();\r\n        return cloned;\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.mail.EMailSender.parseRecipientsString",
	"Comment": "unwrap the comma separated list string of default recipients into a real list.",
	"Method": "void parseRecipientsString(){\r\n    defaultRecipients.clear();\r\n    if (null != defaultRecipientString) {\r\n        String[] strArray = defaultRecipientString.split(\",\");\r\n        for (String element : strArray) {\r\n            String address = element.trim();\r\n            if (EMailUtils.isValidEmailAddress(address)) {\r\n                defaultRecipients.add(address);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.ci.ConfigurationInterfaceManager.updateEnvironment",
	"Comment": "updates the given environment and saves it to the disk. update will fail with an exception\tenvironment does not exists on the cmr.\tenvironment revision sequence does not match the current sequence.",
	"Method": "Environment updateEnvironment(Environment environment,boolean checkProfiles){\r\n    if (checkProfiles) {\r\n        checkProfiles(environment);\r\n    }\r\n    String id = environment.getId();\r\n    environment.setRevision(environment.getRevision() + 1);\r\n    Environment local = existingEnvironments.replace(id, environment);\r\n    if (null == local) {\r\n        existingEnvironments.remove(id);\r\n        throw new BusinessException(\"Update of the environment '\" + environment.getName() + \".\", ConfigurationInterfaceErrorCodeEnum.ENVIRONMENT_DOES_NOT_EXIST);\r\n    } else if ((local != environment) && ((local.getRevision() + 1) != environment.getRevision())) {\r\n        existingEnvironments.replace(id, local);\r\n        BusinessException e = new BusinessException(\"Update of the environment '\" + environment.getName() + \".\", ConfigurationInterfaceErrorCodeEnum.REVISION_CHECK_FAILED);\r\n        environment.setRevision(environment.getRevision() - 1);\r\n        throw e;\r\n    }\r\n    environment.setUpdatedDate(new Date());\r\n    saveEnvironment(environment);\r\n    if (!Objects.equals(environment.getName(), local.getName())) {\r\n        Files.deleteIfExists(pathResolver.getEnvironmentFilePath(local));\r\n    }\r\n    publishEnvironmentUpdateEvent(local, environment);\r\n    return environment;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.MatchVelocity.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum linear acceleration.",
	"Method": "MatchVelocity<T> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.utils.rays.CentralRayWithWhiskersConfiguration.setWhiskerAngle",
	"Comment": "sets the angle in radians of the whiskers from the central ray.",
	"Method": "void setWhiskerAngle(float whiskerAngle){\r\n    this.whiskerAngle = whiskerAngle;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.cfg.context.DefaultConstraintMapping.getBeanConfigurations",
	"Comment": "returns all bean configurations configured through this constraint mapping.",
	"Method": "Set<BeanConfiguration<?>> getBeanConfigurations(ConstraintHelper constraintHelper,TypeResolutionHelper typeResolutionHelper,ValueExtractorManager valueExtractorManager){\r\n    Set<BeanConfiguration<?>> configurations = newHashSet();\r\n    for (TypeConstraintMappingContextImpl<?> typeContext : typeContexts) {\r\n        configurations.add(typeContext.build(constraintHelper, typeResolutionHelper, valueExtractorManager));\r\n    }\r\n    return configurations;\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.config.ConfigurationHolder.isInitialized",
	"Comment": "returns if the configuration in this holder is properly initialized.",
	"Method": "boolean isInitialized(){\r\n    return null != environment;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHCommit.populate",
	"Comment": "some of the fields are not always filled in when this object is retrieved as a part of another api call.",
	"Method": "void populate(){\r\n    if (files == null && stats == null)\r\n        owner.root.retrieve().to(owner.getApiTailUrl(\"commits/\" + sha), this);\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.getTree",
	"Comment": "retrive a tree of the given type for the current github repository.",
	"Method": "GHTree getTree(String sha){\r\n    String url = String.format(\"/repos/%s/%s/git/trees/%s\", getOwnerName(), name, sha);\r\n    return root.retrieve().to(url, GHTree.class).wrap(this);\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.util.ExecutableHelper.instanceMethodParametersResolveToSameTypes",
	"Comment": "whether the parameters of the two given instance methods resolve to the same types or not. takes type parameters into account.",
	"Method": "boolean instanceMethodParametersResolveToSameTypes(Method subTypeMethod,Method superTypeMethod,boolean instanceMethodParametersResolveToSameTypes,Class<?> mainSubType,Method left,Method right){\r\n    if (left.getParameterTypes().length == 0) {\r\n        return true;\r\n    }\r\n    ResolvedType resolvedSubType = typeResolver.resolve(mainSubType);\r\n    MemberResolver memberResolver = new MemberResolver(typeResolver);\r\n    memberResolver.setMethodFilter(new SimpleMethodFilter(left, right));\r\n    ResolvedTypeWithMembers typeWithMembers = memberResolver.resolve(resolvedSubType, null, null);\r\n    ResolvedMethod[] resolvedMethods = run(GetResolvedMemberMethods.action(typeWithMembers));\r\n    if (resolvedMethods.length == 1) {\r\n        return true;\r\n    }\r\n    try {\r\n        for (int i = 0; i < resolvedMethods[0].getArgumentCount(); i++) {\r\n            if (!resolvedMethods[0].getArgumentType(i).equals(resolvedMethods[1].getArgumentType(i))) {\r\n                return false;\r\n            }\r\n        }\r\n    } catch (ArrayIndexOutOfBoundsException e) {\r\n        LOG.debug(\"Error in ExecutableHelper#instanceMethodParametersResolveToSameTypes comparing \" + left + \" with \" + right);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "ch.hsr.geohash.GeoHash.getCharacterPrecision",
	"Comment": "returns the number of characters that represent this hash.",
	"Method": "int getCharacterPrecision(){\r\n    if (significantBits % 5 != 0) {\r\n        throw new IllegalStateException(\"precision of GeoHash is not divisble by 5: \" + this);\r\n    }\r\n    return significantBits / 5;\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.BufferProperties.getFlagsSetOnBytes",
	"Comment": "number of bytes that need to be added or removed for the buffer so that update and clean of\tthe indexing tree is performed.",
	"Method": "long getFlagsSetOnBytes(long bufferSize){\r\n    return (long) (bytesMaintenancePercentage * bufferSize);\r\n}"
}, {
	"Path": "com.hypertrack.hyperlog.HyperLog.getURL",
	"Comment": "call this method to get a end point url where logs need to be pushed.",
	"Method": "String getURL(){\r\n    return URL;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.instrumentation.TagInjectionResponseWrapper.commitHeaderData",
	"Comment": "called when the headers are commited. at this point of time we have to decide whether we\tforce chunked encoding.",
	"Method": "void commitHeaderData(){\r\n    if (headerCommitted) {\r\n        return;\r\n    }\r\n    headerCommitted = true;\r\n    if (isNonHtmlContentTypeSet()) {\r\n        for (Runnable cmd : contentLengthHeaderModifications) {\r\n            cmd.run();\r\n        }\r\n    } else {\r\n        setSessionIDCookie();\r\n        setTraceCorrelationInformation();\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.proxy.impl.RuntimeLinker.getProxyClass",
	"Comment": "checks the cache for a proxy class. if it does not exist, it is created.",
	"Method": "IProxyClassInfo getProxyClass(Class<T> subjectType,ClassLoader context,boolean create){\r\n    context = getActualClassLoader(context);\r\n    Cache<ClassLoader, IProxyClassInfo> classLoaderMap;\r\n    try {\r\n        classLoaderMap = linkedClassCache.get(subjectType);\r\n    } catch (ExecutionException e1) {\r\n        log.error(\"Error generating cache\", e1);\r\n        return null;\r\n    }\r\n    IProxyClassInfo proxyClassInfo = classLoaderMap.getIfPresent(context);\r\n    if (proxyClassInfo == null) {\r\n        synchronized (classLoaderMap) {\r\n            proxyClassInfo = classLoaderMap.getIfPresent(context);\r\n            if (proxyClassInfo == null) {\r\n                try {\r\n                    Class<?> proxyClazz = Class.forName(getProxyClassName(subjectType.getName()), false, context);\r\n                    ClassLoader owner = proxyClazz.getClassLoader();\r\n                    owner = getActualClassLoader(owner);\r\n                    proxyClassInfo = classLoaderMap.getIfPresent(owner);\r\n                    if (proxyClassInfo == null) {\r\n                        log.error(\"Proxy for \" + subjectType.getSimpleName() + \" already created but not in cache!\");\r\n                        return null;\r\n                    } else {\r\n                        classLoaderMap.put(context, proxyClassInfo);\r\n                    }\r\n                } catch (ClassNotFoundException e) {\r\n                    if (create) {\r\n                        try {\r\n                            String name = getProxyClassName(subjectType.getName());\r\n                            IProxyBuildPlan plan = ProxyBuildPlanImpl.create(subjectType, name, context);\r\n                            ClassLoader target = plan.getTargetClassLoader();\r\n                            try {\r\n                                Class<?> proxyClazz = Class.forName(name, false, target);\r\n                                ClassLoader owner = proxyClazz.getClassLoader();\r\n                                owner = getActualClassLoader(owner);\r\n                                proxyClassInfo = classLoaderMap.getIfPresent(owner);\r\n                                if (proxyClassInfo == null) {\r\n                                    log.error(\"Proxy for \" + subjectType.getSimpleName() + \" already created but not in cache!\");\r\n                                    return null;\r\n                                } else {\r\n                                    classLoaderMap.put(context, proxyClassInfo);\r\n                                }\r\n                            } catch (ClassNotFoundException e2) {\r\n                                proxyClassInfo = proxyBuilder.createProxyClass(plan);\r\n                                classLoaderMap.put(proxyClassInfo.getProxyClass().getClassLoader(), proxyClassInfo);\r\n                                classLoaderMap.put(context, proxyClassInfo);\r\n                            }\r\n                        } catch (Exception e2) {\r\n                            log.error(\"Could not create proxy for \" + subjectType.getName() + \" in classloader \" + context, e2);\r\n                            classLoaderMap.put(context, UNLINKEABLE_MARKER);\r\n                            proxyClassInfo = UNLINKEABLE_MARKER;\r\n                        }\r\n                    } else {\r\n                        return null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (UNLINKEABLE_MARKER.equals(proxyClassInfo)) {\r\n        return null;\r\n    } else {\r\n        return proxyClassInfo;\r\n    }\r\n}"
}, {
	"Path": "org.kohsuke.github.GitHub.connectAnonymously",
	"Comment": "connects to github anonymously.all operations that requires authentication will fail.",
	"Method": "GitHub connectAnonymously(){\r\n    return new GitHubBuilder().build();\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.getWritersStatus",
	"Comment": "returns the status of the active storage writers. this can be used for logging purposes.",
	"Method": "Map<StorageData, String> getWritersStatus(){\r\n    Map<StorageData, String> map = new HashMap();\r\n    for (Map.Entry<StorageData, StorageWriter> entry : openedStoragesMap.entrySet()) {\r\n        map.put(entry.getKey(), entry.getValue().getExecutorServiceStatus());\r\n    }\r\n    if (storageRecorder.isRecordingOn()) {\r\n        StorageData storageData = recorderStorageData;\r\n        StorageWriter storageWriter = storageRecorder.getStorageWriter();\r\n        if ((null != storageData) && (null != storageWriter)) {\r\n            map.put(storageData, storageWriter.getExecutorServiceStatus());\r\n        }\r\n    }\r\n    return map;\r\n}"
}, {
	"Path": "rocks.inspectit.server.jetty.JettyWebApplicationContextInitializer.setContextAttribute",
	"Comment": "initializes the context attribute used to bind the web application context to the\tservletcontext.",
	"Method": "void setContextAttribute(String contextAttribute){\r\n    this.contextAttribute = contextAttribute;\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.closeAllStorages",
	"Comment": "closes all opened storages. this method should only be called when the cmr shutdown hook is\tactivated to ensure that no data is lost.",
	"Method": "void closeAllStorages(){\r\n    if (storageRecorder.isRecordingOn() || storageRecorder.isRecordingScheduled()) {\r\n        try {\r\n            stopRecording();\r\n        } catch (Exception e) {\r\n            log.warn(\"Recording storage could not be finalized during the CMR shut-down.\", e);\r\n        }\r\n    }\r\n    for (StorageData openedStorage : openedStoragesMap.keySet()) {\r\n        try {\r\n            this.closeStorage(openedStorage);\r\n        } catch (Exception e) {\r\n            log.warn(\"Storage \" + openedStorage + \" could not be finalized during the CMR shut-down.\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth2.AuthorizationCodeFlow.getClock",
	"Comment": "returns the clock which will be passed along to the credential.",
	"Method": "Clock getClock(Clock getClock){\r\n    return clock;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Jump.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum linear acceleration and\tspeed.",
	"Method": "Jump<T> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sdk.opentracing.internal.impl.SpanBuilderImpl.doNotReport",
	"Comment": "explicitly states that the span created should not be reported.",
	"Method": "SpanBuilderImpl doNotReport(){\r\n    this.span.setReport(false);\r\n    return this;\r\n}"
}, {
	"Path": "hprose.server.HproseTcpServer.setThreadPoolEnabled",
	"Comment": "set thread pool enabled.this thread pool is not for the service threads, it is for the user service method.if your service method takes a long time, or will be blocked, please set this property to be true.",
	"Method": "void setThreadPoolEnabled(boolean value){\r\n    if (value && (threadPool == null)) {\r\n        threadPool = Executors.newCachedThreadPool();\r\n    }\r\n    threadPoolEnabled = value;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.config.impl.PropertyAccessorTest.nullNeededResultObjectForResultAccess",
	"Comment": "we no longer throw exceptions in the case that the return value is null as this would\tcompletely remove the property accessor and this is not the desired behaviour.",
	"Method": "void nullNeededResultObjectForResultAccess(){\r\n    PropertyPathStart start = new PropertyPathStart();\r\n    start.setName(\"this\");\r\n    start.setContentType(ParameterContentType.RETURN);\r\n    String result = propertyAccessor.getPropertyContent(start, null, null, null, false);\r\n    assertThat(result, is(equalTo(\"null\")));\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.PrioritySteering.getEpsilon",
	"Comment": "returns the threshold of the steering acceleration magnitude below which a steering behavior is considered to have given no\toutput.",
	"Method": "float getEpsilon(){\r\n    return epsilon;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.valueextraction.ValueExtractorResolver.getMaximallySpecificValueExtractors",
	"Comment": "used to find all the maximally specific value extractors based on a declared type in the case of value unwrapping.\tthere might be several of them as there might be several type parameters.\tused for container element constraints.",
	"Method": "Set<ValueExtractorDescriptor> getMaximallySpecificValueExtractors(Class<?> declaredType,Set<ValueExtractorDescriptor> getMaximallySpecificValueExtractors,Set<ValueExtractorDescriptor> possibleValueExtractors){\r\n    Set<ValueExtractorDescriptor> valueExtractorDescriptors = CollectionHelper.newHashSet(possibleValueExtractors.size());\r\n    for (ValueExtractorDescriptor descriptor : possibleValueExtractors) {\r\n        if (valueExtractorDescriptors.isEmpty()) {\r\n            valueExtractorDescriptors.add(descriptor);\r\n            continue;\r\n        }\r\n        Iterator<ValueExtractorDescriptor> candidatesIterator = valueExtractorDescriptors.iterator();\r\n        boolean isNewRoot = true;\r\n        while (candidatesIterator.hasNext()) {\r\n            ValueExtractorDescriptor candidate = candidatesIterator.next();\r\n            if (candidate.getContainerType().equals(descriptor.getContainerType())) {\r\n                continue;\r\n            }\r\n            if (TypeHelper.isAssignable(candidate.getContainerType(), descriptor.getContainerType())) {\r\n                candidatesIterator.remove();\r\n            } else if (TypeHelper.isAssignable(descriptor.getContainerType(), candidate.getContainerType())) {\r\n                isNewRoot = false;\r\n            }\r\n        }\r\n        if (isNewRoot) {\r\n            valueExtractorDescriptors.add(descriptor);\r\n        }\r\n    }\r\n    return valueExtractorDescriptors;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.http.HttpInformationExtractor.getServerName",
	"Comment": "reads the request server name from the httpservletrequest object.",
	"Method": "String getServerName(Class<?> httpServletRequestClass,Object httpServletRequest){\r\n    Method m = retrieveMethod(HttpMethods.RESPONSE_GET_SERVER_NAME, httpServletRequestClass);\r\n    if (null == m) {\r\n        return null;\r\n    }\r\n    try {\r\n        return (String) m.invoke(httpServletRequest, (Object[]) null);\r\n    } catch (Exception e) {\r\n        LOG.error(\"Invocation on given object failed.\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.invocationsequence.InvocationSequenceHookTest.startEndInvocationWithDataSaving",
	"Comment": "tests that the correct time and ids will be set on the invocation.",
	"Method": "void startEndInvocationWithDataSaving(){\r\n    long platformId = 1L;\r\n    long methodId = 3L;\r\n    long sensorTypeId = 11L;\r\n    Object object = mock(Object.class);\r\n    Object[] parameters = new Object[0];\r\n    Object result = mock(Object.class);\r\n    when(platformManager.getPlatformId()).thenReturn(platformId);\r\n    double firstTimerValue = 1000.0d;\r\n    double secondTimerValue = 1323.0d;\r\n    when(timer.getCurrentTime()).thenReturn(firstTimerValue, secondTimerValue);\r\n    when(rsc.getMethodSensors()).thenReturn(Collections.singletonList(methodSensor));\r\n    when(methodSensor.getSensorTypeConfig()).thenReturn(methodSensorTypeConfig);\r\n    invocationSequenceHook.beforeBody(methodId, sensorTypeId, object, parameters, rsc);\r\n    TimerData timerData = new TimerData();\r\n    SqlStatementData sqlStatementData = new SqlStatementData();\r\n    invocationSequenceHook.addDefaultData(timerData);\r\n    invocationSequenceHook.addDefaultData(sqlStatementData);\r\n    invocationSequenceHook.firstAfterBody(methodId, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.secondAfterBody(coreService, methodId, sensorTypeId, object, parameters, result, false, rsc);\r\n    verify(timer, times(2)).getCurrentTime();\r\n    ArgumentCaptor<InvocationSequenceData> captor = ArgumentCaptor.forClass(InvocationSequenceData.class);\r\n    verify(coreService, times(1)).addDefaultData(captor.capture());\r\n    InvocationSequenceData invocation = captor.getValue();\r\n    assertThat(invocation.getPlatformIdent(), is(platformId));\r\n    assertThat(invocation.getMethodIdent(), is(methodId));\r\n    assertThat(invocation.getSensorTypeIdent(), is(sensorTypeId));\r\n    assertThat(invocation.getDuration(), is(secondTimerValue - firstTimerValue));\r\n    assertThat(invocation.getNestedSequences(), is(empty()));\r\n    assertThat(invocation.getChildCount(), is(0L));\r\n    assertThat(invocation.getTimerData(), is(timerData));\r\n    assertThat(invocation.getSqlStatementData(), is(sqlStatementData));\r\n    assertThat(invocation.getSpanIdent(), is(nullValue()));\r\n    verifyZeroInteractions(realCoreService);\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.classcache.ClassCacheModification.mergeModifiers",
	"Comment": "merges the modifiers of two types and store the result to the base type.",
	"Method": "boolean mergeModifiers(TypeWithModifiers base,TypeWithModifiers given){\r\n    int baseMod = base.getModifiers();\r\n    base.setModifiers(Modifiers.mergeModifiers(base.getModifiers(), given.getModifiers()));\r\n    return baseMod != base.getModifiers();\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.BufferPropertiesTest.parametrizedExpansionRateTestBufferOccupancy",
	"Comment": "parameterized test to assure that no matter how big buffer size is, expansion rate will be\tbetween min and max related to buffer occupancy.",
	"Method": "void parametrizedExpansionRateTestBufferOccupancy(long bufferSize){\r\n    float expansionRate = bufferProperties.getObjectSecurityExpansionRateBufferOccupancy(bufferSize, bufferProperties.getOldGenMax());\r\n    assertThat(expansionRate, is(lessThanOrEqualTo(bufferProperties.getMaxObjectExpansionRate())));\r\n    assertThat(expansionRate, is(greaterThanOrEqualTo(bufferProperties.getMinObjectExpansionRate())));\r\n    long maxOldGen = bufferProperties.getOldGenMax();\r\n    float occupancy = bufferSize / maxOldGen;\r\n    if ((occupancy > bufferProperties.getMinObjectExpansionRateActiveTillOccupancy()) && (occupancy < bufferProperties.getMaxObjectExpansionRateActiveFromOccupancy())) {\r\n        assertThat(expansionRate, is(lessThan(bufferProperties.getMaxObjectExpansionRate())));\r\n        assertThat(expansionRate, is(greaterThan(bufferProperties.getMinObjectExpansionRate())));\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.classcache.ClassCache.getInstrumentationService",
	"Comment": "returns the instrumentation service, which allows to perform instrumentation operations\twithin the class cache.",
	"Method": "ClassCacheInstrumentation getInstrumentationService(){\r\n    return instrumentationService;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.instrumentation.asm.AbstractMethodInstrumenter.loadHookDispatcher",
	"Comment": "loads hook dispatcher on the stack so that methods can be executed on it.\tprotected access so we can change in tests.",
	"Method": "void loadHookDispatcher(){\r\n    mv.visitFieldInsn(Opcodes.GETSTATIC, IInstrumenterConstant.AGENT_INTERNAL_NAME, \"agent\", IInstrumenterConstant.IAGENT_DESCRIPTOR);\r\n    mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, IInstrumenterConstant.IAGENT_INTERNAL_NAME, \"getHookDispatcher\", IInstrumenterConstant.GET_IHOOK_DISPATCHER_DESCRIPTOR, true);\r\n}"
}, {
	"Path": "com.firebase.geofire.GeoQuery.setCenter",
	"Comment": "sets the new center of this query and triggers new events if necessary.",
	"Method": "void setCenter(GeoLocation center){\r\n    this.center = center;\r\n    if (this.hasListeners()) {\r\n        this.setupQueries();\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.util.StringHelper.join",
	"Comment": "joins the elements of the given iterable to a string, separated by the given separator string.",
	"Method": "String join(Object[] array,String separator,String join,Iterable<?> iterable,String separator){\r\n    if (iterable == null) {\r\n        return null;\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    boolean isFirst = true;\r\n    for (Object object : iterable) {\r\n        if (!isFirst) {\r\n            sb.append(separator);\r\n        } else {\r\n            isFirst = false;\r\n        }\r\n        sb.append(object);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.valueextraction.ValueExtractorManager.getMaximallySpecificAndRuntimeContainerElementCompliantValueExtractor",
	"Comment": "used to find the maximally specific and container element compliant value extractor based on the runtime type.\tthe maximally specific one is chosen among the candidates passed to this method.\tused for cascading validation.",
	"Method": "ValueExtractorDescriptor getMaximallySpecificAndRuntimeContainerElementCompliantValueExtractor(Type declaredType,TypeVariable<?> typeParameter,Class<?> runtimeType,Collection<ValueExtractorDescriptor> valueExtractorCandidates){\r\n    if (valueExtractorCandidates.size() == 1) {\r\n        return valueExtractorCandidates.iterator().next();\r\n    } else if (!valueExtractorCandidates.isEmpty()) {\r\n        return valueExtractorResolver.getMaximallySpecificAndRuntimeContainerElementCompliantValueExtractor(declaredType, typeParameter, runtimeType, valueExtractorCandidates);\r\n    } else {\r\n        return valueExtractorResolver.getMaximallySpecificAndRuntimeContainerElementCompliantValueExtractor(declaredType, typeParameter, runtimeType, registeredValueExtractors.values());\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.ConstraintAnnotationVisitor.checkConstraints",
	"Comment": "retrieves the checks required for the given element and annotations,\texecutes them and reports all occurred errors.",
	"Method": "void checkConstraints(Element annotatedElement,List<AnnotationMirror> mirrors){\r\n    for (AnnotationMirror oneAnnotationMirror : mirrors) {\r\n        try {\r\n            ConstraintChecks constraintChecks = constraintCheckFactory.getConstraintChecks(annotatedElement, oneAnnotationMirror);\r\n            reportIssues(constraintChecks.execute(annotatedElement, oneAnnotationMirror));\r\n        } catch (Exception e) {\r\n            if (verbose) {\r\n                messager.getDelegate().printMessage(Kind.NOTE, e.getMessage() != null ? e.getMessage() : e.toString(), annotatedElement, oneAnnotationMirror);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.test.internal.engine.methodvalidation.MethodLevelValidationGroupSequenceTest.processingOfGroupSequenceForReturnValueStopsAfterFirstErroneousGroup",
	"Comment": "only one constraint violation is expected, as processing should stop after the\tfirst erroneous group of the validated sequence.",
	"Method": "void processingOfGroupSequenceForReturnValueStopsAfterFirstErroneousGroup(){\r\n    setUpValidatorForGroups(ValidationSequence.class);\r\n    try {\r\n        customerRepository.constraintsInAllPartsOfGroupSequence();\r\n        fail(\"Expected MethodConstraintViolationException wasn't thrown.\");\r\n    } catch (ConstraintViolationException e) {\r\n        assertThat(e.getConstraintViolations()).containsOnlyViolations(violationOf(Min.class).withMessage(\"must be greater than or equal to 5\").withInvalidValue(1).withRootBeanClass(CustomerRepositoryWithRedefinedDefaultGroupImpl.class));\r\n        ConstraintViolation<?> constraintViolation = e.getConstraintViolations().iterator().next();\r\n        assertEquals(constraintViolation.getConstraintDescriptor().getGroups().iterator().next(), ValidationGroup2.class);\r\n    }\r\n}"
}, {
	"Path": "org.kohsuke.github.HttpException.getResponseMessage",
	"Comment": "http response message of the request that cause the exception",
	"Method": "String getResponseMessage(){\r\n    return responseMessage;\r\n}"
}, {
	"Path": "rocks.inspectit.server.alerting.AlertingStateLifecycleManager.noData",
	"Comment": "this method is called when no data is existing for the given threshold in the latest period.",
	"Method": "void noData(AlertingState alertingState){\r\n    if (alertingState == null) {\r\n        return;\r\n    }\r\n    if (log.isDebugEnabled()) {\r\n        log.debug(\"||-No data available for alerting definition '{}'. Expecting the same behavior as before.\", alertingState.getAlertingDefinition().getName());\r\n    }\r\n    if (!alertingState.isAlertActive() || (alertingState.getValidCount() > 0)) {\r\n        valid(alertingState);\r\n    } else {\r\n        violation(alertingState, Double.NaN);\r\n    }\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeHashSet.indexReplace",
	"Comment": "replaces the existing equivalent key with the given one and returns any previous valuestored for that key.",
	"Method": "KType indexReplace(int index,KType equivalentKey){\r\n    assert index >= 0 : \"The index must point at an existing key.\";\r\n    assert index <= mask || (index == mask + 1 && hasEmptyKey);\r\n    assert Intrinsics.equals(this, keys[index], equivalentKey);\r\n    KType previousValue = Intrinsics.<KType>cast(keys[index]);\r\n    keys[index] = equivalentKey;\r\n    return previousValue;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHReleaseUpdater.commitish",
	"Comment": "specifies the commitish value that determines where the git tag is created from. can be any branch orcommit sha.",
	"Method": "GHReleaseUpdater commitish(String commitish){\r\n    builder.with(\"target_commitish\", commitish);\r\n    return this;\r\n}"
}, {
	"Path": "org.kohsuke.github.Requester.setHeader",
	"Comment": "sets the request http header.if a header of the same name is already set, this method overrides it.",
	"Method": "void setHeader(String name,String value){\r\n    headers.put(name, value);\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.invocationsequence.InvocationSequenceHookTest.noRemoveWrappedSql",
	"Comment": "no removing done due to the wrapped sqls, because there is sql object.",
	"Method": "void noRemoveWrappedSql(){\r\n    long platformId = 1L;\r\n    long methodId1 = 3L;\r\n    long sensorTypeId = 11L;\r\n    long methodId2 = 23L;\r\n    Object object = mock(Object.class);\r\n    Object[] parameters = new Object[0];\r\n    Object result = mock(Object.class);\r\n    when(platformManager.getPlatformId()).thenReturn(platformId);\r\n    double firstTimerValue = 1000.0d;\r\n    double secondTimerValue = 1323.0d;\r\n    double thirdTimerValue = 1881.0d;\r\n    double fourthTimerValue = 2562.0d;\r\n    when(timer.getCurrentTime()).thenReturn(firstTimerValue, secondTimerValue, thirdTimerValue, fourthTimerValue);\r\n    when(rsc.getMethodSensors()).thenReturn(Collections.<IMethodSensor>emptyList());\r\n    invocationSequenceHook.beforeBody(methodId1, sensorTypeId, object, parameters, rsc);\r\n    invocationSequenceHook.beforeBody(methodId2, sensorTypeId, object, parameters, rsc);\r\n    SqlStatementData sqlStatementData = new SqlStatementData();\r\n    sqlStatementData.setCount(1L);\r\n    invocationSequenceHook.addDefaultData(sqlStatementData);\r\n    invocationSequenceHook.firstAfterBody(methodId2, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.secondAfterBody(coreService, methodId2, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.firstAfterBody(methodId1, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.secondAfterBody(coreService, methodId1, sensorTypeId, object, parameters, result, false, rsc);\r\n    verify(timer, times(4)).getCurrentTime();\r\n    ArgumentCaptor<InvocationSequenceData> captor = ArgumentCaptor.forClass(InvocationSequenceData.class);\r\n    verify(coreService, times(1)).addDefaultData(captor.capture());\r\n    InvocationSequenceData invocation = captor.getValue();\r\n    assertThat(invocation.getPlatformIdent(), is(platformId));\r\n    assertThat(invocation.getMethodIdent(), is(methodId1));\r\n    assertThat(invocation.getSensorTypeIdent(), is(sensorTypeId));\r\n    assertThat(invocation.getDuration(), is(fourthTimerValue - firstTimerValue));\r\n    assertThat(invocation.getNestedSequences(), hasSize(1));\r\n    assertThat(invocation.getChildCount(), is(1L));\r\n    InvocationSequenceData child = invocation.getNestedSequences().iterator().next();\r\n    assertThat(child.getPlatformIdent(), is(platformId));\r\n    assertThat(child.getMethodIdent(), is(methodId2));\r\n    assertThat(child.getSensorTypeIdent(), is(sensorTypeId));\r\n    assertThat(child.getDuration(), is(thirdTimerValue - secondTimerValue));\r\n    assertThat(child.getNestedSequences(), is(empty()));\r\n    assertThat(child.getParentSequence(), is(invocation));\r\n    assertThat(child.getChildCount(), is(0L));\r\n    assertThat(child.getSqlStatementData(), is(sqlStatementData));\r\n    verifyZeroInteractions(realCoreService);\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Jump.setTakeoffVelocityTolerance",
	"Comment": "sets the tolerance used to check if the owner has reached the takeoff velocity.",
	"Method": "Jump<T> setTakeoffVelocityTolerance(float takeoffVelocityTolerance){\r\n    this.takeoffVelocityTolerance = takeoffVelocityTolerance;\r\n    return this;\r\n}"
}, {
	"Path": "org.influxdb.impl.BatchProcessor.flush",
	"Comment": "flush the current open writes to influxdb. this will block until all pending points are written.",
	"Method": "void flush(){\r\n    this.write();\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.fma.Formation.changePattern",
	"Comment": "changes the pattern of this formation and updates slot assignments if the number of member is supported by the given\tpattern.",
	"Method": "boolean changePattern(FormationPattern<T> pattern){\r\n    int occupiedSlots = slotAssignments.size;\r\n    if (pattern.supportsSlots(occupiedSlots)) {\r\n        setPattern(pattern);\r\n        updateSlotAssignments();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth2.TokenRequest.setResponseClass",
	"Comment": "sets the tokenresponse class to allow specifying object parsing.",
	"Method": "TokenRequest setResponseClass(Class<? extends TokenResponse> responseClass){\r\n    this.responseClass = responseClass;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.btree.decorator.Repeat.start",
	"Comment": "draws a value from the distribution that determines how many times the wrapped task must be repeated. any negative value\tmeans forever.\tthis method is called when the task is entered.",
	"Method": "void start(){\r\n    count = times.nextInt();\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.util.Configuration.getDiagnosticKind",
	"Comment": "returns the diagnostickind to be used when reporting failing constraint checks.",
	"Method": "Kind getDiagnosticKind(){\r\n    return diagnosticKind;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.metadata.raw.ConstrainedExecutable.merge",
	"Comment": "creates a new constrained executable object by merging this and the given\tother executable. both executables must have the same location, i.e.\trepresent the same executable on the same type.",
	"Method": "ConstrainedExecutable merge(ConstrainedExecutable other){\r\n    ConfigurationSource mergedSource = ConfigurationSource.max(source, other.source);\r\n    List<ConstrainedParameter> mergedParameterMetaData = newArrayList(parameterMetaData.size());\r\n    int i = 0;\r\n    for (ConstrainedParameter parameter : parameterMetaData) {\r\n        mergedParameterMetaData.add(parameter.merge(other.getParameterMetaData(i)));\r\n        i++;\r\n    }\r\n    Set<MetaConstraint<?>> mergedCrossParameterConstraints = newHashSet(crossParameterConstraints);\r\n    mergedCrossParameterConstraints.addAll(other.crossParameterConstraints);\r\n    Set<MetaConstraint<?>> mergedReturnValueConstraints = newHashSet(constraints);\r\n    mergedReturnValueConstraints.addAll(other.constraints);\r\n    Set<MetaConstraint<?>> mergedTypeArgumentConstraints = new HashSet(typeArgumentConstraints);\r\n    mergedTypeArgumentConstraints.addAll(other.typeArgumentConstraints);\r\n    CascadingMetaDataBuilder mergedCascadingMetaDataBuilder = cascadingMetaDataBuilder.merge(other.cascadingMetaDataBuilder);\r\n    return new ConstrainedExecutable(mergedSource, callable, mergedParameterMetaData, mergedCrossParameterConstraints, mergedReturnValueConstraints, mergedTypeArgumentConstraints, mergedCascadingMetaDataBuilder);\r\n}"
}, {
	"Path": "org.hibernate.validator.test.internal.engine.methodvalidation.cascadedgroupvalidation.CascadedMethodLevelValidationGroupSequenceTest.cascadedReturnValueConstraintInSecondGroup",
	"Comment": "expect a single constraint violation from the second validation group.",
	"Method": "void cascadedReturnValueConstraintInSecondGroup(){\r\n    setUpValidatorForGroups(CompoundGroup.class);\r\n    try {\r\n        entityRepository.getEntity(new CompoundEntity(new Entity(\"value\", null)));\r\n        fail(\"Expected MethodConstraintViolationException wasn't thrown.\");\r\n    } catch (ConstraintViolationException e) {\r\n        assertThat(e.getConstraintViolations()).containsOnlyViolations(violationOf(NotNull.class).withMessage(\"must not be null\").withInvalidValue(null).withRootBeanClass(CompoundEntityRepositoryImpl.class));\r\n        ConstraintViolation<?> constraintViolation = e.getConstraintViolations().iterator().next();\r\n        assertEquals(constraintViolation.getConstraintDescriptor().getGroups().iterator().next(), ValidationGroup2.class);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.http.HttpInformationExtractor.retrieveMethod",
	"Comment": "tries a lookup in the cache first, then tries to get the method object via\treflection.",
	"Method": "Method retrieveMethod(HttpMethods httpMethod,Class<?> clazzUsedToLookup){\r\n    String cacheLookupName = getCacheLookupName(httpMethod, clazzUsedToLookup);\r\n    Method m = methodCache.get(cacheLookupName);\r\n    if (null == m) {\r\n        try {\r\n            m = clazzUsedToLookup.getMethod(httpMethod.methodName, httpMethod.parameters);\r\n            m.setAccessible(true);\r\n            Method existing = methodCache.putIfAbsent(cacheLookupName, m);\r\n            if (null != existing) {\r\n                m = existing;\r\n            }\r\n        } catch (Exception e) {\r\n            LOG.error(\"The provided class \" + clazzUsedToLookup.getName() + \" did not provide the desired method.\", e);\r\n            methodCache.putIfAbsent(cacheLookupName, markerMethod);\r\n        }\r\n    } else if (markerMethod.equals(m)) {\r\n        return null;\r\n    }\r\n    return m;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.constraintvalidation.ComposingConstraintTree.prepareFinalConstraintViolations",
	"Comment": "before the final constraint violations can be reported back we need to check whether we have a composing\tconstraint whose result should be reported as single violation.",
	"Method": "void prepareFinalConstraintViolations(ValidationContext<?> validationContext,ValueContext<?, ?> valueContext,Collection<ConstraintValidatorContextImpl> violatedConstraintValidatorContexts,Optional<ConstraintValidatorContextImpl> localConstraintValidatorContext){\r\n    if (reportAsSingleViolation()) {\r\n        violatedConstraintValidatorContexts.clear();\r\n        if (!localConstraintValidatorContext.isPresent()) {\r\n            violatedConstraintValidatorContexts.add(validationContext.createConstraintValidatorContextFor(descriptor, valueContext.getPropertyPath()));\r\n        }\r\n    }\r\n    if (localConstraintValidatorContext.isPresent()) {\r\n        violatedConstraintValidatorContexts.add(localConstraintValidatorContext.get());\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.http.HttpInformationExtractor.getRequestMethod",
	"Comment": "reads the request uri from the given httpservletrequest object and stores it\twith the given httptimerdata object.",
	"Method": "String getRequestMethod(Class<?> httpServletRequestClass,Object httpServletRequest){\r\n    Method m = retrieveMethod(HttpMethods.SERVLET_GET_METHOD, httpServletRequestClass);\r\n    if (null == m) {\r\n        return HttpInfo.UNDEFINED;\r\n    }\r\n    try {\r\n        String requestMethod = (String) m.invoke(httpServletRequest, (Object[]) null);\r\n        if (null != requestMethod) {\r\n            return requestMethod;\r\n        } else {\r\n            return HttpInfo.UNDEFINED;\r\n        }\r\n    } catch (Exception e) {\r\n        LOG.error(\"Invocation on given object failed.\", e);\r\n        return HttpInfo.UNDEFINED;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.ci.ConfigurationInterfaceManager.getProfileDifference",
	"Comment": "returns profile differences between two profiles. the result collection will contain profiles\tthat exists in the e1 and do not exist in e2.",
	"Method": "Collection<Profile> getProfileDifference(Environment e1,Environment e2){\r\n    Collection<Profile> profiles = new ArrayList();\r\n    Collection<String> profilesIds = CollectionSubtractUtils.subtractSafe(e1.getProfileIds(), e2.getProfileIds());\r\n    for (String id : profilesIds) {\r\n        try {\r\n            profiles.add(getProfile(id));\r\n        } catch (BusinessException e) {\r\n            if (log.isDebugEnabled()) {\r\n                log.debug(\"Profile with id \" + id + \" ignored during profile difference calculation as it does not exist anymore.\", e);\r\n            }\r\n            continue;\r\n        }\r\n    }\r\n    return profiles;\r\n}"
}, {
	"Path": "org.hibernate.validator.cdi.internal.ValidationProviderHelper.determineRequiredQualifiers",
	"Comment": "returns the qualifiers to be used for registering a validator or validator factory.",
	"Method": "Set<Annotation> determineRequiredQualifiers(boolean isDefaultProvider,boolean isHibernateValidator){\r\n    HashSet<Annotation> qualifiers = newHashSet(3);\r\n    if (isDefaultProvider) {\r\n        qualifiers.add(new AnnotationLiteral<Default>() {\r\n        });\r\n    }\r\n    if (isHibernateValidator) {\r\n        qualifiers.add(new AnnotationLiteral<HibernateValidator>() {\r\n        });\r\n    }\r\n    qualifiers.add(new AnnotationLiteral<Any>() {\r\n    });\r\n    return qualifiers;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Alignment.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum linear acceleration.",
	"Method": "Alignment<T> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.server.influx.builder.eum.EUMCachingParentPointBuilder.tryPointBuildingForPendingElement",
	"Comment": "tries to build the points for the corresponding element, which previously depended on\tunavailable data.",
	"Method": "void tryPointBuildingForPendingElement(AbstractEUMSpanDetails element){\r\n    synchronized (element) {\r\n        @SuppressWarnings(\"rawtypes\")\r\n        Pair<Boolean, AbstractEUMPointBuilder> pair = pendingDataPoints.getIfPresent(element);\r\n        if (pair != null) {\r\n            @SuppressWarnings(\"rawtypes\")\r\n            AbstractEUMPointBuilder responsibleBuilder = pair.getSecond();\r\n            boolean isBrowserInfoCaptured = pair.getFirst();\r\n            boolean requiredDataIsPresent = true;\r\n            PageLoadRequest plr = null;\r\n            UserSessionInfo sessInfo = null;\r\n            Long sessId = element.getOwningSpan().getSessionId();\r\n            Long tabId = element.getOwningSpan().getTabId();\r\n            Pair<Long, Long> plrSessionTabId = new Pair<Long, Long>(sessId, tabId);\r\n            if (responsibleBuilder.requiresPageLoadRequest()) {\r\n                plr = pageLoadRequestCache.getIfPresent(plrSessionTabId);\r\n                if (plr == null) {\r\n                    requiredDataIsPresent = false;\r\n                }\r\n            }\r\n            if (responsibleBuilder.requiresSessionMetaInfo() && isBrowserInfoCaptured) {\r\n                sessInfo = sessionInfoCache.getIfPresent(sessId);\r\n                if ((sessInfo == null)) {\r\n                    requiredDataIsPresent = false;\r\n                }\r\n            }\r\n            if (requiredDataIsPresent) {\r\n                dataPointsToWrite.addAll(responsibleBuilder.build(sessInfo, plr, element));\r\n                pendingDataPoints.invalidate(element);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.reflection.ClassLoaderAwareClassCache.isInstance",
	"Comment": "checks if the given object is an isntance of the class specified by the given full qualified\tname. if such a class does not exist in the context of this object, false is returned.",
	"Method": "boolean isInstance(Object objToCheck,String fqn){\r\n    Class<?> clazz = lookupClass(fqn, objToCheck.getClass().getClassLoader());\r\n    if (clazz == null) {\r\n        return false;\r\n    } else {\r\n        return clazz.isInstance(objToCheck);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.AtomicBuffer.substractFromCurrentSize",
	"Comment": "subtracts size value from the current size.\tthis method is thread safe.",
	"Method": "void substractFromCurrentSize(long size){\r\n    currentSize.addAndGet(-(size));\r\n    dataRemovedInBytes.addAndGet(size);\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.getCompare",
	"Comment": "gets a comparison between 2 points in the repository. this would be similarto calling git log id1...id2 against a local repository.",
	"Method": "GHCompare getCompare(String id1,String id2,GHCompare getCompare,GHCommit id1,GHCommit id2,GHCompare getCompare,GHBranch id1,GHBranch id2){\r\n    GHRepository owner1 = id1.getOwner();\r\n    GHRepository owner2 = id2.getOwner();\r\n    if (owner1 != null && owner2 != null) {\r\n        String ownerName1 = owner1.getOwnerName();\r\n        String ownerName2 = owner2.getOwnerName();\r\n        if (!StringUtils.equals(ownerName1, ownerName2)) {\r\n            String qualifiedName1 = String.format(\"%s:%s\", ownerName1, id1.getName());\r\n            String qualifiedName2 = String.format(\"%s:%s\", ownerName2, id2.getName());\r\n            return getCompare(qualifiedName1, qualifiedName2);\r\n        }\r\n    }\r\n    return getCompare(id1.getName(), id2.getName());\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.msg.PriorityQueue.siftDown",
	"Comment": "inserts item x at position k, maintaining heap invariant by demoting x down the tree repeatedly until it is less than or\tequal to its children or is a leaf.",
	"Method": "void siftDown(int k,E x){\r\n    int half = size >>> 1;\r\n    while (k < half) {\r\n        int child = (k << 1) + 1;\r\n        E c = (E) queue[child];\r\n        int right = child + 1;\r\n        if (right < size && c.compareTo((E) queue[right]) > 0)\r\n            c = (E) queue[child = right];\r\n        if (x.compareTo(c) <= 0)\r\n            break;\r\n        queue[k] = c;\r\n        k = child;\r\n    }\r\n    queue[k] = x;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.proxy.impl.ASMProxyBuilder.generateDelegationMethodTargetFields",
	"Comment": "generates the static fields of type java.lang.reflection.method which store the delegation\ttargets.",
	"Method": "Map<IMethodBuildPlan, String> generateDelegationMethodTargetFields(IProxyBuildPlan plan,ClassWriter cw){\r\n    if (CollectionUtils.isEmpty(plan.getMethods())) {\r\n        return Collections.emptyMap();\r\n    }\r\n    Map<IMethodBuildPlan, String> methodFields = new HashMap<IMethodBuildPlan, String>();\r\n    int counter = 1;\r\n    for (IMethodBuildPlan mplan : plan.getMethods()) {\r\n        String name = METHOD_FIELD_PREFIX + counter;\r\n        cw.visitField(ACC_STATIC, name, IInstrumenterConstant.REFLECTION_METHOD_TYPE.getDescriptor(), null, null).visitEnd();\r\n        methodFields.put(mplan, name);\r\n        counter++;\r\n    }\r\n    return methodFields;\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.engine.session.SessionPerfTest.getIterativeInvocationSequence",
	"Comment": "creates an invocationsequence which has a huge number of iterative calls.",
	"Method": "InvocationSequenceData getIterativeInvocationSequence(InvocationSequenceData parentSequence,int numberOfChildren){\r\n    List<InvocationSequenceData> nestedSequencesOfParent = new ArrayList<InvocationSequenceData>();\r\n    double durationOfParent = 0;\r\n    int splitFactor = 2;\r\n    for (int i = 0; i < splitFactor; i++) {\r\n        InvocationSequenceData childSequence = new InvocationSequenceData(new Timestamp(System.currentTimeMillis() + (i + 100)), 0, 0, parentSequence.getMethodIdent() + i);\r\n        childSequence.setParentSequence(parentSequence);\r\n        List<InvocationSequenceData> nestedSequencesOfChild = new ArrayList<InvocationSequenceData>();\r\n        double durationOfChild = 0;\r\n        for (int j = 0; j < (numberOfChildren / splitFactor); j++) {\r\n            InvocationSequenceData grandChildSequence = new InvocationSequenceData(new Timestamp(System.currentTimeMillis() + (j + 100)), 0, 0, childSequence.getMethodIdent() + 1);\r\n            grandChildSequence.setParentSequence(childSequence);\r\n            grandChildSequence.setDuration(EXCLUSIVE_DURATION_OF_GRAND_CHILD);\r\n            TimerData timerDataGrandChild = new TimerData(grandChildSequence.getTimeStamp(), grandChildSequence.getPlatformIdent(), grandChildSequence.getSensorTypeIdent(), grandChildSequence.getMethodIdent());\r\n            timerDataGrandChild.addDuration(EXCLUSIVE_DURATION_OF_GRAND_CHILD);\r\n            timerDataGrandChild.setExclusiveDuration(EXCLUSIVE_DURATION_OF_GRAND_CHILD);\r\n            timerDataGrandChild.addCpuDuration(CPU_DURATION);\r\n            timerDataGrandChild.calculateExclusiveMin(EXCLUSIVE_DURATION_OF_GRAND_CHILD);\r\n            grandChildSequence.setTimerData(timerDataGrandChild);\r\n            nestedSequencesOfChild.add(grandChildSequence);\r\n            durationOfChild += EXCLUSIVE_DURATION_OF_GRAND_CHILD;\r\n        }\r\n        durationOfChild += EXCLUSIVE_DURATION_OF_CHILD;\r\n        childSequence.setDuration(durationOfChild);\r\n        childSequence.getNestedSequences().addAll(nestedSequencesOfChild);\r\n        nestedSequencesOfParent.add(childSequence);\r\n        durationOfParent += durationOfChild;\r\n        TimerData timerDataChild = new TimerData(childSequence.getTimeStamp(), childSequence.getPlatformIdent(), childSequence.getSensorTypeIdent(), childSequence.getMethodIdent());\r\n        timerDataChild.addDuration(durationOfChild);\r\n        timerDataChild.setExclusiveDuration(EXCLUSIVE_DURATION_OF_CHILD);\r\n        timerDataChild.addCpuDuration(CPU_DURATION);\r\n        timerDataChild.calculateExclusiveMin(EXCLUSIVE_DURATION_OF_CHILD);\r\n        childSequence.setTimerData(timerDataChild);\r\n    }\r\n    durationOfParent += EXCLUSIVE_DURATION_OF_PARENT;\r\n    parentSequence.getNestedSequences().addAll(nestedSequencesOfParent);\r\n    parentSequence.setDuration(durationOfParent);\r\n    TimerData timerDataParent = new TimerData(parentSequence.getTimeStamp(), parentSequence.getPlatformIdent(), parentSequence.getSensorTypeIdent(), parentSequence.getMethodIdent());\r\n    timerDataParent.addDuration(durationOfParent);\r\n    timerDataParent.setExclusiveDuration(EXCLUSIVE_DURATION_OF_PARENT);\r\n    timerDataParent.addCpuDuration(CPU_DURATION);\r\n    timerDataParent.calculateExclusiveMin(EXCLUSIVE_DURATION_OF_PARENT);\r\n    parentSequence.setTimerData(timerDataParent);\r\n    return parentSequence;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Hide.getDistanceFromBoundary",
	"Comment": "returns the distance from the boundary of the obstacle behind which to hide.",
	"Method": "float getDistanceFromBoundary(){\r\n    return distanceFromBoundary;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.SteeringAcceleration.calculateMagnitude",
	"Comment": "returns the magnitude of this steering acceleration. this includes the angular component.",
	"Method": "float calculateMagnitude(){\r\n    return (float) Math.sqrt(calculateSquareMagnitude());\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.BitUtil.pop_union",
	"Comment": "returns the popcount or cardinality of the union of two sets.neither array is modified.",
	"Method": "long pop_union(long[] arr1,long[] arr2,int wordOffset,int numWords){\r\n    long popCount = 0;\r\n    for (int i = wordOffset, end = wordOffset + numWords; i < end; ++i) {\r\n        popCount += Long.bitCount(arr1[i] | arr2[i]);\r\n    }\r\n    return popCount;\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.AtomicBuffer.getIndexedElements",
	"Comment": "returns the number of indexed elements since the buffer has been created.",
	"Method": "long getIndexedElements(){\r\n    return elementsIndexed.get();\r\n}"
}, {
	"Path": "com.alorma.github.Base64.decode",
	"Comment": "decodes base64 content using the supplied decodabet and returnsthe decoded byte array.",
	"Method": "byte[] decode(String s,byte[] decode,byte[] source,byte[] decode,byte[] source,int off,int len,byte[] decode,byte[] source,int off,int len,byte[] decodabet){\r\n    int len34 = len * 3 / 4;\r\n    byte[] outBuff = new byte[2 + len34];\r\n    int outBuffPosn = 0;\r\n    byte[] b4 = new byte[4];\r\n    int b4Posn = 0;\r\n    int i = 0;\r\n    byte sbiCrop = 0;\r\n    byte sbiDecode = 0;\r\n    for (i = 0; i < len; i++) {\r\n        sbiCrop = (byte) (source[i + off] & 0x7f);\r\n        sbiDecode = decodabet[sbiCrop];\r\n        if (sbiDecode >= WHITE_SPACE_ENC) {\r\n            if (sbiDecode >= EQUALS_SIGN_ENC) {\r\n                if (sbiCrop == EQUALS_SIGN) {\r\n                    int bytesLeft = len - i;\r\n                    byte lastByte = (byte) (source[len - 1 + off] & 0x7f);\r\n                    if (b4Posn == 0 || b4Posn == 1) {\r\n                        throw new Base64DecoderException(\"invalid padding byte '=' at byte offset \" + i);\r\n                    } else if ((b4Posn == 3 && bytesLeft > 2) || (b4Posn == 4 && bytesLeft > 1)) {\r\n                        throw new Base64DecoderException(\"padding byte '=' falsely signals end of encoded value \" + \"at offset \" + i);\r\n                    } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {\r\n                        throw new Base64DecoderException(\"encoded value has invalid trailing byte\");\r\n                    }\r\n                    break;\r\n                }\r\n                b4[b4Posn++] = sbiCrop;\r\n                if (b4Posn == 4) {\r\n                    outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);\r\n                    b4Posn = 0;\r\n                }\r\n            }\r\n        } else {\r\n            throw new Base64DecoderException(\"Bad Base64 input character at \" + i + \": \" + source[i + off] + \"(decimal)\");\r\n        }\r\n    }\r\n    if (b4Posn != 0) {\r\n        if (b4Posn == 1) {\r\n            throw new Base64DecoderException(\"single trailing character at offset \" + (len - 1));\r\n        }\r\n        b4[b4Posn++] = EQUALS_SIGN;\r\n        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);\r\n    }\r\n    byte[] out = new byte[outBuffPosn];\r\n    System.arraycopy(outBuff, 0, out, 0, outBuffPosn);\r\n    return out;\r\n}"
}, {
	"Path": "com.firebase.geofire.GeoFire.queryAtLocation",
	"Comment": "returns a new query object centered at the given location and with the given radius.",
	"Method": "GeoQuery queryAtLocation(GeoLocation center,double radius){\r\n    return new GeoQuery(this, center, capRadius(radius));\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.invocationsequence.InvocationSequenceHookTest.twoInvocationsParentChild",
	"Comment": "tests that the invocation and child will have correct times and ids.",
	"Method": "void twoInvocationsParentChild(){\r\n    long platformId = 1L;\r\n    long methodId1 = 3L;\r\n    long sensorTypeId = 11L;\r\n    long methodId2 = 23L;\r\n    Object object = mock(Object.class);\r\n    Object[] parameters = new Object[0];\r\n    Object result = mock(Object.class);\r\n    when(platformManager.getPlatformId()).thenReturn(platformId);\r\n    double firstTimerValue = 1000.0d;\r\n    double secondTimerValue = 1323.0d;\r\n    double thirdTimerValue = 1881.0d;\r\n    double fourthTimerValue = 2562.0d;\r\n    when(timer.getCurrentTime()).thenReturn(firstTimerValue, secondTimerValue, thirdTimerValue, fourthTimerValue);\r\n    when(rsc.getMethodSensors()).thenReturn(Collections.singletonList(methodSensor));\r\n    when(methodSensor.getSensorTypeConfig()).thenReturn(methodSensorTypeConfig);\r\n    TimerData timerData = new TimerData();\r\n    invocationSequenceHook.beforeBody(methodId1, sensorTypeId, object, parameters, rsc);\r\n    invocationSequenceHook.beforeBody(methodId2, sensorTypeId, object, parameters, rsc);\r\n    invocationSequenceHook.addDefaultData(timerData);\r\n    invocationSequenceHook.firstAfterBody(methodId2, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.secondAfterBody(coreService, methodId2, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.firstAfterBody(methodId1, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.secondAfterBody(coreService, methodId1, sensorTypeId, object, parameters, result, false, rsc);\r\n    verify(timer, times(4)).getCurrentTime();\r\n    ArgumentCaptor<InvocationSequenceData> captor = ArgumentCaptor.forClass(InvocationSequenceData.class);\r\n    verify(coreService, times(1)).addDefaultData(captor.capture());\r\n    InvocationSequenceData invocation = captor.getValue();\r\n    assertThat(invocation.getPlatformIdent(), is(platformId));\r\n    assertThat(invocation.getMethodIdent(), is(methodId1));\r\n    assertThat(invocation.getSensorTypeIdent(), is(sensorTypeId));\r\n    assertThat(invocation.getDuration(), is(fourthTimerValue - firstTimerValue));\r\n    assertThat(invocation.getNestedSequences(), hasSize(1));\r\n    assertThat(invocation.getChildCount(), is(1L));\r\n    InvocationSequenceData child = invocation.getNestedSequences().iterator().next();\r\n    assertThat(child.getPlatformIdent(), is(platformId));\r\n    assertThat(child.getMethodIdent(), is(methodId2));\r\n    assertThat(child.getSensorTypeIdent(), is(sensorTypeId));\r\n    assertThat(child.getDuration(), is(thirdTimerValue - secondTimerValue));\r\n    assertThat(child.getNestedSequences(), is(empty()));\r\n    assertThat(child.getParentSequence(), is(invocation));\r\n    assertThat(child.getChildCount(), is(0L));\r\n    verifyZeroInteractions(realCoreService);\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.util.PhpTypeProviderUtil.mergeSignatureResults",
	"Comment": "mostly factory pattern doest not return a type, but eg in doctrine getrepository we need to fallback to an interface",
	"Method": "Collection<? extends PhpNamedElement> mergeSignatureResults(Collection<? extends PhpNamedElement> phpNamedElements,PhpNamedElement phpNamed){\r\n    Collection<PhpNamedElement> result = new ArrayList<PhpNamedElement>();\r\n    result.add(phpNamed);\r\n    if (!(phpNamed instanceof PhpClass)) {\r\n        result.addAll(phpNamedElements);\r\n        return result;\r\n    }\r\n    for (PhpNamedElement phpNamedElement : phpNamedElements) {\r\n        if (phpNamedElement == null) {\r\n            continue;\r\n        }\r\n        if (!(phpNamedElement instanceof Method)) {\r\n            result.add(phpNamedElement);\r\n            continue;\r\n        }\r\n        if (isPhpTypeEqual(phpNamedElement.getType(), (PhpClass) phpNamed)) {\r\n            continue;\r\n        }\r\n        result.add(phpNamedElement);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.AtomicBuffer.addToCurrentSize",
	"Comment": "adds size value to the current size.\tthis method is thread safe.",
	"Method": "void addToCurrentSize(long size,boolean areObjects){\r\n    currentSize.addAndGet(size);\r\n    notifyEvictionIfNeeded();\r\n    if (areObjects) {\r\n        dataAddedInBytes.addAndGet(size);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.AbstractObjectSizes.getSizeOfPrimitiveArray",
	"Comment": "calculates the size of the primitive array with the primitives in the array.",
	"Method": "long getSizeOfPrimitiveArray(int arraySize,long primitiveSize){\r\n    long size = this.getSizeOfObjectHeader() + INT_SIZE;\r\n    if (ALLIGN_CLASS_CALCULATION) {\r\n        size = alignTo8Bytes(size);\r\n    }\r\n    size += arraySize * primitiveSize;\r\n    return alignTo8Bytes(size);\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Separation.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum linear acceleration.",
	"Method": "Separation<T> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.invocationsequence.InvocationSequenceHookTest.noRemoveCapturedLogging",
	"Comment": "no removing done due to the captured logging, because there is log object.",
	"Method": "void noRemoveCapturedLogging(){\r\n    long platformId = 1L;\r\n    long methodId1 = 3L;\r\n    long sensorTypeId = 11L;\r\n    long methodId2 = 23L;\r\n    Object object = mock(Object.class);\r\n    Object[] parameters = new Object[0];\r\n    Object result = mock(Object.class);\r\n    when(platformManager.getPlatformId()).thenReturn(platformId);\r\n    double firstTimerValue = 1000.0d;\r\n    double secondTimerValue = 1323.0d;\r\n    double thirdTimerValue = 1881.0d;\r\n    double fourthTimerValue = 2562.0d;\r\n    when(timer.getCurrentTime()).thenReturn(firstTimerValue, secondTimerValue, thirdTimerValue, fourthTimerValue);\r\n    when(rsc.getMethodSensors()).thenReturn(Collections.<IMethodSensor>emptyList());\r\n    invocationSequenceHook.beforeBody(methodId1, sensorTypeId, object, parameters, rsc);\r\n    invocationSequenceHook.beforeBody(methodId2, sensorTypeId, object, parameters, rsc);\r\n    LoggingData loggingData = new LoggingData();\r\n    invocationSequenceHook.addDefaultData(loggingData);\r\n    invocationSequenceHook.firstAfterBody(methodId2, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.secondAfterBody(coreService, methodId2, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.firstAfterBody(methodId1, sensorTypeId, object, parameters, result, false, rsc);\r\n    invocationSequenceHook.secondAfterBody(coreService, methodId1, sensorTypeId, object, parameters, result, false, rsc);\r\n    verify(timer, times(4)).getCurrentTime();\r\n    ArgumentCaptor<InvocationSequenceData> captor = ArgumentCaptor.forClass(InvocationSequenceData.class);\r\n    verify(coreService, times(1)).addDefaultData(captor.capture());\r\n    InvocationSequenceData invocation = captor.getValue();\r\n    assertThat(invocation.getPlatformIdent(), is(platformId));\r\n    assertThat(invocation.getMethodIdent(), is(methodId1));\r\n    assertThat(invocation.getSensorTypeIdent(), is(sensorTypeId));\r\n    assertThat(invocation.getDuration(), is(fourthTimerValue - firstTimerValue));\r\n    assertThat(invocation.getNestedSequences(), hasSize(1));\r\n    assertThat(invocation.getChildCount(), is(1L));\r\n    InvocationSequenceData child = invocation.getNestedSequences().iterator().next();\r\n    assertThat(child.getPlatformIdent(), is(platformId));\r\n    assertThat(child.getMethodIdent(), is(methodId2));\r\n    assertThat(child.getSensorTypeIdent(), is(sensorTypeId));\r\n    assertThat(child.getDuration(), is(thirdTimerValue - secondTimerValue));\r\n    assertThat(child.getNestedSequences(), is(empty()));\r\n    assertThat(child.getParentSequence(), is(invocation));\r\n    assertThat(child.getChildCount(), is(0L));\r\n    assertThat(child.getLoggingData(), is(loggingData));\r\n    verifyZeroInteractions(realCoreService);\r\n}"
}, {
	"Path": "org.kohsuke.github.GHBranch.disableProtection",
	"Comment": "disables branch protection and allows anyone with push access to push changes.",
	"Method": "void disableProtection(){\r\n    new Requester(root).method(\"DELETE\").to(protection_url);\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.util.ConstraintHelper.isComposedConstraint",
	"Comment": "checks whether the given type element represents a composed constraint or not.",
	"Method": "boolean isComposedConstraint(TypeElement element){\r\n    return Boolean.TRUE.equals(element.asType().accept(new TypeKindVisitor8<Boolean, Void>() {\r\n        @Override\r\n        public Boolean visitDeclared(DeclaredType constraintValidatorImplementation, Void p) {\r\n            return !getComposingConstraints(constraintValidatorImplementation).isEmpty();\r\n        }\r\n    }, null));\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.util.ConstraintHelper.isComposedConstraint",
	"Comment": "checks whether the given type element represents a composed constraint or not.",
	"Method": "boolean isComposedConstraint(TypeElement element){\r\n    return !getComposingConstraints(constraintValidatorImplementation).isEmpty();\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.util.StringHelper.join",
	"Comment": "joins the elements of the given iterable to a string, separated by the given separator string.",
	"Method": "String join(Object[] array,String separator,String join,Iterable<?> iterable,String separator){\r\n    if (iterable == null) {\r\n        return null;\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    boolean isFirst = true;\r\n    for (Object object : iterable) {\r\n        if (!isFirst) {\r\n            sb.append(separator);\r\n        } else {\r\n            isFirst = false;\r\n        }\r\n        sb.append(object);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.StorageIntegrationTest.canNotOpenClosed",
	"Comment": "test that the storage can not be opened after it has been finalized.",
	"Method": "void canNotOpenClosed(){\r\n    storageManager.openStorage(storageData);\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.SteeringAcceleration.calculateSquareMagnitude",
	"Comment": "returns the square of the magnitude of this steering acceleration. this includes the angular component.",
	"Method": "float calculateSquareMagnitude(){\r\n    return linear.len2() + angular * angular;\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth2.AuthorizationCodeFlow.createAndStoreCredential",
	"Comment": "creates a new credential for the given user id based on the given token responseand stores it in the credential store.",
	"Method": "Credential createAndStoreCredential(TokenResponse response,String userId){\r\n    Credential credential = newCredential(userId).setFromTokenResponse(response);\r\n    if (credentialStore != null) {\r\n        credentialStore.store(userId, credential);\r\n    }\r\n    if (credentialDataStore != null) {\r\n        credentialDataStore.set(userId, new StoredCredential(credential));\r\n    }\r\n    if (credentialCreatedListener != null) {\r\n        credentialCreatedListener.onCredentialCreated(credential, response);\r\n    }\r\n    return credential;\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.checks.AnnotationTypeMemberCheck.validateWildcardBounds",
	"Comment": "returns true, if the given type mirror is a wildcard type with the given extends and super bounds, false otherwise.",
	"Method": "boolean validateWildcardBounds(TypeMirror type,TypeMirror expectedExtendsBound,TypeMirror expectedSuperBound){\r\n    Boolean theValue = type.accept(new TypeKindVisitor8<Boolean, Void>() {\r\n        @Override\r\n        public Boolean visitWildcard(WildcardType t, Void p) {\r\n            boolean extendsBoundMatches = (t.getExtendsBound() == null ? expectedExtendsBound == null : expectedExtendsBound != null && typeUtils.isSameType(t.getExtendsBound(), expectedExtendsBound));\r\n            boolean superBoundMatches = (t.getSuperBound() == null ? expectedSuperBound == null : expectedSuperBound != null && typeUtils.isSameType(t.getSuperBound(), expectedSuperBound));\r\n            return extendsBoundMatches && superBoundMatches;\r\n        }\r\n    }, null);\r\n    return Boolean.TRUE.equals(theValue);\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.checks.AnnotationTypeMemberCheck.validateWildcardBounds",
	"Comment": "returns true, if the given type mirror is a wildcard type with the given extends and super bounds, false otherwise.",
	"Method": "boolean validateWildcardBounds(TypeMirror type,TypeMirror expectedExtendsBound,TypeMirror expectedSuperBound){\r\n    boolean extendsBoundMatches = (t.getExtendsBound() == null ? expectedExtendsBound == null : expectedExtendsBound != null && typeUtils.isSameType(t.getExtendsBound(), expectedExtendsBound));\r\n    boolean superBoundMatches = (t.getSuperBound() == null ? expectedSuperBound == null : expectedSuperBound != null && typeUtils.isSameType(t.getSuperBound(), expectedSuperBound));\r\n    return extendsBoundMatches && superBoundMatches;\r\n}"
}, {
	"Path": "rocks.inspectit.server.processor.impl.ExceptionMessageCmrProcessor.connectErrorMessagesInExceptionData",
	"Comment": "connects exception message between linked exception data.",
	"Method": "void connectErrorMessagesInExceptionData(ExceptionSensorData exceptionSensorData){\r\n    ExceptionSensorData child = exceptionSensorData.getChild();\r\n    if (null != child) {\r\n        child.setErrorMessage(exceptionSensorData.getErrorMessage());\r\n        connectErrorMessagesInExceptionData(child);\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Arrive.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum linear speed and\tacceleration.",
	"Method": "Arrive<T> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.RaycastObstacleAvoidance.getDistanceFromBoundary",
	"Comment": "returns the distance from boundary, i.e. the minimum distance to an obstacle.",
	"Method": "float getDistanceFromBoundary(){\r\n    return distanceFromBoundary;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHCommitStatus.getTargetUrl",
	"Comment": "the url that this status is linked to.this is the url specified when creating a commit status.",
	"Method": "String getTargetUrl(){\r\n    return target_url;\r\n}"
}, {
	"Path": "rocks.inspectit.server.ci.ConfigurationInterfaceManager.updateBusinessContextDefinition",
	"Comment": "updates and stores new definition of the business context.",
	"Method": "BusinessContextDefinition updateBusinessContextDefinition(BusinessContextDefinition businessContextDefinition){\r\n    businessContextDefinition.setRevision(businessContextDefinition.getRevision() + 1);\r\n    BusinessContextDefinition currentBusinessContextDefinition = businessContextDefinitionReference.get();\r\n    if ((currentBusinessContextDefinition != businessContextDefinition) && ((currentBusinessContextDefinition.getRevision() + 1) != businessContextDefinition.getRevision())) {\r\n        throw new BusinessException(\"Update of the business context.\", ConfigurationInterfaceErrorCodeEnum.REVISION_CHECK_FAILED);\r\n    }\r\n    saveBusinessContext(businessContextDefinition);\r\n    eventPublisher.publishEvent(new BusinessContextDefinitionUpdateEvent(this, businessContextDefinition));\r\n    return businessContextDefinition;\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.util.StringHelper.isNullOrEmptyString",
	"Comment": "indicates if the string is null or is empty ie only contains whitespaces.",
	"Method": "boolean isNullOrEmptyString(String value){\r\n    return value == null || value.trim().isEmpty();\r\n}"
}, {
	"Path": "rocks.inspectit.server.dao.impl.TimerDataAggregatorTest.maxElementsReached",
	"Comment": "tests that after maximum amount of elements is reached we move them to persist list.",
	"Method": "void maxElementsReached(){\r\n    aggregator.maxElements = 1;\r\n    TimerData timerData1 = new TimerData(new Timestamp(System.currentTimeMillis()), 10L, 20L, 30L);\r\n    TimerData timerData2 = new TimerData(new Timestamp(System.currentTimeMillis()), 100L, 200L, 300L);\r\n    aggregator.processTimerData(timerData1);\r\n    aggregator.processTimerData(timerData2);\r\n    assertThat(aggregator.getElementCount(), is(1));\r\n    verifyZeroInteractions(entityManager);\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageRecorderTest.processing",
	"Comment": "test that start of recording and processing of data is correct.",
	"Method": "void processing(){\r\n    when(recordingProperties.getRecordingDataProcessors()).thenReturn(Collections.singleton(dataProcessor));\r\n    cmrStorageRecorder.startOrScheduleRecording(storageWriter, recordingProperties);\r\n    assertThat(cmrStorageRecorder.isRecordingOn(), is(true));\r\n    DefaultData defaultData = mock(DefaultData.class);\r\n    cmrStorageRecorder.record(defaultData);\r\n    verify(dataProcessor, times(1)).setStorageWriter(storageWriter);\r\n    verify(dataProcessor, times(1)).process(defaultData);\r\n    verifyNoMoreInteractions(dataProcessor);\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.ReachOrientation.getTimeToTarget",
	"Comment": "returns the time over which to achieve target rotation speed",
	"Method": "float getTimeToTarget(){\r\n    return timeToTarget;\r\n}"
}, {
	"Path": "com.firebase.geofire.testing.SimpleFuture.isDone",
	"Comment": "if the value is set this method returns true and the get method will return it then.",
	"Method": "boolean isDone(){\r\n    return isSet;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHCommitComment.getPath",
	"Comment": "a commit comment can be on a specific line of a specific file, if so, this field points to a file.otherwise null.",
	"Method": "String getPath(){\r\n    return path;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.LookWhereYouAreGoing.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum angular speed and\tacceleration.",
	"Method": "LookWhereYouAreGoing<T> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "org.influxdb.UDPInfluxDBTest.testWriteMultipleStringDataThroughUDP",
	"Comment": "test writing multiple records to the database using string protocolthrough udp.",
	"Method": "void testWriteMultipleStringDataThroughUDP(){\r\n    String measurement = TestUtils.getRandomMeasurement();\r\n    this.influxDB.write(UDP_PORT, measurement + \",atag=test1 idle=100,usertime=10,system=1\\n\" + measurement + \",atag=test2 idle=200,usertime=20,system=2\\n\" + measurement + \",atag=test3 idle=300,usertime=30,system=3\");\r\n    Thread.sleep(2000);\r\n    Query query = new Query(\"SELECT * FROM \" + measurement + \" GROUP BY *\", UDP_DATABASE);\r\n    QueryResult result = this.influxDB.query(query);\r\n    Assertions.assertEquals(3, result.getResults().get(0).getSeries().size());\r\n    Assertions.assertEquals(\"test1\", result.getResults().get(0).getSeries().get(0).getTags().get(\"atag\"));\r\n    Assertions.assertEquals(\"test2\", result.getResults().get(0).getSeries().get(1).getTags().get(\"atag\"));\r\n    Assertions.assertEquals(\"test3\", result.getResults().get(0).getSeries().get(2).getTags().get(\"atag\"));\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.msg.PriorityQueue.siftUp",
	"Comment": "inserts item x at position k, maintaining heap invariant by promoting x up the tree until it is greater than or equal to its\tparent, or is the root.",
	"Method": "void siftUp(int k,E x){\r\n    while (k > 0) {\r\n        int parent = (k - 1) >>> 1;\r\n        E e = (E) queue[parent];\r\n        if (x.compareTo(e) >= 0)\r\n            break;\r\n        queue[k] = e;\r\n        k = parent;\r\n    }\r\n    queue[k] = x;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.tests.steer.box2d.Box2dSquareAABBProximity.getDetectionRadius",
	"Comment": "returns the detection radius that is half the side of the square aabb.",
	"Method": "float getDetectionRadius(){\r\n    return detectionRadius;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHContent.populate",
	"Comment": "fully populate the data by retrieving missing data.depending on the original api call where this object is created, it may not contain everything.",
	"Method": "void populate(){\r\n    if (download_url != null)\r\n        return;\r\n    root.retrieve().to(url, this);\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth2.AuthorizationRequestUrl.setClientId",
	"Comment": "sets the client identifier.overriding is only supported for the purpose of calling the super implementation and changingthe return type, but nothing else.",
	"Method": "AuthorizationRequestUrl setClientId(String clientId){\r\n    this.clientId = Preconditions.checkNotNull(clientId);\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.addLabelToStorage",
	"Comment": "add a label to the storage and saves new state of the storage to the disk.",
	"Method": "void addLabelToStorage(StorageData storageData,AbstractStorageLabel<?> storageLabel,boolean doOverwrite){\r\n    StorageData local = getLocalStorageDataObject(storageData);\r\n    if (null != local) {\r\n        local.addLabel(storageLabel, doOverwrite);\r\n        writeStorageDataToDisk(local);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.util.ReflectionCache.getField",
	"Comment": "gets the given field on the given class. this method uses the cache to only lookup the field\tif the same field was not looked up before for the same class.",
	"Method": "Object getField(Class<?> clazz,String fieldName,Object instance,Object errorValue){\r\n    if ((null == clazz) || (null == fieldName)) {\r\n        return errorValue;\r\n    }\r\n    Cache<String, Field> classCache = fieldCache.getIfPresent(clazz);\r\n    if (null == classCache) {\r\n        classCache = CacheBuilder.newBuilder().expireAfterAccess(20, TimeUnit.MINUTES).weakKeys().build();\r\n        fieldCache.put(clazz, classCache);\r\n    }\r\n    Field field = classCache.getIfPresent(fieldName);\r\n    if (null == field) {\r\n        Class<?> lookupClass = clazz;\r\n        while (field == null) {\r\n            try {\r\n                field = lookupClass.getDeclaredField(fieldName);\r\n            } catch (NoSuchFieldException nsfe) {\r\n                lookupClass = lookupClass.getSuperclass();\r\n                if (lookupClass == null) {\r\n                    LOG.warn(\"Could not lookup field \" + fieldName + \" on class \" + clazz.getName(), nsfe);\r\n                    return errorValue;\r\n                }\r\n            } catch (Throwable t) {\r\n                LOG.warn(\"Could not lookup field \" + fieldName + \" on class \" + clazz.getName(), t);\r\n                return errorValue;\r\n            }\r\n        }\r\n        field.setAccessible(true);\r\n        classCache.put(fieldName, field);\r\n    }\r\n    try {\r\n        return field.get(instance);\r\n    } catch (Throwable t) {\r\n        LOG.warn(\"Could not get field \" + fieldName + \" on instance \" + instance, t);\r\n        return errorValue;\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.SteeringAcceleration.mulAdd",
	"Comment": "first scale a supplied steering acceleration, then add it to this steering acceleration.",
	"Method": "SteeringAcceleration<T> mulAdd(SteeringAcceleration<T> steering,float scalar){\r\n    linear.mulAdd(steering.linear, scalar);\r\n    angular += steering.angular * scalar;\r\n    return this;\r\n}"
}, {
	"Path": "org.kohsuke.github.GitHub.connectToEnterpriseAnonymously",
	"Comment": "connects to github enterprise anonymously.all operations that requires authentication will fail.",
	"Method": "GitHub connectToEnterpriseAnonymously(String apiUrl){\r\n    return new GitHubBuilder().withEndpoint(apiUrl).build();\r\n}"
}, {
	"Path": "org.hibernate.validator.test.internal.engine.methodvalidation.cascadedgroupvalidation.CascadedMethodLevelValidationGroupSequenceTest.cascadedReturnValueConstraintInBothGroups",
	"Comment": "expect a single constraint violation in the first group. the second group should not be\tvalidated due to the violation in the first group.",
	"Method": "void cascadedReturnValueConstraintInBothGroups(){\r\n    setUpValidatorForGroups(CompoundGroup.class);\r\n    try {\r\n        entityRepository.getEntity(new CompoundEntity(new Entity(null, null)));\r\n        fail(\"Expected MethodConstraintViolationException wasn't thrown.\");\r\n    } catch (ConstraintViolationException e) {\r\n        assertThat(e.getConstraintViolations()).containsOnlyViolations(violationOf(NotNull.class).withMessage(\"must not be null\").withInvalidValue(null).withRootBeanClass(CompoundEntityRepositoryImpl.class));\r\n        ConstraintViolation<?> constraintViolation = e.getConstraintViolations().iterator().next();\r\n        assertEquals(constraintViolation.getConstraintDescriptor().getGroups().iterator().next(), ValidationGroup1.class);\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.groups.ValidationOrderGenerator.getValidationOrder",
	"Comment": "generates a order of groups and sequences for the specified validation groups.",
	"Method": "ValidationOrder getValidationOrder(Class<?> group,boolean expand,ValidationOrder getValidationOrder,Collection<Class<?>> groups){\r\n    if (groups == null || groups.size() == 0) {\r\n        throw LOG.getAtLeastOneGroupHasToBeSpecifiedException();\r\n    }\r\n    if (groups.size() == 1 && groups.contains(Default.class)) {\r\n        return ValidationOrder.DEFAULT_GROUP;\r\n    }\r\n    for (Class<?> clazz : groups) {\r\n        if (!clazz.isInterface()) {\r\n            throw LOG.getGroupHasToBeAnInterfaceException(clazz);\r\n        }\r\n    }\r\n    DefaultValidationOrder validationOrder = new DefaultValidationOrder();\r\n    for (Class<?> clazz : groups) {\r\n        if (Default.class.equals(clazz)) {\r\n            validationOrder.insertGroup(Group.DEFAULT_GROUP);\r\n        } else if (isGroupSequence(clazz)) {\r\n            insertSequence(clazz, clazz.getAnnotation(GroupSequence.class).value(), true, validationOrder);\r\n        } else {\r\n            Group group = new Group(clazz);\r\n            validationOrder.insertGroup(group);\r\n            insertInheritedGroups(clazz, validationOrder);\r\n        }\r\n    }\r\n    return validationOrder;\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeArrayDeque.release",
	"Comment": "release internal buffers of this deque and reallocate with the defaultbuffer.",
	"Method": "void release(){\r\n    this.head = tail = 0;\r\n    buffer = KTypeArrayList.EMPTY_ARRAY;\r\n    ensureBufferSpace(0);\r\n}"
}, {
	"Path": "org.kohsuke.github.GHPullRequest.listReviewComments",
	"Comment": "obtains all the review comments associated with this pull request.",
	"Method": "PagedIterable<GHPullRequestReviewComment> listReviewComments(){\r\n    return new PagedIterable<GHPullRequestReviewComment>() {\r\n        public PagedIterator<GHPullRequestReviewComment> _iterator(int pageSize) {\r\n            return new PagedIterator<GHPullRequestReviewComment>(root.retrieve().asIterator(getApiRoute() + COMMENTS_ACTION, GHPullRequestReviewComment[].class, pageSize)) {\r\n                protected void wrapUp(GHPullRequestReviewComment[] page) {\r\n                    for (GHPullRequestReviewComment c : page) c.wrapUp(GHPullRequest.this);\r\n                }\r\n            };\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.kohsuke.github.GHPullRequest.listReviewComments",
	"Comment": "obtains all the review comments associated with this pull request.",
	"Method": "PagedIterable<GHPullRequestReviewComment> listReviewComments(){\r\n    return new PagedIterator<GHPullRequestReviewComment>(root.retrieve().asIterator(getApiRoute() + COMMENTS_ACTION, GHPullRequestReviewComment[].class, pageSize)) {\r\n        protected void wrapUp(GHPullRequestReviewComment[] page) {\r\n            for (GHPullRequestReviewComment c : page) c.wrapUp(GHPullRequest.this);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.kohsuke.github.GHPullRequest.listReviewComments",
	"Comment": "obtains all the review comments associated with this pull request.",
	"Method": "PagedIterable<GHPullRequestReviewComment> listReviewComments(){\r\n    for (GHPullRequestReviewComment c : page) c.wrapUp(GHPullRequest.this);\r\n}"
}, {
	"Path": "org.influxdb.dto.BatchPoints.database",
	"Comment": "create a new batchpoints build to create a new batchpoints in a fluent manner.",
	"Method": "Builder database(String database){\r\n    return new Builder(database);\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.jdbc.StatementStorage.addPreparedStatement",
	"Comment": "adds a prepared statement to this storage for later retrieval.",
	"Method": "void addPreparedStatement(Object object){\r\n    String sql = sqlThreadLocalStack.getLast();\r\n    preparedStatements.put(object, new QueryInformation(sql));\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"Recorded prepared sql statement: \" + sql);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.http.HttpInformationExtractor.getResponseStatus",
	"Comment": "reads the response status from the httpservletresponse object.",
	"Method": "int getResponseStatus(Class<?> httpServletResponseClass,Object httpServletResponse){\r\n    Method getStatusMethod = retrieveMethod(HttpMethods.RESPONSE_GET_STATUS, httpServletResponseClass);\r\n    if (null == getStatusMethod) {\r\n        return 0;\r\n    }\r\n    try {\r\n        return (Integer) getStatusMethod.invoke(httpServletResponse);\r\n    } catch (Exception e) {\r\n        LOG.error(\"Invocation of to get response status on given object failed.\", e);\r\n    }\r\n    return 0;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.listCommitStatuses",
	"Comment": "lists all the commit statues attached to the given commit, newer ones first.",
	"Method": "PagedIterable<GHCommitStatus> listCommitStatuses(String sha1){\r\n    return new PagedIterable<GHCommitStatus>() {\r\n        public PagedIterator<GHCommitStatus> _iterator(int pageSize) {\r\n            return new PagedIterator<GHCommitStatus>(root.retrieve().asIterator(String.format(\"/repos/%s/%s/statuses/%s\", getOwnerName(), name, sha1), GHCommitStatus[].class, pageSize)) {\r\n                @Override\r\n                protected void wrapUp(GHCommitStatus[] page) {\r\n                    for (GHCommitStatus c : page) c.wrapUp(root);\r\n                }\r\n            };\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.listCommitStatuses",
	"Comment": "lists all the commit statues attached to the given commit, newer ones first.",
	"Method": "PagedIterable<GHCommitStatus> listCommitStatuses(String sha1){\r\n    return new PagedIterator<GHCommitStatus>(root.retrieve().asIterator(String.format(\"/repos/%s/%s/statuses/%s\", getOwnerName(), name, sha1), GHCommitStatus[].class, pageSize)) {\r\n        @Override\r\n        protected void wrapUp(GHCommitStatus[] page) {\r\n            for (GHCommitStatus c : page) c.wrapUp(root);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.listCommitStatuses",
	"Comment": "lists all the commit statues attached to the given commit, newer ones first.",
	"Method": "PagedIterable<GHCommitStatus> listCommitStatuses(String sha1){\r\n    for (GHCommitStatus c : page) c.wrapUp(root);\r\n}"
}, {
	"Path": "org.hibernate.validator.test.internal.util.TypeHelperTest.isAssignableWithObjectFromInterface",
	"Comment": "the type object, if c is an interface type with no direct superinterfaces.",
	"Method": "void isAssignableWithObjectFromInterface(){\r\n    assertAssignable(Object.class, Iterable.class);\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.html.DecodingHtmlScriptInjector.setCharacterEncoding",
	"Comment": "changes the encoding of the accepted binary data. this method may only be called if no binary\tdata has been passed to this injector yet!",
	"Method": "void setCharacterEncoding(String charsetName){\r\n    if (!codersInitialized()) {\r\n        charSet = charsetName;\r\n    } else {\r\n        throw new IllegalStateException(\"Decoding has already begun!\");\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.util.MessagerAdapter.reportError",
	"Comment": "reports the given error. message parameters will be put into the template\tretrieved from the resource bundle if applicable.",
	"Method": "void reportError(ConstraintCheckIssue error){\r\n    report(error, diagnosticKind);\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Pursue.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum linear acceleration.",
	"Method": "Pursue<T> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.metadata.provider.AnnotationMetaDataProvider.getParameterMetaData",
	"Comment": "retrieves constraint related meta data for the parameters of the given\texecutable.",
	"Method": "List<ConstrainedParameter> getParameterMetaData(JavaBeanExecutable<?> javaBeanExecutable){\r\n    if (!javaBeanExecutable.hasParameters()) {\r\n        return Collections.emptyList();\r\n    }\r\n    List<JavaBeanParameter> parameters = javaBeanExecutable.getParameters();\r\n    List<ConstrainedParameter> metaData = new ArrayList(parameters.size());\r\n    int i = 0;\r\n    for (JavaBeanParameter parameter : parameters) {\r\n        if (annotationProcessingOptions.areParameterConstraintsIgnoredFor(javaBeanExecutable, i)) {\r\n            metaData.add(new ConstrainedParameter(ConfigurationSource.ANNOTATION, javaBeanExecutable, parameter.getGenericType(), i, Collections.emptySet(), Collections.emptySet(), CascadingMetaDataBuilder.nonCascading()));\r\n            i++;\r\n            continue;\r\n        }\r\n        List<ConstraintDescriptorImpl<?>> constraintDescriptors = findConstraints(javaBeanExecutable, parameter, ConstraintLocationKind.PARAMETER);\r\n        Set<MetaConstraint<?>> parameterConstraints;\r\n        if (!constraintDescriptors.isEmpty()) {\r\n            parameterConstraints = newHashSet(constraintDescriptors.size());\r\n            ConstraintLocation location = ConstraintLocation.forParameter(javaBeanExecutable, i);\r\n            for (ConstraintDescriptorImpl<?> constraintDescriptorImpl : constraintDescriptors) {\r\n                parameterConstraints.add(MetaConstraints.create(typeResolutionHelper, valueExtractorManager, constraintDescriptorImpl, location));\r\n            }\r\n        } else {\r\n            parameterConstraints = Collections.emptySet();\r\n        }\r\n        Set<MetaConstraint<?>> typeArgumentsConstraints = findTypeAnnotationConstraintsForExecutableParameter(javaBeanExecutable, parameter);\r\n        CascadingMetaDataBuilder cascadingMetaData = findCascadingMetaData(parameter);\r\n        metaData.add(new ConstrainedParameter(ConfigurationSource.ANNOTATION, javaBeanExecutable, parameter.getGenericType(), i, parameterConstraints, typeArgumentsConstraints, cascadingMetaData));\r\n        i++;\r\n    }\r\n    return metaData;\r\n}"
}, {
	"Path": "com.github.mobile.util.HtmlUtils.format",
	"Comment": "format given html string so it is ready to be presented in a text view",
	"Method": "CharSequence format(String html){\r\n    if (html == null)\r\n        return \"\";\r\n    if (html.length() == 0)\r\n        return \"\";\r\n    StringBuilder formatted = new StringBuilder(html);\r\n    strip(formatted, TOGGLE_START, TOGGLE_END);\r\n    strip(formatted, SIGNATURE_START, SIGNATURE_END);\r\n    replace(formatted, REPLY_START, REPLY_END, BLOCKQUOTE_START, BLOCKQUOTE_END);\r\n    strip(formatted, HIDDEN_REPLY_START, HIDDEN_REPLY_END);\r\n    replace(formatted, PARAGRAPH_START, BREAK);\r\n    replace(formatted, PARAGRAPH_END, BREAK);\r\n    formatPres(formatted);\r\n    formatEmailFragments(formatted);\r\n    trim(formatted);\r\n    return formatted;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.util.TypeHelper.parameterizedType",
	"Comment": "creates a parameterized type for the specified raw type and actual type arguments.",
	"Method": "ParameterizedType parameterizedType(Class<?> rawType,Type actualTypeArguments){\r\n    return new ParameterizedType() {\r\n        @Override\r\n        public Type[] getActualTypeArguments() {\r\n            return actualTypeArguments;\r\n        }\r\n        @Override\r\n        public Type getRawType() {\r\n            return rawType;\r\n        }\r\n        @Override\r\n        public Type getOwnerType() {\r\n            return null;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.util.TypeHelper.parameterizedType",
	"Comment": "creates a parameterized type for the specified raw type and actual type arguments.",
	"Method": "ParameterizedType parameterizedType(Class<?> rawType,Type actualTypeArguments){\r\n    return actualTypeArguments;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.util.TypeHelper.parameterizedType",
	"Comment": "creates a parameterized type for the specified raw type and actual type arguments.",
	"Method": "ParameterizedType parameterizedType(Class<?> rawType,Type actualTypeArguments){\r\n    return rawType;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.util.TypeHelper.parameterizedType",
	"Comment": "creates a parameterized type for the specified raw type and actual type arguments.",
	"Method": "ParameterizedType parameterizedType(Class<?> rawType,Type actualTypeArguments){\r\n    return null;\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.TestUtils.newArray",
	"Comment": "create a new array of a given type and copy the arguments to this array.",
	"Method": "T[] newArray(T[] arrayType,T elements,int[] newArray,int[] arrayType,int elements,double[] newArray,double[] arrayType,double elements,float[] newArray,float[] arrayType,float elements,long[] newArray,long[] arrayType,long elements,short[] newArray,short[] arrayType,int elements,char[] newArray,char[] arrayType,int elements,byte[] newArray,byte[] arrayType,int elements){\r\n    final byte[] result = new byte[elements.length];\r\n    for (int i = 0; i < elements.length; i++) {\r\n        org.junit.Assert.assertTrue(elements[i] >= Byte.MIN_VALUE && elements[i] <= Byte.MAX_VALUE);\r\n        result[i] = (byte) elements[i];\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Jump.getTakeoffPositionTolerance",
	"Comment": "returns the tolerance used to check if the owner has reached the takeoff location.",
	"Method": "float getTakeoffPositionTolerance(){\r\n    return takeoffPositionTolerance;\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.listNotifications",
	"Comment": "list all the notifications in a repository for the current user.",
	"Method": "GHNotificationStream listNotifications(){\r\n    return new GHNotificationStream(root, getApiTailUrl(\"/notifications\"));\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sdk.opentracing.internal.impl.SpanImpl.isServer",
	"Comment": "if span is of a type server. only returns false if span is explicitly declared\tas client.",
	"Method": "boolean isServer(){\r\n    return !isClient();\r\n}"
}, {
	"Path": "rocks.inspectit.server.dao.impl.TimerDataAggregator.postConstruct",
	"Comment": "starting the thread in post construct, not in constructor.",
	"Method": "void postConstruct(){\r\n    timerDataAggregatorCacheCleaner = new TimerDataAggregatorCacheCleaner(this);\r\n    timerDataAggregatorCacheCleaner.start();\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.MemoryCalculationTest.booleanTestClass",
	"Comment": "tests the special boolean test class to assuer boolean sizes in jvm are in fact compiled as\t\tint.",
	"Method": "void booleanTestClass(){\r\n    BooleanTestClass testObject = new BooleanTestClass();\r\n    long ourSize = objectSizes.getSizeOf(testObject);\r\n    long theirSize = MemoryUtil.deepMemoryUsageOf(testObject, VisibilityFilter.ALL);\r\n    assertThat(\"Boolean test class\", ourSize, is(equalTo(theirSize)));\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.fma.Formation.addMember",
	"Comment": "adds a new member to the first available slot and updates slot assignments if the number of member is supported by the\tcurrent pattern.",
	"Method": "boolean addMember(FormationMember<T> member){\r\n    int occupiedSlots = slotAssignments.size;\r\n    if (pattern.supportsSlots(occupiedSlots + 1)) {\r\n        slotAssignments.add(new SlotAssignment<T>(member, occupiedSlots));\r\n        updateSlotAssignments();\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Wander.getWanderRate",
	"Comment": "returns the rate, expressed in radian per second, at which the wander orientation can change.",
	"Method": "float getWanderRate(){\r\n    return wanderRate;\r\n}"
}, {
	"Path": "com.alorma.github.inapp.Inventory.hasDetails",
	"Comment": "return whether or not details about the given product are available.",
	"Method": "boolean hasDetails(String sku){\r\n    return mSkuMap.containsKey(sku);\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.html.Caret.walkToWhitespace",
	"Comment": "walks forward until the caret points at a whitespace character.",
	"Method": "boolean walkToWhitespace(){\r\n    while (!endReached() && !Character.isWhitespace(src.charAt(offset))) {\r\n        offset++;\r\n    }\r\n    return !endReached();\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.KeepAliveService.postConstruct",
	"Comment": "starts a continuous thread to be able to detect dead agents.",
	"Method": "void postConstruct(){\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"|-Keep Alive Service active...\");\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.metadata.core.ConstraintHelper.putValidatorDescriptors",
	"Comment": "registers the given validator descriptors with the given constraint\tannotation type.",
	"Method": "void putValidatorDescriptors(Class<A> annotationType,List<ConstraintValidatorDescriptor<A>> validatorDescriptors,boolean keepExistingClasses){\r\n    List<ConstraintValidatorDescriptor<A>> validatorDescriptorsToAdd = new ArrayList();\r\n    if (keepExistingClasses) {\r\n        List<ConstraintValidatorDescriptor<A>> existingvalidatorDescriptors = getAllValidatorDescriptors(annotationType);\r\n        if (existingvalidatorDescriptors != null) {\r\n            validatorDescriptorsToAdd.addAll(0, existingvalidatorDescriptors);\r\n        }\r\n    }\r\n    validatorDescriptorsToAdd.addAll(validatorDescriptors);\r\n    this.validatorDescriptors.put(annotationType, CollectionHelper.toImmutableList(validatorDescriptorsToAdd));\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.tests.pfa.tests.tiled.TiledSmoothableGraphPath.getNodePosition",
	"Comment": "returns the position of the node at the given index.\tnote that the same vector2 instance is returned each time this method is called.",
	"Method": "Vector2 getNodePosition(int index){\r\n    N node = nodes.get(index);\r\n    return tmpPosition.set(node.x, node.y);\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.SqlDataAccessService.postConstruct",
	"Comment": "is executed after dependency injection is done to perform any initialization.",
	"Method": "void postConstruct(){\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"|-SQL Data Access Service active...\");\r\n    }\r\n}"
}, {
	"Path": "com.firebase.geofire.GeoQuery.setRadius",
	"Comment": "sets the radius of this query, in kilometers, and triggers new events if necessary.",
	"Method": "void setRadius(double radius){\r\n    this.radius = capRadius(radius) * KILOMETER_TO_METER;\r\n    if (this.hasListeners()) {\r\n        this.setupQueries();\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth2.PasswordTokenRequest.setPassword",
	"Comment": "sets the resource owner password.overriding is only supported for the purpose of calling the super implementation and changingthe return type, but nothing else.",
	"Method": "PasswordTokenRequest setPassword(String password){\r\n    this.password = Preconditions.checkNotNull(password);\r\n    return this;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.metadata.aggregated.ExecutableMetaData.getParameterMetaData",
	"Comment": "returns meta data for the specified parameter of the represented executable.",
	"Method": "ParameterMetaData getParameterMetaData(int parameterIndex){\r\n    return parameterMetaDataList.get(parameterIndex);\r\n}"
}, {
	"Path": "org.kohsuke.github.GHRepository.getRefs",
	"Comment": "retrieves all refs of the given type for the current github repository.",
	"Method": "GHRef[] getRefs(GHRef[] getRefs,String refType){\r\n    return GHRef.wrap(root.retrieve().to(String.format(\"/repos/%s/%s/git/refs/%s\", getOwnerName(), name, refType), GHRef[].class), root);\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.cfg.context.ConstraintMappingContextImplBase.addConstraint",
	"Comment": "adds a constraint to the set of constraints managed by this creational context.",
	"Method": "void addConstraint(ConfiguredConstraint<?> constraint){\r\n    constraints.add(constraint);\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.util.privilegedactions.LoadClass.action",
	"Comment": "in some cases, the tccl has been overridden so we need to pass it explicitly.",
	"Method": "LoadClass action(String className,ClassLoader classLoader,LoadClass action,String className,ClassLoader classLoader,boolean fallbackOnTCCL,LoadClass action,String className,ClassLoader classLoader,ClassLoader initialThreadContextClassLoader){\r\n    return new LoadClass(className, classLoader, initialThreadContextClassLoader, true);\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.getRandomUUIDString",
	"Comment": "returns the unique string that will be used as a storagedata id. this id needs to be unique\tnot only for the current cmr, but we need to ensure that is unique for all cmrs, because the\tcorrelation between storage and cmr will be done by this id.",
	"Method": "String getRandomUUIDString(){\r\n    return UUID.randomUUID().toString();\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.jmx.JmxSensor.getArrayValue",
	"Comment": "correctly handles printing of the array no matter if the array class is primitive or not.",
	"Method": "String getArrayValue(Object collectedArray){\r\n    if ((null != collectedArray) && collectedArray.getClass().isArray()) {\r\n        StringBuilder sb = new StringBuilder(\"[\");\r\n        int length = Array.getLength(collectedArray);\r\n        for (int i = 0; i < length; i++) {\r\n            if (i > 0) {\r\n                sb.append(\", \");\r\n            }\r\n            sb.append(Array.get(collectedArray, i));\r\n        }\r\n        sb.append(']');\r\n        return sb.toString();\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.util.Configuration.isVerbose",
	"Comment": "whether logging information shall be put out in a verbose way or not.",
	"Method": "boolean isVerbose(){\r\n    return verbose;\r\n}"
}, {
	"Path": "org.influxdb.msgpack.MessagePackTraverser.parse",
	"Comment": "parse the message pack stream.this method can be used for converting queryresult from normal query response where exactly one queryresult returned",
	"Method": "QueryResult parse(InputStream is,QueryResult parse,MessageUnpacker unpacker){\r\n    QueryResult queryResult = new QueryResult();\r\n    QueryResultModelPath queryResultPath = new QueryResultModelPath();\r\n    queryResultPath.add(\"queryResult\", queryResult);\r\n    try {\r\n        traverse(unpacker, queryResultPath, 1);\r\n    } catch (IOException e) {\r\n        throw new InfluxDBException(e);\r\n    }\r\n    return queryResult;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.jdbc.ConnectionMetaDataStorage.get",
	"Comment": "retrieves the connectionmetadata stored with this connection.",
	"Method": "ConnectionMetaData get(Object connection){\r\n    if (null == connection) {\r\n        return null;\r\n    }\r\n    try {\r\n        return storage.get(connection, new Callable<ConnectionMetaData>() {\r\n            @Override\r\n            public ConnectionMetaData call() throws Exception {\r\n                ConnectionMetaData data = dataExtractor.parse(connection);\r\n                return data != null ? data : EMPTY;\r\n            }\r\n        });\r\n    } catch (ExecutionException e) {\r\n        return EMPTY;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.jdbc.ConnectionMetaDataStorage.get",
	"Comment": "retrieves the connectionmetadata stored with this connection.",
	"Method": "ConnectionMetaData get(Object connection){\r\n    ConnectionMetaData data = dataExtractor.parse(connection);\r\n    return data != null ? data : EMPTY;\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.classchecks.MethodInheritanceTree.getTopLevelMethods",
	"Comment": "returns a set containing all the top level overridden methods.",
	"Method": "Set<ExecutableElement> getTopLevelMethods(){\r\n    return topLevelMethods;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.metadata.raw.ConstrainedExecutable.getAllParameterMetaData",
	"Comment": "returns meta data for all parameters of the represented executable.",
	"Method": "List<ConstrainedParameter> getAllParameterMetaData(){\r\n    return parameterMetaData;\r\n}"
}, {
	"Path": "org.influxdb.InfluxDBTest.testCreateNumericNamedDatabase",
	"Comment": "test that creating database which name is composed of numbers only works",
	"Method": "void testCreateNumericNamedDatabase(){\r\n    String numericDbName = \"123\";\r\n    this.influxDB.createDatabase(numericDbName);\r\n    List<String> result = this.influxDB.describeDatabases();\r\n    Assertions.assertTrue(result.contains(numericDbName));\r\n    this.influxDB.deleteDatabase(numericDbName);\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.constraintdefinition.ConstraintDefinitionContribution.includeExisting",
	"Comment": "whether or not the existing constraint validators should be kept or not.",
	"Method": "boolean includeExisting(){\r\n    return includeExisting;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.ReachOrientation.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum angular speed and\tacceleration.",
	"Method": "ReachOrientation<T> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Jump.getTakeoffVelocityTolerance",
	"Comment": "returns the tolerance used to check if the owner has reached the takeoff velocity.",
	"Method": "float getTakeoffVelocityTolerance(){\r\n    return takeoffVelocityTolerance;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.http.StartEndMarker.matchesFirst",
	"Comment": "checks if we already returned to the method that marked the first call.",
	"Method": "boolean matchesFirst(){\r\n    return super.get().getValue() == 0;\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.AbstractObjectSizes.getConcurrentMapCapacityFromSize",
	"Comment": "returns the capacity of the concurrenthashmap from it size. the calculations take the default\tcapacity of 16 and default load factor of 0.75.",
	"Method": "int getConcurrentMapCapacityFromSize(int mapSize,int initialCapacity){\r\n    if (mapSize == 0) {\r\n        return 0;\r\n    }\r\n    int capacity = 1;\r\n    if (initialCapacity > 0) {\r\n        capacity = initialCapacity;\r\n    }\r\n    float loadFactor = 0.75f;\r\n    int threshold = (int) (capacity * loadFactor);\r\n    while (threshold <= mapSize) {\r\n        capacity *= 2;\r\n        threshold = (int) (capacity * loadFactor);\r\n    }\r\n    return capacity;\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.sorting.IndirectSort.mergesort",
	"Comment": "returns the order of elements between indices start andlength, as indicated by the given comparator.this routine uses merge sort. it is guaranteed to be stable.",
	"Method": "int[] mergesort(int start,int length,IndirectComparator comparator,int[] mergesort,T[] input,int start,int length,Comparator<? super T> comparator){\r\n    return mergesort(start, length, new IndirectComparator.DelegatingComparator<T>(input, comparator));\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.html.StreamedHtmlScriptInjector.scanXmlDeclaration",
	"Comment": "scans for an openingdeclaration in case the html is delivered as xml.",
	"Method": "void scanXmlDeclaration(){\r\n    if (CharSequenceUtils.checkEqualIgnoreCase(tokenParser.getTagType(), \"?xml\")) {\r\n        if (tokenParser.getParsedTokenType() != Token.STANDALONE_TAG) {\r\n            abortInjectionPointSearch();\r\n            return;\r\n        }\r\n        status = Status.SCAN_REQUIRED_XHTML_PREAMBLE;\r\n    } else {\r\n        status = Status.SCAN_HTML_PREAMBLE;\r\n        processToken();\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.BufferProperties.getMaxObjectExpansionRateActiveTillBufferSize",
	"Comment": "returns buffer size till which maximum object expansion rate is active.",
	"Method": "long getMaxObjectExpansionRateActiveTillBufferSize(){\r\n    return maxObjectExpansionRateActiveTillBufferSize;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.platform.provider.ibm.IbmJava6OperatingSystemInfoProvider.getMethod",
	"Comment": "loads the wanted method from the class and makes it accessible.",
	"Method": "Method getMethod(Class<?> clazz,String methodName,Class<?> parameterTypes){\r\n    Method m = clazz.getDeclaredMethod(methodName, parameterTypes);\r\n    m.setAccessible(true);\r\n    return m;\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.BitUtil.pop_andnot",
	"Comment": "returns the popcount or cardinality of a & ~b. neither array is modified.",
	"Method": "long pop_andnot(long[] arr1,long[] arr2,int wordOffset,int numWords){\r\n    long popCount = 0;\r\n    for (int i = wordOffset, end = wordOffset + numWords; i < end; ++i) {\r\n        popCount += Long.bitCount(arr1[i] & ~arr2[i]);\r\n    }\r\n    return popCount;\r\n}"
}, {
	"Path": "rocks.inspectit.server.property.PropertyUpdateExecutor.getTargetObject",
	"Comment": "checks if the given bean is proxy and if so tries to get the target object. otherwise returns\tthe original bean.",
	"Method": "Object getTargetObject(Object bean){\r\n    if (AopUtils.isJdkDynamicProxy(bean)) {\r\n        return ((Advised) bean).getTargetSource().getTarget();\r\n    } else {\r\n        return bean;\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.constraintvalidators.bv.time.AbstractInstantBasedTimeValidator.isValid",
	"Comment": "returns whether the result of the comparison between the validated value and the time reference is considered\tvalid.",
	"Method": "boolean isValid(T value,ConstraintValidatorContext context,boolean isValid,int result){\r\n    if (value == null) {\r\n        return true;\r\n    }\r\n    int result = getInstant(value).compareTo(referenceClock.instant());\r\n    return isValid(result);\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.KTypeVTypeHashMap.addTo",
	"Comment": "adds incrementvalue to any existing value for the given keyor inserts incrementvalue if key did not previously exist.",
	"Method": "VType addTo(KType key,VType incrementValue){\r\n    return putOrAdd(key, incrementValue, incrementValue);\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.btree.Task.cancelRunningChildren",
	"Comment": "terminates the running children of this task starting from the specified index up to the end.",
	"Method": "void cancelRunningChildren(int startIndex){\r\n    for (int i = startIndex, n = getChildCount(); i < n; i++) {\r\n        Task<E> child = getChild(i);\r\n        if (child.status == Status.RUNNING)\r\n            child.cancel();\r\n    }\r\n}"
}, {
	"Path": "com.carrotsearch.hppc.BitUtil.pop_xor",
	"Comment": "returns the popcount or cardinality of a ^ b neither array is modified.",
	"Method": "long pop_xor(long[] arr1,long[] arr2,int wordOffset,int numWords){\r\n    long popCount = 0;\r\n    for (int i = wordOffset, end = wordOffset + numWords; i < end; ++i) {\r\n        popCount += Long.bitCount(arr1[i] ^ arr2[i]);\r\n    }\r\n    return popCount;\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.rest.PlatformRestfulService.handleAllException",
	"Comment": "handling of all the exceptions happening in this controller.",
	"Method": "ModelAndView handleAllException(Exception exception){\r\n    return new JsonError(exception).asModelAndView();\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.engine.rule.ActionMethod.getObjectArray",
	"Comment": "converts the result to an object array depending on the component type of the array.",
	"Method": "Object[] getObjectArray(Object result){\r\n    if (result.getClass().getComponentType().isPrimitive()) {\r\n        int length = Array.getLength(result);\r\n        Object[] array = new Object[length];\r\n        for (int i = 0; i < length; ++i) {\r\n            array[i] = Array.get(result, i);\r\n        }\r\n        return array;\r\n    } else {\r\n        return (Object[]) result;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.mail.EMailSender.prepareHtmlEmail",
	"Comment": "prepares an email object including the default recipients.",
	"Method": "HtmlEmail prepareHtmlEmail(List<String> recipients,HtmlEmail prepareHtmlEmail,List<String> recipients,boolean includeDefaultRecipients){\r\n    HtmlEmail email = objectFactory.createHtmlEmail();\r\n    email.setHostName(smtpHost);\r\n    email.setSmtpPort(smtpPort);\r\n    if (StringUtils.isNotEmpty(smtpUser) && StringUtils.isNotEmpty(smtpPassword)) {\r\n        email.setAuthentication(smtpUser, smtpPassword);\r\n    }\r\n    email.setFrom(senderAddress, senderName);\r\n    if ((additionalProperties != null) && !additionalProperties.isEmpty()) {\r\n        email.getMailSession().getProperties().putAll(additionalProperties);\r\n    }\r\n    if (includeDefaultRecipients) {\r\n        for (String defaultTo : defaultRecipients) {\r\n            try {\r\n                email.addTo(defaultTo);\r\n            } catch (EmailException e) {\r\n                if (log.isWarnEnabled()) {\r\n                    log.warn(\"Invalid recipient e-mail address!\", e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (recipients != null) {\r\n        for (String to : recipients) {\r\n            try {\r\n                email.addTo(to);\r\n            } catch (EmailException e) {\r\n                if (log.isWarnEnabled()) {\r\n                    log.warn(\"Invalid recipient e-mail address!\", e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return email;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.btree.decorator.Random.start",
	"Comment": "draws a value from the distribution that determines the success probability.\tthis method is called when the task is entered.",
	"Method": "void start(){\r\n    p = success.nextFloat();\r\n}"
}, {
	"Path": "com.google.api.client.auth.openidconnect.IdTokenResponse.setIdToken",
	"Comment": "sets the id token.overriding is only supported for the purpose of calling the super implementation and changingthe return type, but nothing else.",
	"Method": "IdTokenResponse setIdToken(String idToken){\r\n    this.idToken = Preconditions.checkNotNull(idToken);\r\n    return this;\r\n}"
}, {
	"Path": "com.google.api.client.auth.oauth2.RefreshTokenRequest.setRefreshToken",
	"Comment": "sets the refresh token issued to the client.overriding is only supported for the purpose of calling the super implementation and changingthe return type, but nothing else.",
	"Method": "RefreshTokenRequest setRefreshToken(String refreshToken){\r\n    this.refreshToken = Preconditions.checkNotNull(refreshToken);\r\n    return this;\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.classchecks.MethodInheritanceTree.hasParallelDefinitions",
	"Comment": "checks if there are any parallel definitions of the method in the hierarchy.",
	"Method": "boolean hasParallelDefinitions(){\r\n    return topLevelMethods.size() > 1;\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.AgentStorageService.postConstruct",
	"Comment": "is executed after dependency injection is done to perform any initialization.",
	"Method": "void postConstruct(){\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"|-Agent Storage Service active...\");\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.MethodValidationConfiguration.getConfiguredRuleSet",
	"Comment": "return an unmodifiable set of methodconfigurationrule that are to be\tenforced based on the configuration.",
	"Method": "Set<MethodConfigurationRule> getConfiguredRuleSet(){\r\n    return configuredRuleSet;\r\n}"
}, {
	"Path": "com.google.api.client.auth.openidconnect.IdTokenResponse.execute",
	"Comment": "executes the given id token request, and returns the parsed id token response.",
	"Method": "IdTokenResponse execute(TokenRequest tokenRequest){\r\n    return tokenRequest.executeUnparsed().parseAs(IdTokenResponse.class);\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.BufferProperties.getMinObjectExpansionRateActiveFromBufferSize",
	"Comment": "returns buffer size from which minimum object expansion rate is active.",
	"Method": "long getMinObjectExpansionRateActiveFromBufferSize(){\r\n    return minObjectExpansionRateActiveFromBufferSize;\r\n}"
}, {
	"Path": "com.alorma.github.inapp.Inventory.hasPurchase",
	"Comment": "returns whether or not there exists a purchase of the given product.",
	"Method": "boolean hasPurchase(String sku){\r\n    return mPurchaseMap.containsKey(sku);\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.testutil.CompilerTestHelper.getSourceFile",
	"Comment": "retrieves a file object containing the source of the given class.",
	"Method": "File getSourceFile(Class<?> clazz){\r\n    String sourceFileName = File.separator + clazz.getName().replace(\".\", File.separator) + \".java\";\r\n    return new File(sourceBaseDir + sourceFileName);\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.ConfigurationImpl.getDefaultMessageInterpolatorConfiguredWithClassLoader",
	"Comment": "returns the default message interpolator, configured with the given user class loader, if present.",
	"Method": "MessageInterpolator getDefaultMessageInterpolatorConfiguredWithClassLoader(){\r\n    if (externalClassLoader != null) {\r\n        PlatformResourceBundleLocator userResourceBundleLocator = new PlatformResourceBundleLocator(ResourceBundleMessageInterpolator.USER_VALIDATION_MESSAGES, externalClassLoader);\r\n        PlatformResourceBundleLocator contributorResourceBundleLocator = new PlatformResourceBundleLocator(ResourceBundleMessageInterpolator.CONTRIBUTOR_VALIDATION_MESSAGES, externalClassLoader, true);\r\n        final ClassLoader originalContextClassLoader = run(GetClassLoader.fromContext());\r\n        try {\r\n            run(SetContextClassLoader.action(externalClassLoader));\r\n            return new ResourceBundleMessageInterpolator(userResourceBundleLocator, contributorResourceBundleLocator);\r\n        } finally {\r\n            run(SetContextClassLoader.action(originalContextClassLoader));\r\n        }\r\n    } else {\r\n        return getDefaultMessageInterpolator();\r\n    }\r\n}"
}, {
	"Path": "com.google.api.client.auth.openidconnect.IdToken.verifyIssuer",
	"Comment": "returns whether the issuer in the payload matches the given expected issuer as specified instep 1 of id tokenvalidation. when an issuer is migrating to a new issuer string the expected issuer hasmultiple aliases, so multiple are permitted here.",
	"Method": "boolean verifyIssuer(String expectedIssuer,boolean verifyIssuer,Collection<String> expectedIssuer){\r\n    return expectedIssuer.contains(getPayload().getIssuer());\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.special.ClassLoadingDelegationHook.loadClass",
	"Comment": "loads class with the given parameters that have been passed to the target class loader.\tloading will be delegated only if parameters are of size 1 and that single parameter is\tstring type.",
	"Method": "Class<?> loadClass(Object classLoader,Object[] params,Class<?> loadClass,Object classLoader,String className){\r\n    if (loadWithInspectItClassLoader(classLoader, className)) {\r\n        try {\r\n            return getInspectITClassLoader().loadClass(className);\r\n        } catch (ClassNotFoundException e) {\r\n            LOG.warn(\"Class \" + className + \" could not be loaded with the inspectIT class loader, although it has the correct prefix.\", e);\r\n            return null;\r\n        }\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.kohsuke.github.GHPullRequest.populate",
	"Comment": "fully populate the data by retrieving missing data.depending on the original api call where this object is created, it may not contain everything.",
	"Method": "void populate(){\r\n    if (mergeable_state != null)\r\n        return;\r\n    refresh();\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.ConfigurationInterfaceService.postConstruct",
	"Comment": "is executed after dependency injection is done to perform any initialization.",
	"Method": "void postConstruct(){\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"|-Configuration Interface Service active...\");\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Hide.setDistanceFromBoundary",
	"Comment": "sets the distance from the boundary of the obstacle behind which to hide.",
	"Method": "Hide<T> setDistanceFromBoundary(float distanceFromBoundary){\r\n    this.distanceFromBoundary = distanceFromBoundary;\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.updateExistingStorageSize",
	"Comment": "updates size of the given storage and saves information to this.",
	"Method": "void updateExistingStorageSize(StorageData storageData){\r\n    if (null != storageData) {\r\n        synchronized (storageData) {\r\n            long newSize = getDiskSizeForStorage(storageData);\r\n            if (newSize != storageData.getDiskSize()) {\r\n                storageData.setDiskSize(newSize);\r\n                writeStorageDataToDisk(storageData);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.kohsuke.github.GitHub.rateLimit",
	"Comment": "gets the current rate limit while trying not to actually make any remote requests unless absolutely necessary.",
	"Method": "GHRateLimit rateLimit(){\r\n    synchronized (headerRateLimitLock) {\r\n        if (headerRateLimit != null) {\r\n            return headerRateLimit;\r\n        }\r\n    }\r\n    GHRateLimit rateLimit = this.rateLimit;\r\n    if (rateLimit == null || rateLimit.getResetDate().getTime() < System.currentTimeMillis()) {\r\n        rateLimit = getRateLimit();\r\n    }\r\n    return rateLimit;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.config.impl.ConfigurationStorage.loadConfigurationFromJvmParameters",
	"Comment": "checks if the jvm parameters have the repository and agent information.",
	"Method": "void loadConfigurationFromJvmParameters(){\r\n    String repositoryProperty = System.getProperty(REPOSITORY_PROPERTY);\r\n    if (null != repositoryProperty) {\r\n        String[] repositoryIpHost = repositoryProperty.split(\":\");\r\n        if (repositoryIpHost.length == 2) {\r\n            String repositoryIp = repositoryIpHost[0];\r\n            String repositoryPort = repositoryIpHost[1];\r\n            if (StringUtils.isNotBlank(repositoryIp) && StringUtils.isNotBlank(repositoryPort)) {\r\n                log.info(\"Repository information found in the JVM parameters: IP=\" + repositoryIp + \" Port=\" + repositoryPort);\r\n                try {\r\n                    int port = Integer.parseInt(repositoryPort);\r\n                    setRepository(repositoryIp, port);\r\n                } catch (Exception e) {\r\n                    log.warn(\"Repository could not be defined from the data in the JVM parameters\", e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    String agentName = System.getProperty(AGENT_NAME_PROPERTY);\r\n    if (StringUtils.isNotBlank(agentName)) {\r\n        String newAgentName = checkPatternAgentName(agentName).replaceAll(\"(\\r|\\n)\", \"\");\r\n        try {\r\n            log.info(\"Agent name found in the JVM parameters: AgentName=\" + newAgentName);\r\n            setAgentName(newAgentName);\r\n        } catch (Exception e) {\r\n            log.warn(\"Agent name could not be defined from the data in the JVM parameters\", e);\r\n        }\r\n    } else {\r\n        try {\r\n            log.info(\"Agent name set by default: AgentName = \" + DEFAULT_AGENT_NAME);\r\n            setAgentName(DEFAULT_AGENT_NAME);\r\n        } catch (StorageException e) {\r\n            log.warn(\"Agent name could not be defined from default agent name\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.engine.constraintvalidation.ConstraintValidatorManager.resolveAssignableTypes",
	"Comment": "tries to reduce all assignable classes down to a single class.",
	"Method": "void resolveAssignableTypes(List<Type> assignableTypes){\r\n    if (assignableTypes.size() == 0 || assignableTypes.size() == 1) {\r\n        return;\r\n    }\r\n    List<Type> typesToRemove = new ArrayList();\r\n    do {\r\n        typesToRemove.clear();\r\n        Type type = assignableTypes.get(0);\r\n        for (int i = 1; i < assignableTypes.size(); i++) {\r\n            if (TypeHelper.isAssignable(type, assignableTypes.get(i))) {\r\n                typesToRemove.add(type);\r\n            } else if (TypeHelper.isAssignable(assignableTypes.get(i), type)) {\r\n                typesToRemove.add(assignableTypes.get(i));\r\n            }\r\n        }\r\n        assignableTypes.removeAll(typesToRemove);\r\n    } while (typesToRemove.size() > 0);\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.SteeringAcceleration.setZero",
	"Comment": "zeros the linear and angular components of this steering acceleration.",
	"Method": "SteeringAcceleration<T> setZero(){\r\n    linear.setZero();\r\n    angular = 0f;\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.proxy.impl.ASMProxyBuilder.getTypes",
	"Comment": "utility function for retrieving the types for a set of classes.",
	"Method": "Type[] getTypes(Collection<Class<?>> classes){\r\n    Type[] types = new Type[classes.size()];\r\n    int i = 0;\r\n    for (Class<?> clazz : classes) {\r\n        types[i] = Type.getType(clazz);\r\n        i++;\r\n    }\r\n    return types;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.html.StreamedHtmlScriptInjector.scanForBodyTag",
	"Comment": "tries to find an opening body tag. omitting both the head and the body tag is currently not\tsupported.",
	"Method": "void scanForBodyTag(){\r\n    if (CharSequenceUtils.checkEqualIgnoreCase(tokenParser.getTagType(), \"body\")) {\r\n        if (tokenParser.getParsedTokenType() != Token.START_TAG) {\r\n            abortInjectionPointSearch();\r\n            return;\r\n        }\r\n        status = Status.INJECTION_POINT_FOUND;\r\n    } else {\r\n        abortInjectionPointSearch();\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.btree.Task.cancel",
	"Comment": "terminates this task and all its running children. this method must be called only if this task is running.",
	"Method": "void cancel(){\r\n    cancelRunningChildren(0);\r\n    Status previousStatus = status;\r\n    status = Status.CANCELLED;\r\n    if (tree.listeners != null && tree.listeners.size > 0)\r\n        tree.notifyStatusUpdated(this, previousStatus);\r\n    end();\r\n}"
}, {
	"Path": "org.kohsuke.github.GitHub.listAllPublicRepositories",
	"Comment": "this provides a dump of every public repository, in the order that they were created.",
	"Method": "PagedIterable<GHRepository> listAllPublicRepositories(PagedIterable<GHRepository> listAllPublicRepositories,String since){\r\n    return new PagedIterable<GHRepository>() {\r\n        public PagedIterator<GHRepository> _iterator(int pageSize) {\r\n            return new PagedIterator<GHRepository>(retrieve().with(\"since\", since).asIterator(\"/repositories\", GHRepository[].class, pageSize)) {\r\n                @Override\r\n                protected void wrapUp(GHRepository[] page) {\r\n                    for (GHRepository c : page) c.wrap(GitHub.this);\r\n                }\r\n            };\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.kohsuke.github.GitHub.listAllPublicRepositories",
	"Comment": "this provides a dump of every public repository, in the order that they were created.",
	"Method": "PagedIterable<GHRepository> listAllPublicRepositories(PagedIterable<GHRepository> listAllPublicRepositories,String since){\r\n    return new PagedIterator<GHRepository>(retrieve().with(\"since\", since).asIterator(\"/repositories\", GHRepository[].class, pageSize)) {\r\n        @Override\r\n        protected void wrapUp(GHRepository[] page) {\r\n            for (GHRepository c : page) c.wrap(GitHub.this);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.kohsuke.github.GitHub.listAllPublicRepositories",
	"Comment": "this provides a dump of every public repository, in the order that they were created.",
	"Method": "PagedIterable<GHRepository> listAllPublicRepositories(PagedIterable<GHRepository> listAllPublicRepositories,String since){\r\n    for (GHRepository c : page) c.wrap(GitHub.this);\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.http.HttpInformationExtractor.getQueryString",
	"Comment": "reads the request query string name from the httpservletrequest object.",
	"Method": "String getQueryString(Class<?> httpServletRequestClass,Object httpServletRequest){\r\n    Method m = retrieveMethod(HttpMethods.RESPONSE_GET_QUERY_STRING, httpServletRequestClass);\r\n    if (null == m) {\r\n        return null;\r\n    }\r\n    try {\r\n        return (String) m.invoke(httpServletRequest, (Object[]) null);\r\n    } catch (Exception e) {\r\n        LOG.error(\"Invocation on given object failed.\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Evade.setLimiter",
	"Comment": "sets the limiter of this steering behavior. the given limiter must at least take care of the maximum linear acceleration.",
	"Method": "Evade<T> setLimiter(Limiter limiter){\r\n    this.limiter = limiter;\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.isStorageOpen",
	"Comment": "returns if the storage is opened, and thus if the write to the storage can be executed.",
	"Method": "boolean isStorageOpen(StorageData storageData){\r\n    for (StorageData existing : openedStoragesMap.keySet()) {\r\n        if (existing.getId().equals(storageData.getId())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.rest.BusinessContextDefinitionRestfulService.handleAllException",
	"Comment": "handling of all the exceptions happening in this controller.",
	"Method": "ModelAndView handleAllException(Exception exception){\r\n    return new JsonError(exception).asModelAndView();\r\n}"
}, {
	"Path": "rocks.inspectit.server.rmi.KryoNetServerCreator.createServer",
	"Comment": "start the kryonet server and binds it to the specified port.",
	"Method": "Server createServer(){\r\n    IExtendedSerialization serialization = new ExtendedSerializationImpl(serializationManagerProvider);\r\n    Server server = new Server(serialization, streamProvider);\r\n    server.start();\r\n    try {\r\n        server.bind(port);\r\n        log.info(\"|-Kryonet server successfully started and running on port \" + port);\r\n    } catch (IOException e) {\r\n        throw new BeanInitializationException(\"Could not bind the kryonet server to the specified port (\" + port + \").\", e);\r\n    }\r\n    return server;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.SteeringAcceleration.scl",
	"Comment": "scales this steering acceleration by the specified scalar.",
	"Method": "SteeringAcceleration<T> scl(float scalar){\r\n    linear.scl(scalar);\r\n    angular *= scalar;\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.reflection.CachedConstructor.newInstance",
	"Comment": "invokes the constructor in the given classloader context. does not catch any occurring\texceptions.",
	"Method": "Object newInstance(ClassLoader env,Object parameters){\r\n    Constructor<?> constructor = findConstructor(env);\r\n    if (constructor == null) {\r\n        throw new RuntimeException(\"Constructor not found on \" + className);\r\n    } else {\r\n        return constructor.newInstance(parameters);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.AbstractObjectSizes.getSizeOfHighScaleLibCAT",
	"Comment": "returns size of the cat object used in the high scale lib counter.",
	"Method": "long getSizeOfHighScaleLibCAT(){\r\n    long size = this.getSizeOfObjectHeader();\r\n    size += this.getPrimitiveTypesSize(2, 0, 0, 0, 4, 0);\r\n    size = alignTo8Bytes(size);\r\n    size += this.getSizeOfPrimitiveArray(4, LONG_SIZE);\r\n    return size;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.Separation.setDecayCoefficient",
	"Comment": "sets the coefficient of decay for the inverse square law force. it controls how fast the separation strength decays with\tdistance.",
	"Method": "Separation<T> setDecayCoefficient(float decayCoefficient){\r\n    this.decayCoefficient = decayCoefficient;\r\n    return this;\r\n}"
}, {
	"Path": "com.alorma.github.inapp.Inventory.getPurchase",
	"Comment": "returns purchase information for a given product, or null if there is no purchase.",
	"Method": "Purchase getPurchase(String sku){\r\n    return mPurchaseMap.get(sku);\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.classcache.ClassCacheModification.init",
	"Comment": "creates a new instance of the modification service. note that this constructor is package\taccess on purpose to allow the class cache to create instances but to disallow creating\tinstances from the outside.",
	"Method": "void init(ClassCache classCache){\r\n    this.classCache = classCache;\r\n    this.lookup = classCache.getLookupService();\r\n}"
}, {
	"Path": "rocks.inspectit.server.spring.exporter.RemotingExporter.getNameForExporterBean",
	"Comment": "creates the name of the exporter bean under which it will be exposed in the spring container.",
	"Method": "String getNameForExporterBean(String beanName,Annotation annotation){\r\n    String name = (String) AnnotationUtils.getValue(annotation, \"name\");\r\n    if ((null != name) && !\"\".equals(name.trim())) {\r\n        return name;\r\n    } else {\r\n        return beanName + \"Exporter\";\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.eum.instrumentation.JSAgentBuilder.setConfiguration",
	"Comment": "configuration initialization. automatically called by spring.",
	"Method": "void setConfiguration(IConfigurationStorage config){\r\n    if (config != null) {\r\n        try {\r\n            useMinifedAgent = config.getEndUserMonitoringConfig().isAgentMinificationEnabled();\r\n        } catch (StorageException e) {\r\n            useMinifedAgent = false;\r\n        }\r\n    } else {\r\n        useMinifedAgent = false;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.classcache.ClassCacheInstrumentation.removeInstrumentationPoints",
	"Comment": "removes all instrumentation point from the given types that that might be created as result\tof given instrumentation appliers.",
	"Method": "Collection<? extends ImmutableClassType> removeInstrumentationPoints(Collection<? extends ImmutableClassType> removeInstrumentationPoints,Collection<? extends ImmutableType> types,Collection<? extends ImmutableClassType> removeInstrumentationPoints,Collection<? extends ImmutableType> types,Collection<IInstrumentationApplier> instrumentationAppliers){\r\n    if (CollectionUtils.isEmpty(types)) {\r\n        return Collections.emptyList();\r\n    }\r\n    try {\r\n        return classCache.executeWithWriteLock(new Callable<Collection<? extends ImmutableClassType>>() {\r\n            @Override\r\n            public Collection<? extends ImmutableClassType> call() throws Exception {\r\n                Collection<ImmutableClassType> results = new ArrayList();\r\n                for (ImmutableType type : types) {\r\n                    if (type.isClass() && type.isInitialized()) {\r\n                        ClassType classType = (ClassType) type.castToClass();\r\n                        boolean added = false;\r\n                        for (IInstrumentationApplier applier : instrumentationAppliers) {\r\n                            added |= applier.removeInstrumentationPoints(classType);\r\n                        }\r\n                        if (added) {\r\n                            results.add(type.castToClass());\r\n                        }\r\n                    }\r\n                }\r\n                return results;\r\n            }\r\n        });\r\n    } catch (Exception e) {\r\n        log.error(\"Error occurred while trying to remove specific instrumentation points from the class cache.\", e);\r\n        return Collections.emptyList();\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.classcache.ClassCacheInstrumentation.removeInstrumentationPoints",
	"Comment": "removes all instrumentation point from the given types that that might be created as result\tof given instrumentation appliers.",
	"Method": "Collection<? extends ImmutableClassType> removeInstrumentationPoints(Collection<? extends ImmutableClassType> removeInstrumentationPoints,Collection<? extends ImmutableType> types,Collection<? extends ImmutableClassType> removeInstrumentationPoints,Collection<? extends ImmutableType> types,Collection<IInstrumentationApplier> instrumentationAppliers){\r\n    Collection<ImmutableClassType> results = new ArrayList();\r\n    for (ImmutableType type : types) {\r\n        if (type.isClass() && type.isInitialized()) {\r\n            ClassType classType = (ClassType) type.castToClass();\r\n            boolean added = false;\r\n            for (IInstrumentationApplier applier : instrumentationAppliers) {\r\n                added |= applier.removeInstrumentationPoints(classType);\r\n            }\r\n            if (added) {\r\n                results.add(type.castToClass());\r\n            }\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "fr.adrienbrault.idea.symfony2plugin.util.PhpTypeProviderUtil.getResolvedParameter",
	"Comment": "we can also pipe php references signatures and resolve them hereoverwrite parameter to get string value",
	"Method": "String getResolvedParameter(PhpIndex phpIndex,String parameter){\r\n    if (parameter.startsWith(\"#K#C\")) {\r\n        if (parameter.endsWith(\".class\")) {\r\n            return parameter.substring(4, parameter.length() - 6);\r\n        }\r\n        if (parameter.endsWith(\".\")) {\r\n            return parameter.substring(4, parameter.length() - 1);\r\n        }\r\n    }\r\n    if (parameter.startsWith(\"#\")) {\r\n        Collection<? extends PhpNamedElement> signTypes = phpIndex.getBySignature(parameter, null, 0);\r\n        if (signTypes.size() == 0) {\r\n            return null;\r\n        }\r\n        parameter = PhpElementsUtil.getStringValue(signTypes.iterator().next());\r\n        if (parameter == null) {\r\n            return null;\r\n        }\r\n    }\r\n    return parameter;\r\n}"
}, {
	"Path": "org.hibernate.validator.internal.metadata.raw.ConstrainedExecutable.isEquallyParameterConstrained",
	"Comment": "whether this and the given other executable have the same parameter\tconstraints.",
	"Method": "boolean isEquallyParameterConstrained(ConstrainedExecutable other){\r\n    if (!getDescriptors(crossParameterConstraints).equals(getDescriptors(other.crossParameterConstraints))) {\r\n        return false;\r\n    }\r\n    int i = 0;\r\n    for (ConstrainedParameter parameter : parameterMetaData) {\r\n        ConstrainedParameter otherParameter = other.getParameterMetaData(i);\r\n        if (!parameter.getCascadingMetaDataBuilder().equals(otherParameter.getCascadingMetaDataBuilder()) || !getDescriptors(parameter.getConstraints()).equals(getDescriptors(otherParameter.getConstraints()))) {\r\n            return false;\r\n        }\r\n        i++;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.classcache.ClassCache.getLookupService",
	"Comment": "returns the lookup service, which allows to search for specific entries within the class\tcache.",
	"Method": "ClassCacheLookup getLookupService(){\r\n    return lookupService;\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.sched.LoadBalancingScheduler.run",
	"Comment": "executes scheduled tasks based on their frequency and phase. this method must be called once per frame.",
	"Method": "void run(long timeToRun){\r\n    frame++;\r\n    runList.size = 0;\r\n    for (int i = 0; i < schedulableRecords.size; i++) {\r\n        SchedulableRecord record = schedulableRecords.get(i);\r\n        if ((frame + record.phase) % record.frequency == 0)\r\n            runList.add(record);\r\n    }\r\n    long lastTime = TimeUtils.nanoTime();\r\n    int numToRun = runList.size;\r\n    for (int i = 0; i < numToRun; i++) {\r\n        long currentTime = TimeUtils.nanoTime();\r\n        timeToRun -= currentTime - lastTime;\r\n        long availableTime = timeToRun / (numToRun - i);\r\n        runList.get(i).schedulable.run(availableTime);\r\n        lastTime = currentTime;\r\n    }\r\n}"
}, {
	"Path": "hprose.server.HproseTcpServer.getThreadPool",
	"Comment": "get the thread pool.this thread pool is not for the service threads, it is for the user service method.the default value is null.",
	"Method": "ExecutorService getThreadPool(){\r\n    return threadPool;\r\n}"
}, {
	"Path": "rocks.inspectit.server.dao.impl.TimerDataAggregatorTest.noMaxElementsReached",
	"Comment": "tests that if we place many time same amount of elements, maximum will not be reached.",
	"Method": "void noMaxElementsReached(){\r\n    aggregator.maxElements = 2;\r\n    TimerData timerData1 = new TimerData(new Timestamp(System.currentTimeMillis()), 10L, 20L, 30L);\r\n    TimerData timerData2 = new TimerData(new Timestamp(System.currentTimeMillis()), 100L, 200L, 300L);\r\n    for (int i = 0; i < 100; i++) {\r\n        aggregator.processTimerData(timerData1);\r\n        aggregator.processTimerData(timerData2);\r\n    }\r\n    assertThat(aggregator.getElementCount(), is(2));\r\n    verifyZeroInteractions(entityManager);\r\n}"
}, {
	"Path": "org.kohsuke.github.GHCreateRepositoryBuilder.allowMergeCommit",
	"Comment": "allow or disallow merging pull requests with a merge commit.",
	"Method": "GHCreateRepositoryBuilder allowMergeCommit(boolean b){\r\n    this.builder.with(\"allow_merge_commit\", b);\r\n    return this;\r\n}"
}, {
	"Path": "com.firebase.geofire.testing.GeoFireTestingRule.setValueAndWait",
	"Comment": "sets the value on the given databasereference and waits until the operation has successfully finished.",
	"Method": "void setValueAndWait(DatabaseReference databaseReference,Object value){\r\n    final SimpleFuture<DatabaseError> futureError = new SimpleFuture<DatabaseError>();\r\n    databaseReference.setValue(value, new DatabaseReference.CompletionListener() {\r\n        @Override\r\n        public void onComplete(DatabaseError databaseError, DatabaseReference databaseReference) {\r\n            futureError.put(databaseError);\r\n        }\r\n    });\r\n    try {\r\n        assertNull(futureError.get(timeout, TimeUnit.SECONDS));\r\n    } catch (InterruptedException e) {\r\n        throw new RuntimeException(e);\r\n    } catch (TimeoutException e) {\r\n        fail(\"Timeout occured!\");\r\n    }\r\n}"
}, {
	"Path": "com.firebase.geofire.testing.GeoFireTestingRule.setValueAndWait",
	"Comment": "sets the value on the given databasereference and waits until the operation has successfully finished.",
	"Method": "void setValueAndWait(DatabaseReference databaseReference,Object value){\r\n    futureError.put(databaseError);\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.proxy.impl.ASMProxyBuilder.loadClass",
	"Comment": "taken from the asm faq. loads the given bytecode as class using the given classloader.",
	"Method": "Class<?> loadClass(byte[] b,String className,ClassLoader loader){\r\n    Class<?> clazz = null;\r\n    try {\r\n        Class<?> cls = Class.forName(\"java.lang.ClassLoader\");\r\n        java.lang.reflect.Method method = cls.getDeclaredMethod(\"defineClass\", new Class[] { String.class, byte[].class, int.class, int.class });\r\n        method.setAccessible(true);\r\n        Object[] args = new Object[] { className, b, Integer.valueOf(0), Integer.valueOf(b.length) };\r\n        clazz = (Class<?>) method.invoke(loader, args);\r\n    } catch (Exception e) {\r\n        try {\r\n            Class.forName(className, false, loader);\r\n            Log.error(\"PROXY CREATION ERROR: class is already present in classloader!\");\r\n        } catch (ClassNotFoundException e1) {\r\n            StringWriter logWriter = new StringWriter();\r\n            CheckClassAdapter.verify(new ClassReader(b), loader, false, new PrintWriter(logWriter));\r\n            Log.error(\"BYTECODE checking result : \\r\\n\" + logWriter.toString());\r\n        }\r\n        throw new RuntimeException(e);\r\n    }\r\n    return clazz;\r\n}"
}, {
	"Path": "com.alorma.github.ui.view.CircularImageView.setSelectorStrokeWidth",
	"Comment": "sets the stroke width to be drawn around the circularimageviewduring click events when the selector is enabled.",
	"Method": "void setSelectorStrokeWidth(int selectorStrokeWidth){\r\n    this.selectorStrokeWidth = selectorStrokeWidth;\r\n    this.requestLayout();\r\n    this.invalidate();\r\n}"
}, {
	"Path": "com.firebase.geofire.testing.GeoFireTestingRule.waitForGeoFireReady",
	"Comment": "this lets you blockingly wait until the ongeofireready was fired on the provided geofire instance.",
	"Method": "void waitForGeoFireReady(GeoFire geoFire){\r\n    final Semaphore semaphore = new Semaphore(0);\r\n    geoFire.getDatabaseReference().addListenerForSingleValueEvent(new ValueEventListener() {\r\n        @Override\r\n        public void onDataChange(DataSnapshot dataSnapshot) {\r\n            semaphore.release();\r\n        }\r\n        @Override\r\n        public void onCancelled(DatabaseError databaseError) {\r\n            fail(\"Firebase error: \" + databaseError);\r\n        }\r\n    });\r\n    assertTrue(\"Timeout occured!\", semaphore.tryAcquire(timeout, TimeUnit.SECONDS));\r\n}"
}, {
	"Path": "com.firebase.geofire.testing.GeoFireTestingRule.waitForGeoFireReady",
	"Comment": "this lets you blockingly wait until the ongeofireready was fired on the provided geofire instance.",
	"Method": "void waitForGeoFireReady(GeoFire geoFire){\r\n    semaphore.release();\r\n}"
}, {
	"Path": "com.firebase.geofire.testing.GeoFireTestingRule.waitForGeoFireReady",
	"Comment": "this lets you blockingly wait until the ongeofireready was fired on the provided geofire instance.",
	"Method": "void waitForGeoFireReady(GeoFire geoFire){\r\n    fail(\"Firebase error: \" + databaseError);\r\n}"
}, {
	"Path": "org.hibernate.validator.test.internal.engine.methodvalidation.RelaxedMethodParameterConstraintsTest.allowParameterConstraintsAddedInSubType",
	"Comment": "the converse of disallowparameterconstraintsaddedinsubtype,\trelaxes constraint.",
	"Method": "void allowParameterConstraintsAddedInSubType(){\r\n    HibernateValidatorConfiguration configuration = Validation.byProvider(HibernateValidator.class).configure();\r\n    configuration.allowOverridingMethodAlterParameterConstraint(true);\r\n    ValidatorFactory factory = configuration.buildValidatorFactory();\r\n    Validator validator = factory.getValidator();\r\n    Set<? extends ConstraintViolation<?>> violations = validator.forExecutables().validateParameters(new RealizationWithMethodParameterConstraint(), RealizationWithMethodParameterConstraint.class.getDeclaredMethods()[0], new Object[] { \"foo\" });\r\n    ConstraintViolationAssert.assertNoViolations(violations);\r\n    configuration.allowOverridingMethodAlterParameterConstraint(false);\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageManager.getStorageQueuedWriteTaskCount",
	"Comment": "returns the amount of writing tasks storage still has to process. note that this is an\tapproximate number.",
	"Method": "long getStorageQueuedWriteTaskCount(StorageData storageData){\r\n    try {\r\n        StorageData local = getLocalStorageDataObject(storageData);\r\n        if (!isStorageOpen(local)) {\r\n            return 0;\r\n        }\r\n        StorageWriter storageWriter = openedStoragesMap.get(local);\r\n        if (null == storageWriter) {\r\n            return 0;\r\n        } else {\r\n            return storageWriter.getQueuedTaskCount();\r\n        }\r\n    } catch (BusinessException e) {\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.service.ExceptionDataAccessService.postConstruct",
	"Comment": "is executed after dependency injection is done to perform any initialization.",
	"Method": "void postConstruct(){\r\n    if (log.isInfoEnabled()) {\r\n        log.info(\"|-Exception Sensor Data Access Service active...\");\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.instrumentation.asm.SpecialMethodInstrumenter.generateAfterBodyCall",
	"Comment": "generates code for the after body call. this method expects the result of the method call on\tthe stack that can be consumed.",
	"Method": "void generateAfterBodyCall(){\r\n    loadHookDispatcher();\r\n    swap();\r\n    push(methodId);\r\n    dup2X1();\r\n    pop2();\r\n    if (isStatic) {\r\n        pushNull();\r\n    } else {\r\n        loadThis();\r\n    }\r\n    swap();\r\n    loadArgArray();\r\n    swap();\r\n    mv.visitMethodInsn(Opcodes.INVOKEINTERFACE, IInstrumenterConstant.IHOOK_DISPATCHER_INTERNAL_NAME, \"dispatchSpecialMethodAfterBody\", IInstrumenterConstant.DISPATCH_SPECIAL_METHOD_AFTER_BODY_DESCRIPTOR, true);\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.steer.behaviors.FollowPath.getInternalTargetPosition",
	"Comment": "returns the current position of the internal target. this method is useful for debug purpose.",
	"Method": "T getInternalTargetPosition(){\r\n    return internalTargetPosition;\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.classchecks.MethodInheritanceTree.hasOverriddenMethods",
	"Comment": "checks if there are any overridden methods in the hierarchy.",
	"Method": "boolean hasOverriddenMethods(){\r\n    return overriddenMethods.size() > 0;\r\n}"
}, {
	"Path": "rocks.inspectit.agent.java.sensor.method.http.HttpInformationExtractor.getAttributes",
	"Comment": "reads all request attributes from the given httpservletrequest object and stores\tthem with the given httptimerdata object.",
	"Method": "Map<String, String> getAttributes(Class<?> httpServletRequestClass,Object httpServletRequest){\r\n    Method attributesMethod = retrieveMethod(HttpMethods.SERVLET_GET_ATTRIBUTE_NAMES, httpServletRequestClass);\r\n    if (null == attributesMethod) {\r\n        return null;\r\n    }\r\n    Method attributeValue = retrieveMethod(HttpMethods.SERVLET_GET_ATTRIBUTE, httpServletRequestClass);\r\n    if (null == attributeValue) {\r\n        return null;\r\n    }\r\n    try {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Enumeration<String> params = (Enumeration<String>) attributesMethod.invoke(httpServletRequest, (Object[]) null);\r\n        Map<String, String> attributes = new HashMap<String, String>();\r\n        if (null == params) {\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"Attribute enumeration was <null>\");\r\n            }\r\n            return null;\r\n        }\r\n        while (params.hasMoreElements()) {\r\n            String attrName = params.nextElement();\r\n            Object value = attributeValue.invoke(httpServletRequest, new Object[] { attrName });\r\n            attributes.put(attrName, strConstraint.crop(getAttributeValue(value)));\r\n        }\r\n        return attributes;\r\n    } catch (Exception e) {\r\n        LOG.error(\"Invocation of \" + attributesMethod.getName() + \" to get attributes on given object failed.\", e);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.CmrStorageRecorderTest.noProcessing",
	"Comment": "tests that no data will be processed if recording is off and storage writer is turned off.",
	"Method": "void noProcessing(){\r\n    cmrStorageRecorder = spy(cmrStorageRecorder);\r\n    when(recordingProperties.getRecordingDataProcessors()).thenReturn(Collections.singleton(dataProcessor));\r\n    cmrStorageRecorder.startOrScheduleRecording(storageWriter, recordingProperties);\r\n    DefaultData defaultData = mock(DefaultData.class);\r\n    when(cmrStorageRecorder.isRecordingOn()).thenReturn(false);\r\n    cmrStorageRecorder.record(defaultData);\r\n    when(cmrStorageRecorder.isRecordingOn()).thenReturn(true);\r\n    when(storageWriter.isWritingOn()).thenReturn(false);\r\n    cmrStorageRecorder.record(defaultData);\r\n    verify(dataProcessor, times(0)).process(defaultData);\r\n}"
}, {
	"Path": "com.github.mobile.util.HtmlUtils.rewriteRelativeUrls",
	"Comment": "rewrite relative urls in html fetched e.g. from markdown files.",
	"Method": "String rewriteRelativeUrls(String html,String repoUser,String repoName,String branch){\r\n    final String baseUrl = \"https://raw.github.com/\" + repoUser + \"/\" + repoName + \"/\" + branch;\r\n    final StringBuffer sb = new StringBuffer();\r\n    final Pattern p = Pattern.compile(\"(href|src)=\\\"(\\\\S+)\\\"\");\r\n    final Matcher m = p.matcher(html);\r\n    while (m.find()) {\r\n        String url = m.group(2);\r\n        if (!url.contains(\"://\") && !url.startsWith(\"#\")) {\r\n            if (url.startsWith(\"/\")) {\r\n                url = baseUrl + url;\r\n            } else {\r\n                url = baseUrl + \"/\" + url;\r\n            }\r\n        }\r\n        m.appendReplacement(sb, Matcher.quoteReplacement(m.group(1) + \"=\\\"\" + url + \"\\\"\"));\r\n    }\r\n    m.appendTail(sb);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.alorma.gitskarios.core.Pair.create",
	"Comment": "convenience method for creating an appropriately typed pair.",
	"Method": "Pair<A, B> create(A a,B b){\r\n    return new Pair<A, B>(a, b);\r\n}"
}, {
	"Path": "com.hypertrack.hyperlog.HyperLog.getDeviceLogBatchCount",
	"Comment": "call this method to get number of device logs batches. each batch contains the 5000 devicelogs.",
	"Method": "int getDeviceLogBatchCount(){\r\n    if (!isInitialize())\r\n        return 0;\r\n    return mDeviceLogList.getDeviceLogBatchCount();\r\n}"
}, {
	"Path": "com.badlogic.gdx.ai.fma.FormationMotionModerator.calculateDriftOffset",
	"Comment": "calculates the drift offset when members are in the given set of slots for the specified pattern.",
	"Method": "Location<T> calculateDriftOffset(Location<T> centerOfMass,Array<SlotAssignment<T>> slotAssignments,FormationPattern<T> pattern){\r\n    centerOfMass.getPosition().setZero();\r\n    float centerOfMassOrientation = 0;\r\n    if (tempLocation == null)\r\n        tempLocation = centerOfMass.newLocation();\r\n    T centerOfMassPos = centerOfMass.getPosition();\r\n    T tempLocationPos = tempLocation.getPosition();\r\n    float numberOfAssignments = slotAssignments.size;\r\n    for (int i = 0; i < numberOfAssignments; i++) {\r\n        pattern.calculateSlotLocation(tempLocation, slotAssignments.get(i).slotNumber);\r\n        centerOfMassPos.add(tempLocationPos);\r\n        centerOfMassOrientation += tempLocation.getOrientation();\r\n    }\r\n    centerOfMassPos.scl(1f / numberOfAssignments);\r\n    centerOfMassOrientation /= numberOfAssignments;\r\n    centerOfMass.setOrientation(centerOfMassOrientation);\r\n    return centerOfMass;\r\n}"
}, {
	"Path": "org.hibernate.validator.ap.internal.util.MessagerAdapter.reportWarning",
	"Comment": "reports the given warning. message parameters will be put into the template\tretrieved from the resource bundle if applicable.",
	"Method": "void reportWarning(ConstraintCheckIssue warning){\r\n    report(warning, Kind.WARNING);\r\n}"
}, {
	"Path": "rocks.inspectit.server.spring.exporter.KryoNetRmiServiceExporter.prepare",
	"Comment": "prepares the server and register the service for remote usage.",
	"Method": "void prepare(){\r\n    if (null == service) {\r\n        throw new BeanInitializationException(\"The service to export with the kryonet RMI must not be null.\");\r\n    }\r\n    objectSpace.register(serviceId, service);\r\n    log.info(\"|-Service \" + serviceInterface + \" exported and available via kryonet RMI with the ID \" + serviceId);\r\n}"
}, {
	"Path": "rocks.inspectit.server.storage.StorageIntegrationTest.readUsingNioStream",
	"Comment": "tests reading of data from created storage using the nio streams.",
	"Method": "void readUsingNioStream(){\r\n    if (storageIndexingTree == null) {\r\n        return;\r\n    }\r\n    StorageIndexQuery query = new StorageIndexQuery();\r\n    List<Class<?>> searchedClasses = new ArrayList();\r\n    searchedClasses.add(InvocationSequenceData.class);\r\n    query.setObjectClasses(searchedClasses);\r\n    List<IStorageDescriptor> descriptors = storageIndexingTree.query(query);\r\n    assertThat(\"Amount of descriptors is less than the amount of invocations saved.\", descriptors.size(), is(equalTo(createdInvocations.size())));\r\n    for (IStorageDescriptor descriptor : descriptors) {\r\n        assertThat(\"position of descriptor is negative.\", descriptor.getPosition(), is(greaterThanOrEqualTo(0L)));\r\n        assertThat(\"Size of the descriptor is wrong.\", descriptor.getSize(), is(greaterThan(0L)));\r\n    }\r\n    Set<Path> allPaths = new HashSet();\r\n    for (IStorageDescriptor desc : descriptors) {\r\n        Path absolutePath = storageManager.getChannelPath(storageData, desc.getChannelId()).toAbsolutePath();\r\n        allPaths.add(absolutePath);\r\n    }\r\n    int count = 0;\r\n    for (Path path : allPaths) {\r\n        try (InputStream result = Files.newInputStream(path, StandardOpenOption.READ)) {\r\n            Input input = new Input(result);\r\n            while (KryoUtil.hasMoreBytes(input)) {\r\n                Object invocation = serializer.deserialize(input);\r\n                assertThat(invocation, is(instanceOf(InvocationSequenceData.class)));\r\n                assertThat(createdInvocations, hasItem((InvocationSequenceData) invocation));\r\n                count++;\r\n            }\r\n        }\r\n    }\r\n    assertThat(\"Amount of de-serialize objects is less than the amount of invocations saved.\", count, is(equalTo(createdInvocations.size())));\r\n}"
}, {
	"Path": "rocks.inspectit.server.dao.impl.TimerDataAggregatorTest.saveAllInPersistList",
	"Comment": "tests that persist list saving includes correct elements being saved.",
	"Method": "void saveAllInPersistList(){\r\n    aggregator.maxElements = 1;\r\n    TimerData timerData1 = new TimerData(new Timestamp(System.currentTimeMillis()), 10L, 20L, 30L);\r\n    TimerData timerData2 = new TimerData(new Timestamp(System.currentTimeMillis()), 100L, 200L, 300L);\r\n    aggregator.processTimerData(timerData1);\r\n    aggregator.processTimerData(timerData2);\r\n    aggregator.saveAllInPersistList();\r\n    ArgumentCaptor<DatabaseAggregatedTimerData> argument = ArgumentCaptor.forClass(DatabaseAggregatedTimerData.class);\r\n    verify(entityManager, times(1)).persist(argument.capture());\r\n    assertThat(argument.getValue(), is(instanceOf(DatabaseAggregatedTimerData.class)));\r\n    assertThat(argument.getValue().getPlatformIdent(), is(timerData1.getPlatformIdent()));\r\n    assertThat(argument.getValue().getSensorTypeIdent(), is(timerData1.getSensorTypeIdent()));\r\n    assertThat(argument.getValue().getMethodIdent(), is(timerData1.getMethodIdent()));\r\n}"
}, {
	"Path": "rocks.inspectit.server.instrumentation.classcache.ClassCache.informNodeChange",
	"Comment": "inform the registered listeners about changes to the class node structure.\tnote that this method is synchronized. as it is ensured that only one thread can actively\tchange the structure this synchronization does not really hinder us. but is provides an\tadditional level of safety as the indexers can assume that they are only called single\tthreaded for sure.",
	"Method": "void informNodeChange(NodeEvent e){\r\n    for (INodeChangeListener listener : nodeChangeListeners) {\r\n        listener.informNodeChange(e);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.cache.impl.AtomicBuffer.getInsertedElemenets",
	"Comment": "returns the number of inserted elements since the buffer has been created.",
	"Method": "long getInsertedElemenets(){\r\n    return elementsAdded.get();\r\n}"
}]