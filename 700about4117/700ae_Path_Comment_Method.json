[{
	"Path": "rocks.inspectit.server.diagnosis.service.ProblemOccurrenceResultCollector.getRootCauseInvocations",
	"Comment": "returns the aggregatedinvocationsequencedata of rootcauseinvocations tag.",
	"Method": "Optional<AggregatedDiagnosisData> getRootCauseInvocations(Tag leafTag){\r\n    while (null != leafTag) {\r\n        if (leafTag.getType().equals(RuleConstants.DIAGNOSIS_TAG_PROBLEM_CAUSE)) {\r\n            if (leafTag.getValue() instanceof AggregatedDiagnosisData) {\r\n                return Optional.of((AggregatedDiagnosisData) leafTag.getValue());\r\n            } else {\r\n                throw new RuntimeException(\"Problem cause has wrong datatype!\");\r\n            }\r\n        }\r\n        leafTag = leafTag.getParent();\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "org.apache.isis.core.integtestsupport.scenarios.ScenarioExecutionForIntegration.install",
	"Comment": "install arbitrary fixtures, eg before an integration tests or as part of a cucumber step definitions or hook.",
	"Method": "void install(InstallableFixture fixtures){\r\n    isft.installFixtures(fixtures);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.storage.http.TransferDataMonitor.getFileSize",
	"Comment": "returns the size of the file based on if the current download is compressed or not.",
	"Method": "long getFileSize(long originalFileSize){\r\n    if (gzipCompression && (originalFileSize > MIN_GZIP_FILE_SIZE)) {\r\n        return (long) (originalFileSize * GZIP_FILE_SIZE_RATIO);\r\n    } else {\r\n        return originalFileSize;\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.core.specsupport.scenarios.InMemoryDB.getNoCreate",
	"Comment": "returns the object if exists, but will not instantiate a new one if not present.",
	"Method": "T getNoCreate(Class<T> cls,String id){\r\n    Class type = cls;\r\n    while (type != null) {\r\n        final InMemoryDB.EntityId entityId = new EntityId(cls, id);\r\n        final Object object = objectsById.get(entityId);\r\n        if (object != null) {\r\n            return (T) object;\r\n        }\r\n        type = type.getSuperclass();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.nio.CustomAsyncChannel.reserveWritingPosition",
	"Comment": "reserves the writing position in this channel with the given size. this method is thread\tsafe.",
	"Method": "long reserveWritingPosition(long writeSize){\r\n    while (true) {\r\n        long writingPosition = nextWritingPosition.get();\r\n        if (nextWritingPosition.compareAndSet(writingPosition, writingPosition + writeSize)) {\r\n            return writingPosition;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.wizard.page.AlertDetailsWizardPage.initContents",
	"Comment": "initializes the contents of all fields if there are initial values.",
	"Method": "void initContents(){\r\n    if (null != initialThreshold) {\r\n        thresholdBox.setText(String.valueOf(initialThreshold));\r\n    }\r\n    lowerThresholdCheckBox.setSelection(initialLowerThreshold);\r\n    timerangeSpinner.setSelection((int) initialTimerange);\r\n    if (null != initialsEmails) {\r\n        String emailsText = \"\";\r\n        for (String email : initialsEmails) {\r\n            if (!emailsText.isEmpty()) {\r\n                emailsText += NEW_LINE;\r\n            }\r\n            emailsText += email;\r\n        }\r\n        emailsBox.setText(emailsText);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.EUMSettingsPart.updateEnabledState",
	"Comment": "disables or enabled the controls depending on wheterh eum is enalbed or not.",
	"Method": "void updateEnabledState(){\r\n    boolean en = eumEnabledButton.getSelection();\r\n    modulesTable.setEnabled(en);\r\n    scriptBaseUrl.setEnabled(en);\r\n    listenerInstrumentationAllowedButton.setEnabled(en);\r\n    minificationEnabledButton.setEnabled(en);\r\n    relevancyThresholdMS.setEnabled(en);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.instrumentation.config.impl.PropertyPathStart.setSignaturePosition",
	"Comment": "sets the position of the parameter in the signature to read.",
	"Method": "void setSignaturePosition(int signaturePosition){\r\n    this.signaturePosition = signaturePosition;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.InvocationAwareDataTest.complicatedDifferentParentsAggregation",
	"Comment": "tests the complicated aggregation when objects are in different invocations.",
	"Method": "void complicatedDifferentParentsAggregation(){\r\n    InvocationAwareData i1 = getInvocationAwareData();\r\n    i1.addInvocationParentId(Long.valueOf(1));\r\n    InvocationAwareData i2 = getInvocationAwareData();\r\n    i2.addInvocationParentId(Long.valueOf(2));\r\n    i1.aggregateInvocationAwareData(i2);\r\n    InvocationAwareData i3 = getInvocationAwareData();\r\n    i3.addInvocationParentId(Long.valueOf(3));\r\n    InvocationAwareData i4 = getInvocationAwareData();\r\n    i4.addInvocationParentId(Long.valueOf(4));\r\n    i3.aggregateInvocationAwareData(i4);\r\n    i1.aggregateInvocationAwareData(i3);\r\n    assertThat(i1.getObjectsInInvocationsCount(), is(equalTo(4)));\r\n    assertThat(i1.getInvocationParentsIdSet().size(), is(equalTo(4)));\r\n    assertThat(i1.getInvocationParentsIdSet(), contains(1L, 2L, 3L, 4L));\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Date.startOfWeek",
	"Comment": "calculates, and returns, a date representing the first day of the weekrelative to the current date.",
	"Method": "Date startOfWeek(){\r\n    return new Date(date.dayOfWeek().withMinimumValue());\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.impl.StorageIndexingTest.emptyQueryTest",
	"Comment": "test tree with empty query. all elements should be returned.",
	"Method": "void emptyQueryTest(){\r\n    IStorageTreeComponent<DefaultData> rootBranch = new StorageBranch(new StorageBranchIndexer(new ObjectTypeIndexer(), false));\r\n    DefaultData defaultData = mock(DefaultData.class);\r\n    when(defaultData.getId()).thenReturn(1L);\r\n    IStorageDescriptor storageDescriptor1 = rootBranch.put(defaultData);\r\n    storageDescriptor1.setPositionAndSize(0, 1);\r\n    SqlStatementData defaultData2 = mock(SqlStatementData.class);\r\n    when(defaultData2.getId()).thenReturn(2L);\r\n    IStorageDescriptor storageDescriptor2 = rootBranch.put(defaultData2);\r\n    storageDescriptor2.setPositionAndSize(2, 1);\r\n    List<IStorageDescriptor> results = rootBranch.query(storageIndexQuery);\r\n    assertThat(results.size(), is(equalTo(2)));\r\n    List<IStorageDescriptor> resultsForkJoin = rootBranch.query(storageIndexQuery, forkJoinPool);\r\n    assertThat(resultsForkJoin.size(), is(equalTo(2)));\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.view.util.SelectionProviderIntermediate.setSelectionProviderDelegate",
	"Comment": "sets a new selection provider to delegate to. selection listeners registered with the\tprevious delegate are removed before.",
	"Method": "void setSelectionProviderDelegate(ISelectionProvider newDelegate){\r\n    if (delegate == newDelegate) {\r\n        return;\r\n    }\r\n    if (delegate != null) {\r\n        delegate.removeSelectionChangedListener(selectionListener);\r\n        if (delegate instanceof IPostSelectionProvider) {\r\n            ((IPostSelectionProvider) delegate).removePostSelectionChangedListener(postSelectionListener);\r\n        }\r\n    }\r\n    delegate = newDelegate;\r\n    if (newDelegate != null) {\r\n        newDelegate.addSelectionChangedListener(selectionListener);\r\n        if (newDelegate instanceof IPostSelectionProvider) {\r\n            ((IPostSelectionProvider) newDelegate).addPostSelectionChangedListener(postSelectionListener);\r\n        }\r\n        fireSelectionChanged(newDelegate.getSelection());\r\n        firePostSelectionChanged(newDelegate.getSelection());\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.ui.pages.entity.EntityPage.createEntityModel",
	"Comment": "creates an entitymodel from the given page parameters.redirects to the application home page if there is no oid in the parameters.",
	"Method": "EntityModel createEntityModel(PageParameters parameters){\r\n    String oid = EntityModel.oidStr(parameters);\r\n    if (Strings.isEmpty(oid)) {\r\n        throw new RestartResponseException(Application.get().getHomePage());\r\n    }\r\n    return new EntityModel(parameters);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.storage.impl.StorageBranchIndexerTest.newInstance",
	"Comment": "test that new instance is correctly created based on the delegate indexer settings.",
	"Method": "void newInstance(){\r\n    when(delegateIndexer.sharedInstance()).thenReturn(true);\r\n    IStorageBranchIndexer<DefaultData> instance = storageBranchIndexer.getNewInstance();\r\n    verify(delegateIndexer, times(0)).getNewInstance();\r\n    assertThat(instance, is(instanceOf(StorageBranchIndexer.class)));\r\n    assertThat(((StorageBranchIndexer<DefaultData>) instance).getDelegateIndexer(), is(delegateIndexer));\r\n    when(delegateIndexer.sharedInstance()).thenReturn(false);\r\n    instance = storageBranchIndexer.getNewInstance();\r\n    verify(delegateIndexer, times(1)).getNewInstance();\r\n    assertThat(instance, is(instanceOf(StorageBranchIndexer.class)));\r\n    assertThat(((StorageBranchIndexer<DefaultData>) instance).getDelegateIndexer(), is(not(delegateIndexer)));\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.StorageManager.unzipStorageData",
	"Comment": "unzips the content of the zip file provided to the default storage folder.",
	"Method": "void unzipStorageData(Path zipFilePath,Path destinationPath){\r\n    if (Files.notExists(zipFilePath)) {\r\n        throw new BusinessException(\"Unpack the storage file with path \" + zipFilePath + \".\", StorageErrorCodeEnum.FILE_DOES_NOT_EXIST);\r\n    }\r\n    Files.createDirectories(destinationPath);\r\n    try (ZipFile zipFile = new ZipFile(zipFilePath.toFile())) {\r\n        Enumeration<? extends ZipEntry> entries = zipFile.entries();\r\n        while (entries.hasMoreElements()) {\r\n            ZipEntry zipEntry = entries.nextElement();\r\n            Path path = destinationPath.resolve(Paths.get(zipEntry.getName()));\r\n            if (Files.isDirectory(path)) {\r\n                Files.createDirectories(path);\r\n            } else {\r\n                Path parent = path.getParent();\r\n                if (null != parent) {\r\n                    if (Files.notExists(parent)) {\r\n                        Files.createDirectories(parent);\r\n                    }\r\n                }\r\n                boolean isGzip = false;\r\n                try (InputStream is = zipFile.getInputStream(zipEntry)) {\r\n                    isGzip = isGzipCompressedData(is);\r\n                }\r\n                try (InputStream is = zipFile.getInputStream(zipEntry)) {\r\n                    if (isGzip) {\r\n                        try (GZIPInputStream gis = new GZIPInputStream(is)) {\r\n                            Files.copy(gis, path, StandardCopyOption.REPLACE_EXISTING);\r\n                        }\r\n                    } else {\r\n                        Files.copy(is, path, StandardCopyOption.REPLACE_EXISTING);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.rmi.ObjectSpace.addConnection",
	"Comment": "allows the remote end of the specified connection to access objects registered in this\tobjectspace.",
	"Method": "void addConnection(Connection connection){\r\n    if (connection == null) {\r\n        throw new IllegalArgumentException(\"connection cannot be null.\");\r\n    }\r\n    synchronized (connectionsLock) {\r\n        Connection[] newConnections = new Connection[connections.length + 1];\r\n        newConnections[0] = connection;\r\n        System.arraycopy(connections, 0, newConnections, 1, connections.length);\r\n        connections = newConnections;\r\n    }\r\n    connection.addListener(invokeListener);\r\n    if (TRACE) {\r\n        trace(\"kryonet\", \"Added connection to ObjectSpace: \" + connection);\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.applib.layout.menubars.bootstrap3.BS3Menu.isUnreferencedActions",
	"Comment": "whether this menu should be used to hold any unreferenced actions.any menubars layout must have precisely one menu that has this attribute set.",
	"Method": "Boolean isUnreferencedActions(){\r\n    return unreferencedActions;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.storage.nio.stream.SocketExtendedByteBufferInputStream.reset",
	"Comment": "resets the input stream so that new read from the channel can be executed with wanted length.\tthis method makes stream reusable. caller must ensure that all the bytes from previous read\thave been read, otherwise they will be lost.",
	"Method": "void reset(int length){\r\n    while (!getFullBuffers().isEmpty()) {\r\n        ByteBuffer byteBuffer = getFullBuffers().poll();\r\n        if (null != byteBuffer) {\r\n            byteBuffer.clear();\r\n            getEmptyBuffers().add(byteBuffer);\r\n        }\r\n    }\r\n    setTotalSize(length);\r\n    setPosition(0);\r\n    executorService.execute(new SocketReadRunnable(length));\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.communication.data.InvocationSequenceDataHelper.hasNestedSqlStatements",
	"Comment": "checks whether this data object has nested sql statements.",
	"Method": "boolean hasNestedSqlStatements(InvocationSequenceData data){\r\n    return (null != data.isNestedSqlStatements()) && data.isNestedSqlStatements().booleanValue();\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.preferences.StringToPrimitiveTransformUtil.transformStringCollection",
	"Comment": "transforms all the strings in the original collection to the given class objects and adds\tthem to the given resulting collection.",
	"Method": "void transformStringCollection(Collection<String> original,Collection<E> collection,Class<E> elementClass){\r\n    Method parseMethod = findParseMethod(elementClass);\r\n    if (null != parseMethod) {\r\n        for (String toTransform : original) {\r\n            try {\r\n                Object transformed = parseMethod.invoke(null, toTransform);\r\n                if (elementClass.isAssignableFrom(transformed.getClass())) {\r\n                    collection.add((E) transformed);\r\n                }\r\n            } catch (Exception e) {\r\n                throw new PreferenceException(\"Error transforming Collection<java.lang.String> to Collection<\" + elementClass.getName() + \">.\", e);\r\n            }\r\n        }\r\n    } else {\r\n        throw new PreferenceException(\"Error transforming Collection<java.lang.String> to Collection<\" + elementClass.getName() + \">. Parsing method can not be found in class \" + elementClass.getName() + \".\");\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.actions.interaction.ActionNamedExplorationFacetFactory.attachNamedFacetInferredFromMethodName",
	"Comment": "must be called after added the debug, exploration etc facets.",
	"Method": "void attachNamedFacetInferredFromMethodName(ProcessMethodContext processMethodContext){\r\n    final Method method = processMethodContext.getMethod();\r\n    final String capitalizedName = StringExtensions.asCapitalizedName(method.getName());\r\n    String name = capitalizedName;\r\n    name = StringExtensions.removePrefix(name, EXPLORATION_PREFIX);\r\n    name = StringExtensions.asNaturalName2(name);\r\n    final FacetHolder facetedMethod = processMethodContext.getFacetHolder();\r\n    FacetUtil.addFacet(new NamedFacetInferred(name, facetedMethod));\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.TextFormatter.getMethodWithParameters",
	"Comment": "returns a method string which is appended by the parameters.",
	"Method": "String getMethodWithParameters(MethodIdent methodIdent,String getMethodWithParameters,MethodSensorAssignment methodSensorAssignment){\r\n    if ((null == methodSensorAssignment.getMethodName()) && !methodSensorAssignment.isConstructor()) {\r\n        return \"\";\r\n    }\r\n    StringBuilder builder = new StringBuilder();\r\n    if (methodSensorAssignment.isConstructor()) {\r\n        builder.append(\"<init>\");\r\n    } else {\r\n        builder.append(methodSensorAssignment.getMethodName());\r\n    }\r\n    if (null != methodSensorAssignment.getParameters()) {\r\n        if (methodSensorAssignment.getParameters().isEmpty()) {\r\n            builder.append(\"()\");\r\n        } else {\r\n            String parameterText = methodSensorAssignment.getParameters().toString();\r\n            parameterText = parameterText.substring(1, parameterText.length() - 1);\r\n            builder.append('(');\r\n            builder.append(parameterText);\r\n            builder.append(')');\r\n        }\r\n    }\r\n    return builder.toString();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.TimerData.getExclusiveAverage",
	"Comment": "returns the average exclusive time calculated as exclusive duration % count.",
	"Method": "double getExclusiveAverage(){\r\n    return exclusiveDuration / exclusiveCount;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.data.invocationtree.InvocationTreeBuilder.loadInvocationSequences",
	"Comment": "loads all invocation sequences which are related to the set trace.",
	"Method": "List<InvocationSequenceData> loadInvocationSequences(){\r\n    if (invocationService == null) {\r\n        return Collections.emptyList();\r\n    }\r\n    return new ArrayList(invocationService.getInvocationSequenceDetail(traceId));\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.Modifier.isAnnotation",
	"Comment": "returns true if the modifiers include the annotation modifier.",
	"Method": "boolean isAnnotation(int mod){\r\n    return (mod & ANNOTATION) != 0;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.job.CheckNewVersionJob.getHighestVersionFromJson",
	"Comment": "returns the highest available version release from the github jsonarray.",
	"Method": "VersionRelease getHighestVersionFromJson(JsonArray jsonArray){\r\n    Version highest = new Version(0, 0, 0);\r\n    VersionRelease versionRelease = new VersionRelease(highest);\r\n    for (int i = 0, size = jsonArray.size(); i < size; i++) {\r\n        JsonObject element = (JsonObject) jsonArray.get(i);\r\n        String versionTag = element.get(\"tag_name\").getAsString();\r\n        Version version = Version.verifyAndCreate(versionTag);\r\n        if (version.compareTo(highest) > 0) {\r\n            highest = version;\r\n            versionRelease = new VersionRelease(version);\r\n            boolean preRelease = element.get(\"prerelease\").getAsBoolean();\r\n            versionRelease.setPreRelease(preRelease);\r\n            String htmlLink = element.get(\"html_url\").getAsString();\r\n            versionRelease.setLink(htmlLink);\r\n        }\r\n    }\r\n    return versionRelease;\r\n}"
}, {
	"Path": "org.apache.isis.viewer.restfulobjects.applib.JsonRepresentation.ensureArray",
	"Comment": "a reciprocal of the behaviour of the automatic dereferencing of arraysthat occurs when there is only a single instance.",
	"Method": "JsonRepresentation ensureArray(){\r\n    if (jsonNode.isArray()) {\r\n        return this;\r\n    }\r\n    final JsonRepresentation arrayRepr = JsonRepresentation.newArray();\r\n    arrayRepr.arrayAdd(jsonNode);\r\n    return arrayRepr;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.repository.CmrRepositoryManager.repositoryAgentDeleted",
	"Comment": "informs all listener that the provided agent on the repository has been deleted.",
	"Method": "void repositoryAgentDeleted(CmrRepositoryDefinition cmrRepositoryDefinition,PlatformIdent agent){\r\n    for (CmrRepositoryChangeListener listener : cmrRepositoryChangeListeners) {\r\n        listener.repositoryAgentDeleted(cmrRepositoryDefinition, agent);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.label.management.impl.LabelManagementActionsTest.emptyAddAction",
	"Comment": "no exceptions and no interactions with storage service with empty action.",
	"Method": "void emptyAddAction(){\r\n    addLabelManagementAction = new AddLabelManagementAction();\r\n    verifyNoMoreInteractions(storageService);\r\n}"
}, {
	"Path": "org.apache.isis.applib.services.publish.EventMetadata.getUser",
	"Comment": "represents the user that was responsible for generating the event.",
	"Method": "String getUser(){\r\n    return user;\r\n}"
}, {
	"Path": "org.apache.isis.core.commons.exceptions.ExceptionUtils.isNestedThrowable",
	"Comment": "checks whether this throwable class can store a cause.this method does not check whether it actually does store a cause.",
	"Method": "boolean isNestedThrowable(Throwable throwable){\r\n    if (throwable == null) {\r\n        return false;\r\n    }\r\n    if (throwable instanceof SQLException) {\r\n        return true;\r\n    } else if (throwable instanceof InvocationTargetException) {\r\n        return true;\r\n    } else if (isThrowableNested()) {\r\n        return true;\r\n    }\r\n    Class cls = throwable.getClass();\r\n    for (final String causeMethodName : CAUSE_METHOD_NAMES) {\r\n        try {\r\n            Method method = cls.getMethod(causeMethodName, null);\r\n            if (method != null && Throwable.class.isAssignableFrom(method.getReturnType())) {\r\n                return true;\r\n            }\r\n        } catch (NoSuchMethodException | SecurityException ignored) {\r\n        }\r\n    }\r\n    try {\r\n        Field field = cls.getField(\"detail\");\r\n        if (field != null) {\r\n            return true;\r\n        }\r\n    } catch (NoSuchFieldException | SecurityException ignored) {\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.github.jamm.MemoryMeter.ignoreNonStrongReferences",
	"Comment": "return a memorymeter that ignores space occupied by known singletons such as class objects and enums",
	"Method": "MemoryMeter ignoreNonStrongReferences(){\r\n    return new MemoryMeter(trackerProvider, includeFullBufferSize, guess, ignoreOuterClassReference, ignoreKnownSingletons, true, listenerFactory);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.NumberFormatter.formatDouble",
	"Comment": "formats a double value based on the number of decimal places.",
	"Method": "String formatDouble(double number,String formatDouble,double number,int decimalPlaces){\r\n    doubleUnspecificFormat.setMaximumFractionDigits(decimalPlaces);\r\n    doubleUnspecificFormat.setMinimumFractionDigits(decimalPlaces);\r\n    return doubleUnspecificFormat.format(number);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.wizard.page.AddStorageLabelWizardPage.isLabelTypePresent",
	"Comment": "returns if the label type is present in the storage or in the list of labels to add.",
	"Method": "boolean isLabelTypePresent(AbstractStorageLabelType<?> selectedLabelType){\r\n    if (storageData.isLabelPresent(selectedLabelType)) {\r\n        return true;\r\n    }\r\n    for (AbstractStorageLabel<?> label : labelsToAdd) {\r\n        if (ObjectUtils.equals(selectedLabelType, label.getStorageLabelType())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.storage.util.DataRetriever.getCachedDataLocally",
	"Comment": "returns cached data for the given hash locally. this method can be used when storage if fully\tdownloaded.",
	"Method": "List<E> getCachedDataLocally(LocalStorageData localStorageData,int hash){\r\n    Path path = storageManager.getCachedDataPath(localStorageData, hash);\r\n    if (Files.notExists(path)) {\r\n        return null;\r\n    } else {\r\n        ISerializer serializer = null;\r\n        try {\r\n            serializer = serializerQueue.take();\r\n        } catch (InterruptedException e) {\r\n            Thread.interrupted();\r\n        }\r\n        Input input = null;\r\n        try (InputStream inputStream = Files.newInputStream(path, StandardOpenOption.READ)) {\r\n            input = new Input(inputStream);\r\n            Object object = serializer.deserialize(input);\r\n            List<E> receivedData = (List<E>) object;\r\n            return receivedData;\r\n        } finally {\r\n            if (null != input) {\r\n                input.close();\r\n            }\r\n            serializerQueue.add(serializer);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Date.sameYearAs",
	"Comment": "determines if this date and the specified date represent the same year.",
	"Method": "boolean sameYearAs(Date as){\r\n    return sameAs(as, DateTimeFieldType.year());\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.service.rules.impl.ProblemContextRule.getCauseCluster",
	"Comment": "in case there is just one cause invocation then the parent of the problem context is the\tcause invocation, otherwise a new instance of causecluster will be created with the only\tinvocation in the list.",
	"Method": "CauseCluster getCauseCluster(InvocationSequenceData causeInvocation){\r\n    if ((causeInvocation.getParentSequence() != null) && !(causeInvocation.equals(globalContext))) {\r\n        CauseCluster causeCluster = new CauseCluster(causeInvocation.getParentSequence());\r\n        causeCluster.getCauseInvocations().clear();\r\n        causeCluster.getCauseInvocations().add(causeInvocation);\r\n        return causeCluster;\r\n    } else {\r\n        return new CauseCluster(causeInvocation);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.nio.CustomAsyncChannel.closeChannel",
	"Comment": "closes the channel. note that no write will be possible after calling this method.",
	"Method": "boolean closeChannel(){\r\n    openCloseLock.lock();\r\n    try {\r\n        if (this.isOpened()) {\r\n            fileChannel.force(true);\r\n            fileChannel.close();\r\n            if (log.isDebugEnabled()) {\r\n                log.info(\"Channel closed for path \" + path + \". Next write position is \" + nextWritingPosition.get() + \".\");\r\n            }\r\n            return true;\r\n        } else {\r\n            if (log.isDebugEnabled()) {\r\n                log.info(\"Tried to close already closed channel for path \" + path + \".\");\r\n            }\r\n            return false;\r\n        }\r\n    } finally {\r\n        openCloseLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Date.sameDayOfWeekAs",
	"Comment": "determines if this date and the specified date represent the same day ofthe week, eg both dates are on a tuesday.",
	"Method": "boolean sameDayOfWeekAs(Date as){\r\n    return sameAs(as, DateTimeFieldType.dayOfWeek());\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.model.models.EntityModel.equals",
	"Comment": "in order that isisajaxfallbackdatatable can use areuseifmodelsequalstrategy to preserve any concurrency exceptioninformation in original model.",
	"Method": "boolean equals(Object obj){\r\n    if (this == obj)\r\n        return true;\r\n    if (obj == null)\r\n        return false;\r\n    if (getClass() != obj.getClass())\r\n        return false;\r\n    EntityModel other = (EntityModel) obj;\r\n    if (adapterMemento == null) {\r\n        if (other.adapterMemento != null)\r\n            return false;\r\n    } else if (!adapterMemento.equals(other.adapterMemento))\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.isis.core.runtime.snapshot.XmlSchema.setTargetNamespace",
	"Comment": "sets the target namespace for the xsd document to a uri derived from thefully qualified class name of the supplied object",
	"Method": "void setTargetNamespace(Document xsdDoc,String fullyQualifiedClassName){\r\n    final Element xsSchemaElement = xsdDoc.getDocumentElement();\r\n    if (xsSchemaElement == null) {\r\n        throw new IllegalArgumentException(\"XSD Document must have <xs:schema> element attached\");\r\n    }\r\n    xsSchemaElement.setAttribute(\"targetNamespace\", getUri());\r\n    addNamespace(xsSchemaElement, getPrefix(), getUri());\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.AgentMappingPart.checkEnvironments",
	"Comment": "checks if there is environments in the cmr and thus updates the part based on the state.",
	"Method": "void checkEnvironments(){\r\n    if (CollectionUtils.isEmpty(environments)) {\r\n        tableViewer.getTable().setEnabled(false);\r\n        addButton.setEnabled(false);\r\n        managedForm.getForm().setMessage(\"No environment exists on the selected CMR, mapping can not be defined.\", IMessageProvider.ERROR);\r\n    } else {\r\n        tableViewer.getTable().setEnabled(true);\r\n        addButton.setEnabled(true);\r\n        managedForm.getForm().setMessage(\"Define agent mapping properties for the '\" + cmrRepositoryDefinition.getName() + \"' repository. Pay attention to the order of the agent mappings!\", IMessageProvider.NONE);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.wizard.page.ImportStorageInfoPage.update",
	"Comment": "updates the page content by loading the storage information from file.",
	"Method": "void update(){\r\n    reset();\r\n    Job updateImportStoragePage = new Job(\"Update Import Storage Info Page\") {\r\n        @Override\r\n        protected IStatus run(IProgressMonitor monitor) {\r\n            boolean callServices = !importLocally && (cmrRepositoryDefinition.getOnlineStatus() != OnlineStatus.OFFLINE);\r\n            final List<StorageData> existingStorages = callServices ? cmrRepositoryDefinition.getStorageService().getExistingStorages() : Collections.<StorageData>emptyList();\r\n            final long spaceLeftOnCmr = callServices ? cmrRepositoryDefinition.getCmrManagementService().getCmrStatusData().getStorageDataSpaceLeft() : 0;\r\n            SafeExecutor.asyncExec(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    if (null == fileName) {\r\n                        canImport = false;\r\n                    } else {\r\n                        file.setText(fileName);\r\n                        if (importLocally) {\r\n                            importTo.setText(\"Import locally\");\r\n                        } else {\r\n                            importTo.setText(cmrRepositoryDefinition.getName());\r\n                        }\r\n                        InspectITStorageManager storageManager = InspectIT.getDefault().getInspectITStorageManager();\r\n                        IStorageData storageData = storageManager.getStorageDataFromZip(fileName);\r\n                        if (null != storageData) {\r\n                            storageInfoComposite.displayStorageData(storageData);\r\n                            if (importLocally) {\r\n                                boolean notImportedYet = true;\r\n                                for (LocalStorageData localStorageData : storageManager.getDownloadedStorages()) {\r\n                                    if (ObjectUtils.equals(localStorageData.getId(), storageData.getId())) {\r\n                                        notImportedYet = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                if (notImportedYet) {\r\n                                    canImport = true;\r\n                                    setMessage(DEFAULT_MESSAGE);\r\n                                } else {\r\n                                    canImport = false;\r\n                                    setMessage(\"Selected storage to import is already available locally\", ERROR);\r\n                                }\r\n                            } else if (cmrRepositoryDefinition.getOnlineStatus() != OnlineStatus.OFFLINE) {\r\n                                boolean notImportedYet = true;\r\n                                for (StorageData storageDataOnRepository : existingStorages) {\r\n                                    if (ObjectUtils.equals(storageDataOnRepository.getId(), storageData.getId())) {\r\n                                        notImportedYet = false;\r\n                                        break;\r\n                                    }\r\n                                }\r\n                                boolean enoughSpace = spaceLeftOnCmr > storageData.getDiskSize();\r\n                                if (notImportedYet && enoughSpace) {\r\n                                    canImport = true;\r\n                                    String cmrVersion = cmrRepositoryDefinition.getVersion();\r\n                                    if (null == storageData.getCmrVersion()) {\r\n                                        setMessage(\"Selected storage does not define CMR version. The storage might be unstable on the CMR version \" + cmrVersion + \".\", WARNING);\r\n                                    } else if (!ObjectUtils.equals(storageData.getCmrVersion(), cmrVersion)) {\r\n                                        setMessage(\"Selected storage has different CMR version than the current CMR version \" + cmrVersion + \". The storage might be unstable.\", WARNING);\r\n                                    } else {\r\n                                        setMessage(DEFAULT_MESSAGE);\r\n                                    }\r\n                                } else if (!notImportedYet) {\r\n                                    canImport = false;\r\n                                    setMessage(\"Selected storage to import is already available on selected CMR\", ERROR);\r\n                                } else if (!enoughSpace) {\r\n                                    canImport = false;\r\n                                    setMessage(\"Insufficient storage space of the selected repository (\" + NumberFormatter.humanReadableByteCount(spaceLeftOnCmr) + \" left)\", ERROR);\r\n                                }\r\n                            } else {\r\n                                canImport = false;\r\n                                setMessage(\"Can not import storage to selected CMR because the CMR is offline\", ERROR);\r\n                            }\r\n                        } else {\r\n                            storageInfoComposite.showDataUnavailable();\r\n                            canImport = false;\r\n                            setMessage(\"Provided file is not valid inspectIT compressed storage file\", ERROR);\r\n                        }\r\n                        main.layout();\r\n                        main.update();\r\n                    }\r\n                    setPageComplete(isPageComplete());\r\n                }\r\n            }, file, importTo, storageInfoComposite, main);\r\n            return Status.OK_STATUS;\r\n        }\r\n    };\r\n    updateImportStoragePage.schedule();\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.wizard.page.ImportStorageInfoPage.update",
	"Comment": "updates the page content by loading the storage information from file.",
	"Method": "void update(){\r\n    boolean callServices = !importLocally && (cmrRepositoryDefinition.getOnlineStatus() != OnlineStatus.OFFLINE);\r\n    final List<StorageData> existingStorages = callServices ? cmrRepositoryDefinition.getStorageService().getExistingStorages() : Collections.<StorageData>emptyList();\r\n    final long spaceLeftOnCmr = callServices ? cmrRepositoryDefinition.getCmrManagementService().getCmrStatusData().getStorageDataSpaceLeft() : 0;\r\n    SafeExecutor.asyncExec(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            if (null == fileName) {\r\n                canImport = false;\r\n            } else {\r\n                file.setText(fileName);\r\n                if (importLocally) {\r\n                    importTo.setText(\"Import locally\");\r\n                } else {\r\n                    importTo.setText(cmrRepositoryDefinition.getName());\r\n                }\r\n                InspectITStorageManager storageManager = InspectIT.getDefault().getInspectITStorageManager();\r\n                IStorageData storageData = storageManager.getStorageDataFromZip(fileName);\r\n                if (null != storageData) {\r\n                    storageInfoComposite.displayStorageData(storageData);\r\n                    if (importLocally) {\r\n                        boolean notImportedYet = true;\r\n                        for (LocalStorageData localStorageData : storageManager.getDownloadedStorages()) {\r\n                            if (ObjectUtils.equals(localStorageData.getId(), storageData.getId())) {\r\n                                notImportedYet = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                        if (notImportedYet) {\r\n                            canImport = true;\r\n                            setMessage(DEFAULT_MESSAGE);\r\n                        } else {\r\n                            canImport = false;\r\n                            setMessage(\"Selected storage to import is already available locally\", ERROR);\r\n                        }\r\n                    } else if (cmrRepositoryDefinition.getOnlineStatus() != OnlineStatus.OFFLINE) {\r\n                        boolean notImportedYet = true;\r\n                        for (StorageData storageDataOnRepository : existingStorages) {\r\n                            if (ObjectUtils.equals(storageDataOnRepository.getId(), storageData.getId())) {\r\n                                notImportedYet = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                        boolean enoughSpace = spaceLeftOnCmr > storageData.getDiskSize();\r\n                        if (notImportedYet && enoughSpace) {\r\n                            canImport = true;\r\n                            String cmrVersion = cmrRepositoryDefinition.getVersion();\r\n                            if (null == storageData.getCmrVersion()) {\r\n                                setMessage(\"Selected storage does not define CMR version. The storage might be unstable on the CMR version \" + cmrVersion + \".\", WARNING);\r\n                            } else if (!ObjectUtils.equals(storageData.getCmrVersion(), cmrVersion)) {\r\n                                setMessage(\"Selected storage has different CMR version than the current CMR version \" + cmrVersion + \". The storage might be unstable.\", WARNING);\r\n                            } else {\r\n                                setMessage(DEFAULT_MESSAGE);\r\n                            }\r\n                        } else if (!notImportedYet) {\r\n                            canImport = false;\r\n                            setMessage(\"Selected storage to import is already available on selected CMR\", ERROR);\r\n                        } else if (!enoughSpace) {\r\n                            canImport = false;\r\n                            setMessage(\"Insufficient storage space of the selected repository (\" + NumberFormatter.humanReadableByteCount(spaceLeftOnCmr) + \" left)\", ERROR);\r\n                        }\r\n                    } else {\r\n                        canImport = false;\r\n                        setMessage(\"Can not import storage to selected CMR because the CMR is offline\", ERROR);\r\n                    }\r\n                } else {\r\n                    storageInfoComposite.showDataUnavailable();\r\n                    canImport = false;\r\n                    setMessage(\"Provided file is not valid inspectIT compressed storage file\", ERROR);\r\n                }\r\n                main.layout();\r\n                main.update();\r\n            }\r\n            setPageComplete(isPageComplete());\r\n        }\r\n    }, file, importTo, storageInfoComposite, main);\r\n    return Status.OK_STATUS;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.wizard.page.ImportStorageInfoPage.update",
	"Comment": "updates the page content by loading the storage information from file.",
	"Method": "void update(){\r\n    if (null == fileName) {\r\n        canImport = false;\r\n    } else {\r\n        file.setText(fileName);\r\n        if (importLocally) {\r\n            importTo.setText(\"Import locally\");\r\n        } else {\r\n            importTo.setText(cmrRepositoryDefinition.getName());\r\n        }\r\n        InspectITStorageManager storageManager = InspectIT.getDefault().getInspectITStorageManager();\r\n        IStorageData storageData = storageManager.getStorageDataFromZip(fileName);\r\n        if (null != storageData) {\r\n            storageInfoComposite.displayStorageData(storageData);\r\n            if (importLocally) {\r\n                boolean notImportedYet = true;\r\n                for (LocalStorageData localStorageData : storageManager.getDownloadedStorages()) {\r\n                    if (ObjectUtils.equals(localStorageData.getId(), storageData.getId())) {\r\n                        notImportedYet = false;\r\n                        break;\r\n                    }\r\n                }\r\n                if (notImportedYet) {\r\n                    canImport = true;\r\n                    setMessage(DEFAULT_MESSAGE);\r\n                } else {\r\n                    canImport = false;\r\n                    setMessage(\"Selected storage to import is already available locally\", ERROR);\r\n                }\r\n            } else if (cmrRepositoryDefinition.getOnlineStatus() != OnlineStatus.OFFLINE) {\r\n                boolean notImportedYet = true;\r\n                for (StorageData storageDataOnRepository : existingStorages) {\r\n                    if (ObjectUtils.equals(storageDataOnRepository.getId(), storageData.getId())) {\r\n                        notImportedYet = false;\r\n                        break;\r\n                    }\r\n                }\r\n                boolean enoughSpace = spaceLeftOnCmr > storageData.getDiskSize();\r\n                if (notImportedYet && enoughSpace) {\r\n                    canImport = true;\r\n                    String cmrVersion = cmrRepositoryDefinition.getVersion();\r\n                    if (null == storageData.getCmrVersion()) {\r\n                        setMessage(\"Selected storage does not define CMR version. The storage might be unstable on the CMR version \" + cmrVersion + \".\", WARNING);\r\n                    } else if (!ObjectUtils.equals(storageData.getCmrVersion(), cmrVersion)) {\r\n                        setMessage(\"Selected storage has different CMR version than the current CMR version \" + cmrVersion + \". The storage might be unstable.\", WARNING);\r\n                    } else {\r\n                        setMessage(DEFAULT_MESSAGE);\r\n                    }\r\n                } else if (!notImportedYet) {\r\n                    canImport = false;\r\n                    setMessage(\"Selected storage to import is already available on selected CMR\", ERROR);\r\n                } else if (!enoughSpace) {\r\n                    canImport = false;\r\n                    setMessage(\"Insufficient storage space of the selected repository (\" + NumberFormatter.humanReadableByteCount(spaceLeftOnCmr) + \" left)\", ERROR);\r\n                }\r\n            } else {\r\n                canImport = false;\r\n                setMessage(\"Can not import storage to selected CMR because the CMR is offline\", ERROR);\r\n            }\r\n        } else {\r\n            storageInfoComposite.showDataUnavailable();\r\n            canImport = false;\r\n            setMessage(\"Provided file is not valid inspectIT compressed storage file\", ERROR);\r\n        }\r\n        main.layout();\r\n        main.update();\r\n    }\r\n    setPageComplete(isPageComplete());\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.details.DetailsTable.heightHint",
	"Comment": "returns the height hint for the text that should fit into specified maximum width. if the\tcalculated height hint is higher than the given max height, then max height is returned.",
	"Method": "int heightHint(String text,int maxWidth,int maxHeight){\r\n    Point fontPoint = gc.textExtent(text);\r\n    int rows = (fontPoint.x / (maxWidth - 50)) + 1;\r\n    return Math.min(rows * fontPoint.y, maxHeight);\r\n}"
}, {
	"Path": "org.apache.isis.applib.layout.component.ServiceActionLayoutData.getOwner",
	"Comment": "owner.set programmatically by framework after reading in from xml.",
	"Method": "ServiceActionLayoutDataOwner getOwner(){\r\n    return owner;\r\n}"
}, {
	"Path": "org.apache.isis.applib.security.UserMemento.hasRole",
	"Comment": "determines if the user fulfills the specified role. roles are comparedlexically by role name.",
	"Method": "boolean hasRole(RoleMemento role,boolean hasRole,String roleName){\r\n    for (final RoleMemento role : roles) {\r\n        if (role.getName().matches(roleName)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.AgentFolderFactory.getAgentDisplayNameInFolder",
	"Comment": "returns what should be the name of the agent if the agent is located in a folder.",
	"Method": "String getAgentDisplayNameInFolder(String agentName){\r\n    String[] splitted = getSplittedAgentName(agentName);\r\n    return splitted[splitted.length - 1];\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.Modifier.toString",
	"Comment": "return a string describing the access modifier flags in the specified modifier.",
	"Method": "String toString(int mod){\r\n    return java.lang.reflect.Modifier.toString(mod);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.ci.business.expression.impl.NameExtractionExpression.compileRegexPattern",
	"Comment": "compiles the regular expression if it has not been compiled yet.",
	"Method": "void compileRegexPattern(){\r\n    if (null == regex) {\r\n        regex = Pattern.compile(getRegularExpression());\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.aggregation.impl.AggregationPerformer.reset",
	"Comment": "resets the current results of the aggregations so that the new clean aggregation can start.",
	"Method": "void reset(){\r\n    aggregationMap.clear();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.StorageData.isLabelPresent",
	"Comment": "return if the label of provided type is present in the label list.",
	"Method": "boolean isLabelPresent(AbstractStorageLabelType<?> labelType){\r\n    for (AbstractStorageLabel<?> label : labelList) {\r\n        if (label.getStorageLabelType().equals(labelType)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.redhat.developer.demos.recommendation.DarkLaunchIT.waitUntilIstioResourcesArePopulated",
	"Comment": "istio resources takes some time until all envoy proxies of the cluster receives the update.in case of local installations might take one second in case of real clusters some tenths of seconds.",
	"Method": "void waitUntilIstioResourcesArePopulated(){\r\n    istioAssistant.await(createRequestForRecommendationV2(), response -> {\r\n        try {\r\n            return response.body().string().contains(\"v2\");\r\n        } catch (IOException e) {\r\n            return false;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.apache.isis.applib.events.InteractionEvent.getReasonMessage",
	"Comment": "the reason message, if any, that this interaction may have been vetoed orotherwise disallowed.this message should be overridden by subclasses for containing the reason, the identifier and any other relevant context information.",
	"Method": "String getReasonMessage(){\r\n    if (this.getIdentifier() != null) {\r\n        return String.format(\"Reason: %s. Identifier: %s\", this.getReason(), this.getIdentifier());\r\n    } else {\r\n        return String.format(\"Reason: %s\", this.getReason());\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.applib.events.CollectionMethodEvent.getMethodName",
	"Comment": "the name of the method invoked on this collection, for exampleisempty.",
	"Method": "String getMethodName(){\r\n    return methodName;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.storage.nio.ByteBufferProviderTest.relaseAfterMin",
	"Comment": "tests that a buffer will not be returned to the queue after a release when the available\tcapacity is above or equal to min capacity.",
	"Method": "void relaseAfterMin(){\r\n    byteBufferProvider.setBufferSize(1);\r\n    byteBufferProvider.setPoolMaxCapacity(3);\r\n    byteBufferProvider.setPoolMinCapacity(1);\r\n    byteBufferProvider.init();\r\n    ByteBuffer buffer1 = byteBufferProvider.acquireByteBuffer();\r\n    ByteBuffer buffer2 = byteBufferProvider.acquireByteBuffer();\r\n    assertThat(byteBufferProvider.getCreatedCapacity(), is(equalTo(2L)));\r\n    assertThat(byteBufferProvider.getAvailableCapacity(), is(equalTo(0L)));\r\n    byteBufferProvider.releaseByteBuffer(buffer1);\r\n    byteBufferProvider.releaseByteBuffer(buffer2);\r\n    assertThat(byteBufferProvider.getCreatedCapacity(), is(equalTo(1L)));\r\n    assertThat(byteBufferProvider.getAvailableCapacity(), is(equalTo(1L)));\r\n    assertThat(byteBufferProvider.getBufferPoolSize(), is(equalTo(1)));\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.ui.components.scalars.ScalarPanelSelect2Abstract.updateChoices",
	"Comment": "hook method to refresh choices when changing.called from onupdate callback",
	"Method": "boolean updateChoices(ObjectAdapter[] argsIfAvailable){\r\n    if (select2 == null) {\r\n        return false;\r\n    }\r\n    setProviderAndCurrAndPending(select2, argsIfAvailable);\r\n    return true;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.handlers.ShowHideColumnsHandler.isColumnHidden",
	"Comment": "returns if the cache has any knowledge if the column is hidden.",
	"Method": "boolean isColumnHidden(Class<?> controllerClass,String columnName){\r\n    return hiddenColumnsCache.contains(getColumnHash(controllerClass, columnName));\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.storage.nio.ByteBufferProvider.updatePoolProperties",
	"Comment": "updates the buffer capacity, min & max idle buffers based on the current properties.\tthis is an automated properties update execution method.",
	"Method": "void updatePoolProperties(){\r\n    long maxDirectMemory = 64 * 1024 * 1024;\r\n    try {\r\n        Class<?> vmClazz = Class.forName(\"sun.misc.VM\");\r\n        Method directMemoryMethod = vmClazz.getMethod(\"maxDirectMemory\");\r\n        directMemoryMethod.setAccessible(true);\r\n        maxDirectMemory = (Long) directMemoryMethod.invoke(null);\r\n        log.debug(\"Direct memory available for the JVM {}\", maxDirectMemory);\r\n    } catch (Exception e) {\r\n        if (log.isDebugEnabled()) {\r\n            log.debug(\"Exception occurred trying to use the class sun.misc.VM via reflection\", e);\r\n        }\r\n    }\r\n    if (poolMinCapacity > (long) (maxDirectMemory * bufferPoolMinDirectMemoryOccupancy)) {\r\n        poolMinCapacity = (long) (maxDirectMemory * bufferPoolMinDirectMemoryOccupancy);\r\n    }\r\n    if (poolMaxCapacity > (long) (maxDirectMemory * bufferPoolMaxDirectMemoryOccupancy)) {\r\n        poolMaxCapacity = (long) (maxDirectMemory * bufferPoolMaxDirectMemoryOccupancy);\r\n    }\r\n    poolFactory.setBufferCapacity(bufferSize);\r\n    int maxIdle = (int) (poolMinCapacity / bufferSize);\r\n    int maxActive = (int) (poolMaxCapacity / bufferSize);\r\n    super.setMaxIdle(maxIdle);\r\n    super.setMaxActive(maxActive);\r\n    log.info(\"|-Updated byte buffer pool capacity, maxIdle={} and maxActive={}\", maxIdle, maxActive);\r\n    log.info(\"|-Default byte buffer size set to {}\", bufferSize);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.Client.update",
	"Comment": "reads or writes any pending data for this client. multiple threads should not call this\tmethod at the same time.",
	"Method": "void update(int timeout){\r\n    updateThread = Thread.currentThread();\r\n    synchronized (updateLock) {\r\n    }\r\n    long startTime = System.currentTimeMillis();\r\n    int select = selector.selectNow();\r\n    long waitUntil = System.nanoTime() + TimeUnit.MILLISECONDS.toNanos(timeout);\r\n    while ((select == 0) && (System.nanoTime() < waitUntil)) {\r\n        LockSupport.parkNanos(100000);\r\n        select = selector.selectNow();\r\n    }\r\n    if (select == 0) {\r\n        emptySelects++;\r\n        if (emptySelects == 100) {\r\n            emptySelects = 0;\r\n            long elapsedTime = System.currentTimeMillis() - startTime;\r\n            try {\r\n                if (elapsedTime < 25) {\r\n                    Thread.sleep(25 - elapsedTime);\r\n                }\r\n            } catch (InterruptedException ex) {\r\n            }\r\n        }\r\n    } else {\r\n        emptySelects = 0;\r\n        isClosed = false;\r\n        Set<SelectionKey> keys = selector.selectedKeys();\r\n        synchronized (keys) {\r\n            for (Iterator<SelectionKey> iter = keys.iterator(); iter.hasNext(); ) {\r\n                SelectionKey selectionKey = iter.next();\r\n                iter.remove();\r\n                try {\r\n                    int ops = selectionKey.readyOps();\r\n                    if ((ops & SelectionKey.OP_READ) == SelectionKey.OP_READ) {\r\n                        if (selectionKey.attachment() == tcp) {\r\n                            while (true) {\r\n                                Object object = tcp.readObject(this);\r\n                                if (object == null) {\r\n                                    break;\r\n                                }\r\n                                if (!tcpRegistered) {\r\n                                    if (object instanceof RegisterTCP) {\r\n                                        id = ((RegisterTCP) object).connectionID;\r\n                                        synchronized (tcpRegistrationLock) {\r\n                                            tcpRegistered = true;\r\n                                            tcpRegistrationLock.notifyAll();\r\n                                            if (TRACE) {\r\n                                                trace(\"kryonet\", this + \" received TCP: RegisterTCP\");\r\n                                            }\r\n                                            if (udp == null) {\r\n                                                setConnected(true);\r\n                                            }\r\n                                        }\r\n                                        if (udp == null) {\r\n                                            notifyConnected();\r\n                                        }\r\n                                    }\r\n                                    continue;\r\n                                }\r\n                                if ((udp != null) && !udpRegistered) {\r\n                                    if (object instanceof RegisterUDP) {\r\n                                        synchronized (udpRegistrationLock) {\r\n                                            udpRegistered = true;\r\n                                            udpRegistrationLock.notifyAll();\r\n                                            if (TRACE) {\r\n                                                trace(\"kryonet\", this + \" received UDP: RegisterUDP\");\r\n                                            }\r\n                                            if (DEBUG) {\r\n                                                debug(\"kryonet\", \"Port \" + udp.datagramChannel.socket().getLocalPort() + \"/UDP connected to: \" + udp.connectedAddress);\r\n                                            }\r\n                                            setConnected(true);\r\n                                        }\r\n                                        notifyConnected();\r\n                                    }\r\n                                    continue;\r\n                                }\r\n                                if (!isConnected) {\r\n                                    continue;\r\n                                }\r\n                                keepAlive();\r\n                                if (DEBUG) {\r\n                                    String objectString = object == null ? \"null\" : object.getClass().getSimpleName();\r\n                                    if (!(object instanceof FrameworkMessage)) {\r\n                                        debug(\"kryonet\", this + \" received TCP: \" + objectString);\r\n                                    } else if (TRACE) {\r\n                                        trace(\"kryonet\", this + \" received TCP: \" + objectString);\r\n                                    }\r\n                                }\r\n                                notifyReceived(object);\r\n                            }\r\n                        } else {\r\n                            if (udp.readFromAddress() == null) {\r\n                                continue;\r\n                            }\r\n                            Object object = udp.readObject(this);\r\n                            if (object == null) {\r\n                                continue;\r\n                            }\r\n                            keepAlive();\r\n                            if (DEBUG) {\r\n                                String objectString = object == null ? \"null\" : object.getClass().getSimpleName();\r\n                                debug(\"kryonet\", this + \" received UDP: \" + objectString);\r\n                            }\r\n                            notifyReceived(object);\r\n                        }\r\n                    }\r\n                    if ((ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {\r\n                        tcp.writeOperation();\r\n                    }\r\n                } catch (CancelledKeyException ignored) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (isConnected) {\r\n        long time = System.currentTimeMillis();\r\n        if (tcp.isTimedOut(time)) {\r\n            if (DEBUG) {\r\n                debug(\"kryonet\", this + \" timed out.\");\r\n            }\r\n            close();\r\n        } else {\r\n            keepAlive();\r\n        }\r\n        if (isIdle()) {\r\n            notifyIdle();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.ImageFormatter.getSpanImage",
	"Comment": "returns span image based on propagation and reference type.",
	"Method": "Image getSpanImage(Span span,ResourceManager resourceManager){\r\n    Image propagationImage = getPropagationImage(span.getPropagationType());\r\n    if (!span.isCaller() && !References.FOLLOWS_FROM.equals(span.getReferenceType())) {\r\n        return propagationImage;\r\n    } else {\r\n        return getOverlayedImage(propagationImage, resourceManager, 1, getReferenceImage(span.getReferenceType()));\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.TextFormatter.getSpanDetailsShort",
	"Comment": "helper method to generate span details out of some available information.",
	"Method": "StyledString getSpanDetailsShort(Span span,ICachedDataService cachedDataService,StyledString getSpanDetailsShort,PropagationType propagationType,long methodId,Map<String, String> tags,ICachedDataService cachedDataService){\r\n    StyledString styledString = new StyledString();\r\n    boolean isError = MapUtils.getBoolean(tags, Tags.ERROR.getKey(), false);\r\n    if (isError) {\r\n        styledString.append('[', StyledString.DECORATIONS_STYLER);\r\n        styledString.append(\"Err\", ERROR_STYLED);\r\n        styledString.append(\"] \", StyledString.DECORATIONS_STYLER);\r\n    }\r\n    if (null != propagationType) {\r\n        switch(propagationType) {\r\n            case HTTP:\r\n                if (!isError) {\r\n                    styledString.append('[', StyledString.DECORATIONS_STYLER);\r\n                    String status = tags.get(Tags.HTTP_STATUS.getKey());\r\n                    styledString.append(getHttpStatusStyledString(status));\r\n                    styledString.append(\"] \", StyledString.DECORATIONS_STYLER);\r\n                }\r\n                styledString.append(StringUtils.defaultString(tags.get(Tags.HTTP_URL.getKey())));\r\n                return styledString;\r\n            case JMS:\r\n                String destination = tags.get(ExtraTags.JMS_MESSAGE_DESTINATION);\r\n                if (StringUtils.isNotEmpty(destination)) {\r\n                    styledString.append(destination);\r\n                    return styledString;\r\n                }\r\n            default:\r\n        }\r\n    }\r\n    String op = tags.get(ExtraTags.OPERATION_NAME);\r\n    if (StringUtils.isNotEmpty(op)) {\r\n        styledString.append(op);\r\n        return styledString;\r\n    }\r\n    String runnableType = tags.get(ExtraTags.RUNNABLE_TYPE);\r\n    if (StringUtils.isNotEmpty(runnableType)) {\r\n        styledString.append(getFqnAbbreviated(runnableType));\r\n        return styledString;\r\n    }\r\n    MethodIdent methodIdent = cachedDataService.getMethodIdentForId(methodId);\r\n    if (null != methodIdent) {\r\n        styledString.append(methodIdent.getMethodName() + \"() - \" + getFqnAbbreviated(methodIdent.getFQN()));\r\n    }\r\n    return styledString;\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Date.startOfYear",
	"Comment": "calculates, and returns, a date representing the first day of the yearrelative to the current date.",
	"Method": "Date startOfYear(){\r\n    return new Date(date.dayOfYear().withMinimumValue());\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.InvocationSequenceData.getClonedInvocationSequence",
	"Comment": "clones invocation sequence. this method returns new object exactly same as the original\tobject, but with out nested sequences set.",
	"Method": "InvocationSequenceData getClonedInvocationSequence(){\r\n    InvocationSequenceData clone = new InvocationSequenceData(this.getTimeStamp(), this.getPlatformIdent(), this.getSensorTypeIdent(), this.getMethodIdent());\r\n    clone.setId(this.getId());\r\n    clone.setSpanIdent(this.getSpanIdent());\r\n    clone.setChildCount(this.getChildCount());\r\n    clone.setDuration(this.getDuration());\r\n    clone.setEnd(this.getEnd());\r\n    clone.setNestedSequences(Collections.<InvocationSequenceData>emptyList());\r\n    clone.setParameterContentData(this.getParameterContentData());\r\n    clone.setParentSequence(this.getParentSequence());\r\n    clone.setPosition(this.getPosition());\r\n    clone.setSqlStatementData(this.getSqlStatementData());\r\n    clone.setTimerData(this.getTimerData());\r\n    clone.setExceptionSensorDataObjects(this.getExceptionSensorDataObjects());\r\n    clone.setStart(this.getStart());\r\n    clone.setNestedSqlStatements(this.isNestedSqlStatements());\r\n    clone.setNestedExceptions(this.isNestedExceptions());\r\n    clone.setLoggingData(this.getLoggingData());\r\n    clone.setApplicationId(this.getApplicationId());\r\n    clone.setBusinessTransactionId(this.getBusinessTransactionId());\r\n    return clone;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.SensorAssignmentMasterBlock.createNewTabItem",
	"Comment": "creates new tab item with the list of assignments to be used as input.",
	"Method": "void createNewTabItem(Class<? extends ISensorConfig> sensorClass,List<AbstractClassSensorAssignment<?>> assignments){\r\n    if ((null != emptyHintComposite) && !emptyHintComposite.isDisposed()) {\r\n        tabFolder.getItem(0).dispose();\r\n        emptyHintComposite.dispose();\r\n    }\r\n    SensorAssignmentTableProvider tableProvider = new SensorAssignmentTableProvider(this, tabFolder);\r\n    tableProvider.setInput(assignments);\r\n    CTabItem tabItem = new CTabItem(tabFolder, SWT.NONE);\r\n    tabItem.setControl(tableProvider.getTableViewer().getTable());\r\n    tabItem.setText(TextFormatter.getSensorConfigName(sensorClass));\r\n    tabItem.setImage(ImageFormatter.getSensorConfigImage(sensorClass));\r\n    sensorToTabMap.put(sensorClass, tabItem);\r\n    TableViewer tableViewer = tableProvider.getTableViewer();\r\n    tableViewer.getTable().setData(sensorClass);\r\n    tableViewers.add(tableViewer);\r\n    tableViewer.getTable().addKeyListener(new KeyAdapter() {\r\n        @Override\r\n        public void keyPressed(KeyEvent e) {\r\n            if (e.keyCode == SWT.DEL) {\r\n                fireRemove();\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.SensorAssignmentMasterBlock.createNewTabItem",
	"Comment": "creates new tab item with the list of assignments to be used as input.",
	"Method": "void createNewTabItem(Class<? extends ISensorConfig> sensorClass,List<AbstractClassSensorAssignment<?>> assignments){\r\n    if (e.keyCode == SWT.DEL) {\r\n        fireRemove();\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.instrumentation.classcache.Modifiers.mergeModifiers",
	"Comment": "merges two modifiers. this is a simple or operation on the given modifiers.",
	"Method": "int mergeModifiers(int m1,int m2){\r\n    return m1 | m2;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.details.DetailsGenerationFactory.createDetailComposites",
	"Comment": "creates list of detail composites displaying different types of the information for the given\tdefault data.",
	"Method": "List<DetailsTable> createDetailComposites(DefaultData defaultData,RepositoryDefinition repositoryDefinition,Composite parent,FormToolkit toolkit){\r\n    DefaultData secondary = null;\r\n    if (defaultData instanceof InvocationSequenceData) {\r\n        InvocationSequenceData invocationSequenceData = (InvocationSequenceData) defaultData;\r\n        if (null != invocationSequenceData.getTimerData()) {\r\n            secondary = invocationSequenceData.getTimerData();\r\n        }\r\n        if (null != invocationSequenceData.getSqlStatementData()) {\r\n            secondary = invocationSequenceData.getSqlStatementData();\r\n        }\r\n        if (CollectionUtils.isNotEmpty(invocationSequenceData.getExceptionSensorDataObjects())) {\r\n            secondary = invocationSequenceData.getExceptionSensorDataObjects().get(0);\r\n        }\r\n        if (null != invocationSequenceData.getLoggingData()) {\r\n            secondary = invocationSequenceData.getLoggingData();\r\n        }\r\n    }\r\n    List<DetailsTable> result = new ArrayList();\r\n    for (IDetailsGenerator generator : generators) {\r\n        if (generator.canGenerateFor(defaultData)) {\r\n            result.add(generator.generate(defaultData, repositoryDefinition, parent, toolkit));\r\n        } else if ((null != secondary) && generator.canGenerateFor(secondary)) {\r\n            result.add(generator.generate(secondary, repositoryDefinition, parent, toolkit));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.impl.StorageIndexingTest.totalSizeOfBoundedDescriptor",
	"Comment": "tests that the total returned size of the leaf with no descriptors will be the same as the\tamount given.",
	"Method": "void totalSizeOfBoundedDescriptor(){\r\n    LeafWithNoDescriptors<DefaultData> leafWithNoDescriptors = new LeafWithNoDescriptors();\r\n    DefaultData defaultData = mock(DefaultData.class);\r\n    long i = 1L;\r\n    int entries = 100;\r\n    long totalSize = 0L;\r\n    while (i <= entries) {\r\n        when(defaultData.getId()).thenReturn(i);\r\n        IStorageDescriptor storageDescriptor = leafWithNoDescriptors.put(defaultData);\r\n        storageDescriptor.setPositionAndSize(totalSize, i);\r\n        totalSize += i;\r\n        i++;\r\n    }\r\n    List<IStorageDescriptor> results = leafWithNoDescriptors.query(storageIndexQuery);\r\n    long totalReturnedSize = 0;\r\n    for (IStorageDescriptor storageDescriptor : results) {\r\n        totalReturnedSize += storageDescriptor.getSize();\r\n    }\r\n    assertThat(totalReturnedSize, is(equalTo(totalSize)));\r\n    List<IStorageDescriptor> resultsForkJoin = leafWithNoDescriptors.query(storageIndexQuery, forkJoinPool);\r\n    totalReturnedSize = 0;\r\n    for (IStorageDescriptor storageDescriptor : resultsForkJoin) {\r\n        totalReturnedSize += storageDescriptor.getSize();\r\n    }\r\n    assertThat(totalReturnedSize, is(equalTo(totalSize)));\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.cmr.service.cache.CachedSpanService.get",
	"Comment": "returns the span with given span ident. this method will look into the cache first and only\tif span is not cached try to load it from the original span service.",
	"Method": "Span get(SpanIdent spanIdent){\r\n    try {\r\n        return cache.get(spanIdent);\r\n    } catch (ExecutionException e) {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"Span with span ident \" + spanIdent.toString() + \" can not be loaded.\", e);\r\n        }\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.service.data.DiagnosisHelper.getExclusiveDuration",
	"Comment": "gets the exclusive duration of the invocation sequence data element, in case the element has\tnot timer data or has not the exclusive time available it will returns 0.",
	"Method": "double getExclusiveDuration(InvocationSequenceData data){\r\n    TimerData timerData;\r\n    if (InvocationSequenceDataHelper.hasSQLData(data)) {\r\n        timerData = data.getSqlStatementData();\r\n    } else if (InvocationSequenceDataHelper.hasTimerData(data)) {\r\n        timerData = data.getTimerData();\r\n    } else {\r\n        return 0.0;\r\n    }\r\n    if (timerData.isExclusiveTimeDataAvailable()) {\r\n        return timerData.getExclusiveDuration();\r\n    } else {\r\n        return 0.0;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.serializer.impl.SerializerTest.javaCollections",
	"Comment": "tests the java collections. compares array gotten from collections because the equal is\tmissing in those collections.",
	"Method": "void javaCollections(Collection<?> testCollection){\r\n    Collection<?> deserialized = serializeBackAndForth(testCollection);\r\n    assertThat(deserialized, is(instanceOf(testCollection.getClass())));\r\n    assertThat(deserialized.toArray(), is(equalTo(testCollection.toArray())));\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.object.parseable.ParseableFacetAbstract.isValid",
	"Comment": "discover whether either of the candidate parser name or class is valid.",
	"Method": "boolean isValid(){\r\n    return parserClass != null;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.composite.BreadcrumbTitleComposite.layoutInternal",
	"Comment": "layouts the widget so that the text is properly displayed on the composite.",
	"Method": "void layoutInternal(){\r\n    layout(true, true);\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.service.ProblemOccurrenceResultCollector.getProblemContext",
	"Comment": "returns the invocationsequencedata of problemcontext tag.",
	"Method": "Optional<CauseCluster> getProblemContext(Tag leafTag){\r\n    while (null != leafTag) {\r\n        if (leafTag.getType().equals(RuleConstants.DIAGNOSIS_TAG_PROBLEM_CONTEXT)) {\r\n            if (leafTag.getValue() instanceof CauseCluster) {\r\n                return Optional.of((CauseCluster) leafTag.getValue());\r\n            } else {\r\n                throw new RuntimeException(\"Problem context has wrong datatype!\");\r\n            }\r\n        }\r\n        leafTag = leafTag.getParent();\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.processor.impl.StorageDataProcessorsTest.dataAggregationProcessorWritting",
	"Comment": "test that aggregation processor will write elements when needed.",
	"Method": "void dataAggregationProcessorWritting(){\r\n    IAggregator<TimerData> aggregator = mock(IAggregator.class);\r\n    when(aggregator.getAggregationKey(Matchers.<TimerData>anyObject())).thenReturn(1L);\r\n    DataAggregatorProcessor<TimerData> dataProcessor = new DataAggregatorProcessor(TimerData.class, 1000, 1, aggregator, false);\r\n    IWriter writer = mock(IWriter.class);\r\n    dataProcessor.setStorageWriter(writer);\r\n    TimerData timerData1 = new TimerData();\r\n    timerData1.setId(1L);\r\n    timerData1.setTimeStamp(new Timestamp(new Date().getTime()));\r\n    when(aggregator.getClone(Matchers.<TimerData>anyObject())).thenReturn(new AggregatedTimerData());\r\n    dataProcessor.process(timerData1);\r\n    dataProcessor.process(timerData1);\r\n    verify(aggregator, times(2)).aggregate(Matchers.<IAggregatedData<TimerData>>anyObject(), eq(timerData1));\r\n    verifyNoMoreInteractions(writer);\r\n    Timestamp newTimestamp = new Timestamp(timerData1.getTimeStamp().getTime() + 2000L);\r\n    timerData1.setTimeStamp(newTimestamp);\r\n    dataProcessor.process(timerData1);\r\n    ArgumentCaptor<DefaultData> writtenObject = ArgumentCaptor.forClass(DefaultData.class);\r\n    ArgumentCaptor<Map> kryoMap = ArgumentCaptor.forClass(Map.class);\r\n    verify(writer, times(1)).write(writtenObject.capture(), kryoMap.capture());\r\n    assertThat(writtenObject.getValue(), is(instanceOf(AggregatedTimerData.class)));\r\n    assertThat(((AggregatedTimerData) writtenObject.getValue()).getId(), is(1L));\r\n    assertThat(((Map<String, Boolean>) kryoMap.getValue()), hasEntry(KryoSerializationPreferences.WRITE_INVOCATION_AFFILIATION_DATA, Boolean.FALSE));\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.specloader.specimpl.FacetedMethodsBuilder.findAndRemovePropertyAccessorsAndCreateCorrespondingFacetedMethods",
	"Comment": "since the value properties and collections have already been processed,this will pick up the remaining reference properties.",
	"Method": "void findAndRemovePropertyAccessorsAndCreateCorrespondingFacetedMethods(List<FacetedMethod> fields,Properties properties){\r\n    final List<Method> propertyAccessors = Lists.newArrayList();\r\n    getFacetProcessor().findAndRemovePropertyAccessors(methodRemover, propertyAccessors);\r\n    findAndRemovePrefixedNonVoidMethods(MethodScope.OBJECT, GET_PREFIX, Object.class, 0, propertyAccessors);\r\n    findAndRemovePrefixedNonVoidMethods(MethodScope.OBJECT, IS_PREFIX, Boolean.class, 0, propertyAccessors);\r\n    createPropertyFacetedMethodsFromAccessors(propertyAccessors, fields, properties);\r\n}"
}, {
	"Path": "org.apache.isis.core.runtime.system.persistence.PersistenceQueryFactory.wrap",
	"Comment": "converts a map of pojos keyed by string to a map of adapters keyed by thesame strings.",
	"Method": "Map<String, ObjectAdapter> wrap(Map<String, Object> argumentsByParameterName){\r\n    final Map<String, ObjectAdapter> argumentsAdaptersByParameterName = Maps.newHashMap();\r\n    for (final Map.Entry<String, Object> entry : argumentsByParameterName.entrySet()) {\r\n        final String parameterName = entry.getKey();\r\n        final Object argument = argumentsByParameterName.get(parameterName);\r\n        final ObjectAdapter argumentAdapter = argument != null ? adapterManager.adapterFor(argument) : null;\r\n        argumentsAdaptersByParameterName.put(parameterName, argumentAdapter);\r\n    }\r\n    return argumentsAdaptersByParameterName;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.wizard.page.AlertSourceDefinitionWizardPage.initContents",
	"Comment": "initializes the contents of all fields if there are initial values.",
	"Method": "void initContents(Composite main){\r\n    if (null != initialName) {\r\n        nameBox.setText(initialName);\r\n    }\r\n    if (null != initialMeasurement) {\r\n        measurementBox.setText(initialMeasurement);\r\n    }\r\n    if (null != initialField) {\r\n        fieldBox.setText(initialField);\r\n    }\r\n    if (null != initialTags) {\r\n        for (Entry<String, String> tag : initialTags.entrySet()) {\r\n            TagKeyValueUIComponent tagComponent = new TagKeyValueUIComponent(main, tag.getKey(), tag.getValue());\r\n            tagComponents.add(tagComponent);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.preferences.control.samplingrate.test.TimeframeDividerTest.noDataToAggregateWithLessObjectsThanSamplingRate",
	"Comment": "no data to aggregate when sampling rate is bigger than the count of data objects.",
	"Method": "void noDataToAggregateWithLessObjectsThanSamplingRate(){\r\n    List<? extends DefaultData> resultList = null;\r\n    List<ClassLoadingInformationData> tempList = createDataObjects(30);\r\n    Sensitivity sensitivity = SamplingRateControl.Sensitivity.MEDIUM;\r\n    Date fromDate = new Date(1221468612000L);\r\n    Date toDate = new Date(1221472800000L);\r\n    resultList = mode.adjustSamplingRate(tempList, fromDate, toDate, sensitivity.getValue(), new ClassLoadingInformationDataAggregator());\r\n    assertThat(resultList.size(), is(lessThan(sensitivity.getValue())));\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.TextFormatter.getStyledAgentDescription",
	"Comment": "returns the styled information about the agent version and connection status.",
	"Method": "StyledString getStyledAgentDescription(PlatformIdent platformIdent,AgentStatusData agentStatusData){\r\n    StyledString styledString = new StyledString();\r\n    styledString.append(\" \");\r\n    styledString.append(\"[\" + platformIdent.getVersion() + \"]\", StyledString.QUALIFIER_STYLER);\r\n    styledString.append(\" - \");\r\n    if (null != agentStatusData) {\r\n        switch(agentStatusData.getAgentConnection()) {\r\n            case CONNECTED:\r\n                if (null != agentStatusData.getMillisSinceLastData()) {\r\n                    long millis = agentStatusData.getMillisSinceLastData().longValue();\r\n                    if (millis > 60000) {\r\n                        styledString.append(\"Connected :: Last data sent \" + NumberFormatter.humanReadableMillisCount(millis, true) + \" ago\", StyledString.DECORATIONS_STYLER);\r\n                    } else if (agentStatusData.getInstrumentationStatus() == InstrumentationStatus.NO_CLASS_CACHE_AVAILABLE) {\r\n                        styledString.append(\"Connected :: Sending data :: No class cache available\", StyledString.DECORATIONS_STYLER);\r\n                    } else {\r\n                        styledString.append(\"Connected :: Sending data\", StyledString.DECORATIONS_STYLER);\r\n                    }\r\n                } else {\r\n                    styledString.append(\"Connected :: No data sent\", StyledString.DECORATIONS_STYLER);\r\n                }\r\n                break;\r\n            case NO_KEEP_ALIVE:\r\n                long timeSinceLastKeepAlive = System.currentTimeMillis() - agentStatusData.getLastKeepAliveTimestamp();\r\n                styledString.append(\"No keep-alive signal for \" + NumberFormatter.humanReadableMillisCount(timeSinceLastKeepAlive, true), StyledString.DECORATIONS_STYLER);\r\n                break;\r\n            case DISCONNECTED:\r\n                styledString.append(\"Disconnected\", StyledString.DECORATIONS_STYLER);\r\n                break;\r\n            default:\r\n                styledString.append(\"Not connected\", StyledString.DECORATIONS_STYLER);\r\n                break;\r\n        }\r\n    } else {\r\n        styledString.append(\"Not connected\", StyledString.DECORATIONS_STYLER);\r\n    }\r\n    return styledString;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.repository.service.storage.StorageGlobalDataAccessService.getDataObjectsInInterval",
	"Comment": "returns data objects in wanted interval based on the wanted template.",
	"Method": "List<DefaultData> getDataObjectsInInterval(DefaultData template,Timestamp fromDate,Timestamp toDate){\r\n    StorageIndexQuery query = storageIndexQueryProvider.createNewStorageIndexQuery();\r\n    ArrayList<Class<?>> searchClasses = new ArrayList();\r\n    searchClasses.add(template.getClass());\r\n    query.setObjectClasses(searchClasses);\r\n    query.setPlatformIdent(template.getPlatformIdent());\r\n    query.setSensorTypeIdent(template.getSensorTypeIdent());\r\n    query.setToDate(toDate);\r\n    query.setFromDate(fromDate);\r\n    if (template instanceof MethodSensorData) {\r\n        query.setMethodIdent(((MethodSensorData) template).getMethodIdent());\r\n        if (template instanceof InvocationSequenceData) {\r\n            query.setOnlyInvocationsWithoutChildren(true);\r\n        }\r\n    }\r\n    if (template instanceof JmxSensorValueData) {\r\n        query.addIndexingRestriction(IndexQueryRestrictionFactory.equal(\"jmxSensorDefinitionDataIdentId\", ((JmxSensorValueData) template).getJmxSensorDefinitionDataIdentId()));\r\n    }\r\n    List<DefaultData> returnList = super.executeQuery(query);\r\n    Collections.sort(returnList, new Comparator<DefaultData>() {\r\n        @Override\r\n        public int compare(DefaultData o1, DefaultData o2) {\r\n            return o1.getTimeStamp().compareTo(o2.getTimeStamp());\r\n        }\r\n    });\r\n    return returnList;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.repository.service.storage.StorageGlobalDataAccessService.getDataObjectsInInterval",
	"Comment": "returns data objects in wanted interval based on the wanted template.",
	"Method": "List<DefaultData> getDataObjectsInInterval(DefaultData template,Timestamp fromDate,Timestamp toDate){\r\n    return o1.getTimeStamp().compareTo(o2.getTimeStamp());\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Color.isEqualTo",
	"Comment": "returns true if the number of this object has the same value as thespecified number",
	"Method": "boolean isEqualTo(Color number){\r\n    return (number).color == color;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.nio.AbstractChannelManager.finalizeAllChannels",
	"Comment": "finalize all open channels. before closing the channels, force will be performed, so that all\tpending writing on the file channel are performed.",
	"Method": "void finalizeAllChannels(){\r\n    for (CustomAsyncChannel channel : writingChannelsMap.values()) {\r\n        if (channel.isOpened()) {\r\n            closeAsyncChannel(channel);\r\n        }\r\n        writingChannelsMap.values().remove(channel);\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.applib.util.TitleBuffer.truncate",
	"Comment": "truncates this title so it has a maximum number of words. spaces are usedto determine words, thus two spaces in a title will cause two words to bemistakenly identified.",
	"Method": "TitleBuffer truncate(int noWords){\r\n    if (noWords < 1) {\r\n        throw new IllegalArgumentException(\"Truncation must be to one or more words\");\r\n    }\r\n    int pos = 0;\r\n    int spaces = 0;\r\n    while (pos < title.length() && spaces < noWords) {\r\n        if (title.charAt(pos) == ' ') {\r\n            spaces++;\r\n        }\r\n        pos++;\r\n    }\r\n    if (pos < title.length()) {\r\n        title.setLength(pos - 1);\r\n        title.append(\"...\");\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.apache.isis.viewer.restfulobjects.applib.domainobjects.DomainObjectRepresentation.getServiceId",
	"Comment": "populated only for domain services, not for domain objects.",
	"Method": "String getServiceId(){\r\n    return getString(\"serviceId\");\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.TimeStamp.isLessThan",
	"Comment": "returns true if the timestamp of this object is earlier than thespecified timestamp",
	"Method": "boolean isLessThan(TimeStamp timeStamp){\r\n    return time < (timeStamp).time;\r\n}"
}, {
	"Path": "org.apache.isis.core.webapp.content.ResourceCachingFilter.isCachedResource",
	"Comment": "to allow other filters to ask whether a request is mapped to the resourcecaching filter.for example, the isissessionfilter uses this in order to skipany session handling.",
	"Method": "boolean isCachedResource(HttpServletRequest request){\r\n    return request.getAttribute(REQUEST_ATTRIBUTE) != null;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.preferences.control.samplingrate.test.TimeframeDividerTest.nineValuesInOneTimeframe",
	"Comment": "when nine values are in one timeframe and one value is in another timeframe, then the result\tis 2.",
	"Method": "void nineValuesInOneTimeframe(){\r\n    List<ClassLoadingInformationData> tempList = new ArrayList();\r\n    List<? extends DefaultData> resultList = null;\r\n    Sensitivity sensitivity = SamplingRateControl.Sensitivity.VERY_COARSE;\r\n    Date fromDate = new Date(1221469200000L);\r\n    Date toDate = new Date(1221470400000L);\r\n    tempList = createDataObjects(9);\r\n    ClassLoadingInformationData data = new ClassLoadingInformationData(new Timestamp(fromDate.getTime() + 300000L), 1, 5);\r\n    int count = 5;\r\n    data.setCount(count);\r\n    data.setId(-1L);\r\n    data.setMinLoadedClassCount(2010);\r\n    data.setMaxLoadedClassCount(3010);\r\n    int totalLoadedClassCount = (((data.getMinLoadedClassCount() + data.getMaxLoadedClassCount())) / 2) / count;\r\n    data.setTotalLoadedClassCount(totalLoadedClassCount);\r\n    data.setMinUnloadedClassCount(30);\r\n    data.setMaxUnloadedClassCount(40);\r\n    long totalUnloadedClassCount = ((data.getMinUnloadedClassCount() + data.getMaxUnloadedClassCount()) / 2) / count;\r\n    data.setTotalUnloadedClassCount(totalUnloadedClassCount);\r\n    data.setMinTotalLoadedClassCount(10000);\r\n    data.setMaxTotalLoadedClassCount(15000);\r\n    long totalTotalLoadedClassCount = ((data.getMinTotalLoadedClassCount() + data.getMaxTotalLoadedClassCount()) / 2) / count;\r\n    data.setTotalTotalLoadedClassCount(totalTotalLoadedClassCount);\r\n    tempList.add(data);\r\n    resultList = mode.adjustSamplingRate(tempList, fromDate, toDate, sensitivity.getValue(), new ClassLoadingInformationDataAggregator());\r\n    assertThat(resultList.size(), is(equalTo(2)));\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.ui.components.scalars.ScalarPanelSelect2Abstract.setProviderAndCurrAndPending",
	"Comment": "sets up the choices, also ensuring that any currently held value is compatible.",
	"Method": "void setProviderAndCurrAndPending(Select2 select2,ObjectAdapter[] argsIfAvailable){\r\n    final ChoiceProvider<ObjectAdapterMemento> choiceProvider;\r\n    choiceProvider = buildChoiceProvider(argsIfAvailable);\r\n    select2.setProvider(choiceProvider);\r\n    getModel().clearPending();\r\n    if (choiceProvider instanceof ObjectAdapterMementoProviderForChoices) {\r\n        final ObjectAdapterMementoProviderForChoices providerForChoices = (ObjectAdapterMementoProviderForChoices) choiceProvider;\r\n        syncIfNull(select2, providerForChoices.getChoiceMementos());\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.core.runtime.snapshot.Helper.rootElementFor",
	"Comment": "returns the root element for the element by looking up the owner documentfor the element, and from that its document element.if no document element exists, just returns the supplied document.",
	"Method": "Element rootElementFor(Element element){\r\n    final Document doc = element.getOwnerDocument();\r\n    if (doc == null) {\r\n        return element;\r\n    }\r\n    final Element rootElement = doc.getDocumentElement();\r\n    if (rootElement == null) {\r\n        return element;\r\n    }\r\n    return rootElement;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.AgentFolderFactory.accessibleForFolder",
	"Comment": "does agent name applies that agent should be put in the folder.",
	"Method": "boolean accessibleForFolder(String agentName){\r\n    return accessibleForLevel(agentName, 0);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.util.UnderlyingSystemInfo.is64Bit",
	"Comment": "returns if the jvm is a 64bit. note that this method returns false if the jvm is\tnot from sun or ibm.",
	"Method": "boolean is64Bit(){\r\n    switch(JVM_PROVIDER) {\r\n        case SUN:\r\n            return System.getProperty(\"sun.arch.data.model\").indexOf(\"64\") != -1;\r\n        case ORACLE:\r\n            return System.getProperty(\"sun.arch.data.model\").indexOf(\"64\") != -1;\r\n        case IBM:\r\n            return System.getProperty(\"com.ibm.vm.bitmode\").indexOf(\"64\") != -1;\r\n        case AZUL:\r\n            return System.getProperty(\"java.vm.name\").indexOf(\"64\") != -1;\r\n        default:\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.TextFormatter.getStyledStorageDataString",
	"Comment": "returns the styled string for the storage data and its cmr repository definition.",
	"Method": "StyledString getStyledStorageDataString(StorageData storageData,CmrRepositoryDefinition cmrRepositoryDefinition,StyledString getStyledStorageDataString,LocalStorageData localStorageData){\r\n    StyledString styledString = new StyledString();\r\n    styledString.append(localStorageData.getName());\r\n    styledString.append(\" \");\r\n    styledString.append(\"[Local Disk]\", StyledString.QUALIFIER_STYLER);\r\n    styledString.append(\" - \");\r\n    styledString.append(NumberFormatter.humanReadableByteCount(localStorageData.getDiskSize()), StyledString.DECORATIONS_STYLER);\r\n    return styledString;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.InvocationAwareDataTest.simpleDifferentParentsAggregation",
	"Comment": "tests the simple aggregation when objects are in different invocations.",
	"Method": "void simpleDifferentParentsAggregation(){\r\n    InvocationAwareData i1 = getInvocationAwareData();\r\n    i1.addInvocationParentId(Long.valueOf(1));\r\n    InvocationAwareData i2 = getInvocationAwareData();\r\n    i2.addInvocationParentId(Long.valueOf(2));\r\n    i1.aggregateInvocationAwareData(i2);\r\n    assertThat(i1.getObjectsInInvocationsCount(), is(equalTo(2)));\r\n    assertThat(i1.getInvocationParentsIdSet().size(), is(equalTo(2)));\r\n    assertThat(i1.getInvocationParentsIdSet(), contains(1L, 2L));\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.property.CmrConfigurationDialog.showIfNoAdvanced",
	"Comment": "defines if node should be displayed if no advanced is selected. this method is recursive.",
	"Method": "boolean showIfNoAdvanced(IPreferenceNode node){\r\n    if (node.getPage() instanceof PropertyPreferencePage) {\r\n        if (!((PropertyPreferencePage) node.getPage()).isAllAdvancedProperties()) {\r\n            return true;\r\n        }\r\n    }\r\n    if (ArrayUtils.isNotEmpty(node.getSubNodes())) {\r\n        for (IPreferenceNode subNode : node.getSubNodes()) {\r\n            if (showIfNoAdvanced(subNode)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.engine.rule.RuleOutput.hasConditionFailures",
	"Comment": "convenience method to check if the rule execution failed due to failed conditions.",
	"Method": "boolean hasConditionFailures(){\r\n    return CollectionUtils.isNotEmpty(conditionFailures);\r\n}"
}, {
	"Path": "org.apache.isis.core.wrapper.handlers.ProxyContextHandler.proxy",
	"Comment": "whether to execute or not will be picked up from the supplied parenthandler.",
	"Method": "T proxy(T domainObject,ExecutionMode mode,IsisSessionFactory isisSessionFactory,Collection<E> proxy,Collection<E> collectionToProxy,String collectionName,DomainObjectInvocationHandler<T> handler,OneToManyAssociation otma,Map<P, Q> proxy,Map<P, Q> collectionToProxy,String collectionName,DomainObjectInvocationHandler<T> handler,OneToManyAssociation otma){\r\n    final MapInvocationHandler<T, Map<P, Q>> mapInvocationHandler = new MapInvocationHandler<T, Map<P, Q>>(collectionToProxy, collectionName, handler, otma);\r\n    mapInvocationHandler.setResolveObjectChangedEnabled(handler.isResolveObjectChangedEnabled());\r\n    return proxyCreator.instantiateProxy(mapInvocationHandler);\r\n}"
}, {
	"Path": "j2html.tags.Tag.attr",
	"Comment": "adds the specified attribute. if the tag previously contained an attribute with the same name, the old attribute is replaced by the specified attribute.",
	"Method": "T attr(String attribute,Object value,T attr,Attribute attribute,T attr,String attribute){\r\n    return attr(attribute, null);\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Date.add",
	"Comment": "add the specified days, years and months to this date value and return anew date object containing the result.",
	"Method": "Date add(int years,int months,int days){\r\n    final Period add = new Period(years, months, 0, days, 0, 0, 0, 0);\r\n    final DateTime newDate = date.plus(add);\r\n    return new Date(newDate);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.repository.CmrRepositoryManager.getCmrRepositoryDefinitions",
	"Comment": "returns all registered repository definitions handled by this manager. the list is\tunmodifiable.",
	"Method": "List<CmrRepositoryDefinition> getCmrRepositoryDefinitions(){\r\n    return Collections.unmodifiableList(cmrRepositoryDefinitions);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.TimerData.calculateCpuMax",
	"Comment": "sets the maximum if the given value is bigger than the current value.",
	"Method": "void calculateCpuMax(double time){\r\n    cpuMax = Math.max(cpuMax, time);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.Modifier.isVolatile",
	"Comment": "returns true if the modifiers include the volatile modifier.",
	"Method": "boolean isVolatile(int mod){\r\n    return (mod & VOLATILE) != 0;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.storage.InspectITStorageManager.getMountedUnavailableStorages",
	"Comment": "returns mounted but not available storages, thus the ones that can not be read from because\tthere is no cmr that can handle them.",
	"Method": "Collection<LocalStorageData> getMountedUnavailableStorages(){\r\n    return Collections.unmodifiableSet(mountedNotAvailableStorages);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.business.DynamicNameExtractionPart.addOptionalControl",
	"Comment": "adds control to the list of optional controls for the given group id.",
	"Method": "void addOptionalControl(String groupId,Control control){\r\n    if (!optionalControls.containsKey(groupId)) {\r\n        optionalControls.put(groupId, new HashSet<Control>());\r\n    }\r\n    optionalControls.get(groupId).add(control);\r\n}"
}, {
	"Path": "org.apache.isis.viewer.restfulobjects.rendering.service.conneg.ContentNegotiationServiceForRestfulObjectsV1_0.responseBuilder",
	"Comment": "for easy subclassing to further customize, eg additional headers",
	"Method": "ResponseBuilder responseBuilder(ResponseBuilder responseBuilder){\r\n    return responseBuilder;\r\n}"
}, {
	"Path": "org.apache.isis.applib.util.ReasonBuffer.appendOnCondition",
	"Comment": "append a reason to the list of existing reasons if the condition flag istrue.",
	"Method": "void appendOnCondition(boolean condition,String reason){\r\n    if (condition) {\r\n        append(reason);\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.core.integtestsupport.scenarios.ScenarioExecutionForIntegration.beginTran",
	"Comment": "for cucumber hooks to call, performing transaction management around each step.",
	"Method": "void beginTran(){\r\n    isft.beginTran();\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.TextFormatter.clearLineBreaks",
	"Comment": "the original text will be cleaned from the line breaks.\tif string passed is null, null will be returned.",
	"Method": "String clearLineBreaks(String originalText){\r\n    if (null == originalText) {\r\n        return originalText;\r\n    }\r\n    boolean lastCharWhitespace = false;\r\n    StringBuilder stringBuilder = new StringBuilder(originalText.length());\r\n    for (int i = 0; i < originalText.length(); i++) {\r\n        char c = originalText.charAt(i);\r\n        if ((c == '\\r') || (c == '\\n')) {\r\n            if (!lastCharWhitespace) {\r\n                stringBuilder.append(' ');\r\n                lastCharWhitespace = true;\r\n            }\r\n        } else if (Character.isWhitespace(c)) {\r\n            if (!lastCharWhitespace) {\r\n                stringBuilder.append(' ');\r\n                lastCharWhitespace = true;\r\n            }\r\n        } else {\r\n            stringBuilder.append(c);\r\n            lastCharWhitespace = false;\r\n        }\r\n    }\r\n    return stringBuilder.toString();\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.util.OccurrenceFinderFactory.getOccurrenceCount",
	"Comment": "counts number of occurrences of the element in the given invocation.",
	"Method": "ElementOccurrenceCount getOccurrenceCount(List<InvocationSequenceData> invocations,Object element,ViewerFilter[] filters,ElementOccurrenceCount getOccurrenceCount,InvocationSequenceData invocation,Object element,ViewerFilter[] filters,ElementOccurrenceCount getOccurrenceCount,InvocationSequenceData invocationData,E template,ViewerFilter[] filters,ElementOccurrenceCount elementOccurrence){\r\n    OccurrenceFinder finder = getOccurrenceFinder(element);\r\n    return finder.getOccurrenceCount(invocation, element, filters, null);\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.adapter.version.Version.getSequence",
	"Comment": "the internal, strictly monotonically increasing, version number.this might be the timestamp of the change, or it might be simply a number incrementing 1,2,3...",
	"Method": "long getSequence(){\r\n    return sequence;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.wizard.page.ManageLabelWizardPage.isLabelTypeExistsInStorage",
	"Comment": "returns if any storage in collection of storages does contain at least one label that is of\tthe given label type.",
	"Method": "boolean isLabelTypeExistsInStorage(AbstractStorageLabelType<?> labelType,Set<AbstractStorageLabel<?>> labelsInStorages){\r\n    for (AbstractStorageLabel<?> label : labelsInStorages) {\r\n        if (ObjectUtils.equals(label.getStorageLabelType(), labelType)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.viewers.StyledCellIndexLabelProvider.getForeground",
	"Comment": "default behavior is to return null. clients should override this method if\tneeded.",
	"Method": "Color getForeground(Object element,int index){\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.composite.BreadcrumbTitleComposite.getCopyString",
	"Comment": "returns textual representation of the displayed data for the copy purposes.",
	"Method": "String getCopyString(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(repositoryLabel.getText());\r\n    sb.append(\" > \");\r\n    sb.append(agentLabel.getText());\r\n    if (null != groupLabel.getText()) {\r\n        sb.append(\" > \");\r\n        sb.append(groupLabel.getText());\r\n    }\r\n    if (null != viewLabel.getText()) {\r\n        sb.append(\" > \");\r\n        sb.append(viewLabel.getText());\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.communication.data.InvocationSequenceDataHelper.computeNestedDuration",
	"Comment": "computes the duration of the nested invocation elements. includes span duration as last\tresource if the span ident exists on the data.",
	"Method": "double computeNestedDuration(InvocationSequenceData data,double computeNestedDuration,InvocationSequenceData data,ISpanService spanService){\r\n    if (data.getNestedSequences().isEmpty()) {\r\n        return 0;\r\n    }\r\n    double nestedDuration = 0d;\r\n    for (InvocationSequenceData nestedData : data.getNestedSequences()) {\r\n        double duration = calculateDuration(nestedData, spanService);\r\n        if (duration != -1.0d) {\r\n            nestedDuration += duration;\r\n        } else if (!nestedData.getNestedSequences().isEmpty()) {\r\n            nestedDuration += computeNestedDuration(nestedData, spanService);\r\n        }\r\n    }\r\n    return nestedDuration;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.job.BlockingJob.scheduleAndJoin",
	"Comment": "executes the job and returns the result. this method blocks until the job has finished.",
	"Method": "E scheduleAndJoin(){\r\n    schedule();\r\n    try {\r\n        join();\r\n    } catch (InterruptedException e) {\r\n        Thread.interrupted();\r\n        return null;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.isis.core.commons.config.IsisConfigurationDefault.getColor",
	"Comment": "gets the color for the specified name. if no color property is specifiedwith this name then the specified default color is returned.",
	"Method": "Color getColor(String name,Color getColor,String name,Color defaultValue){\r\n    final String color = getPropertyElseNull(name);\r\n    if (color == null) {\r\n        return defaultValue;\r\n    }\r\n    return Color.decode(color);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.communication.data.InvocationSequenceDataHelper.isRootElementInSequence",
	"Comment": "checks whether this data object is the root element of the invocation.",
	"Method": "boolean isRootElementInSequence(InvocationSequenceData data){\r\n    return !hasParentElementInSequence(data);\r\n}"
}, {
	"Path": "org.apache.isis.viewer.restfulobjects.applib.client.RestfulResponse.wraps",
	"Comment": "convenience that recasts this response as wrapping some otherrepresentation.this would typically be as the results of a content type being anerror rather than a representation returned on success.",
	"Method": "RestfulResponse<Q> wraps(Class<Q> cls){\r\n    return (RestfulResponse<Q>) this;\r\n}"
}, {
	"Path": "org.apache.isis.applib.layout.component.PropertyLayoutData.getOwner",
	"Comment": "owner.set programmatically by framework after reading in from xml.",
	"Method": "FieldSet getOwner(){\r\n    return owner;\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.services.container.DomainObjectContainerDefault.newPersistentInstance",
	"Comment": "returns a new instance of the specified class that will have beenpersisted.",
	"Method": "T newPersistentInstance(Class<T> ofClass){\r\n    final T newInstance = newTransientInstance(ofClass);\r\n    persist(newInstance);\r\n    return newInstance;\r\n}"
}, {
	"Path": "org.apache.isis.core.commons.config.IsisConfigurationDefault.getInteger",
	"Comment": "gets the number value for the specified name. if no property is specifiedwith this name then the specified default number value is returned.",
	"Method": "int getInteger(String name,int getInteger,String name,int defaultValue){\r\n    final String value = getPropertyElseNull(name);\r\n    if (value == null) {\r\n        return defaultValue;\r\n    }\r\n    return Integer.valueOf(value).intValue();\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.postprocessors.param.ActionParameterChoicesFacetFromParentedCollection.determineParentAdapter",
	"Comment": "in the case of a mixin action, the target passed to the facet is actually the mixin itself, not the mixee.",
	"Method": "ObjectAdapter determineParentAdapter(ObjectAdapter target){\r\n    final MixinFacet mixinFacet = target.getSpecification().getFacet(MixinFacet.class);\r\n    ObjectAdapter mixedInTarget = null;\r\n    if (mixinFacet != null) {\r\n        mixedInTarget = mixinFacet.mixedIn(target, MixinFacet.Policy.FAIL_FAST);\r\n    }\r\n    return mixedInTarget != null ? mixedInTarget : target;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.storage.nio.ByteBufferProviderTest.capacity",
	"Comment": "test that the created capacity of the buffer will be as wanted.",
	"Method": "void capacity(){\r\n    int maxCapacity = 1000;\r\n    Random random = new Random();\r\n    int wantedCapacity = 1 + random.nextInt(maxCapacity);\r\n    byteBufferProvider.setBufferSize(wantedCapacity);\r\n    byteBufferProvider.setPoolMaxCapacity(maxCapacity);\r\n    byteBufferProvider.init();\r\n    ByteBuffer buffer = byteBufferProvider.acquireByteBuffer();\r\n    assertThat(buffer, is(notNullValue()));\r\n    assertThat(buffer.capacity(), is(equalTo(wantedCapacity)));\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.ColorFormatter.getLinearGradientColor",
	"Comment": "creates the color that is between two supplied color descriptors in linear gradient.",
	"Method": "Color getLinearGradientColor(RGB rgb1,RGB rgb2,double ratio,ResourceManager resourceManager){\r\n    Assert.isTrue((ratio >= 0) && (ratio <= 1), \"Ratio for linear gradient must me between 0 and 1 (including).\");\r\n    int red = (int) ((rgb2.red * ratio) + (rgb1.red * (1 - ratio)));\r\n    int green = (int) ((rgb2.green * ratio) + (rgb1.green * (1 - ratio)));\r\n    int blue = (int) ((rgb2.blue * ratio) + (rgb1.blue * (1 - ratio)));\r\n    RGB newRgb = new RGB(red, green, blue);\r\n    return resourceManager.createColor(newRgb);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.StorageManager.setStorageDefaultFolder",
	"Comment": "this setter can be removed when the spring3.0 on the gui side is working properly.",
	"Method": "void setStorageDefaultFolder(String storageDefaultFolder){\r\n    this.storageDefaultFolder = storageDefaultFolder;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.InvocationAwareData.getObjectsInInvocationsCount",
	"Comment": "returns how much objects are contained in the invocation parents.",
	"Method": "int getObjectsInInvocationsCount(){\r\n    int count = 0;\r\n    if (null != invocationsParentsIdMap) {\r\n        for (MutableInt parentId : invocationsParentsIdMap.values()) {\r\n            count += parentId.getValue();\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.ci.AlertingDefinition.replaceTags",
	"Comment": "replacing the current tags with the tags contained on the given map.",
	"Method": "void replaceTags(Map<String, String> newTags){\r\n    if (newTags == null) {\r\n        throw new IllegalArgumentException(\"Replacing the current tags with a null map.\");\r\n    }\r\n    tags.clear();\r\n    for (Entry<String, String> tag : newTags.entrySet()) {\r\n        putTag(tag.getKey(), tag.getValue());\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.Modifier.isPackage",
	"Comment": "returns true if the modifiers do not include either public, protected, or\tprivate.",
	"Method": "boolean isPackage(int mod){\r\n    return (mod & (PUBLIC | PRIVATE | PROTECTED)) == 0;\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.engine.session.Session.activate",
	"Comment": "tries to activate the session for the given input object and sessionvariables. activation\tmeans that state is changes to activated and sessioncontext is activated as well. activation\tis only possible if the session is currently in new or passivated state, any other state\tforces a sessionexception.",
	"Method": "Session<I, R> activate(I input,Map<String, ?> variables){\r\n    switch(state) {\r\n        case NEW:\r\n        case PASSIVATED:\r\n            sessionContext.activate(input, variables);\r\n            state = State.ACTIVATED;\r\n            break;\r\n        case DESTROYED:\r\n        case FAILURE:\r\n        case ACTIVATED:\r\n        case PROCESSED:\r\n        default:\r\n            throw new SessionException(\"Session can not enter ACTIVATED state from: \" + state + \" state. Ensure Session is in NEW or PASSIVATED state when activating.\");\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.rmi.ObjectSpace.registerClasses",
	"Comment": "registers the classes needed to use objectspaces. this should be called before any\tconnections are opened.",
	"Method": "int registerClasses(Kryo kryo,int nextRegistrationId){\r\n    kryo.register(Object[].class, nextRegistrationId++);\r\n    kryo.register(InvokeMethod.class, nextRegistrationId++);\r\n    FieldSerializer serializer = (FieldSerializer) kryo.register(InvokeMethodResult.class, nextRegistrationId++).getSerializer();\r\n    serializer.getField(\"objectID\").setClass(int.class, new Serializer<Integer>() {\r\n        @Override\r\n        public void write(Kryo kryo, Output output, Integer object) {\r\n            output.writeInt(object, true);\r\n        }\r\n        @Override\r\n        public Integer read(Kryo kryo, Input input, Class<Integer> type) {\r\n            return input.readInt(true);\r\n        }\r\n    });\r\n    kryo.register(InvocationHandler.class, new Serializer() {\r\n        @Override\r\n        public void write(Kryo kryo, Output output, Object object) {\r\n            RemoteInvocationHandler handler = (RemoteInvocationHandler) Proxy.getInvocationHandler(object);\r\n            output.writeInt(handler.objectID, true);\r\n        }\r\n        @Override\r\n        public Object read(Kryo kryo, Input input, Class type) {\r\n            int objectID = input.readInt(true);\r\n            Connection connection = (Connection) kryo.getContext().get(\"connection\");\r\n            Object object = getRegisteredObject(connection, objectID);\r\n            if (WARN && (object == null)) {\r\n                warn(\"kryonet\", \"Unknown object ID \" + objectID + \" for connection: \" + connection);\r\n            }\r\n            return object;\r\n        }\r\n    }, nextRegistrationId++);\r\n    return nextRegistrationId;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.rmi.ObjectSpace.registerClasses",
	"Comment": "registers the classes needed to use objectspaces. this should be called before any\tconnections are opened.",
	"Method": "int registerClasses(Kryo kryo,int nextRegistrationId){\r\n    output.writeInt(object, true);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.rmi.ObjectSpace.registerClasses",
	"Comment": "registers the classes needed to use objectspaces. this should be called before any\tconnections are opened.",
	"Method": "int registerClasses(Kryo kryo,int nextRegistrationId){\r\n    return input.readInt(true);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.rmi.ObjectSpace.registerClasses",
	"Comment": "registers the classes needed to use objectspaces. this should be called before any\tconnections are opened.",
	"Method": "int registerClasses(Kryo kryo,int nextRegistrationId){\r\n    RemoteInvocationHandler handler = (RemoteInvocationHandler) Proxy.getInvocationHandler(object);\r\n    output.writeInt(handler.objectID, true);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.rmi.ObjectSpace.registerClasses",
	"Comment": "registers the classes needed to use objectspaces. this should be called before any\tconnections are opened.",
	"Method": "int registerClasses(Kryo kryo,int nextRegistrationId){\r\n    int objectID = input.readInt(true);\r\n    Connection connection = (Connection) kryo.getContext().get(\"connection\");\r\n    Object object = getRegisteredObject(connection, objectID);\r\n    if (WARN && (object == null)) {\r\n        warn(\"kryonet\", \"Unknown object ID \" + objectID + \" for connection: \" + connection);\r\n    }\r\n    return object;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.InvocationAwareDataTest.simpleSameParentsAggregation",
	"Comment": "tests the simple aggregation when objects are in same invocations.",
	"Method": "void simpleSameParentsAggregation(){\r\n    InvocationAwareData i1 = getInvocationAwareData();\r\n    i1.addInvocationParentId(Long.valueOf(1));\r\n    InvocationAwareData i2 = getInvocationAwareData();\r\n    i2.addInvocationParentId(Long.valueOf(1));\r\n    i1.aggregateInvocationAwareData(i2);\r\n    assertThat(i1.getObjectsInInvocationsCount(), is(equalTo(2)));\r\n    assertThat(i1.getInvocationParentsIdSet().size(), is(equalTo(1)));\r\n    assertThat(i1.getInvocationParentsIdSet(), contains(1L));\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.impl.BufferIndexingTest.getWithNoKey",
	"Comment": "test that get will work even when branch can not generate key for the element if id is\tcorrectly set.",
	"Method": "void getWithNoKey(){\r\n    IBufferTreeComponent<DefaultData> rootBranch = new Branch(new BufferBranchIndexer(new TimestampIndexer()));\r\n    DefaultData defaultData = mock(DefaultData.class);\r\n    when(defaultData.getId()).thenReturn(1L);\r\n    when(defaultData.getTimeStamp()).thenReturn(new Timestamp(new Date().getTime()));\r\n    rootBranch.put(defaultData);\r\n    when(defaultData.getTimeStamp()).thenReturn(null);\r\n    assertThat(rootBranch.get(defaultData), is(equalTo(defaultData)));\r\n    assertThat(rootBranch.getAndRemove(defaultData), is(equalTo(defaultData)));\r\n    assertThat(rootBranch.get(defaultData), is(nullValue()));\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.storage.nio.stream.AbstractExtendedByteBufferInputStream.bufferChange",
	"Comment": "changes the current buffer used for streaming with a full one.",
	"Method": "void bufferChange(){\r\n    ByteBuffer current = super.getByteBuffer();\r\n    if (null != current) {\r\n        current.clear();\r\n        emptyBuffers.add(current);\r\n    }\r\n    int tries = 0;\r\n    while (true) {\r\n        try {\r\n            ByteBuffer buffer = fullBuffers.poll(100, TimeUnit.MILLISECONDS);\r\n            if (null != buffer) {\r\n                super.setByteBuffer(buffer);\r\n                break;\r\n            } else {\r\n                tries++;\r\n                if (readFailed) {\r\n                    throw new ReadFailedException(\"Read failed signal received.\");\r\n                } else if (tries > MAX_BUFFER_POOL_TRIES) {\r\n                    throw new ReadFailedException(\"Time-out trying to get the full byte buffer to read after \" + TimeUnit.MILLISECONDS.toSeconds(100 * MAX_BUFFER_POOL_TRIES) + \" sec.\");\r\n                }\r\n            }\r\n        } catch (InterruptedException e) {\r\n            Thread.interrupted();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.core.runtime.services.eventbus.adapter.EventBusImplementationForAxonSimple.post",
	"Comment": "logic equivalent to guava event bus.despite that, event processing cannot be followed after an exception is thrown.",
	"Method": "void post(Object event){\r\n    simpleEventBus.publish(GenericEventMessage.asEventMessage(event));\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.AgentFolderFactory.accessibleForLevel",
	"Comment": "checks if the name of the agent is accessible for the given level of folder.",
	"Method": "boolean accessibleForLevel(String agentName,int level){\r\n    String[] splitted = getSplittedAgentName(agentName);\r\n    if (splitted.length > (level + 1)) {\r\n        for (String string : splitted) {\r\n            if (StringUtils.isEmpty(string)) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.applib.services.i18n.TranslatableString.trn",
	"Comment": "a translatable string with different patterns for singular and plural forms, selected automatically by the number",
	"Method": "TranslatableString trn(String singularPattern,String pluralPattern,int number,Object paramArgs){\r\n    return new TranslatableString(Type.TRN, singularPattern, pluralPattern, number, asMap(paramArgs));\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.impl.BufferIndexingTest.queryDifferentLevels",
	"Comment": "test tree with query that holds platform ident and sensor ident in different levels.",
	"Method": "void queryDifferentLevels(){\r\n    BufferBranchIndexer<DefaultData> sensorTypeIndexer = new BufferBranchIndexer(new SensorTypeIdentIndexer());\r\n    BufferBranchIndexer<DefaultData> objectTypeIndexer = new BufferBranchIndexer(new ObjectTypeIndexer(), sensorTypeIndexer);\r\n    BufferBranchIndexer<DefaultData> platformTypeIndexer = new BufferBranchIndexer(new PlatformIdentIndexer(), objectTypeIndexer);\r\n    IBufferTreeComponent<DefaultData> rootBranch = new Branch(platformTypeIndexer);\r\n    TimerData defaultData1 = mock(TimerData.class);\r\n    when(defaultData1.getId()).thenReturn(1L);\r\n    when(defaultData1.getPlatformIdent()).thenReturn(10L);\r\n    when(defaultData1.getSensorTypeIdent()).thenReturn(10L);\r\n    when(defaultData1.isQueryComplied(indexQuery)).thenReturn(true);\r\n    rootBranch.put(defaultData1);\r\n    SqlStatementData defaultData2 = mock(SqlStatementData.class);\r\n    when(defaultData2.getId()).thenReturn(2L);\r\n    when(defaultData2.getPlatformIdent()).thenReturn(10L);\r\n    when(defaultData2.getSensorTypeIdent()).thenReturn(20L);\r\n    when(defaultData2.isQueryComplied(indexQuery)).thenReturn(true);\r\n    rootBranch.put(defaultData2);\r\n    indexQuery.setPlatformIdent(10L);\r\n    List<DefaultData> results = rootBranch.query(indexQuery);\r\n    assertThat(results.size(), is(equalTo(2)));\r\n    for (DefaultData result : results) {\r\n        assertThat(result.getPlatformIdent(), is(equalTo(10L)));\r\n    }\r\n    indexQuery.setPlatformIdent(10L);\r\n    indexQuery.setSensorTypeIdent(10L);\r\n    results = rootBranch.query(indexQuery);\r\n    assertThat(results.size(), is(equalTo(1)));\r\n    for (DefaultData result : results) {\r\n        assertThat(result.getPlatformIdent(), is(equalTo(10L)));\r\n        assertThat(result.getSensorTypeIdent(), is(equalTo(10L)));\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.nio.ChannelManagersTest.initChannelManagers",
	"Comment": "initializes the channel managers that will use default executor service.",
	"Method": "void initChannelManagers(){\r\n    writingChannelManager = new WritingChannelManager();\r\n    readingChannelManager = new ReadingChannelManager();\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.documentation.DocumentationService.getSearchUrlFor",
	"Comment": "builds the appropriate url for searching within the enduser documentation of inspectit. if\tthe version can be retrieved, the search is filtered to only be applied on the space of this\tversion. if the version cannot be retrieved, a general search is executed.\tif no search string is given, the normal documentation page is returned using the\tgetdocumentationurl method.",
	"Method": "String getSearchUrlFor(String searchString){\r\n    if (StringUtils.isNotEmpty(searchString)) {\r\n        StringBuilder stringBuilder = new StringBuilder(DOCUMENTATION_SEARCH_URL);\r\n        String[] words = StringUtils.split(searchString);\r\n        for (int i = 0; i < words.length; i++) {\r\n            stringBuilder.append(words[i]);\r\n            if (i < (words.length - 1)) {\r\n                stringBuilder.append('+');\r\n            }\r\n        }\r\n        try {\r\n            Version version = versionService.getVersion();\r\n            stringBuilder.append(\"&where=DOC\");\r\n            stringBuilder.append(getSpaceKey(version));\r\n        } catch (InvalidVersionException e) {\r\n        }\r\n        return stringBuilder.toString();\r\n    }\r\n    return getDocumentationUrl();\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.object.immutable.ImmutableFacetAbstract.disables",
	"Comment": "immutable facet only prevents changes to a property or a collection.",
	"Method": "String disables(UsabilityContext<? extends UsabilityEvent> ic){\r\n    final ObjectAdapter target = ic.getTarget();\r\n    switch(ic.getInteractionType()) {\r\n        case PROPERTY_MODIFY:\r\n        case COLLECTION_ADD_TO:\r\n        case COLLECTION_REMOVE_FROM:\r\n            return disabledReason(target);\r\n        default:\r\n            return null;\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.applib.layout.grid.bootstrap3.BS3Row.getOwner",
	"Comment": "owner.set programmatically by framework after reading in from xml.",
	"Method": "BS3RowOwner getOwner(){\r\n    return owner;\r\n}"
}, {
	"Path": "org.apache.isis.viewer.restfulobjects.applib.domainobjects.DomainObjectRepresentation.getDomainType",
	"Comment": "populated only for domain objects, not for domain services.",
	"Method": "String getDomainType(){\r\n    return getString(\"domainType\");\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.query.factory.impl.ExceptionSensorDataQueryFactory.getDataForGroupedExceptionOverviewQuery",
	"Comment": "returns a query for list of objects that is used to show an overview over exceptions with\tspecific information about the number of caused event types.",
	"Method": "E getDataForGroupedExceptionOverviewQuery(ExceptionSensorData template,Date fromDate,Date toDate){\r\n    E query = getIndexQueryProvider().getIndexQuery();\r\n    ArrayList<Class<?>> searchedClasses = new ArrayList();\r\n    searchedClasses.add(ExceptionSensorData.class);\r\n    searchedClasses.add(AggregatedExceptionSensorData.class);\r\n    query.setObjectClasses(searchedClasses);\r\n    query.setPlatformIdent(template.getPlatformIdent());\r\n    if (null != template.getThrowableType()) {\r\n        query.addIndexingRestriction(IndexQueryRestrictionFactory.equal(\"throwableType\", template.getThrowableType()));\r\n    }\r\n    if (null != fromDate) {\r\n        query.setFromDate(new Timestamp(fromDate.getTime()));\r\n    }\r\n    if (null != toDate) {\r\n        query.setToDate(new Timestamp(toDate.getTime()));\r\n    }\r\n    return query;\r\n}"
}, {
	"Path": "org.apache.isis.core.runtime.snapshot.IsisSchema.setAttribute",
	"Comment": "sets an attribute of the supplied element with the attribute being in theisis namespace.",
	"Method": "void setAttribute(Element element,String attributeName,String attributeValue){\r\n    element.setAttributeNS(IsisSchema.NS_URI, IsisSchema.NS_PREFIX + \":\" + attributeName, attributeValue);\r\n}"
}, {
	"Path": "org.apache.isis.core.webapp.content.ResourceCachingFilter.init",
	"Comment": "initializes the servlet filter with the cache time and sets up theunchanging headers.",
	"Method": "void init(FilterConfig pConfig){\r\n    final ArrayList<String[]> newReplyHeaders = new ArrayList<String[]>();\r\n    final String cacheTime = pConfig.getInitParameter(CACHE_TIME_PARAM_NAME);\r\n    this.cacheTime = Long.parseLong(cacheTime != null ? cacheTime : CACHE_TIME_PARAM_NAME_DEFAULT);\r\n    if (this.cacheTime > 0L) {\r\n        newReplyHeaders.add(new String[] { CACHE_CONTROL_HEADER, MAX_AGE_VALUE + this.cacheTime.longValue() });\r\n        newReplyHeaders.add(new String[] { CACHE_CONTROL_HEADER, PRE_CHECK_VALUE + this.cacheTime.longValue() });\r\n        newReplyHeaders.add(new String[] { CACHE_CONTROL_HEADER, POST_CHECK_VALUE + this.cacheTime.longValue() });\r\n    } else {\r\n        newReplyHeaders.add(new String[] { PRAGMA_HEADER, NO_CACHE_VALUE });\r\n        newReplyHeaders.add(new String[] { EXPIRES_HEADER, ZERO_STRING_VALUE });\r\n        newReplyHeaders.add(new String[] { CACHE_CONTROL_HEADER, NO_CACHE_VALUE });\r\n        newReplyHeaders.add(new String[] { CACHE_CONTROL_HEADER, NO_STORE_VALUE });\r\n    }\r\n    this.mReplyHeaders = new String[newReplyHeaders.size()][2];\r\n    newReplyHeaders.toArray(this.mReplyHeaders);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.jaxb.JAXBTransformator.getMigrationFiles",
	"Comment": "collects the files from given directory if it exists. files will be sorted by name.",
	"Method": "List<Path> getMigrationFiles(Path migrationPath){\r\n    if ((null == migrationPath) || !Files.exists(migrationPath) || !Files.isDirectory(migrationPath)) {\r\n        return Collections.emptyList();\r\n    }\r\n    DirectoryStream<Path> directoryStream = Files.newDirectoryStream(migrationPath);\r\n    List<Path> migrationsFiles = new ArrayList();\r\n    for (Path migrationFile : directoryStream) {\r\n        if (!Files.isDirectory(migrationFile)) {\r\n            migrationsFiles.add(migrationFile);\r\n        }\r\n    }\r\n    Collections.sort(migrationsFiles, new Comparator<Path>() {\r\n        @Override\r\n        public int compare(Path o1, Path o2) {\r\n            return o1.getFileName().toString().compareTo(o2.getFileName().toString());\r\n        }\r\n    });\r\n    return migrationsFiles;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.jaxb.JAXBTransformator.getMigrationFiles",
	"Comment": "collects the files from given directory if it exists. files will be sorted by name.",
	"Method": "List<Path> getMigrationFiles(Path migrationPath){\r\n    return o1.getFileName().toString().compareTo(o2.getFileName().toString());\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.version.VersionService.getVersion",
	"Comment": "retrieves the version information of the current release.",
	"Method": "Version getVersion(){\r\n    if (null == cachedVersion) {\r\n        String readVersion = provider.readVersion();\r\n        cachedVersion = Version.verifyAndCreate(readVersion);\r\n    }\r\n    return cachedVersion;\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.adapter.version.Version.getUtcTimestamp",
	"Comment": "the time of the last change, as utc milliseconds.may be null.",
	"Method": "Long getUtcTimestamp(){\r\n    return utcTimestamp;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.Connection.isConnected",
	"Comment": "returns true if this connection is connected to the remote end. note that a connection can\tbecome disconnected at any time.",
	"Method": "boolean isConnected(){\r\n    return isConnected;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.repository.CmrRepositoryDefinition.addCmrRepositoryChangeListener",
	"Comment": "registers a cmr repository change listener to this cmr if it was not already.",
	"Method": "void addCmrRepositoryChangeListener(CmrRepositoryChangeListener cmrRepositoryChangeListener){\r\n    synchronized (cmrRepositoryChangeListeners) {\r\n        if (!cmrRepositoryChangeListeners.contains(cmrRepositoryChangeListener)) {\r\n            cmrRepositoryChangeListeners.add(cmrRepositoryChangeListener);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.storage.InspectITStorageManager.unzipStorageData",
	"Comment": "unzips the content of the zip file provided to the default storage folder. the method will\tfirst unzip the complete content of the zip file to the temporary folder and then rename the\ttemporary folder to match the storage id.\tthe method will also check if the imported storage is available online, and if it is will\tupdate the local data saved.",
	"Method": "void unzipStorageData(String fileName){\r\n    Path zipPath = Paths.get(fileName);\r\n    IStorageData packedStorageData = getStorageDataFromZip(zipPath);\r\n    this.unzipStorageData(zipPath, getStoragePath(packedStorageData));\r\n    List<LocalStorageData> localStorageDataList = getMountedStoragesFromDisk();\r\n    for (LocalStorageData localStorageData : localStorageDataList) {\r\n        if (localStorageData.isFullyDownloaded() && !downloadedStorages.contains(localStorageData)) {\r\n            downloadedStorages.add(localStorageData);\r\n            for (StorageData storageData : getOnlineStorages().keySet()) {\r\n                if (ObjectUtils.equals(storageData.getId(), localStorageData.getId())) {\r\n                    updateLocalStorageData(localStorageData, storageData);\r\n                    break;\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.ui.components.scalars.ScalarPanelAbstract.buildGui",
	"Comment": "builds gui lazily prior to first render.this design allows the panel to be configured first.",
	"Method": "void buildGui(){\r\n    componentIfCompact = addComponentForCompact();\r\n    componentIfRegular = addComponentForRegular();\r\n    getRendering().buildGui(this);\r\n    addCssForMetaModel();\r\n    if (!subscribers.isEmpty()) {\r\n        addFormComponentBehavior(new ScalarUpdatingBehavior());\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.tree.DeferredTreeViewer.areFiltersPassed",
	"Comment": "returns if all the filters are passed for the specific object.",
	"Method": "boolean areFiltersPassed(Object object){\r\n    ViewerFilter[] filters = getFilters();\r\n    if (null != filters) {\r\n        for (ViewerFilter filer : filters) {\r\n            if (!filer.select(this, getParentElement(object), object)) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.repository.CmrRepositoryManager.cancelAllUpdateRepositoriesJobs",
	"Comment": "cancels all the update repository jobs. the method will return only when all jobs are\tcanceled.",
	"Method": "void cancelAllUpdateRepositoriesJobs(){\r\n    for (UpdateRepositoryJob updateRepositoryJob : repositoryUpdateJobMap.values()) {\r\n        while (!updateRepositoryJob.cancel()) {\r\n            try {\r\n                updateRepositoryJob.join();\r\n            } catch (InterruptedException e) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.core.commons.exceptions.ExceptionUtils.isThrowableNested",
	"Comment": "checks if the throwable class has a getcause method.this is true for jdk 1.4 and above.",
	"Method": "boolean isThrowableNested(){\r\n    return THROWABLE_CAUSE_METHOD != null;\r\n}"
}, {
	"Path": "org.apache.isis.core.runtime.snapshot.XmlSnapshot.mergeTree",
	"Comment": "merges the tree of elements whose root is childelementunderneath the parentelement.if the parentelement already has an element that matches thechildelement, then recursively attaches the grandchildreninstead.the element returned will be either the suppliedchildelement, or an existing child element if one alreadyexisted under parentelement.",
	"Method": "Element mergeTree(Element parentElement,Element childElement){\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"mergeTree({}{})\", log(\"parent\", parentElement), andlog(\"child\", childElement));\r\n    }\r\n    final String childElementOid = isisMetaModel.getAttribute(childElement, \"oid\");\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"mergeTree(El,El): {}\", log(\"childOid\", childElementOid));\r\n    }\r\n    if (childElementOid != null) {\r\n        if (LOG.isDebugEnabled()) {\r\n            LOG.debug(\"mergeTree(El,El): check if child already there\");\r\n        }\r\n        final Vector existingChildElements = elementsUnder(parentElement, childElement.getLocalName());\r\n        for (final Enumeration childEnum = existingChildElements.elements(); childEnum.hasMoreElements(); ) {\r\n            final Element possibleMatchingElement = (Element) childEnum.nextElement();\r\n            final String possibleMatchOid = isisMetaModel.getAttribute(possibleMatchingElement, \"oid\");\r\n            if (possibleMatchOid == null || !possibleMatchOid.equals(childElementOid)) {\r\n                continue;\r\n            }\r\n            if (LOG.isDebugEnabled()) {\r\n                LOG.debug(\"mergeTree(El,El): child already there; merging grandchildren\");\r\n            }\r\n            final Element existingChildElement = possibleMatchingElement;\r\n            final Vector grandchildrenElements = elementsUnder(childElement, \"*\");\r\n            for (final Enumeration grandchildEnum = grandchildrenElements.elements(); grandchildEnum.hasMoreElements(); ) {\r\n                final Element grandchildElement = (Element) grandchildEnum.nextElement();\r\n                childElement.removeChild(grandchildElement);\r\n                if (LOG.isDebugEnabled()) {\r\n                    LOG.debug(\"mergeTree(El,El): merging {}\", log(\"grandchild\", grandchildElement));\r\n                }\r\n                mergeTree(existingChildElement, grandchildElement);\r\n            }\r\n            return existingChildElement;\r\n        }\r\n    }\r\n    parentElement.appendChild(childElement);\r\n    return childElement;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.impl.StorageIndexingTest.queryDifferentLevels",
	"Comment": "test tree with query that holds platform ident and sensor ident in different levels.",
	"Method": "void queryDifferentLevels(){\r\n    StorageBranchIndexer<DefaultData> sensorTypeIndexer = new StorageBranchIndexer(new SensorTypeIdentIndexer(), false);\r\n    StorageBranchIndexer<DefaultData> objectTypeIndexer = new StorageBranchIndexer(new ObjectTypeIndexer(), sensorTypeIndexer, false);\r\n    StorageBranchIndexer<DefaultData> platformTypeIndexer = new StorageBranchIndexer(new PlatformIdentIndexer(), objectTypeIndexer, false);\r\n    IStorageTreeComponent<DefaultData> rootBranch = new StorageBranch(platformTypeIndexer);\r\n    TimerData defaultData1 = mock(TimerData.class);\r\n    when(defaultData1.getId()).thenReturn(1L);\r\n    when(defaultData1.getPlatformIdent()).thenReturn(10L);\r\n    when(defaultData1.getSensorTypeIdent()).thenReturn(10L);\r\n    IStorageDescriptor storageDescriptor1 = rootBranch.put(defaultData1);\r\n    storageDescriptor1.setPositionAndSize(0L, 100L);\r\n    SqlStatementData defaultData2 = mock(SqlStatementData.class);\r\n    when(defaultData2.getId()).thenReturn(2L);\r\n    when(defaultData2.getPlatformIdent()).thenReturn(10L);\r\n    when(defaultData2.getSensorTypeIdent()).thenReturn(20L);\r\n    IStorageDescriptor storageDescriptor2 = rootBranch.put(defaultData2);\r\n    storageDescriptor2.setPositionAndSize(0L, 200L);\r\n    storageIndexQuery.setPlatformIdent(10L);\r\n    List<IStorageDescriptor> results = rootBranch.query(storageIndexQuery);\r\n    assertThat(results.size(), is(equalTo(2)));\r\n    long totalSize = 0;\r\n    for (IStorageDescriptor result : results) {\r\n        totalSize += result.getSize();\r\n    }\r\n    assertThat(totalSize, is(equalTo(300L)));\r\n    storageIndexQuery.setPlatformIdent(10L);\r\n    storageIndexQuery.setSensorTypeIdent(10L);\r\n    results = rootBranch.query(storageIndexQuery);\r\n    assertThat(results.size(), is(equalTo(1)));\r\n    for (IStorageDescriptor result : results) {\r\n        assertThat(result.getSize(), is(equalTo(100L)));\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.query.factory.impl.SpanQueryFactory.getSpans",
	"Comment": "returns query for searching spans that belong to the same trace.",
	"Method": "E getSpans(long traceId){\r\n    E query = getIndexQueryProvider().getIndexQuery();\r\n    query.setObjectClasses(CLASSES_LIST);\r\n    query.addIndexingRestriction(IndexQueryRestrictionFactory.equal(\"spanIdent.traceId\", traceId));\r\n    return query;\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Date.endOfMonth",
	"Comment": "calculates, and returns, a date representing the last day of the monthrelative to the current date.",
	"Method": "Date endOfMonth(){\r\n    return new Date(date.dayOfMonth().withMaximumValue());\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.StorageManager.zipFiles",
	"Comment": "zips all files in the given directory to the provided zippath.",
	"Method": "void zipFiles(Path directory,Path zipPath){\r\n    if (Files.notExists(directory)) {\r\n        throw new IOException(\"Can not create zip file. The directory \" + directory.toString() + \" does not exist.\");\r\n    }\r\n    if (!Files.isDirectory(directory)) {\r\n        throw new IOException(\"Can not create zip file. Given path \" + directory.toString() + \" is not the directory.\");\r\n    }\r\n    Files.deleteIfExists(zipPath);\r\n    try (final ZipOutputStream zos = new ZipOutputStream(Files.newOutputStream(zipPath, StandardOpenOption.CREATE, StandardOpenOption.WRITE))) {\r\n        Files.walkFileTree(directory, new SimpleFileVisitor<Path>() {\r\n            @Override\r\n            public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {\r\n                String fileName = directory.relativize(file).toString();\r\n                ZipEntry zipEntry = new ZipEntry(fileName);\r\n                zos.putNextEntry(zipEntry);\r\n                Files.copy(file, zos);\r\n                zos.closeEntry();\r\n                return FileVisitResult.CONTINUE;\r\n            }\r\n        });\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.StorageManager.zipFiles",
	"Comment": "zips all files in the given directory to the provided zippath.",
	"Method": "void zipFiles(Path directory,Path zipPath){\r\n    String fileName = directory.relativize(file).toString();\r\n    ZipEntry zipEntry = new ZipEntry(fileName);\r\n    zos.putNextEntry(zipEntry);\r\n    Files.copy(file, zos);\r\n    zos.closeEntry();\r\n    return FileVisitResult.CONTINUE;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.tree.TreeSubView.getColumnNames",
	"Comment": "return the names of all columns in the tree. not visible columns names will also be included.\tthe order of the names will be same to the initial tree column order, thus not reflecting the\tcurrent state of the table if the columns were moved.",
	"Method": "List<String> getColumnNames(){\r\n    List<String> names = new ArrayList();\r\n    for (TreeColumn column : treeViewer.getTree().getColumns()) {\r\n        names.add(column.getText());\r\n    }\r\n    return names;\r\n}"
}, {
	"Path": "org.apache.isis.core.commons.config.IsisConfigurationDefault.getFont",
	"Comment": "gets the font for the specified name. if no font property is specifiedwith this name then the specified default font is returned.",
	"Method": "Font getFont(String name,Font getFont,String name,Font defaultValue){\r\n    final String font = getPropertyElseNull(name);\r\n    if (font == null) {\r\n        return defaultValue;\r\n    }\r\n    return Font.decode(font);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.view.AbstractTableBasedManagerView.updateViewContent",
	"Comment": "updates the content of the view by communicating with the cmr.",
	"Method": "void updateViewContent(IJobChangeListener jobListener){\r\n    Job updateStorageListJob = new Job(\"Update data\") {\r\n        @Override\r\n        protected IStatus run(IProgressMonitor monitor) {\r\n            updateContent();\r\n            return Status.OK_STATUS;\r\n        }\r\n    };\r\n    if (null != jobListener) {\r\n        updateStorageListJob.addJobChangeListener(jobListener);\r\n    }\r\n    updateStorageListJob.schedule();\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.view.AbstractTableBasedManagerView.updateViewContent",
	"Comment": "updates the content of the view by communicating with the cmr.",
	"Method": "void updateViewContent(IJobChangeListener jobListener){\r\n    updateContent();\r\n    return Status.OK_STATUS;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.Modifier.isInterface",
	"Comment": "returns true if the modifiers include the interface modifier.",
	"Method": "boolean isInterface(int mod){\r\n    return (mod & INTERFACE) != 0;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.Connection.getRemoteAddressUDP",
	"Comment": "returns the ip address and port of the remote end of the udp connection, or null if this\tconnection is not connected.",
	"Method": "InetSocketAddress getRemoteAddressUDP(){\r\n    InetSocketAddress connectedAddress = udp.connectedAddress;\r\n    if (connectedAddress != null) {\r\n        return connectedAddress;\r\n    }\r\n    return udpRemoteAddress;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.ci.business.expression.impl.StringMatchingExpression.evaluate",
	"Comment": "recursive evaluation in the invocation sequence structure if search in trace is activated.",
	"Method": "boolean evaluate(InvocationSequenceData invocSequence,ICachedDataService cachedDataService,boolean evaluate,InvocationSequenceData invocSequence,ICachedDataService cachedDataService,int depth){\r\n    String[] strArray = getStringValueSource().getStringValues(invocSequence, cachedDataService);\r\n    if (ArrayUtils.isNotEmpty(strArray)) {\r\n        for (String element : strArray) {\r\n            if ((null != element) && evaluateString(element)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    if (isSearchNodeInTrace() && ((getMaxSearchDepth() < 0) || (depth < getMaxSearchDepth()))) {\r\n        for (InvocationSequenceData childNode : invocSequence.getNestedSequences()) {\r\n            if (evaluate(childNode, cachedDataService, depth + 1)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.isis.applib.fixtures.FixtureClock.setTime",
	"Comment": "sets the hours and minutes as specified, and sets the seconds andmilliseconds to zero, but the date portion is left unchanged.",
	"Method": "void setTime(int hour,int min){\r\n    setupCalendarIfRequired();\r\n    calendar.set(Calendar.HOUR_OF_DAY, hour);\r\n    calendar.set(Calendar.MINUTE, min);\r\n    calendar.set(Calendar.SECOND, 0);\r\n    calendar.set(Calendar.MILLISECOND, 0);\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.specloader.specimpl.ObjectActionDefault.withTargetAdapters",
	"Comment": "a horrible hack to be able to persist a number of adapters in the command object.what is really needed is to be able to invoke an action on a number of adapters all together.",
	"Method": "T withTargetAdapters(List<ObjectAdapter> adapters,Callable<T> callable){\r\n    commandTargetAdaptersHolder.set(adapters);\r\n    try {\r\n        return callable.call();\r\n    } catch (Exception e) {\r\n        throw new ApplicationException(e);\r\n    } finally {\r\n        commandTargetAdaptersHolder.set(null);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.preferences.FormPreferencePanel.createPreferenceControls",
	"Comment": "creates the preference controls in the preference control panel.",
	"Method": "void createPreferenceControls(Composite parent,Set<PreferenceId> preferenceSet,InputDefinition inputDefinition){\r\n    for (PreferenceId preferenceIdEnum : preferenceSet) {\r\n        IPreferenceControl preferenceControl = PreferenceControlFactory.createPreferenceControls(parent, toolkit, preferenceIdEnum, this, inputDefinition);\r\n        if (null != preferenceControl) {\r\n            preferenceControlList.add(preferenceControl);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.viewer.restfulobjects.rendering.domainobjects.AbstractObjectMemberReprRenderer.asFollowed",
	"Comment": "indicate that this is a representation to include as the result of afollowed link.",
	"Method": "R asFollowed(){\r\n    mode = Mode.FOLLOWED;\r\n    return cast(this);\r\n}"
}, {
	"Path": "org.apache.isis.core.runtime.snapshot.XmlSchema.createElement",
	"Comment": "creates an element with the specified localname, in the appropriatenamespace for the nos.if necessary the namespace definition is added to the root element of thedoc used to create the element. the element is not parented but to avoidan error can only be added as a child of another element in the same doc.",
	"Method": "Element createElement(Document doc,String localName,String fullyQualifiedClassName,String singularName,String pluralName){\r\n    final Element element = doc.createElementNS(getUri(), getPrefix() + \":\" + localName);\r\n    element.setAttributeNS(IsisSchema.NS_URI, IsisSchema.NS_PREFIX + \":fqn\", fullyQualifiedClassName);\r\n    element.setAttributeNS(IsisSchema.NS_URI, IsisSchema.NS_PREFIX + \":singular\", singularName);\r\n    element.setAttributeNS(IsisSchema.NS_URI, IsisSchema.NS_PREFIX + \":plural\", pluralName);\r\n    isisMeta.addNamespace(element);\r\n    addNamespace(element, getPrefix(), getUri());\r\n    return element;\r\n}"
}, {
	"Path": "j2html.TagCreator.attrs",
	"Comment": "returns a attr.shortform object with either id, classes or both,obtained from parsing the input string using css selector syntax",
	"Method": "Attr.ShortForm attrs(String attrs){\r\n    return Attr.shortFormFromAttrsString(attrs);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.InvocationAwareData.addInvocationParentId",
	"Comment": "adds one invocation sequence data id to the set of invocation ids where this object is found.",
	"Method": "void addInvocationParentId(Long id){\r\n    if (null != id) {\r\n        if (null == invocationsParentsIdMap) {\r\n            invocationsParentsIdMap = new HashMap<Long, MutableInt>();\r\n        }\r\n        MutableInt count = invocationsParentsIdMap.get(id);\r\n        if (null != count) {\r\n            count.increase();\r\n        } else {\r\n            invocationsParentsIdMap.put(id, new MutableInt(1));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.github.jamm.MemoryLayoutSpecification.sizeOfInstance",
	"Comment": "sizeofinstancewithunsafe is safe against this miscounting",
	"Method": "long sizeOfInstance(Class<?> type){\r\n    long size = SPEC.getObjectHeaderSize() + sizeOfDeclaredFields(type);\r\n    while ((type = type.getSuperclass()) != Object.class && type != null) size += roundTo(sizeOfDeclaredFields(type), SPEC.getSuperclassFieldPadding());\r\n    return roundTo(size, SPEC.getObjectPadding());\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.engine.rule.RuleOutput.hasResultTags",
	"Comment": "convenience method to check if the rule execution produced result tags.",
	"Method": "boolean hasResultTags(){\r\n    return CollectionUtils.isNotEmpty(tags);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.repository.CmrRepositoryDefinition.checkKey",
	"Comment": "check if key has changed and fire the refresh idents if necessary.",
	"Method": "void checkKey(String newKey){\r\n    boolean isRefreshIdents = false;\r\n    if (null == registrationIdKey) {\r\n        registrationIdKey = newKey;\r\n    } else {\r\n        isRefreshIdents = !// NOPMD\r\n        Objects.equals(registrationIdKey, newKey);\r\n        registrationIdKey = newKey;\r\n    }\r\n    if (isRefreshIdents) {\r\n        cachedDataService.triggerRefreshIdents();\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.instrumentation.config.impl.AbstractSensorTypeConfig.getClassName",
	"Comment": "returns the class name of the sensor type as fully qualified.",
	"Method": "String getClassName(){\r\n    return className;\r\n}"
}, {
	"Path": "org.github.jamm.GuessTest.compile",
	"Comment": "compile the provided defs by declaring them in source files and calling javac",
	"Method": "List<GeneratedClass> compile(List<Def> defs){\r\n    final List<String> args = new ArrayList<String>();\r\n    args.addAll(Arrays.asList(\"javac\", \"-d\", tempDir.getAbsolutePath()));\r\n    final List<Decl> decls = new ArrayList<Decl>();\r\n    for (Def def : defs) decls.add(def.declare());\r\n    for (Decl decl : decls) for (Decl.ClassDecl classdecl : decl.classdecls) args.add(classdecl.srcfile.getAbsolutePath());\r\n    final Process p = new ProcessBuilder(args.toArray(new String[0])).start();\r\n    final Future<String> stdout = CONSUME_PROCESS_OUTPUT.submit(new ConsumeOutput(p.getInputStream()));\r\n    final Future<String> stderr = CONSUME_PROCESS_OUTPUT.submit(new ConsumeOutput(p.getErrorStream()));\r\n    try {\r\n        p.waitFor();\r\n    } catch (InterruptedException e) {\r\n        throw new IllegalStateException();\r\n    }\r\n    final List<GeneratedClass> generated = new ArrayList<GeneratedClass>();\r\n    for (Decl decl : decls) {\r\n        Class<?> loaded = null;\r\n        for (Decl.ClassDecl classdecl : decl.classdecls) {\r\n            File trg = classdecl.binfile;\r\n            if (!trg.exists()) {\r\n                System.out.println(stdout.get());\r\n                System.err.println(stderr.get());\r\n            }\r\n            ByteArrayOutputStream buffer = new ByteArrayOutputStream();\r\n            BufferedInputStream in = new BufferedInputStream(new FileInputStream(trg));\r\n            int i;\r\n            while ((i = in.read()) >= 0) buffer.write(i);\r\n            in.close();\r\n            loaded = CL.load(classdecl.name, buffer.toByteArray());\r\n        }\r\n        generated.add(new GeneratedClass(loaded, decl.def.description()));\r\n    }\r\n    return generated;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.view.impl.DataExplorerView.showRepository",
	"Comment": "show the given repository on the view. if the selected agent is not provided, the arbitrary\tagent will be shown.",
	"Method": "void showRepository(RepositoryDefinition repositoryDefinition,PlatformIdent agent){\r\n    SafeExecutor.syncExec(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            mainForm.setBusy(true);\r\n            if ((null != displayedAgent) && (null != displayedRepositoryDefinition)) {\r\n                cacheExpandedObjects(displayedAgent, displayedRepositoryDefinition);\r\n            }\r\n            updateFormTitle();\r\n            agentsCombo.removeAll();\r\n            displayMessage(\"Loading agents for repository \" + repositoryDefinition.getName(), Display.getDefault().getSystemImage(SWT.ICON_WORKING));\r\n        }\r\n    }, mainForm, agentsCombo);\r\n    displayedRepositoryDefinition = repositoryDefinition;\r\n    PreferencesUtils.saveObject(PreferencesConstants.LAST_SELECTED_REPOSITORY, displayedRepositoryDefinition, false);\r\n    updateAvailableAgents(repositoryDefinition, new JobChangeAdapter() {\r\n        @Override\r\n        public void done(IJobChangeEvent event) {\r\n            selectAgentForDisplay(agent);\r\n            SafeExecutor.syncExec(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    StructuredSelection ss = new StructuredSelection(repositoryDefinition);\r\n                    selectionProviderAdapter.setSelection(ss);\r\n                }\r\n            });\r\n            performUpdate();\r\n        }\r\n    });\r\n    Display.getDefault().syncExec(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            mainForm.setBusy(false);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.view.impl.DataExplorerView.showRepository",
	"Comment": "show the given repository on the view. if the selected agent is not provided, the arbitrary\tagent will be shown.",
	"Method": "void showRepository(RepositoryDefinition repositoryDefinition,PlatformIdent agent){\r\n    mainForm.setBusy(true);\r\n    if ((null != displayedAgent) && (null != displayedRepositoryDefinition)) {\r\n        cacheExpandedObjects(displayedAgent, displayedRepositoryDefinition);\r\n    }\r\n    updateFormTitle();\r\n    agentsCombo.removeAll();\r\n    displayMessage(\"Loading agents for repository \" + repositoryDefinition.getName(), Display.getDefault().getSystemImage(SWT.ICON_WORKING));\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.view.impl.DataExplorerView.showRepository",
	"Comment": "show the given repository on the view. if the selected agent is not provided, the arbitrary\tagent will be shown.",
	"Method": "void showRepository(RepositoryDefinition repositoryDefinition,PlatformIdent agent){\r\n    selectAgentForDisplay(agent);\r\n    SafeExecutor.syncExec(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            StructuredSelection ss = new StructuredSelection(repositoryDefinition);\r\n            selectionProviderAdapter.setSelection(ss);\r\n        }\r\n    });\r\n    performUpdate();\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.view.impl.DataExplorerView.showRepository",
	"Comment": "show the given repository on the view. if the selected agent is not provided, the arbitrary\tagent will be shown.",
	"Method": "void showRepository(RepositoryDefinition repositoryDefinition,PlatformIdent agent){\r\n    StructuredSelection ss = new StructuredSelection(repositoryDefinition);\r\n    selectionProviderAdapter.setSelection(ss);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.view.impl.DataExplorerView.showRepository",
	"Comment": "show the given repository on the view. if the selected agent is not provided, the arbitrary\tagent will be shown.",
	"Method": "void showRepository(RepositoryDefinition repositoryDefinition,PlatformIdent agent){\r\n    mainForm.setBusy(false);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.Server.newConnection",
	"Comment": "allows the connections used by the server to be subclassed. this can be useful for storage\tper connection without an additional lookup.",
	"Method": "Connection newConnection(){\r\n    return new Connection(streamProvider);\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Date.sameMonthAs",
	"Comment": "determines if this date and the specified date represent the same month,eg both dates are for the march.",
	"Method": "boolean sameMonthAs(Date as){\r\n    return sameAs(as, DateTimeFieldType.monthOfYear());\r\n}"
}, {
	"Path": "org.apache.isis.applib.layout.grid.bootstrap3.BS3Tab.getOwner",
	"Comment": "owner.set programmatically by framework after reading in from xml.",
	"Method": "BS3TabOwner getOwner(){\r\n    return owner;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.root.AbstractRootEditor.handlePostSelectionChanged",
	"Comment": "handles a post selection changed even from the active sub view.",
	"Method": "void handlePostSelectionChanged(SelectionChangedEvent event){\r\n    ISelectionProvider provider = getSite().getSelectionProvider();\r\n    if (provider instanceof MultiSubViewSelectionProvider) {\r\n        SelectionChangedEvent newEvent = new SelectionChangedEvent(provider, event.getSelection());\r\n        MultiSubViewSelectionProvider prov = (MultiSubViewSelectionProvider) provider;\r\n        prov.firePostSelectionChanged(newEvent);\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.layout.DeweyOrderSet.getSortedSet",
	"Comment": "gets the sortedset with the specified group from the supplied map ofsortedsets.if there is no such sortedset, creates.",
	"Method": "SortedSet<IdentifiedHolder> getSortedSet(SortedMap<String, SortedSet<IdentifiedHolder>> sortedMembersByGroup,String groupName){\r\n    SortedSet<IdentifiedHolder> sortedMembersForGroup = sortedMembersByGroup.get(groupName);\r\n    if (sortedMembersForGroup == null) {\r\n        sortedMembersForGroup = new TreeSet<IdentifiedHolder>(new MemberOrderComparator(true));\r\n        sortedMembersByGroup.put(groupName, sortedMembersForGroup);\r\n    }\r\n    return sortedMembersForGroup;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.DefaultData.getObjectSize",
	"Comment": "returns the approximate size of the object in the memory in bytes.\tthis method needs to be overridden by all subclasses.",
	"Method": "long getObjectSize(IObjectSizes objectSizes,long getObjectSize,IObjectSizes objectSizes,boolean doAlign){\r\n    long size = objectSizes.getSizeOfObjectHeader();\r\n    size += objectSizes.getPrimitiveTypesSize(1, 0, 0, 0, 3, 0);\r\n    size += objectSizes.getSizeOf(timeStamp);\r\n    if (doAlign) {\r\n        return objectSizes.alignTo8Bytes(size);\r\n    } else {\r\n        return size;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.repository.service.storage.AbstractStorageService.cacheQueryResultOnCmr",
	"Comment": "caches result set on the cmr for the given storage under given hash.",
	"Method": "void cacheQueryResultOnCmr(CmrRepositoryDefinition cmrRepositoryDefinition,StorageData storageData,List<E> results,int hash){\r\n    try {\r\n        cmrRepositoryDefinition.getStorageService().cacheStorageData(storageData, results, hash);\r\n    } catch (BusinessException e) {\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.AgentMappingPart.updateButtonsState",
	"Comment": "updates the state of the remove button depending on the current table selection.",
	"Method": "void updateButtonsState(){\r\n    StructuredSelection structuredSelection = (StructuredSelection) tableViewer.getSelection();\r\n    if (structuredSelection.isEmpty()) {\r\n        removeButton.setEnabled(false);\r\n        editButton.setEnabled(false);\r\n        moveUpButton.setEnabled(false);\r\n        moveDownButton.setEnabled(false);\r\n    } else {\r\n        removeButton.setEnabled(true);\r\n        editButton.setEnabled(structuredSelection.size() == 1);\r\n        moveUpButton.setEnabled(structuredSelection.size() == 1 && !selectionIsAtTheTopOfTheList(structuredSelection));\r\n        moveDownButton.setEnabled(structuredSelection.size() == 1 && !selectionIsAtTheBottomOfTheList(structuredSelection));\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.properties.validating.PropertyValidateFacetNone.invalidReason",
	"Comment": "returns null, ie property is valid.subclasses should override as required.",
	"Method": "String invalidReason(ObjectAdapter inObject,ObjectAdapter value){\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.TimerData.isExclusiveTimeDataAvailable",
	"Comment": "whether or not this timer data contains exclusive time metrics.",
	"Method": "boolean isExclusiveTimeDataAvailable(){\r\n    return exclusiveMin != -1;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.AgentFolderFactory.getAgentFolderTree",
	"Comment": "returns the list of components representing the input tree structure of agents divided if\tneeded to folders.",
	"Method": "List<Component> getAgentFolderTree(Map<PlatformIdent, AgentStatusData> platformIdentMap,CmrRepositoryDefinition cmrRepositoryDefinition){\r\n    Composite dummy = new Composite();\r\n    for (Entry<PlatformIdent, AgentStatusData> entry : platformIdentMap.entrySet()) {\r\n        PlatformIdent platformIdent = entry.getKey();\r\n        AgentStatusData agentStatusData = entry.getValue();\r\n        addToFolder(dummy, 0, platformIdent, agentStatusData, cmrRepositoryDefinition);\r\n    }\r\n    return dummy.getChildren();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.jaxb.JAXBTransformator.unmarshall",
	"Comment": "unmarshalls the bytes. the root class of the xml must be given.\tno migration will be tried if schema validation fails.",
	"Method": "T unmarshall(Path path,Path schemaPath,Class<T> rootClass,T unmarshall,Path path,Path schemaPath,int targetSchemaVersion,Path migrationPath,Class<T> rootClass,T unmarshall,byte[] data,Path schemaPath,Class<T> rootClass,T unmarshall,byte[] data,Path schemaPath,int targetSchemaVersion,Path migrationPath,Class<T> rootClass){\r\n    InputStream inputStream = null;\r\n    boolean migrated = false;\r\n    if (null != migrationPath) {\r\n        try (InputStream xmlInputStream = new ByteArrayInputStream(data)) {\r\n            int schemaVersion = getSchemaVersion(xmlInputStream, 0);\r\n            if (schemaVersion < targetSchemaVersion) {\r\n                try {\r\n                    LOG.info(\"|- Migrating data bytes from schema version \" + schemaVersion + \" to \" + targetSchemaVersion);\r\n                    inputStream = migrate(new ByteArrayInputStream(data), migrationPath, schemaVersion, targetSchemaVersion);\r\n                    migrated = (null != inputStream);\r\n                } catch (TransformerException e) {\r\n                    throw new JAXBException(\"Failed to migrate data bytes\", e);\r\n                }\r\n            } else if (schemaVersion > targetSchemaVersion) {\r\n                LOG.warn(\"|- Migration of data bytes is not possible. Current schema version \" + schemaVersion + \" is higher than migration target version \" + targetSchemaVersion);\r\n            }\r\n        }\r\n    }\r\n    if (null == inputStream) {\r\n        inputStream = new ByteArrayInputStream(data);\r\n    }\r\n    Unmarshaller unmarshaller = getUnmarshaller(schemaPath, rootClass);\r\n    try {\r\n        T object = (T) unmarshaller.unmarshal(inputStream);\r\n        if (migrated && (object instanceof ISchemaVersionAware)) {\r\n            ((ISchemaVersionAware) object).setSchemaVersion(targetSchemaVersion);\r\n        }\r\n        return object;\r\n    } finally {\r\n        inputStream.close();\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.business.rules.AbstractRuleEditingElement.initialize",
	"Comment": "initializes the content of the controls comprised in this editing element.",
	"Method": "void initialize(){\r\n    notificationActive = false;\r\n    executeSpecificInitialization(expression);\r\n    createControlValidators();\r\n    notificationActive = true;\r\n    validationManager.performInitialValidation();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.InvocationAwareData.aggregateInvocationAwareData",
	"Comment": "aggregates the data correlated to the invocation parents. note that this method has to be\tcalled from the subclasses when they implement any kind of aggregation.",
	"Method": "void aggregateInvocationAwareData(InvocationAwareData invocationAwareData){\r\n    if (null != invocationAwareData.getInvocationsParentsIdMap()) {\r\n        if (null == invocationsParentsIdMap) {\r\n            invocationsParentsIdMap = new HashMap<Long, MutableInt>();\r\n        }\r\n        for (Map.Entry<Long, MutableInt> entry : invocationAwareData.getInvocationsParentsIdMap().entrySet()) {\r\n            MutableInt count = invocationsParentsIdMap.get(entry.getKey());\r\n            if (null != count) {\r\n                count.add(entry.getValue().getValue());\r\n            } else {\r\n                invocationsParentsIdMap.put(entry.getKey(), new MutableInt(entry.getValue().getValue()));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.property.PropertyPreferencePage.getPropertyUpdates",
	"Comment": "returns all valid property updates on this page. note that this method will return empty\tcollection if the page is not valid.",
	"Method": "Collection<IPropertyUpdate<?>> getPropertyUpdates(){\r\n    if (isValid()) {\r\n        return correctUpdateMap.values();\r\n    } else {\r\n        return Collections.emptySet();\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.storage.nio.stream.ExtendedByteBufferOutputStream.getTotalWriteSize",
	"Comment": "returns the total writing size including the size that is currently available in the\tbytebuffer that is currently used for write.",
	"Method": "long getTotalWriteSize(){\r\n    long size = totalWriteSize;\r\n    ByteBuffer byteBuffer = super.getByteBuffer();\r\n    if (null != byteBuffer) {\r\n        size += byteBuffer.position();\r\n    }\r\n    return size;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.ThreadInformationData.addTotalStartedThreadCount",
	"Comment": "increase the total number of started threads by the given value.",
	"Method": "void addTotalStartedThreadCount(long totalStartedThreadCount){\r\n    this.totalTotalStartedThreadCount += totalStartedThreadCount;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.InspectIT.getImage",
	"Comment": "returns an image from the image registry by resolving the passed image key.\timages retrieved by this method should not be disposed, because they are shared resources\tin the plugin and will be disposed with the disposal of the display.",
	"Method": "Image getImage(String imageKey){\r\n    return getImageRegistry().get(imageKey);\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.model.models.WicketComponentUtils.getFrom",
	"Comment": "locates a component implementing the required class on the supplied page.",
	"Method": "T getFrom(Component component,Class<T> cls,T getFrom,Page page,Class<T> cls){\r\n    final Object[] pComponent = new Object[1];\r\n    page.visitChildren(new DeepChildFirstVisitor() {\r\n        @Override\r\n        public void component(Component component, IVisit<Void> visit) {\r\n            if (cls.isAssignableFrom(component.getClass())) {\r\n                pComponent[0] = component;\r\n                visit.stop();\r\n            }\r\n        }\r\n        @Override\r\n        public boolean preCheck(Component component) {\r\n            return false;\r\n        }\r\n    });\r\n    return (T) pComponent[0];\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.model.models.WicketComponentUtils.getFrom",
	"Comment": "locates a component implementing the required class on the supplied page.",
	"Method": "T getFrom(Component component,Class<T> cls,T getFrom,Page page,Class<T> cls){\r\n    if (cls.isAssignableFrom(component.getClass())) {\r\n        pComponent[0] = component;\r\n        visit.stop();\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.model.models.WicketComponentUtils.getFrom",
	"Comment": "locates a component implementing the required class on the supplied page.",
	"Method": "T getFrom(Component component,Class<T> cls,T getFrom,Page page,Class<T> cls){\r\n    return false;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.TextFormatter.getDescriptiveReference",
	"Comment": "returns descriptive reference for a span if one is provided.",
	"Method": "String getDescriptiveReference(Span span){\r\n    String referenceType = span.getReferenceType();\r\n    if (References.CHILD_OF.equals(referenceType)) {\r\n        return \"Synchronous\";\r\n    } else if (References.FOLLOWS_FROM.equals(referenceType)) {\r\n        return \"Non-Synchronous\";\r\n    }\r\n    return \"N/A\";\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.editor.AbstractConfigurationInterfaceFormEditor.getInvalidForms",
	"Comment": "returns the pages that contain at least one part that is not valid.",
	"Method": "Collection<IManagedForm> getInvalidForms(){\r\n    if (pages != null) {\r\n        List<IManagedForm> invalidForms = new ArrayList();\r\n        for (int i = 0; i < pages.size(); i++) {\r\n            Object page = pages.get(i);\r\n            if (page instanceof IFormPage) {\r\n                IFormPage formPage = (IFormPage) page;\r\n                IManagedForm managedForm = formPage.getManagedForm();\r\n                if ((null != managedForm) && (managedForm.getForm().getMessageType() == IMessageProvider.ERROR)) {\r\n                    invalidForms.add(managedForm);\r\n                }\r\n            }\r\n        }\r\n        return invalidForms;\r\n    }\r\n    return Collections.emptyList();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.processor.impl.InvocationExtractorDataProcessor.extractDataFromInvocation",
	"Comment": "extract data from the invocation and return it to the storage writer to process it.",
	"Method": "void extractDataFromInvocation(InvocationSequenceData invocation){\r\n    if (null != invocation.getTimerData()) {\r\n        passToChainedProcessors(invocation.getTimerData());\r\n    }\r\n    if (null != invocation.getSqlStatementData()) {\r\n        passToChainedProcessors(invocation.getSqlStatementData());\r\n    }\r\n    if (null != invocation.getExceptionSensorDataObjects()) {\r\n        for (ExceptionSensorData exceptionSensorData : invocation.getExceptionSensorDataObjects()) {\r\n            if (exceptionSensorData.getExceptionEvent() == ExceptionEvent.CREATED) {\r\n                passToChainedProcessors(exceptionSensorData);\r\n            }\r\n        }\r\n    }\r\n    for (InvocationSequenceData child : invocation.getNestedSequences()) {\r\n        extractDataFromInvocation(child);\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.applib.services.exceprecog.ExceptionRecognizerAbstract.prefix",
	"Comment": "convenience for subclass implementations that always prefixes the exception messagewith the supplied text",
	"Method": "Function<String, String> prefix(String prefix){\r\n    return new Function<String, String>() {\r\n        @Override\r\n        public String apply(String input) {\r\n            return prefix + \": \" + input;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.apache.isis.applib.services.exceprecog.ExceptionRecognizerAbstract.prefix",
	"Comment": "convenience for subclass implementations that always prefixes the exception messagewith the supplied text",
	"Method": "Function<String, String> prefix(String prefix){\r\n    return prefix + \": \" + input;\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.DateTime.isLessThan",
	"Comment": "returns true if the timestamp of this object is earlier than thespecified timestamp",
	"Method": "boolean isLessThan(DateTime timeStamp){\r\n    return dateTime.isBefore((timeStamp).dateTime);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.communication.data.InvocationSequenceDataHelper.hasHttpTimerData",
	"Comment": "checks whether this data object contains a http timer data object.",
	"Method": "boolean hasHttpTimerData(InvocationSequenceData data){\r\n    return data.getTimerData() instanceof HttpTimerData;\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.service.DiagnosisService.init",
	"Comment": "initialization of the diagnosisservice and diagnosisengine.",
	"Method": "boolean init(){\r\n    Set<Class<?>> ruleClasses = readDiagnosisRuleClasses();\r\n    if (ruleClasses.isEmpty()) {\r\n        if (LOG.isInfoEnabled()) {\r\n            LOG.info(\"|-Diagnosis Service inactive as no rules are found in \" + rulesPackages);\r\n        }\r\n        return false;\r\n    } else {\r\n        DiagnosisEngineConfiguration<InvocationSequenceData, List<ProblemOccurrence>> configuration = new DiagnosisEngineConfiguration<InvocationSequenceData, List<ProblemOccurrence>>();\r\n        configuration.setNumSessionWorkers(numberOfSessionWorker);\r\n        configuration.addRuleClasses(ruleClasses);\r\n        configuration.setResultCollector(new ProblemOccurrenceResultCollector());\r\n        configuration.addSessionCallback(new DelegatingResultHandler());\r\n        try {\r\n            engine = new DiagnosisEngine(configuration);\r\n        } catch (DiagnosisEngineException e) {\r\n            LOG.info(\"DiagnosisEngine could not be initialized.\");\r\n            return false;\r\n        }\r\n        diagnosisServiceExecutor.execute(this);\r\n        if (LOG.isInfoEnabled()) {\r\n            LOG.info(\"|-Diagnosis Service active...\");\r\n        }\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.core.integtestsupport.scenarios.ScenarioExecutionForIntegration.endTran",
	"Comment": "for cucumber hooks to call, performing transaction management around each step.",
	"Method": "void endTran(boolean ok){\r\n    if (ok) {\r\n        isft.commitTran();\r\n    } else {\r\n        isft.abortTran();\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.object.defaults.DefaultedFacetAbstract.isValid",
	"Comment": "discover whether either of the candidate defaults provider name or classis valid.",
	"Method": "boolean isValid(){\r\n    return defaultsProviderClass != null;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.nio.CustomAsyncChannel.write",
	"Comment": "writes to the file channel if the channel is open. if the channel is closed, the write will\tnot be done, and false will be returned.",
	"Method": "boolean write(ByteBuffer src,long position,A attachment,CompletionHandler<Integer, ? super A> handler){\r\n    writeReadChannelLock.lock();\r\n    try {\r\n        if (this.isOpened()) {\r\n            fileChannel.write(src, position, attachment, handler);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } finally {\r\n        writeReadChannelLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.engine.util.ReflectionUtils.hasNoArgsConstructor",
	"Comment": "checks if a class provides a public constructor without any arguments.",
	"Method": "boolean hasNoArgsConstructor(Class<?> clazz){\r\n    for (Constructor<?> constructor : clazz.getDeclaredConstructors()) {\r\n        if (Modifier.isPublic(constructor.getModifiers()) && (constructor.getParameterTypes().length == 0)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.model.models.ActionModel.execute",
	"Comment": "simply executes the action.previously there was exception handling code here also, but this has now been centralizedwithin formexecutorabstract",
	"Method": "ObjectAdapter execute(){\r\n    final ObjectAdapter resultAdapter = this.getObject();\r\n    return resultAdapter;\r\n}"
}, {
	"Path": "org.apache.isis.applib.layout.component.CollectionLayoutData.getOwner",
	"Comment": "owner.set programmatically by framework after reading in from xml.",
	"Method": "CollectionLayoutDataOwner getOwner(){\r\n    return owner;\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.viewer.IsisWicketApplication.get",
	"Comment": "convenience locator, downcasts inherited functionality.",
	"Method": "IsisWicketApplication get(){\r\n    return (IsisWicketApplication) AuthenticatedWebApplication.get();\r\n}"
}, {
	"Path": "org.apache.isis.viewer.restfulobjects.rendering.domainobjects.AbstractObjectMemberReprRenderer.linkToForMutatorInvoke",
	"Comment": "hook to allow actions to render invoke links that point to thecontributing service.",
	"Method": "ObjectAdapterLinkTo linkToForMutatorInvoke(){\r\n    return linkTo;\r\n}"
}, {
	"Path": "org.apache.isis.applib.services.eventbus.IconUiEvent.setIconName",
	"Comment": "for subscribers to call to provide an icon name for this object.",
	"Method": "void setIconName(String iconName){\r\n    this.iconName = iconName;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.property.PropertyPreferencePage.createSinglePropertyContents",
	"Comment": "creates one line of widgets in the page for displaying a single property.",
	"Method": "void createSinglePropertyContents(SingleProperty<?> property,Composite parent){\r\n    AbstractPropertyControl<?, ?> propertyControl = AbstractPropertyControl.createFor(property, this);\r\n    propertyControl.create(parent);\r\n    propertyControls.add(propertyControl);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.ci.strategy.impl.DisruptorStrategyConfig.checkPowerOfTwo",
	"Comment": "checks if the given number is power of two and if not returns the next power of two number\tthat is bigger than given number.",
	"Method": "int checkPowerOfTwo(int number,int nonPositiveDefault){\r\n    if (number <= 0) {\r\n        return nonPositiveDefault;\r\n    } else if ((number & (number - 1)) == 0) {\r\n        return number;\r\n    } else {\r\n        return (int) Math.pow(2, Math.ceil(Math.log(number) / Math.log(2)));\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Time.add",
	"Comment": "add the specified hours and minutes to this time value, returned as a newtime object.",
	"Method": "Time add(int hours,int minutes){\r\n    final Period period = new Period(hours, minutes, 0, 0);\r\n    return new Time(time.plus(period));\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.CpuInformationData.updateProcessCpuTime",
	"Comment": "sets the process cpu time if it is higher than the current cpu time.",
	"Method": "void updateProcessCpuTime(long actualProcessCpuTime){\r\n    if (actualProcessCpuTime > processCpuTime) {\r\n        processCpuTime = actualProcessCpuTime;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.Modifier.isSynchronized",
	"Comment": "returns true if the modifiers include the synchronized modifier.",
	"Method": "boolean isSynchronized(int mod){\r\n    return (mod & SYNCHRONIZED) != 0;\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.viewer.IsisWicketApplication.isWicketSourcePluginEnabled",
	"Comment": "whether the wicket source plugin should be enabled, as specified by configuration settings.if the isis.viewer.wicket.wicketsourceplugin is set, then this is used, otherwise the default is to disable.",
	"Method": "boolean isWicketSourcePluginEnabled(IsisConfiguration configuration){\r\n    final boolean pluginEnabled = configuration.getBoolean(WICKET_SOURCE_PLUGIN_KEY, WICKET_SOURCE_PLUGIN_DEFAULT);\r\n    return pluginEnabled;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.table.input.AbstractTableInputController.getMappedTableViewerColumn",
	"Comment": "returns the column that has been mapped with the given enum key. enum should represent the\twanted column.",
	"Method": "TableViewerColumn getMappedTableViewerColumn(Enum<?> key){\r\n    return tableViewerColumnMap.get(key);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.restriction.impl.CachingIndexQueryRestrictionProcessor.getMethodCacheKey",
	"Comment": "returns key for the hash map based on the supplied class and method name.",
	"Method": "int getMethodCacheKey(Class<?> clazz,String methodName){\r\n    final int prime = 31;\r\n    int result = 0;\r\n    result = (prime * result) + ((clazz == null) ? 0 : clazz.hashCode());\r\n    result = (prime * result) + ((methodName == null) ? 0 : methodName.hashCode());\r\n    return result;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.handler.InstrumentationUpdateHandler.getPendingAgents",
	"Comment": "fetches the existing agents from the cmr and extracts the ones which instrumentation status\tis pending.",
	"Method": "Map<PlatformIdent, AgentStatusData> getPendingAgents(CmrRepositoryDefinition repositoryDefinition){\r\n    ProgressDialog<Map<PlatformIdent, AgentStatusData>> dialog = new ProgressDialog<Map<PlatformIdent, AgentStatusData>>(\"Fetching status of agents..\", IProgressMonitor.UNKNOWN) {\r\n        @Override\r\n        public Map<PlatformIdent, AgentStatusData> execute(IProgressMonitor monitor) throws BusinessException {\r\n            return repositoryDefinition.getGlobalDataAccessService().getAgentsOverview();\r\n        }\r\n    };\r\n    dialog.start(true, false);\r\n    if (!dialog.wasSuccessful()) {\r\n        InspectIT.getDefault().createErrorDialog(\"Unexpected exception occurred during an attempt to fetch agent status.\", dialog.getThrownException(), -1);\r\n        return null;\r\n    }\r\n    Map<PlatformIdent, AgentStatusData> agentsOverview = dialog.getResult();\r\n    Map<PlatformIdent, AgentStatusData> resultMap = new HashMap();\r\n    for (Entry<PlatformIdent, AgentStatusData> entry : agentsOverview.entrySet()) {\r\n        AgentStatusData agentStatus = entry.getValue();\r\n        if ((agentStatus.getAgentConnection() == AgentConnection.CONNECTED) && (agentStatus.getInstrumentationStatus() == InstrumentationStatus.PENDING)) {\r\n            resultMap.put(entry.getKey(), entry.getValue());\r\n        }\r\n    }\r\n    return resultMap;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.handler.InstrumentationUpdateHandler.getPendingAgents",
	"Comment": "fetches the existing agents from the cmr and extracts the ones which instrumentation status\tis pending.",
	"Method": "Map<PlatformIdent, AgentStatusData> getPendingAgents(CmrRepositoryDefinition repositoryDefinition){\r\n    return repositoryDefinition.getGlobalDataAccessService().getAgentsOverview();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.ci.business.impl.BusinessTransactionDefinition.dynamicNameExtractionActive",
	"Comment": "indicates whether the name of the business transaction shell be extracted dynamically from\tthe measurement data.",
	"Method": "boolean dynamicNameExtractionActive(){\r\n    return null != getNameExtractionExpression();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.StorageManager.zipStorageData",
	"Comment": "compresses the content of the storage data folder to the file. file name is provided via\tgiven path. if the file already exists, it will be deleted first.",
	"Method": "void zipStorageData(IStorageData storageData,Path zipPath){\r\n    final Path storageDir = getStoragePath(storageData);\r\n    this.zipFiles(storageDir, zipPath);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.business.DynamicNameExtractionPart.createNamePatternSection",
	"Comment": "creates control section for specification of the name pattern.",
	"Method": "void createNamePatternSection(){\r\n    createSectionHeading(\"Name Pattern Specification\");\r\n    useStringValueAsNameRadioButton = toolkit.createButton(mainComposite, \"Use string value as name\", SWT.RADIO);\r\n    useStringValueAsNameRadioButton.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, true, false, NUM_COLUMNS - 1, 1));\r\n    useStringValueAsNameRadioButton.setSelection(true);\r\n    useStringValueAsNameRadioButton.addSelectionListener(new SelectionAdapter() {\r\n        @Override\r\n        public void widgetSelected(SelectionEvent e) {\r\n            if (useStringValueAsNameRadioButton.getSelection() && !useDefaultPattern) {\r\n                resetNamePatternSection();\r\n                if (!initializationPhase) {\r\n                    markDirty();\r\n                }\r\n                mainComposite.layout(true, true);\r\n            }\r\n        }\r\n    });\r\n    addControl(useStringValueAsNameRadioButton);\r\n    Label useStringValueAsNameLabelInfoImage = toolkit.createLabel(mainComposite, DESCRIPTION_STRING_VALUE_AS_NAME);\r\n    useStringValueAsNameLabelInfoImage.setImage(InspectIT.getDefault().getImage(InspectITImages.IMG_INFORMATION));\r\n    useStringValueAsNameLabelInfoImage.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));\r\n    useStringValueAsNameLabelInfoImage.setToolTipText(DESCRIPTION_STRING_VALUE_AS_NAME);\r\n    useRegexForNameRadioButton = toolkit.createButton(mainComposite, \"Specify name pattern\", SWT.RADIO);\r\n    useRegexForNameRadioButton.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, true, false, NUM_COLUMNS - 1, 1));\r\n    useRegexForNameRadioButton.setSelection(false);\r\n    addControl(useRegexForNameRadioButton);\r\n    final Label useRegexForNameLabelInfoImage = toolkit.createLabel(mainComposite, DESCRIPTION_REGEX_FOR_NAME);\r\n    useRegexForNameLabelInfoImage.setImage(InspectIT.getDefault().getImage(InspectITImages.IMG_INFORMATION));\r\n    useRegexForNameLabelInfoImage.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));\r\n    useRegexForNameLabelInfoImage.setToolTipText(DESCRIPTION_REGEX_FOR_NAME);\r\n    moveBelowForNamePatternControls = useRegexForNameLabelInfoImage;\r\n    useRegexForNameRadioButton.addSelectionListener(new SelectionAdapter() {\r\n        @Override\r\n        public void widgetSelected(SelectionEvent e) {\r\n            if (useRegexForNameRadioButton.getSelection() && useDefaultPattern) {\r\n                createNamePatternControls();\r\n                if (!initializationPhase) {\r\n                    markDirty();\r\n                }\r\n                mainComposite.layout(true, true);\r\n                useDefaultPattern = false;\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.business.DynamicNameExtractionPart.createNamePatternSection",
	"Comment": "creates control section for specification of the name pattern.",
	"Method": "void createNamePatternSection(){\r\n    if (useStringValueAsNameRadioButton.getSelection() && !useDefaultPattern) {\r\n        resetNamePatternSection();\r\n        if (!initializationPhase) {\r\n            markDirty();\r\n        }\r\n        mainComposite.layout(true, true);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.business.DynamicNameExtractionPart.createNamePatternSection",
	"Comment": "creates control section for specification of the name pattern.",
	"Method": "void createNamePatternSection(){\r\n    if (useRegexForNameRadioButton.getSelection() && useDefaultPattern) {\r\n        createNamePatternControls();\r\n        if (!initializationPhase) {\r\n            markDirty();\r\n        }\r\n        mainComposite.layout(true, true);\r\n        useDefaultPattern = false;\r\n    }\r\n}"
}, {
	"Path": "org.github.jamm.MemoryLayoutSpecification.sizeOfInstanceWithUnsafe",
	"Comment": "attemps to use sun.misc.unsafe to find the maximum object offset, this work around helps deal with long alignment",
	"Method": "long sizeOfInstanceWithUnsafe(Class<?> type){\r\n    while (type != null) {\r\n        long size = 0;\r\n        for (Field f : declaredFieldsOf(type)) size = Math.max(size, unsafe.objectFieldOffset(f) + sizeOf(f));\r\n        if (size > 0)\r\n            return roundTo(size, SPEC.getObjectPadding());\r\n        type = type.getSuperclass();\r\n    }\r\n    return roundTo(SPEC.getObjectHeaderSize(), SPEC.getObjectPadding());\r\n}"
}, {
	"Path": "org.apache.isis.applib.services.publish.EventPayloadForObjectChanged.withStringifier",
	"Comment": "injected by isis runtime immediately after instantiation.",
	"Method": "void withStringifier(ObjectStringifier stringifier){\r\n    this.stringifier = stringifier;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.cmr.property.configuration.Configuration.validate",
	"Comment": "validates all properties in this configuration returning the map of containing the properties\tthat have validation errors.",
	"Method": "Map<AbstractProperty, PropertyValidation> validate(){\r\n    Map<AbstractProperty, PropertyValidation> validationMap = new HashMap();\r\n    for (AbstractProperty property : getAllProperties()) {\r\n        PropertyValidation propertyValidation = property.validate();\r\n        if (propertyValidation.hasErrors()) {\r\n            validationMap.put(property, propertyValidation);\r\n        }\r\n    }\r\n    return validationMap;\r\n}"
}, {
	"Path": "org.apache.isis.core.commons.lang.InputStreamExtensions.copyTo",
	"Comment": "copy bytes from an inputstream to anoutputstream.this method buffers the input internally, so there is no need to use abufferedinputstream.",
	"Method": "int copyTo(InputStream extendee,OutputStream output){\r\n    if (extendee == null) {\r\n        throw new IllegalArgumentException(\"InputStream cannot be null\");\r\n    }\r\n    if (output == null) {\r\n        throw new IllegalArgumentException(\"OutputStream cannot be null\");\r\n    }\r\n    final byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];\r\n    int count = 0;\r\n    int n = 0;\r\n    while (-1 != (n = extendee.read(buffer))) {\r\n        output.write(buffer, 0, n);\r\n        count += n;\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.ci.business.impl.ApplicationDefinition.getId",
	"Comment": "returns the unique identifier of this application definition.",
	"Method": "int getId(){\r\n    return id;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.tree.DeferredTreeViewer.createObjectList",
	"Comment": "constructs the list of elements that need to be expanded, so that object supplied can be\tvisible.",
	"Method": "List<Object> createObjectList(Object object,List<Object> objectList){\r\n    if (object == null) {\r\n        return objectList;\r\n    }\r\n    if (areFiltersPassed(object) && !getExpandedState(object)) {\r\n        if (childrenLoaded(object)) {\r\n            expandToLevel(object, 1);\r\n        } else {\r\n            if (objectList == null) {\r\n                objectList = new ArrayList();\r\n            }\r\n            objectList.add(object);\r\n        }\r\n    }\r\n    Object parent = getParentElement(object);\r\n    if (null != parent) {\r\n        createObjectList(parent, objectList);\r\n    }\r\n    return objectList;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.tree.DeferredTreeViewer.isRootElement",
	"Comment": "checks if the given element is one of the root object in the input list of the tree viewer.",
	"Method": "boolean isRootElement(Object element){\r\n    Object input = getRoot();\r\n    Object[] rootElemens = ((ITreeContentProvider) getContentProvider()).getElements(input);\r\n    return ArrayUtils.contains(rootElemens, element);\r\n}"
}, {
	"Path": "org.apache.isis.core.commons.exceptions.ExceptionUtils.getCauseUsingWellKnownTypes",
	"Comment": "finds a throwable for known types.uses instanceof checks to examine the exception,looking for well known types which could contain chained orwrapped exceptions.",
	"Method": "Throwable getCauseUsingWellKnownTypes(Throwable throwable){\r\n    if (throwable instanceof SQLException) {\r\n        return ((SQLException) throwable).getNextException();\r\n    }\r\n    if (throwable instanceof InvocationTargetException) {\r\n        return ((InvocationTargetException) throwable).getTargetException();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.param.defaults.fromtype.ActionParameterDefaultFacetDerivedFromTypeFacets.getDefaults",
	"Comment": "return the defaults.note that we get the defaults fresh each time in case the defaults mightconceivably change.",
	"Method": "Object[] getDefaults(ObjectAdapter inObject){\r\n    final Object[] defaults = new Object[defaultedFacets.length];\r\n    for (int i = 0; i < defaults.length; i++) {\r\n        if (defaultedFacets[i] != null) {\r\n            defaults[i] = defaultedFacets[i].getDefault();\r\n        }\r\n    }\r\n    return defaults;\r\n}"
}, {
	"Path": "org.apache.isis.core.specsupport.scenarios.ScenarioExecution.service",
	"Comment": "returns a domain service of the specified type, ensuring thatit is available.",
	"Method": "T service(Class<T> cls){\r\n    final T service = dsp.getService(cls);\r\n    if (service == null) {\r\n        throw new IllegalStateException(\"No service of type \" + cls.getSimpleName() + \" available\");\r\n    }\r\n    return service;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.Connection.getRemoteAddressTCP",
	"Comment": "returns the ip address and port of the remote end of the tcp connection, or null if this\tconnection is not connected.",
	"Method": "InetSocketAddress getRemoteAddressTCP(){\r\n    SocketChannel socketChannel = tcp.socketChannel;\r\n    if (socketChannel != null) {\r\n        Socket socket = tcp.socketChannel.socket();\r\n        if (socket != null) {\r\n            return (InetSocketAddress) socket.getRemoteSocketAddress();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.wizard.page.NameDescriptionInsertBeforeWizardPage.alreadyExists",
	"Comment": "indicates whether an element with such a name already exists.",
	"Method": "boolean alreadyExists(String name){\r\n    for (String item : existingItems) {\r\n        if (item.equals(name)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.StorageWriter.writeNonDefaultDataObject",
	"Comment": "writes any object to the file with given file name. note that this will be a synchronus\twrite.",
	"Method": "boolean writeNonDefaultDataObject(Object object,String fileName){\r\n    try {\r\n        ISerializer serializer = null;\r\n        try {\r\n            serializer = serializerQueue.take();\r\n        } catch (InterruptedException e1) {\r\n            Thread.interrupted();\r\n        }\r\n        if (null == serializer) {\r\n            log.error(\"Serializer instance could not be obtained.\");\r\n            return false;\r\n        }\r\n        Path path = writingFolderPath.resolve(fileName);\r\n        if (Files.exists(path)) {\r\n            try {\r\n                Files.delete(path);\r\n            } catch (IOException e) {\r\n                log.error(\"Exception thrown trying to delete file from disk\", e);\r\n                return false;\r\n            }\r\n        }\r\n        try (OutputStream outputStream = Files.newOutputStream(path, StandardOpenOption.CREATE_NEW)) {\r\n            Output output = new Output(outputStream);\r\n            serializer.serialize(object, output);\r\n        } catch (SerializationException e) {\r\n            log.error(\"Serialization for the object \" + object + \" failed. Data will be skipped.\", e);\r\n            return false;\r\n        } finally {\r\n            serializerQueue.add(serializer);\r\n        }\r\n        return true;\r\n    } catch (Throwable throwable) {\r\n        log.error(\"Exception occurred while attempting to write data to disk\", throwable);\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.Connection.getTcpWriteBufferSize",
	"Comment": "returns the number of bytes that are waiting to be written to the tcp socket, if any.",
	"Method": "int getTcpWriteBufferSize(){\r\n    return tcp.writeBuffer.position();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.ci.assignment.impl.JmxBeanSensorAssignment.constructObjectName",
	"Comment": "constructs the object name from the current input in the assignment.",
	"Method": "ObjectName constructObjectName(){\r\n    if (MapUtils.isNotEmpty(objectNameParameters)) {\r\n        StringBuilder nameString = new StringBuilder(domain);\r\n        nameString.append(':');\r\n        Iterator<Entry<String, String>> it = objectNameParameters.entrySet().iterator();\r\n        while (it.hasNext()) {\r\n            Entry<String, String> next = it.next();\r\n            nameString.append(next.getKey());\r\n            nameString.append('=');\r\n            nameString.append(next.getValue());\r\n            if (it.hasNext()) {\r\n                nameString.append(',');\r\n            }\r\n        }\r\n        try {\r\n            return new ObjectName(nameString.toString());\r\n        } catch (MalformedObjectNameException e) {\r\n            return null;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.Server.update",
	"Comment": "accepts any new connections and reads or writes any pending data for the current connections.",
	"Method": "void update(int timeout){\r\n    updateThread = Thread.currentThread();\r\n    synchronized (updateLock) {\r\n    }\r\n    long startTime = System.currentTimeMillis();\r\n    int select = selector.selectNow();\r\n    long waitUntil = System.nanoTime() + TimeUnit.MILLISECONDS.toNanos(timeout);\r\n    while ((select == 0) && (System.nanoTime() < waitUntil)) {\r\n        LockSupport.parkNanos(100000);\r\n        select = selector.selectNow();\r\n    }\r\n    if (select == 0) {\r\n        emptySelects++;\r\n        if (emptySelects == 100) {\r\n            emptySelects = 0;\r\n            long elapsedTime = System.currentTimeMillis() - startTime;\r\n            try {\r\n                if (elapsedTime < 25) {\r\n                    Thread.sleep(25 - elapsedTime);\r\n                }\r\n            } catch (InterruptedException ex) {\r\n            }\r\n        }\r\n    } else {\r\n        emptySelects = 0;\r\n        Set<SelectionKey> keys = selector.selectedKeys();\r\n        synchronized (keys) {\r\n            UdpConnection udp = this.udp;\r\n            outer: for (Iterator<SelectionKey> iter = keys.iterator(); iter.hasNext(); ) {\r\n                SelectionKey selectionKey = iter.next();\r\n                iter.remove();\r\n                Connection fromConnection = (Connection) selectionKey.attachment();\r\n                try {\r\n                    int ops = selectionKey.readyOps();\r\n                    if (fromConnection != null) {\r\n                        if ((udp != null) && (fromConnection.udpRemoteAddress == null)) {\r\n                            fromConnection.close();\r\n                            continue;\r\n                        }\r\n                        if ((ops & SelectionKey.OP_READ) == SelectionKey.OP_READ) {\r\n                            try {\r\n                                while (true) {\r\n                                    Object object = fromConnection.tcp.readObject(fromConnection);\r\n                                    if (object == null) {\r\n                                        break;\r\n                                    }\r\n                                    if (DEBUG) {\r\n                                        String objectString = object == null ? \"null\" : object.getClass().getSimpleName();\r\n                                        if (!(object instanceof FrameworkMessage)) {\r\n                                            debug(\"kryonet\", fromConnection + \" received TCP: \" + objectString);\r\n                                        } else if (TRACE) {\r\n                                            trace(\"kryonet\", fromConnection + \" received TCP: \" + objectString);\r\n                                        }\r\n                                    }\r\n                                    fromConnection.notifyReceived(object);\r\n                                }\r\n                            } catch (IOException ex) {\r\n                                if (TRACE) {\r\n                                    trace(\"kryonet\", \"Unable to read TCP from: \" + fromConnection, ex);\r\n                                } else if (DEBUG) {\r\n                                    debug(\"kryonet\", fromConnection + \" update: \" + ex.getMessage());\r\n                                }\r\n                                fromConnection.close();\r\n                            } catch (KryoNetException ex) {\r\n                                if (ERROR) {\r\n                                    error(\"kryonet\", \"Error reading TCP from connection: \" + fromConnection, ex);\r\n                                }\r\n                                fromConnection.close();\r\n                            }\r\n                        }\r\n                        if ((ops & SelectionKey.OP_WRITE) == SelectionKey.OP_WRITE) {\r\n                            try {\r\n                                fromConnection.tcp.writeOperation();\r\n                            } catch (IOException ex) {\r\n                                if (TRACE) {\r\n                                    trace(\"kryonet\", \"Unable to write TCP to connection: \" + fromConnection, ex);\r\n                                } else if (DEBUG) {\r\n                                    debug(\"kryonet\", fromConnection + \" update: \" + ex.getMessage());\r\n                                }\r\n                                fromConnection.close();\r\n                            }\r\n                        }\r\n                        continue;\r\n                    }\r\n                    if ((ops & SelectionKey.OP_ACCEPT) == SelectionKey.OP_ACCEPT) {\r\n                        ServerSocketChannel serverChannel = this.serverChannel;\r\n                        if (serverChannel == null) {\r\n                            continue;\r\n                        }\r\n                        try {\r\n                            SocketChannel socketChannel = serverChannel.accept();\r\n                            if (socketChannel != null) {\r\n                                acceptOperation(socketChannel);\r\n                            }\r\n                        } catch (IOException ex) {\r\n                            if (DEBUG) {\r\n                                debug(\"kryonet\", \"Unable to accept new connection.\", ex);\r\n                            }\r\n                        }\r\n                        continue;\r\n                    }\r\n                    if (udp == null) {\r\n                        selectionKey.channel().close();\r\n                        continue;\r\n                    }\r\n                    InetSocketAddress fromAddress;\r\n                    try {\r\n                        fromAddress = udp.readFromAddress();\r\n                    } catch (IOException ex) {\r\n                        if (WARN) {\r\n                            warn(\"kryonet\", \"Error reading UDP data.\", ex);\r\n                        }\r\n                        continue;\r\n                    }\r\n                    if (fromAddress == null) {\r\n                        continue;\r\n                    }\r\n                    Connection[] connections = this.connections;\r\n                    for (Connection connection : connections) {\r\n                        if (fromAddress.equals(connection.udpRemoteAddress)) {\r\n                            fromConnection = connection;\r\n                            break;\r\n                        }\r\n                    }\r\n                    Object object;\r\n                    try {\r\n                        object = udp.readObject(fromConnection);\r\n                    } catch (KryoNetException ex) {\r\n                        if (WARN) {\r\n                            if (fromConnection != null) {\r\n                                if (ERROR) {\r\n                                    error(\"kryonet\", \"Error reading UDP from connection: \" + fromConnection, ex);\r\n                                }\r\n                            } else {\r\n                                warn(\"kryonet\", \"Error reading UDP from unregistered address: \" + fromAddress, ex);\r\n                            }\r\n                        }\r\n                        continue;\r\n                    }\r\n                    if (object instanceof FrameworkMessage) {\r\n                        if (object instanceof RegisterUDP) {\r\n                            int fromConnectionID = ((RegisterUDP) object).connectionID;\r\n                            Connection connection = pendingConnections.remove(fromConnectionID);\r\n                            if (connection != null) {\r\n                                if (connection.udpRemoteAddress != null) {\r\n                                    continue outer;\r\n                                }\r\n                                connection.udpRemoteAddress = fromAddress;\r\n                                addConnection(connection);\r\n                                connection.sendTCP(new RegisterUDP());\r\n                                if (DEBUG) {\r\n                                    debug(\"kryonet\", \"Port \" + udp.datagramChannel.socket().getLocalPort() + \"/UDP connected to: \" + fromAddress);\r\n                                }\r\n                                connection.notifyConnected();\r\n                                continue;\r\n                            }\r\n                            if (DEBUG) {\r\n                                debug(\"kryonet\", \"Ignoring incoming RegisterUDP with invalid connection ID: \" + fromConnectionID);\r\n                            }\r\n                            continue;\r\n                        }\r\n                        if (object instanceof DiscoverHost) {\r\n                            try {\r\n                                udp.datagramChannel.send(emptyBuffer, fromAddress);\r\n                                if (DEBUG) {\r\n                                    debug(\"kryonet\", \"Responded to host discovery from: \" + fromAddress);\r\n                                }\r\n                            } catch (IOException ex) {\r\n                                if (WARN) {\r\n                                    warn(\"kryonet\", \"Error replying to host discovery from: \" + fromAddress, ex);\r\n                                }\r\n                            }\r\n                            continue;\r\n                        }\r\n                    }\r\n                    if (fromConnection != null) {\r\n                        if (DEBUG) {\r\n                            String objectString = object == null ? \"null\" : object.getClass().getSimpleName();\r\n                            if (object instanceof FrameworkMessage) {\r\n                                if (TRACE) {\r\n                                    trace(\"kryonet\", fromConnection + \" received UDP: \" + objectString);\r\n                                }\r\n                            } else {\r\n                                debug(\"kryonet\", fromConnection + \" received UDP: \" + objectString);\r\n                            }\r\n                        }\r\n                        fromConnection.notifyReceived(object);\r\n                        continue;\r\n                    }\r\n                    if (DEBUG) {\r\n                        debug(\"kryonet\", \"Ignoring UDP from unregistered address: \" + fromAddress);\r\n                    }\r\n                } catch (CancelledKeyException ex) {\r\n                    if (fromConnection != null) {\r\n                        fromConnection.close();\r\n                    } else {\r\n                        selectionKey.channel().close();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    long time = System.currentTimeMillis();\r\n    Connection[] connections = this.connections;\r\n    for (Connection connection : connections) {\r\n        if (connection.tcp.isTimedOut(time)) {\r\n            if (DEBUG) {\r\n                debug(\"kryonet\", connection + \" timed out.\");\r\n            }\r\n            connection.close();\r\n        } else {\r\n            if (connection.tcp.needsKeepAlive(time)) {\r\n                connection.sendTCP(FrameworkMessage.keepAlive);\r\n            }\r\n        }\r\n        if (connection.isIdle()) {\r\n            connection.notifyIdle();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.communication.data.InvocationSequenceDataHelper.hasTimerData",
	"Comment": "checks whether this data object contains a timer data object of some sort.",
	"Method": "boolean hasTimerData(InvocationSequenceData data){\r\n    return null != data.getTimerData();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.InvocationSequenceData.addExceptionSensorData",
	"Comment": "adds the given exception data to this invocation sequence.",
	"Method": "void addExceptionSensorData(ExceptionSensorData data){\r\n    if (null == exceptionSensorDataObjects) {\r\n        exceptionSensorDataObjects = new ArrayList<ExceptionSensorData>();\r\n    }\r\n    exceptionSensorDataObjects.add(data);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.root.AbstractRootEditor.canMinimizeActiveSubView",
	"Comment": "returns if the active sub view is currently maximized and thus can be minimized.",
	"Method": "boolean canMinimizeActiveSubView(){\r\n    return isMaximizedMode;\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.object.value.annotcfg.ValueFacetAnnotation.isValid",
	"Comment": "always valid, even if the specified semanticsprovidername might have beenwrong.",
	"Method": "boolean isValid(){\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.members.disabled.method.DisableForContextFacetNone.disables",
	"Comment": "the reason this object is disabled, or null otherwise.always returns null.",
	"Method": "String disables(UsabilityContext<? extends UsabilityEvent> ic){\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.preferences.page.CmrRepositoryPreferencePage.updateButtonsState",
	"Comment": "updates the state of the remove and license info buttons depending on the current table\tselection.",
	"Method": "void updateButtonsState(){\r\n    StructuredSelection structuredSelection = (StructuredSelection) tableViewer.getSelection();\r\n    if (structuredSelection.isEmpty()) {\r\n        removeButton.setEnabled(false);\r\n        manageLabelsButton.setEnabled(false);\r\n    } else {\r\n        removeButton.setEnabled(true);\r\n        if ((structuredSelection.size() == 1) && (((CmrRepositoryDefinition) structuredSelection.getFirstElement()).getOnlineStatus() == OnlineStatus.ONLINE)) {\r\n            manageLabelsButton.setEnabled(true);\r\n        } else {\r\n            manageLabelsButton.setEnabled(false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.NumberFormatter.humanReadableByteCount",
	"Comment": "returns the human readable bytes number with one decimal place.",
	"Method": "String humanReadableByteCount(long bytes,String humanReadableByteCount,long bytes,int decimalPlaces){\r\n    if (bytes < 1024L) {\r\n        return bytes + \" B\";\r\n    }\r\n    int sizeIndex = (int) (Math.log(bytes) / Math.log(1024D));\r\n    double value = bytes / Math.pow(1024D, sizeIndex);\r\n    return String.format(Locale.US, \"%.\" + decimalPlaces + \"f %sB\", value, BINARY_METRIC_UNITS[sizeIndex]);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.ci.BusinessContextDefinition.addApplicationDefinition",
	"Comment": "adds application definition to the business context. inserts it to the list before the\telement with the passed index.",
	"Method": "ApplicationDefinition addApplicationDefinition(ApplicationDefinition appDefinition,ApplicationDefinition addApplicationDefinition,ApplicationDefinition appDefinition,int insertBeforeIndex){\r\n    if (appDefinition == null) {\r\n        throw new BusinessException(\"Adding application 'null'.\", BusinessContextErrorCodeEnum.UNKNOWN_APPLICATION);\r\n    } else if (applicationDefinitions.contains(appDefinition)) {\r\n        throw new BusinessException(\"Adding application \" + appDefinition.getApplicationName() + \" with id \" + appDefinition.getId() + \".\", BusinessContextErrorCodeEnum.DUPLICATE_ITEM);\r\n    } else if ((insertBeforeIndex < 0) || (insertBeforeIndex > applicationDefinitions.size())) {\r\n        throw new BusinessException(\"Adding application\" + appDefinition.getApplicationName() + \" with id \" + appDefinition.getId() + \" at index \" + insertBeforeIndex + \".\", BusinessContextErrorCodeEnum.INVALID_MOVE_OPRATION);\r\n    } else {\r\n        applicationDefinitions.add(insertBeforeIndex, appDefinition);\r\n        return appDefinition;\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.core.runtime.snapshot.XsMetaModel.createXsElement",
	"Comment": "creates an element in the xs namespace, adding the definition of thenamespace to the root element of the document if required,",
	"Method": "Element createXsElement(Document xsdDoc,String localName){\r\n    final Element element = xsdDoc.createElementNS(XsMetaModel.W3_ORG_XS_URI, XsMetaModel.W3_ORG_XS_PREFIX + \":\" + localName);\r\n    helper.rootElementFor(element).setAttributeNS(XsMetaModel.W3_ORG_XMLNS_URI, XsMetaModel.W3_ORG_XMLNS_PREFIX + \":\" + XsMetaModel.W3_ORG_XS_PREFIX, XsMetaModel.W3_ORG_XS_URI);\r\n    return element;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.ci.AlertingDefinition.removeNotificationEmailAddress",
	"Comment": "removes the given email address from the alerting definition.",
	"Method": "boolean removeNotificationEmailAddress(String email){\r\n    if (email == null) {\r\n        throw new IllegalArgumentException(\"Adding email adress 'null'.\");\r\n    } else if (email.isEmpty()) {\r\n        throw new IllegalArgumentException(\"Adding empty email address.\");\r\n    } else {\r\n        return notificationEmailAddresses.remove(email);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.JmxSensorValueData.getAverageValue",
	"Comment": "calculates and returns the average value of the aggregated objects.",
	"Method": "double getAverageValue(){\r\n    if (aggregationCount <= 0) {\r\n        return getValueAsDouble();\r\n    }\r\n    return totalValue / aggregationCount;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.business.BusinessTransactionMasterBlock.deleteSelectedBusinessTransactions",
	"Comment": "deletes selected business transaction definitions from the table.",
	"Method": "void deleteSelectedBusinessTransactions(){\r\n    ISelection selection = tableViewer.getSelection();\r\n    if ((selection instanceof StructuredSelection) && !selection.isEmpty()) {\r\n        boolean itemsDeleted = false;\r\n        for (Object selectedElement : ((StructuredSelection) selection).toList()) {\r\n            BusinessTransactionDefinition businessTxDefinition = (BusinessTransactionDefinition) selectedElement;\r\n            if (businessTxDefinition.getId() != BusinessTransactionDefinition.DEFAULT_ID) {\r\n                getApplication().deleteBusinessTransactionDefinition(businessTxDefinition);\r\n                validationManager.validationStatesRemoved(businessTxDefinition);\r\n                itemsDeleted = true;\r\n            }\r\n        }\r\n        if (itemsDeleted) {\r\n            updateContent(StructuredSelection.EMPTY);\r\n            managedForm.fireSelectionChanged(BusinessTransactionMasterBlock.this, StructuredSelection.EMPTY);\r\n            markDirty();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.engine.session.Session.doProcess",
	"Comment": "internal processing routine to execute all rules. this methods blocks as long as further\trules can be executed. if this method returns it is assured that all possible rules are\texecuted and all possible results are available in the iruleoutputstorage.",
	"Method": "void doProcess(){\r\n    Collection<RuleDefinition> nextRules = findNextRules(sessionContext.getStorage().getAvailableTagTypes(), sessionContext.getRuleSet());\r\n    while (!nextRules.isEmpty()) {\r\n        boolean anyRuleExecuted = false;\r\n        for (RuleDefinition ruleDef : nextRules) {\r\n            try {\r\n                Collection<RuleInput> inputs = collectInputs(ruleDef, sessionContext.getStorage());\r\n                inputs = filterProcessedInputs(sessionContext.getExecutions(), ruleDef, inputs);\r\n                if (CollectionUtils.isNotEmpty(inputs)) {\r\n                    Collection<RuleOutput> outputs = ruleDef.execute(inputs, Session.this.sessionContext.getSessionVariables());\r\n                    sessionContext.getStorage().store(outputs);\r\n                    anyRuleExecuted = true;\r\n                    for (RuleInput ruleInput : inputs) {\r\n                        sessionContext.addExecution(ruleDef, ruleInput);\r\n                    }\r\n                }\r\n            } catch (DiagnosisEngineException ex) {\r\n                failure(ex);\r\n            }\r\n        }\r\n        if (anyRuleExecuted) {\r\n            nextRules = findNextRules(sessionContext.getStorage().getAvailableTagTypes(), sessionContext.getRuleSet());\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Time.isEqualTo",
	"Comment": "returns true if the time of this object has the same value as thespecified time",
	"Method": "boolean isEqualTo(Time time){\r\n    return (time == null) ? false : (this.equals(time));\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.tree.input.AbstractTreeInputController.mapTreeViewerColumn",
	"Comment": "maps a column with the enumeration key. the implementing classes should map each column they\tcreate to the enum that represents that column. later on the column can be retrieved with the\tenum key if needed.",
	"Method": "void mapTreeViewerColumn(Enum<?> key,TreeViewerColumn column){\r\n    treeViewerColumnMap.put(key, column);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.TextFormatter.getAgentDescription",
	"Comment": "description of the agent with the connection information.",
	"Method": "String getAgentDescription(PlatformIdent agent,String getAgentDescription,PlatformIdent agent,AgentStatusData agentStatusData){\r\n    return agent.getAgentName() + getStyledAgentDescription(agent, agentStatusData).getString();\r\n}"
}, {
	"Path": "org.apache.isis.applib.layout.component.ActionLayoutData.getOwner",
	"Comment": "owner.set programmatically by framework after reading in from xml.",
	"Method": "ActionLayoutDataOwner getOwner(){\r\n    return owner;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.composite.BreadcrumbTitleComposite.updateStorageDetailsIfDisplayed",
	"Comment": "updates storage name and icon if given storagedata is displayed currently on the breadcrumb.",
	"Method": "void updateStorageDetailsIfDisplayed(IStorageData storageData){\r\n    if (repositoryDefinition instanceof StorageRepositoryDefinition) {\r\n        final StorageRepositoryDefinition storageRepositoryDefinition = (StorageRepositoryDefinition) repositoryDefinition;\r\n        if (Objects.equals(storageRepositoryDefinition.getLocalStorageData(), storageData)) {\r\n            SafeExecutor.asyncExec(new Runnable() {\r\n                @Override\r\n                public void run() {\r\n                    repositoryLabel.setText(TextFormatter.clearLineBreaks(repositoryDefinition.getName()));\r\n                    repositoryLabel.setImage(ImageFormatter.getStorageRepositoryImage(storageRepositoryDefinition));\r\n                    layoutInternal();\r\n                }\r\n            }, getDisplay(), repositoryLabel);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.composite.BreadcrumbTitleComposite.updateStorageDetailsIfDisplayed",
	"Comment": "updates storage name and icon if given storagedata is displayed currently on the breadcrumb.",
	"Method": "void updateStorageDetailsIfDisplayed(IStorageData storageData){\r\n    repositoryLabel.setText(TextFormatter.clearLineBreaks(repositoryDefinition.getName()));\r\n    repositoryLabel.setImage(ImageFormatter.getStorageRepositoryImage(storageRepositoryDefinition));\r\n    layoutInternal();\r\n}"
}, {
	"Path": "org.apache.isis.viewer.restfulobjects.rendering.domainobjects.AbstractObjectMemberReprRenderer.asMutated",
	"Comment": "indicates that the representation was produced as the result of aresource that mutated the state.the effect of this is to suppress the link to self.",
	"Method": "R asMutated(){\r\n    mode = Mode.MUTATED;\r\n    return cast(this);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.table.TableSubView.getColumnNames",
	"Comment": "return the names of all columns in the table. not visible columns names will also be\tincluded. the order of the names will be same to the initial table column order, thus not\treflecting the current state of the table if the columns were moved.",
	"Method": "List<String> getColumnNames(){\r\n    List<String> names = new ArrayList();\r\n    for (TableColumn column : tableViewer.getTable().getColumns()) {\r\n        names.add(column.getText());\r\n    }\r\n    return names;\r\n}"
}, {
	"Path": "org.apache.isis.applib.services.i18n.TranslatableString.tr",
	"Comment": "a translatable string with a single pattern for both singular and plural forms.",
	"Method": "TranslatableString tr(String pattern,Object paramArgs){\r\n    if (pattern == null) {\r\n        return null;\r\n    }\r\n    return new TranslatableString(Type.TR, pattern, null, 1, asMap(paramArgs));\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.nio.ChannelManagersTest.writeReadFixedSize",
	"Comment": "tests if writing and then reading the set of fixed sizes bytes will be correct.",
	"Method": "void writeReadFixedSize(){\r\n    final LinkedBlockingQueue<ByteBuffer> bufferQueue = new LinkedBlockingQueue();\r\n    byte[] bytes = getRandomByteArray();\r\n    final ByteBuffer byteBuffer = ByteBuffer.allocateDirect(bytes.length);\r\n    byteBuffer.put(bytes);\r\n    byteBuffer.flip();\r\n    long position = writingChannelManager.write(byteBuffer, file, new WriteReadCompletionRunnable() {\r\n        @Override\r\n        public void run() {\r\n            byteBuffer.clear();\r\n            bufferQueue.add(byteBuffer);\r\n        }\r\n    });\r\n    final ByteBuffer readBuffer = bufferQueue.take();\r\n    readingChannelManager.read(readBuffer, position, bytes.length, file, new WriteReadCompletionRunnable() {\r\n        @Override\r\n        public void run() {\r\n            bufferQueue.add(readBuffer);\r\n        }\r\n    });\r\n    byte[] readBytes = new byte[bytes.length];\r\n    bufferQueue.take().get(readBytes);\r\n    assertThat(readBytes, is(equalTo(bytes)));\r\n    readingChannelManager.finalizeChannel(file);\r\n    writingChannelManager.finalizeChannel(file);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.nio.ChannelManagersTest.writeReadFixedSize",
	"Comment": "tests if writing and then reading the set of fixed sizes bytes will be correct.",
	"Method": "void writeReadFixedSize(){\r\n    byteBuffer.clear();\r\n    bufferQueue.add(byteBuffer);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.nio.ChannelManagersTest.writeReadFixedSize",
	"Comment": "tests if writing and then reading the set of fixed sizes bytes will be correct.",
	"Method": "void writeReadFixedSize(){\r\n    bufferQueue.add(readBuffer);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.TextFormatter.getInvocationAffilliationPercentageString",
	"Comment": "returns styled string for invocation affilliation percentage.",
	"Method": "StyledString getInvocationAffilliationPercentageString(int percentage,int invocationsNumber){\r\n    StyledString styledString = new StyledString();\r\n    styledString.append(String.valueOf(percentage), StyledString.QUALIFIER_STYLER);\r\n    styledString.append(\"% (in \", StyledString.QUALIFIER_STYLER);\r\n    styledString.append(String.valueOf(invocationsNumber), StyledString.QUALIFIER_STYLER);\r\n    styledString.append(\" inv)\", StyledString.QUALIFIER_STYLER);\r\n    return styledString;\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.ui.components.collectioncontents.ajaxtable.IsisAjaxFallbackHeadersToolbar.getAjaxCallListener",
	"Comment": "returns a decorator that will be used to decorate ajax links used in sortable headers",
	"Method": "IAjaxCallListener getAjaxCallListener(){\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.query.factory.impl.ExceptionSensorDataQueryFactory.getStackTraceMessagesForThrowableTypeQuery",
	"Comment": "returns a query for a stack trace message of a throwable type.",
	"Method": "E getStackTraceMessagesForThrowableTypeQuery(ExceptionSensorData template){\r\n    E query = getIndexQueryProvider().getIndexQuery();\r\n    ArrayList<Class<?>> searchedClasses = new ArrayList();\r\n    searchedClasses.add(ExceptionSensorData.class);\r\n    searchedClasses.add(AggregatedExceptionSensorData.class);\r\n    query.setObjectClasses(searchedClasses);\r\n    query.setPlatformIdent(template.getPlatformIdent());\r\n    query.addIndexingRestriction(IndexQueryRestrictionFactory.equal(\"throwableType\", template.getThrowableType()));\r\n    query.addIndexingRestriction(IndexQueryRestrictionFactory.isNotNull(\"stackTrace\"));\r\n    return query;\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.param.choices.methodnum.ActionParameterChoicesFacetViaMethodFactory.findChoicesNumMethodReturning",
	"Comment": "search successively for the default method, trimming number of param types each loop",
	"Method": "Method findChoicesNumMethodReturning(ProcessMethodContext processMethodContext,int n,Method findChoicesNumMethodReturning,ProcessMethodContext processMethodContext,int n,Class<?>[] paramTypes,Class<?> returnType){\r\n    final Class<?> cls = processMethodContext.getCls();\r\n    final Method actionMethod = processMethodContext.getMethod();\r\n    final String capitalizedName = StringExtensions.asCapitalizedName(actionMethod.getName());\r\n    final String name = MethodPrefixConstants.CHOICES_PREFIX + n + capitalizedName;\r\n    return MethodFinderUtils.findMethod(cls, MethodScope.OBJECT, name, returnType, paramTypes);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.impl.BufferIndexingTest.emptyQueryTest",
	"Comment": "test tree with empty query. all elements should be returned.",
	"Method": "void emptyQueryTest(){\r\n    IBufferTreeComponent<DefaultData> rootBranch = new Branch(new BufferBranchIndexer(new ObjectTypeIndexer()));\r\n    DefaultData defaultData = mock(DefaultData.class);\r\n    when(defaultData.getId()).thenReturn(1L);\r\n    when(defaultData.isQueryComplied(indexQuery)).thenReturn(true);\r\n    rootBranch.put(defaultData);\r\n    SqlStatementData defaultData2 = mock(SqlStatementData.class);\r\n    when(defaultData2.getId()).thenReturn(2L);\r\n    when(defaultData2.isQueryComplied(indexQuery)).thenReturn(true);\r\n    rootBranch.put(defaultData2);\r\n    List<DefaultData> results = rootBranch.query(indexQuery);\r\n    assertThat(results.size(), is(equalTo(2)));\r\n    List<DefaultData> resultsForkJoin = rootBranch.query(indexQuery, forkJoinPool);\r\n    assertThat(resultsForkJoin.size(), is(equalTo(2)));\r\n}"
}, {
	"Path": "j2html.tags.TagCreatorCodeGenerator.emptyTags",
	"Comment": "this is a method that contains all containertags, there is nothing below it",
	"Method": "List<String> emptyTags(){\r\n    return // \"!DOCTYPE html\",\r\n    Arrays.asList(// \"!DOCTYPE html\",\r\n    \"area\", // \"!DOCTYPE html\",\r\n    \"base\", // \"!DOCTYPE html\",\r\n    \"br\", \"col\", \"embed\", \"hr\", \"img\", \"input\", \"keygen\", \"link\", \"meta\", \"param\", \"source\", \"track\", \"wbr\");\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.instrumentation.classcache.util.SortedArraySet.find",
	"Comment": "finds index for an element in the array. if the element does not exists by comparator it will\treturn negative value.",
	"Method": "int find(E[] array,E element){\r\n    int min = 0;\r\n    int max = array.length - 1;\r\n    while (max >= min) {\r\n        int mid = midpoint(min, max);\r\n        int compare = comparator.compare(array[mid], element);\r\n        if (0 == compare) {\r\n            return mid;\r\n        }\r\n        min = (compare < 0) ? mid + 1 : min;\r\n        max = (compare > 0) ? mid - 1 : max;\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.service.rules.impl.ProblemContextRule.action",
	"Comment": "rule execution.\tthe exclusive times of all invocationsequencedata in the time wasting operation are summed\tup. the invocationsequencedata are clustered until there is a cluster with a significant high\texclusive time.",
	"Method": "CauseCluster action(){\r\n    List<InvocationSequenceData> causeInvocations = timeWastingOperation.getRawInvocationsSequenceElements();\r\n    if (causeInvocations.size() > 1) {\r\n        return getSignificantCluster(populateCauseCluster());\r\n    } else if (causeInvocations.size() == 1) {\r\n        return getCauseCluster(causeInvocations.get(0));\r\n    } else {\r\n        throw new RuntimeException(\"TimeWastingOperation has no elements\");\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.view.AbstractTableBasedManagerView.repositoryDefinitionChange",
	"Comment": "informs that the editing repository for the configuration interface has been changed.",
	"Method": "void repositoryDefinitionChange(CmrRepositoryDefinition cmrRepositoryDefinition){\r\n    displayedCmrRepositoryDefinition = cmrRepositoryDefinition;\r\n    performUpdate(true);\r\n    getSelectionProviderAdapter().setSelection(new StructuredSelection(displayedCmrRepositoryDefinition));\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.version.Version.getIntFromString",
	"Comment": "tries to convert one string element of the version to integer.",
	"Method": "int getIntFromString(String element){\r\n    try {\r\n        return Integer.parseInt(element);\r\n    } catch (NumberFormatException e) {\r\n        throw new InvalidVersionException(\"Cannot convert sub element of the version to String\", VersioningErrorCodeEnum.VERSION_INVALID, e);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.data.invocationtree.InvocationTreeElement.getTimeStamp",
	"Comment": "returns the timestamp of this element. the time stamp will be gathered from the data object.",
	"Method": "Timestamp getTimeStamp(){\r\n    if (dataElement instanceof Span) {\r\n        return ((Span) dataElement).getTimeStamp();\r\n    } else if (dataElement instanceof InvocationSequenceData) {\r\n        return ((InvocationSequenceData) dataElement).getTimeStamp();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.service.rules.impl.ProblemContextRule.populateCauseCluster",
	"Comment": "creates list with clusters. for each invocationsequencedata in the time wasting operation a\tcluster is build initially.",
	"Method": "List<CauseCluster> populateCauseCluster(){\r\n    List<InvocationSequenceData> causeInvocations = timeWastingOperation.getRawInvocationsSequenceElements();\r\n    List<CauseCluster> causeClusters = new LinkedList();\r\n    for (InvocationSequenceData invocation : causeInvocations) {\r\n        causeClusters.add(new CauseCluster(invocation));\r\n    }\r\n    return causeClusters;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.nio.ChannelManagersTest.writeReadUnknownSize",
	"Comment": "tests if writing and then reading the set of unknown bytes size will be correct.",
	"Method": "void writeReadUnknownSize(){\r\n    final LinkedBlockingQueue<ByteBuffer> bufferQueue = new LinkedBlockingQueue();\r\n    byte[] bytes = getRandomByteArray();\r\n    final ByteBuffer byteBuffer = ByteBuffer.allocateDirect(bytes.length);\r\n    byteBuffer.put(bytes);\r\n    byteBuffer.flip();\r\n    long position = writingChannelManager.write(byteBuffer, file, new WriteReadCompletionRunnable() {\r\n        @Override\r\n        public void run() {\r\n            byteBuffer.clear();\r\n            bufferQueue.add(byteBuffer);\r\n        }\r\n    });\r\n    final ByteBuffer readBuffer = bufferQueue.take();\r\n    readingChannelManager.read(readBuffer, position, 0, file, new WriteReadCompletionRunnable() {\r\n        @Override\r\n        public void run() {\r\n            bufferQueue.add(readBuffer);\r\n        }\r\n    });\r\n    byte[] readBytes = new byte[bytes.length];\r\n    bufferQueue.take().get(readBytes);\r\n    assertThat(readBytes, is(equalTo(bytes)));\r\n    writingChannelManager.finalizeChannel(file);\r\n    readingChannelManager.finalizeChannel(file);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.nio.ChannelManagersTest.writeReadUnknownSize",
	"Comment": "tests if writing and then reading the set of unknown bytes size will be correct.",
	"Method": "void writeReadUnknownSize(){\r\n    byteBuffer.clear();\r\n    bufferQueue.add(byteBuffer);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.nio.ChannelManagersTest.writeReadUnknownSize",
	"Comment": "tests if writing and then reading the set of unknown bytes size will be correct.",
	"Method": "void writeReadUnknownSize(){\r\n    bufferQueue.add(readBuffer);\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.service.ProblemOccurrenceResultCollector.getGlobalContext",
	"Comment": "returns the invocationsequencedata of globalcontext tag.",
	"Method": "Optional<InvocationSequenceData> getGlobalContext(Tag leafTag){\r\n    while (null != leafTag) {\r\n        if (leafTag.getType().equals(RuleConstants.DIAGNOSIS_TAG_GLOBAL_CONTEXT)) {\r\n            if (leafTag.getValue() instanceof InvocationSequenceData) {\r\n                return Optional.of((InvocationSequenceData) leafTag.getValue());\r\n            } else {\r\n                throw new RuntimeException(\"Global context has wrong datatype!\");\r\n            }\r\n        }\r\n        leafTag = leafTag.getParent();\r\n    }\r\n    return Optional.empty();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.util.UnderlyingSystemInfo.isJavaVersionMatch",
	"Comment": "decides if the java version matches.\tthis method is package private instead of private to support unit test invocation.",
	"Method": "boolean isJavaVersionMatch(String version,String versionPrefix){\r\n    if (version == null) {\r\n        return false;\r\n    }\r\n    return version.startsWith(versionPrefix);\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.DateTime.startOfWeek",
	"Comment": "a datetime that is at the start of the current week. time is preserved.",
	"Method": "DateTime startOfWeek(){\r\n    return new DateTime(dateTime.withDayOfWeek(1));\r\n}"
}, {
	"Path": "org.apache.isis.applib.layout.component.CollectionLayoutData.getDefaultView",
	"Comment": "typically table or hidden, but could be any other named view that is configured andappropriate, eg gmap3 or fullcalendar2.",
	"Method": "String getDefaultView(){\r\n    return defaultView;\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Date.isLessThan",
	"Comment": "returns true if the time of this object is earlier than the specifiedtime",
	"Method": "boolean isLessThan(Date date){\r\n    return this.date.isBefore((date).date);\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Date.isEqualTo",
	"Comment": "returns true if the date of this object has the same value as thespecified date",
	"Method": "boolean isEqualTo(Date date){\r\n    return this.date.equals((date).date);\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.ui.components.scalars.ScalarPanelTextFieldAbstract.createInlinePromptComponent",
	"Comment": "overrides default to use a fragment, allowing the inner rendering to switch between a simple spanor a textarea",
	"Method": "Component createInlinePromptComponent(String id,IModel<String> inlinePromptModel){\r\n    final Fragment fragment = new Fragment(id, \"textInlinePrompt\", this);\r\n    final Label label = new Label(\"scalarValue\", inlinePromptModel);\r\n    fragment.add(label);\r\n    return fragment;\r\n}"
}, {
	"Path": "j2html.TagCreator.join",
	"Comment": "returns the html created by concatenating the input elements,separated by space, in encounter order.also removes spaces before periods and commas.",
	"Method": "UnescapedText join(Object stringOrDomObjects){\r\n    return DomContentJoiner.join(\" \", true, stringOrDomObjects);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.Modifier.isTransient",
	"Comment": "returns true if the modifiers include the transient modifier.",
	"Method": "boolean isTransient(int mod){\r\n    return (mod & TRANSIENT) != 0;\r\n}"
}, {
	"Path": "j2html.tags.ContainerTag.renderFormatted",
	"Comment": "render the containertag and its children, adding newlines before eachchild and using config.indenter to indent child based on how deepin the tree it is",
	"Method": "String renderFormatted(String renderFormatted,int lvl){\r\n    StringBuilder sb = new StringBuilder();\r\n    renderOpenTag(sb, null);\r\n    if (hasTagName() && !isSelfFormattingTag()) {\r\n        sb.append(\"\\n\");\r\n    }\r\n    if (!children.isEmpty()) {\r\n        for (DomContent c : children) {\r\n            lvl++;\r\n            if (c instanceof ContainerTag) {\r\n                if (((ContainerTag) c).hasTagName()) {\r\n                    sb.append(Config.indenter.indent(lvl, ((ContainerTag) c).renderFormatted(lvl)));\r\n                } else {\r\n                    sb.append(Config.indenter.indent(lvl - 1, ((ContainerTag) c).renderFormatted(lvl - 1)));\r\n                }\r\n            } else if (isSelfFormattingTag()) {\r\n                sb.append(Config.indenter.indent(0, c.render()));\r\n            } else {\r\n                sb.append(Config.indenter.indent(lvl, c.render())).append(\"\\n\");\r\n            }\r\n            lvl--;\r\n        }\r\n    }\r\n    if (!isSelfFormattingTag()) {\r\n        sb.append(Config.indenter.indent(lvl, \"\"));\r\n    }\r\n    renderCloseTag(sb);\r\n    if (hasTagName()) {\r\n        sb.append(\"\\n\");\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.StorageIndexingTreeHandler.prepare",
	"Comment": "prepares for write by creating the new indexing tree. this method must be called before\tasking for the position of the data to be written to.",
	"Method": "void prepare(){\r\n    storageIndexingTreeReference = new AtomicReference(getNewStorageIndexingTree());\r\n    indexingTreeSavingFuture = executorService.scheduleWithFixedDelay(new IndexingTreeSavingTask(), TREE_CHECK_DELAY, TREE_CHECK_DELAY, TREE_CHECK_DELAY_TIME_UNIT);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.preferences.control.samplingrate.test.TimeframeDividerTest.fromAndToBeforeDataExists",
	"Comment": "if the from and to time are smaller then the time of the first data object, then no data\tshould be aggregated.",
	"Method": "void fromAndToBeforeDataExists(){\r\n    List<? extends DefaultData> resultList = null;\r\n    Sensitivity sensitivity = SamplingRateControl.Sensitivity.VERY_COARSE;\r\n    Date fromDate = new Date(1221465600000L);\r\n    Date toDate = new Date(1221467400000L);\r\n    resultList = mode.adjustSamplingRate(dataObjects, fromDate, toDate, sensitivity.getValue(), new ClassLoadingInformationDataAggregator());\r\n    assertThat(resultList.size(), is(equalTo(0)));\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.table.input.AbstractTableInputController.mapTableViewerColumn",
	"Comment": "maps a column with the enumeration key. the implementing classes should map each column they\tcreate to the enum that represents that column. later on the column can be retrieved with the\tenum key if needed.",
	"Method": "void mapTableViewerColumn(Enum<?> key,TableViewerColumn column){\r\n    tableViewerColumnMap.put(key, column);\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.ui.pages.PageAbstract.contributeThemeSpecificOverrides",
	"Comment": "contributes theme specific bootstrap css overrides if there is such resource",
	"Method": "void contributeThemeSpecificOverrides(IHeaderResponse response){\r\n    final IBootstrapSettings bootstrapSettings = Bootstrap.getSettings(getApplication());\r\n    final ITheme activeTheme = bootstrapSettings.getActiveThemeProvider().getActiveTheme();\r\n    final String name = activeTheme.name().toLowerCase(Locale.ENGLISH);\r\n    final String themeSpecificOverride = \"bootstrap-overrides-\" + name + \".css\";\r\n    final ResourceReference.Key themeSpecificOverrideKey = new ResourceReference.Key(PageAbstract.class.getName(), themeSpecificOverride, null, null, null);\r\n    if (PackageResource.exists(themeSpecificOverrideKey)) {\r\n        response.render(CssHeaderItem.forReference(new CssResourceReference(themeSpecificOverrideKey)));\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.storage.http.TransferDataMonitor.getMillisLeft",
	"Comment": "returns time left for the given amounts of bytes to be downloaded. note that this is not\trelated to the current transfer rate, but to the time since the download started. thus this\tcan be used as the information when it is gonna be completely over.",
	"Method": "long getMillisLeft(long bytesMore){\r\n    return (long) ((bytesMore * 1000.0d) / getAverageTransferRate());\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.nio.WriteReadCompletionRunnable.isFinished",
	"Comment": "denotes if the number of reported succeeded and failed operations is same as the number of\texpected marks.",
	"Method": "boolean isFinished(){\r\n    return (successMarks.get() + failedMarks.get()) == completeMarks;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.viewers.StyledCellIndexLabelProvider.getBackground",
	"Comment": "default behavior is to return null. clients should override this method if\tneeded.",
	"Method": "Color getBackground(Object element,int index){\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.property.PropertyPreferencePage.updatePage",
	"Comment": "updates the page valid status, message and error table if needed.",
	"Method": "void updatePage(){\r\n    setValid(isValid());\r\n    updateMessage();\r\n    updateValidationMessages();\r\n}"
}, {
	"Path": "org.apache.isis.applib.services.publish.EventPayloadForActionInvocation.withStringifier",
	"Comment": "injected by isis runtime immediately after instantiation.",
	"Method": "void withStringifier(ObjectStringifier stringifier){\r\n    this.stringifier = stringifier;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.ModifiersImageFactory.getImage",
	"Comment": "returns the image for the given modifiers. this image should not be disposed.",
	"Method": "Image getImage(int modifiers){\r\n    InspectIT inspectIT = InspectIT.getDefault();\r\n    if (isPrivate(modifiers)) {\r\n        return inspectIT.getImage(METHOD_PRIV_IMAGE);\r\n    } else if (isPackage(modifiers)) {\r\n        return inspectIT.getImage(METHOD_DEFAULT_IMAGE);\r\n    } else if (isProtected(modifiers)) {\r\n        return inspectIT.getImage(METHOD_PROT_IMAGE);\r\n    } else if (isPublic(modifiers)) {\r\n        return inspectIT.getImage(METHOD_PUB_IMAGE);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.property.PropertyPreferencePage.updateMessage",
	"Comment": "updates the message of the page based on number of validation errors.",
	"Method": "void updateMessage(){\r\n    int count = getValidationErrorsCount();\r\n    if (0 == count) {\r\n        setMessage(null);\r\n    } else {\r\n        String msg = count + \" validation error\" + (count > 1 ? \"s\" : \"\") + \" detected\";\r\n        setMessage(msg, ERROR);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.text.input.SqlInvocSummaryTextInputController.getSlowestSqlCount",
	"Comment": "calculates how much slowest sql can fit into the given percentage of total duration.",
	"Method": "int getSlowestSqlCount(double totalDuration,List<SqlStatementData> sqlStatementDataList,double percentage,Collection<SqlStatementData> resultList){\r\n    Collections.sort(sqlStatementDataList, new Comparator<SqlStatementData>() {\r\n        @Override\r\n        public int compare(SqlStatementData o1, SqlStatementData o2) {\r\n            return ObjectUtils.compare(o2.getDuration(), o1.getDuration());\r\n        }\r\n    });\r\n    int result = 0;\r\n    double currentDurationSum = 0;\r\n    for (SqlStatementData sqlStatementData : sqlStatementDataList) {\r\n        if ((currentDurationSum / totalDuration) < percentage) {\r\n            result++;\r\n            resultList.add(sqlStatementData);\r\n        } else {\r\n            break;\r\n        }\r\n        currentDurationSum += sqlStatementData.getDuration();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.text.input.SqlInvocSummaryTextInputController.getSlowestSqlCount",
	"Comment": "calculates how much slowest sql can fit into the given percentage of total duration.",
	"Method": "int getSlowestSqlCount(double totalDuration,List<SqlStatementData> sqlStatementDataList,double percentage,Collection<SqlStatementData> resultList){\r\n    return ObjectUtils.compare(o2.getDuration(), o1.getDuration());\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.view.impl.StorageManagerView.refreshWithoutCmrCall",
	"Comment": "performs update of the view, without getting data from cmr.",
	"Method": "void refreshWithoutCmrCall(){\r\n    performUpdate(false);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.Modifier.isProtected",
	"Comment": "returns true if the modifiers include the protected modifier.",
	"Method": "boolean isProtected(int mod){\r\n    return (mod & PROTECTED) != 0;\r\n}"
}, {
	"Path": "org.apache.isis.applib.services.exceprecog.ExceptionRecognizerAbstract.constant",
	"Comment": "convenience for subclass implementations that always return a fixed message.",
	"Method": "Function<String, String> constant(String message){\r\n    return new Function<String, String>() {\r\n        @Override\r\n        public String apply(String input) {\r\n            return message;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.apache.isis.applib.services.exceprecog.ExceptionRecognizerAbstract.constant",
	"Comment": "convenience for subclass implementations that always return a fixed message.",
	"Method": "Function<String, String> constant(String message){\r\n    return message;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.label.management.impl.LabelManagementActionsTest.emptyRemoveAction",
	"Comment": "no exceptions and no interactions with storage service with empty action.",
	"Method": "void emptyRemoveAction(){\r\n    removeLabelManagementAction = new RemoveLabelManagementAction();\r\n    verifyNoMoreInteractions(storageService);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.TimerData.calculateMax",
	"Comment": "sets the maximum if the given value is bigger than the current value.",
	"Method": "void calculateMax(double max){\r\n    this.max = Math.max(this.max, max);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.instrumentation.config.impl.InstrumentationDefinition.isEmpty",
	"Comment": "defines if instrumentation result is empty in terms that no instrumentation have to be\tperformed with this instrumentation result.",
	"Method": "boolean isEmpty(){\r\n    return CollectionUtils.isEmpty(methodInstrumentationConfigs);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.serializer.schema.ClassSchema.getFieldName",
	"Comment": "returns the name of the class field that marker is defined for.",
	"Method": "String getFieldName(int fieldMarker){\r\n    return fieldMap.get(fieldMarker);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.TextFormatter.getSpanDetailsFull",
	"Comment": "helper method to generate span details out of full available information.",
	"Method": "StyledString getSpanDetailsFull(Span span,ICachedDataService cachedDataService,StyledString getSpanDetailsFull,boolean isCaller,PropagationType propagationType,long methodId,Map<String, String> tags,ICachedDataService cachedDataService){\r\n    StyledString styledString = new StyledString();\r\n    if (isCaller) {\r\n        styledString.append(CLIENT_SPAN);\r\n    }\r\n    boolean isError = MapUtils.getBoolean(tags, Tags.ERROR.getKey(), false);\r\n    if (isError) {\r\n        styledString.append('[', StyledString.DECORATIONS_STYLER);\r\n        styledString.append(\"Err\", ERROR_STYLED);\r\n        styledString.append(\"] \", StyledString.DECORATIONS_STYLER);\r\n    }\r\n    if (null != propagationType) {\r\n        switch(propagationType) {\r\n            case HTTP:\r\n                if (!isError) {\r\n                    styledString.append('[', StyledString.DECORATIONS_STYLER);\r\n                    String status = tags.get(Tags.HTTP_STATUS.getKey());\r\n                    styledString.append(getHttpStatusStyledString(status));\r\n                    styledString.append(\" | \", StyledString.DECORATIONS_STYLER);\r\n                    styledString.append(StringUtils.defaultString(tags.get(Tags.HTTP_METHOD.getKey()), \"?\"), StyledString.DECORATIONS_STYLER);\r\n                    styledString.append(\"] \", StyledString.DECORATIONS_STYLER);\r\n                }\r\n                styledString.append(StringUtils.defaultString(tags.get(Tags.HTTP_URL.getKey())));\r\n                return styledString;\r\n            case JMS:\r\n                styledString.append(StringUtils.defaultString(tags.get(ExtraTags.JMS_MESSAGE_DESTINATION), \"?\"));\r\n                return styledString;\r\n            default:\r\n        }\r\n    }\r\n    String op = tags.get(ExtraTags.OPERATION_NAME);\r\n    if (StringUtils.isNotEmpty(op)) {\r\n        styledString.append(op);\r\n        return styledString;\r\n    }\r\n    String runnableType = tags.get(ExtraTags.RUNNABLE_TYPE);\r\n    if (StringUtils.isNotEmpty(runnableType)) {\r\n        styledString.append(getFqnAbbreviated(runnableType));\r\n        return styledString;\r\n    }\r\n    MethodIdent methodIdent = cachedDataService.getMethodIdentForId(methodId);\r\n    if (null != methodIdent) {\r\n        styledString.append(getMethodWithParameters(methodIdent) + \" - \" + methodIdent.getFQN());\r\n    }\r\n    return styledString;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.Modifier.isStrict",
	"Comment": "returns true if the modifiers include the strictfp modifier.",
	"Method": "boolean isStrict(int mod){\r\n    return (mod & STRICT) != 0;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.table.input.InvocOverviewInputController.getLimit",
	"Comment": "returns current view item count limit defined for the view.",
	"Method": "int getLimit(){\r\n    return limit;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.preferences.PreferencesUtils.saveCmrRepositoryDefinitions",
	"Comment": "save given repository definitions to the preference store.",
	"Method": "void saveCmrRepositoryDefinitions(List<CmrRepositoryDefinition> repositoryDefinitions,boolean isDefault){\r\n    saveObject(PreferencesConstants.CMR_REPOSITORY_DEFINITIONS, repositoryDefinitions, isDefault);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.util.UnderlyingSystemInfo.getSystemProperty",
	"Comment": "gets a system property, defaulting to null if the property cannot be read.\tif a securityexception is caught, the return value is null and a\tmessage is written to system.err.",
	"Method": "String getSystemProperty(String property){\r\n    try {\r\n        return System.getProperty(property);\r\n    } catch (SecurityException ex) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.business.rules.AbstractRuleEditingElement.notifyDisposed",
	"Comment": "notifies all modify listeners about the disposition of this editing element.",
	"Method": "void notifyDisposed(){\r\n    if (notificationActive) {\r\n        for (DisposeListener listener : disposeListeners) {\r\n            Event event = new Event();\r\n            event.widget = parent;\r\n            DisposeEvent disposeEvent = new DisposeEvent(event);\r\n            disposeEvent.data = this;\r\n            listener.widgetDisposed(disposeEvent);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.Modifier.isAbstract",
	"Comment": "returns true if the modifiers include the abstract modifier.",
	"Method": "boolean isAbstract(int mod){\r\n    return (mod & ABSTRACT) != 0;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.wizard.page.SelectAgentsWizardPage.setCmrRepositoryDefinition",
	"Comment": "sets the repository. needed to be called before the page is displayed to the user.",
	"Method": "void setCmrRepositoryDefinition(CmrRepositoryDefinition cmrRepositoryDefinition){\r\n    if (!ObjectUtils.equals(cmrRepositoryDefinition, this.cmrRepositoryDefinition)) {\r\n        this.cmrRepositoryDefinition = cmrRepositoryDefinition;\r\n        for (Control control : main.getChildren()) {\r\n            control.dispose();\r\n        }\r\n        if (cmrRepositoryDefinition.getOnlineStatus() != OnlineStatus.OFFLINE) {\r\n            Job getAgentsJob = new Job(\"Loading agents information..\") {\r\n                @Override\r\n                protected IStatus run(IProgressMonitor monitor) {\r\n                    final Map<PlatformIdent, AgentStatusData> agentMap = cmrRepositoryDefinition.getGlobalDataAccessService().getAgentsOverview();\r\n                    agentList = new ArrayList(agentMap.keySet());\r\n                    Collections.sort(agentList, new Comparator<PlatformIdent>() {\r\n                        @Override\r\n                        public int compare(PlatformIdent a1, PlatformIdent a2) {\r\n                            return a1.getAgentName().compareToIgnoreCase(a2.getAgentName());\r\n                        }\r\n                    });\r\n                    SafeExecutor.asyncExec(new Runnable() {\r\n                        @Override\r\n                        public void run() {\r\n                            main.setLayout(new GridLayout(1, false));\r\n                            allAgents = new Button(main, SWT.RADIO);\r\n                            allAgents.setText(\"All agent(s)\");\r\n                            allAgents.setSelection(true);\r\n                            specificAgents = new Button(main, SWT.RADIO);\r\n                            specificAgents.setText(\"Select specific Agent(s)\");\r\n                            boolean preSelectedAgentsActive = false;\r\n                            agentSelection = new Table(main, SWT.CHECK | SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER | SWT.FULL_SELECTION);\r\n                            for (PlatformIdent platformIdent : agentList) {\r\n                                AgentStatusData agentStatusData = agentMap.get(platformIdent);\r\n                                TableItem tableItem = new TableItem(agentSelection, SWT.NONE);\r\n                                tableItem.setText(TextFormatter.getAgentDescription(platformIdent, agentStatusData));\r\n                                tableItem.setImage(ImageFormatter.getAgentImage(agentStatusData));\r\n                                if (CollectionUtils.isNotEmpty(autoSelectedAgents) && autoSelectedAgents.contains(platformIdent)) {\r\n                                    tableItem.setChecked(true);\r\n                                    preSelectedAgentsActive = true;\r\n                                }\r\n                            }\r\n                            agentSelection.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));\r\n                            agentSelection.setEnabled(false);\r\n                            Listener pageCompletedListener = new Listener() {\r\n                                @Override\r\n                                public void handleEvent(Event event) {\r\n                                    setPageComplete(isPageComplete());\r\n                                }\r\n                            };\r\n                            agentSelection.addListener(SWT.Selection, pageCompletedListener);\r\n                            allAgents.addListener(SWT.Selection, pageCompletedListener);\r\n                            specificAgents.addListener(SWT.Selection, pageCompletedListener);\r\n                            Listener agentsSelectionListener = new Listener() {\r\n                                @Override\r\n                                public void handleEvent(Event event) {\r\n                                    if (allAgents.getSelection()) {\r\n                                        agentSelection.setEnabled(false);\r\n                                    } else {\r\n                                        agentSelection.setEnabled(true);\r\n                                    }\r\n                                }\r\n                            };\r\n                            allAgents.addListener(SWT.Selection, agentsSelectionListener);\r\n                            specificAgents.addListener(SWT.Selection, agentsSelectionListener);\r\n                            if (preSelectedAgentsActive) {\r\n                                specificAgents.setSelection(true);\r\n                                allAgents.setSelection(false);\r\n                                agentSelection.setEnabled(true);\r\n                            }\r\n                            main.layout();\r\n                        }\r\n                    }, main, allAgents, agentSelection, specificAgents);\r\n                    return Status.OK_STATUS;\r\n                }\r\n            };\r\n            getAgentsJob.schedule();\r\n        } else {\r\n            main.setLayout(new GridLayout(2, false));\r\n            new Label(main, SWT.NONE).setImage(Display.getDefault().getSystemImage(SWT.ERROR));\r\n            Label text = new Label(main, SWT.WRAP);\r\n            text.setText(\"Selected repository is currently offline. Action can not be performed.\");\r\n            main.layout();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.wizard.page.SelectAgentsWizardPage.setCmrRepositoryDefinition",
	"Comment": "sets the repository. needed to be called before the page is displayed to the user.",
	"Method": "void setCmrRepositoryDefinition(CmrRepositoryDefinition cmrRepositoryDefinition){\r\n    final Map<PlatformIdent, AgentStatusData> agentMap = cmrRepositoryDefinition.getGlobalDataAccessService().getAgentsOverview();\r\n    agentList = new ArrayList(agentMap.keySet());\r\n    Collections.sort(agentList, new Comparator<PlatformIdent>() {\r\n        @Override\r\n        public int compare(PlatformIdent a1, PlatformIdent a2) {\r\n            return a1.getAgentName().compareToIgnoreCase(a2.getAgentName());\r\n        }\r\n    });\r\n    SafeExecutor.asyncExec(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            main.setLayout(new GridLayout(1, false));\r\n            allAgents = new Button(main, SWT.RADIO);\r\n            allAgents.setText(\"All agent(s)\");\r\n            allAgents.setSelection(true);\r\n            specificAgents = new Button(main, SWT.RADIO);\r\n            specificAgents.setText(\"Select specific Agent(s)\");\r\n            boolean preSelectedAgentsActive = false;\r\n            agentSelection = new Table(main, SWT.CHECK | SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER | SWT.FULL_SELECTION);\r\n            for (PlatformIdent platformIdent : agentList) {\r\n                AgentStatusData agentStatusData = agentMap.get(platformIdent);\r\n                TableItem tableItem = new TableItem(agentSelection, SWT.NONE);\r\n                tableItem.setText(TextFormatter.getAgentDescription(platformIdent, agentStatusData));\r\n                tableItem.setImage(ImageFormatter.getAgentImage(agentStatusData));\r\n                if (CollectionUtils.isNotEmpty(autoSelectedAgents) && autoSelectedAgents.contains(platformIdent)) {\r\n                    tableItem.setChecked(true);\r\n                    preSelectedAgentsActive = true;\r\n                }\r\n            }\r\n            agentSelection.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));\r\n            agentSelection.setEnabled(false);\r\n            Listener pageCompletedListener = new Listener() {\r\n                @Override\r\n                public void handleEvent(Event event) {\r\n                    setPageComplete(isPageComplete());\r\n                }\r\n            };\r\n            agentSelection.addListener(SWT.Selection, pageCompletedListener);\r\n            allAgents.addListener(SWT.Selection, pageCompletedListener);\r\n            specificAgents.addListener(SWT.Selection, pageCompletedListener);\r\n            Listener agentsSelectionListener = new Listener() {\r\n                @Override\r\n                public void handleEvent(Event event) {\r\n                    if (allAgents.getSelection()) {\r\n                        agentSelection.setEnabled(false);\r\n                    } else {\r\n                        agentSelection.setEnabled(true);\r\n                    }\r\n                }\r\n            };\r\n            allAgents.addListener(SWT.Selection, agentsSelectionListener);\r\n            specificAgents.addListener(SWT.Selection, agentsSelectionListener);\r\n            if (preSelectedAgentsActive) {\r\n                specificAgents.setSelection(true);\r\n                allAgents.setSelection(false);\r\n                agentSelection.setEnabled(true);\r\n            }\r\n            main.layout();\r\n        }\r\n    }, main, allAgents, agentSelection, specificAgents);\r\n    return Status.OK_STATUS;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.wizard.page.SelectAgentsWizardPage.setCmrRepositoryDefinition",
	"Comment": "sets the repository. needed to be called before the page is displayed to the user.",
	"Method": "void setCmrRepositoryDefinition(CmrRepositoryDefinition cmrRepositoryDefinition){\r\n    return a1.getAgentName().compareToIgnoreCase(a2.getAgentName());\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.wizard.page.SelectAgentsWizardPage.setCmrRepositoryDefinition",
	"Comment": "sets the repository. needed to be called before the page is displayed to the user.",
	"Method": "void setCmrRepositoryDefinition(CmrRepositoryDefinition cmrRepositoryDefinition){\r\n    main.setLayout(new GridLayout(1, false));\r\n    allAgents = new Button(main, SWT.RADIO);\r\n    allAgents.setText(\"All agent(s)\");\r\n    allAgents.setSelection(true);\r\n    specificAgents = new Button(main, SWT.RADIO);\r\n    specificAgents.setText(\"Select specific Agent(s)\");\r\n    boolean preSelectedAgentsActive = false;\r\n    agentSelection = new Table(main, SWT.CHECK | SWT.H_SCROLL | SWT.V_SCROLL | SWT.BORDER | SWT.FULL_SELECTION);\r\n    for (PlatformIdent platformIdent : agentList) {\r\n        AgentStatusData agentStatusData = agentMap.get(platformIdent);\r\n        TableItem tableItem = new TableItem(agentSelection, SWT.NONE);\r\n        tableItem.setText(TextFormatter.getAgentDescription(platformIdent, agentStatusData));\r\n        tableItem.setImage(ImageFormatter.getAgentImage(agentStatusData));\r\n        if (CollectionUtils.isNotEmpty(autoSelectedAgents) && autoSelectedAgents.contains(platformIdent)) {\r\n            tableItem.setChecked(true);\r\n            preSelectedAgentsActive = true;\r\n        }\r\n    }\r\n    agentSelection.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, true));\r\n    agentSelection.setEnabled(false);\r\n    Listener pageCompletedListener = new Listener() {\r\n        @Override\r\n        public void handleEvent(Event event) {\r\n            setPageComplete(isPageComplete());\r\n        }\r\n    };\r\n    agentSelection.addListener(SWT.Selection, pageCompletedListener);\r\n    allAgents.addListener(SWT.Selection, pageCompletedListener);\r\n    specificAgents.addListener(SWT.Selection, pageCompletedListener);\r\n    Listener agentsSelectionListener = new Listener() {\r\n        @Override\r\n        public void handleEvent(Event event) {\r\n            if (allAgents.getSelection()) {\r\n                agentSelection.setEnabled(false);\r\n            } else {\r\n                agentSelection.setEnabled(true);\r\n            }\r\n        }\r\n    };\r\n    allAgents.addListener(SWT.Selection, agentsSelectionListener);\r\n    specificAgents.addListener(SWT.Selection, agentsSelectionListener);\r\n    if (preSelectedAgentsActive) {\r\n        specificAgents.setSelection(true);\r\n        allAgents.setSelection(false);\r\n        agentSelection.setEnabled(true);\r\n    }\r\n    main.layout();\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.wizard.page.SelectAgentsWizardPage.setCmrRepositoryDefinition",
	"Comment": "sets the repository. needed to be called before the page is displayed to the user.",
	"Method": "void setCmrRepositoryDefinition(CmrRepositoryDefinition cmrRepositoryDefinition){\r\n    setPageComplete(isPageComplete());\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.wizard.page.SelectAgentsWizardPage.setCmrRepositoryDefinition",
	"Comment": "sets the repository. needed to be called before the page is displayed to the user.",
	"Method": "void setCmrRepositoryDefinition(CmrRepositoryDefinition cmrRepositoryDefinition){\r\n    if (allAgents.getSelection()) {\r\n        agentSelection.setEnabled(false);\r\n    } else {\r\n        agentSelection.setEnabled(true);\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Time.isLessThan",
	"Comment": "returns true if the time of this object is earlier than the specifiedtime",
	"Method": "boolean isLessThan(Time time){\r\n    return (time != null) && this.time.isBefore((time).time);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.Client.setKeepAliveUDP",
	"Comment": "an empty object will be sent if the udp connection is inactive more than the specified\tmilliseconds. network hardware may keep a translation table of inside to outside ip addresses\tand a udp keep alive keeps this table entry from expiring. set to zero to disable. defaults\tto 19000.",
	"Method": "void setKeepAliveUDP(int keepAliveMillis){\r\n    if (udp == null) {\r\n        throw new IllegalStateException(\"Not connected via UDP.\");\r\n    }\r\n    udp.keepAliveMillis = keepAliveMillis;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.util.FileVisitorsTest.storageDeleteFileVisitor",
	"Comment": "test that the deleting of the storage files works with visitor.",
	"Method": "void storageDeleteFileVisitor(){\r\n    StorageFileType storageFileType = StorageFileType.DATA_FILE;\r\n    Path dir = testPath.resolve(\"dir\");\r\n    Files.createDirectories(dir);\r\n    Path file = dir.resolve(storageFileType.getExtension());\r\n    Files.createFile(file);\r\n    Files.walkFileTree(dir, new StorageDeleteFileVisitor(new StorageFileType[] { storageFileType }, false));\r\n    assertThat(Files.exists(file), is(false));\r\n    assertThat(Files.exists(dir), is(true));\r\n    assertThat(Files.exists(testPath), is(true));\r\n    Files.walkFileTree(dir, new StorageDeleteFileVisitor(new StorageFileType[] { storageFileType }, true));\r\n    assertThat(Files.exists(dir), is(false));\r\n    assertThat(Files.exists(testPath), is(true));\r\n}"
}, {
	"Path": "org.github.jamm.MemoryLayoutSpecification.hasUnsafe",
	"Comment": "indicates if unsafe object size determination is available",
	"Method": "boolean hasUnsafe(){\r\n    return unsafe != null;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.text.input.VmSummaryInputController.addStaticInformations",
	"Comment": "adds some static text informations to the parent component.",
	"Method": "void addStaticInformations(Composite parent,FormToolkit toolkit){\r\n    SystemInformationData data = (SystemInformationData) dataAccessService.getLastDataObject(systemObj);\r\n    int minTitleColumnWidth = 170;\r\n    int minInformationColumnWidth = 230;\r\n    String processId = NOT_AVAILABLE;\r\n    String pcName = NOT_AVAILABLE;\r\n    if (null != data) {\r\n        addMinimizedSection(parent, toolkit, SECTION_CLASSPATH, 1);\r\n        addMinimizedSection(parent, toolkit, VM_ARGS, 2);\r\n        String vmFullName = data.getVmName();\r\n        String[] vmNames = vmFullName.split(\"@\");\r\n        if ((vmNames != null) && (vmNames.length > 1)) {\r\n            processId = vmNames[0];\r\n            pcName = vmNames[1];\r\n        }\r\n        addItemToSection(toolkit, SECTION_VM, \"Vendor: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, data.getVmVendor(), minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, \"Version: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, data.getVmVersion(), minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, \"Process Id: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, processId, minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, \"Pc Name: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, pcName, minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, \"Jit Compiler Name: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, data.getJitCompilerName(), minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, \"Specification Name: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, data.getVmSpecName(), minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_MEMORY, \"Max heap size: \", minTitleColumnWidth);\r\n        if (data.getMaxHeapMemorySize() > 0) {\r\n            addItemToSection(toolkit, SECTION_MEMORY, NumberFormatter.formatBytesToKBytes(data.getMaxHeapMemorySize()), minInformationColumnWidth);\r\n        } else {\r\n            addItemToSection(toolkit, SECTION_MEMORY, NOT_AVAILABLE, minInformationColumnWidth);\r\n        }\r\n        addItemToSection(toolkit, SECTION_MEMORY, \"Max non-heap size: \", minTitleColumnWidth);\r\n        if (data.getMaxNonHeapMemorySize() > 0) {\r\n            addItemToSection(toolkit, SECTION_MEMORY, NumberFormatter.formatBytesToKBytes(data.getMaxNonHeapMemorySize()), minInformationColumnWidth);\r\n        } else {\r\n            addItemToSection(toolkit, SECTION_MEMORY, NOT_AVAILABLE, minInformationColumnWidth);\r\n        }\r\n        addItemToSection(toolkit, SECTION_MEMORY, \"Total physical memory: \", minTitleColumnWidth);\r\n        if (data.getTotalPhysMemory() > 0) {\r\n            addItemToSection(toolkit, SECTION_MEMORY, NumberFormatter.formatBytesToKBytes(data.getTotalPhysMemory()), minInformationColumnWidth);\r\n        } else {\r\n            addItemToSection(toolkit, SECTION_MEMORY, NOT_AVAILABLE, minInformationColumnWidth);\r\n        }\r\n        addItemToSection(toolkit, SECTION_MEMORY, \"Total swap space: \", minTitleColumnWidth);\r\n        if (data.getTotalSwapSpace() > 0) {\r\n            addItemToSection(toolkit, SECTION_MEMORY, NumberFormatter.formatBytesToKBytes(data.getTotalSwapSpace()), minInformationColumnWidth);\r\n        } else {\r\n            addItemToSection(toolkit, SECTION_MEMORY, NOT_AVAILABLE, minInformationColumnWidth);\r\n        }\r\n        addItemToSection(toolkit, SECTION_OS, \"Operating System: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_OS, data.getOsName() + \" \" + data.getOsVersion(), minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_OS, \"Available processors: \", minTitleColumnWidth);\r\n        if (data.getAvailableProcessors() > 0) {\r\n            addItemToSection(toolkit, SECTION_OS, NumberFormatter.formatInteger(data.getAvailableProcessors()), minInformationColumnWidth);\r\n        } else {\r\n            addItemToSection(toolkit, SECTION_OS, NOT_AVAILABLE, minInformationColumnWidth);\r\n        }\r\n        addItemToSection(toolkit, SECTION_OS, \"Architecture: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_OS, data.getArchitecture(), minInformationColumnWidth);\r\n        String tokenDelimiter = \";\";\r\n        String classPath = data.getClassPath();\r\n        if (classPath.indexOf(tokenDelimiter) == -1) {\r\n            tokenDelimiter = \":\";\r\n        }\r\n        addItemToMinimizedSection(toolkit, SECTION_CLASSPATH, \"Class path: \");\r\n        StringTokenizer classpathTokenizer = new StringTokenizer(data.getClassPath(), tokenDelimiter);\r\n        while (classpathTokenizer.hasMoreTokens()) {\r\n            addItemToMinimizedSection(toolkit, SECTION_CLASSPATH, \" \\t\" + classpathTokenizer.nextToken());\r\n        }\r\n        addItemToMinimizedSection(toolkit, SECTION_CLASSPATH, \"Boot class path: \");\r\n        StringTokenizer bootClasspathTokenizer = new StringTokenizer(data.getBootClassPath(), tokenDelimiter);\r\n        while (bootClasspathTokenizer.hasMoreTokens()) {\r\n            addItemToMinimizedSection(toolkit, SECTION_CLASSPATH, \" \\t\" + bootClasspathTokenizer.nextToken());\r\n        }\r\n        addItemToMinimizedSection(toolkit, SECTION_CLASSPATH, \"Library Path: \");\r\n        StringTokenizer libPathTokenizer = new StringTokenizer(data.getLibraryPath(), tokenDelimiter);\r\n        while (libPathTokenizer.hasMoreTokens()) {\r\n            addItemToMinimizedSection(toolkit, SECTION_CLASSPATH, \" \\t\" + libPathTokenizer.nextToken());\r\n        }\r\n        TreeSet<VmArgumentData> treeSet = new TreeSet(new Comparator<VmArgumentData>() {\r\n            @Override\r\n            public int compare(VmArgumentData one, VmArgumentData two) {\r\n                return one.getVmName().compareTo(two.getVmName());\r\n            }\r\n        });\r\n        treeSet.addAll(data.getVmSet());\r\n        for (VmArgumentData argumentData : treeSet) {\r\n            if (!argumentData.getVmName().endsWith(\"path\") && !argumentData.getVmName().endsWith(\"separator\")) {\r\n                addItemToMinimizedSection(toolkit, VM_ARGS, argumentData.getVmName() + \":\");\r\n                addItemToMinimizedSection(toolkit, VM_ARGS, argumentData.getVmValue());\r\n            }\r\n        }\r\n    } else {\r\n        addMinimizedSectionNotAvailable(parent, toolkit, SECTION_CLASSPATH + \" (n/a)\", 1);\r\n        addMinimizedSectionNotAvailable(parent, toolkit, VM_ARGS + \" (n/a)\", 2);\r\n        addItemToSection(toolkit, SECTION_VM, \"Vendor: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, NOT_AVAILABLE, minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, \"Version: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, NOT_AVAILABLE, minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, \"Process Id: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, processId, minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, \"Pc Name: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, pcName, minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, \"Jit Compiler Name: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, NOT_AVAILABLE, minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, \"Specification Name: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_VM, NOT_AVAILABLE, minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_MEMORY, \"Max heap size: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_MEMORY, NOT_AVAILABLE, minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_MEMORY, \"Max non-heap size: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_MEMORY, NOT_AVAILABLE, minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_MEMORY, \"Total physical memory: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_MEMORY, NOT_AVAILABLE, minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_MEMORY, \"Total swap space: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_MEMORY, NOT_AVAILABLE, minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_OS, \"Operating System: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_OS, NOT_AVAILABLE, minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_OS, \"Available processors: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_OS, NOT_AVAILABLE, minInformationColumnWidth);\r\n        addItemToSection(toolkit, SECTION_OS, \"Architecture: \", minTitleColumnWidth);\r\n        addItemToSection(toolkit, SECTION_OS, NOT_AVAILABLE, minInformationColumnWidth);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.text.input.VmSummaryInputController.addStaticInformations",
	"Comment": "adds some static text informations to the parent component.",
	"Method": "void addStaticInformations(Composite parent,FormToolkit toolkit){\r\n    return one.getVmName().compareTo(two.getVmName());\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.collections.accessor.CollectionAccessorFacetViaAccessorFactory.isPropertyAccessor",
	"Comment": "the method way well represent a reference property, but this facetfactory does not have any opinion on the matter.",
	"Method": "boolean isPropertyAccessor(Method method){\r\n    return false;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.TimerData.isCpuMetricDataAvailable",
	"Comment": "whether or not this timer data contains cpu related metrics.",
	"Method": "boolean isCpuMetricDataAvailable(){\r\n    return cpuMin != -1;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.business.rules.AbstractRuleEditingElement.notifyModifyListeners",
	"Comment": "notifies all modify listeners about a modification of the controls content.",
	"Method": "void notifyModifyListeners(){\r\n    if (notificationActive) {\r\n        for (IDetailsModifiedListener<AbstractExpression> listener : modifyListeners) {\r\n            listener.contentModified(expression);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.storage.impl.StorageBranchIndexerTest.nextComponentIsBranch",
	"Comment": "test the creation of new component when branch should be created.",
	"Method": "void nextComponentIsBranch(){\r\n    int id = 1;\r\n    storageBranchIndexer = new StorageBranchIndexer(delegateIndexer, childIndexer, id, true);\r\n    DefaultData defaultData = mock(DefaultData.class);\r\n    when(childIndexer.isPassId()).thenReturn(false);\r\n    when(childIndexer.getNewInstance()).thenReturn(mock(IStorageBranchIndexer.class));\r\n    IStorageTreeComponent<DefaultData> component = storageBranchIndexer.getNextTreeComponent(defaultData);\r\n    assertThat(component, is(instanceOf(StorageBranch.class)));\r\n    StorageBranch<DefaultData> branch = (StorageBranch<DefaultData>) component;\r\n    assertThat(branch.getStorageBranchIndexer(), is(not((IStorageBranchIndexer<DefaultData>) childIndexer)));\r\n    verify(branch.getStorageBranchIndexer()).setId(id);\r\n    storageBranchIndexer = new StorageBranchIndexer(delegateIndexer, childIndexer, id, false);\r\n    when(childIndexer.isPassId()).thenReturn(true);\r\n    when(childIndexer.getNewInstance()).thenReturn(mock(IStorageBranchIndexer.class));\r\n    component = storageBranchIndexer.getNextTreeComponent(defaultData);\r\n    assertThat(component, is(instanceOf(StorageBranch.class)));\r\n    branch = (StorageBranch<DefaultData>) component;\r\n    assertThat(branch.getStorageBranchIndexer(), is(not((IStorageBranchIndexer<DefaultData>) childIndexer)));\r\n    verify(branch.getStorageBranchIndexer(), times(0)).setId(anyInt());\r\n    when(childIndexer.isPassId()).thenReturn(false);\r\n    component = storageBranchIndexer.getNextTreeComponent(defaultData);\r\n    assertThat(component, is(instanceOf(StorageBranch.class)));\r\n    branch = (StorageBranch<DefaultData>) component;\r\n    assertThat(branch.getStorageBranchIndexer(), is((IStorageBranchIndexer<DefaultData>) childIndexer));\r\n    verify(childIndexer, times(0)).setId(anyInt());\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.cmr.property.configuration.SingleProperty.validateForValue",
	"Comment": "check if the property would have validation errors if given value would be set.",
	"Method": "PropertyValidation validateForValue(T value){\r\n    PropertyValidation propertyValidation = PropertyValidation.createFor(this);\r\n    if (CollectionUtils.isNotEmpty(validators)) {\r\n        for (ISinglePropertyValidator<? super T> validator : validators) {\r\n            validator.validateForValue(this, propertyValidation, value);\r\n        }\r\n    }\r\n    return propertyValidation;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.Client.discoverHosts",
	"Comment": "broadcasts a udp message on the lan to discover any running servers.",
	"Method": "List<InetAddress> discoverHosts(int udpPort,int timeoutMillis){\r\n    List<InetAddress> hosts = new ArrayList<InetAddress>();\r\n    DatagramSocket socket = null;\r\n    try {\r\n        socket = new DatagramSocket();\r\n        broadcast(udpPort, socket);\r\n        socket.setSoTimeout(timeoutMillis);\r\n        while (true) {\r\n            DatagramPacket packet = new DatagramPacket(new byte[0], 0);\r\n            try {\r\n                socket.receive(packet);\r\n            } catch (SocketTimeoutException ex) {\r\n                if (INFO) {\r\n                    info(\"kryonet\", \"Host discovery timed out.\");\r\n                }\r\n                return hosts;\r\n            }\r\n            if (INFO) {\r\n                info(\"kryonet\", \"Discovered server: \" + packet.getAddress());\r\n            }\r\n            hosts.add(packet.getAddress());\r\n        }\r\n    } catch (IOException ex) {\r\n        if (ERROR) {\r\n            error(\"kryonet\", \"Host discovery failed.\", ex);\r\n        }\r\n        return hosts;\r\n    } finally {\r\n        if (socket != null) {\r\n            socket.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Date.startOfMonth",
	"Comment": "calculates, and returns, a date representing the first day of the monthrelative to the current date.",
	"Method": "Date startOfMonth(){\r\n    return new Date(date.dayOfMonth().withMinimumValue());\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.business.DynamicNameExtractionPart.createStringSourceSection",
	"Comment": "creates control section for selection of the string source.",
	"Method": "void createStringSourceSection(){\r\n    createSectionHeading(\"String Source Selection\");\r\n    Label selectionComboLabel = toolkit.createLabel(mainComposite, \"String source:\");\r\n    GridData gridData = new GridData(SWT.LEFT, SWT.CENTER, false, false);\r\n    gridData.widthHint = 150;\r\n    selectionComboLabel.setLayoutData(gridData);\r\n    stringSourceSelectionCombo = new Combo(mainComposite, SWT.BORDER | SWT.DROP_DOWN | SWT.READ_ONLY);\r\n    stringSourceSelectionCombo.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false, NUM_COLUMNS - 2, 1));\r\n    String[] items = new String[MatchingRuleType.values().length];\r\n    for (int i = 0; i < MatchingRuleType.values().length; i++) {\r\n        items[i] = MatchingRuleType.values()[i].toString().replace(\" Matching\", \"\");\r\n    }\r\n    stringSourceSelectionCombo.setItems(items);\r\n    stringSourceSelectionCombo.select(0);\r\n    addControl(stringSourceSelectionCombo);\r\n    final Label stringSourceSelectionLabelInfoImage = toolkit.createLabel(mainComposite, NAME_PATTERN_DESCRIPTION);\r\n    stringSourceSelectionLabelInfoImage.setImage(InspectIT.getDefault().getImage(InspectITImages.IMG_INFORMATION));\r\n    stringSourceSelectionLabelInfoImage.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));\r\n    stringSourceSelectionLabelInfoImage.setToolTipText(DESCRIPTION_STRING_SOURCE);\r\n    moveBelowForStringValueSourceControls = stringSourceSelectionLabelInfoImage;\r\n    stringSourceSelectionCombo.addSelectionListener(new SelectionAdapter() {\r\n        @Override\r\n        public void widgetSelected(SelectionEvent e) {\r\n            stringSourceSelectionChanged();\r\n        }\r\n    });\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.business.DynamicNameExtractionPart.createStringSourceSection",
	"Comment": "creates control section for selection of the string source.",
	"Method": "void createStringSourceSection(){\r\n    stringSourceSelectionChanged();\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.util.ClipboardUtil.textToClipboard",
	"Comment": "sets the given text to the clipboard so it can be used by other application.",
	"Method": "void textToClipboard(Display display,String text){\r\n    Assert.isNotNull(display);\r\n    if (null == text) {\r\n        return;\r\n    }\r\n    TextTransfer textTransfer = TextTransfer.getInstance();\r\n    Clipboard cb = new Clipboard(display);\r\n    cb.setContents(new Object[] { text }, new Transfer[] { textTransfer });\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Date.sameDayOfYearAs",
	"Comment": "determines if this date and the specified date represent the same day ofthe year, eg both dates are for the 108th day of the year.",
	"Method": "boolean sameDayOfYearAs(Date as){\r\n    return sameAs(as, DateTimeFieldType.dayOfYear());\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.ci.AlertingDefinition.replaceNotificationEmailAddresses",
	"Comment": "replaces the current notification email addresses with the ones of the given list.",
	"Method": "void replaceNotificationEmailAddresses(List<String> newNotificationEmailAddresses){\r\n    if (newNotificationEmailAddresses == null) {\r\n        throw new IllegalArgumentException(\"Replacing notification email list with 'null'.\");\r\n    }\r\n    notificationEmailAddresses.clear();\r\n    for (String emailAddress : newNotificationEmailAddresses) {\r\n        addNotificationEmailAddress(emailAddress);\r\n    }\r\n}"
}, {
	"Path": "j2html.tags.Tag.withClasses",
	"Comment": "convenience methods that call attr with predefined attributes",
	"Method": "T withClasses(String classes){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (String s : classes) {\r\n        sb.append(s != null ? s : \"\").append(\" \");\r\n    }\r\n    return attr(Attr.CLASS, sb.toString().trim());\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.communication.data.InvocationSequenceDataHelper.hasCapturedParametersInInvocationSequence",
	"Comment": "checks if the invocation sequence data object itself contains parameters.",
	"Method": "boolean hasCapturedParametersInInvocationSequence(InvocationSequenceData data){\r\n    return (null != data.getParameterContentData()) && !data.getParameterContentData().isEmpty();\r\n}"
}, {
	"Path": "org.apache.isis.applib.layout.component.FieldSet.getOwner",
	"Comment": "owner.set programmatically by framework after reading in from xml.",
	"Method": "FieldSetOwner getOwner(){\r\n    return owner;\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.service.rules.impl.TimeWastingOperationsRule.setMinimumBaseline",
	"Comment": "ensures that the baseline is not below 100ms. otherwise the diagnosis can take too long.",
	"Method": "void setMinimumBaseline(){\r\n    if (baseline < MINIMUMBASELINE) {\r\n        baseline = MINIMUMBASELINE;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.storage.nio.ByteBufferProviderTest.acquireAndRelease",
	"Comment": "tests that acquire and release of the buffer will have the correct side effects.",
	"Method": "void acquireAndRelease(){\r\n    byteBufferProvider.setBufferSize(1);\r\n    byteBufferProvider.setPoolMaxCapacity(2);\r\n    byteBufferProvider.setPoolMinCapacity(1);\r\n    byteBufferProvider.init();\r\n    assertThat(byteBufferProvider.getCreatedCapacity(), is(equalTo(0L)));\r\n    assertThat(byteBufferProvider.getAvailableCapacity(), is(equalTo(0L)));\r\n    ByteBuffer buffer = byteBufferProvider.acquireByteBuffer();\r\n    assertThat(buffer, is(notNullValue()));\r\n    assertThat(byteBufferProvider.getBufferPoolSize(), is(equalTo(0)));\r\n    assertThat(byteBufferProvider.getCreatedCapacity(), is(equalTo(1L)));\r\n    assertThat(byteBufferProvider.getAvailableCapacity(), is(equalTo(0L)));\r\n    byteBufferProvider.releaseByteBuffer(buffer);\r\n    assertThat(byteBufferProvider.getBufferPoolSize(), is(equalTo(1)));\r\n    assertThat(byteBufferProvider.getCreatedCapacity(), is(equalTo(1L)));\r\n    assertThat(byteBufferProvider.getAvailableCapacity(), is(equalTo(1L)));\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.cmr.property.configuration.GroupedProperty.validateForPropertiesUpdate",
	"Comment": "validates with the group validators this property, based on the changes of the single\tproperties reported by update list.",
	"Method": "void validateForPropertiesUpdate(Collection<IPropertyUpdate<?>> propertyUpdates){\r\n    PropertyValidation propertyValidation = PropertyValidation.createFor(this);\r\n    for (IGroupedProperyValidator groupedProperyValidator : validators) {\r\n        groupedProperyValidator.validateForPropertyUpdates(this, propertyUpdates, propertyValidation);\r\n    }\r\n    if (propertyValidation.hasErrors()) {\r\n        throw new PropertyValidationException(propertyValidation);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.util.UnderlyingSystemInfo.getJavaVendorMatches",
	"Comment": "matches the vendor name provided with the vendor of the jvm.",
	"Method": "boolean getJavaVendorMatches(String vendor){\r\n    if (null != JAVA_VENDOR) {\r\n        return JAVA_VENDOR.indexOf(vendor) != -1;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.validation.ValidationControlDecoration.controlActive",
	"Comment": "returns if control is active. no validation will be process when control is not active.",
	"Method": "boolean controlActive(){\r\n    return control.isEnabled();\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.ExceptionImageFactory.decorateImageWithException",
	"Comment": "the passed image will be decorated with an overlay which is defined on the event type of the\texception transparently.",
	"Method": "Image decorateImageWithException(Image image,ExceptionSensorData data,ResourceManager resourceManager){\r\n    ImageDescriptor exceptionDesc = getImageDescriptor(data);\r\n    DecorationOverlayIcon icon = new DecorationOverlayIcon(image, exceptionDesc, IDecoration.BOTTOM_RIGHT);\r\n    Image createdImage = resourceManager.createImage(icon);\r\n    return createdImage;\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.engine.session.SessionPool.defaultConfig",
	"Comment": "utility method to create a default genericobjectpool.config with configuration values from\tdiagnosisengineconfiguration.",
	"Method": "GenericObjectPool.Config defaultConfig(DiagnosisEngineConfiguration<?, ?> configuration){\r\n    GenericObjectPool.Config config = new GenericObjectPool.Config();\r\n    config.whenExhaustedAction = GenericObjectPool.DEFAULT_WHEN_EXHAUSTED_ACTION;\r\n    config.maxActive = configuration.getNumSessionWorkers();\r\n    return config;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.LocalStorageData.copyStorageDataInformation",
	"Comment": "copies the local storage data information in this local storage instance.",
	"Method": "void copyStorageDataInformation(StorageData storageData){\r\n    this.setId(storageData.getId());\r\n    this.setName(storageData.getName());\r\n    this.setDescription(storageData.getDescription());\r\n    this.setDiskSize(storageData.getDiskSize());\r\n    this.setCmrVersion(storageData.getCmrVersion());\r\n    this.labelList = storageData.getLabelList();\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.ImageFormatter.getAgentImage",
	"Comment": "returns the image for the agent based on the last data sent date.",
	"Method": "Image getAgentImage(AgentStatusData agentStatusData){\r\n    if (null != agentStatusData) {\r\n        switch(agentStatusData.getAgentConnection()) {\r\n            case CONNECTED:\r\n                if (null != agentStatusData.getMillisSinceLastData()) {\r\n                    long millis = agentStatusData.getMillisSinceLastData().longValue();\r\n                    if (millis > 60000) {\r\n                        return InspectIT.getDefault().getImage(InspectITImages.IMG_AGENT_NOT_SENDING);\r\n                    } else {\r\n                        return InspectIT.getDefault().getImage(InspectITImages.IMG_AGENT_ACTIVE);\r\n                    }\r\n                } else {\r\n                    return InspectIT.getDefault().getImage(InspectITImages.IMG_AGENT_NOT_SENDING);\r\n                }\r\n            case NO_KEEP_ALIVE:\r\n                return InspectIT.getDefault().getImage(InspectITImages.IMG_AGENT_NO_KEEPALIVE);\r\n            default:\r\n                return InspectIT.getDefault().getImage(InspectITImages.IMG_AGENT_NOT_ACTIVE);\r\n        }\r\n    } else {\r\n        return InspectIT.getDefault().getImage(InspectITImages.IMG_AGENT_NOT_ACTIVE);\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.applib.layout.grid.bootstrap3.BS3TabGroup.isCollapseIfOne",
	"Comment": "if there is a single tab in the tabgroup, then whether to collapse and render without the outer tab.",
	"Method": "Boolean isCollapseIfOne(){\r\n    return collapseIfOne;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.SensorAssignmentMasterBlock.updateButtonsState",
	"Comment": "updates the state of the remove button depending on the current selection.",
	"Method": "void updateButtonsState(ISelection selection){\r\n    if (selection.isEmpty()) {\r\n        removeButton.setEnabled(false);\r\n        duplicateButton.setEnabled(false);\r\n    } else {\r\n        removeButton.setEnabled(canEdit);\r\n        duplicateButton.setEnabled(canEdit);\r\n    }\r\n    addButton.setEnabled(canEdit);\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.model.common.PageParametersUtils.newPageParameters",
	"Comment": "creates a new instance of pageparameters that preserves some special request parameterswhich should propagate in all links created by isis",
	"Method": "PageParameters newPageParameters(){\r\n    final PageParameters newPageParameters = new PageParameters();\r\n    final RequestCycle cycle = RequestCycle.get();\r\n    if (cycle != null) {\r\n        final IPageRequestHandler pageRequestHandler = PageRequestHandlerTracker.getFirstHandler(cycle);\r\n        final PageParameters currentPageParameters = pageRequestHandler.getPageParameters();\r\n        if (currentPageParameters != null) {\r\n            final StringValue noHeader = currentPageParameters.get(ISIS_NO_HEADER_PARAMETER_NAME);\r\n            if (!noHeader.isNull()) {\r\n                newPageParameters.set(ISIS_NO_HEADER_PARAMETER_NAME, noHeader.toString());\r\n            }\r\n            final StringValue noFooter = currentPageParameters.get(ISIS_NO_FOOTER_PARAMETER_NAME);\r\n            if (!noFooter.isNull()) {\r\n                newPageParameters.set(ISIS_NO_FOOTER_PARAMETER_NAME, noFooter.toString());\r\n            }\r\n        }\r\n    }\r\n    return newPageParameters;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.instrumentation.config.impl.StrategyConfig.getClassName",
	"Comment": "returns the fully qualified class name of this configuration.",
	"Method": "String getClassName(){\r\n    return className;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.serializer.impl.InvocationSequenceCustomCompatibleFieldSerializer.connectChildren",
	"Comment": "sets the parent to all nested sequences of the invocation to the correct one.",
	"Method": "void connectChildren(InvocationSequenceData parent){\r\n    if (null != parent.getNestedSequences()) {\r\n        for (InvocationSequenceData child : parent.getNestedSequences()) {\r\n            child.setParentSequence(parent);\r\n            connectChildren(child);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.util.AccessibleArrowImage.drawCompositeImage",
	"Comment": "draw the composite images.\tsubclasses must implement this framework method to paint images within the given bounds using\tone or more calls to the drawimage framework method.",
	"Method": "void drawCompositeImage(int width,int height){\r\n    Display display = Display.getDefault();\r\n    Image image = new Image(display, ARROW_SIZE, ARROW_SIZE * 2);\r\n    GC gc = new GC(image);\r\n    Color triangle = createColor(SWT.COLOR_LIST_FOREGROUND, SWT.COLOR_LIST_BACKGROUND, 20, display);\r\n    Color aliasing = createColor(SWT.COLOR_LIST_FOREGROUND, SWT.COLOR_LIST_BACKGROUND, 30, display);\r\n    gc.setBackground(triangle);\r\n    if (fLTR) {\r\n        gc.fillPolygon(new int[] { mirror(0), 0, mirror(ARROW_SIZE), ARROW_SIZE, mirror(0), ARROW_SIZE * 2 });\r\n    } else {\r\n        gc.fillPolygon(new int[] { ARROW_SIZE, 0, 0, ARROW_SIZE, ARROW_SIZE, ARROW_SIZE * 2 });\r\n    }\r\n    gc.setForeground(aliasing);\r\n    gc.drawLine(mirror(0), 1, mirror(ARROW_SIZE - 1), ARROW_SIZE);\r\n    gc.drawLine(mirror(ARROW_SIZE - 1), ARROW_SIZE, mirror(0), (ARROW_SIZE * 2) - 1);\r\n    gc.dispose();\r\n    triangle.dispose();\r\n    aliasing.dispose();\r\n    ImageData imageData = image.getImageData();\r\n    for (int y = 1; y < ARROW_SIZE; y++) {\r\n        for (int x = 0; x < y; x++) {\r\n            imageData.setAlpha(mirror(x), y, 255);\r\n        }\r\n    }\r\n    for (int y = 0; y < ARROW_SIZE; y++) {\r\n        for (int x = 0; x <= y; x++) {\r\n            imageData.setAlpha(mirror(x), (ARROW_SIZE * 2) - y - 1, 255);\r\n        }\r\n    }\r\n    int offset = 0;\r\n    if (!fLTR) {\r\n        offset = -1;\r\n    }\r\n    drawImage(imageData, ((width / 2) - (ARROW_SIZE / 2)) + offset, (height / 2) - ARROW_SIZE - 1);\r\n    image.dispose();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.serializer.impl.SerializationManager.setSchemaManager",
	"Comment": "this setter can be removed when the spring3.0 on the gui side is working properly.",
	"Method": "void setSchemaManager(ClassSchemaManager schemaManager){\r\n    this.schemaManager = schemaManager;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.ci.business.valuesource.StringValueSource.hasOptions",
	"Comment": "indicates whether the value source has a set of options to be compared to.",
	"Method": "boolean hasOptions(){\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.isis.applib.services.error.Ticket.getKittenUrl",
	"Comment": "if specified, is the external url of an image to display to the end user.not necessarily of a kitten, but something by way of an apology.",
	"Method": "String getKittenUrl(){\r\n    return kittenUrl;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.preferences.control.samplingrate.test.TimeframeDividerTest.allValuesInOneTimeframe",
	"Comment": "if all values are in one timeframe, then the result must be 1.",
	"Method": "void allValuesInOneTimeframe(){\r\n    List<? extends DefaultData> resultList = null;\r\n    Sensitivity sensitivity = SamplingRateControl.Sensitivity.VERY_COARSE;\r\n    Date fromDate = new Date(1221364800000L);\r\n    Date toDate = new Date(1221472800000L);\r\n    resultList = mode.adjustSamplingRate(dataObjects, fromDate, toDate, sensitivity.getValue(), new ClassLoadingInformationDataAggregator());\r\n    assertThat(resultList.size(), is(equalTo(1)));\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.graph.plot.DateAxisZoomNotify.notifyZoomListeners",
	"Comment": "notifies all zoom listeners that a zooming event occurred.",
	"Method": "void notifyZoomListeners(){\r\n    Object[] listeners = zoomListeners.getListeners();\r\n    for (Object listener : listeners) {\r\n        ((ZoomListener) listener).zoomOccured();\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.storage.nio.ByteBufferProviderTest.creationUntilMax",
	"Comment": "tests that no buffer will be created after max pool capacity has been reached.",
	"Method": "void creationUntilMax(){\r\n    int maxCapacity = 3;\r\n    byteBufferProvider.setBufferSize(1);\r\n    byteBufferProvider.setPoolMaxCapacity(maxCapacity);\r\n    byteBufferProvider.init();\r\n    for (int i = 0; i < maxCapacity; i++) {\r\n        ByteBuffer buffer = byteBufferProvider.acquireByteBuffer();\r\n        assertThat(buffer, is(notNullValue()));\r\n    }\r\n    assertThat(byteBufferProvider.getBufferPoolSize(), is(equalTo(0)));\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.text.input.VmSummaryInputController.addMinimizedSectionNotAvailable",
	"Comment": "adds a section which is not available due to not activated platform sensor types.",
	"Method": "void addMinimizedSectionNotAvailable(Composite parent,FormToolkit toolkit,String sectionTitle,int numColums){\r\n    Section section = toolkit.createSection(parent, ExpandableComposite.TITLE_BAR | ExpandableComposite.TWISTIE);\r\n    section.setText(sectionTitle);\r\n    section.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true, false));\r\n    Composite sectionComposite = toolkit.createComposite(section);\r\n    GridLayout gridLayout = new GridLayout(numColums, false);\r\n    gridLayout.marginLeft = 5;\r\n    gridLayout.marginTop = 5;\r\n    sectionComposite.setLayout(gridLayout);\r\n    section.setClient(sectionComposite);\r\n    if (!minimizedSections.containsKey(sectionTitle)) {\r\n        minimizedSections.put(sectionTitle, sectionComposite);\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Date.sameWeekAs",
	"Comment": "determines if this date and the specified date represent the same week inthe year, eg both dates are the for the 18th week of the year.",
	"Method": "boolean sameWeekAs(Date as){\r\n    return sameAs(as, DateTimeFieldType.weekOfWeekyear());\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.storage.nio.stream.AbstractExtendedByteBufferInputStream.prepare",
	"Comment": "prepares the stream for read. must be called before any read operation is executed.\timplementing classes must extend this method in way that full buffers queue is filled with\tdata that will be available for the reader of input stream.",
	"Method": "void prepare(){\r\n    int buffers = numberOfBuffers;\r\n    if (buffers < MIN_BUFFERS) {\r\n        buffers = MIN_BUFFERS;\r\n    } else if (buffers > MAX_BUFFERS) {\r\n        buffers = MAX_BUFFERS;\r\n    }\r\n    for (int i = 0; i < buffers; i++) {\r\n        ByteBuffer byteBuffer = byteBufferProvider.acquireByteBuffer();\r\n        emptyBuffers.add(byteBuffer);\r\n    }\r\n    numberOfBuffers = buffers;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.util.ElementOccurrenceCount.emptyElement",
	"Comment": "returns the empty element. the returned element content can not be changed.",
	"Method": "ElementOccurrenceCount emptyElement(){\r\n    return empty;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.Modifier.isPublic",
	"Comment": "returns true if the modifiers include the public modifier.",
	"Method": "boolean isPublic(int mod){\r\n    return (mod & PUBLIC) != 0;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.wizard.page.AlertSourceDefinitionWizardPage.alreadyExists",
	"Comment": "indicates whether an element with such a name already exists.",
	"Method": "boolean alreadyExists(String name){\r\n    for (String item : existingItems) {\r\n        if (item.equals(name)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.github.jamm.MemoryMeter.enableDebug",
	"Comment": "makes this memorymeter prints the classes tree to system.out up to the specified depthwhen measuring",
	"Method": "MemoryMeter enableDebug(MemoryMeter enableDebug,int depth){\r\n    if (depth <= 0)\r\n        throw new IllegalArgumentException(String.format(\"the depth must be greater than zero (was %s).\", depth));\r\n    return new MemoryMeter(trackerProvider, includeFullBufferSize, guess, ignoreOuterClassReference, ignoreKnownSingletons, ignoreNonStrongReferences, new TreePrinter.Factory(depth));\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.DateTime.isEqualTo",
	"Comment": "returns true if the time stamp of this object has the same value as thespecified time",
	"Method": "boolean isEqualTo(DateTime timeStamp){\r\n    return this.dateTime.equals((timeStamp).dateTime);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.ImageFormatter.getOverlayedImage",
	"Comment": "returns an overlayed icon of the passed main image using the passed images as overlays.",
	"Method": "Image getOverlayedImage(Image main,ResourceManager resourceManager,double scaleFactor,Image overlays){\r\n    ImageDescriptor[] descriptors = new ImageDescriptor[overlays.length];\r\n    for (int i = 0; i < overlays.length; i++) {\r\n        if (null != overlays[i]) {\r\n            ImageData imageData = overlays[i].getImageData();\r\n            imageData = imageData.scaledTo((int) (scaleFactor * imageData.width), (int) (scaleFactor * imageData.height));\r\n            descriptors[i] = ImageDescriptor.createFromImageData(imageData);\r\n        }\r\n    }\r\n    DecorationOverlayIcon icon = new DecorationOverlayIcon(main, descriptors);\r\n    Image img = resourceManager.createImage(icon);\r\n    return img;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.storage.InspectITStorageManager.getMountedAvailableStorages",
	"Comment": "returns mounted and available storages, thus the ones that can be read from.",
	"Method": "Collection<LocalStorageData> getMountedAvailableStorages(){\r\n    return Collections.unmodifiableSet(mountedAvailableStorages.keySet());\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.repository.service.storage.AbstractStorageService.cacheQueryResultLocally",
	"Comment": "caches result locally for the given storage under given hash.",
	"Method": "void cacheQueryResultLocally(LocalStorageData localStorageData,List<E> results,int hash){\r\n    try {\r\n        storageManager.cacheStorageData(localStorageData, results, hash);\r\n    } catch (IOException | SerializationException e) {\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.nio.CustomAsyncChannel.read",
	"Comment": "reads to the file channel if the channel is open. if the channel is closed, the read will not\tbe done, and false will be returned.",
	"Method": "boolean read(ByteBuffer dst,long position,A attachment,CompletionHandler<Integer, ? super A> handler){\r\n    writeReadChannelLock.lock();\r\n    try {\r\n        if (this.isOpened()) {\r\n            fileChannel.read(dst, position, attachment, handler);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    } finally {\r\n        writeReadChannelLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.InspectIT.isDevelopment",
	"Comment": "returns whether the current environment is a development environment.",
	"Method": "boolean isDevelopment(){\r\n    if (developmentEnvironment == null) {\r\n        File bundleFile = null;\r\n        try {\r\n            bundleFile = FileLocator.getBundleFile(getBundle());\r\n            if ((bundleFile != null) && bundleFile.isDirectory()) {\r\n                developmentEnvironment = Boolean.TRUE;\r\n            } else {\r\n                developmentEnvironment = Boolean.FALSE;\r\n            }\r\n        } catch (IOException e) {\r\n            developmentEnvironment = Boolean.FALSE;\r\n        }\r\n    }\r\n    return developmentEnvironment.booleanValue();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.communication.data.InvocationSequenceDataHelper.hasLoggingData",
	"Comment": "checks whether this data object contains a loggingdata object.",
	"Method": "boolean hasLoggingData(InvocationSequenceData data){\r\n    return null != data.getLoggingData();\r\n}"
}, {
	"Path": "org.apache.isis.core.commons.lang.ListExtensions.mergeWith",
	"Comment": "returns list1 with everything in list2, ignoring duplicates.",
	"Method": "List<T> mergeWith(List<T> extendee,List<T> list2){\r\n    for (final T obj : list2) {\r\n        if (!(extendee.contains(obj))) {\r\n            extendee.add(obj);\r\n        }\r\n    }\r\n    return extendee;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.InspectIT.getService",
	"Comment": "returns a service, if one is registered with the bundle context.",
	"Method": "E getService(Class<E> clazz){\r\n    ServiceReference<E> reference = getDefault().getBundle().getBundleContext().getServiceReference(clazz);\r\n    if (null != reference) {\r\n        return getDefault().getBundle().getBundleContext().getService(reference);\r\n    }\r\n    throw new RuntimeException(\"Requested service of the class \" + clazz.getName() + \" is not registered in the bundle.\");\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.ui.components.collectioncontents.ajaxtable.IsisAjaxHeadersToolbar.newSortableHeader",
	"Comment": "factory method for sortable header components. a sortable header component must have id ofheaderid and conform to markup specified in headerstoolbar.html",
	"Method": "WebMarkupContainer newSortableHeader(String headerId,S property,ISortStateLocator<S> locator){\r\n    return new OrderByBorder<S>(headerId, property, locator) {\r\n        private static final long serialVersionUID = 1L;\r\n        @Override\r\n        protected void onSortChanged() {\r\n            getTable().setCurrentPage(0);\r\n        }\r\n    };\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.ui.components.collectioncontents.ajaxtable.IsisAjaxHeadersToolbar.newSortableHeader",
	"Comment": "factory method for sortable header components. a sortable header component must have id ofheaderid and conform to markup specified in headerstoolbar.html",
	"Method": "WebMarkupContainer newSortableHeader(String headerId,S property,ISortStateLocator<S> locator){\r\n    getTable().setCurrentPage(0);\r\n}"
}, {
	"Path": "org.apache.isis.viewer.restfulobjects.rendering.ReprRendererAbstract.addExtensionsIsisProprietaryChangedObjects",
	"Comment": "convenience for representations that are returned from objects thatmutate state.",
	"Method": "void addExtensionsIsisProprietaryChangedObjects(){\r\n    final List<ObjectAdapter> changedObjects = Lists.newArrayList();\r\n    final List<ObjectAdapter> disposedObjects = Lists.newArrayList();\r\n    addToExtensions(\"changed\", changedObjects);\r\n    addToExtensions(\"disposed\", disposedObjects);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.viewers.StyledCellIndexLabelProvider.getFont",
	"Comment": "default behavior is to return null. clients should override this method if\tneeded.",
	"Method": "Font getFont(Object element,int index){\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.TextFormatter.getInvocationAwareDataTextualRepresentation",
	"Comment": "get the textual representation of objects that will be displayed in the new view.",
	"Method": "String getInvocationAwareDataTextualRepresentation(InvocationAwareData invAwareData,RepositoryDefinition repositoryDefinition){\r\n    if (invAwareData instanceof SqlStatementData) {\r\n        SqlStatementData sqlData = (SqlStatementData) invAwareData;\r\n        return \"SQL: \" + sqlData.getSql();\r\n    } else if (invAwareData instanceof RegExAggregatedHttpTimerData) {\r\n        return \"transformed URI: \" + ((RegExAggregatedHttpTimerData) invAwareData).getTransformedUri();\r\n    } else if (invAwareData instanceof HttpTimerData) {\r\n        HttpTimerData timerData = (HttpTimerData) invAwareData;\r\n        if (!HttpInfo.UNDEFINED.equals(timerData.getHttpInfo().getUri())) {\r\n            return \"URI: \" + timerData.getHttpInfo().getUri();\r\n        } else {\r\n            return \"Usecase: \" + timerData.getHttpInfo().getInspectItTaggingHeaderValue();\r\n        }\r\n    } else if (invAwareData instanceof ExceptionSensorData) {\r\n        ExceptionSensorData exData = (ExceptionSensorData) invAwareData;\r\n        return \"Exception: \" + exData.getThrowableType();\r\n    } else if (invAwareData instanceof TimerData) {\r\n        TimerData timerData = (TimerData) invAwareData;\r\n        MethodIdent methodIdent = repositoryDefinition.getCachedDataService().getMethodIdentForId(timerData.getMethodIdent());\r\n        return TextFormatter.getMethodString(methodIdent);\r\n    }\r\n    return \"\";\r\n}"
}, {
	"Path": "org.apache.isis.core.commons.config.IsisConfigurationDefault.referedToAs",
	"Comment": "returns as a string that the named property is refered to as. for examplein a simple properties file the property z might be specified in the fileas x.y.z.",
	"Method": "String referedToAs(String name){\r\n    return name;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.rmi.ObjectSpace.getRegisteredObject",
	"Comment": "returns the first object registered with the specified id in any of the objectspaces the\tspecified connection belongs to.",
	"Method": "Object getRegisteredObject(Connection connection,int objectID){\r\n    ObjectSpace[] instances = ObjectSpace.instances;\r\n    for (ObjectSpace objectSpace : instances) {\r\n        Connection[] connections = objectSpace.connections;\r\n        for (Connection connection2 : connections) {\r\n            if (connection2 != connection) {\r\n                continue;\r\n            }\r\n            Object object = objectSpace.idToObject.get(objectID);\r\n            if (object != null) {\r\n                return object;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.ci.AlertingDefinition.removeTag",
	"Comment": "removes the tag with the given key from the alerting definition.",
	"Method": "void removeTag(String tagKey){\r\n    if (tagKey == null) {\r\n        throw new IllegalArgumentException(\"Removing tag with key 'null'.\");\r\n    } else if (tagKey.isEmpty()) {\r\n        throw new IllegalArgumentException(\"Removing tag with empty key.\");\r\n    } else if (!tags.containsKey(tagKey)) {\r\n        throw new IllegalArgumentException(\"Removing tag with key '\" + tagKey + \"'.\");\r\n    } else {\r\n        tags.remove(tagKey);\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.properties.accessor.PropertyAccessorFacetViaAccessorFactory.isCollectionAccessor",
	"Comment": "the method way well represent a collection, but this facet factory doesnot have any opinion on the matter.",
	"Method": "boolean isCollectionAccessor(Method method){\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.isis.core.commons.config.IsisConfigurationDefault.getBoolean",
	"Comment": "gets the boolean value for the specified name. if no property isspecified with this name then the specified default boolean value isreturned.",
	"Method": "boolean getBoolean(String name,boolean getBoolean,String name,boolean defaultValue){\r\n    String value = getPropertyElseNull(name);\r\n    if (value == null) {\r\n        return defaultValue;\r\n    }\r\n    value = value.toLowerCase();\r\n    if (value.equals(\"on\") || value.equals(\"yes\") || value.equals(\"true\") || value.equals(\"\")) {\r\n        return true;\r\n    }\r\n    if (value.equals(\"off\") || value.equals(\"no\") || value.equals(\"false\")) {\r\n        return false;\r\n    }\r\n    throw new IsisConfigurationException(\"Illegal flag for \" + name + \"; must be one of on, off, yes, no, true or false\");\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.repository.CmrRepositoryManager.removeCmrRepositoryDefinition",
	"Comment": "removes a repository definition and notifies all registered listeners.",
	"Method": "void removeCmrRepositoryDefinition(CmrRepositoryDefinition cmrRepositoryDefinition){\r\n    for (CmrRepositoryChangeListener repositoryChangeListener : cmrRepositoryChangeListeners) {\r\n        cmrRepositoryDefinition.removeCmrRepositoryChangeListener(repositoryChangeListener);\r\n    }\r\n    cmrRepositoryDefinitions.remove(cmrRepositoryDefinition);\r\n    savePreference();\r\n    for (CmrRepositoryChangeListener repositoryChangeListener : cmrRepositoryChangeListeners) {\r\n        repositoryChangeListener.repositoryRemoved(cmrRepositoryDefinition);\r\n    }\r\n    UpdateRepositoryJob updateRepositoryJob = repositoryUpdateJobMap.remove(cmrRepositoryDefinition);\r\n    if (null != updateRepositoryJob) {\r\n        updateRepositoryJob.cancel();\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.Date.sameDayOfMonthAs",
	"Comment": "determines if this date and the specified date represent the same day ofthe month, eg both dates are for the 3rd.",
	"Method": "boolean sameDayOfMonthAs(Date as){\r\n    return sameAs(as, DateTimeFieldType.dayOfMonth());\r\n}"
}, {
	"Path": "j2html.TagCreator.area",
	"Comment": "emptytags, generated in class j2html.tags.tagcreatorcodegenerator",
	"Method": "EmptyTag area(EmptyTag area,Attr.ShortForm shortAttr){\r\n    return Attr.addTo(new EmptyTag(\"area\"), shortAttr);\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.model.models.ScalarModel.getAuthenticationSession",
	"Comment": "default implementation looks up from singleton, but can be overridden fortesting.",
	"Method": "AuthenticationSession getAuthenticationSession(){\r\n    return getPersistenceSession().getServicesInjector().lookupService(AuthenticationSessionProvider.class).getAuthenticationSession();\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.value.image.ImageValueSemanticsProviderAbstract.getParser",
	"Comment": "returns null to indicate that this value does not parse entry strings",
	"Method": "Parser<T> getParser(){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.isis.viewer.restfulobjects.rendering.service.conneg.ContentNegotiationServiceOrgApacheIsisV1.responseBuilder",
	"Comment": "for easy subclassing to further customize, eg additional headers",
	"Method": "Response.ResponseBuilder responseBuilder(Response.ResponseBuilder responseBuilder){\r\n    return responseBuilder;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.storage.nio.ByteBufferProviderTest.bufferNotAvailable",
	"Comment": "test that ioexception will be thrown when there is no buffer available any more.",
	"Method": "void bufferNotAvailable(){\r\n    byteBufferProvider.setBufferSize(1);\r\n    byteBufferProvider.setPoolMaxCapacity(1);\r\n    byteBufferProvider.setPoolMinCapacity(0);\r\n    byteBufferProvider.init();\r\n    ByteBuffer buffer = byteBufferProvider.acquireByteBuffer();\r\n    assertThat(buffer, is(notNullValue()));\r\n    buffer = byteBufferProvider.acquireByteBuffer();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.instrumentation.config.impl.PropertyPathStart.getSignaturePosition",
	"Comment": "returns the position of the parameter in the signature to read.",
	"Method": "int getSignaturePosition(){\r\n    return signaturePosition;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.util.AccessibleArrowImage.getSize",
	"Comment": "return the size of this composite image.\tsubclasses must implement this framework method.",
	"Method": "Point getSize(){\r\n    return new Point(10, 16);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.storage.util.DataRetriever.getCachedDataViaHttp",
	"Comment": "returns cached data for the storage from the cmr if the cached data exists for given hash. if\tdata does not exist null is returned.",
	"Method": "List<E> getCachedDataViaHttp(CmrRepositoryDefinition cmrRepositoryDefinition,StorageData storageData,int hash){\r\n    String cachedFileLocation = cmrRepositoryDefinition.getStorageService().getCachedStorageDataFileLocation(storageData, hash);\r\n    if (null == cachedFileLocation) {\r\n        return null;\r\n    } else {\r\n        HttpClient httpClient = new DefaultHttpClient();\r\n        HttpGet httpGet = new HttpGet(getServerUri(cmrRepositoryDefinition) + cachedFileLocation);\r\n        ISerializer serializer = null;\r\n        try {\r\n            serializer = serializerQueue.take();\r\n        } catch (InterruptedException e) {\r\n            Thread.interrupted();\r\n        }\r\n        InputStream inputStream = null;\r\n        Input input = null;\r\n        try {\r\n            HttpResponse response = httpClient.execute(httpGet);\r\n            HttpEntity entity = response.getEntity();\r\n            inputStream = entity.getContent();\r\n            input = new Input(inputStream);\r\n            Object object = serializer.deserialize(input);\r\n            List<E> receivedData = (List<E>) object;\r\n            return receivedData;\r\n        } finally {\r\n            if (null != inputStream) {\r\n                inputStream.close();\r\n            }\r\n            if (null != input) {\r\n                input.close();\r\n            }\r\n            serializerQueue.add(serializer);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.eum.Beacon.deserializationComplete",
	"Comment": "finalises the deserialization of all elements and optionally assigns a new session or tab id.",
	"Method": "void deserializationComplete(long sessionID,long tabID){\r\n    this.sessionID = sessionID;\r\n    this.tabID = tabID;\r\n    for (EUMBeaconElement element : data) {\r\n        element.deserializationComplete(this);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.instrumentation.classcache.Modifiers.getModifiers",
	"Comment": "returns the modifier with the correctly set bit for the package modifier if one should be\tdefined.",
	"Method": "int getModifiers(int originalMod){\r\n    if (isPublic(originalMod) || isPrivate(originalMod) || isProtected(originalMod)) {\r\n        return originalMod;\r\n    } else {\r\n        return originalMod | PACKAGE;\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.storage.impl.StorageBranchIndexerTest.nextComponentIsLeaf",
	"Comment": "test the creation of new component when leaf should be created.",
	"Method": "void nextComponentIsLeaf(){\r\n    int id = 1;\r\n    storageBranchIndexer = new StorageBranchIndexer(delegateIndexer, null, id, true);\r\n    DefaultData defaultData = mock(DefaultData.class);\r\n    InvocationSequenceData invocationSequenceData = mock(InvocationSequenceData.class);\r\n    IStorageTreeComponent<DefaultData> component = storageBranchIndexer.getNextTreeComponent(defaultData);\r\n    assertThat(component, is(instanceOf(LeafWithNoDescriptors.class)));\r\n    LeafWithNoDescriptors<DefaultData> leaf = (LeafWithNoDescriptors<DefaultData>) component;\r\n    assertThat(leaf.getId(), is(id));\r\n    component = storageBranchIndexer.getNextTreeComponent(invocationSequenceData);\r\n    assertThat(component, is(instanceOf(ArrayBasedStorageLeaf.class)));\r\n    ArrayBasedStorageLeaf<DefaultData> arrayLeaf = (ArrayBasedStorageLeaf<DefaultData>) component;\r\n    assertThat(arrayLeaf.getId(), is(id));\r\n    storageBranchIndexer = new StorageBranchIndexer(delegateIndexer, null, id, false);\r\n    component = storageBranchIndexer.getNextTreeComponent(defaultData);\r\n    assertThat(component, is(instanceOf(LeafWithNoDescriptors.class)));\r\n    leaf = (LeafWithNoDescriptors<DefaultData>) component;\r\n    assertThat(leaf.getId(), is(not(id)));\r\n    component = storageBranchIndexer.getNextTreeComponent(invocationSequenceData);\r\n    assertThat(component, is(instanceOf(ArrayBasedStorageLeaf.class)));\r\n    arrayLeaf = (ArrayBasedStorageLeaf<DefaultData>) component;\r\n    assertThat(arrayLeaf.getId(), is(not(id)));\r\n}"
}, {
	"Path": "org.apache.isis.applib.services.eventbus.CssClassUiEvent.setCssClass",
	"Comment": "for subscribers to call to provide a css class for this object.",
	"Method": "void setCssClass(String cssClass){\r\n    this.cssClass = cssClass;\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.object.bookmarkpolicy.bookmarkable.BookmarkPolicyFacetViaBookmarkableAnnotationElseFallbackFactory.refineMetaModelValidator",
	"Comment": "violation if there is an action that is bookmarkable but does not have safe action semantics.",
	"Method": "void refineMetaModelValidator(MetaModelValidatorComposite metaModelValidator,IsisConfiguration configuration){\r\n    metaModelValidator.add(new MetaModelValidatorVisiting(new MetaModelValidatorVisiting.Visitor() {\r\n        @Override\r\n        public boolean visit(ObjectSpecification objectSpec, ValidationFailures validationFailures) {\r\n            final Class<?> cls = objectSpec.getCorrespondingClass();\r\n            final List<ObjectAction> objectActions = objectSpec.getObjectActions(Contributed.EXCLUDED);\r\n            for (final ObjectAction objectAction : objectActions) {\r\n                final BookmarkPolicyFacet bookmarkFacet = objectAction.getFacet(BookmarkPolicyFacet.class);\r\n                if (bookmarkFacet == null || bookmarkFacet.isNoop() || bookmarkFacet.value() == BookmarkPolicy.NEVER) {\r\n                    continue;\r\n                }\r\n                final ActionSemanticsFacet semanticsFacet = objectAction.getFacet(ActionSemanticsFacet.class);\r\n                if (semanticsFacet == null || semanticsFacet.isNoop() || !semanticsFacet.value().isSafeInNature()) {\r\n                    validationFailures.add(\"%s: action is bookmarkable but action semantics are not explicitly indicated as being safe.  \" + \"Either add @Action(semantics=SemanticsOf.SAFE) or @Action(semantics=SemanticsOf.SAFE_AND_REQUEST_CACHEABLE), or remove @ActionLayout(bookmarking=...).\", objectAction.getIdentifier().toClassAndNameIdentityString());\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n    }));\r\n    metaModelValidator.add(validator);\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.object.bookmarkpolicy.bookmarkable.BookmarkPolicyFacetViaBookmarkableAnnotationElseFallbackFactory.refineMetaModelValidator",
	"Comment": "violation if there is an action that is bookmarkable but does not have safe action semantics.",
	"Method": "void refineMetaModelValidator(MetaModelValidatorComposite metaModelValidator,IsisConfiguration configuration){\r\n    final Class<?> cls = objectSpec.getCorrespondingClass();\r\n    final List<ObjectAction> objectActions = objectSpec.getObjectActions(Contributed.EXCLUDED);\r\n    for (final ObjectAction objectAction : objectActions) {\r\n        final BookmarkPolicyFacet bookmarkFacet = objectAction.getFacet(BookmarkPolicyFacet.class);\r\n        if (bookmarkFacet == null || bookmarkFacet.isNoop() || bookmarkFacet.value() == BookmarkPolicy.NEVER) {\r\n            continue;\r\n        }\r\n        final ActionSemanticsFacet semanticsFacet = objectAction.getFacet(ActionSemanticsFacet.class);\r\n        if (semanticsFacet == null || semanticsFacet.isNoop() || !semanticsFacet.value().isSafeInNature()) {\r\n            validationFailures.add(\"%s: action is bookmarkable but action semantics are not explicitly indicated as being safe.  \" + \"Either add @Action(semantics=SemanticsOf.SAFE) or @Action(semantics=SemanticsOf.SAFE_AND_REQUEST_CACHEABLE), or remove @ActionLayout(bookmarking=...).\", objectAction.getIdentifier().toClassAndNameIdentityString());\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.value.ValueSemanticsProviderAbstractTemporal.type",
	"Comment": "the facet type, used if not specified explicitly in the constructor.",
	"Method": "Class<? extends Facet> type(){\r\n    return DateValueFacet.class;\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.engine.session.Session.destroy",
	"Comment": "destroys this session. if the session was not yet passivated, it will be passivated in\tadvance. while the session is destroyed, the executorservice is shutdown and the\tsessioncontext is destroyed. after the session is destroyed it is unusable!",
	"Method": "void destroy(){\r\n    switch(state) {\r\n        case PROCESSED:\r\n            passivate();\r\n            break;\r\n        case DESTROYED:\r\n            LOG.warn(\"Failed destroying session. Session has already been destroyed!\");\r\n            return;\r\n        case NEW:\r\n        case ACTIVATED:\r\n            LOG.warn(\"Session is destroy before it was processed.\");\r\n            break;\r\n        case FAILURE:\r\n        case PASSIVATED:\r\n        default:\r\n            break;\r\n    }\r\n    state = State.DESTROYED;\r\n    sessionContext = null;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.rmi.ObjectSpace.setExecutor",
	"Comment": "sets the executor used to invoke methods when an invocation is received from a remote\tendpoint. by default, no executor is set and invocations occur on the network thread, which\tshould not be blocked for long.",
	"Method": "void setExecutor(Executor executor){\r\n    this.executor = executor;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.Composite.hasChildren",
	"Comment": "returns true if children are available under this composite.",
	"Method": "boolean hasChildren(){\r\n    return !components.isEmpty();\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.AbstractClassSensorAssignmentDetailsPage.createTitle",
	"Comment": "create title part based on the sensor configuration being assigned.",
	"Method": "FormText createTitle(Composite parent,FormToolkit toolkit){\r\n    title = toolkit.createFormText(parent, false);\r\n    title.setColor(\"header\", toolkit.getColors().getColor(IFormColors.TITLE));\r\n    title.setFont(\"header\", JFaceResources.getBannerFont());\r\n    return title;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.query.factory.impl.HttpTimerDataQueryFactory.getFindAllTaggedHttpTimersQuery",
	"Comment": "return query for all httptimerdata objects that have a inspectit tag header\tvalue.",
	"Method": "E getFindAllTaggedHttpTimersQuery(HttpTimerData httpData,Date fromDate,Date toDate){\r\n    E query = getIndexQueryProvider().getIndexQuery();\r\n    query.setPlatformIdent(httpData.getPlatformIdent());\r\n    ArrayList<Class<?>> classesToSearch = new ArrayList();\r\n    classesToSearch.add(HttpTimerData.class);\r\n    classesToSearch.add(AggregatedHttpTimerData.class);\r\n    query.setObjectClasses(classesToSearch);\r\n    query.addIndexingRestriction(IndexQueryRestrictionFactory.isNotNull(\"httpInfo.inspectItTaggingHeaderValue\"));\r\n    if (null != fromDate) {\r\n        query.setFromDate(new Timestamp(fromDate.getTime()));\r\n    }\r\n    if (null != toDate) {\r\n        query.setToDate(new Timestamp(toDate.getTime()));\r\n    }\r\n    return query;\r\n}"
}, {
	"Path": "org.apache.isis.core.runtime.snapshot.IsisSchema.getAttribute",
	"Comment": "gets an attribute with the supplied name in the isis namespace from thesupplied element",
	"Method": "String getAttribute(Element element,String attributeName){\r\n    return element.getAttributeNS(IsisSchema.NS_URI, attributeName);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.aggregation.impl.ExceptionDataAggregator.getCorrectStackTrace",
	"Comment": "returns the stack trace starting at the first line where the method trace starts.",
	"Method": "String getCorrectStackTrace(String stackTrace){\r\n    if (null == stackTrace) {\r\n        return null;\r\n    } else {\r\n        int index = stackTrace.indexOf(\"\\n\\tat\");\r\n        if (index >= 0) {\r\n            return stackTrace.substring(index + 1);\r\n        } else {\r\n            return stackTrace;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.util.ListenerList.add",
	"Comment": "adds a listener to this list. this method has no effect if the same\tlistener is already registered.",
	"Method": "void add(E listener){\r\n    if (listener == null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    final int oldSize = listeners.length;\r\n    for (int i = 0; i < oldSize; ++i) {\r\n        E listener2 = listeners[i];\r\n        if (identity ? listener == listener2 : listener.equals(listener2)) {\r\n            return;\r\n        }\r\n    }\r\n    E[] newListeners = (E[]) new Object[oldSize + 1];\r\n    System.arraycopy(listeners, 0, newListeners, 0, oldSize);\r\n    newListeners[oldSize] = listener;\r\n    this.listeners = newListeners;\r\n}"
}, {
	"Path": "org.apache.isis.applib.layout.grid.bootstrap3.BS3ElementAbstract.getCssClass",
	"Comment": "any additional css classes to render on the page element corresponding to this object,eg as per the bootstrap mixins or just forcustom styling.",
	"Method": "String getCssClass(){\r\n    return cssClass;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.formatter.ImageFormatter.getCombinedImage",
	"Comment": "returns the combined image for given array of descriptors. orientation can be vertical or\thorizontal.",
	"Method": "Image getCombinedImage(ResourceManager resourceManager,int orientation,ImageDescriptor descriptors,Image getCombinedImage,ResourceManager resourceManager,int orientation,int minWidth,int minHeight,ImageDescriptor descriptors){\r\n    ImageDescriptor combinedImageDescriptor = new CombinedIcon(descriptors, orientation, minWidth, minHeight);\r\n    Image img = resourceManager.createImage(combinedImageDescriptor);\r\n    return img;\r\n}"
}, {
	"Path": "org.apache.isis.applib.util.TitleBuffer.appendSpace",
	"Comment": "append a space to the text of this titlestring object if, and only if,there is some existing text i.e., a space is only added to existing textand will not create a text entry consisting of only one space.",
	"Method": "TitleBuffer appendSpace(){\r\n    if (title.length() > 0) {\r\n        title.append(SPACE);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.apache.isis.core.runtime.system.persistence.PersistenceSession.open",
	"Comment": "injects components, calls open on subcomponents, and then creates serviceadapters.",
	"Method": "void open(){\r\n    ensureNotOpened();\r\n    if (LOG.isDebugEnabled()) {\r\n        LOG.debug(\"opening {}\", this);\r\n    }\r\n    oidAdapterMap.open();\r\n    pojoAdapterMap.open();\r\n    persistenceManager = jdoPersistenceManagerFactory.getPersistenceManager();\r\n    final IsisLifecycleListener2.PersistenceSessionLifecycleManagement psLifecycleMgmt = this;\r\n    final IsisLifecycleListener2 isisLifecycleListener = new IsisLifecycleListener2(psLifecycleMgmt);\r\n    persistenceManager.addInstanceLifecycleListener(isisLifecycleListener, (Class[]) null);\r\n    persistenceQueryProcessorByClass.put(PersistenceQueryFindAllInstances.class, new PersistenceQueryFindAllInstancesProcessor(this));\r\n    persistenceQueryProcessorByClass.put(PersistenceQueryFindUsingApplibQueryDefault.class, new PersistenceQueryFindUsingApplibQueryProcessor(this));\r\n    initServices();\r\n    startRequestOnRequestScopedServices();\r\n    postConstructOnRequestScopedServices();\r\n    if (metricsService instanceof InstanceLifecycleListener) {\r\n        final InstanceLifecycleListener metricsService = (InstanceLifecycleListener) this.metricsService;\r\n        persistenceManager.addInstanceLifecycleListener(metricsService, (Class[]) null);\r\n    }\r\n    final Command command = createCommand();\r\n    final UUID transactionId = UUID.randomUUID();\r\n    final Interaction interaction = factoryService.instantiate(Interaction.class);\r\n    final Timestamp timestamp = clockService.nowAsJavaSqlTimestamp();\r\n    final String userName = userService.getUser().getName();\r\n    command.setTimestamp(timestamp);\r\n    command.setUser(userName);\r\n    command.setTransactionId(transactionId);\r\n    interaction.setTransactionId(transactionId);\r\n    commandContext.setCommand(command);\r\n    interactionContext.setInteraction(interaction);\r\n    Bulk.InteractionContext.current.set(bulkInteractionContext);\r\n    this.state = State.OPEN;\r\n}"
}, {
	"Path": "j2html.TagCreator.a",
	"Comment": "containertags, generated in class j2html.tags.tagcreatorcodegenerator",
	"Method": "ContainerTag a(ContainerTag a,String text,ContainerTag a,DomContent dc,ContainerTag a,Attr.ShortForm shortAttr,ContainerTag a,Attr.ShortForm shortAttr,String text,ContainerTag a,Attr.ShortForm shortAttr,DomContent dc){\r\n    return Attr.addTo(new ContainerTag(\"a\").with(dc), shortAttr);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.property.control.AbstractPropertyControl.showIfAdvanced",
	"Comment": "shows or hides all controls for this property if property is advanced.",
	"Method": "void showIfAdvanced(boolean visible){\r\n    if (property.isAdvanced()) {\r\n        for (Control control : allControls) {\r\n            control.setVisible(visible);\r\n        }\r\n        if (decorationDisplayed && visible) {\r\n            decoration.show();\r\n        } else {\r\n            decoration.hide();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.StorageManager.isGzipCompressedData",
	"Comment": "returns true if the data stored in the input stream is in a gzip format. the input stream\twill be closed at the end.",
	"Method": "boolean isGzipCompressedData(InputStream is){\r\n    try {\r\n        byte[] firstTwoBytes = new byte[2];\r\n        int read = 0;\r\n        while (read < 2) {\r\n            read += is.read(firstTwoBytes, read, 2 - read);\r\n        }\r\n        int head = (firstTwoBytes[0] & 0xff) | ((firstTwoBytes[1] << 8) & 0xff00);\r\n        return GZIPInputStream.GZIP_MAGIC == head;\r\n    } finally {\r\n        if (null != is) {\r\n            is.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.tree.SteppingTreeSubView.expandToObject",
	"Comment": "tries to expand the tree viewer to the wanted occurrence of wanted element. if the wanted\toccurrence is not reachable, nothing is done. otherwise the tree is expanded and element\tselected.",
	"Method": "void expandToObject(Object template,int occurrence){\r\n    Object realElement = steppingTreeInputController.getElement(template, occurrence, getTreeViewer().getFilters());\r\n    if (null != realElement) {\r\n        ((DeferredTreeViewer) getTreeViewer()).expandToObjectAndSelect(realElement, 0);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.nio.stream.ExtendedByteBufferInputStream.prepare",
	"Comment": "prepares the stream for read. must be called before any read operation is executed.",
	"Method": "void prepare(){\r\n    super.prepare();\r\n    long totalSize = 0;\r\n    for (IStorageDescriptor descriptor : descriptors) {\r\n        totalSize += descriptor.getSize();\r\n    }\r\n    setTotalSize(totalSize);\r\n    executorService.execute(new ReadTask());\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.impl.StorageIndexingTest.getWithNoKey",
	"Comment": "test that get will work even when branch can not generate key for the element if id is\tcorrectly set.",
	"Method": "void getWithNoKey(){\r\n    IStorageTreeComponent<DefaultData> rootBranch = new StorageBranch(new StorageBranchIndexer(new TimestampIndexer(), false));\r\n    InvocationSequenceData invocation = mock(InvocationSequenceData.class);\r\n    when(invocation.getId()).thenReturn(1L);\r\n    when(invocation.getTimeStamp()).thenReturn(new Timestamp(new Date().getTime()));\r\n    IStorageDescriptor storageDescriptor = rootBranch.put(invocation);\r\n    when(invocation.getTimeStamp()).thenReturn(null);\r\n    assertThat(rootBranch.get(invocation), is(equalTo(storageDescriptor)));\r\n    assertThat(rootBranch.getAndRemove(invocation), is(equalTo(storageDescriptor)));\r\n    assertThat(rootBranch.get(invocation), is(nullValue()));\r\n}"
}, {
	"Path": "org.apache.isis.applib.layout.grid.bootstrap3.BS3RowContent.getOwner",
	"Comment": "owner.set programmatically by framework after reading in from xml.",
	"Method": "BS3RowContentOwner getOwner(){\r\n    return owner;\r\n}"
}, {
	"Path": "org.apache.isis.applib.layout.grid.bootstrap3.BS3TabGroup.getOwner",
	"Comment": "owner.set programmatically by framework after reading in from xml.",
	"Method": "BS3TabGroupOwner getOwner(){\r\n    return owner;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.tree.input.AbstractTreeInputController.getMappedTreeViewerColumn",
	"Comment": "returns the column that has been mapped with the given enum key. enum should represent the\twanted column.",
	"Method": "TreeViewerColumn getMappedTreeViewerColumn(Enum<?> key){\r\n    return treeViewerColumnMap.get(key);\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.DateTime.startOfYear",
	"Comment": "this datetime, but on the first day of the year. time is preserved.",
	"Method": "DateTime startOfYear(){\r\n    return new DateTime(dateTime.withDayOfYear(1));\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.service.rules.impl.CauseStructureRule.calculateMaxRecursionDepth",
	"Comment": "calculates the absolute maximum depth for the common context of the\tproblemcontext.",
	"Method": "int calculateMaxRecursionDepth(){\r\n    InvocationSequenceDataIterator iterator = new InvocationSequenceDataIterator(problemContext.getCommonContext());\r\n    Stack<Integer> recursionStack = new Stack();\r\n    int maxRecursionDepth = 0;\r\n    int maxIterationsToCheck = 0;\r\n    while (iterator.hasNext() && (maxIterationsToCheck < MAX_CALLS_TO_CHECK) && (maxRecursionDepth < 2)) {\r\n        InvocationSequenceData invocation = iterator.next();\r\n        if (!recursionStack.isEmpty() && (recursionStack.peek() >= iterator.currentDepth())) {\r\n            recursionStack.pop();\r\n        }\r\n        if (isCauseInvocation(invocation)) {\r\n            recursionStack.push(iterator.currentDepth());\r\n            if (recursionStack.size() > maxRecursionDepth) {\r\n                maxRecursionDepth = recursionStack.size();\r\n            }\r\n            maxIterationsToCheck++;\r\n        }\r\n    }\r\n    return maxRecursionDepth;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.repository.service.storage.AbstractStorageService.executeQuery",
	"Comment": "executes the query on the indexing tree. results can be sorted by comparator. furthermore the\tresult list can be limited.",
	"Method": "List<E> executeQuery(StorageIndexQuery storageIndexQuery,List<E> executeQuery,StorageIndexQuery storageIndexQuery,IAggregator<E> aggregator,List<E> executeQuery,StorageIndexQuery storageIndexQuery,Comparator<? super E> comparator,List<E> executeQuery,StorageIndexQuery storageIndexQuery,int limit,List<E> executeQuery,StorageIndexQuery storageIndexQuery,IAggregator<E> aggregator,Comparator<? super E> comparator,List<E> executeQuery,StorageIndexQuery storageIndexQuery,IAggregator<E> aggregator,int limit,List<E> executeQuery,StorageIndexQuery storageIndexQuery,Comparator<? super E> comparator,int limit,List<E> executeQuery,StorageIndexQuery storageIndexQuery,IAggregator<E> aggregator,Comparator<? super E> comparator,int limit){\r\n    List<E> returnList = null;\r\n    if (storageManager.canBeCached(storageIndexQuery, aggregator)) {\r\n        int hash = storageManager.getCachedDataHash(storageIndexQuery, aggregator);\r\n        if (!localStorageData.isFullyDownloaded()) {\r\n            StorageData storageData = new StorageData(localStorageData);\r\n            try {\r\n                returnList = dataRetriever.getCachedDataViaHttp(getCmrRepositoryDefinition(), storageData, hash);\r\n            } catch (BusinessException | IOException | SerializationException e) {\r\n            }\r\n            if (null == returnList) {\r\n                returnList = loadData(storageIndexQuery, aggregator);\r\n                if (CollectionUtils.isNotEmpty(returnList)) {\r\n                    cacheQueryResultOnCmr(getCmrRepositoryDefinition(), storageData, returnList, hash);\r\n                }\r\n            }\r\n        } else {\r\n            try {\r\n                returnList = dataRetriever.getCachedDataLocally(localStorageData, hash);\r\n            } catch (IOException | SerializationException e) {\r\n            }\r\n            if (null == returnList) {\r\n                returnList = loadData(storageIndexQuery, aggregator);\r\n                if (CollectionUtils.isNotEmpty(returnList)) {\r\n                    cacheQueryResultLocally(localStorageData, returnList, hash);\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        returnList = loadData(storageIndexQuery, aggregator);\r\n    }\r\n    if (null != comparator) {\r\n        Collections.sort(returnList, comparator);\r\n    }\r\n    if ((limit > -1) && (returnList.size() > limit)) {\r\n        returnList = returnList.subList(0, limit);\r\n    }\r\n    return returnList;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.communication.data.InvocationSequenceDataHelper.calculateDuration",
	"Comment": "calculates the duration starting from this invocation sequence data element. includes span\tduration as last resource if the span ident exists on the data.",
	"Method": "double calculateDuration(InvocationSequenceData data,double calculateDuration,InvocationSequenceData data,ISpanService spanService){\r\n    if (InvocationSequenceDataHelper.hasTimerData(data)) {\r\n        return data.getTimerData().getDuration();\r\n    } else if (InvocationSequenceDataHelper.hasSQLData(data)) {\r\n        return data.getSqlStatementData().getDuration();\r\n    } else if ((null != spanService) && hasSpanIdent(data)) {\r\n        Span span = spanService.get(data.getSpanIdent());\r\n        if ((span != null) && !References.FOLLOWS_FROM.equals(span.getReferenceType())) {\r\n            return span.getDuration();\r\n        }\r\n    }\r\n    if (InvocationSequenceDataHelper.isRootElementInSequence(data)) {\r\n        return data.getDuration();\r\n    }\r\n    return -1.0d;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.Modifier.isNative",
	"Comment": "returns true if the modifiers include the native modifier.",
	"Method": "boolean isNative(int mod){\r\n    return (mod & NATIVE) != 0;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.storage.InspectITStorageManager.getLocalDataForStorage",
	"Comment": "returns the local data for storage if the storage is mounted or downloaded.",
	"Method": "LocalStorageData getLocalDataForStorage(StorageData storageData){\r\n    for (LocalStorageData downloadedStorage : downloadedStorages) {\r\n        if (ObjectUtils.equals(downloadedStorage.getId(), storageData.getId())) {\r\n            return downloadedStorage;\r\n        }\r\n    }\r\n    for (LocalStorageData mountedStorage : mountedNotAvailableStorages) {\r\n        if (ObjectUtils.equals(storageData.getId(), mountedStorage.getId())) {\r\n            return mountedStorage;\r\n        }\r\n    }\r\n    for (LocalStorageData mountedStorage : mountedAvailableStorages.keySet()) {\r\n        if (ObjectUtils.equals(storageData.getId(), mountedStorage.getId())) {\r\n            return mountedStorage;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.InvocationAwareDataTest.complicatedSameParentsAggregation",
	"Comment": "tests the complicated aggregation when objects are in same invocations.",
	"Method": "void complicatedSameParentsAggregation(){\r\n    InvocationAwareData i1 = getInvocationAwareData();\r\n    i1.addInvocationParentId(Long.valueOf(1));\r\n    InvocationAwareData i2 = getInvocationAwareData();\r\n    i2.addInvocationParentId(Long.valueOf(2));\r\n    i1.aggregateInvocationAwareData(i2);\r\n    InvocationAwareData i3 = getInvocationAwareData();\r\n    i3.addInvocationParentId(Long.valueOf(1));\r\n    InvocationAwareData i4 = getInvocationAwareData();\r\n    i4.addInvocationParentId(Long.valueOf(2));\r\n    i3.aggregateInvocationAwareData(i4);\r\n    i1.aggregateInvocationAwareData(i3);\r\n    assertThat(i1.getObjectsInInvocationsCount(), is(equalTo(4)));\r\n    assertThat(i1.getInvocationParentsIdSet().size(), is(equalTo(2)));\r\n    assertThat(i1.getInvocationParentsIdSet(), contains(1L, 2L));\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.viewer.IsisWicketApplication.determineStripWicketTags",
	"Comment": "whether wicket tags should be stripped from the markup, as specified by configuration settings..if the isis.viewer.wicket.stripwickettags is set, then this is used, otherwise the default is to strip the tags because they may break some css rules.",
	"Method": "boolean determineStripWicketTags(IsisConfiguration configuration){\r\n    final boolean strip = configuration.getBoolean(STRIP_WICKET_TAGS_KEY, STRIP_WICKET_TAGS_DEFAULT);\r\n    return strip;\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.viewer.IsisWicketApplication.determineAjaxDebugModeEnabled",
	"Comment": "whether the ajax debug should be shown, as specified by configuration settings.if the isis.viewer.wicket.ajaxdebugmode is set, then this is used, otherwise the default is to disable.",
	"Method": "boolean determineAjaxDebugModeEnabled(IsisConfiguration configuration){\r\n    final boolean debugModeEnabled = configuration.getBoolean(AJAX_DEBUG_MODE_KEY, AJAX_DEBUG_MODE_DEFAULT);\r\n    return debugModeEnabled;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.text.input.SqlStatementTextInputController.fitSizeOfScrolledContent",
	"Comment": "fits the width of the main composite to the same width scrolled composite was given.",
	"Method": "void fitSizeOfScrolledContent(){\r\n    Point p = scrollComposite.getSize();\r\n    main.setSize(main.computeSize(p.x, SWT.DEFAULT));\r\n}"
}, {
	"Path": "org.apache.isis.core.commons.config.IsisConfigurationDefault.getString",
	"Comment": "returns the configuration property with the specified name. if there isno matching property then null is returned.",
	"Method": "String getString(String name,String getString,String name,String defaultValue){\r\n    return getProperty(name, defaultValue);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.Client.discoverHost",
	"Comment": "broadcasts a udp message on the lan to discover any running servers. the address of the first\tserver to respond is returned.",
	"Method": "InetAddress discoverHost(int udpPort,int timeoutMillis){\r\n    DatagramSocket socket = null;\r\n    try {\r\n        socket = new DatagramSocket();\r\n        broadcast(udpPort, socket);\r\n        socket.setSoTimeout(timeoutMillis);\r\n        DatagramPacket packet = new DatagramPacket(new byte[0], 0);\r\n        try {\r\n            socket.receive(packet);\r\n        } catch (SocketTimeoutException ex) {\r\n            if (INFO) {\r\n                info(\"kryonet\", \"Host discovery timed out.\");\r\n            }\r\n            return null;\r\n        }\r\n        if (INFO) {\r\n            info(\"kryonet\", \"Discovered server: \" + packet.getAddress());\r\n        }\r\n        return packet.getAddress();\r\n    } catch (IOException ex) {\r\n        if (ERROR) {\r\n            error(\"kryonet\", \"Host discovery failed.\", ex);\r\n        }\r\n        return null;\r\n    } finally {\r\n        if (socket != null) {\r\n            socket.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.wizard.page.ManageLabelWizardPage.isLabelExistsInStorage",
	"Comment": "returns if any storage in collection of storages does contain given label.",
	"Method": "boolean isLabelExistsInStorage(AbstractStorageLabel<?> label,Set<AbstractStorageLabel<?>> labelsInStorages){\r\n    for (AbstractStorageLabel<?> labelInStorage : labelsInStorages) {\r\n        if (ObjectUtils.equals(label, labelInStorage)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.rmi.ObjectSpace.removeConnection",
	"Comment": "removes the specified connection, it will no longer be able to access objects registered in\tthis objectspace.",
	"Method": "void removeConnection(Connection connection){\r\n    if (connection == null) {\r\n        throw new IllegalArgumentException(\"connection cannot be null.\");\r\n    }\r\n    connection.removeListener(invokeListener);\r\n    synchronized (connectionsLock) {\r\n        ArrayList<Connection> temp = new ArrayList(Arrays.asList(connections));\r\n        temp.remove(connection);\r\n        connections = temp.toArray(new Connection[temp.size()]);\r\n    }\r\n    if (TRACE) {\r\n        trace(\"kryonet\", \"Removed connection from ObjectSpace: \" + connection);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.Modifier.isPrivate",
	"Comment": "returns true if the modifiers include the private modifier.",
	"Method": "boolean isPrivate(int mod){\r\n    return (mod & PRIVATE) != 0;\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.Annotations.getAnnotation",
	"Comment": "searches for annotation on provided method, and if not found for anyinherited methods up from the superclass.",
	"Method": "T getAnnotation(Class<?> cls,Class<T> annotationClass,T getAnnotation,Method method,Class<T> annotationClass,T getAnnotation){\r\n    if (method == null) {\r\n        return null;\r\n    }\r\n    final Class<?> methodDeclaringClass = method.getDeclaringClass();\r\n    final String methodName = method.getName();\r\n    final T annotation = method.getAnnotation(annotationClass);\r\n    if (annotation != null) {\r\n        return annotation;\r\n    }\r\n    if (shouldSearchForField(annotationClass)) {\r\n        List<String> fieldNameCandidates = fieldNameCandidatesFor(methodName);\r\n        for (String fieldNameCandidate : fieldNameCandidates) {\r\n            try {\r\n                final Field field = methodDeclaringClass.getDeclaredField(fieldNameCandidate);\r\n                final T fieldAnnotation = field.getAnnotation(annotationClass);\r\n                if (fieldAnnotation != null) {\r\n                    return fieldAnnotation;\r\n                }\r\n            } catch (NoSuchFieldException e) {\r\n            }\r\n        }\r\n    }\r\n    final Class<?> superclass = methodDeclaringClass.getSuperclass();\r\n    if (superclass != null) {\r\n        try {\r\n            final Method parentClassMethod = superclass.getMethod(methodName, method.getParameterTypes());\r\n            return getAnnotation(parentClassMethod, annotationClass);\r\n        } catch (final SecurityException | NoSuchMethodException e) {\r\n        }\r\n    }\r\n    final Class<?>[] interfaces = methodDeclaringClass.getInterfaces();\r\n    for (final Class<?> iface : interfaces) {\r\n        try {\r\n            final Method ifaceMethod = iface.getMethod(methodName, method.getParameterTypes());\r\n            return getAnnotation(ifaceMethod, annotationClass);\r\n        } catch (final SecurityException | NoSuchMethodException e) {\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.nio.AbstractChannelManager.createNewChannel",
	"Comment": "creates a new channel. we need to do this in synchronized method since the channel also has\tto be opened, thus we can not use putifabsent.",
	"Method": "CustomAsyncChannel createNewChannel(Path channelPath){\r\n    CustomAsyncChannel channel = writingChannelsMap.get(channelPath);\r\n    if (channel == null) {\r\n        channel = new CustomAsyncChannel(channelPath);\r\n        this.openAsyncChannel(channel);\r\n        writingChannelsMap.put(channelPath, channel);\r\n    }\r\n    return channel;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.business.AdvancedMatchingRulesPart.performInitialValidation",
	"Comment": "performs initial validation of the tree elements without the need to create corresponding\tediting controls.",
	"Method": "void performInitialValidation(AbstractExpression expression){\r\n    if (expression instanceof IContainerExpression) {\r\n        for (AbstractExpression child : ((IContainerExpression) expression).getOperands()) {\r\n            performInitialValidation(child);\r\n        }\r\n    } else if (expression instanceof StringMatchingExpression) {\r\n        Set<ValidationState> validationStates = AbstractRuleEditingElement.validate((StringMatchingExpression) expression);\r\n        for (ValidationState state : validationStates) {\r\n            validationManager.validationStateChanged(expression, state);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.storage.nio.ByteBufferProvider.setPoolMaxCapacity",
	"Comment": "this setter can be removed when the spring3.0 on the gui side is working properly.",
	"Method": "void setPoolMaxCapacity(long poolMaxCapacity){\r\n    this.poolMaxCapacity = poolMaxCapacity;\r\n}"
}, {
	"Path": "org.apache.isis.viewer.restfulobjects.applib.client.RepresentationWalker.getEntity",
	"Comment": "the entity returned from the previous walk.will return null if the previous walk returned an error.",
	"Method": "JsonRepresentation getEntity(){\r\n    final Step currentStep = currentStep();\r\n    if (currentStep.response == null || currentStep.error != null) {\r\n        return null;\r\n    }\r\n    return currentStep.response.getEntity();\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.handlers.ShowHideColumnsHandler.registerNewColumnWidth",
	"Comment": "registers new column width to be saved for further use. only positive column widths will be\tsaved.",
	"Method": "void registerNewColumnWidth(Class<?> controllerClass,String columnName,int width){\r\n    if (width > 0) {\r\n        int hash = getColumnHash(controllerClass, columnName);\r\n        columnSizeCache.put(hash, width);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.property.control.AbstractPropertyControl.create",
	"Comment": "creates set of controls that will be displayed for the property.\tit is expected that the parent composite has a grid layout with four columns.",
	"Method": "void create(Composite parent){\r\n    if (null == control) {\r\n        Label name = new Label(parent, SWT.LEFT);\r\n        name.setText(property.getName() + \":\");\r\n        name.setLayoutData(new GridData(SWT.FILL, SWT.CENTER, false, false));\r\n        control = createControl(parent);\r\n        GridData controlGridData = new GridData(SWT.FILL, SWT.CENTER, true, false);\r\n        controlGridData.widthHint = 175;\r\n        controlGridData.horizontalIndent = 10;\r\n        control.setLayoutData(controlGridData);\r\n        decoration = new ControlDecoration(control, SWT.LEFT | SWT.BOTTOM);\r\n        decoration.setImage(FieldDecorationRegistry.getDefault().getFieldDecoration(FieldDecorationRegistry.DEC_ERROR).getImage());\r\n        decoration.hide();\r\n        Label info = new Label(parent, SWT.CENTER);\r\n        info.setImage(InspectIT.getDefault().getImage(InspectITImages.IMG_INFORMATION));\r\n        info.setToolTipText(property.getDescription());\r\n        info.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));\r\n        Label serverRestart = new Label(parent, SWT.CENTER);\r\n        if (property.isServerRestartRequired()) {\r\n            serverRestart.setImage(InspectIT.getDefault().getImage(InspectITImages.IMG_WARNING));\r\n            serverRestart.setToolTipText(\"Changing this property requires restart of the CMR\");\r\n        }\r\n        serverRestart.setLayoutData(new GridData(SWT.CENTER, SWT.CENTER, false, false));\r\n        CollectionUtils.addAll(allControls, new Object[] { name, control, info, serverRestart });\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.ui.components.scalars.datepicker.DateTimeConfig.autoClose",
	"Comment": "whether or not to close the datepicker immediately when a date is selected.",
	"Method": "DateTimeConfig autoClose(boolean value){\r\n    put(AutoClose, value);\r\n    return this;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.business.DynamicNameExtractionPart.createScopeInTraceSection",
	"Comment": "creates control section for specification of the scope in trace.",
	"Method": "void createScopeInTraceSection(){\r\n    createSectionHeading(\"Scope in Trace\");\r\n    Label searchInTraceLabel = toolkit.createLabel(mainComposite, \"Search in trace:\");\r\n    searchInTraceLabel.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false));\r\n    searchInTraceCheckBox = toolkit.createButton(mainComposite, \"Yes\", SWT.CHECK);\r\n    searchInTraceCheckBox.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, true, false, 1, 1));\r\n    searchInTraceCheckBox.addSelectionListener(new SelectionAdapter() {\r\n        @Override\r\n        public void widgetSelected(SelectionEvent e) {\r\n            searchDepthSpinner.setEnabled(searchInTraceCheckBox.getSelection());\r\n            if (!initializationPhase) {\r\n                markDirty();\r\n            }\r\n        }\r\n    });\r\n    addControl(searchInTraceCheckBox);\r\n    Label depthLabel = toolkit.createLabel(mainComposite, \"Maximum search depth: \");\r\n    depthLabel.setEnabled(false);\r\n    depthLabel.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false, 1, 1));\r\n    searchDepthSpinner = new Spinner(mainComposite, SWT.BORDER);\r\n    searchDepthSpinner.setMinimum(-1);\r\n    searchDepthSpinner.setMaximum(Integer.MAX_VALUE);\r\n    searchDepthSpinner.setSelection(-1);\r\n    searchDepthSpinner.setIncrement(1);\r\n    searchDepthSpinner.setPageIncrement(100);\r\n    searchDepthSpinner.setEnabled(false);\r\n    searchDepthSpinner.setToolTipText(\"A value of -1 means that no limit for the search depth is used!\");\r\n    searchDepthSpinner.setLayoutData(new GridData(SWT.LEFT, SWT.CENTER, false, false, 1, 1));\r\n    searchDepthSpinner.addModifyListener(new ModifyListener() {\r\n        @Override\r\n        public void modifyText(ModifyEvent e) {\r\n            if (!initializationPhase) {\r\n                markDirty();\r\n            }\r\n        }\r\n    });\r\n    addControl(searchDepthSpinner);\r\n    Label searchInTraceInfoLabelImage = toolkit.createLabel(mainComposite, \"\");\r\n    searchInTraceInfoLabelImage.setImage(InspectIT.getDefault().getImage(InspectITImages.IMG_INFORMATION));\r\n    searchInTraceInfoLabelImage.setLayoutData(new GridData(SWT.RIGHT, SWT.CENTER, false, false));\r\n    searchInTraceInfoLabelImage.setToolTipText(SEARCH_IN_TRACE_DESCRIPTION);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.business.DynamicNameExtractionPart.createScopeInTraceSection",
	"Comment": "creates control section for specification of the scope in trace.",
	"Method": "void createScopeInTraceSection(){\r\n    searchDepthSpinner.setEnabled(searchInTraceCheckBox.getSelection());\r\n    if (!initializationPhase) {\r\n        markDirty();\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.business.DynamicNameExtractionPart.createScopeInTraceSection",
	"Comment": "creates control section for specification of the scope in trace.",
	"Method": "void createScopeInTraceSection(){\r\n    if (!initializationPhase) {\r\n        markDirty();\r\n    }\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.collections.modify.CollectionAddToRemoveFromAndValidateFacetFactory.createRemoveFromFacet",
	"Comment": "todo need to distinguish between java collections, arrays and othercollections!",
	"Method": "CollectionRemoveFromFacet createRemoveFromFacet(Method removeFromMethodIfAny,Method accessorMethod,FacetHolder holder){\r\n    if (removeFromMethodIfAny != null) {\r\n        return new CollectionRemoveFromFacetViaMethod(removeFromMethodIfAny, holder);\r\n    } else {\r\n        return new CollectionRemoveFromFacetViaAccessor(accessorMethod, holder);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.tree.SteppingTreeSubView.setSwitchSteppingControlButtonChecked",
	"Comment": "alters the state of the stepping control button on preference panel.",
	"Method": "void setSwitchSteppingControlButtonChecked(boolean checked){\r\n    this.getRootEditor().getPreferencePanel().setSteppingControlChecked(checked);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.data.invocationtree.InvocationTreeUtil.getRoot",
	"Comment": "returns the root element of the tree where the given element belongs to.",
	"Method": "InvocationTreeElement getRoot(InvocationTreeElement element){\r\n    if (element == null) {\r\n        return null;\r\n    }\r\n    while (element.getParent() != null) {\r\n        element = element.getParent();\r\n    }\r\n    return element;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.processor.impl.DataAggregatorProcessor.getAlteredTimestamp",
	"Comment": "returns the value of the time stamp based on a aggregation period.",
	"Method": "long getAlteredTimestamp(TimerData timerData){\r\n    long timestampValue = timerData.getTimeStamp().getTime();\r\n    long newTimestampValue = timestampValue - (timestampValue % aggregationPeriod);\r\n    return newTimestampValue;\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.ui.pages.accmngt.EmailVerificationUrlServiceDefault.createVerificationUrl",
	"Comment": "creates a url to the passed pageclass by encrypting the givendatum as a first indexed parameter",
	"Method": "String createVerificationUrl(PageType pageType,String datum,String createVerificationUrl,Class<? extends Page> pageClass,String datum){\r\n    String uuid = UUID.randomUUID().toString();\r\n    uuid = uuid.replace(\"-\", \"\");\r\n    final AccountConfirmationMap accountConfirmationMap = getAccountConfirmationMap();\r\n    accountConfirmationMap.put(uuid, datum);\r\n    final PageParameters parameters = new PageParameters();\r\n    parameters.set(0, uuid);\r\n    final String fullUrl = fullUrlFor(pageClass, parameters);\r\n    return fullUrl;\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.facets.param.defaults.methodnum.ActionParameterDefaultsFacetViaMethodFactory.findDefaultNumMethod",
	"Comment": "search successively for the default method, trimming number of param types each loop",
	"Method": "Method findDefaultNumMethod(ProcessMethodContext processMethodContext,int n,Method findDefaultNumMethod,ProcessMethodContext processMethodContext,int n,Class<?>[] paramTypes){\r\n    final Class<?> cls = processMethodContext.getCls();\r\n    final Method actionMethod = processMethodContext.getMethod();\r\n    final Class<?> returnType = actionMethod.getParameterTypes()[n];\r\n    final String capitalizedName = StringExtensions.asCapitalizedName(actionMethod.getName());\r\n    return MethodFinderUtils.findMethod(cls, MethodScope.OBJECT, MethodPrefixConstants.DEFAULT_PREFIX + n + capitalizedName, returnType, paramTypes);\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.services.container.DomainObjectContainerDefault.newInstance",
	"Comment": "returns a new instance of the specified class that has the same persistedstate as the specified object.",
	"Method": "T newInstance(Class<T> ofClass,Object object){\r\n    if (isPersistent(object)) {\r\n        return newPersistentInstance(ofClass);\r\n    } else {\r\n        return newTransientInstance(ofClass);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.communication.data.InvocationSequenceDataHelper.getRootElementInSequence",
	"Comment": "returns root object of the sequence the given data belongs to by iterating till the tree\troot.",
	"Method": "InvocationSequenceData getRootElementInSequence(InvocationSequenceData data){\r\n    InvocationSequenceData invoc = data;\r\n    while (null != invoc.getParentSequence()) {\r\n        invoc = invoc.getParentSequence();\r\n    }\r\n    return invoc;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.storage.StorageData.addLabel",
	"Comment": "adds a label to the label list of the storage data. the labels that are one per storage will\tbe inserted only if the label of that type does not exists, or the overwrite flag is set to\ttrue.",
	"Method": "void addLabel(AbstractStorageLabel<?> label,boolean doOverwrite){\r\n    if (label.getStorageLabelType().isOnePerStorage()) {\r\n        boolean exists = false;\r\n        for (AbstractStorageLabel<?> existingLabel : labelList) {\r\n            if (label.getStorageLabelType().equals(existingLabel.getStorageLabelType())) {\r\n                exists = true;\r\n                if (doOverwrite) {\r\n                    labelList.remove(existingLabel);\r\n                    labelList.add(label);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n        if (!exists) {\r\n            labelList.add(label);\r\n        }\r\n    } else if (!labelList.contains(label)) {\r\n        labelList.add(label);\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.business.rules.AbstractSelectionRuleEditingElement.isValidExpression",
	"Comment": "returns true, if the given expression is a valid expression for this editing element.",
	"Method": "boolean isValidExpression(StringMatchingExpression expression){\r\n    return expression.getStringValueSource().hasOptions() && (expression.getStringValueSource().getOptions().length > 0);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.text.input.VmSummaryInputController.initializeInput",
	"Comment": "returns the new composite with initialized input and sections with text labels.",
	"Method": "void initializeInput(Composite parent,FormToolkit toolkit){\r\n    int labelStyle = SWT.LEFT;\r\n    int minTitleColumnWidth = 170;\r\n    int minInformationColumnWidth = 230;\r\n    addSection(parent, toolkit, SECTION_VM);\r\n    addSection(parent, toolkit, SECTION_OS);\r\n    addSection(parent, toolkit, SECTION_MEMORY);\r\n    addSection(parent, toolkit, SECTION_CLASSES);\r\n    addSection(parent, toolkit, SECTION_THREADS);\r\n    addStaticInformations(parent, toolkit);\r\n    if (sections.containsKey(SECTION_CLASSES)) {\r\n        addItemToSection(toolkit, SECTION_CLASSES, \"Current loaded classes: \", minTitleColumnWidth);\r\n        loadedClassCount = toolkit.createLabel(sections.get(SECTION_CLASSES), NOT_AVAILABLE, labelStyle);\r\n        loadedClassCount.setLayoutData(new GridData(minInformationColumnWidth, SWT.DEFAULT));\r\n        addItemToSection(toolkit, SECTION_CLASSES, \"Total loaded classes: \", minTitleColumnWidth);\r\n        totalLoadedClassCount = toolkit.createLabel(sections.get(SECTION_CLASSES), NOT_AVAILABLE, labelStyle);\r\n        totalLoadedClassCount.setLayoutData(new GridData(minInformationColumnWidth, SWT.DEFAULT));\r\n        addItemToSection(toolkit, SECTION_CLASSES, \"Total unloaded classes: \", minTitleColumnWidth);\r\n        unloadedClassCount = toolkit.createLabel(sections.get(SECTION_CLASSES), NOT_AVAILABLE, labelStyle);\r\n        unloadedClassCount.setLayoutData(new GridData(minInformationColumnWidth, SWT.DEFAULT));\r\n    }\r\n    if (sections.containsKey(SECTION_VM)) {\r\n        addItemToSection(toolkit, SECTION_VM, \"Total compile time: \", minTitleColumnWidth);\r\n        totalCompilationTime = toolkit.createLabel(sections.get(SECTION_VM), NOT_AVAILABLE, labelStyle);\r\n        totalCompilationTime.setLayoutData(new GridData(minInformationColumnWidth, SWT.DEFAULT));\r\n        addItemToSection(toolkit, SECTION_VM, \"Uptime: \", minTitleColumnWidth);\r\n        uptime = toolkit.createLabel(sections.get(SECTION_VM), NOT_AVAILABLE, labelStyle);\r\n        uptime.setLayoutData(new GridData(minInformationColumnWidth, SWT.DEFAULT));\r\n        addItemToSection(toolkit, SECTION_VM, \"Process Cpu Time: \", minTitleColumnWidth);\r\n        processCpuTime = toolkit.createLabel(sections.get(SECTION_VM), NOT_AVAILABLE, labelStyle);\r\n        processCpuTime.setLayoutData(new GridData(minInformationColumnWidth, SWT.DEFAULT));\r\n    }\r\n    if (sections.containsKey(SECTION_MEMORY)) {\r\n        addItemToSection(toolkit, SECTION_MEMORY, \"Free physical memory: \", minTitleColumnWidth);\r\n        freePhysMemory = toolkit.createLabel(sections.get(SECTION_MEMORY), NOT_AVAILABLE, labelStyle);\r\n        freePhysMemory.setLayoutData(new GridData(minInformationColumnWidth, SWT.DEFAULT));\r\n        addItemToSection(toolkit, SECTION_MEMORY, \"Free swap space: \", minTitleColumnWidth);\r\n        freeSwapSpace = toolkit.createLabel(sections.get(SECTION_MEMORY), NOT_AVAILABLE, labelStyle);\r\n        freeSwapSpace.setLayoutData(new GridData(minInformationColumnWidth, SWT.DEFAULT));\r\n        addItemToSection(toolkit, SECTION_MEMORY, \"Committed heap size: \", minTitleColumnWidth);\r\n        committedHeapMemorySize = toolkit.createLabel(sections.get(SECTION_MEMORY), NOT_AVAILABLE, labelStyle);\r\n        committedHeapMemorySize.setLayoutData(new GridData(minInformationColumnWidth, SWT.DEFAULT));\r\n        addItemToSection(toolkit, SECTION_MEMORY, \"Committed non-heap size: \", minTitleColumnWidth);\r\n        committedNonHeapMemorySize = toolkit.createLabel(sections.get(SECTION_MEMORY), NOT_AVAILABLE, labelStyle);\r\n        committedNonHeapMemorySize.setLayoutData(new GridData(minInformationColumnWidth, SWT.DEFAULT));\r\n        addItemToSection(toolkit, SECTION_MEMORY, \"Used heap size: \", minTitleColumnWidth);\r\n        usedHeapMemorySize = toolkit.createLabel(sections.get(SECTION_MEMORY), NOT_AVAILABLE, labelStyle);\r\n        usedHeapMemorySize.setLayoutData(new GridData(minInformationColumnWidth, SWT.DEFAULT));\r\n        addItemToSection(toolkit, SECTION_MEMORY, \"Used non-heap size: \", minTitleColumnWidth);\r\n        usedNonHeapMemorySize = toolkit.createLabel(sections.get(SECTION_MEMORY), NOT_AVAILABLE, labelStyle);\r\n        usedNonHeapMemorySize.setLayoutData(new GridData(minInformationColumnWidth, SWT.DEFAULT));\r\n    }\r\n    if (sections.containsKey(SECTION_THREADS)) {\r\n        addItemToSection(toolkit, SECTION_THREADS, \"Live threads: \", minTitleColumnWidth);\r\n        liveThreadCount = toolkit.createLabel(sections.get(SECTION_THREADS), NOT_AVAILABLE, labelStyle);\r\n        liveThreadCount.setLayoutData(new GridData(minInformationColumnWidth, SWT.DEFAULT));\r\n        addItemToSection(toolkit, SECTION_THREADS, \"Daemon threads: \", minTitleColumnWidth);\r\n        daemonThreadCount = toolkit.createLabel(sections.get(SECTION_THREADS), NOT_AVAILABLE, labelStyle);\r\n        daemonThreadCount.setLayoutData(new GridData(minInformationColumnWidth, SWT.DEFAULT));\r\n        addItemToSection(toolkit, SECTION_THREADS, \"Peak: \", minTitleColumnWidth);\r\n        peakThreadCount = toolkit.createLabel(sections.get(SECTION_THREADS), NOT_AVAILABLE, labelStyle);\r\n        peakThreadCount.setLayoutData(new GridData(minInformationColumnWidth, SWT.DEFAULT));\r\n        addItemToSection(toolkit, SECTION_THREADS, \"Total threads started: \", minTitleColumnWidth);\r\n        totalStartedThreadCount = toolkit.createLabel(sections.get(SECTION_THREADS), NOT_AVAILABLE, labelStyle);\r\n        totalStartedThreadCount.setLayoutData(new GridData(minInformationColumnWidth, SWT.DEFAULT));\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.JmxSensorValueData.isBooleanOrNumeric",
	"Comment": "checks if the value of this object is a boolean or numeric value.",
	"Method": "boolean isBooleanOrNumeric(){\r\n    return isBooleanValue(value) || NumberUtils.isNumber(value);\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.service.aggregation.DiagnosisDataAggregator.aggregate",
	"Comment": "aggregate the invocationsequencedata to the aggregateddiagnosisdata.",
	"Method": "void aggregate(AggregatedDiagnosisData aggregatedObject,InvocationSequenceData objectToAdd){\r\n    aggregatedObject.aggregate(objectToAdd);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.storage.util.DataRetriever.getFilesFromCmr",
	"Comment": "returns the map of the existing files for the given storage. the value in the map is file\tsize. only wanted file types will be included in the map.",
	"Method": "Map<String, Long> getFilesFromCmr(CmrRepositoryDefinition cmrRepositoryDefinition,StorageData storageData,StorageFileType fileTypes){\r\n    Map<String, Long> allFiles = new HashMap();\r\n    if (ArrayUtils.contains(fileTypes, StorageFileType.AGENT_FILE)) {\r\n        Map<String, Long> platformIdentsFiles = cmrRepositoryDefinition.getStorageService().getAgentFilesLocations(storageData);\r\n        allFiles.putAll(platformIdentsFiles);\r\n    }\r\n    if (ArrayUtils.contains(fileTypes, StorageFileType.BUSINESS_CONTEXT_FILE)) {\r\n        Map<String, Long> businessContextFiles = cmrRepositoryDefinition.getStorageService().getBusinessContextFilesLocation(storageData);\r\n        allFiles.putAll(businessContextFiles);\r\n    }\r\n    if (ArrayUtils.contains(fileTypes, StorageFileType.INDEX_FILE)) {\r\n        Map<String, Long> indexingTreeFiles = cmrRepositoryDefinition.getStorageService().getIndexFilesLocations(storageData);\r\n        allFiles.putAll(indexingTreeFiles);\r\n    }\r\n    if (ArrayUtils.contains(fileTypes, StorageFileType.DATA_FILE)) {\r\n        Map<String, Long> dataFiles = cmrRepositoryDefinition.getStorageService().getDataFilesLocations(storageData);\r\n        allFiles.putAll(dataFiles);\r\n    }\r\n    if (ArrayUtils.contains(fileTypes, StorageFileType.CACHED_DATA_FILE)) {\r\n        Map<String, Long> dataFiles = cmrRepositoryDefinition.getStorageService().getCachedDataFilesLocations(storageData);\r\n        allFiles.putAll(dataFiles);\r\n    }\r\n    return allFiles;\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.specloader.specimpl.ObjectMemberAbstract.getName",
	"Comment": "return the default label for this member. this is based on the name ofthis member.",
	"Method": "String getName(){\r\n    final NamedFacet facet = getFacet(NamedFacet.class);\r\n    final String name = facet.value();\r\n    if (name != null) {\r\n        return name;\r\n    } else {\r\n        return StringExtensions.asNaturalName2(getId());\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.communication.data.InvocationSequenceDataHelper.hasNestedExceptions",
	"Comment": "checks whether this data object has nested sql statements.",
	"Method": "boolean hasNestedExceptions(InvocationSequenceData data){\r\n    return (null != data.isNestedExceptions()) && data.isNestedExceptions().booleanValue();\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.graph.plot.datasolver.impl.PlotDataSolverFactory.instance",
	"Comment": "returns the singleton. if there is no instance of this class, it will be created.",
	"Method": "PlotDataSolverFactory instance(){\r\n    if (null == singleton) {\r\n        createSingleton();\r\n    }\r\n    return singleton;\r\n}"
}, {
	"Path": "org.apache.isis.applib.services.error.Ticket.getUserMessage",
	"Comment": "message to display to the user.typically this message should be short, one line long.",
	"Method": "String getUserMessage(){\r\n    return userMessage;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.indexing.storage.impl.StorageDescriptor.join",
	"Comment": "joins the information from the other storage descriptor if possible. this method will return\ttrue if the join was successfully done, and false if no join was done. the join is possible\tonly if the two descriptors are actually describing the data in the same channel that are\tnext to each other. there is no difference if the other descriptor is pointing to the data\tafter or before this descriptor. after successful join the joined data descriptor will be\trepresented by this descriptor.",
	"Method": "boolean join(IStorageDescriptor other,boolean join,long otherPosition,long otherSize){\r\n    return simpleStorageDescriptor.join(otherPosition, otherSize);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.JmxMasterDetailsBlock.updateButtonsState",
	"Comment": "updates the state of the remove button depending on the current selection.",
	"Method": "void updateButtonsState(ISelection selection){\r\n    removeButton.setEnabled(!selection.isEmpty());\r\n    duplicateButton.setEnabled(!selection.isEmpty());\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.service.DiagnosisService.readDiagnosisRuleClasses",
	"Comment": "this method derives the classes that represent the diagnosis rules.",
	"Method": "Set<Class<?>> readDiagnosisRuleClasses(){\r\n    ClassPathScanningCandidateComponentProvider scanner = new ClassPathScanningCandidateComponentProvider(false);\r\n    scanner.addIncludeFilter(new AnnotationTypeFilter(Rule.class));\r\n    Set<Class<?>> ruleClasses = new HashSet();\r\n    ClassLoader classLoader = DiagnosisService.class.getClassLoader();\r\n    for (String packageName : rulesPackages) {\r\n        for (BeanDefinition bd : scanner.findCandidateComponents(packageName)) {\r\n            Class<?> clazz;\r\n            try {\r\n                clazz = classLoader.loadClass(bd.getBeanClassName());\r\n                ruleClasses.add(clazz);\r\n            } catch (ClassNotFoundException e) {\r\n                LOG.warn(\"Rule class \" + bd.getBeanClassName() + \"could not be found\");\r\n            }\r\n        }\r\n    }\r\n    return ruleClasses;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.TimerData.aggregateTimerData",
	"Comment": "aggregates the values given in the supplied timer data parameter to the objects data.",
	"Method": "void aggregateTimerData(TimerData timerData){\r\n    super.aggregateInvocationAwareData(timerData);\r\n    this.setCount(this.getCount() + timerData.getCount());\r\n    this.setDuration(this.getDuration() + timerData.getDuration());\r\n    this.calculateMax(timerData.getMax());\r\n    this.calculateMin(timerData.getMin());\r\n    if (timerData.isCpuMetricDataAvailable()) {\r\n        this.setCpuDuration(this.getCpuDuration() + timerData.getCpuDuration());\r\n        this.calculateCpuMax(timerData.getCpuMax());\r\n        this.calculateCpuMin(timerData.getCpuMin());\r\n    }\r\n    if (timerData.isExclusiveTimeDataAvailable()) {\r\n        this.addExclusiveDuration(timerData.getExclusiveDuration());\r\n        this.setExclusiveCount(this.getExclusiveCount() + timerData.getExclusiveCount());\r\n        this.calculateExclusiveMax(timerData.getExclusiveMax());\r\n        this.calculateExclusiveMin(timerData.getExclusiveMin());\r\n    }\r\n    this.charting = this.charting | timerData.isCharting();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.kryonet.Server.getConnections",
	"Comment": "returns the current connections. the array returned should not be modified.",
	"Method": "Connection[] getConnections(){\r\n    return connections;\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.ci.form.part.business.DynamicNameExtractionPart.disposeOptionalControls",
	"Comment": "disposes all optional controls that belong to the specified group id.",
	"Method": "void disposeOptionalControls(String groupId){\r\n    if (optionalControls.containsKey(groupId)) {\r\n        for (Control c : optionalControls.get(groupId)) {\r\n            c.dispose();\r\n        }\r\n        optionalControls.remove(groupId);\r\n    }\r\n    mainComposite.layout(true, true);\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.DateTime.startOfMonth",
	"Comment": "a datetime that represents the start of the current month. time ispreserved.",
	"Method": "DateTime startOfMonth(){\r\n    return new DateTime(dateTime.withDayOfMonth(1));\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.editor.viewers.StyledCellIndexLabelProvider.getColumnImage",
	"Comment": "default behavior is to return null. clients should override this method if\tneeded.",
	"Method": "Image getColumnImage(Object element,int index){\r\n    return null;\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.data.invocationtree.InvocationTreeBuilder.isSpanInTree",
	"Comment": "returns whether the current tree contains already a span with an id equals to the one of the\tgiven span ident.",
	"Method": "boolean isSpanInTree(SpanIdent spanIdent){\r\n    return spansExistingInTree.containsKey(spanIdent.getId());\r\n}"
}, {
	"Path": "org.apache.isis.viewer.wicket.ui.components.scalars.ScalarPanelAbstract2.buildGui",
	"Comment": "builds gui lazily prior to first render.this design allows the panel to be configured first.",
	"Method": "void buildGui(){\r\n    scalarTypeContainer = new WebMarkupContainer(ID_SCALAR_TYPE_CONTAINER);\r\n    scalarTypeContainer.setOutputMarkupId(true);\r\n    scalarTypeContainer.add(new CssClassAppender(Model.of(getScalarPanelType())));\r\n    addOrReplace(scalarTypeContainer);\r\n    this.scalarIfCompact = createComponentForCompact();\r\n    this.scalarIfRegular = createComponentForRegular();\r\n    scalarIfRegular.setOutputMarkupId(true);\r\n    scalarTypeContainer.addOrReplace(scalarIfCompact, scalarIfRegular);\r\n    List<LinkAndLabel> linkAndLabels = LinkAndLabelUtil.asActionLinksForAssociation(this.scalarModel, getDeploymentCategory());\r\n    final InlinePromptConfig inlinePromptConfig = getInlinePromptConfig();\r\n    if (inlinePromptConfig.isSupported()) {\r\n        this.scalarIfRegularInlinePromptForm = createInlinePromptForm();\r\n        scalarTypeContainer.addOrReplace(scalarIfRegularInlinePromptForm);\r\n        inlinePromptLink = createInlinePromptLink();\r\n        scalarIfRegular.add(inlinePromptLink);\r\n        scalarModel.setInlinePromptContext(new InlinePromptContext(getComponentForRegular(), scalarIfRegularInlinePromptForm, scalarTypeContainer));\r\n        Component componentToHideIfAny = inlinePromptLink;\r\n        final LinkAndLabel linkAndLabelAsIfEdit = inlineAsIfEditIfAny(linkAndLabels);\r\n        if (this.scalarModel.getPromptStyle().isInline() && scalarModel.canEnterEditMode()) {\r\n            configureInlinePromptLinkCallback(inlinePromptLink);\r\n            componentToHideIfAny = inlinePromptConfig.getComponentToHideIfAny();\r\n        } else {\r\n            if (linkAndLabelAsIfEdit != null) {\r\n                scalarModel.setHasActionWithInlineAsIfEdit(true);\r\n                final ActionLink actionLinkInlineAsIfEdit = (ActionLink) linkAndLabelAsIfEdit.getLink();\r\n                if (actionLinkInlineAsIfEdit.isVisible() && actionLinkInlineAsIfEdit.isEnabled()) {\r\n                    configureInlinePromptLinkCallback(inlinePromptLink, actionLinkInlineAsIfEdit);\r\n                    componentToHideIfAny = inlinePromptConfig.getComponentToHideIfAny();\r\n                }\r\n            }\r\n        }\r\n        if (linkAndLabelAsIfEdit != null) {\r\n            linkAndLabels = Lists.newArrayList(linkAndLabels);\r\n            linkAndLabels.remove(linkAndLabelAsIfEdit);\r\n        }\r\n        if (componentToHideIfAny != null) {\r\n            componentToHideIfAny.setVisibilityAllowed(false);\r\n        }\r\n    }\r\n    if (scalarModel.getKind() == ScalarModel.Kind.PROPERTY && scalarModel.getMode() == EntityModel.Mode.VIEW && (scalarModel.getPromptStyle().isDialog() || !scalarModel.canEnterEditMode())) {\r\n        getScalarValueComponent().add(new AttributeAppender(\"tabindex\", \"-1\"));\r\n    }\r\n    addPositioningCssTo(scalarIfRegular, linkAndLabels);\r\n    addActionLinksBelowAndRight(scalarIfRegular, linkAndLabels);\r\n    addEditPropertyTo(scalarIfRegular);\r\n    addFeedbackOnlyTo(scalarIfRegular, getScalarValueComponent());\r\n    getRendering().buildGui(this);\r\n    addCssFromMetaModel();\r\n    notifyOnChange(this);\r\n    addFormComponentBehaviourToUpdateSubscribers();\r\n}"
}, {
	"Path": "rocks.inspectit.shared.all.communication.data.TimerData.calculateExclusiveMax",
	"Comment": "sets the maximum if the given value is bigger than the current value.",
	"Method": "void calculateExclusiveMax(double max){\r\n    exclusiveMax = Math.max(exclusiveMax, max);\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.cmr.service.cache.CachedDataService.refreshIdents",
	"Comment": "internal refresh of the idents. currently everything is loaded again.",
	"Method": "void refreshIdents(){\r\n    Map<PlatformIdent, AgentStatusData> agentMap = globalDataAccessService.getAgentsOverview();\r\n    platformMap.clear();\r\n    methodMap.clear();\r\n    sensorTypeMap.clear();\r\n    jmxDefinitionDataMap.clear();\r\n    for (PlatformIdent overview : agentMap.keySet()) {\r\n        PlatformIdent platformIdent;\r\n        try {\r\n            platformIdent = globalDataAccessService.getCompleteAgent(overview.getId());\r\n        } catch (BusinessException e) {\r\n            LOG.warn(\"Exception occurred trying to refresh sensor information for the agent \" + overview.getAgentName() + \".\", e);\r\n            continue;\r\n        }\r\n        platformMap.put(platformIdent.getId(), platformIdent);\r\n        for (MethodIdent methodIdent : platformIdent.getMethodIdents()) {\r\n            methodMap.put(methodIdent.getId(), methodIdent);\r\n        }\r\n        for (SensorTypeIdent sensorTypeIdent : platformIdent.getSensorTypeIdents()) {\r\n            sensorTypeMap.put(sensorTypeIdent.getId(), sensorTypeIdent);\r\n        }\r\n        for (JmxDefinitionDataIdent jmxDefinitionDataIdent : platformIdent.getJmxDefinitionDataIdents()) {\r\n            jmxDefinitionDataMap.put(jmxDefinitionDataIdent.getId(), jmxDefinitionDataIdent);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.model.Modifier.isStatic",
	"Comment": "returns true if the modifiers include the static modifier.",
	"Method": "boolean isStatic(int mod){\r\n    return (mod & STATIC) != 0;\r\n}"
}, {
	"Path": "rocks.inspectit.server.diagnosis.service.rules.impl.GlobalContextRule.isDominatingCall",
	"Comment": "checks whether the child with the highest duration of the current investigated invocation\tsequence is a dominating call. if not, the invocation sequence is the\tglobal context. this method is used to decide whether to dig deeper in the\tinvocation tree.",
	"Method": "boolean isDominatingCall(double maxChildDuration,double traceDuration){\r\n    return ((traceDuration - maxChildDuration) < baseline) && (maxChildDuration > (traceDuration * PROPORTION));\r\n}"
}, {
	"Path": "rocks.inspectit.shared.cs.cmr.property.configuration.PropertySection.hasAdvancedProperties",
	"Comment": "returns true if at least one property in this section is marked as advanced,\tfalse otherwise.",
	"Method": "boolean hasAdvancedProperties(){\r\n    if (CollectionUtils.isNotEmpty(properties)) {\r\n        for (AbstractProperty property : properties) {\r\n            if (property.isAdvanced()) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.isis.applib.value.TimeStamp.isEqualTo",
	"Comment": "returns true if the time stamp of this object has the same value as thespecified timestamp",
	"Method": "boolean isEqualTo(TimeStamp timeStamp){\r\n    return this.time == (timeStamp).time;\r\n}"
}, {
	"Path": "org.apache.isis.applib.util.ReasonBuffer.getReason",
	"Comment": "return the combined set of reasons, or null if there arenone.",
	"Method": "String getReason(){\r\n    return reasonBuffer.length() == 0 ? null : reasonBuffer.toString();\r\n}"
}, {
	"Path": "org.apache.isis.core.metamodel.specloader.specimpl.ObjectActionDefault.hasReturn",
	"Comment": "returns true if the represented action returns something, else returnsfalse.",
	"Method": "boolean hasReturn(){\r\n    if (getReturnType() == null) {\r\n        return false;\r\n    }\r\n    return getReturnType() != getSpecificationLoader().loadSpecification(void.class);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.storage.InspectITStorageManager.updateLocalStorageData",
	"Comment": "updates the information of the local storage data saved on the client machine with the data\tprovided in the storage data available online.",
	"Method": "void updateLocalStorageData(LocalStorageData localStorageData,StorageData storageData){\r\n    localStorageData.copyStorageDataInformation(storageData);\r\n    writeLocalStorageDataToDisk(localStorageData);\r\n}"
}, {
	"Path": "rocks.inspectit.ui.rcp.preferences.valueproviders.CollectionPreferenceValueProvider.getCollectionForResults",
	"Comment": "returns collection type to use when creating resulting collection from strings.",
	"Method": "Collection<Object> getCollectionForResults(){\r\n    return new ArrayList();\r\n}"
}]