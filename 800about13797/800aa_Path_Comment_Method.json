[{
	"Path": "com.sun.enterprise.resource.pool.PoolManagerImpl.lazyEnlist",
	"Comment": "this method gets called by the lazyenlistableconnectionmanagerimpl whena connection needs enlistment, i.e on use of a statement etc.",
	"Method": "void lazyEnlist(ManagedConnection mc){\r\n    lazyEnlistableResourceManager.lazyEnlist(mc);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.Statement.getFormattedSQLText",
	"Comment": "gets formatted sql text corrsponding to this statement object. the textalso contains values for input to the statement.",
	"Method": "String getFormattedSQLText(){\r\n    return formatSqlText(getText(), getInputValues());\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.logging.AbstractLogger.severe",
	"Comment": "log a severe message.\tif the logger is currently enabled for the severe message \tlevel then the given message is forwarded to all the\tregistered output handler objects.",
	"Method": "void severe(String msg){\r\n    log(SEVERE, msg);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getEnvironmentProperties",
	"Comment": "return a copy of the structure holding the environment properties.",
	"Method": "Set<EnvironmentProperty> getEnvironmentProperties(){\r\n    if (env != null)\r\n        return env.getEnvironmentProperties();\r\n    else\r\n        return environmentProperties;\r\n}"
}, {
	"Path": "org.glassfish.concurrent.runtime.ConcurrentRuntime.getRuntime",
	"Comment": "returns the concurrentruntime instance.it follows singleton pattern and only one instance exists at any pointof time. external entities need to call this method to getconcurrentruntime instance",
	"Method": "ConcurrentRuntime getRuntime(){\r\n    if (_runtime == null) {\r\n        throw new RuntimeException(\"ConcurrentRuntime not initialized\");\r\n    }\r\n    return _runtime;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createInverseMappingComponent",
	"Comment": "create a validation component which can check whether the mapping of \tthe relationship and the mapping of its inverse are inverses of each \tother.",
	"Method": "ValidationComponent createInverseMappingComponent(RelationshipElement field){\r\n    return new ValidationComponent() {\r\n        public void validate() throws ModelValidationException {\r\n            Model model = getModel();\r\n            RelationshipElement inverse = field.getInverseRelationship(model);\r\n            if ((inverse != null) && !isInverseMapping(field, inverse)) {\r\n                String fieldName = field.getName();\r\n                throw new ModelValidationException(model.getField(getClassName(), fieldName), I18NHelper.getMessage(getMessages(), \"util.validation.inverse_mapping_mismatch\", new Object[] { fieldName, inverse.getName() }));\r\n            }\r\n        }\r\n        private boolean hasMappingRows(MappingRelationshipElement field2) {\r\n            if (field2 != null) {\r\n                ArrayList columns = field2.getColumns();\r\n                return ((columns != null) && !columns.isEmpty());\r\n            }\r\n            return false;\r\n        }\r\n        private boolean isInverseMapping(RelationshipElement jdoField1, RelationshipElement jdoField2) {\r\n            MappingRelationshipElement field1 = getMappingRelationship(jdoField1);\r\n            MappingRelationshipElement field2 = getMappingRelationship(jdoField2);\r\n            boolean field1HasMapping = hasMappingRows(field1);\r\n            boolean field2HasMapping = hasMappingRows(field2);\r\n            if (field1HasMapping && field2HasMapping) {\r\n                boolean field1IsJoin = isJoin(field1);\r\n                if (field1IsJoin == isJoin(field2)) {\r\n                    ArrayList pairs1 = field1.getColumns();\r\n                    ArrayList pairs2 = field2.getColumns();\r\n                    return ((!field1IsJoin) ? isInverse(pairs1, pairs2) : (isInverse(pairs1, field2.getAssociatedColumns()) && isInverse(field1.getAssociatedColumns(), pairs2)));\r\n                }\r\n                return false;\r\n            }\r\n            return (field1HasMapping == field2HasMapping);\r\n        }\r\n        private boolean isInverse(ArrayList pairs1, ArrayList pairs2) {\r\n            int i, size1 = pairs1.size(), size2 = pairs2.size();\r\n            if (size1 == size2) {\r\n                for (i = 0; i < size1; i++) {\r\n                    String nextPair = (String) pairs1.get(i);\r\n                    String inversePair = (String) pairs2.get(i);\r\n                    int semicolonIndex1 = nextPair.indexOf(';');\r\n                    int semicolonIndex2 = inversePair.indexOf(';');\r\n                    if (((semicolonIndex1 == -1) || (semicolonIndex2 == -1)) || (!nextPair.substring(0, semicolonIndex1).equals(inversePair.substring(semicolonIndex2 + 1)) || !nextPair.substring(semicolonIndex1 + 1).equals(inversePair.substring(0, semicolonIndex2)))) {\r\n                        return false;\r\n                    }\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createInverseMappingComponent",
	"Comment": "create a validation component which can check whether the mapping of \tthe relationship and the mapping of its inverse are inverses of each \tother.",
	"Method": "ValidationComponent createInverseMappingComponent(RelationshipElement field){\r\n    Model model = getModel();\r\n    RelationshipElement inverse = field.getInverseRelationship(model);\r\n    if ((inverse != null) && !isInverseMapping(field, inverse)) {\r\n        String fieldName = field.getName();\r\n        throw new ModelValidationException(model.getField(getClassName(), fieldName), I18NHelper.getMessage(getMessages(), \"util.validation.inverse_mapping_mismatch\", new Object[] { fieldName, inverse.getName() }));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createInverseMappingComponent",
	"Comment": "create a validation component which can check whether the mapping of \tthe relationship and the mapping of its inverse are inverses of each \tother.",
	"Method": "ValidationComponent createInverseMappingComponent(RelationshipElement field){\r\n    if (field2 != null) {\r\n        ArrayList columns = field2.getColumns();\r\n        return ((columns != null) && !columns.isEmpty());\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createInverseMappingComponent",
	"Comment": "create a validation component which can check whether the mapping of \tthe relationship and the mapping of its inverse are inverses of each \tother.",
	"Method": "ValidationComponent createInverseMappingComponent(RelationshipElement field){\r\n    MappingRelationshipElement field1 = getMappingRelationship(jdoField1);\r\n    MappingRelationshipElement field2 = getMappingRelationship(jdoField2);\r\n    boolean field1HasMapping = hasMappingRows(field1);\r\n    boolean field2HasMapping = hasMappingRows(field2);\r\n    if (field1HasMapping && field2HasMapping) {\r\n        boolean field1IsJoin = isJoin(field1);\r\n        if (field1IsJoin == isJoin(field2)) {\r\n            ArrayList pairs1 = field1.getColumns();\r\n            ArrayList pairs2 = field2.getColumns();\r\n            return ((!field1IsJoin) ? isInverse(pairs1, pairs2) : (isInverse(pairs1, field2.getAssociatedColumns()) && isInverse(field1.getAssociatedColumns(), pairs2)));\r\n        }\r\n        return false;\r\n    }\r\n    return (field1HasMapping == field2HasMapping);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createInverseMappingComponent",
	"Comment": "create a validation component which can check whether the mapping of \tthe relationship and the mapping of its inverse are inverses of each \tother.",
	"Method": "ValidationComponent createInverseMappingComponent(RelationshipElement field){\r\n    int i, size1 = pairs1.size(), size2 = pairs2.size();\r\n    if (size1 == size2) {\r\n        for (i = 0; i < size1; i++) {\r\n            String nextPair = (String) pairs1.get(i);\r\n            String inversePair = (String) pairs2.get(i);\r\n            int semicolonIndex1 = nextPair.indexOf(';');\r\n            int semicolonIndex2 = inversePair.indexOf(';');\r\n            if (((semicolonIndex1 == -1) || (semicolonIndex2 == -1)) || (!nextPair.substring(0, semicolonIndex1).equals(inversePair.substring(semicolonIndex2 + 1)) || !nextPair.substring(semicolonIndex1 + 1).equals(inversePair.substring(0, semicolonIndex2)))) {\r\n                return false;\r\n            }\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.storesMixedCaseQuotedIdentifiers",
	"Comment": "retrieves whether this database treats mixed case quoted sql identifiers ascase insensitive and stores them in mixed case.",
	"Method": "boolean storesMixedCaseQuotedIdentifiers(){\r\n    return databaseMetaData.storesMixedCaseQuotedIdentifiers();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.MappingFile.setUpperBound",
	"Comment": "sets the upper bound for relationship element reldepending on the upper bound information from the deploymentdescriptor and defines the element class for collectionrelationship fields.",
	"Method": "void setUpperBound(RelationshipElement rel,String beanName,String fieldName){\r\n    String beanInField = helper.getRelationshipFieldContent(beanName, fieldName);\r\n    String classInJdoField = helper.getMappedClassName(beanInField);\r\n    String multiplicity = helper.getMultiplicity(beanName, fieldName);\r\n    if (multiplicity.equals(helper.MANY)) {\r\n        rel.setUpperBound(Integer.MAX_VALUE);\r\n        rel.setElementClass(classInJdoField);\r\n        String collectionClass = helper.getRelationshipFieldType(beanName, fieldName);\r\n        if (types.contains(collectionClass)) {\r\n            rel.setCollectionClass(collectionClass);\r\n        } else {\r\n            rel.setCollectionClass(null);\r\n            if (logger.isLoggable(Logger.WARNING))\r\n                logger.warning(// NOI18N\r\n                I18NHelper.getMessage(messages, \"WARN_INVALID_RELATIONSHIP_FIELDTYPE\", beanName, fieldName, collectionClass));\r\n        }\r\n    } else if (multiplicity.equals(helper.ONE)) {\r\n        rel.setUpperBound(1);\r\n        rel.setElementClass(classInJdoField);\r\n    } else {\r\n        throw new ConversionException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"ERR_BAD_MULTIPLICTY\", multiplicity, rel.getName()));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerWrapper.setSupersedeDeletedInstance",
	"Comment": "sets the supersededeletedinstance flag for this persistencemanager.",
	"Method": "void setSupersedeDeletedInstance(boolean flag){\r\n    if (isValid) {\r\n        pm.setSupersedeDeletedInstance(flag);\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerwrapper.invalidpm\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createKeyColumnMappingComponent",
	"Comment": "create a validation component which can check whether the class \tcontains field mappings for all primary key columns.",
	"Method": "ValidationComponent createKeyColumnMappingComponent(PersistenceClassElement persistenceClass){\r\n    return new ValidationComponent() {\r\n        public void validate() throws ModelValidationException {\r\n            String className = getClassName();\r\n            MappingClassElement mappingClass = getMappingClass(className);\r\n            if (mappingClass != null) {\r\n                List tables = mappingClass.getTables();\r\n                if (tables.size() > 0) {\r\n                    String tableName = ((MappingTableElement) tables.get(0)).getName();\r\n                    TableElement table = getTable(tableName, getSchemaForClass(className));\r\n                    List columns = getUnmappedColumnNames(((table != null) ? table.getPrimaryKey() : null), mappingClass);\r\n                    if ((columns != null) && (columns.size() > 0)) {\r\n                        throw new ModelValidationException(ModelValidationException.WARNING, getOffendingObject(null), I18NHelper.getMessage(getMessages(), \"util.validation.class_key_column_missing\", className, tableName, StringHelper.arrayToSeparatedList(columns)));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        private List getUnmappedColumnNames(KeyElement primaryKey, MappingClassElement mappingClass) {\r\n            List unmappedColumns = null;\r\n            if (primaryKey != null) {\r\n                ColumnElement[] columns = primaryKey.getColumns();\r\n                int count = ((columns != null) ? columns.length : 0);\r\n                if (count > 0) {\r\n                    List mappingFields = mappingClass.getFields();\r\n                    Iterator iterator = mappingFields.iterator();\r\n                    unmappedColumns = getRelativeColumnNames(columns);\r\n                    while (iterator.hasNext()) {\r\n                        MappingFieldElement field = (MappingFieldElement) iterator.next();\r\n                        if (isKeyField(field))\r\n                            unmappedColumns.removeAll(field.getColumns());\r\n                    }\r\n                }\r\n            }\r\n            return unmappedColumns;\r\n        }\r\n        private List getRelativeColumnNames(ColumnElement[] columns) {\r\n            int i, count = ((columns != null) ? columns.length : 0);\r\n            List columnNames = new ArrayList(count);\r\n            for (i = 0; i < count; i++) {\r\n                columnNames.add(NameUtil.getRelativeMemberName(columns[i].getName().getFullName()));\r\n            }\r\n            return columnNames;\r\n        }\r\n        private boolean isKeyField(MappingFieldElement field) {\r\n            PersistenceFieldElement persistenceField = persistenceClass.getField(field.getName());\r\n            return ((persistenceField != null) && persistenceField.isKey());\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createKeyColumnMappingComponent",
	"Comment": "create a validation component which can check whether the class \tcontains field mappings for all primary key columns.",
	"Method": "ValidationComponent createKeyColumnMappingComponent(PersistenceClassElement persistenceClass){\r\n    String className = getClassName();\r\n    MappingClassElement mappingClass = getMappingClass(className);\r\n    if (mappingClass != null) {\r\n        List tables = mappingClass.getTables();\r\n        if (tables.size() > 0) {\r\n            String tableName = ((MappingTableElement) tables.get(0)).getName();\r\n            TableElement table = getTable(tableName, getSchemaForClass(className));\r\n            List columns = getUnmappedColumnNames(((table != null) ? table.getPrimaryKey() : null), mappingClass);\r\n            if ((columns != null) && (columns.size() > 0)) {\r\n                throw new ModelValidationException(ModelValidationException.WARNING, getOffendingObject(null), I18NHelper.getMessage(getMessages(), \"util.validation.class_key_column_missing\", className, tableName, StringHelper.arrayToSeparatedList(columns)));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createKeyColumnMappingComponent",
	"Comment": "create a validation component which can check whether the class \tcontains field mappings for all primary key columns.",
	"Method": "ValidationComponent createKeyColumnMappingComponent(PersistenceClassElement persistenceClass){\r\n    List unmappedColumns = null;\r\n    if (primaryKey != null) {\r\n        ColumnElement[] columns = primaryKey.getColumns();\r\n        int count = ((columns != null) ? columns.length : 0);\r\n        if (count > 0) {\r\n            List mappingFields = mappingClass.getFields();\r\n            Iterator iterator = mappingFields.iterator();\r\n            unmappedColumns = getRelativeColumnNames(columns);\r\n            while (iterator.hasNext()) {\r\n                MappingFieldElement field = (MappingFieldElement) iterator.next();\r\n                if (isKeyField(field))\r\n                    unmappedColumns.removeAll(field.getColumns());\r\n            }\r\n        }\r\n    }\r\n    return unmappedColumns;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createKeyColumnMappingComponent",
	"Comment": "create a validation component which can check whether the class \tcontains field mappings for all primary key columns.",
	"Method": "ValidationComponent createKeyColumnMappingComponent(PersistenceClassElement persistenceClass){\r\n    int i, count = ((columns != null) ? columns.length : 0);\r\n    List columnNames = new ArrayList(count);\r\n    for (i = 0; i < count; i++) {\r\n        columnNames.add(NameUtil.getRelativeMemberName(columns[i].getName().getFullName()));\r\n    }\r\n    return columnNames;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createKeyColumnMappingComponent",
	"Comment": "create a validation component which can check whether the class \tcontains field mappings for all primary key columns.",
	"Method": "ValidationComponent createKeyColumnMappingComponent(PersistenceClassElement persistenceClass){\r\n    PersistenceFieldElement persistenceField = persistenceClass.getField(field.getName());\r\n    return ((persistenceField != null) && persistenceField.isKey());\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxIndexLength",
	"Comment": "retrieves the maximum number of bytes this database allows for anindex, including all of the parts of the index.",
	"Method": "int getMaxIndexLength(){\r\n    return databaseMetaData.getMaxIndexLength();\r\n}"
}, {
	"Path": "com.sun.enterprise.naming.impl.JavaURLContext.listBindings",
	"Comment": "lists the bindings of a context or subcontext. the operation isdelegated to the serial context.",
	"Method": "NamingEnumeration<Binding> listBindings(String name,NamingEnumeration<Binding> listBindings,Name name){\r\n    return listBindings(name.toString());\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.BundleDescriptor.getEntityManagerFactories",
	"Comment": "returns the set of physical entity manager factories associatedwith persistence units in this module.",
	"Method": "Set<EntityManagerFactory> getEntityManagerFactories(){\r\n    return new HashSet<EntityManagerFactory>(entityManagerFactories.values());\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.connector.InBoundRANode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object obj){\r\n    if (obj instanceof MessageListener) {\r\n        descriptor.addMessageListener((MessageListener) obj);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.servlet.LogFilesContentSource.cleanUp",
	"Comment": "this method may be used to clean up any temporary resources.it will be invoked after the inputstream has been completely read.",
	"Method": "void cleanUp(DownloadServlet.Context ctx){\r\n    // NOI18N\r\n    InputStream tmpFile = (InputStream) ctx.getAttribute(\"tmpFile\");\r\n    if (tmpFile != null) {\r\n        try {\r\n            tmpFile.close();\r\n        } catch (Exception ex) {\r\n        }\r\n    }\r\n    ctx.removeAttribute(\"tmpFile\");\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.isAfterLast",
	"Comment": "retrieves whether the cursor is after the last row inthis resultset object.",
	"Method": "boolean isAfterLast(){\r\n    return resultSet.isAfterLast();\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.Java2DBProcessorHelper.executeDDLStatement",
	"Comment": "get the ddl files eventually executedagainst the database. this method dealswith both create and drop ddl files.",
	"Method": "boolean executeDDLStatement(File fileName,String resourceName,boolean executeDDLStatement,String fileNamePrefix,String resourceName){\r\n    File file = null;\r\n    Connection conn = null;\r\n    try {\r\n        conn = getConnection(resourceName);\r\n        DatabaseMetaData dbMetaData = conn.getMetaData();\r\n        String vendorName = DBVendorTypeHelper.getDBType(dbMetaData.getDatabaseProductName()).toLowerCase(Locale.ENGLISH);\r\n        file = new File(fileNamePrefix + vendorName + DatabaseConstants.SQL_FILE_EXTENSION);\r\n        logger.fine(\"===> File to use: \" + file);\r\n    } catch (IOException e) {\r\n        fileIOError(appRegisteredName, e);\r\n    } catch (Exception ex) {\r\n        cannotConnect(resourceName, ex);\r\n    } finally {\r\n        closeConn(conn);\r\n    }\r\n    return executeDDLStatement(file, resourceName);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorService.switchOnMatching",
	"Comment": "matching will be switched off in the pool, by default. this will beswitched on if the connections with different resource principals reach the pool.",
	"Method": "void switchOnMatching(String rarName,PoolInfo poolInfo){\r\n    if (rarName.equals(ConnectorConstants.JDBCDATASOURCE_RA_NAME) || rarName.equals(ConnectorConstants.JDBCCONNECTIONPOOLDATASOURCE_RA_NAME) || rarName.equals(ConnectorConstants.JDBCXA_RA_NAME)) {\r\n        PoolManager poolMgr = _runtime.getPoolManager();\r\n        boolean result = poolMgr.switchOnMatching(poolInfo);\r\n        if (!result) {\r\n            try {\r\n                _runtime.switchOnMatchingInJndi(poolInfo);\r\n            } catch (ConnectorRuntimeException cre) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.enterprise.iiop.impl.IORAddrAnyInterceptor.name",
	"Comment": "returns the name of the interceptor.each interceptor may have a name that may be used administrativelyto order the lists of interceptors. only one interceptor of a givenname can be registered with the orb for each interceptor type. aninterceptor may be anonymous, i.e., have an empty string as the nameattribute. any number of anonymous interceptors may be registered withthe orb.",
	"Method": "String name(){\r\n    return baseMsg;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.Environment.lookupDestClass",
	"Comment": "look for a class source using the destination directory as aroot directory for the lookup which represents the annotated outputfor the class specified.return null if not found.",
	"Method": "ClassFileSource lookupDestClass(String className){\r\n    if (destClassPath == null && destinationDirectory != null)\r\n        destClassPath = new ClassPath(destinationDirectory.getPath());\r\n    return (destClassPath == null ? null : destClassPath.findClass(className));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.NameMapper.isRemoteInterface",
	"Comment": "determines if the specified name represents a remote interface.",
	"Method": "boolean isRemoteInterface(String name){\r\n    return mapContainsKey(REMOTE_NAME, name);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.setRuntimeXMLValidation",
	"Comment": "turn on or off the xml validation for runtime deploymentdescriptors loading",
	"Method": "void setRuntimeXMLValidation(boolean validate){\r\n    isValidatingRuntimeXML = validate;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.updateMethodPermissionForMethod",
	"Comment": "update a method descriptor set of method permission with a new method permissionthe new method permission is added to the list of existing method permissionsgiven it respect the ejb 2.0 paragraph 21.3.2 on priorities of method permissions",
	"Method": "void updateMethodPermissionForMethod(MethodPermission mp,MethodDescriptor md){\r\n    Set oldPermissions = getMethodPermissions(md);\r\n    if (oldPermissions.isEmpty()) {\r\n        addMethodPermissionForMethod(mp, md);\r\n        return;\r\n    }\r\n    if (mp.isExcluded()) {\r\n        for (Iterator oldPermissionsItr = oldPermissions.iterator(); oldPermissionsItr.hasNext(); ) {\r\n            MethodPermission oldMp = (MethodPermission) oldPermissionsItr.next();\r\n            removePermissionedMethod(oldMp, md);\r\n        }\r\n        addMethodPermissionForMethod(mp, md);\r\n    } else {\r\n        if (mp.isUnchecked()) {\r\n            for (Iterator oldPermissionsItr = oldPermissions.iterator(); oldPermissionsItr.hasNext(); ) {\r\n                MethodPermission oldMp = (MethodPermission) oldPermissionsItr.next();\r\n                if (!oldMp.isExcluded()) {\r\n                    removePermissionedMethod(oldMp, md);\r\n                    addMethodPermissionForMethod(mp, md);\r\n                }\r\n            }\r\n        } else {\r\n            for (Iterator oldPermissionsItr = oldPermissions.iterator(); oldPermissionsItr.hasNext(); ) {\r\n                MethodPermission oldMp = (MethodPermission) oldPermissionsItr.next();\r\n                if (!oldMp.isExcluded()) {\r\n                    if (!oldMp.isUnchecked()) {\r\n                        addMethodPermissionForMethod(mp, md);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.deployment.node.SecurityRoleNode.getDispatchTable",
	"Comment": "declare the setname method as an action on the securityroledescriptor, as initialized by thedescriptorfactory.the deploymentdescriptornode superclass specifies the setdescription method for the description element, so we just add the setname action to that dispatch table.",
	"Method": "Map getDispatchTable(){\r\n    Map table = super.getDispatchTable();\r\n    table.put(TagNames.ROLE_NAME, \"setName\");\r\n    return table;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ee.SecurityUtil.createUniquePseudoModuleID",
	"Comment": "create pseudo module context id, and make sure it is unique, bychacking it against the names of all the other modules in the app.",
	"Method": "String createUniquePseudoModuleID(EjbBundleDescriptor ejbDesc){\r\n    Application app = ejbDesc.getApplication();\r\n    Collection<WebBundleDescriptor> webModules = app.getBundleDescriptors(WebBundleDescriptor.class);\r\n    Collection<EjbBundleDescriptor> ejbModules = app.getBundleDescriptors(EjbBundleDescriptor.class);\r\n    String moduleName = ejbDesc.getUniqueFriendlyId();\r\n    String pseudonym;\r\n    int uniquifier = 0;\r\n    boolean unique;\r\n    do {\r\n        unique = true;\r\n        pseudonym = moduleName + (uniquifier == 0 ? \"_internal\" : \"_internal_\" + uniquifier);\r\n        if (webModules != null) {\r\n            for (WebBundleDescriptor w : webModules) {\r\n                if (pseudonym.equals(w.getUniqueFriendlyId())) {\r\n                    unique = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (unique && ejbModules != null) {\r\n            for (EjbBundleDescriptor e : ejbModules) {\r\n                if (pseudonym.equals(e.getUniqueFriendlyId())) {\r\n                    unique = false;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        uniquifier += 1;\r\n    } while (!unique);\r\n    return VersioningUtils.getRepositoryName(app.getRegistrationName()) + \"/\" + pseudonym;\r\n}"
}, {
	"Path": "org.glassfish.resources.javamail.deployer.MailResourceDeployer.toMailJavaEEResource",
	"Comment": "returns a new instance of j2ee mail resource from the given config bean.this method gets called from the mail resource deployer to convert mailconfig bean into mail j2ee resource.",
	"Method": "org.glassfish.resources.api.JavaEEResource toMailJavaEEResource(MailResource mailResourceConfig,ResourceInfo resourceInfo){\r\n    org.glassfish.resources.javamail.beans.MailResource mailResource = new org.glassfish.resources.javamail.beans.MailResource(resourceInfo);\r\n    mailResource.setEnabled(Boolean.valueOf(mailResourceConfig.getEnabled()));\r\n    mailResource.setStoreProtocol(mailResourceConfig.getStoreProtocol());\r\n    mailResource.setStoreProtocolClass(mailResourceConfig.getStoreProtocolClass());\r\n    mailResource.setTransportProtocol(mailResourceConfig.getTransportProtocol());\r\n    mailResource.setTransportProtocolClass(mailResourceConfig.getTransportProtocolClass());\r\n    mailResource.setMailHost(mailResourceConfig.getHost());\r\n    mailResource.setUsername(mailResourceConfig.getUser());\r\n    mailResource.setMailFrom(mailResourceConfig.getFrom());\r\n    mailResource.setDebug(Boolean.valueOf(mailResourceConfig.getDebug()));\r\n    List<Property> properties = mailResourceConfig.getProperty();\r\n    if (properties != null) {\r\n        for (Property property : properties) {\r\n            ResourceProperty rp = new org.glassfish.resources.api.ResourcePropertyImpl(property.getName(), property.getValue());\r\n            mailResource.addProperty(rp);\r\n        }\r\n    }\r\n    return mailResource;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.hasPermissionedRoles",
	"Comment": "returns true if i have roles to which method permissions have been assigned.",
	"Method": "boolean hasPermissionedRoles(){\r\n    for (Iterator itr = getEjbs().iterator(); itr.hasNext(); ) {\r\n        EjbDescriptor nextEjbDescriptor = (EjbDescriptor) itr.next();\r\n        if (!nextEjbDescriptor.getPermissionedMethodsByPermission().isEmpty()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.equals",
	"Comment": "determines whether obj is a persistencemanagerfactoryimpl with the same configuration",
	"Method": "boolean equals(Object obj){\r\n    if ((obj == null) || !(obj instanceof PersistenceManagerFactoryImpl)) {\r\n        return false;\r\n    }\r\n    PersistenceManagerFactoryImpl pmf = (PersistenceManagerFactoryImpl) obj;\r\n    if (pmf.providedConnectionFactory == this.providedConnectionFactory) {\r\n        if (pmf.providedConnectionFactory == SET_AS_CONNECTIONFACTORY) {\r\n            return (pmf.connectionFactory.equals(this.connectionFactory) && equalBooleanProperties(pmf));\r\n        } else if (pmf.providedConnectionFactory == SET_AS_DATASOURCE) {\r\n            return (pmf.dataSource.equals(this.dataSource) && equalBooleanProperties(pmf));\r\n        } else if (pmf.connectionFactoryName != null) {\r\n            return (pmf.connectionFactoryName.equals(this.connectionFactoryName) && equalBooleanProperties(pmf));\r\n        }\r\n        return (pmf.URL.equals(this.URL) && pmf.userName.equals(this.userName) && pmf.password.equals(this.password) && pmf.driverName.equals(this.driverName) && equalBooleanProperties(pmf));\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.perms.SMGlobalPolicyUtil.getCompRestrictedPerms",
	"Comment": "get the restricted permission set of a specified component type on the server",
	"Method": "PermissionCollection getCompRestrictedPerms(CommponentType type,PermissionCollection getCompRestrictedPerms,String type){\r\n    CommponentType compType = convertComponentType(type);\r\n    return getCompRestrictedPerms(compType);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.SelectStatement.bindInputValues",
	"Comment": "binds input valus corrsponding to this statement object todatabase statement s.",
	"Method": "void bindInputValues(DBStatement s,ValueFetcher parameters){\r\n    for (int i = 0, size = inputDesc.values.size(); i < size; i++) {\r\n        InputValue inputVal = (InputValue) inputDesc.values.get(i);\r\n        s.bindInputColumn(i + 1, getInputValue(inputVal, parameters), inputVal.getColumnElement(), vendorType);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.NestedAppClientDeployerHelper.addJARsFromDir",
	"Comment": "adds all jars that pass the filter to the download set for the application.",
	"Method": "void addJARsFromDir(StringBuilder cpForFacade,StringBuilder puScanTargets,Set<URI> dependencyURIsProcessed,File dirContainingJARs,FileFilter filter){\r\n    if (dirContainingJARs.exists() && dirContainingJARs.isDirectory()) {\r\n        File[] files = dirContainingJARs.listFiles(filter);\r\n        if (files == null) {\r\n            return;\r\n        }\r\n        for (File jar : files) {\r\n            addJar(cpForFacade, puScanTargets, jar.toURI(), dependencyURIsProcessed);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.setJTATransaction",
	"Comment": "assigns reference to javax.transaction.transaction associatedwith the current thread in the managed environment",
	"Method": "void setJTATransaction(javax.transaction.Transaction t){\r\n    if (this._jta != null) {\r\n        Object[] items = new Object[] { this._jta, t };\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerimpl.setjtatransaction.notnulljta\", items));\r\n    }\r\n    this._jta = t;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getFields",
	"Comment": "returns a list of names of all the declared field elements in the \tclass with the specified name.",
	"Method": "List getFields(String className){\r\n    List returnList = new ArrayList();\r\n    final Class classElement = (Class) getClass(className);\r\n    if (classElement != null) {\r\n        Field[] fields = (Field[]) AccessController.doPrivileged(new PrivilegedAction() {\r\n            public Object run() {\r\n                return classElement.getDeclaredFields();\r\n            }\r\n        });\r\n        int i, count = fields.length;\r\n        for (i = 0; i < count; i++) returnList.add(fields[i].getName());\r\n    }\r\n    return returnList;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getFields",
	"Comment": "returns a list of names of all the declared field elements in the \tclass with the specified name.",
	"Method": "List getFields(String className){\r\n    return classElement.getDeclaredFields();\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnectionFactory.setLogWriter",
	"Comment": "set the log writer for this managedconnectionfactory instance.",
	"Method": "void setLogWriter(java.io.PrintWriter out){\r\n    logWriter = out;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.obtainManagedConnectionFactory",
	"Comment": "returns the mcf instance. if the mcf is already created andpresent in connectorregistry that instance is returned. otherwise itis created explicitly and added to connectorregistry.",
	"Method": "ManagedConnectionFactory obtainManagedConnectionFactory(PoolInfo poolInfo,ManagedConnectionFactory obtainManagedConnectionFactory,PoolInfo poolInfo,Hashtable env){\r\n    return ccPoolAdmService.obtainManagedConnectionFactory(poolInfo, env);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConnectionPoolAdminServiceImpl.getConnectionDefinitionPropertiesAndDefaults",
	"Comment": "gets the properties of the java bean connection definition class thathave setter methods defined and the default values as provided by theconnection definition java bean developer.",
	"Method": "Map<String, Object> getConnectionDefinitionPropertiesAndDefaults(String connectionDefinitionClassName,String resType){\r\n    return ConnectionDefinitionUtils.getConnectionDefinitionPropertiesAndDefaults(connectionDefinitionClassName, resType);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.DumpMapping.dumpClassLoaderCache",
	"Comment": "print out the cache of classloaders to the specified printstream.",
	"Method": "void dumpClassLoaderCache(PrintStream stream){\r\n    stream.println(\"ClassLoader cache (class names -> ClassLoaders)\");\r\n    for (Iterator i = model.getClassLoaderCache().entrySet().iterator(); i.hasNext(); ) {\r\n        Map.Entry entry = (Map.Entry) i.next();\r\n        String className = (String) entry.getKey();\r\n        ClassLoader classLoader = (ClassLoader) entry.getValue();\r\n        // NOI18N\r\n        stream.println(\"\\t\" + className + \" ->\\t\" + classLoader);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.WebServiceEndpoint.getHandlerChain",
	"Comment": "get ordered list of webservicehandler handler chains for this endpoint.",
	"Method": "LinkedList<WebServiceHandlerChain> getHandlerChain(){\r\n    return handlerChains;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.perms.ModuleEEPermissionsProcessor.getAdjustedEEPermission",
	"Comment": "get the ee permissions which have the file path adjusted for the right module",
	"Method": "PermissionCollection getAdjustedEEPermission(){\r\n    return eePc;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsLikeEscapeClause",
	"Comment": "retrieves whether this database supports specifying alike escape clause.",
	"Method": "boolean supportsLikeEscapeClause(){\r\n    return databaseMetaData.supportsLikeEscapeClause();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.validateAndSetIsolation",
	"Comment": "common operation performed by all the child mcfs before returning a created mc",
	"Method": "void validateAndSetIsolation(ManagedConnectionImpl mc){\r\n    try {\r\n        isValid(mc);\r\n        setIsolation(mc);\r\n    } catch (ResourceException e) {\r\n        if (mc != null) {\r\n            try {\r\n                mc.destroy();\r\n            } catch (ResourceException e1) {\r\n                _logger.log(Level.WARNING, \"jdbc.exc_destroy\", e1);\r\n            }\r\n        }\r\n        String msg = localStrings.getString(\"jdbc.exc_destroy\", e.getMessage());\r\n        ResourceAllocationException rae = new ResourceAllocationException(msg, e);\r\n        throw rae;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.support.JDOHelper.isDeleted",
	"Comment": "tests whether the object has been deleted.for objects that have been deleted in the current transaction,true is returned.for transient objects, false is returned.",
	"Method": "boolean isDeleted(Object obj){\r\n    if (obj instanceof PersistenceCapable)\r\n        return ((PersistenceCapable) obj).jdoIsDeleted();\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.PoolTxHelper.isLocalResourceEligibleForReuse",
	"Comment": "check whether the local resource can be put back to poolif true, unenlist the resource",
	"Method": "boolean isLocalResourceEligibleForReuse(ResourceHandle h){\r\n    boolean result = false;\r\n    if ((!isLocalResourceInTransaction(h))) {\r\n        try {\r\n            enforceDelistment(h);\r\n        } catch (SystemException se) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"Exception while delisting the local resource [ of pool : \" + poolInfo + \" ] \" + \"forcibily from transaction\", se);\r\n            }\r\n            return result;\r\n        }\r\n        h.getResourceState().setEnlisted(false);\r\n        result = true;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConnectionPoolAdminServiceImpl.getOriginalConnectorConnectionPool",
	"Comment": "create a connectorconnectionpool from information in memory",
	"Method": "ConnectorConnectionPool getOriginalConnectorConnectionPool(PoolInfo poolInfo){\r\n    ConnectorConnectionPool ccpOrig = null;\r\n    String jndiNameForPool = ConnectorAdminServiceUtils.getReservePrefixedJNDINameForPool(poolInfo);\r\n    try {\r\n        ccpOrig = (ConnectorConnectionPool) _runtime.getResourceNamingService().lookup(poolInfo, jndiNameForPool);\r\n    } catch (NamingException ne) {\r\n        throw ne;\r\n    }\r\n    return ccpOrig;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.getDefaultCollectionClass",
	"Comment": "returns the default collection class for the specified class.if\tthe specified class is an unspecified collection type, the return\twill be hashset.",
	"Method": "String getDefaultCollectionClass(String className){\r\n    String collectionClass = \"java.util.HashSet\";\r\n    return collectionClass;\r\n}"
}, {
	"Path": "org.glassfish.admin.amxtest.config.StandaloneServerConfigTest.ensureDefaultInstance",
	"Comment": "we want the default instance to be available on both pe and ee so we have no choice but to use the das instance.",
	"Method": "StandaloneServerConfig ensureDefaultInstance(DomainRoot domainRoot){\r\n    final Map<String, StandaloneServerConfig> servers = domainRoot.getDomainConfig().getServersConfig().getStandaloneServerConfigMap();\r\n    StandaloneServerConfig server = servers.get(getDefaultInstanceName());\r\n    assert (server != null);\r\n    return server;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOConcreteBeanGenerator.getSignaturesOfGeneratorClasses",
	"Comment": "returns the signatures of the classes and properties which areinvolved in the codegen.",
	"Method": "String getSignaturesOfGeneratorClasses(){\r\n    StringBuffer signatures = // adding signature of JDOConcreteBeanGenerator\r\n    new StringBuffer().append(JDOConcreteBeanGenerator.SIGNATURE).append(// adding signature of CMPTemplates.properties\r\n    CMPTemplateFormatter.signatureDelimiter_).append(CMPTemplateFormatter.signatureTemplate).append(// adding signature of DeploymentDescriptorModel\r\n    CMPTemplateFormatter.signatureDelimiter_).append(DeploymentDescriptorModel.SIGNATURE);\r\n    return signatures.toString();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ConnectionHolder40.createBlob",
	"Comment": "constructs an object that implements the blob interface. the objectreturned initially contains no data.the setbinarystream andsetbytes methods of the blob interface may be used to add data tothe blob.",
	"Method": "Blob createBlob(){\r\n    checkValidity();\r\n    jdbcPreInvoke();\r\n    return con.createBlob();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.ConnectionFactoryImpl.equals",
	"Comment": "determines whether obj is a connectionfactoryimpl with the same configuration",
	"Method": "boolean equals(Object obj){\r\n    if ((obj != null) && (obj instanceof ConnectionFactoryImpl)) {\r\n        ConnectionFactoryImpl cf = (ConnectionFactoryImpl) obj;\r\n        return (cf.URL.equals(this.URL) && cf.userName.equals(this.userName) && cf.driverName.equals(this.driverName) && Arrays.equals(cf.password, this.password));\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.getEntityManagerFactoryReferenceByName",
	"Comment": "return the entity manager factory reference descriptor corresponding tothe given name.",
	"Method": "EntityManagerFactoryReferenceDescriptor getEntityManagerFactoryReferenceByName(String name){\r\n    for (EntityManagerFactoryReferenceDescriptor next : getEntityManagerFactoryReferenceDescriptors()) {\r\n        if (next.getName().equals(name)) {\r\n            return next;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"No entity manager factory reference of name \" + name);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.PersistenceDescriptor.getFkeyFields",
	"Comment": "return the array of persistentfieldinfo objects for the foreign key fields of this bean.",
	"Method": "PersistentFieldInfo[] getFkeyFields(){\r\n    if (!fieldInfoInitialized)\r\n        initializeFieldInfo();\r\n    return this.fkeyFields;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingClassElementImpl.setPersistenceElement",
	"Comment": "set the persistence class element for this mapping class element.",
	"Method": "void setPersistenceElement(PersistenceClassElement element){\r\n    _persistenceElement = element;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.getPersistenceManagerFactory",
	"Comment": "this method returns the persistencemanagerfactory used to createthis persistencemanager.it returns null if this instance wascreated via a constructor.",
	"Method": "com.sun.jdo.api.persistence.support.PersistenceManagerFactory getPersistenceManagerFactory(){\r\n    return persistenceManagerFactory;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.FieldDesc.initializeSCO",
	"Comment": "initializes the sco instance scoval correspondingto value. currently only used for dates.",
	"Method": "void initializeSCO(Object scoVal,Object value){\r\n    switch(enumFieldType) {\r\n        case FieldTypeEnumeration.UTIL_DATE:\r\n        case FieldTypeEnumeration.SQL_DATE:\r\n        case FieldTypeEnumeration.SQL_TIME:\r\n        case FieldTypeEnumeration.SQL_TIMESTAMP:\r\n            if (value instanceof Date) {\r\n                ((SCODate) scoVal).setTimeInternal(((Date) value).getTime());\r\n                if (enumFieldType == FieldTypeEnumeration.SQL_TIMESTAMP && value instanceof java.sql.Timestamp) {\r\n                    ((SqlTimestamp) scoVal).setNanosInternal(((java.sql.Timestamp) value).getNanos());\r\n                }\r\n            }\r\n            break;\r\n        default:\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.VersionConsistencyCacheImpl.createCacheFactory",
	"Comment": "create a cachefactory.uses system properties to determine what kind ofcache will be returned by the factory.",
	"Method": "CacheFactory createCacheFactory(){\r\n    CacheFactory rc = null;\r\n    loadFactor = getFloatValue(LOAD_FACTOR_PROPERTY, loadFactor);\r\n    bucketSize = getIntValue(BUCKET_SIZE_PROPERTY, bucketSize);\r\n    initialCapacity = getIntValue(INITIAL_CAPACITY_PROPERTY, initialCapacity);\r\n    maxEntries = getIntValue(MAX_ENTRIES_PROPERTY, maxEntries);\r\n    timeout = getLongValue(TIMEOUT_PROPERTY, timeout);\r\n    boolean lruCache = false;\r\n    try {\r\n        String s = System.getProperty(LRU_CACHE_PROPERTY);\r\n        if (s != null) {\r\n            lruCache = Boolean.valueOf(s).booleanValue();\r\n            if (lruCache) {\r\n                try {\r\n                    Class.forName(LRU_CACHE_CLASSNAME);\r\n                } catch (Exception ex) {\r\n                    logger.warning(I18NHelper.getMessage(messages, \"jdo.versionconsistencycacheimpl.lrucachenotfound\"));\r\n                    lruCache = false;\r\n                }\r\n            }\r\n        } else {\r\n            try {\r\n                Class.forName(LRU_CACHE_CLASSNAME);\r\n                lruCache = true;\r\n            } catch (Exception ex) {\r\n            }\r\n        }\r\n    } catch (Exception ex) {\r\n        lruCache = false;\r\n        logger.warning(I18NHelper.getMessage(messages, \"jdo.versionconsistencycacheimpl.unexpectedduringcreate\", ex));\r\n    }\r\n    if (lruCache) {\r\n        rc = new LruCacheFactory();\r\n    } else {\r\n        rc = new BasicCacheFactory();\r\n    }\r\n    if (logger.isLoggable(Logger.FINER)) {\r\n        // NOI18N\r\n        String values = \"\\nloadFactor= \" + loadFactor + \"\\nbucketSize= \" + bucketSize + \"\\ninitialCapacity=\" + initialCapacity + \"\\nmaxEntries=\" + maxEntries + \"\\ntimeout=\" + timeout + \"\\nlruCache=\" + lruCache;\r\n        logger.finer(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        messages, \"jdo.versionconsistencycacheimpl.created\", values));\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jauth.AuthPolicy.setContentAuth",
	"Comment": "set the source of the message content authentication policy.",
	"Method": "void setContentAuth(boolean required){\r\n    if (required) {\r\n        this.setSourceAuth(SOURCE_AUTH_CONTENT);\r\n    } else if (!isSenderAuthRequired()) {\r\n        this.setSourceAuth(SOURCE_AUTH_NONE);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.removeFromCache",
	"Comment": "removes the class with the supplied name from the cache of\tclasses known to be non pc. \tthe next call getmappingclass will determine the status of the class.",
	"Method": "void removeFromCache(String className){\r\n    synchronized (this._classes) {\r\n        _nonPCClasses.remove(className);\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.base.stats.StatefulSessionStoreStatsImpl.getActivationCount",
	"Comment": "returns the total number of sessions activated from the store",
	"Method": "CountStatistic getActivationCount(){\r\n    synchronized (activationCountLock) {\r\n        activationCount.setCount(activationCountVal);\r\n        return (CountStatistic) activationCount.unmodifiableView();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.application.gf.GFApplicationRuntimeNode.registerBundle",
	"Comment": "register this node as a root node capable of loading entire dd files",
	"Method": "String registerBundle(Map publicIDToDTD){\r\n    publicIDToDTD.put(DTDRegistry.GF_APPLICATION_601_DTD_PUBLIC_ID, DTDRegistry.GF_APPLICATION_601_DTD_SYSTEM_ID);\r\n    return RuntimeTagNames.GF_APPLICATION_RUNTIME_TAG;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.BootstrapContextImpl.createTimer",
	"Comment": "creates a java.util.timer instance.this can cause a problem, since the timer threads are not actuallyunder appserver control. we should override the timer later.",
	"Method": "Timer createTimer(){\r\n    return new Timer(\"connectors-runtime-context\", true);\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.util.GuiUtil.arrayToString",
	"Comment": "this method concatenates the delimiter char to the end of each stringin the array, and returns a single string with the concatenated string.",
	"Method": "String arrayToString(String[] str,String delimiter){\r\n    StringBuffer retStr = new StringBuffer();\r\n    if (str != null) {\r\n        for (int i = 0; i < str.length; i++) {\r\n            String element = str[i];\r\n            retStr.append(element);\r\n            if (i < str.length - 1) {\r\n                retStr.append(delimiter);\r\n            }\r\n        }\r\n    }\r\n    return retStr.toString();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.checkRelationship",
	"Comment": "checks, if there is a relationship between the persistencecapable instance managed by state manager sm andpc on field fielddesc. ifsm represents a before image, the relationship wasreset in the current transaction.",
	"Method": "boolean checkRelationship(SQLStateManager sm,ForeignFieldDesc fieldDesc,Object pc){\r\n    boolean related = false;\r\n    if (fieldDesc != null && sm != null && sm.getPresenceMaskBit(fieldDesc.absoluteID)) {\r\n        if (fieldDesc.cardinalityUPB > 1) {\r\n            Collection c = sm.getCollectionValue(fieldDesc);\r\n            related = c.contains(pc);\r\n        } else {\r\n            related = fieldDesc.getValue(sm) == pc;\r\n        }\r\n    }\r\n    return related;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBTimerService.getTimerClassLoader",
	"Comment": "get the application class loader for the timed objectthat created a given timer.",
	"Method": "ClassLoader getTimerClassLoader(long containerId){\r\n    BaseContainer container = getContainer(containerId);\r\n    return (container != null) ? container.getClassLoader() : null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingTableElementImpl.removeKeyColumn",
	"Comment": "removes a column from the primary key of columns in this mapping table.\tthis method should only be used to manipulate the key columns of the \tprimary table.the secondary table key columns should be manipulated \tusing mappingreferencekeyelement methods for pairs.",
	"Method": "void removeKeyColumn(String columnName){\r\n    if (columnName != null) {\r\n        try {\r\n            fireVetoableChange(PROP_KEY_COLUMNS, null, null);\r\n            if (!getKey().remove(columnName)) {\r\n                throw new ModelException(I18NHelper.getMessage(getMessages(), \"mapping.element.element_not_removed\", columnName));\r\n            }\r\n            firePropertyChange(PROP_KEY_COLUMNS, null, null);\r\n            _keyObjects = null;\r\n        } catch (PropertyVetoException e) {\r\n            throw new ModelVetoException(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.TransactionImpl.replaceConnection",
	"Comment": "replace a connection. used in a managed environment only.in a j2ee ri connection need to be replaced at the beforecompletion.",
	"Method": "void replaceConnection(){\r\n    if (EJBHelper.isManaged()) {\r\n        this.releaseConnection();\r\n        this.closeConnection();\r\n        this.getConnection();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.initializeEnvironment",
	"Comment": "initializes the connector runtime mode to be server or client",
	"Method": "void initializeEnvironment(ProcessEnvironment processEnvironment){\r\n    processType = processEnvironment.getProcessType();\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.ext.WhoAmIRequest.createExtendedResponse",
	"Comment": "creates an extended response object that corresponds to the ldap whoami extended request.",
	"Method": "ExtendedResponse createExtendedResponse(String id,byte[] berValue,int offset,int length){\r\n    if ((id != null) && (!id.equals(OID))) {\r\n        throw new ConfigurationException(\"WhoAmI received the following response instead of \" + OID + \": \" + id);\r\n    }\r\n    try {\r\n        return new WhoAmIResponse(id, berValue, offset, length);\r\n    } catch (IOException e) {\r\n        NamingException ne = new NamingException(\"Could not parse the response value\");\r\n        ne.setRootCause(e);\r\n        throw ne;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.resources.admin.cli.ListCustomResources.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        List<String> list = new ArrayList<String>();\r\n        Collection<CustomResource> customResources = domain.getResources().getResources(CustomResource.class);\r\n        for (CustomResource customResource : customResources) {\r\n            if (bindableResourcesHelper.resourceExists(customResource.getJndiName(), targetOperand)) {\r\n                list.add(customResource.getJndiName());\r\n            }\r\n        }\r\n        for (String jndiName : list) {\r\n            final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n            part.setMessage(jndiName);\r\n        }\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"\" + \"list.custom.resources.fail\", \"Unable to list custom resources\") + \" \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.CLIBootstrap.quote",
	"Comment": "places double quote marks around a string if the string is not alreadyso enclosed.",
	"Method": "String quote(String s){\r\n    if (s.length() > 2 && s.charAt(0) != '\"' && s.charAt(s.length() - 1) != '\"') {\r\n        return '\\\"' + s + '\\\"';\r\n    } else {\r\n        return s;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.work.WorkCoordinator.lock",
	"Comment": "lock the thread upto the end of execution or start of workexecution.",
	"Method": "void lock(){\r\n    if (!lockRequired()) {\r\n        return;\r\n    }\r\n    try {\r\n        synchronized (lock) {\r\n            while (checkStateBeforeLocking()) {\r\n                if (timeout != -1) {\r\n                    lock.wait(timeout);\r\n                } else {\r\n                    lock.wait();\r\n                }\r\n            }\r\n        }\r\n        if (getState() < STARTED) {\r\n            workTimedOut();\r\n        }\r\n        if (lockRequired()) {\r\n            synchronized (lock) {\r\n                if (checkStateBeforeLocking()) {\r\n                    lock.wait();\r\n                }\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        setException(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ActiveResourceAdapterImpl.destroyAllConnectorResources",
	"Comment": "deletes both the default connector connection pools and resources",
	"Method": "void destroyAllConnectorResources(){\r\n    if (!(isSystemRar(moduleName_))) {\r\n        deleteDefaultConnectorResources();\r\n        deleteDefaultConnectorConnectionPools();\r\n        if (desc_.getSunDescriptor() != null && desc_.getSunDescriptor().getResourceAdapter() != null) {\r\n            String jndiName = (String) desc_.getSunDescriptor().getResourceAdapter().getValue(ResourceAdapter.JNDI_NAME);\r\n            if (jndiName == null || jndiName.equals(\"\")) {\r\n            } else {\r\n                deleteSunRAConnectionPool();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.ClusterHandler.deleteInstance",
	"Comment": "if successfully deleted the instance, null will be returned, otherwise, return the error string to be displayed to user.",
	"Method": "String deleteInstance(String instanceName){\r\n    try {\r\n        String endpoint = GuiUtil.getSessionValue(\"REST_URL\") + \"/servers/server/\" + instanceName + \"/delete-instance\";\r\n        GuiUtil.getLogger().info(endpoint);\r\n        RestUtil.restRequest(endpoint, null, \"post\", null, false);\r\n        return null;\r\n    } catch (Exception ex) {\r\n        String endpoint = GuiUtil.getSessionValue(\"REST_URL\") + \"/servers/server/\" + instanceName + \"/delete-instance\\n\";\r\n        GuiUtil.getLogger().severe(GuiUtil.getCommonMessage(\"LOG_DELETE_INSTANCE\", new Object[] { endpoint, \"null\" }));\r\n        return ex.getMessage();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.DBStatement.close",
	"Comment": "delegates the close call to the preparedstatement wrapped bythis dbstatement.",
	"Method": "void close(){\r\n    if (preparedStmt != null) {\r\n        preparedStmt.close();\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxCursorNameLength",
	"Comment": "retrieves the maximum number of characters that this database allows in acursor name.",
	"Method": "int getMaxCursorNameLength(){\r\n    return databaseMetaData.getMaxCursorNameLength();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.SaxParserHandler.resolveSchemaNamespace",
	"Comment": "determine whether the syatemid starts with a known namespace.if so, strip off that namespace and return the rest.otherwise, return null",
	"Method": "String resolveSchemaNamespace(String systemID){\r\n    List<String> namespaces = DOLUtils.getProprietarySchemaNamespaces();\r\n    for (int n = 0; n < namespaces.size(); ++n) {\r\n        String namespace = namespaces.get(n);\r\n        if (systemID.startsWith(namespace)) {\r\n            return systemID.substring(namespace.length());\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.getEntityManagerReferenceByName",
	"Comment": "return the entity manager factory reference descriptor corresponding tothe given name.",
	"Method": "EntityManagerReferenceDescriptor getEntityManagerReferenceByName(String name){\r\n    for (EntityManagerReferenceDescriptor next : getEntityManagerReferenceDescriptors()) {\r\n        if (next.getName().equals(name)) {\r\n            return next;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"No entity manager reference of name \" + name);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.node.runtime.EjbBundleRuntimeNode.registerBundle",
	"Comment": "register this node as a root node capable of loading entire dd files",
	"Method": "String registerBundle(Map publicIDToDTD){\r\n    publicIDToDTD.put(DTDRegistry.SUN_EJBJAR_200_DTD_PUBLIC_ID, DTDRegistry.SUN_EJBJAR_200_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_EJBJAR_201_DTD_PUBLIC_ID, DTDRegistry.SUN_EJBJAR_201_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_EJBJAR_210_DTD_PUBLIC_ID, DTDRegistry.SUN_EJBJAR_210_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_EJBJAR_211_DTD_PUBLIC_ID, DTDRegistry.SUN_EJBJAR_211_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_EJBJAR_300_DTD_PUBLIC_ID, DTDRegistry.SUN_EJBJAR_300_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_EJBJAR_310_DTD_PUBLIC_ID, DTDRegistry.SUN_EJBJAR_310_DTD_SYSTEM_ID);\r\n    if (!restrictDTDDeclarations()) {\r\n        publicIDToDTD.put(DTDRegistry.SUN_EJBJAR_210beta_DTD_PUBLIC_ID, DTDRegistry.SUN_EJBJAR_210beta_DTD_SYSTEM_ID);\r\n    }\r\n    return RuntimeTagNames.S1AS_EJB_RUNTIME_TAG;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.CodeAttribute.localsUsed",
	"Comment": "return the maximum number of local variables used by this method",
	"Method": "int localsUsed(){\r\n    makeValid();\r\n    return maxLocals;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.beforeFirst",
	"Comment": "moves the cursor to the front ofthis resultset object, just before thefirst row. this method has no effect if the result set contains no rows.",
	"Method": "void beforeFirst(){\r\n    resultSet.beforeFirst();\r\n}"
}, {
	"Path": "com.sun.ejb.base.stats.HAStatefulSessionStoreStatsImpl.getCheckpointTime",
	"Comment": "returns the time spent on passivating beans to the store including total, min, max",
	"Method": "AverageRangeStatistic getCheckpointTime(){\r\n    synchronized (checkpointTimeLock) {\r\n        return (AverageRangeStatistic) checkpointTime.unmodifiableView();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.isParameterCast",
	"Comment": "returns true if parameters need to be casted for this database",
	"Method": "boolean isParameterCast(){\r\n    String s = (String) dbMap.get(PARAMETER_CAST);\r\n    Boolean b = Boolean.valueOf(s);\r\n    if (logger.isLoggable()) {\r\n        logger.fine(\"sqlstore.database.dbvendor.isParameterCast\", b);\r\n    }\r\n    return b.booleanValue();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.getEnvironmentProperties",
	"Comment": "return a copy of the structure holding the environment properties.",
	"Method": "Set<EnvironmentProperty> getEnvironmentProperties(){\r\n    return environmentProperties;\r\n}"
}, {
	"Path": "com.sun.jaspic.config.factory.RegStoreFileParser.loadEntries",
	"Comment": "called from the constructor. this is the only timethe file is read, though it is written when newentries are stored or deleted.",
	"Method": "void loadEntries(){\r\n    synchronized (confFile) {\r\n        entries = new ArrayList<EntryInfo>();\r\n        if (confFile.exists()) {\r\n            try (BufferedReader reader = new BufferedReader(new FileReader(confFile))) {\r\n                String line = reader.readLine();\r\n                while (line != null) {\r\n                    String trimLine = line.trim();\r\n                    if (trimLine.startsWith(CON_ENTRY)) {\r\n                        entries.add(readConEntry(reader));\r\n                    } else if (trimLine.startsWith(REG_ENTRY)) {\r\n                        entries.add(readRegEntry(reader));\r\n                    }\r\n                    line = reader.readLine();\r\n                }\r\n            }\r\n        } else {\r\n            if (logger.isLoggable(Level.FINER)) {\r\n                logger.log(Level.FINER, \"jmac.factory_file_not_found\", confFile.getParent() + File.pathSeparator + confFile.getPath());\r\n            }\r\n            for (EntryInfo e : defaultEntries) {\r\n                entries.add(new EntryInfo(e));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.acl.RoleMapper.getUsersAssignedTo",
	"Comment": "returns an enumeration of principals assigned to the given role",
	"Method": "Enumeration<Principal> getUsersAssignedTo(Role r){\r\n    assert roleToPrincipal != null;\r\n    Set<Principal> s = roleToPrincipal.get(r.getName());\r\n    if (s == null) {\r\n        return Collections.enumeration(Collections.EMPTY_SET);\r\n    }\r\n    return Collections.enumeration(s);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.XAResourceImpl.prepare",
	"Comment": "ask the resource manager to prepare for a transaction commitof the transaction specified in xid.",
	"Method": "int prepare(Xid xid){\r\n    try {\r\n        int result = xar.prepare(xid);\r\n        if (result == XAResource.XA_RDONLY) {\r\n            mc.transactionCompleted();\r\n        }\r\n        return result;\r\n    } catch (XAException xae) {\r\n        mc.transactionCompleted();\r\n        throw xae;\r\n    } catch (Exception e) {\r\n        mc.transactionCompleted();\r\n        throw new XAException(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsOpenStatementsAcrossCommit",
	"Comment": "retrieves whether this database supports keeping statements openacross commits.",
	"Method": "boolean supportsOpenStatementsAcrossCommit(){\r\n    return databaseMetaData.supportsOpenStatementsAcrossCommit();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.RuntimeVersion.parse_version",
	"Comment": "parse the build date and create a localized versionreturn version as string",
	"Method": "String parse_version(){\r\n    if (_properties == null)\r\n        return null;\r\n    String majorVersion = _properties.getProperty(product_version);\r\n    String minorVersion = _properties.getProperty(runtime_version);\r\n    String buildTime = _properties.getProperty(build_time);\r\n    String s = null;\r\n    try {\r\n        DateFormat dateFormatter = DateFormat.getDateTimeInstance();\r\n        SimpleDateFormat propertyFormat = new SimpleDateFormat(\"MM/dd/yy hh:mm:ss\");\r\n        s = dateFormatter.format(propertyFormat.parse(buildTime));\r\n    } catch (Exception e) {\r\n        s = \"\";\r\n    }\r\n    return I18NHelper.getMessage(vendor_info, \"fullVersion\", majorVersion, minorVersion, s);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.isTransactionInProgress",
	"Comment": "checks if a this managedconnection is involved in a transactionor not.",
	"Method": "boolean isTransactionInProgress(){\r\n    return transactionInProgress;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.scope.SymbolTable.leaveScope",
	"Comment": "closes the actual scope.hidden definitions are reinstalled.",
	"Method": "void leaveScope(){\r\n    forgetNesting((Nesting) nestings.pop());\r\n    actualScope--;\r\n}"
}, {
	"Path": "org.glassfish.deployapi.actions.ClientConfigurationImpl.execute",
	"Comment": "this method performs an exec and starts theapplication client running in another process.",
	"Method": "void execute(){\r\n    if (targetModuleID == null) {\r\n        throw new ClientExecuteException(localStrings.getLocalString(\"enterprise.deployapi.actions.clientconfigurationimpl.nomoduleid\", \"No moduleID for deployed application found\"));\r\n    }\r\n    TargetImpl target = (TargetImpl) targetModuleID.getTarget();\r\n    String moduleID;\r\n    if (targetModuleID.getParentTargetModuleID() != null) {\r\n        moduleID = targetModuleID.getParentTargetModuleID().getModuleID();\r\n    } else {\r\n        moduleID = targetModuleID.getModuleID();\r\n    }\r\n    try {\r\n        String location = target.exportClientStubs(moduleID, System.getProperty(\"java.io.tmpdir\"));\r\n        String j2eeHome = System.getProperty(\"com.sun.aas.installRoot\");\r\n        String appClientBinary = j2eeHome + File.separatorChar + \"bin\" + File.separatorChar + \"appclient\";\r\n        String command = appClientBinary + \" -client \" + location;\r\n        Runtime.getRuntime().exec(command);\r\n    } catch (Exception e) {\r\n        Logger.getAnonymousLogger().log(Level.WARNING, \"Error occurred\", e);\r\n        throw new ClientExecuteException(localStrings.getLocalString(\"enterprise.deployapi.actions.clientconfigurationimpl.exception\", \"Exception while invoking application client : \\n {0}\", new Object[] { e.getMessage() }));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.deleteFile",
	"Comment": "deletes the file with the given file name which is parallel\tto the supplied class.",
	"Method": "void deleteFile(String className,String fileName){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.NameMapper.getConcreteBeanClassForEjbName",
	"Comment": "gets the name of the concrete bean class which corresponds to the \tspecified ejb.",
	"Method": "String getConcreteBeanClassForEjbName(String name){\r\n    IASEjbCMPEntityDescriptor descriptor = getIASDescriptorForEjbName(name);\r\n    return ((descriptor != null) ? getQualifiedName(getAbstractBeanClassForEjbName(name), descriptor.getConcreteImplClassName()) : null);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingTableElementImpl.setKey",
	"Comment": "set the list of column names in the primary key for this mapping \ttable.this method should only be used internally and for cloning \tand archiving.",
	"Method": "void setKey(ArrayList key){\r\n    _key = key;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.CMPHelper.getNumericConverterPolicy",
	"Comment": "called in cmp environment to get numericconverter policy referencedby this container instance.",
	"Method": "int getNumericConverterPolicy(Object container){\r\n    return getContainerHelper().getNumericConverterPolicy(container);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.TypeSupport.unaryNumericPromotion",
	"Comment": "implements unray numeric promotion as defined in the java language specification section 5.6.1",
	"Method": "Object unaryNumericPromotion(Object type){\r\n    if (isNumericType(type)) {\r\n        if (type.equals(byteType) || type.equals(shortType) || type.equals(charType)) {\r\n            return intType;\r\n        } else {\r\n            return type;\r\n        }\r\n    }\r\n    return errorType;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.ApplicationFactory.openWith",
	"Comment": "this method populates the rest of the application object from theprevious standard deployment descriptor reading",
	"Method": "Application openWith(Application application,ReadableArchive archive,Archivist archivist){\r\n    archivist.openWith(application, archive);\r\n    if (application.isVirtual()) {\r\n        application.setClassLoader(archivist.getClassLoader());\r\n        application.visit((ApplicationVisitor) new ApplicationValidator());\r\n    }\r\n    return application;\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.obj.GroupOfURLs.removeMembers",
	"Comment": "removes members from the group.performs an ldap modify to remove the ldap url.",
	"Method": "void removeMembers(String members){\r\n    if (!isBound()) {\r\n        throw new IllegalStateException();\r\n    }\r\n    if (debug) {\r\n        System.out.println(\"[debug] removing the members: \" + members);\r\n    }\r\n    modifyMembers(members, DirContext.REMOVE_ATTRIBUTE);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.stats.BoundedRangeStatisticImpl.getLowWaterMark",
	"Comment": "returns the lowest value of this statistic, since measurement started.",
	"Method": "long getLowWaterMark(){\r\n    return lowWaterMark;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ClassDesc.newStateManagerInstance",
	"Comment": "returns a new sqlstatemanager instance,initialized with passed store manager and this instance ofthe runtime class model.",
	"Method": "SQLStateManager newStateManagerInstance(PersistenceStore store){\r\n    return new SQLStateManager(store, this);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.DriverLoader.getEquivalentName",
	"Comment": "get equivalent name for the database vendor name. this is useful forintrospection as the vendor name for oracle and sun oracle type of jdbcdrivers are the same.",
	"Method": "String getEquivalentName(String dbVendor){\r\n    if (dbVendor.toUpperCase(Locale.getDefault()).startsWith(DATABASE_VENDOR_JAVADB) || dbVendor.equalsIgnoreCase(DATABASE_VENDOR_EMBEDDED_DERBY) || dbVendor.equalsIgnoreCase(DATABASE_VENDOR_EMBEDDED_DERBY_30) || dbVendor.equalsIgnoreCase(DATABASE_VENDOR_DERBY_30) || dbVendor.equalsIgnoreCase(DATABASE_VENDOR_JAVADB_30)) {\r\n        return DATABASE_VENDOR_DERBY;\r\n    } else if (dbVendor.equalsIgnoreCase(DATABASE_VENDOR_MSSQLSERVER) || dbVendor.equalsIgnoreCase(DATABASE_VENDOR_SUN_SQLSERVER)) {\r\n        return DATABASE_VENDOR_SQLSERVER;\r\n    } else if (dbVendor.equalsIgnoreCase(DATABASE_VENDOR_SUN_DB2)) {\r\n        return DATABASE_VENDOR_DB2;\r\n    } else if (dbVendor.equalsIgnoreCase(DATABASE_VENDOR_SUN_ORACLE)) {\r\n        return DATABASE_VENDOR_ORACLE;\r\n    } else if (dbVendor.equalsIgnoreCase(DATABASE_VENDOR_SUN_SYBASE)) {\r\n        return DATABASE_VENDOR_SYBASE;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.Environment.excludeDestinationDirectory",
	"Comment": "update the class path to remove the destination directory if itis found in the class path.",
	"Method": "void excludeDestinationDirectory(){\r\n    if (destinationDirectory != null)\r\n        classPathOption.remove(destinationDirectory);\r\n}"
}, {
	"Path": "org.glassfish.resources.connector.ResourcesSniffer.getContainersNames",
	"Comment": "returns the list of containers that this sniffer enables.the runtime will look up each container implementingusing the names provided in the habitat.",
	"Method": "String[] getContainersNames(){\r\n    return containerNames;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.PersistenceDescriptor.methodsEqual",
	"Comment": "checks whether two methods that might have been loaded bydifferent class loaders are equal.",
	"Method": "boolean methodsEqual(Method m1,Method m2,boolean compareDeclaringClass){\r\n    boolean equal = false;\r\n    do {\r\n        String m1Name = m1.getName();\r\n        String m2Name = m2.getName();\r\n        if (!m1Name.equals(m2Name)) {\r\n            break;\r\n        }\r\n        String m1DeclaringClass = m1.getDeclaringClass().getName();\r\n        String m2DeclaringClass = m2.getDeclaringClass().getName();\r\n        if (compareDeclaringClass) {\r\n            if (!m1DeclaringClass.equals(m2DeclaringClass)) {\r\n                break;\r\n            }\r\n        }\r\n        Class[] m1ParamTypes = m1.getParameterTypes();\r\n        Class[] m2ParamTypes = m2.getParameterTypes();\r\n        if (m1ParamTypes.length != m2ParamTypes.length) {\r\n            break;\r\n        }\r\n        equal = true;\r\n        for (int pIndex = 0; pIndex < m1ParamTypes.length; pIndex++) {\r\n            String m1ParamClass = m1ParamTypes[pIndex].getName();\r\n            String m2ParamClass = m2ParamTypes[pIndex].getName();\r\n            if (!m1ParamClass.equals(m2ParamClass)) {\r\n                equal = false;\r\n                break;\r\n            }\r\n        }\r\n    } while (false);\r\n    return equal;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.EJBHashSet.addAll",
	"Comment": "adds all of the elements in the specified collection to this collection",
	"Method": "boolean addAll(Collection c){\r\n    logger.finest(\"---EJBHashSet.addAll---\");\r\n    assertIsValid();\r\n    assertInTransaction();\r\n    assertInstancesOfLocalInterfaceImpl(c);\r\n    return pcSet.addAll(helper.convertCollectionEJBLocalObjectToPC(c, pm, true));\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.XAResourceImpl.forget",
	"Comment": "tell the resource manager to forget about a heuristically completed transaction branch.",
	"Method": "void forget(Xid xid){\r\n    xar.forget(xid);\r\n}"
}, {
	"Path": "com.sun.jaspic.config.factory.BaseAuthConfigFactory.detachListener",
	"Comment": "disassociate the listener from all the providerregistrations whose layer and appcontext values are matchedby the corresponding arguments to this method.",
	"Method": "String[] detachListener(RegistrationListener listener,String layer,String appContext){\r\n    SecurityManager sm = System.getSecurityManager();\r\n    if (sm != null) {\r\n        sm.checkPermission(AuthConfigFactory.providerRegistrationSecurityPermission);\r\n    }\r\n    ArrayList<String> list = new ArrayList<String>();\r\n    String regisID = getRegistrationID(layer, appContext);\r\n    wLock.lock();\r\n    try {\r\n        Set<String> targets = id2RegisListenersMap.keySet();\r\n        for (String targetID : targets) {\r\n            if (regIdImplies(regisID, targetID)) {\r\n                List<RegistrationListener> listeners = id2RegisListenersMap.get(targetID);\r\n                if (listeners != null && listeners.remove(listener)) {\r\n                    list.add(targetID);\r\n                }\r\n            }\r\n        }\r\n    } finally {\r\n        wLock.unlock();\r\n    }\r\n    return list.toArray(new String[list.size()]);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxCharLiteralLength",
	"Comment": "retrieves the maximum number of characters this database allowsfor a character literal.",
	"Method": "int getMaxCharLiteralLength(){\r\n    return databaseMetaData.getMaxCharLiteralLength();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ConnectionWrapper40.getMetaData",
	"Comment": "retrieves the databasemetadataobject from the underlying connectionobject.",
	"Method": "DatabaseMetaData getMetaData(){\r\n    return new DatabaseMetaDataWrapper40(this, super.getMetaData());\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getByte",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object asa byte in the java programming language.",
	"Method": "byte getByte(int columnIndex,byte getByte,String columnName){\r\n    return resultSet.getByte(columnName);\r\n}"
}, {
	"Path": "org.glassfish.javaee.core.deployment.JavaEEDeployer.prepare",
	"Comment": "prepares the application bits for running in the application server.for certain cases, this is generating non portableartifacts and other application specific tasks.failure to prepare should throw an exception which will cause the overalldeployment to fail.",
	"Method": "boolean prepare(DeploymentContext dc){\r\n    try {\r\n        ((ExtendedDeploymentContext) dc).prepareScratchDirs();\r\n        BundleDescriptor bundleDesc = dc.getModuleMetaData(BundleDescriptor.class);\r\n        if (bundleDesc.hasWebServiceClients()) {\r\n            JAXRPCCodeGenFacade jaxrpcCodeGenFacade = jaxrpcCodeGenFacadeProvider.get();\r\n            if (jaxrpcCodeGenFacade != null) {\r\n                jaxrpcCodeGenFacade.run(habitat, dc, getModuleClassPath(dc), true);\r\n            }\r\n        }\r\n        if (!dc.getCommandParameters(OpsParams.class).origin.isArtifactsPresent()) {\r\n            generateArtifacts(dc);\r\n        }\r\n        return true;\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(ex.getMessage(), ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConnectionPoolAdminServiceImpl.getConnection",
	"Comment": "get a sql connection from the datasource specified by the jdbcjndiname.this api is intended to be used in the das. the motivation for having thisapi is to provide the cmp backend a means of acquiring a connection duringthe codegen phase. if a user is trying to deploy an app on a remote server,without this api, a resource reference has to be present both in the dasand the server instance. this makes the deployment more complex for theuser since a resource needs to be forcibly created in the das too.this api will mitigate this need.",
	"Method": "Connection getConnection(ResourceInfo resourceInfo,String user,String password,Connection getConnection,ResourceInfo resourceInfo){\r\n    java.sql.Connection con = null;\r\n    try {\r\n        PoolInfo poolInfo = getPoolNameFromResourceJndiName(resourceInfo);\r\n        if (poolInfo == null) {\r\n            throw new SQLException(\"No pool by name exists \");\r\n        }\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.fine(\"ConnectorRuntime.getConnection :: poolName : \" + poolInfo);\r\n        }\r\n        con = (java.sql.Connection) getUnpooledConnection(poolInfo, null, true);\r\n        if (con == null) {\r\n            String i18nMsg = localStrings.getString(\"ccp_adm.null_unpooled_connection\");\r\n            throw new SQLException(i18nMsg);\r\n        }\r\n    } catch (ResourceException re) {\r\n        SQLException sqle = new SQLException(re.getMessage());\r\n        sqle.initCause(re);\r\n        _logger.log(Level.WARNING, \"jdbc.exc_get_conn\", re.getMessage());\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.fine(\"Exception : \" + re);\r\n        }\r\n        throw sqle;\r\n    } catch (Exception ex) {\r\n        SQLException sqle = new SQLException(ex.getMessage());\r\n        sqle.initCause(ex);\r\n        _logger.log(Level.WARNING, \"jdbc.exc_get_conn\", ex.getMessage());\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.fine(\" getConnection in ConnectorRuntime failed : \" + ex);\r\n        }\r\n        throw sqle;\r\n    }\r\n    return con;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectorConnPoolStatsProvider.potentialConnLeakEvent",
	"Comment": "whenever connection leak happens, increment numpotentialconnleak",
	"Method": "void potentialConnLeakEvent(String poolName,String appName,String moduleName){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (logger.isLoggable(Level.FINEST)) {\r\n            logger.finest(\"Connection Leak event received - poolName = \" + poolName);\r\n        }\r\n        numPotentialConnLeak.increment();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.SelectStatement.isUpdateLockRequired",
	"Comment": "determines if an update lock is required while executing this query.",
	"Method": "boolean isUpdateLockRequired(QueryTable table,boolean isUpdateLockRequired){\r\n    boolean updateLockRequired = false;\r\n    for (int i = 0; i < tableList.size() && !updateLockRequired; i++) {\r\n        QueryTable queryTable = (QueryTable) tableList.get(i);\r\n        updateLockRequired = isUpdateLockRequired(queryTable);\r\n    }\r\n    return updateLockRequired;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.TagSupport.setTagMaps",
	"Comment": "this method stores the given array of maps via the \tpreferences api.",
	"Method": "void setTagMaps(Map<String, List<Tag>>[] maps){\r\n    ByteArrayOutputStream buf = new ByteArrayOutputStream();\r\n    try {\r\n        ObjectOutputStream out = new ObjectOutputStream(buf);\r\n        out.writeObject(maps);\r\n        Preferences prefs = Preferences.userRoot().node(BASE_NODE);\r\n        prefs.putByteArray(TAG_DATA_KEY, buf.toByteArray());\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(\"Unable to store preference!\", ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.TypeSupport.isEjbOrInterfaceName",
	"Comment": "returns true if the specified type info denotes an ejb name or the name of a local interface or the name of a remote interface.",
	"Method": "boolean isEjbOrInterfaceName(Object typeInfo){\r\n    String typeName = getTypeName(typeInfo);\r\n    return nameMapper.isEjbName(typeName) || nameMapper.isLocalInterface(typeName) || nameMapper.isRemoteInterface(typeName);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.VerificationSelectPlan.processFields",
	"Comment": "there are no real fields to be selected for verification query.this method just adds the tables for the version field.",
	"Method": "void processFields(){\r\n    LocalFieldDesc[] versionFields = config.getVersionFields();\r\n    for (int i = 0; i < versionFields.length; i++) {\r\n        LocalFieldDesc versionField = versionFields[i];\r\n        addTable(versionField);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.util.ClassFileSource.expectedClassName",
	"Comment": "the expected name of the class contained in the class file.returns null if the class name can not be intuited from the file name.",
	"Method": "String expectedClassName(){\r\n    return theExpectedClassName;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsANSI92IntermediateSQL",
	"Comment": "retrieves whether this database supports the ansi92 intermediate sql grammar supported.",
	"Method": "boolean supportsANSI92IntermediateSQL(){\r\n    return databaseMetaData.supportsANSI92IntermediateSQL();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.toPCArray",
	"Comment": "converts the list smlist of state managers intoan array of persistence capable instances.",
	"Method": "Object[] toPCArray(List smList){\r\n    final int size = smList.size();\r\n    if (size > 0) {\r\n        List pcList = new ArrayList(size);\r\n        for (int i = 0; i < size; i++) {\r\n            StateManager sm = (StateManager) smList.get(i);\r\n            pcList.add(sm.getPersistent());\r\n        }\r\n        return pcList.toArray();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.CommandLaunchInfo.getClientLaunchType",
	"Comment": "returns which type of launch the user has triggered given the combinationof options he or she specified.",
	"Method": "ClientLaunchType getClientLaunchType(){\r\n    return clientLaunchType;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.flushTxCache",
	"Comment": "writes the instances from the transactional cache to the store.the transactional cache contains modified instances only.",
	"Method": "void flushTxCache(){\r\n    List err = flushToDataStore(_txCache);\r\n    if (err != null && err.size() > 0) {\r\n        Iterator iter = err.iterator();\r\n        while (iter.hasNext()) {\r\n            ((StateManager) iter.next()).resolveDependencies();\r\n        }\r\n        err = flushToDataStore(err);\r\n    }\r\n    if (err != null && err.size() > 0) {\r\n        _transaction.setRollbackOnly();\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerimpl.notprocessed\"), toPCArray(err));\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.BundleDescriptor.getRoles",
	"Comment": "return the set of com.sun.enterprise.deployment.role objectsi have plus the ones from application",
	"Method": "Set<Role> getRoles(){\r\n    if (roles == null) {\r\n        roles = new OrderedSet<Role>();\r\n    }\r\n    if (application != null) {\r\n        roles.addAll(application.getAppRoles());\r\n    }\r\n    return roles;\r\n}"
}, {
	"Path": "org.glassfish.deployapi.SunDeploymentManager.isLocaleSupported",
	"Comment": "reports if this implementation supports the designated locale.",
	"Method": "boolean isLocaleSupported(Locale locale){\r\n    Locale[] locales = getSupportedLocales();\r\n    for (int i = 0; i < locales.length; i++) {\r\n        if (locales[i].equals(locale))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.support.SynchronizationManager.beforeCompletion",
	"Comment": "this method will be called during transaction completion.resourceaccess is allowed.this method in turn calls each registered instance beforecompletion method.",
	"Method": "void beforeCompletion(){\r\n    int size = synchronizations.size();\r\n    for (int i = 0; i < size; ++i) {\r\n        Synchronization instance = (Synchronization) synchronizations.get(i);\r\n        instance.beforeCompletion();\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBTimerService.getTimerIds",
	"Comment": "called by ejbtimerservicewrapper when caller calls gettimers.",
	"Method": "Collection<TimerPrimaryKey> getTimerIds(long containerId,Object timedObjectPrimaryKey,Collection<TimerPrimaryKey> getTimerIds,Collection<Long> containerIds){\r\n    Collection<TimerPrimaryKey> timerIds = new HashSet<TimerPrimaryKey>();\r\n    for (long containerId : containerIds) {\r\n        timerIds.addAll(timerCache_.getNonPersistentActiveTimerIdsForContainer(containerId));\r\n    }\r\n    return timerIds;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ConnectionHolder.setSavepoint",
	"Comment": "creates a savepoint with the name and returns an object corresponding to that.",
	"Method": "Savepoint setSavepoint(Savepoint setSavepoint,String name){\r\n    checkValidity();\r\n    return con.setSavepoint(name);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jacc.provider.SimplePolicyConfiguration.getPermissions",
	"Comment": "evaluates the policy and returns apermissioncollection object specifying the set ofpermissions allowed given the characteristics of theprotection domain.",
	"Method": "PermissionCollection getPermissions(PermissionCollection basePerms,CodeSource codesource,PermissionCollection getPermissions,PermissionCollection basePerms,ProtectionDomain domain,PermissionCollection getPermissions,PermissionCollection basePerms,PermissionCollection domainPerms,Principal[] principals){\r\n    pcrLock.lock();\r\n    try {\r\n        assertStateIsInService();\r\n        Permissions c = null;\r\n        boolean hasExcludes = hasExcludedPermissions();\r\n        if (basePerms != null) {\r\n            for (Enumeration e = basePerms.elements(); e.hasMoreElements(); ) {\r\n                Permission p = (Permission) e.nextElement();\r\n                if (!hasExcludes || !permIsExcluded(p)) {\r\n                    if (c == null) {\r\n                        c = new Permissions();\r\n                    }\r\n                    c.add(p);\r\n                }\r\n            }\r\n        }\r\n        if (domainPerms != null) {\r\n            for (Enumeration e = domainPerms.elements(); e.hasMoreElements(); ) {\r\n                Permission p = (Permission) e.nextElement();\r\n                if (!hasExcludes || !permIsExcluded(p)) {\r\n                    if (c == null) {\r\n                        c = new Permissions();\r\n                    }\r\n                    c.add(p);\r\n                }\r\n            }\r\n        }\r\n        for (Enumeration e = getUncheckedPermissions().elements(); e.hasMoreElements(); ) {\r\n            Permission p = (Permission) e.nextElement();\r\n            if (!hasExcludes || !permIsExcluded(p)) {\r\n                if (c == null) {\r\n                    c = new Permissions();\r\n                }\r\n                c.add(p);\r\n            }\r\n        }\r\n        if (principals.length == 0 || roleTable == null) {\r\n            return c;\r\n        }\r\n        for (Role role : roleTable) {\r\n            if (role.arePrincipalsInRole(principals)) {\r\n                PermissionCollection rc = role.getPermissions();\r\n                for (Enumeration e = rc.elements(); e.hasMoreElements(); ) {\r\n                    Permission p = (Permission) e.nextElement();\r\n                    if (!hasExcludes || !permIsExcluded(p)) {\r\n                        if (c == null) {\r\n                            c = new Permissions();\r\n                        }\r\n                        c.add(p);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return c;\r\n    } catch (UnsupportedOperationException uso) {\r\n        throw new PolicyContextException(uso);\r\n    } finally {\r\n        pcrLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.PersistenceDescriptor.setFkeyFields",
	"Comment": "set the array of persistentfieldinfo objects representing the foreign key fields of this bean.",
	"Method": "void setFkeyFields(PersistentFieldInfo[] fkeyFields){\r\n    this.fkeyFields = fkeyFields;\r\n    fieldInfoInitialized = false;\r\n    persFieldInfo = null;\r\n}"
}, {
	"Path": "com.sun.enterprise.naming.impl.SerialContext.getNameInNamespace",
	"Comment": "the getnameinnamespace api is not supported in this context.",
	"Method": "String getNameInNamespace(){\r\n    return myName;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.ArrayList.removeAll",
	"Comment": "removes from this arraylist all of its elements that are contained in thespecified collection.",
	"Method": "boolean removeAll(Collection c){\r\n    boolean modified = false;\r\n    StateManager stateManager = this.makeDirty();\r\n    Iterator e = c.iterator();\r\n    while (e.hasNext()) {\r\n        Object o = e.next();\r\n        if (super.contains(o)) {\r\n            removeInternal(o);\r\n            if (added.remove(o) == false)\r\n                removed.add(o);\r\n            modified = true;\r\n        }\r\n    }\r\n    this.applyUpdates(stateManager, modified);\r\n    return modified;\r\n}"
}, {
	"Path": "admin.AdminBaseDevTest.writeTimestamp",
	"Comment": "this will give a rough idea of the time spent for every report call",
	"Method": "void writeTimestamp(String s,boolean b){\r\n    BufferedWriter out = null;\r\n    long prevTime = lastReportTime;\r\n    lastReportTime = System.currentTimeMillis();\r\n    long elapsed = prevTime == 0 ? 0 : lastReportTime - prevTime;\r\n    try {\r\n        out = new BufferedWriter(new FileWriter(TIMESTAMP_FILE, true));\r\n        out.write(\"\" + elapsed + \"ms \" + b + \"  [\" + s + \"]\");\r\n    } catch (IOException e) {\r\n    } finally {\r\n        if (out != null) {\r\n            try {\r\n                out.write(\"\\n\");\r\n                out.close();\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getType",
	"Comment": "returns the string representation of type of the specified element. \tif element denotes a field, it returns the type of the field. \tif element denotes a method, it returns the return type of the method. \tnote, element is either a field element as returned by getfield, or a \tmethod element as returned by getmethod executed on the same model \tinstance. this implementation expects the element being a reflection \tinstance.",
	"Method": "String getType(Object element){\r\n    return getNameForType(getTypeObject(element));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.newSpecialDBOperationInstance",
	"Comment": "returns new instance of class specified by specialdbopclassname.the class is required to implement interface specialdboperation.if specialdbopclassname is null or cannot be loaded, then an instanceof basespecialdboperation is returned.",
	"Method": "SpecialDBOperation newSpecialDBOperationInstance(String specialDBOpClassName,DatabaseMetaData databaseMetaData,String identifier){\r\n    SpecialDBOperation retInstance = null;\r\n    if (specialDBOpClassName != null) {\r\n        final ClassLoader loader = DBVendorType.class.getClassLoader();\r\n        Class clz = (Class) java.security.AccessController.doPrivileged(new java.security.PrivilegedAction() {\r\n            public Object run() {\r\n                try {\r\n                    if (loader != null) {\r\n                        return Class.forName(specialDBOpClassName, true, loader);\r\n                    } else {\r\n                        return Class.forName(specialDBOpClassName);\r\n                    }\r\n                } catch (Exception ex) {\r\n                    if (logger.isLoggable()) {\r\n                        logger.log(Logger.INFO, \"core.configuration.cantloadclass\", specialDBOpClassName);\r\n                    }\r\n                    return null;\r\n                }\r\n            }\r\n        });\r\n        if (clz != null) {\r\n            try {\r\n                retInstance = (SpecialDBOperation) clz.newInstance();\r\n                retInstance.initialize(databaseMetaData, identifier);\r\n            } catch (Exception ex) {\r\n                throw new JDOFatalUserException(I18NHelper.getMessage(messages, \"sqlstore.database.dbvendor.cantinstantiateclass\", specialDBOpClassName), ex);\r\n            }\r\n        }\r\n    }\r\n    return (retInstance != null) ? retInstance : DEFAULT_SPECIAL_DB_OPERATION;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.newSpecialDBOperationInstance",
	"Comment": "returns new instance of class specified by specialdbopclassname.the class is required to implement interface specialdboperation.if specialdbopclassname is null or cannot be loaded, then an instanceof basespecialdboperation is returned.",
	"Method": "SpecialDBOperation newSpecialDBOperationInstance(String specialDBOpClassName,DatabaseMetaData databaseMetaData,String identifier){\r\n    try {\r\n        if (loader != null) {\r\n            return Class.forName(specialDBOpClassName, true, loader);\r\n        } else {\r\n            return Class.forName(specialDBOpClassName);\r\n        }\r\n    } catch (Exception ex) {\r\n        if (logger.isLoggable()) {\r\n            logger.log(Logger.INFO, \"core.configuration.cantloadclass\", specialDBOpClassName);\r\n        }\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceMemberElement.setDeclaringClass",
	"Comment": "set the declaring class of this member element.this method should \tonly be used internally and for cloning and archiving.",
	"Method": "void setDeclaringClass(PersistenceClassElement declaringClass){\r\n    _declaringClass = declaringClass;\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.NestedAppClientDeployerHelper.newArtifact",
	"Comment": "creates a new artifact using the uri of a referencing file and the uriof the referenced file.",
	"Method": "Artifact newArtifact(Artifact referencingArtifact,URI referencedURI,Artifact newArtifact,URI referencingURI,URI referencedURI,Artifact newArtifact,URI canonicalArtifactURIWithinEAR){\r\n    Artifact result = null;\r\n    if (isSubmodule(canonicalArtifactURIWithinEAR) && isDirectoryDeployed) {\r\n        result = new VirtualJARArtifact(canonicalArtifactURIWithinEAR);\r\n    } else {\r\n        final File artifactFile;\r\n        try {\r\n            artifactFile = new File(ensureFileSchemedURI(earURI.resolve(canonicalArtifactURIWithinEAR)));\r\n            if (artifactFile.exists()) {\r\n                if (artifactFile.isDirectory()) {\r\n                    result = new DirectoryArtifact(artifactFile);\r\n                } else {\r\n                    result = new JARArtifact(artifactFile);\r\n                }\r\n            } else {\r\n                logger.log(Level.FINE, \"Attempt to create artifact with URI {0} which translates to the file {1}  but no such file exists.\", new Object[] { canonicalArtifactURIWithinEAR.toASCIIString(), artifactFile.getAbsolutePath() });\r\n            }\r\n        } catch (URISyntaxException ex) {\r\n            throw new RuntimeException(ex);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ConnectionHolder.setHoldability",
	"Comment": "sets the holdability of resultset objects createdusing this connection object.",
	"Method": "void setHoldability(int holdability){\r\n    checkValidity();\r\n    con.setHoldability(holdability);\r\n}"
}, {
	"Path": "org.glassfish.deployapi.DeploymentStatusImpl.isFailed",
	"Comment": "a convience method to report if the operation isin the failed state.",
	"Method": "boolean isFailed(){\r\n    return StateType.FAILED.equals(stateType);\r\n}"
}, {
	"Path": "org.glassfish.loadbalancer.admin.cli.reader.impl.ClusterReaderHelper.getWebModules",
	"Comment": "returns the web module readers for a set of application refs.",
	"Method": "WebModuleReader[] getWebModules(Domain domain,ApplicationRegistry appRegistry,List<ApplicationRef> refs,String target){\r\n    List<WebModuleReader> list = new ArrayList<WebModuleReader>();\r\n    Set<String> contextRoots = new HashSet<String>();\r\n    Iterator<ApplicationRef> refAppsIter = refs.iterator();\r\n    HashMap<String, ApplicationRef> refferedApps = new HashMap<String, ApplicationRef>();\r\n    while (refAppsIter.hasNext()) {\r\n        ApplicationRef appRef = refAppsIter.next();\r\n        refferedApps.put(appRef.getRef(), appRef);\r\n    }\r\n    Applications applications = domain.getApplications();\r\n    Set<Application> apps = new HashSet<Application>();\r\n    apps.addAll(applications.getApplicationsWithSnifferType(\"web\"));\r\n    apps.addAll(applications.getApplicationsWithSnifferType(\"webservices\"));\r\n    Iterator<Application> appsIter = apps.iterator();\r\n    while (appsIter.hasNext()) {\r\n        Application app = appsIter.next();\r\n        String appName = app.getName();\r\n        if (!refferedApps.containsKey(appName)) {\r\n            continue;\r\n        }\r\n        ApplicationInfo appInfo = appRegistry.get(appName);\r\n        if (appInfo == null) {\r\n            String msg = LbLogUtil.getStringManager().getString(\"UnableToGetAppInfo\", appName);\r\n            LbLogUtil.getLogger().log(Level.WARNING, msg);\r\n            continue;\r\n        }\r\n        com.sun.enterprise.deployment.Application depApp = appInfo.getMetaData(com.sun.enterprise.deployment.Application.class);\r\n        Iterator<BundleDescriptor> bundleDescriptorIter = depApp.getBundleDescriptors().iterator();\r\n        while (bundleDescriptorIter.hasNext()) {\r\n            BundleDescriptor bundleDescriptor = bundleDescriptorIter.next();\r\n            try {\r\n                if (bundleDescriptor instanceof WebBundleDescriptor) {\r\n                    WebModuleReader wmr = new WebModuleReaderImpl(appName, refferedApps.get(appName), app, (WebBundleDescriptor) bundleDescriptor);\r\n                    if (!contextRoots.contains(wmr.getContextRoot())) {\r\n                        contextRoots.add(wmr.getContextRoot());\r\n                        list.add(wmr);\r\n                    }\r\n                } else if (bundleDescriptor instanceof EjbBundleDescriptor) {\r\n                    EjbBundleDescriptor ejbBundleDescriptor = (EjbBundleDescriptor) bundleDescriptor;\r\n                    if (!ejbBundleDescriptor.hasWebServices()) {\r\n                        continue;\r\n                    }\r\n                    Iterator<WebServiceEndpoint> wsIter = ejbBundleDescriptor.getWebServices().getEndpoints().iterator();\r\n                    while (wsIter.hasNext()) {\r\n                        WebServiceEndpointReaderImpl wsr = new WebServiceEndpointReaderImpl(appName, refferedApps.get(appName), app, wsIter.next());\r\n                        if (!contextRoots.contains(wsr.getContextRoot())) {\r\n                            contextRoots.add(wsr.getContextRoot());\r\n                            list.add(wsr);\r\n                        }\r\n                    }\r\n                }\r\n            } catch (LbReaderException ex) {\r\n                String msg = LbLogUtil.getStringManager().getString(\"UnableToGetContextRoot\", appName, ex.getMessage());\r\n                LbLogUtil.getLogger().log(Level.WARNING, msg);\r\n                if (LbLogUtil.getLogger().isLoggable(Level.FINE)) {\r\n                    LbLogUtil.getLogger().log(Level.FINE, \"Exception when getting context root for application\", ex);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    contextRoots.clear();\r\n    WebModuleReader[] webModules = new WebModuleReader[list.size()];\r\n    return (WebModuleReader[]) list.toArray(webModules);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerWrapper.getTransactionalInstance",
	"Comment": "this method is used to get a persistencecapable instancerepresenting the same data store object as the parameter, that is validfor this persistencemanager.",
	"Method": "Object getTransactionalInstance(Object pc){\r\n    if (isValid) {\r\n        return pm.getTransactionalInstance(pc);\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerwrapper.invalidpm\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBContainerTransactionManager.preInvokeTx",
	"Comment": "handle transaction requirements, if any, before invoking bean method",
	"Method": "void preInvokeTx(EjbInvocation inv){\r\n    Integer preInvokeTxStatus = inv.getPreInvokeTxStatus();\r\n    int status = (preInvokeTxStatus != null) ? preInvokeTxStatus.intValue() : transactionManager.getStatus();\r\n    if (container.suspendTransaction(inv)) {\r\n        if (status != Status.STATUS_NO_TRANSACTION) {\r\n            try {\r\n                inv.clientTx = transactionManager.suspend();\r\n            } catch (SystemException ex) {\r\n                throw new EJBException(ex);\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    boolean isNullTx = false;\r\n    if (inv.isRemote) {\r\n        isNullTx = transactionManager.isNullTransaction();\r\n    }\r\n    int txAttr = container.getTxAttr(inv);\r\n    EJBContextImpl context = (EJBContextImpl) inv.context;\r\n    Transaction prevTx = context.getTransaction();\r\n    switch(txAttr) {\r\n        case Container.TX_BEAN_MANAGED:\r\n            if (status != Status.STATUS_NO_TRANSACTION) {\r\n                inv.clientTx = transactionManager.suspend();\r\n            }\r\n            if (container.isStatefulSession && prevTx != null && prevTx.getStatus() != Status.STATUS_NO_TRANSACTION) {\r\n                transactionManager.resume(prevTx);\r\n                transactionManager.enlistComponentResources();\r\n            }\r\n            break;\r\n        case Container.TX_NOT_SUPPORTED:\r\n            if (status != Status.STATUS_NO_TRANSACTION) {\r\n                inv.clientTx = transactionManager.suspend();\r\n            }\r\n            container.checkUnfinishedTx(prevTx, inv);\r\n            container.preInvokeNoTx(inv);\r\n            break;\r\n        case Container.TX_MANDATORY:\r\n            if (isNullTx || status == Status.STATUS_NO_TRANSACTION) {\r\n                throw new TransactionRequiredLocalException();\r\n            }\r\n            useClientTx(prevTx, inv);\r\n            break;\r\n        case Container.TX_REQUIRED:\r\n            if (isNullTx) {\r\n                throw new TransactionRequiredLocalException();\r\n            }\r\n            if (status == Status.STATUS_NO_TRANSACTION) {\r\n                inv.clientTx = null;\r\n                startNewTx(prevTx, inv);\r\n            } else {\r\n                inv.clientTx = transactionManager.getTransaction();\r\n                useClientTx(prevTx, inv);\r\n            }\r\n            break;\r\n        case Container.TX_REQUIRES_NEW:\r\n            if (status != Status.STATUS_NO_TRANSACTION) {\r\n                inv.clientTx = transactionManager.suspend();\r\n            }\r\n            startNewTx(prevTx, inv);\r\n            break;\r\n        case Container.TX_SUPPORTS:\r\n            if (isNullTx) {\r\n                throw new TransactionRequiredLocalException();\r\n            }\r\n            if (status != Status.STATUS_NO_TRANSACTION) {\r\n                useClientTx(prevTx, inv);\r\n            } else {\r\n                container.checkUnfinishedTx(prevTx, inv);\r\n                container.preInvokeNoTx(inv);\r\n            }\r\n            break;\r\n        case Container.TX_NEVER:\r\n            if (isNullTx || status != Status.STATUS_NO_TRANSACTION) {\r\n                throw new EJBException(\"EJB cannot be invoked in global transaction\");\r\n            } else {\r\n                container.checkUnfinishedTx(prevTx, inv);\r\n                container.preInvokeNoTx(inv);\r\n            }\r\n            break;\r\n        default:\r\n            throw new EJBException(\"Bad transaction attribute\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceElementCollection.setPropertyName",
	"Comment": "set the property name of this collection to the supplied name.\tthis name is used to generate the correct property change event on \tchanges to the collection.this method should only be used \tinternally and for cloning and archiving.",
	"Method": "void setPropertyName(String propertyName){\r\n    _propertyName = propertyName;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnectionFactory.isValidByAutoCommit",
	"Comment": "checks if a java.sql.connection is valid or notby checking its auto commit property.",
	"Method": "void isValidByAutoCommit(java.sql.Connection con){\r\n    if (con == null) {\r\n        throw new ResourceException(\"The connection is not valid as \" + \"the connection is null\");\r\n    }\r\n    try {\r\n        boolean ac = con.getAutoCommit();\r\n        if (ac) {\r\n            con.setAutoCommit(false);\r\n        } else {\r\n            con.rollback();\r\n            con.setAutoCommit(true);\r\n        }\r\n        con.setAutoCommit(ac);\r\n    } catch (Exception sqle) {\r\n        _logger.log(Level.SEVERE, \"jdbc.exc_autocommit\");\r\n        throw new ResourceException(sqle.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getDouble",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object asa double in the java programming language.",
	"Method": "double getDouble(int columnIndex,double getDouble,String columnName){\r\n    return resultSet.getDouble(columnName);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.XAEndOccurred",
	"Comment": "this method is called by the xaresource object when its end methodhas been invoked.",
	"Method": "void XAEndOccurred(){\r\n    try {\r\n        actualConnection.setAutoCommit(true);\r\n    } catch (Exception e) {\r\n        _logger.log(Level.WARNING, \"XA End [ setAutoCommit ] failure \", e);\r\n        connectionErrorOccurred(e, null);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.util.SecurityUtils.getPasswordCredential",
	"Comment": "this method returns the passwordcredential object, giventhe managedconnectionfactory, subject and theconnectionrequestinfo. it first checks if theconnectionrequestinfo is null or not. if it is not null,it constructs a passwordcredential object withthe user and password fields from the connectionrequestinfo and returns thispasswordcredential object. if the connectionrequestinfois null, it retrieves the passwordcredential objects fromthe subject parameter and returns the firstpasswordcredential object which contains amanagedconnectionfactory, instance equivalentto the managedconnectionfactory, parameter.",
	"Method": "PasswordCredential getPasswordCredential(ManagedConnectionFactory mcf,Subject subject,javax.resource.spi.ConnectionRequestInfo info){\r\n    if (info == null) {\r\n        if (subject == null) {\r\n            return null;\r\n        } else {\r\n            PasswordCredential pc = (PasswordCredential) AccessController.doPrivileged(new PrivilegedAction() {\r\n                public Object run() {\r\n                    Set passwdCredentialSet = subject.getPrivateCredentials(PasswordCredential.class);\r\n                    Iterator iter = passwdCredentialSet.iterator();\r\n                    while (iter.hasNext()) {\r\n                        PasswordCredential temp = (PasswordCredential) iter.next();\r\n                        if (temp.getManagedConnectionFactory().equals(mcf)) {\r\n                            return temp;\r\n                        }\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            if (pc == null) {\r\n                String msg = sm.getString(\"su.no_passwd_cred\");\r\n                throw new javax.resource.spi.SecurityException(msg);\r\n            } else {\r\n                return pc;\r\n            }\r\n        }\r\n    } else {\r\n        ConnectionRequestInfoImpl cxReqInfo = (ConnectionRequestInfoImpl) info;\r\n        PasswordCredential pc = new PasswordCredential(cxReqInfo.getUser(), cxReqInfo.getPassword());\r\n        pc.setManagedConnectionFactory(mcf);\r\n        return pc;\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.util.SecurityUtils.getPasswordCredential",
	"Comment": "this method returns the passwordcredential object, giventhe managedconnectionfactory, subject and theconnectionrequestinfo. it first checks if theconnectionrequestinfo is null or not. if it is not null,it constructs a passwordcredential object withthe user and password fields from the connectionrequestinfo and returns thispasswordcredential object. if the connectionrequestinfois null, it retrieves the passwordcredential objects fromthe subject parameter and returns the firstpasswordcredential object which contains amanagedconnectionfactory, instance equivalentto the managedconnectionfactory, parameter.",
	"Method": "PasswordCredential getPasswordCredential(ManagedConnectionFactory mcf,Subject subject,javax.resource.spi.ConnectionRequestInfo info){\r\n    Set passwdCredentialSet = subject.getPrivateCredentials(PasswordCredential.class);\r\n    Iterator iter = passwdCredentialSet.iterator();\r\n    while (iter.hasNext()) {\r\n        PasswordCredential temp = (PasswordCredential) iter.next();\r\n        if (temp.getManagedConnectionFactory().equals(mcf)) {\r\n            return temp;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getTypeObject",
	"Comment": "returns the class type of the specified element. \tif element denotes a field, it returns the type of the field. \tif element denotes a method, it returns the return type of the method. \tnote, element is either a field element as returned by getfield, or a \tmethod element as returned by getmethod executed on the same model \tinstance.",
	"Method": "Class getTypeObject(Object element){\r\n    Class type = null;\r\n    if (element != null) {\r\n        if (element instanceof Field)\r\n            type = ((Field) element).getType();\r\n        else if (element instanceof Method)\r\n            type = ((Method) element).getReturnType();\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecurityMechanismSelector.getSecurityContextForAppClient",
	"Comment": "create the security context to be used by the csiv2 layerto marshal in the service context of the iiop message from an appclientor standalone client.",
	"Method": "SecurityContext getSecurityContextForAppClient(ComponentInvocation ci,boolean sslUsed,boolean clientAuthOccurred,CompoundSecMech mechanism){\r\n    return sendUsernameAndPassword(ci, sslUsed, clientAuthOccurred, mechanism);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.QueryImpl.setClass",
	"Comment": "bind the candidate class to the query instance.the class is used to scope the names in the query filter.all of the candidate instances will be of this class or subclass.",
	"Method": "void setClass(Class candidateClass){\r\n    synchronized (this.paramtab) {\r\n        this.candidateClass = candidateClass;\r\n        this.compiled = false;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.getMaxPool",
	"Comment": "returns maximum number of persistencemanager instances in the pool",
	"Method": "int getMaxPool(){\r\n    return maxPool;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.node.EjbBundleNode.registerBundle",
	"Comment": "register this node as a root node capable of loading entire dd files",
	"Method": "String registerBundle(Map publicIDToDTD){\r\n    publicIDToDTD.put(PUBLIC_DTD_ID, SYSTEM_ID);\r\n    publicIDToDTD.put(PUBLIC_DTD_ID_12, SYSTEM_ID_12);\r\n    return tag.getQName();\r\n}"
}, {
	"Path": "org.glassfish.deployapi.ProgressObjectImpl.getCompletedStatus",
	"Comment": "retrieve the final deployment status which has complete details for each stage",
	"Method": "DFDeploymentStatus getCompletedStatus(){\r\n    if (deployActionCompleted) {\r\n        return finalDeploymentStatus;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.interceptors.JavaEEInterceptorBuilderFactoryImpl.isClientProxy",
	"Comment": "tests if a given object is a client proxy associated with an interceptor invoker.",
	"Method": "boolean isClientProxy(Object obj){\r\n    Class clazz = obj.getClass();\r\n    return (OptionalLocalInterfaceProvider.class.isAssignableFrom(clazz));\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.MethodAnnotater.checkMethod",
	"Comment": "examine the method to determine what sort of annotations are needed",
	"Method": "void checkMethod(){\r\n    // NOI18N\r\n    env.message(\"checking method \" + ca.userClassName() + \".\" + method.name().asString() + Descriptor.userMethodArgs(method.signature().asString()));\r\n    annotate = 0;\r\n    final CodeAttribute codeAttr = method.codeAttribute();\r\n    if (codeAttr == null) {\r\n        return;\r\n    }\r\n    if (avoidAnnotation()) {\r\n        return;\r\n    }\r\n    checkCode(codeAttr);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.optional.BackupDomainCommand.canSuspend",
	"Comment": "this method determines if the das has the ability to suspend itself.",
	"Method": "boolean canSuspend(){\r\n    try {\r\n        RemoteCLICommand cmd = new RemoteCLICommand(\"list-commands\", programOpts, env);\r\n        String response = cmd.executeAndReturnOutput(\"list-commands\");\r\n        if (response.indexOf(\"suspend-domain\") >= 0)\r\n            return true;\r\n    } catch (Exception e) {\r\n        logger.info(\"Exception while probing DAS (list-commands): \" + e.getMessage());\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.FieldGroupElementImpl.getCollection",
	"Comment": "returns the field collection of this field group element.this \tmethod should only be used internally and for cloning and archiving.",
	"Method": "PersistenceElementCollection getCollection(){\r\n    return _fields;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.io.runtime.WLSApplicationRuntimeDDFile.registerBundle",
	"Comment": "register the root node for this runtime deployment descriptor filein the root nodes map, and also in the dtd map which will be used fordtd validation.",
	"Method": "void registerBundle(Map<String, Class> rootNodesMap,Map<String, String> publicIDToDTDMap,Map<String, List<Class>> versionUpgrades){\r\n    rootNodesMap.put(WeblogicApplicationNode.registerBundle(publicIDToDTDMap, versionUpgrades), WeblogicApplicationNode.class);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStoreManager.executeUpdate",
	"Comment": "executes the sql text contained in updatestatementagainst the database. data used for placeholders in theupdatestatement is passed in the updatedesc parameterand bound to the statement before execution. can be used fordelete, insert, or update sql statements, but not for selectsql statements as these return result values with whichexecuteupdate is not prepared to deal.",
	"Method": "void executeUpdate(PersistenceManager pm,UpdateStatement updateStatement,UpdateObjectDescImpl updateDesc){\r\n    int affectedRows = 0;\r\n    boolean debug = logger.isLoggable();\r\n    if (debug) {\r\n        logger.fine(\"sqlstore.sqlstoremanager.executeupdate\");\r\n    }\r\n    String sqlText = updateStatement.getText();\r\n    if (sqlText.length() > 0) {\r\n        if (sqlLogger.isLoggable()) {\r\n            sqlLogger.fine(updateStatement.getFormattedSQLText());\r\n        }\r\n        Transaction tran = (Transaction) pm.currentTransaction();\r\n        Connection conn = tran.getConnection();\r\n        DBStatement s = null;\r\n        boolean preparationSuccessful = false;\r\n        try {\r\n            s = new DBStatement(conn, sqlText, tran.getUpdateTimeout());\r\n            updateStatement.bindInputValues(s);\r\n            preparationSuccessful = true;\r\n            affectedRows = s.executeUpdate();\r\n            if (affectedRows < updateStatement.minAffectedRows) {\r\n                updateDesc.setVerificationFailed();\r\n                rollbackXact(tran);\r\n                throwJDOConcurrentAccessException(sqlText);\r\n            }\r\n        } catch (SQLException e) {\r\n            if (preparationSuccessful) {\r\n                updateDesc.setVerificationFailed();\r\n            }\r\n            rollbackXact(tran);\r\n            throwJDOSqlException(e, updateStatement.getFormattedSQLText());\r\n        } finally {\r\n            close(s);\r\n            closeConnection(tran, conn);\r\n        }\r\n    }\r\n    if (debug) {\r\n        // NOI18N\r\n        logger.fine(\"sqlstore.sqlstoremanager.executeupdate.exit\", new Integer(affectedRows));\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsSubqueriesInQuantifieds",
	"Comment": "retrieves whether this database supports subqueries in quantifiedexpressions.",
	"Method": "boolean supportsSubqueriesInQuantifieds(){\r\n    return databaseMetaData.supportsSubqueriesInQuantifieds();\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolStatsProviderBootstrap.registerPool",
	"Comment": "registers the pool lifecycle listener for this pool by creating a new connectionpoolemitterimpl object for this pool.",
	"Method": "PoolLifeCycleListenerRegistry registerPool(PoolInfo poolInfo,ConnectionPoolProbeProvider poolProvider,ConnectionPoolAppProbeProvider registerPool,PoolInfo poolInfo,String appName){\r\n    ConnectionPoolAppProbeProvider probeAppProvider = null;\r\n    Collection<ConnectionPoolMonitoringExtension> extensions = habitat.getAllServices(ConnectionPoolMonitoringExtension.class);\r\n    for (ConnectionPoolMonitoringExtension extension : extensions) {\r\n        probeAppProvider = extension.registerConnectionPool(poolInfo, appName);\r\n    }\r\n    return probeAppProvider;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.equalBooleanProperties",
	"Comment": "compares boolean setting on 2 persistencemanagerfactory instances.",
	"Method": "boolean equalBooleanProperties(PersistenceManagerFactory pmf){\r\n    return (pmf.getOptimistic() == optimistic && pmf.getRetainValues() == retainValues && pmf.getNontransactionalRead() == nontransactionalRead && pmf.getIgnoreCache() == ignoreCache && pmf.getSupersedeDeletedInstance() == supersedeDeletedInstance && pmf.getRequireCopyObjectId() == requireCopyObjectId && pmf.getRequireTrackedSCO() == requireTrackedSCO);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.TypeTable.isPersistenceCapableType",
	"Comment": "returns true if type denotes a pertsistence capable classnote, it returns false for non classtype values, especially fornulltype and errortype.",
	"Method": "boolean isPersistenceCapableType(Type type){\r\n    return ((type instanceof ClassType) && ((ClassType) type).isPersistenceCapable());\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.getConnection",
	"Comment": "get a sql connection from the datasource specified by the jdbcjndiname.this api is intended to be used in the das. the motivation for having thisapi is to provide the cmp backend a means of acquiring a connection duringthe codegen phase. if a user is trying to deploy an app on a remote server,without this api, a resource reference has to be present both in the dasand the server instance. this makes the deployment more complex for theuser since a resource needs to be forcibly created in the das too.this api will mitigate this need.",
	"Method": "Connection getConnection(ResourceInfo resourceInfo,String user,String password,Connection getConnection,ResourceInfo resourceInfo){\r\n    return ccPoolAdmService.getConnection(resourceInfo);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.EnhancerClassLoader.isSealed",
	"Comment": "returns true if the specified package name is sealed according to thegiven manifest.",
	"Method": "boolean isSealed(String name,Manifest man){\r\n    String path = name.replace('.', '/').concat(\"/\");\r\n    Attributes attr = man.getAttributes(path);\r\n    String sealed = null;\r\n    if (attr != null) {\r\n        sealed = attr.getValue(Name.SEALED);\r\n    }\r\n    if (sealed == null) {\r\n        if ((attr = man.getMainAttributes()) != null) {\r\n            sealed = attr.getValue(Name.SEALED);\r\n        }\r\n    }\r\n    return \"true\".equalsIgnoreCase(sealed);\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.JdbcTempHandler.addClassNameColumn",
	"Comment": "this handler adds the class name table column depends on the resource type.",
	"Method": "void addClassNameColumn(HandlerContext handlerCtx){\r\n    List<Map<String, String>> poolsData = (List<Map<String, String>>) handlerCtx.getInputValue(\"poolsData\");\r\n    if (poolsData != null) {\r\n        for (Map<String, String> poolData : poolsData) {\r\n            String resType = poolData.get(\"resType\");\r\n            String driverClassName = poolData.get(\"driverClassname\");\r\n            String datasourceClassName = poolData.get(\"datasourceClassname\");\r\n            if (!resType.isEmpty()) {\r\n                if (resType.equals(\"java.sql.Driver\")) {\r\n                    poolData.put(\"className\", driverClassName);\r\n                } else {\r\n                    poolData.put(\"className\", datasourceClassName);\r\n                }\r\n            } else {\r\n                if (!datasourceClassName.isEmpty()) {\r\n                    poolData.put(\"className\", datasourceClassName);\r\n                }\r\n                if (!driverClassName.isEmpty()) {\r\n                    poolData.put(\"className\", driverClassName);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    handlerCtx.setOutputValue(\"result\", poolsData);\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.jws.boot.ErrorDisplayDialog.showText",
	"Comment": "manages the dialog box to display whatever error information has alreadybeen formatted.",
	"Method": "void showText(String text,ResourceBundle rb){\r\n    ErrorDisplayDialog.rb = rb;\r\n    JTextArea stackTraceArea = new JTextArea();\r\n    stackTraceArea.setEditable(false);\r\n    stackTraceArea.setRows(16);\r\n    stackTraceArea.setText(text);\r\n    JScrollPane sp = new JScrollPane(stackTraceArea);\r\n    JCheckBox copyToClipboardCB = new JCheckBox(getString(\"jwsacc.errorDialog.copyToClipboardLabel\"));\r\n    boolean copyToClipboard = showDialog(getString(\"jwsacc.errorDialog.mainMessage.1\") + LINE_SEP + getString(\"jwsacc.errorDialog.mainMessage.2\"), sp, copyToClipboardCB);\r\n    if (copyToClipboard) {\r\n        Clipboard cb = Toolkit.getDefaultToolkit().getSystemClipboard();\r\n        StringSelection ss = new StringSelection(stackTraceArea.getText());\r\n        try {\r\n            cb.setContents(ss, null);\r\n        } catch (Throwable e) {\r\n            showDialog(getString(\"jwsacc.errorDialog.errorCopyingMessage.1\") + LINE_SEP + getString(\"jwsacc.errorDialog.errorCopyingMessage.2\"), sp, null);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.FieldGroupElementImpl.setCollection",
	"Comment": "set the field collection of this field group element to the supplied \tcollection.this method should only be used internally and for \tcloning and archiving.",
	"Method": "void setCollection(PersistenceElementCollection collection){\r\n    _fields = collection;\r\n}"
}, {
	"Path": "org.glassfish.deployment.client.AbstractDeploymentFacility.waitFor",
	"Comment": "convenient method to wait for the operation monitored by the progressobject to complete, returning the final operation status.",
	"Method": "DFDeploymentStatus waitFor(DFProgressObject po){\r\n    return po.waitFor();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.getConnectionMinPool",
	"Comment": "returns minimum number of connections in the connection pool",
	"Method": "int getConnectionMinPool(){\r\n    return _persistenceManagerFactory.getConnectionMinPool();\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecurityContextUtil.authenticate",
	"Comment": "authenticate the user with the specified subject andcredential class.",
	"Method": "void authenticate(Subject s,Class cls){\r\n    try {\r\n        final Subject fs = s;\r\n        final Class cl = cls;\r\n        AccessController.doPrivileged(new PrivilegedAction() {\r\n            public java.lang.Object run() {\r\n                LoginContextDriver.login(fs, cl);\r\n                return null;\r\n            }\r\n        });\r\n    } catch (Exception e) {\r\n        if (_logger.isLoggable(Level.SEVERE)) {\r\n            _logger.log(Level.SEVERE, \"iiop.login_exception\", e.toString());\r\n        }\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Login Exception\", e);\r\n        }\r\n        throw new SecurityMechanismException(\"Cannot login user:\" + e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecurityContextUtil.authenticate",
	"Comment": "authenticate the user with the specified subject andcredential class.",
	"Method": "void authenticate(Subject s,Class cls){\r\n    LoginContextDriver.login(fs, cl);\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.removeFromCaches",
	"Comment": "if a transaction is active, removes the given statemanger from allcaches, otherwise just from the version consistency cache.",
	"Method": "void removeFromCaches(StateManager sm){\r\n    if (sm != null) {\r\n        if (_activeTransaction) {\r\n            _txCache.remove(sm);\r\n            _flushedCache.remove(sm);\r\n        }\r\n        removeFromVersionConsistencyCache(sm);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.security.application.EJBSecurityManager.getCurrentSubject",
	"Comment": "this will return the subject associated with the current call. if therun as subject is in effect. it will return that subject. this is doneto support the jacc specification which says if the runas principal isin effect,that principal should be used for making a component call.",
	"Method": "Subject getCurrentSubject(){\r\n    return SecurityContext.getCurrent().getSubject();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.constraint.Constraint.mergeConstraint",
	"Comment": "merges the stack with the specified foreign constraint stack.",
	"Method": "boolean mergeConstraint(Constraint foreignConstraint,int joinOp){\r\n    stack.addAll(foreignConstraint.stack);\r\n    outerJoinStack.addAll(foreignConstraint.outerJoinStack);\r\n    return addAnd(foreignConstraint, joinOp);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsColumnAliasing",
	"Comment": "retrieves whether this database supports column aliasing.if so, the sql as clause can be used to provide names forcomputed columns or to provide alias names for columns asrequired.",
	"Method": "boolean supportsColumnAliasing(){\r\n    return databaseMetaData.supportsColumnAliasing();\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.Tag.getUsers",
	"Comment": "provides access to all the users that have created this tag.this \tmay be null.",
	"Method": "List<String> getUsers(){\r\n    return users;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.StatelessSessionContainer.createEJBLocalObjectImpl",
	"Comment": "called during client creation request through ejb localhome view.",
	"Method": "EJBLocalObjectImpl createEJBLocalObjectImpl(){\r\n    authorizeLocalMethod(EJBLocalHome_create);\r\n    ejbBeanCreatedEvent();\r\n    return theEJBLocalObjectImpl;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.EjbConversionHelper.setEnsureValidation",
	"Comment": "sets the flag whether the mapping conversion should validate all fieldsagainst schema columns.",
	"Method": "void setEnsureValidation(boolean isValidating){\r\n    ensureValidation = isValidating;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.getMaxPool",
	"Comment": "returns maximum number of persistencemanager instances in the pool",
	"Method": "int getMaxPool(){\r\n    return maxPool;\r\n}"
}, {
	"Path": "org.glassfish.resources.api.Resource.isEqualAttribute",
	"Comment": "compares the attribute with the specified namein this resource with the passed in resource and checksif they are equal",
	"Method": "boolean isEqualAttribute(Resource r,String name){\r\n    return (getAttribute(r, name).equals(getAttribute(this, name)));\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.ResourceHandle.isTransactional",
	"Comment": "does this resource need enlistment to transaction manager?",
	"Method": "boolean isTransactional(){\r\n    return alloc.isTransactional();\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.annotation.handlers.StatelessHandler.setEjbDescriptorInfo",
	"Comment": "set annotation information to descriptor.this method will also be invoked for an existing descriptor withannotation as user may not specific a complete xml.",
	"Method": "HandlerProcessingResult setEjbDescriptorInfo(EjbDescriptor ejbDesc,AnnotationInfo ainfo){\r\n    EjbSessionDescriptor ejbSessionDesc = (EjbSessionDescriptor) ejbDesc;\r\n    if (!ejbSessionDesc.isSessionTypeSet()) {\r\n        ejbSessionDesc.setSessionType(EjbSessionDescriptor.STATELESS);\r\n    }\r\n    Stateless sless = (Stateless) ainfo.getAnnotation();\r\n    doDescriptionProcessing(sless.description(), ejbDesc);\r\n    doMappedNameProcessing(sless.mappedName(), ejbDesc);\r\n    return setBusinessAndHomeInterfaces(ejbDesc, ainfo);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.MappingPolicy.getConstraintName",
	"Comment": "returns the name of a constraint corresponding to the namedrelationship.",
	"Method": "String getConstraintName(String relName,String uniqueId){\r\n    String rc = (String) namingPolicy.get(DEFAULT_CONSTRAINT_KEY);\r\n    if (rc.equals(CONSTRAINT_NAME_UPPERCASE)) {\r\n        rc = FK_PREFIX + relName.toUpperCase();\r\n    }\r\n    if (uniqueTableName) {\r\n        rc += uniqueId;\r\n    }\r\n    rc = getUniqueGlobalName(rc, constraintNameMaxLength);\r\n    if (logger.isLoggable(Logger.FINER)) {\r\n        // NOI8N\r\n        logger.finer(\"MappingPolicy.getConstraintName: \" + relName + \" -> \" + rc);\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MailConfiguration.getJndiName",
	"Comment": "get the mail jndi name for the mail session the server will provide.",
	"Method": "String getJndiName(){\r\n    return this.jndiName;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.DSManagedConnectionFactory.equals",
	"Comment": "check if this managedconnectionfactory is equal toanother managedconnectionfactory.",
	"Method": "boolean equals(Object other){\r\n    logFine(\"In equals\");\r\n    if (other instanceof com.sun.gjc.spi.DSManagedConnectionFactory) {\r\n        com.sun.gjc.spi.DSManagedConnectionFactory otherMCF = (com.sun.gjc.spi.DSManagedConnectionFactory) other;\r\n        return this.spec.equals(otherMCF.spec);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.StatementWrapper.getResultSetType",
	"Comment": "retrieves the result set type for resultset objectsgenerated by this statement object.",
	"Method": "int getResultSetType(){\r\n    return jdbcStatement.getResultSetType();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsANSI92FullSQL",
	"Comment": "retrieves whether this database supports the ansi92 full sql grammar supported.",
	"Method": "boolean supportsANSI92FullSQL(){\r\n    return databaseMetaData.supportsANSI92FullSQL();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.EjbConversionHelper.getMultiplicity",
	"Comment": "getmultiplicity of the other role on the relationshipplease note that multiplicity is jdo style",
	"Method": "String getMultiplicity(String ejbName,String fieldName){\r\n    RelationRoleDescriptor oppRole = getRelationRoleDescriptor(ejbName, fieldName, false);\r\n    return (oppRole.getIsMany()) ? MANY : ONE;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOCodeGenerator.validateEJB",
	"Comment": "validate the bean. for now, validate ejbql for all finders and selectors of this bean.",
	"Method": "Collection validateEJB(IASEjbCMPEntityDescriptor descr){\r\n    Collection c = null;\r\n    try {\r\n        JDOConcreteBeanGenerator cmpGenerator = getCMPGenerator(descr);\r\n        c = cmpGenerator.validate(new MethodHelper(descr), descr.getName());\r\n    } catch (GeneratorException e) {\r\n        c = new ArrayList();\r\n        c.add(e);\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.database.DBVendorTypeHelper.overrideWithSystemProperties",
	"Comment": "overrides nametovendortype with any system properties defined.",
	"Method": "void overrideWithSystemProperties(Properties nameToVendorType){\r\n    String vendorNameToType = null;\r\n    boolean debug = logger.isLoggable(Level.FINE);\r\n    int counter = 1;\r\n    do {\r\n        String vendorNameToTypeProperty = VENDOR_NAME_TO_TYPE_PROPERTY + counter++;\r\n        vendorNameToType = System.getProperty(vendorNameToTypeProperty);\r\n        if (vendorNameToType != null) {\r\n            String[] parsedProperty = vendorNameToType.split(\"=\", 2);\r\n            if (parsedProperty.length >= 2) {\r\n                String suggestedDbType = parsedProperty[0];\r\n                String regExp = parsedProperty[1];\r\n                if (debug) {\r\n                    logger.log(Level.FINE, // NOI18N\r\n                    I18NHelper.getMessage(messages, \"database.DBVendorTypeHelper.traceVendorNameToTypeProperty\", vendorNameToTypeProperty, regExp, suggestedDbType));\r\n                }\r\n                nameToVendorType.put(regExp, suggestedDbType);\r\n            } else {\r\n                if (debug)\r\n                    logger.log(Level.FINE, // NOI18N\r\n                    I18NHelper.getMessage(messages, \"database.DBVendorTypeHelper.errorParsingVendorNameToTypeProperty\", vendorNameToTypeProperty, vendorNameToType));\r\n            }\r\n        }\r\n    } while (vendorNameToType != null);\r\n}"
}, {
	"Path": "org.glassfish.enterprise.iiop.util.S1ASThreadPoolManager.getThreadPoolChooser",
	"Comment": "return an instance of threadpoolchooser based on the componentindex that waspassed as argument. this is added for improved performance so that the callerdoes not have to pay the cost of computing hashcode for the componentid",
	"Method": "ThreadPoolChooser getThreadPoolChooser(String componentId,ThreadPoolChooser getThreadPoolChooser,int componentIndex){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.FieldAction.nDims",
	"Comment": "for array fields, return the number of dimensions in the array typeelse 0.",
	"Method": "int nDims(){\r\n    return nFieldArrayDims;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.setUsesDefaultTransaction",
	"Comment": "have default method transaction if isboundschecking is on.",
	"Method": "void setUsesDefaultTransaction(){\r\n    usesDefaultTransaction = true;\r\n}"
}, {
	"Path": "org.glassfish.resources.admin.cli.ResourcesXMLParser.initProperties",
	"Comment": "parse the xml properties file and populate it into document object",
	"Method": "void initProperties(){\r\n    DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();\r\n    BufferedInputStream bis = null;\r\n    FileInputStream fis = null;\r\n    try {\r\n        AddResourcesErrorHandler errorHandler = new AddResourcesErrorHandler();\r\n        factory.setValidating(true);\r\n        DocumentBuilder builder = factory.newDocumentBuilder();\r\n        builder.setEntityResolver(this);\r\n        builder.setErrorHandler(errorHandler);\r\n        Object[] args = new Object[] { resourceFile };\r\n        if (resourceFile == null) {\r\n            String msg = localStrings.getStringWithDefault(\"resources.parser.no_resource_file\", \"Resource file ({0} does not exist\", args);\r\n            throw new Exception(msg);\r\n        }\r\n        fis = new FileInputStream(resourceFile);\r\n        InputSource is = new InputSource(fis);\r\n        document = builder.parse(is);\r\n        detectDeprecatedDescriptor();\r\n    } catch (SAXException sxe) {\r\n        try {\r\n            SAXParserFactory spf = SAXParserFactory.newInstance();\r\n            SAXParser sp = spf.newSAXParser();\r\n            sp.setProperty(\"http://xml.org/sax/properties/lexical-handler\", new MyLexicalHandler());\r\n            if (fis != null) {\r\n                try {\r\n                    fis.close();\r\n                    fis = null;\r\n                } catch (Exception e) {\r\n                }\r\n            }\r\n            fis = new FileInputStream(resourceFile);\r\n            sp.getXMLReader().parse(new InputSource(fis));\r\n        } catch (ParserConfigurationException ex) {\r\n        } catch (SAXException ex) {\r\n        } catch (IOException ex) {\r\n        }\r\n        if (!isDoctypePresent) {\r\n            Object[] args = new Object[] { resourceFile.toString() };\r\n            throw new Exception(localStrings.getStringWithDefault(\"resources.parser.doctype_not_present_in_xml\", \"Error Parsing the xml ({0}), doctype is not present\", args));\r\n        }\r\n        Exception x = sxe;\r\n        if (sxe.getException() != null)\r\n            x = sxe.getException();\r\n        throw new Exception(x.getLocalizedMessage());\r\n    } catch (ParserConfigurationException pce) {\r\n        throw new Exception(pce.getLocalizedMessage());\r\n    } catch (IOException ioe) {\r\n        throw new Exception(ioe.getLocalizedMessage());\r\n    } finally {\r\n        if (fis != null) {\r\n            try {\r\n                fis.close();\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ForeignFieldDesc.initializeIsMappedToPk",
	"Comment": "checks, if the relationship is mapped to primary key fieldson the other relationship side and sets the propertyismappedtopk.",
	"Method": "void initializeIsMappedToPk(){\r\n    int count = foreignFields.size();\r\n    isMappedToPk = !useJoinTable() && foreignConfig.getKeyFields().length == count;\r\n    for (int i = 0; i < count && isMappedToPk; i++) {\r\n        isMappedToPk = ((LocalFieldDesc) foreignFields.get(i)).isKeyField();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.getFullValidationList",
	"Comment": "computes and returns a collection of validationcomponents \trepresenting the tests to be performed during validation.these \tinclude all those in the basic list plus those which check \tcardinality and the related classes in more detail.",
	"Method": "Collection getFullValidationList(){\r\n    ArrayList list = new ArrayList(getBasicValidationList());\r\n    String className = getClassName();\r\n    PersistenceClassElement persistenceClass = getPersistenceClass(className);\r\n    if (persistenceClass != null) {\r\n        PersistenceFieldElement[] fields = persistenceClass.getFields();\r\n        int i, count = ((fields != null) ? fields.length : 0);\r\n        list.add(createSerializableClassComponent(className));\r\n        list.add(createKeyClassComponent(persistenceClass.getKeyClass()));\r\n        list.add(createClassMappingComponent(persistenceClass));\r\n        list.add(createKeyColumnMappingComponent(persistenceClass));\r\n        for (i = 0; i < count; i++) {\r\n            PersistenceFieldElement field = fields[i];\r\n            list.add(createFieldCardinalityComponent(field));\r\n            list.add(createFieldMappingComponent(field));\r\n            list.add(createFieldBlobMappingComponent(field));\r\n            list.addAll(getRelatedClassValidationList(field));\r\n        }\r\n    }\r\n    return Collections.unmodifiableCollection(list);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.deletesAreDetected",
	"Comment": "retrieves whether or not a visible row delete can be detected bycalling the method resultset.rowdeleted.if the methoddeletesaredetected returns false, it means thatdeleted rows are removed from the result set.",
	"Method": "boolean deletesAreDetected(int type){\r\n    return databaseMetaData.deletesAreDetected(type);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.switchOnMatchingInJndi",
	"Comment": "causes matching to be switched on the connectorconnectionpoolbound in jndi",
	"Method": "void switchOnMatchingInJndi(PoolInfo poolInfo){\r\n    ccPoolAdmService.switchOnMatching(poolInfo);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.containsConcurrencyGroup",
	"Comment": "tests whether the supplied group is in the collection of groups \tmaintained by this class.",
	"Method": "boolean containsConcurrencyGroup(ConcurrencyGroupElement group){\r\n    return (getClassImpl().getConcurrencyGroup(group.getName()) != null);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.CodeAttribute.read",
	"Comment": "this version reads the attribute into a byte array for laterconsumption",
	"Method": "CodeAttribute read(ConstUtf8 attrName,DataInputStream data,ConstantPool pool,CodeAttribute read,ConstUtf8 attrName,int attrLength,DataInputStream data,ConstantPool pool){\r\n    byte[] dataBytes = new byte[attrLength];\r\n    data.readFully(dataBytes);\r\n    return new CodeAttribute(attrName, dataBytes, new CodeEnv(pool));\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.jws.AppClientHTTPAdapter.service",
	"Comment": "responds to all requests routed to the context root with which thisadapter was registered to the requestdispatcher.",
	"Method": "void service(Request gReq,Response gResp){\r\n    if (logger.isLoggable(Level.FINER)) {\r\n        dumpHeaders(gReq);\r\n    }\r\n    final String savedRequestURI = gReq.getRequestURI();\r\n    Session s = gReq.getSession(false);\r\n    logger.log(Level.FINE, \"Req \" + savedRequestURI + \", session was \" + (s == null ? \"NONE\" : s.getIdInternal() + \":\" + s.getSessionTimeout()));\r\n    final String relativeURIString = relativizeURIString(contextRoot(), savedRequestURI);\r\n    if (relativeURIString == null) {\r\n        respondNotFound(gResp);\r\n    } else if (dynamicContent.containsKey(relativeURIString)) {\r\n        try {\r\n            processDynamicContent(tokens, relativeURIString, gReq, gResp);\r\n        } catch (IOException ex) {\r\n            throw new RuntimeException(ex);\r\n        } catch (URISyntaxException ex) {\r\n            throw new RuntimeException(ex);\r\n        } finally {\r\n            if (logger.isLoggable(Level.FINER)) {\r\n                dumpHeaders(gResp, savedRequestURI);\r\n            }\r\n        }\r\n    } else\r\n        try {\r\n            if (!serviceContent(gReq, gResp)) {\r\n                respondNotFound(gResp);\r\n            }\r\n        } catch (IOException ex) {\r\n            throw new RuntimeException(ex);\r\n        } finally {\r\n            if (logger.isLoggable(Level.FINER)) {\r\n                dumpHeaders(gResp, savedRequestURI);\r\n            }\r\n        }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.DeploymentDescriptorNode.writeSubDescriptors",
	"Comment": "write out descriptor in a generic way to an jaxp dom node and return itthis api will generally be invoked when the parent node needs towrite out a mix of statically and dynamically registered sub nodes.",
	"Method": "Node writeSubDescriptors(Node node,String nodeName,Descriptor descriptor){\r\n    XMLNode rootNode = getRootNode();\r\n    if (rootNode instanceof RuntimeBundleNode) {\r\n        LinkedHashMap<String, Class> elementToNodeMappings = ((RuntimeBundleNode) rootNode).getNodeMappings(nodeName);\r\n        if (elementToNodeMappings != null) {\r\n            Set<Map.Entry<String, Class>> entrySet = elementToNodeMappings.entrySet();\r\n            Iterator<Map.Entry<String, Class>> entryIt = entrySet.iterator();\r\n            while (entryIt.hasNext()) {\r\n                Map.Entry<String, Class> entry = entryIt.next();\r\n                String subElementName = entry.getKey();\r\n                if (subElementName.equals(nodeName)) {\r\n                    continue;\r\n                }\r\n                Class handlerClass = entry.getValue();\r\n                if (handlerClass.getName().equals(this.getClass().getName())) {\r\n                    writeSimpleTextDescriptor(node, subElementName, descriptor);\r\n                } else {\r\n                    try {\r\n                        DeploymentDescriptorNode subNode = (DeploymentDescriptorNode) handlerClass.newInstance();\r\n                        subNode.setParentNode(this);\r\n                        subNode.writeDescriptors(node, subElementName, descriptor);\r\n                    } catch (Exception e) {\r\n                        DOLUtils.getDefaultLogger().log(Level.WARNING, e.getMessage(), e);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return node;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.getConnectionMinPool",
	"Comment": "returns minimum number of connections in the connection pool",
	"Method": "int getConnectionMinPool(){\r\n    if (connectionFactory != null)\r\n        return connectionFactory.getMinPool();\r\n    return connectionMinPool;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ExtentCollection.equals",
	"Comment": "two extent collections are equal, iff the names of their persistence capable class are equal",
	"Method": "boolean equals(Object o){\r\n    if (o == this)\r\n        return true;\r\n    if (o instanceof ExtentCollection) {\r\n        String otherClassName = ((ExtentCollection) o).persistenceCapableClass.getName();\r\n        return persistenceCapableClass.getName().equals(otherClassName);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.QueryImpl.declareParameters",
	"Comment": "bind the parameter statements to the query instance.this method defines the parameter types and nameswhich will be used by a subsequent execute method.the parameter declaration is a string containing one ormore query parameter declarations separated with commas.it follows the syntax for formal parameters in the java language.each parameter named in the parameter declaration must be boundto a value when the query is executed.",
	"Method": "void declareParameters(String parameters){\r\n    synchronized (this.paramtab) {\r\n        this.parameterDeclarations = parameters;\r\n        this.compiled = false;\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getClob",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object as a clob objectin the java programming language.",
	"Method": "Clob getClob(int i,Clob getClob,String colName){\r\n    return resultSet.getClob(colName);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.support.JDOHelper.getObjectClassLoader",
	"Comment": "returns the class loader for the class of the object.if object is an instance of the java.util.collection oran array it is recursively checked for the class loaderof its elements.",
	"Method": "ClassLoader getObjectClassLoader(Object obj){\r\n    Class clazz = obj.getClass();\r\n    if (obj instanceof Collection) {\r\n        return getCollectionClassLoader((Collection) obj);\r\n    } else if (clazz.isArray()) {\r\n        return getArrayClassLoader((Object[]) obj);\r\n    } else {\r\n        return clazz.getClassLoader();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.UpdateStatement.getDBStatement",
	"Comment": "returns the cached db statement for the specified connection.if there is not any statement for this connection in the cache,then a new statement is created.",
	"Method": "DBStatement getDBStatement(Transaction tran,Connection conn){\r\n    DBStatement dbStatement = null;\r\n    synchronized (dbStatementCache) {\r\n        dbStatement = (DBStatement) dbStatementCache.get(tran);\r\n        if (dbStatement == null) {\r\n            dbStatement = new DBStatement(conn, getText(), tran.getUpdateTimeout());\r\n            dbStatementCache.put(tran, dbStatement);\r\n        }\r\n    }\r\n    return dbStatement;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.Insn.create",
	"Comment": "create an instruction which requires a single branch offsetas an immediate operand.",
	"Method": "Insn create(int theOpCode,Insn create,int theOpCode,ConstBasic constValue,Insn create,int theOpCode,int intValue,Insn create,int theOpCode,InsnTarget target){\r\n    return new InsnTargetOp(theOpCode, target);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ConnectionWrapper40.prepareCall",
	"Comment": "creates acallablestatementobject for calling databasestored procedures.",
	"Method": "CallableStatement prepareCall(String sql,CallableStatement prepareCall,String sql,int resultSetType,int resultSetConcurrency,CallableStatement prepareCall,String sql,int resultSetType,int resultSetConcurrency,int resultSetHoldability){\r\n    return mc.prepareCachedCallableStatement(this, sql, resultSetType, resultSetConcurrency, resultSetHoldability);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.FieldInfo.isStatic",
	"Comment": "checks whether this field is defined with the static modifier.",
	"Method": "boolean isStatic(){\r\n    return (field != null) && Modifier.isStatic(field.getModifiers());\r\n}"
}, {
	"Path": "org.glassfish.resources.javamail.admin.cli.ListJavaMailResources.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        List<String> list = new ArrayList<String>();\r\n        Collection<MailResource> mailResources = domain.getResources().getResources(MailResource.class);\r\n        for (MailResource mailResource : mailResources) {\r\n            if (bindableResourcesHelper.resourceExists(mailResource.getJndiName(), targetOperand)) {\r\n                list.add(mailResource.getJndiName());\r\n            }\r\n        }\r\n        for (String jndiName : list) {\r\n            final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n            part.setMessage(jndiName);\r\n        }\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.javamail.resources.failed\", \"Unable to list mail resources\") + \" \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.JDOEJB11HelperImpl.readSerializableObjectFromByteArray",
	"Comment": "constructs a serializable object from bytearray. it is expected thatbytearray was constructed using a previous call to writeserializableobjecttobytearray",
	"Method": "Serializable readSerializableObjectFromByteArray(byte[] byteArray){\r\n    Serializable serializableObject = null;\r\n    if (byteArray != null) {\r\n        ByteArrayInputStream bis = new ByteArrayInputStream(byteArray);\r\n        HelperObjectInputStream ois = null;\r\n        ClassLoader cl = this.getClass().getClassLoader();\r\n        try {\r\n            ois = new HelperObjectInputStream(bis, cl);\r\n            serializableObject = (Serializable) ois.readObject();\r\n        } catch (ClassNotFoundException e) {\r\n            throw new JDOFatalDataStoreException(I18NHelper.getMessage(messages, \"EXC_CNFReadSerializableObject\"), e);\r\n        } catch (java.io.IOException e) {\r\n            throw new JDOFatalDataStoreException(I18NHelper.getMessage(messages, \"EXC_IOReadSerializableObject\"), e);\r\n        }\r\n    }\r\n    return serializableObject;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.HashSet.addAll",
	"Comment": "adds all of the elements in the specified collection to this collection",
	"Method": "boolean addAll(Collection c){\r\n    if (allowNulls == false && c.contains(null)) {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"sco.nulls_not_allowed\"));\r\n    }\r\n    ArrayList errc = new ArrayList();\r\n    if (elementType != null) {\r\n        Iterator i = c.iterator();\r\n        while (i.hasNext()) {\r\n            Object o = i.next();\r\n            if (!elementType.isAssignableFrom(o.getClass()))\r\n                errc.add(o);\r\n        }\r\n    }\r\n    if (errc != null && errc.size() > 0) {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        messages, \"sco.classcastexception\", elementType.getName()), new ClassCastException(), errc.toArray());\r\n    }\r\n    boolean modified = false;\r\n    if (owner != null) {\r\n        StateManager stateManager = owner.jdoGetStateManager();\r\n        if (stateManager != null) {\r\n            PersistenceManager pm = (PersistenceManager) stateManager.getPersistenceManagerInternal();\r\n            pm.acquireShareLock();\r\n            try {\r\n                pm.acquireFieldUpdateLock();\r\n                try {\r\n                    stateManager.makeDirty(fieldName);\r\n                    for (Iterator iter = c.iterator(); iter.hasNext(); ) {\r\n                        Object o = iter.next();\r\n                        if (!super.contains(o)) {\r\n                            if (removed.remove(o) == false) {\r\n                                added.add(o);\r\n                            }\r\n                            super.add(o);\r\n                            modified = true;\r\n                        }\r\n                    }\r\n                    if (modified) {\r\n                        stateManager.applyUpdates(fieldName, this);\r\n                    }\r\n                    return modified;\r\n                } finally {\r\n                    pm.releaseFieldUpdateLock();\r\n                }\r\n            } catch (JDOUserException e) {\r\n                Object[] failedObjects = e.getFailedObjectArray();\r\n                if (modified && (failedObjects != null)) {\r\n                    for (int i = 0; i < failedObjects.length; i++) {\r\n                        super.remove(failedObjects[i]);\r\n                    }\r\n                }\r\n                throw e;\r\n            } finally {\r\n                pm.releaseShareLock();\r\n            }\r\n        }\r\n    }\r\n    return super.addAll(c);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.TypeTable.isIntegralType",
	"Comment": "returns true if type is an integral type or a java wrapper classtype wrapping an integral type.",
	"Method": "boolean isIntegralType(Type type){\r\n    if (type instanceof IntegralType)\r\n        return true;\r\n    else if (type instanceof NumericWrapperClassType)\r\n        return ((NumericWrapperClassType) type).getPrimitiveType() instanceof IntegralType;\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxStatements",
	"Comment": "retrieves the maximum number of active statements to this databasethat can be open at the same time.",
	"Method": "int getMaxStatements(){\r\n    return databaseMetaData.getMaxStatements();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.EJBBundleInfoHelper.getClassLoader",
	"Comment": "gets the class loader which corresponds to this ejb bundle.",
	"Method": "ClassLoader getClassLoader(){\r\n    return bundleDescriptor.getClassLoader();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.ConnectorClassLoader.loadClass",
	"Comment": "loads the class with the specified name and resolves it if specified.",
	"Method": "Class loadClass(String name,boolean resolve){\r\n    Class clz = null;\r\n    if (parent != null) {\r\n        try {\r\n            clz = parent.loadClass(name);\r\n            if (clz != null) {\r\n                if (resolve) {\r\n                    resolveClass(clz);\r\n                }\r\n                return clz;\r\n            }\r\n        } catch (ClassNotFoundException e) {\r\n        }\r\n    } else {\r\n        return super.loadClass(name, resolve);\r\n    }\r\n    for (Iterator iter = classLoaderChain.iterator(); iter.hasNext(); ) {\r\n        ASURLClassLoader ccl = (ASURLClassLoader) iter.next();\r\n        try {\r\n            clz = ccl.loadClass(name);\r\n            if (clz != null) {\r\n                if (resolve) {\r\n                    resolveClass(clz);\r\n                }\r\n                return clz;\r\n            }\r\n        } catch (ClassNotFoundException cnfe) {\r\n            continue;\r\n        }\r\n    }\r\n    throw new ClassNotFoundException(name);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ServiceReferenceDescriptor.addCallProperty",
	"Comment": "add call property, using property name as a key. this willreplace the property value of any existing stub property withthe same name.",
	"Method": "void addCallProperty(NameValuePairDescriptor property){\r\n    NameValuePairDescriptor prop = getCallPropertyByName(property.getName());\r\n    if (prop != null) {\r\n        prop.setValue(property.getValue());\r\n    } else {\r\n        callProperties.add(property);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.resources.api.Resource.getAttribute",
	"Comment": "utility method to get an attribute of the given namein the specified resource",
	"Method": "String getAttribute(Resource r,String name){\r\n    return (String) r.getAttributes().get(name);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.FieldGroupElement.setFields",
	"Comment": "sets the collection of fields maintained by this holder to the contents\tof the supplied array.",
	"Method": "void setFields(PersistenceFieldElement[] fields){\r\n    getFieldGroupImpl().changeFields(fields, Impl.SET);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerWrapper.getRequireTrackedSCO",
	"Comment": "returns the boolean value of the requiretrackedsco flagfor this persistencemanager. if set to false, the persistencemanagerwill not create tracked sco instances for new persistent instances at commit with retainvalues set to trueand while retrieving data from a datastore.",
	"Method": "boolean getRequireTrackedSCO(){\r\n    if (isValid) {\r\n        return pm.getRequireTrackedSCO();\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerwrapper.invalidpm\"));\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployapi.TargetModuleIDImpl.getModuleID",
	"Comment": "returns the name of the module that is deployed to a given target.",
	"Method": "String getModuleID(){\r\n    return moduleID;\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.UpdateConnectorSecurityMap.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (securityMapName == null) {\r\n        report.setMessage(localStrings.getLocalString(\"create.connector.security.map.noSecurityMapName\", \"No security map name specified\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    Collection<ConnectorConnectionPool> ccPools = domain.getResources().getResources(ConnectorConnectionPool.class);\r\n    if (!doesPoolNameExist(poolName, ccPools)) {\r\n        report.setMessage(localStrings.getLocalString(\"create.connector.security.map.noSuchPoolFound\", \"Connector connection pool {0} does not exist. Please specify a valid pool name.\", poolName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (!doesMapNameExist(poolName, securityMapName, ccPools)) {\r\n        report.setMessage(localStrings.getLocalString(\"update.connector.security.map.map_does_not_exist\", \"Security map {0} does not exist for connector connection pool {1}. Please give a valid map name.\", securityMapName, poolName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    List<SecurityMap> maps = getAllSecurityMapsForPool(poolName, ccPools);\r\n    if (addPrincipals != null && removePrincipals != null) {\r\n        for (String ap : addPrincipals) {\r\n            for (String rp : removePrincipals) {\r\n                if (rp.equals(ap)) {\r\n                    report.setMessage(localStrings.getLocalString(\"update.connector.security.map.same_principal_values\", \"This value {0} is given in both --addprincipals and --removeprincipals. The same value cannot given for these options.\", ap));\r\n                    report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (addUserGroups != null && removeUserGroups != null) {\r\n        for (String aug : addUserGroups) {\r\n            for (String rug : removeUserGroups) {\r\n                if (rug.equals(aug)) {\r\n                    report.setMessage(localStrings.getLocalString(\"update.connector.security.map.same_usergroup_values\", \"This value {0} is given in both --addusergroups and --removeusergroups. The same value cannot given for these options.\", aug));\r\n                    report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (addPrincipals != null) {\r\n        for (String principal : addPrincipals) {\r\n            if (isPrincipalExisting(principal, maps)) {\r\n                report.setMessage(localStrings.getLocalString(\"create.connector.security.map.principal_exists\", \"The principal {0} already exists in connector connection pool {1}. Please give a different principal name.\", principal, poolName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (addUserGroups != null) {\r\n        for (String userGroup : addUserGroups) {\r\n            if (isUserGroupExisting(userGroup, maps)) {\r\n                report.setMessage(localStrings.getLocalString(\"create.connector.security.map.usergroup_exists\", \"The user-group {0} already exists in connector connection pool {1}. Please give a different user-group name.\", userGroup, poolName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    SecurityMap map = getSecurityMap(securityMapName, poolName, ccPools);\r\n    final List<String> existingPrincipals = new ArrayList(map.getPrincipal());\r\n    final List<String> existingUserGroups = new ArrayList(map.getUserGroup());\r\n    if (removePrincipals != null) {\r\n        boolean principalExists = true;\r\n        String principal = null;\r\n        for (String p : removePrincipals) {\r\n            if (!existingPrincipals.contains(p)) {\r\n                principalExists = false;\r\n                principal = p;\r\n                break;\r\n            }\r\n        }\r\n        if (!principalExists) {\r\n            report.setMessage(localStrings.getLocalString(\"update.connector.security.map.principal_does_not_exists\", \"The principal {0} that you want to delete does not exist in connector connection pool {1}. Please give a valid principal name.\", principal, poolName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    if (removeUserGroups != null) {\r\n        boolean userGroupExists = true;\r\n        String userGroup = null;\r\n        for (String ug : removeUserGroups) {\r\n            if (!existingUserGroups.contains(ug)) {\r\n                userGroupExists = false;\r\n                userGroup = ug;\r\n                break;\r\n            }\r\n        }\r\n        if (!userGroupExists) {\r\n            report.setMessage(localStrings.getLocalString(\"update.connector.security.map.usergroup_does_not_exists\", \"The usergroup {0} that you want to delete does not exist in connector connection pool {1}. Please give a valid user-group name.\", userGroup, poolName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    if (addPrincipals == null && addUserGroups == null) {\r\n        boolean principalsEmpty = false;\r\n        boolean userGroupsEmpty = false;\r\n        if (removePrincipals == null && existingPrincipals.isEmpty()) {\r\n            principalsEmpty = true;\r\n        }\r\n        if (removeUserGroups == null && existingUserGroups.isEmpty()) {\r\n            userGroupsEmpty = true;\r\n        }\r\n        if ((removePrincipals != null) && (removePrincipals.size() == existingPrincipals.size())) {\r\n            principalsEmpty = true;\r\n        }\r\n        if ((removeUserGroups != null) && (removeUserGroups.size() == existingUserGroups.size())) {\r\n            userGroupsEmpty = true;\r\n        }\r\n        if (userGroupsEmpty && principalsEmpty) {\r\n            report.setMessage(localStrings.getLocalString(\"update.connector.security.map.principals_usergroups_will_be_null\", \"The values in your command will delete all principals and usergroups. You cannot delete all principals and usergroups. Atleast one of them must exist.\"));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    if (addPrincipals != null) {\r\n        for (String principal : addPrincipals) {\r\n            if (!existingPrincipals.contains(principal)) {\r\n                existingPrincipals.add(principal);\r\n            } else {\r\n                report.setMessage(localStrings.getLocalString(\"create.connector.security.map.principal_exists\", \"The principal {0} already exists in connector connection pool {1}. Please give a different principal name.\", principal, poolName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (removePrincipals != null) {\r\n        for (String principal : removePrincipals) {\r\n            existingPrincipals.remove(principal);\r\n        }\r\n    }\r\n    if (addUserGroups != null) {\r\n        for (String userGroup : addUserGroups) {\r\n            if (!existingUserGroups.contains(userGroup)) {\r\n                existingUserGroups.add(userGroup);\r\n            } else {\r\n                report.setMessage(localStrings.getLocalString(\"create.connector.security.map.usergroup_exists\", \"The user-group {0} already exists in connector connection pool {1}. Please give a different user-group name.\", userGroup, poolName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (removeUserGroups != null) {\r\n        for (String userGroup : removeUserGroups) {\r\n            existingUserGroups.remove(userGroup);\r\n        }\r\n    }\r\n    if (!hasOnlyPrincipalsOrOnlyUserGroups(report, existingPrincipals, existingUserGroups))\r\n        return;\r\n    BackendPrincipal backendPrincipal = map.getBackendPrincipal();\r\n    try {\r\n        ConfigSupport.apply(new ConfigCode() {\r\n            public Object run(ConfigBeanProxy... params) throws PropertyVetoException, TransactionFailure {\r\n                SecurityMap sm = (SecurityMap) params[0];\r\n                BackendPrincipal bp = (BackendPrincipal) params[1];\r\n                if (existingPrincipals != null) {\r\n                    sm.getPrincipal().clear();\r\n                    for (String principal : existingPrincipals) {\r\n                        sm.getPrincipal().add(principal);\r\n                    }\r\n                }\r\n                if (existingUserGroups != null) {\r\n                    sm.getUserGroup().clear();\r\n                    for (String userGroup : existingUserGroups) {\r\n                        sm.getUserGroup().add(userGroup);\r\n                    }\r\n                }\r\n                if (mappedusername != null && !mappedusername.isEmpty()) {\r\n                    bp.setUserName(mappedusername);\r\n                }\r\n                if (mappedpassword != null) {\r\n                    if (mappedpassword.isEmpty()) {\r\n                        bp.setPassword(null);\r\n                    } else {\r\n                        bp.setPassword(mappedpassword);\r\n                    }\r\n                }\r\n                return sm;\r\n            }\r\n        }, map, backendPrincipal);\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (TransactionFailure tfe) {\r\n        Object[] params = { securityMapName, poolName };\r\n        report.setMessage(localStrings.getLocalString(\"update.connector.security.map.fail\", \"Unable to update security map {0} for connector connection pool {1}.\", params) + \" \" + tfe.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.UpdateConnectorSecurityMap.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    SecurityMap sm = (SecurityMap) params[0];\r\n    BackendPrincipal bp = (BackendPrincipal) params[1];\r\n    if (existingPrincipals != null) {\r\n        sm.getPrincipal().clear();\r\n        for (String principal : existingPrincipals) {\r\n            sm.getPrincipal().add(principal);\r\n        }\r\n    }\r\n    if (existingUserGroups != null) {\r\n        sm.getUserGroup().clear();\r\n        for (String userGroup : existingUserGroups) {\r\n            sm.getUserGroup().add(userGroup);\r\n        }\r\n    }\r\n    if (mappedusername != null && !mappedusername.isEmpty()) {\r\n        bp.setUserName(mappedusername);\r\n    }\r\n    if (mappedpassword != null) {\r\n        if (mappedpassword.isEmpty()) {\r\n            bp.setPassword(null);\r\n        } else {\r\n            bp.setPassword(mappedpassword);\r\n        }\r\n    }\r\n    return sm;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.DeploymentDescriptorNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object descriptor){\r\n    if (getParentNode() == null) {\r\n        DOLUtils.getDefaultLogger().log(Level.SEVERE, \"enterprise.deployment.backend.addDescriptorFailure\", new Object[] { descriptor, toString() });\r\n        throw new RuntimeException(\"Cannot add \" + descriptor + \" to \" + toString());\r\n    } else {\r\n        getParentNode().addDescriptor(descriptor);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.inbound.ConnectorMessageBeanClient.isDeliveryTransacted",
	"Comment": "checks whether the message delivery is transacted for the method.",
	"Method": "boolean isDeliveryTransacted(Method method){\r\n    return messageBeanPM_.isDeliveryTransacted(method);\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.database.PropertyHelper.load",
	"Comment": "loads properties list from the specified resourceinto specified properties object.",
	"Method": "void load(Properties properties,String resourceName,boolean loadFromFile,ClassLoader classLoader){\r\n    InputStream bin = null;\r\n    InputStream in = null;\r\n    boolean debug = logger.isLoggable(Level.FINE);\r\n    if (debug) {\r\n        Object[] items = new Object[] { resourceName, Boolean.valueOf(loadFromFile) };\r\n        logger.log(Level.FINE, // NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        messages, \"database.PropertyHelper.load\", items));\r\n    }\r\n    in = loadFromFile ? openFileInputStream(resourceName) : openResourceInputStream(resourceName, classLoader);\r\n    if (in == null) {\r\n        throw new IOException(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        messages, \"database.PropertyHelper.failedToLoadResource\", resourceName));\r\n    }\r\n    bin = new BufferedInputStream(in);\r\n    try {\r\n        properties.load(bin);\r\n    } finally {\r\n        try {\r\n            bin.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.CallableStatementWrapper40.getCharacterStream",
	"Comment": "retrieves the value of the designated parameter as ajava.io.reader object in the java programming language.",
	"Method": "Reader getCharacterStream(int parameterIndex,Reader getCharacterStream,String parameterName){\r\n    return callableStatement.getCharacterStream(parameterName);\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.CSIV2TaggedComponentInfo.getSecurityMechanisms",
	"Comment": "get the compound security mechanism list from the given ior.",
	"Method": "CompoundSecMech[] getSecurityMechanisms(IOR ior){\r\n    IIOPProfile prof = ior.getProfile();\r\n    IIOPProfileTemplate ptemp = (IIOPProfileTemplate) prof.getTaggedProfileTemplate();\r\n    Iterator<TaggedComponent> itr = ptemp.iteratorById(TAG_CSI_SEC_MECH_LIST.value);\r\n    if (!itr.hasNext()) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            String msg = \"IIOP:TAG_CSI_SEC_MECH_LIST tagged component not found\";\r\n            _logger.log(Level.FINE, msg);\r\n        }\r\n        return null;\r\n    }\r\n    TaggedComponent tcomp = itr.next();\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"Component:\" + tcomp);\r\n    }\r\n    if (itr.hasNext()) {\r\n        String msg = \"More than one TAG_CSI_SEC_MECH_LIST tagged \" + \"component found \";\r\n        _logger.log(Level.SEVERE, \"iiop.many_tagged_component\");\r\n        throw new RuntimeException(msg);\r\n    }\r\n    org.omg.IOP.TaggedComponent comp = tcomp.getIOPComponent(orb);\r\n    byte[] b = comp.component_data;\r\n    CDRInputObject in = (CDRInputObject) new EncapsInputStream(orb, b, b.length);\r\n    in.consumeEndian();\r\n    CompoundSecMechList l = CompoundSecMechListHelper.read(in);\r\n    CompoundSecMech[] list = l.mechanism_list;\r\n    return list;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.TransactionHelperImpl.unwrapStatement",
	"Comment": "this method unwraps given statement and return the statement fromjdbc driver if possible.",
	"Method": "java.sql.Statement unwrapStatement(java.sql.Statement stmt){\r\n    return stmt;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.UpdateObjectDescImpl.recordUpdatedJoinTableRelationship",
	"Comment": "schedules a jointable entry for relationship fieldfielddesc.the scheduled jointable entry isuniquely identified by the relationship field and the twoassociated state managers.the action parameterspecifies, if the jointable entry should be created or removed.",
	"Method": "void recordUpdatedJoinTableRelationship(ForeignFieldDesc fieldDesc,SQLStateManager parentSM,SQLStateManager foreignSM,int action){\r\n    if (updatedJoinTableRelationships == null) {\r\n        updatedJoinTableRelationships = new HashMap();\r\n    }\r\n    HashMap updateJoinTableDescs = null;\r\n    if ((updateJoinTableDescs = (HashMap) updatedJoinTableRelationships.get(fieldDesc)) == null) {\r\n        updateJoinTableDescs = new HashMap();\r\n        updatedJoinTableRelationships.put(fieldDesc, updateJoinTableDescs);\r\n    }\r\n    UpdateJoinTableDesc desc = null;\r\n    if ((desc = (UpdateJoinTableDesc) updateJoinTableDescs.get(foreignSM)) == null) {\r\n        desc = new UpdateJoinTableDesc(parentSM, foreignSM, action);\r\n        updateJoinTableDescs.put(foreignSM, desc);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.getEjbBySEIName",
	"Comment": "returns all ejb descriptors that has a given class name asthe web service endpoint interface.it returns an empty array if no ejb is found.",
	"Method": "EjbDescriptor[] getEjbBySEIName(String className){\r\n    ArrayList<EjbDescriptor> ejbList = new ArrayList<EjbDescriptor>();\r\n    for (Object ejb : getEjbs()) {\r\n        if (ejb instanceof EjbDescriptor) {\r\n            EjbDescriptor ejbDesc = (EjbDescriptor) ejb;\r\n            if (className.equals(ejbDesc.getWebServiceEndpointInterfaceName())) {\r\n                ejbList.add(ejbDesc);\r\n            }\r\n        }\r\n    }\r\n    return ejbList.toArray(new EjbDescriptor[ejbList.size()]);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.getInt",
	"Comment": "retrieves the value of a jdbc integer parameter as an intin the java programming language.",
	"Method": "int getInt(int parameterIndex,int getInt,String parameterName){\r\n    return callableStatement.getInt(parameterName);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.isInlineNumeric",
	"Comment": "returns true if numeric parameters are inlined for this database",
	"Method": "boolean isInlineNumeric(){\r\n    String s = (String) dbMap.get(INLINE_NUMERIC);\r\n    Boolean b = Boolean.valueOf(s);\r\n    if (logger.isLoggable()) {\r\n        logger.fine(\"sqlstore.database.dbvendor.isInlineNumeric\", b);\r\n    }\r\n    return b.booleanValue();\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.jws.boot.LaunchSecurityHelper.loadResource",
	"Comment": "retrieves a resource as a string.this method does not save the template in a cache.use the instance methodgettemplate for that purpose.",
	"Method": "String loadResource(Class contextClass,String resourcePath){\r\n    String result = null;\r\n    InputStream is = null;\r\n    BufferedReader reader = null;\r\n    try {\r\n        is = contextClass.getResourceAsStream(resourcePath);\r\n        if (is == null) {\r\n            throw new IOException(\"Could not locate the requested resource relative to class \" + contextClass.getName());\r\n        }\r\n        StringBuilder sb = new StringBuilder();\r\n        reader = new BufferedReader(new InputStreamReader(is));\r\n        int charsRead;\r\n        char[] buffer = new char[BUFFER_SIZE];\r\n        while ((charsRead = reader.read(buffer)) != -1) {\r\n            sb.append(buffer, 0, charsRead);\r\n        }\r\n        result = sb.toString();\r\n        return result;\r\n    } catch (IOException ioe) {\r\n        throw new IOException(\"Error loading resource \" + resourcePath, ioe);\r\n    } finally {\r\n        if (reader != null) {\r\n            reader.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.connection.ConnectionImpl.release",
	"Comment": "called by connectionmanager to close old connection when a new free connectionbecomes available",
	"Method": "void release(){\r\n    try {\r\n        this.connection.close();\r\n    } catch (SQLException se) {\r\n    }\r\n    logger.finest(\"sqlstore.connectionimpl.close.connrelease\");\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.connection.ConnectionManager.checkXact",
	"Comment": "check whether a connectionimpl is already associated withthe transaction on the current thread.",
	"Method": "ConnectionImpl checkXact(){\r\n    Transaction tran = null;\r\n    if (tran == null)\r\n        return null;\r\n    return (ConnectionImpl) this.xactConnections.get(tran);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.runtime.IASEjbExtraDescriptors.isFlushEnabledFor",
	"Comment": "convenience method to check if a method is flush enabled or not",
	"Method": "boolean isFlushEnabledFor(MethodDescriptor methodDesc){\r\n    if (flushMethodDescriptor != null) {\r\n        return flushMethodDescriptor.isFlushEnabledFor(methodDesc);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdbcra.common.DataSourceObjectBuilder.parseDriverProperties",
	"Comment": "get the extra driver properties from the datasourcespec object andparse them to a set of methodname and parameters. prepare a hashtablecontaining these details and return.",
	"Method": "Hashtable parseDriverProperties(DataSourceSpec spec){\r\n    String delim = spec.getDetail(DataSourceSpec.DELIMITER);\r\n    String prop = spec.getDetail(DataSourceSpec.DRIVERPROPERTIES);\r\n    if (prop == null || prop.trim().equals(\"\")) {\r\n        return new Hashtable();\r\n    } else if (delim == null || delim.equals(\"\")) {\r\n        throw new ResourceException(\"Delimiter is not provided in the configuration\");\r\n    }\r\n    Hashtable properties = new Hashtable();\r\n    delim = delim.trim();\r\n    String sep = delim + delim;\r\n    int sepLen = sep.length();\r\n    String cache = prop;\r\n    Vector methods = new Vector();\r\n    while (cache.indexOf(sep) != -1) {\r\n        int index = cache.indexOf(sep);\r\n        String name = cache.substring(0, index);\r\n        if (name.trim() != \"\") {\r\n            methods.add(name);\r\n            cache = cache.substring(index + sepLen);\r\n        }\r\n    }\r\n    Enumeration allMethods = methods.elements();\r\n    while (allMethods.hasMoreElements()) {\r\n        String oneMethod = (String) allMethods.nextElement();\r\n        if (!oneMethod.trim().equals(\"\")) {\r\n            String methodName = null;\r\n            Vector parms = new Vector();\r\n            StringTokenizer methodDetails = new StringTokenizer(oneMethod, delim);\r\n            for (int i = 0; methodDetails.hasMoreTokens(); i++) {\r\n                String token = (String) methodDetails.nextToken();\r\n                if (i == 0) {\r\n                    methodName = token.toUpperCase();\r\n                } else {\r\n                    parms.add(token);\r\n                }\r\n            }\r\n            properties.put(methodName, parms);\r\n        }\r\n    }\r\n    return properties;\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.JMSPing.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    Server targetServer = domain.getServerNamed(target);\r\n    if (targetServer != null) {\r\n        config = domain.getConfigNamed(targetServer.getConfigRef());\r\n    }\r\n    com.sun.enterprise.config.serverbeans.Cluster cluster = domain.getClusterNamed(target);\r\n    if (cluster != null) {\r\n        config = domain.getConfigNamed(cluster.getConfigRef());\r\n    }\r\n    JmsService jmsservice = config.getExtensionByType(JmsService.class);\r\n    String defaultJmshostStr = jmsservice.getDefaultJmsHost();\r\n    JmsHost defaultJmsHost = null;\r\n    for (JmsHost jmshost : jmsservice.getJmsHost()) {\r\n        if (defaultJmshostStr.equals(jmshost.getName()))\r\n            defaultJmsHost = jmshost;\r\n    }\r\n    String tmpJMSResource = \"test_jms_adapter\";\r\n    ActionReport subReport = report.addSubActionsReport();\r\n    createJMSResource(defaultJmsHost, subReport, tmpJMSResource, context.getSubject());\r\n    if (ActionReport.ExitCode.FAILURE.equals(subReport.getActionExitCode())) {\r\n        report.setMessage(localStrings.getLocalString(\"jms-ping.cannotCreateJMSResource\", \"Unable to create a temporary Connection Factory to the JMS Host\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        boolean value = pingConnectionPool(tmpJMSResource + JNDINAME_APPENDER);\r\n        if (!value) {\r\n            report.setMessage(localStrings.getLocalString(\"jms-ping.pingConnectionPoolFailed\", \"Pinging to the JMS Host failed.\"));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        } else {\r\n            report.setMessage(localStrings.getLocalString(\"jms-ping.pingConnectionPoolSuccess\", \"JMS-ping command executed successfully\"));\r\n            report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n        }\r\n    } catch (ResourceException e) {\r\n        report.setMessage(localStrings.getLocalString(\"jms-ping.pingConnectionPoolException\", \"An exception occured while trying to ping the JMS Host.\", e.getMessage()));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n    }\r\n    deleteJMSResource(subReport, tmpJMSResource, context.getSubject());\r\n    if (ActionReport.ExitCode.FAILURE.equals(subReport.getActionExitCode())) {\r\n        report.setMessage(localStrings.getLocalString(\"jms-ping.cannotdeleteJMSResource\", \"Unable to delete the temporary JMS Resource \" + tmpJMSResource + \". Please delete this manually.\", tmpJMSResource));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingClassElementImpl.getVersionNumber",
	"Comment": "returns the version number of this mappingclasselement object.\tplease note, the returned version number reflects the version number at \tthe last save, not the version number of the memory representation.",
	"Method": "int getVersionNumber(){\r\n    return versionNo;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceFieldElement.isReadSensitive",
	"Comment": "determines whether this field element is read sensitive or not.\tthis value is only used if getpersistencetype returns \tderived",
	"Method": "boolean isReadSensitive(boolean isReadSensitive){\r\n    return ((getPersistenceType() == DERIVED) && getFieldImpl().isReadSensitive());\r\n}"
}, {
	"Path": "com.sun.enterprise.security.deployment.annotation.handlers.AbstractAuthAnnotationHandler.getMethodAllDescriptors",
	"Comment": "returns methoddescriptors representing all for a given ejbdescriptor.",
	"Method": "Set<MethodDescriptor> getMethodAllDescriptors(EjbDescriptor ejbDesc){\r\n    Set methodAlls = new HashSet();\r\n    if (ejbDesc.isRemoteInterfacesSupported() || ejbDesc.isRemoteBusinessInterfacesSupported()) {\r\n        methodAlls.add(new MethodDescriptor(MethodDescriptor.ALL_METHODS, \"\", MethodDescriptor.EJB_REMOTE));\r\n        if (ejbDesc.isRemoteInterfacesSupported()) {\r\n            methodAlls.add(new MethodDescriptor(MethodDescriptor.ALL_METHODS, \"\", MethodDescriptor.EJB_HOME));\r\n        }\r\n    }\r\n    if (ejbDesc.isLocalInterfacesSupported() || ejbDesc.isLocalBusinessInterfacesSupported()) {\r\n        methodAlls.add(new MethodDescriptor(MethodDescriptor.ALL_METHODS, \"\", MethodDescriptor.EJB_LOCAL));\r\n        if (ejbDesc.isLocalInterfacesSupported()) {\r\n            methodAlls.add(new MethodDescriptor(MethodDescriptor.ALL_METHODS, \"\", MethodDescriptor.EJB_LOCALHOME));\r\n        }\r\n    }\r\n    if (ejbDesc.isLocalBean()) {\r\n        methodAlls.add(new MethodDescriptor(MethodDescriptor.ALL_METHODS, \"\", MethodDescriptor.EJB_LOCAL));\r\n    }\r\n    if (ejbDesc.hasWebServiceEndpointInterface()) {\r\n        methodAlls.add(new MethodDescriptor(MethodDescriptor.ALL_METHODS, \"\", MethodDescriptor.EJB_WEB_SERVICE));\r\n    }\r\n    return methodAlls;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.JDOQLElements.setAggregate",
	"Comment": "sets whether the result of the jdoql query is a associated toan aggregate function.",
	"Method": "void setAggregate(boolean isAggregate){\r\n    this.isAggregate = isAggregate;\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.packageappclient.PackageAppClient.findCurrentJarFile",
	"Comment": "returns a file object for the jar file that contains this class.",
	"Method": "File findCurrentJarFile(){\r\n    URI thisJarURI = getClass().getProtectionDomain().getCodeSource().getLocation().toURI();\r\n    URI thisJarFileBasedURI = (thisJarURI.getScheme().startsWith(\"jar\")) ? URI.create(\"file:\" + thisJarURI.getRawSchemeSpecificPart()) : thisJarURI;\r\n    File result = new File(thisJarFileBasedURI);\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsCatalogsInTableDefinitions",
	"Comment": "retrieves whether a catalog name can be used in a table definition statement.",
	"Method": "boolean supportsCatalogsInTableDefinitions(){\r\n    return databaseMetaData.supportsCatalogsInTableDefinitions();\r\n}"
}, {
	"Path": "org.glassfish.admingui.devtests.BaseSeleniumTestClass.selectTableRowsByValue",
	"Comment": "for the given table, this method will select each row whose value in the specified columnmatched the value given, returning the number of rows selected.",
	"Method": "int selectTableRowsByValue(String baseId,String value,int selectTableRowsByValue,String tableId,String value,String selectColId,String valueColId){\r\n    List<String> rows = getTableRowsByValue(tableId, value, valueColId);\r\n    if (!rows.isEmpty()) {\r\n        for (String row : rows) {\r\n            selectTableRow(row, selectColId);\r\n        }\r\n    }\r\n    return rows.size();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.MethodAnnotater.knownTypes",
	"Comment": "check that the top nwords worth of types on stack are well defined",
	"Method": "boolean knownTypes(Stack stack,int nWords){\r\n    for (int i = stack.size() - 1; i >= 0 && nWords > 0; i--) {\r\n        int words = 0;\r\n        switch(((Integer) stack.elementAt(i)).intValue()) {\r\n            case T_UNKNOWN:\r\n            case T_WORD:\r\n            case T_TWOWORD:\r\n                return false;\r\n            case T_BOOLEAN:\r\n            case T_CHAR:\r\n            case T_FLOAT:\r\n            case T_BYTE:\r\n            case T_SHORT:\r\n            case T_INT:\r\n            case TC_OBJECT:\r\n            case TC_INTERFACE:\r\n            case TC_STRING:\r\n                words = 1;\r\n                break;\r\n            case T_DOUBLE:\r\n            case T_LONG:\r\n                words = 2;\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n        nWords -= words;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.containsField",
	"Comment": "tests whether the supplied field is in the collection of fields \tmaintained by this holder.",
	"Method": "boolean containsField(PersistenceFieldElement field){\r\n    return (getClassImpl().getField(field.getName()) != null);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.loadDBProperties",
	"Comment": "load properties for database specified by vendortype and vendorname",
	"Method": "Properties loadDBProperties(String vendorType,String vendorName){\r\n    Properties dbProperties = new Properties();\r\n    if (!vendorType.equals(DBVendorTypeHelper.DEFAULT_DB)) {\r\n        try {\r\n            loadFromResource(vendorType, dbProperties);\r\n        } catch (IOException e) {\r\n            if (logger.isLoggable()) {\r\n                logger.fine(\"sqlstore.database.dbvendor.init.default\", vendorType);\r\n            }\r\n        }\r\n    }\r\n    overrideProperties(dbProperties, vendorName);\r\n    return dbProperties;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.annotation.handlers.StatefulHandler.createEjbDescriptor",
	"Comment": "create a new ejbdescriptor for a given elementname and annotationinfo.",
	"Method": "EjbDescriptor createEjbDescriptor(String elementName,AnnotationInfo ainfo){\r\n    AnnotatedElement ae = ainfo.getAnnotatedElement();\r\n    Class ejbClass = (Class) ae;\r\n    EjbSessionDescriptor newDescriptor = new EjbSessionDescriptor();\r\n    newDescriptor.setName(elementName);\r\n    newDescriptor.setEjbClassName(ejbClass.getName());\r\n    newDescriptor.setSessionType(EjbSessionDescriptor.STATEFUL);\r\n    return newDescriptor;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingClassElementImpl.toColumnObjects",
	"Comment": "accept an arraylist of column names and return an array list containing\tthe corresponding column or column pair objects.",
	"Method": "ArrayList toColumnObjects(String schemaName,ArrayList columnNames){\r\n    Iterator iterator = columnNames.iterator();\r\n    ArrayList objects = new ArrayList();\r\n    while (iterator.hasNext()) {\r\n        String columnName = (String) iterator.next();\r\n        String absoluteColumnName = NameUtil.getAbsoluteMemberName(schemaName, columnName);\r\n        final TableElement table = TableElement.forName(NameUtil.getTableName(absoluteColumnName));\r\n        objects.add(table.getMember(DBIdentifier.create(absoluteColumnName)));\r\n    }\r\n    return objects;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ConnectionHolder.getHoldability",
	"Comment": "retrieves the current holdability of resultset objects createdusing this connection object.",
	"Method": "int getHoldability(){\r\n    checkValidity();\r\n    return con.getHoldability();\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnection.invalidateAllConnectionHandles",
	"Comment": "this method removes all the connection handles from the tableof connection handles and invalidates all of them so that anyoperation on those connection handles throws an exception.",
	"Method": "void invalidateAllConnectionHandles(){\r\n    Set handles = connectionHandles.keySet();\r\n    Iterator iter = handles.iterator();\r\n    try {\r\n        while (iter.hasNext()) {\r\n            ConnectionHolder ch = (ConnectionHolder) iter.next();\r\n            ch.invalidate();\r\n        }\r\n    } catch (java.util.NoSuchElementException nsee) {\r\n        throw new ResourceException(\"Could not find the connection handle: \" + nsee.getMessage());\r\n    }\r\n    connectionHandles.clear();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.EJBBundleInfoHelper.getAvailableSchemaNames",
	"Comment": "gets a collection of names of schemas defined in this\tejb jar.this implementation simply returns the list passed in\tthe constructor or null if there was none supplied.",
	"Method": "Collection getAvailableSchemaNames(){\r\n    return availableSchemaNames;\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.CreateJMSResource.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (resourceType == null) {\r\n        report.setMessage(localStrings.getLocalString(\"create.jms.resource.noResourceType\", \"No Resoruce Type specified for JMS Resource.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (jndiName == null) {\r\n        report.setMessage(localStrings.getLocalString(\"create.jms.resource.noJndiName\", \"No JNDI name specified for JMS Resource.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (!(resourceType.equals(TOPIC_CF) || resourceType.equals(QUEUE_CF) || resourceType.equals(UNIFIED_CF) || resourceType.equals(TOPIC) || resourceType.equals(QUEUE))) {\r\n        report.setMessage(localStrings.getLocalString(\"create.jms.resource.InvalidResourceType\", \"Invalid Resource Type specified for JMS Resource.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    jndiNameForConnectionPool = jndiName + JNDINAME_APPENDER;\r\n    if (force) {\r\n        Resource res = null;\r\n        if (resourceType.equals(TOPIC) || resourceType.equals(QUEUE))\r\n            res = ConnectorsUtil.getResourceByName(domain.getResources(), AdminObjectResource.class, jndiName);\r\n        else\r\n            res = ConnectorsUtil.getResourceByName(domain.getResources(), ConnectorResource.class, jndiName);\r\n        if (res != null) {\r\n            ActionReport deleteReport = report.addSubActionsReport();\r\n            ParameterMap parameters = new ParameterMap();\r\n            parameters.set(DEFAULT_OPERAND, jndiName);\r\n            parameters.set(\"target\", target);\r\n            commandRunner.getCommandInvocation(\"delete-jms-resource\", deleteReport, context.getSubject()).parameters(parameters).execute();\r\n            if (ActionReport.ExitCode.FAILURE.equals(deleteReport.getActionExitCode())) {\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    populateJmsRAMap();\r\n    if (props != null) {\r\n        Enumeration en = props.keys();\r\n        while (en.hasMoreElements()) {\r\n            String key = (String) en.nextElement();\r\n            String raKey = getMappedName(key);\r\n            if (raKey == null)\r\n                raKey = key;\r\n            props.put(raKey, (String) props.get(key));\r\n            if (!raKey.equals(key))\r\n                props.remove(key);\r\n        }\r\n    }\r\n    ActionReport subReport = report.addSubActionsReport();\r\n    if (resourceType.equals(TOPIC_CF) || resourceType.equals(QUEUE_CF) || resourceType.equals(UNIFIED_CF)) {\r\n        ConnectorConnectionPool cpool = (ConnectorConnectionPool) ConnectorsUtil.getResourceByName(domain.getResources(), ConnectorConnectionPool.class, jndiNameForConnectionPool);\r\n        boolean createdPool = false;\r\n        if (cpool == null || !filterForTarget(jndiNameForConnectionPool)) {\r\n            ParameterMap parameters = populateConnectionPoolParameters();\r\n            commandRunner.getCommandInvocation(\"create-connector-connection-pool\", subReport, context.getSubject()).parameters(parameters).execute();\r\n            createdPool = true;\r\n            if (ActionReport.ExitCode.FAILURE.equals(subReport.getActionExitCode())) {\r\n                report.setMessage(localStrings.getLocalString(\"create.jms.resource.cannotCreateConnectionPool\", \"Unable to create connection pool.\"));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n        ParameterMap params = populateConnectionResourceParameters();\r\n        commandRunner.getCommandInvocation(\"create-connector-resource\", subReport, context.getSubject()).parameters(params).execute();\r\n        if (ActionReport.ExitCode.FAILURE.equals(subReport.getActionExitCode())) {\r\n            report.setMessage(localStrings.getLocalString(\"create.jms.resource.cannotCreateConnectorResource\", \"Unable to create connection resource.\"));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            if (createdPool) {\r\n                ParameterMap paramsForRollback = new ParameterMap();\r\n                paramsForRollback.set(DEFAULT_OPERAND, jndiNameForConnectionPool);\r\n                commandRunner.getCommandInvocation(\"delete-connector-connection-pool\", subReport, context.getSubject()).parameters(paramsForRollback).execute();\r\n            }\r\n            return;\r\n        }\r\n    } else if (resourceType.equals(TOPIC) || resourceType.equals(QUEUE)) {\r\n        ParameterMap aoAttrList = new ParameterMap();\r\n        try {\r\n            Properties properties = validateDestinationResourceProps(props, jndiName);\r\n            StringBuilder builder = new StringBuilder();\r\n            for (java.util.Map.Entry<Object, Object> prop : properties.entrySet()) {\r\n                builder.append(prop.getKey()).append(\"=\").append(prop.getValue()).append(\":\");\r\n            }\r\n            String propString = builder.toString();\r\n            int lastColonIndex = propString.lastIndexOf(\":\");\r\n            if (lastColonIndex >= 0) {\r\n                propString = propString.substring(0, lastColonIndex);\r\n            }\r\n            aoAttrList.set(\"property\", propString);\r\n        } catch (Exception e) {\r\n            report.setMessage(localStrings.getLocalString(\"create.jms.resource.cannotCreateAdminObjectWithRootCause\", \"Unable to create admin object. Reason: \" + e.getMessage(), e.getMessage()));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n        aoAttrList.set(DEFAULT_OPERAND, jndiName);\r\n        aoAttrList.set(\"restype\", resourceType);\r\n        aoAttrList.set(\"raname\", DEFAULT_JMS_ADAPTER);\r\n        aoAttrList.set(\"target\", target);\r\n        if (enabled != null)\r\n            aoAttrList.set(\"enabled\", Boolean.toString(enabled));\r\n        commandRunner.getCommandInvocation(\"create-admin-object\", subReport, context.getSubject()).parameters(aoAttrList).execute();\r\n        if (ActionReport.ExitCode.FAILURE.equals(subReport.getActionExitCode())) {\r\n            report.setMessage(localStrings.getLocalString(\"create.jms.resource.cannotCreateAdminObject\", \"Unable to create admin object.\"));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    ActionReport.ExitCode ec = ActionReport.ExitCode.SUCCESS;\r\n    report.setActionExitCode(ec);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.getIdentifier",
	"Comment": "gets identifier. an identifier is a string that user can use to identify\tthe persistencemanagerfactory in a given environment. identifier can be\tparticularly useful in an environment where multiple \tpersistencemanagerfactories are initialized in a system.",
	"Method": "String getIdentifier(){\r\n    return identifier;\r\n}"
}, {
	"Path": "org.glassfish.jdbcruntime.service.JdbcAdminServiceImpl.getValidationClassNames",
	"Comment": "get validation class names list for the classname that the jdbc connection pool refers to. this is used for custom connection validation.",
	"Method": "Set<String> getValidationClassNames(String className){\r\n    SortedSet classNames = new TreeSet();\r\n    if (className == null) {\r\n        _logger.log(Level.WARNING, \"jdbc.admin.service.ds_class_name_null\");\r\n        return classNames;\r\n    }\r\n    File validationClassMappingFile;\r\n    String dbVendor = getDatabaseVendorName(className);\r\n    if (dbVendor != null) {\r\n        validationClassMappingFile = new File(DBVENDOR_MAPPINGS_ROOT + CONVAL_PROPERTIES);\r\n        Properties validationClassMappings = DriverLoader.loadFile(validationClassMappingFile);\r\n        String validationClassName = validationClassMappings.getProperty(dbVendor);\r\n        if (validationClassName != null) {\r\n            classNames.add(validationClassName);\r\n        }\r\n        if (detectJDBC40(className)) {\r\n            classNames.add(JDBC40_CONNECTION_VALIDATION);\r\n        }\r\n    }\r\n    return classNames;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.PersistenceDescriptor.getPkeyFieldInfo",
	"Comment": "return the array of persistentfieldinfo objects for the pkey fields.",
	"Method": "PersistentFieldInfo[] getPkeyFieldInfo(){\r\n    if (!fieldInfoInitialized)\r\n        initializeFieldInfo();\r\n    return pkeyFieldInfo;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.isBeforeFirst",
	"Comment": "retrieves whether the cursor is before the first row inthis resultset object.",
	"Method": "boolean isBeforeFirst(){\r\n    return resultSet.isBeforeFirst();\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.obj.GroupOfURLs.isSubgroupMember",
	"Comment": "checks if the supplied name is a member of any subgroups.only subgroups are retrieved and explored.",
	"Method": "boolean isSubgroupMember(String dn){\r\n    for (NamingEnumeration members = (NamingEnumeration) members(GROUPS_ONLY); members.hasMore(); ) {\r\n        Object obj = members.next();\r\n        if (obj instanceof GroupOfNames && ((GroupOfNames) obj).isMember(dn)) {\r\n            members.close();\r\n            return true;\r\n        } else if (obj instanceof GroupOfURLs && ((GroupOfURLs) obj).isMember(dn)) {\r\n            members.close();\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.SunContainerHelper.getEJBLocalObject",
	"Comment": "get an ejblocalobject reference for this primary key and container helper.this is suncontainerhelper specific code.",
	"Method": "EJBLocalObject getEJBLocalObject(Object pk,Object container,EJBLocalObject getEJBLocalObject,Object pk,Object container,EJBContext context){\r\n    EJBLocalObject rc = null;\r\n    try {\r\n        rc = ((Container) container).getEJBLocalObjectForPrimaryKey(pk, context);\r\n    } catch (Exception ex) {\r\n        processContainerException(ex);\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecServerRequestInterceptor.createAuthCred",
	"Comment": "create an auth credential from authentication token and storeit as a private credential in the jaas subject in the security context.set the authcls field in the security context.this method currently only works for passwordcredential tokens.",
	"Method": "void createAuthCred(SecurityContext sc,byte[] authtok,ORB orb){\r\n    _logger.log(Level.FINE, \"Constructing a PasswordCredential from client authentication token\");\r\n    GSSUPToken tok = GSSUPToken.getServerSideInstance(orb, codec, authtok);\r\n    final PasswordCredential pwdcred = tok.getPwdcred();\r\n    final SecurityContext fsc = sc;\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"Password credential = \" + pwdcred.toString());\r\n        _logger.log(Level.FINE, \"Adding PasswordCredential to subject's PrivateCredentials\");\r\n    }\r\n    java.security.AccessController.doPrivileged(new java.security.PrivilegedAction() {\r\n        public java.lang.Object run() {\r\n            fsc.subject.getPrivateCredentials().add(pwdcred);\r\n            return null;\r\n        }\r\n    });\r\n    sc = fsc;\r\n    sc.authcls = PasswordCredential.class;\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecServerRequestInterceptor.createAuthCred",
	"Comment": "create an auth credential from authentication token and storeit as a private credential in the jaas subject in the security context.set the authcls field in the security context.this method currently only works for passwordcredential tokens.",
	"Method": "void createAuthCred(SecurityContext sc,byte[] authtok,ORB orb){\r\n    fsc.subject.getPrivateCredentials().add(pwdcred);\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.UtilHandlers.convertStringtoListHandler",
	"Comment": "this handler takes in a string with delimiter and returns list",
	"Method": "void convertStringtoListHandler(HandlerContext handlerCtx){\r\n    List result = convertStringToList((String) handlerCtx.getInputValue(\"str\"), (String) handlerCtx.getInputValue(\"delimiter\"));\r\n    handlerCtx.setOutputValue(\"result\", result);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.connector.OutBoundRANode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object obj){\r\n    if (obj instanceof AuthMechanism) {\r\n        boolean flag = descriptor.addAuthMechanism((AuthMechanism) obj);\r\n        if (flag == false)\r\n            DOLUtils.getDefaultLogger().finer(\"The AuthMechanism object already exists in the Descriptor\");\r\n    } else if (obj instanceof ConnectionDefDescriptor) {\r\n        descriptor.addConnectionDefDescriptor((ConnectionDefDescriptor) obj);\r\n    } else if (obj instanceof ConnectorConfigProperty) {\r\n        descriptor.addConfigProperty((ConnectorConfigProperty) obj);\r\n    } else if (obj instanceof SecurityPermission) {\r\n        ConnectorDescriptor connDesc = (ConnectorDescriptor) getParentNode().getDescriptor();\r\n        connDesc.addSecurityPermission((SecurityPermission) obj);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.CodeAttribute.setLocalsUsed",
	"Comment": "set the maximum number of local variables used by this method",
	"Method": "void setLocalsUsed(int used){\r\n    makeValid();\r\n    maxLocals = used;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.util.ClassFileSource.sameAs",
	"Comment": "does the other class file source refer to the same source location?",
	"Method": "boolean sameAs(ClassFileSource other){\r\n    if (isZipped())\r\n        return (other.isZipped() && other.zipFile.getName().equals(zipFile.getName()));\r\n    else if (other.isZipped())\r\n        return false;\r\n    else if (other.classFile != null && classFile != null)\r\n        return other.classFile.getPath().equals(classFile.getPath());\r\n    else if (byteCodeStream != null)\r\n        return byteCodeStream.equals(other.byteCodeStream);\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.AppClientContainer.stop",
	"Comment": "stops the app client container.note that the calling program should not stop the acc if there might beother threads running, such as the swing event dispatcher thread.stoppingthe acc can shut down various services that those continuing threads mighttry to use.also note that stopping the acc will have no effect on any thread thatthe app client itself might have created.if the calling program needsto control such threads it and the client code running in the threadsshould agree on how they will communicate with each other.the acc cannothelp with this.",
	"Method": "void stop(){\r\n    if (state == State.STOPPED) {\r\n        return;\r\n    }\r\n    if (state != State.STARTED) {\r\n        throw new IllegalStateException();\r\n    }\r\n    cleanup.start();\r\n    state = State.STOPPED;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.MappingPolicy.getUniqueName",
	"Comment": "return a unique name for name.it will be unique within the givennamespace.",
	"Method": "String getUniqueName(String name,String namespace,int maxLen){\r\n    String rc = name;\r\n    maxLen -= MAX_LEN_COUNTER;\r\n    if (name.length() > maxLen) {\r\n        rc = name.substring(0, maxLen);\r\n    }\r\n    String nameUpper = rc.toUpperCase();\r\n    if (defaultReservedWords.contains(nameUpper) || reservedWords.contains(nameUpper)) {\r\n        maxLen -= MAX_LEN_RESERVED;\r\n        if (rc.length() > maxLen) {\r\n            nameUpper = nameUpper.substring(0, maxLen);\r\n            rc = rc.substring(0, maxLen);\r\n        }\r\n        nameUpper += RESERVED_WORD_UNRESERVER;\r\n        rc += RESERVED_WORD_UNRESERVER;\r\n    }\r\n    Set names = (Set) namespaces.get(namespace);\r\n    if (names == null) {\r\n        names = new HashSet();\r\n        names.add(nameUpper);\r\n        namespaces.put(namespace, names);\r\n    } else if (names.contains(nameUpper)) {\r\n        counter++;\r\n        rc += DatabaseConstants.NAME_SEPARATOR + counter;\r\n    } else {\r\n        names.add(nameUpper);\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.HashSet.iterator",
	"Comment": "returns an iterator over the elements in this set.the elementsare returned in no particular order.",
	"Method": "Iterator iterator(){\r\n    return new SCOHashIterator(super.iterator(), this);\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.util.RestUtil.appendEncodedSegment",
	"Comment": "this method will encode append segment to base, encoding it so that a correct url is returned.",
	"Method": "String appendEncodedSegment(String base,String segment){\r\n    String encodedUrl = getJerseyClient().target(base).getUriBuilder().segment(segment).build().toASCIIString();\r\n    return encodedUrl;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnectionFactory.setIsolation",
	"Comment": "sets the isolation level specified in the connectionrequestinfofor the managedconnection passed.",
	"Method": "void setIsolation(com.sun.jdbcra.spi.ManagedConnection mc){\r\n    java.sql.Connection con = mc.getActualConnection();\r\n    if (con == null) {\r\n        return;\r\n    }\r\n    String tranIsolation = spec.getDetail(DataSourceSpec.TRANSACTIONISOLATION);\r\n    if (tranIsolation != null && tranIsolation.equals(\"\") == false) {\r\n        int tranIsolationInt = getTransactionIsolationInt(tranIsolation);\r\n        try {\r\n            con.setTransactionIsolation(tranIsolationInt);\r\n        } catch (java.sql.SQLException sqle) {\r\n            _logger.log(Level.SEVERE, \"jdbc.exc_tx_level\");\r\n            throw new ResourceException(\"The transaction isolation could \" + \"not be set: \" + sqle.getMessage());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.isDirty",
	"Comment": "a flag to indicate that my data has changed since the last save.",
	"Method": "boolean isDirty(){\r\n    return this.isDirty;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbCMPEntityDescriptor.setEjbImplementationImplClassName",
	"Comment": "set the generated implementation class for a cmp 2.0 ejb object",
	"Method": "void setEjbImplementationImplClassName(String className){\r\n    ejbImplementationImplClassName = className;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbMessageBeanDescriptor.print",
	"Comment": "returns a formatted string of the attributes of this object.",
	"Method": "void print(StringBuffer toStringBuffer){\r\n    super.print(toStringBuffer);\r\n    toStringBuffer.append(\"Message-driven descriptor : \").append(activationConfig.getActivationConfig()).append(runtimeActivationConfig.getActivationConfig());\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.PreparedStatementWrapper.setBlob",
	"Comment": "sets the designated parameter to the given blob object.the driver converts this to an sql blob value when itsends it to the database.",
	"Method": "void setBlob(int i,Blob x){\r\n    preparedStatement.setBlob(i, x);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.getClassLoader",
	"Comment": "get the class loader used to load the class being validated.",
	"Method": "ClassLoader getClassLoader(){\r\n    return _classLoader;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.model.util.NameMapper.hasField",
	"Comment": "iscmpfield does not return true for relationships, so we use gettypefor",
	"Method": "boolean hasField(PersistenceDescriptor persistenceDescriptor,String fieldName){\r\n    Class fieldType = null;\r\n    try {\r\n        fieldType = persistenceDescriptor.getTypeFor(fieldName);\r\n    } catch (RuntimeException e) {\r\n    }\r\n    return (fieldType != null);\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.PluginHandlers.getContentOfIntegrationPoints",
	"Comment": "finds the integration point of the specified type.returns the contents of this ip type as a list. the content can be a comma separated string.this is useful for the case such as dropdown or list box to allow additional options in the component.",
	"Method": "void getContentOfIntegrationPoints(HandlerContext handlerCtx){\r\n    String type = (String) handlerCtx.getInputValue(\"type\");\r\n    FacesContext ctx = handlerCtx.getFacesContext();\r\n    Set<IntegrationPoint> points = getSortedIntegrationPoints(getIntegrationPoints(ctx, type));\r\n    List labels = new ArrayList();\r\n    List values = new ArrayList();\r\n    if (points != null) {\r\n        for (IntegrationPoint it : points) {\r\n            String content = it.getContent();\r\n            if (GuiUtil.isEmpty(content)) {\r\n                GuiUtil.getLogger().warning(\"No Content specified for Integration Point: \" + type + \" id : \" + it.getId());\r\n                continue;\r\n            }\r\n            List<String> labelsAndValues = GuiUtil.parseStringList(content, \"|\");\r\n            values.add(labelsAndValues.get(0));\r\n            labels.add(GuiUtil.getMessage(labelsAndValues.get(1), labelsAndValues.get(2)));\r\n        }\r\n    }\r\n    handlerCtx.setOutputValue(\"labels\", labels);\r\n    handlerCtx.setOutputValue(\"values\", values);\r\n}"
}, {
	"Path": "org.glassfish.admin.mejb.IIOPMBeanServerImpl.getObjectInstance",
	"Comment": "gets the objectinstance for a given mbean registered with the mbean server.",
	"Method": "ObjectInstance getObjectInstance(ObjectName name){\r\n    return server.getObjectInstance(name);\r\n}"
}, {
	"Path": "org.glassfish.deployment.client.RemoteDeploymentFacility.prepareRemoteCommandArguments",
	"Comment": "assembles an argument list suitable for use by remotecommand from thecommand, options, and operand.",
	"Method": "String[] prepareRemoteCommandArguments(String commandName,Map<String, Object> options,String[] operands){\r\n    ArrayList<String> result = new ArrayList<String>();\r\n    result.add(commandName);\r\n    if (options == null) {\r\n        options = Collections.EMPTY_MAP;\r\n    }\r\n    for (Map.Entry<String, Object> entry : options.entrySet()) {\r\n        result.add(\"--\" + entry.getKey() + \"=\" + convertValue(entry.getValue()));\r\n    }\r\n    if (operands != null) {\r\n        for (String o : operands) {\r\n            result.add(o);\r\n        }\r\n    }\r\n    return result.toArray(new String[result.size()]);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.getRelationship",
	"Comment": "returns the relationship with the supplied name from the collection of \trelationships maintained by this holder.",
	"Method": "RelationshipElement getRelationship(String name){\r\n    RelationshipElement[] relationships = getRelationships();\r\n    int i, count = ((relationships != null) ? relationships.length : 0);\r\n    for (i = 0; i < count; i++) {\r\n        RelationshipElement relationship = relationships[i];\r\n        if (name.equals(relationship.getName()))\r\n            return relationship;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.application.gf.ApplicationRuntimeNode.registerBundle",
	"Comment": "register this node as a root node capable of loading entire dd files",
	"Method": "String registerBundle(Map publicIDToDTD,Map<String, List<Class>> versionUpgrades){\r\n    publicIDToDTD.put(DTDRegistry.SUN_APPLICATION_130_DTD_PUBLIC_ID, DTDRegistry.SUN_APPLICATION_130_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_APPLICATION_140_DTD_PUBLIC_ID, DTDRegistry.SUN_APPLICATION_140_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_APPLICATION_141_DTD_PUBLIC_ID, DTDRegistry.SUN_APPLICATION_141_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_APPLICATION_500_DTD_PUBLIC_ID, DTDRegistry.SUN_APPLICATION_500_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_APPLICATION_600_DTD_PUBLIC_ID, DTDRegistry.SUN_APPLICATION_600_DTD_SYSTEM_ID);\r\n    if (!restrictDTDDeclarations()) {\r\n        publicIDToDTD.put(DTDRegistry.SUN_APPLICATION_140beta_DTD_PUBLIC_ID, DTDRegistry.SUN_APPLICATION_140beta_DTD_SYSTEM_ID);\r\n    }\r\n    return RuntimeTagNames.S1AS_APPLICATION_RUNTIME_TAG;\r\n}"
}, {
	"Path": "org.glassfish.concurrent.admin.ListManagedThreadFactories.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        Collection<ManagedThreadFactory> managedThreadFactories = domain.getResources().getResources(ManagedThreadFactory.class);\r\n        List<Map<String, String>> resourcesList = new ArrayList<Map<String, String>>();\r\n        List<DefaultResourceProxy> drps = habitat.getAllServices(DefaultResourceProxy.class);\r\n        for (ManagedThreadFactory managedThreadFactory : managedThreadFactories) {\r\n            String jndiName = managedThreadFactory.getJndiName();\r\n            if (bindableResourcesHelper.resourceExists(jndiName, target)) {\r\n                ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n                part.setMessage(jndiName);\r\n                Map<String, String> resourceNameMap = new HashMap<String, String>();\r\n                String logicalName = DefaultResourceProxy.Util.getLogicalName(drps, jndiName);\r\n                if (logicalName != null) {\r\n                    resourceNameMap.put(\"logical-jndi-name\", logicalName);\r\n                }\r\n                resourceNameMap.put(\"name\", jndiName);\r\n                resourcesList.add(resourceNameMap);\r\n            }\r\n        }\r\n        Properties extraProperties = new Properties();\r\n        extraProperties.put(\"managedThreadFactories\", resourcesList);\r\n        report.setExtraProperties(extraProperties);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.managed.thread.factory.failed\", \"List managed thread factories failed\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnUtils.load",
	"Comment": "return the best instruction for loading a value from a localvariable slot",
	"Method": "Insn load(int tp,int i,ConstantPool pool){\r\n    switch(tp) {\r\n        case T_BOOLEAN:\r\n        case T_CHAR:\r\n        case T_BYTE:\r\n        case T_SHORT:\r\n        case T_INT:\r\n            return iLoad(i, pool);\r\n        case T_FLOAT:\r\n            return fLoad(i, pool);\r\n        case T_DOUBLE:\r\n            return dLoad(i, pool);\r\n        case T_LONG:\r\n            return lLoad(i, pool);\r\n        case TC_OBJECT:\r\n            return aLoad(i, pool);\r\n        default:\r\n            throw new InsnError(\"bad load type\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.MappingFile.fromMappingClasses",
	"Comment": "creates an suncmpmapping object from a collection ofmappingclasselement objects",
	"Method": "void fromMappingClasses(OutputStream dest,Map mappingClasses,ConversionHelper helper,SunCmpMappings fromMappingClasses,Map mappingClasses,ConversionHelper helper){\r\n    Iterator keyIter = mappingClasses.keySet().iterator();\r\n    Map mapOfMapping = new java.util.HashMap();\r\n    while (keyIter.hasNext()) {\r\n        String ejbName = (String) keyIter.next();\r\n        MappingClassElement mce = (MappingClassElement) mappingClasses.get(ejbName);\r\n        EntityMapping beanMapping = new EntityMapping();\r\n        if (null != mce) {\r\n            setConsistency(mce, beanMapping);\r\n            String schemaName = mce.getDatabaseRoot();\r\n            SunCmpMapping aMapping = (SunCmpMapping) mapOfMapping.get(schemaName);\r\n            if (null == aMapping) {\r\n                aMapping = new SunCmpMapping();\r\n                aMapping.setSchema(schemaName);\r\n                mapOfMapping.put(schemaName, aMapping);\r\n            }\r\n            List tables = mce.getTables();\r\n            MappingTableElement primary = null;\r\n            if (tables.size() > 0) {\r\n                primary = (MappingTableElement) tables.get(0);\r\n                beanMapping.setTableName(primary.getName());\r\n            }\r\n            beanMapping.setEjbName(ejbName);\r\n            if (null != primary) {\r\n                List refKeys = primary.getReferencingKeys();\r\n                for (int i = 0; refKeys != null && i < refKeys.size(); i++) {\r\n                    SecondaryTable sT = new SecondaryTable();\r\n                    MappingReferenceKeyElement mrke = (MappingReferenceKeyElement) refKeys.get(i);\r\n                    MappingTableElement mte = mrke.getTable();\r\n                    if (null != mte) {\r\n                        sT.setTableName(mte.getName());\r\n                        List cpnames = mrke.getColumnPairNames();\r\n                        boolean hasPairs = false;\r\n                        for (int j = 0; cpnames != null && j < cpnames.size(); j++) {\r\n                            // NOI18N\r\n                            List token = StringHelper.separatedListToArray((String) cpnames.get(j), \";\");\r\n                            ColumnPair cp = new ColumnPair();\r\n                            Iterator iter = token.iterator();\r\n                            while (iter.hasNext()) {\r\n                                String columnName = (String) iter.next();\r\n                                cp.addColumnName(columnName);\r\n                            }\r\n                            sT.addColumnPair(cp);\r\n                            hasPairs = true;\r\n                        }\r\n                        if (hasPairs)\r\n                            beanMapping.addSecondaryTable(sT);\r\n                        else if (logger.isLoggable(Logger.FINE))\r\n                            logger.fine(// NOI18N\r\n                            I18NHelper.getMessage(messages, \"WARN_ILLEGAL_PAIR\", new Object[] { ejbName, mte.getName(), cpnames }));\r\n                    } else {\r\n                        if (logger.isLoggable(Logger.FINE))\r\n                            logger.fine(// NOI18N\r\n                            I18NHelper.getMessage(messages, \"WARN_MISSING_TABLE\", new Object[] { ejbName, primary.getName() }));\r\n                    }\r\n                }\r\n            } else {\r\n                if (logger.isLoggable(Logger.FINE))\r\n                    logger.fine(// NOI18N\r\n                    I18NHelper.getMessage(messages, \"WARN_NO_PRIMARY\", ejbName));\r\n            }\r\n            PersistenceClassElement pce = null;\r\n            PersistenceFieldElement[] pfields = null;\r\n            if (mce instanceof MappingClassElementImpl) {\r\n                MappingClassElementImpl mcei = (MappingClassElementImpl) mce;\r\n                pce = mcei.getPersistenceElement();\r\n                pfields = pce.getFields();\r\n            }\r\n            int len = 0;\r\n            if (null != pfields)\r\n                len = pfields.length;\r\n            for (int i = 0; i < len; i++) {\r\n                PersistenceFieldElement pfield = pfields[i];\r\n                String fieldName = pfield.getName();\r\n                if (helper.isGeneratedField(ejbName, fieldName)) {\r\n                    continue;\r\n                }\r\n                if (pfield instanceof RelationshipElement) {\r\n                    MappingRelationshipElement mre = (MappingRelationshipElement) mce.getField(fieldName);\r\n                    MappingFieldElement mfe = mre;\r\n                    CmrFieldMapping cfm = new CmrFieldMapping();\r\n                    cfm.setCmrFieldName(fieldName);\r\n                    List cols = null;\r\n                    if (null != mfe) {\r\n                        cols = mfe.getColumns();\r\n                        int fgVal = mfe.getFetchGroup();\r\n                        setFetchedWith(cfm, fgVal);\r\n                    }\r\n                    for (int j = 0; null != cols && j < cols.size(); j++) {\r\n                        String cpstring = (String) cols.get(j);\r\n                        int slen = cpstring.indexOf(';');\r\n                        ColumnPair cp = new ColumnPair();\r\n                        cp.addColumnName(cpstring.substring(0, slen));\r\n                        cp.addColumnName(cpstring.substring(slen + 1));\r\n                        cfm.addColumnPair(cp);\r\n                    }\r\n                    if (null != mre)\r\n                        cols = mre.getAssociatedColumns();\r\n                    for (int j = 0; null != cols && j < cols.size(); j++) {\r\n                        String cpstring = (String) cols.get(j);\r\n                        int slen = cpstring.indexOf(';');\r\n                        ColumnPair cp = new ColumnPair();\r\n                        cp.addColumnName(cpstring.substring(0, slen));\r\n                        cp.addColumnName(cpstring.substring(slen + 1));\r\n                        cfm.addColumnPair(cp);\r\n                    }\r\n                    beanMapping.addCmrFieldMapping(cfm);\r\n                } else {\r\n                    MappingFieldElement mfe = mce.getField(fieldName);\r\n                    CmpFieldMapping cfm = new CmpFieldMapping();\r\n                    cfm.setFieldName(fieldName);\r\n                    List cols = null;\r\n                    if (null != mfe) {\r\n                        cols = mfe.getColumns();\r\n                        for (int j = 0; null != cols && j < cols.size(); j++) {\r\n                            cfm.addColumnName((String) cols.get(j));\r\n                        }\r\n                        int fgVal = mfe.getFetchGroup();\r\n                        setFetchedWith(cfm, fgVal);\r\n                    }\r\n                    beanMapping.addCmpFieldMapping(cfm);\r\n                }\r\n            }\r\n            aMapping.addEntityMapping(beanMapping);\r\n        }\r\n    }\r\n    SunCmpMappings retVal = null;\r\n    retVal = new SunCmpMappings();\r\n    Iterator mapOfMappingIter = mapOfMapping.values().iterator();\r\n    while (mapOfMappingIter.hasNext()) {\r\n        SunCmpMapping aVal = (SunCmpMapping) mapOfMappingIter.next();\r\n        retVal.addSunCmpMapping(aVal);\r\n    }\r\n    return retVal;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.getDate",
	"Comment": "retrieves the value of a jdbc date parameter as ajava.sql.date object, usingthe given calendar objectto construct the date.with a calendar object, the drivercan calculate the date taking into account a custom timezone and locale.if no calendar object is specified, the driver uses thedefault timezone and locale.",
	"Method": "Date getDate(int parameterIndex,Date getDate,int parameterIndex,Calendar cal,Date getDate,String parameterName,Date getDate,String parameterName,Calendar cal){\r\n    return callableStatement.getDate(parameterName, cal);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.web.integration.WebSecurityManager.getSecurityContext",
	"Comment": "this is an private method for transforming principal into a securitycontext",
	"Method": "SecurityContext getSecurityContext(Principal principal){\r\n    SecurityContext secContext = null;\r\n    if (principal != null) {\r\n        if (principal instanceof WebPrincipal) {\r\n            WebPrincipal wp = (WebPrincipal) principal;\r\n            secContext = wp.getSecurityContext();\r\n        } else {\r\n            secContext = new SecurityContext(principal.getName(), null);\r\n        }\r\n    }\r\n    if (secContext == null) {\r\n        secContext = SecurityContext.getDefaultSecurityContext();\r\n    }\r\n    return secContext;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.handlers.ResourceHandler.getResourceEnvReferenceDescriptors",
	"Comment": "return resourceenvreferencedescriptors with given nameif exists or a new one without name being set.",
	"Method": "ResourceEnvReferenceDescriptor[] getResourceEnvReferenceDescriptors(String logicName,ResourceContainerContext[] rcContexts){\r\n    ResourceEnvReferenceDescriptor[] resourceEnvRefs = new ResourceEnvReferenceDescriptor[rcContexts.length];\r\n    for (int i = 0; i < rcContexts.length; i++) {\r\n        ResourceEnvReferenceDescriptor resourceEnvRef = rcContexts[i].getResourceEnvReference(logicName);\r\n        if (resourceEnvRef == null) {\r\n            resourceEnvRef = new ResourceEnvReferenceDescriptor();\r\n            rcContexts[i].addResourceEnvReferenceDescriptor(resourceEnvRef);\r\n        }\r\n        resourceEnvRefs[i] = resourceEnvRef;\r\n    }\r\n    return resourceEnvRefs;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.BaseContainer.authorize",
	"Comment": "common code to handle ejb security manager authorization call.",
	"Method": "boolean authorize(EjbInvocation inv){\r\n    if (inv.invocationInfo == null) {\r\n        inv.invocationInfo = getInvocationInfo(inv);\r\n    }\r\n    if ((inv.method.getDeclaringClass() == localBusinessHomeIntf) || (inv.method.getDeclaringClass() == remoteBusinessHomeIntf)) {\r\n        return true;\r\n    }\r\n    boolean authorized = securityManager.authorize(inv);\r\n    if (!authorized) {\r\n        if (inv.context != null) {\r\n            releaseContext(inv);\r\n        }\r\n    }\r\n    return authorized;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.getBigDecimal",
	"Comment": "retrieves the value of a jdbc numeric parameter as ajava.math.bigdecimal object with as many digits to theright of the decimal point as the value contains.",
	"Method": "BigDecimal getBigDecimal(int parameterIndex,int scale,BigDecimal getBigDecimal,int parameterIndex,BigDecimal getBigDecimal,String parameterName){\r\n    return callableStatement.getBigDecimal(parameterName);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.util.ClassPath.classesInPackage",
	"Comment": "return an enumeration of all of the class files in the specified package in this class path.",
	"Method": "Enumeration classesInPackage(String packageName){\r\n    return new ClassPackageEnumeration(this, packageName);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jauth.callback.SecretKeyCallback.getRequest",
	"Comment": "get the request object which identifies the secret key to be returned.",
	"Method": "Request getRequest(){\r\n    return (Request) super.getRequest();\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.node.runtime.GFEjbBundleRuntimeNode.registerBundle",
	"Comment": "register this node as a root node capable of loading entire dd files",
	"Method": "String registerBundle(Map publicIDToDTD){\r\n    publicIDToDTD.put(DTDRegistry.GF_EJBJAR_311_DTD_PUBLIC_ID, DTDRegistry.GF_EJBJAR_311_DTD_SYSTEM_ID);\r\n    return RuntimeTagNames.GF_EJB_RUNTIME_TAG;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.BundleDescriptor.getEntityManagerFactory",
	"Comment": "retrieve the physical entity manager factory associated with theunitname of a persistence unit within this module. returns null ifno matching entry is found.",
	"Method": "EntityManagerFactory getEntityManagerFactory(String unitName){\r\n    return entityManagerFactories.get(unitName);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.PersistenceDescriptor.setPkeyFields",
	"Comment": "set the fielddescriptor objects for primary key fieldsfor this bean.",
	"Method": "void setPkeyFields(Set pkeyFields){\r\n    this.pkeyFields = pkeyFields;\r\n    fieldInfoInitialized = false;\r\n    persFieldInfo = null;\r\n    pkeyStuffInitialized = false;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.CallableStatementWrapper40.getSQLXML",
	"Comment": "retrieves the value of the designated sql xml parameter as ajava.sql.sqlxml object in the java programming language.",
	"Method": "SQLXML getSQLXML(int parameterIndex,SQLXML getSQLXML,String parameterName){\r\n    return callableStatement.getSQLXML(parameterName);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.registry.MonitoredObjectType.getMonitoredObjectTypeOrNull",
	"Comment": "get a monitoredobjecttype instance for the specified string type. if thespecified type is not known, the method returns null.",
	"Method": "MonitoredObjectType getMonitoredObjectTypeOrNull(String typeName){\r\n    MonitoredObjectType type = null;\r\n    if (objectMap != null && typeName != null) {\r\n        type = (MonitoredObjectType) objectMap.get(typeName);\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.PoolLifeCycleRegistry.unRegisterPoolLifeCycle",
	"Comment": "clear the list of pool lifecycle listeners maintained by the registry.this happens when a pool is destroyed so the information about its listeners need not be stored.",
	"Method": "void unRegisterPoolLifeCycle(PoolLifeCycle listener){\r\n    if (lifeCycleListeners != null) {\r\n        if (!lifeCycleListeners.isEmpty()) {\r\n            lifeCycleListeners.remove(listener);\r\n        } else {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.UpdateQueryPlan.addColumn",
	"Comment": "specifies an field the data for which needs to be updated,and the mapped columns for which therefor need to be updated.for update queries the column will be put in the set lists,and for insert queries the column will be put into theinsert values lists.",
	"Method": "void addColumn(LocalFieldDesc fieldDesc,Object value){\r\n    if ((fieldDesc.sqlProperties & FieldDesc.PROP_SECONDARY_TRACKED_FIELD) > 0) {\r\n        return;\r\n    }\r\n    for (Iterator iter = fieldDesc.getColumnElements(); iter.hasNext(); ) {\r\n        ColumnElement columnElement = (ColumnElement) iter.next();\r\n        TableElement tableElement = columnElement.getDeclaringTable();\r\n        if (tableElement == null) {\r\n            throw new JDOFatalInternalException(// NOI18N\r\n            I18NHelper.getMessage(messages, \"core.configuration.fieldnotable\", fieldDesc.getName()));\r\n        }\r\n        QueryTable t = findQueryTable(tableElement);\r\n        UpdateStatement s = null;\r\n        if (t == null) {\r\n            t = addQueryTable(tableElement, null);\r\n            s = (UpdateStatement) addStatement(t);\r\n        } else {\r\n            s = (UpdateStatement) getStatement(t);\r\n        }\r\n        if (fieldDesc.isVersion() && action == ACT_UPDATE) {\r\n            s.addVersionColumn(columnElement);\r\n        } else {\r\n            s.addColumn(columnElement, value);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.MappingPolicy.getOverrideForType",
	"Comment": "provides a string that can be recognized as a policy to override thedefault type of a field.",
	"Method": "String getOverrideForType(String className,String fieldName){\r\n    return className + DOT + fieldName + DOT + DatabaseGenerationConstants.INDICATOR_JDBC_TYPE;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.DeploymentDescriptorNode.writeMessageDestinationRefDescriptors",
	"Comment": "write a list of message destination reference descriptors to a dom tree",
	"Method": "void writeMessageDestinationRefDescriptors(Node parentNode,Iterator msgDestRefs){\r\n    if (msgDestRefs == null || !msgDestRefs.hasNext())\r\n        return;\r\n    MessageDestinationRefNode subNode = new MessageDestinationRefNode();\r\n    for (; msgDestRefs.hasNext(); ) {\r\n        MessageDestinationReferenceDescriptor next = (MessageDestinationReferenceDescriptor) msgDestRefs.next();\r\n        subNode.writeDescriptor(parentNode, TagNames.MESSAGE_DESTINATION_REFERENCE, next);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.getBundleDescriptors",
	"Comment": "obtain a full set of bundle descriptors for a particular type",
	"Method": "Set<T> getBundleDescriptors(Class<T> type,Set<BundleDescriptor> getBundleDescriptors){\r\n    Set<BundleDescriptor> bundleSet = new OrderedSet<BundleDescriptor>();\r\n    for (ModuleDescriptor<BundleDescriptor> aModule : getModules()) {\r\n        BundleDescriptor bundleDesc = aModule.getDescriptor();\r\n        if (bundleDesc != null) {\r\n            bundleSet.add(bundleDesc);\r\n            for (RootDeploymentDescriptor rd : bundleDesc.getExtensionsDescriptors()) {\r\n                if (rd instanceof BundleDescriptor) {\r\n                    bundleSet.add((BundleDescriptor) rd);\r\n                }\r\n            }\r\n        } else {\r\n            DOLUtils.getDefaultLogger().fine(\"Null descriptor for module \" + aModule.getArchiveUri());\r\n        }\r\n    }\r\n    return bundleSet;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.stats.RangeStatisticImpl.getLowWaterMark",
	"Comment": "returns the lowest value of this statistic, since measurement started.",
	"Method": "long getLowWaterMark(){\r\n    return lowWaterMark;\r\n}"
}, {
	"Path": "org.glassfish.apf.AnnotationProcessorException.setFatal",
	"Comment": "sets wether is exception is considered as fatal to the annotation processing.",
	"Method": "void setFatal(boolean fatal){\r\n    this.isFatal = fatal;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.MappingFile.getBean2EntityMappingMap",
	"Comment": "loop through the mappings to create a hash from bean name to em objects",
	"Method": "Map getBean2EntityMappingMap(SunCmpMapping beanSet){\r\n    Map retVal = new HashMap();\r\n    EntityMapping[] entityMappingsInSet = beanSet.getEntityMapping();\r\n    int len = 0;\r\n    if (null != entityMappingsInSet)\r\n        len = entityMappingsInSet.length;\r\n    for (int k = 0; k < len; k++) {\r\n        EntityMapping anEntityMapping = entityMappingsInSet[k];\r\n        String beanName = anEntityMapping.getEjbName();\r\n        beanName.trim().charAt(0);\r\n        retVal.put(beanName, anEntityMapping);\r\n    }\r\n    return retVal;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.hasResolvedResourceReferences",
	"Comment": "returns true if this ejb descriptor has resource references that areresolved.",
	"Method": "boolean hasResolvedResourceReferences(){\r\n    if (!this.getResourceReferenceDescriptors().isEmpty()) {\r\n        return false;\r\n    } else {\r\n        for (Iterator itr = getResourceReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n            ResourceReferenceDescriptor resourceReference = (ResourceReferenceDescriptor) itr.next();\r\n            if (resourceReference.isResolved()) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.isPersistent",
	"Comment": "determines if the specified classname and fieldname pair represent a\tpersistent field.",
	"Method": "boolean isPersistent(String className,boolean isPersistent,String className,ClassLoader classLoader,boolean isPersistent,String className,String fieldName){\r\n    PersistenceFieldElement fieldElement = getPersistenceField(className, fieldName);\r\n    if (fieldElement != null) {\r\n        return (PersistenceFieldElement.PERSISTENT == fieldElement.getPersistenceType());\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.deleteRow",
	"Comment": "deletes the current row from this resultset objectand from the underlying database.this method cannot be called whenthe cursor is on the insert row.",
	"Method": "void deleteRow(){\r\n    resultSet.deleteRow();\r\n}"
}, {
	"Path": "org.glassfish.enterprise.iiop.impl.PEORBConfigurator.setThreadPoolManager",
	"Comment": "called from glassfishorbmanager only when the orb is running on server side",
	"Method": "void setThreadPoolManager(){\r\n    threadpoolMgr = S1ASThreadPoolManager.getThreadPoolManager();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.MappingGenerator.isPropertyDefined",
	"Comment": "returns true if the specified propertyvalue representsa defined value, false otherwise.this implementation returns true if the value is not empty, but subclassesmay override this method to compare to a constant which represents anundefined value.",
	"Method": "boolean isPropertyDefined(String propertyValue){\r\n    return !StringHelper.isEmpty(propertyValue);\r\n}"
}, {
	"Path": "org.glassfish.deployapi.SunDeploymentManager.getNonRunningModules",
	"Comment": "retrieve the list of j2ee application modules distributedto the identified targets and that are currently not running on the associated server or servers.",
	"Method": "TargetModuleID[] getNonRunningModules(ModuleType moduleType,Target[] targetList){\r\n    return getModules(moduleType, targetList, DFDeploymentProperties.NON_RUNNING);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.FieldGroupElement.getFields",
	"Comment": "returns the collection of fields maintained by this holder in the form\tof an array.",
	"Method": "PersistenceFieldElement[] getFields(PersistenceFieldElement[] getFields){\r\n    return getFieldGroupImpl().getFields();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.scope.SymbolTable.enterScope",
	"Comment": "opens a new scope. prepare everything to handle old definitions when a identifier declaration is hidden.",
	"Method": "void enterScope(){\r\n    actualScope++;\r\n    nestings.push(new Nesting());\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.allMechanismsRequireSSL",
	"Comment": "this method determines if all the mechanisms defined in thecsiv2 compoundsecmechlist structure require protectedinvocations.",
	"Method": "boolean allMechanismsRequireSSL(){\r\n    if (iorConfigDescriptors == null || iorConfigDescriptors.isEmpty()) {\r\n        return false;\r\n    }\r\n    for (EjbIORConfigurationDescriptor iorDesc : iorConfigDescriptors) {\r\n        if (EjbIORConfigurationDescriptor.REQUIRED.equalsIgnoreCase(iorDesc.getConfidentiality())) {\r\n            continue;\r\n        } else if (EjbIORConfigurationDescriptor.REQUIRED.equalsIgnoreCase(iorDesc.getConfidentiality())) {\r\n            continue;\r\n        } else if (EjbIORConfigurationDescriptor.REQUIRED.equalsIgnoreCase(iorDesc.getEstablishTrustInTarget())) {\r\n            continue;\r\n        } else if (EjbIORConfigurationDescriptor.REQUIRED.equalsIgnoreCase(iorDesc.getEstablishTrustInClient())) {\r\n            continue;\r\n        }\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.util.JSONUtil.jsonToJava",
	"Comment": "this is the primary switching method which determines the context \tin which the processing should occur.",
	"Method": "Object jsonToJava(String json,Object jsonToJava,JsonChars json){\r\n    Object value = null;\r\n    while (json.hasNext() && (value == null)) {\r\n        char ch = json.next();\r\n        switch(ch) {\r\n            case '{':\r\n                value = readObject(json);\r\n                break;\r\n            case '[':\r\n                value = readArray(json);\r\n                break;\r\n            case '}':\r\n            case ']':\r\n                if (json.isAtContextEnd()) {\r\n                    value = ABORT_PROCESSING;\r\n                } else {\r\n                    throw new IllegalArgumentException(\"Expected '\" + json.peekContextEnd() + \"' but found '\" + json.current() + \"' instead!\");\r\n                }\r\n                break;\r\n            case '-':\r\n            case '0':\r\n            case '1':\r\n            case '2':\r\n            case '3':\r\n            case '4':\r\n            case '5':\r\n            case '6':\r\n            case '7':\r\n            case '8':\r\n            case '9':\r\n                value = readNumber(json);\r\n                break;\r\n            case '\\'':\r\n            case '\"':\r\n                value = readString(json);\r\n                break;\r\n            case 'T':\r\n            case 't':\r\n                value = readConstant(json, \"true\");\r\n                break;\r\n            case 'F':\r\n            case 'f':\r\n                value = readConstant(json, \"false\");\r\n                break;\r\n            case 'N':\r\n            case 'n':\r\n                value = readConstant(json, \"null\");\r\n                break;\r\n            case ' ':\r\n            case '\\t':\r\n            case '\\r':\r\n            case '\\n':\r\n            case '\\b':\r\n            case '\\f':\r\n                break;\r\n            case ':':\r\n                value = COLON;\r\n                break;\r\n            case ',':\r\n                value = COMMA;\r\n                break;\r\n            default:\r\n                throw new IllegalArgumentException(\"Unexpected char '\" + json.current() + \"' near: \" + json.getContext(30) + \"!\");\r\n        }\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.StatefulSessionContainer.releaseContext",
	"Comment": "called from preinvoke which is called from the ejbobject for local andremote invocations.",
	"Method": "void releaseContext(EjbInvocation inv){\r\n    SessionContextImpl sc = (SessionContextImpl) inv.context;\r\n    try {\r\n        if (sc.getState() == BeanState.DESTROYED)\r\n            return;\r\n        Transaction tx = sc.getTransaction();\r\n        if (inv.invocationInfo.removalInfo != null) {\r\n            InvocationInfo invInfo = inv.invocationInfo;\r\n            EjbRemovalInfo removeInfo = invInfo.removalInfo;\r\n            if (retainAfterRemoveMethod(inv, removeInfo)) {\r\n                _logger.log(Level.FINE, \"Skipping destruction of SFSB \" + invInfo.ejbName + \" after @Remove method \" + invInfo.method + \" due to (retainIfException\" + \" == true) and exception \" + inv.exception);\r\n            } else {\r\n                try {\r\n                    destroyBean(inv, sc);\r\n                } catch (Throwable t) {\r\n                    _logger.log(Level.FINE, \"@Remove.preDestroy exception\", t);\r\n                }\r\n                sc.setTransaction(null);\r\n                forceDestroyBean(sc);\r\n                return;\r\n            }\r\n        }\r\n        if (tx == null || tx.getStatus() == Status.STATUS_NO_TRANSACTION) {\r\n            if (sc.getState() != BeanState.READY) {\r\n                if (sc.isAfterCompletionDelayed()) {\r\n                    if (_logger.isLoggable(TRACE_LEVEL)) {\r\n                        logTraceInfo(inv, sc, \"Calling delayed afterCompletion\");\r\n                    }\r\n                    callEjbAfterCompletion(sc, sc.getCompletedTxStatus());\r\n                }\r\n                if (sc.getState() != BeanState.DESTROYED) {\r\n                    sc.setState(BeanState.READY);\r\n                    handleEndOfMethodCheckpoint(sc, inv);\r\n                }\r\n            }\r\n            if ((sc.getState() != BeanState.DESTROYED) && isHAEnabled) {\r\n                syncClientVersion(inv, sc);\r\n            }\r\n        } else {\r\n            if ((sc.getState() != BeanState.DESTROYED) && isHAEnabled) {\r\n                syncClientVersion(inv, sc);\r\n            }\r\n            sc.setState(BeanState.INCOMPLETE_TX);\r\n            if (_logger.isLoggable(TRACE_LEVEL)) {\r\n                logTraceInfo(inv, sc, \"Marking state == INCOMPLETE_TX\");\r\n            }\r\n        }\r\n    } catch (SystemException ex) {\r\n        throw new EJBException(ex);\r\n    } finally {\r\n        releaseSFSBSerializedLock(inv, sc);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.EnhancerClassLoader.findAndEnhanceClass",
	"Comment": "finds and loads the class with the specified name from the url searchpath. any urls referring to jar files are loaded and opened as neededuntil the class is found.",
	"Method": "Class findAndEnhanceClass(String name){\r\n    try {\r\n        if (doTiming) {\r\n            // NOI18N\r\n            Support.timer.push(\"EnhancerClassLoader.findAndEnhanceClass(String)\", \"EnhancerClassLoader.findAndEnhanceClass(\" + name + \")\");\r\n        }\r\n        return (Class) AccessController.doPrivileged(new PrivilegedExceptionAction() {\r\n            public Object run() throws ClassNotFoundException {\r\n                String path = name.replace('.', '/').concat(\".class\");\r\n                Resource res = ucp.getResource(path, false);\r\n                if (res != null) {\r\n                    try {\r\n                        return defineClass(name, res);\r\n                    } catch (IOException e) {\r\n                        final String msg = (\"Exception caught while loading class '\" + name + \"' : \" + e);\r\n                        throw new ClassNotFoundException(msg, e);\r\n                    }\r\n                } else {\r\n                    return null;\r\n                }\r\n            }\r\n        }, acc);\r\n    } catch (PrivilegedActionException pae) {\r\n        throw (ClassNotFoundException) pae.getException();\r\n    } finally {\r\n        if (doTiming) {\r\n            Support.timer.pop();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.EnhancerClassLoader.findAndEnhanceClass",
	"Comment": "finds and loads the class with the specified name from the url searchpath. any urls referring to jar files are loaded and opened as neededuntil the class is found.",
	"Method": "Class findAndEnhanceClass(String name){\r\n    String path = name.replace('.', '/').concat(\".class\");\r\n    Resource res = ucp.getResource(path, false);\r\n    if (res != null) {\r\n        try {\r\n            return defineClass(name, res);\r\n        } catch (IOException e) {\r\n            final String msg = (\"Exception caught while loading class '\" + name + \"' : \" + e);\r\n            throw new ClassNotFoundException(msg, e);\r\n        }\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.EjbIORConfigurationDescriptor.setEstablishTrustInTarget",
	"Comment": "set the value of establishtrustintarget in the transport layer.",
	"Method": "void setEstablishTrustInTarget(String val){\r\n    if (!val.equalsIgnoreCase(NONE) && !val.equalsIgnoreCase(SUPPORTED)) {\r\n        throw new RuntimeException(\"Incorrect value for \" + \"establishTrustInTarget:\" + val);\r\n    }\r\n    establishTrustInTarget = val;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsPositionedUpdate",
	"Comment": "retrieves whether this database supports positioned updatestatements.",
	"Method": "boolean supportsPositionedUpdate(){\r\n    return databaseMetaData.supportsPositionedUpdate();\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBHomeImpl.getEJBMetaData",
	"Comment": "this is the implementation of the javax.ejb.ejbhome method.",
	"Method": "EJBMetaData getEJBMetaData(){\r\n    container.authorizeRemoteMethod(BaseContainer.EJBHome_getEJBMetaData);\r\n    return container.getEJBMetaData();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.PreparedStatementWrapper.setFloat",
	"Comment": "sets the designated parameter to the given java float value.the driver converts thisto an sql float value when it sends it to the database.",
	"Method": "void setFloat(int parameterIndex,float x){\r\n    preparedStatement.setFloat(parameterIndex, x);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingFieldElementImpl.isVersion",
	"Comment": "determines whether this field element is a version field or not.",
	"Method": "boolean isVersion(){\r\n    return _isVersion;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolAppEmitterImpl.connectionUsed",
	"Comment": "fires probe event related to the fact the given connection pool hasgot a connection used event.",
	"Method": "void connectionUsed(){\r\n    poolAppProbeProvider.connectionUsedEvent(poolName, appName);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.util.ResourceValidator.isResourceInDomainXML",
	"Comment": "validate the given resource in the corresponding target using domain.xml server beans.for resources defined outside the application.",
	"Method": "boolean isResourceInDomainXML(String jndiName){\r\n    if (jndiName == null)\r\n        return false;\r\n    Server svr = domain.getServerNamed(target);\r\n    if (svr != null) {\r\n        return svr.isResourceRefExists(jndiName);\r\n    }\r\n    Cluster cluster = domain.getClusterNamed(target);\r\n    return cluster != null && cluster.isResourceRefExists(jndiName);\r\n}"
}, {
	"Path": "org.glassfish.deployapi.SimpleProgressObjectImpl.fireProgressEvent",
	"Comment": "notifies all listeners that have registered interest for progressevent notification.",
	"Method": "void fireProgressEvent(ProgressEvent progressEvent){\r\n    Vector currentListeners = null;\r\n    synchronized (listeners) {\r\n        currentListeners = (Vector) listeners.clone();\r\n        deliveredEvents.add(progressEvent);\r\n    }\r\n    for (Iterator listenersItr = currentListeners.iterator(); listenersItr.hasNext(); ) {\r\n        ((ProgressListener) listenersItr.next()).handleProgressEvent(progressEvent);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.jdbc.pool.monitor.JdbcConnPoolStatsProvider.connectionRequestQueuedEvent",
	"Comment": "when an object is added to wait queue, increment the waitqueuelength.",
	"Method": "void connectionRequestQueuedEvent(String poolName,String appName,String moduleName){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (logger.isLoggable(Level.FINEST)) {\r\n            logger.finest(\"Wait Queue length modified event received - \" + \"poolName = \" + poolName);\r\n        }\r\n        waitQueueLength.increment();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.BundleDescriptor.findReferencedPU0",
	"Comment": "internal method.this method is used to find referenced pu with a given name.it does not accept null or empty unit name.",
	"Method": "PersistenceUnitDescriptor findReferencedPU0(String unitName){\r\n    int separatorIndex = unitName.lastIndexOf(PERSISTENCE_UNIT_NAME_SEPARATOR);\r\n    if (separatorIndex != -1) {\r\n        String unqualifiedUnitName = unitName.substring(separatorIndex + 1);\r\n        String path = unitName.substring(0, separatorIndex);\r\n        String puRoot = getTargetUri(this, path);\r\n        final PersistenceUnitsDescriptor pus = getApplication().getExtensionsDescriptors(PersistenceUnitsDescriptor.class, puRoot);\r\n        if (pus != null) {\r\n            for (PersistenceUnitDescriptor pu : pus.getPersistenceUnitDescriptors()) {\r\n                if (pu.getName().equals(unqualifiedUnitName)) {\r\n                    return pu;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        Map<String, PersistenceUnitDescriptor> visiblePUs = getVisiblePUs();\r\n        PersistenceUnitDescriptor result = visiblePUs.get(unitName);\r\n        if (result != null)\r\n            return result;\r\n        int sameNamedEarScopedPUCount = 0;\r\n        Set<Map.Entry<String, PersistenceUnitDescriptor>> entrySet = visiblePUs.entrySet();\r\n        Iterator<Map.Entry<String, PersistenceUnitDescriptor>> entryIt = entrySet.iterator();\r\n        while (entryIt.hasNext()) {\r\n            Map.Entry<String, PersistenceUnitDescriptor> entry = entryIt.next();\r\n            String s = entry.getKey();\r\n            int idx = s.lastIndexOf(PERSISTENCE_UNIT_NAME_SEPARATOR);\r\n            if (idx != -1 && s.substring(idx + 1).matches(unitName)) {\r\n                result = entry.getValue();\r\n                sameNamedEarScopedPUCount++;\r\n            }\r\n        }\r\n        if (sameNamedEarScopedPUCount == 1) {\r\n            return result;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConnectionPoolAdminServiceImpl.getPropertyValue",
	"Comment": "utility method to get property value from connectordescriptorinfo.",
	"Method": "String getPropertyValue(String prop,ConnectorConnectionPool connectorConnectionPool){\r\n    String result = null;\r\n    ConnectorDescriptorInfo cdi = connectorConnectionPool.getConnectorDescriptorInfo();\r\n    Set mcfConfigProperties = cdi.getMCFConfigProperties();\r\n    Iterator mcfConfPropsIter = mcfConfigProperties.iterator();\r\n    while (mcfConfPropsIter.hasNext()) {\r\n        ConnectorConfigProperty envProp = (ConnectorConfigProperty) mcfConfPropsIter.next();\r\n        if (envProp.getName().toUpperCase(Locale.getDefault()).equals(prop)) {\r\n            result = envProp.getValue();\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolProbeProviderUtil.createJcaProbeProvider",
	"Comment": "create probe provider for jcapool related events.the generated jcapool probe providers are shared by all jca connection pools. each jca connection pool will qualify a probe event with its pool name.",
	"Method": "void createJcaProbeProvider(){\r\n    jcaProbeProvider = new ConnectorConnPoolProbeProvider();\r\n}"
}, {
	"Path": "org.glassfish.loadbalancer.admin.cli.reader.impl.InstanceReaderImpl.getDisableTimeoutInMinutes",
	"Comment": "this is used in quicescing. timeouts after this interval and disables theinstance in the load balancer.",
	"Method": "String getDisableTimeoutInMinutes(){\r\n    if (_serverRef != null) {\r\n        return _serverRef.getDisableTimeoutInMinutes();\r\n    }\r\n    return LoadbalancerReader.DISABLE_TIMEOUT_IN_MINUTES_VALUE;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.introspection.ResourceAdapterAnnotationScanner.isAnnotation",
	"Comment": "test if the passed constant pool string is a reference toa type.type annotation of a j2ee component",
	"Method": "boolean isAnnotation(String value){\r\n    if (annotations == null) {\r\n        synchronized (ResourceAdapterAnnotationScanner.class) {\r\n            if (annotations == null)\r\n                init();\r\n        }\r\n    }\r\n    return annotations.contains(value);\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.TagSupport.setTagInMap",
	"Comment": "this method sets a tag in the given \tmap by the given key.the key is \texpected to be normalized already.",
	"Method": "void setTagInMap(Map<String, List<Tag>> map,String key,Tag tag){\r\n    List<Tag> tagList = map.get(key);\r\n    if (tagList != null) {\r\n        int tagIdx = tagList.indexOf(tag);\r\n        if (tagIdx != -1) {\r\n            tagList.remove(tagIdx);\r\n        }\r\n    } else {\r\n        tagList = new ArrayList<Tag>(1);\r\n        map.put(key, tagList);\r\n    }\r\n    tagList.add(tag);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createFieldCardinalityComponent",
	"Comment": "create a validation component which can check whether the cardinality \tbounds are semantically valid given the relationship field type.",
	"Method": "ValidationComponent createFieldCardinalityComponent(PersistenceFieldElement field){\r\n    return new ValidationComponent() {\r\n        public void validate() throws ModelValidationException {\r\n            if (isLegalRelationship(field)) {\r\n                RelationshipElement relationship = (RelationshipElement) field;\r\n                String fieldName = field.getName();\r\n                boolean nonCollectionRelationship = !isCollection(getClassName(), fieldName);\r\n                int upperBound = (nonCollectionRelationship ? 1 : relationship.getUpperBound());\r\n                int lowerBound = relationship.getLowerBound();\r\n                MappingRelationshipElement mapping = null;\r\n                if ((lowerBound < 0) || (upperBound <= 0) || (lowerBound > upperBound)) {\r\n                    throw constructFieldException(fieldName, \"util.validation.cardinality_invalid\");\r\n                }\r\n                mapping = getMappingRelationship(relationship);\r\n                if (nonCollectionRelationship && (lowerBound != 1) && (mapping != null) && !isJoin(mapping)) {\r\n                    ForeignKeyElement fk = getMatchingFK(mapping);\r\n                    if ((fk != null) && hasNonNullableColumn(fk)) {\r\n                        throw constructFieldException(fieldName, \"util.validation.lower_bound_invalid\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        private boolean hasNonNullableColumn(ForeignKeyElement fk) {\r\n            ColumnElement[] localColumns = fk.getLocalColumns();\r\n            int count = ((localColumns != null) ? localColumns.length : 0);\r\n            for (int i = 0; i < count; i++) {\r\n                if (!localColumns[i].isNullable())\r\n                    return true;\r\n            }\r\n            return false;\r\n        }\r\n        private ForeignKeyElement getMatchingFK(MappingRelationshipElement mapping) {\r\n            MappingClassElement mappingClass = mapping.getDeclaringClass();\r\n            String databaseRoot = getSchemaForClass(getClassName());\r\n            List pairNames = mapping.getColumns();\r\n            List tables = mappingClass.getTables();\r\n            if (tables != null) {\r\n                for (Iterator i = tables.iterator(); i.hasNext(); ) {\r\n                    String tableName = ((MappingTableElement) i.next()).getName();\r\n                    TableElement table = getTable(tableName, databaseRoot);\r\n                    ForeignKeyElement fk = getMatchingFK(pairNames, table);\r\n                    if (fk != null)\r\n                        return fk;\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n        private ForeignKeyElement getMatchingFK(List pairNames, TableElement table) {\r\n            ForeignKeyElement[] foreignKeys = (table != null) ? table.getForeignKeys() : null;\r\n            int count = ((foreignKeys != null) ? foreignKeys.length : 0);\r\n            for (int i = 0; i < count; i++) {\r\n                if (matchesFK(pairNames, foreignKeys[i]))\r\n                    return foreignKeys[i];\r\n            }\r\n            return null;\r\n        }\r\n        private boolean matchesFK(List pairNames, ForeignKeyElement foreignKey) {\r\n            ColumnPairElement[] fkPairs = foreignKey.getColumnPairs();\r\n            int fkCount = ((fkPairs != null) ? fkPairs.length : 0);\r\n            int count = ((pairNames != null) ? pairNames.size() : 0);\r\n            if (fkCount == count) {\r\n                for (int i = 0; i < fkCount; i++) {\r\n                    String fkPairName = NameUtil.getRelativeMemberName(fkPairs[i].getName().getFullName());\r\n                    if (!pairNames.contains(fkPairName))\r\n                        return false;\r\n                }\r\n                return true;\r\n            }\r\n            return false;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createFieldCardinalityComponent",
	"Comment": "create a validation component which can check whether the cardinality \tbounds are semantically valid given the relationship field type.",
	"Method": "ValidationComponent createFieldCardinalityComponent(PersistenceFieldElement field){\r\n    if (isLegalRelationship(field)) {\r\n        RelationshipElement relationship = (RelationshipElement) field;\r\n        String fieldName = field.getName();\r\n        boolean nonCollectionRelationship = !isCollection(getClassName(), fieldName);\r\n        int upperBound = (nonCollectionRelationship ? 1 : relationship.getUpperBound());\r\n        int lowerBound = relationship.getLowerBound();\r\n        MappingRelationshipElement mapping = null;\r\n        if ((lowerBound < 0) || (upperBound <= 0) || (lowerBound > upperBound)) {\r\n            throw constructFieldException(fieldName, \"util.validation.cardinality_invalid\");\r\n        }\r\n        mapping = getMappingRelationship(relationship);\r\n        if (nonCollectionRelationship && (lowerBound != 1) && (mapping != null) && !isJoin(mapping)) {\r\n            ForeignKeyElement fk = getMatchingFK(mapping);\r\n            if ((fk != null) && hasNonNullableColumn(fk)) {\r\n                throw constructFieldException(fieldName, \"util.validation.lower_bound_invalid\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createFieldCardinalityComponent",
	"Comment": "create a validation component which can check whether the cardinality \tbounds are semantically valid given the relationship field type.",
	"Method": "ValidationComponent createFieldCardinalityComponent(PersistenceFieldElement field){\r\n    ColumnElement[] localColumns = fk.getLocalColumns();\r\n    int count = ((localColumns != null) ? localColumns.length : 0);\r\n    for (int i = 0; i < count; i++) {\r\n        if (!localColumns[i].isNullable())\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createFieldCardinalityComponent",
	"Comment": "create a validation component which can check whether the cardinality \tbounds are semantically valid given the relationship field type.",
	"Method": "ValidationComponent createFieldCardinalityComponent(PersistenceFieldElement field){\r\n    MappingClassElement mappingClass = mapping.getDeclaringClass();\r\n    String databaseRoot = getSchemaForClass(getClassName());\r\n    List pairNames = mapping.getColumns();\r\n    List tables = mappingClass.getTables();\r\n    if (tables != null) {\r\n        for (Iterator i = tables.iterator(); i.hasNext(); ) {\r\n            String tableName = ((MappingTableElement) i.next()).getName();\r\n            TableElement table = getTable(tableName, databaseRoot);\r\n            ForeignKeyElement fk = getMatchingFK(pairNames, table);\r\n            if (fk != null)\r\n                return fk;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createFieldCardinalityComponent",
	"Comment": "create a validation component which can check whether the cardinality \tbounds are semantically valid given the relationship field type.",
	"Method": "ValidationComponent createFieldCardinalityComponent(PersistenceFieldElement field){\r\n    ForeignKeyElement[] foreignKeys = (table != null) ? table.getForeignKeys() : null;\r\n    int count = ((foreignKeys != null) ? foreignKeys.length : 0);\r\n    for (int i = 0; i < count; i++) {\r\n        if (matchesFK(pairNames, foreignKeys[i]))\r\n            return foreignKeys[i];\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createFieldCardinalityComponent",
	"Comment": "create a validation component which can check whether the cardinality \tbounds are semantically valid given the relationship field type.",
	"Method": "ValidationComponent createFieldCardinalityComponent(PersistenceFieldElement field){\r\n    ColumnPairElement[] fkPairs = foreignKey.getColumnPairs();\r\n    int fkCount = ((fkPairs != null) ? fkPairs.length : 0);\r\n    int count = ((pairNames != null) ? pairNames.size() : 0);\r\n    if (fkCount == count) {\r\n        for (int i = 0; i < fkCount; i++) {\r\n            String fkPairName = NameUtil.getRelativeMemberName(fkPairs[i].getName().getFullName());\r\n            if (!pairNames.contains(fkPairName))\r\n                return false;\r\n        }\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.setExtensionArchivists",
	"Comment": "set the applicable extension archivists for this archivist",
	"Method": "void setExtensionArchivists(List<ExtensionsArchivist> archivists){\r\n    extensionsArchivists = archivists;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorService.loadConnectorDescriptorForEmbeddedRAR",
	"Comment": "todo v3 with annotations, is it right a approach to load the descriptor using archivist ?",
	"Method": "ConnectorDescriptor loadConnectorDescriptorForEmbeddedRAR(String rarName){\r\n    ResourcesUtil resutil = ResourcesUtil.createInstance();\r\n    String rarFileName = ConnectorAdminServiceUtils.getConnectorModuleName(rarName) + \".rar\";\r\n    return resutil.getConnectorDescriptorFromUri(rarName, rarFileName);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getSecurityBusinessMethodDescriptors",
	"Comment": "returns the full set of security business method descriptors i have.",
	"Method": "Set getSecurityBusinessMethodDescriptors(){\r\n    return getBusinessMethodDescriptors();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.BundleDescriptor.addEntityManagerFactory",
	"Comment": "set the physical entity manager factory for a persistence unitwithin this module.",
	"Method": "void addEntityManagerFactory(String unitName,EntityManagerFactory emf){\r\n    entityManagerFactories.put(unitName, emf);\r\n}"
}, {
	"Path": "org.glassfish.deployapi.ProgressObjectSink.sinkProgressObject",
	"Comment": "register to a new progressobject for progressevent notifications",
	"Method": "void sinkProgressObject(ProgressObject source){\r\n    sources.add(source);\r\n    source.addProgressListener(this);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ApplicationClientDescriptor.getEntityManagerReferenceByName",
	"Comment": "return the entity manager factory reference descriptor corresponding tothe given name.",
	"Method": "EntityManagerReferenceDescriptor getEntityManagerReferenceByName(String name){\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"exceptionappclienthasnoentitymgrrefbyname\", \"This application client [{0}] has no entity manager reference by the name of [{1}]\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStoreManager.executeBatch",
	"Comment": "retrieves the update query plan for the specified request andcalls executeupdatebatch for all statements in this plan.",
	"Method": "void executeBatch(PersistenceManager pm,UpdateObjectDesc request,boolean forceFlush){\r\n    boolean cleanup = true;\r\n    UpdateObjectDescImpl objectRequest = null;\r\n    if (request instanceof UpdateObjectDescImpl) {\r\n        objectRequest = (UpdateObjectDescImpl) request;\r\n    } else {\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, // NOI18N\r\n        \"core.generic.notinstanceof\", request.getClass().getName(), \"UpdateObjectDescImpl\"));\r\n    }\r\n    ClassDesc config = objectRequest.getConfig();\r\n    UpdateQueryPlan plan = config.getUpdateQueryPlan(objectRequest, this);\r\n    Transaction tran = (Transaction) pm.currentTransaction();\r\n    Connection conn = tran.getConnection();\r\n    boolean doFlush = forceFlush || plan.checkBatchThreshold(tran);\r\n    try {\r\n        for (int i = 0, size = plan.statements.size(); i < size; i++) {\r\n            UpdateStatement s = (UpdateStatement) plan.statements.get(i);\r\n            executeUpdateBatch(tran, conn, s, objectRequest, doFlush);\r\n        }\r\n        cleanup = forceFlush;\r\n    } finally {\r\n        if (cleanup)\r\n            closeDBStatements(plan, tran);\r\n        closeConnection(tran, conn);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.Tag.getDisplayName",
	"Comment": "this returns a string that is meaningful to the user \twhich represents the content of this tag instance.",
	"Method": "String getDisplayName(){\r\n    return displayName;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ResourceEnvReferenceDescriptor.checkType",
	"Comment": "performs the same check as in resourcereferencedescriptor",
	"Method": "void checkType(){\r\n    if (refType == null) {\r\n        if (isBoundsChecking()) {\r\n            throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptiontypenotallowedpropertytype\", \"{0} is not an allowed property value type\", new Object[] { \"null\" }));\r\n        }\r\n    }\r\n    if (refType != null) {\r\n        try {\r\n            Class.forName(refType, true, Thread.currentThread().getContextClassLoader());\r\n        } catch (Throwable t) {\r\n            if (isBoundsChecking()) {\r\n                throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptiontypenotallowedpropertytype\", \"{0} is not an allowed property value type\", new Object[] { refType }));\r\n            } else {\r\n                return;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.JavaTypeHelper.valueOf",
	"Comment": "returns the boolean wrapper object for true or false \tcorresponding to the supplied argument.this is to provide a \tconvenience method for this conversion but to prevent calling the \tboolean constructor which has been determined to be unnecessary \tand a performance problem.jdk 1.4 provides such a method, but \tsome of our code still works with jdk 1.3.",
	"Method": "Boolean valueOf(boolean flag){\r\n    return (flag ? Boolean.TRUE : Boolean.FALSE);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.PreparedStatementWrapper40.getResultSet",
	"Comment": "retrieves the current result as a resultset object.this method should be called only once per result.",
	"Method": "java.sql.ResultSet getResultSet(){\r\n    ResultSet rs = preparedStatement.getResultSet();\r\n    if (rs == null)\r\n        return null;\r\n    incrementResultSetReferenceCount();\r\n    return new ResultSetWrapper40(this, rs);\r\n}"
}, {
	"Path": "test.beans.SecondTestEventConditionalObserver.onDocumentCreate",
	"Comment": "should not get called as there is no conversation is in this test",
	"Method": "void onDocumentCreate(Document d){\r\n    System.out.println(\"TestEventObserver:onDocumentCreate\");\r\n    documentCreatedEvent++;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.DeploymentDescriptorNode.writeResourceEnvRefDescriptors",
	"Comment": "write a list of resource env reference descriptors to a dom tree",
	"Method": "void writeResourceEnvRefDescriptors(Node parentNode,Iterator resRefs){\r\n    if (resRefs == null || !resRefs.hasNext())\r\n        return;\r\n    ResourceEnvRefNode subNode = new ResourceEnvRefNode();\r\n    for (; resRefs.hasNext(); ) {\r\n        ResourceEnvReferenceDescriptor aResRef = (ResourceEnvReferenceDescriptor) resRefs.next();\r\n        subNode.writeDescriptor(parentNode, TagNames.RESOURCE_ENV_REFERENCE, aResRef);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.SelectStatement.processJoinOperation",
	"Comment": "generates a join condition for specified jnode. equi joins and nativeouter joins endup in the where clause. ansi compliant outer joinconditions end up in the from clause.",
	"Method": "void processJoinOperation(ConstraintJoin jnode,StringBuffer whereText){\r\n    int opCode = jnode.operation;\r\n    boolean doAnsiJoin = opCode != ActionDesc.OP_EQUIJOIN && !vendorType.isNativeOuterJoin();\r\n    if (doAnsiJoin) {\r\n        generateAnsiJoin(jnode, opCode);\r\n    } else {\r\n        generateJoin(jnode, whereText, opCode);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createInverseFieldComponent",
	"Comment": "create a validation component which can check whether the inverse of \tthe inverse of the relationship is the relationship itself.",
	"Method": "ValidationComponent createInverseFieldComponent(RelationshipElement field){\r\n    return new ValidationComponent() {\r\n        public void validate() throws ModelValidationException {\r\n            Model model = getModel();\r\n            RelationshipElement inverse = field.getInverseRelationship(model);\r\n            RelationshipElement inverseInverse = ((inverse != null) ? inverse.getInverseRelationship(model) : null);\r\n            if ((inverse != null) && (!field.equals(inverseInverse) || (inverseInverse == null))) {\r\n                String fieldName = field.getName();\r\n                throw new ModelValidationException(model.getField(getClassName(), fieldName), I18NHelper.getMessage(getMessages(), \"util.validation.inverse_field_invalid\", new Object[] { fieldName, inverse.getName() }));\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createInverseFieldComponent",
	"Comment": "create a validation component which can check whether the inverse of \tthe inverse of the relationship is the relationship itself.",
	"Method": "ValidationComponent createInverseFieldComponent(RelationshipElement field){\r\n    Model model = getModel();\r\n    RelationshipElement inverse = field.getInverseRelationship(model);\r\n    RelationshipElement inverseInverse = ((inverse != null) ? inverse.getInverseRelationship(model) : null);\r\n    if ((inverse != null) && (!field.equals(inverseInverse) || (inverseInverse == null))) {\r\n        String fieldName = field.getName();\r\n        throw new ModelValidationException(model.getField(getClassName(), fieldName), I18NHelper.getMessage(getMessages(), \"util.validation.inverse_field_invalid\", new Object[] { fieldName, inverse.getName() }));\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.BundleDescriptor.getNamedDescriptorsFrom",
	"Comment": "utility method for iterating the set of named descriptors in the supplied nameenvironment",
	"Method": "Collection getNamedDescriptorsFrom(JndiNameEnvironment nameEnvironment){\r\n    Collection namedDescriptors = new Vector();\r\n    for (Iterator itr = nameEnvironment.getResourceReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        ResourceReferenceDescriptor resourceReference = (ResourceReferenceDescriptor) itr.next();\r\n        namedDescriptors.add(resourceReference);\r\n    }\r\n    for (Iterator itr = nameEnvironment.getEjbReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        EjbReferenceDescriptor ejbReference = (EjbReferenceDescriptor) itr.next();\r\n        namedDescriptors.add(ejbReference);\r\n    }\r\n    for (Iterator itr = nameEnvironment.getResourceEnvReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        ResourceEnvReferenceDescriptor resourceEnvRef = (ResourceEnvReferenceDescriptor) itr.next();\r\n        namedDescriptors.add(resourceEnvRef);\r\n    }\r\n    return namedDescriptors;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.AbstractNameMapper.getEjbFieldForGeneratedField",
	"Comment": "gets the name of the ejb field which corresponds to the specified \tgenerated ejb name and field name pair.",
	"Method": "String[] getEjbFieldForGeneratedField(String name,String fieldName){\r\n    List field = (List) getGeneratedFieldsMap().get(Arrays.asList(new String[] { name, fieldName }));\r\n    return ((field != null) ? (String[]) field.toArray(new String[2]) : null);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.QueryImpl.setIgnoreCache",
	"Comment": "set the ignorecache option.the ignorecache option setting specifies whether the query should executeentirely in the back end, instead of in the cache.",
	"Method": "void setIgnoreCache(boolean ignoreCache){\r\n    synchronized (this.paramtab) {\r\n        this.ignoreCache = ignoreCache;\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.monitoring.JdbcStatsProvider.traceSQLEvent",
	"Comment": "whenever a sql statement that is traced is to be cache for monitoringpurpose, the sqltrace object is created for the specified sql andupdated in the sqltracecache. this is used to update thefrequently used sql queries.",
	"Method": "void traceSQLEvent(String poolName,String appName,String moduleName,String sql){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (sqlTraceCache != null) {\r\n            if (sql != null) {\r\n                SQLTrace cacheObj = new SQLTrace(sql, 1, System.currentTimeMillis());\r\n                sqlTraceCache.checkAndUpdateCache(cacheObj);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ClassDesc.computeTrackedPrimitiveFields",
	"Comment": "computes all the primitive tracked fields.primitive fields track each other if they are mapped to same columns.one of them is made the primary tracked field as per precedence ruleson the field types. this field is used to bind values to columns whileupdating the database.",
	"Method": "void computeTrackedPrimitiveFields(){\r\n    for (int i = 0; i < fields.size(); i++) {\r\n        FieldDesc f = (FieldDesc) fields.get(i);\r\n        if (!f.isRelationshipField()) {\r\n            LocalFieldDesc lf = (LocalFieldDesc) f;\r\n            lf.computeTrackedPrimitiveFields();\r\n            lf.computePrimaryTrackedPrimitiveField();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.connector.ConnectorNode.registerBundle",
	"Comment": "register this node as a root node capable of loading entire dd files",
	"Method": "String registerBundle(Map publicIDToDTD){\r\n    publicIDToDTD.put(DTDRegistry.SUN_CONNECTOR_100_DTD_PUBLIC_ID, DTDRegistry.SUN_CONNECTOR_100_DTD_SYSTEM_ID);\r\n    return RuntimeTagNames.S1AS_CONNECTOR_RUNTIME_TAG;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnectionFactory.getLogWriter",
	"Comment": "get the log writer for this managedconnectionfactory instance.",
	"Method": "java.io.PrintWriter getLogWriter(){\r\n    return logWriter;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.RelationshipElementImpl.isPrefetch",
	"Comment": "determines whether this relationship element should prefetch or not.",
	"Method": "boolean isPrefetch(){\r\n    return _isPrefetch;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.CommonHandlers.initClusterSessionAttribute",
	"Comment": "this handler will be called during initialization when cluster support is detected.",
	"Method": "void initClusterSessionAttribute(HandlerContext handlerCtx){\r\n    Map sessionMap = handlerCtx.getFacesContext().getExternalContext().getSessionMap();\r\n    sessionMap.put(\"appSummaryView\", true);\r\n    sessionMap.put(\"webSummaryView\", true);\r\n    sessionMap.put(\"ejbSummaryView\", true);\r\n    sessionMap.put(\"appclientSummaryView\", true);\r\n    sessionMap.put(\"rarSummaryView\", true);\r\n    sessionMap.put(\"lifecycleSummaryView\", true);\r\n    sessionMap.put(\"adminObjectSummaryView\", true);\r\n    sessionMap.put(\"connectorResSummaryView\", true);\r\n    sessionMap.put(\"customResSummaryView\", true);\r\n    sessionMap.put(\"externalResSummaryView\", true);\r\n    sessionMap.put(\"javaMailSessionSummaryView\", true);\r\n    sessionMap.put(\"jdbcResSummaryView\", true);\r\n    sessionMap.put(\"jmsConnectionSummaryView\", true);\r\n    sessionMap.put(\"jmsDestinationSummaryView\", true);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptorInheritedMethodImplementationTest.testEjbDescriptorInheritedMethodImplementation",
	"Comment": "this method tests if methods inherited from writablejndinameenvironment aredirectly implemented in ejbdescriptor or not and if implemented, methodsare marked final or not.",
	"Method": "void testEjbDescriptorInheritedMethodImplementation(){\r\n    Map<Error, List<Method>> unimplementedMethods = new HashMap<Error, List<Method>>();\r\n    validateWritableJndiNameEnvInterfaceImplementation();\r\n    List<Method> methodsDefinedByWritableJndiNameEnvInterface = Arrays.asList(WritableJndiNameEnvironment.class.getMethods());\r\n    for (Method writableJndiNameEnvMethod : methodsDefinedByWritableJndiNameEnvInterface) {\r\n        try {\r\n            Method ejbDescriptorMethod = EjbDescriptor.class.getDeclaredMethod(writableJndiNameEnvMethod.getName(), writableJndiNameEnvMethod.getParameterTypes());\r\n            if (!Modifier.isFinal(ejbDescriptorMethod.getModifiers())) {\r\n                updateUnimplementedMethodsMap(Error.NON_FINAL_METHOD, ejbDescriptorMethod, unimplementedMethods);\r\n            }\r\n        } catch (NoSuchMethodException e) {\r\n            updateUnimplementedMethodsMap(Error.UNIMPLEMENTED_METHOD, writableJndiNameEnvMethod, unimplementedMethods);\r\n        }\r\n    }\r\n    assertTrue(getErrorMessage(unimplementedMethods), unimplementedMethods.size() == 0);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingClassElementImpl.getDatabaseRoot",
	"Comment": "returns the name of the schemaelement which represents the \tdatabase used by the tables mapped to this mapping class.",
	"Method": "String getDatabaseRoot(){\r\n    return _databaseRoot;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.work.context.WorkContextHandlerImpl.getMostSpecificWorkContextSupported",
	"Comment": "provide the most specific work context support for the work context in question",
	"Method": "Class<? extends WorkContext> getMostSpecificWorkContextSupported(WorkContext ic){\r\n    List<Class> assignableClasses = new ArrayList<Class>();\r\n    for (Class<? extends WorkContext> icClass : containerSupportedContexts) {\r\n        if (icClass.isAssignableFrom(ic.getClass())) {\r\n            assignableClasses.add(icClass);\r\n        }\r\n    }\r\n    assignableClasses = sortBasedOnInheritence(assignableClasses);\r\n    Object[] params = { ic.getClass().getName(), assignableClasses.get(0).getName() };\r\n    logger.log(Level.INFO, RAR_USE_SUPER_WORK_CONTEXT, params);\r\n    return assignableClasses.get(0);\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolProbeProviderUtil.createJdbcProbeProvider",
	"Comment": "create probe provider for jdbcpool related events.the generated jdbcpool probe providers are shared by all jdbc connection pools. each jdbc connection pool will qualify a probe event with its pool name.",
	"Method": "void createJdbcProbeProvider(){\r\n    Collection<ConnectionPoolMonitoringExtension> extensions = habitat.getAllServices(ConnectionPoolMonitoringExtension.class);\r\n    for (ConnectionPoolMonitoringExtension extension : extensions) {\r\n        jdbcProbeProvider = extension.createProbeProvider();\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.setLong",
	"Comment": "sets the designated parameter to the given java long value.the driver converts thisto an sql bigint value when it sends it to the database.",
	"Method": "void setLong(String parameterName,long x){\r\n    callableStatement.setLong(parameterName, x);\r\n}"
}, {
	"Path": "org.glassfish.ejb.mdb.deployment.annotation.handlers.MessageDrivenHandler.createEjbDescriptor",
	"Comment": "create a new ejbdescriptor for a given elementname and annotationinfo.",
	"Method": "EjbDescriptor createEjbDescriptor(String elementName,AnnotationInfo ainfo){\r\n    AnnotatedElement ae = ainfo.getAnnotatedElement();\r\n    EjbMessageBeanDescriptor newDescriptor = new EjbMessageBeanDescriptor();\r\n    Class ejbClass = (Class) ae;\r\n    newDescriptor.setName(elementName);\r\n    newDescriptor.setEjbClassName(ejbClass.getName());\r\n    return newDescriptor;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.MethodHelper.isQueryPrefetchEnabled",
	"Comment": "returns true if prefetch is enabled for the specified\tmethod, false otherwise. prefetch is enabled by default.",
	"Method": "boolean isQueryPrefetchEnabled(Method method){\r\n    boolean enabled = true;\r\n    QueryDescriptor queryDescriptor = getQueryDescriptor(method);\r\n    if (queryDescriptor != null) {\r\n        IASEjbCMPEntityDescriptor cmpDescriptor = (IASEjbCMPEntityDescriptor) getDescriptor();\r\n        PrefetchDisabledDescriptor pdDescriptor = cmpDescriptor.getPrefetchDisabledDescriptor();\r\n        if (pdDescriptor != null) {\r\n            MethodDescriptor methodDescriptor = queryDescriptor.getQueryMethodDescriptor();\r\n            enabled = !pdDescriptor.isPrefetchDisabledFor(methodDescriptor);\r\n        }\r\n    }\r\n    return enabled;\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.CreateJMSHost.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    Config targetConfig = domain.getConfigNamed(target);\r\n    if (targetConfig != null)\r\n        config = targetConfig;\r\n    Server targetServer = domain.getServerNamed(target);\r\n    if (targetServer != null) {\r\n        config = domain.getConfigNamed(targetServer.getConfigRef());\r\n    }\r\n    com.sun.enterprise.config.serverbeans.Cluster cluster = domain.getClusterNamed(target);\r\n    if (cluster != null) {\r\n        config = domain.getConfigNamed(cluster.getConfigRef());\r\n    }\r\n    if (jmsHostName == null) {\r\n        report.setMessage(localStrings.getLocalString(\"create.jms.host.noJmsHost\", \"No JMS Host name specified.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    JmsService jmsservice = config.getExtensionByType(JmsService.class);\r\n    for (JmsHost jmsHost : jmsservice.getJmsHost()) {\r\n        if (jmsHostName.equals(jmsHost.getName())) {\r\n            if (force) {\r\n                ActionReport deleteReport = report.addSubActionsReport();\r\n                ParameterMap parameters = new ParameterMap();\r\n                parameters.set(\"DEFAULT\", jmsHostName);\r\n                parameters.set(\"target\", target);\r\n                commandRunner.getCommandInvocation(\"delete-jms-host\", deleteReport, context.getSubject()).parameters(parameters).execute();\r\n                if (ActionReport.ExitCode.FAILURE.equals(deleteReport.getActionExitCode())) {\r\n                    report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                    return;\r\n                }\r\n                break;\r\n            } else {\r\n                report.setMessage(localStrings.getLocalString(\"create.jms.host.duplicate\", \"A JMS Host named {0} already exists.\", jmsHostName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<JmsService>() {\r\n            public Object run(JmsService param) throws PropertyVetoException, TransactionFailure {\r\n                JmsHost jmsHost = param.createChild(JmsHost.class);\r\n                jmsHost.setAdminPassword(mqpassword);\r\n                jmsHost.setAdminUserName(mquser);\r\n                jmsHost.setName(jmsHostName);\r\n                jmsHost.setHost(mqhost);\r\n                jmsHost.setPort(mqport);\r\n                if (props != null) {\r\n                    for (Map.Entry e : props.entrySet()) {\r\n                        Property prop = jmsHost.createChild(Property.class);\r\n                        prop.setName((String) e.getKey());\r\n                        prop.setValue((String) e.getValue());\r\n                        jmsHost.getProperty().add(prop);\r\n                    }\r\n                }\r\n                param.getJmsHost().add(jmsHost);\r\n                return jmsHost;\r\n            }\r\n        }, jmsservice);\r\n    } catch (TransactionFailure tfe) {\r\n        report.setMessage(localStrings.getLocalString(\"create.jms.host.fail\", \"Unable to create jms host {0}.\", jmsHostName) + \" \" + tfe.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n    }\r\n    report.setMessage(localStrings.getLocalString(\"create.jms.host.success\", \"Jms Host {0} created.\", jmsHostName));\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.CreateJMSHost.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    JmsHost jmsHost = param.createChild(JmsHost.class);\r\n    jmsHost.setAdminPassword(mqpassword);\r\n    jmsHost.setAdminUserName(mquser);\r\n    jmsHost.setName(jmsHostName);\r\n    jmsHost.setHost(mqhost);\r\n    jmsHost.setPort(mqport);\r\n    if (props != null) {\r\n        for (Map.Entry e : props.entrySet()) {\r\n            Property prop = jmsHost.createChild(Property.class);\r\n            prop.setName((String) e.getKey());\r\n            prop.setValue((String) e.getValue());\r\n            jmsHost.getProperty().add(prop);\r\n        }\r\n    }\r\n    param.getJmsHost().add(jmsHost);\r\n    return jmsHost;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlTime.writeReplace",
	"Comment": "use java.sql.time as the designated object to be used when writingthis object to the stream.",
	"Method": "Object writeReplace(){\r\n    return new java.sql.Time(getTime());\r\n}"
}, {
	"Path": "org.glassfish.loadbalancer.admin.cli.CreateHTTPHealthCheckerCommand.createHealthCheckerInternal",
	"Comment": "this is to create a health checker for a cluster configuration. bydefault the healh checker will be configured.this applies onlyto our native load balancer.",
	"Method": "void createHealthCheckerInternal(String url,String interval,String timeout,LbConfig lbConfig,String lbConfigName,String target){\r\n    if (lbConfigName == null) {\r\n        String msg = localStrings.getLocalString(\"InvalidLbConfigName\", \"Invalid LB configuration.\");\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setMessage(msg);\r\n        return;\r\n    }\r\n    lbConfigName = lbConfig.getName();\r\n    if (logger.isLoggable(Level.FINE)) {\r\n        logger.fine(\"[LB-ADMIN] createHealthChecker called - URL \" + url + \", Interval \" + interval + \", Time out \" + timeout + \", LB Config  \" + lbConfigName + \", Target \" + target);\r\n    }\r\n    if (target == null) {\r\n        String msg = localStrings.getLocalString(\"Nulltarget\", \"Null target\");\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setMessage(msg);\r\n        return;\r\n    }\r\n    if (tgt.isCluster(target)) {\r\n        ClusterRef cRef = lbConfig.getRefByRef(ClusterRef.class, target);\r\n        if (cRef == null) {\r\n            String msg = localStrings.getLocalString(\"UnassociatedCluster\", \"Load balancer configuration [{0}] does not have a reference to the given cluster [{1}].\", lbConfigName, target);\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            report.setMessage(msg);\r\n            return;\r\n        }\r\n        if (cRef.getHealthChecker() == null) {\r\n            try {\r\n                addHealthChecker(cRef);\r\n            } catch (TransactionFailure ex) {\r\n                String msg = localStrings.getLocalString(\"FailedToAddHC\", \"Failed to add health checker\");\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                report.setMessage(msg);\r\n                report.setFailureCause(ex);\r\n                return;\r\n            }\r\n            logger.info(localStrings.getLocalString(\"http_lb_admin.HealthCheckerCreated\", \"Health checker created for target {0}\", target));\r\n        } else {\r\n            String msg = localStrings.getLocalString(\"HealthCheckerExists\", \"Health checker server/cluster [{0}] already exists.\", target);\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            report.setMessage(msg);\r\n            return;\r\n        }\r\n    } else if (domain.isServer(target)) {\r\n        ServerRef sRef = lbConfig.getRefByRef(ServerRef.class, target);\r\n        if (sRef == null) {\r\n            String msg = localStrings.getLocalString(\"UnassociatedServer\", \"Load balancer configuration [{0}] does not have a reference to the given server [{1}].\", lbConfigName, target);\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            report.setMessage(msg);\r\n            return;\r\n        }\r\n        if (sRef.getHealthChecker() == null) {\r\n            try {\r\n                addHealthChecker(sRef);\r\n            } catch (TransactionFailure ex) {\r\n                String msg = localStrings.getLocalString(\"FailedToAddHC\", \"Failed to add health checker\");\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                report.setMessage(msg);\r\n                report.setFailureCause(ex);\r\n                return;\r\n            }\r\n            logger.info(localStrings.getLocalString(\"http_lb_admin.HealthCheckerCreated\", \"Health checker created for target {0}\", target));\r\n        } else {\r\n            String msg = localStrings.getLocalString(\"HealthCheckerExists\", \"Health checker server/cluster [{0}] already exists.\", target);\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            report.setMessage(msg);\r\n            return;\r\n        }\r\n    } else {\r\n        String msg = localStrings.getLocalString(\"InvalidTarget\", \"Invalid target\", target);\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setMessage(msg);\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.monitoring.JdbcStatsProvider.potentialStatementLeakEvent",
	"Comment": "whenever statement leak happens, increment numpotentialstatementleak count.",
	"Method": "void potentialStatementLeakEvent(String poolName,String appName,String moduleName){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        numPotentialStatementLeak.increment();\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getDatabaseMinorVersion",
	"Comment": "retrieves the minor version number of the underlying database.",
	"Method": "int getDatabaseMinorVersion(){\r\n    return databaseMetaData.getDatabaseMinorVersion();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingFieldElementImpl.setInConcurrencyCheck",
	"Comment": "set whether this field element is in a concurrency check or not.",
	"Method": "void setInConcurrencyCheck(boolean flag){\r\n    Boolean old = JavaTypeHelper.valueOf(isInConcurrencyCheck());\r\n    Boolean newFlag = JavaTypeHelper.valueOf(flag);\r\n    try {\r\n        fireVetoableChange(PROP_IN_CONCURRENCY_CHECK, old, newFlag);\r\n        setProperty(flag, IN_CONCURRENCY_CHECK);\r\n        firePropertyChange(PROP_IN_CONCURRENCY_CHECK, old, newFlag);\r\n    } catch (PropertyVetoException e) {\r\n        throw new ModelVetoException(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.ConnectionContext.getSSLClientAuthenticationOccurred",
	"Comment": "return true if ssl client authentication has happened, false otherwise.",
	"Method": "boolean getSSLClientAuthenticationOccurred(){\r\n    return sslClientAuth;\r\n}"
}, {
	"Path": "com.sun.enterprise.naming.impl.JavaURLContext.lookupLink",
	"Comment": "this context does not treat links specially. a lookup operation isperformed.",
	"Method": "Object lookupLink(String name,Object lookupLink,Name name){\r\n    return lookupLink(name.toString());\r\n}"
}, {
	"Path": "org.glassfish.resources.admin.cli.ResourcesXMLParser.getResources",
	"Comment": "returns an iterator of resourceobjects in the order as definedin the resources xml configuration file. maintained for backward compat purposes only.",
	"Method": "Iterator<org.glassfish.resources.api.Resource> getResources(){\r\n    return vResources.iterator();\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getAroundTimeoutInterceptors",
	"Comment": "return the ordered list of interceptor info for aroundtimeout behaviorof a particular business method.this listinclude the infoon any bean class interceptor.if present, this would always be thelast element in the list because of the precedence defined by the spec.",
	"Method": "List<EjbInterceptor> getAroundTimeoutInterceptors(MethodDescriptor businessMethod){\r\n    LinkedList<EjbInterceptor> aroundTimeoutInterceptors = new LinkedList<EjbInterceptor>();\r\n    List<EjbInterceptor> classOrMethodInterceptors = getClassOrMethodInterceptors(businessMethod);\r\n    for (EjbInterceptor next : classOrMethodInterceptors) {\r\n        if (next.getAroundTimeoutDescriptors().size() > 0) {\r\n            aroundTimeoutInterceptors.add(next);\r\n        }\r\n    }\r\n    if (hasAroundTimeoutMethod()) {\r\n        EjbInterceptor interceptorInfo = new EjbInterceptor();\r\n        interceptorInfo.setFromBeanClass(true);\r\n        interceptorInfo.addAroundTimeoutDescriptors(getAroundTimeoutDescriptors());\r\n        interceptorInfo.setInterceptorClassName(getEjbImplClassName());\r\n        aroundTimeoutInterceptors.add(interceptorInfo);\r\n    }\r\n    return aroundTimeoutInterceptors;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.WeakHashSet.iterator",
	"Comment": "returns an iterator over the elements in this set.the elementsare returned in no particular order.",
	"Method": "Iterator iterator(){\r\n    processQueue();\r\n    final Iterator i = super.iterator();\r\n    return new Iterator() {\r\n        public boolean hasNext() {\r\n            return i.hasNext();\r\n        }\r\n        public Object next() {\r\n            return getReferenceObject((WeakReference) i.next());\r\n        }\r\n        public void remove() {\r\n            i.remove();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.WeakHashSet.iterator",
	"Comment": "returns an iterator over the elements in this set.the elementsare returned in no particular order.",
	"Method": "Iterator iterator(){\r\n    return i.hasNext();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.WeakHashSet.iterator",
	"Comment": "returns an iterator over the elements in this set.the elementsare returned in no particular order.",
	"Method": "Iterator iterator(){\r\n    return getReferenceObject((WeakReference) i.next());\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.WeakHashSet.iterator",
	"Comment": "returns an iterator over the elements in this set.the elementsare returned in no particular order.",
	"Method": "Iterator iterator(){\r\n    i.remove();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.Vector.remove",
	"Comment": "removes the first occurrence of the specified element in this vectorif the vector does not contain the element, it is unchanged.",
	"Method": "boolean remove(Object o,Object remove,int index){\r\n    throwUnsupportedOption();\r\n    StateManager stateManager = this.makeDirty();\r\n    Object obj = super.remove(index);\r\n    if (added.remove(obj) == false)\r\n        removed.add(obj);\r\n    this.applyUpdates(stateManager, true);\r\n    return obj;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.help.HelpTreeIndexAdaptor.getInstance",
	"Comment": "this method provides access to an helptreeadaptor \tinstance.each time it is invoked, it returns a new instance.",
	"Method": "TreeAdaptor getInstance(FacesContext ctx,LayoutComponent desc,UIComponent parent){\r\n    return new HelpTreeIndexAdaptor(desc, parent);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.module.ConnectorApplication.getDescriptor",
	"Comment": "returns the deployment descriptor associated with this application",
	"Method": "Object getDescriptor(){\r\n    return descriptor;\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecurityMechanismSelector.getSSLPort",
	"Comment": "this method determines if ssl should be used to connect to thetarget based on client and target policies. it will return null ifssl should not be used or an socketinfo containing the ssl portif ssl should be used.",
	"Method": "SocketInfo getSSLPort(IOR ior,ConnectionContext ctx){\r\n    SocketInfo info = null;\r\n    CompoundSecMech mechanism = null;\r\n    try {\r\n        mechanism = selectSecurityMechanism(ior);\r\n    } catch (SecurityMechanismException sme) {\r\n        throw new RuntimeException(sme.getMessage());\r\n    }\r\n    ctx.setIOR(ior);\r\n    ctx.setMechanism(mechanism);\r\n    TLS_SEC_TRANS ssl = null;\r\n    if (mechanism != null) {\r\n        ssl = getCtc().getSSLInformation(mechanism);\r\n    }\r\n    if (ssl == null) {\r\n        if (isSslRequired()) {\r\n            IIOPProfileTemplate templ = (IIOPProfileTemplate) ior.getProfile().getTaggedProfileTemplate();\r\n            IIOPAddress addr = templ.getPrimaryAddress();\r\n            info = IORToSocketInfoImpl.createSocketInfo(\"SecurityMechanismSelector1\", \"SSL\", addr.getHost(), orbHelper.getORBPort(orbHelper.getORB()));\r\n            return info;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n    int targetRequires = ssl.target_requires;\r\n    int targetSupports = ssl.target_supports;\r\n    if (isSet(targetRequires, Integrity.value) || isSet(targetRequires, Confidentiality.value) || isSet(targetRequires, EstablishTrustInClient.value)) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Target requires SSL\");\r\n        }\r\n        ctx.setSSLUsed(true);\r\n        String type = \"SSL\";\r\n        if (isSet(targetRequires, EstablishTrustInClient.value)) {\r\n            type = \"SSL_MUTUALAUTH\";\r\n            ctx.setSSLClientAuthenticationOccurred(true);\r\n        }\r\n        short sslport = ssl.addresses[0].port;\r\n        int ssl_port = Utility.shortToInt(sslport);\r\n        String host_name = ssl.addresses[0].host_name;\r\n        info = IORToSocketInfoImpl.createSocketInfo(\"SecurityMechanismSelector2\", type, host_name, ssl_port);\r\n        return info;\r\n    } else if (isSet(targetSupports, Integrity.value) || isSet(targetSupports, Confidentiality.value) || isSet(targetSupports, EstablishTrustInClient.value)) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Target supports SSL\");\r\n        }\r\n        if (isSslRequired()) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"Client is configured to require SSL for the target\");\r\n            }\r\n            ctx.setSSLUsed(true);\r\n            short sslport = ssl.addresses[0].port;\r\n            String host_name = ssl.addresses[0].host_name;\r\n            int ssl_port = Utility.shortToInt(sslport);\r\n            info = IORToSocketInfoImpl.createSocketInfo(\"SecurityMechanismSelector3\", \"SSL\", host_name, ssl_port);\r\n            return info;\r\n        } else {\r\n            return null;\r\n        }\r\n    } else if (isSslRequired()) {\r\n        throw new RuntimeException(\"SSL required by client but not supported by server.\");\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.XAResourceImpl.setTransactionTimeout",
	"Comment": "set the current transaction timeout value for this xaresource instance.",
	"Method": "boolean setTransactionTimeout(int seconds){\r\n    return xar.setTransactionTimeout(seconds);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.isDefaultFetchGroup",
	"Comment": "determines if the specified classname and fieldname pair represent a\tfield which is part of the default fetch group.",
	"Method": "boolean isDefaultFetchGroup(String className,String fieldName){\r\n    MappingClassElement mappingClass = getMappingClass(className);\r\n    try {\r\n        return (MappingFieldElement.GROUP_DEFAULT == mappingClass.getField(fieldName).getFetchGroup());\r\n    } catch (Exception e) {\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.admingui.plugin.ConsolePluginService.getHelpTOC",
	"Comment": "this method returns a merged table of contents for all found help \tsets for the given locale.",
	"Method": "TOC getHelpTOC(String locale){\r\n    if (locale == null) {\r\n        locale = \"en\";\r\n    }\r\n    TOC mergedTOC = helpSetMap.get(locale);\r\n    if (mergedTOC != null) {\r\n        return mergedTOC;\r\n    }\r\n    Map<String, List<URL>> mapUrls = getResources(locale + \"/help/toc.xml\");\r\n    ConfigParser parser = new ConfigParser(habitat);\r\n    mergedTOC = new TOC();\r\n    mergedTOC.setTOCItems(new ArrayList<TOCItem>());\r\n    mergedTOC.setVersion(\"2.0\");\r\n    String id = null;\r\n    String prefix = \"/\" + locale + \"/help/\";\r\n    List<URL> urls = null;\r\n    for (Map.Entry<String, List<URL>> entry : mapUrls.entrySet()) {\r\n        id = entry.getKey();\r\n        urls = entry.getValue();\r\n        for (URL url : urls) {\r\n            DomDocument doc = parser.parse(url);\r\n            TOC toc = (TOC) doc.getRoot().get();\r\n            for (TOCItem item : toc.getTOCItems()) {\r\n                insertTOCItem(mergedTOC.getTOCItems(), item, id + prefix);\r\n            }\r\n        }\r\n    }\r\n    return mergedTOC;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ApplicationClientDescriptor.getResourceEnvReferenceByName",
	"Comment": "return a resource environment reference by the same name or throw an illegalargumentexception.",
	"Method": "ResourceEnvReferenceDescriptor getResourceEnvReferenceByName(String name){\r\n    for (Iterator itr = this.getResourceEnvReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        ResourceEnvReferenceDescriptor jdr = (ResourceEnvReferenceDescriptor) itr.next();\r\n        if (jdr.getName().equals(name)) {\r\n            return jdr;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionappclienthasnoesourceenvrefbyname\", \"This application client [{0}] has no resource environment reference by the name of [{1}]\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "org.glassfish.ejb.persistent.timer.PersistentEJBTimerService._notifyContainers",
	"Comment": "the portion of timer migration that notifies containers about automatic timers being migrated to this instance",
	"Method": "void _notifyContainers(Set<TimerState> timers){\r\n    for (TimerState timer : timers) {\r\n        EJBTimerSchedule ts = timer.getTimerSchedule();\r\n        if (ts != null && ts.isAutomatic()) {\r\n            addToSchedules(timer.getContainerId(), getPrimaryKey(timer), ts);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jaspic.config.factory.BaseAuthConfigFactory.getRegistrationIDs",
	"Comment": "get the registration identifiers for all registrations of theprovider instance at the factory.",
	"Method": "String[] getRegistrationIDs(AuthConfigProvider provider){\r\n    rLock.lock();\r\n    try {\r\n        Collection<String> regisIDs = null;\r\n        if (provider != null) {\r\n            regisIDs = provider2IdsMap.get(provider);\r\n        } else {\r\n            Collection<List<String>> collList = provider2IdsMap.values();\r\n            if (collList != null) {\r\n                regisIDs = new HashSet<String>();\r\n                for (List<String> listIds : collList) {\r\n                    if (listIds != null) {\r\n                        regisIDs.addAll(listIds);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return ((regisIDs != null) ? regisIDs.toArray(new String[regisIDs.size()]) : new String[0]);\r\n    } finally {\r\n        rLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.QueryImpl.clearPersistenceManager",
	"Comment": "this method clears the persistencemanager and the candidatecollection fields. then this query instance cannot be executed anymore, but it might be used to create a new equivalent query instance by passing this query instance to persistencemanager newquery method taking a compiled query.this method effectively disconnects the persistencemanager allowing it to be garbage collected.",
	"Method": "void clearPersistenceManager(){\r\n    this.pm = null;\r\n    this.candidateCollection = null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.ClassFile.addMethod",
	"Comment": "add a method to the list of the methods which the class defines",
	"Method": "void addMethod(ClassMethod method){\r\n    classMethods.addElement(method);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConnectionPoolAdminServiceImpl.getResourceAdapter",
	"Comment": "returns the resource adapter object correspondingto the pool",
	"Method": "ActiveResourceAdapter getResourceAdapter(ConnectorConnectionPool connectorConnectionPool){\r\n    String rarName = connectorConnectionPool.getConnectorDescriptorInfo().getRarName();\r\n    ActiveResourceAdapter activeResourceAdapter = getActiveResourceAdapter(rarName);\r\n    if (activeResourceAdapter == null) {\r\n        String i18nMsg = localStrings.getString(\"ccp_adm.active_ra_not_init\", rarName);\r\n        ConnectorRuntimeException cre = new ConnectorRuntimeException(i18nMsg);\r\n        _logger.log(Level.SEVERE, \"rardeployment.resourceadapter_not_initialized\", rarName);\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"\", cre);\r\n        }\r\n        throw cre;\r\n    }\r\n    return activeResourceAdapter;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.SelectQueryPlan.addCorrelatedExistsQuery",
	"Comment": "adds a subquery constraint for a correlated exists query to theconstraint stack. also add the table alias from the subqueryto the local table aliases.",
	"Method": "void addCorrelatedExistsQuery(ForeignFieldDesc ff,int operation){\r\n    Class classType = (ff.cardinalityUPB > 1) ? ff.getComponentType() : ff.getType();\r\n    RetrieveDescImpl rd = (RetrieveDescImpl) store.getRetrieveDesc(classType);\r\n    SelectQueryPlan subqueryPlan = new CorrelatedExistSelectPlan(rd, store, ff, this);\r\n    subqueryPlan.build();\r\n    addQueryTables(subqueryPlan.tables);\r\n    ConstraintSubquery subqueryConstraint = new ConstraintSubquery();\r\n    subqueryConstraint.operation = operation;\r\n    subqueryConstraint.plan = subqueryPlan;\r\n    constraint.stack.add(subqueryConstraint);\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecurityContextUtil.getSecurityContext",
	"Comment": "this is called by the csiv2 interceptor on the client beforesending the iiop message.",
	"Method": "SecurityContext getSecurityContext(org.omg.CORBA.Object effective_target){\r\n    SecurityContext context = null;\r\n    assert (orbHelper != null);\r\n    IOR ior = ((com.sun.corba.ee.spi.orb.ORB) orbHelper.getORB()).getIOR(effective_target, false);\r\n    if (StubAdapter.isStub(effective_target)) {\r\n        if (StubAdapter.isLocal(effective_target)) {\r\n            ConnectionExecutionContext.setClientThreadID(Thread.currentThread().getId());\r\n            return null;\r\n        }\r\n    }\r\n    try {\r\n        context = sms.selectSecurityContext(ior);\r\n    } catch (InvalidMechanismException ime) {\r\n        _logger.log(Level.SEVERE, \"iiop.invalidmechanism_exception\", ime);\r\n        throw new InvalidMechanismException(ime.getMessage());\r\n    } catch (InvalidIdentityTokenException iite) {\r\n        _logger.log(Level.SEVERE, \"iiop.invalididtoken_exception\", iite);\r\n        throw new InvalidIdentityTokenException(iite.getMessage());\r\n    } catch (SecurityMechanismException sme) {\r\n        _logger.log(Level.SEVERE, \"iiop.secmechanism_exception\", sme);\r\n        throw new RuntimeException(sme.getMessage());\r\n    }\r\n    return context;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.Environment.findClass",
	"Comment": "look for the specified class in the class map.if not there,use the class path to find the class.if still not found,return false.",
	"Method": "ClassControl findClass(String className){\r\n    ClassControl cc = (ClassControl) classMap.get(className);\r\n    if ((cc == null) && (missingClasses.get(className) == null)) {\r\n        cc = lookupClass(className);\r\n        if (cc != null) {\r\n            message(\"Reading class \" + cc.userClassName() + \" from \" + cc.sourceName());\r\n            classMap.put(className, cc);\r\n        } else {\r\n            missingClasses.put(className, className);\r\n        }\r\n    }\r\n    return cc;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ConnectionWrapper40.prepareStatement",
	"Comment": "creates apreparedstatementobject for sendingparamterized sql statements to database",
	"Method": "PreparedStatement prepareStatement(String sql,PreparedStatement prepareStatement,String sql,int autoGeneratedKeys,PreparedStatement prepareStatement,String sql,int[] columnIndexes,PreparedStatement prepareStatement,String sql,int resultSetType,int resultSetConcurrency,PreparedStatement prepareStatement,String sql,int resultSetType,int resultSetConcurrency,int resultSetHoldability,PreparedStatement prepareStatement,String sql,String[] columnNames){\r\n    checkValidity();\r\n    jdbcPreInvoke();\r\n    return mc.prepareCachedStatement(this, sql, columnNames);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.getLocalTransaction",
	"Comment": "returns an localtransactionimpl instance. the localtransactionimpl interfaceis used by the container to manage local transactions for a rm instance.",
	"Method": "javax.resource.spi.LocalTransaction getLocalTransaction(){\r\n    logFine(\"In getLocalTransaction\");\r\n    checkIfValid();\r\n    return new com.sun.gjc.spi.LocalTransactionImpl(this);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.jqlc.ParameterTable.getIndexForParamName",
	"Comment": "returns the parameter index for the specified parameter name.",
	"Method": "Integer getIndexForParamName(String paramName){\r\n    return new Integer(names.indexOf(paramName));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.ClassType.isOrderable",
	"Comment": "returns whether this represents a type with andefined order.",
	"Method": "boolean isOrderable(){\r\n    Type comparable = typetab.checkType(\"java.lang.Comparable\");\r\n    return isCompatibleWith(comparable);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.model.util.NameMapper.getBundleDescriptor",
	"Comment": "gets the ejbbundledescriptor which defines the universe of\tnames for this application.",
	"Method": "EjbBundleDescriptorImpl getBundleDescriptor(){\r\n    return _bundleDescriptor;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.util.ClassFileSource.unpackagedName",
	"Comment": "return the name of the class, ignoring any leading package specification.",
	"Method": "String unpackagedName(String className){\r\n    int idx = className.lastIndexOf((int) '/');\r\n    if (idx < 0)\r\n        return className;\r\n    return className.substring(idx + 1);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.stats.RangeStatisticImpl.getHighWaterMark",
	"Comment": "returns the highest value of this statistic, since measurement started.",
	"Method": "long getHighWaterMark(){\r\n    return highWaterMark;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getEnvironmentPropertyByName",
	"Comment": "returns the environment property object searching on the supplied key.throws an illegal argument exception if no such environment propertyexists.",
	"Method": "EnvironmentProperty getEnvironmentPropertyByName(String name){\r\n    if (env != null)\r\n        return env.getEnvironmentPropertyByName(name);\r\n    for (Iterator itr = this.getEnvironmentProperties().iterator(); itr.hasNext(); ) {\r\n        EnvironmentProperty ev = (EnvironmentProperty) itr.next();\r\n        if (ev.getName().equals(name)) {\r\n            return ev;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionbeanhasnoenvpropertybyname\", \"This bean {0} has no environment property by the name of {1}\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.ExtensionsArchivist.writeStandardDeploymentDescriptors",
	"Comment": "writes the standard deployment descriptors to an abstract archive",
	"Method": "void writeStandardDeploymentDescriptors(Archivist main,BundleDescriptor descriptor,WritableArchive out){\r\n    getStandardDDFile(descriptor).setArchiveType(main.getModuleType());\r\n    OutputStream os = out.putNextEntry(standardDD.getDeploymentDescriptorPath());\r\n    standardDD.write(descriptor, os);\r\n    out.closeEntry();\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.PoolLifeCycleListenerRegistry.unRegisterPoolLifeCycleListener",
	"Comment": "clear the list of pool lifecycle listeners maintained by the registry.this happens when a pool is destroyed so the information about its listeners need not be stored.",
	"Method": "void unRegisterPoolLifeCycleListener(PoolInfo poolInfo){\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (poolListenersList != null && !poolListenersList.isEmpty()) {\r\n            poolListenersList.clear();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.cditest.user.impl.UserServiceImpl.addUser",
	"Comment": "add a new userthe implementation must ensure that the provided user object is persistedbefore returning the assigned persistent user id.",
	"Method": "Long addUser(User user){\r\n    LOG.log(Level.INFO, \"Storing user {0}\", user);\r\n    return new Long(123);\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.ext.EmptyExtendedResponse.getEncodedValue",
	"Comment": "since the response has no defined value, null is alwaysreturned.",
	"Method": "byte[] getEncodedValue(){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.EnvironmentProperty.print",
	"Comment": "returns a string representation of this environment property.",
	"Method": "void print(StringBuffer toStringBuffer){\r\n    toStringBuffer.append(\"Env-Prop: \").append(super.getName()).append(\"@\");\r\n    printInjectableResourceInfo(toStringBuffer);\r\n    toStringBuffer.append(\"@\").append(this.getType()).append(\"@\").append(this.getValue()).append(\"@\").append(\"@\").append(super.getDescription());\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.visit",
	"Comment": "visit the descriptor and all sub descriptors with a dol visitor implementation",
	"Method": "void visit(DescriptorVisitor aVisitor){\r\n    if (aVisitor instanceof EjbBundleVisitor || aVisitor instanceof ComponentPostVisitor) {\r\n        visit((ComponentVisitor) aVisitor);\r\n    } else {\r\n        super.visit(aVisitor);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.MethodAction.needsAnnotation",
	"Comment": "returns true if any code annotations need to be performed onthis method.",
	"Method": "boolean needsAnnotation(){\r\n    return annotater.needsAnnotation();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.utility.NumericConverterImpl.toBigInteger",
	"Comment": "to convert number other than bigdecimal, double and float to biginteger.",
	"Method": "BigInteger toBigInteger(BigDecimal bDecimal,BigInteger toBigInteger,Double d,BigInteger toBigInteger,Float f,BigInteger toBigInteger,Number n){\r\n    return (n == null) ? null : BigInteger.valueOf(n.longValue());\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.AbstractNameMapper.getGeneratedFieldForEjbField",
	"Comment": "gets the name of the generated field in the ejb which corresponds to \tthe specified ejb name and field name pair.",
	"Method": "String[] getGeneratedFieldForEjbField(String name,String fieldName){\r\n    List field = (List) getInverseFieldsMap().get(Arrays.asList(new String[] { name, fieldName }));\r\n    return ((field != null) ? (String[]) field.toArray(new String[2]) : null);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getLong",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object asa long in the java programming language.",
	"Method": "long getLong(int columnIndex,long getLong,String columnName){\r\n    return resultSet.getLong(columnName);\r\n}"
}, {
	"Path": "org.glassfish.loadbalancer.admin.cli.helper.LbConfigHelper.exportOtdProperties",
	"Comment": "exports the otd.properties from the config to the outputstream provided",
	"Method": "void exportOtdProperties(LoadbalancerReader lbRdr,OutputStream out){\r\n    Loadbalancer _lb = new Loadbalancer();\r\n    Properties props = new Properties();\r\n    String CLUSTER = \"cluster\";\r\n    String LISTENER = \"listeners\";\r\n    String WEB = \"web-modules\";\r\n    String SEPARATOR = \".\";\r\n    StringBuffer buffer = new StringBuffer();\r\n    LoadbalancerVisitor lbVstr = new LoadbalancerVisitor(_lb);\r\n    lbRdr.accept(lbVstr);\r\n    ClusterReader[] clusterReaders = lbRdr.getClusters();\r\n    buffer.append(\"otd.properties\");\r\n    for (int i = 0; i < clusterReaders.length; i++) {\r\n        StringBuffer clusterHostList = new StringBuffer();\r\n        String clusterWebList = \"\";\r\n        ClusterReader clusterReader = clusterReaders[i];\r\n        String clusterName = clusterReader.getName();\r\n        WebModuleReader[] webmoduleReaders = clusterReader.getWebModules();\r\n        InstanceReader[] instanceReaders = clusterReader.getInstances();\r\n        for (int j = 0; j < instanceReaders.length; j++) {\r\n            InstanceReader instanceReader = instanceReaders[j];\r\n            String listenerHost = \"\";\r\n            String listenerPort = \"\";\r\n            StringTokenizer st = new StringTokenizer(instanceReader.getListeners(), \" \");\r\n            while (st.hasMoreElements()) {\r\n                String listener = st.nextToken();\r\n                if (listener.contains(\"http://\")) {\r\n                    listenerHost = listener.substring(listener.lastIndexOf(\"/\") + 1, listener.lastIndexOf(\":\"));\r\n                    listenerPort = listener.substring(listener.lastIndexOf(\":\") + 1, listener.length());\r\n                    break;\r\n                }\r\n            }\r\n            clusterHostList = clusterHostList.append(j > 0 ? \",\" : \"\").append(listenerHost).append(\":\").append(listenerPort);\r\n        }\r\n        props.setProperty(CLUSTER + SEPARATOR + clusterName + SEPARATOR + LISTENER, clusterHostList.toString());\r\n        for (int m = 0; m < webmoduleReaders.length; m++) {\r\n            clusterWebList = clusterWebList + (m > 0 ? \",\" : \"\") + webmoduleReaders[m].getContextRoot();\r\n        }\r\n        props.setProperty(CLUSTER + SEPARATOR + clusterName + SEPARATOR + WEB, clusterWebList);\r\n    }\r\n    try {\r\n        props.store(out, buffer.toString());\r\n    } finally {\r\n        if (out != null) {\r\n            out.close();\r\n            out = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.TagSupport.addTag",
	"Comment": "this method adds a tag for the given tagviewid and \tuser.if the tagviewid is new, it will store the \tgiven displayname.",
	"Method": "void addTag(String tagName,String tagViewId,String displayName,String user){\r\n    if (tagName == null) {\r\n        throw new IllegalArgumentException(\"You cannot add a tag with a null name!\");\r\n    }\r\n    if (tagViewId == null) {\r\n        throw new IllegalArgumentException(\"You cannot tag a page which does not have an ID!\");\r\n    }\r\n    tagViewId = normalizeTagViewId(tagViewId);\r\n    if (user == null) {\r\n        user = \"anonymous\";\r\n    }\r\n    Tag theTag = null;\r\n    List<Tag> tags = queryTags(tagName, tagViewId, (String) null);\r\n    if ((tags != null) && (tags.size() > 0)) {\r\n        theTag = tags.get(0);\r\n        if (theTag.containsUser(user)) {\r\n            return;\r\n        }\r\n        theTag.addUser(user);\r\n    } else {\r\n        theTag = new Tag(tagName, tagViewId, displayName, user);\r\n    }\r\n    setTag(theTag);\r\n}"
}, {
	"Path": "com.sun.jdbcra.common.DataSourceSpec.equals",
	"Comment": "checks whether two datasourcespec objectsare equal or not.",
	"Method": "boolean equals(Object obj){\r\n    if (obj instanceof DataSourceSpec) {\r\n        return this.details.equals(((DataSourceSpec) obj).details);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.jdbc.admin.cli.ListJdbcResources.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        Collection<JdbcResource> jdbcResources = domain.getResources().getResources(JdbcResource.class);\r\n        List<Map<String, String>> resourcesList = new ArrayList<Map<String, String>>();\r\n        List<DefaultResourceProxy> drps = habitat.getAllServices(DefaultResourceProxy.class);\r\n        for (JdbcResource jdbcResource : jdbcResources) {\r\n            String jndiName = jdbcResource.getJndiName();\r\n            if (bindableResourcesHelper.resourceExists(jndiName, target)) {\r\n                ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n                part.setMessage(jndiName);\r\n                Map<String, String> resourceNameMap = new HashMap<String, String>();\r\n                String logicalName = DefaultResourceProxy.Util.getLogicalName(drps, jndiName);\r\n                if (logicalName != null) {\r\n                    resourceNameMap.put(\"logical-jndi-name\", logicalName);\r\n                }\r\n                resourceNameMap.put(\"name\", jndiName);\r\n                resourcesList.add(resourceNameMap);\r\n            }\r\n        }\r\n        Properties extraProperties = new Properties();\r\n        extraProperties.put(\"jdbcResources\", resourcesList);\r\n        report.setExtraProperties(extraProperties);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.jdbc.resources.failed\", \"List JDBC resources failed\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.BundleDescriptor.getTargetUri",
	"Comment": "get the uri of a target based on a source module and a a relative urifrom the perspective of that source module.",
	"Method": "String getTargetUri(BundleDescriptor origin,String relativeTargetUri){\r\n    try {\r\n        String archiveUri = origin.getModuleDescriptor().getArchiveUri();\r\n        return new URI(archiveUri).resolve(relativeTargetUri).getPath();\r\n    } catch (URISyntaxException use) {\r\n        throw new RuntimeException(use);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingRelationshipElementImpl.setAssociatedColumns",
	"Comment": "set the list of associated column names to which this mapping field is\tmapped.this method should only be used internally and for cloning\tand archiving.",
	"Method": "void setAssociatedColumns(ArrayList associatedColumns){\r\n    _associatedColumns = associatedColumns;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.FieldInfo.getFieldNumber",
	"Comment": "return the field number in the case of a field of a persistence capable class.",
	"Method": "int getFieldNumber(){\r\n    if (pfe != null) {\r\n        int index = pfe.getFieldNumber();\r\n        if (index < 0)\r\n            throw new JDOFatalInternalException(// NO18N\r\n            I18NHelper.getMessage(messages, \"query.util.type.fieldinfo.getfieldnumber.invalidfieldno\", String.valueOf(index), name));\r\n        return index;\r\n    } else {\r\n        throw new JDOFatalInternalException(// NO18N\r\n        I18NHelper.getMessage(messages, \"query.util.type.fieldinfo.getfieldnumber.missingfieldelement\", name));\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.ApplicationFactory.openArchive",
	"Comment": "open a jar file with the default archivists and return an applicationobject for the modules contained in the archive.if the archive is a standalone module, this api willcreate an empty application and add the standalone module to it",
	"Method": "Application openArchive(URI jarFile,String archiveType,Application openArchive,Archivist archivist,URI jarFile,boolean handleRuntimeInfo,Application openArchive,Archivist archivist,ReadableArchive in,boolean handleRuntimeInfo,Application openArchive,String appName,Archivist archivist,ReadableArchive in,boolean handleRuntimeInfo,Application openArchive,URI jarFile,String archiveType,boolean handleRuntimeInfo){\r\n    Archivist archivist = archivistFactory.getArchivist(archiveType);\r\n    return openArchive(archivist, jarFile, handleRuntimeInfo);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.TypeSupport.isLocalInterface",
	"Comment": "returns true if the specified type info denotesa local interface.",
	"Method": "boolean isLocalInterface(Object typeInfo){\r\n    return nameMapper.isLocalInterface(getTypeName(typeInfo));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.state.LifeCycleState.isNavigable",
	"Comment": "return whether the object can dynamically navigate to fields that arenot present.",
	"Method": "boolean isNavigable(){\r\n    return isNavigable;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.setRegistrationName",
	"Comment": "sets the registration name for this application. this name is usedwhile deploying the application. the deployment process guranteesthat this name is unique.",
	"Method": "void setRegistrationName(String appId){\r\n    SecurityRoleMapper roleMapper = null;\r\n    try {\r\n        roleMapper = getRoleMapper();\r\n    } catch (IllegalArgumentException ignore) {\r\n    }\r\n    if (roleMapper != null) {\r\n        if (securityRoleMapperFactory == null) {\r\n            throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.norolemapperfactorydefine\", \"This application has no role mapper factory defined\"));\r\n        }\r\n        securityRoleMapperFactory.removeRoleMapper(getName());\r\n        roleMapper.setName(appId);\r\n        securityRoleMapperFactory.setRoleMapper(appId, roleMapper);\r\n    }\r\n    this.registrationName = appId;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.FieldGroupElement.containsField",
	"Comment": "tests whether the supplied field is in the collection of fields \tmaintained by this holder.",
	"Method": "boolean containsField(PersistenceFieldElement field){\r\n    return (getFieldGroupImpl().getField(field.getName()) != null);\r\n}"
}, {
	"Path": "org.glassfish.ejb.security.application.EJBSecurityManager.addToRolePermissionsTable",
	"Comment": "utility to collect role permisisions in table of collections",
	"Method": "HashMap addToRolePermissionsTable(HashMap table,MethodPermission mp,EJBMethodPermission ejbmp){\r\n    if (mp.isRoleBased()) {\r\n        if (table == null) {\r\n            table = new HashMap();\r\n        }\r\n        String roleName = mp.getRole().getName();\r\n        Permissions rolePermissions = (Permissions) table.get(roleName);\r\n        if (rolePermissions == null) {\r\n            rolePermissions = new Permissions();\r\n            table.put(roleName, rolePermissions);\r\n        }\r\n        rolePermissions.add(ejbmp);\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.fine(\"JACC DD conversion: EJBMethodPermission ->(\" + ejbmp.getName() + \" \" + ejbmp.getActions() + \")protected by role -> \" + roleName);\r\n        }\r\n    }\r\n    return table;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.addConcurrencyGroups",
	"Comment": "add the supplied groups to the collection of concurrency groups for \tthis class.",
	"Method": "void addConcurrencyGroups(ConcurrencyGroupElement[] groups){\r\n    getClassImpl().changeConcurrencyGroups(groups, Impl.ADD);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOConcreteBean20Generator.isFinderReturningEnumeration",
	"Comment": "checks if the finder returns an enumeration. returns falsefor cmp2.0.",
	"Method": "boolean isFinderReturningEnumeration(Method finder){\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.setMinPool",
	"Comment": "sets minimum number of persistencemanager instances in the pool",
	"Method": "void setMinPool(int MinPool){\r\n    throw new JDOUnsupportedOptionException(// NOI18N\r\n    I18NHelper.getMessage(messages, \"jdo.persistencemanagerfactoryimpl.notsupported\"));\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.PersistenceDescriptor.classesChanged",
	"Comment": "called from ejbcmpentitydescriptorwhen some classes in this object are updated.",
	"Method": "boolean classesChanged(){\r\n    persistentClass = null;\r\n    stateClass = null;\r\n    Vector fieldDescriptors = parentDesc.getFieldDescriptors();\r\n    if (this.cmpFields != null) {\r\n        for (Iterator iter = cmpFields.iterator(); iter.hasNext(); ) {\r\n            FieldDescriptor next = (FieldDescriptor) iter.next();\r\n            if (!fieldDescriptors.contains(next)) {\r\n                iter.remove();\r\n            }\r\n        }\r\n    }\r\n    if (this.pkeyFields != null) {\r\n        for (Iterator iter = pkeyFields.iterator(); iter.hasNext(); ) {\r\n            FieldDescriptor next = (FieldDescriptor) iter.next();\r\n            if (!fieldDescriptors.contains(next)) {\r\n                iter.remove();\r\n            }\r\n        }\r\n    }\r\n    FieldDescriptor primKeyFieldDesc = parentDesc.getPrimaryKeyFieldDesc();\r\n    if ((primKeyFieldDesc != null) && !fieldDescriptors.contains(primKeyFieldDesc)) {\r\n        parentDesc.setPrimaryKeyFieldDesc(null);\r\n    }\r\n    Hashtable queriesClone = (Hashtable) queries.clone();\r\n    queries = new Hashtable();\r\n    initializeAllQueriedMethods();\r\n    for (Object o : queriesClone.entrySet()) {\r\n        Map.Entry entry = (Map.Entry) o;\r\n        Method oldMethod = (Method) entry.getKey();\r\n        Method newMethod = findEquivalentMethod(allQueriedMethods, oldMethod);\r\n        if (newMethod != null) {\r\n            QueryDescriptor oldQuery = (QueryDescriptor) entry.getValue();\r\n            QueryDescriptor newQuery = new QueryDescriptor(oldQuery, newMethod);\r\n            queries.put(newMethod, newQuery);\r\n        }\r\n    }\r\n    invalidate();\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.TypeSupport.hasRemoteInterface",
	"Comment": "returns true if the bean with the specified ejb namehas a remote interface.",
	"Method": "boolean hasRemoteInterface(Object typeInfo){\r\n    return nameMapper.getRemoteInterfaceForEjbName(getTypeName(typeInfo)) != null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.TypeSupport.isNumericType",
	"Comment": "returns true if type is a primitive numeric type such as byte, int etc.",
	"Method": "boolean isNumericType(Object type){\r\n    return numericTypes.contains(type);\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.jws.ExtensionFileManager.addExtJarsFromDirectory",
	"Comment": "adds entries for the extension files from one directory to the indicated map.",
	"Method": "void addExtJarsFromDirectory(Map<ExtensionKey, Extension> map,int extensionDirNumber,File extDir){\r\n    File[] extJars = extDir.listFiles(new FilenameFilter() {\r\n        @Override\r\n        public boolean accept(File dir, String name) {\r\n            return name.endsWith(\".jar\");\r\n        }\r\n    });\r\n    if (extJars != null) {\r\n        for (File file : extJars) {\r\n            Extension entry = buildExtensionForJar(file, extensionDirNumber);\r\n            if (entry != null) {\r\n                map.put(entry.extensionKey, entry);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.jws.ExtensionFileManager.addExtJarsFromDirectory",
	"Comment": "adds entries for the extension files from one directory to the indicated map.",
	"Method": "void addExtJarsFromDirectory(Map<ExtensionKey, Extension> map,int extensionDirNumber,File extDir){\r\n    return name.endsWith(\".jar\");\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.PreparedStatementWrapper.setShort",
	"Comment": "sets the designated parameter to the given java short value.the driver converts thisto an sql smallint value when it sends it to the database.",
	"Method": "void setShort(int parameterIndex,short x){\r\n    preparedStatement.setShort(parameterIndex, x);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceFieldElement.getConcurrencyGroups",
	"Comment": "returns the array of concurrency groups to which this field belongs.",
	"Method": "ConcurrencyGroupElement[] getConcurrencyGroups(){\r\n    ConcurrencyGroupElement[] groups = getDeclaringClass().getConcurrencyGroups();\r\n    int i, count = ((groups != null) ? groups.length : 0);\r\n    ArrayList myGroups = new ArrayList(count);\r\n    for (i = 0; i < count; i++) {\r\n        ConcurrencyGroupElement group = groups[i];\r\n        if (group.containsField(this))\r\n            myGroups.add(group);\r\n    }\r\n    count = myGroups.size();\r\n    return ((ConcurrencyGroupElement[]) myGroups.toArray(new ConcurrencyGroupElement[count]));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.NameMapper.getDescriptorForEjbName",
	"Comment": "gets the ejbcmpentitydescriptor which represents the ejb\twith the specified name.",
	"Method": "EjbCMPEntityDescriptor getDescriptorForEjbName(String name){\r\n    Map ejbMap = (Map) getMap().get(EJB_NAME);\r\n    Object descriptor = ejbMap.get(name);\r\n    return (((descriptor != null) && (descriptor instanceof EjbCMPEntityDescriptor)) ? (EjbCMPEntityDescriptor) descriptor : null);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsResultSetType",
	"Comment": "retrieves whether this database supports the given result set type.",
	"Method": "boolean supportsResultSetType(int type){\r\n    return databaseMetaData.supportsResultSetType(type);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.connector.MapElementNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object newDescriptor){\r\n    MapElement descriptor = (MapElement) getDescriptor();\r\n    if (descriptor == null) {\r\n        throw new RuntimeException(\"Cannot set info on null descriptor\");\r\n    }\r\n    if (newDescriptor instanceof Principal) {\r\n        Principal principal = (Principal) newDescriptor;\r\n        if (principal.getValue(Principal.CREDENTIAL) == null) {\r\n            descriptor.addPrincipal(principal);\r\n        } else {\r\n            descriptor.setBackendPrincipal(true);\r\n            descriptor.setAttributeValue(MapElement.BACKEND_PRINCIPAL, Principal.USER_NAME, principal.getValue(Principal.USER_NAME));\r\n            descriptor.setAttributeValue(MapElement.BACKEND_PRINCIPAL, Principal.PASSWORD, principal.getValue(Principal.PASSWORD));\r\n            descriptor.setAttributeValue(MapElement.BACKEND_PRINCIPAL, Principal.CREDENTIAL, principal.getValue(Principal.CREDENTIAL));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.BaseContainer.useClientTx",
	"Comment": "also called from entitycontainer.removebean for cascaded deletes",
	"Method": "void useClientTx(Transaction prevTx,EjbInvocation inv){\r\n    containerTransactionManager.useClientTx(prevTx, inv);\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.ListJMSResources.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    ArrayList<Map<String, String>> list = new ArrayList();\r\n    Properties extraProperties = new Properties();\r\n    Collection adminObjectResourceList = domain.getResources().getResources(AdminObjectResource.class);\r\n    Collection connectorResourcesList = domain.getResources().getResources(ConnectorResource.class);\r\n    Object[] connectorResources = connectorResourcesList.toArray();\r\n    Object[] adminObjectResources = adminObjectResourceList.toArray();\r\n    if (resourceType == null) {\r\n        try {\r\n            for (Object r : adminObjectResources) {\r\n                AdminObjectResource adminObject = (AdminObjectResource) r;\r\n                if (JMSRA.equals(adminObject.getResAdapter())) {\r\n                    Map<String, String> m = new HashMap();\r\n                    m.put(\"name\", adminObject.getJndiName());\r\n                    list.add(m);\r\n                }\r\n            }\r\n            for (Object c : connectorResources) {\r\n                ConnectorResource cr = (ConnectorResource) c;\r\n                ConnectorConnectionPool cp = (ConnectorConnectionPool) ConnectorsUtil.getResourceByName(domain.getResources(), ConnectorConnectionPool.class, cr.getPoolName());\r\n                if (cp != null && JMSRA.equals(cp.getResourceAdapterName())) {\r\n                    Map<String, String> m = new HashMap();\r\n                    m.put(\"name\", cr.getJndiName());\r\n                    list.add(m);\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            report.setMessage(localStrings.getLocalString(\"list.jms.resources.fail\", \"Unable to list JMS Resources\") + \" \" + e.getLocalizedMessage());\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            report.setFailureCause(e);\r\n            return;\r\n        }\r\n    } else {\r\n        switch(resourceType) {\r\n            case TOPIC_CF:\r\n            case QUEUE_CF:\r\n            case UNIFIED_CF:\r\n                for (Object c : connectorResources) {\r\n                    ConnectorResource cr = (ConnectorResource) c;\r\n                    ConnectorConnectionPool cp = (ConnectorConnectionPool) ConnectorsUtil.getResourceByName(domain.getResources(), ConnectorConnectionPool.class, cr.getPoolName());\r\n                    if (cp != null && resourceType.equals(cp.getConnectionDefinitionName()) && JMSRA.equals(cp.getResourceAdapterName())) {\r\n                        Map<String, String> m = new HashMap();\r\n                        m.put(\"name\", cr.getJndiName());\r\n                        list.add(m);\r\n                    }\r\n                }\r\n                break;\r\n            case TOPIC:\r\n            case QUEUE:\r\n                for (Object r : adminObjectResources) {\r\n                    AdminObjectResource res = (AdminObjectResource) r;\r\n                    if (resourceType.equals(res.getResType()) && JMSRA.equals(res.getResAdapter())) {\r\n                        Map<String, String> m = new HashMap();\r\n                        m.put(\"name\", res.getJndiName());\r\n                        list.add(m);\r\n                    }\r\n                }\r\n                break;\r\n        }\r\n    }\r\n    if (!list.isEmpty()) {\r\n        List<Map<String, String>> resourceList = CommandTarget.DOMAIN.isValid(habitat, target) ? list : filterListForTarget(list);\r\n        List<DefaultResourceProxy> drps = habitat.getAllServices(DefaultResourceProxy.class);\r\n        for (Map<String, String> m : resourceList) {\r\n            String jndiName = m.get(\"name\");\r\n            final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n            part.setMessage(jndiName);\r\n            String logicalName = DefaultResourceProxy.Util.getLogicalName(drps, jndiName);\r\n            if (logicalName != null) {\r\n                m.put(\"logical-jndi-name\", logicalName);\r\n            }\r\n        }\r\n        extraProperties.put(\"jmsResources\", resourceList);\r\n    }\r\n    report.setExtraProperties(extraProperties);\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getCallbackInterceptors",
	"Comment": "return the ordered list of interceptor info for a particularcallback event type.this listinclude the infoon any bean class callback.if present, this would always be thelast element in the list because of the precedence defined by the spec.",
	"Method": "List<EjbInterceptor> getCallbackInterceptors(CallbackType type,LinkedList<EjbInterceptor> getCallbackInterceptors,CallbackType type,Set<LifecycleCallbackDescriptor> callbackDescriptors){\r\n    LinkedList<EjbInterceptor> callbackInterceptors = new LinkedList<EjbInterceptor>();\r\n    ClassLoader classLoader = getEjbBundleDescriptor().getClassLoader();\r\n    List<EjbInterceptor> classOrMethodInterceptors = (type.equals(CallbackType.AROUND_CONSTRUCT)) ? getConstructorInterceptors(classLoader) : interceptorChain;\r\n    for (EjbInterceptor next : classOrMethodInterceptors) {\r\n        if (next.getCallbackDescriptors(type).size() > 0) {\r\n            callbackInterceptors.add(next);\r\n        }\r\n    }\r\n    if (callbackDescriptors != null && callbackDescriptors.size() > 0) {\r\n        EjbInterceptor beanClassCallbackInfo = new EjbInterceptor();\r\n        beanClassCallbackInfo.setFromBeanClass(true);\r\n        beanClassCallbackInfo.addCallbackDescriptors(type, callbackDescriptors);\r\n        beanClassCallbackInfo.setInterceptorClassName(getEjbImplClassName());\r\n        callbackInterceptors.add(beanClassCallbackInfo);\r\n    }\r\n    return callbackInterceptors;\r\n}"
}, {
	"Path": "com.sun.enterprise.container.common.impl.managedbean.ManagedBeanManagerImpl.registerRuntimeInterceptor",
	"Comment": "apply a runtime interceptor instance to all managed beans in the given module",
	"Method": "void registerRuntimeInterceptor(Object interceptorInstance,BundleDescriptor bundle){\r\n    for (ManagedBeanDescriptor next : bundle.getManagedBeans()) {\r\n        JavaEEInterceptorBuilder interceptorBuilder = (JavaEEInterceptorBuilder) next.getInterceptorBuilder();\r\n        interceptorBuilder.addRuntimeInterceptor(interceptorInstance);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.enterprise.iiop.impl.GlassFishORBManager.setFOLBProperties",
	"Comment": "set the orb properties for iiop failover and load balancing.",
	"Method": "void setFOLBProperties(Properties orbInitProperties){\r\n    orbInitProperties.put(ORBConstants.RFM_PROPERTY, \"dummy\");\r\n    orbInitProperties.put(ORBConstants.SOCKET_FACTORY_CLASS_PROPERTY, IIOP_SSL_SOCKET_FACTORY_CLASS);\r\n    orbInitProperties.setProperty(ORBConstants.USER_CONFIGURATOR_PREFIX + \"com.sun.corba.ee.impl.folb.ClientGroupManager\", \"dummy\");\r\n    orbInitProperties.setProperty(ORBConstants.USER_CONFIGURATOR_PREFIX + CSIv2SSLTaggedComponentHandlerImpl.class.getName(), \"dummy\");\r\n    if (processType.isServer()) {\r\n        gmsClient = new IiopFolbGmsClient(services);\r\n        if (gmsClient.isGMSAvailable()) {\r\n            fineLog(\"GMS available and enabled - doing EE initialization\");\r\n            orbInitProperties.setProperty(ORBConstants.USER_CONFIGURATOR_PREFIX + \"com.sun.corba.ee.impl.folb.ServerGroupManager\", \"dummy\");\r\n            fineLog(\"Did EE property initialization\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ServiceRefPortInfo.getStubProperties",
	"Comment": "set of namevaluepairdescriptor objects for each stub property.",
	"Method": "Set getStubProperties(){\r\n    return stubProperties;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.rm.NoTxResourceManagerImpl.getTransaction",
	"Comment": "returns null since this connection is outside any tx context",
	"Method": "Transaction getTransaction(){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.SunCmpMappingsUtils.findCompatibleBeansWithValue",
	"Comment": "a utility for finding beans in a graph of basebean objects.search the bean graph, starting at a given root, for beans where the namedproperty has the given value.the returned list is filtered by assignmentcompatibility.",
	"Method": "List findCompatibleBeansWithValue(BaseBean root,String propName,String propVal,Class type){\r\n    List retVal = null;\r\n    GraphManager gm = root.graphManager();\r\n    if (null == gm)\r\n        throw new IllegalArgumentException(bundle.getString(\"ERR_DISCONNECTED_NOT_SUPPORTED\"));\r\n    String[] props = root.findPropertyValue(propName, propVal);\r\n    int len = 0;\r\n    if (null != props)\r\n        len = props.length;\r\n    if (len > 0)\r\n        retVal = new ArrayList();\r\n    for (int i = 0; i < len; i++) {\r\n        BaseBean candidate = gm.getPropertyParent(props[i]);\r\n        if (type.isInstance(candidate))\r\n            retVal.add(candidate);\r\n    }\r\n    return retVal;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.provider.PolicyConfigurationImpl.removeRole",
	"Comment": "used to remove a role and all its permissions from this policyconfiguration.",
	"Method": "void removeRole(String roleName){\r\n    assertStateIsOpen();\r\n    if (roleName != null && rolePermissionsTable != null) {\r\n        checkSetPolicyPermission();\r\n        if (rolePermissionsTable.remove(roleName) != null) {\r\n            if (rolePermissionsTable.isEmpty()) {\r\n                rolePermissionsTable = null;\r\n            }\r\n            writeOnCommit = true;\r\n        } else if (roleName.equals(\"*\")) {\r\n            boolean wasEmpty = rolePermissionsTable.isEmpty();\r\n            if (!wasEmpty) {\r\n                rolePermissionsTable.clear();\r\n            }\r\n            rolePermissionsTable = null;\r\n            if (!wasEmpty) {\r\n                writeOnCommit = true;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.javaee.full.deployment.EarSniffer.getDeploymentConfigurationPaths",
	"Comment": "returns the descriptor paths that might exist at the root of the ear.",
	"Method": "List<String> getDeploymentConfigurationPaths(){\r\n    return deploymentConfigurationPaths;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConfigurationParserServiceImpl.getSecurityPermissionSpec",
	"Comment": "obtains the permission string that needs to be added to theto the security policy files. these are the security permissions neededby the resource adapter implementation classes.these strings are obtained by parsing the ra.xml",
	"Method": "String getSecurityPermissionSpec(String moduleName){\r\n    if (moduleName == null) {\r\n        return null;\r\n    }\r\n    String policyString = null;\r\n    String fileName = System.getProperty(\"java.security.policy\");\r\n    if (fileName != null) {\r\n        File policyFile = new File(fileName);\r\n        String policyContent = getFileContent(policyFile);\r\n        ConnectorDescriptor connectorDescriptor = getConnectorDescriptor(moduleName);\r\n        Set securityPermissions = connectorDescriptor.getSecurityPermissions();\r\n        Iterator it = securityPermissions.iterator();\r\n        SecurityPermission secPerm = null;\r\n        String permissionString = null;\r\n        while (it.hasNext()) {\r\n            secPerm = (SecurityPermission) it.next();\r\n            permissionString = secPerm.getPermission();\r\n            if (permissionString != null) {\r\n                int intIndex = policyContent.indexOf(permissionString);\r\n                if (intIndex == -1) {\r\n                    if (policyString != null) {\r\n                        policyString = policyString + \"\\n \\n\" + permissionString;\r\n                    } else {\r\n                        policyString = \"\\n\\n\" + permissionString;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (policyString != null) {\r\n            policyString = CAUTION_MESSAGE + policyString;\r\n        }\r\n    }\r\n    return policyString;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ResultSetWrapper40.getSQLXML",
	"Comment": "retrieves the value of the designated column inthe current row ofthis resultset as ajava.sql.sqlxml object in the java programming language.",
	"Method": "SQLXML getSQLXML(int columnIndex,SQLXML getSQLXML,String columnLabel){\r\n    return resultSet.getSQLXML(columnLabel);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.JDOEJB11HelperImpl.getNumericConverter",
	"Comment": "return numericconverter for conversion from number to bigdecimal orbiginteger for this bean type. it is responsible for passing thecorrect policy value to the numericconverterfactory.",
	"Method": "NumericConverter getNumericConverter(){\r\n    int policy = CMPHelper.getNumericConverterPolicy(getContainer());\r\n    return NumericConverterFactory.getNumericConverter(policy);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.jqlc.ParameterTable.getKeyForRetrieveDescCache",
	"Comment": "calculates and returns the key for the retrievedesc cache based,on the actual parameter values.a null return means, the retrievedesc should not becached. note, this method needs to be in sync with method inline.",
	"Method": "String getKeyForRetrieveDescCache(){\r\n    StringBuffer key = new StringBuffer();\r\n    final int size = values.size();\r\n    for (int i = 0; i < size; i++) {\r\n        if (isInlineType(types.get(i)))\r\n            return null;\r\n        Object item = values.get(i);\r\n        if (item == null) {\r\n            key.append(ParameterTable.NULL_);\r\n        } else if (item instanceof Boolean) {\r\n            if (((Boolean) item).booleanValue()) {\r\n                key.append(ParameterTable.TRUE_);\r\n            } else {\r\n                key.append(ParameterTable.FALSE_);\r\n            }\r\n        } else {\r\n            key.append(ParameterTable.OTHER_);\r\n        }\r\n        key.append(ParameterTable.PARAMKEY_SEPARATOR);\r\n    }\r\n    if (key.length() == 0) {\r\n        key.append(ParameterTable.NOPARAMS_);\r\n    }\r\n    return key.toString();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.insertRow",
	"Comment": "inserts the contents of the insert row into thisresultset object and into the database.the cursor must be on the insert row when this method is called.",
	"Method": "void insertRow(){\r\n    resultSet.insertRow();\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.getEnvironmentProperties",
	"Comment": "return a copy of the structure holding the environment properties.",
	"Method": "Set<EnvironmentProperty> getEnvironmentProperties(){\r\n    return environmentProperties;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.MappingPolicy.getColumnName",
	"Comment": "returns the name of a column for a given field in a given class.thecolumn name will be unique within the table.",
	"Method": "String getColumnName(String className,String fieldName,String tableName){\r\n    StringBuffer key = new StringBuffer(className).append(DOT).append(fieldName).append(DOT).append(INDICATOR_COLUMN_NAME);\r\n    String rc = (String) namingPolicy.get(key.toString());\r\n    if (rc == null) {\r\n        key = new StringBuffer(className).append(DOT).append(FIELD_BASE).append(DOT).append(INDICATOR_COLUMN_NAME);\r\n        rc = (String) namingPolicy.get(key.toString());\r\n    }\r\n    if (rc == null) {\r\n        rc = (String) namingPolicy.get(DEFAULT_COLUMN_KEY);\r\n    }\r\n    if (rc.equals(COLUMN_NAME_UPPERCASE)) {\r\n        rc = fieldName.toUpperCase();\r\n    } else if (rc.equals(COLUMN_NAME_AS_FIELDNAME)) {\r\n        rc = fieldName;\r\n    }\r\n    return getUniqueLocalName(rc, tableName, columnNameMaxLength);\r\n}"
}, {
	"Path": "com.sun.ejb.EjbInvocation.isCallerInRole",
	"Comment": "implements themethod in org.glassfish.ejb.api.ejbinvocation",
	"Method": "boolean isCallerInRole(String role){\r\n    return getEjbSecurityManager().isCallerInRole(role);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.NumericWrapperClassType.getValue",
	"Comment": "converts the specified value into a value of this numeric type.e.g. an integer is converted into a double, if this represents the numeric type double.",
	"Method": "Number getValue(Number value){\r\n    return ((NumericType) primitiveType).getValue(value);\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBTimerService.createSchedulesOnServer",
	"Comment": "called in a clustered environment to eagerly create automatic persistent timerson the specific server instance.in a ejb lite distribution if there is at least one persistent automatic timerdefined, this method will fail with a runtimeexception.",
	"Method": "void createSchedulesOnServer(EjbDescriptor ejbDescriptor,String server_name){\r\n    for (ScheduledTimerDescriptor schd : ejbDescriptor.getScheduledTimerDescriptors()) {\r\n        if (schd.getTimeoutMethod() != null && schd.getPersistent()) {\r\n            throw new RuntimeException(\"EJB \" + ejbDescriptor.getName() + \" uses persistent EJB Timer Service\" + \". This feature is not part of the EJB Lite API\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxColumnsInIndex",
	"Comment": "retrieves the maximum number of columns this database allows in an index.",
	"Method": "int getMaxColumnsInIndex(){\r\n    return databaseMetaData.getMaxColumnsInIndex();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsOpenCursorsAcrossRollback",
	"Comment": "retrieves whether this database supports keeping cursors openacross rollbacks.",
	"Method": "boolean supportsOpenCursorsAcrossRollback(){\r\n    return databaseMetaData.supportsOpenCursorsAcrossRollback();\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnectionFactory.createConnectionFactory",
	"Comment": "creates a connection factory instance. the connectionmanager implementationof the application server is used here.",
	"Method": "Object createConnectionFactory(Object createConnectionFactory,javax.resource.spi.ConnectionManager cxManager){\r\n    if (logWriter != null) {\r\n        logWriter.println(\"In createConnectionFactory(javax.resource.spi.ConnectionManager cxManager)\");\r\n    }\r\n    com.sun.jdbcra.spi.DataSource cf = new com.sun.jdbcra.spi.DataSource((javax.resource.spi.ManagedConnectionFactory) this, cxManager);\r\n    return cf;\r\n}"
}, {
	"Path": "com.sun.jaspic.config.factory.BaseAuthConfigFactory._register",
	"Comment": "xxx need to update persistent state and notify effected listeners",
	"Method": "String _register(AuthConfigProvider provider,Map<String, Object> properties,String layer,String appContext,String description,boolean persistent){\r\n    String regisID = getRegistrationID(layer, appContext);\r\n    RegistrationContext rc = new RegistrationContextImpl(layer, appContext, description, persistent);\r\n    RegistrationContext prevRegisContext = null;\r\n    Map<String, List<RegistrationListener>> listenerMap;\r\n    wLock.lock();\r\n    try {\r\n        prevRegisContext = id2RegisContextMap.get(regisID);\r\n        AuthConfigProvider prevProvider = id2ProviderMap.get(regisID);\r\n        if (persistent) {\r\n            _storeRegistration(regisID, rc, provider, properties);\r\n        } else if (prevRegisContext != null && prevRegisContext.isPersistent()) {\r\n            _deleteStoredRegistration(regisID, prevRegisContext);\r\n        }\r\n        boolean wasRegistered = id2ProviderMap.containsKey(regisID);\r\n        if (wasRegistered) {\r\n            List<String> prevRegisIDs = provider2IdsMap.get(prevProvider);\r\n            prevRegisIDs.remove(regisID);\r\n            if (prevRegisIDs.isEmpty()) {\r\n                provider2IdsMap.remove(prevProvider);\r\n            }\r\n        }\r\n        id2ProviderMap.put(regisID, provider);\r\n        id2RegisContextMap.put(regisID, rc);\r\n        List<String> regisIDs = provider2IdsMap.get(provider);\r\n        if (regisIDs == null) {\r\n            regisIDs = new ArrayList<String>();\r\n            provider2IdsMap.put(provider, regisIDs);\r\n        }\r\n        if (!regisIDs.contains(regisID)) {\r\n            regisIDs.add(regisID);\r\n        }\r\n        listenerMap = getEffectedListeners(regisID);\r\n    } finally {\r\n        wLock.unlock();\r\n    }\r\n    notifyListeners(listenerMap);\r\n    return regisID;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.StatementWrapper.getConnection",
	"Comment": "retrieves the connection objectthat produced this statement object.",
	"Method": "Connection getConnection(){\r\n    return connection;\r\n}"
}, {
	"Path": "org.glassfish.loadbalancer.admin.cli.ApplyHttpLbChanges.publish",
	"Comment": "publishes the loadbalancer.xml to the physical loadbalancer.",
	"Method": "void publish(ConnectionManager _connectionManager,Domain domain,String lbConfigName){\r\n    LoadbalancerReader lbr = LbConfigHelper.getLbReader(domain, appRegistry, lbConfigName);\r\n    HttpURLConnection conn = _connectionManager.getConnection(LB_UPDATE_CONTEXT_ROOT);\r\n    OutputStream out = null;\r\n    try {\r\n        conn.setDoOutput(true);\r\n        conn.setRequestMethod(POST);\r\n        conn.connect();\r\n        out = conn.getOutputStream();\r\n        LbConfigHelper.exportXml(lbr, out);\r\n        out.flush();\r\n        lbr.getLbConfig().setLastApplied();\r\n    } catch (UnknownHostException uhe) {\r\n        throw new IOException(LbLogUtil.getStringManager().getString(\"CannotConnectToLBHost\", uhe.getMessage()), uhe);\r\n    } catch (Exception e) {\r\n        throw new IOException(e.getMessage(), e);\r\n    } finally {\r\n        if (out != null && conn != null) {\r\n            int code = conn.getResponseCode();\r\n            String response = conn.getResponseMessage();\r\n            out.close();\r\n            conn.disconnect();\r\n            out = null;\r\n            if (code != HttpURLConnection.HTTP_OK) {\r\n                String url = conn.getURL().toString();\r\n                conn = null;\r\n                throw new IOException(LbLogUtil.getStringManager().getString(\"HttpError\", Integer.valueOf(code), response, url));\r\n            }\r\n            conn = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbMessageBeanDescriptor.getRuntimeActivationConfigDescriptor",
	"Comment": "through the other accessors on the message bean descriptor.",
	"Method": "ActivationConfigDescriptor getRuntimeActivationConfigDescriptor(){\r\n    return runtimeActivationConfig;\r\n}"
}, {
	"Path": "org.glassfish.resources.deployer.ExternalJndiResourceDeployer.installExternalJndiResource",
	"Comment": "installs the given external jndi resource. this method gets calledduring server initialization and from external jndi resourcedeployer to handle resource events.",
	"Method": "void installExternalJndiResource(org.glassfish.resources.beans.ExternalJndiResource extJndiRes,ResourceInfo resourceInfo){\r\n    try {\r\n        String factoryClass = extJndiRes.getFactoryClass();\r\n        String jndiLookupName = extJndiRes.getJndiLookupName();\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"installExternalJndiResources resourceName \" + resourceInfo + \" factoryClass \" + factoryClass + \" jndiLookupName = \" + jndiLookupName);\r\n        }\r\n        Object factory = ResourceUtil.loadObject(factoryClass);\r\n        if (factory == null) {\r\n            _logger.log(Level.WARNING, \"jndi.factory_load_error\", factoryClass);\r\n            return;\r\n        } else if (!(factory instanceof javax.naming.spi.InitialContextFactory)) {\r\n            _logger.log(Level.WARNING, \"jndi.factory_class_unexpected\", factoryClass);\r\n            return;\r\n        }\r\n        Hashtable env = new Hashtable();\r\n        for (Iterator props = extJndiRes.getProperties().iterator(); props.hasNext(); ) {\r\n            ResourceProperty prop = (ResourceProperty) props.next();\r\n            env.put(prop.getName(), prop.getValue());\r\n        }\r\n        Context context = null;\r\n        try {\r\n            context = ((InitialContextFactory) factory).getInitialContext(env);\r\n        } catch (NamingException ne) {\r\n            _logger.log(Level.SEVERE, \"jndi.initial_context_error\", factoryClass);\r\n            _logger.log(Level.SEVERE, \"jndi.initial_context_error_excp\", ne.getMessage());\r\n        }\r\n        if (context == null) {\r\n            _logger.log(Level.SEVERE, \"jndi.factory_create_error\", factoryClass);\r\n            return;\r\n        }\r\n        Reference ref = new Reference(extJndiRes.getResType(), \"org.glassfish.resources.naming.JndiProxyObjectFactory\", null);\r\n        ref.add(new SerializableObjectRefAddr(\"resourceInfo\", resourceInfo));\r\n        ref.add(new StringRefAddr(\"jndiLookupName\", jndiLookupName));\r\n        ref.add(new StringRefAddr(\"jndiFactoryClass\", factoryClass));\r\n        ref.add(new ProxyRefAddr(extJndiRes.getResourceInfo().getName(), env));\r\n        namingService.publishObject(resourceInfo, ref, true);\r\n    } catch (Exception ex) {\r\n        _logger.log(Level.SEVERE, \"customrsrc.create_ref_error\", resourceInfo);\r\n        _logger.log(Level.SEVERE, \"customrsrc.create_ref_error_excp\", ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.TypeTable.isCollectionType",
	"Comment": "returns true if type denotes a collection type.note, it returns false for non classtype values, especially fornulltype and errortype.",
	"Method": "boolean isCollectionType(Type type){\r\n    Type collectionType = checkType(\"java.util.Collection\");\r\n    return (type instanceof ClassType) && type.isCompatibleWith(collectionType);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.getAuthenticationService",
	"Comment": "obtain the authentication service associated with rar module.currently only the basicpassword authentication is supported.",
	"Method": "AuthenticationService getAuthenticationService(String rarName,PoolInfo poolInfo){\r\n    return connectorSecurityAdmService.getAuthenticationService(rarName, poolInfo);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ConnectionHolder40.isValid",
	"Comment": "returns true if the connection has not been closed and is still valid.the driver shall submit a query on the connection or use some othermechanism that positively verifies the connection is still valid whenthis method is called.the query submitted by the driver to validate the connection shall beexecuted in the context of the current transaction.",
	"Method": "boolean isValid(int timeout){\r\n    checkValidity();\r\n    return con.isValid(timeout);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ee.PermissionCacheFactory.registerPermissionCache",
	"Comment": "register a permissioncache object with the factory. if an object isalready registered at the key, it will be overidden.",
	"Method": "PermissionCache registerPermissionCache(PermissionCache cache){\r\n    cacheMap.put(cache.getFactoryKey(), cache);\r\n    return cache;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConnectionPoolAdminServiceImpl.getManagedConnection",
	"Comment": "utility method to get managed connection from the supplied mcf and default subject.",
	"Method": "ManagedConnection getManagedConnection(ManagedConnectionFactory mcf,Subject defaultSubject,ConnectionRequestInfo cReqInfo){\r\n    ManagedConnection mc = null;\r\n    mc = mcf.createManagedConnection(defaultSubject, cReqInfo);\r\n    return mc;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.isValidByCustomValidation",
	"Comment": "checks if a java.sql.connection is valid or notby doing a custom validation using the validation class name specified.",
	"Method": "void isValidByCustomValidation(java.sql.Connection con,String validationClassName){\r\n    boolean isValid = false;\r\n    if (con == null) {\r\n        throw new ResourceException(\"The connection is not valid as \" + \"the connection is null\");\r\n    }\r\n    try {\r\n        Class validationClass = Thread.currentThread().getContextClassLoader().loadClass(validationClassName);\r\n        ConnectionValidation valClass = (ConnectionValidation) validationClass.newInstance();\r\n        isValid = valClass.isConnectionValid(con);\r\n    } catch (Exception e) {\r\n        _logger.log(Level.INFO, \"jdbc.exc_custom_validation\", validationClassName);\r\n        throw new ResourceException(e);\r\n    }\r\n    if (!isValid) {\r\n        _logger.log(Level.INFO, \"jdbc.exc_custom_validation\", validationClassName);\r\n        throw new ResourceException(\"Custom validation detected invalid connection\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.allProceduresAreCallable",
	"Comment": "retrieves whether the current user can call all the proceduresreturned by the method getprocedures.",
	"Method": "boolean allProceduresAreCallable(){\r\n    return databaseMetaData.allProceduresAreCallable();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ApplicationClientDescriptor.getResourceEnvReferenceDescriptors",
	"Comment": "return the set of resource environment references this ejb declares.",
	"Method": "Set getResourceEnvReferenceDescriptors(){\r\n    if (this.resourceEnvReferences == null) {\r\n        this.resourceEnvReferences = new OrderedSet();\r\n    }\r\n    return this.resourceEnvReferences = new OrderedSet(this.resourceEnvReferences);\r\n}"
}, {
	"Path": "org.glassfish.admin.amxtest.base.AMXTest.isSuitableReturnTypeForAPI",
	"Comment": "verify that the type is suitable for the api.it must meet the following constraintsthat it is an opentype or a standard java type or a jmx type that it is serializable or an interface or that it is an array whose elements meet the above constraints or that it is one of our specific stats types",
	"Method": "boolean isSuitableReturnTypeForAPI(String type){\r\n    boolean isSuitable = SUITABLE_TYPES.contains(type);\r\n    if (!isSuitable) {\r\n        final boolean isArray = ClassUtil.classnameIsArray(type);\r\n        if (isArray || type.startsWith(\"java.\") || type.startsWith(\"javax.management.\")) {\r\n            Class c = null;\r\n            try {\r\n                c = ClassUtil.getClassFromName(type);\r\n                isSuitable = c.isInterface() || Serializable.class.isAssignableFrom(c) || c == Object.class;\r\n            } catch (ClassNotFoundException e) {\r\n                trace(\"WARNING: can't find class for type: \" + type);\r\n                isSuitable = false;\r\n            }\r\n            if (isArray) {\r\n                final Class elementClass = ClassUtil.getArrayElementClass(c);\r\n                isSuitable = isSuitableReturnTypeForAPI(elementClass.getName());\r\n            } else if (isSuitable && (!type.startsWith(\"javax.\")) && !c.isInterface()) {\r\n                isSuitable = false;\r\n            }\r\n        } else if (type.endsWith(\"Stats\")) {\r\n            isSuitable = type.startsWith(\"com.sun.appserv.management.monitor.statistics\") || type.startsWith(\"org.glassfish.j2ee.statistics\");\r\n        }\r\n    }\r\n    return (isSuitable);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.connector.module.ConnectorSniffer.handles",
	"Comment": "returns true if the passed file or directory is recognized by thissniffer.",
	"Method": "boolean handles(DeploymentContext context){\r\n    ArchiveType archiveType = habitat.getService(ArchiveType.class, context.getArchiveHandler().getArchiveType());\r\n    if (archiveType != null && !supportsArchiveType(archiveType)) {\r\n        return false;\r\n    }\r\n    return DeploymentUtils.isArchiveOfType(context.getSource(), rarType, context, locator);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsSchemasInDataManipulation",
	"Comment": "retrieves whether a schema name can be used in a data manipulation statement.",
	"Method": "boolean supportsSchemasInDataManipulation(){\r\n    return databaseMetaData.supportsSchemasInDataManipulation();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.TransactionImpl.getQueryTimeout",
	"Comment": "gets the number of seconds to wait for a query statementto execute in the datastore associated with thistransaction instance",
	"Method": "int getQueryTimeout(){\r\n    return queryTimeout;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.WeakValueHashMap.values",
	"Comment": "returns a collection view of the values containedin this map.",
	"Method": "Collection values(){\r\n    if (values == null) {\r\n        values = new AbstractCollection() {\r\n            public Iterator iterator() {\r\n                return new Iterator() {\r\n                    private Iterator i = entrySet().iterator();\r\n                    public boolean hasNext() {\r\n                        return i.hasNext();\r\n                    }\r\n                    public Object next() {\r\n                        return ((Entry) i.next()).getValue();\r\n                    }\r\n                    public void remove() {\r\n                        i.remove();\r\n                    }\r\n                };\r\n            }\r\n            public int size() {\r\n                return WeakValueHashMap.this.size();\r\n            }\r\n            public boolean contains(Object v) {\r\n                return WeakValueHashMap.this.containsValue(v);\r\n            }\r\n        };\r\n    }\r\n    return values;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.WeakValueHashMap.values",
	"Comment": "returns a collection view of the values containedin this map.",
	"Method": "Collection values(){\r\n    return new Iterator() {\r\n        private Iterator i = entrySet().iterator();\r\n        public boolean hasNext() {\r\n            return i.hasNext();\r\n        }\r\n        public Object next() {\r\n            return ((Entry) i.next()).getValue();\r\n        }\r\n        public void remove() {\r\n            i.remove();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.WeakValueHashMap.values",
	"Comment": "returns a collection view of the values containedin this map.",
	"Method": "Collection values(){\r\n    return i.hasNext();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.WeakValueHashMap.values",
	"Comment": "returns a collection view of the values containedin this map.",
	"Method": "Collection values(){\r\n    return ((Entry) i.next()).getValue();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.WeakValueHashMap.values",
	"Comment": "returns a collection view of the values containedin this map.",
	"Method": "Collection values(){\r\n    i.remove();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.WeakValueHashMap.values",
	"Comment": "returns a collection view of the values containedin this map.",
	"Method": "Collection values(){\r\n    return WeakValueHashMap.this.size();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.WeakValueHashMap.values",
	"Comment": "returns a collection view of the values containedin this map.",
	"Method": "Collection values(){\r\n    return WeakValueHashMap.this.containsValue(v);\r\n}"
}, {
	"Path": "org.glassfish.deployapi.SunDeploymentManager.getDConfigBeanVersion",
	"Comment": "returns the j2ee platform version number for which the configuration beans are provided.the beans must havebeen compiled with the j2se version required by the j2eeplatform.",
	"Method": "DConfigBeanVersionType getDConfigBeanVersion(){\r\n    return DConfigBeanVersionType.V5;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.webservices.MessageLayerClientHandler.isSoapMessageContext",
	"Comment": "109 mandates that each messagecontext be checked to see if it is aa soapmessagecontext and whether the handler processes it",
	"Method": "boolean isSoapMessageContext(MessageContext mc){\r\n    boolean retValue = (mc instanceof SOAPMessageContext) ? true : false;\r\n    if (!retValue && _logger.isLoggable(Level.WARNING)) {\r\n        _logger.log(Level.WARNING, LogUtils.NOT_SOAP);\r\n    }\r\n    return retValue;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.Vector.addElement",
	"Comment": "adds the specified component to the end of this vector,increasing its size by one.",
	"Method": "void addElement(Object obj){\r\n    if (allowNulls == false && obj == null) {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"sco.nulls_not_allowed\"));\r\n    }\r\n    if (elementType == null || elementType.isAssignableFrom(obj.getClass())) {\r\n        StateManager stateManager = this.makeDirty();\r\n        super.addElement(obj);\r\n        if (removed.remove(obj) == false)\r\n            added.add(obj);\r\n        this.applyUpdates(stateManager, true);\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        messages, \"sco.classcastexception\", elementType.getName()), new ClassCastException(), new Object[] { obj });\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnection.initializeConnectionType",
	"Comment": "sets the connection type of this connection. this method is calledby the mcf while creating this managedconnection. saves us a costlyinstanceof operation in the getconnectiontype",
	"Method": "void initializeConnectionType(int _connectionType){\r\n    connectionType = _connectionType;\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.obj.RemoteToAttrs.jrmpObject",
	"Comment": "returns a pair consisting of a marshalledobject and attributes to be bound with the stub.",
	"Method": "DirStateFactory.Result jrmpObject(Object obj,Attributes inAttrs){\r\n    try {\r\n        Object mobj = new MarshalledObject(obj);\r\n        Attributes outAttrs = null;\r\n        Attribute cname = null;\r\n        Attribute tnames = null;\r\n        Attribute objectClass = null;\r\n        if (inAttrs != null) {\r\n            objectClass = (Attribute) inAttrs.get(\"objectClass\");\r\n            if (objectClass == null && !inAttrs.isCaseIgnored()) {\r\n                objectClass = (Attribute) inAttrs.get(\"objectclass\");\r\n            }\r\n            if (objectClass == null) {\r\n                objectClass = new BasicAttribute(\"objectClass\", \"top\");\r\n            } else {\r\n                objectClass = (Attribute) objectClass.clone();\r\n            }\r\n            cname = inAttrs.get(CLASSNAME_ATTRID);\r\n            tnames = inAttrs.get(CLASSNAMES_ATTRID);\r\n            outAttrs = (Attributes) inAttrs.clone();\r\n        } else {\r\n            outAttrs = new BasicAttributes(true);\r\n            objectClass = new BasicAttribute(\"objectClass\", \"top\");\r\n        }\r\n        if (cname == null) {\r\n            outAttrs.put(CLASSNAME_ATTRID, obj.getClass().getName());\r\n        }\r\n        if (tnames == null) {\r\n            Attribute tAttr = LdapCtxFactory.createTypeNameAttr(obj.getClass());\r\n            if (tAttr != null) {\r\n                outAttrs.put(tAttr);\r\n            }\r\n        }\r\n        boolean structural = (objectClass.size() == 0 || (objectClass.size() == 1 && objectClass.contains(\"top\")));\r\n        if (structural) {\r\n            objectClass.add(STRUCTURAL_OCID);\r\n        }\r\n        objectClass.add(MARSHALLED_OCID);\r\n        outAttrs.put(objectClass);\r\n        return new DirStateFactory.Result(mobj, outAttrs);\r\n    } catch (java.io.IOException e) {\r\n        NamingException ne = new NamingException(\"Cannot create MarshallObject for \" + obj);\r\n        ne.setRootCause(e);\r\n        throw ne;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.SourceFileAttribute.fileName",
	"Comment": "returns the source file namethe file name should not include directories",
	"Method": "ConstUtf8 fileName(){\r\n    return sourceFileName;\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.FacadeLaunchable.getDescriptor",
	"Comment": "return the augmented descriptor constructed during deployment andstored in the facade client jar.",
	"Method": "ApplicationClientDescriptor getDescriptor(URLClassLoader loader){\r\n    if (acDesc == null) {\r\n        final AppClientArchivist archivist = getArchivist();\r\n        archivist.setAnnotationProcessingRequested(!isJWSLaunch);\r\n        final ACCClassLoader tempLoader = AccessController.doPrivileged(new PrivilegedAction<ACCClassLoader>() {\r\n            @Override\r\n            public ACCClassLoader run() {\r\n                return new ACCClassLoader(loader.getURLs(), loader.getParent());\r\n            }\r\n        });\r\n        archivist.setClassLoader(tempLoader);\r\n        acDesc = archivist.open(combinedRA, mainClassNameToLaunch);\r\n        archivist.setDescriptor(acDesc);\r\n        Application.createVirtualApplication(null, acDesc.getModuleDescriptor());\r\n        final Manifest facadeMF = combinedRA.getManifest();\r\n        final Attributes mainAttrs = facadeMF.getMainAttributes();\r\n        final String appName = mainAttrs.getValue(GLASSFISH_APP_NAME);\r\n        acDesc.getApplication().setAppName(appName);\r\n        this.classLoader = loader;\r\n    }\r\n    return acDesc;\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.FacadeLaunchable.getDescriptor",
	"Comment": "return the augmented descriptor constructed during deployment andstored in the facade client jar.",
	"Method": "ApplicationClientDescriptor getDescriptor(URLClassLoader loader){\r\n    return new ACCClassLoader(loader.getURLs(), loader.getParent());\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.ParameterSupport.getParameterName",
	"Comment": "returns the name of the corresponding jdo parameter by parameter number.",
	"Method": "String getParameterName(String ejbqlParamDecl,String getParameterName,int paramNumber){\r\n    return \"_jdoParam\" + String.valueOf(paramNumber);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.NewModel",
	"Comment": "create a new model of the requested type.if the class definition\t\texists in the class path of the environment, then this method will\t\tcreate a new instance of the model.",
	"Method": "Model NewModel(String testName,String modelName){\r\n    Class DynamicClass = null;\r\n    Model model = null;\r\n    try {\r\n        if (testName != null)\r\n            Class.forName(testName);\r\n        DynamicClass = Class.forName(modelName);\r\n        if (DynamicClass != null)\r\n            model = (Model) DynamicClass.newInstance();\r\n    } catch (Exception e) {\r\n    }\r\n    return model;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.JmsHostWrapper.setLazyInit",
	"Comment": "sets the value of lazyinit propertyspecify is this listener should be started as part of server startup or not",
	"Method": "void setLazyInit(String value){\r\n    lazyInit = value;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOCodeGenerator.getCMPGenerator",
	"Comment": "returns cmp bean classes generator of the appropriate type.",
	"Method": "JDOConcreteBeanGenerator getCMPGenerator(IASEjbCMPEntityDescriptor descr){\r\n    JDOConcreteBeanGenerator cmpGenerator = null;\r\n    try {\r\n        if (descr.isEJB20()) {\r\n            cmpGenerator = getCMP20Generator();\r\n        } else {\r\n            cmpGenerator = getCMP11Generator();\r\n        }\r\n        cmpGenerator.setUpdateable(!descr.getIASEjbExtraDescriptors().isIsReadOnlyBean());\r\n    } catch (IOException e) {\r\n        throw JDOCodeGeneratorHelper.createGeneratorException(\"CMG.IOExceptionInInit\", bundle, e);\r\n    }\r\n    return cmpGenerator;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ClassDesc.createLocalHiddenField",
	"Comment": "creates an instance of localfielddesc for columnthat corresponds to a hidden field. adds the newly created field tohiddenfields and declaredhiddenfields.",
	"Method": "LocalFieldDesc createLocalHiddenField(ColumnElement column){\r\n    ArrayList columnDesc = new ArrayList();\r\n    columnDesc.add(column);\r\n    LocalFieldDesc lf = new LocalFieldDesc(this, columnDesc);\r\n    if (hiddenFields == null) {\r\n        hiddenFields = new ArrayList();\r\n    }\r\n    hiddenFields.add(lf);\r\n    lf.absoluteID = -hiddenFields.size();\r\n    if (logger.isLoggable(Logger.FINEST)) {\r\n        Object[] items = new Object[] { pcClass, lf.getName(), column.getName().getFullName() };\r\n        logger.finest(\"sqlstore.model.classdesc.getlocalfielddesc\", items);\r\n    }\r\n    return lf;\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecurityContextUtil.receivedReply",
	"Comment": "this is called by the csiv2 interceptor on the client aftera reply is received.",
	"Method": "void receivedReply(int reply_status,org.omg.CORBA.Object effective_target){\r\n    if (reply_status == STATUS_FAILED) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Failed status\");\r\n        }\r\n        throw new RuntimeException(\"Target did not accept security context\");\r\n    } else if (reply_status == STATUS_RETRY) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Retry status\");\r\n        }\r\n    } else {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Passed status\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.print",
	"Comment": "returns a formatted string of the attributes of this object.",
	"Method": "void print(StringBuffer toStringBuffer){\r\n    super.print(toStringBuffer);\r\n    toStringBuffer.append(\"\\n homeClassName \").append(homeClassName);\r\n    toStringBuffer.append(\"\\n remoteClassName \").append(remoteClassName);\r\n    toStringBuffer.append(\"\\n remoteBusinessIntfs \").append(remoteBusinessClassNames).append(\"\\n\");\r\n    toStringBuffer.append(\"\\n localhomeClassName \").append(localHomeClassName);\r\n    toStringBuffer.append(\"\\n localClassName \").append(localClassName);\r\n    toStringBuffer.append(\"\\n localBusinessIntfs \").append(localBusinessClassNames);\r\n    toStringBuffer.append(\"\\n isLocalBean \").append(isLocalBean()).append(\"\\n\");\r\n    toStringBuffer.append(\"\\n jndiName \").append(jndiName).append(\"\\n\");\r\n    toStringBuffer.append(\"\\n ejbClassName \").append(ejbClassName);\r\n    toStringBuffer.append(\"\\n transactionType \").append(transactionType);\r\n    toStringBuffer.append(\"\\n methodContainerTransactions \").append(getMethodContainerTransactions());\r\n    toStringBuffer.append(\"\\n environmentProperties \");\r\n    if (environmentProperties != null)\r\n        printDescriptorSet(environmentProperties, toStringBuffer);\r\n    toStringBuffer.append(\"\\n ejbReferences \");\r\n    if (ejbReferences != null)\r\n        printDescriptorSet(ejbReferences, toStringBuffer);\r\n    toStringBuffer.append(\"\\n resourceEnvReferences \");\r\n    if (resourceEnvReferences != null)\r\n        printDescriptorSet(resourceEnvReferences, toStringBuffer);\r\n    toStringBuffer.append(\"\\n messageDestReferences \");\r\n    if (messageDestReferences != null)\r\n        printDescriptorSet(messageDestReferences, toStringBuffer);\r\n    toStringBuffer.append(\"\\n resourceReferences \");\r\n    if (resourceReferences != null)\r\n        printDescriptorSet(resourceReferences, toStringBuffer);\r\n    toStringBuffer.append(\"\\n serviceReferences \");\r\n    if (serviceReferences != null)\r\n        printDescriptorSet(serviceReferences, toStringBuffer);\r\n    toStringBuffer.append(\"\\n roleReferences \");\r\n    if (roleReferences != null)\r\n        printDescriptorSet(roleReferences, toStringBuffer);\r\n    for (Iterator e = this.getPermissionedMethodsByPermission().keySet().iterator(); e.hasNext(); ) {\r\n        MethodPermission nextPermission = (MethodPermission) e.next();\r\n        toStringBuffer.append(\"\\n method-permission->method: \");\r\n        nextPermission.print(toStringBuffer);\r\n        toStringBuffer.append(\" -> \").append(this.getPermissionedMethodsByPermission().get(nextPermission));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.TransactionHelperImpl.setPersistenceManagerFactoryDefaults",
	"Comment": "set environment specific default values for the given persistencemanagerfactory. in most app servers optimistic and retainvalues flags should be false.for any other settings this method should be overritten.",
	"Method": "void setPersistenceManagerFactoryDefaults(PersistenceManagerFactory pmf){\r\n    pmf.setOptimistic(false);\r\n    pmf.setRetainValues(false);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ResourceReferenceDescriptor.setMailConfiguration",
	"Comment": "sets the mail configuration information for this reference.",
	"Method": "void setMailConfiguration(MailConfiguration mailConfiguration){\r\n    this.mailConfiguration = mailConfiguration;\r\n}"
}, {
	"Path": "org.glassfish.deployapi.SunDeploymentManager.getDefaultLocale",
	"Comment": "returns the default locale supported by this implementation of javax.enterprise.deploy.spi subpackages.",
	"Method": "Locale getDefaultLocale(){\r\n    return defaultLocale;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.Vector.removeAll",
	"Comment": "removes from this vector all of its elements that are contained in thespecified collection.",
	"Method": "boolean removeAll(Collection c){\r\n    boolean modified = false;\r\n    StateManager stateManager = this.makeDirty();\r\n    Iterator e = c.iterator();\r\n    while (e.hasNext()) {\r\n        Object o = e.next();\r\n        if (super.contains(o)) {\r\n            removeInternal(o);\r\n            if (added.remove(o) == false)\r\n                removed.add(o);\r\n            modified = true;\r\n        }\r\n    }\r\n    this.applyUpdates(stateManager, modified);\r\n    return modified;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.notifyStatusChange",
	"Comment": "for transaction to notify persistencemanager thatstatus is changed",
	"Method": "void notifyStatusChange(boolean isActive){\r\n    _activeTransaction = isActive;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingClassElementImpl.removeField",
	"Comment": "removes a field from the list of fields in this mapping class.",
	"Method": "void removeField(MappingFieldElement field){\r\n    try {\r\n        fireVetoableChange(PROP_FIELDS, null, null);\r\n        if (!getFields().remove(field)) {\r\n            throw new ModelException(// NOI18N\r\n            I18NHelper.getMessage(getMessages(), \"mapping.element.element_not_removed\", field));\r\n        }\r\n        firePropertyChange(PROP_FIELDS, null, null);\r\n    } catch (PropertyVetoException e) {\r\n        throw new ModelVetoException(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.getCollectionValue",
	"Comment": "returns the value of the collection relationship fieldff.for deferred scocollections, only theobjects added in the current transaction are returned.this method may only be called for collection fields!",
	"Method": "Collection getCollectionValue(ForeignFieldDesc ff){\r\n    Collection c = null;\r\n    if (ff.cardinalityUPB > 1) {\r\n        c = (Collection) ff.getValue(this);\r\n        if (c != null && c instanceof SCOCollection) {\r\n            SCOCollection sco = (SCOCollection) c;\r\n            if (sco.isDeferred()) {\r\n                c = sco.getAdded();\r\n            }\r\n        }\r\n    }\r\n    return c;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsSchemasInProcedureCalls",
	"Comment": "retrieves whether a schema name can be used in a procedure call statement.",
	"Method": "boolean supportsSchemasInProcedureCalls(){\r\n    return databaseMetaData.supportsSchemasInProcedureCalls();\r\n}"
}, {
	"Path": "org.glassfish.resources.connector.ResourcesCompositeSniffer.handles",
	"Comment": "returns true if the passed file or directory is recognized by thisinstance.",
	"Method": "boolean handles(ReadableArchive archive){\r\n    return ResourceUtil.hasResourcesXML(archive, locator);\r\n}"
}, {
	"Path": "com.sun.ejb.containers.ContainerSynchronization.getTimerSynchronization",
	"Comment": "might be null if no timer synch object for this timerid in this tx",
	"Method": "Synchronization getTimerSynchronization(TimerPrimaryKey timerId){\r\n    return (Synchronization) timerSyncs.get(timerId);\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.toString",
	"Comment": "fires probe event that a stack trace is to be printed on the server.log.the stack trace is mainly related to connection leak tracing for the given jdbc connection pool.",
	"Method": "void toString(StringBuffer stackTrace){\r\n    stackTrace.append(\"\\n Monitoring Statistics for \\n\" + poolName);\r\n    poolProbeProvider.toString(poolName, appName, moduleName, stackTrace);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.isServer",
	"Comment": "checks whether the executing environment is application server",
	"Method": "boolean isServer(){\r\n    return ProcessEnvironment.ProcessType.Server.equals(processType);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.meta.JDOMetaDataModelImpl.getPersistentFields",
	"Comment": "returns an array of field names of all declared, persistent fieldsof a class.",
	"Method": "String[] getPersistentFields(String classPath){\r\n    final String className = pathToName(classPath);\r\n    final PersistenceClassElement pce = model.getPersistenceClass(className);\r\n    if (pce == null)\r\n        return new String[] {};\r\n    final PersistenceFieldElement[] pfes = pce.getFields();\r\n    final int nofFields = (pfes != null ? pfes.length : 0);\r\n    final String[] names = new String[nofFields];\r\n    for (int i = 0; i < nofFields; i++) {\r\n        final PersistenceFieldElement pfe = pfes[i];\r\n        names[i] = pfe.getName();\r\n        if (false) {\r\n            if (pfe.getPersistenceType() != PersistenceFieldElement.PERSISTENT) {\r\n                final String msg = (\"Getting persistent field names: \" + \"Encountered non-persistent field '\" + names[i] + \"' for class \" + classPath);\r\n                throw new JDOMetaDataFatalError(msg);\r\n            }\r\n        }\r\n    }\r\n    return names;\r\n}"
}, {
	"Path": "com.sun.jaspic.config.factory.BaseAuthConfigFactory.getRegistrationContext",
	"Comment": "get the the registration context for the identified registration.",
	"Method": "RegistrationContext getRegistrationContext(String registrationID){\r\n    rLock.lock();\r\n    try {\r\n        return id2RegisContextMap.get(registrationID);\r\n    } finally {\r\n        rLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxTablesInSelect",
	"Comment": "retrieves the maximum number of tables this database allows in aselect statement.",
	"Method": "int getMaxTablesInSelect(){\r\n    return databaseMetaData.getMaxTablesInSelect();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ServiceReferenceDescriptor.getHandlers",
	"Comment": "get ordered list of webservicehandler handlers for this endpoint.",
	"Method": "LinkedList getHandlers(){\r\n    return handlers;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.AbstractMethodHelper.getRemoteHome",
	"Comment": "gets the name of the remote home which corresponds to this bean.",
	"Method": "String getRemoteHome(){\r\n    return getDescriptor().getHomeClassName();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.Vector.insertElementAt",
	"Comment": "inserts the specified object as a component in this vector at thespecified index.",
	"Method": "void insertElementAt(Object obj,int index){\r\n    if (allowNulls == false && obj == null) {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"sco.nulls_not_allowed\"));\r\n    }\r\n    if (elementType == null || elementType.isAssignableFrom(obj.getClass())) {\r\n        StateManager stateManager = this.makeDirty();\r\n        super.insertElementAt(obj, index);\r\n        if (removed.remove(obj) == false)\r\n            added.add(obj);\r\n        this.applyUpdates(stateManager, true);\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        messages, \"sco.classcastexception\", elementType.getName()), new ClassCastException(), new Object[] { obj });\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.LogViewHandlers.parseDateString",
	"Comment": "this method simply takes the given simpledateformat and parses the givenstring after applying the given format string.",
	"Method": "Date parseDateString(SimpleDateFormat fmt,String format,String dateTime){\r\n    fmt.applyLocalizedPattern(format);\r\n    return fmt.parse(dateTime);\r\n}"
}, {
	"Path": "org.glassfish.enterprise.api.enabler.ORBConnectorStartup.initializeLazyListener",
	"Comment": "start grizzly based orb lazy listener, which is going to initializeorb container on first request.",
	"Method": "void initializeLazyListener(){\r\n    final IiopService iiopService = config.getExtensionByType(IiopService.class);\r\n    if (iiopService != null) {\r\n        List<IiopListener> iiopListenerList = iiopService.getIiopListener();\r\n        for (IiopListener oneListener : iiopListenerList) {\r\n            if (Boolean.valueOf(oneListener.getEnabled()) && Boolean.valueOf(oneListener.getLazyInit())) {\r\n                NetworkListener dummy = new DummyNetworkListener();\r\n                dummy.setPort(oneListener.getPort());\r\n                dummy.setAddress(oneListener.getAddress());\r\n                dummy.setProtocol(\"light-weight-listener\");\r\n                dummy.setTransport(\"tcp\");\r\n                dummy.setName(\"iiop-service\");\r\n                grizzlyService.createNetworkProxy(dummy);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnUtils.fLoad",
	"Comment": "return the best instruction for loading a float from a localvariable slot",
	"Method": "Insn fLoad(int i,ConstantPool pool){\r\n    if (i == 0)\r\n        return Insn.create(opc_fload_0);\r\n    else if (i == 1)\r\n        return Insn.create(opc_fload_1);\r\n    else if (i == 2)\r\n        return Insn.create(opc_fload_2);\r\n    else if (i == 3)\r\n        return Insn.create(opc_fload_3);\r\n    return Insn.create(opc_fload, i);\r\n}"
}, {
	"Path": "org.glassfish.deployapi.ProgressObjectImpl.getDeploymentStatusMessage",
	"Comment": "parse the deploymentstatus to get the status message within",
	"Method": "String getDeploymentStatusMessage(DFDeploymentStatus status){\r\n    if (status == null) {\r\n        return null;\r\n    }\r\n    if (DFDeploymentStatus.Status.SUCCESS.isWorseThanOrEqual(status.getStatus())) {\r\n        return null;\r\n    }\r\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    PrintWriter pw = new PrintWriter(bos);\r\n    DFDeploymentStatus.parseDeploymentStatus(status, pw);\r\n    byte[] statusBytes = bos.toByteArray();\r\n    String statusString = new String(statusBytes);\r\n    if (status.getStatus() == DFDeploymentStatus.Status.WARNING) {\r\n        if (warningMessages == null) {\r\n            warningMessages = WARNING_PREFIX + statusString;\r\n        } else {\r\n            warningMessages += statusString;\r\n        }\r\n        return null;\r\n    }\r\n    return statusString;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.jqlc.ErrorMsg.unsupported",
	"Comment": "indicates that a feature is not supported by the current release.",
	"Method": "void unsupported(int line,int col,String msg){\r\n    JDOUnsupportedOptionException ex;\r\n    if (line > 1) {\r\n        Object[] args = { context, new Integer(line), new Integer(col), msg };\r\n        ex = new JDOUnsupportedOptionException(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        messages, \"jqlc.errormsg.generic.msglinecolumn\", args));\r\n    } else if (col > 0) {\r\n        Object[] args = { context, new Integer(col), msg };\r\n        ex = new JDOUnsupportedOptionException(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        messages, \"jqlc.errormsg.generic.msgcolumn\", args));\r\n    } else {\r\n        Object[] args = { context, msg };\r\n        ex = new JDOUnsupportedOptionException(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        messages, \"jqlc.errormsg.generic.msg\", args));\r\n    }\r\n    logger.throwing(\"jqlc.ErrorMsg\", \"unsupported\", ex);\r\n    throw ex;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.perms.DeclaredPermissionsProcessor.getAdjustedDeclaredPermissions",
	"Comment": "get the declared permissions which have the file path adjusted for the right module",
	"Method": "PermissionCollection getAdjustedDeclaredPermissions(){\r\n    return declaredPc;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.scope.SymbolTable.declare",
	"Comment": "add identifier to the actual scope.if the identifier was already declared in the actualscope the symbol table is not changed and the old definitionis returned. otherwise a possible definition of a lower level scope is saved in the actual nesting and the new definition is stored in the symbol table. this allows to reinstall the olddefinition when the sctaul scope is closed.",
	"Method": "Definition declare(String ident,Definition def){\r\n    Definition old = (Definition) symbols.get(ident);\r\n    def.setScope(actualScope);\r\n    if ((old == null) || (old.getScope() < actualScope)) {\r\n        Nesting nest = (Nesting) nestings.peek();\r\n        nest.add(ident, old);\r\n        symbols.put(ident, def);\r\n        return null;\r\n    } else {\r\n        return old;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.deployment.AuthorizationConstraintImpl.removeSecurityRole",
	"Comment": "removes the given role from the autrhorization constraint.",
	"Method": "void removeSecurityRole(SecurityRole securityRole){\r\n    this.getSecurityRoleSet().remove(securityRole);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.addConnectionEventListener",
	"Comment": "adds a connection event listener to the managedconnectionimpl instance.",
	"Method": "void addConnectionEventListener(ConnectionEventListener listener){\r\n    this.listener = listener;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.meta.JDOMetaDataPropertyImpl.isTransactionalField",
	"Comment": "tests whether a field of a class is known to be transactional.",
	"Method": "boolean isTransactionalField(String classPath,String fieldName){\r\n    JDOField field = getJDOField(classPath, fieldName);\r\n    return (field != null ? field.isTransactional() : false);\r\n}"
}, {
	"Path": "org.glassfish.deployapi.ProgressObjectSink.handleProgressEvent",
	"Comment": "receives notification of a progress event from one of our registered interface.",
	"Method": "void handleProgressEvent(ProgressEvent progressEvent){\r\n    ProgressEvent forwardedEvent;\r\n    DeploymentStatus forwardedDS = progressEvent.getDeploymentStatus();\r\n    if (!forwardedDS.isRunning()) {\r\n        if (forwardedDS.isFailed()) {\r\n            finalStateType = StateType.FAILED;\r\n        }\r\n        Object source = progressEvent.getSource();\r\n        if (source instanceof ProgressObject) {\r\n            ProgressObject po = (ProgressObject) source;\r\n            po.removeProgressListener(this);\r\n            sources.remove(source);\r\n            if (forwardedDS.isCompleted()) {\r\n                TargetModuleID[] ids = po.getResultTargetModuleIDs();\r\n                for (int i = 0; i < ids.length; i++) {\r\n                    targetModuleIDs.add(ids[i]);\r\n                }\r\n            }\r\n        } else {\r\n            throw new RuntimeException(localStrings.getLocalString(\"enterprise.deployment.client.noprogressobject\", \"Progress event does not contain a ProgressObject source\"));\r\n        }\r\n        updateCompletedStatus(forwardedDS);\r\n        DeploymentStatusImpl forwardedStatus = new DeploymentStatusImpl();\r\n        forwardedStatus.setState(StateType.RUNNING);\r\n        forwardedStatus.setMessage(forwardedDS.getMessage());\r\n        forwardedStatus.setCommand(forwardedDS.getCommand());\r\n        forwardedEvent = new ProgressEvent(this, progressEvent.getTargetModuleID(), forwardedStatus);\r\n    } else {\r\n        forwardedEvent = new ProgressEvent(this, progressEvent.getTargetModuleID(), forwardedDS);\r\n    }\r\n    Collection clone;\r\n    ProgressEvent finalEvent = null;\r\n    synchronized (registeredPL) {\r\n        clone = (Collection) registeredPL.clone();\r\n        deliveredEvents.add(forwardedEvent);\r\n        if (sources.isEmpty()) {\r\n            prepareCompletedStatus();\r\n            DeploymentStatusImpl status = new DeploymentStatusImpl();\r\n            status.setState(finalStateType);\r\n            if (finalStateType.equals(StateType.FAILED)) {\r\n                status.setMessage(localStrings.getLocalString(\"enterprise.deployment.client.aggregatefailure\", \"At least one operation failed\"));\r\n            } else {\r\n                status.setMessage(localStrings.getLocalString(\"enterprise.deployment.client.aggregatesuccess\", \"All operations completed successfully\"));\r\n            }\r\n            finalEvent = new ProgressEvent(this, progressEvent.getTargetModuleID(), status);\r\n            deliveredEvents.add(finalEvent);\r\n        }\r\n    }\r\n    for (Iterator itr = clone.iterator(); itr.hasNext(); ) {\r\n        ProgressListener pl = (ProgressListener) itr.next();\r\n        pl.handleProgressEvent(forwardedEvent);\r\n    }\r\n    if (finalEvent != null) {\r\n        for (Iterator itr = clone.iterator(); itr.hasNext(); ) {\r\n            ProgressListener pl = (ProgressListener) itr.next();\r\n            pl.handleProgressEvent(finalEvent);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.embedded.DomainXmlTransformer.getSkippedElementStartEvent",
	"Comment": "create a new start element based on the original but that does not includethe specified attribute.",
	"Method": "StartElement getSkippedElementStartEvent(XMLEvent event){\r\n    Set attributes = new HashSet();\r\n    for (java.util.Iterator i = event.asStartElement().getAttributes(); i.hasNext(); ) {\r\n        Attribute a = (Attribute) i.next();\r\n        if (!DISABLE_SUB_ELEMENTS.contains(a.getName().getLocalPart())) {\r\n            attributes.add(a);\r\n        }\r\n    }\r\n    StartElement oldStartEvent = event.asStartElement();\r\n    return xmlEventFactory.createStartElement(oldStartEvent.getName(), attributes.iterator(), oldStartEvent.getNamespaces());\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.ActiveJmsResourceAdapter.initializeLazyListener",
	"Comment": "start grizzly based jms lazy listener, which is going to initializejms container on first request.",
	"Method": "void initializeLazyListener(JmsService jmsService){\r\n    if (jmsService != null) {\r\n        if (EMBEDDED.equalsIgnoreCase(jmsService.getType()) && !grizzlyListenerInit) {\r\n            GrizzlyService grizzlyService = Globals.get(GrizzlyService.class);\r\n            if (grizzlyService != null) {\r\n                List<JmsHost> jmsHosts = jmsService.getJmsHost();\r\n                for (JmsHost oneHost : jmsHosts) {\r\n                    if (Boolean.valueOf(oneHost.getLazyInit()) && !doBind) {\r\n                        String jmsHost = null;\r\n                        if (oneHost.getHost() != null && \"localhost\".equals(oneHost.getHost())) {\r\n                            jmsHost = \"0.0.0.0\";\r\n                        } else {\r\n                            jmsHost = oneHost.getHost();\r\n                        }\r\n                        NetworkListener dummy = new DummyNetworkListener();\r\n                        dummy.setPort(oneHost.getPort());\r\n                        dummy.setAddress(jmsHost);\r\n                        dummy.setType(\"proxy\");\r\n                        dummy.setProtocol(JMS_SERVICE);\r\n                        dummy.setTransport(\"tcp\");\r\n                        String name = GRIZZLY_PROXY_PREFIX + oneHost.getName();\r\n                        dummy.setName(name);\r\n                        synchronized (grizzlyListeners) {\r\n                            grizzlyService.createNetworkProxy(dummy);\r\n                            grizzlyListeners.add(name);\r\n                        }\r\n                        grizzlyListenerInit = true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.node.MethodPermissionNode.writeDescriptorInNode",
	"Comment": "write the descriptor in a dom tree which root element is provided",
	"Method": "Node writeDescriptorInNode(Node subNode,MethodPermissionDescriptor descriptor,EjbDescriptor ejb){\r\n    writeLocalizedDescriptions(subNode, descriptor);\r\n    MethodPermission[] mps = descriptor.getMethodPermissions();\r\n    if (mps.length == 0)\r\n        return null;\r\n    if (!mps[0].isExcluded()) {\r\n        if (mps[0].isUnchecked()) {\r\n            appendChild(subNode, EjbTagNames.UNCHECKED);\r\n        } else {\r\n            for (int i = 0; i < mps.length; i++) {\r\n                appendTextChild(subNode, TagNames.ROLE_NAME, mps[i].getRole().getName());\r\n            }\r\n        }\r\n    }\r\n    MethodDescriptor[] methods = descriptor.getMethods();\r\n    MethodNode mn = new MethodNode();\r\n    for (int i = 0; i < methods.length; i++) {\r\n        String ejbName = ejb.getName();\r\n        mn.writeDescriptor(subNode, EjbTagNames.METHOD, methods[i], ejbName);\r\n    }\r\n    return subNode;\r\n}"
}, {
	"Path": "org.glassfish.deployapi.config.SunDeploymentConfiguration.restoreDConfigBean",
	"Comment": "restore from disk to instantated objects all the dconfigbeans associated with a specific deployment descriptor. the beansmay be fully or partially configured.",
	"Method": "DConfigBeanRoot restoreDConfigBean(InputStream inputStream,DDBeanRoot dDBeanRoot){\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.getEjbReferenceByName",
	"Comment": "return a reference to another ejb by the same name or throw an illegalargumentexception.",
	"Method": "EjbReference getEjbReferenceByName(String name){\r\n    return (EjbReferenceDescriptor) getEjbReference(name);\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.ConnectionPool.increaseSteadyPoolSize",
	"Comment": "increase the number of steady resources in the pool if we detect that the steadypoolsize has been increased",
	"Method": "void increaseSteadyPoolSize(int newSteadyPoolSize){\r\n    cancelResizerTask();\r\n    for (int i = ds.getResourcesSize(); i < newSteadyPoolSize; i++) {\r\n        createResourceAndAddToPool(allocator);\r\n    }\r\n    scheduleResizerTask();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.application.gf.ApplicationRuntimeNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object newDescriptor){\r\n    if (newDescriptor instanceof SecurityRoleMapping) {\r\n        SecurityRoleMapping roleMap = (SecurityRoleMapping) newDescriptor;\r\n        if (descriptor != null && !descriptor.isVirtual()) {\r\n            descriptor.addSecurityRoleMapping(roleMap);\r\n            Role role = new Role(roleMap.getRoleName());\r\n            SecurityRoleMapper rm = descriptor.getRoleMapper();\r\n            if (rm != null) {\r\n                List<PrincipalNameDescriptor> principals = roleMap.getPrincipalNames();\r\n                for (int i = 0; i < principals.size(); i++) {\r\n                    rm.assignRole(principals.get(i).getPrincipal(), role, descriptor);\r\n                }\r\n                List<String> groups = roleMap.getGroupNames();\r\n                for (int i = 0; i < groups.size(); i++) {\r\n                    rm.assignRole(new Group(groups.get(i)), role, descriptor);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.StatementWrapper.clearWarnings",
	"Comment": "clears all the warnings reported on this statementobject. after a call to this method,the method getwarnings will returnnull until a new warning is reported for thisstatement object.",
	"Method": "void clearWarnings(){\r\n    jdbcStatement.clearWarnings();\r\n}"
}, {
	"Path": "com.sun.gjc.util.SQLTraceDelegator.isMethodValidForCaching",
	"Comment": "check if the method name from the sql trace record can be used toretrieve a sql string for caching purpose. most of the method names do not contain a sql string and hence are unusable for caching the sql strings. these method names are filtered in this method.",
	"Method": "boolean isMethodValidForCaching(String methodName){\r\n    return JdbcRAConstants.validSqlTracingMethodNames.contains(methodName);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerWrapper.isClosed",
	"Comment": "a persistencemanager instance can be used until it is closed.",
	"Method": "boolean isClosed(){\r\n    if (isValid) {\r\n        return pm.isClosed();\r\n    } else {\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.AbstractSingletonContainer.createEJBLocalObjectImpl",
	"Comment": "called during client creation request through ejb localhome view.",
	"Method": "EJBLocalObjectImpl createEJBLocalObjectImpl(){\r\n    throw new CreateException(\"EJB 2.x Local view not supported on Singletons\");\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.module.ConnectorDeployer.clean",
	"Comment": "clean any files and artifacts that were created during the executionof the prepare method.",
	"Method": "void clean(DeploymentContext dc){\r\n    super.clean(dc);\r\n    UndeployCommandParameters dcp = dc.getCommandParameters(UndeployCommandParameters.class);\r\n    if (dcp != null && dcp.origin == OpsParams.Origin.undeploy) {\r\n        if (dcp.cascade != null && dcp.cascade) {\r\n            File sourceDir = dc.getSourceDir();\r\n            String moduleName = sourceDir.getName();\r\n            if (ConnectorsUtil.isEmbedded(dc)) {\r\n                String applicationName = ConnectorsUtil.getApplicationName(dc);\r\n                moduleName = ConnectorsUtil.getEmbeddedRarModuleName(applicationName, moduleName);\r\n            }\r\n            deleteAllResources(moduleName, dcp.target);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployapi.SunDeploymentManager.getAvailableModules",
	"Comment": "retrieve the list of all j2ee application modules runningor not running on the identified targets.",
	"Method": "TargetModuleID[] getAvailableModules(ModuleType moduleType,Target[] targetList){\r\n    return getModules(moduleType, targetList, DFDeploymentProperties.ALL);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.util.ApplicationValidator.validateResourceDescriptor",
	"Comment": "method to read complete application and all defined descriptor for given app. method is used to identifyscope and validation for all defined jndi names at different namespace.",
	"Method": "boolean validateResourceDescriptor(Application application){\r\n    final String APP_LEVEL = \"AppLevel:\";\r\n    final String EJBBUNDLE_LEVEL = \"EBDLevel:\";\r\n    final String EJB_LEVEL = \"EJBLevel:\";\r\n    final String APPCLIENTBUNDLE_LEVEL = \"ACDevel:\";\r\n    final String APPCLIENT_LEVEL = \"ACLevel:\";\r\n    final String WEBBUNDLE_LEVEL = \"WBDLevel:\";\r\n    Set<EnvironmentProperty> environmentProperties = application != null ? application.getEnvironmentProperties() : null;\r\n    if (environmentProperties != null) {\r\n        for (EnvironmentProperty environmentProperty : environmentProperties) {\r\n            String jndiName = environmentProperty.getName();\r\n            if (environmentProperty.hasLookupName()) {\r\n                jndiName = environmentProperty.getLookupName();\r\n            } else if (environmentProperty.getMappedName().length() > 0) {\r\n                jndiName = environmentProperty.getMappedName();\r\n            }\r\n            if (jndiName.startsWith(JNDI_COMP) || jndiName.startsWith(JNDI_MODULE)) {\r\n                inValidJndiName = jndiName;\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    CommonResourceBundleDescriptor commonResourceBundleDescriptor = application != null ? (CommonResourceBundleDescriptor) application : null;\r\n    Vector appLevel = new Vector();\r\n    if (commonResourceBundleDescriptor != null) {\r\n        Set<ResourceDescriptor> resourceDescriptors = commonResourceBundleDescriptor.getAllResourcesDescriptors();\r\n        if (findExistingDescriptors(resourceDescriptors, APP_LEVEL + commonResourceBundleDescriptor.getName())) {\r\n            return false;\r\n        }\r\n        appLevel.add(APP_LEVEL + commonResourceBundleDescriptor.getName());\r\n        validNameSpaceDetails.put(APP_KEYS, appLevel);\r\n    }\r\n    Set<ApplicationClientDescriptor> appClientDescs = application.getBundleDescriptors(ApplicationClientDescriptor.class);\r\n    Vector appClientLevel = new Vector();\r\n    for (ApplicationClientDescriptor acd : appClientDescs) {\r\n        Set<ResourceDescriptor> resourceDescriptors = acd.getAllResourcesDescriptors(ApplicationClientDescriptor.class);\r\n        if (findExistingDescriptors(resourceDescriptors, APPCLIENTBUNDLE_LEVEL + acd.getName())) {\r\n            return false;\r\n        }\r\n        appClientLevel.add(APPCLIENTBUNDLE_LEVEL + acd.getName());\r\n    }\r\n    validNameSpaceDetails.put(APPCLIENT_KEYS, appClientLevel);\r\n    Set<ConnectorDescriptor> connectorDescs = application.getBundleDescriptors(ConnectorDescriptor.class);\r\n    Vector cdLevel = new Vector();\r\n    for (ConnectorDescriptor cd : connectorDescs) {\r\n        Set<ResourceDescriptor> resourceDescriptors = cd.getAllResourcesDescriptors(ApplicationClientDescriptor.class);\r\n        if (findExistingDescriptors(resourceDescriptors, APPCLIENT_LEVEL + cd.getName())) {\r\n            return false;\r\n        }\r\n        cdLevel.add(APPCLIENT_LEVEL + cd.getName());\r\n    }\r\n    validNameSpaceDetails.put(CONNECTOR_KEYS, cdLevel);\r\n    Set<EjbBundleDescriptor> ejbBundleDescs = application.getBundleDescriptors(EjbBundleDescriptor.class);\r\n    Vector ebdLevel = new Vector();\r\n    Vector edLevel = new Vector();\r\n    for (EjbBundleDescriptor ebd : ejbBundleDescs) {\r\n        Set<ResourceDescriptor> resourceDescriptors = ebd.getAllResourcesDescriptors();\r\n        if (findExistingDescriptors(resourceDescriptors, EJBBUNDLE_LEVEL + ebd.getName())) {\r\n            return false;\r\n        }\r\n        ebdLevel.add(EJBBUNDLE_LEVEL + ebd.getName());\r\n        Set<EjbDescriptor> ejbDescriptors = (Set<EjbDescriptor>) ebd.getEjbs();\r\n        for (Iterator itr = ejbDescriptors.iterator(); itr.hasNext(); ) {\r\n            EjbDescriptor ejbDescriptor = (EjbDescriptor) itr.next();\r\n            resourceDescriptors = ejbDescriptor.getAllResourcesDescriptors();\r\n            if (findExistingDescriptors(resourceDescriptors, EJB_LEVEL + ebd.getName() + \"#\" + ejbDescriptor.getName())) {\r\n                return false;\r\n            }\r\n            edLevel.add(EJB_LEVEL + ebd.getName() + \"#\" + ejbDescriptor.getName());\r\n        }\r\n    }\r\n    validNameSpaceDetails.put(EJBBUNDLE_KEYS, ebdLevel);\r\n    validNameSpaceDetails.put(EJB_KEYS, edLevel);\r\n    Set<WebBundleDescriptor> webBundleDescs = application.getBundleDescriptors(WebBundleDescriptor.class);\r\n    Vector wbdLevel = new Vector();\r\n    for (WebBundleDescriptor wbd : webBundleDescs) {\r\n        Set<ResourceDescriptor> resourceDescriptors = wbd.getAllResourcesDescriptors();\r\n        if (findExistingDescriptors(resourceDescriptors, WEBBUNDLE_LEVEL + wbd.getName())) {\r\n            return false;\r\n        }\r\n        wbdLevel.add(WEBBUNDLE_LEVEL + wbd.getName());\r\n    }\r\n    validNameSpaceDetails.put(WEBBUNDLE_KEYS, wbdLevel);\r\n    for (CommonResourceValidator rv : allResourceDescriptors.values()) {\r\n        Descriptor desc = rv.getDescriptor();\r\n        if (desc instanceof AbstractConnectorResourceDescriptor) {\r\n            AbstractConnectorResourceDescriptor acrd = (AbstractConnectorResourceDescriptor) desc;\r\n            if (acrd.getResourceAdapter() == null) {\r\n                continue;\r\n            }\r\n            int poundIndex = acrd.getResourceAdapter().indexOf(\"#\");\r\n            if (poundIndex == 0) {\r\n                acrd.setResourceAdapter(application.getName() + acrd.getResourceAdapter());\r\n            } else if (poundIndex < 0) {\r\n            } else {\r\n                deplLogger.log(Level.SEVERE, RESOURCE_ADAPTER_NAME_INVALID, new Object[] { application.getAppName(), acrd.getName(), acrd.getResourceAdapter() });\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    if (allUniqueResource) {\r\n        return compareDescriptors();\r\n    }\r\n    return allUniqueResource;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.locatorsUpdateCopy",
	"Comment": "indicates whether updates made to a lob are made on a copy or directlyto the lob.",
	"Method": "boolean locatorsUpdateCopy(){\r\n    return databaseMetaData.locatorsUpdateCopy();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.getResourceReferenceByName",
	"Comment": "return the resource object corresponding to the supplied name or throw an illegal argument exception.",
	"Method": "ResourceReferenceDescriptor getResourceReferenceByName(String name){\r\n    for (Iterator itr = this.getResourceReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        ResourceReferenceDescriptor next = (ResourceReferenceDescriptor) itr.next();\r\n        if (next.getName().equals(name)) {\r\n            return next;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionapphasnoresourcerefbyname\", \"This app {0} has no resource reference by the name of {1}\", new Object[] { getRegistrationName(), name }));\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.getEjbByName",
	"Comment": "returns an ejb descriptor that i have by the same name. create a dummyejbdescriptor if requested, otherwisethrows an illegalargumentexception",
	"Method": "EjbDescriptor getEjbByName(String name,EjbDescriptor getEjbByName,String name,boolean isCreateDummy){\r\n    for (EjbDescriptor next : getEjbs()) {\r\n        if (next.getName().equals(name)) {\r\n            return next;\r\n        }\r\n    }\r\n    if (!isCreateDummy) {\r\n        throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionbeanbundle\", \"Referencing error: this bundle has no bean of name: {0}\", name));\r\n    }\r\n    _logger.log(Level.FINE, \"enterprise.deployment_dummy_ejb_descriptor\", new Object[] { name });\r\n    DummyEjbDescriptor dummyEjbDesc = new DummyEjbDescriptor();\r\n    dummyEjbDesc.setName(name);\r\n    addEjb(dummyEjbDesc);\r\n    return dummyEjbDesc;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsSelectForUpdate",
	"Comment": "retrieves whether this database supports select for updatestatements.",
	"Method": "boolean supportsSelectForUpdate(){\r\n    return databaseMetaData.supportsSelectForUpdate();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.removeConcurrencyGroup",
	"Comment": "remove the supplied group from the collection of concurrency groups for \tthis class.",
	"Method": "void removeConcurrencyGroup(ConcurrencyGroupElement group){\r\n    removeConcurrencyGroups(new ConcurrencyGroupElement[] { group });\r\n}"
}, {
	"Path": "org.glassfish.persistence.jpaconnector.JPASniffer.supportsArchiveType",
	"Comment": "this api is used to help determine if the sniffer should recognizethe current archive.if the sniffer does not support the archive type associated withthe current deployment, the sniffer should not recognize the archive.",
	"Method": "boolean supportsArchiveType(ArchiveType archiveType){\r\n    if (archiveType.toString().equals(ModuleType.WAR.toString()) || archiveType.toString().equals(ModuleType.EJB.toString()) || archiveType.toString().equals(ModuleType.CAR.toString())) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.RelationshipElement.isPrefetch",
	"Comment": "determines whether this relationship element should prefetch or not.",
	"Method": "boolean isPrefetch(boolean isPrefetch){\r\n    return getRelationshipImpl().isPrefetch();\r\n}"
}, {
	"Path": "org.glassfish.concurrent.admin.DeleteManagedThreadFactory.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        ResourceStatus rs = managedThreadFactoryMgr.delete(domain.getResources(), jndiName, target);\r\n        if (rs.getMessage() != null) {\r\n            report.setMessage(rs.getMessage());\r\n        }\r\n        if (rs.getStatus() == ResourceStatus.SUCCESS) {\r\n            report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n        } else {\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            if (rs.getException() != null)\r\n                report.setFailureCause(rs.getException());\r\n        }\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.managed.thread.factory.failed\", \"Managed thread factory {0} deletion failed\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.datastructure.RWLockDataStructure.setMaxSize",
	"Comment": "set maxsize based on the new max pool size set on the connection pool during a reconfiguration.",
	"Method": "void setMaxSize(int maxSize){\r\n    this.maxSize = maxSize;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.writeRuntimeDeploymentDescriptors",
	"Comment": "writes the runtime deployment descriptors to an abstract archive",
	"Method": "void writeRuntimeDeploymentDescriptors(ReadableArchive in,WritableArchive out){\r\n    T desc = getDescriptor();\r\n    List<ConfigurationDeploymentDescriptorFile> confDDFilesToWrite = getSortedConfigurationDDFiles(in);\r\n    if (confDDFilesToWrite.isEmpty()) {\r\n        confDDFilesToWrite = getConfigurationDDFiles();\r\n    }\r\n    for (ConfigurationDeploymentDescriptorFile ddFile : confDDFilesToWrite) {\r\n        ddFile.setArchiveType(getModuleType());\r\n        OutputStream os = out.putNextEntry(ddFile.getDeploymentDescriptorPath());\r\n        ddFile.write(desc, os);\r\n        out.closeEntry();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingReferenceKeyElementImpl.setTableInternal",
	"Comment": "set the mapping table for this referencing key to the supplied table \twithout firing any property change events.",
	"Method": "void setTableInternal(MappingTableElement table){\r\n    if (table == null) {\r\n        throw new ModelException(// NOI18N\r\n        I18NHelper.getMessage(getMessages(), \"mapping.element.null_argument\"));\r\n    }\r\n    _table = table;\r\n    if (null == getDeclaringClass())\r\n        _declaringClass = table.getDeclaringClass();\r\n    if (null == getName())\r\n        _name = table.getName();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.meta.JDOMetaDataModelImpl.getManagedFields",
	"Comment": "returns an array of field names of all declared persistent andtransactional fields of a class.",
	"Method": "String[] getManagedFields(String classPath){\r\n    return getPersistentFields(classPath);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.FieldAction.createMethodSig",
	"Comment": "return the type signature of the static method on class field whichwill create a field of the appropriate type.",
	"Method": "String createMethodSig(){\r\n    return fieldTypeInfo.fieldCreateMethodSig;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.DriverLoader.isResType",
	"Comment": "find if the particular class has any implementations of java.sql.driver orjavax.sql.datasource or any other restypes passed.",
	"Method": "boolean isResType(Class cls,String resType){\r\n    boolean isResType = false;\r\n    if (cls != null) {\r\n        if (\"javax.sql.DataSource\".equals(resType)) {\r\n            if (javax.sql.DataSource.class.isAssignableFrom(cls)) {\r\n                isResType = isNotAbstract(cls);\r\n            }\r\n        } else if (\"javax.sql.ConnectionPoolDataSource\".equals(resType)) {\r\n            if (javax.sql.ConnectionPoolDataSource.class.isAssignableFrom(cls)) {\r\n                isResType = isNotAbstract(cls);\r\n            }\r\n        } else if (\"javax.sql.XADataSource\".equals(resType)) {\r\n            if (javax.sql.XADataSource.class.isAssignableFrom(cls)) {\r\n                isResType = isNotAbstract(cls);\r\n            }\r\n        } else if (\"java.sql.Driver\".equals(resType)) {\r\n            if (java.sql.Driver.class.isAssignableFrom(cls)) {\r\n                isResType = isNotAbstract(cls);\r\n            }\r\n        }\r\n    }\r\n    return isResType;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.ApplicationArchivist.createApplication",
	"Comment": "this method creates a top level application object for an ear.",
	"Method": "Application createApplication(ReadableArchive archive,boolean directory){\r\n    if (hasStandardDeploymentDescriptor(archive)) {\r\n        return readStandardDeploymentDescriptor(archive);\r\n    } else {\r\n        return getApplicationFromIntrospection(archive, directory);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.InterceptorDescriptor.orderDescriptors",
	"Comment": "order a set of lifecycle method descriptors for a particularinheritance hierarchy with highest precedence assigned to theleast derived class.",
	"Method": "List<LifecycleCallbackDescriptor> orderDescriptors(Set<LifecycleCallbackDescriptor> lcds,ClassLoader loader){\r\n    LinkedList<LifecycleCallbackDescriptor> orderedDescs = new LinkedList<LifecycleCallbackDescriptor>();\r\n    Map<String, LifecycleCallbackDescriptor> map = new HashMap<String, LifecycleCallbackDescriptor>();\r\n    for (LifecycleCallbackDescriptor next : lcds) {\r\n        map.put(next.getLifecycleCallbackClass(), next);\r\n    }\r\n    Class nextClass = loader.loadClass(getInterceptorClassName());\r\n    while ((nextClass != Object.class) && (nextClass != null)) {\r\n        String nextClassName = nextClass.getName();\r\n        if (map.containsKey(nextClassName)) {\r\n            LifecycleCallbackDescriptor lcd = map.get(nextClassName);\r\n            orderedDescs.addFirst(lcd);\r\n        }\r\n        nextClass = nextClass.getSuperclass();\r\n    }\r\n    return orderedDescs;\r\n}"
}, {
	"Path": "org.glassfish.deployapi.SunDeploymentManager.isRedeploySupported",
	"Comment": "this method designates whether this platform vendor provides application redeployment functionality. a value of true means it is supported.false means it is not.",
	"Method": "boolean isRedeploySupported(){\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.ejb.base.stats.StatefulSessionStoreStatsImpl.getActivationSuccessCount",
	"Comment": "returns the total number of sessions successfully activated from the store",
	"Method": "CountStatistic getActivationSuccessCount(){\r\n    synchronized (activationCountLock) {\r\n        activationSuccessCount.setCount(activationSuccessCountVal);\r\n        return (CountStatistic) activationSuccessCount.unmodifiableView();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.util.RestUtil.sendUpdateRequest",
	"Comment": "but the rest api will be modified to use put for updates, a more correct use of http",
	"Method": "RestResponse sendUpdateRequest(String endpoint,Map<String, Object> attrs,List<String> skipAttrs,List<String> onlyUseAttrs,List<String> convertToFalse){\r\n    removeSpecifiedAttrs(attrs, skipAttrs);\r\n    attrs = buildUseOnlyAttrMap(attrs, onlyUseAttrs);\r\n    attrs = convertNullValuesToFalse(attrs, convertToFalse);\r\n    attrs = fixKeyNames(attrs);\r\n    return post(endpoint, attrs);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.LocalFieldDesc.incrementValue",
	"Comment": "increments this field in the instance managed by state managersm by one.",
	"Method": "void incrementValue(StateManager sm){\r\n    assert isVersion();\r\n    Long val = (Long) getValue(sm);\r\n    long value = (val != null) ? val.longValue() : 0;\r\n    setValue(sm, new Long(++value));\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.AbstractDataSource.getConnection",
	"Comment": "retrieves the actual sqlconnection from the connection wrapperimplementation of sunone application server. if an actual connection issupplied as argument, then it will be just returned.",
	"Method": "Connection getConnection(Connection getConnection,String user,String pwd,Connection getConnection,Connection con){\r\n    Connection driverCon = con;\r\n    if (con instanceof com.sun.gjc.spi.base.ConnectionHolder) {\r\n        driverCon = ((com.sun.gjc.spi.base.ConnectionHolder) con).getConnection();\r\n    }\r\n    return driverCon;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.connectionValidationFailed",
	"Comment": "fires probe event related to the fact the given jdbc connection pool hasgot a connection validation failed event.",
	"Method": "void connectionValidationFailed(int count){\r\n    poolProbeProvider.connectionValidationFailedEvent(poolName, appName, moduleName, count);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.logging.AbstractLogger.getMessageWithPrefix",
	"Comment": "this method returns a string with a formatted prefix which \tdepends on the level.",
	"Method": "String getMessageWithPrefix(int level,String message){\r\n    MessageFormat messageFormat = new MessageFormat(getMessages().getString(\"logging_prefix\"));\r\n    return messageFormat.format(new String[] { toString(level), message });\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.storesUpperCaseIdentifiers",
	"Comment": "retrieves whether this database treats mixed case unquoted sql identifiers ascase insensitive and stores them in upper case.",
	"Method": "boolean storesUpperCaseIdentifiers(){\r\n    return databaseMetaData.storesUpperCaseIdentifiers();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.StatementWrapper.cancel",
	"Comment": "cancels this statement object if both the dbms anddriver support aborting an sql statement.this method can be used by one thread to cancel a statement thatis being executed by another thread.",
	"Method": "void cancel(){\r\n    jdbcStatement.cancel();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createClassPersistenceComponent",
	"Comment": "create a validation component which can check the class persistence.",
	"Method": "ValidationComponent createClassPersistenceComponent(String className,PersistenceFieldElement relatedField,ValidationComponent createClassPersistenceComponent,String className){\r\n    return createClassPersistenceComponent(className, null);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.Environment.collectClasses",
	"Comment": "return an arraylist of the classcontrols in classmap.this is useful in that it provides a stable base for enumeration.",
	"Method": "ArrayList collectClasses(int persistType,ArrayList collectClasses){\r\n    ArrayList v = new ArrayList();\r\n    for (Iterator e = classMap.values().iterator(); e.hasNext(); ) v.add(e.next());\r\n    return v;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.isValidByAutoCommit",
	"Comment": "checks if a java.sql.connection is valid or notby checking its auto commit property.",
	"Method": "void isValidByAutoCommit(java.sql.Connection con){\r\n    if (con == null) {\r\n        throw new ResourceException(\"The connection is not valid as \" + \"the connection is null\");\r\n    }\r\n    try {\r\n        boolean ac = con.getAutoCommit();\r\n        if (ac) {\r\n            con.setAutoCommit(false);\r\n        } else {\r\n            con.rollback();\r\n            con.setAutoCommit(true);\r\n        }\r\n        con.setAutoCommit(ac);\r\n    } catch (Exception sqle) {\r\n        _logger.log(Level.INFO, \"jdbc.exc_autocommit_validation\");\r\n        throw new ResourceException(sqle);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.TypeTable.unaryNumericPromotion",
	"Comment": "implements unray numeric promotion as defined in the java language specification section 5.6.1",
	"Method": "Type unaryNumericPromotion(Type type){\r\n    if (type instanceof NumericType) {\r\n        if (type.equals(byteType) || type.equals(shortType) || type.equals(charType)) {\r\n            return intType;\r\n        } else {\r\n            return type;\r\n        }\r\n    } else {\r\n        return errorType;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.annotation.handlers.AbstractAttributeHandler.isDelegatee",
	"Comment": "this indicates whether the annotation can be processed by delegationfrom the another annotation.",
	"Method": "boolean isDelegatee(){\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.ListResources.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    if (appName != null) {\r\n        if (!isValidApplication(appName)) {\r\n            ActionReport report = context.getActionReport();\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            ActionReport.MessagePart messagePart = report.getTopMessagePart();\r\n            messagePart.setMessage(\"Invalid application [\" + appName + \"]\");\r\n            return;\r\n        }\r\n    }\r\n    if (moduleName != null) {\r\n        if (!isValidModule(appName, moduleName)) {\r\n            ActionReport report = context.getActionReport();\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            ActionReport.MessagePart messagePart = report.getTopMessagePart();\r\n            messagePart.setMessage(\"Invalid module [\" + moduleName + \"] in application [\" + appName + \"]\");\r\n            return;\r\n        }\r\n    }\r\n    if (appName != null && moduleName != null) {\r\n        Application application = applications.getApplication(appName);\r\n        Module module = application.getModule(moduleName);\r\n        Resources moduleScopedResources = module.getResources();\r\n        if (moduleScopedResources != null) {\r\n            ActionReport report = context.getActionReport();\r\n            ActionReport.MessagePart messagePart = report.getTopMessagePart();\r\n            generateResourcesList(messagePart, moduleScopedResources.getResources());\r\n        }\r\n    } else if (appName != null) {\r\n        Application application = applications.getApplication(appName);\r\n        Resources appScopedResources = application.getResources();\r\n        if (appScopedResources != null) {\r\n            ActionReport report = context.getActionReport();\r\n            ActionReport.MessagePart messagePart = report.getTopMessagePart();\r\n            generateResourcesList(messagePart, appScopedResources.getResources());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ConfigCacheImpl.getPersistenceConfig",
	"Comment": "get the persistenceconfig for given pcclass. the config is looked upfrom a cache. if a config can not be found in cache, a newinstance is created and returned.",
	"Method": "PersistenceConfig getPersistenceConfig(Class pcClass){\r\n    ClassDesc sqlConfig = (ClassDesc) classConfigs.get(pcClass);\r\n    if (sqlConfig == null) {\r\n        sqlConfig = ClassDesc.newInstance(pcClass);\r\n        classConfigs.put(pcClass, sqlConfig);\r\n        sqlConfig.initialize(this);\r\n        oidClassToClassType.put(sqlConfig.getOidClass(), pcClass);\r\n        addToClassLoaderMap(pcClass);\r\n    }\r\n    return sqlConfig;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.EjbIORConfigurationDescriptor.setEstablishTrustInClient",
	"Comment": "set the value of establishtrustinclient in the transport layer.",
	"Method": "void setEstablishTrustInClient(String val){\r\n    if (!val.equalsIgnoreCase(NONE) && !val.equalsIgnoreCase(SUPPORTED) && !val.equalsIgnoreCase(REQUIRED)) {\r\n        throw new RuntimeException(\"Incorrect value for \" + \"establishTrustInClient:\" + val);\r\n    }\r\n    establishTrustInClient = val;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.SelectQueryPlan.addTable",
	"Comment": "the addtable method is used to add tables correponding to a field to the plan.no columns corresponding the field are added to the plan.",
	"Method": "void addTable(LocalFieldDesc fieldDesc){\r\n    addColumn(fieldDesc, false, false);\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.connectionsFreed",
	"Comment": "fires probe event related to the fact the given jdbc connection pool hasgot a connection freed event.",
	"Method": "void connectionsFreed(int count){\r\n    poolProbeProvider.connectionsFreedEvent(poolName, appName, moduleName, count);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.introspection.AbstractAnnotationScanner.isAnnotation",
	"Comment": "test if the passed constant pool string is a reference to a type.type annotation of a j2ee component",
	"Method": "boolean isAnnotation(String value){\r\n    if (annotations == null) {\r\n        synchronized (this) {\r\n            if (annotations == null) {\r\n                annotations = new HashSet();\r\n                init(annotations);\r\n            }\r\n        }\r\n    }\r\n    return annotations.contains(value);\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.jws.JavaWebStartInfo.rootForGeneratedSubmoduleJAR",
	"Comment": "returns an absolute uri for the root directory that contains jarsfor submodules that are generated from a directory deployment submoduledirectory.",
	"Method": "URI rootForGeneratedSubmoduleJAR(DeploymentContext dc,AppClientDeployerHelper helper){\r\n    final File f = new File(dc.getScratchDir(\"xml\").getParentFile(), NamingConventions.anchorSubpathForNestedClient(helper.appName(dc)));\r\n    return f.toURI();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.FieldAction.getMethod",
	"Comment": "return the name of the static method on class genericobject whichwill get the field value.",
	"Method": "String getMethod(){\r\n    return fieldTypeInfo.fieldGetMethod;\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.CreateConnectorConnectionPool.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    HashMap attrList = new HashMap();\r\n    attrList.put(ResourceConstants.RES_ADAPTER_NAME, raname);\r\n    attrList.put(ResourceConstants.CONN_DEF_NAME, connectiondefinition);\r\n    attrList.put(ServerTags.DESCRIPTION, description);\r\n    attrList.put(ResourceConstants.STEADY_POOL_SIZE, steadypoolsize);\r\n    attrList.put(ResourceConstants.MAX_POOL_SIZE, maxpoolsize);\r\n    attrList.put(ResourceConstants.MAX_WAIT_TIME_IN_MILLIS, maxwait);\r\n    attrList.put(ResourceConstants.POOL_SIZE_QUANTITY, poolresize);\r\n    attrList.put(ResourceConstants.IDLE_TIME_OUT_IN_SECONDS, idletimeout);\r\n    attrList.put(ResourceConstants.IS_CONNECTION_VALIDATION_REQUIRED, isconnectvalidatereq.toString());\r\n    attrList.put(ResourceConstants.CONN_FAIL_ALL_CONNECTIONS, failconnection.toString());\r\n    attrList.put(ResourceConstants.VALIDATE_ATMOST_ONCE_PERIOD_IN_SECONDS, validateatmostonceperiod);\r\n    attrList.put(ResourceConstants.CONNECTION_LEAK_TIMEOUT_IN_SECONDS, leaktimeout);\r\n    attrList.put(ResourceConstants.CONNECTION_LEAK_RECLAIM, leakreclaim.toString());\r\n    attrList.put(ResourceConstants.CONNECTION_CREATION_RETRY_ATTEMPTS, creationretryattempts);\r\n    attrList.put(ResourceConstants.CONNECTION_CREATION_RETRY_INTERVAL_IN_SECONDS, creationretryinterval);\r\n    attrList.put(ResourceConstants.LAZY_CONNECTION_ASSOCIATION, lazyconnectionassociation.toString());\r\n    attrList.put(ResourceConstants.LAZY_CONNECTION_ENLISTMENT, lazyconnectionenlistment.toString());\r\n    attrList.put(ResourceConstants.ASSOCIATE_WITH_THREAD, associatewiththread.toString());\r\n    attrList.put(ResourceConstants.MATCH_CONNECTIONS, matchconnections.toString());\r\n    attrList.put(ResourceConstants.MAX_CONNECTION_USAGE_COUNT, maxconnectionusagecount);\r\n    attrList.put(ResourceConstants.CONNECTOR_CONNECTION_POOL_NAME, poolname);\r\n    attrList.put(ResourceConstants.CONN_TRANSACTION_SUPPORT, transactionsupport);\r\n    attrList.put(ResourceConstants.PING, ping.toString());\r\n    attrList.put(ResourceConstants.POOLING, pooling.toString());\r\n    ResourceStatus rs;\r\n    try {\r\n        ConnectorConnectionPoolManager connPoolMgr = connectorConnectionPoolManagerProvider.get();\r\n        rs = connPoolMgr.create(domain.getResources(), attrList, properties, target);\r\n    } catch (Exception e) {\r\n        Logger.getLogger(CreateConnectorConnectionPool.class.getName()).log(Level.SEVERE, \"Unable to create connector connection pool \" + poolname, e);\r\n        String def = \"Connector connection pool: {0} could not be created, reason: {1}\";\r\n        report.setMessage(localStrings.getLocalString(\"create.connector.connection.pool.fail\", def, poolname) + \" \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    ActionReport.ExitCode ec = ActionReport.ExitCode.SUCCESS;\r\n    if (rs.getStatus() == ResourceStatus.FAILURE) {\r\n        ec = ActionReport.ExitCode.FAILURE;\r\n        if (rs.getMessage() != null) {\r\n            report.setMessage(rs.getMessage());\r\n        } else {\r\n            report.setMessage(localStrings.getLocalString(\"create.connector.connection.pool.fail\", \"Connector connection pool {0} creation failed.\", poolname));\r\n        }\r\n        if (rs.getException() != null)\r\n            report.setFailureCause(rs.getException());\r\n    } else {\r\n        if (\"true\".equalsIgnoreCase(ping.toString())) {\r\n            ActionReport subReport = report.addSubActionsReport();\r\n            ParameterMap parameters = new ParameterMap();\r\n            parameters.set(\"pool_name\", poolname);\r\n            commandRunner.getCommandInvocation(\"ping-connection-pool\", subReport, context.getSubject()).parameters(parameters).execute();\r\n            if (ActionReport.ExitCode.FAILURE.equals(subReport.getActionExitCode())) {\r\n                subReport.setMessage(localStrings.getLocalString(\"ping.create.connector.connection.pool.fail\", \"\\nAttempting to ping during Connector Connection \" + \"Pool Creation : {0} - Failed.\", poolname));\r\n                subReport.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            } else {\r\n                subReport.setMessage(localStrings.getLocalString(\"ping.create.connector.connection.pool.success\", \"\\nAttempting to ping during Connector Connection \" + \"Pool Creation : {0} - Succeeded.\", poolname));\r\n            }\r\n        }\r\n    }\r\n    if (rs.getMessage() != null) {\r\n        report.setMessage(rs.getMessage());\r\n    }\r\n    report.setActionExitCode(ec);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getTypeForName",
	"Comment": "converts the specified type name into its corresponding java.lang.class \trepresentation.",
	"Method": "Class getTypeForName(String typeName){\r\n    Class clazz = JavaTypeHelper.getPrimitiveClass(typeName);\r\n    if (clazz == null)\r\n        clazz = (Class) getClass(typeName);\r\n    return clazz;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.TypeSupport.getElementType",
	"Comment": "returns the type info of the element type if the specified field infodenotes a collection relationship. otherwise it returns null.",
	"Method": "Object getElementType(Object fieldInfo){\r\n    if ((fieldInfo != null) && (fieldInfo instanceof RelationshipElement)) {\r\n        String elementClass = ((RelationshipElement) fieldInfo).getElementClass();\r\n        return nameMapper.getEjbNameForPersistenceClass(elementClass);\r\n    } else\r\n        return null;\r\n}"
}, {
	"Path": "org.glassfish.enterprise.iiop.util.S1ASThreadPoolManager.getThreadPool",
	"Comment": "this method will return an instance of the threadpool given a numeric threadpoolid.this method will be used by the orb to support the functionality ofdedicated threadpool for ejb beans",
	"Method": "ThreadPool getThreadPool(String id,ThreadPool getThreadPool,int numericIdForThreadpool){\r\n    try {\r\n        ThreadPool threadpool = (ThreadPool) threadpoolList.get(numericIdForThreadpool);\r\n        return threadpool;\r\n    } catch (IndexOutOfBoundsException iobe) {\r\n        throw new NoSuchThreadPoolException();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.stats.StatisticImpl.getStartTime",
	"Comment": "returns the time in millis, at which the first measurement was taken",
	"Method": "long getStartTime(){\r\n    return this.startTime;\r\n}"
}, {
	"Path": "com.sun.web.security.RealmAdapter.hasResourcePermission",
	"Comment": "perform access control based on the specified authorization constraint.return true if this constraint is satisfied and processingshould continue, or false otherwise.",
	"Method": "boolean hasResourcePermission(HttpRequest request,HttpResponse response,SecurityConstraint[] constraints,Context context){\r\n    boolean isGranted = false;\r\n    try {\r\n        isGranted = invokeWebSecurityManager(request, response, constraints);\r\n    } catch (IOException iex) {\r\n        throw iex;\r\n    } catch (Throwable ex) {\r\n        _logger.log(Level.SEVERE, \"web_server.excep_authenticate_realmadapter\", ex);\r\n        ((HttpServletResponse) response.getResponse()).sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\r\n        response.setDetailMessage(rb.getString(\"realmBase.forbidden\"));\r\n        return isGranted;\r\n    }\r\n    if (isGranted) {\r\n        return isGranted;\r\n    } else {\r\n        ((HttpServletResponse) response.getResponse()).sendError(HttpServletResponse.SC_FORBIDDEN);\r\n        response.setDetailMessage(rb.getString(\"realmBase.forbidden\"));\r\n        invokePostAuthenticateDelegate(request, response, context);\r\n        return isGranted;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.ClassType.isPersistenceCapable",
	"Comment": "returns true if this is defined as persistence capable class.",
	"Method": "boolean isPersistenceCapable(){\r\n    return (pce != null);\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecurityIIOPInterceptorFactory.createClientRequestInterceptor",
	"Comment": "are we supposed to add the interceptor and then return or just return an instance ?.",
	"Method": "ClientRequestInterceptor createClientRequestInterceptor(ORBInitInfo info,Codec codec){\r\n    if (!penv.getProcessType().isServer()) {\r\n        return null;\r\n    }\r\n    if (altSecFactory != null || (interceptorFactory != null && createAlternateSecurityInterceptorFactory())) {\r\n        return altSecFactory.getClientRequestInterceptor(codec);\r\n    }\r\n    ClientRequestInterceptor ret = getClientInterceptorInstance(codec);\r\n    return ret;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.DeploymentDescriptorNode.endElement",
	"Comment": "receives notification of the end of an xml element by the parser",
	"Method": "boolean endElement(XMLElement element){\r\n    boolean allDone = element.equals(getXMLRootTag());\r\n    if (allDone) {\r\n        postParsing();\r\n        if (getParentNode() != null && getDescriptor() != null) {\r\n            ((DeploymentDescriptorNode) getParentNode()).addNodeDescriptor(this);\r\n        }\r\n    }\r\n    return allDone;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.getDefaultPoolName",
	"Comment": "returns the generated default connection poolname for aconnection definition.",
	"Method": "String getDefaultPoolName(String moduleName,String connectionDefName){\r\n    return connectorService.getDefaultPoolName(moduleName, connectionDefName);\r\n}"
}, {
	"Path": "org.glassfish.admin.amxtest.TestUtil.getAllObjectNames",
	"Comment": "as an optimization to speed up testing, we always get the set of amx objectnames using observer, which maintains such a list.",
	"Method": "SortedSet<ObjectName> getAllObjectNames(){\r\n    final Set<ObjectName> s = Observer.getInstance().getCurrentlyRegisteredAMX();\r\n    return newSortedSet(s);\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ConnectionHolder.wrapped",
	"Comment": "sets the flag to indicate that, the connection is wrapped already or not.",
	"Method": "void wrapped(boolean wrapFlag){\r\n    this.wrappedAlready = wrapFlag;\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.ListJMSHosts.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    Config targetConfig = domain.getConfigNamed(target);\r\n    if (targetConfig != null)\r\n        config = targetConfig;\r\n    Server targetServer = domain.getServerNamed(target);\r\n    if (targetServer != null) {\r\n        config = domain.getConfigNamed(targetServer.getConfigRef());\r\n    }\r\n    com.sun.enterprise.config.serverbeans.Cluster cluster = domain.getClusterNamed(target);\r\n    if (cluster != null) {\r\n        config = domain.getConfigNamed(cluster.getConfigRef());\r\n    }\r\n    JmsService jmsService = config.getExtensionByType(JmsService.class);\r\n    if (jmsService == null) {\r\n        report.setMessage(localStrings.getLocalString(\"list.jms.host.invalidTarget\", \"Invalid Target specified.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        ArrayList<String> list = new ArrayList();\r\n        for (JmsHost r : jmsService.getJmsHost()) {\r\n            list.add(r.getName());\r\n        }\r\n        for (String jmsName : list) {\r\n            final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n            part.setMessage(jmsName);\r\n        }\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.jms.host.fail\", \"Unable to list JMS Hosts\") + \" \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.DeleteConnectorWorkSecurityMap.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (!isResourceExists()) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.connector.work.security.map.notFound\", \"A connector work security map named {0} for resource adapter {1} does not exist.\", mapName, raName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<Resources>() {\r\n            Collection<WorkSecurityMap> workSecurityMaps = domain.getResources().getResources(WorkSecurityMap.class);\r\n            public Object run(Resources param) throws PropertyVetoException, TransactionFailure {\r\n                for (WorkSecurityMap resource : workSecurityMaps) {\r\n                    if (resource.getName().equals(mapName) && resource.getResourceAdapterName().equals(raName)) {\r\n                        param.getResources().remove(resource);\r\n                        break;\r\n                    }\r\n                }\r\n                return workSecurityMaps;\r\n            }\r\n        }, domain.getResources());\r\n    } catch (TransactionFailure tfe) {\r\n        Logger.getLogger(DeleteConnectorWorkSecurityMap.class.getName()).log(Level.SEVERE, \"delete-connector-work-security-map failed\", tfe);\r\n        report.setMessage(localStrings.getLocalString(\"\" + \"delete.connector.work.security.map.fail\", \"Unable to delete connector work security map {0} for resource adapter {1}\", mapName, raName) + \" \" + tfe.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.DeleteConnectorWorkSecurityMap.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    for (WorkSecurityMap resource : workSecurityMaps) {\r\n        if (resource.getName().equals(mapName) && resource.getResourceAdapterName().equals(raName)) {\r\n            param.getResources().remove(resource);\r\n            break;\r\n        }\r\n    }\r\n    return workSecurityMaps;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.ClassControl.filterRequired",
	"Comment": "return true if filtering of the class is required.this checks only whether the filtered version of the class isup to date w.r.t. its input class.",
	"Method": "boolean filterRequired(){\r\n    if (updateType == UpdateUnknown)\r\n        checkUpdateType();\r\n    return (updateType > UpdateUnknown || env.forceOverwrite());\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingReferenceKeyElementImpl.setTable",
	"Comment": "set the mapping table for this referencing key to the supplied table.",
	"Method": "void setTable(MappingTableElement table){\r\n    MappingTableElement old = getTable();\r\n    try {\r\n        fireVetoableChange(PROP_TABLE, old, table);\r\n        setTableInternal(table);\r\n        firePropertyChange(PROP_TABLE, old, table);\r\n    } catch (PropertyVetoException e) {\r\n        throw new ModelVetoException(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.setMaxPool",
	"Comment": "sets maximum number of persistencemanager instances in the pool",
	"Method": "void setMaxPool(int MaxPool){\r\n    assertNotConfigured();\r\n    this.maxPool = MaxPool;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.PreparedStatementWrapper.setInt",
	"Comment": "sets the designated parameter to the given java int value.the driver converts thisto an sql integer value when it sends it to the database.",
	"Method": "void setInt(int parameterIndex,int x){\r\n    preparedStatement.setInt(parameterIndex, x);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.setIdentifier",
	"Comment": "sets identifier. an identifier is a string that user can use to identify\tthe persistencemanagerfactory in a given environment. identifier can be\tparticularly useful in an environment where multiple \tpersistencemanagerfactories are initialized in a system.",
	"Method": "void setIdentifier(String identifier){\r\n    assertNotConfigured();\r\n    this.identifier = identifier;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.BaseContainer.userTransactionMethodsAllowed",
	"Comment": "ejb spec makes a distinction between access to the usertransactionobject itself and access to its methods.getusertransaction coversthe first check and this method covers the second.it is calledby the usertransaction implementation to verify access.",
	"Method": "boolean userTransactionMethodsAllowed(ComponentInvocation inv){\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.EJBQLASTFactory.create",
	"Comment": "overwrites superclass method to create the correct ast instance.",
	"Method": "AST create(AST create,AST tr,EJBQLAST create,EJBQLAST tr){\r\n    try {\r\n        return (tr == null) ? null : (EJBQLAST) tr.clone();\r\n    } catch (CloneNotSupportedException ex) {\r\n        throw new EJBQLException(I18NHelper.getMessage(msgs, \"ERR_UnexpectedExceptionClone\"), ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOConcreteBeanGenerator.generateConversions",
	"Comment": "generates conversion methods from pc to ejbobject and backto the helper class.",
	"Method": "void generateConversions(){\r\n    String[] pcParams = new String[] { CMPTemplateFormatter.pc_, CMPTemplateFormatter.jdoPersistenceManager_ };\r\n    String[] pcParamTypes = new String[] { CMPTemplateFormatter.Object_, CMPTemplateFormatter.jdoPersistenceManagerClass_ };\r\n    String[] collParamTypes = new String[] { CMPTemplateFormatter.Collection_, CMPTemplateFormatter.jdoPersistenceManagerClass_ };\r\n    String[] body = null;\r\n    if (hasRemoteInterface == false) {\r\n        body = CMPTemplateFormatter.getBodyAsStrings(CMPTemplateFormatter.returnNull_);\r\n        // name\r\n        jdoHelperWriter.addMethod(CMPTemplateFormatter.convertPCToEJBObject_, Modifier.PUBLIC, CMPTemplateFormatter.ejbObject_, pcParams, pcParamTypes, null, body, null);\r\n        twoParams[0] = CMPTemplateFormatter.ejbObject_;\r\n        twoParams[1] = CMPTemplateFormatter.jdoPersistenceManagerClass_;\r\n        // name\r\n        jdoHelperWriter.addMethod(CMPTemplateFormatter.convertEJBObjectToPC_, Modifier.PUBLIC, CMPTemplateFormatter.Object_, param0PM, twoParams, null, body, null);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ConnectorDescriptor.visit",
	"Comment": "visit the descriptor and all sub descriptors with a dol visitor implementation",
	"Method": "void visit(DescriptorVisitor aVisitor){\r\n    if (aVisitor instanceof ConnectorVisitor) {\r\n        visit((ComponentVisitor) aVisitor);\r\n    } else {\r\n        super.visit(aVisitor);\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBLocalHomeImpl.remove",
	"Comment": "this is the implementation of the javax.ejb.ejblocalhome remove method.",
	"Method": "void remove(Object primaryKey){\r\n    if (container.getContainerType() != BaseContainer.ContainerType.ENTITY) {\r\n        throw new RemoveException(\"Attempt to call remove(Object primaryKey) on a session bean.\");\r\n    }\r\n    container.authorizeLocalMethod(BaseContainer.EJBLocalHome_remove_Pkey);\r\n    Method method = null;\r\n    try {\r\n        method = EJBLocalHome.class.getMethod(\"remove\", new Class[] { Object.class });\r\n    } catch (NoSuchMethodException e) {\r\n        _logger.log(Level.FINE, \"Exception in method remove()\", e);\r\n    }\r\n    try {\r\n        container.doEJBHomeRemove(primaryKey, method, true);\r\n    } catch (java.rmi.RemoteException re) {\r\n        EJBException ejbEx = new EJBException(\"unexpected RemoteException\");\r\n        ejbEx.initCause(re);\r\n        throw ejbEx;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.SelectQueryPlan.newInstance",
	"Comment": "creates a new instance of selectqueryplan depending on the retrievedescriptor options.",
	"Method": "SelectQueryPlan newInstance(RetrieveDescImpl desc,SQLStoreManager store,Concurrency concurrency){\r\n    SelectQueryPlan plan = null;\r\n    if ((desc.getOptions() & RetrieveDescImpl.OPT_VERIFY) > 0) {\r\n        plan = new VerificationSelectPlan(desc, store);\r\n    } else {\r\n        plan = new SelectQueryPlan(desc, store, concurrency);\r\n    }\r\n    return plan;\r\n}"
}, {
	"Path": "org.glassfish.jdbc.admin.cli.CreateJdbcConnectionPool.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    HashMap attrList = new HashMap();\r\n    attrList.put(ResourceConstants.CONNECTION_POOL_NAME, jdbc_connection_pool_id);\r\n    attrList.put(ResourceConstants.DATASOURCE_CLASS, datasourceclassname);\r\n    attrList.put(ServerTags.DESCRIPTION, description);\r\n    attrList.put(ResourceConstants.RES_TYPE, restype);\r\n    attrList.put(ResourceConstants.STEADY_POOL_SIZE, steadypoolsize);\r\n    attrList.put(ResourceConstants.MAX_POOL_SIZE, maxpoolsize);\r\n    attrList.put(ResourceConstants.MAX_WAIT_TIME_IN_MILLIS, maxwait);\r\n    attrList.put(ResourceConstants.POOL_SIZE_QUANTITY, poolresize);\r\n    attrList.put(ResourceConstants.INIT_SQL, initsql);\r\n    attrList.put(ResourceConstants.IDLE_TIME_OUT_IN_SECONDS, idletimeout);\r\n    attrList.put(ResourceConstants.TRANS_ISOLATION_LEVEL, isolationlevel);\r\n    attrList.put(ResourceConstants.IS_ISOLATION_LEVEL_GUARANTEED, isisolationguaranteed.toString());\r\n    attrList.put(ResourceConstants.IS_CONNECTION_VALIDATION_REQUIRED, isconnectvalidatereq.toString());\r\n    attrList.put(ResourceConstants.CONNECTION_VALIDATION_METHOD, validationmethod);\r\n    attrList.put(ResourceConstants.VALIDATION_TABLE_NAME, validationtable);\r\n    attrList.put(ResourceConstants.CONN_FAIL_ALL_CONNECTIONS, failconnection.toString());\r\n    attrList.put(ResourceConstants.NON_TRANSACTIONAL_CONNECTIONS, nontransactionalconnections.toString());\r\n    attrList.put(ResourceConstants.ALLOW_NON_COMPONENT_CALLERS, allownoncomponentcallers.toString());\r\n    attrList.put(ResourceConstants.VALIDATE_ATMOST_ONCE_PERIOD_IN_SECONDS, validateatmostonceperiod);\r\n    attrList.put(ResourceConstants.CONNECTION_LEAK_TIMEOUT_IN_SECONDS, leaktimeout);\r\n    attrList.put(ResourceConstants.CONNECTION_LEAK_RECLAIM, leakreclaim.toString());\r\n    attrList.put(ResourceConstants.CONNECTION_CREATION_RETRY_ATTEMPTS, creationretryattempts);\r\n    attrList.put(ResourceConstants.CONNECTION_CREATION_RETRY_INTERVAL_IN_SECONDS, creationretryinterval);\r\n    attrList.put(ResourceConstants.DRIVER_CLASSNAME, driverclassname);\r\n    attrList.put(ResourceConstants.SQL_TRACE_LISTENERS, sqltracelisteners);\r\n    attrList.put(ResourceConstants.STATEMENT_TIMEOUT_IN_SECONDS, statementtimeout);\r\n    attrList.put(ResourceConstants.STATEMENT_LEAK_TIMEOUT_IN_SECONDS, statementLeaktimeout);\r\n    attrList.put(ResourceConstants.STATEMENT_LEAK_RECLAIM, statementLeakreclaim.toString());\r\n    attrList.put(ResourceConstants.STATEMENT_CACHE_SIZE, statementcachesize);\r\n    attrList.put(ResourceConstants.LAZY_CONNECTION_ASSOCIATION, lazyconnectionassociation.toString());\r\n    attrList.put(ResourceConstants.LAZY_CONNECTION_ENLISTMENT, lazyconnectionenlistment.toString());\r\n    attrList.put(ResourceConstants.ASSOCIATE_WITH_THREAD, associatewiththread.toString());\r\n    attrList.put(ResourceConstants.MATCH_CONNECTIONS, matchconnections.toString());\r\n    attrList.put(ResourceConstants.MAX_CONNECTION_USAGE_COUNT, maxconnectionusagecount);\r\n    attrList.put(ResourceConstants.PING, ping.toString());\r\n    attrList.put(ResourceConstants.POOLING, pooling.toString());\r\n    attrList.put(ResourceConstants.VALIDATION_CLASSNAME, validationclassname);\r\n    attrList.put(ResourceConstants.WRAP_JDBC_OBJECTS, wrapjdbcobjects.toString());\r\n    ResourceStatus rs;\r\n    try {\r\n        JDBCConnectionPoolManager connPoolMgr = new JDBCConnectionPoolManager();\r\n        rs = connPoolMgr.create(domain.getResources(), attrList, properties, target);\r\n    } catch (Exception e) {\r\n        String actual = e.getMessage();\r\n        String def = \"JDBC connection pool: {0} could not be created, reason: {1}\";\r\n        report.setMessage(localStrings.getLocalString(\"create.jdbc.connection.pool.fail\", def, jdbc_connection_pool_id, actual));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    if (rs.getMessage() != null) {\r\n        report.setMessage(rs.getMessage());\r\n    }\r\n    ActionReport.ExitCode ec = ActionReport.ExitCode.SUCCESS;\r\n    if (rs.getStatus() == ResourceStatus.FAILURE) {\r\n        ec = ActionReport.ExitCode.FAILURE;\r\n        if (rs.getMessage() == null) {\r\n            report.setMessage(localStrings.getLocalString(\"create.jdbc.connection.pool.fail\", \"JDBC connection pool {0} creation failed\", jdbc_connection_pool_id, \"\"));\r\n        }\r\n        if (rs.getException() != null)\r\n            report.setFailureCause(rs.getException());\r\n    } else {\r\n        if (\"true\".equalsIgnoreCase(ping.toString())) {\r\n            ActionReport subReport = report.addSubActionsReport();\r\n            ParameterMap parameters = new ParameterMap();\r\n            parameters.set(\"pool_name\", jdbc_connection_pool_id);\r\n            commandRunner.getCommandInvocation(\"ping-connection-pool\", subReport, context.getSubject()).parameters(parameters).execute();\r\n            if (ActionReport.ExitCode.FAILURE.equals(subReport.getActionExitCode())) {\r\n                subReport.setMessage(localStrings.getLocalString(\"ping.create.jdbc.connection.pool.fail\", \"\\nAttempting to ping during JDBC Connection Pool \" + \"Creation : {0} - Failed.\", jdbc_connection_pool_id));\r\n                subReport.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            } else {\r\n                subReport.setMessage(localStrings.getLocalString(\"ping.create.jdbc.connection.pool.success\", \"\\nAttempting to ping during JDBC Connection Pool \" + \"Creation : {0} - Succeeded.\", jdbc_connection_pool_id));\r\n            }\r\n        }\r\n    }\r\n    report.setActionExitCode(ec);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.datastructure.LRUCacheImpl.checkAndUpdateCache",
	"Comment": "check if an entry is found for this key object. if found, the entry isput in the result object and back into the list.",
	"Method": "Object checkAndUpdateCache(CacheObjectKey key){\r\n    Object result = null;\r\n    CacheEntry entry = list.get(key);\r\n    if (entry != null) {\r\n        result = entry.entryObj;\r\n        if (_logger.isLoggable(Level.FINEST)) {\r\n            _logger.finest(\"Cache Hit\");\r\n        }\r\n        probeProvider.statementCacheHitEvent(poolInfo.getName(), poolInfo.getApplicationName(), poolInfo.getModuleName());\r\n    } else {\r\n        if (_logger.isLoggable(Level.FINEST)) {\r\n            _logger.finest(\"Cache Miss\");\r\n        }\r\n        probeProvider.statementCacheMissEvent(poolInfo.getName(), poolInfo.getApplicationName(), poolInfo.getModuleName());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.PersistenceDescriptor.getPkeyFields",
	"Comment": "return the set of primary key fields.the elements of this set are fielddescriptor objects.this set can be modified by calling addpkeyfield, removepkeyfield",
	"Method": "Set getPkeyFields(){\r\n    if (!pkeyStuffInitialized)\r\n        initPkeyInfo();\r\n    return pkeyFields;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getTxBusinessMethodDescriptors",
	"Comment": "returns the full set of transactional business method descriptors i have.",
	"Method": "Set getTxBusinessMethodDescriptors(){\r\n    Set txBusMethods = getBusinessMethodDescriptors();\r\n    if (isTimedObject()) {\r\n        if (timedObjectMethod != null) {\r\n            txBusMethods.add(timedObjectMethod);\r\n        }\r\n    }\r\n    return txBusMethods;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.retrieve",
	"Comment": "executes the given retrieve descriptor. the resultis a collection unless an aggregate query was specified.in most cases the query result is a collection ofpersistent objects. in case of a projectionon a local field the collection holds objects of thattype. for aggregate queries the result is asingle object, which type was defined by the caller.",
	"Method": "Object retrieve(RetrieveDesc action,ValueFetcher parameters,Object retrieve,RetrieveDesc action){\r\n    return retrieve(action, null);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.hasConstructor",
	"Comment": "determines if the class with the specified name declares a constructor.",
	"Method": "boolean hasConstructor(String className){\r\n    final Class classElement = (Class) getClass(className);\r\n    if (classElement != null) {\r\n        Boolean b = (Boolean) AccessController.doPrivileged(new PrivilegedAction() {\r\n            public Object run() {\r\n                return JavaTypeHelper.valueOf(((Class) classElement).getDeclaredConstructors().length != 0);\r\n            }\r\n        });\r\n        return b.booleanValue();\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.hasConstructor",
	"Comment": "determines if the class with the specified name declares a constructor.",
	"Method": "boolean hasConstructor(String className){\r\n    return JavaTypeHelper.valueOf(((Class) classElement).getDeclaredConstructors().length != 0);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.postConstruct",
	"Comment": "the component has been injected with any dependency andwill be placed into commission by the subsystem.",
	"Method": "void postConstruct(){\r\n    ccPoolAdmService = (ConnectorConnectionPoolAdminServiceImpl) ConnectorAdminServicesFactory.getService(ConnectorConstants.CCP);\r\n    connectorResourceAdmService = (ConnectorResourceAdminServiceImpl) ConnectorAdminServicesFactory.getService(ConnectorConstants.CR);\r\n    connectorService = new ConnectorService();\r\n    resourceAdapterAdmService = (ResourceAdapterAdminServiceImpl) ConnectorAdminServicesFactory.getService(ConnectorConstants.RA);\r\n    connectorSecurityAdmService = (ConnectorSecurityAdminServiceImpl) ConnectorAdminServicesFactory.getService(ConnectorConstants.SEC);\r\n    adminObjectAdminService = (ConnectorAdminObjectAdminServiceImpl) ConnectorAdminServicesFactory.getService(ConnectorConstants.AOR);\r\n    configParserAdmService = new ConnectorConfigurationParserServiceImpl();\r\n    initializeEnvironment(processEnvironment);\r\n    if (isServer()) {\r\n        getProbeProviderUtil().registerProbeProvider();\r\n    }\r\n    if (isServer() || isEmbedded()) {\r\n        poolMonitoringLevelListener = poolMonitoringLevelListenerProvider.get();\r\n        getResourceManager();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.amxtest.ext.wsmgmt.WebServiceMgrTest.testListRegistryLocations",
	"Comment": "tests to see if any registrylocations are present. expects to see atleast one, else the test fails. create a connection pool with a type javax.xml.registry.connectionfactory",
	"Method": "void testListRegistryLocations(){\r\n    String[] list = getDomainRoot().getWebServiceMgr().listRegistryLocations();\r\n    if (list == null) {\r\n        fail(\"Did not get any registry locations. Please check you have \" + \"created one with the name foo\");\r\n    } else {\r\n        for (int i = 0; i < list.length; i++) {\r\n            System.out.println(\"RegistryLocation = \" + list[i]);\r\n        }\r\n        assert (true);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jaspic.config.factory.RegStoreFileParser.delete",
	"Comment": "removes the provider from the entry list if it is alreadypresent, creates the configuration file if necessary, andwrites the entries to the file.",
	"Method": "void delete(RegistrationContext ctx){\r\n    synchronized (confFile) {\r\n        if (checkAndRemoveFromList(ctx)) {\r\n            try {\r\n                writeEntries();\r\n            } catch (IOException ioe) {\r\n                logWarningUpdated(ioe);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.persistence.ejb.entitybean.container.EntityContainer.createEJBObjectImpl",
	"Comment": "implementation of basecontainer method. this is never called.",
	"Method": "EJBObjectImpl createEJBObjectImpl(){\r\n    throw new EJBException(\"INTERNAL ERROR: EntityContainer.createEJBObject() called\");\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.WeakHashSet.getReferenceObject",
	"Comment": "a convenience method to return the object held by the weak reference or null if it does not exist.",
	"Method": "Object getReferenceObject(WeakReference ref){\r\n    return ((ref != null) ? ref.get() : null);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ForeignFieldDesc.registerForeignConfig",
	"Comment": "registers the relationship information about the foreign class.",
	"Method": "void registerForeignConfig(ClassDesc foreignConfig,ForeignFieldDesc inverseField){\r\n    boolean debug = logger.isLoggable(Logger.FINEST);\r\n    if (debug) {\r\n        Object[] items = new Object[] { classDesc, this, foreignConfig };\r\n        logger.finest(\"sqlstore.model.classdesc.general\", items);\r\n    }\r\n    this.foreignConfig = foreignConfig;\r\n    if (debug && inverseField != null) {\r\n        logger.finest(\"sqlstore.model.classdesc.assocrelatedfield\", inverseField);\r\n    }\r\n    setInverseRelationshipField(inverseField);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.registry.MonitoringLevel.instance",
	"Comment": "returns an instance of monitoringlevel for the given string.the given string has to correspond to one of the public fields declaredin this class.",
	"Method": "MonitoringLevel instance(String name){\r\n    if (OFF.toString().equalsIgnoreCase(name))\r\n        return (OFF);\r\n    else if (LOW.toString().equalsIgnoreCase(name))\r\n        return (LOW);\r\n    else if (HIGH.toString().equalsIgnoreCase(name))\r\n        return (HIGH);\r\n    return (null);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getFile",
	"Comment": "returns a file with the given file name which is parallel to the \tsupplied class.",
	"Method": "File getFile(String className,String fileName){\r\n    Class classElement = (Class) getClass(className);\r\n    if (classElement != null) {\r\n        URL path = classElement.getResource(fileName.substring(fileName.lastIndexOf(getShortClassName(className))));\r\n        return ((path != null) ? (new File(path.getFile())) : null);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.Descriptor.remapTypes",
	"Comment": "classtranslations contains a set of mappings of class names.for any types within the input signature which appear as keysin the translation table, change the signature to replace theoriginal type with the translation.return a string containingthe original signature with any translations applied.",
	"Method": "String remapTypes(String sig,Map classTranslations){\r\n    StringBuffer buf = null;\r\n    for (int idx = 0; idx < sig.length(); idx++) {\r\n        char c;\r\n        switch(c = sig.charAt(idx)) {\r\n            case '[':\r\n                while ((c = sig.charAt(idx)) == '[' || c == ']') {\r\n                    idx++;\r\n                    if (buf != null)\r\n                        buf.append(c);\r\n                }\r\n                if (sig.charAt(idx) != 'L')\r\n                    break;\r\n            case 'L':\r\n                idx++;\r\n                int endIdx = sig.indexOf(';', idx);\r\n                String typeName = sig.substring(idx, endIdx);\r\n                String mapTo = (String) classTranslations.get(typeName);\r\n                if (mapTo != null) {\r\n                    if (buf == null) {\r\n                        buf = new StringBuffer(sig.length() + 20);\r\n                        buf.append(sig.substring(0, idx - 1));\r\n                    }\r\n                    typeName = mapTo;\r\n                }\r\n                if (buf != null) {\r\n                    buf.append('L');\r\n                    buf.append(typeName);\r\n                }\r\n                idx = endIdx;\r\n                c = ';';\r\n                break;\r\n        }\r\n        if (buf != null)\r\n            buf.append(c);\r\n    }\r\n    return (buf == null) ? sig : (buf.toString());\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.addApplication",
	"Comment": "add all the deployment information about the given application to me.",
	"Method": "void addApplication(Application application){\r\n    for (ModuleDescriptor md : application.getModules()) {\r\n        addModule(md);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getField",
	"Comment": "returns the field element for the specified fieldname in the class\twith the specified classname.",
	"Method": "Object getField(String className,String fieldName){\r\n    final Class classElement = (Class) getClass(className);\r\n    if (classElement != null) {\r\n        return AccessController.doPrivileged(new PrivilegedAction() {\r\n            public Object run() {\r\n                try {\r\n                    return classElement.getDeclaredField(fieldName);\r\n                } catch (NoSuchFieldException e) {\r\n                    return null;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getField",
	"Comment": "returns the field element for the specified fieldname in the class\twith the specified classname.",
	"Method": "Object getField(String className,String fieldName){\r\n    try {\r\n        return classElement.getDeclaredField(fieldName);\r\n    } catch (NoSuchFieldException e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.isArray",
	"Comment": "determines if a field with the specified fieldname in the class\twith the specified classname is an array.",
	"Method": "boolean isArray(String className,String fieldName){\r\n    Object fieldElement = getField(className, fieldName);\r\n    return ((fieldElement != null) ? getTypeObject(fieldElement).isArray() : false);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getStatement",
	"Comment": "retrieves the statement object that produced thisresultset object.if the result set was generated some other way, such as by adatabasemetadata method, this method returnsnull.",
	"Method": "Statement getStatement(){\r\n    return statement;\r\n}"
}, {
	"Path": "org.glassfish.jdbcruntime.JdbcRuntimeExtension.getPoolNameFromResourceJndiName",
	"Comment": "gets the pool name that this jdbc resource points to. in case of a pmf resourcegets the pool name of the pool pointed to by jdbc resource being pointed to bythe pmf resource",
	"Method": "PoolInfo getPoolNameFromResourceJndiName(ResourceInfo resourceInfo){\r\n    PoolInfo poolInfo = null;\r\n    JdbcResource jdbcResource = null;\r\n    String jndiName = resourceInfo.getName();\r\n    ResourceInfo actualResourceInfo = new ResourceInfo(jndiName, resourceInfo.getApplicationName(), resourceInfo.getModuleName());\r\n    ConnectorRuntime runtime = ConnectorRuntime.getRuntime();\r\n    jdbcResource = (JdbcResource) ConnectorsUtil.getResourceByName(runtime.getResources(actualResourceInfo), JdbcResource.class, actualResourceInfo.getName());\r\n    if (jdbcResource == null) {\r\n        String suffix = ConnectorsUtil.getValidSuffix(jndiName);\r\n        if (suffix != null) {\r\n            jndiName = jndiName.substring(0, jndiName.lastIndexOf(suffix));\r\n            actualResourceInfo = new ResourceInfo(jndiName, resourceInfo.getApplicationName(), resourceInfo.getModuleName());\r\n        }\r\n    }\r\n    jdbcResource = (JdbcResource) ConnectorsUtil.getResourceByName(runtime.getResources(actualResourceInfo), JdbcResource.class, actualResourceInfo.getName());\r\n    if (jdbcResource != null) {\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.fine(\"jdbcRes is ---: \" + jdbcResource.getJndiName());\r\n            logger.fine(\"poolName is ---: \" + jdbcResource.getPoolName());\r\n        }\r\n    }\r\n    if (jdbcResource != null) {\r\n        poolInfo = new PoolInfo(jdbcResource.getPoolName(), actualResourceInfo.getApplicationName(), actualResourceInfo.getModuleName());\r\n    }\r\n    return poolInfo;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.provider.PolicyConfigurationImpl.removeUncheckedPolicy",
	"Comment": "used to remove any unchecked policy statements from thispolicyconfiguration.",
	"Method": "void removeUncheckedPolicy(){\r\n    assertStateIsOpen();\r\n    checkSetPolicyPermission();\r\n    if (uncheckedPermissions != null) {\r\n        uncheckedPermissions = null;\r\n        writeOnCommit = true;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.TypeSupport.getTypeInfo",
	"Comment": "the method returns a type info by type name. if the type name denotes a class the name should be fully qualified. the method uses the type name as type info.",
	"Method": "Object getTypeInfo(String name,Object getTypeInfo,Class clazz){\r\n    return getTypeInfo(clazz.getName());\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.BeanMethodCalculatorImpl.transformAndAdd",
	"Comment": "utiliy method to transform our collection of method objects intomethoddescriptor objects and add them to our global list ofelligible methods",
	"Method": "void transformAndAdd(Collection methods,String methodIntf,Vector globalList){\r\n    for (Iterator itr = methods.iterator(); itr.hasNext(); ) {\r\n        Method m = (Method) itr.next();\r\n        MethodDescriptor md = new MethodDescriptor(m, methodIntf);\r\n        globalList.add(md);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.deleteFile",
	"Comment": "deletes the file with the given file name which is parallel \tto the supplied class.",
	"Method": "void deleteFile(String className,String fileName){\r\n    File file = getFile(className, fileName);\r\n    if ((file != null) && file.exists())\r\n        file.delete();\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.obj.LdapGroupFactory.getObjectInstance",
	"Comment": "creates an object that represents an ldap object at directory context.the ldap objectclass attribute is examined to determine which object to create.",
	"Method": "Object getObjectInstance(Object obj,Name name,Context ctx,Hashtable environment,Object getObjectInstance,Object obj,Name name,Context ctx,Hashtable environment,Attributes attributes){\r\n    if (obj instanceof DirContext && ctx instanceof DirContext) {\r\n        Attribute objectClass = (attributes != null ? attributes.get(\"objectClass\") : null);\r\n        if (objectClass != null) {\r\n            if (GroupOfURLs.matches(objectClass)) {\r\n                return GroupOfURLs.getObjectInstance(((DirContext) obj).getNameInNamespace(), (DirContext) ctx, name, environment, attributes);\r\n            } else if (GroupOfUniqueNames.matches(objectClass)) {\r\n                return GroupOfUniqueNames.getObjectInstance(((DirContext) obj).getNameInNamespace(), (DirContext) ctx, name, environment, attributes);\r\n            } else if (GroupOfNames.matches(objectClass)) {\r\n                return GroupOfNames.getObjectInstance(((DirContext) obj).getNameInNamespace(), (DirContext) ctx, name, environment, attributes);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.PreparedStatementWrapper40.isPoolable",
	"Comment": "returns avalue indicating whether the statementis poolable or not.",
	"Method": "boolean isPoolable(){\r\n    return preparedStatement.isPoolable();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.DriverLoader.isVendorSpecific",
	"Comment": "utility method that checks if a classname is vendor specific.this method is used for jar files that do not have a manifest file to look up the classname.",
	"Method": "boolean isVendorSpecific(File f,String dbVendor,String className,String origDbVendor,boolean isVendorSpecific,String dbVendor,String className){\r\n    return className.toUpperCase(Locale.getDefault()).indexOf(dbVendor.toUpperCase(Locale.getDefault())) != -1;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.ResultDesc.addCollectionValue",
	"Comment": "adds value to the collection for the given field f and statemanager sm.also sets presence mask bit for the field in given sm, if not already set.",
	"Method": "void addCollectionValue(SQLStateManager sm,ForeignFieldDesc f,Object value){\r\n    Collection collection = (Collection) f.getValue(sm);\r\n    if (collection == null) {\r\n        sm.replaceCollection(f, null);\r\n        collection = (Collection) f.getValue(sm);\r\n    }\r\n    if (!sm.getPresenceMaskBit(f.absoluteID)) {\r\n        sm.setPresenceMaskBit(f.absoluteID);\r\n    }\r\n    if (value != null) {\r\n        if (collection instanceof SCOCollection) {\r\n            ((SCOCollection) collection).addToBaseCollection(value);\r\n        } else {\r\n            collection.add(value);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.decrementConnectionUsed",
	"Comment": "fires probe event related to the fact the given jdbc connection pool hasgot a decrement connection used event.",
	"Method": "void decrementConnectionUsed(long resourceHandleId){\r\n    ConnectionPoolAppEmitterImpl appEmitter = detectAppBasedProviders(getAppName(resourceHandleId));\r\n    poolProbeProvider.decrementConnectionUsedEvent(poolName, appName, moduleName);\r\n    if (appEmitter != null) {\r\n        appEmitter.decrementConnectionUsed();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.resources.connector.ResourcesCompositeSniffer.supportsArchiveType",
	"Comment": "this api is used to help determine if the sniffer should recognizethe current archive.if the sniffer does not support the archive type associated withthe current deployment, the sniffer should not recognize the archive.",
	"Method": "boolean supportsArchiveType(ArchiveType archiveType){\r\n    if (archiveType.toString().equals(ModuleType.EAR.toString())) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.PersistenceDescriptor.setCMPFields",
	"Comment": "set the fielddescriptor objects that the ejb container will persist for this bean.",
	"Method": "void setCMPFields(Set cmpFields){\r\n    this.cmpFields = cmpFields;\r\n    persFieldInfo = null;\r\n    fieldInfoInitialized = false;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.deployer.ConnectorConnectionPoolDeployer.convertElementPropertyToPoolProperty",
	"Comment": "the idea is to convert the elementproperty values coming from the adminconnection pool to standard pool attributes thereby making iteasy in case of a reconfig",
	"Method": "void convertElementPropertyToPoolProperty(ConnectorConnectionPool ccp,org.glassfish.connectors.config.ConnectorConnectionPool domainCcp){\r\n    List<Property> elemProps = domainCcp.getProperty();\r\n    if (elemProps == null) {\r\n        return;\r\n    }\r\n    for (Property ep : elemProps) {\r\n        if (ep != null) {\r\n            if (\"MATCHCONNECTIONS\".equals(ep.getName().toUpperCase(locale))) {\r\n                if (_logger.isLoggable(Level.FINE)) {\r\n                    _logger.fine(\" ConnectorConnectionPoolDeployer::  Setting matchConnections\");\r\n                }\r\n                ccp.setMatchConnections(toBoolean(ep.getValue(), true));\r\n            } else if (\"LAZYCONNECTIONASSOCIATION\".equals(ep.getName().toUpperCase(locale))) {\r\n                ConnectionPoolObjectsUtils.setLazyEnlistAndLazyAssocProperties(ep.getValue(), domainCcp.getProperty(), ccp);\r\n                if (_logger.isLoggable(Level.FINE)) {\r\n                    _logger.fine(\"LAZYCONNECTIONASSOCIATION\");\r\n                }\r\n            } else if (\"LAZYCONNECTIONENLISTMENT\".equals(ep.getName().toUpperCase(locale))) {\r\n                ccp.setLazyConnectionEnlist(toBoolean(ep.getValue(), false));\r\n                if (_logger.isLoggable(Level.FINE)) {\r\n                    _logger.fine(\"LAZYCONNECTIONENLISTMENT\");\r\n                }\r\n            } else if (\"ASSOCIATEWITHTHREAD\".equals(ep.getName().toUpperCase(locale))) {\r\n                ccp.setAssociateWithThread(toBoolean(ep.getValue(), false));\r\n                if (_logger.isLoggable(Level.FINE)) {\r\n                    _logger.fine(\"ASSOCIATEWITHTHREAD\");\r\n                }\r\n            } else if (\"POOLDATASTRUCTURE\".equals(ep.getName().toUpperCase(locale))) {\r\n                ccp.setPoolDataStructureType(ep.getValue());\r\n                if (_logger.isLoggable(Level.FINE)) {\r\n                    _logger.fine(\"POOLDATASTRUCTURE\");\r\n                }\r\n            } else if (\"POOLWAITQUEUE\".equals(ep.getName().toUpperCase(locale))) {\r\n                ccp.setPoolWaitQueue(ep.getValue());\r\n                if (_logger.isLoggable(Level.FINE)) {\r\n                    _logger.fine(\"POOLWAITQUEUE\");\r\n                }\r\n            } else if (\"DATASTRUCTUREPARAMETERS\".equals(ep.getName().toUpperCase(locale))) {\r\n                ccp.setDataStructureParameters(ep.getValue());\r\n                if (_logger.isLoggable(Level.FINE)) {\r\n                    _logger.fine(\"DATASTRUCTUREPARAMETERS\");\r\n                }\r\n            } else if (\"PREFER-VALIDATE-OVER-RECREATE\".equals(ep.getName().toUpperCase(locale))) {\r\n                String value = ep.getValue();\r\n                if (_logger.isLoggable(Level.FINE)) {\r\n                    _logger.fine(\" ConnectorConnectionPoolDeployer::  \" + \"Setting PREFER-VALIDATE-OVER-RECREATE to \" + value);\r\n                }\r\n                ccp.setPreferValidateOverRecreate(toBoolean(value, false));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.StatefulSessionContainer.completeLifecycleCallbackTxIfUsed",
	"Comment": "complete transaction if necessary after lifecycle callback",
	"Method": "void completeLifecycleCallbackTxIfUsed(EjbInvocation ejbInv,EJBContextImpl ctx,boolean usedTx){\r\n    if (usedTx) {\r\n        delistExtendedEntityManagers(ctx);\r\n        try {\r\n            postInvokeTx(ejbInv);\r\n        } catch (Exception pie) {\r\n            _logger.log(Level.FINE, \"SFSB postInvokeTx exception\", pie);\r\n        }\r\n        ((SessionContextImpl) ctx).setInLifeCycleCallback(false);\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.util.cache.LruSessionCache.trimTimedoutItems",
	"Comment": "trim the timedout entries from the cache.this call is to be scheduled by a thread managed by the container.in this case a sorted lru list exists based on access time and thislist is scanned",
	"Method": "void trimTimedoutItems(int maxTrimCount){\r\n    int count = 0;\r\n    LruCacheItem item;\r\n    long currentTime = System.currentTimeMillis();\r\n    long idleThresholdTime = currentTime - cacheIdleTimeoutInSeconds * 1000L;\r\n    ArrayList victimList = new ArrayList();\r\n    synchronized (this) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"[\" + cacheName + \"]: TrimTimedoutBeans started...\");\r\n        }\r\n        if (tail == null) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"[\" + cacheName + \"]: TrimTimedoutBeans \" + \" finished after removing 0 idle beans\");\r\n            }\r\n            head = null;\r\n            return;\r\n        }\r\n        item = tail;\r\n        while (true) {\r\n            if (currentCacheState != STATE_RUNNING) {\r\n                _logger.log(Level.WARNING, EXITING_TRIM_TIMEDOUT_BEANS, new Object[] { cacheName, currentCacheState });\r\n                break;\r\n            }\r\n            StatefulEJBContext ctx = (StatefulEJBContext) item.getValue();\r\n            if (ctx != null) {\r\n                if ((ctx.getLastAccessTime() <= idleThresholdTime) && ctx.canBePassivated()) {\r\n                    item.setTrimmed(true);\r\n                    victimList.add(item);\r\n                } else {\r\n                    break;\r\n                }\r\n            }\r\n            if ((item == head) && (item.getLPrev() != null)) {\r\n                _logger.log(Level.WARNING, TRIM_TIMEDOUT_BEANS_RESETTING_HEAD_LPREV, cacheName);\r\n                item.setLPrev(null);\r\n            }\r\n            item = item.getLPrev();\r\n            if (item == null) {\r\n                break;\r\n            }\r\n            item.getLNext().setLPrev(null);\r\n            item.getLNext().setLNext(null);\r\n            item.setLNext(null);\r\n        }\r\n        if (item == tail) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"[\" + cacheName + \"]: TrimTimedoutBeans \" + \" finished after removing 0 idle beans\");\r\n            }\r\n            return;\r\n        }\r\n        if (item == null)\r\n            head = null;\r\n        tail = item;\r\n        count = victimList.size();\r\n        listSize -= count;\r\n        trimCount += count;\r\n    }\r\n    for (int idx = 0; idx < count; idx++) {\r\n        trimItem((LruCacheItem) victimList.get(idx));\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"[\" + cacheName + \"]: TrimTimedoutBeans \" + \" finished after removing \" + count + \" idle beans\");\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.persistent.timer.PersistentEJBTimerService.createSchedulesOnServer",
	"Comment": "called in a clustered environment to eagerly create automatic persistent timerson the specific server instance.",
	"Method": "void createSchedulesOnServer(EjbDescriptor ejbDescriptor,String server_name){\r\n    Map<MethodDescriptor, List<ScheduledTimerDescriptor>> schedules = new HashMap<MethodDescriptor, List<ScheduledTimerDescriptor>>();\r\n    for (ScheduledTimerDescriptor schd : ejbDescriptor.getScheduledTimerDescriptors()) {\r\n        MethodDescriptor method = schd.getTimeoutMethod();\r\n        if (method != null && schd.getPersistent()) {\r\n            if (logger.isLoggable(Level.FINE)) {\r\n                logger.log(Level.FINE, \"... processing \" + method);\r\n            }\r\n            List<ScheduledTimerDescriptor> list = schedules.get(method);\r\n            if (list == null) {\r\n                list = new ArrayList<ScheduledTimerDescriptor>();\r\n                schedules.put(method, list);\r\n            }\r\n            list.add(schd);\r\n        }\r\n    }\r\n    if (logger.isLoggable(Level.FINE)) {\r\n        logger.log(Level.FINE, \"EJBTimerService - creating schedules for \" + ejbDescriptor.getUniqueId());\r\n    }\r\n    createSchedules(ejbDescriptor.getUniqueId(), ejbDescriptor.getApplication().getUniqueId(), schedules, server_name);\r\n    if (logger.isLoggable(Level.FINE)) {\r\n        logger.log(Level.FINE, \"EJBTimerService - finished processing schedules for BEAN ID: \" + ejbDescriptor.getUniqueId());\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getLocalBusinessClassNames",
	"Comment": "returns the set of local business interface names for this ejb.if the bean does not expose a local business view, return a setof size 0.",
	"Method": "Set<String> getLocalBusinessClassNames(){\r\n    return new HashSet<String>(localBusinessClassNames);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.model.DeploymentDescriptorModel.getModifiers",
	"Comment": "returns the modifier mask for the specified member element.\tnote, the member element is either a class element as returned by \tgetclass, a member wrapper element as returned by getfield or \tgetmethod, a constructor element as returned by getconstructor \texecuted on the same model instance. \tthis implementation expects the member element being a reflection \tinstance or a wrapped member instance.",
	"Method": "int getModifiers(Object memberElement,int getModifiers){\r\n    if ((memberElement != null) && (memberElement instanceof MemberWrapper))\r\n        return ((MemberWrapper) memberElement).getModifiers();\r\n    return super.getModifiers(memberElement);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.setRequireTrackedSCO",
	"Comment": "sets the requiretrackedsco flag for this persistencemanagerfactory.if set to false, by default the persistencemanager will not create trackedsco instances for new persistent instances at commit with retainvalues set to trueand while retrieving data from a datastore.",
	"Method": "void setRequireTrackedSCO(boolean flag){\r\n    assertNotConfigured();\r\n    requireTrackedSCO = flag;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.CommonHandlers.initSessionAttributes",
	"Comment": "this handler will be called during initialization for doing any initialization.",
	"Method": "void initSessionAttributes(HandlerContext handlerCtx){\r\n    Object initialized = FacesContext.getCurrentInstance().getExternalContext().getSessionMap().get(\"_SESSION_INITIALIZED\");\r\n    if (initialized == null) {\r\n        GuiUtil.initSessionAttributes();\r\n    }\r\n    return;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBLocalHomeInvocationHandler.invokeSpecialEJBLocalHomeMethod",
	"Comment": "default impl to be overridden in subclasses if special invoke is necessary",
	"Method": "Object invokeSpecialEJBLocalHomeMethod(Method method,Class methodClass,Object[] args){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxTableNameLength",
	"Comment": "retrieves the maximum number of characters this database allows ina table name.",
	"Method": "int getMaxTableNameLength(){\r\n    return databaseMetaData.getMaxTableNameLength();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ClassDesc.getUpdateQueryPlan",
	"Comment": "retrieves the update query plan for the specified descriptor.",
	"Method": "UpdateQueryPlan getUpdateQueryPlan(UpdateObjectDescImpl desc,SQLStoreManager store){\r\n    switch(desc.getUpdateAction()) {\r\n        case ActionDesc.LOG_CREATE:\r\n            return getUpdateQueryPlanForInsert(desc, store);\r\n        case ActionDesc.LOG_DESTROY:\r\n            return getUpdateQueryPlanForDelete(desc, store);\r\n        case ActionDesc.LOG_UPDATE:\r\n            return getUpdateQueryPlanForUpdate(desc, store);\r\n        default:\r\n            return null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.AssocWithThreadResourcePool.freeUnenlistedResource",
	"Comment": "return the resource back to pool only if it is not associated with the thread.",
	"Method": "void freeUnenlistedResource(ResourceHandle h){\r\n    if (this.cleanupResource(h)) {\r\n        if (h instanceof AssocWithThreadResourceHandle) {\r\n            if (maxConnectionUsage_ > 0 && h.getUsageCount() >= maxConnectionUsage_) {\r\n                performMaxConnectionUsageOperation(h);\r\n            } else {\r\n                if (!((AssocWithThreadResourceHandle) h).isAssociated()) {\r\n                    ds.returnResource(h);\r\n                }\r\n                if (poolLifeCycleListener != null) {\r\n                    poolLifeCycleListener.decrementConnectionUsed(h.getId());\r\n                    poolLifeCycleListener.incrementNumConnFree(false, steadyPoolSize);\r\n                }\r\n            }\r\n            notifyWaitingThreads();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.support.SynchronizationManager.getSynchronizationManager",
	"Comment": "get the synchronization manager already registered with this persistence manager.if the synchronization instance is not of the proper class, then replace it with a new instance of the synchronization manager, and register the previous synchronizationwith the newly created synchronization manager.",
	"Method": "SynchronizationManager getSynchronizationManager(PersistenceManager pm){\r\n    Transaction tx = pm.currentTransaction();\r\n    Synchronization oldsync = tx.getSynchronization();\r\n    if (oldsync instanceof SynchronizationManager) {\r\n        return (SynchronizationManager) oldsync;\r\n    } else {\r\n        SynchronizationManager newsync = new SynchronizationManager(pm);\r\n        if (oldsync != null) {\r\n            newsync.registerSynchronization(oldsync);\r\n        }\r\n        return newsync;\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.interceptors.InterceptorManager.registerRuntimeInterceptor",
	"Comment": "called sometime after original interceptor initialization.install the given interceptor class instance before any applicationlevel interceptors.param oinstance of an interceptor class",
	"Method": "void registerRuntimeInterceptor(Object o){\r\n    runtimeInterceptor = o;\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.Java2DBProcessorHelper.getGeneratedLocation",
	"Comment": "returns appgeneratedlocation or user defined value if the latter is specified",
	"Method": "String getGeneratedLocation(String bundleName){\r\n    String userFileLocation = deploymentContextProps.getProperty(JDBC_FILE_LOCATION + bundleName);\r\n    return (userFileLocation != null) ? userFileLocation : appGeneratedLocation;\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.CSIV2TaggedComponentInfo.createASContextSec",
	"Comment": "create the as layer context within a compound mechanism definition.",
	"Method": "AS_ContextSec createASContextSec(EjbIORConfigurationDescriptor iorDesc,String realmName){\r\n    AS_ContextSec asContext = null;\r\n    int target_supports = 0;\r\n    int target_requires = 0;\r\n    byte[] client_authentication_mechanism = {};\r\n    byte[] target_name = {};\r\n    String authMethod = null;\r\n    boolean authMethodRequired = false;\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"IIOP: Creating AS_Context\");\r\n    }\r\n    if (iorDesc != null) {\r\n        authMethod = iorDesc.getAuthenticationMethod();\r\n        authMethodRequired = iorDesc.isAuthMethodRequired();\r\n    }\r\n    if ((authMethod != null) && (authMethod.equalsIgnoreCase(EjbIORConfigurationDescriptor.NONE))) {\r\n        asContext = new AS_ContextSec((short) target_supports, (short) target_requires, client_authentication_mechanism, target_name);\r\n        return asContext;\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"IIOP:AS_Context: Realm Name for login = \" + realmName);\r\n    }\r\n    if (realmName == null) {\r\n        realmName = iorDesc.getRealmName();\r\n    }\r\n    if (realmName == null) {\r\n        realmName = DEFAULT_REALM;\r\n    }\r\n    byte[] _realm_name_bytes = realmName.getBytes();\r\n    target_name = GSSUtils.createExportedName(GSSUtils.GSSUP_MECH_OID, _realm_name_bytes);\r\n    target_supports = EstablishTrustInClient.value;\r\n    if (authMethodRequired) {\r\n        target_requires = EstablishTrustInClient.value;\r\n    }\r\n    client_authentication_mechanism = GSSUtils.getMechanism();\r\n    asContext = new AS_ContextSec((short) target_supports, (short) target_requires, client_authentication_mechanism, target_name);\r\n    return asContext;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.XAResourceImpl.prepare",
	"Comment": "ask the resource manager to prepare for a transaction commit of the transaction specified in xid.",
	"Method": "int prepare(Xid xid){\r\n    return xar.prepare(xid);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.CMPBeanHelper.assertPersistent",
	"Comment": "called from a cmp bean to verify that the persistencecapableinstance is already persistent. throws illegalstateexceptionotherwise.",
	"Method": "void assertPersistent(PersistenceCapable pc,String beanName){\r\n    if (!JDOHelper.isPersistent(pc)) {\r\n        String msg = // NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        cmpMessages, // NOI18N\r\n        \"GEN.cmrgettersetter_exception\", beanName, findCallingMethodName());\r\n        cmpInternalLogger.log(Logger.SEVERE, msg);\r\n        throw new IllegalStateException(msg);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.util.JSONUtil.readObject",
	"Comment": "this method creates a hashmap to represent the json object.",
	"Method": "Map<String, Object> readObject(JsonChars json){\r\n    json.pushContextEnd('}');\r\n    Map<String, Object> map = new HashMap<String, Object>(10);\r\n    Object tmp = null;\r\n    Object key = null;\r\n    Object value = null;\r\n    while (!json.isAtContextEnd()) {\r\n        key = replaceSpecial(jsonToJava(json));\r\n        if (json.isAtContextEnd()) {\r\n            break;\r\n        }\r\n        if (!(key instanceof String)) {\r\n            throw new IllegalArgumentException(\"Object keys must be a String!\");\r\n        }\r\n        if (!(jsonToJava(json).equals(COLON))) {\r\n            throw new IllegalArgumentException(\"Object keys must be followed by a colon (:)!\");\r\n        }\r\n        value = replaceSpecial(jsonToJava(json));\r\n        tmp = jsonToJava(json);\r\n        if ((!(tmp.equals(COMMA))) && !json.isAtContextEnd()) {\r\n            throw new IllegalArgumentException(\"Expected comma (,) or end curly brace (}), but found (\" + tmp + \") instead!  Near: (\" + json.getContext(30) + \")\");\r\n        }\r\n        map.put((String) key, value);\r\n    }\r\n    json.popContextEnd();\r\n    return map;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getTimestamp",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object as a java.sql.timestamp objectin the java programming language.this method uses the given calendar to construct an appropriate millisecondvalue for the timestamp if the underlying database does not storetimezone information.",
	"Method": "Timestamp getTimestamp(int columnIndex,Timestamp getTimestamp,String columnName,Timestamp getTimestamp,int columnIndex,Calendar cal,Timestamp getTimestamp,String columnName,Calendar cal){\r\n    return resultSet.getTimestamp(columnName, cal);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.EJBHelper.unwrapStatement",
	"Comment": "this method unwraps given statement and return the statement fromjdbc driver if possible.",
	"Method": "java.sql.Statement unwrapStatement(java.sql.Statement stmt,java.sql.Statement unwrapStatement,java.sql.Statement stmt){\r\n    return myHelper.unwrapStatement(stmt);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.JDOQLElements.toString",
	"Comment": "returns a string representation of this jdoqlelements instance.",
	"Method": "String toString(){\r\n    StringBuffer repr = new StringBuffer();\r\n    repr.append(\"JDOQLElements(\");\r\n    repr.append(\"candidateClass: \");\r\n    repr.append(candidateClassName);\r\n    if (parameters != null && parameters.length() > 0) {\r\n        repr.append(\", parameters: \");\r\n        repr.append(parameters);\r\n    }\r\n    if (variables != null && variables.length() > 0) {\r\n        repr.append(\", variables: \");\r\n        repr.append(variables);\r\n    }\r\n    if (filter != null && filter.length() > 0) {\r\n        repr.append(\", filter: \");\r\n        repr.append(filter);\r\n    }\r\n    if (ordering != null && ordering.length() > 0) {\r\n        repr.append(\", ordering: \");\r\n        repr.append(ordering);\r\n    }\r\n    if (result != null && result.length() > 0) {\r\n        repr.append(\", result: \");\r\n        repr.append(result);\r\n        repr.append(\", resultType: \");\r\n        repr.append(resultType);\r\n        repr.append(\", isPCResult: \");\r\n        repr.append(isPCResult);\r\n    }\r\n    repr.append(\", isAggregate: \");\r\n    repr.append(isAggregate);\r\n    if (parameterEjbNames != null && parameterEjbNames.length > 0) {\r\n        repr.append(\", parameterEjbNames: \");\r\n        for (int i = 0; i < parameterEjbNames.length; i++) {\r\n            repr.append(i);\r\n            repr.append(\": \");\r\n            repr.append(parameterEjbNames[i]);\r\n            repr.append(\", \");\r\n        }\r\n    }\r\n    repr.append(\")\");\r\n    return repr.toString();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MailConfiguration.getMailTransportProtocolClass",
	"Comment": "get the default transport protocol class for the mail session the serverwill provide.",
	"Method": "String getMailTransportProtocolClass(){\r\n    return this.transportProtocolClass;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ActiveOutboundResourceAdapter.createManagedConnectionFactory",
	"Comment": "creates an instance of managedconnectionfactoryobject using the connection pool properties. also set theresourceadapterassociation",
	"Method": "ManagedConnectionFactory createManagedConnectionFactory(ConnectorConnectionPool pool,ClassLoader jcl){\r\n    ManagedConnectionFactory mcf;\r\n    mcf = super.createManagedConnectionFactory(pool, jcl);\r\n    if (mcf instanceof ResourceAdapterAssociation) {\r\n        try {\r\n            ((ResourceAdapterAssociation) mcf).setResourceAdapter(this.resourceadapter_);\r\n        } catch (ResourceException ex) {\r\n            _logger.log(Level.SEVERE, \"rardeployment.assoc_failed\", ex);\r\n        }\r\n    }\r\n    return mcf;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.DSManagedConnectionFactory.createManagedConnection",
	"Comment": "creates a new physical connection to the underlying eis resourcemanager.",
	"Method": "javax.resource.spi.ManagedConnection createManagedConnection(javax.security.auth.Subject subject,ConnectionRequestInfo cxRequestInfo){\r\n    logFine(\"In createManagedConnection\");\r\n    PasswordCredential pc = SecurityUtils.getPasswordCredential(this, subject, cxRequestInfo);\r\n    javax.sql.DataSource dataSource = getDataSource();\r\n    java.sql.Connection dsConn = null;\r\n    ManagedConnectionImpl mc = null;\r\n    try {\r\n        if (isEqual(pc, getUser(), getPassword())) {\r\n            dsConn = dataSource.getConnection();\r\n        } else {\r\n            dsConn = dataSource.getConnection(pc.getUserName(), new String(pc.getPassword()));\r\n        }\r\n    } catch (java.sql.SQLException sqle) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"jdbc.exc_create_conn\", sqle.getMessage());\r\n        }\r\n        StringManager localStrings = StringManager.getManager(DataSourceObjectBuilder.class);\r\n        String msg = localStrings.getString(\"jdbc.cannot_allocate_connection\", sqle.getMessage());\r\n        ResourceAllocationException rae = new ResourceAllocationException(msg);\r\n        rae.initCause(sqle);\r\n        throw rae;\r\n    }\r\n    try {\r\n        mc = constructManagedConnection(null, dsConn, pc, this);\r\n        validateAndSetIsolation(mc);\r\n    } finally {\r\n        if (mc == null) {\r\n            if (dsConn != null) {\r\n                try {\r\n                    dsConn.close();\r\n                } catch (SQLException e) {\r\n                    _logger.log(Level.FINEST, \"Exception while closing connection : \" + \"createManagedConnection\" + dsConn);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return mc;\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.connector.AppClientSniffer.handles",
	"Comment": "returns true if the passed file or directory is recognized by thisinstance.",
	"Method": "boolean handles(ReadableArchive location){\r\n    for (String s : stigmas) {\r\n        try {\r\n            if (location.exists(s)) {\r\n                return true;\r\n            }\r\n        } catch (IOException ignore) {\r\n        }\r\n    }\r\n    try {\r\n        Manifest manifest = location.getManifest();\r\n        if (manifest != null && manifest.getMainAttributes().containsKey(Attributes.Name.MAIN_CLASS)) {\r\n            return true;\r\n        }\r\n    } catch (IOException ignore) {\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.deployment.client.DFDeploymentPropertiesTest.testSetProperties",
	"Comment": "test of setproperties method, of class dfdeploymentproperties.",
	"Method": "void testSetProperties(){\r\n    Properties props = new Properties();\r\n    props.setProperty(\"keepSessions\", \"true\");\r\n    props.setProperty(\"foo\", \"bar\");\r\n    DFDeploymentProperties instance = new DFDeploymentProperties();\r\n    instance.setProperties(props);\r\n    String storedProps = (String) instance.get(DFDeploymentProperties.PROPERTY);\r\n    assertEquals(storedProps, \"keepSessions=true:foo=bar\");\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ApplicationClientDescriptor.getServiceReferenceByName",
	"Comment": "looks up an service reference with the given name. throws an illegalargumentexception if it is not found.",
	"Method": "ServiceReferenceDescriptor getServiceReferenceByName(String name){\r\n    for (Iterator itr = this.getServiceReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        ServiceReferenceDescriptor srd = (ServiceReferenceDescriptor) itr.next();\r\n        if (srd.getName().equals(name)) {\r\n            return srd;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionappclienthasnoservicerefbyname\", \"This application client [{0}] has no service reference by the name of [{1}]\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "org.glassfish.enterprise.iiop.impl.POAProtocolMgr.getEjbDescriptor",
	"Comment": "called from securitymechanismselector for each objref creation",
	"Method": "EjbDescriptor getEjbDescriptor(byte[] ejbKey){\r\n    EjbDescriptor result = null;\r\n    try {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"POAProtocolMgr.getEjbDescriptor->: {0}\", ejbKey);\r\n        }\r\n        if (ejbKey.length < POARemoteReferenceFactory.EJBID_OFFSET + 8) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"POAProtocolMgr.getEjbDescriptor: {0}: {1} < {2}{3}\", new Object[] { ejbKey, ejbKey.length, POARemoteReferenceFactory.EJBID_OFFSET, 8 });\r\n            }\r\n            return null;\r\n        }\r\n        long ejbId = Utility.bytesToLong(ejbKey, POARemoteReferenceFactory.EJBID_OFFSET);\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"POAProtocolMgr.getEjbDescriptor: {0}: ejbId: {1}\", new Object[] { ejbKey, ejbId });\r\n        }\r\n        EjbService ejbService = ejbServiceProvider.get();\r\n        result = ejbService.ejbIdToDescriptor(ejbId);\r\n    } finally {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"POAProtocolMgr.getEjbDescriptor<-: {0}: {1}\", new Object[] { ejbKey, result });\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.deployment.client.DFDeploymentStatus.setStageException",
	"Comment": "when the stage throws an exception, it should store it here in \tthe assiciated deployment status",
	"Method": "void setStageException(Throwable throwable){\r\n    if (throwable != null) {\r\n        stageException = new Throwable(throwable.toString());\r\n        stageException.setStackTrace(throwable.getStackTrace());\r\n    } else {\r\n        stageException = null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.StatefulSessionContainer.callLifecycleCallbackInTxIfUsed",
	"Comment": "start transaction if necessary and invoke lifecycle callback",
	"Method": "boolean callLifecycleCallbackInTxIfUsed(EjbInvocation ejbInv,EJBContextImpl ctx,InvocationInfo invInfo,CallbackType callbackType){\r\n    boolean inTx = (invInfo.txAttr != -1 && invInfo.txAttr != Container.TX_BEAN_MANAGED);\r\n    if (inTx) {\r\n        ((SessionContextImpl) ctx).setInLifeCycleCallback(true);\r\n        ejbInv.transactionAttribute = invInfo.txAttr;\r\n        ejbInv.invocationInfo = invInfo;\r\n        preInvokeTx(ejbInv);\r\n        enlistExtendedEntityManagers(ctx);\r\n    }\r\n    intercept(callbackType, ctx);\r\n    return inTx;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ForeignFieldDesc.chooseUpdatedSide",
	"Comment": "choose the updated relationship side based on the alphabethicalorder of the related class names. for self relationships, thefield names itself are compared, too.",
	"Method": "boolean chooseUpdatedSide(ForeignFieldDesc inverseFieldDesc){\r\n    int comparison = classDesc.getName().compareTo(foreignConfig.getName());\r\n    if (comparison == 0) {\r\n        comparison = getName().compareTo(inverseFieldDesc.getName());\r\n    }\r\n    return comparison < 0;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.unregisterAppStatsProviders",
	"Comment": "unregister the appstatsproviders registered for this connection pool.",
	"Method": "void unregisterAppStatsProviders(){\r\n    runtime.getProbeProviderUtil().getConnPoolBootstrap().unRegisterPool();\r\n    Iterator ccProviders = ccPoolAppStatsProviders.iterator();\r\n    while (ccProviders.hasNext()) {\r\n        ConnectorConnPoolAppStatsProvider ccPoolAppStatsProvider = (ConnectorConnPoolAppStatsProvider) ccProviders.next();\r\n        StatsProviderManager.unregister(ccPoolAppStatsProvider);\r\n    }\r\n    ccPoolAppStatsProviders.clear();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.setSupersedeDeletedInstance",
	"Comment": "sets the supersededeletedinstance flag for all persistencemanagers.",
	"Method": "void setSupersedeDeletedInstance(boolean flag){\r\n    throw new JDOUnsupportedOptionException(// NOI18N\r\n    I18NHelper.getMessage(messages, \"jdo.persistencemanagerfactoryimpl.notsupported\"));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.logging.LoggerJDK13.logInternal",
	"Comment": "this method does the actual logging.it is expected that if a \tcheck for isloggable is desired for performance reasons, it has \talready been done, as it should not be done here.this \timplementation uses a print stream for logging.",
	"Method": "void logInternal(int level,String message){\r\n    getPrintStream().println(getMessageWithPrefix(level, message));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.setMaxPool",
	"Comment": "sets maximum number of persistencemanager instances in the pool",
	"Method": "void setMaxPool(int MaxPool){\r\n    throw new JDOUnsupportedOptionException(// NOI18N\r\n    I18NHelper.getMessage(messages, \"jdo.persistencemanagerfactoryimpl.notsupported\"));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.MathType.getValue",
	"Comment": "converts the specified value into a value of this numeric type.e.g. an integer is converted into a bigdecimal, if this represents the type bigdecimal.",
	"Method": "Number getValue(Number value){\r\n    Number ret = null;\r\n    if (value == null)\r\n        ret = null;\r\n    else if (\"java.math.BigDecimal\".equals(getName())) {\r\n        if (value instanceof BigDecimal)\r\n            ret = value;\r\n        else if (value instanceof BigInteger)\r\n            ret = new BigDecimal((BigInteger) value);\r\n        else if (value instanceof Double)\r\n            ret = new BigDecimal(((Double) value).toString());\r\n        else if (value instanceof Float)\r\n            ret = new BigDecimal(((Float) value).toString());\r\n        else if (value instanceof Number)\r\n            ret = BigDecimal.valueOf(((Number) value).longValue());\r\n    } else if (\"java.math.BigInteger\".equals(getName())) {\r\n        if (value instanceof BigInteger)\r\n            ret = value;\r\n        else if (value instanceof Double)\r\n            ret = (new BigDecimal(((Double) value).toString())).toBigInteger();\r\n        else if (value instanceof Float)\r\n            ret = (new BigDecimal(((Float) value).toString())).toBigInteger();\r\n        else if (value instanceof Number)\r\n            ret = BigInteger.valueOf(((Number) value).longValue());\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ConnectionHolder.setClosed",
	"Comment": "set the isclosed flag based on whether the underlying connectionobject is closed.",
	"Method": "void setClosed(boolean flag){\r\n    isClosed = flag;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.logging.LoggerJDK13.log",
	"Comment": "log a message.\tif the logger is currently enabled for the message \tlevel then the given message, and the exception dump, \tis forwarded to all the\tregistered output handler objects.",
	"Method": "void log(int level,String msg,Throwable thrown){\r\n    if (isLoggable(level)) {\r\n        logInternal(level, getMessage(msg));\r\n        thrown.printStackTrace(getPrintStream());\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ConnectionHolder.isClosed",
	"Comment": "retrieves whether underlying connection object is closed.",
	"Method": "boolean isClosed(){\r\n    return isClosed;\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.database.PropertyHelper.loadFromFile",
	"Comment": "loads properties list from the specified file into specified properties object.",
	"Method": "void loadFromFile(Properties properties,String fileName){\r\n    load(properties, fileName, true, null);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jmac.provider.SOAPAuthParam.setRequestPacket",
	"Comment": "set the request packet.has the side effect of resetting the soap request message.",
	"Method": "void setRequestPacket(Object p){\r\n    if (classLoadingException != null) {\r\n        throw new RuntimeException(classLoadingException);\r\n    }\r\n    if (p == null || p instanceof Packet) {\r\n        getMap().put(REQ_PACKET, p);\r\n        this.requestInPacket = (p == null ? false : true);\r\n        this.request = null;\r\n    } else {\r\n        throw new RuntimeException(\"argument is not packet\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.constructFieldException",
	"Comment": "constructs a modelvalidationexception for field validation tests \tusing the supplied field name and key.",
	"Method": "ModelValidationException constructFieldException(String fieldName,String key,ModelValidationException constructFieldException,int errorType,String fieldName,String key){\r\n    return new ModelValidationException(errorType, getModel().getField(getClassName(), fieldName), I18NHelper.getMessage(getMessages(), key, fieldName));\r\n}"
}, {
	"Path": "com.sun.gjc.spi.XAResourceImpl.isSameRM",
	"Comment": "this method is called to determine if the resource manager instancerepresented by the target object is the same as the resouce managerinstance represented by the parameter xares.",
	"Method": "boolean isSameRM(XAResource xares){\r\n    return xar.isSameRM(xares);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.MappingGenerator.addRelatedTableName",
	"Comment": "adds a table name, if it is specified as a part of the column name,to the set of known table names.",
	"Method": "void addRelatedTableName(String columnName,Set tables){\r\n    if (!StringHelper.isEmpty(columnName)) {\r\n        int l = columnName.indexOf(DOT);\r\n        if (l > 0) {\r\n            addTableName(columnName.substring(0, l), tables);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnUtils.longConstant",
	"Comment": "return the best instruction for loading the specified long constant ontothe stack.",
	"Method": "Insn longConstant(long l,ConstantPool pool){\r\n    if (l == 0)\r\n        return Insn.create(opc_lconst_0);\r\n    else if (l == 1)\r\n        return Insn.create(opc_lconst_1);\r\n    else\r\n        return Insn.create(opc_ldc2_w, pool.addLong(l));\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.ApplicationArchivist.readModulesDescriptors",
	"Comment": "read the modules deployment descriptor from this application object usingthe passed archive",
	"Method": "boolean readModulesDescriptors(Application app,ReadableArchive appArchive){\r\n    List<ModuleDescriptor> nonexistentModules = new ArrayList<ModuleDescriptor>();\r\n    List<ModuleDescriptor> sortedModules = sortModules(app);\r\n    for (ModuleDescriptor aModule : sortedModules) {\r\n        if (aModule.getArchiveUri().indexOf(\" \") != -1) {\r\n            throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.unsupporturi\", \"Unsupported module URI {0}, it contains space(s)\", new Object[] { aModule.getArchiveUri() }));\r\n        }\r\n        if (DOLUtils.getDefaultLogger().isLoggable(Level.FINE)) {\r\n            DOLUtils.getDefaultLogger().fine(\"Opening sub-module \" + aModule);\r\n        }\r\n        BundleDescriptor descriptor = null;\r\n        Archivist newArchivist = archivistFactory.get().getArchivist(aModule.getModuleType());\r\n        newArchivist.initializeContext(this);\r\n        newArchivist.setRuntimeXMLValidation(this.getRuntimeXMLValidation());\r\n        newArchivist.setRuntimeXMLValidationLevel(this.getRuntimeXMLValidationLevel());\r\n        newArchivist.setAnnotationProcessingRequested(annotationProcessingRequested);\r\n        ReadableArchive embeddedArchive = appArchive.getSubArchive(aModule.getArchiveUri());\r\n        if (embeddedArchive == null) {\r\n            throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.nosuchmodule\", \"Could not find sub module [{0}] as defined in application.xml\", new Object[] { aModule.getArchiveUri() }));\r\n        }\r\n        embeddedArchive.setParentArchive(appArchive);\r\n        DOLUtils.setExtensionArchivistForSubArchivist(habitat, embeddedArchive, aModule, app, newArchivist);\r\n        if (aModule.getAlternateDescriptor() != null) {\r\n            InputStream is = appArchive.getEntry(aModule.getAlternateDescriptor());\r\n            DeploymentDescriptorFile ddFile = newArchivist.getStandardDDFile();\r\n            ddFile.setXMLValidation(newArchivist.getXMLValidation());\r\n            ddFile.setXMLValidationLevel(newArchivist.getXMLValidationLevel());\r\n            if (appArchive.getURI() != null) {\r\n                ddFile.setErrorReportingString(appArchive.getURI().getSchemeSpecificPart());\r\n            }\r\n            descriptor = (BundleDescriptor) ddFile.read(is);\r\n            descriptor.setApplication(app);\r\n            is.close();\r\n            Map<ExtensionsArchivist, RootDeploymentDescriptor> extensions = new HashMap<ExtensionsArchivist, RootDeploymentDescriptor>();\r\n            List<ExtensionsArchivist> extensionsArchivists = newArchivist.getExtensionArchivists();\r\n            if (extensionsArchivists != null) {\r\n                for (ExtensionsArchivist extension : extensionsArchivists) {\r\n                    Object rdd = extension.open(newArchivist, embeddedArchive, descriptor);\r\n                    if (rdd instanceof RootDeploymentDescriptor) {\r\n                        extensions.put(extension, (RootDeploymentDescriptor) rdd);\r\n                    }\r\n                }\r\n            }\r\n            newArchivist.postStandardDDsRead(descriptor, embeddedArchive, extensions);\r\n            newArchivist.readAnnotations(embeddedArchive, descriptor, extensions);\r\n            newArchivist.postAnnotationProcess(descriptor, embeddedArchive);\r\n            newArchivist.postOpen(descriptor, embeddedArchive);\r\n            if (isHandlingRuntimeInfo()) {\r\n                DOLUtils.readAlternativeRuntimeDescriptor(appArchive, embeddedArchive, newArchivist, descriptor, aModule.getAlternateDescriptor());\r\n                for (Map.Entry<ExtensionsArchivist, RootDeploymentDescriptor> extension : extensions.entrySet()) {\r\n                    if (extension.getValue() != null) {\r\n                        extension.getKey().readRuntimeDeploymentDescriptor(newArchivist, embeddedArchive, extension.getValue());\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            descriptor = newArchivist.open(embeddedArchive, app);\r\n        }\r\n        embeddedArchive.close();\r\n        if (descriptor != null) {\r\n            descriptor.getModuleDescriptor().setArchiveUri(aModule.getArchiveUri());\r\n            aModule.setModuleName(descriptor.getModuleDescriptor().getModuleName());\r\n            aModule.setDescriptor(descriptor);\r\n            descriptor.setApplication(app);\r\n            aModule.setManifest(newArchivist.getManifest());\r\n            if (!appArchive.exists(\"META-INF/application.xml\")) {\r\n                if (aModule.getModuleType().equals(DOLUtils.warType())) {\r\n                    WebBundleDescriptor wbd = (WebBundleDescriptor) descriptor;\r\n                    if (wbd.getContextRoot() != null && !wbd.getContextRoot().equals(\"\"))\r\n                        aModule.setContextRoot(wbd.getContextRoot());\r\n                    else\r\n                        aModule.setContextRoot(aModule.getModuleName());\r\n                }\r\n            }\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    for (ModuleDescriptor nonexistentModule : nonexistentModules) {\r\n        app.removeModule(nonexistentModule);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.BundleDescriptor.getUniqueFriendlyId",
	"Comment": "return a short unique representation of this bundledescriptor",
	"Method": "String getUniqueFriendlyId(){\r\n    return FileUtils.makeFriendlyFilename(getModuleName());\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.util.TypeUtil.intGetBytes",
	"Comment": "place a byte representation of src into the byte array buf.no commas or any other formatting is done to the integer.",
	"Method": "int intGetBytes(int src,byte buf,int offset){\r\n    int power = 1000000000;\r\n    int this_digit;\r\n    boolean have_emitted = false;\r\n    int init_offset = offset;\r\n    if (src == 0) {\r\n        buf[offset] = charval[0];\r\n        return 1;\r\n    } else if (src < 0) {\r\n        if (src == Integer.MIN_VALUE)\r\n            throw new IllegalArgumentException();\r\n        buf[offset++] = (byte) '-';\r\n        src = Math.abs(src);\r\n    }\r\n    while (power > 0) {\r\n        this_digit = src / power;\r\n        if (this_digit != 0 || have_emitted) {\r\n            have_emitted = true;\r\n            buf[offset++] = charval[this_digit];\r\n        }\r\n        src = src % power;\r\n        power = power / 10;\r\n    }\r\n    return offset - init_offset;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.StatefulSessionContainer._getContext",
	"Comment": "called from preinvoke which is called from the ejbobjectfor local and remote invocations.",
	"Method": "ComponentContext _getContext(EjbInvocation inv){\r\n    EJBLocalRemoteObject ejbo = inv.ejbObject;\r\n    SessionContextImpl sc = ejbo.getContext();\r\n    Serializable sessionKey = (Serializable) ejbo.getKey();\r\n    if (_logger.isLoggable(TRACE_LEVEL)) {\r\n        logTraceInfo(inv, sessionKey, \"Trying to get context\");\r\n    }\r\n    if (sc == null) {\r\n        sc = (SessionContextImpl) sessionBeanCache.lookupEJB(sessionKey, this, ejbo);\r\n    }\r\n    if ((sc == null) || (sc.getState() == BeanState.DESTROYED)) {\r\n        if (_logger.isLoggable(TRACE_LEVEL)) {\r\n            logTraceInfo(inv, sessionKey, \"Context already destroyed\");\r\n        }\r\n        throw new NoSuchObjectLocalException(\"The EJB does not exist.\" + \" session-key: \" + sessionKey);\r\n    }\r\n    MethodLockInfo lockInfo = inv.invocationInfo.methodLockInfo;\r\n    boolean allowSerializedAccess = (lockInfo == null) || (lockInfo.getTimeout() != CONCURRENCY_NOT_ALLOWED);\r\n    if (allowSerializedAccess) {\r\n        boolean blockWithTimeout = (lockInfo != null) && (lockInfo.getTimeout() != BLOCK_INDEFINITELY);\r\n        if (blockWithTimeout) {\r\n            try {\r\n                boolean acquired = sc.getStatefulWriteLock().tryLock(lockInfo.getTimeout(), lockInfo.getTimeUnit());\r\n                if (!acquired) {\r\n                    String msg = \"Serialized access attempt on method \" + inv.beanMethod + \" for ejb \" + ejbDescriptor.getName() + \" timed out after \" + +lockInfo.getTimeout() + \" \" + lockInfo.getTimeUnit();\r\n                    throw new ConcurrentAccessTimeoutException(msg);\r\n                }\r\n            } catch (InterruptedException ie) {\r\n                String msg = \"Serialized access attempt on method \" + inv.beanMethod + \" for ejb \" + ejbDescriptor.getName() + \" was interrupted within \" + +lockInfo.getTimeout() + \" \" + lockInfo.getTimeUnit();\r\n                ConcurrentAccessException cae = new ConcurrentAccessTimeoutException(msg);\r\n                cae.initCause(ie);\r\n                throw cae;\r\n            }\r\n        } else {\r\n            sc.getStatefulWriteLock().lock();\r\n        }\r\n        inv.setHoldingSFSBSerializedLock(true);\r\n    }\r\n    SessionContextImpl context = null;\r\n    try {\r\n        synchronized (sc) {\r\n            SessionContextImpl newSC = sc;\r\n            if (sc.getState() == BeanState.PASSIVATED) {\r\n                newSC = (SessionContextImpl) sessionBeanCache.lookupEJB(sessionKey, this, ejbo);\r\n                if (newSC == null) {\r\n                    if (_logger.isLoggable(TRACE_LEVEL)) {\r\n                        logTraceInfo(inv, sessionKey, \"Context does not exist\");\r\n                    }\r\n                    throw new NoSuchObjectLocalException(\"The EJB does not exist. key: \" + sessionKey);\r\n                }\r\n                newSC.setStatefulWriteLock(sc);\r\n            }\r\n            synchronized (newSC) {\r\n                if (newSC.getState() == BeanState.DESTROYED) {\r\n                    if (_logger.isLoggable(TRACE_LEVEL)) {\r\n                        logTraceInfo(inv, sessionKey, \"Got destroyed context\");\r\n                    }\r\n                    throw new NoSuchObjectLocalException(\"The EJB does not exist. session-key: \" + sessionKey);\r\n                } else if (newSC.getState() == BeanState.INVOKING) {\r\n                    handleConcurrentInvocation(allowSerializedAccess, inv, newSC, sessionKey);\r\n                }\r\n                if (newSC.getState() == BeanState.READY) {\r\n                    decrementMethodReadyStat();\r\n                }\r\n                if (isHAEnabled) {\r\n                    doVersionCheck(inv, sessionKey, sc);\r\n                }\r\n                newSC.setState(BeanState.INVOKING);\r\n                context = newSC;\r\n            }\r\n        }\r\n        context.touch();\r\n        if ((context.existsInStore()) && (removalGracePeriodInSeconds > 0)) {\r\n            long now = System.currentTimeMillis();\r\n            long threshold = now - (removalGracePeriodInSeconds * 1000L);\r\n            if (context.getLastPersistedAt() <= threshold) {\r\n                try {\r\n                    backingStore.updateTimestamp(sessionKey, now);\r\n                    context.setLastPersistedAt(System.currentTimeMillis());\r\n                } catch (BackingStoreException sfsbEx) {\r\n                    _logger.log(Level.WARNING, COULDNT_UPDATE_TIMESTAMP_FOR_EXCEPTION, new Object[] { sessionKey, sfsbEx });\r\n                    _logger.log(Level.FINE, \"Couldn't update timestamp for: \" + sessionKey, sfsbEx);\r\n                }\r\n            }\r\n        }\r\n        if (_logger.isLoggable(TRACE_LEVEL)) {\r\n            logTraceInfo(inv, context, \"Got Context!!\");\r\n        }\r\n    } catch (RuntimeException t) {\r\n        releaseSFSBSerializedLock(inv, sc);\r\n        throw t;\r\n    }\r\n    return context;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.NameMapper.getEjbNameForLocalInterface",
	"Comment": "gets the name of the ejb which corresponds to the specified \tlocal interface name.",
	"Method": "String getEjbNameForLocalInterface(String ejbName,String fieldName,String interfaceName){\r\n    EjbCMPEntityDescriptor descriptor = getRelatedEjbDescriptor(ejbName, fieldName);\r\n    return (((descriptor != null) && !StringHelper.isEmpty(interfaceName) && interfaceName.equals(descriptor.getLocalClassName())) ? descriptor.getName() : null);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.connector.ConnectorNode.registerBundle",
	"Comment": "register this node as a root node capable of loading entire dd files",
	"Method": "String registerBundle(Map<String, String> publicIDToDTD){\r\n    publicIDToDTD.put(PUBLIC_DTD_ID, SYSTEM_ID);\r\n    publicIDToDTD.put(PUBLIC_DTD_ID_10, SYSTEM_ID_10);\r\n    return tag.getQName();\r\n}"
}, {
	"Path": "client.SampleExternalMethods.countCoffee",
	"Comment": "counts rows in the coffee table.this is the procedure body for countcoffee procedure.",
	"Method": "void countCoffee(int[] count){\r\n    Connection conn = null;\r\n    Statement stmt = null;\r\n    try {\r\n        conn = DriverManager.getConnection(\"jdbc:default:connection\");\r\n        stmt = conn.createStatement();\r\n        ResultSet rs = stmt.executeQuery(\"select count(*) from coffee\");\r\n        if (rs.next()) {\r\n            count[0] = rs.getInt(1);\r\n        }\r\n        rs.close();\r\n        stmt.close();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        throw e;\r\n    } finally {\r\n        if (stmt != null)\r\n            try {\r\n                stmt.close();\r\n            } catch (Exception e) {\r\n            }\r\n        if (conn != null)\r\n            try {\r\n                stmt.close();\r\n            } catch (Exception e) {\r\n            }\r\n    }\r\n}"
}, {
	"Path": "com.sun.web.security.RealmAdapter.invokeAuthenticateDelegate",
	"Comment": "authenticates the user making this request, based on the specifiedlogin configuration.return true if any specifiedrequirements have been satisfied, or false if we havecreated a response challenge already.",
	"Method": "boolean invokeAuthenticateDelegate(HttpRequest request,HttpResponse response,Context context,Authenticator authenticator,boolean calledFromAuthenticate){\r\n    boolean result = false;\r\n    LoginConfig config = context.getLoginConfig();\r\n    ServerAuthConfig serverAuthConfig = null;\r\n    try {\r\n        if (helper != null) {\r\n            serverAuthConfig = helper.getServerAuthConfig();\r\n        }\r\n    } catch (Exception ex) {\r\n        IOException iex = new IOException();\r\n        iex.initCause(ex);\r\n        throw iex;\r\n    }\r\n    if (serverAuthConfig != null) {\r\n        try {\r\n            context.fireContainerEvent(ContainerEvent.BEFORE_AUTHENTICATION, null);\r\n            result = validate(request, response, config, authenticator, calledFromAuthenticate);\r\n        } finally {\r\n            context.fireContainerEvent(ContainerEvent.AFTER_AUTHENTICATION, null);\r\n        }\r\n    } else {\r\n        result = ((AuthenticatorBase) authenticator).authenticate(request, response, config);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.deployapi.DeploymentStatusImpl.isRunning",
	"Comment": "a convience method to report if the operation isin the running state.",
	"Method": "boolean isRunning(){\r\n    return StateType.RUNNING.equals(stateType);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.getWriteObjectArgs",
	"Comment": "standard set of arguments for comparison with writeobject method.",
	"Method": "String[] getWriteObjectArgs(){\r\n    return new String[] { \"java.io.ObjectOutputStream\" };\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.help.HelpTreeAdaptor.getId",
	"Comment": "this method returns the id for the given tree node \tmodel object.",
	"Method": "String getId(Object nodeObject){\r\n    String id = \"invalideNodeObjectType\";\r\n    if (nodeObject == null) {\r\n        id = \"nullNodeObject\";\r\n    } else if (nodeObject instanceof TOCItem) {\r\n        id = genId(((TOCItem) nodeObject).getTarget());\r\n    } else if (nodeObject instanceof TOC) {\r\n        id = getLayoutComponent().getId(FacesContext.getCurrentInstance(), getParentUIComponent());\r\n    }\r\n    return id;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ResultSetWrapper40.getNClob",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object as a nclob objectin the java programming language.",
	"Method": "NClob getNClob(int columnIndex,NClob getNClob,String columnLabel){\r\n    return resultSet.getNClob(columnLabel);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.getField",
	"Comment": "returns the field element for the specified fieldname in the class\twith the specified classname.",
	"Method": "Object getField(String className,String fieldName){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.UtilHandlers.formatStringsforDisplay",
	"Comment": "we want to separator and display each jar in one line in the text box.",
	"Method": "void formatStringsforDisplay(HandlerContext handlerCtx){\r\n    String values = (String) handlerCtx.getInputValue(\"string\");\r\n    if (values == null || GuiUtil.isEmpty(values.trim())) {\r\n        handlerCtx.setOutputValue(\"formattedString\", \"\");\r\n    } else {\r\n        String s1 = values.trim().replaceAll(\"\\\\.jar:\", \"\\\\.jar\\\\$\\\\{path.separator\\\\}\");\r\n        String s2 = s1.replaceAll(\"\\\\.jar;\", \"\\\\.jar\\\\$\\\\{path.separator\\\\}\");\r\n        String[] strArray = s2.split(\"\\\\$\\\\{path.separator\\\\}\");\r\n        StringBuilder result = new StringBuilder(\"\");\r\n        for (String s : strArray) {\r\n            result.append(s).append(\"\\n\");\r\n        }\r\n        handlerCtx.setOutputValue(\"formattedString\", result.toString().trim());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.PoolTxHelper.isLocalResourceInTransaction",
	"Comment": "check whether the local resource in question is the one participating in transaction.",
	"Method": "boolean isLocalResourceInTransaction(ResourceHandle h){\r\n    boolean result = true;\r\n    try {\r\n        JavaEETransaction txn = (JavaEETransaction) ConnectorRuntime.getRuntime().getTransaction();\r\n        if (txn != null)\r\n            result = isNonXAResourceInTransaction(txn, h);\r\n    } catch (SystemException e) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Exception while checking whether the resource [ of pool : \" + poolInfo + \" ] \" + \"is nonxa and is enlisted in transaction : \", e);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.RelationshipElementImpl.setLowerBound",
	"Comment": "set the lower cardinality bound for this relationship element.",
	"Method": "void setLowerBound(int lowerBound){\r\n    Integer old = new Integer(getLowerBound());\r\n    Integer newBound = new Integer(lowerBound);\r\n    try {\r\n        fireVetoableChange(PROP_CARDINALITY, old, newBound);\r\n        _lowerBound = lowerBound;\r\n        firePropertyChange(PROP_CARDINALITY, old, newBound);\r\n    } catch (PropertyVetoException e) {\r\n        throw new ModelVetoException(e);\r\n    }\r\n}"
}, {
	"Path": "client.SampleExternalMethods.insertCoffee",
	"Comment": "inserts a row in the coffee table.this is the procedure body for insertcoffee procedure.",
	"Method": "void insertCoffee(String name,int qty){\r\n    Connection conn = null;\r\n    PreparedStatement stmt = null;\r\n    try {\r\n        conn = DriverManager.getConnection(\"jdbc:default:connection\");\r\n        stmt = conn.prepareStatement(\"insert into coffee values (?, ?)\");\r\n        stmt.setString(1, name);\r\n        stmt.setInt(2, qty);\r\n        stmt.executeUpdate();\r\n        conn.commit();\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        throw e;\r\n    } finally {\r\n        if (stmt != null)\r\n            try {\r\n                stmt.close();\r\n            } catch (Exception e) {\r\n            }\r\n        if (conn != null)\r\n            try {\r\n                stmt.close();\r\n            } catch (Exception e) {\r\n            }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.client.TestDeploy.testDeploy",
	"Comment": "note that the two tests below are here as examples of how to use thedeploymentfacility.in their current form they should not be usedas tests, because they would require the server to be up.",
	"Method": "void testDeploy(){\r\n    DeploymentFacility df = DeploymentFacilityFactory.getDeploymentFacility();\r\n    ServerConnectionIdentifier sci = new ServerConnectionIdentifier();\r\n    sci.setHostName(\"localhost\");\r\n    sci.setHostPort(4848);\r\n    sci.setUserName(\"admin\");\r\n    sci.setPassword(\"\");\r\n    df.connect(sci);\r\n    File archive = new File(\"/home/hzhang/deployment/apps/jsr88/servletonly-portable.war\");\r\n    File plan = new File(\"/home/hzhang/deployment/apps/jsr88/servletonly-deployplan.jar\");\r\n    DFDeploymentProperties options = new DFDeploymentProperties();\r\n    options.setForce(true);\r\n    options.setUpload(true);\r\n    options.setName(APP_NAME);\r\n    Properties props = new Properties();\r\n    props.setProperty(\"keepSessions\", \"true\");\r\n    props.setProperty(\"foo\", \"bar\");\r\n    options.setProperties(props);\r\n    try {\r\n        Target[] targets = df.listTargets();\r\n        DFProgressObject prog = df.deploy(targets, archive.toURI(), plan.toURI(), options);\r\n        DFDeploymentStatus ds = prog.waitFor();\r\n        if (ds.getStatus() == DFDeploymentStatus.Status.FAILURE) {\r\n            fail(ds.getAllStageMessages());\r\n        }\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        fail(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ResourceAdapterImpl.getXAResources",
	"Comment": "empty method implementation for getxaresourceswhich just throws notsupportedexception",
	"Method": "XAResource[] getXAResources(ActivationSpec[] specs){\r\n    throw new NotSupportedException(\"This method is not supported for this JDBC connector\");\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.getSupportedCollectionClasses",
	"Comment": "computes the list of names of the possible collection classes for the\tspecified class.",
	"Method": "ArrayList getSupportedCollectionClasses(String className){\r\n    String supportedSet = \"java.util.HashSet\";\r\n    ArrayList returnList = new ArrayList();\r\n    returnList.add(supportedSet);\r\n    return returnList;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.insertsAreDetected",
	"Comment": "retrieves whether or not a visible row insert can be detectedby calling the method resultset.rowinserted.",
	"Method": "boolean insertsAreDetected(int type){\r\n    return databaseMetaData.insertsAreDetected(type);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.setConnectionLoginTimeout",
	"Comment": "sets the number of seconds to wait for a new connection to beestablished to the data source",
	"Method": "void setConnectionLoginTimeout(int LoginTimeout){\r\n    throw new JDOUnsupportedOptionException(// NOI18N\r\n    I18NHelper.getMessage(messages, \"jdo.persistencemanagerfactoryimpl.notsupported\"));\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBTimerService.restoreTaskToDelivered",
	"Comment": "called from timerbean in case where timer is cancelled from withinits own ejbtimeout method and then rolled back.",
	"Method": "void restoreTaskToDelivered(TimerPrimaryKey timerId){\r\n    RuntimeTimerState timerState = getTimerState(timerId);\r\n    if (timerState != null) {\r\n        synchronized (timerState) {\r\n            timerState.restoredToDelivered();\r\n        }\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.log(Level.FINE, \"Restoring \" + timerId + \" to delivered state after it was cancelled and \" + \" rolled back from within its own ejbTimeout method\");\r\n        }\r\n    } else {\r\n        logger.log(Level.FINE, \"No timer state found for \" + \"restoreTaskToDelivered request of \" + timerId);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.JdbcObjectsFactory.getInstance",
	"Comment": "returns jdbc objet factory for jdbc 3.0 or jdbc 4.0 depending upon the jdbc versionavailable in jdk.",
	"Method": "JdbcObjectsFactory getInstance(){\r\n    boolean jdbc40 = DataSourceObjectBuilder.isJDBC40();\r\n    JdbcObjectsFactory factory = null;\r\n    try {\r\n        if (jdbc40) {\r\n            factory = (JdbcObjectsFactory) Class.forName(\"com.sun.gjc.spi.jdbc40.Jdbc40ObjectsFactory\").newInstance();\r\n        } else {\r\n            factory = (JdbcObjectsFactory) Class.forName(\"com.sun.gjc.spi.jdbc30.Jdbc30ObjectsFactory\").newInstance();\r\n        }\r\n    } catch (Exception e) {\r\n        _logger.log(Level.WARNING, \"jdbc.jdbc_factory_class_load_exception\", e);\r\n    }\r\n    return factory;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.DBStatement.executeQuery",
	"Comment": "delegates the executequery call to the preparedstatement wrapped bythis dbstatement.",
	"Method": "ResultSet executeQuery(){\r\n    return preparedStmt.executeQuery();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.TransactionImpl.statusString",
	"Comment": "translates a javax.transaction.status value into a string.",
	"Method": "String statusString(int status){\r\n    switch(status) {\r\n        case Status.STATUS_ACTIVE:\r\n            return \"STATUS_ACTIVE\";\r\n        case Status.STATUS_MARKED_ROLLBACK:\r\n            return \"STATUS_MARKED_ROLLBACK\";\r\n        case Status.STATUS_PREPARED:\r\n            return \"STATUS_PREPARED\";\r\n        case Status.STATUS_COMMITTED:\r\n            return \"STATUS_COMMITTED\";\r\n        case Status.STATUS_ROLLEDBACK:\r\n            return \"STATUS_ROLLEDBACK\";\r\n        case Status.STATUS_UNKNOWN:\r\n            return \"STATUS_UNKNOWN\";\r\n        case Status.STATUS_NO_TRANSACTION:\r\n            return \"STATUS_NO_TRANSACTION\";\r\n        case Status.STATUS_PREPARING:\r\n            return \"STATUS_PREPARING\";\r\n        case Status.STATUS_COMMITTING:\r\n            return \"STATUS_COMMITTING\";\r\n        case Status.STATUS_ROLLING_BACK:\r\n            return \"STATUS_ROLLING_BACK\";\r\n        default:\r\n            break;\r\n    }\r\n    return \"STATUS_Invalid[\" + status + \"]\";\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.CreateConnectorWorkSecurityMap.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (mapName == null) {\r\n        report.setMessage(localStrings.getLocalString(\"create.connector.work.security.map.noMapName\", \"No mapname defined for connector work security map.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (raName == null) {\r\n        report.setMessage(localStrings.getLocalString(\"create.connector.work.security.map.noRaName\", \"No raname defined for connector work security map.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (principalsMap == null && groupsMap == null) {\r\n        report.setMessage(localStrings.getLocalString(\"create.connector.work.security.map.noMap\", \"No principalsmap or groupsmap defined for connector work security map.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (principalsMap != null && groupsMap != null) {\r\n        report.setMessage(localStrings.getLocalString(\"create.connector.work.security.map.specifyPrincipalsOrGroupsMap\", \"A work-security-map can have either (any number of) group mapping  \" + \"or (any number of) principals mapping but not both. Specify\" + \"--principalsmap or --groupsmap.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (hasDuplicate(domain.getResources(), report))\r\n        return;\r\n    String appName = raName;\r\n    if (!ConnectorsUtil.isStandAloneRA(raName)) {\r\n        appName = ConnectorsUtil.getApplicationNameOfEmbeddedRar(raName);\r\n        Application application = applications.getApplication(appName);\r\n        if (application != null) {\r\n            String resourceAdapterName = ConnectorsUtil.getRarNameFromApplication(raName);\r\n            Module module = application.getModule(resourceAdapterName);\r\n            if (module != null) {\r\n                Resources msr = module.getResources();\r\n                if (msr != null) {\r\n                    if (hasDuplicate(msr, report))\r\n                        return;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        Application application = applications.getApplication(appName);\r\n        if (application != null) {\r\n            Resources appScopedResources = application.getResources();\r\n            if (appScopedResources != null) {\r\n                if (hasDuplicate(appScopedResources, report))\r\n                    return;\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<Resources>() {\r\n            public Object run(Resources param) throws PropertyVetoException, TransactionFailure {\r\n                WorkSecurityMap workSecurityMap = param.createChild(WorkSecurityMap.class);\r\n                workSecurityMap.setName(mapName);\r\n                workSecurityMap.setResourceAdapterName(raName);\r\n                if (principalsMap != null) {\r\n                    for (Map.Entry e : principalsMap.entrySet()) {\r\n                        PrincipalMap principalMap = workSecurityMap.createChild(PrincipalMap.class);\r\n                        principalMap.setEisPrincipal((String) e.getKey());\r\n                        principalMap.setMappedPrincipal((String) e.getValue());\r\n                        workSecurityMap.getPrincipalMap().add(principalMap);\r\n                    }\r\n                } else if (groupsMap != null) {\r\n                    for (Map.Entry e : groupsMap.entrySet()) {\r\n                        GroupMap groupMap = workSecurityMap.createChild(GroupMap.class);\r\n                        groupMap.setEisGroup((String) e.getKey());\r\n                        groupMap.setMappedGroup((String) e.getValue());\r\n                        workSecurityMap.getGroupMap().add(groupMap);\r\n                    }\r\n                } else {\r\n                }\r\n                param.getResources().add(workSecurityMap);\r\n                return workSecurityMap;\r\n            }\r\n        }, domain.getResources());\r\n    } catch (TransactionFailure tfe) {\r\n        Logger.getLogger(CreateConnectorWorkSecurityMap.class.getName()).log(Level.SEVERE, \"create-connector-work-security-map failed\", tfe);\r\n        report.setMessage(localStrings.getLocalString(\"create.connector.work.security.map.fail\", \"Unable to create connector work security map {0}.\", mapName) + \" \" + tfe.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.CreateConnectorWorkSecurityMap.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    WorkSecurityMap workSecurityMap = param.createChild(WorkSecurityMap.class);\r\n    workSecurityMap.setName(mapName);\r\n    workSecurityMap.setResourceAdapterName(raName);\r\n    if (principalsMap != null) {\r\n        for (Map.Entry e : principalsMap.entrySet()) {\r\n            PrincipalMap principalMap = workSecurityMap.createChild(PrincipalMap.class);\r\n            principalMap.setEisPrincipal((String) e.getKey());\r\n            principalMap.setMappedPrincipal((String) e.getValue());\r\n            workSecurityMap.getPrincipalMap().add(principalMap);\r\n        }\r\n    } else if (groupsMap != null) {\r\n        for (Map.Entry e : groupsMap.entrySet()) {\r\n            GroupMap groupMap = workSecurityMap.createChild(GroupMap.class);\r\n            groupMap.setEisGroup((String) e.getKey());\r\n            groupMap.setMappedGroup((String) e.getValue());\r\n            workSecurityMap.getGroupMap().add(groupMap);\r\n        }\r\n    } else {\r\n    }\r\n    param.getResources().add(workSecurityMap);\r\n    return workSecurityMap;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ee.Audit.getWebComponentCount",
	"Comment": "the number of web components in this application.current implementation only return the number of servletsinside the application, and not the jsps since we cannotget that information from deployment descriptors.",
	"Method": "int getWebComponentCount(Application app){\r\n    int count = 0;\r\n    for (WebBundleDescriptor wbd : app.getBundleDescriptors(WebBundleDescriptor.class)) {\r\n        count = count + wbd.getWebComponentDescriptors().size();\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.CodeAttribute.buildInstructions",
	"Comment": "derive the instruction list from the instruction byte codes",
	"Method": "void buildInstructions(CodeEnv codeEnv){\r\n    if (theCodeBytes != null) {\r\n        InsnReadEnv insnEnv = new InsnReadEnv(theCodeBytes, codeEnv);\r\n        theCode = insnEnv.getTarget(0);\r\n        Insn currInsn = theCode;\r\n        while (insnEnv.more()) {\r\n            Insn newInsn = Insn.read(insnEnv);\r\n            currInsn.setNext(newInsn);\r\n            currInsn = newInsn;\r\n        }\r\n        InsnTarget targ;\r\n        currInsn = theCode;\r\n        Insn prevInsn = null;\r\n        while (currInsn != null) {\r\n            int off = currInsn.offset();\r\n            if (off > 0) {\r\n                targ = codeEnv.findTarget(off);\r\n                if (targ != null)\r\n                    prevInsn.setNext(targ);\r\n            }\r\n            prevInsn = currInsn;\r\n            currInsn = currInsn.next();\r\n        }\r\n        targ = codeEnv.findTarget(insnEnv.currentPC());\r\n        if (targ != null)\r\n            prevInsn.setNext(targ);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.XAResourceImpl.getTransactionTimeout",
	"Comment": "obtain the current transaction timeout value set for this xaresource instance.",
	"Method": "int getTransactionTimeout(){\r\n    return xar.getTransactionTimeout();\r\n}"
}, {
	"Path": "org.glassfish.deployapi.ProgressObjectImpl.getResultTargetModuleIDs",
	"Comment": "retrieve the list of targetmoduleids successfullyprocessed or created by the associated deploymentmanageroperation.",
	"Method": "TargetModuleID[] getResultTargetModuleIDs(){\r\n    if (targetModuleIDs == null) {\r\n        if (target != null) {\r\n            initializeTargetModuleIDs(moduleID);\r\n        }\r\n    }\r\n    return targetModuleIDs;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingClassElementImpl.fireVetoableChange",
	"Comment": "fires vetoable change event.this method overrides that of \tmappingelementimpl to give listeners a chance to block \tchanges on the mapping class element modified status.",
	"Method": "void fireVetoableChange(String name,Object o,Object n){\r\n    boolean noChange = ((o != null) && (n != null) && o.equals(n));\r\n    super.fireVetoableChange(name, o, n);\r\n    if (!(PROP_MODIFIED.equals(name)) && !noChange)\r\n        fireVetoableChange(PROP_MODIFIED, Boolean.FALSE, Boolean.TRUE);\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.obj.RemoteToAttrs.getStateToBind",
	"Comment": "returns an object and attributes for storing into ldap that represents the remote object. if the input is not a remote object, or if the remote object cannot be transformed, return null.",
	"Method": "DirStateFactory.Result getStateToBind(Object orig,Name name,Context ctx,Hashtable env,Attributes inAttrs,Object getStateToBind,Object orig,Name name,Context ctx,Hashtable env){\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.ejb.security.application.EJBSecurityManager.invoke",
	"Comment": "this method is similiar to the runmethod, except it keeps thesemantics same as the one in reflection. on failure, if theexception is caused due to reflection, it returns theinvocationtargetexception.this method is called from thecontainers for ejbtimeout, webservice and mdbs.",
	"Method": "Object invoke(Method beanClassMethod,boolean isLocal,Object o,Object[] oa){\r\n    final Method meth = beanClassMethod;\r\n    final Object obj = o;\r\n    final Object[] objArr = oa;\r\n    Object ret = null;\r\n    if ((isLocal && this.getUsesCallerIdentity()) || System.getSecurityManager() == null) {\r\n        ret = this.runMethod(meth, obj, objArr);\r\n    } else {\r\n        PrivilegedExceptionAction pea = new PrivilegedExceptionAction() {\r\n            public Object run() throws Exception {\r\n                return meth.invoke(obj, objArr);\r\n            }\r\n        };\r\n        try {\r\n            ret = this.doAsPrivileged(pea);\r\n        } catch (PrivilegedActionException pae) {\r\n            Throwable cause = pae.getCause();\r\n            throw cause;\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.glassfish.ejb.security.application.EJBSecurityManager.invoke",
	"Comment": "this method is similiar to the runmethod, except it keeps thesemantics same as the one in reflection. on failure, if theexception is caused due to reflection, it returns theinvocationtargetexception.this method is called from thecontainers for ejbtimeout, webservice and mdbs.",
	"Method": "Object invoke(Method beanClassMethod,boolean isLocal,Object o,Object[] oa){\r\n    return meth.invoke(obj, objArr);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.isSerializable",
	"Comment": "determines if the specified field element has a serializable type. \ta type is serializable if it is a primitive type, a class that implements \tjava.io.serializable or an interface that inherits from \tjava.io.serializable.\tnote, the field element is a model specific field representation as \treturned by a getfield call executed on the same model instance.",
	"Method": "boolean isSerializable(Object fieldElement){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.sun.ejb.containers.BaseContainer.suspendTransaction",
	"Comment": "called from preinvoketx to check if transaction needs to be suspended",
	"Method": "boolean suspendTransaction(EjbInvocation inv){\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.XAStartOccurred",
	"Comment": "this method is called by the xaresource object when its start methodhas been invoked.",
	"Method": "void XAStartOccurred(){\r\n    try {\r\n        actualConnection.setAutoCommit(false);\r\n    } catch (Exception e) {\r\n        _logger.log(Level.WARNING, \"XA Start [ setAutoCommit ] failure \", e);\r\n        connectionErrorOccurred(e, null);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.DriverLoader.getDatabaseVendorNames",
	"Comment": "get a set of common database vendor names supported in glassfish.",
	"Method": "Set<String> getDatabaseVendorNames(){\r\n    File dbVendorFile = new File(DBVENDOR_MAPPINGS_ROOT + VENDOR_PROPERTIES);\r\n    Properties fileProperties = loadFile(dbVendorFile);\r\n    Set<String> dbvendorNames = new TreeSet<String>();\r\n    Enumeration e = fileProperties.propertyNames();\r\n    while (e.hasMoreElements()) {\r\n        String vendor = (String) e.nextElement();\r\n        dbvendorNames.add(vendor);\r\n    }\r\n    return dbvendorNames;\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.ChangeMasterBrokerCommand.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    final String newMB = newMasterBroker;\r\n    Server newMBServer = domain.getServerNamed(newMasterBroker);\r\n    if (newMBServer == null) {\r\n        report.setMessage(localStrings.getLocalString(\"change.master.broker.invalidServerName\", \"Invalid server name specified. There is no server by this name\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    Cluster cluster = newMBServer.getCluster();\r\n    if (cluster == null) {\r\n        report.setMessage(localStrings.getLocalString(\"change.master.broker.invalidClusterName\", \"The server specified is not associated with a cluster. The server assocaited with the master broker has to be a part of the cluster\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    Nodes nodes = domain.getNodes();\r\n    config = domain.getConfigNamed(cluster.getConfigRef());\r\n    JmsService jmsservice = config.getExtensionByType(JmsService.class);\r\n    Server oldMBServer = null;\r\n    if (jmsservice.getMasterBroker() != null) {\r\n        oldMBServer = domain.getServerNamed(jmsservice.getMasterBroker());\r\n    } else {\r\n        List<Server> serverList = cluster.getInstances();\r\n        oldMBServer = serverList.get(0);\r\n    }\r\n    String oldMasterBrokerPort = JmsRaUtil.getJMSPropertyValue(oldMBServer);\r\n    if (oldMasterBrokerPort == null) {\r\n        SystemProperty sp = config.getSystemProperty(\"JMS_PROVIDER_PORT\");\r\n        if (sp != null)\r\n            oldMasterBrokerPort = sp.getValue();\r\n    }\r\n    if (oldMasterBrokerPort == null)\r\n        oldMasterBrokerPort = getDefaultJmsHost(jmsservice).getPort();\r\n    String oldMasterBrokerHost = nodes.getNode(oldMBServer.getNodeRef()).getNodeHost();\r\n    String newMasterBrokerPort = JmsRaUtil.getJMSPropertyValue(newMBServer);\r\n    if (newMasterBrokerPort == null)\r\n        newMasterBrokerPort = getDefaultJmsHost(jmsservice).getPort();\r\n    String newMasterBrokerHost = nodes.getNode(newMBServer.getNodeRef()).getNodeHost();\r\n    String oldMasterBroker = oldMasterBrokerHost + \":\" + oldMasterBrokerPort;\r\n    String newMasterBroker = newMasterBrokerHost + \":\" + newMasterBrokerPort;\r\n    try {\r\n        CompositeData result = updateMasterBroker(oldMBServer.getName(), oldMasterBroker, newMasterBroker);\r\n        boolean success = ((Boolean) result.get(\"Success\")).booleanValue();\r\n        if (!success) {\r\n            int statusCode = ((Integer) result.get(\"StatusCode\")).intValue();\r\n            String detailMessage = (String) result.get(\"DetailMessage\");\r\n            String msg = \" \" + detailMessage;\r\n            if (BrokerStatusCode.BAD_REQUEST.getCode() == statusCode || BrokerStatusCode.NOT_ALLOWED.getCode() == statusCode || BrokerStatusCode.UNAVAILABLE.getCode() == statusCode || BrokerStatusCode.PRECONDITION_FAILED.getCode() == statusCode) {\r\n                msg = localStrings.getLocalString(\"change.master.broker.errorMsg\", \"{0}. But it didn't affect current master broker configuration.\", msg);\r\n            } else {\r\n                msg = msg + \". \" + localStrings.getLocalString(\"change.master.broker.otherErrorMsg\", \"The cluster should be shutdown and configured with the new master broker then restarts.\");\r\n            }\r\n            report.setMessage(localStrings.getLocalString(\"change.master.broker.CannotChangeMB\", \"Unable to change master broker.{0}\", msg));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"change.master.broker.CannotChangeMB\", \"Unable to change master broker because {0}\", e.getMessage()));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<JmsService>() {\r\n            public Object run(JmsService param) throws PropertyVetoException, TransactionFailure {\r\n                param.setMasterBroker(newMB);\r\n                return param;\r\n            }\r\n        }, jmsservice);\r\n    } catch (Exception tfe) {\r\n        report.setMessage(localStrings.getLocalString(\"change.master.broker.fail\", \"Unable to update the domain.xml with the new master broker\") + \" \" + tfe.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n    }\r\n    report.setMessage(localStrings.getLocalString(\"change.master.broker.success\", \"Master broker change has executed successfully for Cluster {0}.\", cluster.getName()));\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.ChangeMasterBrokerCommand.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    param.setMasterBroker(newMB);\r\n    return param;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.servlet.LBConfigContentSource.cleanUp",
	"Comment": "this method may be used to clean up any temporary resources.it \twill be invoked after the inputstream has been \tcompletely read.",
	"Method": "void cleanUp(DownloadServlet.Context ctx){\r\n    // NOI18N\r\n    InputStream tmpFile = (InputStream) ctx.getAttribute(\"tmpFile\");\r\n    if (tmpFile != null) {\r\n        try {\r\n            tmpFile.close();\r\n        } catch (Exception ex) {\r\n        }\r\n    }\r\n    ctx.removeAttribute(\"tmpFile\");\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.SaxParserHandler.setStopOnError",
	"Comment": "sets if the parser should stop parsing and generate an saxparseexceptionwhen the xml parsed contains errors in regards to validation",
	"Method": "void setStopOnError(boolean stop){\r\n    stopOnXMLErrors = stop;\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.ctl.SortResponseControl.getException",
	"Comment": "retrieves the namingexception appropriate for the result code.",
	"Method": "NamingException getException(){\r\n    return LdapCtx.mapErrorCode(resultCode, null);\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.connector.AppClientSniffer.getDeploymentConfigurationPaths",
	"Comment": "returns the descriptor paths that might exist in an appclient app.",
	"Method": "List<String> getDeploymentConfigurationPaths(){\r\n    return deploymentConfigurationPaths;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.WebServiceRuntimeNode.writeWebServiceRuntimeInfo",
	"Comment": "writes all the runtime information for the web services for a givenbundle descriptor",
	"Method": "void writeWebServiceRuntimeInfo(Node parent,BundleDescriptor bundle){\r\n    WebServicesDescriptor webServices = bundle.getWebServices();\r\n    if (webServices != null) {\r\n        for (Iterator iter = webServices.getWebServices().iterator(); iter.hasNext(); ) {\r\n            WebService next = (WebService) iter.next();\r\n            if (next.hasClientPublishUrl()) {\r\n                writeDescriptor(parent, WebServicesTagNames.WEB_SERVICE, next);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.RelationshipElement.getLowerBound",
	"Comment": "get the lower cardinality bound for this relationship element.",
	"Method": "int getLowerBound(int getLowerBound){\r\n    return getRelationshipImpl().getLowerBound();\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectorConnPoolStatsProvider.connectionRequestDequeuedEvent",
	"Comment": "when an object is removed from the wait queue, decrement the waitqueuelength.",
	"Method": "void connectionRequestDequeuedEvent(String poolName,String appName,String moduleName){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (logger.isLoggable(Level.FINEST)) {\r\n            logger.finest(\"Wait Queue length modified event received - \" + \"poolName = \" + poolName);\r\n        }\r\n        waitQueueLength.decrement();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.meta.JDOMetaDataPropertyImpl.isDefaultFetchGroupField",
	"Comment": "tests whether a field of a class is known to be part of thedefault fetch group.",
	"Method": "boolean isDefaultFetchGroupField(String classPath,String fieldName){\r\n    JDOField field = getJDOField(classPath, fieldName);\r\n    return (field != null ? field.isInDefaultFetchGroup() : false);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingFieldElementImpl.removeColumn",
	"Comment": "removes a column from the list of columns mapped by this mapping field.\tthis method overrides the one in mappingfieldelement to\tremove the argument from the associated columns if necessary.",
	"Method": "void removeColumn(String columnName){\r\n    if (columnName != null) {\r\n        try {\r\n            fireVetoableChange(PROP_COLUMNS, null, null);\r\n            if (!getColumns().remove(columnName)) {\r\n                throw new ModelException(I18NHelper.getMessage(getMessages(), \"mapping.element.element_not_removed\", columnName));\r\n            }\r\n            firePropertyChange(PROP_COLUMNS, null, null);\r\n            _columnObjects = null;\r\n        } catch (PropertyVetoException e) {\r\n            throw new ModelVetoException(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.findOrCreateStateManager",
	"Comment": "called internally by retrievedesc to lookup an instancein the cache, or prepare new instance to be populated with values from the datastore.",
	"Method": "StateManager findOrCreateStateManager(Object oid,Class pcClass){\r\n    return lookupObjectById(oid, pcClass);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.util.ClassPathElement.create",
	"Comment": "create an appropriate type of class path element based on thepath element name.",
	"Method": "ClassPathElement create(String elementSpec){\r\n    File element = new File(elementSpec);\r\n    if (!element.isDirectory() && looksLikeZipName(elementSpec))\r\n        return new ZipFileClassPathElement(element);\r\n    else\r\n        return new DirectoryClassPathElement(element);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.hasRuntimeInformation",
	"Comment": "return true if i have information to do with deployment on aparticular operational environment.",
	"Method": "boolean hasRuntimeInformation(){\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.GFAppClientRuntimeNode.registerBundle",
	"Comment": "register this node as a root node capable of loading entire dd files",
	"Method": "String registerBundle(Map publicIDToDTD){\r\n    publicIDToDTD.put(DTDRegistry.GF_APPCLIENT_602_DTD_PUBLIC_ID, DTDRegistry.GF_APPCLIENT_602_DTD_SYSTEM_ID);\r\n    return RuntimeTagNames.GF_APPCLIENT_RUNTIME_TAG;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.flushConnectionPool",
	"Comment": "flush connection pool by reinitializing the connectionsestablished in the pool.",
	"Method": "boolean flushConnectionPool(String poolName,boolean flushConnectionPool,PoolInfo poolInfo){\r\n    return ccPoolAdmService.flushConnectionPool(poolInfo);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnUtils.fStore",
	"Comment": "return the best instruction for storing a float to a localvariable slot",
	"Method": "Insn fStore(int i,ConstantPool pool){\r\n    if (i == 0)\r\n        return Insn.create(opc_fstore_0);\r\n    else if (i == 1)\r\n        return Insn.create(opc_fstore_1);\r\n    else if (i == 2)\r\n        return Insn.create(opc_fstore_2);\r\n    else if (i == 3)\r\n        return Insn.create(opc_fstore_3);\r\n    return Insn.create(opc_fstore, i);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.oracle.OracleSpecialDBOperation.loadClass",
	"Comment": "loads classname using loader inside a previleged block.returns null if class is not in classpath.",
	"Method": "Class loadClass(String className,ClassLoader loader){\r\n    final ClassLoader finalLoader = loader;\r\n    final String finalClassName = className;\r\n    return (Class) AccessController.doPrivileged(new PrivilegedAction() {\r\n        public Object run() {\r\n            try {\r\n                if (finalLoader != null) {\r\n                    return Class.forName(finalClassName, true, finalLoader);\r\n                } else {\r\n                    return Class.forName(finalClassName);\r\n                }\r\n            } catch (Exception e) {\r\n                return null;\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.oracle.OracleSpecialDBOperation.loadClass",
	"Comment": "loads classname using loader inside a previleged block.returns null if class is not in classpath.",
	"Method": "Class loadClass(String className,ClassLoader loader){\r\n    try {\r\n        if (finalLoader != null) {\r\n            return Class.forName(finalClassName, true, finalLoader);\r\n        } else {\r\n            return Class.forName(finalClassName);\r\n        }\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployapi.ProgressObjectImpl.isCancelSupported",
	"Comment": "tests whether the vendor supports a cancelopertation for deployment activities.",
	"Method": "boolean isCancelSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlTimestamp.setDate",
	"Comment": "sets the day of the month of this sqltimestamp object to thespecified value.",
	"Method": "void setDate(int date){\r\n    this.makeDirty();\r\n    super.setDate(date);\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.ApplicationHandlers.getSingleTargetAppsInfo",
	"Comment": "this handler is called for populating the application table in the cluster or instance application tab.",
	"Method": "void getSingleTargetAppsInfo(HandlerContext handlerCtx){\r\n    String appRefEndpoint = (String) handlerCtx.getInputValue(\"appRefEndpoint\");\r\n    String target = (String) handlerCtx.getInputValue(\"target\");\r\n    Map<String, String> appPropsMap = (Map) handlerCtx.getInputValue(\"appPropsMap\");\r\n    String filterValue = (String) handlerCtx.getInputValue(\"filterValue\");\r\n    Set filters = new TreeSet();\r\n    filters.add(\"\");\r\n    if (GuiUtil.isEmpty(filterValue)) {\r\n        filterValue = null;\r\n    }\r\n    List result = new ArrayList();\r\n    String prefix = (String) GuiUtil.getSessionValue(\"REST_URL\");\r\n    if (appPropsMap != null) {\r\n        for (Map.Entry<String, String> e : appPropsMap.entrySet()) {\r\n            try {\r\n                String engines = e.getValue();\r\n                HashMap oneRow = new HashMap();\r\n                oneRow.put(\"name\", e.getKey());\r\n                String encodedName = URLEncoder.encode(e.getKey(), \"UTF-8\");\r\n                oneRow.put(\"targetName\", target);\r\n                oneRow.put(\"selected\", false);\r\n                String endpoint = prefix + appRefEndpoint + encodedName;\r\n                oneRow.put(\"endpoint\", endpoint);\r\n                Map appRefAttrsMap = RestUtil.getAttributesMap(endpoint);\r\n                String image = (appRefAttrsMap.get(\"enabled\").equals(\"true\")) ? \"/resource/images/enabled.png\" : \"/resource/images/disabled.png\";\r\n                oneRow.put(\"enabled\", image);\r\n                image = (appRefAttrsMap.get(\"lbEnabled\").equals(\"true\")) ? \"/resource/images/enabled.png\" : \"/resource/images/disabled.png\";\r\n                oneRow.put(\"lbEnabled\", image);\r\n                oneRow.put(\"sniffers\", engines);\r\n                List sniffersList = GuiUtil.parseStringList(engines, \",\");\r\n                oneRow.put(\"sniffersList\", sniffersList);\r\n                for (int ix = 0; ix < sniffersList.size(); ix++) filters.add(sniffersList.get(ix));\r\n                if (filterValue != null) {\r\n                    if (!sniffersList.contains(filterValue))\r\n                        continue;\r\n                }\r\n                result.add(oneRow);\r\n            } catch (Exception ex) {\r\n            }\r\n        }\r\n    }\r\n    handlerCtx.setOutputValue(\"result\", result);\r\n    handlerCtx.setOutputValue(\"filters\", new ArrayList(filters));\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.MessageDestinationRefNode.writeMessageDestinationReferences",
	"Comment": "writes all the runtime information for jms destination references",
	"Method": "void writeMessageDestinationReferences(Node parent,MessageDestinationReferenceContainer descriptor){\r\n    Iterator msgDestRefs = descriptor.getMessageDestinationReferenceDescriptors().iterator();\r\n    if (msgDestRefs.hasNext()) {\r\n        MessageDestinationRefNode messageDestinationRefNode = new MessageDestinationRefNode();\r\n        while (msgDestRefs.hasNext()) {\r\n            messageDestinationRefNode.writeDescriptor(parent, TagNames.MESSAGE_DESTINATION_REFERENCE, (MessageDestinationReferenceDescriptor) msgDestRefs.next());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createFieldMappingComponent",
	"Comment": "create a validation component which can check whether the field is\tunmapped.",
	"Method": "ValidationComponent createFieldMappingComponent(PersistenceFieldElement field){\r\n    return new ValidationComponent() {\r\n        public void validate() throws ModelValidationException {\r\n            String fieldName = field.getName();\r\n            MappingClassElement mappingClass = getMappingClass(getClassName());\r\n            if ((mappingClass != null) && (mappingClass.getTables().size() > 0)) {\r\n                MappingFieldElement mappingField = mappingClass.getField(fieldName);\r\n                if ((mappingField == null) || (mappingField.getColumns().size() == 0)) {\r\n                    throw constructFieldException(ModelValidationException.WARNING, fieldName, \"util.validation.field_not_mapped\");\r\n                }\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createFieldMappingComponent",
	"Comment": "create a validation component which can check whether the field is\tunmapped.",
	"Method": "ValidationComponent createFieldMappingComponent(PersistenceFieldElement field){\r\n    String fieldName = field.getName();\r\n    MappingClassElement mappingClass = getMappingClass(getClassName());\r\n    if ((mappingClass != null) && (mappingClass.getTables().size() > 0)) {\r\n        MappingFieldElement mappingField = mappingClass.getField(fieldName);\r\n        if ((mappingField == null) || (mappingField.getColumns().size() == 0)) {\r\n            throw constructFieldException(ModelValidationException.WARNING, fieldName, \"util.validation.field_not_mapped\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.AbstractMethodHelper.getQueryDescriptor",
	"Comment": "gets the query descriptor associated with the specified method if it \texists.",
	"Method": "QueryDescriptor getQueryDescriptor(Method method){\r\n    PersistenceDescriptor persistenceDescriptor = getDescriptor().getPersistenceDescriptor();\r\n    return persistenceDescriptor.getQueryFor(method);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.PersistenceDescriptor.getCMPFields",
	"Comment": "return the set of fields deemed persistent.the elements of this set are fielddescriptor objects.this set should be modified by calling addcmpfield, removecmpfield",
	"Method": "Set<FieldDescriptor> getCMPFields(){\r\n    return this.cmpFields;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.TransactionImpl.setQueryTimeout",
	"Comment": "sets the number of seconds to wait for a query statementto execute in the datastore associated with thistransaction instance",
	"Method": "void setQueryTimeout(int timeout){\r\n    queryTimeout = timeout;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getConstructor",
	"Comment": "returns the constructor element for the specified argument types \tin the class with the specified name. types are specified as type \tnames for primitive type such as int, float or as fully qualified \tclass names.",
	"Method": "Object getConstructor(String className,String[] argTypeNames){\r\n    final Class classElement = (Class) getClass(className);\r\n    if (classElement != null) {\r\n        final Class[] argTypes = getTypesForNames(argTypeNames);\r\n        return AccessController.doPrivileged(new PrivilegedAction() {\r\n            public Object run() {\r\n                try {\r\n                    return ((Class) classElement).getDeclaredConstructor(argTypes);\r\n                } catch (NoSuchMethodException ex) {\r\n                    return null;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getConstructor",
	"Comment": "returns the constructor element for the specified argument types \tin the class with the specified name. types are specified as type \tnames for primitive type such as int, float or as fully qualified \tclass names.",
	"Method": "Object getConstructor(String className,String[] argTypeNames){\r\n    try {\r\n        return ((Class) classElement).getDeclaredConstructor(argTypes);\r\n    } catch (NoSuchMethodException ex) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.MQAddressList.defaultSetup",
	"Comment": "default setup concatanates all jmshosts in a jmsservice to create the address list",
	"Method": "void defaultSetup(){\r\n    logFine(\"performing defaultsetup\");\r\n    JmsService jmsService = Globals.get(JmsService.class);\r\n    List hosts = jmsService.getJmsHost();\r\n    for (int i = 0; i < hosts.size(); i++) {\r\n        MQUrl url = createUrl((JmsHost) hosts.get(i));\r\n        urlList.add(url);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ConnectionHolder.releaseSavepoint",
	"Comment": "removes the given savepoint object from the current transaction.",
	"Method": "void releaseSavepoint(Savepoint savepoint){\r\n    checkValidity();\r\n    con.releaseSavepoint(savepoint);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxColumnsInTable",
	"Comment": "retrieves the maximum number of columns this database allows in a table.",
	"Method": "int getMaxColumnsInTable(){\r\n    return databaseMetaData.getMaxColumnsInTable();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.web.integration.WebSecurityManager.checkPermission",
	"Comment": "invoke the policy to determine if the permissionobject has security permission.",
	"Method": "boolean checkPermission(Permission perm,Set principalSet){\r\n    boolean ret = false;\r\n    if (uncheckedPermissionCache != null) {\r\n        ret = uncheckedPermissionCache.checkPermission(perm);\r\n    }\r\n    if (ret == false) {\r\n        ret = checkPermissionWithoutCache(perm, principalSet);\r\n    } else {\r\n        try {\r\n            setPolicyContext(CONTEXT_ID);\r\n        } catch (Throwable t) {\r\n            if (logger.isLoggable(Level.FINE)) {\r\n                logger.log(Level.FINE, \"[Web-Security] Web Permission Access Denied.\", t);\r\n            }\r\n            ret = false;\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.UpgradeService.addProperty",
	"Comment": "adds a property with the specified name and value to a writable configobject.",
	"Method": "Property addProperty(String propName,String propValue,T owner_w){\r\n    final Property p = owner_w.createChild(Property.class);\r\n    p.setName(propName);\r\n    p.setValue(propValue);\r\n    owner_w.getProperty().add(p);\r\n    return p;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingClassElementImpl.hasOldVersionNumber",
	"Comment": "returns true if the version number of this mappingclasselement object\tis older than the current version number of the archiving scheme.",
	"Method": "boolean hasOldVersionNumber(){\r\n    return (getVersionNumber() < CURRENT_VERSION_NO);\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolStatsProviderBootstrap.unregisterPool",
	"Comment": "unregister connector connection pool from the statsprovidermanager.remove the pool lifecycle listeners associated with this pool.",
	"Method": "void unregisterPool(PoolInfo poolInfo){\r\n    if (ccStatsProviders != null) {\r\n        Iterator i = ccStatsProviders.iterator();\r\n        while (i.hasNext()) {\r\n            ConnectorConnPoolStatsProvider ccPoolStatsProvider = (ConnectorConnPoolStatsProvider) i.next();\r\n            if (poolInfo.equals(ccPoolStatsProvider.getPoolInfo())) {\r\n                PoolLifeCycleListenerRegistry poolRegistry = ccPoolStatsProvider.getPoolRegistry();\r\n                poolRegistry.unRegisterPoolLifeCycleListener(poolInfo);\r\n                StatsProviderManager.unregister(ccPoolStatsProvider);\r\n                i.remove();\r\n            }\r\n        }\r\n    }\r\n    postUnregisterPool(poolInfo);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.jqlc.ParameterTable.initValueHandling",
	"Comment": "initializes the parameter values. this methods sets the values for all declared parameters to unbound.",
	"Method": "void initValueHandling(){\r\n    values = new ArrayList(names.size());\r\n    final int size = names.size();\r\n    for (int i = 0; i < size; i++) {\r\n        values.add(unbound);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.loadForRead",
	"Comment": "triggers the state transition for read and registers theinstance in the transaction cache.",
	"Method": "void loadForRead(){\r\n    boolean debug = logger.isLoggable(Logger.FINER);\r\n    if (debug) {\r\n        logger.finer(\"sqlstore.sqlstatemanager.loadforread\");\r\n    }\r\n    persistenceManager.acquireShareLock();\r\n    try {\r\n        getLock();\r\n        byte oldFlags = persistenceManager.getFlags(persistentObject);\r\n        if (oldFlags != LOAD_REQUIRED) {\r\n            return;\r\n        }\r\n        try {\r\n            boolean xactActive = persistenceManager.isActiveTransaction();\r\n            boolean optimistic = persistenceManager.isOptimisticTransaction();\r\n            boolean nontransactionalRead = persistenceManager.isNontransactionalRead();\r\n            if (state.needsReload(optimistic, nontransactionalRead, xactActive)) {\r\n                reload(null);\r\n            }\r\n            LifeCycleState oldstate = state;\r\n            state = state.transitionReadField(optimistic, nontransactionalRead, xactActive);\r\n            persistenceManager.setFlags(persistentObject, READ_OK);\r\n            registerInstance(false, null, oldstate);\r\n        } catch (JDOException e) {\r\n            persistenceManager.setFlags(persistentObject, oldFlags);\r\n            throw e;\r\n        }\r\n    } finally {\r\n        persistenceManager.releaseShareLock();\r\n        releaseLock();\r\n        if (debug) {\r\n            logger.finer(\"sqlstore.sqlstatemanager.loadforread.exit\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ConnectionHolder.prepareCall",
	"Comment": "creates acallablestatementobject for calling databasestored procedures.",
	"Method": "CallableStatement prepareCall(String sql,CallableStatement prepareCall,String sql,int resultSetType,int resultSetConcurrency,CallableStatement prepareCall,String sql,int resultSetType,int resultSetConcurrency,int resultSetHoldabilty){\r\n    checkValidity();\r\n    return con.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldabilty);\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.util.GuiUtil.notNull",
	"Comment": "this method ensure that there will not be a null string for the passed in object.",
	"Method": "String notNull(String test){\r\n    return (test == null) ? \"\" : test;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.LifecycleCallbackDescriptor.getLifecycleCallbackMethodObject",
	"Comment": "given a classloader, find the method object corresponding to thislifecycle callback.",
	"Method": "Method getLifecycleCallbackMethodObject(ClassLoader loader){\r\n    Method method = null;\r\n    if (getLifecycleCallbackClass() == null) {\r\n        throw new IllegalArgumentException(\"no lifecycle class defined\");\r\n    }\r\n    Class clazz = loader.loadClass(getLifecycleCallbackClass());\r\n    while (method == null && !clazz.equals(Object.class)) {\r\n        for (Method next : clazz.getDeclaredMethods()) {\r\n            if (next.getName().equals(lifecycleCallbackMethod)) {\r\n                method = next;\r\n                break;\r\n            }\r\n        }\r\n        if (method == null) {\r\n            clazz = clazz.getSuperclass();\r\n        }\r\n    }\r\n    if (method == null) {\r\n        throw new NoSuchMethodException(\"no method matching \" + lifecycleCallbackMethod);\r\n    }\r\n    return method;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnection.XAStartOccurred",
	"Comment": "this method is called by the xaresource object when its start methodhas been invoked.",
	"Method": "void XAStartOccurred(){\r\n    try {\r\n        actualConnection.setAutoCommit(false);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        connectionErrorOccurred(e, null);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsFullOuterJoins",
	"Comment": "retrieves whether this database supports full nested outer joins.",
	"Method": "boolean supportsFullOuterJoins(){\r\n    return databaseMetaData.supportsFullOuterJoins();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.getTimestamp",
	"Comment": "retrieves the value of a jdbc timestamp parameter as ajava.sql.timestamp object, usingthe given calendar object to constructthe timestamp object.with a calendar object, the drivercan calculate the timestamp taking into account a custom timezone and locale.if no calendar object is specified, the driver uses thedefault timezone and locale.",
	"Method": "Timestamp getTimestamp(int parameterIndex,Timestamp getTimestamp,int parameterIndex,Calendar cal,Timestamp getTimestamp,String parameterName,Timestamp getTimestamp,String parameterName,Calendar cal){\r\n    return callableStatement.getTimestamp(parameterName, cal);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.io.DeploymentDescriptorFile.read",
	"Comment": "read and parse a j2ee deployment descriptor input file and return the constructed dol descriptors for the j2ee module",
	"Method": "T read(InputStream is,T read,T descriptor,File in,T read,T descriptor,ReadableArchive in,T read,T descriptor,InputStream is){\r\n    errorReportingString = FileUtils.revertFriendlyFilenameExtension(errorReportingString);\r\n    String error = (errorReportingString == null) ? errorReportingString : new File(errorReportingString).getName();\r\n    String errorReporting = localStrings.getLocalString(\"enterprise.deployment.io.errorcontext\", \"archive {0} and deployment descriptor file {1}\", error, getDeploymentDescriptorPath());\r\n    SAXParser sp = getSAXParser(getXMLValidation());\r\n    SaxParserHandler dh = SaxParserHandlerFactory.newInstance();\r\n    if (validationLevel.equals(FULL_VALIDATION)) {\r\n        dh.setStopOnError(true);\r\n    }\r\n    if (descriptor != null) {\r\n        dh.setTopNode(getRootXMLNode(descriptor));\r\n    }\r\n    dh.setErrorReportingString(errorReporting);\r\n    InputSource input = new InputSource(is);\r\n    try {\r\n        sp.parse(input, dh);\r\n    } catch (SAXParseException e) {\r\n        DOLUtils.getDefaultLogger().log(Level.SEVERE, \"enterprise.deployment.backend.saxParserError\", new Object[] { e.getMessage() });\r\n        errorReporting += \"  \" + e.getLocalizedMessage();\r\n        SAXParseException spe = new SAXParseException(errorReporting, e.getSystemId(), e.getPublicId(), e.getLineNumber(), e.getColumnNumber(), e);\r\n        throw spe;\r\n    } catch (SAXException e) {\r\n        DOLUtils.getDefaultLogger().log(Level.SEVERE, \"enterprise.deployment.backend.saxParserError\", new Object[] { e.getMessage() });\r\n        DOLUtils.getDefaultLogger().log(Level.SEVERE, \"Error occurred\", e);\r\n        throw e;\r\n    } catch (IOException e) {\r\n        DOLUtils.getDefaultLogger().log(Level.SEVERE, \"enterprise.deployment.backend.saxParserError\", e.getMessage() == null ? \"\" : new Object[] { e.getMessage() });\r\n        for (StackTraceElement stElement : e.getStackTrace()) {\r\n            if (stElement.getClassName().equals(\"java.net.Socket\") && stElement.getMethodName().equals(\"connect\")) {\r\n                String msg = localStrings.getLocalString(\"enterprise.deployment.can_not_locate_dtd\", \"Unable to locate the DTD to validate your deployment descriptor file [{1}] in archive [{0}]. Please make sure the DOCTYPE is correct (no typo in public ID or system ID) and you have proper access to the Internet.\", error, getDeploymentDescriptorPath());\r\n                IOException ioe = new IOException(msg);\r\n                ioe.initCause(e);\r\n                throw ioe;\r\n            }\r\n        }\r\n        IOException ioe = new IOException(localStrings.getLocalString(\"enterprise.deployment.backend.error_parsing_descr\", \"Error parsing descriptor: {0}\", errorReporting));\r\n        ioe.initCause(e);\r\n        throw ioe;\r\n    }\r\n    if (dh.getTopNode() != null) {\r\n        return ((RootXMLNode<T>) dh.getTopNode()).getDescriptor();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.connection.ConnectionManager.setUserName",
	"Comment": "sets the default database user name for the currentconnection manager.",
	"Method": "void setUserName(String userName){\r\n    this.userName = userName;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectorConnPoolStatsProvider.connectionDestroyedEvent",
	"Comment": "when connection destroyed event is got increment numconndestroyed.",
	"Method": "void connectionDestroyedEvent(String poolName,String appName,String moduleName){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (logger.isLoggable(Level.FINEST)) {\r\n            logger.finest(\"Connection destroyed event received - \" + \"poolName = \" + poolName);\r\n        }\r\n        numConnDestroyed.increment();\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.XAResourceImpl.start",
	"Comment": "start work on behalf of a transaction branch specified in xid.",
	"Method": "void start(Xid xid,int flags){\r\n    mc.transactionStarted();\r\n    xar.start(xid, flags);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.setRequireTrackedSCO",
	"Comment": "sets the requiretrackedsco flag for this persistencemanager.if set to false, this persistencemanager will not create trackedsco instances for new persistent instances at commit with retainvaluesset to true and while retrieving data from a datastore.",
	"Method": "void setRequireTrackedSCO(boolean flag){\r\n    _requireTrackedSCO = flag;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.hasClass",
	"Comment": "determines if a class with the specified classname exists.",
	"Method": "boolean hasClass(String className,boolean hasClass,String className,ClassLoader classLoader){\r\n    return (getClass(className, classLoader) != null);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.retrieve",
	"Comment": "the retrieve method gets a retrieve descriptor to retrieve thedesired field and adds constraints necessary to limit theretrieval set to the source object runs the retrievedescriptor against the store, the source object is connected to,and then merges the results back into the source object.",
	"Method": "void retrieve(FieldDesc additionalField){\r\n    boolean debug = logger.isLoggable();\r\n    if (debug) {\r\n        String fieldName = (additionalField != null) ? additionalField.getName() : null;\r\n        logger.fine(\"sqlstore.sqlstatemanager.retrieve\", fieldName);\r\n    }\r\n    LocalFieldDesc[] keyFields = persistenceConfig.getKeyFieldDescs();\r\n    Object[] values = new Object[keyFields.length];\r\n    copyValues(values, keyFields, 0);\r\n    RetrieveDesc rd = persistenceConfig.getRetrieveDescForPKQuery(additionalField, store);\r\n    Collection result = (Collection) store.retrieve(persistenceManager, rd, new QueryValueFetcher(values));\r\n    if (result.size() > 1) {\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"core.statemanager.toomanyrows\", persistenceConfig.getPersistenceCapableClass().getName()));\r\n    } else if (result.size() < 1 || result.iterator().next() != persistentObject) {\r\n        throw new JDOObjectNotFoundException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"core.statemanager.objectnotfound\"), new Object[] { persistentObject });\r\n    }\r\n    if (debug) {\r\n        logger.fine(\"sqlstore.sqlstatemanager.retrieve.exit\");\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.resources.module.ResourcesDeployer.retainResourceConfig",
	"Comment": "retain old resource configuration for the new archive being deployed.",
	"Method": "void retainResourceConfig(DeploymentContext dc,Map<String, Resources> allResources){\r\n    String appName = getAppNameFromDeployCmdParams(dc);\r\n    Application application = dc.getTransientAppMetaData(ServerTags.APPLICATION, Application.class);\r\n    Resources appScopedResources = allResources.get(appName);\r\n    if (appScopedResources != null) {\r\n        application.setResources(appScopedResources);\r\n    }\r\n    if (DeploymentUtils.isArchiveOfType(dc.getSource(), DOLUtils.earType(), locator)) {\r\n        List<Module> modules = application.getModule();\r\n        if (modules != null) {\r\n            for (Module module : modules) {\r\n                Resources moduleScopedResources = allResources.get(module.getName());\r\n                if (moduleScopedResources != null) {\r\n                    module.setResources(moduleScopedResources);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolAppEmitterImpl.connectionAcquired",
	"Comment": "fires probe event that a connection has been acquired by the applicationfor the given connection pool.",
	"Method": "void connectionAcquired(){\r\n    poolAppProbeProvider.connectionAcquiredEvent(poolName, appName);\r\n}"
}, {
	"Path": "com.sun.ejb.codegen.StaticRmiStubGenerator.addGeneratedFiles",
	"Comment": "assembles the name of the client jar files into the given vector.",
	"Method": "void addGeneratedFiles(Set<String> stubClasses,List<String> allClientFiles,File stubsDir){\r\n    for (String stubClass : stubClasses) {\r\n        String stubFile = stubsDir.toString() + File.separator + getStubName(stubClass).replace('.', File.separatorChar) + \".class\";\r\n        allClientFiles.add(stubFile);\r\n    }\r\n    _logger.log(Level.INFO, \"[RMIC] Generated client files: \" + allClientFiles);\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.ConnectionPool.flushConnectionPool",
	"Comment": "reinitialize connections established in the connection pool and bring the pool to steady pool size.",
	"Method": "boolean flushConnectionPool(){\r\n    logFine(\"Flush Connection Pool entered\");\r\n    if (!poolInitialized) {\r\n        _logger.log(Level.WARNING, \"poolmgr.flush_noop_pool_not_initialized\", getPoolInfo());\r\n        String exString = localStrings.getString(\"poolmgr.flush_noop_pool_not_initialized\", poolInfo.toString());\r\n        throw new PoolingException(exString);\r\n    }\r\n    try {\r\n        cancelResizerTask();\r\n        ds.removeAll();\r\n        scheduleResizerTask();\r\n        increaseSteadyPoolSize(steadyPoolSize);\r\n    } catch (PoolingException ex) {\r\n        _logger.log(Level.WARNING, \"pool.flush_pool_failure\", new Object[] { getPoolInfo(), ex.getMessage() });\r\n        throw ex;\r\n    }\r\n    logFine(\"Flush Connection Pool done\");\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.LocalFieldDesc.setupDesc",
	"Comment": "calls the superclass method and disables concurrency checkingfor certain field types.",
	"Method": "void setupDesc(Field f){\r\n    super.setupDesc(f);\r\n    if (isMappedToLob()) {\r\n        sqlProperties = sqlProperties & ~PROP_IN_CONCURRENCY_CHECK;\r\n    }\r\n    switch(getEnumType()) {\r\n        case FieldTypeEnumeration.FLOAT_PRIMITIVE:\r\n        case FieldTypeEnumeration.FLOAT:\r\n        case FieldTypeEnumeration.DOUBLE_PRIMITIVE:\r\n        case FieldTypeEnumeration.DOUBLE:\r\n        case FieldTypeEnumeration.BIGDECIMAL:\r\n            sqlProperties &= ~PROP_IN_CONCURRENCY_CHECK;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.model.DeploymentDescriptorModel.deleteFile",
	"Comment": "deletes the file with the given file name which is parallel\tto the supplied class.this method overrides the one in runtimemodel \tand throws unsupportedoperationexception.",
	"Method": "void deleteFile(String className,String fileName){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.getEjbByName",
	"Comment": "obtain the ejb in this application of the given display name. if the ejb is notpresent, throw an illegalargumentexception.",
	"Method": "EjbDescriptor getEjbByName(String ejbName){\r\n    for (EjbBundleDescriptor ejbd : getBundleDescriptors(EjbBundleDescriptor.class)) {\r\n        if (ejbd.hasEjbByName(ejbName)) {\r\n            return ejbd.getEjbByName(ejbName);\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionapphasnobeannamed\", \"This application has no beans of name {0}\", ejbName));\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getMappingClass",
	"Comment": "returns the mappingclasselement created for the specified class name.\tthis method looks up the class in the internal cache. if not present \tit loads the corresponding xml file containing the mapping information.",
	"Method": "MappingClassElement getMappingClass(String className,ClassLoader classLoader){\r\n    MappingClassElement mappingClass = null;\r\n    classLoader = findClassLoader(className, classLoader);\r\n    mappingClass = super.getMappingClass(className, classLoader);\r\n    if ((mappingClass != null) && (classLoader != null)) {\r\n        String databaseRoot = mappingClass.getDatabaseRoot();\r\n        if (!StringHelper.isEmpty(databaseRoot) && (SchemaElement.forName(databaseRoot, classLoader) == null)) {\r\n            throw new RuntimeException(I18NHelper.getMessage(getMessages(), \"dbschema.not_found\", databaseRoot, className));\r\n        }\r\n    }\r\n    return mappingClass;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.SunContainerHelper.removeByPK",
	"Comment": "remove a bean for a given primary key and container helper.this is suncontainerhelper specific code.",
	"Method": "void removeByPK(Object pk,Object container){\r\n    try {\r\n        ((Container) container).removeBeanUnchecked(pk);\r\n    } catch (Exception ex) {\r\n        processContainerException(ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ResultSetWrapper40.getNCharacterStream",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object as ajava.io.reader object.it is intended for use whenaccessingnchar,nvarcharand longnvarchar columns.",
	"Method": "Reader getNCharacterStream(int columnIndex,Reader getNCharacterStream,String columnLabel){\r\n    return resultSet.getNCharacterStream(columnLabel);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.TransactionImpl.setUpdateTimeout",
	"Comment": "sets the number of seconds to wait for an update statementto execute in the datastore associated with thistransaction instance",
	"Method": "void setUpdateTimeout(int timeout){\r\n    updateTimeout = timeout;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ResourceReferenceDescriptor.getJDBCDataSource",
	"Comment": "lookup the datasource from the namespace based on the jndi name.",
	"Method": "DataSource getJDBCDataSource(){\r\n    if (dataSource == null) {\r\n        try {\r\n            javax.naming.Context ctx = new javax.naming.InitialContext();\r\n            dataSource = (DataSource) ctx.lookup(getJndiName());\r\n        } catch (Exception ex) {\r\n        }\r\n    }\r\n    return dataSource;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceFieldElementImpl.isWriteSensitive",
	"Comment": "determines whether this field element is write sensitive or not.\tthis value is only used if getpersistencetype returns\tderived",
	"Method": "boolean isWriteSensitive(){\r\n    return ((PersistenceFieldElement.DERIVED == getPersistenceType()) ? ((_derivedModifier & WRITE_SENSITIVE) != 0) : false);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.ClassFile.fields",
	"Comment": "return the list of the fields which the class containsthe contents are classfield objects",
	"Method": "Vector fields(){\r\n    return classFields;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.getObjectIdClass",
	"Comment": "in order for the application to construct instance of the objectid classit needs to know the class being used by the jdo implementation.",
	"Method": "Class getObjectIdClass(Class cls){\r\n    PersistenceConfig config = loadPersistenceConfig(cls);\r\n    return config.getOidClass();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.inbound.MessageEndpointInvocationHandler.invokeJavaObjectMethod",
	"Comment": "this is the same implementation incom.sun.ejb.container.invocationhandlerutilneed to abstract out at some point.",
	"Method": "Object invokeJavaObjectMethod(InvocationHandler handler,Method method,Object[] args){\r\n    Object returnValue = null;\r\n    switch(method.getName().charAt(0)) {\r\n        case 'e':\r\n            Object other = Proxy.isProxyClass(args[0].getClass()) ? Proxy.getInvocationHandler(args[0]) : args[0];\r\n            returnValue = Boolean.valueOf(handler.equals(other));\r\n            break;\r\n        case 'h':\r\n            returnValue = Integer.valueOf(handler.hashCode());\r\n            break;\r\n        case 't':\r\n            returnValue = handler.toString();\r\n            break;\r\n        default:\r\n            throw new RuntimeException(method.getName());\r\n    }\r\n    return returnValue;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.StatementWrapper40.setPoolable",
	"Comment": "requests that a statement be pooled or not pooled.the valuespecified is a hint to the statement pool implementation indicatingwhether the applicaiton wants the statement to be pooled.it is up tothe statement pool manager as to whether the hint is used.the poolable value of a statement is applicable to both internalstatement caches implemented by the driver and external statement cachesimplemented by application servers and other applications.by default, a statement is not poolable when created, anda preparedstatement and callablestatementare poolable when created.",
	"Method": "void setPoolable(boolean poolable){\r\n    jdbcStatement.setPoolable(poolable);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.module.ConnectorDeployer.unload",
	"Comment": "unload or stop a previously running application identified with thecontractprovider instance. the container will be stop upon return from thismethod.",
	"Method": "void unload(ConnectorApplication appContainer,DeploymentContext context){\r\n    String moduleName = appContainer.getModuleName();\r\n    try {\r\n        runtime.destroyActiveResourceAdapter(moduleName);\r\n    } catch (ConnectorRuntimeException e) {\r\n        Object[] params = new Object[] { moduleName, e };\r\n        _logger.log(Level.WARNING, \"unable.to.unload.ra\", params);\r\n    } finally {\r\n        if (!ConnectorsUtil.isEmbedded(context)) {\r\n            DelegatingClassLoader dcl = clh.getConnectorClassLoader(null);\r\n            for (DelegatingClassLoader.ClassFinder cf : dcl.getDelegates()) {\r\n                ConnectorClassFinder ccf = (ConnectorClassFinder) cf;\r\n                if (ccf.getResourceAdapterName().equals(moduleName)) {\r\n                    dcl.removeDelegate(ccf);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        unregisterBeanValidator(moduleName);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingFieldElementImpl.stripSchemaName",
	"Comment": "boston to pilsen conversion.\tthis method converts the absolute column names to relative names.",
	"Method": "void stripSchemaName(){\r\n    if (_columns != null) {\r\n        ListIterator i = _columns.listIterator();\r\n        while (i.hasNext()) i.set(NameUtil.getRelativeMemberName((String) i.next()));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOConcreteBeanGenerator.validate",
	"Comment": "validate this cmp bean. to be overridden in subclass if necessary.no generic validation is done at this time.",
	"Method": "Collection validate(AbstractMethodHelper methodHelper,String beanName){\r\n    return new ArrayList();\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.annotation.handlers.EJBHandler.getEjbReferenceDescriptors",
	"Comment": "return ejbreferencedescriptors with given name if exists or a newone without name being set.",
	"Method": "EjbReferenceDescriptor[] getEjbReferenceDescriptors(String logicalName,ResourceContainerContext[] rcContexts){\r\n    EjbReferenceDescriptor[] ejbRefs = new EjbReferenceDescriptor[rcContexts.length];\r\n    for (int i = 0; i < rcContexts.length; i++) {\r\n        EjbReferenceDescriptor ejbRef = (EjbReferenceDescriptor) rcContexts[i].getEjbReference(logicalName);\r\n        if (ejbRef == null) {\r\n            ejbRef = new EjbReferenceDescriptor();\r\n            rcContexts[i].addEjbReferenceDescriptor(ejbRef);\r\n        }\r\n        ejbRefs[i] = ejbRef;\r\n    }\r\n    return ejbRefs;\r\n}"
}, {
	"Path": "org.glassfish.javaee.core.deployment.JavaEEDeployer.clean",
	"Comment": "clean any files and artifacts that were created during the executionof the prepare method.",
	"Method": "void clean(DeploymentContext context){\r\n    if (undeploymentVisitor != null) {\r\n        String appName = context.getCommandParameters(OpsParams.class).name();\r\n        Application app = getApplicationFromApplicationInfo(appName);\r\n        if (app != null) {\r\n            context.addModuleMetaData(app);\r\n            undeploymentVisitor.accept(app);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.plugin.ConsoleClassLoader.findModuleClassLoader",
	"Comment": "this method find the classloader associated with the \tnamed module.",
	"Method": "ClassLoader findModuleClassLoader(String moduleName){\r\n    ServletContext servletCtx = (ServletContext) (FacesContext.getCurrentInstance().getExternalContext()).getContext();\r\n    ServiceLocator habitat = (ServiceLocator) servletCtx.getAttribute(HABITAT_ATTRIBUTE);\r\n    return habitat.<ConsolePluginService>getService(ConsolePluginService.class).getModuleClassLoader(moduleName);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.EJBQLAST.clone",
	"Comment": "creates and returns a copy of this object.the returned ejbqlast shares the same state as this object, meaning the fields type, text, line, column, and typeinfo have the same values. but it is not bound to any tree structure, thus the child is null and the sibling is null.",
	"Method": "Object clone(){\r\n    EJBQLAST clone = (EJBQLAST) super.clone();\r\n    clone.setFirstChild(null);\r\n    clone.setNextSibling(null);\r\n    return clone;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.ConnectionPool.createSingleResourceAndAdjustPool",
	"Comment": "this method will be called from the getunenlistedresource method ifwe detect a failallconnection flag.here we simply create a new resource and replace a free resource inthe pool by this resource and then give it out.this replacement is required since the steadypoolsize might equalmaxpoolsize and in that case if we were not to remove a resourcefrom the pool, our resource would be above maxpoolsize",
	"Method": "ResourceHandle createSingleResourceAndAdjustPool(ResourceAllocator alloc,ResourceSpec spec){\r\n    ResourceHandle handle = ds.getResource();\r\n    if (handle != null) {\r\n        ds.removeResource(handle);\r\n    }\r\n    ResourceHandle result = getNewResource(alloc);\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionMetaDataImpl.getMaxConnections",
	"Comment": "returns maximum limit on number of active concurrent connectionsthat an eis instance can support across client processes.",
	"Method": "int getMaxConnections(){\r\n    try {\r\n        return dmd.getMaxConnections();\r\n    } catch (SQLException sqle) {\r\n        _logger.log(Level.SEVERE, \"jdbc.exc_eis_maxconn\");\r\n        throw new ResourceException(sqle.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerWrapper.getPersistenceManagerFactory",
	"Comment": "this method returns the persistencemanagerfactory used to createthis persistencemanager.it returns null if this instance wascreated via a constructor.",
	"Method": "PersistenceManagerFactory getPersistenceManagerFactory(){\r\n    if (isValid) {\r\n        return pm.getPersistenceManagerFactory();\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerwrapper.invalidpm\"));\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.node.InterceptorBindingNode.endElement",
	"Comment": "receives notification of the end of an xml element by the parser",
	"Method": "boolean endElement(XMLElement element){\r\n    if (EjbTagNames.INTERCEPTOR_ORDER.equals(element.getQName())) {\r\n        InterceptorBindingDescriptor desc = getDescriptor();\r\n        desc.setIsTotalOrdering(true);\r\n    } else if (EjbTagNames.METHOD_PARAMS.equals(element.getQName())) {\r\n        if (businessMethod.getParameterClassNames() == null) {\r\n            businessMethod.setEmptyParameterClassNames();\r\n        }\r\n    } else if (EjbTagNames.METHOD.equals(element.getQName())) {\r\n        InterceptorBindingDescriptor bindingDesc = getDescriptor();\r\n        businessMethod.setEjbClassSymbol(MethodDescriptor.EJB_BEAN);\r\n        bindingDesc.setBusinessMethod(businessMethod);\r\n        if (needsOverloadResolution) {\r\n            bindingDesc.setNeedsOverloadResolution(true);\r\n        }\r\n        businessMethod = null;\r\n        needsOverloadResolution = false;\r\n    }\r\n    return super.endElement(element);\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ResourceAdapter.endpointActivation",
	"Comment": "empty method implementation for endpointactivationwhich just throws notsupportedexception",
	"Method": "void endpointActivation(MessageEndpointFactory mef,ActivationSpec as){\r\n    throw new NotSupportedException(\"This method is not supported for this JDBC connector\");\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getMethods",
	"Comment": "return the ejb method objects, i.e. the methods on the home and remote interfaces.",
	"Method": "Vector getMethods(Vector getMethods,ClassLoader classLoader){\r\n    try {\r\n        BeanMethodCalculatorImpl bmc = new BeanMethodCalculatorImpl();\r\n        return bmc.getMethodsFor(this, classLoader);\r\n    } catch (Throwable t) {\r\n        _logger.log(Level.SEVERE, \"enterprise.deployment.backend.methodClassLoadFailure\", new Object[] { \"(EjbDescriptor.getMethods())\" });\r\n        throw new RuntimeException(t);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.IASEjbCMPEntityDescriptor.getFinders",
	"Comment": "returns a collection of finder methods declared by the home interface given by a class object.",
	"Method": "Collection getFinders(Collection getFinders,Class homeIntf){\r\n    Method[] methods = homeIntf.getMethods();\r\n    Collection finders = new HashSet();\r\n    for (int i = 0; i < methods.length; i++) {\r\n        if (methods[i].getName().startsWith(FIND)) {\r\n            finders.add(methods[i]);\r\n        }\r\n    }\r\n    return finders;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerWrapper.getExtent",
	"Comment": "the persistencemanager may manage a collection of instances in the datastore based on the class of the instances.this method returns acollection of instances in the data store that might be iterated orgiven to a query as the collection of candidate instances.",
	"Method": "Collection getExtent(Class persistenceCapableClass,boolean subclasses){\r\n    if (isValid) {\r\n        return pm.getExtent(persistenceCapableClass, subclasses);\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerwrapper.invalidpm\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.RelationshipElementImpl.getLowerBound",
	"Comment": "get the lower cardinality bound for this relationship element.the \tdefault is 0.",
	"Method": "int getLowerBound(){\r\n    return _lowerBound;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.setConcurrencyGroups",
	"Comment": "sets the collection of concurrency groups maintained by this class to \tthe contents of the supplied array.",
	"Method": "void setConcurrencyGroups(ConcurrencyGroupElement[] groups){\r\n    getClassImpl().changeConcurrencyGroups(groups, Impl.SET);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingClassElementImpl.getField",
	"Comment": "scans through this mapping class looking for a field whose\tname matches the name passed in.",
	"Method": "MappingFieldElement getField(String name){\r\n    Iterator fieldIterator = getFields().iterator();\r\n    while (fieldIterator.hasNext()) {\r\n        MappingFieldElement field = (MappingFieldElement) fieldIterator.next();\r\n        if (name.equals(field.getName()))\r\n            return field;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.util.cache.LruSessionCache.passivateEJB",
	"Comment": "the container has already acquired the lock on the statefulejbcontext",
	"Method": "boolean passivateEJB(StatefulEJBContext ctx,Serializable sessionKey){\r\n    try {\r\n        int hashCode = hash(sessionKey);\r\n        int index = getIndex(hashCode);\r\n        CacheItem prev = null, item = null;\r\n        synchronized (bucketLocks[index]) {\r\n            for (item = buckets[index]; item != null; item = item.getNext()) {\r\n                if (item.getValue() == ctx) {\r\n                    LruCacheItem lruSCItem = (LruCacheItem) item;\r\n                    if (!lruSCItem.isTrimmed()) {\r\n                        if (_logger.isLoggable(Level.FINE)) {\r\n                            _logger.log(Level.FINE, cacheName + \": session accessed after marked for passivation: \" + sessionKey);\r\n                        }\r\n                        return false;\r\n                    }\r\n                    break;\r\n                }\r\n                prev = item;\r\n            }\r\n            if (item == null) {\r\n                return true;\r\n            }\r\n        }\r\n        if (container.isPassivationCapable() && !saveStateToStore(sessionKey, ctx)) {\r\n            return false;\r\n        }\r\n        synchronized (bucketLocks[index]) {\r\n            prev = null;\r\n            for (item = buckets[index]; item != null; item = item.getNext()) {\r\n                if (item.getValue() == ctx) {\r\n                    LruCacheItem lruSCItem = (LruCacheItem) item;\r\n                    if (!lruSCItem.isTrimmed()) {\r\n                        return false;\r\n                    }\r\n                    if (prev == null) {\r\n                        buckets[index] = item.getNext();\r\n                    } else {\r\n                        prev.setNext(item.getNext());\r\n                    }\r\n                    item.setNext(null);\r\n                    break;\r\n                }\r\n                prev = item;\r\n            }\r\n        }\r\n        if (item != null) {\r\n            decrementEntryCount();\r\n            incrementRemovalCount();\r\n        }\r\n        return true;\r\n    } catch (java.io.NotSerializableException notSerEx) {\r\n        _logger.log(Level.FINE, \"\", notSerEx);\r\n        throw notSerEx;\r\n    } catch (Exception ex) {\r\n        _logger.log(Level.WARNING, PASSIVATE_EJB_EXCEPTION_CAUGHT, new Object[] { cacheName, ex });\r\n        _logger.log(Level.FINE, \"\", ex);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.LocalFieldDesc.isCharLobType",
	"Comment": "determines if sqltype passed to this method is to be considered a characterlob type.",
	"Method": "boolean isCharLobType(int sqlType){\r\n    return sqlType == Types.LONGVARCHAR || sqlType == Types.CLOB;\r\n}"
}, {
	"Path": "org.glassfish.persistence.jpa.schemageneration.EclipseLinkSchemaGenerationProcessor.addPropertyToOverride",
	"Comment": "utility method that is used to actually set the property into the persistence unit descriptor.",
	"Method": "void addPropertyToOverride(PersistenceUnitDescriptor descriptor,Map<String, Object> overrides,String propertyName,String propertyValue){\r\n    String oldPropertyValue = descriptor.getProperties().getProperty(propertyName);\r\n    if (null == oldPropertyValue) {\r\n        overrides.put(propertyName, propertyValue);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.jqlc.ParameterTable.getValueByIndex",
	"Comment": "returns the value of the parameter with the specified index.",
	"Method": "Object getValueByIndex(int index){\r\n    if ((index < 0) || (index >= values.size()))\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jqlc.parametertable.getvaluebyindex.wrongindex\", String.valueOf(index)));\r\n    return values.get(index);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.SaxParserHandlerBundled.openSchemaSource",
	"Comment": "returns an inputstream for the schema with the requested system id.",
	"Method": "InputSource openSchemaSource(String systemID){\r\n    return openInputSource(BUNDLED_SCHEMA_ROOT, systemID);\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecServerRequestInterceptor.createIdCred",
	"Comment": "create an identity from an identity token and stores it as apublic credential in the jaas subject in a security context.set the identcls field in the security context.",
	"Method": "void createIdCred(SecurityContext sc,IdentityToken idtok){\r\n    byte[] derenc;\r\n    Any any;\r\n    switch(idtok.discriminator()) {\r\n        case ITTAbsent.value:\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"Identity token type is Absent\");\r\n            }\r\n            sc.identcls = null;\r\n            break;\r\n        case ITTAnonymous.value:\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"Identity token type is Anonymous\");\r\n                _logger.log(Level.FINE, \"Adding AnonyCredential to subject's PublicCredentials\");\r\n            }\r\n            sc.subject.getPublicCredentials().add(new AnonCredential());\r\n            sc.identcls = AnonCredential.class;\r\n            break;\r\n        case ITTDistinguishedName.value:\r\n            derenc = idtok.dn();\r\n            if (isCDR(derenc)) {\r\n                any = codec.decode_value(derenc, X501DistinguishedNameHelper.type());\r\n                derenc = X501DistinguishedNameHelper.extract(any);\r\n            }\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"Create an X500Name object from identity token\");\r\n            }\r\n            X500Name xname = new X500Name(derenc);\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"Identity to be asserted is \" + xname.toString());\r\n                _logger.log(Level.FINE, \"Adding X500Name to subject's PublicCredentials\");\r\n            }\r\n            sc.subject.getPublicCredentials().add(xname);\r\n            sc.identcls = X500Name.class;\r\n            break;\r\n        case ITTX509CertChain.value:\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"Identity token type is a X509 Certificate Chain\");\r\n            }\r\n            derenc = idtok.certificate_chain();\r\n            if (isCDR(derenc)) {\r\n                any = codec.decode_value(derenc, X509CertificateChainHelper.type());\r\n                derenc = X509CertificateChainHelper.extract(any);\r\n            }\r\n            DerInputStream din = new DerInputStream(derenc);\r\n            DerValue[] derval = din.getSequence(1);\r\n            X509Certificate[] certchain = new X509CertImpl[derval.length];\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"Contents of X509 Certificate chain:\");\r\n            }\r\n            for (int i = 0; i < certchain.length; i++) {\r\n                certchain[i] = new X509CertImpl(derval[i]);\r\n                if (_logger.isLoggable(Level.FINE)) {\r\n                    _logger.log(Level.FINE, \"    \" + certchain[i].getSubjectDN().getName());\r\n                }\r\n            }\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"Creating a X509CertificateCredential object from certchain\");\r\n            }\r\n            X509CertificateCredential cred = new X509CertificateCredential(certchain, certchain[0].getSubjectDN().getName(), \"default\");\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"Adding X509CertificateCredential to subject's PublicCredentials\");\r\n            }\r\n            sc.subject.getPublicCredentials().add(cred);\r\n            sc.identcls = X509CertificateCredential.class;\r\n            break;\r\n        case ITTPrincipalName.value:\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"Identity token type is GSS Exported Name\");\r\n            }\r\n            byte[] expname = idtok.principal_name();\r\n            if (isCDR(expname)) {\r\n                any = codec.decode_value(expname, GSS_NT_ExportedNameHelper.type());\r\n                expname = GSS_NT_ExportedNameHelper.extract(any);\r\n            }\r\n            if (!GSSUtils.verifyMechOID(GSSUtils.GSSUP_MECH_OID, expname)) {\r\n                throw new SecurityException(localStrings.getLocalString(\"secserverreqinterceptor.err_unknown_idassert_type\", \"Unknown identity assertion type.\"));\r\n            }\r\n            GSSUPName gssname = new GSSUPName(expname);\r\n            sc.subject.getPublicCredentials().add(gssname);\r\n            sc.identcls = GSSUPName.class;\r\n            _logger.log(Level.FINE, \"Adding GSSUPName credential to subject\");\r\n            break;\r\n        default:\r\n            _logger.log(Level.SEVERE, \"iiop.unknown_identity\");\r\n            throw new SecurityException(localStrings.getLocalString(\"secserverreqinterceptor.err_unknown_idassert_type\", \"Unknown identity assertion type.\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.StatementWrapper.executeUpdate",
	"Comment": "executes the given sql statement, which may be an insert,update, or delete statement or ansql statement that returns nothing, such as an sql ddl statement.",
	"Method": "int executeUpdate(String sql,int executeUpdate,String sql,int autoGeneratedKeys,int executeUpdate,String sql,int columnIndexes,int executeUpdate,String sql,String columnNames){\r\n    return jdbcStatement.executeUpdate(sql, columnNames);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingTableElementImpl.addReferencingKey",
	"Comment": "adds a referencing key to the list of keys in this mapping table.",
	"Method": "void addReferencingKey(MappingReferenceKeyElement referencingKey){\r\n    try {\r\n        fireVetoableChange(PROP_REFERENCING_KEYS, null, null);\r\n        getReferencingKeys().add(referencingKey);\r\n        firePropertyChange(PROP_REFERENCING_KEYS, null, null);\r\n    } catch (PropertyVetoException e) {\r\n        throw new ModelVetoException(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.updateBeforeImage",
	"Comment": "initializes the beforeimage and registers the before imagevalue if not null.",
	"Method": "void updateBeforeImage(FieldDesc fieldDesc,Object value){\r\n    getBeforeImage();\r\n    if (beforeImage != null && !beforeImage.getPresenceMaskBit(fieldDesc.absoluteID) && (fieldDesc.sqlProperties & FieldDesc.PROP_LOG_ON_UPDATE) > 0) {\r\n        if (value == null) {\r\n            value = fieldDesc.getValue(this);\r\n        }\r\n        if (value != null) {\r\n            if (logger.isLoggable(Logger.FINEST)) {\r\n                Object[] items = new Object[] { fieldDesc, value };\r\n                logger.finest(\"sqlstore.sqlstatemanager.updatebeforeimage\", items);\r\n            }\r\n            fieldDesc.setValue(beforeImage, cloneObjectMaybe(value));\r\n            beforeImage.setPresenceMaskBit(fieldDesc.absoluteID);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.ResourceRefNode.writeResourceReferences",
	"Comment": "writes all the runtime information for resources references",
	"Method": "void writeResourceReferences(Node parent,ResourceReferenceContainer descriptor){\r\n    Iterator rrs = descriptor.getResourceReferenceDescriptors().iterator();\r\n    if (rrs.hasNext()) {\r\n        ResourceRefNode rrNode = new ResourceRefNode();\r\n        while (rrs.hasNext()) {\r\n            rrNode.writeDescriptor(parent, TagNames.RESOURCE_REFERENCE, (ResourceReferenceDescriptor) rrs.next());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.disconnectQueries",
	"Comment": "disconnects all query instances created for this pm and nullifies thecollection. this is to allow this pm to be gargabe collected.",
	"Method": "void disconnectQueries(){\r\n    for (Iterator i = queries.iterator(); i.hasNext(); ) {\r\n        QueryImpl q = (QueryImpl) i.next();\r\n        q.clearPersistenceManager();\r\n    }\r\n    queries.clear();\r\n    queries = null;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.hashCode",
	"Comment": "returns the hash code for this managedconnectionfactoryimpl.",
	"Method": "int hashCode(){\r\n    logFine(\"In hashCode\");\r\n    return spec.hashCode();\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getRemoteBusinessClassNames",
	"Comment": "returns the set of remote business interface names for this ejb.if the bean does not expose a remote business view, return a setof size 0.",
	"Method": "Set<String> getRemoteBusinessClassNames(){\r\n    return new HashSet<String>(remoteBusinessClassNames);\r\n}"
}, {
	"Path": "com.sun.web.security.RealmAdapter.hasUserDataPermission",
	"Comment": "enforce any user data constraint required by the security constraintguarding this request uri.",
	"Method": "boolean hasUserDataPermission(HttpRequest request,HttpResponse response,SecurityConstraint[] constraints,boolean hasUserDataPermission,HttpRequest request,HttpResponse response,SecurityConstraint[] constraints,String uri,String method){\r\n    HttpServletRequest hrequest = (HttpServletRequest) request;\r\n    if (hrequest.getServletPath() == null) {\r\n        request.setServletPath(getResourceName(hrequest.getRequestURI(), hrequest.getContextPath()));\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"[Web-Security][ hasUserDataPermission ] Principal: \" + hrequest.getUserPrincipal() + \" ContextPath: \" + hrequest.getContextPath());\r\n    }\r\n    if (request.getRequest().isSecure()) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.fine(\"[Web-Security] request.getRequest().isSecure(): \" + request.getRequest().isSecure());\r\n        }\r\n        return true;\r\n    }\r\n    WebSecurityManager secMgr = getWebSecurityManager(true);\r\n    if (secMgr == null) {\r\n        return false;\r\n    }\r\n    int isGranted = 0;\r\n    try {\r\n        isGranted = secMgr.hasUserDataPermission(hrequest, uri, method);\r\n    } catch (IllegalArgumentException e) {\r\n        String msgWithId = rb.getString(\"realmAdapter.badRequestWithId\");\r\n        _logger.log(Level.WARNING, msgWithId, e);\r\n        String msg = rb.getString(\"realmAdapter.badRequest\");\r\n        ((HttpServletResponse) response.getResponse()).sendError(HttpServletResponse.SC_BAD_REQUEST, msg);\r\n        return false;\r\n    }\r\n    if (isGranted == -1) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.fine(\"[Web-Security] redirecting using SSL\");\r\n        }\r\n        return redirect(request, response);\r\n    }\r\n    if (isGranted == 0) {\r\n        ((HttpServletResponse) response.getResponse()).sendError(HttpServletResponse.SC_FORBIDDEN, rb.getString(\"realmBase.forbidden\"));\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.getConnectionMsWait",
	"Comment": "returns the number of milliseconds to wait for an available connectionfrom the connection pool before throwing an exception",
	"Method": "int getConnectionMsWait(){\r\n    return _persistenceManagerFactory.getConnectionMsWait();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.MappingPolicy.getdbJDBCInfo",
	"Comment": "gets the jdbcinfo corresponding to the type in the given jdbcinfo.i.e., it maps from one jdbcinfo to another on the basis of theirtypes.",
	"Method": "JDBCInfo getdbJDBCInfo(int jdbcType,JDBCInfo getdbJDBCInfo,String fieldType){\r\n    JDBCInfo rc = (JDBCInfo) dbJdbcInfoMap.get(fieldType);\r\n    if (null == rc) {\r\n        rc = (JDBCInfo) dbJdbcInfoMap.get(\"BLOB\");\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.MethodHelper.categorizeMethods",
	"Comment": "reads all known methods and sorts them by name into specific\tcollections for further processing.",
	"Method": "void categorizeMethods(){\r\n    IASEjbCMPEntityDescriptor cmpDescriptor = (IASEjbCMPEntityDescriptor) getDescriptor();\r\n    super.categorizeMethods();\r\n    setFinders(getListForCollection(cmpDescriptor.getFinders()));\r\n    setSelectors(getListForCollection(cmpDescriptor.getSelectors()));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.JDOQLElements.setPCResult",
	"Comment": "sets whether the result of the jdoql query is a collection of pcinstances or not.",
	"Method": "void setPCResult(boolean isPCResult){\r\n    this.isPCResult = isPCResult;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsSubqueriesInIns",
	"Comment": "retrieves whether this database supports subqueries inin statements.",
	"Method": "boolean supportsSubqueriesInIns(){\r\n    return databaseMetaData.supportsSubqueriesInIns();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceElement.setImpl",
	"Comment": "set the implementation factory of this persistence element.\tthis method should only be used internally and for cloning \tand archiving.",
	"Method": "void setImpl(PersistenceElement.Impl impl){\r\n    _impl = impl;\r\n    if (_impl != null)\r\n        getImpl().attachToElement(this);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.NameMapper.isLocalInterface",
	"Comment": "determines if the specified name represents a local interface.",
	"Method": "boolean isLocalInterface(String name){\r\n    return mapContainsKey(LOCAL_NAME, name);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.EJBBundleInfoHelper.getSchemaNameToGenerate",
	"Comment": "gets the name to use for schema generation.this implementation \tuses a combo of app name, module name, etc.",
	"Method": "String getSchemaNameToGenerate(){\r\n    return DeploymentHelper.getDDLNamePrefix(getBundleDescriptor()).replace(DOT, UNDERLINE);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.AppClientRuntimeNode.registerBundle",
	"Comment": "register this node as a root node capable of loading entire dd files",
	"Method": "String registerBundle(Map publicIDToDTD){\r\n    publicIDToDTD.put(DTDRegistry.SUN_APPCLIENT_130_DTD_PUBLIC_ID, DTDRegistry.SUN_APPCLIENT_130_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_APPCLIENT_140_DTD_PUBLIC_ID, DTDRegistry.SUN_APPCLIENT_140_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_APPCLIENT_141_DTD_PUBLIC_ID, DTDRegistry.SUN_APPCLIENT_141_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_APPCLIENT_500_DTD_PUBLIC_ID, DTDRegistry.SUN_APPCLIENT_500_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_APPCLIENT_600_DTD_PUBLIC_ID, DTDRegistry.SUN_APPCLIENT_600_DTD_SYSTEM_ID);\r\n    if (!restrictDTDDeclarations()) {\r\n        publicIDToDTD.put(DTDRegistry.SUN_APPCLIENT_140beta_DTD_PUBLIC_ID, DTDRegistry.SUN_APPCLIENT_140beta_DTD_SYSTEM_ID);\r\n    }\r\n    return RuntimeTagNames.S1AS_APPCLIENT_RUNTIME_TAG;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.util.JSONUtil.readArray",
	"Comment": "this function will process a json string and convert it into \tan array.",
	"Method": "List<Object> readArray(JsonChars json){\r\n    json.pushContextEnd(']');\r\n    List<Object> list = new ArrayList<Object>(10);\r\n    Object tmp = null;\r\n    Object value = null;\r\n    while (!json.isAtContextEnd()) {\r\n        value = replaceSpecial(jsonToJava(json));\r\n        if (!json.isAtContextEnd()) {\r\n            tmp = jsonToJava(json);\r\n            if ((!(tmp.equals(COMMA))) && !json.isAtContextEnd()) {\r\n                throw new IllegalArgumentException(\"Expected comma (,) or end curly brace (}), but found (\" + tmp + \") instead!\");\r\n            }\r\n        }\r\n        if ((value == null) || (!(value.equals(ABORT_PROCESSING)))) {\r\n            list.add(value);\r\n        }\r\n    }\r\n    json.popContextEnd();\r\n    return list;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.getTableListStart",
	"Comment": "returns the string that represents start of table listfor this database",
	"Method": "String getTableListStart(){\r\n    String s = (String) dbMap.get(TABLE_LIST_START);\r\n    if (s == null)\r\n        s = NONE;\r\n    if (logger.isLoggable()) {\r\n        logger.fine(\"sqlstore.database.dbvendor.gettableliststart\", s);\r\n    }\r\n    return SPACE + s;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.getInheritedField",
	"Comment": "returns the inherited field element for the specified fieldname in \tthe class with the specified classname.note that the class \twith the specified classname is not checked for this field, only\tsuperclasses are checked.",
	"Method": "Object getInheritedField(String className,String fieldName){\r\n    String superClass = getSuperclass(className);\r\n    Object field = null;\r\n    while ((superClass != null) && ((field = getField(superClass, fieldName)) == null)) {\r\n        superClass = getSuperclass(superClass);\r\n    }\r\n    return field;\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.AppClientDeployer.clean",
	"Comment": "clean any files and artifacts that were created during the executionof the prepare method.",
	"Method": "void clean(DeploymentContext dc){\r\n    super.clean(dc);\r\n    UndeployCommandParameters params = dc.getCommandParameters(UndeployCommandParameters.class);\r\n    if (params != null) {\r\n        final com.sun.enterprise.config.serverbeans.Application app = applications.getApplication(params.name);\r\n        DeploymentUtils.downloadableArtifacts(app).clearArtifacts();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.TypeSupport.isRemoteInterfaceOfEjb",
	"Comment": "returns true if the specified type info denotes theremote interface of the bean with the specified ejb name.",
	"Method": "boolean isRemoteInterfaceOfEjb(Object typeInfo,String ejbName){\r\n    String typeName = getTypeName(typeInfo);\r\n    String remoteInterface = nameMapper.getRemoteInterfaceForEjbName(ejbName);\r\n    return (remoteInterface != null) && remoteInterface.equals(typeName);\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.help.HelpTreeAdaptor.getInstance",
	"Comment": "this method provides access to an helptreeadaptor \tinstance.each time it is invoked, it returns a new instance.",
	"Method": "TreeAdaptor getInstance(FacesContext ctx,LayoutComponent desc,UIComponent parent){\r\n    return new HelpTreeAdaptor(desc, parent);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.LocalFieldDesc.isMappedToLob",
	"Comment": "determines if this field is mapped to a lob column type. it is assumed thatlob fields are mapped to only one columns and ui and model verifications enforce it.",
	"Method": "boolean isMappedToLob(){\r\n    return primaryColumnType == Types.BLOB || isCharLobType(primaryColumnType) || getEnumType() == FieldTypeEnumeration.ARRAY_BYTE_PRIMITIVE;\r\n}"
}, {
	"Path": "com.sun.ejb.base.stats.StatefulSessionStoreStatsImpl.getActivatedBeanSize",
	"Comment": "returns the total number of bytes activated by this store including total, min, maximum",
	"Method": "AverageRangeStatistic getActivatedBeanSize(){\r\n    synchronized (activationSizeLock) {\r\n        return (AverageRangeStatistic) activationSize.unmodifiableView();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.DBStatement.bindStringValue",
	"Comment": "binds the specified value to the column corresponding withthe specified index reference.",
	"Method": "void bindStringValue(int index,String strVal,ColumnElement columnElement,DBVendorType vendorType){\r\n    int sqlType = getSqlType(columnElement);\r\n    if (LocalFieldDesc.isCharLobType(sqlType)) {\r\n        preparedStmt.setCharacterStream(index, new StringReader(strVal), strVal.length());\r\n    } else if (LocalFieldDesc.isFixedCharType(sqlType)) {\r\n        vendorType.getSpecialDBOperation().bindFixedCharColumn(preparedStmt, index, strVal, getLength(columnElement));\r\n    } else {\r\n        preparedStmt.setString(index, strVal);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.addRelationship",
	"Comment": "updates the relationship field fielddesc between thisand the state manager of the added object addedsm.",
	"Method": "Object addRelationship(ForeignFieldDesc fieldDesc,SQLStateManager addedSM){\r\n    Object previousValue = null;\r\n    boolean isCollection = (fieldDesc.cardinalityUPB > 1);\r\n    if (!isCollection) {\r\n        previousValue = prepareSetField(fieldDesc, addedSM.persistentObject, true);\r\n    } else {\r\n        try {\r\n            prepareUpdateFieldSpecial(fieldDesc, null, true);\r\n            SCOCollection c = (SCOCollection) fieldDesc.getValue(this);\r\n            if (c == null) {\r\n                replaceCollection(fieldDesc, null);\r\n                c = (SCOCollection) fieldDesc.getValue(this);\r\n            }\r\n            c.addInternal(addedSM.persistentObject);\r\n            updateTrackedFields(fieldDesc, c, null);\r\n        } catch (ClassCastException e) {\r\n        }\r\n    }\r\n    return previousValue;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ResourceReferenceDescriptor.getMailConfiguration",
	"Comment": "return the mail configuration details of thsi resource or null.",
	"Method": "MailConfiguration getMailConfiguration(){\r\n    return this.mailConfiguration;\r\n}"
}, {
	"Path": "org.glassfish.jdbc.admin.cli.CreateJdbcResource.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    HashMap attrList = new HashMap();\r\n    attrList.put(ResourceConstants.JNDI_NAME, jndiName);\r\n    attrList.put(ResourceConstants.POOL_NAME, connectionPoolId);\r\n    attrList.put(ServerTags.DESCRIPTION, description);\r\n    attrList.put(ResourceConstants.ENABLED, enabled.toString());\r\n    ResourceStatus rs;\r\n    try {\r\n        rs = jdbcMgr.create(domain.getResources(), attrList, properties, target);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"create.jdbc.resource.failed\", \"JDBC resource {0} creation failed\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    ActionReport.ExitCode ec = ActionReport.ExitCode.SUCCESS;\r\n    if (rs.getMessage() != null) {\r\n        report.setMessage(rs.getMessage());\r\n    }\r\n    if (rs.getStatus() == ResourceStatus.FAILURE) {\r\n        ec = ActionReport.ExitCode.FAILURE;\r\n        if (rs.getException() != null)\r\n            report.setFailureCause(rs.getException());\r\n    }\r\n    report.setActionExitCode(ec);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.SelectQueryPlan.processForeignConstraints",
	"Comment": "builds the constraint plan for foreign constraints on the constraintstack. this method joins the current plan with all plansrelated by foreign constraints found in the plan hierarchy.",
	"Method": "void processForeignConstraints(){\r\n    List currentStack = constraint.getConstraints();\r\n    constraint.stack = new ArrayList();\r\n    int index = 0;\r\n    while (index < currentStack.size()) {\r\n        ConstraintNode node = (ConstraintNode) currentStack.get(index);\r\n        if (node instanceof ConstraintForeignFieldName) {\r\n            processForeignFieldConstraint((ConstraintForeignFieldName) node);\r\n        } else if (node instanceof ConstraintFieldName) {\r\n            index = processLocalFieldConstraint((ConstraintFieldName) node, currentStack, index);\r\n        } else if (node instanceof ConstraintFieldNameSubQuery) {\r\n            addCorrelatedInQuery((ConstraintFieldNameSubQuery) node);\r\n        } else {\r\n            constraint.stack.add(node);\r\n        }\r\n        index++;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.connectionReleased",
	"Comment": "fires probe event that a connection is released for the given jdbcconnection pool.",
	"Method": "void connectionReleased(long resourceHandleId){\r\n    ConnectionPoolAppEmitterImpl appEmitter = detectAppBasedProviders(getAppName(resourceHandleId));\r\n    poolProbeProvider.connectionReleasedEvent(poolName, appName, moduleName);\r\n    if (appEmitter != null) {\r\n        appEmitter.connectionReleased();\r\n    }\r\n    resourceAppAssociationMap.remove(resourceHandleId);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.getStringConcat",
	"Comment": "returns the string that represents concatenation operationfor this database",
	"Method": "String getStringConcat(){\r\n    String s = (String) dbMap.get(STRING_CONCAT);\r\n    if (s == null)\r\n        s = NONE;\r\n    if (logger.isLoggable()) {\r\n        logger.fine(\"sqlstore.database.dbvendor.getstringconcat\", s);\r\n    }\r\n    return SPACE + s + SPACE;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jacc.provider.SimplePolicyConfiguration.removeUncheckedPolicy",
	"Comment": "used to remove any unchecked policy statements from thispolicyconfiguration.",
	"Method": "void removeUncheckedPolicy(){\r\n    checkSetPolicyPermission();\r\n    pcwLock.lock();\r\n    try {\r\n        assertStateIsOpen();\r\n        uncheckedPermissions = null;\r\n    } finally {\r\n        pcwLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.CreateConnectorSecurityMap.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (securityMapName == null) {\r\n        report.setMessage(localStrings.getLocalString(\"create.connector.security.map.noSecurityMapName\", \"No security map name specified\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (principals == null && userGroups == null) {\r\n        report.setMessage(localStrings.getLocalString(\"create.connector.security.map.noPrincipalsOrGroupsMap\", \"Either the principal or the user group has to be specified while creating a security map.\" + \" Both cannot be null.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (principals != null && userGroups != null) {\r\n        report.setMessage(localStrings.getLocalString(\"create.connector.security.map.specifyPrincipalsOrGroupsMap\", \"A work-security-map can have either (any number of) group mapping or (any number of) principals\" + \" mapping but not both. Specify --principals or --usergroups.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    Collection<ConnectorConnectionPool> ccPools = domain.getResources().getResources(ConnectorConnectionPool.class);\r\n    if (!doesPoolNameExist(poolName, ccPools)) {\r\n        report.setMessage(localStrings.getLocalString(\"create.connector.security.map.noSuchPoolFound\", \"Connector connection pool {0} does not exist. Please specify a valid pool name.\", poolName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (doesMapNameExist(poolName, securityMapName, ccPools)) {\r\n        report.setMessage(localStrings.getLocalString(\"create.connector.security.map.duplicate\", \"A security map named {0} already exists for connector connection pool {1}. Please give a\" + \" different map name.\", securityMapName, poolName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    List<SecurityMap> maps = getAllSecurityMapsForPool(poolName, ccPools);\r\n    if (principals != null) {\r\n        for (String principal : principals) {\r\n            if (isPrincipalExisting(principal, maps)) {\r\n                report.setMessage(localStrings.getLocalString(\"create.connector.security.map.principal_exists\", \"The principal {0} already exists in connector connection pool {1}. Please give a \" + \"different principal name.\", principal, poolName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    if (userGroups != null) {\r\n        for (String userGroup : userGroups) {\r\n            if (isUserGroupExisting(userGroup, maps)) {\r\n                report.setMessage(localStrings.getLocalString(\"create.connector.security.map.usergroup_exists\", \"The user-group {0} already exists in connector connection pool {1}. Please give a\" + \" different user-group name.\", userGroup, poolName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    ConnectorConnectionPool connPool = null;\r\n    for (ConnectorConnectionPool ccp : ccPools) {\r\n        if (ccp.getName().equals(poolName)) {\r\n            connPool = ccp;\r\n        }\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<ConnectorConnectionPool>() {\r\n            public Object run(ConnectorConnectionPool ccp) throws PropertyVetoException, TransactionFailure {\r\n                List<SecurityMap> securityMaps = ccp.getSecurityMap();\r\n                SecurityMap newResource = ccp.createChild(SecurityMap.class);\r\n                newResource.setName(securityMapName);\r\n                if (principals != null) {\r\n                    for (String p : principals) {\r\n                        newResource.getPrincipal().add(p);\r\n                    }\r\n                }\r\n                if (userGroups != null) {\r\n                    for (String u : userGroups) {\r\n                        newResource.getUserGroup().add(u);\r\n                    }\r\n                }\r\n                BackendPrincipal backendPrincipal = newResource.createChild(BackendPrincipal.class);\r\n                backendPrincipal.setUserName(mappedusername);\r\n                if (mappedpassword != null && !mappedpassword.isEmpty()) {\r\n                    backendPrincipal.setPassword(mappedpassword);\r\n                }\r\n                newResource.setBackendPrincipal(backendPrincipal);\r\n                securityMaps.add(newResource);\r\n                return newResource;\r\n            }\r\n        }, connPool);\r\n    } catch (TransactionFailure tfe) {\r\n        Object[] params = { securityMapName, poolName };\r\n        report.setMessage(localStrings.getLocalString(\"create.connector.security.map.fail\", \"Unable to create connector security map {0} for connector connection pool {1} \", params) + \" \" + tfe.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.CreateConnectorSecurityMap.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    List<SecurityMap> securityMaps = ccp.getSecurityMap();\r\n    SecurityMap newResource = ccp.createChild(SecurityMap.class);\r\n    newResource.setName(securityMapName);\r\n    if (principals != null) {\r\n        for (String p : principals) {\r\n            newResource.getPrincipal().add(p);\r\n        }\r\n    }\r\n    if (userGroups != null) {\r\n        for (String u : userGroups) {\r\n            newResource.getUserGroup().add(u);\r\n        }\r\n    }\r\n    BackendPrincipal backendPrincipal = newResource.createChild(BackendPrincipal.class);\r\n    backendPrincipal.setUserName(mappedusername);\r\n    if (mappedpassword != null && !mappedpassword.isEmpty()) {\r\n        backendPrincipal.setPassword(mappedpassword);\r\n    }\r\n    newResource.setBackendPrincipal(backendPrincipal);\r\n    securityMaps.add(newResource);\r\n    return newResource;\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.database.PropertyHelper.openResourceInputStream",
	"Comment": "open resourcenname as input stream inside dopriviledged block",
	"Method": "InputStream openResourceInputStream(String resourceName,ClassLoader classLoader){\r\n    return (InputStream) AccessController.doPrivileged(new PrivilegedAction() {\r\n        public Object run() {\r\n            if (classLoader != null) {\r\n                return classLoader.getResourceAsStream(resourceName);\r\n            } else {\r\n                return ClassLoader.getSystemResourceAsStream(resourceName);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.database.PropertyHelper.openResourceInputStream",
	"Comment": "open resourcenname as input stream inside dopriviledged block",
	"Method": "InputStream openResourceInputStream(String resourceName,ClassLoader classLoader){\r\n    if (classLoader != null) {\r\n        return classLoader.getResourceAsStream(resourceName);\r\n    } else {\r\n        return ClassLoader.getSystemResourceAsStream(resourceName);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.setIsolation",
	"Comment": "sets the isolation level specified in the connectionrequestinfofor the managedconnection passed.",
	"Method": "void setIsolation(ManagedConnectionImpl mc){\r\n    java.sql.Connection con = mc.getActualConnection();\r\n    if (con == null) {\r\n        return;\r\n    }\r\n    String tranIsolation = spec.getDetail(DataSourceSpec.TRANSACTIONISOLATION);\r\n    if (tranIsolation != null && !tranIsolation.equals(\"\")) {\r\n        int tranIsolationInt = getTransactionIsolationInt(tranIsolation);\r\n        try {\r\n            con.setTransactionIsolation(tranIsolationInt);\r\n            mc.setLastTransactionIsolationLevel(tranIsolationInt);\r\n        } catch (java.sql.SQLException sqle) {\r\n            _logger.log(Level.SEVERE, \"jdbc.exc_tx_iso\", sqle);\r\n            throw new ResourceException(\"The transaction isolation could \" + \"not be set: \" + sqle.getMessage());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.removeFields",
	"Comment": "removed the supplied fields from the collection of fields maintained\tby this holder.",
	"Method": "void removeFields(PersistenceFieldElement[] fields){\r\n    int i, count = ((fields != null) ? fields.length : 0);\r\n    getClassImpl().changeFields(fields, Impl.REMOVE);\r\n    for (i = 0; i < count; i++) {\r\n        PersistenceFieldElement field = fields[i];\r\n        ConcurrencyGroupElement[] groups = field.getConcurrencyGroups();\r\n        int j, groupCount = ((groups != null) ? groups.length : 0);\r\n        for (j = 0; j < groupCount; j++) groups[j].removeField(field);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.setDouble",
	"Comment": "sets the designated parameter to the given java double value.the driver converts thisto an sql double value when it sends it to the database.",
	"Method": "void setDouble(String parameterName,double x){\r\n    callableStatement.setDouble(parameterName, x);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.getConnectionLoginTimeout",
	"Comment": "returns the number of seconds to wait for a new connection to beestablished to the data source",
	"Method": "int getConnectionLoginTimeout(){\r\n    if (connectionFactory != null) {\r\n        return connectionFactory.getLoginTimeout();\r\n    } else {\r\n        return connectionLoginTimeout;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ConnectionHolder.setTypeMap",
	"Comment": "installs the given map object as the tyoe map for thisconnectionobject.",
	"Method": "void setTypeMap(Map map){\r\n    con.setTypeMap(map);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerWrapper.setUserObject",
	"Comment": "the application can manage the persistencemanager instancesmore easily by having an application object associated with eachpersistencemanager instance.",
	"Method": "void setUserObject(Object o){\r\n    if (isValid) {\r\n        pm.setUserObject(o);\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerwrapper.invalidpm\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.CorrelatedSelectPlan.processJoinTable",
	"Comment": "enhance the select statement to include the join table if therelationship is mapped via a join table.",
	"Method": "void processJoinTable(){\r\n    if (parentField.useJoinTable()) {\r\n        addQueryTables(parentField.assocForeignColumns, config);\r\n        addJoinConstraint(this, this, parentField.assocForeignColumns, parentField.foreignColumns, ActionDesc.OP_EQUIJOIN);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.mdb.MessageBeanContainer.createMessageBeanProxy",
	"Comment": "generates the appropriate proxy based on the message listener type.",
	"Method": "Object createMessageBeanProxy(InvocationHandler handler){\r\n    if (isModernMessageListener(messageListenerType_)) {\r\n        Proxy proxy = (Proxy) Proxy.newProxyInstance(loader, new Class[] { messageBeanInterface_ }, handler);\r\n        OptionalLocalInterfaceProvider provider = (OptionalLocalInterfaceProvider) messageBeanSubClass_.newInstance();\r\n        provider.setOptionalLocalIntfProxy(proxy);\r\n        return provider;\r\n    } else {\r\n        return Proxy.newProxyInstance(loader, new Class[] { messageListenerType_, MessageEndpoint.class }, handler);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.SelectStatement.processOrderByField",
	"Comment": "adds a column corresponding to field fieldnode andorder operation op to the order constraint.",
	"Method": "void processOrderByField(ConstraintFieldDesc fieldNode,int op){\r\n    QueryPlan thePlan = getOriginalPlan(fieldNode);\r\n    StringBuffer orderText = new StringBuffer();\r\n    generateColumnText(fieldNode.desc, thePlan, orderText);\r\n    if (op == ActionDesc.OP_ORDERBY_DESC) {\r\n        orderText.append(\" desc\");\r\n    }\r\n    if (orderClause.length() > 0) {\r\n        orderText.append(\", \");\r\n        orderText.append(orderClause);\r\n    }\r\n    orderClause = orderText;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.assertConnectionWait",
	"Comment": "internal\tasserts that mswait and msinterval are properly configured",
	"Method": "void assertConnectionWait(){\r\n    if (connectionMsWait < 0) {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"connection.connectionmanager.mswaitvalue\"));\r\n    } else if (connectionMsInterval < 0 || connectionMsInterval > connectionMsWait || (connectionMsWait > 0 && connectionMsInterval == 0)) {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"connection.connectionmanager.msintervalvalue\"));\r\n    }\r\n}"
}, {
	"Path": "admin.AdminBaseDevTest.doesGetMatch",
	"Comment": "returns true if there is anything in the config that matches. returnsfalse if there is no such thing",
	"Method": "boolean doesGetMatch(String what,String match,boolean doesGetMatch,String what){\r\n    AsadminReturn ret = asadminWithOutput(\"get\", what);\r\n    if (!ret.returnValue) {\r\n        return false;\r\n    }\r\n    if (ret.err != null && ret.err.length() > 1) {\r\n        return false;\r\n    }\r\n    return ret.out != null && ret.out.indexOf(\"=\") >= 0;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.storesLowerCaseQuotedIdentifiers",
	"Comment": "retrieves whether this database treats mixed case quoted sql identifiers ascase insensitive and stores them in lower case.",
	"Method": "boolean storesLowerCaseQuotedIdentifiers(){\r\n    return databaseMetaData.storesLowerCaseQuotedIdentifiers();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.TransactionImpl.getPersistenceManager",
	"Comment": "returns persistencemanager associated with this transaction",
	"Method": "com.sun.jdo.api.persistence.support.PersistenceManager getPersistenceManager(){\r\n    return persistenceManager.getCurrentWrapper();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.TypeSupport.hasLocalInterface",
	"Comment": "returns true if the bean with the specified ejb namehas a local interface.",
	"Method": "boolean hasLocalInterface(Object typeInfo){\r\n    return nameMapper.getLocalInterfaceForEjbName(getTypeName(typeInfo)) != null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.getPersistenceFieldInternal",
	"Comment": "returns the persistencefieldelement with the supplied fieldname found\tin the supplied classname.",
	"Method": "PersistenceFieldElement getPersistenceFieldInternal(String className,String fieldName){\r\n    PersistenceClassElement classElement = getPersistenceClass(className);\r\n    return ((classElement != null) ? classElement.getField(fieldName) : null);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.util.ComponentValidator.computeRunAsPrincipalDefault",
	"Comment": "set a default runas principal to given runasidentitydescriptorif necessary.",
	"Method": "void computeRunAsPrincipalDefault(RunAsIdentityDescriptor runAs,Application application){\r\n    if (runAs != null && (runAs.getRoleName() == null || runAs.getRoleName().length() == 0)) {\r\n        DOLUtils.getDefaultLogger().log(Level.WARNING, \"enterprise.deployment.backend.emptyRoleName\");\r\n        return;\r\n    }\r\n    if (runAs != null && (runAs.getPrincipal() == null || runAs.getPrincipal().length() == 0) && application != null && application.getRoleMapper() != null) {\r\n        String principalName = null;\r\n        String roleName = runAs.getRoleName();\r\n        final Subject fs = (Subject) application.getRoleMapper().getRoleToSubjectMapping().get(roleName);\r\n        if (fs != null) {\r\n            principalName = (String) AccessController.doPrivileged(new PrivilegedAction() {\r\n                @Override\r\n                public Object run() {\r\n                    Set<Principal> pset = fs.getPrincipals();\r\n                    Principal prin = null;\r\n                    if (pset.size() > 0) {\r\n                        prin = (Principal) pset.iterator().next();\r\n                        DOLUtils.getDefaultLogger().log(Level.WARNING, \"enterprise.deployment.backend.computeRunAsPrincipal\", new Object[] { prin.getName() });\r\n                    }\r\n                    return (prin != null) ? prin.getName() : null;\r\n                }\r\n            });\r\n        }\r\n        if (principalName == null || principalName.length() == 0) {\r\n            throw new RuntimeException(\"The RunAs role \" + \"\\\"\" + roleName + \"\\\"\" + \" is not mapped to a principal.\");\r\n        }\r\n        runAs.setPrincipal(principalName);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.util.ComponentValidator.computeRunAsPrincipalDefault",
	"Comment": "set a default runas principal to given runasidentitydescriptorif necessary.",
	"Method": "void computeRunAsPrincipalDefault(RunAsIdentityDescriptor runAs,Application application){\r\n    Set<Principal> pset = fs.getPrincipals();\r\n    Principal prin = null;\r\n    if (pset.size() > 0) {\r\n        prin = (Principal) pset.iterator().next();\r\n        DOLUtils.getDefaultLogger().log(Level.WARNING, \"enterprise.deployment.backend.computeRunAsPrincipal\", new Object[] { prin.getName() });\r\n    }\r\n    return (prin != null) ? prin.getName() : null;\r\n}"
}, {
	"Path": "org.glassfish.persistence.jpa.PersistenceUnitLoader.loadPU",
	"Comment": "loads an individual persistenceunitdescriptor and registers theentitymanagerfactory in appropriate dol structure.",
	"Method": "EntityManagerFactory loadPU(PersistenceUnitDescriptor pud){\r\n    checkForUpgradeFromTopLinkEssentials(pud);\r\n    checkForDataSourceOverride(pud);\r\n    calculateDefaultDataSource(pud);\r\n    PersistenceUnitInfo pInfo = new PersistenceUnitInfoImpl(pud, providerContainerContractInfo);\r\n    String applicationLocation = providerContainerContractInfo.getApplicationLocation();\r\n    final boolean fineMsgLoggable = logger.isLoggable(Level.FINE);\r\n    if (fineMsgLoggable) {\r\n        logger.fine(\"Loading persistence unit for application: \\\"\" + applicationLocation + \"\\\"pu Root is: \" + pud.getPuRoot());\r\n        logger.fine(\"PersistenceInfo for this pud is :\\n\" + pInfo);\r\n    }\r\n    PersistenceProvider provider;\r\n    try {\r\n        provider = PersistenceProvider.class.cast(providerContainerContractInfo.getClassLoader().loadClass(pInfo.getPersistenceProviderClassName()).newInstance());\r\n    } catch (ClassNotFoundException | InstantiationException | IllegalAccessException e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    Map<String, Object> schemaGenerationOverrides;\r\n    schemaGenerationProcessor = SchemaGenerationProcessorFactory.createSchemaGenerationProcessor(pud);\r\n    if (providerContainerContractInfo.isJava2DBRequired()) {\r\n        schemaGenerationProcessor.init(pud, providerContainerContractInfo.getDeploymentContext());\r\n        schemaGenerationOverrides = schemaGenerationProcessor.getOverridesForSchemaGeneration();\r\n    } else {\r\n        schemaGenerationOverrides = schemaGenerationProcessor.getOverridesForSuppressingSchemaGeneration();\r\n    }\r\n    Map<String, Object> overRides = new HashMap<String, Object>(integrationProperties);\r\n    if (schemaGenerationOverrides != null) {\r\n        overRides.putAll(schemaGenerationOverrides);\r\n    }\r\n    ValidationMode validationMode = getValidationMode(pud);\r\n    if (validationMode == ValidationMode.AUTO || validationMode == ValidationMode.CALLBACK) {\r\n        overRides.put(VALIDATOR_FACTORY, providerContainerContractInfo.getValidatorFactory());\r\n    }\r\n    if (!providerContainerContractInfo.isWeavingEnabled()) {\r\n        overRides.put(ECLIPSELINK_WEAVING_PROPERTY, System.getProperty(ECLIPSELINK_WEAVING_PROPERTY, \"false\"));\r\n    }\r\n    EntityManagerFactory emf = provider.createContainerEntityManagerFactory(pInfo, overRides);\r\n    if (fineMsgLoggable) {\r\n        // NOI18N\r\n        logger.logp(Level.FINE, \"PersistenceUnitLoader\", // NOI18N\r\n        \"loadPU\", \"emf = {0}\", emf);\r\n    }\r\n    PersistenceUnitsDescriptor parent = pud.getParent();\r\n    RootDeploymentDescriptor containingBundle = parent.getParent();\r\n    providerContainerContractInfo.registerEMF(pInfo.getPersistenceUnitName(), pud.getPuRoot(), containingBundle, emf);\r\n    if (fineMsgLoggable) {\r\n        // NOI18N\r\n        logger.fine(\"Finished loading persistence unit for application: \" + applicationLocation);\r\n    }\r\n    return emf;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.getResourceEnvReferenceByName",
	"Comment": "return a reference to another ejb by the same name or throw an illegalargumentexception.",
	"Method": "ResourceEnvReferenceDescriptor getResourceEnvReferenceByName(String name){\r\n    for (Iterator itr = getResourceEnvReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        ResourceEnvReferenceDescriptor jdr = (ResourceEnvReferenceDescriptor) itr.next();\r\n        if (jdr.getName().equals(name)) {\r\n            return jdr;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"No resource env ref of name \" + name);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.Descriptor.countMethodArgWords",
	"Comment": "return the number of words of arguments to the method based on the method signature",
	"Method": "int countMethodArgWords(String sig){\r\n    if (sig.charAt(0) != '(')\r\n        throw new InsnError(\"not a method signature\");\r\n    int count = 0;\r\n    for (int idx = 1; sig.charAt(idx) != ')'; idx++) {\r\n        switch(sig.charAt(idx)) {\r\n            case 'B':\r\n            case 'C':\r\n            case 'S':\r\n            case 'I':\r\n            case 'F':\r\n            case 'Z':\r\n                count++;\r\n                break;\r\n            case 'J':\r\n            case 'D':\r\n                count += 2;\r\n                break;\r\n            case 'L':\r\n                count++;\r\n                idx = sig.indexOf(';', idx);\r\n                break;\r\n            case '[':\r\n                count++;\r\n                while (sig.charAt(idx) == '[' || sig.charAt(idx) == ']') idx++;\r\n                if (sig.charAt(idx) == 'L')\r\n                    idx = sig.indexOf(';', idx);\r\n                break;\r\n            default:\r\n                throw new InsnError(\"missing case\");\r\n        }\r\n    }\r\n    return count;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ForeignFieldDesc.isMappedToPk",
	"Comment": "returns true, if the relationship is mapped to primary key fieldson the other relationship side.",
	"Method": "boolean isMappedToPk(){\r\n    return isMappedToPk;\r\n}"
}, {
	"Path": "org.glassfish.resources.javamail.deployer.MailResourceDeployer.installMailResource",
	"Comment": "installs the given mail resource. this method gets called during serverinitialization and from mail resource deployer to handle resource events.",
	"Method": "void installMailResource(org.glassfish.resources.javamail.beans.MailResource mailResource,ResourceInfo resourceInfo){\r\n    try {\r\n        MailConfiguration config = new MailConfiguration(mailResource);\r\n        javax.naming.Reference ref = new javax.naming.Reference(javax.mail.Session.class.getName(), MailNamingObjectFactory.class.getName(), null);\r\n        SerializableObjectRefAddr serializableRefAddr = new SerializableObjectRefAddr(\"jndiName\", config);\r\n        ref.add(serializableRefAddr);\r\n        namingService.publishObject(resourceInfo, ref, true);\r\n    } catch (Exception ex) {\r\n        _logger.log(Level.SEVERE, \"mailrsrc.create_obj_error\", resourceInfo);\r\n        _logger.log(Level.SEVERE, \"mailrsrc.create_obj_error_excp\", ex);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployapi.DeploymentStatusImpl.isCompleted",
	"Comment": "a convience method to report if the operation isin the completed state.",
	"Method": "boolean isCompleted(){\r\n    return StateType.COMPLETED.equals(stateType);\r\n}"
}, {
	"Path": "org.glassfish.admingui.connector.IntegrationPoint.getContent",
	"Comment": "a reference to extra information needed to use this \tintegrationpoint.an example might be a .jsf page \treference which should be included.or a location used to find \thelpset information.",
	"Method": "String getContent(){\r\n    return content;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MailConfiguration.getDescription",
	"Comment": "get the mail description for the mail session the server will provide.",
	"Method": "String getDescription(){\r\n    return this.description;\r\n}"
}, {
	"Path": "org.glassfish.persistence.jpa.schemageneration.EclipseLinkSchemaGenerationProcessor.executeCreateDDL",
	"Comment": "this method is called after the jdbc files have been created. iterate over all created jdbc ddl files andexecute it against the database to have the required objects created.",
	"Method": "void executeCreateDDL(){\r\n    helper.createOrDropTablesInDB(true, \"JPA\");\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.util.JmsRaUtil.isServerClustered",
	"Comment": "return true if the given server instance is part of a cluster.",
	"Method": "boolean isServerClustered(List clusters,String instanceName){\r\n    return (getClusterForServer(clusters, instanceName) != null);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceElementCollection.getPropertyName",
	"Comment": "returns the property name of this collection.this method \tshould only be used internally and for cloning and archiving.",
	"Method": "String getPropertyName(){\r\n    return _propertyName;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingReferenceKeyElementImpl.getLocalColumns",
	"Comment": "get all local columns in this reference key.this method is \tprovided as part of the implementation of the referencekey interface\tbut should only be used when a referencekey object is used or by \tthe runtime.",
	"Method": "ColumnElement[] getLocalColumns(){\r\n    ColumnPairElement[] columnPairs = getColumnPairs();\r\n    int i, count = ((columnPairs != null) ? columnPairs.length : 0);\r\n    ColumnElement[] columns = new ColumnElement[count];\r\n    for (i = 0; i < count; i++) columns[i] = columnPairs[i].getLocalColumn();\r\n    return columns;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.naming.ConnectorResourceNamingEventNotifier.notifyListeners",
	"Comment": "notifies all the registered listeners about the naming event.",
	"Method": "void notifyListeners(ConnectorNamingEvent event){\r\n    for (ConnectorNamingEventListener listener : listeners) {\r\n        listener.connectorNamingEventPerformed(event);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.io.runtime.ApplicationRuntimeDDFile.registerBundle",
	"Comment": "register the root node for this runtime deployment descriptor filein the root nodes map, and also in the dtd map which will be used fordtd validation.",
	"Method": "void registerBundle(Map<String, Class> rootNodesMap,Map<String, String> publicIDToDTDMap,Map<String, List<Class>> versionUpgrades){\r\n    rootNodesMap.put(ApplicationRuntimeNode.registerBundle(publicIDToDTDMap, versionUpgrades), ApplicationRuntimeNode.class);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.matchesMethod",
	"Comment": "checks whether the specified method element exists and if so whether it\thas the expected modifiers and the expected return type.",
	"Method": "boolean matchesMethod(Object method,int expectedModifiers,int optionalModifiers,String expectedReturnType){\r\n    boolean matches = false;\r\n    if (method != null) {\r\n        Model model = getModel();\r\n        int modifiers = model.getModifiers(method);\r\n        matches = (((modifiers == expectedModifiers) || (modifiers == (expectedModifiers | optionalModifiers))) && expectedReturnType.equals(model.getType(method)));\r\n    }\r\n    return matches;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.connectionDestroyed",
	"Comment": "fires probe event that a connection is destroyed for the given jdbc connection pool.",
	"Method": "void connectionDestroyed(long resourceHandleId){\r\n    poolProbeProvider.connectionDestroyedEvent(poolName, appName, moduleName);\r\n    resourceAppAssociationMap.remove(resourceHandleId);\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecClientRequestInterceptor.getCred",
	"Comment": "retrieves a single credential from a credset for the specified class.it also performs some semantic checking and logging.a null is returned if semantic checking fails.",
	"Method": "java.lang.Object getCred(Set credset,Class c){\r\n    java.lang.Object cred = null;\r\n    String clsname = c.getName();\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"Checking for a single instance of class in subject\");\r\n        _logger.log(Level.FINE, \"    Classname = \" + clsname);\r\n    }\r\n    if (credset.size() != 1) {\r\n        if (_logger.isLoggable(Level.SEVERE))\r\n            _logger.log(Level.SEVERE, \"iiop.multiple_credset\", new java.lang.Object[] { Integer.valueOf(credset.size()), clsname });\r\n        throw new SecurityException(localStrings.getLocalString(\"secclientreqinterceptor.inv_credlist_size\", \"Credential list size is not 1.\"));\r\n    }\r\n    Iterator iter = credset.iterator();\r\n    while (iter.hasNext()) cred = iter.next();\r\n    if (_logger.isLoggable(Level.FINE))\r\n        _logger.log(Level.FINE, \"Verified single instance of class ( \" + clsname + \" )\");\r\n    return cred;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.TypeTable.binaryNumericPromotion",
	"Comment": "implements binary numeric promotion as defined in the java language specification section 5.6.2",
	"Method": "Type binaryNumericPromotion(Type left,Type right){\r\n    if ((left instanceof NumericType) && (right instanceof NumericType)) {\r\n        if (left.equals(doubleType) || right.equals(doubleType))\r\n            return doubleType;\r\n        else if (left.equals(floatType) || right.equals(floatType))\r\n            return floatType;\r\n        else if (left.equals(longType) || right.equals(longType))\r\n            return longType;\r\n        else\r\n            return intType;\r\n    } else {\r\n        return errorType;\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.storesUpperCaseQuotedIdentifiers",
	"Comment": "retrieves whether this database treats mixed case quoted sql identifiers ascase insensitive and stores them in upper case.",
	"Method": "boolean storesUpperCaseQuotedIdentifiers(){\r\n    return databaseMetaData.storesUpperCaseQuotedIdentifiers();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.EJBHelper.getLocalTransactionManager",
	"Comment": "called in a managed environment to access a transactionmanagerfor managing local transaction boundaries and synchronizationfor local transaction completion.",
	"Method": "TransactionManager getLocalTransactionManager(TransactionManager getLocalTransactionManager){\r\n    return myHelper.getLocalTransactionManager();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerWrapper.close",
	"Comment": "a persistencemanager instance can be used until it is closed.this method closes the persistencemanager, which if pooled, releases itto the pool of available persistencemanagers.",
	"Method": "void close(){\r\n    if (isValid) {\r\n        isValid = false;\r\n        pm.popCurrentWrapper(prev);\r\n        pm = null;\r\n        prev = null;\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerwrapper.invalidpm\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.logging.AbstractLoggerFactory.getErrorLogger",
	"Comment": "get the error logger which is used to log things during creation of \tloggers.",
	"Method": "Logger getErrorLogger(){\r\n    return // NOI18N\r\n    LogHelper.getLogger(\"\", _bundleName, AbstractLoggerFactory.class.getClassLoader());\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsOrderByUnrelated",
	"Comment": "retrieves whether this database supports using a column that isnot in the select statement in anorder by clause.",
	"Method": "boolean supportsOrderByUnrelated(){\r\n    return databaseMetaData.supportsOrderByUnrelated();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ApplicationClientDescriptor.getEntityManagerFactoryReferenceByName",
	"Comment": "return the entity manager factory reference descriptor corresponding tothe given name.",
	"Method": "EntityManagerFactoryReferenceDescriptor getEntityManagerFactoryReferenceByName(String name){\r\n    for (EntityManagerFactoryReferenceDescriptor next : getEntityManagerFactoryReferenceDescriptors()) {\r\n        if (next.getName().equals(name)) {\r\n            return next;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"exceptionappclienthasnoentitymgrfactoryrefbyname\", \"This application client [{0}] has no entity manager factory reference by the name of [{1}]\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "org.glassfish.resources.javamail.LogOutputStream.log",
	"Comment": "log the specified message.can be overridden by subclass to do different logging.",
	"Method": "void log(String msg){\r\n    logger.log(level, msg);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.removeField",
	"Comment": "remove the supplied field from the collection of fields maintained by\tthis holder.",
	"Method": "void removeField(PersistenceFieldElement field){\r\n    removeFields(new PersistenceFieldElement[] { field });\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.HashSet.addInternal",
	"Comment": "adds an object to the list without recording changes if the hashset is not deferred. otherwise, add o to the added list.",
	"Method": "void addInternal(Object o){\r\n    if (isDeferred) {\r\n        if (removed.remove(o) == false) {\r\n            added.add(o);\r\n        }\r\n    } else {\r\n        super.add(o);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ConnectionHolder.getWarnings",
	"Comment": "retrieves the the first warning reported by calls on the underlyingconnection object.",
	"Method": "SQLWarning getWarnings(){\r\n    checkValidity();\r\n    return con.getWarnings();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.Descriptor.countMethodReturnWords",
	"Comment": "return the number of words of return value for the methodbased on the method signature",
	"Method": "int countMethodReturnWords(String sig){\r\n    int idx = sig.lastIndexOf(')') + 1;\r\n    if (idx == 0)\r\n        throw new InsnError(\"not a method signature\");\r\n    switch(sig.charAt(idx)) {\r\n        case 'J':\r\n        case 'D':\r\n            return 2;\r\n        case 'B':\r\n        case 'C':\r\n        case 'S':\r\n        case 'I':\r\n        case 'F':\r\n        case 'Z':\r\n        case 'L':\r\n        case '[':\r\n            return 1;\r\n        case 'V':\r\n            return 0;\r\n        default:\r\n            throw new InsnError(\"missing case\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectorConnPoolStatsProvider.connectionRequestQueuedEvent",
	"Comment": "when an object is added to wait queue, increment the waitqueuelength.",
	"Method": "void connectionRequestQueuedEvent(String poolName,String appName,String moduleName){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (logger.isLoggable(Level.FINEST)) {\r\n            logger.finest(\"Wait Queue length modified event received - \" + \"poolName = \" + poolName);\r\n        }\r\n        waitQueueLength.increment();\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.RuntimeTimerState.getNumFailedDeliveries",
	"Comment": "number of failed deliveries since timer last transitioned to the scheduled state.",
	"Method": "int getNumFailedDeliveries(){\r\n    return numFailedDeliveries_;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingFieldElementImpl.addColumn",
	"Comment": "adds a column to the list of columns mapped by this mapping field.",
	"Method": "void addColumn(DBMemberElement column){\r\n    if (column != null) {\r\n        ArrayList columns = getColumns();\r\n        String columnName = NameUtil.getRelativeMemberName(column.getName().getFullName());\r\n        if (!columns.contains(columnName)) {\r\n            try {\r\n                fireVetoableChange(PROP_COLUMNS, null, null);\r\n                columns.add(columnName);\r\n                firePropertyChange(PROP_COLUMNS, null, null);\r\n                _columnObjects = null;\r\n            } catch (PropertyVetoException e) {\r\n                throw new ModelVetoException(e);\r\n            }\r\n        } else {\r\n        }\r\n    } else {\r\n        throw new ModelException(// NOI18N\r\n        I18NHelper.getMessage(getMessages(), \"mapping.element.null_argument\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.ConnectionFactoryImpl.setLoginTimeout",
	"Comment": "sets the number of seconds to wait for a new connection to beestablished to the data source",
	"Method": "void setLoginTimeout(int loginTimeout){\r\n    assertNotConfigured();\r\n    if (connectionManager == null) {\r\n        this.loginTimeout = loginTimeout;\r\n        return;\r\n    }\r\n    try {\r\n        connectionManager.setLoginTimeout(loginTimeout);\r\n    } catch (Exception e) {\r\n        throw new JDOFatalException(null, e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ResourceDescriptorRegistry.removeResourceDescriptor",
	"Comment": "remove resource descriptor based on resource type and given reference",
	"Method": "void removeResourceDescriptor(JavaEEResourceType javaEEResourceType,ResourceDescriptor reference){\r\n    Set<ResourceDescriptor> resourceDescriptorSet = getResourceDescriptors(reference.getResourceType());\r\n    resourceDescriptorSet.remove(reference);\r\n    resourceDescriptors.put(javaEEResourceType, resourceDescriptorSet);\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.PoolLifeCycleListenerRegistry.registerPoolLifeCycleListener",
	"Comment": "add a listener to the list of pool life cycle listeners maintained by this registry.",
	"Method": "void registerPoolLifeCycleListener(PoolLifeCycleListener listener){\r\n    poolListenersList.add(listener);\r\n    if (!(poolListenersList.size() > 1)) {\r\n        PoolManager poolMgr = ConnectorRuntime.getRuntime().getPoolManager();\r\n        ResourcePool pool = poolMgr.getPool(poolInfo);\r\n        pool.setPoolLifeCycleListener(this);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jaspic.config.factory.RegStoreFileParser.writeEntries",
	"Comment": "this method overwrites the existing file with thecurrent entries.",
	"Method": "void writeEntries(){\r\n    if (confFile.exists() && !confFile.canWrite() && logger.isLoggable(Level.WARNING)) {\r\n        logger.log(Level.WARNING, \"jmac.factory_cannot_write_file\", confFile.getPath());\r\n    }\r\n    clearExistingFile();\r\n    PrintWriter out = new PrintWriter(confFile);\r\n    int indent = 0;\r\n    for (EntryInfo info : entries) {\r\n        if (info.isConstructorEntry()) {\r\n            writeConEntry(info, out, indent);\r\n        } else {\r\n            writeRegEntry(info, out, indent);\r\n        }\r\n    }\r\n    out.close();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getModifiers",
	"Comment": "returns the modifier mask for the specified member element.\tnote, the member element is either a class element as returned by \tgetclass, a field element as returned by getfield, a constructor element \tas returned by getconstructor, or a method element as returned by \tgetmethod executed on the same model instance.this implementation \texpects the member element to be a reflection instance.",
	"Method": "int getModifiers(Object memberElement){\r\n    int modifiers = 0;\r\n    if (memberElement != null) {\r\n        if (memberElement instanceof Class) {\r\n            modifiers = ((Class) memberElement).getModifiers();\r\n        } else if (memberElement instanceof Member) {\r\n            modifiers = ((Member) memberElement).getModifiers();\r\n        }\r\n    }\r\n    return modifiers;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsTableCorrelationNames",
	"Comment": "retrieves whether this database supports table correlation names.",
	"Method": "boolean supportsTableCorrelationNames(){\r\n    return databaseMetaData.supportsTableCorrelationNames();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingTableElementImpl.isEqual",
	"Comment": "returns true if the table element used by this mapping table is equal\tto the supplied table.",
	"Method": "boolean isEqual(TableElement table){\r\n    return ((table != null) ? getTable().equals(table.toString()) : false);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.acquireShareLock",
	"Comment": "acquires a share lock from the persistence manager. this method willput the calling thread to sleep if another thread is holding the exclusive lock.",
	"Method": "void acquireShareLock(){\r\n    if (!_multithreaded) {\r\n        return;\r\n    }\r\n    boolean debug = logger.isLoggable(Logger.FINEST);\r\n    synchronized (_readWriteLock) {\r\n        if ((_readWriteCount < 0) && (_exclusiveLockHolder == Thread.currentThread())) {\r\n            return;\r\n        }\r\n        while (_readWriteCount < 0) {\r\n            _waiterCount++;\r\n            try {\r\n                if (debug) {\r\n                    logger.finest(\"sqlstore.persistencemgr.acquiresharedlock\", Thread.currentThread());\r\n                }\r\n                _readWriteLock.wait();\r\n            } catch (InterruptedException e) {\r\n                throw new JDOFatalInternalException(I18NHelper.getMessage(messages, \"jdo.persistencemanagerimpl.acquiresharelock.interrupted\"), e);\r\n            } finally {\r\n                _waiterCount--;\r\n            }\r\n        }\r\n        try {\r\n            assertIsOpen();\r\n        } catch (JDOException ex) {\r\n            if (_readWriteCount == 0 && _waiterCount > 0) {\r\n                _readWriteLock.notify();\r\n            }\r\n            throw ex;\r\n        }\r\n        _readWriteCount++;\r\n        if (debug) {\r\n            // NOI18N\r\n            logger.finest(\"sqlstore.persistencemgr.acquiresharedlock.rdwrcount\", Thread.currentThread(), new Long(_readWriteCount));\r\n        }\r\n        if (_readWriteCount <= 0) {\r\n            throw new JDOFatalInternalException(// NOI18N\r\n            I18NHelper.getMessage(messages, \"jdo.persistencemanagerimpl.acquiresharelock.failed\"));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.ClassAction.getImplementsPersistence",
	"Comment": "return true if this class will implement persistencecapable.",
	"Method": "boolean getImplementsPersistence(){\r\n    return implementsPersistence;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceFieldElementImpl.isReadSensitive",
	"Comment": "determines whether this field element is read sensitive or not.\tthis value is only used if getpersistencetype returns\tderived",
	"Method": "boolean isReadSensitive(){\r\n    return ((PersistenceFieldElement.DERIVED == getPersistenceType()) ? ((_derivedModifier & READ_SENSITIVE) != 0) : false);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceClassElementImpl.fireVetoableChange",
	"Comment": "fires vetoable change event.this method overrides that of \tpersistenceelementimpl to give listeners a chance to block \tchanges on the persistence class element modified status.",
	"Method": "void fireVetoableChange(String name,Object o,Object n){\r\n    boolean noChange = ((o != null) && (n != null) && o.equals(n));\r\n    super.fireVetoableChange(name, o, n);\r\n    if (!(PROP_MODIFIED.equals(name)) && !noChange)\r\n        fireVetoableChange(PROP_MODIFIED, Boolean.FALSE, Boolean.TRUE);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerWrapper.currentTransaction",
	"Comment": "there is exactly one transaction associated with a persistencemanager.",
	"Method": "Transaction currentTransaction(){\r\n    if (isValid) {\r\n        return pm.currentTransaction();\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerwrapper.invalidpm\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceMemberElementImpl.fireVetoableChange",
	"Comment": "fires vetoable change event.this method overrides that of \tpersistenceelementimpl to give listeners a chance to block \tchanges on the persistence class element modified status.",
	"Method": "void fireVetoableChange(String name,Object o,Object n){\r\n    boolean noChange = ((o != null) && (n != null) && o.equals(n));\r\n    PersistenceClassElement classElement = ((PersistenceMemberElement) _element).getDeclaringClass();\r\n    super.fireVetoableChange(name, o, n);\r\n    if ((classElement != null) && !noChange) {\r\n        ((PersistenceElementImpl) classElement.getImpl()).fireVetoableChange(PROP_MODIFIED, Boolean.FALSE, Boolean.TRUE);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlTime.cloneInternal",
	"Comment": "creates and returns a copy of this object without resetting the owner and field value.",
	"Method": "Object cloneInternal(){\r\n    return super.clone();\r\n}"
}, {
	"Path": "com.sun.web.security.RealmAdapter.invokeWebSecurityManager",
	"Comment": "invokes websecuritymanager to perform access control check.return true if permission is granted, or falseotherwise.",
	"Method": "boolean invokeWebSecurityManager(HttpRequest request,HttpResponse response,SecurityConstraint[] constraints){\r\n    boolean evaluated = false;\r\n    try {\r\n        rwLock.readLock().lock();\r\n        evaluated = contextEvaluated;\r\n    } finally {\r\n        rwLock.readLock().unlock();\r\n    }\r\n    if (!evaluated) {\r\n        try {\r\n            rwLock.writeLock().lock();\r\n            if (!contextEvaluated) {\r\n                Context context = (Context) getContainer();\r\n                LoginConfig config = context.getLoginConfig();\r\n                if ((config != null) && (Constants.FORM_METHOD.equals(config.getAuthMethod()))) {\r\n                    loginPage = config.getLoginPage();\r\n                    errorPage = config.getErrorPage();\r\n                }\r\n                contextEvaluated = true;\r\n            }\r\n        } finally {\r\n            rwLock.writeLock().unlock();\r\n        }\r\n    }\r\n    if (loginPage != null || errorPage != null) {\r\n        String requestURI = request.getRequestPathMB().toString();\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.fine(\"[Web-Security]  requestURI: \" + requestURI + \" loginPage: \" + loginPage);\r\n        }\r\n        if (loginPage != null && loginPage.equals(requestURI)) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.fine(\" Allow access to login page \" + loginPage);\r\n            }\r\n            return true;\r\n        } else if (errorPage != null && errorPage.equals(requestURI)) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.fine(\" Allow access to error page \" + errorPage);\r\n            }\r\n            return true;\r\n        } else if (requestURI.endsWith(Constants.FORM_ACTION)) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.fine(\" Allow access to username/password submission\");\r\n            }\r\n            return true;\r\n        }\r\n    }\r\n    HttpServletRequest hrequest = (HttpServletRequest) request;\r\n    if (hrequest.getServletPath() == null) {\r\n        request.setServletPath(getResourceName(hrequest.getRequestURI(), hrequest.getContextPath()));\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"[Web-Security] [ hasResourcePermission ] Principal: \" + hrequest.getUserPrincipal() + \" ContextPath: \" + hrequest.getContextPath());\r\n    }\r\n    WebSecurityManager secMgr = getWebSecurityManager(true);\r\n    if (secMgr == null) {\r\n        return false;\r\n    }\r\n    return secMgr.hasResourcePermission(hrequest);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jmac.config.GFServerConfigProvider.getClientAuthConfig",
	"Comment": "get an instance of clientauthconfig from this provider. the implementation of this method returns a clientauthconfiginstance that describes the configuration of clientauthmodulesat a given message layer, and for use in an identified applicationcontext.",
	"Method": "ClientAuthConfig getClientAuthConfig(String layer,String appContext,CallbackHandler handler){\r\n    return new GFClientAuthConfig(this, layer, appContext, handler);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.getDefaultResourceName",
	"Comment": "returns the generated default connector resource for aconnection definition.",
	"Method": "String getDefaultResourceName(String moduleName,String connectionDefName){\r\n    return connectorService.getDefaultResourceName(moduleName, connectionDefName);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ClassDesc.addFKConstraints",
	"Comment": "generate the condition on the relationship key in the where clausewith inputparamvalues for later binding of the actual query parameters.",
	"Method": "void addFKConstraints(RetrieveDescImpl rd,ForeignFieldDesc foreignField){\r\n    for (int i = 0; i < foreignField.foreignFields.size(); i++) {\r\n        LocalFieldDesc fff = (LocalFieldDesc) foreignField.foreignFields.get(i);\r\n        rd.addParameterConstraint(fff, i);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.EnvironmentProperty.getValueObject",
	"Comment": "returns the typed value object of this environment property. throws an illegalargumentexception if bounds checking istrue and the value cannot be reconciled with the given type.",
	"Method": "Object getValueObject(){\r\n    if (this.valueObject == null) {\r\n        this.valueObject = \"\";\r\n    }\r\n    return getObjectFromString(this.getValue(), this.getValueType());\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.util.GuiUtil.stringToArray",
	"Comment": "this method converts a string into stringarray, uses the delimeter as the separator character. if the delimiter is null, uses space as default.",
	"Method": "String[] stringToArray(String str,String delimiter){\r\n    String[] retString = new String[0];\r\n    if (str != null) {\r\n        if (delimiter == null) {\r\n            delimiter = \" \";\r\n        }\r\n        StringTokenizer tokens = new StringTokenizer(str, delimiter);\r\n        retString = new String[tokens.countTokens()];\r\n        int i = 0;\r\n        while (tokens.hasMoreTokens()) {\r\n            String token = tokens.nextToken().trim();\r\n            retString[i++] = token;\r\n        }\r\n    }\r\n    return retString;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.handlers.ResourceHandler.getEnvironmentPropertyDescriptors",
	"Comment": "return environmentproperty descriptors with the given name if it exists or a new one without name being set.",
	"Method": "EnvironmentProperty[] getEnvironmentPropertyDescriptors(String logicalName,ResourceContainerContext[] rcContexts,Resource annotation){\r\n    Collection<EnvironmentProperty> envEntries = new ArrayList<EnvironmentProperty>();\r\n    for (int i = 0; i < rcContexts.length; i++) {\r\n        EnvironmentProperty envEntry = rcContexts[i].getEnvEntry(logicalName);\r\n        if (envEntry != null) {\r\n            envEntries.add(envEntry);\r\n        } else {\r\n            envEntry = new EnvironmentProperty();\r\n            envEntries.add(envEntry);\r\n            rcContexts[i].addEnvEntryDescriptor(envEntry);\r\n        }\r\n    }\r\n    return envEntries.toArray(new EnvironmentProperty[envEntries.size()]);\r\n}"
}, {
	"Path": "org.glassfish.jdbc.pool.monitor.JdbcConnPoolStatsProvider.connectionNotMatchedEvent",
	"Comment": "when a connection under test does not match the current request,increment numconnnotsuccessfullymatched.",
	"Method": "void connectionNotMatchedEvent(String poolName,String appName,String moduleName){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (logger.isLoggable(Level.FINEST)) {\r\n            logger.finest(\"Connection not matched event received - \" + \"poolName = \" + poolName);\r\n        }\r\n        numConnNotSuccessfullyMatched.increment();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.module.ConnectorApplication.start",
	"Comment": "starts an application container.contractprovider starting should not throw an exception but rather shoulduse their prefered logger instance to log any issue they encounter whilestarting. returning false from a start mean that the container failedto start",
	"Method": "boolean start(ApplicationContext startupContext){\r\n    boolean started = false;\r\n    deployResources();\r\n    runtime.registerConnectorApplication(this);\r\n    started = true;\r\n    event.register(this);\r\n    logFine(\"Resource Adapter [ \" + getModuleName() + \" ] started\");\r\n    return started;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.BaseContainer.lookupExtendedEntityManager",
	"Comment": "containers that allow extended entitymanager will override this method.",
	"Method": "EntityManager lookupExtendedEntityManager(EntityManagerFactory emf){\r\n    throw new IllegalStateException(localStrings.getLocalString(\"ejb.extended_persistence_context_not_supported\", \"EntityManager with PersistenceContextType.EXTENDED is not supported for this bean type\"));\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ConnectionHolder.getMetaData",
	"Comment": "retrieves the databasemetadataobject from the underlying connectionobject.",
	"Method": "DatabaseMetaData getMetaData(){\r\n    checkValidity();\r\n    return con.getMetaData();\r\n}"
}, {
	"Path": "com.sun.ejb.base.stats.StatefulSessionStoreStatsImpl.getPassivationTime",
	"Comment": "returns the time spent on passivating beans to the store including total, min, max",
	"Method": "AverageRangeStatistic getPassivationTime(){\r\n    synchronized (passivationTimeLock) {\r\n        return (AverageRangeStatistic) passivationTime.unmodifiableView();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.getExtent",
	"Comment": "the persistencemanager may manage a collection of instances in the datastore based on the class of the instances.this method returns acollection of instances in the data store that might be iterated orgiven to a query as the collection of candidate instances.",
	"Method": "Collection getExtent(Class persistenceCapableClass,boolean subclasses){\r\n    assertIsOpen();\r\n    return new ExtentCollection(this, persistenceCapableClass, subclasses);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ActiveOutboundResourceAdapter.destroy",
	"Comment": "destroys default pools and resources. stops the resource adapterjava bean.",
	"Method": "void destroy(){\r\n    if ((connectionDefs_ != null) && (connectionDefs_.length != 0)) {\r\n        super.destroy();\r\n    }\r\n    stopResourceAdapter();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ManagedBeanDescriptor.getCallbackInterceptors",
	"Comment": "return the ordered list of interceptor info for a particularcallback event type.this listinclude the infoon any bean class callback.if present, this would always be thelast element in the list because of the precedence defined by the spec.",
	"Method": "List<InterceptorDescriptor> getCallbackInterceptors(CallbackType type){\r\n    LinkedList<InterceptorDescriptor> callbackInterceptors = new LinkedList<InterceptorDescriptor>();\r\n    for (InterceptorDescriptor next : classInterceptorChain) {\r\n        if (next.getCallbackDescriptors(type).size() > 0) {\r\n            callbackInterceptors.add(next);\r\n        }\r\n    }\r\n    if (this.hasCallbackDescriptor(type)) {\r\n        InterceptorDescriptor beanClassCallbackInfo = new InterceptorDescriptor();\r\n        beanClassCallbackInfo.setFromBeanClass(true);\r\n        beanClassCallbackInfo.addCallbackDescriptors(type, this.getCallbackDescriptors(type));\r\n        beanClassCallbackInfo.setInterceptorClassName(getBeanClassName());\r\n        callbackInterceptors.add(beanClassCallbackInfo);\r\n    }\r\n    return callbackInterceptors;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.Statement.generateColumnText",
	"Comment": "generates the column text for field desc.the column has to be associated to the corresponding query tablefrom the list tablelist.for fields mapped to multiple columns choose one column to be included,as all mapped columns should have the same value.",
	"Method": "void generateColumnText(LocalFieldDesc desc,QueryPlan thePlan,StringBuffer sb){\r\n    QueryTable table = null;\r\n    ColumnElement column = null;\r\n    Iterator iter = desc.getColumnElements();\r\n    while (iter.hasNext() && table == null) {\r\n        column = (ColumnElement) iter.next();\r\n        if (action == QueryPlan.ACT_SELECT) {\r\n            table = thePlan.findQueryTable(column.getDeclaringTable());\r\n        } else {\r\n            table = findQueryTable(column.getDeclaringTable());\r\n        }\r\n    }\r\n    if (table == null) {\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"core.configuration.fieldnotable\", desc.getName()));\r\n    }\r\n    if (action == QueryPlan.ACT_SELECT) {\r\n        sb.append(\"t\").append(table.getTableIndex()).append(\".\");\r\n    }\r\n    appendQuotedText(sb, column.getName().getName());\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ServiceReferenceDescriptor.removeCallProperty",
	"Comment": "remove call property, using property name as a key. this willremove the property value of an existing stub property withthe matching name.",
	"Method": "void removeCallProperty(NameValuePairDescriptor property){\r\n    NameValuePairDescriptor prop = getCallPropertyByName(property.getName());\r\n    if (prop != null) {\r\n        callProperties.remove(property);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.EJBQLException.getCause",
	"Comment": "returns the cause of this ejbqlexception or null if the cause is nonexistent or unknown.",
	"Method": "Throwable getCause(){\r\n    return cause;\r\n}"
}, {
	"Path": "org.glassfish.ejb.embedded.EJBContainerProviderImpl.addModules",
	"Comment": "adds ejb modules for the property in the properties map or if such propertyis not specified, from the system classpath. also adds library references.",
	"Method": "Set<DeploymentElement> addModules(Map<?, ?> properties,Locations l){\r\n    Set<DeploymentElement> modules = new HashSet<DeploymentElement>();\r\n    Object obj = (properties == null) ? null : properties.get(EJBContainer.MODULES);\r\n    boolean skip_module_with_main_class = getBooleanProperty(properties, SKIP_CLIENT_MODULES);\r\n    Map<String, Boolean> moduleNames = new HashMap<String, Boolean>();\r\n    if (obj != null) {\r\n        if (obj instanceof String) {\r\n            moduleNames.put((String) obj, false);\r\n        } else if (obj instanceof String[]) {\r\n            String[] arr = (String[]) obj;\r\n            for (String s : arr) {\r\n                moduleNames.put(s, false);\r\n            }\r\n        } else if (obj instanceof File) {\r\n            addModule(l, modules, moduleNames, (File) obj);\r\n        } else if (obj instanceof File[]) {\r\n            File[] arr = (File[]) obj;\r\n            for (File f : arr) {\r\n                addModule(l, modules, moduleNames, f);\r\n            }\r\n        }\r\n    }\r\n    if (modules.isEmpty()) {\r\n        String path = System.getProperty(\"java.class.path\");\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.fine(\"[EJBContainerProviderImpl] Looking for EJB modules in classpath: \" + path);\r\n        }\r\n        String[] entries = path.split(File.pathSeparator);\r\n        for (String s0 : entries) {\r\n            addModule(l, modules, moduleNames, new File(s0), skip_module_with_main_class);\r\n        }\r\n        if (!moduleNames.isEmpty()) {\r\n            StringBuffer sb = new StringBuffer();\r\n            for (Map.Entry<String, Boolean> entry : moduleNames.entrySet()) {\r\n                if (!entry.getValue()) {\r\n                    sb.append(entry.getKey()).append(\", \");\r\n                }\r\n            }\r\n            int ln = sb.length();\r\n            if (ln > 0) {\r\n                throw new EJBException(\"Modules: [\" + sb.substring(0, ln - 2) + \"] do not match an entry in the classpath\");\r\n            }\r\n        }\r\n    }\r\n    return modules;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ActiveResourceAdapterImpl.setup",
	"Comment": "it initializes the resource adapter. it also creates the default poolsand resources of all the connection definitions.",
	"Method": "void setup(){\r\n    if (connectionDefs_ == null || connectionDefs_.length != 1) {\r\n        _logger.log(Level.SEVERE, \"rardeployment.invalid_connector_desc\", moduleName_);\r\n        String i18nMsg = localStrings.getString(\"ccp_adm.invalid_connector_desc\", moduleName_);\r\n        throw new ConnectorRuntimeException(i18nMsg);\r\n    }\r\n    if (isServer() && !isSystemRar(moduleName_)) {\r\n        createAllConnectorResources();\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"Completed Active Resource adapter setup\", moduleName_);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.persistence.jpa.schemageneration.EclipseLinkSchemaGenerationProcessor.getPersistencePropVal",
	"Comment": "given a persistence unit descriptorreturn the value of a property if theuser has specified it.if the user has not defined this propertyreturn the default value.",
	"Method": "String getPersistencePropVal(PersistenceUnitDescriptor parBundle,String propertyName,String defaultValue){\r\n    return parBundle.getProperties().getProperty(propertyName, defaultValue);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.getTransactionalInstance",
	"Comment": "this method is used to get a persistencecapable instancerepresenting the same data store object as the parameter, that is validfor this persistencemanager.",
	"Method": "Object getTransactionalInstance(Object pc){\r\n    assertIsOpen();\r\n    assertActiveTransaction(false);\r\n    if (!(pc instanceof PersistenceCapable)) {\r\n        return pc;\r\n    }\r\n    PersistenceCapable mypc = (PersistenceCapable) pc;\r\n    PersistenceManagerWrapper pmw = (PersistenceManagerWrapper) mypc.jdoGetPersistenceManager();\r\n    PersistenceManagerImpl pm = (PersistenceManagerImpl) pmw.getPersistenceManager();\r\n    if (pm == null || pm == this) {\r\n        return pc;\r\n    }\r\n    return getObjectById(pm.internalGetObjectId(mypc.jdoGetStateManager()));\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionMetaDataImpl.getEISProductVersion",
	"Comment": "returns product version of the underlying eis instance connectedthrough the managedconnection.",
	"Method": "String getEISProductVersion(){\r\n    try {\r\n        return dmd.getDatabaseProductVersion();\r\n    } catch (SQLException sqle) {\r\n        _logger.log(Level.SEVERE, \"jdbc.exc_eis_prodvers\", sqle);\r\n        throw new ResourceException(sqle.getMessage(), sqle.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.getResourceEnvReferenceByName",
	"Comment": "return a reference to another ejb by the same name or throw an illegalargumentexception.",
	"Method": "ResourceEnvReferenceDescriptor getResourceEnvReferenceByName(String name){\r\n    for (Iterator itr = this.getResourceEnvReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        ResourceEnvReferenceDescriptor jdr = (ResourceEnvReferenceDescriptor) itr.next();\r\n        if (jdr.getName().equals(name)) {\r\n            return jdr;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionapphasnoresourceenvrefbyname\", \"This app {0} has no resource environment reference by the name of {1}\", new Object[] { getRegistrationName(), name }));\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.handlers.EntityManagerReferenceHandler.getEmReferenceDescriptors",
	"Comment": "return entitymanagerreferencedescriptors with given name if exists or a new one without name being set.",
	"Method": "EntityManagerReferenceDescriptor[] getEmReferenceDescriptors(String logicalName,ResourceContainerContext[] rcContexts){\r\n    EntityManagerReferenceDescriptor[] emRefs = new EntityManagerReferenceDescriptor[rcContexts.length];\r\n    for (int i = 0; i < rcContexts.length; i++) {\r\n        EntityManagerReferenceDescriptor emRef = (EntityManagerReferenceDescriptor) rcContexts[i].getEntityManagerReference(logicalName);\r\n        if (emRef == null) {\r\n            emRef = new EntityManagerReferenceDescriptor();\r\n            rcContexts[i].addEntityManagerReferenceDescriptor(emRef);\r\n        }\r\n        emRefs[i] = emRef;\r\n    }\r\n    return emRefs;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.DBElementFactory.createAndAttachForeignKey",
	"Comment": "create foreign key between declaring table and reference table withrelationship name.",
	"Method": "ForeignKeyElement createAndAttachForeignKey(TableElement declaringTbl,TableElement refTbl,String keyName,MappingPolicy mappingPolicy,String uniqueId){\r\n    String fkeyName = mappingPolicy.getConstraintName(keyName, uniqueId);\r\n    TableElementImpl tableImpl = (TableElementImpl) declaringTbl.getElementImpl();\r\n    ForeignKeyElementImpl fkeyImpl = new ForeignKeyElementImpl(tableImpl, fkeyName);\r\n    ForeignKeyElement fkey = new ForeignKeyElement(fkeyImpl, declaringTbl);\r\n    UniqueKeyElement pk = refTbl.getPrimaryKey();\r\n    ColumnElement[] pkColumns = pk.getColumns();\r\n    String refTblName = refTbl.getName().getName();\r\n    if (pkColumns != null) {\r\n        for (int i = 0; i < pkColumns.length; i++) {\r\n            ColumnElement refColumn = pkColumns[i];\r\n            String columnName = mappingPolicy.getConstraintColumnName(refTblName, refColumn.getName().getName());\r\n            JDBCInfo ji = new JDBCInfo(refColumn.getType(), refColumn.getPrecision(), refColumn.getScale(), refColumn.getLength(), true);\r\n            ColumnElement column = createAndAttachColumn(columnName, declaringTbl, ji);\r\n            ColumnPairElement pair = createColumnPair(column, refColumn, declaringTbl);\r\n            fkey.addColumnPair(pair);\r\n        }\r\n    }\r\n    declaringTbl.addKey(fkey);\r\n    return fkey;\r\n}"
}, {
	"Path": "com.sun.ejb.EjbInvocation.setParameters",
	"Comment": "set the parameters that will be used to invoke the business method.",
	"Method": "void setParameters(Object[] params){\r\n    InterceptorUtil.checkSetParameters(params, getMethod());\r\n    this.methodParams = params;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsAlterTableWithAddColumn",
	"Comment": "retrieves whether this database supports alter tablewith add column.",
	"Method": "boolean supportsAlterTableWithAddColumn(){\r\n    return databaseMetaData.supportsAlterTableWithAddColumn();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.ConnectorClassLoader.getInstance",
	"Comment": "initializes this singleton with the given parent class loaderif not already created.",
	"Method": "ConnectorClassLoader getInstance(ConnectorClassLoader getInstance,ClassLoader parent){\r\n    if (classLoader == null) {\r\n        synchronized (ConnectorClassLoader.class) {\r\n            if (classLoader == null) {\r\n                classLoader = AccessController.doPrivileged(new PrivilegedAction<ConnectorClassLoader>() {\r\n                    public ConnectorClassLoader run() {\r\n                        return new ConnectorClassLoader(parent);\r\n                    }\r\n                });\r\n            }\r\n        }\r\n    }\r\n    return classLoader;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.ConnectorClassLoader.getInstance",
	"Comment": "initializes this singleton with the given parent class loaderif not already created.",
	"Method": "ConnectorClassLoader getInstance(ConnectorClassLoader getInstance,ClassLoader parent){\r\n    return new ConnectorClassLoader(parent);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlDate.setYear",
	"Comment": "sets the year of this sqldate object to be the specifiedvalue plus 1900.",
	"Method": "void setYear(int year){\r\n    this.makeDirty();\r\n    super.setYear(year);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxProcedureNameLength",
	"Comment": "retrieves the maximum number of characters that this database allows in aprocedure name.",
	"Method": "int getMaxProcedureNameLength(){\r\n    return databaseMetaData.getMaxProcedureNameLength();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.deleteRelationships",
	"Comment": "prepares the current instance for delete by nullifying allrelationships. the deletion is propagated to relationshipfields marked for cascade delete.",
	"Method": "void deleteRelationships(){\r\n    ArrayList foreignFields = persistenceConfig.foreignFields;\r\n    int size = foreignFields.size();\r\n    stateFlags |= ST_DELETE_INPROGRESS;\r\n    for (int i = 0; i < size; i++) {\r\n        ForeignFieldDesc ff = (ForeignFieldDesc) foreignFields.get(i);\r\n        ForeignFieldDesc irf = ff.getInverseRelationshipField();\r\n        if ((ff.sqlProperties & FieldDesc.PROP_SECONDARY_TRACKED_FIELD) > 0) {\r\n            continue;\r\n        }\r\n        if ((ff.deleteAction != ForeignFieldDesc.ACT_CASCADE) && (irf == null)) {\r\n            continue;\r\n        }\r\n        prepareUpdateField(ff, null);\r\n        if (ff.cardinalityUPB > 1) {\r\n            Collection c = (Collection) ff.getValue(this);\r\n            if (c != null) {\r\n                ArrayList removed = new ArrayList(c);\r\n                processCollectionUpdates(ff, removed, null, null, true, false);\r\n                if (c instanceof SCOCollection) {\r\n                    ((SCOCollection) c).clearInternal();\r\n                } else {\r\n                    c.clear();\r\n                }\r\n                if (ff.deleteAction == ForeignFieldDesc.ACT_CASCADE) {\r\n                    Iterator iter = removed.iterator();\r\n                    while (iter.hasNext()) {\r\n                        Object obj = iter.next();\r\n                        if (obj != null) {\r\n                            SQLStateManager sm = (SQLStateManager) persistenceManager.getStateManager(obj);\r\n                            if ((sm != null) && !sm.isDeleted() && ((sm.stateFlags & ST_DELETE_INPROGRESS) == 0)) {\r\n                                try {\r\n                                    persistenceManager.deletePersistent(obj);\r\n                                } catch (Throwable e) {\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            Object obj = ff.getValue(this);\r\n            if (obj != null) {\r\n                updateObjectField(ff, null, true, false);\r\n                ff.setValue(this, null);\r\n                if (ff.deleteAction == ForeignFieldDesc.ACT_CASCADE) {\r\n                    SQLStateManager sm = (SQLStateManager) persistenceManager.getStateManager(obj);\r\n                    if ((sm != null) && !sm.isDeleted() && ((sm.stateFlags & ST_DELETE_INPROGRESS) == 0)) {\r\n                        try {\r\n                            persistenceManager.deletePersistent(obj);\r\n                        } catch (Throwable e) {\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    stateFlags &= ~ST_DELETE_INPROGRESS;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.ConnectorDDTransformUtils.mergeProps",
	"Comment": "merges the properties mentioned in first parameter with the set ofproperties mentioned in second parameter.values of first parameter takes precedence over second.first parameter represents properties present in domain.xmlsecond parameter contains values mentioned in deployment descriptors.",
	"Method": "Set mergeProps(List<Property> props,Set defaultMCFProps,Properties propertiesToSkip,Set mergeProps,List<Property> props,Set defaultMCFProps){\r\n    return mergeProps(props, defaultMCFProps, new Properties());\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.SaxParserHandler.resolvePublicID",
	"Comment": "determine whether the publicid starts with a known proprietary value.if so, strip off that value and return the rest.otherwise, return null",
	"Method": "String resolvePublicID(String publicID,String dtd){\r\n    List<String> dtdStarts = DOLUtils.getProprietaryDTDStart();\r\n    for (int n = 0; n < dtdStarts.size(); ++n) {\r\n        String dtdStart = dtdStarts.get(n);\r\n        if (dtd.startsWith(dtdStart)) {\r\n            return dtd.substring(dtdStart.length());\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.jqlc.ParameterTable.isCompatibleValue",
	"Comment": "checks whether the type of the specified value is compatible with thespecified formal type.",
	"Method": "boolean isCompatibleValue(Class formalType,Object value){\r\n    boolean isCompatible = true;\r\n    if (value == null) {\r\n        isCompatible = !formalType.isPrimitive();\r\n    } else {\r\n        Class actualType = value.getClass();\r\n        if (formalType.isPrimitive())\r\n            formalType = JavaTypeHelper.getWrapperClass(formalType);\r\n        isCompatible = formalType.isAssignableFrom(actualType);\r\n    }\r\n    return isCompatible;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.getTransactionIsolationInt",
	"Comment": "gets the integer equivalent of the string specifyingthe transaction isolation.",
	"Method": "int getTransactionIsolationInt(String tranIsolation){\r\n    if (tranIsolation.equalsIgnoreCase(\"read-uncommitted\")) {\r\n        return java.sql.Connection.TRANSACTION_READ_UNCOMMITTED;\r\n    } else if (tranIsolation.equalsIgnoreCase(\"read-committed\")) {\r\n        return java.sql.Connection.TRANSACTION_READ_COMMITTED;\r\n    } else if (tranIsolation.equalsIgnoreCase(\"repeatable-read\")) {\r\n        return java.sql.Connection.TRANSACTION_REPEATABLE_READ;\r\n    } else if (tranIsolation.equalsIgnoreCase(\"serializable\")) {\r\n        return java.sql.Connection.TRANSACTION_SERIALIZABLE;\r\n    } else {\r\n        throw new ResourceException(\"Invalid transaction isolation; the transaction \" + \"isolation level can be empty or any of the following: \" + \"read-uncommitted, read-committed, repeatable-read, serializable\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.dataDefinitionCausesTransactionCommit",
	"Comment": "retrieves whether a data definition statement within a transaction forcesthe transaction to commit.",
	"Method": "boolean dataDefinitionCausesTransactionCommit(){\r\n    return databaseMetaData.dataDefinitionCausesTransactionCommit();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getTypesForNames",
	"Comment": "converts the array of type names into an array of class objects.",
	"Method": "Class[] getTypesForNames(String[] typeNames){\r\n    Class[] classes = new Class[typeNames.length];\r\n    for (int i = 0; i < classes.length; i++) classes[i] = getTypeForName(typeNames[i]);\r\n    return classes;\r\n}"
}, {
	"Path": "org.glassfish.concurrent.admin.DeleteManagedScheduledExecutorService.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        ResourceStatus rs = managedScheduledExecutorServiceMgr.delete(domain.getResources(), jndiName, target);\r\n        if (rs.getMessage() != null) {\r\n            report.setMessage(rs.getMessage());\r\n        }\r\n        if (rs.getStatus() == ResourceStatus.SUCCESS) {\r\n            report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n        } else {\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            if (rs.getException() != null)\r\n                report.setFailureCause(rs.getException());\r\n        }\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.managed.scheduled.executor.service.failed\", \"Managed scheduled executor service {0} deletion failed\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.security.application.EJBSecurityManager.getCallerPrincipal",
	"Comment": "this method returns the client principal who initiated the currentinvocation.",
	"Method": "Principal getCallerPrincipal(){\r\n    SecurityContext sc = null;\r\n    if (runAs != null) {\r\n        ComponentInvocation ci = invMgr.getCurrentInvocation();\r\n        if (ci == null) {\r\n            throw new InvocationException();\r\n        }\r\n        sc = (SecurityContext) ci.getOldSecurityContext();\r\n    } else {\r\n        sc = SecurityContext.getCurrent();\r\n    }\r\n    Principal prin;\r\n    if (sc != null) {\r\n        prin = sc.getCallerPrincipal();\r\n    } else {\r\n        prin = SecurityContext.getDefaultCallerPrincipal();\r\n    }\r\n    return prin;\r\n}"
}, {
	"Path": "com.sun.gjc.util.SQLTrace.equals",
	"Comment": "check for equality of the sqltrace with the object passed bycomparing the queryname stored.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == null) {\r\n        return false;\r\n    }\r\n    if (!(obj instanceof SQLTrace)) {\r\n        return false;\r\n    }\r\n    final SQLTrace other = (SQLTrace) obj;\r\n    if ((this.queryName == null) || (other.queryName == null) || !this.queryName.equals(other.queryName)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.isPositionSearchSource",
	"Comment": "returns true if first position argument is search string and secondargument is source string for this database",
	"Method": "boolean isPositionSearchSource(){\r\n    String s = (String) dbMap.get(POSITION_SEARCH_SOURCE);\r\n    Boolean b = Boolean.valueOf(s);\r\n    if (logger.isLoggable()) {\r\n        logger.fine(\"sqlstore.database.dbvendor.getpositionsrchsrc\", b);\r\n    }\r\n    return b.booleanValue();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MailConfiguration.loadMailResources",
	"Comment": "load all configuration information from the mail resource node indomain.xml for the javamail session object within java ee.",
	"Method": "void loadMailResources(MailResourceIntf mailResource){\r\n    if (mailResource == null) {\r\n        _logger.log(Level.FINE, \"MailConfiguration: no MailResource object. mailResource=null\");\r\n        return;\r\n    }\r\n    jndiName = mailResource.getName();\r\n    description = mailResource.getDescription();\r\n    enabled = mailResource.isEnabled();\r\n    storeProtocol = mailResource.getStoreProtocol();\r\n    storeProtocolClass = mailResource.getStoreProtocolClass();\r\n    transportProtocol = mailResource.getTransportProtocol();\r\n    transportProtocolClass = mailResource.getTransportProtocolClass();\r\n    mailHost = mailResource.getMailHost();\r\n    username = mailResource.getUsername();\r\n    mailFrom = mailResource.getMailFrom();\r\n    debug = mailResource.isDebug();\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"storeProtocol \" + storeProtocol);\r\n        _logger.fine(\"storeProtocolClass \" + storeProtocolClass);\r\n        _logger.fine(\"transportProtocol \" + transportProtocol);\r\n        _logger.fine(\"transportProtocolClass \" + transportProtocolClass);\r\n        _logger.fine(\"mailHost \" + mailHost);\r\n        _logger.fine(\"username \" + username);\r\n        _logger.fine(\"mailFrom \" + mailFrom);\r\n        _logger.fine(\"debug \" + debug);\r\n    }\r\n    if (transportProtocol == null)\r\n        transportProtocol = \"smtp\";\r\n    put(MAIL_HOST, mailHost);\r\n    put(MAIL_USER, username);\r\n    put(MAIL_STORE_PROTOCOL, storeProtocol);\r\n    put(MAIL_TRANSPORT_PROTOCOL, transportProtocol);\r\n    if (storeProtocol != null)\r\n        put(MAIL_PREFIX + storeProtocol + MAIL_SUFFIX_CLASS, storeProtocolClass);\r\n    if (transportProtocol != null)\r\n        put(MAIL_PREFIX + transportProtocol + MAIL_SUFFIX_CLASS, transportProtocolClass);\r\n    put(MAIL_FROM, mailFrom);\r\n    put(MAIL_DEBUG, (debug ? \"true\" : \"false\"));\r\n    Set properties = mailResource.getProperties();\r\n    for (Iterator it = properties.iterator(); it.hasNext(); ) {\r\n        ResourceProperty property = (ResourceProperty) it.next();\r\n        String name = property.getName();\r\n        String value = (String) property.getValue();\r\n        if (name.startsWith(PROP_NAME_PREFIX_LEGACY))\r\n            name = name.replace(PROP_NAME_DELIM_LEGACY, MAIL_DELIM);\r\n        put(name, value);\r\n        if (_logger.isLoggable(Level.FINE))\r\n            _logger.fine(\"mail property: \" + name + \" = \" + value);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.logging.LoggerFactoryJDK13.createLogger",
	"Comment": "create a new logger.subclasses are responsible for creating a \tlogger for the named component.the bundle name and class loader \tare passed to allow the implementation to properly find and \tconstruct the internationalization bundle.",
	"Method": "Logger createLogger(String absoluteLoggerName,String bundleName,ClassLoader loader){\r\n    return new LoggerJDK13(absoluteLoggerName, bundleName, loader);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.WebServicesDescriptor.getEndpointByName",
	"Comment": "endpoint has a unique name within all the endpoints in the module.",
	"Method": "WebServiceEndpoint getEndpointByName(String endpointName){\r\n    for (Iterator iter = getEndpoints().iterator(); iter.hasNext(); ) {\r\n        WebServiceEndpoint next = (WebServiceEndpoint) iter.next();\r\n        if (next.getEndpointName().equals(endpointName)) {\r\n            return next;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.StatementWrapper.getMaxFieldSize",
	"Comment": "retrieves the maximum number of bytes that can bereturned for character and binary column values in a resultsetobject produced by this statement object.this limit applies only to binary,varbinary, longvarbinary, char,varchar, and longvarcharcolumns.if the limit is exceeded, the excess data is silentlydiscarded.",
	"Method": "int getMaxFieldSize(){\r\n    return jdbcStatement.getMaxFieldSize();\r\n}"
}, {
	"Path": "com.sun.gjc.util.StatementLeakDetector.clearAllStatementLeakTasks",
	"Comment": "clear all statement leak tracing tasks in case of statement leaktracing being turned off",
	"Method": "void clearAllStatementLeakTasks(){\r\n    synchronized (statementLeakLock) {\r\n        Iterator<Map.Entry<Statement, StatementLeakTask>> entryIterator = statementLeakTimerTaskHashMap.entrySet().iterator();\r\n        while (entryIterator.hasNext()) {\r\n            Map.Entry<Statement, StatementLeakTask> entry = entryIterator.next();\r\n            StatementLeakTask statementLeakTask = entry.getValue();\r\n            statementLeakTask.cancel();\r\n        }\r\n        if (timer != null)\r\n            timer.purge();\r\n        statementLeakThreadStackHashMap.clear();\r\n        statementLeakTimerTaskHashMap.clear();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.MappingPolicy.getOverrideForNullability",
	"Comment": "provides a string that can be recognized as a policy to override thedefault nullability of a field.",
	"Method": "String getOverrideForNullability(String className,String fieldName){\r\n    return className + DOT + fieldName + DOT + DatabaseGenerationConstants.INDICATOR_JDBC_NULLABLE;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.ConnectionPool.matchConnection",
	"Comment": "check whether the connection retrieved from the pool matches with the request.",
	"Method": "boolean matchConnection(ResourceHandle resource,ResourceAllocator alloc){\r\n    boolean matched = true;\r\n    if (matchConnections) {\r\n        matched = alloc.matchConnection(resource);\r\n        if (poolLifeCycleListener != null) {\r\n            if (matched) {\r\n                poolLifeCycleListener.connectionMatched();\r\n            } else {\r\n                poolLifeCycleListener.connectionNotMatched();\r\n            }\r\n        }\r\n    }\r\n    return matched;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.tree.ListTreeAdaptor.getChildTreeNodeObjects",
	"Comment": "returns child treenodes for the given \ttreenode model object.",
	"Method": "List getChildTreeNodeObjects(Object nodeObject){\r\n    if (nodeObject == null) {\r\n        return null;\r\n    }\r\n    if ((nodeObject instanceof Integer) && nodeObject.equals(TOP_ID)) {\r\n        if (_children != null) {\r\n            return _children;\r\n        }\r\n        FacesContext ctx = FacesContext.getCurrentInstance();\r\n        LayoutComponent desc = getLayoutComponent();\r\n        Object val = desc.getOption(\"children\");\r\n        if (val == null) {\r\n            throw new IllegalArgumentException(\"'children' must be specified!\");\r\n        }\r\n        val = desc.resolveValue(ctx, getParentUIComponent(), val.toString());\r\n        if ((val != null) && (val instanceof Map)) {\r\n            _childMap = (Map<String, Object>) val;\r\n            val = new ArrayList<Object>(_childMap.keySet());\r\n            Collections.sort((List) val);\r\n        }\r\n        _children = (List<Object>) val;\r\n        Object retVal = getLayoutComponent().dispatchHandlers(ctx, FilterTreeEvent.EVENT_TYPE, new FilterTreeEvent(getParentUIComponent(), _children));\r\n        if ((retVal != null) && (retVal instanceof List)) {\r\n            _children = (List<Object>) retVal;\r\n        }\r\n    } else {\r\n        return null;\r\n    }\r\n    return _children;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnUtils.doubleConstant",
	"Comment": "return the best instruction for loading the specified double constant ontothe stack.",
	"Method": "Insn doubleConstant(double d,ConstantPool pool){\r\n    if (d == 0)\r\n        return Insn.create(opc_dconst_0);\r\n    else if (d == 1)\r\n        return Insn.create(opc_dconst_1);\r\n    else\r\n        return Insn.create(opc_ldc2_w, pool.addDouble(d));\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.ExtensionsArchivist.writeRuntimeDeploymentDescriptors",
	"Comment": "writes the runtime deployment descriptors to an abstract archive",
	"Method": "void writeRuntimeDeploymentDescriptors(Archivist main,BundleDescriptor descriptor,ReadableArchive in,WritableArchive out){\r\n    List<ConfigurationDeploymentDescriptorFile> confDDFilesToWrite = getSortedConfigurationDDFiles(descriptor, in, main.getModuleType());\r\n    if (confDDFilesToWrite.isEmpty()) {\r\n        confDDFilesToWrite = getConfigurationDDFiles(descriptor);\r\n    }\r\n    for (ConfigurationDeploymentDescriptorFile ddFile : confDDFilesToWrite) {\r\n        ddFile.setArchiveType(main.getModuleType());\r\n        OutputStream os = out.putNextEntry(ddFile.getDeploymentDescriptorPath());\r\n        ddFile.write(descriptor, os);\r\n        out.closeEntry();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnectionFactory.isValid",
	"Comment": "checks if a managedconnection is to be validated or notand validates it or returns.",
	"Method": "void isValid(com.sun.jdbcra.spi.ManagedConnection mc){\r\n    if (mc.isTransactionInProgress()) {\r\n        return;\r\n    }\r\n    boolean connectionValidationRequired = (new Boolean(spec.getDetail(DataSourceSpec.CONNECTIONVALIDATIONREQUIRED).toLowerCase())).booleanValue();\r\n    if (connectionValidationRequired == false || mc == null) {\r\n        return;\r\n    }\r\n    String validationMethod = spec.getDetail(DataSourceSpec.VALIDATIONMETHOD).toLowerCase();\r\n    mc.checkIfValid();\r\n    java.sql.Connection con = mc.getActualConnection();\r\n    if (validationMethod.equals(\"auto-commit\") == true) {\r\n        isValidByAutoCommit(con);\r\n    } else if (validationMethod.equalsIgnoreCase(\"meta-data\") == true) {\r\n        isValidByMetaData(con);\r\n    } else if (validationMethod.equalsIgnoreCase(\"table\") == true) {\r\n        isValidByTableQuery(con, spec.getDetail(DataSourceSpec.VALIDATIONTABLENAME));\r\n    } else {\r\n        throw new ResourceException(\"The validation method is not proper\");\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.ACCModulesManager.prepareHabitat",
	"Comment": "sets up the hk2 habitat.must be invoked at least once before an appclientcontainerbuilderreturns a new appclientcontainer to the caller.",
	"Method": "ServiceLocator prepareHabitat(ClassLoader loader){\r\n    ServiceLocator serviceLocator = ServiceLocatorFactory.getInstance().create(\"default\");\r\n    habitat = serviceLocator;\r\n    ContextDuplicatePostProcessor duplicateProcessor = new ContextDuplicatePostProcessor();\r\n    List<PopulatorPostProcessor> postProcessors = new LinkedList<PopulatorPostProcessor>();\r\n    postProcessors.add(duplicateProcessor);\r\n    try {\r\n        HK2Populator.populate(serviceLocator, new ClasspathDescriptorFileFinder(loader), postProcessors);\r\n    } catch (IOException e) {\r\n        e.printStackTrace();\r\n    }\r\n    return habitat;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsMultipleOpenResults",
	"Comment": "retrieves whether it is possible to have multiple resultset objectsreturned from a callablestatement objectsimultaneously.",
	"Method": "boolean supportsMultipleOpenResults(){\r\n    return databaseMetaData.supportsMultipleOpenResults();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.generator.io.IOJavaClassWriter.setClassDeclaration",
	"Comment": "sets the information for the class declaration including modifiers,\tname, and comments.note that the name must not be fully qualified.",
	"Method": "void setClassDeclaration(int modifiers,String className,String[] comments){\r\n    final FormattedWriter writerHelper = new FormattedWriter();\r\n    final String modifierString = Modifier.toString(modifiers);\r\n    writerHelper.writeComments(comments);\r\n    writerHelper.writeln(modifierString + ((modifierString.length() > 0) ? \" \" : \"\") + \"class \" + className);\r\n    _classDeclarationBlock = writerHelper.toString();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.EJBHashSet.iterator",
	"Comment": "returns an iterator over the elements in this set.the elementsare returned in no particular order.",
	"Method": "Iterator iterator(){\r\n    assertIsValid();\r\n    assertInTransaction();\r\n    return new EJBHashIterator();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.ArrayList.set",
	"Comment": "replaces the element at the specified position in this arraylist with thespecified element.",
	"Method": "Object set(int index,Object element){\r\n    throwUnsupportedOption();\r\n    if (element == null) {\r\n        if (allowNulls == false) {\r\n            throw new JDOUserException(// NOI18N\r\n            I18NHelper.getMessage(messages, \"sco.nulls_not_allowed\"));\r\n        }\r\n        return this.remove(index);\r\n    }\r\n    if (elementType == null || elementType.isAssignableFrom(element.getClass())) {\r\n        StateManager stateManager = this.makeDirty();\r\n        Object o = super.set(index, element);\r\n        if (added.remove(o) == false)\r\n            removed.add(o);\r\n        if (removed.remove(element) == false)\r\n            added.add(element);\r\n        this.applyUpdates(stateManager, true);\r\n        return o;\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        messages, \"sco.classcastexception\", elementType.getName()), new ClassCastException(), new Object[] { element });\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ResourceAdapter.getXAResources",
	"Comment": "empty method implementation for getxaresourceswhich just throws notsupportedexception",
	"Method": "XAResource[] getXAResources(ActivationSpec[] specs){\r\n    throw new NotSupportedException(\"This method is not supported for this JDBC connector\");\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.codegen.CMPDeployerImpl.clean",
	"Comment": "integration point for cleanup on undeploy or failed deploy.",
	"Method": "void clean(DeploymentContext ctx){\r\n    CMPProcessor processor = new CMPProcessor(ctx);\r\n    processor.clean();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.web.integration.WebSecurityManager.getContextID",
	"Comment": "used to get the policy context id. also used by the realmadapter",
	"Method": "String getContextID(WebBundleDescriptor wbd){\r\n    return SecurityUtil.getContextID(wbd);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.support.JDOHelper.makeDirty",
	"Comment": "explicitly marks a field of an object as dirty if the object ispersistent and transactional.normally, persistencecapable classes are able to detect changes madeto their fields.however, if a reference to an array is given to amethod outside the class, and the array is modified, then thepersistent object is not aware of the change.this method allows theapplication to notify the object that a change was made to a field.for transient objects, this method does nothing.",
	"Method": "void makeDirty(Object obj,String fieldName){\r\n    if (obj instanceof PersistenceCapable)\r\n        ((PersistenceCapable) obj).jdoMakeDirty(fieldName);\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.ListConnectorWorkSecurityMaps.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    final ActionReport.MessagePart mp = report.getTopMessagePart();\r\n    try {\r\n        boolean foundWSM = false;\r\n        Collection<WorkSecurityMap> workSecurityMaps = domain.getResources().getResources(WorkSecurityMap.class);\r\n        for (WorkSecurityMap wsm : workSecurityMaps) {\r\n            if (wsm.getResourceAdapterName().equals(raName)) {\r\n                if (securityMap == null) {\r\n                    listWorkSecurityMap(wsm, mp);\r\n                    foundWSM = true;\r\n                } else if (wsm.getName().equals(securityMap)) {\r\n                    listWorkSecurityMap(wsm, mp);\r\n                    foundWSM = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (!foundWSM) {\r\n            report.setMessage(localStrings.getLocalString(\"list.connector.work.security.maps.workSecurityMapNotFound\", \"Nothing to list. Either the resource adapter {0} does not exist or the\" + \"resource adapter {0} is not associated with any work security map.\", raName));\r\n        }\r\n    } catch (Exception e) {\r\n        Logger.getLogger(ListConnectorWorkSecurityMaps.class.getName()).log(Level.SEVERE, \"list-connector-work-security-maps failed\", e);\r\n        report.setMessage(localStrings.getLocalString(\"\" + \"list.connector.work.security.maps.fail\", \"Unable to list connector work security map {0} for resource adapter {1}\", securityMap, raName) + \" \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.admin.mejb.IIOPMBeanServerImpl.isRegistered",
	"Comment": "checks whether an mbean, identified by its object name, is already registered with the mbean server.",
	"Method": "boolean isRegistered(ObjectName name){\r\n    return server.isRegistered(name);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getResourceReferenceByName",
	"Comment": "return the resource object corresponding to the supplied name orthrow an illegal argument exception.",
	"Method": "ResourceReferenceDescriptor getResourceReferenceByName(String name){\r\n    for (Iterator itr = getResourceReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        ResourceReferenceDescriptor next = (ResourceReferenceDescriptor) itr.next();\r\n        if (next.getName().equals(name)) {\r\n            return next;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionbeanhasnoresourcerefbyname\", \"This bean {0} has no resource reference by the name of {1}\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.TypeTable.isFloatingPointType",
	"Comment": "returns true if type is a floating point type or a java wrapperclass type wrapping a floating point integral type.",
	"Method": "boolean isFloatingPointType(Type type){\r\n    if (type instanceof FloatingPointType)\r\n        return true;\r\n    else if (type instanceof NumericWrapperClassType)\r\n        return ((NumericWrapperClassType) type).getPrimitiveType() instanceof FloatingPointType;\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.stats.BoundedRangeStatisticImpl.getUpperBound",
	"Comment": "returns the highest possible value, that this statistic is permitted to attain.",
	"Method": "long getUpperBound(){\r\n    return upperBound;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.Statement.getWhereText",
	"Comment": "constructs the where clause for the statement fromthe constraint stack.",
	"Method": "String getWhereText(List stack){\r\n    StringBuffer result = new StringBuffer();\r\n    ConstraintNode node;\r\n    if (stack.size() == 0) {\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"core.constraint.stackempty\"));\r\n    }\r\n    node = (ConstraintNode) stack.get(stack.size() - 1);\r\n    stack.remove(stack.size() - 1);\r\n    if (node instanceof ConstraintParamIndex) {\r\n        processConstraintParamIndex((ConstraintParamIndex) node, result);\r\n    } else if (node instanceof ConstraintValue) {\r\n        processConstraintValue((ConstraintValue) node, result);\r\n    } else if (node instanceof ConstraintField) {\r\n        processConstraintField((ConstraintField) node, result);\r\n    } else if (node instanceof ConstraintConstant) {\r\n        result.append(((ConstraintConstant) node).value.toString());\r\n    } else if (node instanceof ConstraintOperation) {\r\n        processConstraintOperation((ConstraintOperation) node, stack, result);\r\n    } else {\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"core.constraint.illegalnode\", node.getClass().getName()));\r\n    }\r\n    return result.toString();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.DoubleLinkedList.removeFromList",
	"Comment": "remove the specified object from anywhere in the linked list.\tthis method is usually used by the object to remove itself\tfrom the list.",
	"Method": "void removeFromList(Linkable node){\r\n    if ((this.size <= 0) || ((this.head == null) && (this.tail == null))) {\r\n        return;\r\n    }\r\n    if (node instanceof Linkable) {\r\n        Linkable p = node.getPrevious();\r\n        Linkable n = node.getNext();\r\n        if (p == null) {\r\n            this.head = n;\r\n        } else {\r\n            p.setNext(n);\r\n        }\r\n        if (n == null) {\r\n            this.tail = p;\r\n        } else {\r\n            n.setPrevious(p);\r\n        }\r\n        node.setNext(null);\r\n        node.setPrevious(null);\r\n        this.size--;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.backup.Status.getInternalTimestamp",
	"Comment": "open the zip file, parse the status file and return the timestampof when it was created.",
	"Method": "long getInternalTimestamp(File f){\r\n    props = null;\r\n    setPropsFromFile(f);\r\n    try {\r\n        String s = props.getProperty(Constants.PROPS_TIMESTAMP_MSEC);\r\n        return Long.parseLong(s);\r\n    } catch (Exception e) {\r\n        LoggerHelper.warning(badStatusFileMessage(f));\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.persistence.jpaconnector.JPACompositeSniffer.supportsArchiveType",
	"Comment": "this api is used to help determine if the sniffer should recognizethe current archive.if the sniffer does not support the archive type associated withthe current deployment, the sniffer should not recognize the archive.",
	"Method": "boolean supportsArchiveType(ArchiveType archiveType){\r\n    if (archiveType.toString().equals(ModuleType.EAR.toString())) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.ActiveJmsResourceAdapter.reloadRA",
	"Comment": "recreates the resourceadapter using new values from jmsserice.",
	"Method": "void reloadRA(JmsService js){\r\n    setMdbContainerProperties();\r\n    setJmsServiceProperties(js);\r\n    super.loadRAConfiguration();\r\n    rebindDescriptor();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jacc.provider.SimplePolicyProvider.getPermissions",
	"Comment": "evaluates the global policy and returns apermissioncollection object specifying the set ofpermissions allowed given the characteristics of theprotection domain.",
	"Method": "PermissionCollection getPermissions(CodeSource codesource,PermissionCollection getPermissions,ProtectionDomain domain){\r\n    PermissionCollection pC = basePolicy.getPermissions(domain);\r\n    try {\r\n        pC = SimplePolicyConfiguration.getPermissions(pC, domain);\r\n    } catch (PolicyContextException pce) {\r\n        SimplePolicyConfiguration.logGetPermissionsFailure(domain, pce);\r\n    }\r\n    return pC;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.getSuperclass",
	"Comment": "returns the name of the superclass for the given class name.",
	"Method": "String getSuperclass(String className){\r\n    debug(\"getSuperclass (\" + className + \")\");\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBHomeInvocationHandler.invokeTargetBeanMethod",
	"Comment": "allow subclasses to execute a protected method in basecontainer",
	"Method": "Object invokeTargetBeanMethod(BaseContainer container,Method beanClassMethod,EjbInvocation inv,Object target,Object[] params){\r\n    return container.invokeTargetBeanMethod(beanClassMethod, inv, target, params, null);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.getStandaloneBundleDescriptor",
	"Comment": "if this application object is virtual, return the standalonebundle descriptor it is wrapping otherwise return null",
	"Method": "BundleDescriptor getStandaloneBundleDescriptor(){\r\n    if (isVirtual()) {\r\n        if (getModules().size() > 1) {\r\n            throw new IllegalStateException(\"Virtual application contains more than one module\");\r\n        }\r\n        return getModules().iterator().next().getDescriptor();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.BundleDescriptor.setFullFlag",
	"Comment": "sets the full flag of the bundle descriptor. once set, the annotationsof the classes contained in the archive described by this bundledescriptor will be ignored.",
	"Method": "void setFullFlag(boolean flag){\r\n    fullFlag = flag;\r\n}"
}, {
	"Path": "org.glassfish.persistence.jpa.JPADeployer.prepare",
	"Comment": "emfs for refered pus are created and stored in jpaapplication instance.the jpaapplication instance is stored in given deploymentcontext to be retrieved by load",
	"Method": "boolean prepare(DeploymentContext context){\r\n    boolean prepared = super.prepare(context);\r\n    if (prepared) {\r\n        if (isEMFCreationRequired(context)) {\r\n            createEMFs(context);\r\n        }\r\n    }\r\n    return prepared;\r\n}"
}, {
	"Path": "org.glassfish.deployapi.ProgressObjectImpl.checkStatusAndAddStage",
	"Comment": "given a deployment status, this checks if the status is success",
	"Method": "boolean checkStatusAndAddStage(TargetImpl aTarget,String action,DFDeploymentStatus currentStatus){\r\n    String statusMsg = getDeploymentStatusMessage(currentStatus);\r\n    finalDeploymentStatus.addSubStage(currentStatus);\r\n    if (statusMsg == null) {\r\n        fireProgressEvent(StateType.RUNNING, localStrings.getLocalString(\"enterprise.deployment.client.action_completed\", \"Action {0} completed\", action), aTarget);\r\n        return true;\r\n    }\r\n    setupForAbnormalExit(localStrings.getLocalString(\"enterprise.deployment.client.action_failed_with_message\", \"Action {0} failed - {1}\", action, statusMsg), aTarget);\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.WebServiceEndpoint.getPublishingUri",
	"Comment": "this is the logical equivalent to endpoint address uri, but forurl publishing.like endpoint address uri, it does not include thecontext root for servlet endpoints.",
	"Method": "String getPublishingUri(){\r\n    String uri = endpointAddressUri.startsWith(\"/\") ? endpointAddressUri.substring(1) : endpointAddressUri;\r\n    return uri + \"/\" + PUBLISHING_SUBCONTEXT;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.connectionErrorOccurred",
	"Comment": "this method is called by the connectionholder30 when it detects a connecionrelated error.",
	"Method": "void connectionErrorOccurred(Exception e,ConnectionHolder connHolderObject){\r\n    ConnectionEventListener cel = this.listener;\r\n    ConnectionEvent ce = null;\r\n    ce = e == null ? new ConnectionEvent(this, ConnectionEvent.CONNECTION_ERROR_OCCURRED) : new ConnectionEvent(this, ConnectionEvent.CONNECTION_ERROR_OCCURRED, e);\r\n    if (connHolderObject != null) {\r\n        ce.setConnectionHandle(connHolderObject);\r\n    }\r\n    cel.connectionErrorOccurred(ce);\r\n    isUsable = false;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.StatementWrapper40.getResultSet",
	"Comment": "retrieves the current result as a resultset object.this method should be called only once per result.",
	"Method": "java.sql.ResultSet getResultSet(){\r\n    ResultSet rs = jdbcStatement.getResultSet();\r\n    if (rs == null)\r\n        return null;\r\n    return new ResultSetWrapper40(this, rs);\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.jws.boot.LaunchSecurityHelper.refreshPolicy",
	"Comment": "refreshes the current policy object using the contents of the specified fileas additional policy.",
	"Method": "void refreshPolicy(File policyFile){\r\n    int idx = firstFreePolicyIndex();\r\n    URI policyFileURI = policyFile.toURI();\r\n    java.security.Security.setProperty(\"policy.url.\" + idx, policyFileURI.toASCIIString());\r\n    Policy p = Policy.getPolicy();\r\n    p.refresh();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.TransactionImpl.getUpdateTimeout",
	"Comment": "gets the number of seconds to wait for an update statementto execute in the datastore associated with thistransaction instance",
	"Method": "int getUpdateTimeout(){\r\n    return updateTimeout;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.ParameterInfo.getType",
	"Comment": "returns the parameter type. see fieldtypeenumeration for possible values.",
	"Method": "int getType(){\r\n    return type;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.initializeConnectionType",
	"Comment": "sets the connection type of this connection. this method is calledby the mcf while creating this managedconnection. saves us a costlyinstanceof operation in the getconnectiontype",
	"Method": "void initializeConnectionType(int _connectionType){\r\n    connectionType = _connectionType;\r\n}"
}, {
	"Path": "org.glassfish.concurrent.admin.ListManagedExecutorServices.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        Collection<ManagedExecutorService> managedExecutorServices = domain.getResources().getResources(ManagedExecutorService.class);\r\n        List<Map<String, String>> resourcesList = new ArrayList<Map<String, String>>();\r\n        List<DefaultResourceProxy> drps = habitat.getAllServices(DefaultResourceProxy.class);\r\n        for (ManagedExecutorService managedExecutorService : managedExecutorServices) {\r\n            String jndiName = managedExecutorService.getJndiName();\r\n            if (bindableResourcesHelper.resourceExists(jndiName, target)) {\r\n                ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n                part.setMessage(jndiName);\r\n                Map<String, String> resourceNameMap = new HashMap<String, String>();\r\n                String logicalName = DefaultResourceProxy.Util.getLogicalName(drps, jndiName);\r\n                if (logicalName != null) {\r\n                    resourceNameMap.put(\"logical-jndi-name\", logicalName);\r\n                }\r\n                resourceNameMap.put(\"name\", jndiName);\r\n                resourcesList.add(resourceNameMap);\r\n            }\r\n        }\r\n        Properties extraProperties = new Properties();\r\n        extraProperties.put(\"managedExecutorServices\", resourcesList);\r\n        report.setExtraProperties(extraProperties);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.managed.executor.service.failed\", \"List managed executor services failed\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.CSIV2TaggedComponentInfo.allMechanismsRequireSSL",
	"Comment": "this method determines if all the mechanisms defined in thecsiv2 compoundsecmechlist structure require protected invocations.",
	"Method": "boolean allMechanismsRequireSSL(Set iorDescSet){\r\n    int size = iorDescSet.size();\r\n    if (size == 0) {\r\n        return false;\r\n    }\r\n    Iterator<EjbIORConfigurationDescriptor> itr = iorDescSet.iterator();\r\n    for (int i = 0; i < size; i++) {\r\n        EjbIORConfigurationDescriptor iorDesc = itr.next();\r\n        int target_requires = getTargetRequires(iorDesc);\r\n        if (target_requires == 0) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.handlers.AbstractAuthAnnotationHandler.relatedAnnotationTypes",
	"Comment": "this method returns a list of related annotation types.those annotations should not be used with the given annotaton type.",
	"Method": "Class<? extends Annotation>[] relatedAnnotationTypes(){\r\n    return new Class[0];\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.meta.JDOMetaDataModelImpl.isDefaultFetchGroupField",
	"Comment": "tests whether a field of a class is known to be part of thedefault fetch group. please note that for a relationship field, thismethod always returns false.",
	"Method": "boolean isDefaultFetchGroupField(String classPath,String fieldName){\r\n    final String className = pathToName(classPath);\r\n    boolean isdfgField = model.isDefaultFetchGroup(className, fieldName);\r\n    if (isdfgField) {\r\n        final PersistenceFieldElement pfe = model.getPersistenceField(className, fieldName);\r\n        if (pfe instanceof RelationshipElement) {\r\n            isdfgField = false;\r\n        }\r\n    }\r\n    return isdfgField;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getCatalogSeparator",
	"Comment": "retrieves the string that this database uses as theseparator between a catalog and table name.",
	"Method": "String getCatalogSeparator(){\r\n    return databaseMetaData.getCatalogSeparator();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.IntegralType.getValue",
	"Comment": "converts the specified value into a value of this numeric type.e.g. an integer is converted into a long, if this represents the numeric type long.",
	"Method": "Number getValue(Number value){\r\n    Number ret = null;\r\n    if (value == null)\r\n        ret = null;\r\n    else if (\"int\".equals(getName()))\r\n        ret = new Integer(value.intValue());\r\n    else if (\"long\".equals(getName()))\r\n        ret = new Long(value.longValue());\r\n    else if (\"byte\".equals(getName()))\r\n        ret = new Byte(value.byteValue());\r\n    else if (\"short\".equals(getName()))\r\n        ret = new Short(value.shortValue());\r\n    return ret;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxColumnsInSelect",
	"Comment": "retrieves the maximum number of columns this database allows in aselect list.",
	"Method": "int getMaxColumnsInSelect(){\r\n    return databaseMetaData.getMaxColumnsInSelect();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ClassDesc.getKeyFields",
	"Comment": "return the key fields as array of java.lang.reflect.field instances.",
	"Method": "Field[] getKeyFields(){\r\n    return keyFields;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.AbstractMethodHelper.getLocalHome",
	"Comment": "gets the name of the local home which corresponds to this bean.",
	"Method": "String getLocalHome(){\r\n    return getDescriptor().getLocalHomeClassName();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.getInheritedMethod",
	"Comment": "returns the inherited method element for the specified method \tname and argument types in the class with the specified name.\ttypes are specified as type names for primitive type such as \tint, float or as fully qualified class names.note that the class \twith the specified classname is not checked for this method, only\tsuperclasses are checked.",
	"Method": "Object getInheritedMethod(String className,String methodName,String[] argTypeNames){\r\n    String superClass = getSuperclass(className);\r\n    Object method = null;\r\n    while ((superClass != null) && ((method = getMethod(superClass, methodName, argTypeNames)) == null)) {\r\n        superClass = getSuperclass(superClass);\r\n    }\r\n    return method;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.generator.JavaClassWriterHelper.getWrapperExpr",
	"Comment": "a helper method which generates an expression to wrap a primitivedatatype to its corresponding wrapper class.",
	"Method": "String getWrapperExpr(Class exprType,String expr){\r\n    StringBuffer wrapped = new StringBuffer();\r\n    wrapped.append(new_);\r\n    wrapped.append(space_);\r\n    wrapped.append(getWrapperType(exprType).getName());\r\n    wrapped.append(parenleft_);\r\n    wrapped.append(expr);\r\n    wrapped.append(parenright_);\r\n    return wrapped.toString();\r\n}"
}, {
	"Path": "org.glassfish.deployapi.SunDeploymentManager.setServerConnectionEnvironment",
	"Comment": "set additional env vars for the jmx https connector, providedby the client. this method is expected to be called right afterthe client retrieves the deploymentmanager, beforethe client makes any calls on the dm that requires mbean serverconnection.",
	"Method": "void setServerConnectionEnvironment(ServerConnectionEnvironment env){\r\n    serverId.setConnectionEnvironment(env);\r\n}"
}, {
	"Path": "org.glassfish.loadbalancer.admin.cli.helper.LbConfigHelper.getLbReader",
	"Comment": "exports the loadbalancer.xml from the config to the outputstream provided",
	"Method": "LoadbalancerReader getLbReader(Domain domain,ApplicationRegistry appRegistry,String lbConfigName){\r\n    LbConfigs lbConfigs = domain.getExtensionByType(LbConfigs.class);\r\n    if (lbConfigs == null) {\r\n        throw new Exception(LbLogUtil.getStringManager().getString(\"UnableToGetLbConfig\", lbConfigName));\r\n    }\r\n    LbConfig lbConfig = lbConfigs.getLbConfig(lbConfigName);\r\n    if (lbConfig == null) {\r\n        throw new Exception(LbLogUtil.getStringManager().getString(\"UnableToGetLbConfig\", lbConfigName));\r\n    }\r\n    return new LoadbalancerReaderImpl(domain, appRegistry, lbConfig);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.getMinPool",
	"Comment": "returns minimum number of persistencemanager instances in the pool",
	"Method": "int getMinPool(){\r\n    return minPool;\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.jws.JavaWebStartInfo.init",
	"Comment": "completes initialization of the object.should be invoked immediateafter the object is created by the habitat.",
	"Method": "void init(AppClientServerApplication acServerApp){\r\n    this.acServerApp = acServerApp;\r\n    helper = acServerApp.helper();\r\n    acDesc = acServerApp.getDescriptor();\r\n    dc = acServerApp.dc();\r\n    isJWSEligible = acDesc.getJavaWebStartAccessDescriptor().isEligible();\r\n    isJWSEnabledAtApp = isJWSEnabled(dc.getAppProps());\r\n    isJWSEnabledAtModule = isJWSEnabled(dc.getModuleProps());\r\n    tHelper = TokenHelper.newInstance(helper, vendorInfo());\r\n    final String devJNLPDoc = acDesc.getJavaWebStartAccessDescriptor().getJnlpDocument();\r\n    final File sourceDir = acDesc.getApplication().isVirtual() ? dc.getSourceDir() : new File(dc.getSource().getParentArchive().getURI());\r\n    this.developerJNLPDoc = devJNLPDoc;\r\n    signingAlias = JWSAdapterManager.signingAlias(dc);\r\n    dch.init(dc.getClassLoader(), tHelper, sourceDir, dc.getSource(), staticContent, dynamicContent, helper);\r\n}"
}, {
	"Path": "admin.NodeTest.mapToArray",
	"Comment": "converts a map into an array where the first item is thefirst key, the second item is the first value, etc.",
	"Method": "String[] mapToArray(Map<String, String> m){\r\n    String[] results = new String[m.size() * 2];\r\n    Set<String> keys = m.keySet();\r\n    int i = 0;\r\n    for (String k : keys) {\r\n        results[i] = k;\r\n        i++;\r\n        results[i] = m.get(k);\r\n        i++;\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ResourceReferenceDescriptor.setCreateTablesAtDeploy",
	"Comment": "sets whether if automatic creation of tables for the cmp beans is done at deployment time",
	"Method": "void setCreateTablesAtDeploy(boolean createTablesAtDeploy){\r\n    this.createTablesAtDeploy = createTablesAtDeploy;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceClassElementImpl.setModified",
	"Comment": "set the modified flag for this persistence class to flag.this is\tusually set to true by property changes and \tfalse after a save.",
	"Method": "void setModified(boolean flag){\r\n    boolean oldFlag = isModified();\r\n    if (flag != oldFlag) {\r\n        _isModified = flag;\r\n        firePropertyChange(PROP_MODIFIED, JavaTypeHelper.valueOf(oldFlag), JavaTypeHelper.valueOf(flag));\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBContainerStateManager.markObjectRemoved",
	"Comment": "mark ejb object associated with this context as removed or not",
	"Method": "void markObjectRemoved(EJBContextImpl context,boolean removed){\r\n    if (!isNullEJBObject(context)) {\r\n        context.getEJBObjectImpl().setRemoved(removed);\r\n    }\r\n    if (!isNullEJBLocalObject(context)) {\r\n        context.getEJBLocalObjectImpl().setRemoved(removed);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.work.OneWork.doWork",
	"Comment": "this method is executed by thread pool as the basic work operation.",
	"Method": "void doWork(){\r\n    ClassLoader callerCL = Thread.currentThread().getContextClassLoader();\r\n    if (tcc != null && tcc != callerCL) {\r\n        Thread.currentThread().setContextClassLoader(tcc);\r\n    }\r\n    try {\r\n        coordinator.preInvoke();\r\n        boolean timedOut = coordinator.isTimedOut();\r\n        if (coordinator.proceed()) {\r\n            try {\r\n                coordinator.setupContext(this);\r\n                log(\"Start of Work\");\r\n            } catch (Throwable e) {\r\n                coordinator.setException(e);\r\n            }\r\n        }\r\n        if (coordinator.proceed()) {\r\n            try {\r\n                work.run();\r\n                log(\"Work Executed\");\r\n            } catch (Throwable t) {\r\n                log(\"Execution has thrown exception \" + t.getMessage());\r\n                coordinator.setException(t);\r\n            }\r\n        }\r\n        if (!timedOut) {\r\n            coordinator.postInvoke();\r\n        }\r\n        log(\"End of Work\");\r\n    } finally {\r\n        ClassLoader cl = Thread.currentThread().getContextClassLoader();\r\n        if (cl != callerCL) {\r\n            Thread.currentThread().setContextClassLoader(callerCL);\r\n        }\r\n        tcc = null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.web.security.HttpRequestWrapper.generateSessionId",
	"Comment": "generate and return a new session id.this hook allows connectors to provide their own scalable sessionid generators.",
	"Method": "String generateSessionId(){\r\n    return httpRequest.generateSessionId();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.meta.JDOMetaDataModelImpl.isMutableSecondClassObjectType",
	"Comment": "tests whether a type is known for mutable second class objects.",
	"Method": "boolean isMutableSecondClassObjectType(String classPath){\r\n    final String className = pathToName(classPath);\r\n    return model.isMutableSecondClassObject(className);\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.addToList",
	"Comment": "add to the pool emitters list. the connection pool application emitterfor the specific poolinfo and appname.",
	"Method": "ConnectionPoolAppEmitterImpl addToList(String appName,ConnectionPoolAppProbeProvider probeAppProvider,Map<String, ConnectionPoolAppEmitterImpl> appEmitters){\r\n    ConnectionPoolAppEmitterImpl connPoolAppEmitter = null;\r\n    if (probeAppProvider != null) {\r\n        connPoolAppEmitter = new ConnectionPoolAppEmitterImpl(poolName, appName, probeAppProvider);\r\n        appEmitters.put(appName, connPoolAppEmitter);\r\n        appStatsMap.put(poolInfo, appEmitters);\r\n    }\r\n    runtime.getProbeProviderUtil().getConnPoolBootstrap().addToPoolEmitters(poolInfo, this);\r\n    return connPoolAppEmitter;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnUtils.store",
	"Comment": "return the best instruction for storing a value to a localvariable slot",
	"Method": "Insn store(int tp,int i,ConstantPool pool){\r\n    switch(tp) {\r\n        case T_BOOLEAN:\r\n        case T_CHAR:\r\n        case T_BYTE:\r\n        case T_SHORT:\r\n        case T_INT:\r\n            return iStore(i, pool);\r\n        case T_FLOAT:\r\n            return fStore(i, pool);\r\n        case T_DOUBLE:\r\n            return dStore(i, pool);\r\n        case T_LONG:\r\n            return lStore(i, pool);\r\n        case TC_OBJECT:\r\n            return aStore(i, pool);\r\n        default:\r\n            throw new InsnError(\"bad store type\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.getEjbReferenceByName",
	"Comment": "return a reference to another ejb by the same name or throw an illegalargumentexception.",
	"Method": "EjbReference getEjbReferenceByName(String name){\r\n    return (EjbReferenceDescriptor) getEjbReference(name);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createFieldExistenceComponent",
	"Comment": "create a validation component which can check whether the field exists.",
	"Method": "ValidationComponent createFieldExistenceComponent(String fieldName,ValidationComponent createFieldExistenceComponent,Object field){\r\n    return createFieldExistenceComponent(field.toString());\r\n}"
}, {
	"Path": "com.sun.jaspic.config.factory.RegStoreFileParser.store",
	"Comment": "adds the provider to the entry list if it is not alreadypresent, creates the configuration file if necessary, andwrites the entries to the file.",
	"Method": "void store(String className,RegistrationContext ctx,Map properties){\r\n    synchronized (confFile) {\r\n        if (checkAndAddToList(className, ctx, properties)) {\r\n            try {\r\n                writeEntries();\r\n            } catch (IOException ioe) {\r\n                logWarningUpdated(ioe);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.DatabaseGenerator.addAssocMappingRelationship",
	"Comment": "create and add mappingrelationship with associated column pairsfor join table. the column pair for mappingrelationship is sameorder as the column pair from foreign key.it is for column pairs between the join table and the foreign table",
	"Method": "void addAssocMappingRelationship(String relationName,MappingClassElement declaringClass,ForeignKeyElement fkeyForeign){\r\n    MappingRelationshipElement impl = (MappingRelationshipElement) declaringClass.getField(relationName);\r\n    if (null == impl) {\r\n        impl = new MappingRelationshipElementImpl(relationName, declaringClass);\r\n        declaringClass.addField(impl);\r\n    }\r\n    ColumnPairElement[] pairs = fkeyForeign.getColumnPairs();\r\n    for (int i = 0; i < pairs.length; i++) {\r\n        ColumnPairElement pair = pairs[i];\r\n        impl.addAssociatedColumn(pair);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.getValidationClassName",
	"Comment": "returns the validation class name checked for during validation",
	"Method": "String getValidationClassName(){\r\n    return spec.getDetail(DataSourceSpec.VALIDATIONCLASSNAME);\r\n}"
}, {
	"Path": "com.sun.ejb.EjbInvocation.userTransactionMethodsAllowed",
	"Comment": "called by the usertransaction implementation to verify access to the usertransaction methods.",
	"Method": "boolean userTransactionMethodsAllowed(){\r\n    return ((Container) container).userTransactionMethodsAllowed(this);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.Jdbc40ObjectsFactory.getConnection",
	"Comment": "to get an instance of connectionholder40.will return a connectionholder40 with or without wrapper",
	"Method": "ConnectionHolder getConnection(Connection conObject,ManagedConnectionImpl mcObject,javax.resource.spi.ConnectionRequestInfo criObject,boolean statementWrapping,SQLTraceDelegator sqlTraceDelegator){\r\n    ConnectionHolder connection = null;\r\n    if (!initJDBC30Connection) {\r\n        detectJDBC30Connection(conObject, mcObject);\r\n    }\r\n    if (statementWrapping) {\r\n        if (sqlTraceDelegator != null) {\r\n            Class[] connIntf = new Class[] { java.sql.Connection.class };\r\n            Connection proxiedConn = getProxiedConnection(conObject, connIntf, sqlTraceDelegator);\r\n            connection = new ProfiledConnectionWrapper40(proxiedConn, mcObject, criObject, jdbc30Connection, sqlTraceDelegator);\r\n        } else {\r\n            connection = new ConnectionWrapper40(conObject, mcObject, criObject, jdbc30Connection);\r\n        }\r\n    } else {\r\n        connection = new ConnectionHolder40(conObject, mcObject, criObject, jdbc30Connection);\r\n    }\r\n    return connection;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceClassElementImpl.setGroupCollection",
	"Comment": "set the concurrency group collection of this class element to the \tsupplied collection.this method should only be used internally \tand for cloning and archiving.",
	"Method": "void setGroupCollection(PersistenceElementCollection collection){\r\n    _groups = collection;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.EJBHashSet.assertInstancesOfLocalInterfaceImpl",
	"Comment": "verifies that elements of this collection are of the expected type.",
	"Method": "void assertInstancesOfLocalInterfaceImpl(Collection c){\r\n    for (Iterator it = c.iterator(); it.hasNext(); ) helper.assertInstanceOfLocalInterfaceImpl(it.next());\r\n}"
}, {
	"Path": "org.glassfish.enterprise.iiop.impl.POAProtocolMgr.initializePOAs",
	"Comment": "called in all vms, must be called only after initialnaming is available",
	"Method": "void initializePOAs(){\r\n    getRFM();\r\n    _logger.log(Level.FINE, \"POAProtocolMgr.initializePOAs: RFM resolved and activated\");\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getArray",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object as an array objectin the java programming language.",
	"Method": "Array getArray(int i,Array getArray,String colName){\r\n    return resultSet.getArray(colName);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.isInterface",
	"Comment": "determines if the specified classname represents an interface type.",
	"Method": "boolean isInterface(String className){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.getConnectionTransactionIsolation",
	"Comment": "returns current transaction isolation level for connections of this persistencemanagerfactory.",
	"Method": "int getConnectionTransactionIsolation(){\r\n    if (connectionFactory != null)\r\n        return connectionFactory.getTransactionIsolation();\r\n    return txIsolation;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.QueryImpl.setPrefetchEnabled",
	"Comment": "sets the prefetchenabled option.the prefetchenabled option specifies whether prefetch of relationshipfields should be enabled for this query. the prefetch is enabled bydefault if such fields are part of dfg. a user needs to explicitelydisable prefetch for any particular query if the related instanceswill not be used in this transaction.",
	"Method": "void setPrefetchEnabled(boolean prefetchEnabled){\r\n    synchronized (this.paramtab) {\r\n        this.prefetchEnabled = prefetchEnabled;\r\n        this.compiled = false;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.Java2DBProcessorHelper.getCreateTables",
	"Comment": "calculate createtables value based on the parameter stored on deploy",
	"Method": "boolean getCreateTables(boolean param,boolean getCreateTables,String bundleName){\r\n    return getCreateTables(Boolean.valueOf(deploymentContextProps.getProperty(CREATE_TABLE_VALUE + bundleName)));\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.stats.BoundedRangeStatisticImpl.getLowerBound",
	"Comment": "return the lowest possible value, that this statistic is permitted to attain.",
	"Method": "long getLowerBound(){\r\n    return lowerBound;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getDriverVersion",
	"Comment": "retrieves the version number of this jdbc driver as a string.",
	"Method": "String getDriverVersion(){\r\n    return databaseMetaData.getDriverVersion();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.MappingGenerator.generateSchema",
	"Comment": "call databasegenerator to generate database model and mapping model",
	"Method": "DatabaseGenerator.Results generateSchema(List pcClasses,String dbName,Boolean useUniqueTableNames,Properties userPolicy){\r\n    MappingPolicy mappingPolicy = MappingPolicy.getMappingPolicy(dbName);\r\n    mappingPolicy.setUserPolicy(userPolicy);\r\n    if (useUniqueTableNames != null) {\r\n        mappingPolicy.setUniqueTableName(useUniqueTableNames.booleanValue());\r\n    }\r\n    return DatabaseGenerator.generate(model, pcClasses, mappingPolicy, infoHelper.getSchemaNameToGenerate(), CLASS_SUFFIX, true);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.QueryImpl.checkCandidates",
	"Comment": "this method checks a valid candidates setting for this query.",
	"Method": "void checkCandidates(){\r\n    if ((candidateCollection == null) && (candidateClass != null)) {\r\n        candidateCollection = pm.getExtent(candidateClass, false);\r\n    } else {\r\n        jqlc.checkCandidates(candidateClass, candidateCollection);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getPossibleTransactionAttributes",
	"Comment": "returns the set of transaction attributes that can be assignedto methods of this ejb when in cmt mode. elements are of typecontainertransaction",
	"Method": "Vector getPossibleTransactionAttributes(){\r\n    Vector txAttributes = new Vector();\r\n    txAttributes.add(new ContainerTransaction(ContainerTransaction.MANDATORY, \"\"));\r\n    txAttributes.add(new ContainerTransaction(ContainerTransaction.NEVER, \"\"));\r\n    txAttributes.add(new ContainerTransaction(ContainerTransaction.NOT_SUPPORTED, \"\"));\r\n    txAttributes.add(new ContainerTransaction(ContainerTransaction.REQUIRED, \"\"));\r\n    txAttributes.add(new ContainerTransaction(ContainerTransaction.REQUIRES_NEW, \"\"));\r\n    txAttributes.add(new ContainerTransaction(ContainerTransaction.SUPPORTS, \"\"));\r\n    return txAttributes;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.getTime",
	"Comment": "retrieves the value of a jdbc time parameter as ajava.sql.time object, usingthe given calendar objectto construct the time.with a calendar object, the drivercan calculate the time taking into account a custom timezone and locale.if no calendar object is specified, the driver uses thedefault timezone and locale.",
	"Method": "Time getTime(int parameterIndex,Time getTime,int parameterIndex,Calendar cal,Time getTime,String parameterName,Time getTime,String parameterName,Calendar cal){\r\n    return callableStatement.getTime(parameterName, cal);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.registry.MonitoredObjectType.toString",
	"Comment": "a string representation. the return value of this method is same as thatof method gettypename.",
	"Method": "String toString(){\r\n    return typeName;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ConnectionHolder.getManagedConnection",
	"Comment": "returns the managedconnection instance responsiblefor this connection.",
	"Method": "ManagedConnection getManagedConnection(){\r\n    return mc;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsSubqueriesInComparisons",
	"Comment": "retrieves whether this database supports subqueries in comparisonexpressions.",
	"Method": "boolean supportsSubqueriesInComparisons(){\r\n    return databaseMetaData.supportsSubqueriesInComparisons();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.DataSourceDefinitionDescriptor.getIsolationLevelString",
	"Comment": "annotation uses integer values and hence this mapping is needed",
	"Method": "String getIsolationLevelString(){\r\n    String isolationLevelString = null;\r\n    if (isolationLevel == Connection.TRANSACTION_READ_COMMITTED) {\r\n        isolationLevelString = TRANSACTION_READ_COMMITTED;\r\n    } else if (isolationLevel == Connection.TRANSACTION_READ_UNCOMMITTED) {\r\n        isolationLevelString = TRANSACTION_READ_UNCOMMITTED;\r\n    } else if (isolationLevel == Connection.TRANSACTION_REPEATABLE_READ) {\r\n        isolationLevelString = TRANSACTION_REPEATABLE_READ;\r\n    } else if (isolationLevel == Connection.TRANSACTION_SERIALIZABLE) {\r\n        isolationLevelString = TRANSACTION_SERIALIZABLE;\r\n    }\r\n    return isolationLevelString;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ResourceAdapterAdminServiceImpl.deleteResourceAdapterConfig",
	"Comment": "delete the resource adapter configuration to the connector registry",
	"Method": "void deleteResourceAdapterConfig(String rarName){\r\n    if (rarName != null) {\r\n        _registry.removeResourceAdapterConfig(rarName);\r\n        reCreateActiveResourceAdapter(rarName);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.mejb.IIOPMBeanServerImpl.getAttributes",
	"Comment": "enables the values of several attributes of a named mbean. the mbean is identified by its object name.",
	"Method": "AttributeList getAttributes(ObjectName name,String[] attributes){\r\n    return server.getAttributes(name, attributes);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.handles",
	"Comment": "returns true if this archivist is capable of handling the archive typehere we check for the existence of the deployment descriptors",
	"Method": "boolean handles(ReadableArchive archive){\r\n    try {\r\n        if (hasStandardDeploymentDescriptor(archive) || hasRuntimeDeploymentDescriptor(archive)) {\r\n            return true;\r\n        }\r\n        String uri = archive.getURI().toString();\r\n        File file = new File(archive.getURI());\r\n        if (!file.isDirectory() && !uri.endsWith(Archivist.EJB_EXTENSION)) {\r\n            if (uri.endsWith(getArchiveExtension())) {\r\n                return true;\r\n            }\r\n        }\r\n        if (postHandles(archive)) {\r\n            return true;\r\n        }\r\n    } catch (IOException e) {\r\n        return false;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.CodeAttribute.stackUsed",
	"Comment": "return the maximum number of stack entries used by this method",
	"Method": "int stackUsed(){\r\n    makeValid();\r\n    return maxStack;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.archive.EjbSniffer.handles",
	"Comment": "returns true if the passed file or directory is recognized by thisinstance.",
	"Method": "boolean handles(ReadableArchive location){\r\n    boolean result = super.handles(location);\r\n    if (result == false) {\r\n        try {\r\n            result = location.exists(\"META-INF/sun-ejb-jar.xml\") || location.exists(\"META-INF/glassfish-ejb-jar.xml\");\r\n        } catch (IOException ioe) {\r\n        }\r\n    }\r\n    if (result == false) {\r\n        try {\r\n            result = location.exists(\"WEB-INF/ejb-jar.xml\");\r\n        } catch (IOException ioEx) {\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.jdbc.pool.monitor.JdbcConnPoolStatsProvider.connectionRequestDequeuedEvent",
	"Comment": "when an object is removed from the wait queue, decrement the waitqueuelength.",
	"Method": "void connectionRequestDequeuedEvent(String poolName,String appName,String moduleName){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (logger.isLoggable(Level.FINEST)) {\r\n            logger.finest(\"Wait Queue length modified event received - \" + \"poolName = \" + poolName);\r\n        }\r\n        waitQueueLength.decrement();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.isPersistentTypeAllowed",
	"Comment": "returns true if the a field of the specified class or \ttype can be made persistent, false otherwise.fields \twhich are primitive, persistence capable, byte arrays, or second\tclass objects and not arrays return true.",
	"Method": "boolean isPersistentTypeAllowed(String className,ClassLoader classLoader){\r\n    return (isPrimitive(className) || isSecondClassObject(className) || isByteArray(className) || isPersistent(className, classLoader));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.logging.LogHelper.registerLoggerFactory",
	"Comment": "register a loggerfactory for use in managed environments orfor special situations.thisfactory will be delegated to for all getlogger requests.",
	"Method": "void registerLoggerFactory(LoggerFactory factory){\r\n    loggerFactory = factory;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.BundleDescriptor.getApplication",
	"Comment": "the application to which i belong, or none if i am standalone.",
	"Method": "Application getApplication(){\r\n    return application;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.setSupersedeDeletedInstance",
	"Comment": "sets the supersededeletedinstance flag for all persistencemanagers.",
	"Method": "void setSupersedeDeletedInstance(boolean flag){\r\n    assertNotConfigured();\r\n    supersedeDeletedInstance = flag;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.SelectStatement.getInputValue",
	"Comment": "gets actual value corresponding to inputval. ifinputval is an instanceof inputvalue then value containedin inputval is returned. if inputval is an instanceofinputparamvalue then value returned is obtained from parameters.",
	"Method": "Object getInputValue(InputValue inputVal,ValueFetcher parameters){\r\n    Object val;\r\n    if (inputVal instanceof InputParamValue) {\r\n        int paramIndex = ((InputParamValue) inputVal).getParamIndex().intValue();\r\n        val = parameters.getValue(paramIndex);\r\n    } else {\r\n        val = inputVal.getValue();\r\n    }\r\n    return val;\r\n}"
}, {
	"Path": "org.glassfish.deployapi.SunDeploymentManager.getRunningModules",
	"Comment": "retrieve the list of j2ee application modules distributedto the identified targets and that are currently runningon the associated server or servers.",
	"Method": "TargetModuleID[] getRunningModules(ModuleType moduleType,Target[] targetList){\r\n    return getModules(moduleType, targetList, DFDeploymentProperties.RUNNING);\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.AgentArguments.scan",
	"Comment": "scans the input args string, updating the namevaluepairs propertiesobject using items with a keyword and updated the singlewordargs listwith items without a keyword.",
	"Method": "void scan(String args){\r\n    if (args == null) {\r\n        return;\r\n    }\r\n    Matcher m = agentArgPattern.matcher(args);\r\n    while (m.find()) {\r\n        final String keyword = m.group(KEYWORD);\r\n        final String value = CLIBootstrap.decodeArg(m.group(QUOTED) != null ? m.group(QUOTED) : m.group(UNQUOTED));\r\n        getOrCreateValuesForKeyword(keyword).add(value);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.mejb.IIOPMBeanServerImpl.setAttributes",
	"Comment": "sets the values of several attributes of a named mbean. the mbean is identified by its object name.",
	"Method": "AttributeList setAttributes(ObjectName name,AttributeList attributes){\r\n    return server.setAttributes(name, attributes);\r\n}"
}, {
	"Path": "test.extension.ServiceFrameworkExtension.afterProcessInjectionTarget",
	"Comment": "observer for processinjectiontarget events. this event isfired for every java ee component class supporting injection that may be instantiated by the container at runtime. injections points of every discovered enabled java ee component is checked to see if there is a request for injection of a framework service.",
	"Method": "void afterProcessInjectionTarget(ProcessInjectionTarget<?> pb){\r\n    debug(\"AfterProcessInjectionTarget\" + pb.getAnnotatedType().getBaseType());\r\n    Set<InjectionPoint> ips = pb.getInjectionTarget().getInjectionPoints();\r\n    discoverServiceInjectionPoints(ips);\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.ListConnectorSecurityMaps.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    final ActionReport.MessagePart mp = report.getTopMessagePart();\r\n    Collection<ConnectorConnectionPool> ccPools = domain.getResources().getResources(ConnectorConnectionPool.class);\r\n    if (!doesPoolNameExist(poolName, ccPools)) {\r\n        report.setMessage(localStrings.getLocalString(\"create.connector.security.map.noSuchPoolFound\", \"Specified connector connection pool {0} does not exist. Please specify a valid pool name.\", poolName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (securityMap != null) {\r\n        if (!doesMapNameExist(poolName, securityMap, ccPools)) {\r\n            report.setMessage(localStrings.getLocalString(\"list.connector.security.maps.securityMapNotFound\", \"Security map {0} does not exist for connector connection pool {1}. Please give a valid map name.\", securityMap, poolName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    try {\r\n        final List<SecurityMap> securityMaps = getAllSecurityMapsForPool(poolName, ccPools);\r\n        if (securityMaps != null && !securityMaps.isEmpty()) {\r\n            if (securityMap == null && long_opt) {\r\n                for (SecurityMap sm : securityMaps) {\r\n                    listSecurityMapDetails(sm, mp);\r\n                }\r\n            } else if (securityMap == null && !long_opt) {\r\n                for (SecurityMap sm : securityMaps) {\r\n                    listSecurityMapNames(sm, mp);\r\n                }\r\n            } else {\r\n                for (SecurityMap sm : securityMaps) {\r\n                    if (sm.getName().equals(securityMap)) {\r\n                        listSecurityMapDetails(sm, mp);\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        Logger.getLogger(ListConnectorSecurityMaps.class.getName()).log(Level.SEVERE, \"list-connector-security-maps failed\", e);\r\n        report.setMessage(localStrings.getLocalString(\"\" + \"list.connector.security.maps.fail\", \"Unable to list security map {0} for connector connection pool {1}\", securityMap, poolName) + \" \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.provider.PolicyWrapper.getNewPolicy",
	"Comment": "gets the underlying policyfile implementationcan be overridden by subclass",
	"Method": "java.security.Policy getNewPolicy(){\r\n    return (java.security.Policy) new sun.security.provider.PolicyFile();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.context.ResourceContainerContextImpl.getResourceReference",
	"Comment": "looks up an resource reference with the given name.return null if it is not found.",
	"Method": "ResourceReferenceDescriptor getResourceReference(String name){\r\n    ResourceReferenceDescriptor resourceRef = null;\r\n    try {\r\n        resourceRef = getResourceReferenceContainer().getResourceReferenceByName(name);\r\n    } catch (IllegalArgumentException e) {\r\n        Application app = getAppFromDescriptor();\r\n        if (app != null) {\r\n            try {\r\n                resourceRef = app.getResourceReferenceByName(name);\r\n                addResourceReferenceDescriptor(resourceRef);\r\n            } catch (IllegalArgumentException ee) {\r\n            }\r\n        }\r\n    }\r\n    return resourceRef;\r\n}"
}, {
	"Path": "org.glassfish.ejb.mdb.deployment.annotation.handlers.MessageDrivenHandler.setEjbDescriptorInfo",
	"Comment": "set annotation information to descriptor.this method will also be invoked for an existing descriptor withannotation as user may not specific a complete xml.",
	"Method": "HandlerProcessingResult setEjbDescriptorInfo(EjbDescriptor ejbDesc,AnnotationInfo ainfo){\r\n    MessageDriven mdAn = (MessageDriven) ainfo.getAnnotation();\r\n    Class ejbClass = (Class) ainfo.getAnnotatedElement();\r\n    EjbMessageBeanDescriptor ejbMsgBeanDesc = (EjbMessageBeanDescriptor) ejbDesc;\r\n    HandlerProcessingResult procResult = setMessageListenerInterface(mdAn, ejbMsgBeanDesc, ejbClass, ainfo);\r\n    doDescriptionProcessing(mdAn.description(), ejbMsgBeanDesc);\r\n    doMappedNameProcessing(mdAn.mappedName(), ejbMsgBeanDesc);\r\n    for (ActivationConfigProperty acProp : mdAn.activationConfig()) {\r\n        EnvironmentProperty envProp = new EnvironmentProperty(acProp.propertyName(), acProp.propertyValue(), \"\");\r\n        if (ejbMsgBeanDesc.getActivationConfigValue(envProp.getName()) == null) {\r\n            ejbMsgBeanDesc.putActivationConfigProperty(envProp);\r\n        }\r\n    }\r\n    return procResult;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.getEntityManagerFactories",
	"Comment": "returns the set of physical entity manager factories associated withpersistence units in this application.",
	"Method": "Set<EntityManagerFactory> getEntityManagerFactories(){\r\n    return new HashSet<EntityManagerFactory>(entityManagerFactories.values());\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.CallableStatementWrapper40.getNCharacterStream",
	"Comment": "retrieves the value of the designated parameter as ajava.io.reader object in the java programming language.it is intended for use whenaccessingnchar,nvarcharand longnvarchar parameters.",
	"Method": "Reader getNCharacterStream(int parameterIndex,Reader getNCharacterStream,String parameterName){\r\n    return callableStatement.getNCharacterStream(parameterName);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.updateKeyForClass",
	"Comment": "updates the key in the cache for the supplied mappingclasselement.",
	"Method": "void updateKeyForClass(MappingClassElement mappingClass,String oldName){\r\n    synchronized (this._classes) {\r\n        if (oldName != null)\r\n            _classes.remove(oldName);\r\n        if (mappingClass != null) {\r\n            String className = mappingClass.getName();\r\n            _classes.put(className, mappingClass);\r\n            _nonPCClasses.remove(className);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.obj.GroupOfNames.isSubgroupMember",
	"Comment": "checks if the supplied name is a member of any subgroups.all the members are retrieved and any subgroups are explored.",
	"Method": "boolean isSubgroupMember(String dn){\r\n    for (NamingEnumeration members = (NamingEnumeration) members(); members.hasMore(); ) {\r\n        Object obj = members.next();\r\n        if (obj instanceof GroupOfNames && ((GroupOfNames) obj).isMember(dn)) {\r\n            members.close();\r\n            return true;\r\n        } else if (obj instanceof GroupOfURLs && ((GroupOfURLs) obj).isMember(dn)) {\r\n            members.close();\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.UpdateObjectDescImpl.markRelationshipChange",
	"Comment": "marks the relationship change property for this instance, if theupdated field is a relationship field or a hidden field tracing aforeign key column in the database.",
	"Method": "void markRelationshipChange(FieldDesc fieldDesc){\r\n    if (fieldDesc.isRelationshipField() || fieldDesc.isForeignKeyField()) {\r\n        if (logger.isLoggable(Logger.FINEST)) {\r\n            logger.finest(\"sqlstore.sql.updateobjdescimpl.markrelationshipchange\");\r\n        }\r\n        relationshipChanged = true;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.common.wls.EjbReferenceDescriptionNode.writeDescriptors",
	"Comment": "write all occurrences of the descriptor corresponding to the currentnode from the parent descriptor to an jaxp dom node and return itthis api will be invoked by the parent node when the parent nodewrites out a mix of statically and dynamically registered sub nodes.this method should be overriden by the sub classes if itneeds to be called by the parent node.",
	"Method": "Node writeDescriptors(Node parent,String nodeName,Descriptor parentDesc){\r\n    if (parentDesc instanceof EjbReferenceContainer) {\r\n        EjbReferenceContainer ejbReferenceContainer = (EjbReferenceContainer) parentDesc;\r\n        Set<EjbReference> ejbReferences = ejbReferenceContainer.getEjbReferenceDescriptors();\r\n        for (EjbReference ejbReference : ejbReferences) {\r\n            writeDescriptor(parent, nodeName, ejbReference);\r\n        }\r\n    }\r\n    return parent;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.createConnectionFactory",
	"Comment": "creates a connection factory instance. the connectionmanager implementationof the application server is used here.",
	"Method": "Object createConnectionFactory(Object createConnectionFactory,javax.resource.spi.ConnectionManager cxManager){\r\n    logFine(\"In createConnectionFactory(javax.resource.spi.ConnectionManager cxManager)\");\r\n    javax.sql.DataSource cf = jdbcObjectsFactory.getDataSourceInstance(this, cxManager);\r\n    if (cxManager instanceof javax.resource.spi.LazyEnlistableConnectionManager) {\r\n        cm_ = (javax.resource.spi.LazyEnlistableConnectionManager) cxManager;\r\n        isLazyCm_ = true;\r\n    }\r\n    return cf;\r\n}"
}, {
	"Path": "com.sun.web.security.RealmAdapter.findSecurityConstraints",
	"Comment": "returns null1. if there are no security constraints defined on any of the webresources within the context, or2. if the target is a form login related page or target.otherwise return an empty array of securityconstraint.",
	"Method": "SecurityConstraint[] findSecurityConstraints(HttpRequest request,Context context,SecurityConstraint[] findSecurityConstraints,String requestPathMB,String httpMethod,Context context){\r\n    if (this.helper == null) {\r\n        initConfigHelper(context.getServletContext());\r\n    }\r\n    WebSecurityManager secMgr = getWebSecurityManager(false);\r\n    if (secMgr != null && secMgr.hasNoConstrainedResources() && !isSecurityExtensionEnabled(context.getServletContext())) {\r\n        return null;\r\n    }\r\n    SecurityConstraint[] constraints = RealmAdapter.emptyConstraints;\r\n    return constraints;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.model.DeploymentDescriptorModel.getModifiersForClass",
	"Comment": "returns the modifier mask for the specified classname.this method \toverrides the one in model to strip out the abstract modifier when \tthe persistence capable class is represented by the abstract bean.\tit also adds the static modifier when the specified class represents\tthe persistence capable key class which will be generated.",
	"Method": "int getModifiersForClass(String className){\r\n    int modifiers = super.getModifiersForClass(className);\r\n    if (isPCClassName(className))\r\n        modifiers &= ~Modifier.ABSTRACT;\r\n    else if (getNameMapper().getKeyClassForPersistenceKeyClass(className) != null) {\r\n        modifiers |= Modifier.STATIC;\r\n    }\r\n    return modifiers;\r\n}"
}, {
	"Path": "com.sun.enterprise.naming.impl.JavaURLContext.list",
	"Comment": "lists the contents of a context or subcontext. the operation isdelegated to the serial context.",
	"Method": "NamingEnumeration<NameClassPair> list(String name,NamingEnumeration<NameClassPair> list,Name name){\r\n    return list(name.toString());\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.hashCode",
	"Comment": "computes the hash code of this persistencemanagerfactory.",
	"Method": "int hashCode(){\r\n    return this._persistenceManagerFactory.hashCode();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.getInvalidConnections",
	"Comment": "this method returns a set of invalid managedconnectionobjects chosen from a specified set of managedconnectionobjects.",
	"Method": "Set getInvalidConnections(Set connectionSet){\r\n    Iterator iter = connectionSet.iterator();\r\n    Set<ManagedConnectionImpl> invalidConnections = new HashSet<ManagedConnectionImpl>();\r\n    while (iter.hasNext()) {\r\n        ManagedConnectionImpl mc = (ManagedConnectionImpl) iter.next();\r\n        try {\r\n            isValid(mc);\r\n        } catch (ResourceException re) {\r\n            invalidConnections.add(mc);\r\n            mc.connectionErrorOccurred(re, null);\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"jdbc.invalid_connection\", re);\r\n            }\r\n        }\r\n    }\r\n    return invalidConnections;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.addConcurrencyGroup",
	"Comment": "add the supplied group to the collection of concurrency groups for this\tclass.",
	"Method": "void addConcurrencyGroup(ConcurrencyGroupElement group){\r\n    addConcurrencyGroups(new ConcurrencyGroupElement[] { group });\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.isKey",
	"Comment": "determines if the specified classname and fieldname pair represent a\tkey field.",
	"Method": "boolean isKey(String className,String fieldName){\r\n    if (hasField(className, fieldName)) {\r\n        PersistenceClassElement classElement = getPersistenceClass(className);\r\n        if (classElement != null) {\r\n            String keyClass = classElement.getKeyClass();\r\n            if (keyClass != null)\r\n                return hasField(keyClass, fieldName);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ConnectionHolder.clearWarnings",
	"Comment": "clears all warnings reported for the underlying connectionobject.",
	"Method": "void clearWarnings(){\r\n    checkValidity();\r\n    con.clearWarnings();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.updatesAreDetected",
	"Comment": "retrieves whether or not a visible row update can be detected bycalling the method resultset.rowupdated.",
	"Method": "boolean updatesAreDetected(int type){\r\n    return databaseMetaData.updatesAreDetected(type);\r\n}"
}, {
	"Path": "org.glassfish.deployapi.config.SunConfigBean.getDDBean",
	"Comment": "return the javabean containing the deployment descriptor xml text associated with this dconfigbean.",
	"Method": "DDBean getDDBean(){\r\n    return ddBean;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.nullsAreSortedLow",
	"Comment": "retrieves whether null values are sorted low.sorted low means that null valuessort lower than any other value in a domain.in an ascending order,if this method returns true,null valueswill appear at the beginning. by contrast, the methodnullsaresortedatstart indicates whether null valuesare sorted at the beginning regardless of sort order.",
	"Method": "boolean nullsAreSortedLow(){\r\n    return databaseMetaData.nullsAreSortedLow();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlDate.cloneInternal",
	"Comment": "creates and returns a copy of this object without resetting the owner and field value.",
	"Method": "Object cloneInternal(){\r\n    return super.clone();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.EjbConversionHelper.ensureValidation",
	"Comment": "returns the flag whether the mapping conversion should validateall fields against schema columns.",
	"Method": "boolean ensureValidation(){\r\n    return ensureValidation;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.model.DeploymentDescriptorModel.getTypeObject",
	"Comment": "returns the class type of the specified element. \tif element denotes a field, it returns the type of the field. \tif element denotes a method, it returns the return type of the method. \tnote, element is either a field element as returned by getfield, or a \tmethod element as returned by getmethod executed on the same model \tinstance.",
	"Method": "Class getTypeObject(Object element){\r\n    Class type = super.getTypeObject(element);\r\n    if ((element != null) && (element instanceof MemberWrapper))\r\n        type = ((MemberWrapper) element).getType();\r\n    return type;\r\n}"
}, {
	"Path": "org.glassfish.admingui.connector.GadgetUserPref.setDisplayName",
	"Comment": "optional string to display in the user preferences edit window.",
	"Method": "void setDisplayName(String displayName){\r\n    this.displayName = displayName;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.getObjectById",
	"Comment": "this method locates a persistent instance in the cache of instancesmanaged by this persistencemanager.if an instance with the same objectidis found it is returned.otherwise, a new instance is created andassociated with the objectid.if the instance does not exist in the data store, then this method willnot fail.however, a request to access fields of the instance willthrow an exception.",
	"Method": "Object getObjectById(Object oid,Object getObjectById,Object oid,boolean validate){\r\n    boolean debug = logger.isLoggable(Logger.FINEST);\r\n    assertIsOpen();\r\n    assertActiveTransaction(true);\r\n    Object rc = null;\r\n    if (debug) {\r\n        Object[] items = new Object[] { oid, this, _jta };\r\n        logger.finest(\"sqlstore.persistencemgr.getbyobjid\", items);\r\n    }\r\n    if (oid == null)\r\n        return null;\r\n    StateManager sm = lookupObjectById(oid, null);\r\n    rc = sm.getPersistent();\r\n    if (!JDOHelper.isTransactional(rc)) {\r\n        boolean foundInstance = initializeFromVersionConsistencyCache(sm);\r\n        if (validate && !foundInstance) {\r\n            try {\r\n                sm.reload();\r\n            } catch (JDOException e) {\r\n                if (!sm.isValid()) {\r\n                    deregisterInstance(oid);\r\n                    sm.release();\r\n                }\r\n                throw e;\r\n            } catch (Exception e) {\r\n                throw new JDOUserException(I18NHelper.getMessage(messages, \"jdo.persistencemanagerimpl.fetchinstance.none\"), e);\r\n            }\r\n        }\r\n    }\r\n    sm.setValid();\r\n    return rc;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.PoolManagerImpl.flushConnectionPool",
	"Comment": "flush connection pool by reinitializing the connections established in the pool.",
	"Method": "boolean flushConnectionPool(PoolInfo poolInfo){\r\n    boolean result = false;\r\n    ResourcePool pool = getPool(poolInfo);\r\n    if (pool != null) {\r\n        result = pool.flushConnectionPool();\r\n    } else {\r\n        _logger.log(Level.WARNING, \"poolmgr.flush_noop_pool_not_initialized\", poolInfo);\r\n        String exString = localStrings.getString(\"poolmgr.flush_noop_pool_not_initialized\", poolInfo.toString());\r\n        throw new PoolingException(exString);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.CMPHelper.registerContainerHelper",
	"Comment": "register class that implements containerhelper interface should be called by a static method at class initialization time.",
	"Method": "void registerContainerHelper(ContainerHelper h){\r\n    containerHelper = h;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ServiceReferenceDescriptor.addRuntimePortInfo",
	"Comment": "special handling of case where runtime port info is added.ensures that port info is not duplicated when multipleruntime info instances are parsed using same standard descriptor.",
	"Method": "void addRuntimePortInfo(ServiceRefPortInfo runtimePortInfo){\r\n    ServiceRefPortInfo existing = null;\r\n    if (runtimePortInfo.hasServiceEndpointInterface()) {\r\n        existing = getPortInfoBySEI(runtimePortInfo.getServiceEndpointInterface());\r\n    }\r\n    if ((existing == null) && runtimePortInfo.hasWsdlPort()) {\r\n        existing = getPortInfoByPort(runtimePortInfo.getWsdlPort());\r\n    }\r\n    if (existing == null) {\r\n        if (portsInfo != null && portsInfo.size() > 0) {\r\n            LocalStringManagerImpl localStrings = new LocalStringManagerImpl(ServiceReferenceDescriptor.class);\r\n            DOLUtils.getDefaultLogger().warning(localStrings.getLocalString(\"enterprise.deployment.unknownportforruntimeinfo\", \"Runtime port info SEI {0} is not declared in standard service-ref \" + \"deployment descriptors (under port-component-ref), is this intended ?\", new Object[] { runtimePortInfo.getServiceEndpointInterface() }));\r\n        }\r\n        addPortInfo(runtimePortInfo);\r\n    } else {\r\n        if (!existing.hasServiceEndpointInterface()) {\r\n            existing.setServiceEndpointInterface(runtimePortInfo.getServiceEndpointInterface());\r\n        }\r\n        if (!existing.hasWsdlPort()) {\r\n            existing.setWsdlPort(runtimePortInfo.getWsdlPort());\r\n        }\r\n        for (Iterator iter = runtimePortInfo.getStubProperties().iterator(); iter.hasNext(); ) {\r\n            NameValuePairDescriptor next = (NameValuePairDescriptor) iter.next();\r\n            existing.addStubProperty(next);\r\n        }\r\n        for (Iterator iter = runtimePortInfo.getCallProperties().iterator(); iter.hasNext(); ) {\r\n            NameValuePairDescriptor next = (NameValuePairDescriptor) iter.next();\r\n            existing.addCallProperty(next);\r\n        }\r\n        if (runtimePortInfo.getMessageSecurityBinding() != null) {\r\n            existing.setMessageSecurityBinding(runtimePortInfo.getMessageSecurityBinding());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.persistent.timer.PersistentEJBTimerService._restoreTimers",
	"Comment": "the portion of timer restoration that deals with registering thejdk timer tasks and checking for missed expirations.",
	"Method": "Set<TimerState> _restoreTimers(Set<TimerState> timersEligibleForRestoration){\r\n    Map timersToRestore = new HashMap();\r\n    Set timerIdsToRemove = new HashSet();\r\n    Set<TimerState> result = new HashSet<TimerState>();\r\n    for (TimerState timer : timersEligibleForRestoration) {\r\n        TimerPrimaryKey timerId = getPrimaryKey(timer);\r\n        if (getTimerState(timerId) != null) {\r\n            logger.log(Level.FINE, \"@@@ Timer already restored: \" + timer);\r\n            result.add(timer);\r\n            continue;\r\n        }\r\n        long containerId = timer.getContainerId();\r\n        BaseContainer container = getContainer(containerId);\r\n        if (container != null) {\r\n            long appid = timer.getApplicationId();\r\n            if (appid == 0) {\r\n                timer.setApplicationId(container.getApplicationId());\r\n            }\r\n            Date initialExpiration = timer.getInitialExpiration();\r\n            Object timedObjectPrimaryKey = null;\r\n            if (container.getContainerType() == BaseContainer.ContainerType.ENTITY) {\r\n                timedObjectPrimaryKey = timer.getTimedObjectPrimaryKey();\r\n            }\r\n            RuntimeTimerState timerState = new // Don't need to store the info ref for persistent timer\r\n            RuntimeTimerState(// Don't need to store the info ref for persistent timer\r\n            timerId, // Don't need to store the info ref for persistent timer\r\n            initialExpiration, // Don't need to store the info ref for persistent timer\r\n            timer.getIntervalDuration(), // Don't need to store the info ref for persistent timer\r\n            container, // Don't need to store the info ref for persistent timer\r\n            timedObjectPrimaryKey, timer.getTimerSchedule(), null, true);\r\n            timerCache_.addTimer(timerId, timerState);\r\n            Date expirationTime = initialExpiration;\r\n            Date now = new Date();\r\n            if (timerState.isPeriodic()) {\r\n                Date lastExpiration = timer.getLastExpiration();\r\n                EJBTimerSchedule ts = timer.getTimerSchedule();\r\n                if ((lastExpiration == null) && now.after(initialExpiration)) {\r\n                    if (!timerState.isExpired()) {\r\n                        logger.log(Level.INFO, \"Rescheduling missed expiration for \" + \"periodic timer \" + timerState + \". Timer expirations should \" + \" have been delivered starting at \" + initialExpiration);\r\n                    }\r\n                } else if ((lastExpiration != null) && ((ts != null && ts.getNextTimeout(lastExpiration).getTimeInMillis() < now.getTime()) || ((ts == null) && now.getTime() - lastExpiration.getTime() > timer.getIntervalDuration()))) {\r\n                    logger.log(Level.INFO, \"Rescheduling missed expiration for \" + \"periodic timer \" + timerState + \".  Last timer expiration \" + \"occurred at \" + lastExpiration);\r\n                } else {\r\n                    expirationTime = calcNextFixedRateExpiration(timerState);\r\n                }\r\n            } else {\r\n                if (now.after(initialExpiration)) {\r\n                    logger.log(Level.INFO, \"Rescheduling missed expiration for \" + \"single-action timer \" + timerState + \". Timer expiration should \" + \" have been delivered at \" + initialExpiration);\r\n                }\r\n            }\r\n            if (expirationTime == null) {\r\n                logger.log(Level.INFO, \"Removing schedule-based timer \" + timerState + \" that will never expire again\");\r\n                timerIdsToRemove.add(timerId);\r\n            } else {\r\n                timersToRestore.put(timerState, expirationTime);\r\n                result.add(timer);\r\n            }\r\n        } else {\r\n            logger.log(Level.FINE, \"Skipping timer \" + timerId + \" for container that is not up: \" + containerId);\r\n        }\r\n    }\r\n    if (timerIdsToRemove.size() > 0) {\r\n        timerLocal_.remove(timerIdsToRemove);\r\n    }\r\n    for (Iterator entries = timersToRestore.entrySet().iterator(); entries.hasNext(); ) {\r\n        Map.Entry next = (Map.Entry) entries.next();\r\n        RuntimeTimerState nextTimer = (RuntimeTimerState) next.getKey();\r\n        TimerPrimaryKey timerId = nextTimer.getTimerId();\r\n        Date expiration = (Date) next.getValue();\r\n        scheduleTask(timerId, expiration);\r\n        logger.log(Level.FINE, \"EJBTimerService.restoreTimers(), scheduling timer \" + nextTimer);\r\n    }\r\n    logger.log(Level.FINE, \"DONE EJBTimerService.restoreTimers()\");\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.connector.AppClientSniffer.supportsArchiveType",
	"Comment": "this api is used to help determine if the sniffer should recognizethe current archive.if the sniffer does not support the archive type associated withthe current deployment, the sniffer should not recognize the archive.",
	"Method": "boolean supportsArchiveType(ArchiveType archiveType){\r\n    if (archiveType.equals(carType)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsStatementPooling",
	"Comment": "retrieves whether this database supports statement pooling.",
	"Method": "boolean supportsStatementPooling(){\r\n    return databaseMetaData.supportsStatementPooling();\r\n}"
}, {
	"Path": "com.sun.appserv.ProxyHandler.getSSLClientCertificateChain",
	"Comment": "gets the ssl client certificate chain with which the clienthad authenticated itself to the ssl offloader, and which thessl offloader has added as a custom request header on thegiven request.",
	"Method": "X509Certificate[] getSSLClientCertificateChain(HttpServletRequest request){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.setValid",
	"Comment": "mark this statemanager as valid. called before returning fromgetobjectbyid.",
	"Method": "void setValid(){\r\n    try {\r\n        getLock();\r\n        valid = true;\r\n    } finally {\r\n        releaseLock();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.ws.WLWebServiceNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptorinstance associated with this xmlnode",
	"Method": "void addDescriptor(Object descriptor){\r\n    WebServiceEndpoint endpoint = (WebServiceEndpoint) descriptor;\r\n    WebService webService = (WebService) getDescriptor();\r\n    webService.addEndpoint(endpoint);\r\n}"
}, {
	"Path": "org.glassfish.ejb.security.application.EJBSecurityManager.isCallerInRole",
	"Comment": "this method returns a boolean value indicating whether or not thecaller is in the specified role.",
	"Method": "boolean isCallerInRole(String role){\r\n    boolean ret = false;\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.entering(\"EJBSecurityManager\", \"isCallerInRole\", role);\r\n    }\r\n    EJBRoleRefPermission ejbrr = new EJBRoleRefPermission(ejbName, role);\r\n    SecurityContext sc;\r\n    if (runAs != null) {\r\n        ComponentInvocation ci = invMgr.getCurrentInvocation();\r\n        sc = (SecurityContext) ci.getOldSecurityContext();\r\n    } else {\r\n        sc = SecurityContext.getCurrent();\r\n    }\r\n    Set principalSet = (sc != null) ? sc.getPrincipalSet() : null;\r\n    ProtectionDomain prdm = getCachedProtectionDomain(principalSet, true);\r\n    String oldContextId = null;\r\n    try {\r\n        oldContextId = setPolicyContext(this.contextId);\r\n        ret = policy.implies(prdm, ejbrr);\r\n    } catch (SecurityException se) {\r\n        _logger.log(Level.SEVERE, \"jacc_is_caller_in_role_exception\", se);\r\n        ret = false;\r\n    } catch (Throwable t) {\r\n        _logger.log(Level.SEVERE, \"jacc_is_caller_in_role_exception\", t);\r\n        ret = false;\r\n    } finally {\r\n        try {\r\n            resetPolicyContext(oldContextId, this.contextId);\r\n        } catch (Throwable ex) {\r\n            _logger.log(Level.SEVERE, \"jacc_policy_context_exception\", ex);\r\n            ret = false;\r\n        }\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"JACC: isCallerInRole Result: \" + ret + \" EJBRoleRefPermission (Name) = \" + ejbrr.getName() + \" (Action) = \" + ejbrr.getActions() + \" (Codesource) = \" + prdm.getCodeSource());\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.RelationshipElementImpl.setUpperBound",
	"Comment": "set the upper cardinality bound for this relationship element.",
	"Method": "void setUpperBound(int upperBound){\r\n    Integer old = new Integer(getUpperBound());\r\n    Integer newBound = new Integer(upperBound);\r\n    try {\r\n        fireVetoableChange(PROP_CARDINALITY, old, newBound);\r\n        _upperBound = upperBound;\r\n        firePropertyChange(PROP_CARDINALITY, old, newBound);\r\n    } catch (PropertyVetoException e) {\r\n        throw new ModelVetoException(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.CMPHelper.commitInternalTransaction",
	"Comment": "called in a unspecified transaction context of a managed environment.according to p.364 of ejb 2.0 spec, cmp may need to manageits own transaction when its transaction attribute isnotsupported, never, supports.",
	"Method": "void commitInternalTransaction(PersistenceManager pm){\r\n    getContainerHelper().commitInternalTransaction(pm);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.ApplicationArchivist.validate",
	"Comment": "validates the dol objects associated with this archivist, usuallyit requires that a class loader being set on this archivist or passedas a parameter",
	"Method": "void validate(ClassLoader aClassLoader){\r\n    ClassLoader cl = aClassLoader;\r\n    if (cl == null) {\r\n        cl = classLoader;\r\n    }\r\n    if (cl == null) {\r\n        return;\r\n    }\r\n    descriptor.setClassLoader(cl);\r\n    descriptor.visit((ApplicationVisitor) new ApplicationValidator());\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.equals",
	"Comment": "determines whether obj is a sqlpersistencemanagerfactory with the same configuration",
	"Method": "boolean equals(Object obj){\r\n    if ((obj != null) && (obj instanceof SQLPersistenceManagerFactory)) {\r\n        SQLPersistenceManagerFactory pmf = (SQLPersistenceManagerFactory) obj;\r\n        return (pmf._persistenceManagerFactory.equals(this._persistenceManagerFactory));\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.IconNode.addIconInfo",
	"Comment": "writes xml tag and fragment for a particular icon information",
	"Method": "void addIconInfo(Node node,String lang,String smallIconUri,String largeIconUri){\r\n    Element iconNode = appendChild(node, TagNames.ICON);\r\n    if (Locale.ENGLISH.getLanguage().equals(lang)) {\r\n        iconNode.setAttributeNS(TagNames.XML_NAMESPACE, TagNames.XML_NAMESPACE_PREFIX + TagNames.LANG, lang);\r\n    }\r\n    appendTextChild(iconNode, TagNames.SMALL_ICON, smallIconUri);\r\n    appendTextChild(iconNode, TagNames.LARGE_ICON, largeIconUri);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.model.DeploymentDescriptorModel.findClassLoader",
	"Comment": "this method returns the class loader used to find mapping information \tfor the specified classname.this implementation overrides the one in \truntimemodel so that it always returns the classloader provided at \tconstruction time.",
	"Method": "ClassLoader findClassLoader(String className,ClassLoader classLoader){\r\n    return getClassLoader();\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.Java2DBProcessorHelper.fileIOError",
	"Comment": "provide a warning message to the user about inability to read a ddl file.",
	"Method": "void fileIOError(String regName,Throwable ex){\r\n    logI18NWarnMessage(\"Java2DBProcessorHelper.ioexception\", regName, null, ex);\r\n}"
}, {
	"Path": "com.sun.jaspic.config.factory.BaseAuthConfigFactory.getEffectedListeners",
	"Comment": "will return some extra listeners. iow, effected listeners could be reducedby removing any associated with a provider registration id that ismore specific than the one being added or removed.l",
	"Method": "Map<String, List<RegistrationListener>> getEffectedListeners(String regisID){\r\n    Map<String, List<RegistrationListener>> effectedListeners = new HashMap<String, List<RegistrationListener>>();\r\n    Set<String> listenerRegistrations = new HashSet<String>(id2RegisListenersMap.keySet());\r\n    for (String listenerID : listenerRegistrations) {\r\n        if (regIdImplies(regisID, listenerID)) {\r\n            if (!effectedListeners.containsKey(listenerID)) {\r\n                effectedListeners.put(listenerID, new ArrayList<RegistrationListener>());\r\n            }\r\n            effectedListeners.get(listenerID).addAll(id2RegisListenersMap.remove(listenerID));\r\n        }\r\n    }\r\n    return effectedListeners;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.ResourceEnvRefNode.writeResoureEnvReferences",
	"Comment": "writes all the runtime information for resource environment references",
	"Method": "void writeResoureEnvReferences(Node parent,ResourceEnvReferenceContainer descriptor){\r\n    Iterator resRefs = descriptor.getResourceEnvReferenceDescriptors().iterator();\r\n    if (resRefs.hasNext()) {\r\n        ResourceEnvRefNode resourceEnvRefNode = new ResourceEnvRefNode();\r\n        while (resRefs.hasNext()) {\r\n            resourceEnvRefNode.writeDescriptor(parent, TagNames.RESOURCE_ENV_REFERENCE, (ResourceEnvReferenceDescriptor) resRefs.next());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.persistence.ejb.entitybean.container.EntityContainer.beforeCompletion",
	"Comment": "called from basecontainer.syncimpl.beforecompletion, postinvokenotx",
	"Method": "void beforeCompletion(EJBContextImpl ctx){\r\n    EntityContextImpl context = (EntityContextImpl) ctx;\r\n    if (context.isInState(BeanState.DESTROYED)) {\r\n        return;\r\n    }\r\n    if ((!containerStateManager.isNullEJBObject(context) && !containerStateManager.isRemovedEJBObject(context)) || (!containerStateManager.isNullEJBLocalObject(context) && !containerStateManager.isRemovedEJBLocalObject(context))) {\r\n        if (context.isDirty()) {\r\n            enlistResourcesAndStore(context);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ResultSetWrapper40.getRowId",
	"Comment": "retrieves the value of the designated column in the current row of thisresultset object as a java.sql.rowid object in the javaprogramming language.",
	"Method": "RowId getRowId(int columnIndex,RowId getRowId,String columnLabel){\r\n    return resultSet.getRowId(columnLabel);\r\n}"
}, {
	"Path": "org.glassfish.ejb.embedded.EJBContainerProviderImpl.getLocations",
	"Comment": "create file objects corresponding to instance root and domain.xml location.",
	"Method": "Locations getLocations(Map<?, ?> properties){\r\n    String installed_root_location = null;\r\n    String instance_root_location = null;\r\n    String domain_file_location = null;\r\n    File installed_root = null;\r\n    File instance_root = null;\r\n    File domain_file = null;\r\n    boolean reuse_instance_location = false;\r\n    if (properties != null) {\r\n        installed_root_location = (String) properties.get(GF_INSTALLATION_ROOT);\r\n        instance_root_location = (String) properties.get(GF_INSTANCE_ROOT);\r\n        domain_file_location = (String) properties.get(GF_DOMAIN_FILE);\r\n        reuse_instance_location = getBooleanProperty(properties, GF_INSTANCE_REUSE);\r\n    }\r\n    if (installed_root_location == null) {\r\n        try {\r\n            installed_root_location = Which.jarFile(getClass()).getParentFile().getParentFile().getAbsolutePath();\r\n        } catch (Exception e) {\r\n            _logger.log(Level.SEVERE, \"ejb.embedded.cannot_determine_installation_location\");\r\n            _logger.log(Level.FINE, e.getMessage(), e);\r\n        }\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"[EJBContainerProviderImpl] installed_root_location : \" + installed_root_location);\r\n    }\r\n    if (installed_root_location != null) {\r\n        installed_root = getValidFile(installed_root_location, \"ejb.embedded.installation_location_not_exists\");\r\n        if (installed_root != null) {\r\n            if (instance_root_location == null) {\r\n                instance_root_location = installed_root_location + File.separatorChar + \"domains\" + File.separatorChar + \"domain1\";\r\n            }\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.fine(\"[EJBContainerProviderImpl] instance_root_location: \" + instance_root_location);\r\n            }\r\n            instance_root = getValidFile(instance_root_location, \"ejb.embedded.instance_location_not_exists\");\r\n        }\r\n    }\r\n    if (instance_root != null && domain_file_location == null) {\r\n        domain_file_location = instance_root_location + File.separatorChar + \"config\" + File.separatorChar + \"domain.xml\";\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"[EJBContainerProviderImpl] domain_file_location : \" + domain_file_location);\r\n    }\r\n    if (domain_file_location != null) {\r\n        domain_file = getValidFile(domain_file_location, \"ejb.embedded.configuration_file_location_not_exists\");\r\n        if (domain_file != null) {\r\n            if (!reuse_instance_location) {\r\n                File temp_domain_file = null;\r\n                try {\r\n                    DomainXmlTransformer dxf = new DomainXmlTransformer(domain_file, _logger);\r\n                    boolean keep_ports = (properties == null) ? false : ((properties.get(GF_WEB_HTTP_PORT) == null) ? false : true);\r\n                    temp_domain_file = dxf.transform(keep_ports);\r\n                } catch (Exception e) {\r\n                    throw new EJBException(localStrings.getString(\"ejb.embedded.exception_creating_temporary_domain_xml_file\"), e);\r\n                }\r\n                if (temp_domain_file != null) {\r\n                    domain_file = temp_domain_file;\r\n                } else {\r\n                    throw new EJBException(localStrings.getString(\"ejb.embedded.failed_create_temporary_domain_xml_file\"));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return new Locations(installed_root, instance_root, domain_file, reuse_instance_location);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.ApplicationNode.registerBundle",
	"Comment": "register this node as a root node capable of loading entire dd files",
	"Method": "String registerBundle(Map publicIDToDTD){\r\n    publicIDToDTD.put(PUBLIC_DTD_ID, SYSTEM_ID);\r\n    publicIDToDTD.put(PUBLIC_DTD_ID_12, SYSTEM_ID_12);\r\n    return tag.getQName();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.OrderedSet.addAll",
	"Comment": "add all the elements in the given set that are not alreadyin this ordered set.",
	"Method": "boolean addAll(Collection<? extends T> c){\r\n    boolean setChanged = false;\r\n    if (c != null) {\r\n        for (T o : c) {\r\n            if (add(o)) {\r\n                setChanged = true;\r\n            }\r\n        }\r\n    }\r\n    return setChanged;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.Environment.canFindClass",
	"Comment": "look for the specified class in the class map.if not there,use the class path to find the class.if still not found,return false.",
	"Method": "boolean canFindClass(String className){\r\n    return findClass(className) != null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.setQueryTimeout",
	"Comment": "sets the number of seconds to wait for a query statementto execute in the datastore associated with this persistencemanagerfactory.",
	"Method": "void setQueryTimeout(int timeout){\r\n    throw new JDOUnsupportedOptionException(// NOI18N\r\n    I18NHelper.getMessage(messages, \"jdo.persistencemanagerfactoryimpl.notsupported\"));\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.BundleDescriptor.getMessageDestinationByName",
	"Comment": "returns a message destination descriptor that i have by thesame name, or throws an illegalargumentexception",
	"Method": "MessageDestinationDescriptor getMessageDestinationByName(String name){\r\n    for (MessageDestinationDescriptor mtd : getMessageDestinations()) {\r\n        if (mtd.getName().equals(name)) {\r\n            return mtd;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionmessagedestbundle\", \"Referencing error: this bundle has no message destination of name: {0}\", new Object[] { name }));\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getConstructorInterceptors",
	"Comment": "return bean constructor for aroundconstruct interceptors",
	"Method": "List<EjbInterceptor> getConstructorInterceptors(ClassLoader classLoader){\r\n    List<EjbInterceptor> callbackInterceptors = null;\r\n    String shortClassName = ejbClassName;\r\n    int i = ejbClassName.lastIndexOf('.');\r\n    if (i > -1) {\r\n        shortClassName = ejbClassName.substring(i + 1);\r\n    }\r\n    JCDIService jcdiService = (sl == null) ? null : sl.getService(JCDIService.class);\r\n    if (jcdiService != null && jcdiService.isJCDIEnabled(getEjbBundleDescriptor())) {\r\n        try {\r\n            Class beanClass = classLoader.loadClass(getEjbClassName());\r\n            Constructor<?>[] ctors = beanClass.getDeclaredConstructors();\r\n            String[] parameterClassNames = null;\r\n            MethodDescriptor dummy = new MethodDescriptor();\r\n            for (Constructor<?> ctor : ctors) {\r\n                if (ctor.getAnnotation(Inject.class) != null) {\r\n                    Class[] ctorParamTypes = ctor.getParameterTypes();\r\n                    parameterClassNames = dummy.getParameterClassNamesFor(null, ctorParamTypes);\r\n                    callbackInterceptors = getClassOrMethodInterceptors(new MethodDescriptor(shortClassName, null, parameterClassNames, MethodDescriptor.EJB_BEAN));\r\n                    break;\r\n                }\r\n            }\r\n        } catch (Throwable t) {\r\n            _logger.log(Level.SEVERE, \"enterprise.deployment.backend.methodClassLoadFailure\", new Object[] { this.getEjbClassName() });\r\n            throw new RuntimeException(t);\r\n        }\r\n    }\r\n    if (callbackInterceptors == null) {\r\n        callbackInterceptors = getClassOrMethodInterceptors(new MethodDescriptor(shortClassName, null, new String[0], MethodDescriptor.EJB_BEAN));\r\n    }\r\n    return callbackInterceptors;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.UpdateStatement.removeDBStatement",
	"Comment": "removes the db statement for the specified connection from the cacheand closes this statement.",
	"Method": "DBStatement removeDBStatement(Transaction tran){\r\n    synchronized (dbStatementCache) {\r\n        DBStatement s = (DBStatement) dbStatementCache.remove(tran);\r\n        return s;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.enterprise.iiop.util.S1ASThreadPoolManager.getDefaultThreadPool",
	"Comment": "returns the first instance of threadpool in the threadpoolmanager",
	"Method": "ThreadPool getDefaultThreadPool(){\r\n    try {\r\n        return getThreadPool(0);\r\n    } catch (NoSuchThreadPoolException nstpe) {\r\n        if (_logger.isLoggable(Level.WARNING)) {\r\n            _logger.log(Level.WARNING, \"No default ThreadPool defined \", nstpe);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.AppclientCommandArguments.initValuedArgs",
	"Comment": "initializes the list of valued arguments with nulls for all values.",
	"Method": "Map<String, AtomicReference<String>> initValuedArgs(){\r\n    HashMap<String, AtomicReference<String>> result = new HashMap<String, AtomicReference<String>>();\r\n    for (String s : valuedArgNames) {\r\n        result.put(s, new AtomicReference<String>(null));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.FieldGroupElement.addField",
	"Comment": "add the supplied field to the collection of fields maintained by this\tholder.",
	"Method": "void addField(PersistenceFieldElement field){\r\n    addFields(new PersistenceFieldElement[] { field });\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ConnectionHolder40.createClob",
	"Comment": "constructs an object that implements the clob interface. the objectreturned initially contains no data.the setasciistream,setcharacterstream and setstring methods ofthe clob interface may be used to add data to the clob.",
	"Method": "Clob createClob(){\r\n    checkValidity();\r\n    jdbcPreInvoke();\r\n    return con.createClob();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.isPrimitive",
	"Comment": "determines if the specified classname represents a primitive type.",
	"Method": "boolean isPrimitive(String className,String fieldName,boolean isPrimitive,String className){\r\n    return ((className != null) && JavaTypeHelper.getPrimitiveClass(className) != null);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.Descriptor.computeStackTypes",
	"Comment": "stacksig is a signature for a list of types on the jvm stack with thelast type in the signature intended to be on the top of jvm stack.for each type in the signature, pushes an integer objects identifyingthe types on top of the input stack object.",
	"Method": "void computeStackTypes(String stackSig,Stack stack){\r\n    for (int idx = 0; idx < stackSig.length(); idx++) {\r\n        int tp = 0;\r\n        switch(stackSig.charAt(idx)) {\r\n            case 'B':\r\n            case 'C':\r\n            case 'Z':\r\n            case 'S':\r\n            case 'I':\r\n                tp = T_INT;\r\n                break;\r\n            case 'F':\r\n                tp = T_FLOAT;\r\n                break;\r\n            case 'J':\r\n                tp = T_LONG;\r\n                break;\r\n            case 'D':\r\n                tp = T_DOUBLE;\r\n                break;\r\n            case '?':\r\n                tp = T_UNKNOWN;\r\n                break;\r\n            case 'W':\r\n                tp = T_WORD;\r\n                break;\r\n            case 'X':\r\n                tp = T_TWOWORD;\r\n                break;\r\n            case 'A':\r\n                tp = TC_OBJECT;\r\n                break;\r\n            case '[':\r\n                tp = TC_OBJECT;\r\n                while (stackSig.charAt(idx) == '[' || stackSig.charAt(idx) == ']') idx++;\r\n                if (stackSig.charAt(idx) != 'L')\r\n                    break;\r\n            case 'L':\r\n                tp = TC_OBJECT;\r\n                idx = stackSig.indexOf(';', idx);\r\n                break;\r\n            default:\r\n                throw new InsnError(\"bad signature char\");\r\n        }\r\n        stack.push(new Integer(tp));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.VMOp.argTypes",
	"Comment": "return the type descriptor for the stack arguments to the operation.",
	"Method": "String argTypes(){\r\n    return stackArgTypes;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.JdbcTempHandler.setJDBCPoolWizard",
	"Comment": "this handler gets the default values and resource type and puts them in session",
	"Method": "void setJDBCPoolWizard(HandlerContext handlerCtx){\r\n    Boolean fromStep2 = (Boolean) handlerCtx.getInputValue(\"fromStep2\");\r\n    if ((fromStep2 != null) && fromStep2) {\r\n    } else {\r\n        Map attrMap = (Map) handlerCtx.getInputValue(\"attrMap\");\r\n        Map sessionMap = handlerCtx.getFacesContext().getExternalContext().getSessionMap();\r\n        sessionMap.put(\"wizardMap\", attrMap);\r\n        sessionMap.put(\"wizardPoolExtra\", new HashMap());\r\n    }\r\n    handlerCtx.setOutputValue(\"ResTypeList\", resTypeList);\r\n    handlerCtx.setOutputValue(\"DBVendorList\", dbVendorList);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.StatementWrapper.setFetchSize",
	"Comment": "gives the jdbc driver a hint as to the number of rows that shouldbe fetched from the database when more rows are needed.the numberof rows specified affects only result sets created using thisstatement. if the value specified is zero, then the hint is ignored.the default value is zero.",
	"Method": "void setFetchSize(int rows){\r\n    jdbcStatement.setFetchSize(rows);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.getDouble",
	"Comment": "retrieves the value of a jdbc double parameter as a doublein the java programming language.",
	"Method": "double getDouble(int parameterIndex,double getDouble,String parameterName){\r\n    return callableStatement.getDouble(parameterName);\r\n}"
}, {
	"Path": "org.glassfish.concurrent.admin.ListManagedScheduledExecutorServices.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        Collection<ManagedScheduledExecutorService> managedScheduledExecutorServices = domain.getResources().getResources(ManagedScheduledExecutorService.class);\r\n        List<Map<String, String>> resourcesList = new ArrayList<Map<String, String>>();\r\n        List<DefaultResourceProxy> drps = habitat.getAllServices(DefaultResourceProxy.class);\r\n        for (ManagedScheduledExecutorService managedScheduledExecutorService : managedScheduledExecutorServices) {\r\n            String jndiName = managedScheduledExecutorService.getJndiName();\r\n            if (bindableResourcesHelper.resourceExists(jndiName, target)) {\r\n                ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n                part.setMessage(jndiName);\r\n                Map<String, String> resourceNameMap = new HashMap<String, String>();\r\n                String logicalName = DefaultResourceProxy.Util.getLogicalName(drps, jndiName);\r\n                if (logicalName != null) {\r\n                    resourceNameMap.put(\"logical-jndi-name\", logicalName);\r\n                }\r\n                resourceNameMap.put(\"name\", jndiName);\r\n                resourcesList.add(resourceNameMap);\r\n            }\r\n        }\r\n        Properties extraProperties = new Properties();\r\n        extraProperties.put(\"managedScheduledExecutorServices\", resourcesList);\r\n        report.setExtraProperties(extraProperties);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.managed.scheduled.executor.service.failed\", \"List managed scheduled executor services failed\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.SelectStatement.generatePrimaryTableText",
	"Comment": "generates the table text for the first column of the column list.",
	"Method": "QueryTable generatePrimaryTableText(StringBuffer primaryTableText){\r\n    QueryTable primaryTable = ((ColumnRef) columns.get(0)).getQueryTable();\r\n    appendTableText(primaryTableText, primaryTable);\r\n    return primaryTable;\r\n}"
}, {
	"Path": "org.glassfish.admin.amxtest.monitor.MonitorTest.testStatsClassSuppliesAllStatistics",
	"Comment": "verify that the stats class for each monitoringstats supplies all statistics found in itself, and that this matches those advertised by monitoringstats.",
	"Method": "void testStatsClassSuppliesAllStatistics(){\r\n    final long start = now();\r\n    final Set<MonitoringStats> all = getAllMonitoringStats();\r\n    testAll(Util.toObjectNames(all), \"checkStatsClassSuppliesAllStatistics\");\r\n    printElapsed(\"testStatsClassSuppliesAllStatistics\", all.size(), start);\r\n}"
}, {
	"Path": "com.sun.gjc.util.SQLTraceCache.checkAndUpdateCache",
	"Comment": "request for adding a sql query in the form of sqltrace to this cache.if the query is already foundin the list, the number of times it is executed is incremented by onealong with the timestamp.if the query is a new one, it is added to the list.",
	"Method": "void checkAndUpdateCache(SQLTrace cacheObj){\r\n    synchronized (list) {\r\n        if (cacheObj != null) {\r\n            int index = list.indexOf(cacheObj);\r\n            if (index != -1) {\r\n                SQLTrace cache = (SQLTrace) list.get(index);\r\n                cache.setNumExecutions(cache.getNumExecutions() + 1);\r\n                cache.setLastUsageTime(System.currentTimeMillis());\r\n            } else {\r\n                cacheObj.setNumExecutions(1);\r\n                cacheObj.setLastUsageTime(System.currentTimeMillis());\r\n                list.add(cacheObj);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.getBasicValidationList",
	"Comment": "computes and returns a collection of validationcomponents \trepresenting the tests to be performed during parse.",
	"Method": "Collection getBasicValidationList(){\r\n    ArrayList list = new ArrayList();\r\n    String className = getClassName();\r\n    list.add(createClassExistenceComponent(className));\r\n    list.add(createClassPersistenceComponent(className));\r\n    list.addAll(getDatabaseValidationList());\r\n    list.addAll(getFieldsValidationList());\r\n    return Collections.unmodifiableCollection(list);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.getScanner",
	"Comment": "returns the scanner for this archivist, usually it is the scanner regiteredwith the same module type as this archivist, but subclasses can return adifferent version",
	"Method": "ModuleScanner getScanner(){\r\n    Scanner scanner = null;\r\n    try {\r\n        scanner = habitat.getService(Scanner.class, getModuleType().toString());\r\n        if (scanner == null || !(scanner instanceof ModuleScanner)) {\r\n            logger.log(Level.SEVERE, \"Cannot find module scanner for \" + this.getManifest());\r\n        }\r\n    } catch (MultiException e) {\r\n        logger.log(Level.SEVERE, \"Cannot find scanner for \" + this.getModuleType(), e);\r\n    }\r\n    return (ModuleScanner) scanner;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.getConnectorDescriptor",
	"Comment": "obtains the connector descriptor pertaining to rar.if connectordescriptor is present in registry, it is obtained fromregistry and returned. else it is explicitly read from directorywhere rar is exploded.",
	"Method": "ConnectorDescriptor getConnectorDescriptor(String rarName){\r\n    return connectorService.getConnectorDescriptor(rarName);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.getRetainValues",
	"Comment": "returns the boolean value for the flag that will not cause the eviction of persistent\tinstances after transaction completion.",
	"Method": "boolean getRetainValues(){\r\n    return retainValues;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingReferenceKeyElementImpl.getReferencedColumns",
	"Comment": "get all referenced columns in this reference key.this method is \tprovided as part of the implementation of the referencekey interface\tbut should only be used when a referencekey object is used or by \tthe runtime.",
	"Method": "ColumnElement[] getReferencedColumns(){\r\n    ColumnPairElement[] columnPairs = getColumnPairs();\r\n    int i, count = ((columnPairs != null) ? columnPairs.length : 0);\r\n    ColumnElement[] columns = new ColumnElement[count];\r\n    for (i = 0; i < count; i++) columns[i] = columnPairs[i].getReferencedColumn();\r\n    return columns;\r\n}"
}, {
	"Path": "org.glassfish.admingui.plugin.jms.JmsHandlers.flushJMSDestination",
	"Comment": "this handler takes in selected rows, and removes selected config",
	"Method": "void flushJMSDestination(HandlerContext handlerCtx){\r\n    List<Map> selectedRows = (List) handlerCtx.getInputValue(\"selectedRows\");\r\n    try {\r\n        for (Map oneRow : selectedRows) {\r\n            String name = (String) oneRow.get(\"name\");\r\n            String type = ((String) oneRow.get(\"type\"));\r\n            JMXUtil.invoke(getJmsDestinationObjectName(SUBTYPE_CONFIG, name, type), OP_PURGE);\r\n        }\r\n    } catch (Exception ex) {\r\n        GuiUtil.handleException(handlerCtx, ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlDate.setDate",
	"Comment": "sets the day of the month of this sqldate object to thespecified value.",
	"Method": "void setDate(int date){\r\n    this.makeDirty();\r\n    super.setDate(date);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.recordUpdatedField",
	"Comment": "marks the field fielddesc as set and schedules local fieldsto be written to the data store.",
	"Method": "void recordUpdatedField(FieldDesc fieldDesc){\r\n    boolean debug = logger.isLoggable(Logger.FINEST);\r\n    if (!fieldDesc.isRelationshipField() && (fieldDesc.sqlProperties & FieldDesc.PROP_RECORD_ON_UPDATE) > 0) {\r\n        if (debug) {\r\n            logger.finest(\"sqlstore.sqlstatemanager.recordingfield\", fieldDesc);\r\n        }\r\n        getUpdateDesc().recordUpdatedField((LocalFieldDesc) fieldDesc);\r\n    }\r\n    if (debug) {\r\n        logger.finest(\"sqlstore.sqlstatemanager.makedirtyfield\", fieldDesc);\r\n    }\r\n    setSetMaskBit(fieldDesc.absoluteID);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.authentication.BasicPasswordAuthenticationService.isContainerContextAEJBContainerObject",
	"Comment": "todo v3 use this instead of iscontainercontextacontainerobject",
	"Method": "boolean isContainerContextAEJBContainerObject(){\r\n    return ComponentInvocation.ComponentInvocationType.EJB_INVOCATION.equals(getCurrentComponentType());\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.RelationRoleDescriptor.setPersistenceDescriptor",
	"Comment": "can be set to null if there is no associated persistence descriptor.",
	"Method": "void setPersistenceDescriptor(PersistenceDescriptor newPers){\r\n    if (this.pers != null) {\r\n        this.pers.invalidate();\r\n    }\r\n    this.pers = newPers;\r\n    if (newPers != null) {\r\n        this.owner = (EjbCMPEntityDescriptor) newPers.getParentDescriptor();\r\n    }\r\n    invalidateCMRFieldStuff();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.implementsInterface",
	"Comment": "determines if the specified class implements the specified interface. \tnote, class element is a model specific class representation as returned \tby a getclass call executed on the same model instance.",
	"Method": "boolean implementsInterface(Object classElement,String interfaceName){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "org.glassfish.resources.admin.cli.CreateJndiResource.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    HashMap attrList = new HashMap();\r\n    attrList.put(FACTORY_CLASS, factoryClass);\r\n    attrList.put(RES_TYPE, resType);\r\n    attrList.put(JNDI_LOOKUP, jndiLookupName);\r\n    attrList.put(ENABLED, enabled.toString());\r\n    attrList.put(JNDI_NAME, jndiName);\r\n    attrList.put(ServerTags.DESCRIPTION, description);\r\n    ResourceStatus rs;\r\n    try {\r\n        rs = jndiResManager.create(domain.getResources(), attrList, properties, target);\r\n    } catch (Exception e) {\r\n        Logger.getLogger(CreateJndiResource.class.getName()).log(Level.SEVERE, \"Unable to create jndi resource \" + jndiName, e);\r\n        String def = \"jndi resource: {0} could not be created, reason: {1}\";\r\n        report.setMessage(localStrings.getLocalString(\"create.jndi.resource.fail\", def, jndiName) + \" \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    ActionReport.ExitCode ec = ActionReport.ExitCode.SUCCESS;\r\n    if (rs.getStatus() == ResourceStatus.FAILURE) {\r\n        ec = ActionReport.ExitCode.FAILURE;\r\n        if (rs.getMessage() == null) {\r\n            report.setMessage(localStrings.getLocalString(\"create.jndi.resource.fail\", \"jndi resource {0} creation failed\", jndiName, \"\"));\r\n        }\r\n        if (rs.getException() != null)\r\n            report.setFailureCause(rs.getException());\r\n    }\r\n    if (rs.getMessage() != null) {\r\n        report.setMessage(rs.getMessage());\r\n    }\r\n    report.setActionExitCode(ec);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.MQAddressList.removeMQUrl",
	"Comment": "deletes the url represented by the jmshost from the addresslist.",
	"Method": "void removeMQUrl(JmsHost host){\r\n    MQUrl url = createUrl(host);\r\n    urlList.remove(url);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.QueryImpl.getPersistenceManager",
	"Comment": "get the persistencemanager associated with this query.if this query has no persistencemanager return null.",
	"Method": "com.sun.jdo.api.persistence.support.PersistenceManager getPersistenceManager(){\r\n    return (pm == null) ? null : pm.getCurrentWrapper();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jmac.config.ConfigHelper.hasExactMatchAuthProvider",
	"Comment": "check if there is a provider register for a given layer and appctxt.",
	"Method": "boolean hasExactMatchAuthProvider(){\r\n    boolean exactMatch = false;\r\n    AuthConfigProvider p = factory.getConfigProvider(layer, appCtxt, null);\r\n    if (p != null) {\r\n        String[] IDs = factory.getRegistrationIDs(p);\r\n        for (String i : IDs) {\r\n            RegistrationContext c = factory.getRegistrationContext(i);\r\n            if (layer.equals(c.getMessageLayer()) && appCtxt.equals(c.getAppContext())) {\r\n                exactMatch = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return exactMatch;\r\n}"
}, {
	"Path": "org.glassfish.resources.javamail.admin.cli.CreateJavaMailResource.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    HashMap attributes = new HashMap();\r\n    attributes.put(org.glassfish.resources.admin.cli.ResourceConstants.JNDI_NAME, jndiName);\r\n    attributes.put(org.glassfish.resources.admin.cli.ResourceConstants.MAIL_HOST, mailHost);\r\n    attributes.put(org.glassfish.resources.admin.cli.ResourceConstants.MAIL_USER, mailUser);\r\n    attributes.put(org.glassfish.resources.admin.cli.ResourceConstants.MAIL_FROM_ADDRESS, fromAddress);\r\n    attributes.put(org.glassfish.resources.admin.cli.ResourceConstants.MAIL_STORE_PROTO, storeProtocol);\r\n    attributes.put(org.glassfish.resources.admin.cli.ResourceConstants.MAIL_STORE_PROTO_CLASS, storeProtocolClass);\r\n    attributes.put(org.glassfish.resources.admin.cli.ResourceConstants.MAIL_TRANS_PROTO, transportProtocol);\r\n    attributes.put(org.glassfish.resources.admin.cli.ResourceConstants.MAIL_TRANS_PROTO_CLASS, transportProtocolClass);\r\n    attributes.put(org.glassfish.resources.admin.cli.ResourceConstants.MAIL_DEBUG, debug.toString());\r\n    attributes.put(org.glassfish.resources.admin.cli.ResourceConstants.ENABLED, enabled.toString());\r\n    attributes.put(ServerTags.DESCRIPTION, description);\r\n    ResourceStatus rs;\r\n    try {\r\n        rs = mailResMgr.create(domain.getResources(), attributes, properties, target);\r\n    } catch (Exception e) {\r\n        Logger.getLogger(CreateJavaMailResource.class.getName()).log(Level.SEVERE, \"Unable to create Mail Resource \" + jndiName, e);\r\n        String def = \"Mail resource: {0} could not be created\";\r\n        report.setMessage(localStrings.getLocalString(\"create.mail.resource.fail\", def, jndiName) + \" \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    ActionReport.ExitCode ec = ActionReport.ExitCode.SUCCESS;\r\n    if (rs.getStatus() == ResourceStatus.FAILURE) {\r\n        ec = ActionReport.ExitCode.FAILURE;\r\n        if (rs.getMessage() == null) {\r\n            report.setMessage(localStrings.getLocalString(\"create.mail.resource.fail\", \"Unable to create Mail Resource {0}.\", jndiName));\r\n        }\r\n        if (rs.getException() != null)\r\n            report.setFailureCause(rs.getException());\r\n    }\r\n    if (rs.getMessage() != null) {\r\n        report.setMessage(rs.getMessage());\r\n    }\r\n    report.setActionExitCode(ec);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.stats.BoundaryStatisticImpl.getUpperBound",
	"Comment": "return the highest possible value, that this statistic is permitted to attain",
	"Method": "long getUpperBound(){\r\n    return upperBound;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.SymbolTable.getDeclaration",
	"Comment": "checks the symbol table for the actual declaration of the specified identifier. the method returns the declaration object if available ornull for an undeclared identifier.",
	"Method": "Object getDeclaration(String ident){\r\n    return symbols.get(ident.toUpperCase());\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOCodeGenerator.getCMP11Generator",
	"Comment": "returns instance of generator for cmp1.1 beans in this module.",
	"Method": "JDOConcreteBeanGenerator getCMP11Generator(){\r\n    if (cmp11Generator == null) {\r\n        cmp11Generator = new JDOConcreteBean11Generator(loader, model, nameMapper);\r\n        addSignatures(cmp11Generator);\r\n    }\r\n    return cmp11Generator;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnReadEnv.pool",
	"Comment": "get the constant pool which applies to the method being decoded",
	"Method": "ConstantPool pool(){\r\n    return codeEnv.pool();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.isConnectorConnectionPoolDeployed",
	"Comment": "checks if a conncetor connection pool has been deployed to this serverinstance",
	"Method": "boolean isConnectorConnectionPoolDeployed(PoolInfo poolInfo){\r\n    return ccPoolAdmService.isConnectorConnectionPoolDeployed(poolInfo);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.io.runtime.GFApplicationRuntimeDDFile.registerBundle",
	"Comment": "register the root node for this runtime deployment descriptor filein the root nodes map, and also in the dtd map which will be used fordtd validation.",
	"Method": "void registerBundle(Map<String, Class> rootNodesMap,Map<String, String> publicIDToDTDMap,Map<String, List<Class>> versionUpgrades){\r\n    rootNodesMap.put(GFApplicationRuntimeNode.registerBundle(publicIDToDTDMap), GFApplicationRuntimeNode.class);\r\n}"
}, {
	"Path": "org.glassfish.concurrent.admin.DeleteManagedExecutorService.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        ResourceStatus rs = managedExecutorServiceMgr.delete(domain.getResources(), jndiName, target);\r\n        if (rs.getMessage() != null) {\r\n            report.setMessage(rs.getMessage());\r\n        }\r\n        if (rs.getStatus() == ResourceStatus.SUCCESS) {\r\n            report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n        } else {\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            if (rs.getException() != null)\r\n                report.setFailureCause(rs.getException());\r\n        }\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.managed.executor.service.failed\", \"Managed executor service {0} deletion failed\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.model.DeploymentDescriptorModel.getDeclaringClass",
	"Comment": "returns the string representation of declaring class of \tthe specified member element.note, the member element is \teither a class element as returned by getclass, a field element \tas returned by getfield, a constructor element as returned by \tgetconstructor, or a method element as returned by getmethod \texecuted on the same model instance.this implementation expects \tthe member element to be a reflection instance or a wrapped member \tinstance.",
	"Method": "String getDeclaringClass(Object memberElement,Class getDeclaringClass){\r\n    if ((memberElement != null) && (memberElement instanceof MemberWrapper)) {\r\n        Class classElement = ((MemberWrapper) memberElement).getDeclaringClass();\r\n        return ((classElement != null) ? classElement.getName() : null);\r\n    }\r\n    return super.getDeclaringClass(memberElement);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.work.WorkCoordinator.setException",
	"Comment": "accepts an exception object and converts to aworkexception object.",
	"Method": "void setException(Throwable e){\r\n    if (getState() < STARTED) {\r\n        if (e instanceof WorkRejectedException) {\r\n            exception = (WorkException) e;\r\n        } else if (e instanceof WorkException) {\r\n            WorkException we = (WorkException) e;\r\n            exception = new WorkRejectedException(we);\r\n            exception.setErrorCode(we.getErrorCode());\r\n        } else {\r\n            exception = new WorkRejectedException(e);\r\n            exception.setErrorCode(WorkException.UNDEFINED);\r\n        }\r\n    } else {\r\n        if (e instanceof WorkCompletedException) {\r\n            exception = (WorkException) e;\r\n        } else if (e instanceof WorkException) {\r\n            WorkException we = (WorkException) e;\r\n            exception = new WorkCompletedException(we);\r\n            exception.setErrorCode(we.getErrorCode());\r\n        } else {\r\n            exception = new WorkCompletedException(e);\r\n            exception.setErrorCode(WorkException.UNDEFINED);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ServiceRefPortInfo.resolveLinkName",
	"Comment": "try to resolve the current link name value to a webserviceendpointobject.",
	"Method": "WebServiceEndpoint resolveLinkName(){\r\n    WebServiceEndpoint port = null;\r\n    String linkName = portComponentLinkName;\r\n    if ((linkName != null) && (linkName.length() > 0)) {\r\n        int hashIndex = linkName.indexOf('#');\r\n        boolean absoluteLink = (hashIndex != -1);\r\n        BundleDescriptor bundleDescriptor = getBundleDescriptor();\r\n        Application app = bundleDescriptor.getApplication();\r\n        BundleDescriptor targetBundle = bundleDescriptor;\r\n        String portName = linkName;\r\n        if ((app != null) && absoluteLink) {\r\n            String relativeModuleUri = linkName.substring(0, hashIndex);\r\n            portName = linkName.substring(hashIndex + 1);\r\n            targetBundle = app.getRelativeBundle(bundleDescriptor, relativeModuleUri);\r\n        }\r\n        if (targetBundle != null) {\r\n            LinkedList bundles = new LinkedList();\r\n            bundles.addFirst(targetBundle);\r\n            if ((app != null) && !absoluteLink) {\r\n                bundles.addAll(app.getBundleDescriptors());\r\n            }\r\n            for (Iterator iter = bundles.iterator(); iter.hasNext(); ) {\r\n                BundleDescriptor next = (BundleDescriptor) iter.next();\r\n                port = next.getWebServiceEndpointByName(portName);\r\n                if (port != null) {\r\n                    setPortComponentLink(port);\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return port;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.util.ZipFileRegistry.zipFiles",
	"Comment": "returns an enumeration of the zip files in the registryeach element is a zipfile.",
	"Method": "Enumeration zipFiles(){\r\n    return zipFileMap.elements();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.UpdateObjectDescImpl.removeUpdatedJoinTableRelationship",
	"Comment": "removes a previously scheduled jointable entry for relationshipfield fielddesc.the actionparameter specifies, if the entry to be removed isscheduled for creation or removal.",
	"Method": "boolean removeUpdatedJoinTableRelationship(ForeignFieldDesc fieldDesc,SQLStateManager foreignSM,int action){\r\n    HashMap updateJoinTableDescs = null;\r\n    if ((updatedJoinTableRelationships == null) || ((updateJoinTableDescs = (HashMap) updatedJoinTableRelationships.get(fieldDesc)) == null)) {\r\n        return false;\r\n    }\r\n    UpdateJoinTableDesc desc = (UpdateJoinTableDesc) updateJoinTableDescs.get(foreignSM);\r\n    if (desc != null && desc.getAction() == action) {\r\n        return (updateJoinTableDescs.remove(foreignSM) != null);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.getIgnoreCache",
	"Comment": "returns the boolean value for the flag that allows the user to request that queriesbe optimized to return approximate results by ignoring changed values in the cache.",
	"Method": "boolean getIgnoreCache(){\r\n    return _persistenceManagerFactory.getIgnoreCache();\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.annotation.handlers.StatelessHandler.createEjbDescriptor",
	"Comment": "create a new ejbdescriptor for a given elementname and annotationinfo.",
	"Method": "EjbDescriptor createEjbDescriptor(String elementName,AnnotationInfo ainfo){\r\n    AnnotatedElement ae = ainfo.getAnnotatedElement();\r\n    Class ejbClass = (Class) ae;\r\n    EjbSessionDescriptor newDescriptor = new EjbSessionDescriptor();\r\n    newDescriptor.setName(elementName);\r\n    newDescriptor.setEjbClassName(ejbClass.getName());\r\n    newDescriptor.setSessionType(EjbSessionDescriptor.STATELESS);\r\n    return newDescriptor;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.SymbolTable.declare",
	"Comment": "this method adds the specified identifier to this symboltable. the specified decl object provides details anbout the declaration. if this symboltable already defines an identifier with the same name, the symboltable is not changed and the existing declaration is returned. otherwise null is returned.",
	"Method": "Object declare(String ident,Object decl){\r\n    Object old = symbols.get(ident);\r\n    if (old == null) {\r\n        symbols.put(ident.toUpperCase(), decl);\r\n    }\r\n    return old;\r\n}"
}, {
	"Path": "org.glassfish.extras.grizzly.GrizzlyAdapterSniffer.supportsArchiveType",
	"Comment": "this api is used to help determine if the sniffer should recognizethe current archive.if the sniffer does not support the archive type associated withthe current deployment, the sniffer should not recognize the archive.",
	"Method": "boolean supportsArchiveType(ArchiveType archiveType){\r\n    if (archiveType.toString().equals(ModuleType.WAR.toString()) || archiveType.toString().equals(ModuleType.EJB.toString())) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbMessageBeanDescriptor.setConnectionFactoryName",
	"Comment": "connection factory is optional.if set to null, hasconnectionfactory will return false.",
	"Method": "void setConnectionFactoryName(String connectionFactory){\r\n    connectionFactoryName = connectionFactory;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ApplicationClientDescriptor.getEjbReference",
	"Comment": "looks up an ejb reference with the given name. throws an illegalargumentexception if it is not found.",
	"Method": "EjbReference getEjbReference(String name){\r\n    for (Iterator itr = this.getEjbReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        EjbReference ejr = (EjbReference) itr.next();\r\n        if (ejr.getName().equals(name)) {\r\n            return ejr;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"exceptionappclienthasnoejbrefbyname\", \"This application client [{0}] has no ejb reference by the name of [{1}]\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingFieldElementImpl.setFetchGroupInternal",
	"Comment": "set the fetch group of this field element.meant to be used in the\tconstructor and by subclasses when there should be no exceptions and \tno property change events fired.",
	"Method": "void setFetchGroupInternal(int group){\r\n    _fetchGroup = group;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.getEjbReferenceDescriptors",
	"Comment": "returns the generated xml directory feturn the set of ejb references this ejb declares.",
	"Method": "Set<EjbReference> getEjbReferenceDescriptors(){\r\n    return ejbReferences;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.MappingFile.intoMappingClasses",
	"Comment": "convert an suncmpmapping object into the equivelent collection ofmappingclasselement objects",
	"Method": "Map intoMappingClasses(SunCmpMappings content,ConversionHelper helper,Map intoMappingClasses,InputStream content,ConversionHelper helper){\r\n    SunCmpMappings foo = null;\r\n    try {\r\n        foo = SunCmpMappings.createGraph(content);\r\n    } catch (Schema2BeansException t) {\r\n        if (helper.ensureValidation()) {\r\n            throw new ConversionException(I18NHelper.getMessage(messages, \"XML_ERROR_IN_MAPPING_FILE\", DEFAULT_LOCATION_IN_EJB_JAR));\r\n        }\r\n        foo = SunCmpMappings.createGraph();\r\n    }\r\n    return intoMappingClasses(foo, helper);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.hasPersistentSuperclass",
	"Comment": "determines if the specified classname has a persistent superclass.",
	"Method": "boolean hasPersistentSuperclass(String className){\r\n    while ((className = getSuperclass(className)) != null) {\r\n        if (isPersistent(className))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.XAManagedConnectionFactory.equals",
	"Comment": "check if this managedconnectionfactory is equal to another managedconnectionfactory.",
	"Method": "boolean equals(Object other){\r\n    if (logWriter != null) {\r\n        logWriter.println(\"In equals\");\r\n    }\r\n    if (other instanceof com.sun.jdbcra.spi.XAManagedConnectionFactory) {\r\n        com.sun.jdbcra.spi.XAManagedConnectionFactory otherMCF = (com.sun.jdbcra.spi.XAManagedConnectionFactory) other;\r\n        return this.spec.equals(otherMCF.spec);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.FieldGroupElement.removeFields",
	"Comment": "removed the supplied fields from the collection of fields maintained\tby this holder.",
	"Method": "void removeFields(PersistenceFieldElement[] fields){\r\n    getFieldGroupImpl().changeFields(fields, Impl.REMOVE);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.Environment.getClass",
	"Comment": "look for the specified class in the class map.no other classlookup is performed.use this only if you are certain that theclass will have been found.",
	"Method": "ClassControl getClass(String className){\r\n    return (ClassControl) classMap.get(className);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.addFields",
	"Comment": "add the supplied fields to the collection of fields maintained by this\tholder.",
	"Method": "void addFields(PersistenceFieldElement[] fields){\r\n    getClassImpl().changeFields(fields, Impl.ADD);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ResourceReferenceDescriptor.isContainerAuthorization",
	"Comment": "return true of this resource reference is expecting the container to authorize the resource.",
	"Method": "boolean isContainerAuthorization(){\r\n    return this.getAuthorization().equals(CONTAINER_AUTHORIZATION);\r\n}"
}, {
	"Path": "org.glassfish.resources.admin.cli.ResourcesXMLParser.isConnectorResource",
	"Comment": "determines if the passed in resource is a connectorresource. a connector resource is either a connector connection pool or aconnector resource, security map, ra config or an admin object",
	"Method": "boolean isConnectorResource(Resource res){\r\n    String type = res.getType();\r\n    return ((type.equals(Resource.ADMIN_OBJECT_RESOURCE)) || (type.equals(org.glassfish.resources.api.Resource.CONNECTOR_CONNECTION_POOL)) || (type.equals(org.glassfish.resources.api.Resource.CONNECTOR_RESOURCE)) || (type.equals(org.glassfish.resources.api.Resource.CONNECTOR_SECURITY_MAP)) || (type.equals(org.glassfish.resources.api.Resource.RESOURCE_ADAPTER_CONFIG)));\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.setXMLValidation",
	"Comment": "turn on or off the xml validation for all standard deploymentdescriptors loading",
	"Method": "void setXMLValidation(boolean validate){\r\n    isValidatingXML = validate;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createPrimaryTableComponent",
	"Comment": "create a validation component which can check whether the \tclass is mapped to tables even though the schema is null or the \tclass is mapped to a primary table without a primary key.",
	"Method": "ValidationComponent createPrimaryTableComponent(MappingTableElement primaryTable){\r\n    return new ValidationComponent() {\r\n        public void validate() throws ModelValidationException {\r\n            if (primaryTable != null) {\r\n                String className = getClassName();\r\n                String schemaName = getSchemaForClass(className);\r\n                if (schemaName == null) {\r\n                    throw constructClassException(className, null, \"util.validation.schema_not_set\");\r\n                } else {\r\n                    String tableName = primaryTable.getName();\r\n                    TableElement table = getTable(tableName, schemaName);\r\n                    if ((table != null) && (table.getPrimaryKey() == null)) {\r\n                        throw new ModelValidationException(getOffendingObject(null), I18NHelper.getMessage(getMessages(), \"util.validation.table_no_primarykey\", new Object[] { tableName, className }));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createPrimaryTableComponent",
	"Comment": "create a validation component which can check whether the \tclass is mapped to tables even though the schema is null or the \tclass is mapped to a primary table without a primary key.",
	"Method": "ValidationComponent createPrimaryTableComponent(MappingTableElement primaryTable){\r\n    if (primaryTable != null) {\r\n        String className = getClassName();\r\n        String schemaName = getSchemaForClass(className);\r\n        if (schemaName == null) {\r\n            throw constructClassException(className, null, \"util.validation.schema_not_set\");\r\n        } else {\r\n            String tableName = primaryTable.getName();\r\n            TableElement table = getTable(tableName, schemaName);\r\n            if ((table != null) && (table.getPrimaryKey() == null)) {\r\n                throw new ModelValidationException(getOffendingObject(null), I18NHelper.getMessage(getMessages(), \"util.validation.table_no_primarykey\", new Object[] { tableName, className }));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.DatabaseGenerator.addRelationships",
	"Comment": "generate relationships for schema and mapping model from mappingclasses which already have all mapping fields populated.",
	"Method": "void addRelationships(){\r\n    if (logger.isLoggable(Logger.FINE)) {\r\n        logger.fine(\"add relationship\");\r\n    }\r\n    Map relationFKey = new HashMap();\r\n    List deferredRelationships = new ArrayList();\r\n    for (Iterator i = mappingClasses.values().iterator(); i.hasNext(); ) {\r\n        MappingClassElement mappingClass = (MappingClassElement) i.next();\r\n        String pcClassName = mappingClass.getName();\r\n        PersistenceClassElement pcClass = model.getPersistenceClass(pcClassName);\r\n        validateModel(pcClass, \"pcClass\", pcClassName);\r\n        TableElement sourceTable = getPrimaryTable(mappingClass);\r\n        validateModel(sourceTable, \"sourceTable\", pcClassName);\r\n        String uniqueId = getShortClassName(pcClassName);\r\n        int want = 8;\r\n        int end = uniqueId.length();\r\n        int start = want > end ? 0 : end - want;\r\n        uniqueId = uniqueId.substring(start, end);\r\n        RelationshipElement[] rels = pcClass.getRelationships();\r\n        if (rels != null) {\r\n            for (int j = 0; j < rels.length; j++) {\r\n                RelationshipElement relation = rels[j];\r\n                String relationName = relation.getName();\r\n                int upperBound = relation.getUpperBound();\r\n                String inverseRelName = relation.getInverseRelationshipName();\r\n                validateModel(// NOI18N\r\n                inverseRelName, \"inverseRelName\", relationName);\r\n                String relClassName = model.getRelatedClass(relation);\r\n                validateModel(// NOI18N\r\n                relClassName, \"relClassName\", relationName);\r\n                MappingClassElement relMappingClass = (MappingClassElement) mappingClasses.get(relClassName);\r\n                validateModel(// NOI18N\r\n                relMappingClass, \"relMappingClass\", relClassName);\r\n                PersistenceClassElement relClass = model.getPersistenceClass(relClassName);\r\n                validateModel(// NOI18N\r\n                relClass, \"relClass\", relClassName);\r\n                RelationshipElement inverseRelation = relClass.getRelationship(inverseRelName);\r\n                validateModel(// NOI18N\r\n                inverseRelation, \"inverseRelation\", inverseRelName);\r\n                TableElement relTable = getPrimaryTable(relMappingClass);\r\n                validateModel(// NOI18N\r\n                relTable, \"relTable\", relClassName);\r\n                int relUpperBound = inverseRelation.getUpperBound();\r\n                if (logger.isLoggable(Logger.FINE)) {\r\n                    // NOI18N\r\n                    logger.fine(\"Before adding relationship:\" + getTblInfo(\"sourceTable\", sourceTable, relationName) + getTblInfo(\"relTable\", relTable, inverseRelName));\r\n                }\r\n                if ((upperBound > 1) && (relUpperBound > 1)) {\r\n                    if (logger.isLoggable(Logger.FINE)) {\r\n                        logger.fine(\"M-N relationship\");\r\n                    }\r\n                    ForeignKeyElement fKey = getMappedForeignKey(relation, inverseRelation, relationFKey);\r\n                    if (fKey == null) {\r\n                        TableElement joinTable = DBElementFactory.createAndAttachTable(schema, mappingPolicy.getJoinTableName(sourceTable.getName().getName(), relTable.getName().getName()));\r\n                        fKey = createRelationship(joinTable, sourceTable, relationName, inverseRelName, mappingClass, relMappingClass, uniqueId, true);\r\n                        relationFKey.put(relation, fKey);\r\n                        ForeignKeyElement fKey2 = createRelationship(joinTable, relTable, inverseRelName, relationName, relMappingClass, mappingClass, uniqueId, true);\r\n                        relationFKey.put(inverseRelation, fKey2);\r\n                    }\r\n                } else if ((upperBound > 1) && (relUpperBound == 1)) {\r\n                    if (logger.isLoggable(Logger.FINE)) {\r\n                        logger.fine(\"M-1 relationship: skip\");\r\n                    }\r\n                } else if ((upperBound == 1) && (relUpperBound > 1)) {\r\n                    if (logger.isLoggable(Logger.FINE)) {\r\n                        logger.fine(\"1-M relationship\");\r\n                    }\r\n                    ForeignKeyElement fKey = getMappedForeignKey(relation, inverseRelation, relationFKey);\r\n                    if (fKey == null) {\r\n                        fKey = createRelationship(sourceTable, relTable, relationName, inverseRelName, mappingClass, relMappingClass, uniqueId, false);\r\n                        relationFKey.put(relation, fKey);\r\n                    }\r\n                } else if ((upperBound == 1) && (relUpperBound == 1)) {\r\n                    ForeignKeyElement fKey = getMappedForeignKey(relation, inverseRelation, relationFKey);\r\n                    if (fKey == null) {\r\n                        if (relation.getDeleteAction() == RelationshipElement.CASCADE_ACTION) {\r\n                            if (logger.isLoggable(Logger.FINE)) {\r\n                                logger.fine(\"1-1 relationship: cascade(this)\");\r\n                            }\r\n                            fKey = createRelationship(sourceTable, relTable, relationName, inverseRelName, mappingClass, relMappingClass, uniqueId, false);\r\n                            relationFKey.put(relation, fKey);\r\n                        } else if (inverseRelation.getDeleteAction() == RelationshipElement.CASCADE_ACTION) {\r\n                            if (logger.isLoggable(Logger.FINE)) {\r\n                                logger.fine(\"1-1 relationship: cascade(inverse)\");\r\n                            }\r\n                            fKey = createRelationship(relTable, sourceTable, inverseRelName, relationName, relMappingClass, mappingClass, uniqueId, false);\r\n                            relationFKey.put(inverseRelation, fKey);\r\n                        } else {\r\n                            if (logger.isLoggable(Logger.FINE)) {\r\n                                logger.fine(\"1-1 relationship: defer\");\r\n                            }\r\n                            deferredRelationships.add(new DeferredRelationship(relation, inverseRelation, sourceTable, relTable, relationName, inverseRelName, mappingClass, relMappingClass, uniqueId));\r\n                        }\r\n                    }\r\n                }\r\n                if (logger.isLoggable(Logger.FINE)) {\r\n                    // NOI18N\r\n                    logger.fine(\"After adding relationship:\" + getTblInfo(\"sourceTable\", sourceTable, relationName) + getTblInfo(\"relTable\", relTable, inverseRelName));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (deferredRelationships.size() > 0) {\r\n        addDeferredRelationships(deferredRelationships, relationFKey);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.Descriptor.elementSize",
	"Comment": "return the number of stack words required for a value of the specifiedtype on the operand stack.",
	"Method": "int elementSize(int elementType){\r\n    switch(elementType) {\r\n        case T_LONG:\r\n        case T_DOUBLE:\r\n        case T_TWOWORD:\r\n            return 2;\r\n        default:\r\n            return 1;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnection.XAEndOccurred",
	"Comment": "this method is called by the xaresource object when its end methodhas been invoked.",
	"Method": "void XAEndOccurred(){\r\n    try {\r\n        actualConnection.setAutoCommit(true);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        connectionErrorOccurred(e, null);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.handlers.AbstractAuthAnnotationHandler.getMethodAllDescriptors",
	"Comment": "returns methoddescriptors representing all for a given ejbdescriptor.",
	"Method": "Set<MethodDescriptor> getMethodAllDescriptors(EjbDescriptor ejbDesc){\r\n    Set methodAlls = new HashSet();\r\n    if (ejbDesc.isRemoteInterfacesSupported() || ejbDesc.isRemoteBusinessInterfacesSupported()) {\r\n        methodAlls.add(new MethodDescriptor(MethodDescriptor.ALL_METHODS, \"\", MethodDescriptor.EJB_REMOTE));\r\n        if (ejbDesc.isRemoteInterfacesSupported()) {\r\n            methodAlls.add(new MethodDescriptor(MethodDescriptor.ALL_METHODS, \"\", MethodDescriptor.EJB_HOME));\r\n        }\r\n    }\r\n    if (ejbDesc.isLocalInterfacesSupported() || ejbDesc.isLocalBusinessInterfacesSupported()) {\r\n        methodAlls.add(new MethodDescriptor(MethodDescriptor.ALL_METHODS, \"\", MethodDescriptor.EJB_LOCAL));\r\n        if (ejbDesc.isLocalInterfacesSupported()) {\r\n            methodAlls.add(new MethodDescriptor(MethodDescriptor.ALL_METHODS, \"\", MethodDescriptor.EJB_LOCALHOME));\r\n        }\r\n    }\r\n    if (ejbDesc.isLocalBean()) {\r\n        methodAlls.add(new MethodDescriptor(MethodDescriptor.ALL_METHODS, \"\", MethodDescriptor.EJB_LOCAL));\r\n    }\r\n    if (ejbDesc.hasWebServiceEndpointInterface()) {\r\n        methodAlls.add(new MethodDescriptor(MethodDescriptor.ALL_METHODS, \"\", MethodDescriptor.EJB_WEB_SERVICE));\r\n    }\r\n    return methodAlls;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingClassElementImpl.getTable",
	"Comment": "scans through this mapping class looking for a table whose\tname matches the name passed in.",
	"Method": "MappingTableElement getTable(String name){\r\n    Iterator tableIterator = getTables().iterator();\r\n    while (tableIterator.hasNext()) {\r\n        MappingTableElement table = (MappingTableElement) tableIterator.next();\r\n        if (table.getName().equals(name))\r\n            return table;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.LocalizedNode.writeLocalizedMap",
	"Comment": "writes all the localized map element usign the tagname with the lang attribute to a dom node",
	"Method": "void writeLocalizedMap(Node parentNode,String tagName,Map localizedMap){\r\n    if (localizedMap != null) {\r\n        Set<Map.Entry> entrySet = localizedMap.entrySet();\r\n        Iterator<Map.Entry> entryIt = entrySet.iterator();\r\n        while (entryIt.hasNext()) {\r\n            Map.Entry entry = entryIt.next();\r\n            String lang = (String) entry.getKey();\r\n            Element aLocalizedNode = (Element) appendTextChild(parentNode, tagName, (String) entry.getValue());\r\n            if ((aLocalizedNode != null) && (Locale.getDefault().getLanguage().equals(lang))) {\r\n                aLocalizedNode.setAttributeNS(TagNames.XML_NAMESPACE, TagNames.XML_NAMESPACE_PREFIX + TagNames.LANG, lang);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.CallableStatementWrapper40.executeQuery",
	"Comment": "executes the given sql statement, which returns a singleresultset object.",
	"Method": "java.sql.ResultSet executeQuery(java.sql.ResultSet executeQuery,String sql){\r\n    ResultSet rs = callableStatement.executeQuery(sql);\r\n    incrementResultSetReferenceCount();\r\n    return new ResultSetWrapper40(this, rs);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.newSCOInstance",
	"Comment": "returns a new second class object instance of the type specified,with the owner and field name to notify upon changes to the valueof any of its fields. if a collection class is created, then theclass does not restrict the element types, and allows nulls to be added as elements.",
	"Method": "Object newSCOInstance(Class type,Object owner,String fieldName){\r\n    Object obj = null;\r\n    if (Collection.class.isAssignableFrom(type)) {\r\n        obj = this.newCollectionInstanceInternal(type, owner, fieldName, null, true, 0);\r\n    } else {\r\n        obj = newSCOInstanceInternal(type, owner, fieldName);\r\n    }\r\n    this.replaceSCO(fieldName, owner, obj);\r\n    return obj;\r\n}"
}, {
	"Path": "org.glassfish.enterprise.iiop.impl.POAProtocolMgr.isIdentical",
	"Comment": "return true if the two object references refer to the sameremote object.",
	"Method": "boolean isIdentical(Remote obj1,Remote obj2){\r\n    if (obj1 instanceof org.omg.CORBA.Object && obj2 instanceof org.omg.CORBA.Object) {\r\n        org.omg.CORBA.Object corbaObj1 = (org.omg.CORBA.Object) obj1;\r\n        org.omg.CORBA.Object corbaObj2 = (org.omg.CORBA.Object) obj2;\r\n        return corbaObj1._is_equivalent(corbaObj2);\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.ConfigureJMSCluster.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    Cluster cluster = domain.getClusterNamed(clusterName);\r\n    if (cluster == null) {\r\n        report.setMessage(localStrings.getLocalString(\"configure.jms.cluster.invalidClusterName\", \"No Cluster by this name has been configured\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    List instances = cluster.getInstances();\r\n    String warning = null;\r\n    if (instances.size() > 0) {\r\n        ActionReport listReport = habitat.getService(ActionReport.class);\r\n        ParameterMap parameters = new ParameterMap();\r\n        parameters.set(\"DEFAULT\", clusterName);\r\n        commandRunner.getCommandInvocation(\"list-instances\", listReport, context.getSubject()).parameters(parameters).execute();\r\n        if (ActionReport.ExitCode.FAILURE.equals(listReport.getActionExitCode())) {\r\n            warning = localStrings.getLocalString(\"configure.jms.cluster.clusterWithInstances\", \"Warning: Please make sure running this command with all cluster instances stopped, otherwise it may lead to inconsistent JMS behavior and corruption of configuration and message stores.\");\r\n        } else {\r\n            String result = listReport.getMessage();\r\n            String fixedResult = result.replaceAll(\"not running\", \"stopped\");\r\n            if (fixedResult.indexOf(\"running\") > -1) {\r\n                warning = localStrings.getLocalString(\"configure.jms.cluster.clusterWithInstances\", \"Warning: Please make sure running this command with all cluster instances stopped, otherwise it may lead to inconsistent JMS behavior and corruption of configuration and message stores.\");\r\n                warning = warning + \"\\r\\n\" + result + \"\\r\\n\";\r\n            }\r\n        }\r\n    }\r\n    Config config = domain.getConfigNamed(cluster.getConfigRef());\r\n    JmsService jmsService = config.getExtensionByType(JmsService.class);\r\n    if (jmsService == null) {\r\n        report.setMessage(localStrings.getLocalString(\"configure.jms.cluster.nojmsservice\", \"No JMS Service element in config\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (!CONVENTIONAL.equalsIgnoreCase(clusterType) && !ENHANCED.equalsIgnoreCase(clusterType)) {\r\n        report.setMessage(localStrings.getLocalString(\"configure.jms.cluster.wrongClusterType\", \"Invalid option sepecified for clustertype. Valid options are conventional and enhanced\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (CONVENTIONAL.equalsIgnoreCase(clusterType) && !MASTER_BROKER.equalsIgnoreCase(configStoreType) && !SHARED_DB.equalsIgnoreCase(configStoreType)) {\r\n        report.setMessage(localStrings.getLocalString(\"configure.jms.cluster.wrongConfigStoreType\", \"Invalid option sepecified for configstoretype. Valid options are masterbroker and shareddb\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (ENHANCED.equalsIgnoreCase(clusterType) && configStoreType != null) {\r\n        report.setMessage(localStrings.getLocalString(\"configure.jms.cluster.wrongStoreType\", \"configstoretype option is not configurable for Enhanced clusters.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (CONVENTIONAL.equalsIgnoreCase(clusterType) && !MASTER_BROKER.equalsIgnoreCase(configStoreType) && !FILE.equalsIgnoreCase(messageStoreType) && !JDBC.equalsIgnoreCase(messageStoreType)) {\r\n        report.setMessage(localStrings.getLocalString(\"configure.jms.cluster.wrongMessageStoreType\", \"Invalid option sepecified for messagestoretype. Valid options are file and jdbc\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (ENHANCED.equalsIgnoreCase(clusterType) && messageStoreType != null) {\r\n        report.setMessage(localStrings.getLocalString(\"configure.jms.cluster.wrongmsgStoreType\", \"messagestoretype option is not configurable for Enhanced clusters.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    String integrationMode = jmsService.getType();\r\n    if (REMOTE.equalsIgnoreCase(integrationMode)) {\r\n        report.setMessage(localStrings.getLocalString(\"configure.jms.cluster.remoteMode\", \"JMS integration mode should be either EMBEDDED or LOCAL to run this command. Please use the asadmin.set command to change the integration mode\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    String changeIntegrationMode = null;\r\n    if (EMBEDDED.equalsIgnoreCase(integrationMode) && ENHANCED.equalsIgnoreCase(clusterType)) {\r\n        try {\r\n            ConfigSupport.apply(new SingleConfigCode<JmsService>() {\r\n                public Object run(JmsService param) throws PropertyVetoException, TransactionFailure {\r\n                    param.setType(LOCAL);\r\n                    return param;\r\n                }\r\n            }, jmsService);\r\n            changeIntegrationMode = localStrings.getLocalString(\"configure.jms.cluster.integrationModeChanged\", \"WARNING: JMS integration mode has been changed from EMBEDDED to LOCAL automatically.\");\r\n        } catch (TransactionFailure tfe) {\r\n            report.setMessage(localStrings.getLocalString(\"configure.jms.cluster.cannotChangeIntegrationMode\", \"Unable to change the JMS integration mode to LOCAL for Enhanced cluster {0}.\", clusterName) + \" \" + tfe.getLocalizedMessage());\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            report.setFailureCause(tfe);\r\n            return;\r\n        }\r\n    }\r\n    if (MASTER_BROKER.equalsIgnoreCase(configStoreType) && FILE.equals(messageStoreType)) {\r\n        if (dbvendor != null || dburl != null || dbuser != null) {\r\n            report.setMessage(localStrings.getLocalString(\"configure.jms.cluster.invalidDboptions\", \"Database options should not be specified for this configuration\"));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    if (!MASTER_BROKER.equalsIgnoreCase(configStoreType) || ENHANCED.equalsIgnoreCase(clusterType) || JDBC.equalsIgnoreCase(messageStoreType)) {\r\n        if (dbvendor == null) {\r\n            report.setMessage(localStrings.getLocalString(\"configure.jms.cluster.nodbvendor\", \"No DataBase vendor specified\"));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        } else if (dburl == null) {\r\n            report.setMessage(localStrings.getLocalString(\"configure.jms.cluster.nojdbcurl\", \"No JDBC URL specified\"));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        } else if (!isSupportedDbVendor()) {\r\n            report.setMessage(localStrings.getLocalString(\"configure.jms.cluster.invaliddbvendor\", \"Invalid DB Vednor specified\"));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    if (CONVENTIONAL.equalsIgnoreCase(clusterType) && configStoreType == null) {\r\n        report.setMessage(localStrings.getLocalString(\"configure.jms.cluster.noConfigStoreType\", \"No configstoretype specified. Using the default value - masterbroker\"));\r\n        configStoreType = \"masterbroker\";\r\n    }\r\n    if (CONVENTIONAL.equalsIgnoreCase(clusterType) && messageStoreType == null) {\r\n        report.setMessage(localStrings.getLocalString(\"configure.jms.cluster.noMessagetoreType\", \"No messagestoretype specified. Using the default value - file\"));\r\n        messageStoreType = \"file\";\r\n    }\r\n    config = domain.getConfigNamed(cluster.getConfigRef());\r\n    JmsAvailability jmsAvailability = config.getAvailabilityService().getExtensionByType(JmsAvailability.class);\r\n    final Boolean availabilityEnabled = Boolean.valueOf(ENHANCED.equalsIgnoreCase(clusterType));\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<JmsAvailability>() {\r\n            public Object run(JmsAvailability param) throws PropertyVetoException, TransactionFailure {\r\n                param.setAvailabilityEnabled(availabilityEnabled.toString());\r\n                if (availabilityEnabled.booleanValue()) {\r\n                    param.setMessageStoreType(JDBC);\r\n                } else {\r\n                    param.setConfigStoreType(configStoreType.toLowerCase(Locale.ENGLISH));\r\n                    param.setMessageStoreType(messageStoreType.toLowerCase(Locale.ENGLISH));\r\n                }\r\n                param.setDbVendor(dbvendor);\r\n                param.setDbUsername(dbuser);\r\n                param.setDbPassword(jmsDbPassword);\r\n                param.setDbUrl(dburl);\r\n                if (props != null) {\r\n                    for (Map.Entry e : props.entrySet()) {\r\n                        Property prop = param.createChild(Property.class);\r\n                        prop.setName((String) e.getKey());\r\n                        prop.setValue((String) e.getValue());\r\n                        param.getProperty().add(prop);\r\n                    }\r\n                }\r\n                return param;\r\n            }\r\n        }, jmsAvailability);\r\n    } catch (TransactionFailure tfe) {\r\n        report.setMessage((changeIntegrationMode == null ? \"\" : changeIntegrationMode + \"\\n\") + localStrings.getLocalString(\"configure.jms.cluster.fail\", \"Unable to Configure JMS Cluster for cluster {0}.\", clusterName) + \" \" + tfe.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n    }\r\n    report.setMessage((warning == null ? \"\" : warning + \"\\n\") + (changeIntegrationMode == null ? \"\" : changeIntegrationMode + \"\\n\") + localStrings.getLocalString(\"configure.jms.cluster.success\", \"JMS Cluster Configuration updated for Cluster {0}.\", clusterName));\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.ConfigureJMSCluster.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    param.setType(LOCAL);\r\n    return param;\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.ConfigureJMSCluster.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    param.setAvailabilityEnabled(availabilityEnabled.toString());\r\n    if (availabilityEnabled.booleanValue()) {\r\n        param.setMessageStoreType(JDBC);\r\n    } else {\r\n        param.setConfigStoreType(configStoreType.toLowerCase(Locale.ENGLISH));\r\n        param.setMessageStoreType(messageStoreType.toLowerCase(Locale.ENGLISH));\r\n    }\r\n    param.setDbVendor(dbvendor);\r\n    param.setDbUsername(dbuser);\r\n    param.setDbPassword(jmsDbPassword);\r\n    param.setDbUrl(dburl);\r\n    if (props != null) {\r\n        for (Map.Entry e : props.entrySet()) {\r\n            Property prop = param.createChild(Property.class);\r\n            prop.setName((String) e.getKey());\r\n            prop.setValue((String) e.getValue());\r\n            param.getProperty().add(prop);\r\n        }\r\n    }\r\n    return param;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnUtils.aStore",
	"Comment": "return the best instruction for storing a reference to a localvariable slot",
	"Method": "Insn aStore(int i,ConstantPool pool){\r\n    if (i == 0)\r\n        return Insn.create(opc_astore_0);\r\n    else if (i == 1)\r\n        return Insn.create(opc_astore_1);\r\n    else if (i == 2)\r\n        return Insn.create(opc_astore_2);\r\n    else if (i == 3)\r\n        return Insn.create(opc_astore_3);\r\n    return Insn.create(opc_astore, i);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getMethod",
	"Comment": "returns the method element for the specified method name and argument \ttypes in the class with the specified name. types are specified as \ttype names for primitive type such as int, float or as fully qualified \tclass names.note, the method does not return inherited methods.",
	"Method": "Object getMethod(String className,String methodName,String[] argTypeNames){\r\n    final Class classElement = (Class) getClass(className);\r\n    if (classElement != null) {\r\n        final Class[] argTypes = getTypesForNames(argTypeNames);\r\n        return AccessController.doPrivileged(new PrivilegedAction() {\r\n            public Object run() {\r\n                try {\r\n                    return classElement.getDeclaredMethod(methodName, argTypes);\r\n                } catch (NoSuchMethodException ex) {\r\n                    return null;\r\n                }\r\n            }\r\n        });\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getMethod",
	"Comment": "returns the method element for the specified method name and argument \ttypes in the class with the specified name. types are specified as \ttype names for primitive type such as int, float or as fully qualified \tclass names.note, the method does not return inherited methods.",
	"Method": "Object getMethod(String className,String methodName,String[] argTypeNames){\r\n    try {\r\n        return classElement.getDeclaredMethod(methodName, argTypes);\r\n    } catch (NoSuchMethodException ex) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.jdbc.pool.monitor.JdbcConnPoolStatsProvider.potentialConnLeakEvent",
	"Comment": "whenever connection leak happens, increment numpotentialconnleak",
	"Method": "void potentialConnLeakEvent(String poolName,String appName,String moduleName){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (logger.isLoggable(Level.FINEST)) {\r\n            logger.finest(\"Connection Leak event received - poolName = \" + poolName);\r\n        }\r\n        numPotentialConnLeak.increment();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.naming.impl.TransientContext.print",
	"Comment": "print the current hashtable.should only be invoked for fine level logging.",
	"Method": "void print(Map<String, Object> ht){\r\n    for (Map.Entry<String, Object> entry : ht.entrySet()) {\r\n        Object value = entry.getValue();\r\n        logger.log(Level.FINE, \"[{0}, {1}:{2}]\", new Object[] { entry.getKey(), value, value.getClass().getName() });\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.switchOnMatching",
	"Comment": "causes pool to switch on the matching of connections.it can be either directly on the pool or on the connectorconnectionpoolobject that is bound in jndi.",
	"Method": "void switchOnMatching(String rarName,PoolInfo poolInfo){\r\n    connectorService.switchOnMatching(rarName, poolInfo);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.Date.setTimeInternal",
	"Comment": "sets the date object without notification of the ownerfield. used internaly to populate date from db",
	"Method": "void setTimeInternal(long time){\r\n    super.setTime(time);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.ClassFile.addInterface",
	"Comment": "add an interface to the list of the interfaces which the class implements",
	"Method": "void addInterface(ConstClass iface){\r\n    classInterfaces.addElement(iface);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnUtils.lStore",
	"Comment": "return the best instruction for storing a long to a localvariable slot",
	"Method": "Insn lStore(int i,ConstantPool pool){\r\n    if (i == 0)\r\n        return Insn.create(opc_lstore_0);\r\n    else if (i == 1)\r\n        return Insn.create(opc_lstore_1);\r\n    else if (i == 2)\r\n        return Insn.create(opc_lstore_2);\r\n    else if (i == 3)\r\n        return Insn.create(opc_lstore_3);\r\n    return Insn.create(opc_lstore, i);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.EjbReferenceDescriptor.setEjbInterface",
	"Comment": "sets the local or remote bean interface classname of the referee ejb.",
	"Method": "void setEjbInterface(String remoteClassName){\r\n    setBeanClassName(remoteClassName);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsNamedParameters",
	"Comment": "retrieves whether this database supports named parameters to callablestatements.",
	"Method": "boolean supportsNamedParameters(){\r\n    return databaseMetaData.supportsNamedParameters();\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ConnectionHolder.associateConnection",
	"Comment": "replace the actual java.sql.connection object with the onesupplied. also replace managedconnection link.",
	"Method": "void associateConnection(Connection con,ManagedConnection mc){\r\n    this.mc = mc;\r\n    this.con = con;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.usesLocalFiles",
	"Comment": "retrieves whether this database stores tables in a local file.",
	"Method": "boolean usesLocalFiles(){\r\n    return databaseMetaData.usesLocalFiles();\r\n}"
}, {
	"Path": "org.glassfish.concurrent.admin.CreateManagedScheduledExecutorService.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    HashMap attrList = new HashMap();\r\n    setAttributeList(attrList);\r\n    ResourceStatus rs;\r\n    try {\r\n        rs = managedScheduledExecutorServiceMgr.create(domain.getResources(), attrList, properties, target);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"create.managed.scheduled.executor.service.failed\", \"Managed scheduled executor service {0} creation failed\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    ActionReport.ExitCode ec = ActionReport.ExitCode.SUCCESS;\r\n    if (rs.getMessage() != null) {\r\n        report.setMessage(rs.getMessage());\r\n    }\r\n    if (rs.getStatus() == ResourceStatus.FAILURE) {\r\n        ec = ActionReport.ExitCode.FAILURE;\r\n        if (rs.getException() != null)\r\n            report.setFailureCause(rs.getException());\r\n    }\r\n    report.setActionExitCode(ec);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.previous",
	"Comment": "moves the cursor to the previous row in thisresultset object.",
	"Method": "boolean previous(){\r\n    return resultSet.previous();\r\n}"
}, {
	"Path": "org.glassfish.jdbcruntime.JdbcPoolMonitoringExtension.unregisterPool",
	"Comment": "unregister jdbc connection pool from the statsprovidermanager.remove the pool lifecycle listeners associated with this pool.",
	"Method": "void unregisterPool(PoolInfo poolInfo){\r\n    if (jdbcStatsProviders != null) {\r\n        Iterator i = jdbcStatsProviders.iterator();\r\n        while (i.hasNext()) {\r\n            JdbcConnPoolStatsProvider jdbcPoolStatsProvider = (JdbcConnPoolStatsProvider) i.next();\r\n            if (poolInfo.equals(jdbcPoolStatsProvider.getPoolInfo())) {\r\n                PoolLifeCycleListenerRegistry poolRegistry = jdbcPoolStatsProvider.getPoolRegistry();\r\n                poolRegistry.unRegisterPoolLifeCycleListener(poolInfo);\r\n                StatsProviderManager.unregister(jdbcPoolStatsProvider);\r\n                i.remove();\r\n            }\r\n        }\r\n    }\r\n    connectionPoolStatsProviderBootstrapProvider.get().postUnregisterPool(poolInfo);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.impl.ModuleScanner.addScanDirectory",
	"Comment": "this will include all class in directory to be scanned.param directory",
	"Method": "void addScanDirectory(File directory){\r\n    scannedURI.add(directory.toURI());\r\n    if (needScanAnnotation) {\r\n        classParser.parse(directory, null);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.naming.impl.TransientContext.doUnbind",
	"Comment": "unbinds the object specified by name. traverses down the context treeand unbinds the object if required.",
	"Method": "void doUnbind(String name){\r\n    if (name.equals(\"\")) {\r\n        throw new InvalidNameException(\"Cannot unbind empty name\");\r\n    }\r\n    bindings.remove(name);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createColumnOverlapComponent",
	"Comment": "create a validation component which can check whether the field is \tone of a set mapped to overlapping columns",
	"Method": "ValidationComponent createColumnOverlapComponent(MappingFieldElement field){\r\n    return new ValidationComponent() {\r\n        public void validate() throws ModelValidationException {\r\n            MappingClassElement mappingClass = field.getDeclaringClass();\r\n            Iterator iterator = mappingClass.getFields().iterator();\r\n            ArrayList myColumns = field.getColumns();\r\n            while (iterator.hasNext()) {\r\n                MappingFieldElement testField = (MappingFieldElement) iterator.next();\r\n                if (!testField.equals(field) && !isRelationship(testField) && isPartialMatch(myColumns, testField.getColumns())) {\r\n                    String fieldName = field.getName();\r\n                    throw new ModelValidationException(getModel().getField(getClassName(), fieldName), I18NHelper.getMessage(getMessages(), \"util.validation.field_mapping_invalid\", new Object[] { fieldName, testField.getName() }));\r\n                }\r\n            }\r\n        }\r\n        private boolean isPartialMatch(ArrayList columns1, ArrayList columns2) {\r\n            int count = columns1.size();\r\n            if (count > 0) {\r\n                ArrayList difference = getDifference(columns1, columns2);\r\n                return (!difference.isEmpty() && (columns2.size() != difference.size()));\r\n            }\r\n            return false;\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createColumnOverlapComponent",
	"Comment": "create a validation component which can check whether the field is \tone of a set mapped to overlapping columns",
	"Method": "ValidationComponent createColumnOverlapComponent(MappingFieldElement field){\r\n    MappingClassElement mappingClass = field.getDeclaringClass();\r\n    Iterator iterator = mappingClass.getFields().iterator();\r\n    ArrayList myColumns = field.getColumns();\r\n    while (iterator.hasNext()) {\r\n        MappingFieldElement testField = (MappingFieldElement) iterator.next();\r\n        if (!testField.equals(field) && !isRelationship(testField) && isPartialMatch(myColumns, testField.getColumns())) {\r\n            String fieldName = field.getName();\r\n            throw new ModelValidationException(getModel().getField(getClassName(), fieldName), I18NHelper.getMessage(getMessages(), \"util.validation.field_mapping_invalid\", new Object[] { fieldName, testField.getName() }));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createColumnOverlapComponent",
	"Comment": "create a validation component which can check whether the field is \tone of a set mapped to overlapping columns",
	"Method": "ValidationComponent createColumnOverlapComponent(MappingFieldElement field){\r\n    int count = columns1.size();\r\n    if (count > 0) {\r\n        ArrayList difference = getDifference(columns1, columns2);\r\n        return (!difference.isEmpty() && (columns2.size() != difference.size()));\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.EJBHashSet.add",
	"Comment": "adds the specified element to this set if it is not alreadypresent.",
	"Method": "boolean add(Object o){\r\n    logger.finest(\"---EJBHashSet.add---\");\r\n    assertIsValid();\r\n    assertInTransaction();\r\n    helper.assertInstanceOfLocalInterfaceImpl(o);\r\n    Object pc = helper.convertEJBLocalObjectToPC((EJBLocalObject) o, pm, true);\r\n    return pcSet.add(pc);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.getQuoteCharStart",
	"Comment": "returns the start identifier quote character for this database, oran empty string, if there is none.",
	"Method": "String getQuoteCharStart(){\r\n    String s = (String) dbMap.get(QUOTE_CHAR_START);\r\n    if (s == null)\r\n        s = NONE;\r\n    if (logger.isLoggable()) {\r\n        logger.fine(\"sqlstore.database.dbvendor.getquotecharstart\", s);\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.SunContainerHelper.commitInternalTransaction",
	"Comment": "called in a unspecified transaction context of a managed environment.according to p.364 of ejb 2.0 spec, cmp may need to manageits own transaction when its transaction attribute isnotsupported, never, supports.this is a generic implementation.application server may like to overwrite this if necessary.",
	"Method": "void commitInternalTransaction(PersistenceManager pm){\r\n    pm.currentTransaction().commit();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ConnectionHolder.associateConnection",
	"Comment": "replace the actual java.sql.connection object with the onesupplied. also replace managedconnection link.",
	"Method": "void associateConnection(Connection con,ManagedConnectionImpl mc){\r\n    this.mc = mc;\r\n    this.con = con;\r\n}"
}, {
	"Path": "org.glassfish.loadbalancer.admin.cli.reader.impl.InstanceReaderImpl.getWeight",
	"Comment": "this is used in weighted round robin. returns the weight of the instance",
	"Method": "String getWeight(){\r\n    return _server.getLbWeight();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.handlers.AbstractHandler.validateInjectionMethod",
	"Comment": "check if given method is a valid injection method.throw exception if it is not.",
	"Method": "void validateInjectionMethod(Method method,AnnotationInfo ainfo){\r\n    if (method.getParameterTypes().length != 1) {\r\n        throw new AnnotationProcessorException(localStrings.getLocalString(\"enterprise.deployment.annotation.handlers.invalidinjectionmethod\", \"Injection on a method requires a JavaBeans setter method type with one parameter \"), ainfo);\r\n    }\r\n    if (!void.class.equals(method.getReturnType())) {\r\n        throw new AnnotationProcessorException(localStrings.getLocalString(\"enterprise.deployment.annotation.handlers.injectionmethodmustreturnvoid\", \"Injection on a method requires a void return type\"), ainfo);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.RetrieveDescImpl.setOption",
	"Comment": "sets option option. only used to mark thisretrieve descriptor as internal. all valid options are definedin this class.",
	"Method": "void setOption(int option){\r\n    this.options |= option;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectorConnPoolStatsProvider.connectionValidationFailedEvent",
	"Comment": "whenever connection leak happens, increment numconnfailedvalidation",
	"Method": "void connectionValidationFailedEvent(String poolName,String appName,String moduleName,int increment){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (logger.isLoggable(Level.FINEST)) {\r\n            logger.finest(\"Connection Validation Failed event received - \" + \"poolName = \" + poolName);\r\n        }\r\n        numConnFailedValidation.increment(increment);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getEntityManagerReferenceByName",
	"Comment": "return the entity manager factory reference descriptor corresponding tothe given name.",
	"Method": "EntityManagerReferenceDescriptor getEntityManagerReferenceByName(String name){\r\n    if (env != null)\r\n        return env.getEntityManagerReferenceByName(name);\r\n    for (EntityManagerReferenceDescriptor next : getEntityManagerReferenceDescriptors()) {\r\n        if (next.getName().equals(name)) {\r\n            return next;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionbeanhasnoentitymgrrefbyname\", \"This ejb {0} has no entity manager reference by the name of {1}\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.SelectStatement.getFormattedSQLText",
	"Comment": "gets formatted sql text corrsponding to this statement object. the textalso contains values for input to the statement.",
	"Method": "String getFormattedSQLText(ValueFetcher parameters){\r\n    return formatSqlText(getText(), getInputValues(parameters));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.MappingPolicy.getJoinTableName",
	"Comment": "returns the name of a join table which joins the tables that correspondto the two named classes.",
	"Method": "String getJoinTableName(String className1,String className2){\r\n    String rc = (String) namingPolicy.get(DEFAULT_JOIN_TABLE_KEY);\r\n    if (rc.equals(JOIN_TABLE_NAME_UPPERCASE)) {\r\n        rc = (className1 + className2).toUpperCase();\r\n    }\r\n    return getUniqueGlobalName(rc, tableNameMaxLength);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.PersistenceArchivist.getProbablePersistenceRoots",
	"Comment": "gets probable persitence roots from given parentarchive using given subarchiverootscanner",
	"Method": "Map<String, ReadableArchive> getProbablePersistenceRoots(ReadableArchive parentArchive,SubArchivePURootScanner subArchivePURootScanner){\r\n    Map<String, ReadableArchive> probablePersitenceArchives = new HashMap<String, ReadableArchive>();\r\n    ReadableArchive archiveToScan = subArchivePURootScanner.getSubArchiveToScan(parentArchive);\r\n    if (archiveToScan != null) {\r\n        Enumeration<String> entries = archiveToScan.entries();\r\n        String puRootPrefix = subArchivePURootScanner.getPurRootPrefix();\r\n        while (entries.hasMoreElements()) {\r\n            String entry = entries.nextElement();\r\n            if (subArchivePURootScanner.isProbablePuRootJar(entry)) {\r\n                ReadableArchive puRootArchive = getSubArchive(archiveToScan, entry, false);\r\n                if (puRootArchive != null) {\r\n                    String puRoot = puRootPrefix + entry;\r\n                    probablePersitenceArchives.put(puRoot, puRootArchive);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return probablePersitenceArchives;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsSchemasInPrivilegeDefinitions",
	"Comment": "retrieves whether a schema name can be used in a privilege definition statement.",
	"Method": "boolean supportsSchemasInPrivilegeDefinitions(){\r\n    return databaseMetaData.supportsSchemasInPrivilegeDefinitions();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsOpenStatementsAcrossRollback",
	"Comment": "retrieves whether this database supports keeping statements openacross rollbacks.",
	"Method": "boolean supportsOpenStatementsAcrossRollback(){\r\n    return databaseMetaData.supportsOpenStatementsAcrossRollback();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.TransactionImpl.verify",
	"Comment": "verify that username and password are equal to ones stored before",
	"Method": "boolean verify(String username,char[] password){\r\n    if ((this.username != null && !this.username.equals(username)) || (this.username == null && username != null) || (this.password != null && !Arrays.equals(this.password, password)) || (this.password == null && password != null)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.ResourceHandlers.combineProperties",
	"Comment": "this method goes through the table list,if there is confidential properties, will ensure that the masked value1 and value2 is the same. and will copy this to the property value column to continue processing. this method is called just before saving the properties.",
	"Method": "void combineProperties(HandlerContext handlerCtx){\r\n    List<Map> tableList = (List) handlerCtx.getInputValue(\"tableList\");\r\n    List<Map> combined = new ArrayList();\r\n    for (Map oneRow : tableList) {\r\n        Map newRow = new HashMap();\r\n        boolean isC = (Boolean) oneRow.get(\"isConfidential\");\r\n        String name = (String) oneRow.get(\"name\");\r\n        newRow.put(\"name\", name);\r\n        if (GuiUtil.isEmpty(name)) {\r\n            continue;\r\n        }\r\n        if (isC) {\r\n            String v1 = (String) oneRow.get(\"confValue\");\r\n            String v2 = (String) oneRow.get(\"confValue2\");\r\n            if (v1 == null) {\r\n                if (v2 != null) {\r\n                    GuiUtil.handleError(handlerCtx, \"Confidential property '\" + name + \"' does not match.\");\r\n                    return;\r\n                }\r\n                continue;\r\n            }\r\n            if (!v1.equals(v2)) {\r\n                GuiUtil.handleError(handlerCtx, \"Confidential property '\" + name + \"' does not match.\");\r\n                return;\r\n            }\r\n            newRow.put(\"value\", v1);\r\n        } else {\r\n            newRow.put(\"value\", oneRow.get(\"value\"));\r\n        }\r\n        combined.add(newRow);\r\n    }\r\n    handlerCtx.setOutputValue(\"combined\", combined);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.SelectQueryPlan.doJoin",
	"Comment": "joins the current plan with foreignplan.the join operation joinoperationwill be added to the constraint stack.",
	"Method": "void doJoin(SelectQueryPlan foreignPlan,int joinOperation){\r\n    if ((foreignPlan.status & ST_JOINED) > 0) {\r\n        return;\r\n    }\r\n    mergeConstraints(foreignPlan, joinOperation);\r\n    mergeStatements(foreignPlan, joinOperation);\r\n    if (foreignPlan.tables != null) {\r\n        addQueryTables(foreignPlan.tables);\r\n    }\r\n    foreignPlan.status = foreignPlan.status | ST_JOINED;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.introspection.DefaultAnnotationScanner.isAnnotation",
	"Comment": "test if the passed constant pool string is a reference to a type.type annotation of a j2ee component",
	"Method": "boolean isAnnotation(String value){\r\n    return annotations.contains(value);\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.UtilHandlers.startsWith",
	"Comment": "this handler will test if a string starts with another string.",
	"Method": "void startsWith(HandlerContext handlerCtx){\r\n    String testStr = ((String) handlerCtx.getInputValue(\"testStr\"));\r\n    String pattern = ((String) handlerCtx.getInputValue(\"pattern\"));\r\n    handlerCtx.setOutputValue(\"result\", testStr.startsWith(pattern));\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.matchesTable",
	"Comment": "check if the table of the column matches one of the list of tables.",
	"Method": "boolean matchesTable(List tableNames,ColumnElement column){\r\n    return ((column == null) ? true : tableNames.contains(column.getDeclaringTable().getName().getName()));\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.AppClientContainer.newBuilder",
	"Comment": "creates a new acc builder object, preset with the specifiedtarget servers.",
	"Method": "AppClientContainer.Builder newBuilder(TargetServer[] targetServers){\r\n    return new AppClientContainerBuilder(targetServers);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.DMManagedConnectionFactory.createManagedConnection",
	"Comment": "creates a new physical connection to the underlying eis resourcemanager.",
	"Method": "javax.resource.spi.ManagedConnection createManagedConnection(javax.security.auth.Subject subject,ConnectionRequestInfo cxRequestInfo){\r\n    logFine(\"In createManagedConnection\");\r\n    if (dsObjBuilder == null) {\r\n        dsObjBuilder = new DataSourceObjectBuilder(spec);\r\n    }\r\n    PasswordCredential pc = SecurityUtils.getPasswordCredential(this, subject, cxRequestInfo);\r\n    try {\r\n        Class.forName(spec.getDetail(DataSourceSpec.CLASSNAME));\r\n    } catch (ClassNotFoundException cnfe) {\r\n        _logger.log(Level.SEVERE, \"jdbc.exc_cnfe\", cnfe);\r\n        throw new ResourceException(\"The driver could not be loaded: \" + spec.getDetail(DataSourceSpec.CLASSNAME));\r\n    }\r\n    java.sql.Connection dsConn = null;\r\n    ManagedConnectionImpl mc = null;\r\n    Properties driverProps = new Properties();\r\n    Hashtable properties = dsObjBuilder.parseDriverProperties(spec, false);\r\n    Set<Map.Entry<String, Vector>> entries = (Set<Map.Entry<String, Vector>>) properties.entrySet();\r\n    for (Map.Entry<String, Vector> entry : entries) {\r\n        String value = \"\";\r\n        String key = (String) entry.getKey();\r\n        Vector values = (Vector) entry.getValue();\r\n        if (!values.isEmpty() && values.size() == 1) {\r\n            value = (String) values.firstElement();\r\n        } else if (values.size() > 1) {\r\n            logFine(\"More than one value for key : \" + key);\r\n        }\r\n        String prop = getParsedKey(key);\r\n        driverProps.put(prop, value);\r\n        if (prop.equalsIgnoreCase(\"URL\")) {\r\n            if (spec.getDetail(DataSourceSpec.URL) == null) {\r\n                setConnectionURL(value);\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        if (cxRequestInfo != null) {\r\n            driverProps.setProperty(\"user\", pc.getUserName());\r\n            driverProps.setProperty(\"password\", new String(pc.getPassword()));\r\n        } else {\r\n            String user = spec.getDetail(DataSourceSpec.USERNAME);\r\n            String password = spec.getDetail(DataSourceSpec.PASSWORD);\r\n            if (user != null) {\r\n                driverProps.setProperty(\"user\", user);\r\n            }\r\n            if (password != null) {\r\n                driverProps.setProperty(\"password\", password);\r\n            }\r\n        }\r\n        dsConn = DriverManager.getConnection(spec.getDetail(DataSourceSpec.URL), driverProps);\r\n    } catch (java.sql.SQLException sqle) {\r\n        _logger.log(Level.SEVERE, \"jdbc.exc_create_mc\", sqle);\r\n        throw new javax.resource.spi.ResourceAllocationException(\"The connection could not be allocated: \" + sqle.getMessage());\r\n    }\r\n    try {\r\n        mc = constructManagedConnection(null, dsConn, pc, this);\r\n        validateAndSetIsolation(mc);\r\n    } finally {\r\n        if (mc == null) {\r\n            try {\r\n                dsConn.close();\r\n            } catch (SQLException e) {\r\n                _logger.log(Level.FINEST, \"Exception while closing connection : createManagedConnection\" + dsConn);\r\n            }\r\n        }\r\n    }\r\n    return mc;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.implementsInterface",
	"Comment": "determines if the specified class implements the specified interface. \tnote, class element is a model specific class representation as returned \tby a getclass call executed on the same model instance. this \timplementation expects the class element being a reflection instance.",
	"Method": "boolean implementsInterface(Object classElement,String interfaceName){\r\n    Class interfaceClass = (Class) getClass(interfaceName);\r\n    if ((classElement == null) || !(classElement instanceof Class) || (interfaceClass == null))\r\n        return false;\r\n    return interfaceClass.isAssignableFrom((Class) classElement);\r\n}"
}, {
	"Path": "org.glassfish.enterprise.iiop.api.GlassFishORBHelper.getORB",
	"Comment": "get or create the default orb.this can be called for any process type.however,protocol manager and cosnaming initialization only take place for the server.",
	"Method": "ORB getORB(){\r\n    if (orb == null) {\r\n        synchronized (this) {\r\n            if (orb == null) {\r\n                try {\r\n                    final boolean isServer = processEnv.getProcessType().isServer();\r\n                    Properties props = new Properties();\r\n                    props.setProperty(GlassFishORBFactory.ENV_IS_SERVER_PROPERTY, Boolean.valueOf(isServer).toString());\r\n                    orb = orbFactory.createORB(props);\r\n                    if (isServer) {\r\n                        if (protocolManager == null) {\r\n                            ProtocolManager tempProtocolManager = protocolManagerProvider.get();\r\n                            tempProtocolManager.initialize(orb);\r\n                            tempProtocolManager.initializePOAs();\r\n                            protocolManager = tempProtocolManager;\r\n                            GlassfishNamingManager namingManager = glassfishNamingManagerProvider.get();\r\n                            Remote remoteSerialProvider = namingManager.initializeRemoteNamingSupport(orb);\r\n                            protocolManager.initializeRemoteNaming(remoteSerialProvider);\r\n                        }\r\n                    }\r\n                } catch (Exception e) {\r\n                    orb = null;\r\n                    protocolManager = null;\r\n                    throw new RuntimeException(\"Orb initialization erorr\", e);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return orb;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.QueryImpl.declareImports",
	"Comment": "bind the import statements to the query instance.all imports must be declared in the same method call,and the imports must be separated by semicolons.the syntax is the same as in the java language import statement.parameters and unbound variables might come from a different classfrom the candidate class, and the names might need to be declared in animport statement to eliminate ambiguity.",
	"Method": "void declareImports(String imports){\r\n    synchronized (this.paramtab) {\r\n        this.importDeclarations = imports;\r\n        this.compiled = false;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.EjbIORConfigurationDescriptor.print",
	"Comment": "returns a formatted string of the attributes of this object.",
	"Method": "void print(StringBuffer toStringBuffer){\r\n    toStringBuffer.append(\"\\n integrity \").append(integrity);\r\n    toStringBuffer.append(\"\\n confidentiality \").append(confidentiality);\r\n    toStringBuffer.append(\"\\n establishTrustInTarget \").append(establishTrustInTarget);\r\n    toStringBuffer.append(\"\\n establishTrustInClient \").append(establishTrustInClient);\r\n    toStringBuffer.append(\"\\n callerPropagation \").append(callerPropagation);\r\n    toStringBuffer.append(\"\\n realm \").append(realmName);\r\n    toStringBuffer.append(\"\\n authenticationMethod \").append(authenticationMethod).append(\"\\n\");\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.NameMapper.getEjbNameForAbstractSchema",
	"Comment": "gets the name of the ejb which corresponds to the specified abstract \tschema name.",
	"Method": "String getEjbNameForAbstractSchema(String schemaName){\r\n    Map abstractSchemaMap = (Map) getMap().get(ABSTRACT_SCHEMA_NAME);\r\n    return (String) abstractSchemaMap.get(schemaName);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStoreManager.getPersistenceConfig",
	"Comment": "returns the sqlstore model for class classtype.sqlstore model information is cached. if the model cache doesnot already hold a model instance for the particular class,a new instance is created, initialized and put into the cache.the access to the model cache is synchronized.",
	"Method": "PersistenceConfig getPersistenceConfig(Class classType){\r\n    if (logger.isLoggable(Logger.FINER)) {\r\n        // NOI18N\r\n        logger.finer(\"sqlstore.sqlstoremanager.getpersistenceconfig\", classType.getName());\r\n    }\r\n    return configCache.getPersistenceConfig(classType);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.Environment.lookupClass",
	"Comment": "look up the specified class in the class search path.callersshould normally consult the classmap prior to calling this function.the class is not entered into the classmap",
	"Method": "ClassControl lookupClass(String className){\r\n    ClassFileSource source = classPathOption.findClass(className);\r\n    while (true) {\r\n        if (source == null)\r\n            return null;\r\n        try {\r\n            ClassControl cc = new ClassControl(source, this);\r\n            if (cc.className() != null && cc.className().equals(className))\r\n                return cc;\r\n        } catch (ClassFormatError e) {\r\n        }\r\n        source = source.nextSource(className);\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.BaseContainer.resumeTransaction",
	"Comment": "called from postinvoketx if transaction needs to be resumed",
	"Method": "boolean resumeTransaction(EjbInvocation inv){\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.connector.module.ConnectorSniffer.getContainersNames",
	"Comment": "returns the list of containers that this sniffer enables.the runtime will look up each container implementingusing the names provided in the habitat.",
	"Method": "String[] getContainersNames(){\r\n    return containerNames;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.isKey",
	"Comment": "determines if the specified classname and fieldname pair represent a\tkey field.",
	"Method": "boolean isKey(String className,String fieldName){\r\n    PersistenceFieldElement field = getPersistenceField(className, fieldName);\r\n    return field != null ? field.isKey() : false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.HashSet.cloneInternal",
	"Comment": "creates and returns a copy of this object without resetting the owner and field value.",
	"Method": "Object cloneInternal(){\r\n    return super.clone();\r\n}"
}, {
	"Path": "org.glassfish.ejb.embedded.DomainXmlTransformer.getAddedEventBeforeEndElement",
	"Comment": "write a new element with the specified name and attribute before the end element is written out",
	"Method": "XMLEvent getAddedEventBeforeEndElement(XMLEvent event,XMLEventWriter writer,String elementName,String attributeName,String attributeValue){\r\n    Attribute newAttribute = xmlEventFactory.createAttribute(attributeName, attributeValue);\r\n    Set attributes = new HashSet();\r\n    attributes.add(newAttribute);\r\n    EndElement oldEvent = event.asEndElement();\r\n    StartElement newStartEvent = xmlEventFactory.createStartElement(new QName(elementName), attributes.iterator(), oldEvent.getNamespaces());\r\n    writer.add(newStartEvent);\r\n    return xmlEventFactory.createEndElement(newStartEvent.getName(), newStartEvent.getNamespaces());\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsSubqueriesInExists",
	"Comment": "retrieves whether this database supports subqueries inexists expressions.",
	"Method": "boolean supportsSubqueriesInExists(){\r\n    return databaseMetaData.supportsSubqueriesInExists();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlDate.writeReplace",
	"Comment": "use java.sql.date as the designated object to be used when writingthis object to the stream.",
	"Method": "Object writeReplace(){\r\n    return new java.sql.Date(getTime());\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.setRequireTrackedSCO",
	"Comment": "sets the requiretrackedsco flag for this persistencemanagerfactory.if set to false, by default the persistencemanager will not create trackedsco instances for new persistent instances at commit with retainvalues set to truerequests and while retrieving data from a datastore.",
	"Method": "void setRequireTrackedSCO(boolean flag){\r\n    throw new JDOUnsupportedOptionException(// NOI18N\r\n    I18NHelper.getMessage(messages, \"jdo.persistencemanagerfactoryimpl.notsupported\"));\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.WebServicesDescriptor.print",
	"Comment": "returns a formatted string of the attributes of this object.",
	"Method": "void print(StringBuffer toStringBuffer){\r\n    super.print(toStringBuffer);\r\n    if (hasWebServices()) {\r\n        for (Iterator itr = getWebServices().iterator(); itr.hasNext(); ) {\r\n            WebService aWebService = (WebService) itr.next();\r\n            toStringBuffer.append(\"\\n Web Service : \");\r\n            aWebService.print(toStringBuffer);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.stats.BoundaryStatisticImpl.getLowerBound",
	"Comment": "returns the lowest possible value, that this statistic is permitted to attain",
	"Method": "long getLowerBound(){\r\n    return lowerBound;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.removeUpdatedForeignReference",
	"Comment": "removes the dependency from state manager sm onthis. state manager sm does not need towait for this to be flushed to the store. the dependencywas established to maintain referential integrity conditions in thedata store.",
	"Method": "void removeUpdatedForeignReference(ForeignFieldDesc fieldDesc,SQLStateManager sm){\r\n    if ((updatedForeignReferences == null) || (updatedForeignReferences.size() == 0)) {\r\n        return;\r\n    }\r\n    if (updatedForeignReferences.remove(new UpdatedForeignReference(fieldDesc, sm))) {\r\n        sm.referenceCount--;\r\n        if (logger.isLoggable()) {\r\n            String fieldName = (fieldDesc != null) ? fieldDesc.getName() : null;\r\n            Object[] items = new Object[] { this.persistentObject, fieldName, sm.persistentObject, new Integer(sm.referenceCount) };\r\n            logger.fine(\"sqlstore.sqlstatemanager.removeupdate\", items);\r\n        }\r\n        if (sm.referenceCount == 0) {\r\n            sm.stateFlags &= ~ST_UPDATE_DISABLED;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.EjbIORConfigurationDescriptor.setAuthenticationMethod",
	"Comment": "set the authentication method used to authenticate clients.",
	"Method": "void setAuthenticationMethod(String val){\r\n    if (!val.equalsIgnoreCase(USERNAME_PASSWORD) && !val.equalsIgnoreCase(NONE)) {\r\n        throw new RuntimeException(\"Incorrect value for \" + \"authentication method:\" + val);\r\n    }\r\n    authenticationMethod = val;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.TransactionImpl.afterCompletion",
	"Comment": "called in the managed environment only for transaction completion",
	"Method": "void afterCompletion(int st){\r\n    if (txType == NON_MGD) {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        messages, \"transaction.transactionimpl.nonmgd\", \"afterCompletion\"));\r\n    }\r\n    st = EJBHelper.translateStatus(st);\r\n    if (this.tracing) {\r\n        // NOI18N\r\n        this.traceCallInfo(\"afterCompletion\", TRACE_SYNCHRONIZATIONS, this.statusString(st));\r\n    }\r\n    if (st == Status.STATUS_ROLLEDBACK) {\r\n        this.setStatus(Status.STATUS_ROLLING_BACK);\r\n        this.internalRollback();\r\n    }\r\n    if (st != this.status) {\r\n        if (synchronization != null) {\r\n            try {\r\n                synchronization.afterCompletion(st);\r\n            } catch (Exception ex) {\r\n                logger.log(Logger.WARNING, I18NHelper.getMessage(messages, \"transaction.transactionimpl.syncmanager.aftercompletion\", ex.getMessage()));\r\n            }\r\n        }\r\n        persistenceManager.forceClose();\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"transaction.transactionimpl.commitprepare.wrongstatus\", \"afterCompletion\", this.statusString(this.status), this.statusString(st)));\r\n    }\r\n    this.notifyAfterCompletion();\r\n}"
}, {
	"Path": "org.glassfish.resources.naming.SerializableObjectRefAddr.getContent",
	"Comment": "retrieves the contents of this address. the result is a string.",
	"Method": "Object getContent(){\r\n    return contents;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ConnectionHolder40.createSQLXML",
	"Comment": "constructs an object that implements the sqlxml interface. the objectreturned initially contains no data. the createxmlstreamwriter object andsetstring method of the sqlxml interface may be used to add data to the sqlxmlobject.",
	"Method": "SQLXML createSQLXML(){\r\n    checkValidity();\r\n    jdbcPreInvoke();\r\n    return con.createSQLXML();\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.security.AdminConsoleAuthModule.initialize",
	"Comment": "this method configures this authmodule and makes sure all the \tinformation needed to continue is present.",
	"Method": "void initialize(MessagePolicy requestPolicy,MessagePolicy responsePolicy,CallbackHandler handler,Map options){\r\n    this.handler = handler;\r\n    if (options != null) {\r\n        this.loginPage = (String) options.get(\"loginPage\");\r\n        if (loginPage == null) {\r\n            throw new AuthException(\"'loginPage' \" + \"must be supplied as a property in the provider-config \" + \"in the domain.xml file!\");\r\n        }\r\n        this.loginErrorPage = (String) options.get(\"loginErrorPage\");\r\n        if (loginErrorPage == null) {\r\n            throw new AuthException(\"'loginErrorPage' \" + \"must be supplied as a property in the provider-config \" + \"in the domain.xml file!\");\r\n        }\r\n        ServiceLocator habitat = SecurityServicesUtil.getInstance().getHabitat();\r\n        Domain domain = habitat.getService(Domain.class);\r\n        NetworkListener adminListener = domain.getServerNamed(\"server\").getConfig().getNetworkConfig().getNetworkListener(\"admin-listener\");\r\n        SecureAdmin secureAdmin = habitat.getService(SecureAdmin.class);\r\n        final String host = adminListener.getAddress();\r\n        this.restURL = (SecureAdmin.Util.isEnabled(secureAdmin) ? \"https://\" : \"http://\") + (host.equals(\"0.0.0.0\") ? \"localhost\" : host) + \":\" + adminListener.getPort() + \"/management/sessions\";\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.jws.servedcontent.CachingDynamicContentImpl.addInstance",
	"Comment": "adds a new content instance to this dynamic content.if adding the instancemakes the cache too long, discards the oldest instance.",
	"Method": "void addInstance(Instance newInstance){\r\n    synchronized (instances) {\r\n        instances.addFirst(newInstance);\r\n        if (instances.size() > maxInstances) {\r\n            instances.removeLast();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.RetrieveDescImpl.setNavigationalId",
	"Comment": "sets a navigational id on the retrieve descriptor. this idwill be used to discriminate different retrieve descriptors whichuse the same navigational field. if not set, the field name is used.",
	"Method": "void setNavigationalId(Object navigationalId){\r\n    this.navigationalId = navigationalId;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.ConnectionFactoryImpl.getMsWait",
	"Comment": "returns the number of milliseconds to wait for an available connectionfrom the connection pool before throwing an exception",
	"Method": "int getMsWait(){\r\n    if (connectionManager == null)\r\n        return msWait;\r\n    return connectionManager.getMsWait();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ActiveOutboundResourceAdapter.loadRAConfiguration",
	"Comment": "loads ra javabean. this method is protected, so that any systemresource adapter can have specific configuration done during theloading.",
	"Method": "void loadRAConfiguration(){\r\n    try {\r\n        Set mergedProps;\r\n        ConnectorRegistry registry = ConnectorRegistry.getInstance();\r\n        ResourceAdapterConfig raConfig = registry.getResourceAdapterConfig(moduleName_);\r\n        List<Property> raConfigProps = new ArrayList<Property>();\r\n        mergedProps = mergeRAConfiguration(raConfig, raConfigProps);\r\n        logMergedProperties(mergedProps);\r\n        SetMethodAction setMethodAction = new SetMethodAction(this.resourceadapter_, mergedProps);\r\n        setMethodAction.run();\r\n    } catch (Exception e) {\r\n        String i18nMsg = localStrings.getString(\"ccp_adm.wrong_params_for_create\", e.getMessage());\r\n        ConnectorRuntimeException cre = new ConnectorRuntimeException(i18nMsg);\r\n        cre.initCause(e);\r\n        throw cre;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.isModOperationUsingFunction",
	"Comment": "returns true if modulo operation uses function, false otherwise.",
	"Method": "boolean isModOperationUsingFunction(){\r\n    return getModFunctionName().length() != 0;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.newCollectionInstanceInternal",
	"Comment": "called by newcollectioninstance from the public interface or internallyby the runtimewill not result in marking field as dirty",
	"Method": "Object newCollectionInstanceInternal(Class type,Object owner,String fieldName,Class elementType,boolean allowNulls,int initialSize){\r\n    Object obj = null;\r\n    if (type == HashSet.class || type == com.sun.jdo.spi.persistence.support.sqlstore.sco.HashSet.class) {\r\n        if (initialSize == 0)\r\n            initialSize = 101;\r\n        obj = new com.sun.jdo.spi.persistence.support.sqlstore.sco.HashSet(owner, fieldName, elementType, allowNulls, initialSize);\r\n    } else if (Set.class.isAssignableFrom(type)) {\r\n        if (initialSize == 0)\r\n            initialSize = 101;\r\n        obj = new com.sun.jdo.spi.persistence.support.sqlstore.sco.HashSet(owner, fieldName, elementType, allowNulls, initialSize);\r\n    } else if (Collection.class.isAssignableFrom(type)) {\r\n        if (initialSize == 0)\r\n            initialSize = 101;\r\n        obj = new com.sun.jdo.spi.persistence.support.sqlstore.sco.HashSet(owner, fieldName, elementType, allowNulls, initialSize);\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerimpl.newscoinstance.wrongclass\", type.getName()));\r\n    }\r\n    boolean debug = logger.isLoggable(Logger.FINEST);\r\n    if (debug)\r\n        logger.finest(\"sqlstore.persistencemgr.newcollection\", obj.getClass());\r\n    return obj;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.work.context.WorkContextHandlerImpl.canContainerHandleSameContextType",
	"Comment": "checks whether the container can handle the exact context type provided",
	"Method": "boolean canContainerHandleSameContextType(String workContextClassName){\r\n    boolean result = false;\r\n    for (Class workContextClass : containerSupportedContexts) {\r\n        Class clz = null;\r\n        try {\r\n            clz = loadClass(workContextClassName);\r\n        } catch (ClassNotFoundException cnfe) {\r\n            logger.log(Level.WARNING, RAR_LOAD_WORK_CONTEXT_ERROR, new Object[] { workContextClassName, cnfe });\r\n            break;\r\n        }\r\n        if (workContextClass.equals(clz)) {\r\n            result = true;\r\n            debug(\"Container can handle the context [Strict] : \" + workContextClassName);\r\n            break;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jaspic.config.factory.BaseAuthConfigFactory.refresh",
	"Comment": "cause the factory to reprocess its persistent declarativerepresentation of provider registrations. a factory should only replace an existing registration whena change of provider implementation class or initializationproperties has occurred.",
	"Method": "void refresh(){\r\n    SecurityManager sm = System.getSecurityManager();\r\n    if (sm != null) {\r\n        sm.checkPermission(AuthConfigFactory.providerRegistrationSecurityPermission);\r\n    }\r\n    Map<String, List<RegistrationListener>> preExistingListenersMap;\r\n    wLock.lock();\r\n    try {\r\n        preExistingListenersMap = id2RegisListenersMap;\r\n        _loadFactory();\r\n    } finally {\r\n        wLock.unlock();\r\n    }\r\n    if (preExistingListenersMap != null) {\r\n        notifyListeners(preExistingListenersMap);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ee.Audit.showACL",
	"Comment": "diagnostic method. read roles and acls from the given applicationand dump a somewhat organized summary of what has been set.this can be used to diagnose deployment or runtime deployment errorsas well as to help in configuring application descriptors.implementation is not particularly efficient but this is onlycalled for debugging purposes at startup. all errors are ignored.",
	"Method": "void showACL(Application app){\r\n    if (!isActive() || !logger.isLoggable(Level.FINEST)) {\r\n        return;\r\n    }\r\n    try {\r\n        dumpDiagnostics(app);\r\n    } catch (Throwable e) {\r\n        logger.fine(\"Error while showing ACL diagnostics: \" + e.toString());\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.ClassAction.insertPersistenceCapableMethods",
	"Comment": "add all the methods required for com.sun.jdo.spi.persistence.support.sqlstore.persistencecapable interface.",
	"Method": "void insertPersistenceCapableMethods(){\r\n    affirm(implementsPersistence);\r\n    control.noteUpdate();\r\n    affirm(!sawMethodJDOGetStateManager);\r\n    classFile().addMethod(methodBuilder.makeJDOGetStateManager(this, jdoGetStateManagerName));\r\n    affirm(!sawMethodJDOSetStateManager);\r\n    classFile().addMethod(methodBuilder.makeJDOSetStateManager(this, jdoSetStateManagerName));\r\n    affirm(!sawMethodJDOGetFlags);\r\n    classFile().addMethod(methodBuilder.makeJDOGetFlags(this, jdoGetFlagsName));\r\n    affirm(!sawMethodJDOSetFlags);\r\n    classFile().addMethod(methodBuilder.makeJDOSetFlags(this, jdoSetFlagsName));\r\n    affirm(!sawMethodJDOMakeDirty);\r\n    classFile().addMethod(methodBuilder.makeJDOMakeDirtyMethod(this, jdoMakeDirtyName));\r\n    affirm(!sawMethodJDOIsDirty);\r\n    classFile().addMethod(methodBuilder.makeJDOInterrogativeMethod(this, jdoIsDirtyName));\r\n    affirm(!sawMethodJDOIsTransactional);\r\n    classFile().addMethod(methodBuilder.makeJDOInterrogativeMethod(this, jdoIsTransactionalName));\r\n    affirm(!sawMethodJDOIsPersistent);\r\n    classFile().addMethod(methodBuilder.makeJDOInterrogativeMethod(this, jdoIsPersistentName));\r\n    affirm(!sawMethodJDOIsNew);\r\n    classFile().addMethod(methodBuilder.makeJDOInterrogativeMethod(this, jdoIsNewName));\r\n    affirm(!sawMethodJDOIsDeleted);\r\n    classFile().addMethod(methodBuilder.makeJDOInterrogativeMethod(this, jdoIsDeletedName));\r\n    affirm(!sawMethodJDOGetPersistenceManager);\r\n    classFile().addMethod(methodBuilder.makeJDOGetPersistenceManagerMethod(this, jdoGetPersistenceManagerName));\r\n    affirm(!sawMethodJDOGetObjectId);\r\n    classFile().addMethod(methodBuilder.makeJDOGetObjectIdMethod(this, jdoGetObjectIdName));\r\n    affirm(!sawMethodJDOConstructor);\r\n    classFile().addMethod(methodBuilder.makeJDOConstructor(this, jdoConstructorName));\r\n    affirm(!sawMethodJDONewInstance);\r\n    classFile().addMethod(methodBuilder.makeJDONewInstanceMethod(this, jdoNewInstanceName));\r\n    affirm(!sawMethodJDOGetField);\r\n    classFile().addMethod(methodBuilder.makeJDOGetFieldMethod(this, jdoGetFieldName));\r\n    affirm(!sawMethodJDOSetField);\r\n    classFile().addMethod(methodBuilder.makeJDOSetFieldMethod(this, jdoSetFieldName));\r\n    affirm(!sawMethodJDOClear);\r\n    classFile().addMethod(methodBuilder.makeJDOClearMethod(this, jdoClearName));\r\n    if (!sawMethodJDOClone) {\r\n        classFile().addMethod(methodBuilder.makeJDOClone(this, jdoCloneName));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.ParameterSupport.getParameterEjbName",
	"Comment": "get ejb name corresponding to the ejbql parameter by inputparameter declaration string.",
	"Method": "String getParameterEjbName(String ejbqlParamDecl,String getParameterEjbName,int paramNumber){\r\n    return parameterEjbNames[paramNumber - 1];\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.TypeSupport.isRemoteInterface",
	"Comment": "returns true if the specified type info denotesa remote interface.",
	"Method": "boolean isRemoteInterface(Object typeInfo){\r\n    return nameMapper.isRemoteInterface(getTypeName(typeInfo));\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnection.removeConnectionEventListener",
	"Comment": "removes an already registered connection event listener from themanagedconnection instance.",
	"Method": "void removeConnectionEventListener(ConnectionEventListener listener){\r\n    listener = null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.UpdateStatement.getInputValue",
	"Comment": "gets input value corrsponding to given columnref from given updatedesc",
	"Method": "Object getInputValue(UpdateObjectDescImpl updateDesc,ColumnRef columnRef,boolean getBeforeValue){\r\n    Object value;\r\n    LocalFieldDesc field = (LocalFieldDesc) columnRef.getValue();\r\n    if (field.isVersion()) {\r\n        value = updateDesc.getAfterValue(field);\r\n    } else {\r\n        value = getBeforeValue ? updateDesc.getBeforeValue(field) : updateDesc.getAfterValue(field);\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.DumpMapping.setModel",
	"Comment": "sets the internal model reference used by the dumpmapping methods\tto the specified model instance.",
	"Method": "void setModel(Model newModel){\r\n    model = newModel;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.resetIsolation",
	"Comment": "resets the isolation level for the managedconnection passed.if the transaction level is to be guaranteed to be the same as the onepresent when this managedconnection was created, as specifiedby the connectionrequestinfo passed, it sets the transactionisolation level from the connectionrequestinfo passed. else,it sets it to the transaction isolation passed.",
	"Method": "void resetIsolation(ManagedConnectionImpl mc,int tranIsol){\r\n    java.sql.Connection con = mc.getActualConnection();\r\n    if (con == null) {\r\n        return;\r\n    }\r\n    String tranIsolation = spec.getDetail(DataSourceSpec.TRANSACTIONISOLATION);\r\n    if (tranIsolation != null && !tranIsolation.equals(\"\")) {\r\n        String guaranteeIsolationLevel = spec.getDetail(DataSourceSpec.GUARANTEEISOLATIONLEVEL);\r\n        if (guaranteeIsolationLevel != null && !guaranteeIsolationLevel.equals(\"\")) {\r\n            boolean guarantee = Boolean.valueOf(guaranteeIsolationLevel.toLowerCase(Locale.getDefault()));\r\n            if (guarantee) {\r\n                int tranIsolationInt = getTransactionIsolationInt(tranIsolation);\r\n                try {\r\n                    if (tranIsolationInt != con.getTransactionIsolation()) {\r\n                        con.setTransactionIsolation(tranIsolationInt);\r\n                    }\r\n                } catch (java.sql.SQLException sqle) {\r\n                    _logger.log(Level.SEVERE, \"jdbc.exc_tx_iso\", sqle);\r\n                    throw new ResourceException(\"The isolation level could not be set: \" + sqle.getMessage());\r\n                }\r\n            } else {\r\n                try {\r\n                    if (tranIsol != con.getTransactionIsolation()) {\r\n                        con.setTransactionIsolation(tranIsol);\r\n                    }\r\n                } catch (java.sql.SQLException sqle) {\r\n                    _logger.log(Level.SEVERE, \"jdbc.exc_tx_iso\", sqle);\r\n                    throw new ResourceException(\"The isolation level could not be set: \" + sqle.getMessage());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.NameMapper.getLocalInterfaceForEjbName",
	"Comment": "gets the name of the local interface which corresponds to the \tspecified ejb name.",
	"Method": "String getLocalInterfaceForEjbName(String name){\r\n    EjbCMPEntityDescriptor descriptor = getDescriptorForEjbName(name);\r\n    return ((descriptor != null) ? descriptor.getLocalClassName() : null);\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.XAResourceImpl.setTransactionTimeout",
	"Comment": "set the current transaction timeout value for this xaresource instance.",
	"Method": "boolean setTransactionTimeout(int seconds){\r\n    return xar.setTransactionTimeout(seconds);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MailConfiguration.getMailTransportProtocol",
	"Comment": "get the default transport protocol for the mail session the server willprovide.",
	"Method": "String getMailTransportProtocol(){\r\n    return this.transportProtocol;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ClassDesc.getKeyFieldDescs",
	"Comment": "returns the descriptors for key fields as array of localfielddesc.",
	"Method": "LocalFieldDesc[] getKeyFieldDescs(){\r\n    return keyFieldDescs;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.ConnectionPool.killExtraResources",
	"Comment": "kill the extra resources.the maxpoolsize being reduced causes this method tobe called",
	"Method": "void killExtraResources(int numToKill){\r\n    cancelResizerTask();\r\n    ResourceHandle h;\r\n    for (int i = 0; i < numToKill && ((h = ds.getResource()) != null); i++) {\r\n        ds.removeResource(h);\r\n    }\r\n    scheduleResizerTask();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.cleanup",
	"Comment": "application server calls this method to force any cleanup on themanagedconnectionimpl instance. this method calls the invalidatemethod on all connectionhandles associated with this managedconnectionimpl.",
	"Method": "void cleanup(){\r\n    logFine(\"In cleanup\");\r\n    isClean = true;\r\n    ManagedConnectionFactoryImpl spiMCF = (ManagedConnectionFactoryImpl) mcf;\r\n    resetConnectionProperties(spiMCF);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.UpdateObjectDescImpl.hasChangedRelationships",
	"Comment": "returns true, if this state manager has a changedrelationship field.",
	"Method": "boolean hasChangedRelationships(){\r\n    if (relationshipChanged) {\r\n        return true;\r\n    }\r\n    if (hasUpdatedJoinTableRelationships()) {\r\n        return true;\r\n    }\r\n    if (updatedFields != null) {\r\n        for (Iterator iter = updatedFields.iterator(); iter.hasNext(); ) {\r\n            LocalFieldDesc field = (LocalFieldDesc) iter.next();\r\n            if (field.isForeignKeyField()) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.LocalFieldDesc.lookupTypePrecedence",
	"Comment": "this method looks up the type precedence given a typeprecedence array.",
	"Method": "int lookupTypePrecedence(Class type,Class typePrecedence){\r\n    for (int i = 0; i < typePrecedence.length; i++) {\r\n        if (type == typePrecedence[i]) {\r\n            return i;\r\n        }\r\n    }\r\n    return Integer.MAX_VALUE;\r\n}"
}, {
	"Path": "org.glassfish.jca.admingui.handlers.ConnectorsHandlers.getConnectorConnectionPoolWizard",
	"Comment": "this handler creates a connectorconnection pool to be used in the wizard",
	"Method": "void getConnectorConnectionPoolWizard(HandlerContext handlerCtx){\r\n    Boolean fromStep2 = (Boolean) handlerCtx.getInputValue(\"fromStep2\");\r\n    Boolean fromStep1 = (Boolean) handlerCtx.getInputValue(\"fromStep1\");\r\n    if ((fromStep2 != null) && fromStep2) {\r\n        Map extra = (Map) handlerCtx.getFacesContext().getExternalContext().getSessionMap().get(\"wizardPoolExtra\");\r\n        String resAdapter = (String) extra.get(\"resourceAdapterName\");\r\n        handlerCtx.setOutputValue(\"resultAdapter\", resAdapter);\r\n    } else if ((fromStep1 != null) && fromStep1) {\r\n        String resAdapter = (String) handlerCtx.getInputValue(\"resAdapter\");\r\n        if (resAdapter != null) {\r\n            resAdapter = resAdapter.trim();\r\n        }\r\n        String poolName = (String) handlerCtx.getInputValue(\"poolName\");\r\n        if (poolName != null) {\r\n            poolName = poolName.trim();\r\n        }\r\n        if (resAdapter != null && !(resAdapter.equals(\"\"))) {\r\n            Map extra = (Map) handlerCtx.getFacesContext().getExternalContext().getSessionMap().get(\"wizardPoolExtra\");\r\n            extra.put(\"resourceAdapterName\", resAdapter);\r\n            extra.put(\"name\", poolName);\r\n            handlerCtx.setOutputValue(\"resultAdapter\", resAdapter);\r\n        }\r\n    } else {\r\n        Map extra = new HashMap();\r\n        Map attrMap = (Map) handlerCtx.getInputValue(\"attrMap\");\r\n        handlerCtx.getFacesContext().getExternalContext().getSessionMap().put(\"wizardMap\", attrMap);\r\n        handlerCtx.getFacesContext().getExternalContext().getSessionMap().put(\"wizardPoolExtra\", extra);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnection.getConnection",
	"Comment": "creates a new connection handle for the underlying physical connection represented by the managedconnection instance.",
	"Method": "Object getConnection(Subject sub,javax.resource.spi.ConnectionRequestInfo cxReqInfo){\r\n    if (logWriter != null) {\r\n        logWriter.println(\"In getConnection\");\r\n    }\r\n    checkIfValid();\r\n    com.sun.jdbcra.spi.ConnectionRequestInfo cxRequestInfo = (com.sun.jdbcra.spi.ConnectionRequestInfo) cxReqInfo;\r\n    PasswordCredential passwdCred = SecurityUtils.getPasswordCredential(this.mcf, sub, cxRequestInfo);\r\n    if (SecurityUtils.isPasswordCredentialEqual(this.passwdCredential, passwdCred) == false) {\r\n        throw new javax.resource.spi.SecurityException(\"Re-authentication not supported\");\r\n    }\r\n    getActualConnection();\r\n    if (isClean) {\r\n        ((com.sun.jdbcra.spi.ManagedConnectionFactory) mcf).resetIsolation(this, isolationLevelWhenCleaned);\r\n    }\r\n    ConnectionHolder connHolderObject = new ConnectionHolder(actualConnection, this);\r\n    isClean = false;\r\n    if (activeConnectionHandle != null) {\r\n        activeConnectionHandle.setActive(false);\r\n    }\r\n    connHolderObject.setActive(true);\r\n    activeConnectionHandle = connHolderObject;\r\n    return connHolderObject;\r\n}"
}, {
	"Path": "org.glassfish.resources.module.ResourcesContainer.getDeployer",
	"Comment": "returns the deployer implementation capable of deploying applications to thiscontainer.",
	"Method": "Class<? extends Deployer> getDeployer(){\r\n    return ResourcesDeployer.class;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnection.getConnectionType",
	"Comment": "this method determines the type of the connection being held in this managedconnection.",
	"Method": "int getConnectionType(PooledConnection pooledConn){\r\n    if (pooledConn == null) {\r\n        return ISNOTAPOOLEDCONNECTION;\r\n    } else if (pooledConn instanceof XAConnection) {\r\n        return ISXACONNECTION;\r\n    } else {\r\n        return ISPOOLEDCONNECTION;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.getAllFields",
	"Comment": "returns a list of names of all the field elements in the\tclass with the specified name.this list includes the inherited \tfields.",
	"Method": "List getAllFields(String className){\r\n    List returnList = new ArrayList();\r\n    while (className != null) {\r\n        returnList.addAll(getFields(className));\r\n        className = getSuperclass(className);\r\n    }\r\n    return returnList;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingReferenceKeyElementImpl.getDeclaringTable",
	"Comment": "get the declaring table.this method is provided as part of \tthe implementation of the referencekey interface but should only \tbe used when a referencekey object is used or by the runtime.",
	"Method": "TableElement getDeclaringTable(){\r\n    ArrayList locals = getReferencingKey();\r\n    if ((locals != null) && (locals.size() > 0)) {\r\n        String absoluteName = NameUtil.getAbsoluteMemberName(getDeclaringClass().getDatabaseRoot(), locals.get(0).toString());\r\n        return TableElement.forName(NameUtil.getTableName(absoluteName));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MethodDescriptor.convertToAppropriateFormat",
	"Comment": "converts an xml style parameter class name to java style and vice versa",
	"Method": "void convertToAppropriateFormat(String[] parameterClassNames){\r\n    int format = isJavaFormat(parameterClassNames);\r\n    if (format == JAVA_FORMAT) {\r\n        this.javaParameterClassNames = parameterClassNames;\r\n        this.parameterClassNames = fixParamClassNames(parameterClassNames);\r\n    } else if (format == XML_FORMAT) {\r\n        this.javaParameterClassNames = xmlFormat2JavaClassNames(parameterClassNames);\r\n        this.parameterClassNames = parameterClassNames;\r\n    } else if (format == XML_JAVA_FORMAT) {\r\n        this.javaParameterClassNames = parameterClassNames;\r\n        this.parameterClassNames = parameterClassNames;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.provider.PolicyConfigurationImpl.refresh",
	"Comment": "called by policywrapper to refresh context specific policy object.",
	"Method": "void refresh(boolean force){\r\n    synchronized (refreshLock) {\r\n        if (stateIs(INSERVICE_STATE) && (wasRefreshed == false || force || filesChanged())) {\r\n            int i = 0;\r\n            String value = null;\r\n            String urlKey = null;\r\n            while (true) {\r\n                urlKey = PROVIDER_URL + (++i);\r\n                value = getSecurityProperty(urlKey);\r\n                if (value == null || value.equals(\"\")) {\r\n                    break;\r\n                }\r\n            }\r\n            try {\r\n                setSecurityProperty(urlKey, policyUrlValue);\r\n                if (fileChanged(false)) {\r\n                    excludedPermissions = loadExcludedPolicy();\r\n                }\r\n                captureFileTime(true);\r\n                if (policy == null) {\r\n                    policy = getNewPolicy();\r\n                } else {\r\n                    policy.refresh();\r\n                    if (logger.isLoggable(Level.FINE)) {\r\n                        logger.fine(\"JACC Policy Provider: Called Policy.refresh on contextId: \" + CONTEXT_ID + \" policyUrlValue was \" + policyUrlValue);\r\n                    }\r\n                }\r\n                wasRefreshed = true;\r\n            } finally {\r\n                setSecurityProperty(urlKey, \"\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.getField",
	"Comment": "returns the field with the supplied name from the collection of fields\tmaintained by this holder.",
	"Method": "PersistenceFieldElement getField(String name,PersistenceFieldElement getField,String name){\r\n    return getClassImpl().getField(name);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidationException.getMessage",
	"Comment": "returns the error message string of this throwable object.",
	"Method": "String getMessage(){\r\n    String message = super.getMessage();\r\n    if ((WARNING == getType()) && !StringHelper.isEmpty(message)) {\r\n        message = I18NHelper.getMessage(getMessages(), \"util.validation.warning\") + message;\r\n    }\r\n    return message;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.notifyNontransactionalRead",
	"Comment": "for transaction to notify persistencemanager thatnontransactionalread flag is changed",
	"Method": "void notifyNontransactionalRead(boolean nontransactionalRead){\r\n    this._nontransactionalRead = nontransactionalRead;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ForeignFieldDesc.hasForeignKey",
	"Comment": "checks the conditions that guarantee, that we have the foreignkey on this side.",
	"Method": "boolean hasForeignKey(){\r\n    boolean result = false;\r\n    if (inverseRelationshipField != null) {\r\n        result = cardinalityUPB == 1 && !useJoinTable() && (sqlProperties & FieldDesc.PROP_REF_INTEGRITY_UPDATES) > 0;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.getEjbByClassName",
	"Comment": "returns all ejb descriptors that has a give class name.it returns an empty array if no ejb is found.",
	"Method": "EjbDescriptor[] getEjbByClassName(String className){\r\n    ArrayList<EjbDescriptor> ejbList = new ArrayList<EjbDescriptor>();\r\n    for (Object ejb : getEjbs()) {\r\n        if (ejb instanceof EjbDescriptor) {\r\n            EjbDescriptor ejbDesc = (EjbDescriptor) ejb;\r\n            if (className.equals(ejbDesc.getEjbClassName())) {\r\n                ejbList.add(ejbDesc);\r\n            }\r\n        }\r\n    }\r\n    return ejbList.toArray(new EjbDescriptor[ejbList.size()]);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.getConnection",
	"Comment": "creates a new connection handle for the underlying physicalconnection represented by the managedconnectionimpl instance.",
	"Method": "Object getConnection(Subject sub,javax.resource.spi.ConnectionRequestInfo cxReqInfo){\r\n    logFine(\"In getConnection\");\r\n    checkIfValid();\r\n    getActualConnection();\r\n    ManagedConnectionFactoryImpl spiMCF = (ManagedConnectionFactoryImpl) mcf;\r\n    String statementTimeoutString = spiMCF.getStatementTimeout();\r\n    if (statementTimeoutString != null) {\r\n        int timeoutValue = Integer.parseInt(statementTimeoutString);\r\n        if (timeoutValue >= 0) {\r\n            statementTimeout = timeoutValue;\r\n        }\r\n    }\r\n    myLogicalConnection = spiMCF.getJdbcObjectsFactory().getConnection(actualConnection, this, cxReqInfo, spiMCF.isStatementWrappingEnabled(), sqlTraceDelegator);\r\n    if (!initSqlExecuted) {\r\n        String initSql = spiMCF.getInitSql();\r\n        executeInitSql(initSql);\r\n    }\r\n    incrementCount();\r\n    isClean = false;\r\n    myLogicalConnection.setActive(true);\r\n    return myLogicalConnection;\r\n}"
}, {
	"Path": "org.glassfish.orb.admin.cli.DeleteIiopListener.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final Target targetUtil = services.getService(Target.class);\r\n    final Config config = targetUtil.getConfig(target);\r\n    ActionReport report = context.getActionReport();\r\n    IiopService iiopService = config.getExtensionByType(IiopService.class);\r\n    if (!isIIOPListenerExists(iiopService)) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.iiop.listener\" + \".notexists\", \"IIOP Listener {0} does not exist.\", listener_id));\r\n        report.setActionExitCode(ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<IiopService>() {\r\n            @Override\r\n            public Object run(IiopService param) throws PropertyVetoException, TransactionFailure {\r\n                List<IiopListener> listenerList = param.getIiopListener();\r\n                for (IiopListener listener : listenerList) {\r\n                    String currListenerId = listener.getId();\r\n                    if (currListenerId != null && currListenerId.equals(listener_id)) {\r\n                        listenerList.remove(listener);\r\n                        break;\r\n                    }\r\n                }\r\n                return listenerList;\r\n            }\r\n        }, iiopService);\r\n        report.setActionExitCode(ExitCode.SUCCESS);\r\n    } catch (TransactionFailure e) {\r\n        String actual = e.getMessage();\r\n        report.setMessage(localStrings.getLocalString(\"delete.iiop.listener.fail\", \"failed\", listener_id, actual));\r\n        report.setActionExitCode(ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.orb.admin.cli.DeleteIiopListener.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    List<IiopListener> listenerList = param.getIiopListener();\r\n    for (IiopListener listener : listenerList) {\r\n        String currListenerId = listener.getId();\r\n        if (currListenerId != null && currListenerId.equals(listener_id)) {\r\n            listenerList.remove(listener);\r\n            break;\r\n        }\r\n    }\r\n    return listenerList;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.TransactionImpl.commit",
	"Comment": "commit the transaction represented by this transaction object",
	"Method": "void commit(){\r\n    persistenceManager.acquireExclusiveLock();\r\n    try {\r\n        if (txType == CMT || txType == BMT_UT) {\r\n            throw new JDOUserException(// NOI18N\r\n            I18NHelper.getMessage(// NOI18N\r\n            messages, \"transaction.transactionimpl.mgd\", \"commit\"));\r\n        } else if (txType == BMT_JDO) {\r\n            try {\r\n                EJBHelper.getLocalTransactionManager().commit();\r\n                return;\r\n            } catch (Exception e) {\r\n                throw new JDOException(\"\", e);\r\n            }\r\n        }\r\n        this.setTrace();\r\n        if (this.tracing)\r\n            this.traceCall(\"commit\");\r\n        this.commitBefore();\r\n        this.commitPrepare();\r\n        this.commitComplete();\r\n        this.notifyAfterCompletion();\r\n    } finally {\r\n        persistenceManager.releaseExclusiveLock();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.resources.connector.ResourcesSniffer.supportsArchiveType",
	"Comment": "this api is used to help determine if the sniffer should recognizethe current archive.if the sniffer does not support the archive type associated withthe current deployment, the sniffer should not recognize the archive.",
	"Method": "boolean supportsArchiveType(ArchiveType archiveType){\r\n    if (archiveType.toString().equals(ModuleType.WAR.toString()) || archiveType.toString().equals(ModuleType.EJB.toString()) || archiveType.toString().equals(ModuleType.RAR.toString()) || archiveType.toString().equals(ModuleType.CAR.toString())) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.persistence.jpa.PersistenceUnitLoader.checkForDataSourceOverride",
	"Comment": "if use provided data source is overridden, update persistenceunitdescriptor with it",
	"Method": "void checkForDataSourceOverride(PersistenceUnitDescriptor pud){\r\n    String jtaDataSourceOverride = providerContainerContractInfo.getJTADataSourceOverride();\r\n    if (jtaDataSourceOverride != null) {\r\n        pud.setJtaDataSource(jtaDataSourceOverride);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.CMPBeanHelper.handleJDOObjectNotFoundException",
	"Comment": "called from a cmp bean to process jdoobjectnotfoundexception.logs the message and throws objectnotfoundexception",
	"Method": "void handleJDOObjectNotFoundException(Object primaryKey,String beanName,JDOException ex){\r\n    String msg = // NOI18N\r\n    I18NHelper.getMessage(cmpMessages, \"GEN.findbypk_exception_notfound\", beanName, primaryKey.toString());\r\n    cmpLifecycleLogger.log(Logger.FINER, msg, ex);\r\n    throw new ObjectNotFoundException(msg);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnUtils.iLoad",
	"Comment": "return the best instruction for loading an int from a localvariable slot",
	"Method": "Insn iLoad(int i,ConstantPool pool){\r\n    if (i == 0)\r\n        return Insn.create(opc_iload_0);\r\n    else if (i == 1)\r\n        return Insn.create(opc_iload_1);\r\n    else if (i == 2)\r\n        return Insn.create(opc_iload_2);\r\n    else if (i == 3)\r\n        return Insn.create(opc_iload_3);\r\n    return Insn.create(opc_iload, i);\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.jws.ExtensionFileManager.buildExtensionFileEntries",
	"Comment": "constructs the collection of extension files known to the app server.",
	"Method": "Map<ExtensionKey, Extension> buildExtensionFileEntries(Vector<File> dirs){\r\n    Map<ExtensionKey, Extension> result = new HashMap<ExtensionKey, Extension>();\r\n    for (int i = 0; i < dirs.size(); i++) {\r\n        addExtJarsFromDirectory(result, i, dirs.get(i));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.connector.ActivationSpecNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object obj){\r\n    if (obj instanceof ConnectorConfigProperty) {\r\n        msgListener.addConfigProperty((ConnectorConfigProperty) obj);\r\n    } else if (obj instanceof EnvironmentProperty) {\r\n        msgListener.addRequiredConfigProperty((EnvironmentProperty) obj);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.CreateResourceAdapterConfig.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    HashMap attrList = new HashMap();\r\n    attrList.put(RESOURCE_ADAPTER_CONFIG_NAME, raName);\r\n    attrList.put(THREAD_POOL_IDS, threadPoolIds);\r\n    attrList.put(ServerTags.OBJECT_TYPE, objectType);\r\n    ResourceStatus rs;\r\n    String appName = raName;\r\n    if (!ConnectorsUtil.isStandAloneRA(raName)) {\r\n        appName = ConnectorsUtil.getApplicationNameOfEmbeddedRar(raName);\r\n        Application application = applications.getApplication(appName);\r\n        if (application != null) {\r\n            String resourceAdapterName = ConnectorsUtil.getRarNameFromApplication(raName);\r\n            Module module = application.getModule(resourceAdapterName);\r\n            if (module != null) {\r\n                Resources msr = module.getResources();\r\n                if (msr != null) {\r\n                    if (hasDuplicate(msr, report))\r\n                        return;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        Application application = applications.getApplication(appName);\r\n        if (application != null) {\r\n            Resources appScopedResources = application.getResources();\r\n            if (appScopedResources != null) {\r\n                if (hasDuplicate(appScopedResources, report))\r\n                    return;\r\n            }\r\n        }\r\n    }\r\n    ResourceAdapterConfigManager resAdapterConfigMgr = new ResourceAdapterConfigManager();\r\n    try {\r\n        rs = resAdapterConfigMgr.create(domain.getResources(), attrList, properties, target);\r\n    } catch (Exception ex) {\r\n        Logger.getLogger(CreateResourceAdapterConfig.class.getName()).log(Level.SEVERE, \"Unable to create resource adapter config for \" + raName, ex);\r\n        String def = \"Resource adapter config: {0} could not be created, reason: {1}\";\r\n        report.setMessage(localStrings.getLocalString(\"create.resource.adapter.config.fail\", def, raName) + \" \" + ex.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(ex);\r\n        return;\r\n    }\r\n    ActionReport.ExitCode ec = ActionReport.ExitCode.SUCCESS;\r\n    if (rs.getStatus() == ResourceStatus.FAILURE) {\r\n        ec = ActionReport.ExitCode.FAILURE;\r\n        if (rs.getMessage() != null) {\r\n            report.setMessage(rs.getMessage());\r\n        } else {\r\n            report.setMessage(localStrings.getLocalString(\"create.resource.adapter.config.fail\", \"Resource adapter config {0} creation failed\", raName, \"\"));\r\n        }\r\n        if (rs.getException() != null)\r\n            report.setFailureCause(rs.getException());\r\n    }\r\n    report.setActionExitCode(ec);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.printDescriptor",
	"Comment": "print the current descriptor associated with this archivist",
	"Method": "void printDescriptor(){\r\n    DescriptorVisitor tracerVisitor = getDescriptor().getTracerVisitor();\r\n    if (tracerVisitor == null) {\r\n        tracerVisitor = new TracerVisitor();\r\n    }\r\n    getDescriptor().visit(tracerVisitor);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.meta.JDOMetaDataPropertyImpl.isMutableSecondClassObjectType",
	"Comment": "tests whether a type is known for mutable second class objects.",
	"Method": "boolean isMutableSecondClassObjectType(String classPath){\r\n    return mutableSecondClassObjectTypes.contains(classPath);\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBObjectImpl.getEJBObject",
	"Comment": "get the remote object corresponding to an ejbobjectimpl forthe remotebusiness view.",
	"Method": "java.rmi.Remote getEJBObject(java.rmi.Remote getEJBObject,String generatedBusinessInterface){\r\n    return (java.rmi.Remote) businessEJBObjects.get(generatedBusinessInterface);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsMixedCaseIdentifiers",
	"Comment": "retrieves whether this database treats mixed case unquoted sql identifiers ascase sensitive and as a result stores them in mixed case.",
	"Method": "boolean supportsMixedCaseIdentifiers(){\r\n    return databaseMetaData.supportsMixedCaseIdentifiers();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.EnhancerClassLoader.defineClass",
	"Comment": "defines a class using the class bytes obtained from the specifiedresource. the resulting class must be resolved before it can beused.",
	"Method": "Class defineClass(String name,Resource res){\r\n    int i = name.lastIndexOf('.');\r\n    URL url = res.getCodeSourceURL();\r\n    if (i != -1) {\r\n        String pkgname = name.substring(0, i);\r\n        Package pkg = getPackage(pkgname);\r\n        Manifest man = res.getManifest();\r\n        if (pkg != null) {\r\n            boolean ok;\r\n            if (pkg.isSealed()) {\r\n                ok = pkg.isSealed(url);\r\n            } else {\r\n                ok = (man == null) || !isSealed(pkgname, man);\r\n            }\r\n            if (!ok) {\r\n                throw new SecurityException(\"sealing violation\");\r\n            }\r\n        } else {\r\n            if (man != null) {\r\n                definePackage(pkgname, man, url);\r\n            } else {\r\n                definePackage(pkgname, null, null, null, null, null, null, null);\r\n            }\r\n        }\r\n    }\r\n    byte[] b = res.getBytes();\r\n    Certificate[] certs = res.getCertificates();\r\n    CodeSource cs = new CodeSource(url, certs);\r\n    final String classPath = name.replace('.', '/');\r\n    if (!metaData.isTransientClass(classPath)) {\r\n        b = enhance(name, b, 0, b.length);\r\n    }\r\n    return defineClass(name, b, 0, b.length, cs);\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.servlet.ClientStubsContentSource.cleanUp",
	"Comment": "this method may be used to clean up any temporary resources.it will be invoked after the inputstream has been completely read.",
	"Method": "void cleanUp(DownloadServlet.Context ctx){\r\n    // NOI18N\r\n    InputStream tmpFile = (InputStream) ctx.getAttribute(\"tmpFile\");\r\n    if (tmpFile != null) {\r\n        try {\r\n            tmpFile.close();\r\n        } catch (Exception ex) {\r\n        }\r\n    }\r\n    ctx.removeAttribute(\"tmpFile\");\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createColumnExistenceComponent",
	"Comment": "create a validation component which can check whether the given\tcolumn or column pair exists.",
	"Method": "ValidationComponent createColumnExistenceComponent(String columnName,ValidationComponent createColumnExistenceComponent,String columnName,MappingFieldElement relatedField){\r\n    return new ValidationComponent() {\r\n        public void validate() throws ModelValidationException {\r\n            if (columnName != null) {\r\n                String className = getClassName();\r\n                String absoluteName = NameUtil.getAbsoluteMemberName(getSchemaForClass(className), columnName);\r\n                TableElement table = TableElement.forName(NameUtil.getTableName(absoluteName));\r\n                boolean foundTable = (table != null);\r\n                DBMemberElement columnElement = ((foundTable) ? table.getMember(DBIdentifier.create(absoluteName)) : null);\r\n                boolean noRelated = (relatedField == null);\r\n                if (foundTable) {\r\n                    boolean isRelationship = (!noRelated && isRelationship(relatedField));\r\n                    boolean noColumn = (columnElement == null);\r\n                    if (!isRelationship && noColumn) {\r\n                        Object[] args = (noRelated) ? new Object[] { columnName, className } : new Object[] { columnName, relatedField, className };\r\n                        throw new ModelValidationException(ModelValidationException.WARNING, getOffendingObject(relatedField), I18NHelper.getMessage(getMessages(), getKey(\"util.validation.column_not_found\", relatedField), args));\r\n                    } else if (isRelationship && (noColumn || !isPairComplete(columnElement))) {\r\n                        throw new ModelValidationException(ModelValidationException.WARNING, getOffendingObject(relatedField), // NOI18N\r\n                        I18NHelper.getMessage(getMessages(), \"util.validation.column_invalid\", new Object[] { columnName, relatedField, className }));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        private boolean isPairComplete(DBMemberElement member) {\r\n            return ((member instanceof ColumnPairElement) && (((ColumnPairElement) member).getLocalColumn() != null) && (((ColumnPairElement) member).getReferencedColumn() != null));\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createColumnExistenceComponent",
	"Comment": "create a validation component which can check whether the given\tcolumn or column pair exists.",
	"Method": "ValidationComponent createColumnExistenceComponent(String columnName,ValidationComponent createColumnExistenceComponent,String columnName,MappingFieldElement relatedField){\r\n    if (columnName != null) {\r\n        String className = getClassName();\r\n        String absoluteName = NameUtil.getAbsoluteMemberName(getSchemaForClass(className), columnName);\r\n        TableElement table = TableElement.forName(NameUtil.getTableName(absoluteName));\r\n        boolean foundTable = (table != null);\r\n        DBMemberElement columnElement = ((foundTable) ? table.getMember(DBIdentifier.create(absoluteName)) : null);\r\n        boolean noRelated = (relatedField == null);\r\n        if (foundTable) {\r\n            boolean isRelationship = (!noRelated && isRelationship(relatedField));\r\n            boolean noColumn = (columnElement == null);\r\n            if (!isRelationship && noColumn) {\r\n                Object[] args = (noRelated) ? new Object[] { columnName, className } : new Object[] { columnName, relatedField, className };\r\n                throw new ModelValidationException(ModelValidationException.WARNING, getOffendingObject(relatedField), I18NHelper.getMessage(getMessages(), getKey(\"util.validation.column_not_found\", relatedField), args));\r\n            } else if (isRelationship && (noColumn || !isPairComplete(columnElement))) {\r\n                throw new ModelValidationException(ModelValidationException.WARNING, getOffendingObject(relatedField), // NOI18N\r\n                I18NHelper.getMessage(getMessages(), \"util.validation.column_invalid\", new Object[] { columnName, relatedField, className }));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createColumnExistenceComponent",
	"Comment": "create a validation component which can check whether the given\tcolumn or column pair exists.",
	"Method": "ValidationComponent createColumnExistenceComponent(String columnName,ValidationComponent createColumnExistenceComponent,String columnName,MappingFieldElement relatedField){\r\n    return ((member instanceof ColumnPairElement) && (((ColumnPairElement) member).getLocalColumn() != null) && (((ColumnPairElement) member).getReferencedColumn() != null));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.removeDependency",
	"Comment": "decrements the reference count and marks this instanceas updateable, if the reference count is zero.",
	"Method": "void removeDependency(){\r\n    if (--referenceCount == 0) {\r\n        stateFlags &= ~ST_UPDATE_DISABLED;\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxConnections",
	"Comment": "retrieves the maximum number of concurrent connections to thisdatabase that are possible.",
	"Method": "int getMaxConnections(){\r\n    return databaseMetaData.getMaxConnections();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.FieldAction.setMethod",
	"Comment": "return the name of the static method on class genericobject whichwill set the field value.",
	"Method": "String setMethod(){\r\n    return fieldTypeInfo.fieldSetMethod;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.processAnnotations",
	"Comment": "process annotations in a bundle descriptor, the annoation processingis dependent on the type of descriptor being passed.",
	"Method": "ProcessingResult processAnnotations(T bundleDesc,ReadableArchive archive,ProcessingResult processAnnotations,RootDeploymentDescriptor bundleDesc,ModuleScanner scanner,ReadableArchive archive){\r\n    if (scanner == null) {\r\n        return null;\r\n    }\r\n    AnnotatedElementHandler aeHandler = AnnotatedElementHandlerFactory.createAnnotatedElementHandler(bundleDesc);\r\n    if (aeHandler == null) {\r\n        return null;\r\n    }\r\n    Parser parser = null;\r\n    if (archive.getParentArchive() != null) {\r\n        parser = archive.getParentArchive().getExtraData(Parser.class);\r\n    } else {\r\n        parser = archive.getExtraData(Parser.class);\r\n    }\r\n    scanner.process(archive, bundleDesc, classLoader, parser);\r\n    if (!scanner.getElements().isEmpty()) {\r\n        if (((BundleDescriptor) bundleDesc).isDDWithNoAnnotationAllowed()) {\r\n            String ddName = getStandardDDFile().getDeploymentDescriptorPath();\r\n            String explodedArchiveName = new File(archive.getURI()).getName();\r\n            String archiveName = FileUtils.revertFriendlyFilenameExtension(explodedArchiveName);\r\n            throw new AnnotationProcessorException(localStrings.getLocalString(\"enterprise.deployment.oldDDwithAnnotation\", \"{0} in archive {1} is of version {2}, which cannot support annotations in an application.  Please upgrade the deployment descriptor to be a version supported by Java EE 5.0 (or later).\", new Object[] { ddName, archiveName, bundleDesc.getSpecVersion() }));\r\n        }\r\n        boolean isFullAttribute = false;\r\n        if (bundleDesc instanceof BundleDescriptor) {\r\n            isFullAttribute = ((BundleDescriptor) bundleDesc).isFullAttribute();\r\n        }\r\n        AnnotationProcessor ap = annotationFactory.getAnnotationProcessor(isFullAttribute);\r\n        ProcessingContext ctx = ap.createContext();\r\n        ctx.setArchive(archive);\r\n        if (annotationErrorHandler != null) {\r\n            ctx.setErrorHandler(annotationErrorHandler);\r\n        }\r\n        ctx.setProcessingInput(scanner);\r\n        ctx.pushHandler(aeHandler);\r\n        ClassLoader originalBundleClassLoader = null;\r\n        try {\r\n            originalBundleClassLoader = bundleDesc.getClassLoader();\r\n        } catch (Exception e) {\r\n        }\r\n        if (originalBundleClassLoader == null) {\r\n            bundleDesc.setClassLoader(classLoader);\r\n        }\r\n        try {\r\n            return ap.process(ctx);\r\n        } finally {\r\n            if (originalBundleClassLoader == null) {\r\n                bundleDesc.setClassLoader(null);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.MappingFile.isCascadeDelete",
	"Comment": "returns the cascade delete setting for the current relationship side.the conversionhelper interface provides cascade delete informationfor the related side only.",
	"Method": "boolean isCascadeDelete(String beanName,String fieldName){\r\n    final String beanInField = helper.getRelationshipFieldContent(beanName, fieldName);\r\n    final String inverseField = helper.getInverseFieldName(beanName, fieldName);\r\n    return (null != beanInField && null != inverseField) ? helper.relatedObjectsAreDeleted(beanInField, inverseField) : false;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.listener.LocalTxConnectionEventListener.badConnectionClosed",
	"Comment": "resource adapters will signal that the connection being closed is bad.",
	"Method": "void badConnectionClosed(ConnectionEvent evt){\r\n    Object connectionHandle = evt.getConnectionHandle();\r\n    ResourceHandle handle = resource;\r\n    if (associatedHandles.containsKey(connectionHandle)) {\r\n        handle = (ResourceHandle) associatedHandles.get(connectionHandle);\r\n    }\r\n    ManagedConnection mc = (ManagedConnection) evt.getSource();\r\n    mc.removeConnectionEventListener(this);\r\n    poolMgr.badResourceClosed(handle);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.isCatalogAtStart",
	"Comment": "retrieves whether a catalog appears at the start of a fully qualifiedtable name.if not, the catalog appears at the end.",
	"Method": "boolean isCatalogAtStart(){\r\n    return databaseMetaData.isCatalogAtStart();\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.Java2DBProcessorHelper.setGeneratedLocation",
	"Comment": "sets the substitute for the internal location of the generated files",
	"Method": "void setGeneratedLocation(String generatedLocation,String bundleName){\r\n    deploymentContextProps.setProperty(JDBC_FILE_LOCATION + bundleName, generatedLocation);\r\n    if (logger.isLoggable(Level.FINE)) {\r\n        logger.fine(\"---> \" + JDBC_FILE_LOCATION + bundleName + \" \" + generatedLocation);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.setBigDecimal",
	"Comment": "sets the designated parameter to the givenjava.math.bigdecimal value.the driver converts this to an sql numeric value whenit sends it to the database.",
	"Method": "void setBigDecimal(String parameterName,BigDecimal x){\r\n    callableStatement.setBigDecimal(parameterName, x);\r\n}"
}, {
	"Path": "org.glassfish.javaee.core.deployment.DolProvider.processDeploymentMetaData",
	"Comment": "this method populates the application object from a readablearchive",
	"Method": "Application processDeploymentMetaData(ReadableArchive archive){\r\n    FileArchive expandedArchive = null;\r\n    File tmpFile = null;\r\n    ExtendedDeploymentContext context = null;\r\n    Logger logger = Logger.getAnonymousLogger();\r\n    ClassLoader cl = null;\r\n    try {\r\n        String archiveName = Util.getURIName(archive.getURI());\r\n        ArchiveHandler archiveHandler = deployment.getArchiveHandler(archive);\r\n        if (archiveHandler == null) {\r\n            throw new IllegalArgumentException(localStrings.getLocalString(\"deploy.unknownarchivetype\", \"Archive type of {0} was not recognized\", archiveName));\r\n        }\r\n        DeployCommandParameters parameters = new DeployCommandParameters(new File(archive.getURI()));\r\n        ActionReport report = new HTMLActionReporter();\r\n        context = new DeploymentContextImpl(report, archive, parameters, env);\r\n        context.setArchiveHandler(archiveHandler);\r\n        String appName = archiveHandler.getDefaultApplicationName(archive, context);\r\n        parameters.name = appName;\r\n        if (archive instanceof InputJarArchive) {\r\n            tmpFile = File.createTempFile(archiveName, \"\");\r\n            String path = tmpFile.getAbsolutePath();\r\n            if (!tmpFile.delete()) {\r\n                logger.log(Level.WARNING, \"cannot.delete.temp.file\", new Object[] { path });\r\n            }\r\n            File tmpDir = new File(path);\r\n            tmpDir.deleteOnExit();\r\n            if (!tmpDir.exists() && !tmpDir.mkdirs()) {\r\n                throw new IOException(\"Unable to create directory \" + tmpDir.getAbsolutePath());\r\n            }\r\n            expandedArchive = (FileArchive) archiveFactory.createArchive(tmpDir);\r\n            archiveHandler.expand(archive, expandedArchive, context);\r\n            context.setSource(expandedArchive);\r\n        }\r\n        context.setPhase(DeploymentContextImpl.Phase.PREPARE);\r\n        ClassLoaderHierarchy clh = clhProvider.get();\r\n        context.createDeploymentClassLoader(clh, archiveHandler);\r\n        cl = context.getClassLoader();\r\n        deployment.getDeployableTypes(context);\r\n        deployment.getSniffers(archiveHandler, null, context);\r\n        return processDOL(context);\r\n    } finally {\r\n        if (cl != null && cl instanceof PreDestroy) {\r\n            try {\r\n                PreDestroy.class.cast(cl).preDestroy();\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        if (context != null) {\r\n            context.postDeployClean(true);\r\n        }\r\n        if (expandedArchive != null) {\r\n            try {\r\n                expandedArchive.close();\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n        if (tmpFile != null && tmpFile.exists()) {\r\n            try {\r\n                FileUtils.whack(tmpFile);\r\n            } catch (Exception e) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.assertActiveTransaction",
	"Comment": "assert that the associated transaction is active but allows to do commit processing.",
	"Method": "void assertActiveTransaction(boolean insideQuery){\r\n    boolean debug = false;\r\n    debug = logger.isLoggable(Logger.FINEST);\r\n    if (debug) {\r\n        logger.finest(\"sqlstore.persistencemgr.assertactivetx\", _transaction);\r\n    }\r\n    if (_insideCommit || (insideQuery && _transaction.getNontransactionalRead()))\r\n        return;\r\n    if (!_activeTransaction) {\r\n        if (debug) {\r\n            logger.finest(\"sqlstore.persistencemgr.assertactivetx.closed\", this);\r\n        }\r\n        throw new JDOException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerimpl.assertactivetransaction.error\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jaspic.config.factory.RegStoreFileParser.checkAndAddToList",
	"Comment": "if this entry does not exist, this method stores it inthe entries list and returns true to indicate that theconfiguration file should be written.",
	"Method": "boolean checkAndAddToList(String className,RegistrationContext ctx,Map props){\r\n    if (props != null && props.isEmpty()) {\r\n        props = null;\r\n    }\r\n    EntryInfo newEntry = new EntryInfo(className, props, ctx);\r\n    EntryInfo entry = getMatchingRegEntry(newEntry);\r\n    if (entry == null) {\r\n        entries.add(newEntry);\r\n        return true;\r\n    }\r\n    if (entry.getRegContexts().contains(ctx)) {\r\n        return false;\r\n    }\r\n    entry.getRegContexts().add(new RegistrationContextImpl(ctx));\r\n    return true;\r\n}"
}, {
	"Path": "org.glassfish.ejb.persistent.timer.PersistentEJBTimerService.getTimerIds",
	"Comment": "return the ids of active timers owned by ejbs.primary key of entity bean is unnecessary because all of the activetimers are expected",
	"Method": "Collection<TimerPrimaryKey> getTimerIds(long containerId,Object timedObjectPrimaryKey,Collection<TimerPrimaryKey> getTimerIds,Collection<Long> containerIds){\r\n    Collection<TimerPrimaryKey> timerIds = new HashSet<TimerPrimaryKey>(super.getTimerIds(containerIds));\r\n    timerIds.addAll(timerLocal_.findActiveTimerIdsByContainers(containerIds));\r\n    return timerIds;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.ConnectionFactoryImpl.initialize",
	"Comment": "internal\tattempts to create new connectionmanagerthrows jdofatalexception",
	"Method": "void initialize(){\r\n    if (connectionManager != null)\r\n        return;\r\n    try {\r\n        assertConnectionWait();\r\n        connectionManager = new ConnectionManager(driverName, URL, userName, password, minPool, maxPool);\r\n        connectionManager.setMsWait(this.msWait);\r\n        connectionManager.setMsInterval(this.msInterval);\r\n        connectionManager.setLoginTimeout(this.loginTimeout);\r\n        if (_txIsolation > 0)\r\n            setTransactionIsolation(_txIsolation);\r\n        else\r\n            _txIsolation = getTransactionIsolation();\r\n        this.configured(true);\r\n    } catch (JDOException e) {\r\n        throw e;\r\n    } catch (Exception e) {\r\n        throw new JDOFatalException(null, e);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.jws.servedcontent.CachingDynamicContentImpl.toString",
	"Comment": "returns a string representation of the cachingdynamiccontentimpl.",
	"Method": "String toString(){\r\n    return super.toString() + \", template=\" + template + \", MIME type=\" + mimeType;\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.NestedAppClientDeployerHelper.addJar",
	"Comment": "adds a jar to the download set for the app, adjusting the accumulatedclasspath for the facade in the process.",
	"Method": "void addJar(StringBuilder cpForFacade,StringBuilder puScanTargets,URI jarURI,Set<URI> dependencyURIsProcessed){\r\n    final URI jarURIForFacade = relativeToFacade(jarURI);\r\n    final URI jarURIForAnchor = earURI.relativize(jarURI);\r\n    final URI fileURIForJAR = URI.create(\"file:\" + jarURI.getRawSchemeSpecificPart());\r\n    if (dependencyURIsProcessed.contains(fileURIForJAR)) {\r\n        return;\r\n    }\r\n    if (cpForFacade.length() > 0) {\r\n        cpForFacade.append(' ');\r\n    }\r\n    cpForFacade.append(jarURIForFacade.toASCIIString());\r\n    if (puScanTargets != null) {\r\n        if (puScanTargets.length() > 0) {\r\n            puScanTargets.append(' ');\r\n        }\r\n        puScanTargets.append(jarURIForFacade.toASCIIString());\r\n    }\r\n    final Artifact jarArtifact = newArtifact(earURI, jarURIForAnchor);\r\n    if (jarArtifact != null) {\r\n        jarArtifact.processArtifact(dependencyURIsProcessed, earLevelDownloads(), earLevelDownloads());\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployapi.SunDeploymentManager.getTargets",
	"Comment": "retrieve the list of deployment targets supported bythis deploymentmanager.",
	"Method": "Target[] getTargets(){\r\n    verifyConnected();\r\n    try {\r\n        return deploymentFacility.listTargets();\r\n    } catch (Throwable e) {\r\n        IllegalStateException ex = new IllegalStateException(e.getMessage());\r\n        ex.initCause(e);\r\n        throw ex;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.backup.BackupFilenameManager.findZips",
	"Comment": "looks through the backups directory and assemblesa list of all backup files found.",
	"Method": "void findZips(){\r\n    File[] zips = dir.listFiles(new ZipFilenameFilter());\r\n    for (int i = 0; (zips != null) && (i < zips.length); i++) {\r\n        ZipFileAndNumber zfan = new ZipFileAndNumber(zips[i]);\r\n        zipFiles.put(zfan.num, zfan);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.getMessageDestinationReferenceByName",
	"Comment": "looks up an message destination reference with the given name.throws an illegalargumentexception if it is not found.",
	"Method": "MessageDestinationReferenceDescriptor getMessageDestinationReferenceByName(String name){\r\n    for (MessageDestinationReferenceDescriptor mdr : messageDestReferences) {\r\n        if (mdr.getName().equals(name)) {\r\n            return mdr;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"exceptionapphasnomsgdestrefbyname\", \"This app [{0}] has no message destination reference by the name of [{1}]\", new Object[] { getRegistrationName(), name }));\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceClassElementImpl.getFieldCollection",
	"Comment": "returns the field collection of this class element.this method \tshould only be used internally and for cloning and archiving.",
	"Method": "PersistenceElementCollection getFieldCollection(){\r\n    return _fields;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.logging.AbstractLoggerFactory.getLogger",
	"Comment": "get a logger.the class that implements this interface is responsible\tfor creating a logger for the named component.\tthe bundle name and class loader are passed to allow the implementation\tto properly find and construct the internationalization bundle.",
	"Method": "Logger getLogger(String relativeLoggerName,String bundleName,ClassLoader loader){\r\n    String absoluteLoggerName = getAbsoluteLoggerName(relativeLoggerName);\r\n    Logger value = (Logger) _loggerCache.get(absoluteLoggerName);\r\n    if (value == null) {\r\n        value = createLogger(absoluteLoggerName, bundleName, loader);\r\n        if (value != null)\r\n            _loggerCache.put(absoluteLoggerName, value);\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingReferenceKeyElementImpl.getColumnPairNames",
	"Comment": "returns the list of relative column pair names in this referencing key.",
	"Method": "ArrayList getColumnPairNames(){\r\n    ArrayList locals = getReferencingKey();\r\n    ArrayList foreigns = getTable().getKey();\r\n    int i, count = ((locals != null) ? locals.size() : 0);\r\n    ArrayList pairs = new ArrayList();\r\n    for (// NOI18N\r\n    i = 0; // NOI18N\r\n    i < count; i++) pairs.add(locals.get(i) + \";\" + foreigns.get(i));\r\n    return pairs;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.handlers.ResourceHandler.getResourceReferenceDescriptors",
	"Comment": "return resourcereferencedescriptors with given name if exists or a newone without name being set.",
	"Method": "ResourceReferenceDescriptor[] getResourceReferenceDescriptors(String logicalName,ResourceContainerContext[] rcContexts){\r\n    ResourceReferenceDescriptor[] resourceRefs = new ResourceReferenceDescriptor[rcContexts.length];\r\n    for (int i = 0; i < rcContexts.length; i++) {\r\n        ResourceReferenceDescriptor resourceRef = rcContexts[i].getResourceReference(logicalName);\r\n        if (resourceRef == null) {\r\n            resourceRef = new ResourceReferenceDescriptor();\r\n            rcContexts[i].addResourceReferenceDescriptor(resourceRef);\r\n        }\r\n        resourceRefs[i] = resourceRef;\r\n    }\r\n    return resourceRefs;\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.ListAdminObjects.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        ArrayList<String> list = new ArrayList<String>();\r\n        Collection<AdminObjectResource> adminObjects = domain.getResources().getResources(AdminObjectResource.class);\r\n        for (AdminObjectResource r : adminObjects) {\r\n            if (bindableResourcesHelper.resourceExists(r.getJndiName(), target)) {\r\n                list.add(r.getJndiName());\r\n            }\r\n        }\r\n        for (String jndiName : list) {\r\n            final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n            part.setMessage(jndiName);\r\n        }\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.admin.object.fail\", \"Unable to list administered objects\") + \" \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.TransactionImpl.toString",
	"Comment": "returns a string representation of this transaction object.",
	"Method": "String toString(){\r\n    int i;\r\n    Object o;\r\n    // NOI18N\r\n    String s = \"  Transaction: \\n   status        = \" + this.statusString(this.status) + \"\\n\" + \"   Transaction Object       = Transaction@\" + this.hashCode() + \"\\n\" + \"   threads       = \" + this.threads + \"\\n\";\r\n    if (this.timeout != 0)\r\n        s = s + \"   timeout       = \" + this.timeout + \"\\n\";\r\n    if (this.startedCommit)\r\n        s = s + \"   startedCommit = true\\n\";\r\n    if (this.onePhase)\r\n        s = s + \"   onePhase      = true\\n\";\r\n    if (synchronization != null) {\r\n        s = s + \"sync:     \" + synchronization + \"\\n\";\r\n    }\r\n    if (!this.resources.isEmpty()) {\r\n        s = s + \"   # resources   = \" + this.resources.size() + \"\\n\";\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.StatelessSessionContainer._getContext",
	"Comment": "called from preinvoke which is called from the ejbobject for local and remote invocations.",
	"Method": "ComponentContext _getContext(EjbInvocation inv){\r\n    try {\r\n        SessionContextImpl sessionCtx = (SessionContextImpl) pool.getObject(null);\r\n        sessionCtx.setState(EJBContextImpl.BeanState.INVOKING);\r\n        return sessionCtx;\r\n    } catch (Exception ex) {\r\n        throw new EJBException(ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.rowInserted",
	"Comment": "retrieves whether the current row has had an insertion.the value returned depends on whether or not thisresultset object can detect visible inserts.",
	"Method": "boolean rowInserted(){\r\n    return resultSet.rowInserted();\r\n}"
}, {
	"Path": "org.glassfish.resources.connector.ResourcesSniffer.getDeploymentConfigurationPaths",
	"Comment": "returns the descriptor paths that might exist in a connector app.",
	"Method": "List<String> getDeploymentConfigurationPaths(){\r\n    return deploymentConfigurationPaths;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.ResourceAdapterConfigParserImpl.getJavaBeanProps",
	"Comment": "parses the ra.xml for the resource adapter javabean properties.here the second parameter connectiondefname is not used and canbe null or any value.it throws connectorruntimeexception if module dir is null orcorresponing rar is not deployed i.e invalid moduledir parameter.",
	"Method": "Properties getJavaBeanProps(ConnectorDescriptor desc,String connectionDefName,String rarName){\r\n    if (desc == null) {\r\n        throw new ConnectorRuntimeException(\"Invalid arguments\");\r\n    }\r\n    Set ddVals = desc.getConfigProperties();\r\n    Properties mergedVals = null;\r\n    String className = desc.getResourceAdapterClass();\r\n    Properties introspectedVals = null;\r\n    if (className != null && className.length() != 0) {\r\n        introspectedVals = configParserUtil.introspectJavaBean(className, ddVals, false, rarName);\r\n        mergedVals = configParserUtil.mergeProps(ddVals, introspectedVals);\r\n    }\r\n    return mergedVals;\r\n}"
}, {
	"Path": "com.sun.ejb.base.stats.StatefulSessionStoreStatsImpl.getPassivatedBeanSize",
	"Comment": "returns the total number of bytes passivated by this store including total, min, maximum",
	"Method": "AverageRangeStatistic getPassivatedBeanSize(){\r\n    synchronized (passivationSizeLock) {\r\n        return (AverageRangeStatistic) passivationSize.unmodifiableView();\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getActualConnection",
	"Comment": "returns the actual connection that produced this metadata object",
	"Method": "Connection getActualConnection(){\r\n    return databaseMetaData.getConnection();\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnection.connectionErrorOccurred",
	"Comment": "this method is called by the connectionholder when it detects a connecionrelated error.",
	"Method": "void connectionErrorOccurred(Exception e,com.sun.jdbcra.spi.ConnectionHolder connHolderObject){\r\n    ConnectionEventListener cel = this.listener;\r\n    ConnectionEvent ce = null;\r\n    ce = e == null ? new ConnectionEvent(this, ConnectionEvent.CONNECTION_ERROR_OCCURRED) : new ConnectionEvent(this, ConnectionEvent.CONNECTION_ERROR_OCCURRED, e);\r\n    if (connHolderObject != null) {\r\n        ce.setConnectionHandle(connHolderObject);\r\n    }\r\n    cel.connectionErrorOccurred(ce);\r\n    isUsable = false;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.web.integration.WebSecurityManager.setSecurityInfo",
	"Comment": "this is an private method for policy context handler data info",
	"Method": "void setSecurityInfo(HttpServletRequest httpRequest){\r\n    if (httpRequest != null) {\r\n        wsmf.pcHandlerImpl.getHandlerData().setHttpServletRequest(httpRequest);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.scope.SymbolTable.getDefinition",
	"Comment": "checks the symbol table for the actual definition of the specified identifier. if the identifier is declared the definition is returned, otherwise null.",
	"Method": "Definition getDefinition(String ident){\r\n    return (Definition) symbols.get(ident);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.SunContainerHelper.getEJBObject",
	"Comment": "get an ejbobject reference for this primary key and container helper.this is suncontainerhelper specific code.",
	"Method": "EJBObject getEJBObject(Object pk,Object container){\r\n    try {\r\n        return ((Container) container).getEJBObjectForPrimaryKey(pk);\r\n    } catch (Exception ex) {\r\n        throw new JDOFatalInternalException(ex.getMessage(), ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.CSIV2TaggedComponentInfo.createSSLInfo",
	"Comment": "create the ssl tagged component within a compound mechanismdefinition.",
	"Method": "org.omg.IOP.TaggedComponent createSSLInfo(int sslport,EjbIORConfigurationDescriptor iorDesc,boolean sslRequired,org.omg.IOP.TaggedComponent createSSLInfo,List<SocketInfo> socketInfos,EjbIORConfigurationDescriptor iorDesc,boolean sslRequired){\r\n    int targetSupports = getTargetSupportsDefault(iorDesc);\r\n    int targetRequires = getTargetRequiresDefault(iorDesc, sslRequired);\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"IIOP: Creating Transport Mechanism for socketInfos \" + socketInfos);\r\n    }\r\n    if ((targetSupports | targetRequires) == 0) {\r\n        return NULL_TAGGED_COMPONENT;\r\n    }\r\n    TransportAddress[] listTa = generateTransportAddresses(socketInfos);\r\n    return createTlsSecTransComponent(targetSupports, targetRequires, listTa);\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ConnectionHolder.getTypeMap",
	"Comment": "retrieves the map object associated withconnection object.",
	"Method": "Map getTypeMap(){\r\n    checkValidity();\r\n    return con.getTypeMap();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.inbound.ConnectorMessageBeanClient.close",
	"Comment": "does endpoint deactivation with the resource adapter.also remove sthe messageendpointfactoryinfofrom house keeping.",
	"Method": "void close(){\r\n    logger.logp(Level.FINEST, \"ConnectorMessageBeanClient\", \"close\", \"called...\");\r\n    started_ = false;\r\n    String resourceAdapterMid = null;\r\n    try {\r\n        resourceAdapterMid = getResourceAdapterMid(descriptor_);\r\n    } catch (ConnectorRuntimeException e) {\r\n        String message = localStrings.getString(\"msg-bean-client.could-not-derive-ra-mid\", descriptor_.getName());\r\n        logger.log(Level.WARNING, message, e);\r\n    }\r\n    ActiveResourceAdapter activeRar = registry_.getActiveResourceAdapter(resourceAdapterMid);\r\n    if (activeRar instanceof ActiveInboundResourceAdapter) {\r\n        ActiveInboundResourceAdapter rar = (ActiveInboundResourceAdapter) activeRar;\r\n        MessageEndpointFactoryInfo info = rar.getEndpointFactoryInfo(beanID_);\r\n        if (info != null) {\r\n            rar.getResourceAdapter().endpointDeactivation(info.getEndpointFactory(), info.getActivationSpec());\r\n            rar.removeEndpointFactoryInfo(beanID_);\r\n        } else {\r\n            logger.log(Level.FINE, \"Not de-activating the end point, since it is not activated\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.EjbIORConfigurationDescriptor.setIntegrity",
	"Comment": "set the value of the integrity element to the specified value.",
	"Method": "void setIntegrity(String val){\r\n    if (!val.equalsIgnoreCase(NONE) && !val.equalsIgnoreCase(SUPPORTED) && !val.equalsIgnoreCase(REQUIRED)) {\r\n        throw new RuntimeException(\"Incorrect value for integrity:\" + val);\r\n    }\r\n    integrity = val;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStoreManager.executeUpdateBatch",
	"Comment": "binds the specified update descriptor to the specified statement andcalls method addbatch on this statement.",
	"Method": "void executeUpdateBatch(Transaction tran,Connection conn,UpdateStatement updateStatement,UpdateObjectDescImpl updateDesc,boolean doFlush){\r\n    int[] affectedRows = null;\r\n    boolean debug = logger.isLoggable();\r\n    if (debug) {\r\n        logger.fine(\"sqlstore.sqlstoremanager.executeupdatebatch\");\r\n    }\r\n    String sqlText = updateStatement.getText();\r\n    if (sqlText.length() > 0) {\r\n        if (sqlLogger.isLoggable()) {\r\n            String formattedText = updateStatement.getFormattedSQLText(updateDesc);\r\n            if (doFlush) {\r\n                sqlLogger.fine(\"sqlstore.sqlstoremanager.executeupdatebatch.flushbatch\", formattedText);\r\n            } else {\r\n                sqlLogger.fine(\"sqlstore.sqlstoremanager.executeupdatebatch.addbatch\", formattedText);\r\n            }\r\n        }\r\n        DBStatement s = null;\r\n        try {\r\n            s = updateStatement.getDBStatement(tran, conn);\r\n            updateStatement.bindInputColumns(s, updateDesc);\r\n            s.addBatch();\r\n            if (doFlush) {\r\n                affectedRows = s.executeBatch();\r\n                for (int i = 0; i < affectedRows.length; i++) {\r\n                    if (affectedRows[i] < updateStatement.minAffectedRows && affectedRows[i] != java.sql.Statement.SUCCESS_NO_INFO) {\r\n                        rollbackXact(tran);\r\n                        throwJDOConcurrentAccessException(sqlText);\r\n                    }\r\n                }\r\n            }\r\n        } catch (SQLException e) {\r\n            rollbackXact(tran);\r\n            throwJDOSqlException(e, sqlText);\r\n        }\r\n    }\r\n    if (debug) {\r\n        if (doFlush) {\r\n            // NOI18N\r\n            logger.fine(\"sqlstore.sqlstoremanager.executeupdatebatch.exit.flush\", '[' + StringHelper.intArrayToSeparatedList(affectedRows, \",\") + ']');\r\n        } else {\r\n            logger.fine(\"sqlstore.sqlstoremanager.executeupdatebatch.exit\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.EjbInvocation.getMethodInterface",
	"Comment": "this method returns the method interface constant for this ejbinvocation.",
	"Method": "String getMethodInterface(){\r\n    if (isWebService) {\r\n        return MethodDescriptor.EJB_WEB_SERVICE;\r\n    } else if (isMessageDriven) {\r\n        return MethodDescriptor.EJB_BEAN;\r\n    } else if (isLocal) {\r\n        return (isHome) ? MethodDescriptor.EJB_LOCALHOME : MethodDescriptor.EJB_LOCAL;\r\n    } else {\r\n        return (isHome) ? MethodDescriptor.EJB_HOME : MethodDescriptor.EJB_REMOTE;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.MappingPolicy.getOverrideForPrecision",
	"Comment": "provides a string that can be recognized as a policy to override thedefault precision of a field.",
	"Method": "String getOverrideForPrecision(String className,String fieldName){\r\n    return className + DOT + fieldName + DOT + DatabaseGenerationConstants.INDICATOR_JDBC_PRECISION;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ConnectionHolder.wrapped",
	"Comment": "sets the flag to indicate that, the connection is wrapped already or not.",
	"Method": "void wrapped(boolean wrapFlag){\r\n    this.wrappedAlready = wrapFlag;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.MappingFile.getTableElement",
	"Comment": "looks up the table element for tablename in thetable element cache knowntables. if the tableelement is not found, the table name is looked up in thedatabase schema and registered in the cache.",
	"Method": "TableElement getTableElement(String tableName,Map knownTables,SchemaElement schema,TableElement getTableElement,SchemaElement schema,DBIdentifier dbId,ConversionHelper helper){\r\n    TableElement retVal = ((schema != null) ? schema.getTable(dbId) : null);\r\n    if (null == retVal && !helper.ensureValidation()) {\r\n        retVal = new TableElement();\r\n        retVal.setName(dbId);\r\n        retVal.setDeclaringSchema(schema);\r\n        org.netbeans.modules.dbschema.UniqueKeyElement tkey = new org.netbeans.modules.dbschema.UniqueKeyElement();\r\n        ColumnElement fakeKeyCol = new ColumnElement();\r\n        fakeKeyCol.setName(DBIdentifier.create(retVal.getName().getName() + \".\" + \"fookeyng\"));\r\n        fakeKeyCol.setType(2);\r\n        fakeKeyCol.setPrecision(new Integer(MINIMUM_PRECISION));\r\n        tkey.setPrimaryKey(true);\r\n        tkey.addColumn(fakeKeyCol);\r\n        retVal.addColumn(fakeKeyCol);\r\n        retVal.addKey(tkey);\r\n    }\r\n    if (retVal == null) {\r\n        throw new ConversionException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"ERR_INVALID_TABLE\", new Object[] { dbId.getName(), schema }));\r\n    }\r\n    return retVal;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.JmsHostWrapper.setHost",
	"Comment": "sets the value of the host property.ip v6 or v4 address or hostname",
	"Method": "void setHost(String value){\r\n    host = value;\r\n}"
}, {
	"Path": "org.glassfish.ejb.embedded.EJBContainerImpl.deploy",
	"Comment": "construct new ejbcontainerimpl instance and deploy found modules.",
	"Method": "void deploy(Map<?, ?> properties,Set<DeploymentElement> modules){\r\n    try {\r\n        String appName = (properties == null) ? null : (String) properties.get(EJBContainer.APP_NAME);\r\n        res_app = DeploymentElement.getOrCreateApplication(modules, appName);\r\n        Object app = res_app.getApplication();\r\n        if (app == null) {\r\n            throw new EJBException(\"Invalid set of modules to deploy - see log for details\");\r\n        }\r\n        if (_logger.isLoggable(Level.INFO)) {\r\n            _logger.info(\"[EJBContainerImpl] Deploying app: \" + app);\r\n        }\r\n        appName = res_app.getAppName();\r\n        String[] params;\r\n        if (appName != null) {\r\n            params = new String[] { \"--name\", appName };\r\n        } else {\r\n            params = new String[] {};\r\n        }\r\n        _logger.info(\"[EJBContainerImpl] GlassFish status: \" + server.getStatus());\r\n        if (app instanceof ScatteredArchive) {\r\n            _logger.info(\"[EJBContainerImpl] Deploying as a ScatteredArchive\");\r\n            deployedAppName = deployer.deploy(((ScatteredArchive) app).toURI(), params);\r\n        } else {\r\n            _logger.info(\"[EJBContainerImpl] Deploying as a File\");\r\n            deployedAppName = deployer.deploy((File) app, params);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new EJBException(\"Failed to deploy EJB modules\", e);\r\n    }\r\n    if (deployedAppName == null) {\r\n        throw new EJBException(\"Failed to deploy EJB modules - see log for details\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.getRelatedClassValidationList",
	"Comment": "computes and returns a collection of validationcomponents \trepresenting the related class tests to be performed.right now, \tthese are only included as part of full validation, as they may \tbe somewhat time intensive since they compute information about \tother classes as well as this class.",
	"Method": "Collection getRelatedClassValidationList(PersistenceFieldElement field){\r\n    String relatedClass = getRelatedClass(field);\r\n    ArrayList list = new ArrayList();\r\n    if ((relatedClass != null) && getModel().hasField(getClassName(), field.getName())) {\r\n        MappingClassElement relatedClassElement = getMappingClass(relatedClass);\r\n        list.add(createClassExistenceComponent(relatedClass, field));\r\n        list.add(createClassPersistenceComponent(relatedClass, field));\r\n        list.add(createSchemaExistenceComponent(relatedClass, field));\r\n        list.add(createRelatedSchemaMatchesComponent(relatedClass, field));\r\n        if (relatedClassElement != null) {\r\n            ArrayList tables = relatedClassElement.getTables();\r\n            MappingTableElement primaryTable = null;\r\n            boolean hasTables = ((tables != null) && (tables.size() > 0));\r\n            if (hasTables) {\r\n                primaryTable = (MappingTableElement) tables.get(0);\r\n                list.add(createTableExistenceComponent(primaryTable.getTable(), field));\r\n            }\r\n            if (isRelationship(field)) {\r\n                RelationshipElement relElement = (RelationshipElement) field;\r\n                Object rel = getMappingClass(getClassName()).getField(field.getName());\r\n                list.add(createInverseFieldComponent(relElement));\r\n                list.add(createInverseMappingComponent(relElement));\r\n                if ((rel != null) && isRelationship(rel)) {\r\n                    MappingRelationshipElement relationship = (MappingRelationshipElement) rel;\r\n                    ArrayList columns = relationship.getAssociatedColumns();\r\n                    Iterator iterator = null;\r\n                    if ((columns == null) || (columns.size() == 0))\r\n                        columns = relationship.getColumns();\r\n                    if (columns != null) {\r\n                        List tableNames = new ArrayList();\r\n                        if (hasTables) {\r\n                            Iterator tableIterator = tables.iterator();\r\n                            while (tableIterator.hasNext()) {\r\n                                tableNames.add(((MappingTableElement) tableIterator.next()).getName());\r\n                            }\r\n                        }\r\n                        iterator = columns.iterator();\r\n                        while (iterator.hasNext()) {\r\n                            list.add(createRelatedTableMatchesComponent(relatedClass, field, tableNames, (String) iterator.next()));\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.nullsAreSortedHigh",
	"Comment": "retrieves whether null values are sorted high.sorted high means that null valuessort higher than any other value in a domain.in an ascending order,if this method returns true,null valueswill appear at the end. by contrast, the methodnullsaresortedatend indicates whether null valuesare sorted at the end regardless of sort order.",
	"Method": "boolean nullsAreSortedHigh(){\r\n    return databaseMetaData.nullsAreSortedHigh();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.AbstractMethodHelper.getMethodNames",
	"Comment": "gets a map of the method names for this bean.the keys are the \tmethod names and the values are the java.lang.reflect.method objects.\tthese should represent all methods of this bean.",
	"Method": "Map getMethodNames(){\r\n    return methodNames;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.Vector.retainAll",
	"Comment": "retains only the elements in this vector that are contained in thespecified collection.",
	"Method": "boolean retainAll(Collection c){\r\n    boolean modified = false;\r\n    java.util.Vector v = new java.util.Vector();\r\n    StateManager stateManager = this.makeDirty();\r\n    for (Iterator iter = super.iterator(); iter.hasNext(); ) {\r\n        Object o = iter.next();\r\n        if (!c.contains(o)) {\r\n            v.add(o);\r\n            if (added.remove(o) == false)\r\n                removed.add(o);\r\n            modified = true;\r\n        }\r\n    }\r\n    for (Iterator iter = v.iterator(); iter.hasNext(); ) {\r\n        removeInternal(iter.next());\r\n    }\r\n    this.applyUpdates(stateManager, modified);\r\n    return modified;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.Environment.moveDestinationDirectoryToEnd",
	"Comment": "update the class path to move the destination directory to theend of the class path if it is found in the class path.",
	"Method": "void moveDestinationDirectoryToEnd(){\r\n    if (destinationDirectory != null && classPathOption.remove(destinationDirectory))\r\n        classPathOption.append(destinationDirectory);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.StatementWrapper.getResultSetConcurrency",
	"Comment": "retrieves the result set concurrency for resultset objectsgenerated by this statement object.",
	"Method": "int getResultSetConcurrency(){\r\n    return jdbcStatement.getResultSetConcurrency();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.Insn.append",
	"Comment": "append an instruction sequence at the end of this instructionsequence. returns the final instruction.",
	"Method": "Insn append(Insn i){\r\n    Insn thisInsn = this;\r\n    while (thisInsn.nextInsn != null) thisInsn = thisInsn.nextInsn;\r\n    return thisInsn.insert(i);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.getEnvironmentPropertyByName",
	"Comment": "returns the environment property object searching on the supplied key.throws an illegal argument exception if no such environment property exists.",
	"Method": "EnvironmentProperty getEnvironmentPropertyByName(String name){\r\n    for (Iterator itr = this.getEnvironmentProperties().iterator(); itr.hasNext(); ) {\r\n        EnvironmentProperty ev = (EnvironmentProperty) itr.next();\r\n        if (ev.getName().equals(name)) {\r\n            return ev;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionapphasnoenvpropertybyname\", \"This app {0} has no environment property by the name of {1}\", new Object[] { getRegistrationName(), name }));\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MessageDestinationReferenceDescriptor.getMessageDestinationRefOwner",
	"Comment": "get the descriptor for the message destination reference owner.",
	"Method": "MessageDestinationReferenceDescriptor getMessageDestinationRefOwner(){\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.model.DeploymentDescriptorModel.getInputStreamForResource",
	"Comment": "returns the input stream with the supplied resource name found with \tthe supplied class name.this method overrides the one in \truntimemodel to enforce using the class loader provided at construction \ttime instead of the one specified in this method.",
	"Method": "BufferedInputStream getInputStreamForResource(String className,ClassLoader classLoader,String resourceName){\r\n    return super.getInputStreamForResource(className, getClassLoader(), resourceName);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.provider.PolicyParser.grantElements",
	"Comment": "enumerate all the entries in the global policy object.this method is used by policy admin tools. the toolsshould use the enumeration methods on the returned objectto fetch the elements sequentially.",
	"Method": "Enumeration grantElements(){\r\n    return grantEntries.elements();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.doesMaxRowSizeIncludeBlobs",
	"Comment": "retrieves whether the return value for the methodgetmaxrowsize includes the sql data typeslongvarchar and longvarbinary.",
	"Method": "boolean doesMaxRowSizeIncludeBlobs(){\r\n    return databaseMetaData.doesMaxRowSizeIncludeBlobs();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingTableElementImpl.getTable",
	"Comment": "returns the name of the table element used by this mapping table.",
	"Method": "String getTable(){\r\n    return _table;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.utility.NumericConverterImpl.toBigDecimal",
	"Comment": "to convert number other than biginteger, double and float to bigdecimal.",
	"Method": "BigDecimal toBigDecimal(BigInteger bInteger,BigDecimal toBigDecimal,Double d,BigDecimal toBigDecimal,Float f,BigDecimal toBigDecimal,Number n){\r\n    return (n == null) ? null : new BigDecimal(n.toString());\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.hasConstructor",
	"Comment": "determines if the class with the specified name declares a constructor.",
	"Method": "boolean hasConstructor(String className){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.CSIV2TaggedComponentInfo.createSecurityTaggedComponent",
	"Comment": "create the csiv2 tagged component for a clustered app server.",
	"Method": "org.omg.IOP.TaggedComponent createSecurityTaggedComponent(int sslPort,EjbDescriptor desc,org.omg.IOP.TaggedComponent createSecurityTaggedComponent,List<SocketInfo> socketInfos,EjbDescriptor desc,org.omg.IOP.TaggedComponent createSecurityTaggedComponent,int sslPort){\r\n    org.omg.IOP.TaggedComponent tc = null;\r\n    try {\r\n        Properties props = orbHelper.getCSIv2Props();\r\n        boolean sslRequired = getBooleanValue(props, GlassFishORBHelper.ORB_SSL_SERVER_REQUIRED);\r\n        boolean clientAuthRequired = getBooleanValue(props, GlassFishORBHelper.ORB_CLIENT_AUTH_REQUIRED);\r\n        CompoundSecMech[] mechList = new CompoundSecMech[1];\r\n        org.omg.IOP.TaggedComponent transportMech = createSSLInfo(sslPort, null, sslRequired);\r\n        AS_ContextSec asContext = createASContextSec(null, DEFAULT_REALM);\r\n        SAS_ContextSec sasContext = createSASContextSec(null);\r\n        short targetRequires = (clientAuthRequired ? EstablishTrustInClient.value : 0);\r\n        mechList[0] = new CompoundSecMech(targetRequires, transportMech, asContext, sasContext);\r\n        tc = createCompoundSecMechListComponent(mechList);\r\n    } catch (Exception e) {\r\n        _logger.log(Level.SEVERE, \"iiop.createcompund_exception\", e);\r\n    }\r\n    return tc;\r\n}"
}, {
	"Path": "com.sun.jaspic.config.factory.BaseAuthConfigFactory.decomposeRegisID",
	"Comment": "this api decomposes the given regisid into layer and appcontext.",
	"Method": "String[] decomposeRegisID(String regisID){\r\n    String layer = null;\r\n    String appContext = null;\r\n    if (regisID.equals(\"__0\")) {\r\n    } else if (regisID.startsWith(\"__1\")) {\r\n        appContext = (regisID.length() == 3) ? \"\" : regisID.substring(3);\r\n    } else if (regisID.startsWith(\"__2\")) {\r\n        layer = (regisID.length() == 3) ? \"\" : regisID.substring(3);\r\n    } else if (regisID.startsWith(\"__3\")) {\r\n        int ind = regisID.indexOf('_', 3);\r\n        if (regisID.length() > 3 && ind > 0) {\r\n            String numberString = regisID.substring(3, ind);\r\n            int n;\r\n            try {\r\n                n = Integer.parseInt(numberString);\r\n            } catch (Exception ex) {\r\n                throw new IllegalArgumentException();\r\n            }\r\n            layer = regisID.substring(ind + 1, ind + 1 + n);\r\n            appContext = regisID.substring(ind + 1 + n);\r\n        } else {\r\n            throw new IllegalArgumentException();\r\n        }\r\n    } else {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return new String[] { layer, appContext };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceElementCollection.getElement",
	"Comment": "returns the element with the supplied name from the collection of \telements maintained by this collection.",
	"Method": "PersistenceElement getElement(String name){\r\n    PersistenceElement[] elements = getElements();\r\n    int i, count = ((elements != null) ? elements.length : 0);\r\n    for (i = 0; i < count; i++) {\r\n        PersistenceElement element = elements[i];\r\n        if (name.equals(element.getName()))\r\n            return element;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.ConnectionPool.getResourceFromTransaction",
	"Comment": "try to get a resource from current transaction if it is shareable",
	"Method": "ResourceHandle getResourceFromTransaction(Transaction tran,ResourceAllocator alloc,ResourceSpec spec){\r\n    ResourceHandle result = null;\r\n    try {\r\n        if (tran != null && alloc.shareableWithinComponent()) {\r\n            JavaEETransaction j2eetran = (JavaEETransaction) tran;\r\n            Set set = j2eetran.getResources(poolInfo);\r\n            if (set != null) {\r\n                Iterator iter = set.iterator();\r\n                while (iter.hasNext()) {\r\n                    ResourceHandle h = (ResourceHandle) iter.next();\r\n                    if (h.hasConnectionErrorOccurred()) {\r\n                        iter.remove();\r\n                        continue;\r\n                    }\r\n                    ResourceState state = h.getResourceState();\r\n                    if (h.getResourceAllocator().shareableWithinComponent()) {\r\n                        if (spec.isXA() || poolTxHelper.isNonXAResourceAndFree(j2eetran, h)) {\r\n                            if (matchConnections) {\r\n                                if (!alloc.matchConnection(h)) {\r\n                                    if (poolLifeCycleListener != null) {\r\n                                        poolLifeCycleListener.connectionNotMatched();\r\n                                    }\r\n                                    continue;\r\n                                }\r\n                                if (h.hasConnectionErrorOccurred()) {\r\n                                    if (failAllConnections) {\r\n                                        result = null;\r\n                                        break;\r\n                                    }\r\n                                    iter.remove();\r\n                                    continue;\r\n                                }\r\n                                if (poolLifeCycleListener != null) {\r\n                                    poolLifeCycleListener.connectionMatched();\r\n                                }\r\n                            }\r\n                            if (state.isFree())\r\n                                setResourceStateToBusy(h);\r\n                            result = h;\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch (ClassCastException e) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Pool: getResource : \" + \"transaction is not JavaEETransaction but a \" + tran.getClass().getName(), e);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.ejb.base.stats.HAStatefulSessionStoreStatsImpl.getCheckpointSuccessCount",
	"Comment": "returns the total number of sessions successfully checkpointed into the store",
	"Method": "CountStatistic getCheckpointSuccessCount(){\r\n    synchronized (checkpointCountLock) {\r\n        checkpointSuccessCount.setCount(checkpointSuccessCountVal);\r\n        return (CountStatistic) checkpointSuccessCount.unmodifiableView();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.concurrency.ConcurrencyOptVerify.prepareVerifyGroupMask",
	"Comment": "find all the local fields that have been updatedand use their concurrencygroup to set the verifygroupmask.",
	"Method": "BitSet prepareVerifyGroupMask(UpdateQueryPlan plan){\r\n    ArrayList fields;\r\n    BitSet verifyGroupMask = new BitSet();\r\n    int action = plan.getAction();\r\n    for (int i = 0; i <= 1; i++) {\r\n        if (i == 0) {\r\n            fields = plan.getConfig().fields;\r\n        } else {\r\n            fields = plan.getConfig().hiddenFields;\r\n        }\r\n        if (fields == null) {\r\n            continue;\r\n        }\r\n        for (int j = 0; j < fields.size(); j++) {\r\n            FieldDesc f = (FieldDesc) fields.get(j);\r\n            if ((f instanceof LocalFieldDesc) && (f.sqlProperties & FieldDesc.PROP_IN_CONCURRENCY_CHECK) > 0) {\r\n                if (afterImage.getSetMaskBit(f.absoluteID) || ((action == QueryPlan.ACT_DELETE) && beforeImage.getPresenceMaskBit(f.absoluteID))) {\r\n                    if (f.concurrencyGroup != -1) {\r\n                        verifyGroupMask.set(f.concurrencyGroup);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return verifyGroupMask;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.addField",
	"Comment": "add the supplied field to the collection of fields maintained by this\tholder.",
	"Method": "void addField(PersistenceFieldElement field){\r\n    addFields(new PersistenceFieldElement[] { field });\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.DBStatement.bindInputColumn",
	"Comment": "binds the specified value to the column corresponding withthe specified index reference.",
	"Method": "void bindInputColumn(int index,Object val,ColumnElement columnElement,DBVendorType vendorType){\r\n    int sqlType = getSqlType(columnElement);\r\n    if (logger.isLoggable(Logger.FINER)) {\r\n        Object[] items = { new Integer(index), val, new Integer(sqlType) };\r\n        logger.finer(\"sqlstore.sql.generator.dbstatement.bindinputcolumn\", items);\r\n    }\r\n    if (val == null) {\r\n        preparedStmt.setNull(index, sqlType);\r\n    } else {\r\n        if (val instanceof Number) {\r\n            Number number = (Number) val;\r\n            if (number instanceof Integer) {\r\n                preparedStmt.setInt(index, number.intValue());\r\n            } else if (number instanceof Long) {\r\n                preparedStmt.setLong(index, number.longValue());\r\n            } else if (number instanceof Short) {\r\n                preparedStmt.setShort(index, number.shortValue());\r\n            } else if (number instanceof Byte) {\r\n                preparedStmt.setByte(index, number.byteValue());\r\n            } else if (number instanceof Double) {\r\n                preparedStmt.setDouble(index, number.doubleValue());\r\n            } else if (number instanceof Float) {\r\n                preparedStmt.setFloat(index, number.floatValue());\r\n            } else if (number instanceof BigDecimal) {\r\n                preparedStmt.setBigDecimal(index, (BigDecimal) number);\r\n            } else if (number instanceof BigInteger) {\r\n                preparedStmt.setBigDecimal(index, new BigDecimal((BigInteger) number));\r\n            }\r\n        } else if (val instanceof String) {\r\n            bindStringValue(index, (String) val, columnElement, vendorType);\r\n        } else if (val instanceof Boolean) {\r\n            preparedStmt.setBoolean(index, ((Boolean) val).booleanValue());\r\n        } else if (val instanceof java.util.Date) {\r\n            if (val instanceof java.sql.Date) {\r\n                preparedStmt.setDate(index, (java.sql.Date) val);\r\n            } else if (val instanceof Time) {\r\n                preparedStmt.setTime(index, (Time) val);\r\n            } else if (val instanceof Timestamp) {\r\n                preparedStmt.setTimestamp(index, (Timestamp) val);\r\n            } else {\r\n                Timestamp timestamp = new Timestamp(((java.util.Date) val).getTime());\r\n                preparedStmt.setTimestamp(index, timestamp);\r\n            }\r\n        } else if (val instanceof Character) {\r\n            bindStringValue(index, val.toString(), columnElement, vendorType);\r\n        } else if (val instanceof byte[]) {\r\n            byte[] ba = (byte[]) val;\r\n            preparedStmt.setBinaryStream(index, new ByteArrayInputStream(ba), ba.length);\r\n        } else if (val instanceof Blob) {\r\n            preparedStmt.setBlob(index, (Blob) val);\r\n        } else if (val instanceof Clob) {\r\n            preparedStmt.setClob(index, (Clob) val);\r\n        } else {\r\n            preparedStmt.setObject(index, val);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnection.getManagedConnectionFactory",
	"Comment": "returns the managedconnectionfactory instance that created this managedconnection instance.",
	"Method": "ManagedConnectionFactory getManagedConnectionFactory(){\r\n    return (com.sun.jdbcra.spi.ManagedConnectionFactory) mcf;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.context.ResourceContainerContextImpl.getEjbReference",
	"Comment": "looks up an ejb reference with the given name.return null if it is not found.",
	"Method": "EjbReference getEjbReference(String name){\r\n    EjbReference ejbRef = null;\r\n    try {\r\n        ejbRef = getEjbReferenceContainer().getEjbReference(name);\r\n    } catch (IllegalArgumentException e) {\r\n        Application app = getAppFromDescriptor();\r\n        if (app != null) {\r\n            try {\r\n                ejbRef = app.getEjbReferenceByName(name);\r\n                addEjbReferenceDescriptor(ejbRef);\r\n            } catch (IllegalArgumentException ee) {\r\n            }\r\n        }\r\n    }\r\n    return ejbRef;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.state.LifeCycleState.isRefreshable",
	"Comment": "return whether the object can be refreshed from the database.",
	"Method": "boolean isRefreshable(){\r\n    return isRefreshable;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolAppEmitterImpl.connectionReleased",
	"Comment": "fires probe event that a connection is released for the givenconnection pool.",
	"Method": "void connectionReleased(){\r\n    poolAppProbeProvider.connectionReleasedEvent(poolName, appName);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.addDependency",
	"Comment": "this method adds the dependency between this statemanagerand the other.",
	"Method": "void addDependency(StateManager sm){\r\n    if (logger.isLoggable()) {\r\n        Object[] items = new Object[] { this, sm };\r\n        logger.fine(\"sqlstore.sqlstatemanager.adddependency\", items);\r\n    }\r\n    SQLStateManager other = (SQLStateManager) sm;\r\n    if (!state.isNew() || !state.isDeleted()) {\r\n        this.addUpdatedForeignReference(null, other);\r\n    } else if ((other.stateFlags & ST_REGISTERED) == 0) {\r\n        persistenceManager.registerInstance(other, other.getObjectId(), false, true);\r\n        other.stateFlags |= ST_REGISTERED;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.hasField",
	"Comment": "determines if a field with the specified fieldname exists in the class\twith the specified classname.",
	"Method": "boolean hasField(String className,String fieldName){\r\n    return (getField(className, fieldName) != null);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.BucketizedHashtable.put",
	"Comment": "maps the specified key to the specifiedvalue in this hashtable. neither the key nor thevalue can be null.",
	"Method": "Object put(Object key,Object value){\r\n    return hashtables[getBucketIndex(key)].put(key, value);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.CMPBeanHelper.assertPersistenceManagerNotNull",
	"Comment": "called from a cmp bean to verify that the persistencemanageris not null. throws illegalstateexception if the argument is null.",
	"Method": "void assertPersistenceManagerNotNull(PersistenceManager pm,Object bean){\r\n    if (pm == null) {\r\n        String msg = // NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        cmpMessages, \"JDO.beannotloaded_exception\", bean);\r\n        cmpInternalLogger.log(Logger.SEVERE, msg);\r\n        throw new IllegalStateException(msg);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnectionFactory.isValidByTableQuery",
	"Comment": "checks if a java.sql.connection is valid or notby querying a table.",
	"Method": "void isValidByTableQuery(java.sql.Connection con,String tableName){\r\n    if (con == null) {\r\n        throw new ResourceException(\"The connection is not valid as \" + \"the connection is null\");\r\n    }\r\n    try {\r\n        java.sql.Statement stmt = con.createStatement();\r\n        java.sql.ResultSet rs = stmt.executeQuery(\"SELECT * FROM \" + tableName);\r\n    } catch (Exception sqle) {\r\n        _logger.log(Level.SEVERE, \"jdbc.exc_execute\");\r\n        throw new ResourceException(\"The connection is not valid as \" + \"querying the table \" + tableName + \" failed: \" + sqle.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.javaee.full.deployment.EarSniffer.handles",
	"Comment": "returns true if the passed file or directory is recognized by thisinstance.",
	"Method": "boolean handles(DeploymentContext context,boolean handles,ReadableArchive location){\r\n    return DeploymentUtils.isArchiveOfType(location, earType, locator);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.ApplicationFactory.createApplicationFromStandardDD",
	"Comment": "this method creates an application object from reading the standard deployment descriptor.",
	"Method": "Application createApplicationFromStandardDD(ReadableArchive archive,String archiveType){\r\n    Archivist archivist = archivistFactory.getArchivist(archiveType, null);\r\n    String xmlValidationLevel = dasConfig.getDeployXmlValidation();\r\n    archivist.setXMLValidationLevel(xmlValidationLevel);\r\n    if (xmlValidationLevel.equals(\"none\")) {\r\n        archivist.setXMLValidation(false);\r\n    }\r\n    BundleDescriptor desc = archivist.readStandardDeploymentDescriptor(archive);\r\n    Application application = null;\r\n    if (desc instanceof Application) {\r\n        application = (Application) desc;\r\n    } else {\r\n        ModuleDescriptor newModule = archivist.createModuleDescriptor(desc);\r\n        newModule.setArchiveUri(archive.getURI().getSchemeSpecificPart());\r\n        String moduleName = newModule.getModuleName();\r\n        application = Application.createVirtualApplication(moduleName, newModule);\r\n    }\r\n    return application;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.setInt",
	"Comment": "sets the designated parameter to the given java int value.the driver converts thisto an sql integer value when it sends it to the database.",
	"Method": "void setInt(String parameterName,int x){\r\n    callableStatement.setInt(parameterName, x);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.getEqualsArgs",
	"Comment": "standard set of arguments for comparison with equals method.",
	"Method": "String[] getEqualsArgs(){\r\n    return new String[] { \"java.lang.Object\" };\r\n}"
}, {
	"Path": "org.glassfish.ejb.mdb.deployment.annotation.handlers.MessageDrivenHandler.isValidEjbDescriptor",
	"Comment": "check if the given ejbdescriptor matches the given annotation.",
	"Method": "boolean isValidEjbDescriptor(EjbDescriptor ejbDesc,Annotation annotation){\r\n    return EjbMessageBeanDescriptor.TYPE.equals(ejbDesc.getType());\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.IASEjbCMPEntityDescriptor.methodsEqual",
	"Comment": "checks whether two methods that might have been loaded bydifferent class loaders are equal.",
	"Method": "boolean methodsEqual(Method m1,Method m2,boolean compareDeclaringClass){\r\n    boolean equal = false;\r\n    do {\r\n        String m1Name = m1.getName();\r\n        String m2Name = m2.getName();\r\n        if (!m1Name.equals(m2Name)) {\r\n            break;\r\n        }\r\n        String m1DeclaringClass = m1.getDeclaringClass().getName();\r\n        String m2DeclaringClass = m2.getDeclaringClass().getName();\r\n        if (compareDeclaringClass) {\r\n            if (!m1DeclaringClass.equals(m2DeclaringClass)) {\r\n                break;\r\n            }\r\n        }\r\n        Class[] m1ParamTypes = m1.getParameterTypes();\r\n        Class[] m2ParamTypes = m2.getParameterTypes();\r\n        if (m1ParamTypes.length != m2ParamTypes.length) {\r\n            break;\r\n        }\r\n        equal = true;\r\n        for (int pIndex = 0; pIndex < m1ParamTypes.length; pIndex++) {\r\n            String m1ParamClass = m1ParamTypes[pIndex].getName();\r\n            String m2ParamClass = m2ParamTypes[pIndex].getName();\r\n            if (!m1ParamClass.equals(m2ParamClass)) {\r\n                equal = false;\r\n                break;\r\n            }\r\n        }\r\n    } while (false);\r\n    return equal;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.ActiveJmsResourceAdapter.getUniqueRmiRegistryPort",
	"Comment": "this method should return a unique and unused port , so thatthe broker can use this to start its rmi registry.used only for local mode",
	"Method": "String getUniqueRmiRegistryPort(){\r\n    int mqrmiport = DEFAULTRMIREGISTRYPORT;\r\n    try {\r\n        String configuredport = System.getProperty(BROKER_RMI_PORT);\r\n        if (configuredport != null) {\r\n            mqrmiport = Integer.parseInt(configuredport);\r\n        } else {\r\n            mqrmiport = Integer.parseInt(brkrPort) + BROKERRMIPORTOFFSET;\r\n        }\r\n    } catch (Exception e) {\r\n        ;\r\n    }\r\n    return \"\" + mqrmiport;\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.obj.AttrsToCorba.getDefaultOrb",
	"Comment": "return default orb.the orb is used for turning a stringified ior into an object.",
	"Method": "ORB getDefaultOrb(Hashtable env){\r\n    return CorbaUtils.getOrb(null, -1, env);\r\n}"
}, {
	"Path": "org.glassfish.ejb.startup.EjbApplication.containsTimedObject",
	"Comment": "returns true if at least one of the containers represents a timed object",
	"Method": "boolean containsTimedObject(){\r\n    for (Container container : containers) {\r\n        if (container.isTimedObject()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.ApplicationArchivist.performOptionalPkgDependenciesCheck",
	"Comment": "perform optional packages dependencies checking on an archive",
	"Method": "boolean performOptionalPkgDependenciesCheck(ReadableArchive archive){\r\n    if (!super.performOptionalPkgDependenciesCheck(archive))\r\n        return false;\r\n    if (descriptor == null) {\r\n        throw new IOException(\"Application object not set on archivist\");\r\n    }\r\n    boolean returnValue = true;\r\n    for (ModuleDescriptor md : descriptor.getModules()) {\r\n        ReadableArchive sub = archive.getSubArchive(md.getArchiveUri());\r\n        if (sub != null) {\r\n            Archivist subArchivist = archivistFactory.get().getArchivist(md.getModuleType());\r\n            if (!subArchivist.performOptionalPkgDependenciesCheck(sub))\r\n                returnValue = false;\r\n        }\r\n    }\r\n    return returnValue;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.connectionRequestServed",
	"Comment": "fires probe event related to the fact that a connection request is servedin the time timetakeninmillis for the given jdbc connection pool.",
	"Method": "void connectionRequestServed(long timeTakenInMillis){\r\n    poolProbeProvider.connectionRequestServedEvent(poolName, appName, moduleName, timeTakenInMillis);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.inbound.ActiveInboundResourceAdapterImpl.init",
	"Comment": "creates an active inbound resource adapter. sets all ra java beanproperties and issues a start.",
	"Method": "void init(ResourceAdapter ra,ConnectorDescriptor desc,String moduleName,ClassLoader jcl){\r\n    super.init(ra, desc, moduleName, jcl);\r\n    this.factories_ = new Hashtable<String, MessageEndpointFactoryInfo>();\r\n}"
}, {
	"Path": "org.glassfish.ejb.startup.EjbDeployer.clean",
	"Comment": "clean any files and artifacts that were created during the executionof the prepare method.",
	"Method": "void clean(DeploymentContext dc){\r\n    OpsParams params = dc.getCommandParameters(OpsParams.class);\r\n    if ((params.origin.isUndeploy() || params.origin.isDeploy()) && isDas()) {\r\n        if (cmpDeployer != null) {\r\n            cmpDeployer.clean(dc);\r\n        }\r\n        Properties appProps = dc.getAppProps();\r\n        String uniqueAppId = appProps.getProperty(APP_UNIQUE_ID_PROP);\r\n        try {\r\n            if (getTimeoutStatusFromApplicationInfo(params.name()) && uniqueAppId != null) {\r\n                String target = ((params.origin.isDeploy()) ? dc.getCommandParameters(DeployCommandParameters.class).target : dc.getCommandParameters(UndeployCommandParameters.class).target);\r\n                if (DeploymentUtils.isDomainTarget(target)) {\r\n                    List<String> targets = (List<String>) dc.getTransientAppMetaData(DeploymentProperties.PREVIOUS_TARGETS, List.class);\r\n                    if (targets == null) {\r\n                        targets = domain.getAllReferencedTargetsForApplication(params.name());\r\n                    }\r\n                    if (targets != null && targets.size() > 0) {\r\n                        target = targets.get(0);\r\n                    }\r\n                }\r\n                EJBTimerService timerService = EJBTimerService.getEJBTimerService(target, false);\r\n                if (_logger.isLoggable(Level.FINE)) {\r\n                    _logger.log(Level.FINE, \"EjbDeployer APP ID of a Timeout App? \" + uniqueAppId);\r\n                    _logger.log(Level.FINE, \"EjbDeployer TimerService: \" + timerService);\r\n                }\r\n                if (timerService == null) {\r\n                    _logger.log(Level.WARNING, \"EJB Timer Service is not available. Timers for application with id \" + uniqueAppId + \" will not be deleted\");\r\n                } else {\r\n                    if (getKeepStateFromApplicationInfo(params.name())) {\r\n                        _logger.log(Level.INFO, \"Timers will not be destroyed since keepstate is true for application {0}\", params.name());\r\n                    } else {\r\n                        timerService.destroyAllTimers(Long.parseLong(uniqueAppId));\r\n                    }\r\n                }\r\n            }\r\n        } catch (Exception e) {\r\n            _logger.log(Level.WARNING, \"Failed to delete timers for application with id \" + uniqueAppId, e);\r\n        }\r\n    }\r\n    if (params.origin.isUndeploy() || params.origin.isDeploy() || params.origin.isLoad()) {\r\n        String appName = params.name();\r\n        String[] contextIds = ejbSecManagerFactory.getContextsForApp(appName, false);\r\n        if (contextIds != null) {\r\n            for (String contextId : contextIds) {\r\n                try {\r\n                    probeProvider.policyDestructionStartedEvent(contextId);\r\n                    SecurityUtil.removePolicy(contextId);\r\n                    probeProvider.policyDestructionEndedEvent(contextId);\r\n                    probeProvider.policyDestructionEvent(contextId);\r\n                } catch (IASSecurityException ex) {\r\n                    _logger.log(Level.WARNING, \"Error removing the policy file \" + \"for application \" + appName + \" \" + ex);\r\n                }\r\n                ArrayList<EJBSecurityManager> managers = ejbSecManagerFactory.getManagers(contextId, false);\r\n                if (managers != null) {\r\n                    for (EJBSecurityManager m : managers) {\r\n                        m.destroy();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        SecurityUtil.removeRoleMapper(dc);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsDataManipulationTransactionsOnly",
	"Comment": "retrieves whether this database supports only data manipulationstatements within a transaction.",
	"Method": "boolean supportsDataManipulationTransactionsOnly(){\r\n    return databaseMetaData.supportsDataManipulationTransactionsOnly();\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.connectionAcquired",
	"Comment": "fires probe event that a connection has been acquired by the application for the given jdbc connection pool.",
	"Method": "void connectionAcquired(long resourceHandleId){\r\n    ConnectionPoolAppEmitterImpl appEmitter = detectAppBasedProviders(getAppName(resourceHandleId));\r\n    poolProbeProvider.connectionAcquiredEvent(poolName, appName, moduleName);\r\n    if (appEmitter != null) {\r\n        appEmitter.connectionAcquired();\r\n    }\r\n}"
}, {
	"Path": "admin.ClusterTest.checkInstanceHealth",
	"Comment": "given a status and instance in cluster cl1, reports whether ornot that status is returned.",
	"Method": "boolean checkInstanceHealth(String cluster,String instanceName,String status){\r\n    final String expected = String.format(\"%s %s\", instanceName, status);\r\n    String out = asadminWithOutput(\"get-health\", cluster).outAndErr;\r\n    return out.indexOf(expected) >= 0;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MailConfiguration.getMailDebug",
	"Comment": "get the mail debug flag for the mail session the server will provide.",
	"Method": "boolean getMailDebug(){\r\n    return this.debug;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnection.getLocalTransaction",
	"Comment": "returns an localtransaction instance. the localtransaction interfaceis used by the container to manage local transactions for a rm instance.",
	"Method": "javax.resource.spi.LocalTransaction getLocalTransaction(){\r\n    if (logWriter != null) {\r\n        logWriter.println(\"In getLocalTransaction\");\r\n    }\r\n    checkIfValid();\r\n    return new com.sun.jdbcra.spi.LocalTransaction(this);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.DeploymentDescriptorNode.writeDescriptors",
	"Comment": "write all occurrences of the descriptor corresponding to the currentnode from the parent descriptor to an jaxp dom node and return itthis api will be invoked by the parent node when the parent nodewrites out a mix of statically and dynamically registered sub nodes.this method should be overriden by the sub classes if itneeds to be called by the parent node.",
	"Method": "Node writeDescriptors(Node parent,String nodeName,Descriptor parentDesc){\r\n    return parent;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.CMPBeanHelper.logJDOExceptionWithInternalLogger",
	"Comment": "called from a cmp bean to log jdoexception message thrownfrom a any getter or setter method, with the internallogger.",
	"Method": "void logJDOExceptionWithInternalLogger(String beanName,JDOException ex){\r\n    cmpInternalLogger.log(Logger.WARNING, // NOI18N\r\n    I18NHelper.getMessage(cmpMessages, \"GEN.generic_method_exception\", beanName, findCallingMethodName()), ex);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsSchemasInTableDefinitions",
	"Comment": "retrieves whether a schema name can be used in a table definition statement.",
	"Method": "boolean supportsSchemasInTableDefinitions(){\r\n    return databaseMetaData.supportsSchemasInTableDefinitions();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.setShort",
	"Comment": "sets the designated parameter to the given java short value.the driver converts thisto an sql smallint value when it sends it to the database.",
	"Method": "void setShort(String parameterName,short x){\r\n    callableStatement.setShort(parameterName, x);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.ActiveJmsResourceAdapter.createManagedConnectionFactories",
	"Comment": "this is a temporay solution for obtaining all the mcfscorresponding to a jms ra pool, this is to facilitate therecovery process where the xa resources of all rms in thebroker cluster are required. should be removed when a permanentsolutuion is available from the broker.",
	"Method": "ManagedConnectionFactory[] createManagedConnectionFactories(com.sun.enterprise.connectors.ConnectorConnectionPool cpr,ClassLoader loader){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"RECOVERY : Entering createMCFS in AJMSRA\");\r\n    }\r\n    ArrayList mcfs = new ArrayList();\r\n    if (getAddressListCount() < 2) {\r\n        mcfs.add(createManagedConnectionFactory(cpr, loader));\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Brokers are not clustered,So doing normal recovery\");\r\n        }\r\n    } else {\r\n        String addlist = null;\r\n        Set s = cpr.getConnectorDescriptorInfo().getMCFConfigProperties();\r\n        Iterator tmpit = s.iterator();\r\n        while (tmpit.hasNext()) {\r\n            ConnectorConfigProperty prop = (ConnectorConfigProperty) tmpit.next();\r\n            String propName = prop.getName();\r\n            if (propName.equalsIgnoreCase(\"imqAddressList\") || propName.equalsIgnoreCase(\"Addresslist\")) {\r\n                addlist = prop.getValue();\r\n            }\r\n        }\r\n        StringTokenizer tokenizer = null;\r\n        if ((addlist == null) || (addlist.trim().equalsIgnoreCase(\"localhost\"))) {\r\n            tokenizer = new StringTokenizer(addressList, \",\");\r\n        } else {\r\n            tokenizer = new StringTokenizer(addlist, \",\");\r\n        }\r\n        _logger.log(Level.FINE, \"No of addresses found \" + tokenizer.countTokens());\r\n        while (tokenizer.hasMoreTokens()) {\r\n            String brokerurl = tokenizer.nextToken();\r\n            ManagedConnectionFactory mcf = super.createManagedConnectionFactory(cpr, loader);\r\n            Iterator it = s.iterator();\r\n            while (it.hasNext()) {\r\n                ConnectorConfigProperty prop = (ConnectorConfigProperty) it.next();\r\n                String propName = prop.getName();\r\n                String propValue = prop.getValue();\r\n                if (propName.startsWith(\"imq\") && !\"\".equals(propValue)) {\r\n                    try {\r\n                        Method meth = mcf.getClass().getMethod(SETTER, new Class[] { java.lang.String.class, java.lang.String.class });\r\n                        if (propName.trim().equalsIgnoreCase(\"imqAddressList\")) {\r\n                            meth.invoke(mcf, new Object[] { prop.getName(), brokerurl });\r\n                        } else {\r\n                            meth.invoke(mcf, new Object[] { prop.getName(), prop.getValueObject() });\r\n                        }\r\n                    } catch (NoSuchMethodException ex) {\r\n                        if (_logger.isLoggable(Level.WARNING)) {\r\n                            _logger.log(Level.WARNING, JMSLoggerInfo.NO_SUCH_METHOD, new Object[] { SETTER, mcf.getClass().getName() });\r\n                        }\r\n                    } catch (Exception ex) {\r\n                        LogHelper.log(_logger, Level.SEVERE, JMSLoggerInfo.ERROR_EXECUTE_METHOD, ex, SETTER, mcf.getClass().getName());\r\n                    }\r\n                }\r\n            }\r\n            ConnectorConfigProperty addressProp3 = new ConnectorConfigProperty(ADDRESSLIST, brokerurl, \"Address List\", \"java.lang.String\");\r\n            if (_logger.isLoggable(Level.INFO)) {\r\n                _logger.log(Level.INFO, JMSLoggerInfo.ADDRESSLIST, new Object[] { brokerurl });\r\n            }\r\n            HashSet addressProp = new HashSet();\r\n            addressProp.add(addressProp3);\r\n            SetMethodAction setMethodAction = new SetMethodAction(mcf, addressProp);\r\n            try {\r\n                setMethodAction.run();\r\n            } catch (Exception e) {\r\n                ;\r\n            }\r\n            mcfs.add(mcf);\r\n        }\r\n    }\r\n    return (ManagedConnectionFactory[]) mcfs.toArray(new ManagedConnectionFactory[mcfs.size()]);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingClassElementImpl.forName",
	"Comment": "returns the mapping class element associated with the class with the \tgiven string name, using the given model object to look it up.",
	"Method": "MappingClassElement forName(String name,Model model){\r\n    return model.getMappingClass(name);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ee.PermissionCacheFactory.createPermissionCache",
	"Comment": "create a permissioncache object.if the corresponding object exists, then it will overwrite theprevious one.",
	"Method": "PermissionCache createPermissionCache(String pcID,CodeSource codesource,Permission[] perms,String name,PermissionCache createPermissionCache,String pcID,CodeSource codesource,Class clazz,String name){\r\n    if (!supportsReuse) {\r\n        return null;\r\n    }\r\n    Integer key = getNextKey();\r\n    PermissionCache cache = new PermissionCache(key, pcID, codesource, clazz, name);\r\n    return registerPermissionCache(cache);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOConcreteBean20Generator.generateConversions",
	"Comment": "generates conversion methods from pc to ejbobject and backto the helper class.",
	"Method": "void generateConversions(){\r\n    super.generateConversions();\r\n    if (hasLocalInterface == false) {\r\n        String[] pcParams = new String[] { CMP20TemplateFormatter.pc_, CMP20TemplateFormatter.jdoPersistenceManager_ };\r\n        String[] pcParamTypes = new String[] { CMP20TemplateFormatter.Object_, CMP20TemplateFormatter.jdoPersistenceManagerClass_ };\r\n        String[] body = CMP20TemplateFormatter.getBodyAsStrings(CMP20TemplateFormatter.returnNull_);\r\n        // name\r\n        jdoHelperWriter.addMethod(CMP20TemplateFormatter.convertPCToEJBLocalObject_, Modifier.PUBLIC, CMP20TemplateFormatter.ejbLocalObject_, pcParams, pcParamTypes, null, body, null);\r\n        String[] pcParamsX = new String[] { CMP20TemplateFormatter.pc_, CMP20TemplateFormatter.jdoPersistenceManager_, CMP20TemplateFormatter.context_ };\r\n        String[] pcParamTypesX = new String[] { CMP20TemplateFormatter.Object_, CMP20TemplateFormatter.jdoPersistenceManagerClass_, CMP20TemplateFormatter.ejbContext_ };\r\n        // name\r\n        jdoHelperWriter.addMethod(CMP20TemplateFormatter.convertPCToEJBLocalObject_, Modifier.PUBLIC, CMP20TemplateFormatter.ejbLocalObject_, pcParamsX, pcParamTypesX, null, body, null);\r\n        twoParams[0] = CMP20TemplateFormatter.ejbLocalObject_;\r\n        twoParams[1] = CMP20TemplateFormatter.jdoPersistenceManagerClass_;\r\n        // name\r\n        jdoHelperWriter.addMethod(CMP20TemplateFormatter.convertEJBLocalObjectToPC_, Modifier.PUBLIC, CMP20TemplateFormatter.Object_, param0PM, twoParams, null, body, null);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.storesLowerCaseIdentifiers",
	"Comment": "retrieves whether this database treats mixed case unquoted sql identifiers ascase insensitive and stores them in lower case.",
	"Method": "boolean storesLowerCaseIdentifiers(){\r\n    return databaseMetaData.storesLowerCaseIdentifiers();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.DMManagedConnectionFactory.equals",
	"Comment": "check if this managedconnectionfactory is equal toanother managedconnectionfactory.",
	"Method": "boolean equals(Object other){\r\n    logFine(\"In equals\");\r\n    if (other instanceof com.sun.gjc.spi.DMManagedConnectionFactory) {\r\n        com.sun.gjc.spi.DMManagedConnectionFactory otherMCF = (com.sun.gjc.spi.DMManagedConnectionFactory) other;\r\n        return this.spec.equals(otherMCF.spec);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.ConnectionPoolReconfigHelper.isEqualConnectorConnectionPool",
	"Comment": "compare the original connectorconnectionpool with the passed oneif mcf properties are changed, indicate that pool recreation isrequired we only check the mcf properties since a pool restart is requiredfor changes in mcf props. for pool specific properties we can getaway without restartif the new pool and old pool have identical mcf properties returns true",
	"Method": "ReconfigAction isEqualConnectorConnectionPool(ConnectorConnectionPool oldCcp,ConnectorConnectionPool newCcp,Set excludedProps){\r\n    boolean poolsEqual = true;\r\n    if (newCcp.isPoolingOn() != oldCcp.isPoolingOn()) {\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    if (newCcp.getTransactionSupport() != oldCcp.getTransactionSupport()) {\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    if (newCcp.isAssociateWithThread() != oldCcp.isAssociateWithThread()) {\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    if (newCcp.isLazyConnectionAssoc() != oldCcp.isLazyConnectionAssoc()) {\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    if (newCcp.isPartitionedPool() != oldCcp.isPartitionedPool()) {\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    if (newCcp.getPoolDataStructureType() == null && oldCcp.getPoolDataStructureType() != null) {\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    if (newCcp.getPoolDataStructureType() != null && oldCcp.getPoolDataStructureType() == null) {\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    if (((newCcp.getPoolDataStructureType() != null) && (oldCcp.getPoolDataStructureType() != null) && !(newCcp.getPoolDataStructureType().equals(oldCcp.getPoolDataStructureType())))) {\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    if ((newCcp.getPoolWaitQueue() != null) && (oldCcp.getPoolWaitQueue() == null)) {\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    if ((newCcp.getPoolWaitQueue() == null) && (oldCcp.getPoolWaitQueue() != null)) {\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    if ((newCcp.getPoolWaitQueue() != null) && (oldCcp.getPoolWaitQueue() != null) && (!newCcp.getPoolWaitQueue().equals(oldCcp.getPoolWaitQueue()))) {\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    if ((newCcp.getDataStructureParameters() != null) && (oldCcp.getDataStructureParameters() == null)) {\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    if ((newCcp.getDataStructureParameters() == null) && (oldCcp.getDataStructureParameters() != null)) {\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    if ((newCcp.getDataStructureParameters() != null) && (oldCcp.getDataStructureParameters() != null) && !(newCcp.getDataStructureParameters().equals(oldCcp.getDataStructureParameters()))) {\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    ConnectorDescriptorInfo oldCdi = oldCcp.getConnectorDescriptorInfo();\r\n    ConnectorDescriptorInfo newCdi = newCcp.getConnectorDescriptorInfo();\r\n    if (!oldCdi.getResourceAdapterClassName().equals(newCdi.getResourceAdapterClassName())) {\r\n        logFine(\"isEqualConnectorConnectionPool: getResourceAdapterClassName:: \" + oldCdi.getResourceAdapterClassName() + \" -- \" + newCdi.getResourceAdapterClassName());\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    if (!oldCdi.getConnectionDefinitionName().equals(newCdi.getConnectionDefinitionName())) {\r\n        logFine(\"isEqualConnectorConnectionPool: getConnectionDefinitionName:: \" + oldCdi.getConnectionDefinitionName() + \" -- \" + newCdi.getConnectionDefinitionName());\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    ConnectorSecurityMap[] newSecurityMaps = newCcp.getSecurityMaps();\r\n    RuntimeSecurityMap newRuntimeSecurityMap = SecurityMapUtils.processSecurityMaps(newSecurityMaps);\r\n    ConnectorSecurityMap[] oldSecurityMaps = oldCcp.getSecurityMaps();\r\n    RuntimeSecurityMap oldRuntimeSecurityMap = SecurityMapUtils.processSecurityMaps(oldSecurityMaps);\r\n    if (!(oldRuntimeSecurityMap.equals(newRuntimeSecurityMap))) {\r\n        logFine(\"isEqualConnectorConnectionPool: CCP.getSecurityMaps:: \" + \"New set of Security Maps is not equal to the existing\" + \" set of security Maps.\");\r\n        return ReconfigAction.RECREATE_POOL;\r\n    }\r\n    return oldCdi.compareMCFConfigProperties(newCdi, excludedProps);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.XAManagedConnectionFactory.equals",
	"Comment": "check if this managedconnectionfactory is equal toanother managedconnectionfactory.",
	"Method": "boolean equals(Object other){\r\n    logFine(\"In equals\");\r\n    if (other instanceof com.sun.gjc.spi.XAManagedConnectionFactory) {\r\n        com.sun.gjc.spi.XAManagedConnectionFactory otherMCF = (com.sun.gjc.spi.XAManagedConnectionFactory) other;\r\n        return this.spec.equals(otherMCF.spec);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jauth.AuthPolicy.isRecipientAuthBeforeContent",
	"Comment": "case, the returned value is only relevant when recipientauth is required.",
	"Method": "boolean isRecipientAuthBeforeContent(boolean isRecipientAuthBeforeContent,boolean orderForValidation){\r\n    return (orderForValidation ? !this.recipientBeforeContent : this.recipientBeforeContent);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConfigurationParserServiceImpl.getAdminObjectClassNames",
	"Comment": "gets the adminobjectclassnames pertaining to a rar & a specificadminobjectinterfacename",
	"Method": "String[] getAdminObjectClassNames(String rarName,String intfName){\r\n    ConnectorDescriptor desc = getConnectorDescriptor(rarName);\r\n    if (desc != null) {\r\n        AdminObjectConfigParser adminObjectConfigParser = (AdminObjectConfigParser) ConnectorConfigParserFactory.getParser(ConnectorConfigParser.AOR);\r\n        return adminObjectConfigParser.getAdminObjectClassNames(desc, intfName);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.annotation.handlers.StatelessHandler.isValidEjbDescriptor",
	"Comment": "check if the given ejbdescriptor matches the given annotation.",
	"Method": "boolean isValidEjbDescriptor(EjbDescriptor ejbDesc,Annotation annotation){\r\n    boolean isValid = EjbSessionDescriptor.TYPE.equals(ejbDesc.getType());\r\n    if (isValid) {\r\n        EjbSessionDescriptor sessionDesc = (EjbSessionDescriptor) ejbDesc;\r\n        if (sessionDesc.isSessionTypeSet() && !sessionDesc.isStateless()) {\r\n            isValid = false;\r\n        }\r\n    }\r\n    return isValid;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.RuntimeBundleNode.recordNodeMapping",
	"Comment": "record mapping of sub element to node class for the current element",
	"Method": "void recordNodeMapping(String currentElementName,String subElementName,Class subElementHandler){\r\n    LinkedHashMap<String, Class> subElementMappings = elementToNodeMappings.get(currentElementName);\r\n    if (subElementMappings == null) {\r\n        subElementMappings = new LinkedHashMap<String, Class>();\r\n        elementToNodeMappings.put(currentElementName, subElementMappings);\r\n    }\r\n    subElementMappings.put(subElementName, subElementHandler);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.connector.OutBoundRANode.createConDefDescriptorFor10",
	"Comment": "this method is required for 1.0 dtd so that there will be 1 instance of connectiondefdescriptor availablei know that this constructor will be called only when it is a 1.0 dddont want to rely on whether 1.0 or 1.5 spec versionso this method is called when the connectornode knows that it is for 1.0 dtd",
	"Method": "void createConDefDescriptorFor10(){\r\n    ConnectionDefDescriptor conDef = new ConnectionDefDescriptor();\r\n    ((OutboundResourceAdapter) getDescriptor()).addConnectionDefDescriptor(conDef);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.support.JDOException.addFailedObject",
	"Comment": "the exception may need to add objects to an array of failed objects.",
	"Method": "void addFailedObject(Object o){\r\n    if (failed == null)\r\n        failed = new Object[] { o };\r\n    else {\r\n        int len = failed.length;\r\n        Object[] ofailed = failed;\r\n        failed = new Object[len + 1];\r\n        for (int i = 0; i < len; i++) failed[i] = ofailed[i];\r\n        failed[len] = o;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.getNullComparisonFunctionName",
	"Comment": "returns function name for comparing null value for this database",
	"Method": "String getNullComparisonFunctionName(){\r\n    String s = (String) dbMap.get(NULL_COMPARISON_FUNCTION_NAME);\r\n    if (s == null)\r\n        s = NONE;\r\n    else\r\n        s = s.trim();\r\n    if (logger.isLoggable()) {\r\n        logger.fine(\"sqlstore.database.dbvendor.getNullComparisonFunctionName\", s);\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.setFetchDirection",
	"Comment": "gives a hint as to the direction in which the rows in thisresultset object will be processed.the initial value is determined by thestatement objectthat produced this resultset object.the fetch direction may be changed at any time.",
	"Method": "void setFetchDirection(int direction){\r\n    resultSet.setFetchDirection(direction);\r\n}"
}, {
	"Path": "com.sun.jaspic.config.factory.BaseAuthConfigFactory._unRegister",
	"Comment": "xxx need to update persistent state and notify effected listeners",
	"Method": "boolean _unRegister(String regisID){\r\n    boolean rvalue = false;\r\n    RegistrationContext rc = null;\r\n    Map<String, List<RegistrationListener>> listenerMap;\r\n    wLock.lock();\r\n    try {\r\n        rc = id2RegisContextMap.remove(regisID);\r\n        rvalue = id2ProviderMap.containsKey(regisID);\r\n        AuthConfigProvider provider = id2ProviderMap.remove(regisID);\r\n        List<String> regisIDs = provider2IdsMap.get(provider);\r\n        if (regisIDs != null) {\r\n            regisIDs.remove(regisID);\r\n        }\r\n        if (regisIDs == null || regisIDs.isEmpty()) {\r\n            provider2IdsMap.remove(provider);\r\n        }\r\n        if (!rvalue) {\r\n            return false;\r\n        }\r\n        listenerMap = getEffectedListeners(regisID);\r\n        if (rc != null && rc.isPersistent()) {\r\n            _deleteStoredRegistration(regisID, rc);\r\n        }\r\n    } finally {\r\n        wLock.unlock();\r\n    }\r\n    notifyListeners(listenerMap);\r\n    return rvalue;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.setFloat",
	"Comment": "sets the designated parameter to the given java float value.the driver converts thisto an sql float value when it sends it to the database.",
	"Method": "void setFloat(String parameterName,float x){\r\n    callableStatement.setFloat(parameterName, x);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.getFields",
	"Comment": "returns a list of names of all the declared field elements in the\tclass with the specified name.",
	"Method": "List getFields(String className){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.Vector.set",
	"Comment": "replaces the element at the specified position in this vector with thespecified element.",
	"Method": "Object set(int index,Object element){\r\n    throwUnsupportedOption();\r\n    if (element == null) {\r\n        if (allowNulls == false) {\r\n            throw new JDOUserException(// NOI18N\r\n            I18NHelper.getMessage(messages, \"sco.nulls_not_allowed\"));\r\n        }\r\n        return this.remove(index);\r\n    }\r\n    if (elementType == null || elementType.isAssignableFrom(element.getClass())) {\r\n        StateManager stateManager = this.makeDirty();\r\n        Object o = super.set(index, element);\r\n        if (added.remove(o) == false)\r\n            removed.add(o);\r\n        if (removed.remove(element) == false)\r\n            added.add(element);\r\n        this.applyUpdates(stateManager, true);\r\n        return o;\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        messages, \"sco.classcastexception\", elementType.getName()), new ClassCastException(), new Object[] { element });\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.HttpAuthenticator.getPasswordAuthentication",
	"Comment": "this is called when authentication is needed for a protectedweb resource. it looks for the authentication data in the subject.if the data is not found then login is invoked on the login context.",
	"Method": "PasswordAuthentication getPasswordAuthentication(){\r\n    String user = null;\r\n    char[] password = null;\r\n    Subject subject = null;\r\n    String scheme = getRequestingScheme();\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"scheme=\" + scheme);\r\n        _logger.fine(\"requesting prompt=\" + getRequestingPrompt());\r\n        _logger.fine(\"requesting protocol=\" + getRequestingProtocol());\r\n    }\r\n    ClientSecurityContext cont = ClientSecurityContext.getCurrent();\r\n    subject = (cont != null) ? cont.getSubject() : null;\r\n    user = getUserName(subject);\r\n    password = getPassword(subject);\r\n    if (user == null || password == null) {\r\n        try {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.fine(\"Initiating login again...\");\r\n            }\r\n            securityInfo.doClientLogin(loginType);\r\n            cont = ClientSecurityContext.getCurrent();\r\n            subject = cont.getSubject();\r\n            user = getUserName(subject);\r\n            password = getPassword(subject);\r\n        } catch (Exception e) {\r\n            _logger.log(Level.FINE, \"Exception \" + e.toString(), e);\r\n            return null;\r\n        }\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"Username:\" + user);\r\n    }\r\n    return new PasswordAuthentication(user, password);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.JavaTypeHelper.getWrapperClass",
	"Comment": "returns the wrapper class associated with the supplied primitive class.",
	"Method": "Class getWrapperClass(Class primitive){\r\n    return (Class) _primitiveToWrappers.get(primitive);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.LocalFieldDesc.isFixedCharType",
	"Comment": "determines if the sqltype passed to this method corresponds toa fixed char type.",
	"Method": "boolean isFixedCharType(int sqlType){\r\n    return sqlType == Types.CHAR;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.ApplicationArchivist.getApplicationFromIntrospection",
	"Comment": "this method introspect an ear file and populate the application object.we follow the java ee platform specification, section ee.8.4.2to determine the type of the modules included in this application.",
	"Method": "Application getApplicationFromIntrospection(ReadableArchive archive,boolean directory){\r\n    String appRoot = archive.getURI().getSchemeSpecificPart();\r\n    if (appRoot.endsWith(File.separator)) {\r\n        appRoot = appRoot.substring(0, appRoot.length() - 1);\r\n    }\r\n    Application app = Application.createApplication();\r\n    app.setLoadedFromApplicationXml(false);\r\n    app.setVirtual(false);\r\n    String appName = appRoot.substring(appRoot.lastIndexOf(File.separatorChar) + 1);\r\n    app.setName(appName);\r\n    List<ReadableArchive> unknowns = new ArrayList<ReadableArchive>();\r\n    File[] files = getEligibleEntries(new File(appRoot), directory);\r\n    for (File subModule : files) {\r\n        ReadableArchive subArchive = null;\r\n        try {\r\n            try {\r\n                subArchive = archiveFactory.openArchive(subModule);\r\n            } catch (IOException ex) {\r\n                logger.log(Level.WARNING, ex.getMessage());\r\n            }\r\n            String name = subModule.getName();\r\n            String uri = deriveArchiveUri(appRoot, subModule, directory);\r\n            if ((!directory && name.endsWith(\".war\")) || (directory && (name.endsWith(\"_war\") || name.endsWith(\".war\")))) {\r\n                ModuleDescriptor<BundleDescriptor> md = new ModuleDescriptor<BundleDescriptor>();\r\n                md.setArchiveUri(uri);\r\n                md.setModuleType(DOLUtils.warType());\r\n                app.addModule(md);\r\n            } else if ((!directory && name.endsWith(\".rar\")) || (directory && (name.endsWith(\"_rar\") || name.endsWith(\".rar\")))) {\r\n                ModuleDescriptor<BundleDescriptor> md = new ModuleDescriptor<BundleDescriptor>();\r\n                md.setArchiveUri(uri);\r\n                md.setModuleType(DOLUtils.rarType());\r\n                app.addModule(md);\r\n            } else if ((!directory && name.endsWith(\".jar\")) || (directory && (name.endsWith(\"_jar\") || name.endsWith(\".jar\")))) {\r\n                try {\r\n                    AppClientArchivist acArchivist = new AppClientArchivist();\r\n                    if (acArchivist.hasStandardDeploymentDescriptor(subArchive) || acArchivist.hasRuntimeDeploymentDescriptor(subArchive) || acArchivist.getMainClassName(subArchive.getManifest()) != null) {\r\n                        ModuleDescriptor<BundleDescriptor> md = new ModuleDescriptor<BundleDescriptor>();\r\n                        md.setArchiveUri(uri);\r\n                        md.setModuleType(DOLUtils.carType());\r\n                        md.setManifest(subArchive.getManifest());\r\n                        app.addModule(md);\r\n                        continue;\r\n                    }\r\n                    Archivist ejbArchivist = archivistFactory.get().getArchivist(DOLUtils.ejbType());\r\n                    if (ejbArchivist.hasStandardDeploymentDescriptor(subArchive) || ejbArchivist.hasRuntimeDeploymentDescriptor(subArchive)) {\r\n                        ModuleDescriptor<BundleDescriptor> md = new ModuleDescriptor<BundleDescriptor>();\r\n                        md.setArchiveUri(uri);\r\n                        md.setModuleType(DOLUtils.ejbType());\r\n                        app.addModule(md);\r\n                        continue;\r\n                    }\r\n                } catch (IOException ex) {\r\n                    logger.log(Level.WARNING, ex.getMessage());\r\n                }\r\n                unknowns.add(subArchive);\r\n                subArchive = null;\r\n            } else {\r\n            }\r\n        } finally {\r\n            if (subArchive != null) {\r\n                try {\r\n                    subArchive.close();\r\n                } catch (IOException ioe) {\r\n                    logger.log(Level.WARNING, localStrings.getLocalString(\"enterprise.deployment.errorClosingSubArch\", \"Error closing subarchive {0}\", new Object[] { subModule.getAbsolutePath() }), ioe);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (unknowns.size() > 0) {\r\n        AnnotationDetector detector = new AnnotationDetector(new EjbComponentAnnotationScanner());\r\n        for (int i = 0; i < unknowns.size(); i++) {\r\n            File jarFile = new File(unknowns.get(i).getURI().getSchemeSpecificPart());\r\n            try {\r\n                if (detector.hasAnnotationInArchive(unknowns.get(i))) {\r\n                    String uri = deriveArchiveUri(appRoot, jarFile, directory);\r\n                    ModuleDescriptor<BundleDescriptor> md = new ModuleDescriptor<BundleDescriptor>();\r\n                    md.setArchiveUri(uri);\r\n                    md.setModuleType(DOLUtils.ejbType());\r\n                    app.addModule(md);\r\n                }\r\n                unknowns.get(i).close();\r\n            } catch (IOException ex) {\r\n                logger.log(Level.WARNING, ex.getMessage());\r\n            }\r\n        }\r\n    }\r\n    return app;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.deployment.UserDataConstraintImpl.setTransportGuarantee",
	"Comment": "sets my transport type to the given value. throws an illegal argument exception if the value is not allowed.",
	"Method": "void setTransportGuarantee(String transportGuarantee){\r\n    if (this.isBoundsChecking()) {\r\n        if (!UserDataConstraint.NONE_TRANSPORT.equals(transportGuarantee) && !UserDataConstraint.INTEGRAL_TRANSPORT.equals(transportGuarantee) && !UserDataConstraint.CONFIDENTIAL_TRANSPORT.equals(transportGuarantee)) {\r\n            throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptiontransportguarentee\", \"{0} is not a valid transport guarantee\", new Object[] { transportGuarantee }));\r\n        }\r\n    }\r\n    this.transportGuarantee = transportGuarantee;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionMetaDataImpl.getEISProductName",
	"Comment": "returns product name of the underlying eis instance connectedthrough the managedconnection.",
	"Method": "String getEISProductName(){\r\n    try {\r\n        return dmd.getDatabaseProductName();\r\n    } catch (SQLException sqle) {\r\n        _logger.log(Level.SEVERE, \"jdbc.exc_eis_prodname\", sqle);\r\n        throw new ResourceException(sqle.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.Vector.removeAllElements",
	"Comment": "removes all components from this vector and sets its size to zero.",
	"Method": "void removeAllElements(){\r\n    StateManager stateManager = this.makeDirty();\r\n    for (Iterator iter = super.iterator(); iter.hasNext(); ) {\r\n        Object o = iter.next();\r\n        if (added.remove(o) == false)\r\n            removed.add(o);\r\n    }\r\n    added.clear();\r\n    super.removeAllElements();\r\n    this.applyUpdates(stateManager, true);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.Date.writeReplace",
	"Comment": "use java.util.date as the designated object to be used when writing this object to the stream.",
	"Method": "Object writeReplace(){\r\n    return new java.util.Date(getTime());\r\n}"
}, {
	"Path": "org.glassfish.deployapi.config.SunDeploymentConfiguration.getDConfigBeanRoot",
	"Comment": "returns the top level configuration bean, dconfigbeanroot,associated with the deployment descriptor represented bythe designated ddbeanroot bean.",
	"Method": "DConfigBeanRoot getDConfigBeanRoot(DDBeanRoot dDBeanRoot){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.XAResourceImpl.getTransactionTimeout",
	"Comment": "obtain the current transaction timeout value set for thisxaresource instance.",
	"Method": "int getTransactionTimeout(){\r\n    return xar.getTransactionTimeout();\r\n}"
}, {
	"Path": "com.sun.ejb.EjbInvocation.getCachedPermission",
	"Comment": "returns cachedpermission associated with this invocation, ornull if not available.",
	"Method": "Object getCachedPermission(){\r\n    return (invocationInfo != null) ? invocationInfo.cachedPermission : null;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.setLogWriter",
	"Comment": "sets the log writer for this managedconnectionimpl instance.",
	"Method": "void setLogWriter(PrintWriter out){\r\n    checkIfValid();\r\n    logWriter = out;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.connectionNotMatched",
	"Comment": "fires probe event that a connection under test does not match the current request for the given jdbc connection pool.",
	"Method": "void connectionNotMatched(){\r\n    poolProbeProvider.connectionNotMatchedEvent(poolName, appName, moduleName);\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.jws.JWSAdapterManager.addStaticSystemContent",
	"Comment": "records the need for signed copies of the glassfish system jars for thespecified signing alias.",
	"Method": "void addStaticSystemContent(String lookupURI,StaticContent newContent,Map<String, StaticContent> addStaticSystemContent,List<String> systemJARRelativeURIs,String signingAlias){\r\n    Map<String, StaticContent> result = new HashMap<String, StaticContent>();\r\n    File gfClientJAR = gfClientJAR();\r\n    final String classPathExpr = getGFClientModuleClassPath(gfClientJAR);\r\n    final URI gfClientJARURI = gfClientJAR.toURI();\r\n    result.put(systemPath(gfClientJARURI, signingAlias), systemJarSignedContent(gfClientJAR, signingAlias));\r\n    if (classPathExpr != null) {\r\n        for (String classPathElement : classPathExpr.split(\" \")) {\r\n            final URI uri = gfClientJARURI.resolve(classPathElement);\r\n            final String systemPath = systemPath(uri, signingAlias);\r\n            final File candidateFile = new File(uri);\r\n            final String relativeSystemPath = relativeSystemPath(uri);\r\n            if (candidateFile.exists() && (!candidateFile.isDirectory()) && (!DO_NOT_SERVE_LIST.contains(relativeSystemPath))) {\r\n                result.put(systemPath, systemJarSignedContent(candidateFile, signingAlias));\r\n                systemJARRelativeURIs.add(relativeSystemPath(uri));\r\n            }\r\n        }\r\n    }\r\n    final File endorsedDir = new File(modulesDir(), \"endorsed\");\r\n    File[] files = endorsedDir.listFiles(new FileFilter() {\r\n        @Override\r\n        public boolean accept(File pathname) {\r\n            return (pathname.isFile() && pathname.getName().endsWith(\".jar\"));\r\n        }\r\n    });\r\n    if (files != null) {\r\n        for (File endorsedJar : files) {\r\n            result.put(systemPath(endorsedJar.toURI()), systemJarSignedContent(endorsedJar, signingAlias));\r\n            systemJARRelativeURIs.add(relativeSystemPath(endorsedJar.toURI()));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.jws.JWSAdapterManager.addStaticSystemContent",
	"Comment": "records the need for signed copies of the glassfish system jars for thespecified signing alias.",
	"Method": "void addStaticSystemContent(String lookupURI,StaticContent newContent,Map<String, StaticContent> addStaticSystemContent,List<String> systemJARRelativeURIs,String signingAlias){\r\n    return (pathname.isFile() && pathname.getName().endsWith(\".jar\"));\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.PreparedStatementWrapper.setURL",
	"Comment": "sets the designated parameter to the given java.net.url value.the driver converts this to an sql datalink valuewhen it sends it to the database.",
	"Method": "void setURL(int parameterIndex,URL x){\r\n    preparedStatement.setURL(parameterIndex, x);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.QueryPlan.processStatements",
	"Comment": "this method goes through the statement list and tries to set up relationshipbetween statements based on secondary table keys.",
	"Method": "void processStatements(){\r\n    for (int i = 0; i < statements.size(); i++) {\r\n        Statement s = (Statement) statements.get(i);\r\n        QueryTable qt = (QueryTable) s.getQueryTables().get(0);\r\n        ArrayList secondaryTableKeys = qt.getTableDesc().getSecondaryTableKeys();\r\n        if (secondaryTableKeys != null) {\r\n            for (int j = 0; j < secondaryTableKeys.size(); j++) {\r\n                ReferenceKeyDesc secondaryTableKey = (ReferenceKeyDesc) secondaryTableKeys.get(j);\r\n                s.addSecondaryTableStatement(getStatement(findQueryTable(secondaryTableKey.getTableDesc())));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.WebServiceEndpoint.getHandlers",
	"Comment": "get ordered list of webservicehandler handler for this endpoint.",
	"Method": "LinkedList getHandlers(){\r\n    return handlers;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsMultipleResultSets",
	"Comment": "retrieves whether this database supports getting multipleresultset objects from a single call to themethod execute.",
	"Method": "boolean supportsMultipleResultSets(){\r\n    return databaseMetaData.supportsMultipleResultSets();\r\n}"
}, {
	"Path": "com.sun.ejb.EjbInvocation.doAfterUtxBegin",
	"Comment": "called by the usertransaction when transaction is started.",
	"Method": "void doAfterUtxBegin(){\r\n    ((Container) container).doAfterBegin(this);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.MappingPolicy.getJdbcTypeName",
	"Comment": "provide the string name of a jdbc type, as per java.sql.types.",
	"Method": "String getJdbcTypeName(int type){\r\n    String rc = (String) jdbcTypeNames.get(new Integer(type));\r\n    if (null == rc) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ResultSetWrapper40.isClosed",
	"Comment": "retrieves whether this resultset object has been closed. a resultset is closed if themethod close has been called on it, or if it is automatically closed.",
	"Method": "boolean isClosed(){\r\n    return resultSet.isClosed();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.BucketizedHashtable.clear",
	"Comment": "clears this bucketizedhashtable so that it contains no key.",
	"Method": "void clear(){\r\n    for (int i = 0; i < bucketSize; i++) {\r\n        hashtables[i].clear();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConfigurationParserServiceImpl.hasAdminObject",
	"Comment": "checks whether the specified intfname, classname has presence inadmin objects of the rar",
	"Method": "boolean hasAdminObject(String rarName,String intfName,String className){\r\n    ConnectorDescriptor desc = getConnectorDescriptor(rarName);\r\n    if (desc != null) {\r\n        AdminObjectConfigParser adminObjectConfigParser = (AdminObjectConfigParser) ConnectorConfigParserFactory.getParser(ConnectorConfigParser.AOR);\r\n        return adminObjectConfigParser.hasAdminObject(desc, intfName, className);\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.SaxParserHandlerBundled.resolveEntity",
	"Comment": "returns an inputsource for the requested dtd or schema.this implementation returns an inputsource that wraps the resultof getresourceasstream, havinglocated the requested schema in the classpath.",
	"Method": "InputSource resolveEntity(String publicID,String systemID){\r\n    InputSource result = null;\r\n    try {\r\n        if (DOLUtils.getDefaultLogger().isLoggable(Level.FINE)) {\r\n            DOLUtils.getDefaultLogger().fine(\"Asked to resolve  \" + publicID + \" system id = \" + systemID);\r\n        }\r\n        if (publicID == null) {\r\n            if (systemID == null || systemID.lastIndexOf('/') == systemID.length()) {\r\n                return null;\r\n            }\r\n            result = openSchemaSource(systemID);\r\n            if (result == null) {\r\n                result = new InputSource(systemID);\r\n            }\r\n        } else {\r\n            if (getMapping().containsKey(publicID)) {\r\n                this.publicID = publicID;\r\n                result = openDTDSource(publicID);\r\n            } else if (systemID != null) {\r\n                result = openSchemaSource(systemID);\r\n                if (result == null) {\r\n                    result = openInputSource(BUNDLED_DTD_ROOT, systemID);\r\n                }\r\n            }\r\n        }\r\n    } catch (Exception exc) {\r\n        DOLUtils.getDefaultLogger().log(Level.SEVERE, \"Error occurred\", exc);\r\n        throw new SAXException(exc);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.DescriptorFactory.register",
	"Comment": "register a new descriptor class handling a particular xpath in the dtd.",
	"Method": "void register(XMLElement xmlPath,Class clazz){\r\n    if (DOLUtils.getDefaultLogger().isLoggable(Level.FINE)) {\r\n        DOLUtils.getDefaultLogger().fine(\"Register \" + clazz + \" to handle \" + xmlPath.getQName());\r\n    }\r\n    descriptorClasses.put(xmlPath.getQName(), clazz);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingClassElementImpl.setModified",
	"Comment": "set the modified flag for this mapping class to flag.this is usually \tset to true by property changes and false \tafter a save.",
	"Method": "void setModified(boolean flag){\r\n    boolean oldFlag = isModified();\r\n    if (flag != oldFlag) {\r\n        _isModified = flag;\r\n        firePropertyChange(PROP_MODIFIED, JavaTypeHelper.valueOf(oldFlag), JavaTypeHelper.valueOf(flag));\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.notifyNewModule",
	"Comment": "called by webarchivist to notify this ejbdescriptor thatit has been associated with a web bundle.",
	"Method": "void notifyNewModule(WebBundleDescriptor wbd){\r\n    wbd.addJndiNameEnvironment(this);\r\n    environmentProperties.clear();\r\n    ejbReferences.clear();\r\n    resourceEnvReferences.clear();\r\n    messageDestReferences.clear();\r\n    resourceReferences.clear();\r\n    serviceReferences.clear();\r\n    entityManagerFactoryReferences.clear();\r\n    entityManagerReferences.clear();\r\n    env = wbd;\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.obj.GroupOfURLs.addMembers",
	"Comment": "adds members to the group.performs an ldap modify to add the ldap url.",
	"Method": "void addMembers(String members){\r\n    if (!isBound()) {\r\n        throw new IllegalStateException();\r\n    }\r\n    if (debug) {\r\n        System.out.println(\"[debug] adding the members: \" + members);\r\n    }\r\n    modifyMembers(members, DirContext.ADD_ATTRIBUTE);\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.ListConnectorConnectionPools.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        Collection<ConnectorConnectionPool> connPools = domain.getResources().getResources(ConnectorConnectionPool.class);\r\n        for (ConnectorConnectionPool pool : connPools) {\r\n            final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n            part.setMessage(pool.getName());\r\n        }\r\n    } catch (Exception e) {\r\n        Logger.getLogger(ListConnectorConnectionPools.class.getName()).log(Level.SEVERE, \"Something went wrong in list-connector-connection-pools\", e);\r\n        report.setMessage(localStrings.getLocalString(\"list.connector.connection.pools.failed\", \"List connector connection pools failed\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerWrapper.setRequireTrackedSCO",
	"Comment": "sets the requiretrackedsco flag for this persistencemanager.if set to false, the persistencemanager will not create trackedsco instances for new persistent instances at commit with retainvalues set to true and while retrieving data from a datastore.",
	"Method": "void setRequireTrackedSCO(boolean flag){\r\n    if (isValid) {\r\n        pm.setRequireTrackedSCO(flag);\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerwrapper.invalidpm\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.MappingGenerator.getDeploymentArguments",
	"Comment": "reads deployment settings from the deployment descriptor and cli optionsand populates the corresponding variables.",
	"Method": "Results getDeploymentArguments(DeploymentContext ctx,ResourceReferenceDescriptor cmpResource,boolean connectToDatabase){\r\n    Boolean useUniqueTableNames = null;\r\n    String dbVendorName = null;\r\n    Properties userPolicy = null;\r\n    boolean javaToDatabaseArgs = false;\r\n    if (null == ctx) {\r\n        dbVendorName = cmpResource.getDatabaseVendorName();\r\n    } else {\r\n        DeployCommandParameters cliOverrides = ctx.getCommandParameters(DeployCommandParameters.class);\r\n        useUniqueTableNames = cliOverrides.uniquetablenames;\r\n        javaToDatabaseArgs = (useUniqueTableNames != null);\r\n        dbVendorName = cliOverrides.dbvendorname;\r\n        javaToDatabaseArgs |= isPropertyDefined(dbVendorName);\r\n        if (null == dbVendorName) {\r\n            dbVendorName = cmpResource.getDatabaseVendorName();\r\n        }\r\n        if (null == dbVendorName && connectToDatabase) {\r\n            try {\r\n                Connection conn = DeploymentHelper.getConnection(cmpResource.getJndiName());\r\n                dbVendorName = conn.getMetaData().getDatabaseProductName();\r\n            } catch (Exception ex) {\r\n            }\r\n        }\r\n        Boolean createTables = cliOverrides.createtables;\r\n        javaToDatabaseArgs |= (createTables != null);\r\n        Boolean dropAndCreateTables = cliOverrides.dropandcreatetables;\r\n        javaToDatabaseArgs |= (dropAndCreateTables != null);\r\n    }\r\n    if (null == dbVendorName) {\r\n        dbVendorName = DBVendorTypeHelper.DEFAULT_DB;\r\n    } else {\r\n        dbVendorName = DBVendorTypeHelper.getDBType(dbVendorName);\r\n    }\r\n    userPolicy = cmpResource.getSchemaGeneratorProperties();\r\n    return new Results(useUniqueTableNames, dbVendorName, userPolicy, javaToDatabaseArgs);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ResourceReferenceDescriptor.isMailResource",
	"Comment": "return true if this resource is to a javamail session object.",
	"Method": "boolean isMailResource(){\r\n    return this.getType().equals(MAIL_RESOURCE_TYPE);\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnectionFactory.isValidByMetaData",
	"Comment": "checks if a java.sql.connection is valid or notby checking its meta data.",
	"Method": "void isValidByMetaData(java.sql.Connection con){\r\n    if (con == null) {\r\n        throw new ResourceException(\"The connection is not valid as \" + \"the connection is null\");\r\n    }\r\n    try {\r\n        java.sql.DatabaseMetaData dmd = con.getMetaData();\r\n    } catch (Exception sqle) {\r\n        _logger.log(Level.SEVERE, \"jdbc.exc_md\");\r\n        throw new ResourceException(\"The connection is not valid as \" + \"getting the meta data failed: \" + sqle.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.CallableStatementWrapper40.getRowId",
	"Comment": "retrieves the value of the designated jdbc rowid parameter as ajava.sql.rowid object.",
	"Method": "RowId getRowId(int parameterIndex,RowId getRowId,String parameterName){\r\n    return callableStatement.getRowId(parameterName);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.getEjbClientJarUri",
	"Comment": "return the empty string or the entry name of the ejb client jar in my archive if i have one.",
	"Method": "String getEjbClientJarUri(){\r\n    if (ejbClientJarUri == null) {\r\n        ejbClientJarUri = \"\";\r\n    }\r\n    return ejbClientJarUri;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.PreparedStatementWrapper.setByte",
	"Comment": "sets the designated parameter to the given java byte value.the driver converts thisto an sql tinyint value when it sends it to the database.",
	"Method": "void setByte(int parameterIndex,byte x){\r\n    preparedStatement.setByte(parameterIndex, x);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlTimestamp.setMinutes",
	"Comment": "sets the minutes of this sqltimestamp object to the specified value.",
	"Method": "void setMinutes(int minutes){\r\n    this.makeDirty();\r\n    super.setMinutes(minutes);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.RetrieveDescImpl.addPrefetchedField",
	"Comment": "add a field specified by name to the list of fields to be prefetched.",
	"Method": "void addPrefetchedField(String name,RetrieveDesc foreignConstraint){\r\n    fields.add(new ConstraintFieldName(name, foreignConstraint, true));\r\n}"
}, {
	"Path": "com.sun.enterprise.security.perms.PermissionsProcessor.processFilePermission",
	"Comment": "for file permission, make the necessary path change, then add permssion to classloader",
	"Method": "void processFilePermission(PermissionCollection revisedPC,DeploymentContext dc,FilePermission fp){\r\n    if (isFilePermforCurrentDir(fp)) {\r\n        addFilePermissionsForCurrentDir(revisedPC, dc, fp);\r\n    } else if (isFilePermforTempDir(fp)) {\r\n        convertTempDirPermission(revisedPC, dc, fp);\r\n    } else {\r\n        revisedPC.add(fp);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.loadbalancer.admin.cli.connection.SSLHostNameVerifier.verify",
	"Comment": "matches the hostname of the load balancer to cn attribute of thecertificate obtained.",
	"Method": "boolean verify(String hostname,SSLSession session){\r\n    if (session != null) {\r\n        Certificate[] certs = null;\r\n        try {\r\n            certs = session.getPeerCertificates();\r\n        } catch (Exception e) {\r\n        }\r\n        if (certs == null) {\r\n            String msg = LbLogUtil.getStringManager().getString(\"NoPeerCert\", hostname);\r\n            LbLogUtil.getLogger().warning(msg);\r\n            return false;\r\n        }\r\n        for (int i = 0; i < certs.length; i++) {\r\n            if (certs[i] instanceof X509Certificate) {\r\n                X500Principal prin = ((X509Certificate) certs[i]).getSubjectX500Principal();\r\n                String hName = null;\r\n                String dn = prin.getName();\r\n                int cnIdx = dn.indexOf(\"CN=\");\r\n                if (cnIdx != -1) {\r\n                    String cnStr = dn.substring(cnIdx, dn.length());\r\n                    int commaIdx = cnStr.indexOf(\",\");\r\n                    if (commaIdx == -1) {\r\n                        commaIdx = dn.length();\r\n                    }\r\n                    hName = dn.substring(cnIdx + 3, commaIdx);\r\n                }\r\n                if (hostname.equals(hName)) {\r\n                    return true;\r\n                }\r\n            } else {\r\n                String msg = LbLogUtil.getStringManager().getString(\"NotX905Cert\", hostname);\r\n                LbLogUtil.getLogger().warning(msg);\r\n            }\r\n        }\r\n        if (hostname.equals(session.getPeerHost())) {\r\n            return true;\r\n        }\r\n    }\r\n    if (session != null) {\r\n        String msg = LbLogUtil.getStringManager().getString(\"NotCertMatch\", hostname, new String(session.getId()));\r\n        LbLogUtil.getLogger().warning(msg);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.j2ee.RegistrationSupport.processApplicationRef",
	"Comment": "examine the mbean to see if it is a resourceref that should be manifested under this server,and if so, register a jsr 77 mbean for it.",
	"Method": "ObjectName processApplicationRef(ApplicationRef ref){\r\n    final ApplicationRegistry appRegistry = J2EEInjectedValues.getInstance().getApplicationRegistry();\r\n    final MetadataImpl meta = new MetadataImpl();\r\n    meta.setCorrespondingRef(getObjectName(ref));\r\n    final String appName = ref.getRef();\r\n    final ApplicationInfo appInfo = appRegistry.get(appName);\r\n    if (appInfo == null) {\r\n        mLogger.fine(\"Unable to get ApplicationInfo for application: \" + appName);\r\n        return null;\r\n    }\r\n    final Application app = appInfo.getMetaData(Application.class);\r\n    if (app == null) {\r\n        if (appInfo.isJavaEEApp()) {\r\n            mLogger.log(Level.WARNING, AMXEELoggerInfo.nullAppinfo, appName);\r\n        }\r\n        return null;\r\n    }\r\n    final com.sun.enterprise.config.serverbeans.Application appConfig = getDomain().getApplications().getApplication(appName);\r\n    if (appConfig == null) {\r\n        mLogger.log(Level.WARNING, AMXEELoggerInfo.errorGetappconfig, appName);\r\n        return null;\r\n    }\r\n    meta.setCorrespondingConfig(getObjectName(appConfig));\r\n    final ObjectName mbean77 = createAppMBeans(appConfig, app, meta);\r\n    synchronized (mConfigRefTo77) {\r\n        mConfigRefTo77.put(getObjectName(ref), mbean77);\r\n    }\r\n    return mbean77;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.setRetainValues",
	"Comment": "sets flag that will not cause the eviction of persistent instances after transaction completion.",
	"Method": "void setRetainValues(boolean flag){\r\n    throw new JDOUnsupportedOptionException(// NOI18N\r\n    I18NHelper.getMessage(messages, \"jdo.persistencemanagerfactoryimpl.notsupported\"));\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getRow",
	"Comment": "retrieves the current row number.the first row is number 1, thesecond number 2, and so on.",
	"Method": "int getRow(){\r\n    return resultSet.getRow();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.NameMapper.getAbstractBeanClassForEjbName",
	"Comment": "gets the name of the abstract bean class which corresponds to the \tspecified ejb name.",
	"Method": "String getAbstractBeanClassForEjbName(String name){\r\n    EjbCMPEntityDescriptor descriptor = getDescriptorForEjbName(name);\r\n    return ((descriptor != null) ? descriptor.getEjbClassName() : null);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.ResourcesUtil.isReferenced",
	"Comment": "returns true if the given resource is referenced by this server.",
	"Method": "boolean isReferenced(ResourceInfo resourceInfo){\r\n    boolean refExists = false;\r\n    if (ConnectorsUtil.isModuleScopedResource(resourceInfo) || ConnectorsUtil.isApplicationScopedResource(resourceInfo)) {\r\n        refExists = getServer().getApplicationRef(resourceInfo.getApplicationName()) != null;\r\n    } else {\r\n        String resourceName = resourceInfo.getName();\r\n        refExists = getServer().isResourceRefExists(resourceName);\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"isReferenced :: \" + resourceInfo + \" - \" + refExists);\r\n    }\r\n    return refExists;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.annotation.handlers.SingletonHandler.createEjbDescriptor",
	"Comment": "create a new ejbdescriptor for a given elementname and annotationinfo.",
	"Method": "EjbDescriptor createEjbDescriptor(String elementName,AnnotationInfo ainfo){\r\n    AnnotatedElement ae = ainfo.getAnnotatedElement();\r\n    Class ejbClass = (Class) ae;\r\n    EjbSessionDescriptor newDescriptor = new EjbSessionDescriptor();\r\n    newDescriptor.setName(elementName);\r\n    newDescriptor.setEjbClassName(ejbClass.getName());\r\n    newDescriptor.setSessionType(EjbSessionDescriptor.SINGLETON);\r\n    doSingletonSpecificProcessing(newDescriptor, ejbClass);\r\n    return newDescriptor;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.CommonHandlers.testExists",
	"Comment": "test if a particular attribute exists. it will look at request scope, then page, then session.",
	"Method": "void testExists(HandlerContext handlerCtx){\r\n    String attr = (String) handlerCtx.getInputValue(\"attr\");\r\n    if (GuiUtil.isEmpty(attr)) {\r\n        handlerCtx.setOutputValue(\"defined\", false);\r\n    } else {\r\n        handlerCtx.setOutputValue(\"defined\", true);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.setSupersedeDeletedInstance",
	"Comment": "sets the supersededeletedinstance flag for this persistencemanager.",
	"Method": "void setSupersedeDeletedInstance(boolean flag){\r\n    _supersedeDeletedInstance = flag;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingClassElementImpl.setPrimaryTable",
	"Comment": "set the primary table for this mapping class to the supplied table.",
	"Method": "void setPrimaryTable(TableElement table){\r\n    ArrayList tables = getTables();\r\n    if (!tables.isEmpty()) {\r\n        throw new ModelException(// NOI18N\r\n        I18NHelper.getMessage(getMessages(), \"mapping.table.primary_table_defined\", table));\r\n    } else {\r\n        UniqueKeyElement key = table.getPrimaryKey();\r\n        MappingTableElement mappingTable = new MappingTableElementImpl(table, this);\r\n        SchemaElement schema = table.getDeclaringSchema();\r\n        String currentRoot = getDatabaseRoot();\r\n        if (currentRoot == null)\r\n            setDatabaseRoot(schema);\r\n        else if (!currentRoot.equals(schema.getName().getFullName())) {\r\n            throw new ModelException(I18NHelper.getMessage(getMessages(), \"mapping.table.schema_mismatch\", table.toString(), currentRoot));\r\n        }\r\n        try {\r\n            fireVetoableChange(PROP_TABLES, null, null);\r\n            tables.add(mappingTable);\r\n            firePropertyChange(PROP_TABLES, null, null);\r\n        } catch (PropertyVetoException e) {\r\n            throw new ModelVetoException(e);\r\n        }\r\n        if (key == null) {\r\n            UniqueKeyElement[] uniqueKeys = table.getUniqueKeys();\r\n            if ((uniqueKeys != null) && (uniqueKeys.length > 0))\r\n                key = uniqueKeys[0];\r\n        }\r\n        if (key == null) {\r\n        } else {\r\n            ColumnElement[] columns = key.getColumns();\r\n            int i, count = ((columns != null) ? columns.length : 0);\r\n            for (i = 0; i < count; i++) mappingTable.addKeyColumn(columns[i]);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ForeignFieldDesc.initializeFieldLists",
	"Comment": "initialize the field lists based on column list information.",
	"Method": "void initializeFieldLists(){\r\n    ClassDesc theConfig = classDesc;\r\n    for (int i = 0; i < 4; i++) {\r\n        ArrayList fields = null;\r\n        ArrayList columns = null;\r\n        switch(i) {\r\n            case 0:\r\n                columns = localColumns;\r\n                fields = getLocalFields();\r\n                break;\r\n            case 1:\r\n                columns = assocLocalColumns;\r\n                fields = getAssocLocalFields();\r\n                break;\r\n            case 2:\r\n                columns = assocForeignColumns;\r\n                fields = getAssocForeignFields();\r\n                break;\r\n            case 3:\r\n                columns = foreignColumns;\r\n                fields = getForeignFields();\r\n                theConfig = foreignConfig;\r\n                break;\r\n        }\r\n        if (columns == null)\r\n            continue;\r\n        for (int j = 0; j < columns.size(); j++) {\r\n            ColumnElement ce = (ColumnElement) columns.get(j);\r\n            TableElement te = ce.getDeclaringTable();\r\n            if (te == null) {\r\n                throw new JDOFatalInternalException(// NOI18N\r\n                I18NHelper.getMessage(messages, \"core.configuration.columnnotable\"));\r\n            }\r\n            fields.add(theConfig.getLocalFieldDesc(ce));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MailConfiguration.getMailStoreProtocolClass",
	"Comment": "get the default message access protocol class for the mail session theserver will provide.",
	"Method": "String getMailStoreProtocolClass(){\r\n    return this.storeProtocolClass;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingReferenceKeyElementImpl.getReferencingKey",
	"Comment": "returns the list of key column names in this referencing key.\tthis method is private since api users should call the \tgetcolumnpairnames method.",
	"Method": "ArrayList getReferencingKey(){\r\n    if (_referencingKey == null)\r\n        _referencingKey = new ArrayList();\r\n    return _referencingKey;\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.ConnectionExecutionContext.getContext",
	"Comment": "this method returns the hashtable that stores the thread specificcontext information.",
	"Method": "Hashtable getContext(){\r\n    if (connCurrent.get() == null) {\r\n        setContext(null);\r\n    }\r\n    return (Hashtable) connCurrent.get();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.StatementWrapper40.executeQuery",
	"Comment": "executes the given sql statement, which returns a singleresultset object.",
	"Method": "java.sql.ResultSet executeQuery(String sql){\r\n    ResultSet rs = jdbcStatement.executeQuery(sql);\r\n    return new ResultSetWrapper40(this, rs);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.EJBBundleInfoHelper.getBundleDescriptor",
	"Comment": "gets the ejbbundledescriptor which defines the universe of\tnames for this application.",
	"Method": "EjbBundleDescriptorImpl getBundleDescriptor(){\r\n    return bundleDescriptor;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.NameMapper.getAbstractSchemaForEjbName",
	"Comment": "gets the name of the abstract schema which corresponds to the \tspecified ejb.",
	"Method": "String getAbstractSchemaForEjbName(String name){\r\n    EjbCMPEntityDescriptor descriptor = getDescriptorForEjbName(name);\r\n    return ((descriptor != null) ? descriptor.getAbstractSchemaName() : null);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ConnectionHolder.getManagedConnection",
	"Comment": "returns the managedconnection instance responsiblefor this connection.",
	"Method": "ManagedConnectionImpl getManagedConnection(){\r\n    return mc;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.forName",
	"Comment": "returns the persistence class element associated with the class with\tthe given string name, using the given model object to look it up.",
	"Method": "PersistenceClassElement forName(String name,Model model){\r\n    return model.getPersistenceClass(name);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingTableElementImpl.addKeyColumn",
	"Comment": "adds a column to the primary key of columns in this mapping table.\tthis method should only be used to manipulate the key columns of the \tprimary table.the secondary table key columns should be manipulated \tusing mappingreferencekeyelement methods for pairs.",
	"Method": "void addKeyColumn(ColumnElement column){\r\n    if (column != null) {\r\n        String columnName = NameUtil.getRelativeMemberName(column.getName().getFullName());\r\n        if (!getKey().contains(columnName))\r\n            addKeyColumnInternal(column);\r\n        else {\r\n        }\r\n    } else {\r\n        throw new ModelException(// NOI18N\r\n        I18NHelper.getMessage(getMessages(), \"mapping.element.null_argument\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingReferenceKeyElementImpl.setReferencingKey",
	"Comment": "set the list of of key column names in this referencing key.this \tmethod should only be used internally and for cloning and archiving.",
	"Method": "void setReferencingKey(ArrayList referencingKey){\r\n    _referencingKey = referencingKey;\r\n}"
}, {
	"Path": "com.sun.gjc.util.SQLTraceCache.scheduleTimerTask",
	"Comment": "schedule timer to perform purgeentries on the cache after thespecified timetokeepqueries delay and period.",
	"Method": "void scheduleTimerTask(Timer timer){\r\n    if (sqlTraceTimerTask != null) {\r\n        sqlTraceTimerTask.cancel();\r\n        sqlTraceTimerTask = null;\r\n    }\r\n    sqlTraceTimerTask = initializeTimerTask();\r\n    if (timer != null) {\r\n        timer.scheduleAtFixedRate(sqlTraceTimerTask, timeToKeepQueries, timeToKeepQueries);\r\n    }\r\n    if (_logger.isLoggable(Level.FINEST)) {\r\n        _logger.finest(\"Scheduled Sql Trace Caching timer task\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.deployment.util.ConnectorArchivist.validate",
	"Comment": "validates the dol objects associated with this archivist, usuallyit requires that a class loader being set on this archivist or passedas a parameter",
	"Method": "void validate(ClassLoader aClassLoader){\r\n    ClassLoader cl = aClassLoader;\r\n    if (cl == null) {\r\n        cl = classLoader;\r\n    }\r\n    if (cl == null) {\r\n        return;\r\n    }\r\n    descriptor.setClassLoader(cl);\r\n    descriptor.visit(connectorValidator);\r\n}"
}, {
	"Path": "org.glassfish.apf.factory.Factory.getDefaultAnnotationProcessor",
	"Comment": "return a empty annotationprocessor with no annotation handlers registered",
	"Method": "AnnotationProcessorImpl getDefaultAnnotationProcessor(){\r\n    return new AnnotationProcessorImpl();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.connector.AdminObjectNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object obj){\r\n    if (obj instanceof ConnectorConfigProperty) {\r\n        adminObject.addConfigProperty((ConnectorConfigProperty) obj);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.ext.BulkImportStartRequest.createExtendedResponse",
	"Comment": "creates an extended response object that corresponds to the ldap bulkimportstart extended request.",
	"Method": "ExtendedResponse createExtendedResponse(String id,byte[] berValue,int offset,int length){\r\n    if ((id != null) && (!id.equals(OID))) {\r\n        throw new ConfigurationException(\"BulkImportStart received the following response instead of \" + OID + \": \" + id);\r\n    }\r\n    return new EmptyExtendedResponse(id);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.optional.DatabaseCommand.checkIfPortIsValid",
	"Comment": "check if database port is valid.derby does not check this so need to add code to check the port number.",
	"Method": "void checkIfPortIsValid(String port){\r\n    try {\r\n        Integer.parseInt(port);\r\n    } catch (NumberFormatException e) {\r\n        throw new CommandValidationException(strings.get(\"InvalidPortNumber\", port));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingRelationshipElementImpl.getElementClass",
	"Comment": "get the element class for this relationship element.if primitive\ttypes are supported, you can use wrapperclass.type\tto specify them.",
	"Method": "String getElementClass(){\r\n    return getRelationshipElement().getElementClass();\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.getEnvironmentPropertyByName",
	"Comment": "returns the environment property object searching on the supplied key.throws an illegal argument exception if no such environment property exists.",
	"Method": "EnvironmentProperty getEnvironmentPropertyByName(String name){\r\n    for (Iterator itr = getEnvironmentProperties().iterator(); itr.hasNext(); ) {\r\n        EnvironmentProperty ev = (EnvironmentProperty) itr.next();\r\n        if (ev.getName().equals(name)) {\r\n            return ev;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"no env-entry of name \" + name);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.ContainerTransaction.equals",
	"Comment": "equality iff the other object is another container transaction with the same transaction attribute.",
	"Method": "boolean equals(Object other){\r\n    if (other != null && other instanceof ContainerTransaction) {\r\n        ContainerTransaction otherContainerTransaction = (ContainerTransaction) other;\r\n        if (otherContainerTransaction.getTransactionAttribute().equals(this.getTransactionAttribute())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.deployapi.config.SunDeploymentConfiguration.getDeployableObject",
	"Comment": "returns an object that provides access tothe deployment descriptor data and classesof a j2ee module.",
	"Method": "DeployableObject getDeployableObject(){\r\n    return deployObject;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceFieldElement.isWriteSensitive",
	"Comment": "determines whether this field element is write sensitive or not.\tthis value is only used if getpersistencetype returns \tderived",
	"Method": "boolean isWriteSensitive(boolean isWriteSensitive){\r\n    return ((getPersistenceType() == DERIVED) && getFieldImpl().isWriteSensitive());\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.copyJarElements",
	"Comment": "copy all contents of a jar file to a new jar file exceptfor all the deployment descriptors files",
	"Method": "void copyJarElements(ReadableArchive in,WritableArchive out,Vector ignoreList){\r\n    Enumeration entries = in.entries();\r\n    if (entries != null) {\r\n        for (; entries.hasMoreElements(); ) {\r\n            String anEntry = (String) entries.nextElement();\r\n            if (ignoreList == null || !ignoreList.contains(anEntry)) {\r\n                InputStream is = in.getEntry(anEntry);\r\n                if (is != null) {\r\n                    OutputStream os = out.putNextEntry(anEntry);\r\n                    ArchivistUtils.copyWithoutClose(is, os);\r\n                    is.close();\r\n                }\r\n                out.closeEntry();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.work.WorkCoordinator.submitWork",
	"Comment": "submits the work to the queue and generates a work accepted event.",
	"Method": "void submitWork(int waitModeValue){\r\n    this.waitMode = waitModeValue;\r\n    this.startTime = System.currentTimeMillis();\r\n    if (listener != null) {\r\n        listener.workAccepted(new WorkEvent(this, WorkEvent.WORK_ACCEPTED, work, null));\r\n    }\r\n    if (probeProvider != null) {\r\n        probeProvider.workSubmitted(raName);\r\n        probeProvider.workQueued(raName);\r\n    }\r\n    queue.addWork(new OneWork(work, this, Thread.currentThread().getContextClassLoader()));\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.DeleteConnectorConnectionPool.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (poolname == null) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.connector.connection.pool.noJndiName\", \"No id defined for connector connection pool.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (ConnectorsUtil.getResourceByName(domain.getResources(), ConnectorConnectionPool.class, poolname) == null) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.connector.connection.pool.notfound\", \"A connector connection pool named {0} does not exist.\", poolname));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        Object obj = deleteAssociatedResources(servers, clusters, domain.getResources(), cascade, poolname);\r\n        if (obj instanceof Integer && (Integer) obj == ResourceStatus.FAILURE) {\r\n            report.setMessage(localStrings.getLocalString(\"delete.connector.connection.pool.pool_in_use\", \"Some connector resources are referencing connection pool {0}. Use 'cascade' \" + \"option to delete them as well.\", poolname));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n        if (ConfigSupport.apply(new SingleConfigCode<Resources>() {\r\n            public Object run(Resources param) throws PropertyVetoException, TransactionFailure {\r\n                ConnectorConnectionPool cp = (ConnectorConnectionPool) ConnectorsUtil.getResourceByName(domain.getResources(), ConnectorConnectionPool.class, poolname);\r\n                if (cp != null) {\r\n                    return param.getResources().remove(cp);\r\n                }\r\n                return null;\r\n            }\r\n        }, domain.getResources()) == null) {\r\n            report.setMessage(localStrings.getLocalString(\"delete.connector.connection.pool.notfound\", \"A connector connection pool named {0} does not exist.\", poolname));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    } catch (TransactionFailure tfe) {\r\n        Logger.getLogger(DeleteConnectorConnectionPool.class.getName()).log(Level.SEVERE, \"Something went wrong in delete-connector-connection-pool\", tfe);\r\n        report.setMessage(tfe.getMessage() != null ? tfe.getLocalizedMessage() : localStrings.getLocalString(\"delete.connector.connection.pool.fail\", \"Connector connection pool {0} delete failed \", poolname));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n    }\r\n    report.setMessage(localStrings.getLocalString(\"delete.connector.connection.pool.success\", \"Connector connection pool {0} deleted successfully\", poolname));\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.DeleteConnectorConnectionPool.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    ConnectorConnectionPool cp = (ConnectorConnectionPool) ConnectorsUtil.getResourceByName(domain.getResources(), ConnectorConnectionPool.class, poolname);\r\n    if (cp != null) {\r\n        return param.getResources().remove(cp);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.enterprise.iiop.util.S1ASThreadPoolManager.getThreadPoolNumericId",
	"Comment": "this method is used to return the numeric id of the threadpool, given a stringthreadpoolid. this is used by the poa interceptors to add the numeric threadpoolid, as a tagged component in the ior. this is used to provide the functionality ofdedicated threadpool for ejb beans",
	"Method": "int getThreadPoolNumericId(String id){\r\n    Integer i = (Integer) idToIndexTable.get(id);\r\n    return ((i == null) ? 0 : i.intValue());\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsStoredProcedures",
	"Comment": "retrieves whether this database supports stored procedure callsthat use the stored procedure escape syntax.",
	"Method": "boolean supportsStoredProcedures(){\r\n    return databaseMetaData.supportsStoredProcedures();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.NameMapper.getKeyClassForEjbName",
	"Comment": "gets the name of the key class which corresponds to the specified \tejb name.",
	"Method": "String getKeyClassForEjbName(String name){\r\n    EjbCMPEntityDescriptor descriptor = getDescriptorForEjbName(name);\r\n    return ((descriptor != null) ? descriptor.getPrimaryKeyClassName() : null);\r\n}"
}, {
	"Path": "com.sun.ejb.containers.BaseContainer.assertValidRemoteObject",
	"Comment": "asserts validity of remotehome objects.this was defined for thej2ee 1.4 implementation and is exposed through container spi.",
	"Method": "void assertValidRemoteObject(Object o){\r\n    boolean valid = false;\r\n    String errorMsg = \"\";\r\n    Exception causeException = null;\r\n    if ((o != null) && (o instanceof EJBObject)) {\r\n        String className = o.getClass().getName();\r\n        if (hasRemoteHomeView) {\r\n            try {\r\n                valid = remoteHomeRefFactory.hasSameContainerID((org.omg.CORBA.Object) o);\r\n            } catch (Exception ex) {\r\n                causeException = ex;\r\n                errorMsg = \"Parameter instance of class '\" + className + \"' is not a valid remote interface instance for bean \" + ejbDescriptor.getName();\r\n            }\r\n        } else {\r\n            errorMsg = \"Parameter instance of class '\" + className + \"' is not a valid remote interface instance for bean \" + ejbDescriptor.getName();\r\n        }\r\n    } else {\r\n        errorMsg = (o != null) ? \"Parameter instance of class '\" + o.getClass().getName() + \"' is not a valid remote interface instance for bean \" + ejbDescriptor.getName() : \"A null parameter is not a valid remote interface of bean \" + ejbDescriptor.getName();\r\n    }\r\n    if (!valid) {\r\n        if (causeException != null) {\r\n            throw new EJBException(errorMsg, causeException);\r\n        } else {\r\n            throw new EJBException(errorMsg);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.Insn.offset",
	"Comment": "return the offset of this instruction in the containing code sequence",
	"Method": "int offset(){\r\n    return insnOffset;\r\n}"
}, {
	"Path": "org.glassfish.loadbalancer.admin.cli.CreateHTTPHealthCheckerCommand.matchLbConfigToTarget",
	"Comment": "returns an array of lbconfigs that has a reference to the targetserver or cluster. if there are no references found for thetarget or the arguments are null, this method returns null.",
	"Method": "List<LbConfig> matchLbConfigToTarget(List<LbConfig> lbConfigs,String target){\r\n    List<LbConfig> list = null;\r\n    if (target == null) {\r\n        String msg = localStrings.getLocalString(\"Nulltarget\", \"Null target\");\r\n        logger.warning(msg);\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setMessage(msg);\r\n        return null;\r\n    }\r\n    if (!lbConfigs.isEmpty()) {\r\n        list = new ArrayList<LbConfig>();\r\n        for (int i = 0; i < lbConfigs.size(); i++) {\r\n            if (tgt.isCluster(target)) {\r\n                ClusterRef cRef = lbConfigs.get(i).getRefByRef(ClusterRef.class, target);\r\n                if (cRef != null) {\r\n                    list.add(lbConfigs.get(i));\r\n                }\r\n            } else if (domain.isServer(target)) {\r\n                ServerRef sRef = lbConfigs.get(i).getRefByRef(ServerRef.class, target);\r\n                if (sRef != null) {\r\n                    list.add(lbConfigs.get(i));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.foundPotentialConnectionLeak",
	"Comment": "fires probe event related to the fact that the given jdbc connection poolhas got a connection leak event.",
	"Method": "void foundPotentialConnectionLeak(){\r\n    poolProbeProvider.potentialConnLeakEvent(poolName, appName, moduleName);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jmac.config.GFServerConfigProvider.getServerAuthConfig",
	"Comment": "get an instance of serverauthconfig from this provider. the implementation of this method returns a serverauthconfiginstance that describes the configuration of serverauthmodulesat a given message layer, and for a particular application context.",
	"Method": "ServerAuthConfig getServerAuthConfig(String layer,String appContext,CallbackHandler handler){\r\n    return new GFServerAuthConfig(this, layer, appContext, handler);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.allTablesAreSelectable",
	"Comment": "retrieves whether the current user can use all the tables returnedby the method gettables in a selectstatement.",
	"Method": "boolean allTablesAreSelectable(){\r\n    return databaseMetaData.allTablesAreSelectable();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getSuperclass",
	"Comment": "returns the name of the superclass for the given class name.",
	"Method": "String getSuperclass(String className){\r\n    Class classElement = (Class) getClass(className);\r\n    if (classElement != null)\r\n        classElement = classElement.getSuperclass();\r\n    return ((classElement != null) ? classElement.getName() : null);\r\n}"
}, {
	"Path": "org.glassfish.jdbc.pool.monitor.JdbcConnPoolStatsProvider.connectionRequestServedEvent",
	"Comment": "event that a connection request is served in timetakeninmillis.",
	"Method": "void connectionRequestServedEvent(String poolName,String appName,String moduleName,long timeTakenInMillis){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (logger.isLoggable(Level.FINEST)) {\r\n            logger.finest(\"Connection request served event received - \" + \"poolName = \" + poolName);\r\n        }\r\n        connRequestWaitTime.setCurrent(timeTakenInMillis);\r\n        totalConnRequestWaitTime.increment(timeTakenInMillis);\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBLocalHomeImpl.createEJBLocalBusinessObjectImpl",
	"Comment": "create a new ejblocalbusinessobjectimpl and new ejb if necessary.",
	"Method": "EJBLocalObjectImpl createEJBLocalBusinessObjectImpl(String intfName){\r\n    return container.createEJBLocalBusinessObjectImpl(intfName);\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.resizer.Resizer.removeInvalidResources",
	"Comment": "removes invalid resource handles in the pool while resizing the pool.uses the connector 1.5 spec 6.5.3.4 optional ra feature to obtaininvalid managedconnections",
	"Method": "void removeInvalidResources(Set<String> freeConnectionsToValidate){\r\n    try {\r\n        debug(\"Sending a set of free connections to RA, \" + \"of size : \" + freeConnectionsToValidate.size());\r\n        int invalidConnectionsCount = 0;\r\n        ResourceHandle handle;\r\n        Set<ResourceHandle> validResources = new HashSet<ResourceHandle>();\r\n        try {\r\n            while ((handle = ds.getResource()) != null) {\r\n                if (freeConnectionsToValidate.contains(handle.toString())) {\r\n                    Set connectionsToTest = new HashSet();\r\n                    connectionsToTest.add(handle.getResource());\r\n                    Set invalidConnections = handler.getInvalidConnections(connectionsToTest);\r\n                    if (invalidConnections != null && invalidConnections.size() > 0) {\r\n                        invalidConnectionsCount = validateAndRemoveResource(handle, invalidConnections);\r\n                    } else {\r\n                        validResources.add(handle);\r\n                    }\r\n                } else {\r\n                    validResources.add(handle);\r\n                }\r\n            }\r\n        } finally {\r\n            for (ResourceHandle resourceHandle : validResources) {\r\n                ds.returnResource(resourceHandle);\r\n            }\r\n            validResources.clear();\r\n            debug(\"No. of invalid connections received from RA : \" + invalidConnectionsCount);\r\n        }\r\n    } catch (ResourceException re) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"ResourceException while trying to get invalid connections from MCF\", re);\r\n        }\r\n    } catch (Exception e) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Exception while trying to get invalid connections from MCF\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.XAResourceImpl.recover",
	"Comment": "obtain a list of prepared transaction branches from a resource manager.",
	"Method": "Xid[] recover(int flag){\r\n    return xar.recover(flag);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.BundleDescriptor.getNamedReferencePairsFrom",
	"Comment": "utility method for iterating the set of namereference pairs in the supplied nameenvironment",
	"Method": "Vector<NamedReferencePair> getNamedReferencePairsFrom(JndiNameEnvironment nameEnvironment){\r\n    Vector<NamedReferencePair> pairs = new Vector<NamedReferencePair>();\r\n    for (Iterator itr = nameEnvironment.getResourceReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        ResourceReferenceDescriptor resourceReference = (ResourceReferenceDescriptor) itr.next();\r\n        pairs.add(NamedReferencePair.createResourceRefPair((Descriptor) nameEnvironment, resourceReference));\r\n    }\r\n    for (Iterator itr = nameEnvironment.getEjbReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        EjbReferenceDescriptor ejbReference = (EjbReferenceDescriptor) itr.next();\r\n        pairs.add(NamedReferencePair.createEjbRefPair((Descriptor) nameEnvironment, ejbReference));\r\n    }\r\n    for (Iterator itr = nameEnvironment.getResourceEnvReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        ResourceEnvReferenceDescriptor resourceEnvRef = (ResourceEnvReferenceDescriptor) itr.next();\r\n        pairs.add(NamedReferencePair.createResourceEnvRefPair((Descriptor) nameEnvironment, resourceEnvRef));\r\n    }\r\n    return pairs;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.connection.ConnectionManager.toString",
	"Comment": "returns a string representation of the current connectionmanager object.",
	"Method": "String toString(){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.SunContainerHelper.preSelect",
	"Comment": "called in a cmp supported environment. notifies the container thatejbselect had been called.this is suncontainerhelper specific code.",
	"Method": "void preSelect(Object container){\r\n    ((Container) container).preSelect();\r\n}"
}, {
	"Path": "org.glassfish.kernel.javaee.WebContainerStarter.postConstruct",
	"Comment": "scans the domain.xml to see if it specifies any configurationthat can be handled only by the web container, and if so, startsthe web container",
	"Method": "void postConstruct(){\r\n    domainProvider.get();\r\n    Config serverConfig = serverConfigProvider.get();\r\n    boolean isStartNeeded = false;\r\n    if (serverConfig != null) {\r\n        if (isStartNeeded(serverConfig.getHttpService())) {\r\n            isStartNeeded = true;\r\n        }\r\n        if (!isStartNeeded && isStartNeeded(serverConfig.getNetworkConfig())) {\r\n            isStartNeeded = true;\r\n        }\r\n    }\r\n    if (isStartNeeded) {\r\n        startWebContainer();\r\n    } else {\r\n        ObservableBean bean = (ObservableBean) ConfigSupport.getImpl(serverConfig.getHttpService());\r\n        bean.addListener(this);\r\n        bean = (ObservableBean) ConfigSupport.getImpl(serverConfig.getNetworkConfig().getNetworkListeners());\r\n        bean.addListener(this);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.getQuoteCharEnd",
	"Comment": "returns the end identifier quote character for this database, oran empty string, if there is none.",
	"Method": "String getQuoteCharEnd(){\r\n    String s = (String) dbMap.get(QUOTE_CHAR_END);\r\n    if (s == null)\r\n        s = NONE;\r\n    if (logger.isLoggable()) {\r\n        logger.fine(\"sqlstore.database.dbvendor.getquotecharend\", s);\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.SunContainerHelper.assertValidRemoteObject",
	"Comment": "verify that this instance is of a valid remote interface type fora given container helper.this is suncontainerhelper specific code.",
	"Method": "void assertValidRemoteObject(Object o,Object container){\r\n    ((Container) container).assertValidRemoteObject(o);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.StatementWrapper.getResultSetHoldability",
	"Comment": "retrieves the result set holdability for resultset objectsgenerated by this statement object.",
	"Method": "int getResultSetHoldability(){\r\n    return jdbcStatement.getResultSetHoldability();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsDataDefinitionAndDataManipulationTransactions",
	"Comment": "retrieves whether this database supports both data definition anddata manipulation statements within a transaction.",
	"Method": "boolean supportsDataDefinitionAndDataManipulationTransactions(){\r\n    return databaseMetaData.supportsDataDefinitionAndDataManipulationTransactions();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.EjbIORConfigurationDescriptor.setConfidentiality",
	"Comment": "set the value of the confidentiality element to the specified value.",
	"Method": "void setConfidentiality(String val){\r\n    if (!val.equalsIgnoreCase(NONE) && !val.equalsIgnoreCase(SUPPORTED) && !val.equalsIgnoreCase(REQUIRED)) {\r\n        throw new RuntimeException(\"Incorrect value for confidentiality:\" + val);\r\n    }\r\n    confidentiality = val;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.generator.io.IOJavaClassWriter.addInterface",
	"Comment": "adds an interface to the list of those implemented by this class.",
	"Method": "void addInterface(String name){\r\n    if (!StringHelper.isEmpty(name))\r\n        _interfaces.add(name);\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.NestedAppClientDeployerHelper.relativeToFacade",
	"Comment": "computes a relative uri within the downloaded file directorystructure for the specified jar uri.",
	"Method": "URI relativeToFacade(URI absJARURI){\r\n    final URI jarRelOnServer = earURI.relativize(absJARURI);\r\n    final StringBuilder dotsFromFacadeToAnchor = new StringBuilder();\r\n    final String clientWithinApp = pathToAppclientWithinApp(dc());\r\n    int slot = -1;\r\n    while ((slot = clientWithinApp.indexOf('/', slot + 1)) != -1) {\r\n        dotsFromFacadeToAnchor.append(\"../\");\r\n    }\r\n    return URI.create(dotsFromFacadeToAnchor.append(jarRelOnServer.toASCIIString()).toString());\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingReferenceKeyElementImpl.setColumnPairs",
	"Comment": "set the column pairs for this holder.\tprevious column pairs are removed.",
	"Method": "void setColumnPairs(ColumnPairElement[] pairs){\r\n    removeColumnPairs(getColumnPairNames());\r\n    addColumnPairs(pairs);\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecServerRequestInterceptor.createCompleteEstablishContext",
	"Comment": "create a completeestablishcontext message. this currently works onlyfor the gssup mechanism.",
	"Method": "SASContextBody createCompleteEstablishContext(int status){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"Creating CompleteEstablishContext message\");\r\n    }\r\n    byte[] final_context_token = {};\r\n    CompleteEstablishContext cec = new CompleteEstablishContext(0, false, final_context_token);\r\n    SASContextBody sasctxtbody = new SASContextBody();\r\n    sasctxtbody.complete_msg(cec);\r\n    return sasctxtbody;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.XMLElement.getPrefixURIMapping",
	"Comment": "map a prefix to a namespaceuri based on the namespace contextof this xml element.",
	"Method": "String getPrefixURIMapping(String prefixToResolve){\r\n    return ((namespaces != null) && (prefixToResolve != null)) ? namespaces.getURI(prefixToResolve) : null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.TypeSupport.isNumberType",
	"Comment": "returns true if type is a numertype, which means it is eithera numeric primitive or a numeric wrapper class.",
	"Method": "boolean isNumberType(Object type){\r\n    return isNumericType(type) || isNumericWrapperType(type) || bigDecimalType.equals(type) || bigIntegerType.equals(type);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.SaxParserHandlerBundled.openDTDSource",
	"Comment": "returns an inputstream for the dtd with the requested public id.",
	"Method": "InputSource openDTDSource(String publicID){\r\n    return openInputSource(BUNDLED_DTD_ROOT, getMapping().get(publicID));\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecurityMechanismSelector.sendUsernameAndPassword",
	"Comment": "get the security context to send username and password in theservice context.",
	"Method": "SecurityContext sendUsernameAndPassword(ComponentInvocation ci,boolean sslUsed,boolean clientAuthOccurred,CompoundSecMech mechanism){\r\n    SecurityContext ctx = null;\r\n    if (mechanism == null) {\r\n        return null;\r\n    }\r\n    AS_ContextSec asContext = mechanism.as_context_mech;\r\n    if (isSet(asContext.target_requires, EstablishTrustInClient.value) || (isSet(mechanism.target_requires, EstablishTrustInClient.value) && !clientAuthOccurred)) {\r\n        ctx = getUsernameAndPassword(ci, mechanism);\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Sending Username/Password\");\r\n        }\r\n    } else {\r\n        return null;\r\n    }\r\n    return ctx;\r\n}"
}, {
	"Path": "org.glassfish.resources.module.ResourcesContainer.getName",
	"Comment": "returns a human readable name for this container, this name is not used foridentifying the container but can be used to display messages belonging tothe container.",
	"Method": "String getName(){\r\n    return ResourceConstants.GF_RESOURCES_MODULE;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.handlers.ResourceHandler.getMessageDestinationReferenceDescriptors",
	"Comment": "return messagedestinationreferencedescriptors with given name if exists or a new one without name being set.",
	"Method": "MessageDestinationReferenceDescriptor[] getMessageDestinationReferenceDescriptors(String logicName,ResourceContainerContext[] rcContexts){\r\n    MessageDestinationReferenceDescriptor[] msgDestRefs = new MessageDestinationReferenceDescriptor[rcContexts.length];\r\n    for (int i = 0; i < rcContexts.length; i++) {\r\n        MessageDestinationReferenceDescriptor msgDestRef = rcContexts[i].getMessageDestinationReference(logicName);\r\n        if (msgDestRef == null) {\r\n            msgDestRef = new MessageDestinationReferenceDescriptor();\r\n            rcContexts[i].addMessageDestinationReferenceDescriptor(msgDestRef);\r\n        }\r\n        msgDestRefs[i] = msgDestRef;\r\n    }\r\n    return msgDestRefs;\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.jws.AppClientHTTPAdapter.prepareRequestPlaceholders",
	"Comment": "initializes a properties object with the token names and values forsubstitution in the dynamic content template.",
	"Method": "Properties prepareRequestPlaceholders(Properties adapterTokens,Request request){\r\n    final Properties answer = new Properties(adapterTokens);\r\n    answer.setProperty(\"request.scheme\", request.getScheme());\r\n    answer.setProperty(\"request.host\", request.getServerName());\r\n    answer.setProperty(\"request.port\", Integer.toString(request.getServerPort()));\r\n    answer.setProperty(\"request.adapter.context.root\", contextRoot());\r\n    answer.setProperty(\"request.glassfish-acc.xml.content\", Util.toXMLEscaped(accConfigContent.sunACC()));\r\n    answer.setProperty(\"request.appclient.login.conf.content\", Util.toXMLEscaped(accConfigContent.appClientLogin()));\r\n    answer.setProperty(\"request.message.security.config.provider.security.config\", Util.toXMLEscaped(accConfigContent.securityConfig()));\r\n    answer.setProperty(\"loader.config\", Util.toXMLEscaped(loaderConfigContent.content()));\r\n    final String queryString = request.getQueryString();\r\n    final StringBuilder queryStringPropValue = new StringBuilder();\r\n    if (queryString != null && queryString.length() > 0) {\r\n        queryStringPropValue.append(\"?\").append(queryString);\r\n    }\r\n    answer.setProperty(\"request.quoted.query.string\", Util.toXMLEscapedInclAmp(queryStringPropValue.toString()));\r\n    processQueryParameters(queryString, answer);\r\n    return answer;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.getFromPool",
	"Comment": "returns an instance of persistencemanagerimpl from available poolor creates a new one",
	"Method": "PersistenceManagerImpl getFromPool(javax.transaction.Transaction tx,String username,char[] password){\r\n    boolean debug = logger.isLoggable(Logger.FINEST);\r\n    if (debug) {\r\n        logger.finest(\"sqlstore.sqlpersistencemgrfactory.getfrompool\");\r\n    }\r\n    synchronized (this) {\r\n        if (_store == null) {\r\n            initializeSQLStoreManager(username, password);\r\n        }\r\n    }\r\n    PersistenceManagerImpl pm = new PersistenceManagerImpl(this, tx, username, password);\r\n    pm.setStore(_store);\r\n    if (debug) {\r\n        Object[] items = new Object[] { pm, tx };\r\n        logger.finest(\"sqlstore.sqlpersistencemgrfactory.getfrompool.pmt\", items);\r\n    }\r\n    return pm;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.XAResourceImpl.rollback",
	"Comment": "inform the resource manager to roll back work done on behalf of a transaction branch",
	"Method": "void rollback(Xid xid){\r\n    mc.transactionCompleted();\r\n    xar.rollback(xid);\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.ctl.VirtualListViewResponseControl.getException",
	"Comment": "retrieves the namingexception appropriate for the result code.",
	"Method": "NamingException getException(){\r\n    return LdapCtx.mapErrorCode(resultCode, null);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.removeRole",
	"Comment": "removes the given org.glassfish.security.common.role object from me.",
	"Method": "void removeRole(Role role){\r\n    if (super.getRoles().contains(role)) {\r\n        for (Iterator itr = getEjbs().iterator(); itr.hasNext(); ) {\r\n            EjbDescriptor ejbDescriptor = (EjbDescriptor) itr.next();\r\n            ejbDescriptor.removeRole(role);\r\n        }\r\n        super.removeRole(role);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.PreparedStatementWrapper.setArray",
	"Comment": "sets the designated parameter to the given array object.the driver converts this to an sql array value when itsends it to the database.",
	"Method": "void setArray(int i,Array x){\r\n    preparedStatement.setArray(i, x);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.getUpdateTimeout",
	"Comment": "gets the number of seconds to wait for an update statementto execute in the datastore associated with this persistencemanagerfactory.",
	"Method": "int getUpdateTimeout(){\r\n    return updateTimeout;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.DeploymentDescriptorNode.writeSimpleTextDescriptor",
	"Comment": "write out simple text element based on the node nameto an jaxp dom node and return itthis api will be invoked by the parent node when the parent nodewrites out a mix of statically and dynamically registered sub nodes.and this api is to write out the simple text sub element that theparent node handles itself.this method should be overriden by the sub classes if itneeds to be called by the parent node.",
	"Method": "Node writeSimpleTextDescriptor(Node parent,String nodeName,Descriptor parentDesc){\r\n    return parent;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConfigurationParserServiceImpl.getMessageListenerTypes",
	"Comment": "parses the ra.xml and returns all the message listener types.",
	"Method": "String[] getMessageListenerTypes(String rarName){\r\n    ConnectorDescriptor desc = getConnectorDescriptor(rarName);\r\n    if (desc != null) {\r\n        MessageListenerConfigParser messagelistenerConfigParser = (MessageListenerConfigParser) ConnectorConfigParserFactory.getParser(ConnectorConfigParser.MSL);\r\n        return messagelistenerConfigParser.getMessageListenerTypes(desc);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.connection.ConnectionManager.startUp",
	"Comment": "starts up this connectionmanager by loading the properjdbc driver class and initializing the pool if necessary.you need to call this method if you are using the connectionmanageras a component, or if you use the default constructor and set theattributes via the setxxx methods.",
	"Method": "void startUp(){\r\n    if (this.initialized == true)\r\n        return;\r\n    this.busyList = new DoubleLinkedList();\r\n    this.xactConnections = new Hashtable();\r\n    this.expandedDriverName = this.expandAttribute(this.driverName);\r\n    if (this.expandedDriverName == null) {\r\n        SQLException se = new SQLException(StringScanner.createParamString(// NOI18N\r\n        I18NHelper.getMessage(messages, \"connection.connectionmanager.nulldriver\")), SQL_INVALID_VALUE);\r\n        throw se;\r\n    }\r\n    this.expandedUrl = this.expandAttribute(this.url);\r\n    if (this.expandedUrl == null) {\r\n        SQLException se = new SQLException(StringScanner.createParamString(// NOI18N\r\n        I18NHelper.getMessage(messages, \"connection.connectionmanager.nullurl\")), SQL_INVALID_VALUE);\r\n        throw se;\r\n    }\r\n    this.expandedUserName = this.expandAttribute(this.userName);\r\n    if (this.expandedUserName == null) {\r\n        this.expandedUserName = \"\";\r\n    }\r\n    this.expandedPassword = this.expandAttribute(new String(this.password));\r\n    if (this.expandedPassword == null) {\r\n        this.expandedPassword = \"\";\r\n    }\r\n    try {\r\n        Class.forName(this.expandedDriverName);\r\n        if ((this.minPool > 0) && (this.maxPool >= this.minPool)) {\r\n            this.pooling = true;\r\n            this.freeList = new DoubleLinkedList();\r\n            expandPool(this.minPool);\r\n        } else if ((this.minPool == 0) && (this.maxPool == 0)) {\r\n            this.pooling = false;\r\n        }\r\n    } catch (SQLException se) {\r\n        throw se;\r\n    } catch (ClassNotFoundException e) {\r\n        throw e;\r\n    }\r\n    this.initialized = true;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsGroupByUnrelated",
	"Comment": "retrieves whether this database supports using a column that isnot in the select statement in agroup by clause.",
	"Method": "boolean supportsGroupByUnrelated(){\r\n    return databaseMetaData.supportsGroupByUnrelated();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.perms.XMLPermissionsHandler.checkServerRestrictedPermissions",
	"Comment": "check the app declared permissions against server restricted policy",
	"Method": "void checkServerRestrictedPermissions(){\r\n    if (this.declaredPermXml == null)\r\n        return;\r\n    if (compType == null)\r\n        return;\r\n    SMGlobalPolicyUtil.checkRestrictionOfComponentType(declaredPermXml, this.compType);\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBContainerTransactionManager.postInvokeTx",
	"Comment": "handle transaction requirements, if any, after invoking bean method",
	"Method": "void postInvokeTx(EjbInvocation inv){\r\n    Throwable exception = inv.exception;\r\n    if (container.resumeTransaction(inv)) {\r\n        if (inv.clientTx != null) {\r\n            transactionManager.resume(inv.clientTx);\r\n        }\r\n        if (inv.exception != null && inv.exception instanceof BaseContainer.PreInvokeException) {\r\n            inv.exception = ((BaseContainer.PreInvokeException) exception).exception;\r\n        }\r\n        return;\r\n    }\r\n    EJBContextImpl context = (EJBContextImpl) inv.context;\r\n    int status = transactionManager.getStatus();\r\n    int txAttr = inv.invocationInfo.txAttr;\r\n    Throwable newException = exception;\r\n    switch(txAttr) {\r\n        case Container.TX_BEAN_MANAGED:\r\n            newException = checkExceptionBeanMgTx(context, exception, status);\r\n            if (inv.clientTx != null) {\r\n                transactionManager.resume(inv.clientTx);\r\n            }\r\n            break;\r\n        case Container.TX_NOT_SUPPORTED:\r\n        case Container.TX_NEVER:\r\n            if (exception != null) {\r\n                newException = checkExceptionNoTx(context, exception);\r\n            }\r\n            container.postInvokeNoTx(inv);\r\n            if (inv.clientTx != null) {\r\n                transactionManager.resume(inv.clientTx);\r\n            }\r\n            break;\r\n        case Container.TX_MANDATORY:\r\n            if (exception != null) {\r\n                newException = checkExceptionClientTx(context, exception);\r\n            }\r\n            break;\r\n        case Container.TX_REQUIRED:\r\n            if (inv.clientTx == null) {\r\n                newException = completeNewTx(context, exception, status);\r\n            } else {\r\n                if (exception != null) {\r\n                    newException = checkExceptionClientTx(context, exception);\r\n                }\r\n            }\r\n            break;\r\n        case Container.TX_REQUIRES_NEW:\r\n            newException = completeNewTx(context, exception, status);\r\n            if (inv.clientTx != null) {\r\n                transactionManager.resume(inv.clientTx);\r\n            }\r\n            break;\r\n        case Container.TX_SUPPORTS:\r\n            if (status != Status.STATUS_NO_TRANSACTION) {\r\n                if (exception != null) {\r\n                    newException = checkExceptionClientTx(context, exception);\r\n                }\r\n            } else {\r\n                if (exception != null) {\r\n                    newException = checkExceptionNoTx(context, exception);\r\n                }\r\n                container.postInvokeNoTx(inv);\r\n            }\r\n            break;\r\n        default:\r\n    }\r\n    inv.exception = newException;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.FieldAction.setMethodSig",
	"Comment": "return the type signature of the static method on class genericobjectwhich will set the field value.",
	"Method": "String setMethodSig(){\r\n    return fieldTypeInfo.fieldSetMethodSig;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.retrieveFromVersionConsistencyCache",
	"Comment": "initialize this sm from the version consistency cache. if thissm is in the cache and the additional field is not populated,the field is retrieved from the store.",
	"Method": "boolean retrieveFromVersionConsistencyCache(FieldDesc additionalField){\r\n    boolean rc = persistenceManager.initializeFromVersionConsistencyCache(this);\r\n    if (rc) {\r\n        if (additionalField != null && !getPresenceMaskBit(additionalField.absoluteID)) {\r\n            realizeField(additionalField);\r\n        }\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxCatalogNameLength",
	"Comment": "retrieves the maximum number of characters that this database allows in acatalog name.",
	"Method": "int getMaxCatalogNameLength(){\r\n    return databaseMetaData.getMaxCatalogNameLength();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.getDatabaseValidationList",
	"Comment": "computes and returns a collection of validationcomponents \trepresenting the database tests to be performed.",
	"Method": "Collection getDatabaseValidationList(){\r\n    ArrayList list = new ArrayList();\r\n    String className = getClassName();\r\n    MappingClassElement mappingClass = getMappingClass(className);\r\n    if (mappingClass != null) {\r\n        ArrayList tables = mappingClass.getTables();\r\n        int i, count = ((tables != null) ? tables.size() : 0);\r\n        MappingTableElement primaryTable = null;\r\n        Iterator iterator = null;\r\n        list.add(createSchemaExistenceComponent(className));\r\n        for (i = 0; i < count; i++) {\r\n            MappingTableElement nextTable = (MappingTableElement) tables.get(i);\r\n            list.add(createTableExistenceComponent(nextTable.getTable()));\r\n            if (i == 0) {\r\n                primaryTable = nextTable;\r\n                list.add(createPrimaryTableComponent(primaryTable));\r\n            } else {\r\n                MappingReferenceKeyElement referenceKey = findReferenceKey(primaryTable, nextTable);\r\n                if (referenceKey != null) {\r\n                    iterator = referenceKey.getColumnPairNames().iterator();\r\n                    while (iterator.hasNext()) {\r\n                        list.add(createColumnExistenceComponent((String) iterator.next()));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        list.add(createVersionConsistencyComponent(mappingClass));\r\n        iterator = mappingClass.getFields().iterator();\r\n        while (iterator.hasNext()) {\r\n            MappingFieldElement nextField = (MappingFieldElement) iterator.next();\r\n            ArrayList allColumns = new ArrayList();\r\n            Iterator columnIterator = null;\r\n            if (isRelationship(nextField)) {\r\n                allColumns.addAll(((MappingRelationshipElement) nextField).getAssociatedColumns());\r\n            }\r\n            allColumns.addAll(nextField.getColumns());\r\n            columnIterator = allColumns.iterator();\r\n            while (columnIterator.hasNext()) {\r\n                list.add(createColumnExistenceComponent((String) columnIterator.next(), nextField));\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.resetConnectionProperties",
	"Comment": "resett connection properties as connections are pooled by application server",
	"Method": "void resetConnectionProperties(ManagedConnectionFactoryImpl spiMCF){\r\n    if (isClean) {\r\n        spiMCF.resetIsolation(this, lastTransactionIsolationLevel);\r\n        resetAutoCommit();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jauth.HttpServletAuthParam.getOperation",
	"Comment": "get the operation related to the encapsulated http servletrequest and response objects.",
	"Method": "String getOperation(){\r\n    return null;\r\n}"
}, {
	"Path": "admin.NodeTest.arrayToMap",
	"Comment": "converts an array where the first item is thefirst key, the second item is the first value, etc.into a map.",
	"Method": "Map<String, String> arrayToMap(String[] a){\r\n    Map<String, String> results = new HashMap<String, String>();\r\n    for (int i = 0; i < a.length; ) {\r\n        results.put(a[i], a[i + 1]);\r\n        i += 2;\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getRoleReferenceByName",
	"Comment": "returns a matching role reference by name or throw an illegalargumentexception.",
	"Method": "RoleReference getRoleReferenceByName(String roleReferenceName){\r\n    for (Iterator itr = this.getRoleReferences().iterator(); itr.hasNext(); ) {\r\n        RoleReference nextRR = (RoleReference) itr.next();\r\n        if (nextRR.getName().equals(roleReferenceName)) {\r\n            return nextRR;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.registerCreateDependency",
	"Comment": "the referred object has to be written to the store before therelationship can be set.to ensure referentional integrityconstraints in the database, the added object has to be writtento the store, before the relationship can be set. the samedependency applies for relationships mapped to a jointable.",
	"Method": "void registerCreateDependency(ForeignFieldDesc inverseFieldDesc,SQLStateManager addedSM){\r\n    if (!addedSM.state.isPersistentInDataStore()) {\r\n        addedSM.addUpdatedForeignReference(inverseFieldDesc, this);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.mejb.IIOPMBeanServerImpl.getAttribute",
	"Comment": "gets the value of a specific attribute of a named mbean. the mbean is identified by its object name.",
	"Method": "Object getAttribute(ObjectName name,String attribute){\r\n    return server.getAttribute(name, attribute);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.RuntimeBundleNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object descriptor){\r\n    return;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.generator.JavaClassWriterHelper.getPrimitiveType",
	"Comment": "returns name of the primitive type corresponding tothe object wrapper class passed as a parameter.if the parameter is of primitive type, its name isreturned.",
	"Method": "String getPrimitiveType(Class cls){\r\n    String rc = getPrimitiveName(cls);\r\n    if (rc == null) {\r\n        rc = cls.getName();\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnectionMetaData.getEISProductName",
	"Comment": "returns product name of the underlying eis instance connectedthrough the managedconnection.",
	"Method": "String getEISProductName(){\r\n    try {\r\n        return dmd.getDatabaseProductName();\r\n    } catch (SQLException sqle) {\r\n        _logger.log(Level.SEVERE, \"jdbc.exc_eis_prodname\", sqle);\r\n        throw new ResourceException(sqle.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnectionMetaData.getUserName",
	"Comment": "returns name of the user associated with the managedconnection instance. the namecorresponds to the resource principal under whose whose security context, a connectionto the eis instance has been established.",
	"Method": "String getUserName(){\r\n    javax.resource.spi.security.PasswordCredential pc = mc.getPasswordCredential();\r\n    if (pc != null) {\r\n        return pc.getUserName();\r\n    }\r\n    return mc.getManagedConnectionFactory().getUser();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getCharacterStream",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object as ajava.io.reader object.",
	"Method": "Reader getCharacterStream(int columnIndex,Reader getCharacterStream,String columnName){\r\n    return resultSet.getCharacterStream(columnName);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.util.ClassFileSource.getOutputStream",
	"Comment": "get a dataoutputstream to which a class file should be written.the caller must close the output stream when complete.",
	"Method": "DataOutputStream getOutputStream(File dest){\r\n    return new DataOutputStream(new BufferedOutputStream(new FileOutputStream(dest)));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlTimestamp.setHours",
	"Comment": "sets the hour of this sqltimestamp object to the specified value.",
	"Method": "void setHours(int hours){\r\n    this.makeDirty();\r\n    super.setHours(hours);\r\n}"
}, {
	"Path": "com.sun.ejb.base.stats.StatefulSessionStoreStatsImpl.getPassivationCount",
	"Comment": "returns the total number of sessions passivated using this store",
	"Method": "CountStatistic getPassivationCount(){\r\n    synchronized (passivationCountLock) {\r\n        passivationCount.setCount(passivationCountVal);\r\n        return (CountStatistic) passivationSuccessCount.unmodifiableView();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnUtils.floatConstant",
	"Comment": "return the best instruction for loading the specified float constant ontothe stack.",
	"Method": "Insn floatConstant(float f,ConstantPool pool){\r\n    if (f == 0)\r\n        return Insn.create(opc_fconst_0);\r\n    else if (f == 1)\r\n        return Insn.create(opc_fconst_1);\r\n    else if (f == 2)\r\n        return Insn.create(opc_fconst_2);\r\n    else\r\n        return Insn.create(opc_ldc, pool.addFloat(f));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.jqlc.VariableTable.markUsed",
	"Comment": "mark the specified variable as used. the method sets the info field of the varinfo object to true.",
	"Method": "void markUsed(JQLAST variable,String dependendVar){\r\n    String name = variable.getText();\r\n    VarInfo entry = (VarInfo) varInfos.get(name);\r\n    if (entry == null)\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jqlc.variabletable.markused.varnotfound\", name));\r\n    entry.used.add(variable);\r\n    if (dependendVar != null) {\r\n        VarInfo dependendVarInfo = (VarInfo) varInfos.get(dependendVar);\r\n        if (dependendVarInfo.dependsOn != null)\r\n            throw new JDOFatalInternalException(// NOI18N\r\n            I18NHelper.getMessage(messages, \"jqlc.variabletable.markused.multidep\", dependendVar, dependendVarInfo.dependsOn, name));\r\n        dependendVarInfo.dependsOn = name;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.ArrayList.retainAll",
	"Comment": "retains only the elements in this arraylist that are contained in thespecified collection.",
	"Method": "boolean retainAll(Collection c){\r\n    boolean modified = false;\r\n    java.util.Vector v = new java.util.Vector();\r\n    StateManager stateManager = this.makeDirty();\r\n    for (Iterator iter = super.iterator(); iter.hasNext(); ) {\r\n        Object o = iter.next();\r\n        if (!c.contains(o)) {\r\n            v.add(o);\r\n            if (added.remove(o) == false)\r\n                removed.add(o);\r\n            modified = true;\r\n        }\r\n    }\r\n    for (Iterator iter = v.iterator(); iter.hasNext(); ) {\r\n        removeInternal(iter.next());\r\n    }\r\n    this.applyUpdates(stateManager, modified);\r\n    return modified;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.AbstractBundleNode.addBundleNodeAttributes",
	"Comment": "write the necessary attributes for the root node of this dds document",
	"Method": "void addBundleNodeAttributes(Element bundleNode,RootDeploymentDescriptor descriptor){\r\n    String schemaLocation;\r\n    schemaLocation = TagNames.JAVAEE_NAMESPACE + \" \" + getSchemaURL();\r\n    bundleNode.setAttributeNS(\"http://www.w3.org/2000/xmlns/\", \"xmlns:xsi\", W3C_XML_SCHEMA_INSTANCE);\r\n    addNamespaceDeclaration(bundleNode, descriptor);\r\n    bundleNode.setAttributeNS(W3C_XML_SCHEMA_INSTANCE, SCHEMA_LOCATION_TAG, schemaLocation);\r\n    bundleNode.setAttribute(TagNames.VERSION, getSpecVersion());\r\n    if (descriptor instanceof BundleDescriptor && !(descriptor instanceof Application)) {\r\n        BundleDescriptor bundleDesc = (BundleDescriptor) descriptor;\r\n        if (!bundleDesc.isDDWithNoAnnotationAllowed()) {\r\n            bundleNode.setAttribute(TagNames.METADATA_COMPLETE, \"true\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingMemberElementImpl.setDeclaringClass",
	"Comment": "set the declaring class of this mapping member.this method should \tonly be used internally and for cloning and archiving.",
	"Method": "void setDeclaringClass(MappingClassElement declaringClass){\r\n    _declaringClass = declaringClass;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.jdbc.JDBCRealm.getGroupNames",
	"Comment": "returns the name of all the groups that this user belongs to.it loads the result from groupcache first.this is called from web path group verification, thoughit should not be.",
	"Method": "Enumeration getGroupNames(String username){\r\n    Vector vector = groupCache.get(username);\r\n    if (vector == null) {\r\n        String[] grps = findGroups(username);\r\n        setGroupNames(username, grps);\r\n        vector = groupCache.get(username);\r\n    }\r\n    return vector.elements();\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.listener.UnpooledConnectionEventListener.badConnectionClosed",
	"Comment": "resource adapters will signal that the connection being closed is bad.",
	"Method": "void badConnectionClosed(ConnectionEvent evt){\r\n    ManagedConnection mc = (ManagedConnection) evt.getSource();\r\n    mc.removeConnectionEventListener(this);\r\n    connectionClosed(evt);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOCodeGenerator.getFileInfoOfInputFile",
	"Comment": "returns a string consisting of the fully path and name of the input fileand its length in bytes.",
	"Method": "String getFileInfoOfInputFile(String pathname){\r\n    File inputFile = new File(pathname);\r\n    StringBuffer inputFileInfo = new StringBuffer().append(inputFile.getCanonicalPath().replace('\\\\', '/')).append(CMPTemplateFormatter.space_).append(String.valueOf(inputFile.length())).append(\" bytes\");\r\n    return inputFileInfo.toString();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jmac.config.GFAuthConfigFactory.getDefaultProviders",
	"Comment": "contains the default providers used when none areconfigured in a factory configuration file.",
	"Method": "List<EntryInfo> getDefaultProviders(){\r\n    WebServicesDelegate delegate = null;\r\n    SecurityServicesUtil svcUtil = SecurityServicesUtil.getInstance();\r\n    if (svcUtil != null) {\r\n        delegate = svcUtil.getHabitat().getService(WebServicesDelegate.class);\r\n    }\r\n    if (delegate != null) {\r\n        List<EntryInfo> entries = new ArrayList<EntryInfo>(2);\r\n        entries.add(new EntryInfo(delegate.getDefaultWebServicesProvider(), null));\r\n        entries.add(new EntryInfo(GFServerConfigProvider.class.getName(), null));\r\n        return entries;\r\n    }\r\n    List<EntryInfo> entries = new ArrayList<EntryInfo>(1);\r\n    entries.add(new EntryInfo(GFServerConfigProvider.class.getName(), null));\r\n    return entries;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.nullsAreSortedAtStart",
	"Comment": "retrieves whether null values are sorted at the start regardlessof sort order.",
	"Method": "boolean nullsAreSortedAtStart(){\r\n    return databaseMetaData.nullsAreSortedAtStart();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorConnectionPool.setTransactionSupport",
	"Comment": "sets the transaction support level for this poolthe valid values are",
	"Method": "void setTransactionSupport(int transactionSupport){\r\n    transactionSupport_ = transactionSupport;\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.obj.LdapGroupFactory.getName",
	"Comment": "builds a fully distinguished name from a context and relative name.",
	"Method": "String getName(Context ctx,Name name){\r\n    String suffix = ctx.getNameInNamespace();\r\n    String prefix = name.toString();\r\n    if (prefix.equals(\"\")) {\r\n        return suffix;\r\n    } else if (suffix == null || suffix.equals(\"\")) {\r\n        return prefix;\r\n    } else {\r\n        StringBuffer buffer = new StringBuffer();\r\n        return buffer.append(prefix).append(\",\").append(suffix).toString();\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.monitoring.JdbcStatsProvider.statementCacheHitEvent",
	"Comment": "whenever statement cache is hit, increment numstatementcachehit count.",
	"Method": "void statementCacheHitEvent(String poolName,String appName,String moduleName){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        numStatementCacheHit.increment();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.MappingGenerator.cleanup",
	"Comment": "clean up strong reference. it should be called by end of deploymentor deploytool.",
	"Method": "void cleanup(){\r\n    strongRefs.clear();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.replaceSCO",
	"Comment": "replace previous value of the sco field with the newly created",
	"Method": "void replaceSCO(String fieldName,Object owner,Object obj){\r\n    if (owner instanceof PersistenceCapable) {\r\n        acquireShareLock();\r\n        try {\r\n            PersistenceCapable pc = (PersistenceCapable) owner;\r\n            StateManager sm = pc.jdoGetStateManager();\r\n            if (obj instanceof SCOCollection) {\r\n                acquireFieldUpdateLock();\r\n                try {\r\n                    sm.replaceObjectField(fieldName, obj);\r\n                } finally {\r\n                    releaseFieldUpdateLock();\r\n                }\r\n            } else {\r\n                sm.replaceObjectField(fieldName, obj);\r\n            }\r\n        } finally {\r\n            releaseShareLock();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.NameMapper.getRemoteInterfaceForEjbName",
	"Comment": "gets the name of the remote interface which corresponds to the \tspecified ejb name.",
	"Method": "String getRemoteInterfaceForEjbName(String name){\r\n    EjbCMPEntityDescriptor descriptor = getDescriptorForEjbName(name);\r\n    return ((descriptor != null) ? descriptor.getRemoteClassName() : null);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.XAResourceImpl.rollback",
	"Comment": "inform the resource manager to roll back work done on behalf of a transaction branch",
	"Method": "void rollback(Xid xid){\r\n    try {\r\n        xar.rollback(xid);\r\n    } catch (XAException xae) {\r\n        throw xae;\r\n    } catch (Exception e) {\r\n        throw new XAException(e.getMessage());\r\n    } finally {\r\n        mc.transactionCompleted();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.getResourceReferenceByName",
	"Comment": "return the resource object corresponding to the supplied name or throw an illegal argument exception.",
	"Method": "ResourceReferenceDescriptor getResourceReferenceByName(String name){\r\n    for (Iterator itr = getResourceReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        ResourceReferenceDescriptor next = (ResourceReferenceDescriptor) itr.next();\r\n        if (next.getName().equals(name)) {\r\n            return next;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"no resource ref of name \" + name);\r\n}"
}, {
	"Path": "org.glassfish.enterprise.iiop.util.S1ASThreadPoolManager.getThreadPoolStringId",
	"Comment": "return a string id for a numericid of a threadpool managed by the threadpoolmanager",
	"Method": "String getThreadPoolStringId(int numericIdForThreadpool){\r\n    String id = (String) indexToIdTable.get(Integer.valueOf(numericIdForThreadpool));\r\n    return ((id == null) ? defaultID : id);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConnectionPoolAdminServiceImpl.getDefaultSubject",
	"Comment": "utility method that is used to get the default subject for the specified mcf and resource principal.",
	"Method": "Subject getDefaultSubject(PoolInfo poolInfo,ManagedConnectionFactory mcf,ResourcePrincipal prin){\r\n    ResourcePrincipal resourcePrincipal = null;\r\n    if (prin == null) {\r\n        try {\r\n            resourcePrincipal = getDefaultResourcePrincipal(poolInfo, mcf);\r\n        } catch (NamingException ne) {\r\n            _logger.log(Level.WARNING, \"jdbc.pool_not_reachable\", ne.getMessage());\r\n            String l10nMsg = localStrings.getString(\"pingpool.name_not_bound\", poolInfo);\r\n            ResourceException e = new ResourceException(l10nMsg + poolInfo);\r\n            e.initCause(ne);\r\n            throw e;\r\n        }\r\n    } else {\r\n        resourcePrincipal = prin;\r\n    }\r\n    final Subject defaultSubject = ConnectionPoolObjectsUtils.createSubject(mcf, resourcePrincipal);\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"using subject: \" + defaultSubject);\r\n    }\r\n    return defaultSubject;\r\n}"
}, {
	"Path": "org.glassfish.enterprise.iiop.impl.RoundRobinPolicy.getNextRotation",
	"Comment": "get a new shape of the endpointsfor e.g. if list contains a,b,cif the logic below chooses b as the endpoint to send the req tothen return b,c,a.logic used is as described in class description comments",
	"Method": "List<String> getNextRotation(){\r\n    int lowerLimit = 0;\r\n    int random = 0;\r\n    while (random == 0) {\r\n        random = rand.nextInt(totalWeight);\r\n        if (random != 0) {\r\n            break;\r\n        }\r\n    }\r\n    int i = 0;\r\n    for (ClusterInstanceInfo endpoint : endpointsList) {\r\n        int upperLimit = lowerLimit + endpoint.weight();\r\n        if (random > lowerLimit && random <= upperLimit) {\r\n            List<ClusterInstanceInfo> instanceInfo = new LinkedList<ClusterInstanceInfo>();\r\n            instanceInfo.addAll(0, endpointsList.subList(i, endpointsList.size()));\r\n            instanceInfo.addAll(endpointsList.subList(0, i));\r\n            endpointsList = instanceInfo;\r\n            if (logger.isLoggable(Level.FINE)) {\r\n                logger.log(Level.FINE, \"getNextRotation: result={0}\", instanceInfo);\r\n            }\r\n            return convertIntoCorbaloc(instanceInfo);\r\n        }\r\n        lowerLimit = upperLimit;\r\n        i++;\r\n    }\r\n    logger.log(Level.WARNING, COULD_NOT_FIND_ENDPOINT);\r\n    return new ArrayList<String>();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getBoolean",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object asa boolean in the java programming language.",
	"Method": "boolean getBoolean(int columnIndex,boolean getBoolean,String columnName){\r\n    return resultSet.getBoolean(columnName);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.impl.AppClientScanner.calculateResults",
	"Comment": "overriding to handle the case where ejb class is mistakenly packaged inside an appclient jar.instead of throwing an error which might raise backward compatiability issues, a cleaner way is tojust skip the annotation processing for them.",
	"Method": "void calculateResults(ApplicationClientDescriptor bundleDesc){\r\n    super.calculateResults(bundleDesc);\r\n    Class[] ejbAnnotations;\r\n    if (ejbProvider != null)\r\n        ejbAnnotations = ejbProvider.getAnnotationTypes();\r\n    else\r\n        ejbAnnotations = new Class[] { javax.ejb.Stateful.class, javax.ejb.Stateless.class, javax.ejb.MessageDriven.class, javax.ejb.Singleton.class };\r\n    Set<String> toBeRemoved = new HashSet<String>();\r\n    ParsingContext context = classParser.getContext();\r\n    for (Class ejbAnnotation : ejbAnnotations) {\r\n        Type type = context.getTypes().getBy(ejbAnnotation.getName());\r\n        if (type != null && type instanceof AnnotationType) {\r\n            AnnotationType at = (AnnotationType) type;\r\n            for (AnnotatedElement ae : at.allAnnotatedTypes()) {\r\n                Type t = (ae instanceof Member ? ((Member) ae).getDeclaringType() : (Type) ae);\r\n                if (t.wasDefinedIn(scannedURI)) {\r\n                    toBeRemoved.add(t.getName());\r\n                }\r\n            }\r\n        }\r\n    }\r\n    for (String element : toBeRemoved) {\r\n        entries.remove(element);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.updateRow",
	"Comment": "updates the underlying database with the new contents of thecurrent row of this resultset object.this method cannot be called when the cursor is on the insert row.",
	"Method": "void updateRow(){\r\n    resultSet.updateRow();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.CMPHelper.getContainerHelper",
	"Comment": "returns a containerhelper instance that can be used to invokethe corresponding method.",
	"Method": "ContainerHelper getContainerHelper(){\r\n    if (containerHelper == null) {\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"ejb.cmphelper.nonmanaged\"));\r\n    }\r\n    return containerHelper;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.CMPBeanHelper.handleUpdateNotAllowedException",
	"Comment": "throws ejbexception on attempted updates to thecalling bean.",
	"Method": "void handleUpdateNotAllowedException(String beanName){\r\n    String msg = // NOI18N\r\n    I18NHelper.getMessage(cmpMessages, \"GEN.update_not_allowed\", beanName, findCallingMethodName());\r\n    cmpLifecycleLogger.log(Logger.SEVERE, msg);\r\n    throw new EJBException(msg);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.getByte",
	"Comment": "retrieves the value of a jdbc tinyint parameter as a bytein the java programming language.",
	"Method": "byte getByte(int parameterIndex,byte getByte,String parameterName){\r\n    return callableStatement.getByte(parameterName);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.getBytes",
	"Comment": "retrieves the value of a jdbc binary or varbinaryparameter as an array of byte values in the javaprogramming language.",
	"Method": "byte[] getBytes(int parameterIndex,byte[] getBytes,String parameterName){\r\n    return callableStatement.getBytes(parameterName);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MailConfiguration.getUsername",
	"Comment": "get the username for the mail session the server will provide.",
	"Method": "String getUsername(){\r\n    return this.username;\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.AppClientDeployerHelper.copy",
	"Comment": "copy the entryname element from the source abstract archive intothe target abstract archive",
	"Method": "void copy(ReadableArchive source,WritableArchive target,String entryName){\r\n    InputStream is = null;\r\n    OutputStream os = null;\r\n    try {\r\n        is = source.getEntry(entryName);\r\n        if (is != null) {\r\n            try {\r\n                os = target.putNextEntry(entryName);\r\n            } catch (ZipException ze) {\r\n                return;\r\n            }\r\n            ArchivistUtils.copyWithoutClose(is, os);\r\n        } else {\r\n            for (Enumeration e = source.entries(entryName); e.hasMoreElements(); ) {\r\n                copy(source, target, (String) e.nextElement());\r\n            }\r\n        }\r\n    } catch (IOException ioe) {\r\n        throw ioe;\r\n    } finally {\r\n        IOException closeEntryIOException = null;\r\n        if (os != null) {\r\n            try {\r\n                target.closeEntry();\r\n            } catch (IOException ioe) {\r\n                closeEntryIOException = ioe;\r\n            }\r\n        }\r\n        if (is != null) {\r\n            is.close();\r\n        }\r\n        if (closeEntryIOException != null) {\r\n            throw closeEntryIOException;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.jdbc.admin.cli.DeleteJdbcConnectionPool.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        JDBCConnectionPoolManager jdbcConnMgr = new JDBCConnectionPoolManager();\r\n        ResourceStatus rs = jdbcConnMgr.delete(servers, clusters, domain.getResources(), cascade.toString(), poolName);\r\n        if (rs.getMessage() != null)\r\n            report.setMessage(rs.getMessage());\r\n        if (rs.getStatus() == ResourceStatus.SUCCESS) {\r\n            report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n        } else {\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            if (rs.getException() != null) {\r\n                report.setFailureCause(rs.getException());\r\n                Logger.getLogger(DeleteJdbcConnectionPool.class.getName()).log(Level.SEVERE, \"Something went wrong in delete-jdbc-connection-pool\", rs.getException());\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        Logger.getLogger(DeleteJdbcConnectionPool.class.getName()).log(Level.SEVERE, \"Something went wrong in delete-jdbc-connection-pool\", e);\r\n        String msg = e.getMessage() != null ? e.getMessage() : localStrings.getLocalString(\"delete.jdbc.connection.pool.fail\", \"{0} delete failed \", poolName);\r\n        report.setMessage(msg);\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ClassDesc.getSortedFieldNumbers",
	"Comment": "the methods returns the string representation of the sorted field numbersof the fielddescs.the key is the string representation of the sorted field number listof updated fields.",
	"Method": "String getSortedFieldNumbers(List fields){\r\n    int size = fields.size();\r\n    int[] fieldNos = new int[size];\r\n    for (int i = 0; i < size; i++) {\r\n        FieldDesc f = (FieldDesc) fields.get(i);\r\n        fieldNos[i] = f.absoluteID;\r\n    }\r\n    Arrays.sort(fieldNos);\r\n    return StringHelper.intArrayToSeparatedList(fieldNos, \",\");\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.TypeTable.isNumberType",
	"Comment": "returns true if type is a numerictype or compatible to java.lang.number",
	"Method": "boolean isNumberType(Type type){\r\n    Type numberType = checkType(\"java.lang.Number\");\r\n    Type characterType = checkType(\"java.lang.Character\");\r\n    return (type instanceof NumericType) || (type.isCompatibleWith(numberType)) || (type.isCompatibleWith(characterType));\r\n}"
}, {
	"Path": "org.glassfish.deployapi.SunDeploymentManager.setLocale",
	"Comment": "set the active locale for this implementation of javax.enterprise.deploy.spi subpackages to run.",
	"Method": "void setLocale(Locale locale){\r\n    for (int i = 0; i < supportedLocales.length; i++) {\r\n        if (supportedLocales[i] == locale) {\r\n            currentLocale = locale;\r\n            return;\r\n        }\r\n    }\r\n    throw new UnsupportedOperationException(// NOI18N\r\n    localStrings.getLocalString(// NOI18N\r\n    \"enterprise.deployapi.spi.localnotsupported\", \"Locale {0} is not supported\", new Object[] { locale }));\r\n}"
}, {
	"Path": "org.glassfish.concurrent.admin.CreateContextService.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    HashMap attrList = new HashMap();\r\n    attrList.put(ResourceConstants.JNDI_NAME, jndiName);\r\n    attrList.put(ResourceConstants.CONTEXT_INFO_ENABLED, contextinfoenabled.toString());\r\n    attrList.put(ResourceConstants.CONTEXT_INFO, contextinfo);\r\n    attrList.put(ServerTags.DESCRIPTION, description);\r\n    attrList.put(ResourceConstants.ENABLED, enabled.toString());\r\n    ResourceStatus rs;\r\n    try {\r\n        rs = contextServiceMgr.create(domain.getResources(), attrList, properties, target);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"create.context.service.failed\", \"Context service {0} creation failed\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    ActionReport.ExitCode ec = ActionReport.ExitCode.SUCCESS;\r\n    if (rs.getMessage() != null) {\r\n        report.setMessage(rs.getMessage());\r\n    }\r\n    if (rs.getStatus() == ResourceStatus.FAILURE) {\r\n        ec = ActionReport.ExitCode.FAILURE;\r\n        if (rs.getException() != null)\r\n            report.setFailureCause(rs.getException());\r\n    }\r\n    report.setActionExitCode(ec);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.getRoleMapper",
	"Comment": "return my mapping of rolename to users and groups on a particularserver.",
	"Method": "SecurityRoleMapper getRoleMapper(){\r\n    if (this.roleMapper == null) {\r\n        if (securityRoleMapperFactory == null) {\r\n            _logger.log(Level.FINE, \"SecurityRoleMapperFactory NOT set.\");\r\n        } else {\r\n            this.roleMapper = securityRoleMapperFactory.getRoleMapper(this.getName());\r\n        }\r\n    }\r\n    return this.roleMapper;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ServiceRefPortInfo.addCallProperty",
	"Comment": "add call property, using property name as a key. this willreplace the property value of any existing stub property withthe same name.",
	"Method": "void addCallProperty(NameValuePairDescriptor property){\r\n    NameValuePairDescriptor prop = getCallPropertyByName(property.getName());\r\n    if (prop != null) {\r\n        prop.setValue(property.getValue());\r\n    } else {\r\n        callProperties.add(property);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.AppClientContainerBuilder.defineIfNotDefined",
	"Comment": "define the specified system property using the new value unless theproperty is already set.",
	"Method": "void defineIfNotDefined(String propName,String newPropValue){\r\n    if (System.getProperty(propName) == null) {\r\n        if (newPropValue == null) {\r\n            throw new RuntimeException(localStrings.getLocalString(AppClientContainerBuilder.class, \"appclient.missingValue\", \"Value for {0} expected but was not configured or assigned\", new Object[] { propName }));\r\n        }\r\n        System.setProperty(propName, newPropValue);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceFieldElement.isKey",
	"Comment": "determines whether this field element is a key field or not.",
	"Method": "boolean isKey(boolean isKey){\r\n    return getFieldImpl().isKey();\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.getMessageDestinationReferenceByName",
	"Comment": "looks up an message destination reference with the given name.throws an illegalargumentexception if it is not found.",
	"Method": "MessageDestinationReferenceDescriptor getMessageDestinationReferenceByName(String name){\r\n    for (MessageDestinationReferenceDescriptor mdr : messageDestReferences) {\r\n        if (mdr.getName().equals(name)) {\r\n            return mdr;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"No message destination ref of name \" + name);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlTime.setMinutes",
	"Comment": "sets the minutes of this sqltime object to the specified value.",
	"Method": "void setMinutes(int minutes){\r\n    this.makeDirty();\r\n    super.setMinutes(minutes);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.JDBCInfo.override",
	"Comment": "update this jdbcinfo with information from the other jdbcinfo.",
	"Method": "void override(JDBCInfo other){\r\n    if (null != other) {\r\n        this.jdbcType = other.jdbcType;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.jws.servedcontent.ASJarSigner.signJar",
	"Comment": "creates a signed zip output stream from an unsigned jar and, possibly, additional content.",
	"Method": "long signJar(File unsignedJar,File signedJar,String alias,Attributes attrs,long signJar,File unsignedJar,ZipOutputStream signedJar,String alias,Attributes attrs,Map<String, byte[]> additionalContent){\r\n    if (alias == null) {\r\n        alias = DEFAULT_ALIAS_VALUE;\r\n    }\r\n    long startTime = System.currentTimeMillis();\r\n    long duration = 0;\r\n    synchronized (this) {\r\n        try {\r\n            JarSigner jarSigner = new JarSigner(DEFAULT_DIGEST_ALGORITHM, DEFAULT_KEY_ALGORITHM);\r\n            jarSigner.signJar(unsignedJar, signedJar, alias, attrs, additionalContent);\r\n        } catch (Throwable t) {\r\n            throw new Exception(localStrings.getString(\"jws.sign.errorSigning\", unsignedJar.getAbsolutePath(), alias), t);\r\n        } finally {\r\n            duration = System.currentTimeMillis() - startTime;\r\n            logger.log(Level.FINE, \"Signing {0} took {1} ms\", new Object[] { unsignedJar.getAbsolutePath(), duration });\r\n        }\r\n    }\r\n    return duration;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getConcurrency",
	"Comment": "retrieves the concurrency mode of this resultset object.the concurrency used is determined by thestatement object that created the result set.",
	"Method": "int getConcurrency(){\r\n    return resultSet.getConcurrency();\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecServerRequestInterceptor.createContextError",
	"Comment": "create a context error with the specified major and minor status",
	"Method": "SASContextBody createContextError(int status,SASContextBody createContextError,int major,int minor){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"Creating ContextError message: major code = \" + major + \"minor code= \" + minor);\r\n    }\r\n    byte[] error_token = {};\r\n    ContextError ce = new // major\r\n    ContextError(0, major, minor, error_token);\r\n    SASContextBody sasctxtbody = new SASContextBody();\r\n    sasctxtbody.error_msg(ce);\r\n    return sasctxtbody;\r\n}"
}, {
	"Path": "com.sun.web.security.RealmAdapter.createFailOveredPrincipal",
	"Comment": "this method is added to create a principal based on the username only. hercules stores the username as part of authentication failover and needs to create a principal based on username only",
	"Method": "Principal createFailOveredPrincipal(String username){\r\n    _logger.log(Level.FINEST, \"IN createFailOveredPrincipal (\" + username + \")\");\r\n    loginForRunAs(username);\r\n    SecurityContext secCtx = SecurityContext.getCurrent();\r\n    _logger.log(Level.FINE, \"Security context is \" + secCtx);\r\n    assert (secCtx != null);\r\n    Principal principal = new WebPrincipal(username, (char[]) null, secCtx);\r\n    _logger.log(Level.INFO, \"Principal created for FailOvered user \" + principal);\r\n    return principal;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.ConnectionFactoryImpl.assertConnectionWait",
	"Comment": "internalasserts that mswait and msinterval are properly configured",
	"Method": "void assertConnectionWait(){\r\n    if (msWait < 0) {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"connection.connectionmanager.mswaitvalue\"));\r\n    } else if (msInterval < 0 || msInterval > msWait || (msWait > 0 && msInterval == 0)) {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"connection.connectionmanager.msintervalvalue\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.ConnectionFactoryImpl.getMaxPool",
	"Comment": "returns maximum number of connections in the connection pool",
	"Method": "int getMaxPool(){\r\n    return maxPool;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.getFieldType",
	"Comment": "returns the field type for the specified fieldname in the class\twith the specified classname.",
	"Method": "String getFieldType(String className,String fieldName){\r\n    return getType(getField(className, fieldName));\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getTime",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object as a java.sql.time objectin the java programming language.this method uses the given calendar to construct an appropriate millisecondvalue for the time if the underlying database does not storetimezone information.",
	"Method": "Time getTime(int columnIndex,Time getTime,String columnName,Time getTime,int columnIndex,Calendar cal,Time getTime,String columnName,Calendar cal){\r\n    return resultSet.getTime(columnName, cal);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.getConnectionType",
	"Comment": "this method determines the type of the connection being heldin this managedconnectionimpl.",
	"Method": "int getConnectionType(PooledConnection pooledConn){\r\n    if (pooledConn == null) {\r\n        return ISNOTAPOOLEDCONNECTION;\r\n    } else if (pooledConn instanceof XAConnection) {\r\n        return ISXACONNECTION;\r\n    } else {\r\n        return ISPOOLEDCONNECTION;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.prepareToUpdatePhaseII",
	"Comment": "this is the second phase of the commit processing. it populates phase3sms with allthe autopersistent instances that are no longer reachable from a persistent instance.",
	"Method": "void prepareToUpdatePhaseII(HashSet phase3sms){\r\n    boolean debug = logger.isLoggable();\r\n    if (debug) {\r\n        // NOI18N\r\n        logger.fine(\"sqlstore.sqlstatemanager.preparetoupdateph2\", persistenceConfig.getPersistenceCapableClass().getName());\r\n    }\r\n    if (state.isAutoPersistent()) {\r\n        state = state.transitionMakePending();\r\n        phase3sms.add(this);\r\n        return;\r\n    }\r\n    if ((stateFlags & ST_PREPARED_PHASE_II) > 0) {\r\n        return;\r\n    }\r\n    stateFlags |= ST_PREPARED_PHASE_II;\r\n    if ((!state.isNew() && !state.isDirty()) || state.isDeleted()) {\r\n        return;\r\n    }\r\n    ArrayList foreignFields = persistenceConfig.foreignFields;\r\n    int size = foreignFields.size();\r\n    for (int i = 0; i < size; i++) {\r\n        ForeignFieldDesc ff = (ForeignFieldDesc) foreignFields.get(i);\r\n        if (ff.cardinalityUPB <= 1) {\r\n            if (getPresenceMaskBit(ff.absoluteID)) {\r\n                Object v = ff.getValue(this);\r\n                if (v != null) {\r\n                    transitionPersistent(v, phase3sms);\r\n                }\r\n            }\r\n        } else {\r\n            Collection c = getCollectionValue(ff);\r\n            if (c != null) {\r\n                Iterator iter = c.iterator();\r\n                while (iter.hasNext()) {\r\n                    Object v = iter.next();\r\n                    transitionPersistent(v, phase3sms);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (debug) {\r\n        logger.fine(\"sqlstore.sqlstatemanager.preparetoupdateph2.exit\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.setValidationClassName",
	"Comment": "sets the validation class name checked for during validation",
	"Method": "void setValidationClassName(String className){\r\n    try {\r\n        Class validationClass = Thread.currentThread().getContextClassLoader().loadClass(className);\r\n        boolean isAssignable = ConnectionValidation.class.isAssignableFrom(validationClass);\r\n        if (isAssignable) {\r\n            spec.setDetail(DataSourceSpec.VALIDATIONCLASSNAME, className);\r\n        } else {\r\n            _logger.log(Level.SEVERE, \"jdbc.set_custom_validation_class_name_failure\", className);\r\n            throw new ResourceException(\"The Custom validation class name is\" + \"not valid as it does not implement \" + ConnectionValidation.class.getName());\r\n        }\r\n    } catch (ResourceException ex) {\r\n        _logger.log(Level.SEVERE, \"jdbc.set_custom_validation_class_name_failure\", ex.getMessage());\r\n    } catch (ClassNotFoundException ex) {\r\n        _logger.log(Level.SEVERE, \"jdbc.set_custom_validation_class_name_failure\", ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admingui.devtests.NodeTest.testDeleteWithInstance",
	"Comment": "create a node,create an instance with this node,delete this node will cause error",
	"Method": "void testDeleteWithInstance(){\r\n    gotoDasPage();\r\n    final String nodeName = NODE_NAME_PREFIX + generateRandomString();\r\n    final String instanceName = \"testInstance\" + generateRandomString();\r\n    createSSHNode(nodeName);\r\n    createInstance(instanceName, nodeName);\r\n    clickAndWait(ID_NODE_TREE_LINK);\r\n    deleteRow(ID_DELETE_NODE_BUTTON, \"propertyForm:nodesTable\", nodeName);\r\n    isClassPresent(\"label_sun4\");\r\n    assertTrue(driver.findElement(By.className(\"label_sun4\")).getText().equals((\"An error has occurred\")));\r\n    clickAndWait(ID_STANDALONE_TREE_LINK);\r\n    deleteRow(\"propertyForm:instancesTable:topActionsGroup1:button1\", \"propertyForm:instancesTable\", instanceName);\r\n    clickAndWait(ID_NODE_TREE_LINK);\r\n    deleteRow(ID_DELETE_NODE_BUTTON, \"propertyForm:nodesTable\", nodeName);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.module.ConnectorContainer.getDeployer",
	"Comment": "returns the deployer implementation capable of deploying applications to thiscontainer.",
	"Method": "Class<? extends Deployer> getDeployer(){\r\n    return ConnectorDeployer.class;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getContainerTransactionFor",
	"Comment": "fetches the assigned container transaction object for the given method object or null.",
	"Method": "ContainerTransaction getContainerTransactionFor(MethodDescriptor methodDescriptor){\r\n    ContainerTransaction containerTransaction = null;\r\n    if (this.needToConvertMethodContainerTransactions()) {\r\n        this.convertMethodContainerTransactions();\r\n    }\r\n    containerTransaction = (ContainerTransaction) this.getMethodContainerTransactions().get(methodDescriptor);\r\n    if (containerTransaction == null) {\r\n        if (this.isBoundsChecking() && usesDefaultTransaction) {\r\n            containerTransaction = new ContainerTransaction(ContainerTransaction.REQUIRED, \"\");\r\n            this.getMethodContainerTransactions().put(methodDescriptor, containerTransaction);\r\n        } else {\r\n            containerTransaction = null;\r\n        }\r\n    }\r\n    return containerTransaction;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.DDLGenerator.generateDDL",
	"Comment": "maybe create, create, drop, drop, but not create, drop, drop, create!",
	"Method": "void generateDDL(SchemaElement schema,String dbVendorName,OutputStream createDDLSql,OutputStream dropDDLSql,OutputStream dropDDLJdbc,OutputStream createDDLJdbc,OutputStream dbStream,boolean dropAndCreateTbl){\r\n    if (schema != null) {\r\n        MappingPolicy mappingPolicy = MappingPolicy.getMappingPolicy(dbVendorName);\r\n        DDLTemplateFormatter.reset(mappingPolicy);\r\n        String schemaName = schema.getName().getName();\r\n        List createAllTblDDL = new ArrayList();\r\n        List createIndexDDL = new ArrayList();\r\n        List alterAddConstraintsDDL = new ArrayList();\r\n        List alterDropConstraintsDDL = new ArrayList();\r\n        List dropAllTblDDL = new ArrayList();\r\n        TableElement[] tables = schema.getTables();\r\n        if (tables != null) {\r\n            for (int ii = 0; ii < tables.length; ii++) {\r\n                TableElement table = tables[ii];\r\n                createAllTblDDL.add(createCreateTableDDL(table, mappingPolicy));\r\n                if (table.getPrimaryKey() != null) {\r\n                    createIndexDDL.add(createIndexDDL(table));\r\n                }\r\n                alterAddConstraintsDDL.addAll(createAddConstraintsDDL(table));\r\n                alterDropConstraintsDDL.addAll(createDropConstraintsDDL(table));\r\n                dropAllTblDDL.add(createDropTableDDL(table));\r\n            }\r\n        }\r\n        String stmtSeparator = mappingPolicy.getStatementSeparator();\r\n        generateSQL(createDDLSql, dropDDLSql, dropDDLJdbc, createDDLJdbc, (DatabaseOutputStream) dbStream, createAllTblDDL, createIndexDDL, alterAddConstraintsDDL, alterDropConstraintsDDL, dropAllTblDDL, stmtSeparator, dropAndCreateTbl);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConnectionPoolAdminServiceImpl.flushConnectionPool",
	"Comment": "flush connection pool by reinitializing the connections established in the pool.",
	"Method": "boolean flushConnectionPool(PoolInfo poolInfo){\r\n    PoolManager poolMgr = _runtime.getPoolManager();\r\n    try {\r\n        return poolMgr.flushConnectionPool(poolInfo);\r\n    } catch (PoolingException ex) {\r\n        ConnectorRuntimeException e = new ConnectorRuntimeException(ex.getLocalizedMessage() + \". Please check the server.log for more details.\");\r\n        e.initCause(ex);\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admingui.plugin.ConsolePluginService.getHelpIndex",
	"Comment": "this method returns a merged table of contents for all found help \tsets for the given locale.",
	"Method": "Index getHelpIndex(String locale){\r\n    if (locale == null) {\r\n        locale = \"en\";\r\n    }\r\n    Index mergedIndex = helpSetIndexMap.get(locale);\r\n    if (mergedIndex != null) {\r\n        return mergedIndex;\r\n    }\r\n    Map<String, List<URL>> mapUrls = getResources(locale + \"/help/index.xml\");\r\n    ConfigParser parser = new ConfigParser(habitat);\r\n    mergedIndex = new Index();\r\n    mergedIndex.setIndexItems(new ArrayList<IndexItem>());\r\n    mergedIndex.setVersion(\"2.0\");\r\n    String id = null;\r\n    String prefix = \"/\" + locale + \"/help/\";\r\n    List<URL> urls = null;\r\n    for (Map.Entry<String, List<URL>> entry : mapUrls.entrySet()) {\r\n        id = entry.getKey();\r\n        urls = entry.getValue();\r\n        for (URL url : urls) {\r\n            DomDocument doc = parser.parse(url);\r\n            Index index = (Index) doc.getRoot().get();\r\n            for (IndexItem item : index.getIndexItems()) {\r\n                insertIndexItem(mergedIndex.getIndexItems(), item, id + prefix);\r\n            }\r\n        }\r\n    }\r\n    return mergedIndex;\r\n}"
}, {
	"Path": "org.glassfish.ejb.persistent.timer.PersistentEJBTimerService.recoverAndCreateSchedulesError",
	"Comment": "common code for exception processing in recoverandcreateschedules",
	"Method": "void recoverAndCreateSchedulesError(Exception e,TransactionManager tm){\r\n    logger.log(Level.WARNING, \"Timer restore or schedule creation error\", e);\r\n    try {\r\n        tm.rollback();\r\n    } catch (Exception re) {\r\n        logger.log(Level.FINE, \"Timer restore or schedule creation rollback error\", re);\r\n    }\r\n    EJBException ejbEx = createEJBException(e);\r\n    throw ejbEx;\r\n}"
}, {
	"Path": "org.glassfish.loadbalancer.admin.cli.DeleteHTTPHealthCheckerCommand.deleteHealthCheckerInternal",
	"Comment": "deletes a health checker from a load balancer configuration.",
	"Method": "void deleteHealthCheckerInternal(LbConfig lbConfig,String target,boolean ignoreFailure){\r\n    if (lbConfig == null) {\r\n        String msg = localStrings.getLocalString(\"InvalidLbConfigName\", \"Invalid LB configuration.\");\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setMessage(msg);\r\n        return;\r\n    }\r\n    String lbConfigName = lbConfig.getName();\r\n    if (logger.isLoggable(Level.FINE)) {\r\n        logger.fine(\"[LB-ADMIN] deleteHealthChecker called - LB Config Name: \" + lbConfigName + \", Target: \" + target);\r\n    }\r\n    if (target == null) {\r\n        String msg = localStrings.getLocalString(\"Nulltarget\", \"Null target\");\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setMessage(msg);\r\n        return;\r\n    }\r\n    if (tgt.isCluster(target)) {\r\n        ClusterRef cRef = lbConfig.getRefByRef(ClusterRef.class, target);\r\n        if ((cRef == null) && (ignoreFailure == false)) {\r\n            String msg = localStrings.getLocalString(\"UnassociatedCluster\", \"Load balancer configuration [{0}] does not have a reference to the given cluster [{1}].\", lbConfigName, target);\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            report.setMessage(msg);\r\n            return;\r\n        }\r\n        if (cRef != null) {\r\n            HealthChecker hc = cRef.getHealthChecker();\r\n            if (hc != null) {\r\n                removeHealthCheckerFromClusterRef(cRef);\r\n                String msg = localStrings.getLocalString(\"http_lb_admin.HealthCheckerDeleted\", \"Health checker deleted for target {0}\", target);\r\n                logger.info(msg);\r\n            } else {\r\n                if (ignoreFailure == false) {\r\n                    String msg = localStrings.getLocalString(\"HealthCheckerDoesNotExist\", \"Health checker does not exist for target {0} in LB {1}\", target, lbConfigName);\r\n                    report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                    report.setMessage(msg);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    } else if (domain.isServer(target)) {\r\n        ServerRef sRef = lbConfig.getRefByRef(ServerRef.class, target);\r\n        if ((sRef == null) && (ignoreFailure == false)) {\r\n            String msg = localStrings.getLocalString(\"UnassociatedServer\", \"Load balancer configuration [{0}] does not have a reference to the given server [{1}].\", lbConfigName, target);\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            report.setMessage(msg);\r\n            return;\r\n        }\r\n        if (sRef != null) {\r\n            HealthChecker hc = sRef.getHealthChecker();\r\n            if (hc != null) {\r\n                removeHealthCheckerFromServerRef(sRef);\r\n                String msg = localStrings.getLocalString(\"http_lb_admin.HealthCheckerDeleted\", \"Health checker deleted for target {0}\", target);\r\n                logger.info(msg);\r\n            } else {\r\n                if (ignoreFailure == false) {\r\n                    String msg = localStrings.getLocalString(\"HealthCheckerDoesNotExist\", \"Health checker does not exist for target {0} in LB {1}\", target, lbConfigName);\r\n                    report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                    report.setMessage(msg);\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        String msg = localStrings.getLocalString(\"InvalidTarget\", \"Invalid target\", target);\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setMessage(msg);\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.connector.module.ConnectorSniffer.getAnnotationTypes",
	"Comment": "returns the list of annotations types that this sniffer is interested in.if an application bundle contains at least one class annotated withone of the returned annotations, the deployment process will notcall the handles method but will invoke the containers deployers as ifthe handles method had been called and returned true.",
	"Method": "Class<? extends Annotation>[] getAnnotationTypes(){\r\n    return connectorAnnotations;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceElementCollection.getOwner",
	"Comment": "returns the owner of this collection.this method should only \tbe used internally and for cloning and archiving.",
	"Method": "PersistenceElementImpl getOwner(){\r\n    return _owner;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.UpdateQueryPlan.checkBatchThreshold",
	"Comment": "determines if the amount of batched operations exceeded a threshold.",
	"Method": "boolean checkBatchThreshold(Transaction tran){\r\n    for (int i = 0, size = statements.size(); i < size; i++) {\r\n        UpdateStatement updateStatement = (UpdateStatement) statements.get(i);\r\n        if (updateStatement.exceedsBatchThreshold(tran))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.stats.MutableTimeStatisticImpl.unmodifiableView",
	"Comment": "this method is the essence of this class. returns the unmodifiable view\tof this instance.",
	"Method": "Statistic unmodifiableView(){\r\n    return (new TimeStatisticImpl(this.methodCount, this.max, this.min, this.total, initial.getName(), initial.getUnit(), initial.getDescription(), initial.getStartTime(), this.lastSampleTime));\r\n}"
}, {
	"Path": "org.glassfish.deployapi.SunDeploymentManager.setDConfigBeanVersion",
	"Comment": "set the configuration beans to be used to the j2ee platformversion specificed.",
	"Method": "void setDConfigBeanVersion(DConfigBeanVersionType version){\r\n    if (!isDConfigBeanVersionSupported(version)) {\r\n        throw new DConfigBeanVersionUnsupportedException(// NOI18N\r\n        localStrings.getLocalString(\"enterprise.deployapi.spi.dconfigbeanversionnotsupported\", \"DConfigBean version {0} is not supported\", new Object[] { version.toString() }));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceElementCollection.getTemplate",
	"Comment": "returns the template for the array of this collection.this method \tshould only be used internally and for cloning and archiving.",
	"Method": "Object[] getTemplate(){\r\n    return _template;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.CMPHelper.beginInternalTransaction",
	"Comment": "called in a unspecified transaction context of a managed environment.according to p.364 of ejb 2.0 spec, cmp may need to manageits own transaction when its transaction attribute isnotsupported, never, supports.",
	"Method": "void beginInternalTransaction(PersistenceManager pm){\r\n    getContainerHelper().beginInternalTransaction(pm);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.AbstractBundleNode.setSpecVersion",
	"Comment": "sets the specversion for this descriptor depending on the doctype",
	"Method": "void setSpecVersion(){\r\n    if (docType == null)\r\n        return;\r\n    StringTokenizer st = new StringTokenizer(docType, \"//\");\r\n    while (st.hasMoreElements()) {\r\n        String tmp = st.nextToken();\r\n        if (tmp.startsWith(\"DTD\")) {\r\n            StringTokenizer versionST = new StringTokenizer(tmp);\r\n            while (versionST.hasMoreElements()) {\r\n                String versionStr = versionST.nextToken();\r\n                try {\r\n                    Float.valueOf(versionStr);\r\n                    RootDeploymentDescriptor rdd = (RootDeploymentDescriptor) getDescriptor();\r\n                    rdd.setSpecVersion(versionStr);\r\n                    return;\r\n                } catch (NumberFormatException nfe) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.Tag.equals",
	"Comment": "this implementation of equals only checks the tagname and the \ttagviewid for equality.this means 2 tags with different user \tlists are still considered equal.the display name is also of no \timportance to this implementation of equality.",
	"Method": "boolean equals(Object obj){\r\n    boolean result = false;\r\n    if (obj instanceof Tag) {\r\n        Tag testTag = (Tag) obj;\r\n        result = getTagName().equals(testTag.getTagName()) && getTagViewId().equals(testTag.getTagViewId());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.setBoolean",
	"Comment": "sets the designated parameter to the given java boolean value.the driver converts thisto an sql bit value when it sends it to the database.",
	"Method": "void setBoolean(String parameterName,boolean x){\r\n    callableStatement.setBoolean(parameterName, x);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingRelationshipElementImpl.getLowerBound",
	"Comment": "get the lower cardinality bound for this relationship element.",
	"Method": "int getLowerBound(){\r\n    return getRelationshipElement().getLowerBound();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.DeploymentDescriptorNode.writeEntityManagerReferenceDescriptors",
	"Comment": "write a list of entity manager reference descriptors to a dom tree",
	"Method": "void writeEntityManagerReferenceDescriptors(Node parentNode,Iterator entityMgrRefs){\r\n    if (entityMgrRefs == null || !entityMgrRefs.hasNext())\r\n        return;\r\n    EntityManagerReferenceNode subNode = new EntityManagerReferenceNode();\r\n    for (; entityMgrRefs.hasNext(); ) {\r\n        EntityManagerReferenceDescriptor aEntityMgrRef = (EntityManagerReferenceDescriptor) entityMgrRefs.next();\r\n        subNode.writeDescriptor(parentNode, TagNames.PERSISTENCE_CONTEXT_REF, aEntityMgrRef);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.ActiveJmsResourceAdapter.addJmsHost",
	"Comment": "adds the jmshost to the mqaddresslist of the resource adapter.",
	"Method": "void addJmsHost(JmsHost host){\r\n    urlList.addMQUrl(host);\r\n    setAddressList();\r\n}"
}, {
	"Path": "com.sun.enterprise.naming.impl.TransientContext.doLookup",
	"Comment": "lookup the specified name in the current objects hashtable.",
	"Method": "Object doLookup(String name){\r\n    Object answer = bindings.get(name);\r\n    if (answer == null) {\r\n        throw new NameNotFoundException(name + \" not found\");\r\n    }\r\n    return answer;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.BundleDescriptor.getWebServices",
	"Comment": "return web services defined for this module.not applicable forapplication clients.",
	"Method": "WebServicesDescriptor getWebServices(){\r\n    return webServices;\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.DeleteJMSHost.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    Config targetConfig = domain.getConfigNamed(target);\r\n    if (targetConfig != null)\r\n        config = targetConfig;\r\n    Server targetServer = domain.getServerNamed(target);\r\n    if (targetServer != null) {\r\n        config = domain.getConfigNamed(targetServer.getConfigRef());\r\n    }\r\n    com.sun.enterprise.config.serverbeans.Cluster cluster = domain.getClusterNamed(target);\r\n    if (cluster != null) {\r\n        config = domain.getConfigNamed(cluster.getConfigRef());\r\n    }\r\n    if (jmsHostName == null) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.jms.host.noHostName\", \"No JMS Host Name specified for JMS Host.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    JmsService jmsService = config.getExtensionByType(JmsService.class);\r\n    if (jmsService == null) {\r\n        report.setMessage(localStrings.getLocalString(\"list.jms.host.invalidTarget\", \"Invalid Target specified.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    JmsHost jmsHost = null;\r\n    for (JmsHost r : jmsService.getJmsHost()) {\r\n        if (jmsHostName.equals(r.getName())) {\r\n            jmsHost = r;\r\n            break;\r\n        }\r\n    }\r\n    if (jmsHost == null) {\r\n        report.setMessage(localStrings.getLocalString(\"list.jms.host.noJmsHostFound\", \"JMS Host {0} does not exist.\", jmsHostName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    final JmsHost jHost = jmsHost;\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<JmsService>() {\r\n            public Object run(JmsService param) throws PropertyVetoException, TransactionFailure {\r\n                return param.getJmsHost().remove(jHost);\r\n            }\r\n        }, jmsService);\r\n    } catch (TransactionFailure tfe) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.jms.host.fail\", \"Unable to delete jms host {0}.\", jmsHostName) + \" \" + tfe.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.DeleteJMSHost.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    return param.getJmsHost().remove(jHost);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MessageDestinationReferencerImpl.resolveLinkName",
	"Comment": "try to resolve the current link name value to a messagedestinationobject.",
	"Method": "MessageDestinationDescriptor resolveLinkName(){\r\n    MessageDestinationDescriptor msgDest = null;\r\n    String linkName = messageDestinationLinkName;\r\n    if ((linkName != null) && (linkName.length() > 0)) {\r\n        int hashIndex = linkName.indexOf('#');\r\n        BundleDescriptor bundleDescriptor = getBundleDescriptor();\r\n        Application app = bundleDescriptor.getApplication();\r\n        if (app == null && bundleDescriptor instanceof Application) {\r\n            app = (Application) bundleDescriptor;\r\n        }\r\n        BundleDescriptor targetBundle = null;\r\n        String msgDestName = linkName;\r\n        if (app != null) {\r\n            if (hashIndex != -1) {\r\n                String relativeModuleUri = linkName.substring(0, hashIndex);\r\n                msgDestName = linkName.substring(hashIndex + 1);\r\n                targetBundle = app.getRelativeBundle(bundleDescriptor, relativeModuleUri);\r\n            } else {\r\n                if (!bundleDescriptor.hasMessageDestinationByName(msgDestName)) {\r\n                    Set modules = app.getBundleDescriptors();\r\n                    for (Iterator iter = modules.iterator(); iter.hasNext(); ) {\r\n                        BundleDescriptor next = (BundleDescriptor) iter.next();\r\n                        if (next.hasMessageDestinationByName(msgDestName)) {\r\n                            targetBundle = next;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (targetBundle == null) {\r\n                        Collection<RootDeploymentDescriptor> extensionBundles = bundleDescriptor.getExtensionsDescriptors();\r\n                        for (Iterator<RootDeploymentDescriptor> itr = extensionBundles.iterator(); itr.hasNext(); ) {\r\n                            RootDeploymentDescriptor next = itr.next();\r\n                            if (next instanceof BundleDescriptor) {\r\n                                if (((BundleDescriptor) next).hasMessageDestinationByName(msgDestName)) {\r\n                                    targetBundle = (BundleDescriptor) next;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                } else {\r\n                    targetBundle = bundleDescriptor;\r\n                }\r\n            }\r\n        }\r\n        try {\r\n            if (targetBundle != null) {\r\n                msgDest = targetBundle.getMessageDestinationByName(msgDestName);\r\n            }\r\n        } catch (IllegalArgumentException iae) {\r\n        }\r\n    }\r\n    if (msgDest != null) {\r\n        setMessageDestination(msgDest);\r\n    }\r\n    return msgDest;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ConnectionRequestInfoImpl.equals",
	"Comment": "verify whether two connectionrequestinfoimpls are equal.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == null)\r\n        return false;\r\n    if (obj instanceof ConnectionRequestInfoImpl) {\r\n        ConnectionRequestInfoImpl other = (ConnectionRequestInfoImpl) obj;\r\n        return (isEqual(this.user, other.user) && Arrays.equals(this.password, other.password));\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.getMappingCache",
	"Comment": "returns an unmodifiable copy of the mappingclasselement cache.",
	"Method": "Map getMappingCache(){\r\n    return Collections.unmodifiableMap(_classes);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceElement.compareTo",
	"Comment": "compares this object with the specified object for order. returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.the specified object must be persistence element, meaning it must be an instance of class persistenceelement or any subclass. if not a classcastexception is thrown.the order of persistenceelement objects is defined by the order of their names.persistence elements without name are considered to be less than any named persistence element.",
	"Method": "int compareTo(Object o){\r\n    if (o == null)\r\n        throw new ClassCastException();\r\n    if (o == this)\r\n        return 0;\r\n    String thisName = getName();\r\n    String otherName = ((PersistenceElement) o).getName();\r\n    if (thisName == null)\r\n        return (otherName == null) ? 0 : -1;\r\n    if (otherName == null)\r\n        return 1;\r\n    int ret = Collator.getInstance().compare(thisName, otherName);\r\n    if ((ret == 0) && (getClass() != o.getClass()))\r\n        ret = getClass().getName().compareTo(o.getClass().getName());\r\n    return ret;\r\n}"
}, {
	"Path": "com.sun.jaspic.config.factory.BaseAuthConfigFactory.removeRegistration",
	"Comment": "remove the identified provider registration from the factoryand invoke any listeners associated with the removed registration.",
	"Method": "boolean removeRegistration(String registrationID){\r\n    SecurityManager sm = System.getSecurityManager();\r\n    if (sm != null) {\r\n        sm.checkPermission(AuthConfigFactory.providerRegistrationSecurityPermission);\r\n    }\r\n    return _unRegister(registrationID);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.impl.AppClientScanner.doProcess",
	"Comment": "this scanner will scan the given main class for annotation processing.the archivefile and libjarfiles correspond to classpath.",
	"Method": "void doProcess(ReadableArchive archive,ApplicationClientDescriptor desc,ClassLoader classLoader){\r\n    if (AnnotationUtils.getLogger().isLoggable(Level.FINE)) {\r\n        AnnotationUtils.getLogger().fine(\"archiveFile is \" + archive.getURI().toASCIIString());\r\n        AnnotationUtils.getLogger().fine(\"classLoader is \" + classLoader);\r\n    }\r\n    String mainClassName = desc.getMainClassName();\r\n    addScanClassName(mainClassName);\r\n    String callbackHandler = desc.getCallbackHandler();\r\n    if (callbackHandler != null && !callbackHandler.trim().equals(\"\")) {\r\n        addScanClassName(desc.getCallbackHandler());\r\n    }\r\n    if (archive instanceof FileArchive) {\r\n        addScanDirectory(new File(archive.getURI()));\r\n    } else if (archive instanceof InputJarArchive) {\r\n        URI uriToAdd = archive.getURI();\r\n        addScanJar(scanJar(uriToAdd));\r\n    } else if (archive instanceof MultiReadableArchive) {\r\n        addScanURI(scanURI(((MultiReadableArchive) archive).getURI(1)));\r\n    }\r\n    this.classLoader = classLoader;\r\n    this.archiveFile = null;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsOpenCursorsAcrossCommit",
	"Comment": "retrieves whether this database supports keeping cursors openacross commits.",
	"Method": "boolean supportsOpenCursorsAcrossCommit(){\r\n    return databaseMetaData.supportsOpenCursorsAcrossCommit();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.support.JDOHelper.getArrayClassLoader",
	"Comment": "returns the first not null class loader for the elements of the object array.if element is itself an instance of the java.util.collection oran array it is recursively checked for its class loader.",
	"Method": "ClassLoader getArrayClassLoader(Object[] arr){\r\n    ClassLoader cl = null;\r\n    for (int i = 0; i < arr.length; i++) {\r\n        cl = getObjectClassLoader(arr[i]);\r\n        if (cl != null) {\r\n            break;\r\n        }\r\n    }\r\n    return cl;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.setIgnoreCache",
	"Comment": "sets the flag that allows the user to request that queries be optimized to returnapproximate results by ignoring changed values in the cache.",
	"Method": "void setIgnoreCache(boolean flag){\r\n    throw new JDOUnsupportedOptionException(// NOI18N\r\n    I18NHelper.getMessage(messages, \"jdo.persistencemanagerfactoryimpl.notsupported\"));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.getOptimistic",
	"Comment": "returns the boolean value of the optimistic flag for all persistencemanagers",
	"Method": "boolean getOptimistic(){\r\n    return _persistenceManagerFactory.getOptimistic();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.dataDefinitionIgnoredInTransactions",
	"Comment": "retrieves whether this database ignores a data definition statementwithin a transaction.",
	"Method": "boolean dataDefinitionIgnoredInTransactions(){\r\n    return databaseMetaData.dataDefinitionIgnoredInTransactions();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.SunContainerHelper.assertValidLocalObject",
	"Comment": "verify that this instance is of a valid local interface type fora given container helper.this is suncontainerhelper specific code.",
	"Method": "void assertValidLocalObject(Object o,Object container){\r\n    ((Container) container).assertValidLocalObject(o);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ee.SecuritySniffer.getContainersNames",
	"Comment": "returns the list of containers that this sniffer enables.the runtime will look up each container implementingusing the names provided in the habitat.",
	"Method": "String[] getContainersNames(){\r\n    return containers;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ConnectionHolder.prepareStatement",
	"Comment": "creates apreparedstatementobject for sendingparamterized sql statements to database",
	"Method": "PreparedStatement prepareStatement(String sql,PreparedStatement prepareStatement,String sql,int autoGeneratedKeys,PreparedStatement prepareStatement,String sql,int[] columnIndexes,PreparedStatement prepareStatement,String sql,int resultSetType,int resultSetConcurrency,PreparedStatement prepareStatement,String sql,int resultSetType,int resultSetConcurrency,int resultSetHoldability,PreparedStatement prepareStatement,String sql,String[] columnNames){\r\n    checkValidity();\r\n    jdbcPreInvoke();\r\n    PreparedStatement stmt = con.prepareStatement(sql, columnNames);\r\n    if (statementTimeoutEnabled) {\r\n        try {\r\n            stmt.setQueryTimeout(statementTimeout);\r\n        } catch (SQLException ex) {\r\n            stmt.close();\r\n        }\r\n    }\r\n    return stmt;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.UpdateStatement.addConstraint",
	"Comment": "batch helper method. adds the columnelement to the list ofcolumnrefs for the where clause and then calls addconstraint.",
	"Method": "void addConstraint(ColumnElement columnElement,LocalFieldDesc lf,Object value){\r\n    columnRefsForWhereClause.add(new ColumnRef(columnElement, value));\r\n    addConstraint(lf, value);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.util.FilePath.getAbsolutePath",
	"Comment": "return the absolute path for a file.all directory separators areconverted to be file.separatorchar",
	"Method": "String getAbsolutePath(File file){\r\n    String basicAbsolute = file.getAbsolutePath();\r\n    if (file.separatorChar == '/')\r\n        return basicAbsolute.replace('\\\\', '/');\r\n    else\r\n        return basicAbsolute.replace('/', '\\\\');\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.jqlc.VariableTable.markConstraint",
	"Comment": "mark the specified variable as constaint with the specified expr.the method sets the constraint field of the varinfo object to true.",
	"Method": "void markConstraint(JQLAST variable,JQLAST expr){\r\n    String name = variable.getText();\r\n    VarInfo entry = (VarInfo) varInfos.get(name);\r\n    if (entry == null)\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jqlc.variabletable.markconstraint.varnotfound\", name));\r\n    String old = (entry.constraint == null ? null : entry.constraint.getText());\r\n    if ((old != null) && !old.equals(expr.getText())) {\r\n        // NOI18N\r\n        errorMsg.unsupported(// NOI18N\r\n        variable.getLine(), variable.getColumn(), // NOI18N\r\n        I18NHelper.getMessage(messages, \"jqlc.variabletable.markconstraint.multiple\", name));\r\n    }\r\n    entry.constraint = expr;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.EJBHashSet.assertInTransaction",
	"Comment": "verifies that persistence manager is not closed andthe current transaction is active.",
	"Method": "void assertInTransaction(){\r\n    if (pm.isClosed() || !tx.isActive()) {\r\n        invalidate();\r\n        throw new IllegalStateException();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.persistence.ejb.entitybean.container.EntityBeanLocalHomeImpl.createEJBLocalObjectImpl",
	"Comment": "ejblocalobjectimpl is created directly by the container, not by this call",
	"Method": "EJBLocalObjectImpl createEJBLocalObjectImpl(){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.ArrayList.cloneInternal",
	"Comment": "creates and returns a copy of this object without resetting the owner and field value.",
	"Method": "Object cloneInternal(){\r\n    return super.clone();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingClassElementImpl.addTable",
	"Comment": "convenience method which accepts a table element and attempts to add \tit as either a primary or secondary table depending on the existing list\tof tables and the foreign keys for the table.",
	"Method": "void addTable(TableElement table){\r\n    if (table != null) {\r\n        ArrayList tables = getTables();\r\n        if (tables.isEmpty())\r\n            setPrimaryTable(table);\r\n        else {\r\n            HashMap newSecondaryTables = new HashMap();\r\n            Iterator iterator = tables.iterator();\r\n            boolean found = false;\r\n            while (iterator.hasNext()) if (((MappingTableElement) iterator.next()).isEqual(table))\r\n                return;\r\n            iterator = tables.iterator();\r\n            while (iterator.hasNext()) {\r\n                MappingTableElement mappingTable = (MappingTableElement) iterator.next();\r\n                String absoluteTableName = NameUtil.getAbsoluteTableName(_databaseRoot, mappingTable.getTable());\r\n                ForeignKeyElement[] foreignKeys = TableElement.forName(absoluteTableName).getForeignKeys();\r\n                int i, count = ((foreignKeys != null) ? foreignKeys.length : 0);\r\n                for (i = 0; i < count; i++) {\r\n                    ForeignKeyElement fk = foreignKeys[i];\r\n                    if (table == fk.getReferencedTable()) {\r\n                        newSecondaryTables.put(mappingTable, fk);\r\n                        found = true;\r\n                    }\r\n                }\r\n            }\r\n            if (found) {\r\n                iterator = newSecondaryTables.keySet().iterator();\r\n                while (iterator.hasNext()) {\r\n                    MappingTableElement mappingTable = (MappingTableElement) iterator.next();\r\n                    MappingReferenceKeyElement refKey = addSecondaryTable(mappingTable, table);\r\n                    refKey.addColumnPairs(((ForeignKeyElement) newSecondaryTables.get(mappingTable)).getColumnPairs());\r\n                }\r\n            } else {\r\n                throw new ModelException(I18NHelper.getMessage(getMessages(), \"mapping.table.foreign_key_not_found\", table));\r\n            }\r\n        }\r\n    } else {\r\n        throw new ModelException(// NOI18N\r\n        I18NHelper.getMessage(getMessages(), \"mapping.table.null_argument\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlTimestamp.setYear",
	"Comment": "sets the year of this sqltimestamp object to be the specifiedvalue plus 1900.",
	"Method": "void setYear(int year){\r\n    this.makeDirty();\r\n    super.setYear(year);\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.JMSDestination._getMQJMXConnectorInfoForCluster",
	"Comment": "gets the mqjmxconnector object for a cluster. since this code isexecuted in das, an admin api is used to resolve hostnames and ports ofcluster instances for local type brokers while creating the connectionurl.",
	"Method": "MQJMXConnectorInfo _getMQJMXConnectorInfoForCluster(String target,JmsService jmsService,Class mqRAClassName,ServerContext serverContext){\r\n    ResourceAdapter raInstance = null;\r\n    MQAddressList list = null;\r\n    try {\r\n        if (jmsService.getType().equalsIgnoreCase(ActiveJmsResourceAdapter.REMOTE)) {\r\n            list = getDefaultAddressList(jmsService);\r\n        } else {\r\n            list = new MQAddressList();\r\n            CommandTarget ctarget = this.getTypeForTarget(target);\r\n            if (ctarget == CommandTarget.CLUSTER) {\r\n                Server[] servers = list.getServersInCluster(target);\r\n                if (servers != null && servers.length > 0)\r\n                    list.setInstanceName(servers[0].getName());\r\n            } else if (ctarget == CommandTarget.CLUSTERED_INSTANCE) {\r\n                list.setInstanceName(target);\r\n            }\r\n            java.util.Map<String, JmsHost> hostMap = list.getResolvedLocalJmsHostsInMyCluster(true);\r\n            if (hostMap.size() == 0) {\r\n                String msg = localStrings.getLocalString(\"mqjmx.no_jms_hosts\", \"No JMS Hosts Configured\");\r\n                throw new ConnectorRuntimeException(msg);\r\n            }\r\n            for (JmsHost host : hostMap.values()) {\r\n                list.addMQUrl(host);\r\n            }\r\n        }\r\n        String connectionUrl = list.toString();\r\n        String adminUserName = null;\r\n        String adminPassword = null;\r\n        JmsHost jmsHost = list.getDefaultJmsHost(jmsService);\r\n        if (jmsHost != null) {\r\n            adminUserName = jmsHost.getAdminUserName();\r\n            adminPassword = JmsRaUtil.getUnAliasedPwd(jmsHost.getAdminPassword());\r\n        } else {\r\n            if (logger.isLoggable(Level.FINE)) {\r\n                logger.log(Level.FINE, \" _getMQJMXConnectorInfo, using default jms admin user and password \");\r\n            }\r\n        }\r\n        raInstance = getConfiguredRA(mqRAClassName, connectionUrl, adminUserName, adminPassword);\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        ConnectorRuntimeException cre = new ConnectorRuntimeException(e.getMessage());\r\n        cre.initCause(e);\r\n        throw cre;\r\n    }\r\n    try {\r\n        String jmxServiceURL = null, jmxServiceURLList = null;\r\n        Map<String, ?> jmxConnectorEnv = null;\r\n        Method[] methds = raInstance.getClass().getMethods();\r\n        for (int i = 0; i < methds.length; i++) {\r\n            Method m = methds[i];\r\n            if (m.getName().equalsIgnoreCase(\"get\" + JMXSERVICEURLLIST)) {\r\n                jmxServiceURLList = (String) m.invoke(raInstance, new Object[] {});\r\n                if (jmxServiceURLList != null && !jmxServiceURLList.trim().equals(\"\")) {\r\n                    jmxServiceURL = getFirstJMXServiceURL(jmxServiceURLList);\r\n                }\r\n            } else if (m.getName().equalsIgnoreCase(\"get\" + JMXCONNECTORENV)) {\r\n                jmxConnectorEnv = (Map<String, ?>) m.invoke(raInstance, new Object[] {});\r\n            }\r\n        }\r\n        MQJMXConnectorInfo mqInfo = new MQJMXConnectorInfo(target, ActiveJmsResourceAdapter.getBrokerInstanceName(jmsService), jmsService.getType(), jmxServiceURL, jmxConnectorEnv);\r\n        return mqInfo;\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        ConnectorRuntimeException cre = new ConnectorRuntimeException(e.getMessage());\r\n        cre.initCause(e);\r\n        throw cre;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.detectAppBasedProviders",
	"Comment": "detect if a stats provider has already been registered to themonitoring framework for this appname and if so, return the specificemitter. if not already registered, create and register thestats provider object to the monitoring framework and add to the listof emitters.",
	"Method": "ConnectionPoolAppEmitterImpl detectAppBasedProviders(String appName){\r\n    ConnectionPoolAppProbeProvider probeAppProvider = null;\r\n    ConnectionPoolAppEmitterImpl connPoolAppEmitter = null;\r\n    if (appName == null) {\r\n        return null;\r\n    }\r\n    if (appStatsMap.containsKey(poolInfo)) {\r\n        Map<String, ConnectionPoolAppEmitterImpl> appEmitters = appStatsMap.get(poolInfo);\r\n        ConnectionPoolAppEmitterImpl emitter = appEmitters.get(appName);\r\n        if (emitter != null) {\r\n            return emitter;\r\n        } else {\r\n            if (!ConnectorsUtil.isApplicationScopedResource(poolInfo)) {\r\n                probeAppProvider = registerConnectionPool(appName);\r\n                connPoolAppEmitter = addToList(appName, probeAppProvider, appEmitters);\r\n            }\r\n        }\r\n    } else {\r\n        if (!ConnectorsUtil.isApplicationScopedResource(poolInfo)) {\r\n            probeAppProvider = registerConnectionPool(appName);\r\n            Map<String, ConnectionPoolAppEmitterImpl> appEmitters = new HashMap<String, ConnectionPoolAppEmitterImpl>();\r\n            connPoolAppEmitter = addToList(appName, probeAppProvider, appEmitters);\r\n        }\r\n    }\r\n    return connPoolAppEmitter;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.FieldAction.fieldClassName",
	"Comment": "for references fields, return the base type class name if a classor interface, else null.",
	"Method": "String fieldClassName(){\r\n    return fieldClassName;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.EJBBundleInfoHelper.getSchema",
	"Comment": "gets the schema with the specified name, loading it if necessary.\tthis implementation uses the class loader as the extra context \tinformation used to load.",
	"Method": "SchemaElement getSchema(String schemaName){\r\n    return SchemaElement.forName(schemaName, getClassLoader());\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.constraint.Constraint.addValue",
	"Comment": "adds a data value to the constraint stack. creates a constraintvaluenode whose value is value and adds it to the constraint stack.",
	"Method": "void addValue(Object value,LocalFieldDesc localField){\r\n    stack.add(new ConstraintValue(value, localField));\r\n}"
}, {
	"Path": "com.sun.enterprise.security.provider.BasePolicyWrapper.getNewPolicy",
	"Comment": "gets the underlying policyfile implementationcan be overridden by subclass",
	"Method": "java.security.Policy getNewPolicy(){\r\n    return (java.security.Policy) new sun.security.provider.PolicyFile();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.addUpdatedForeignReference",
	"Comment": "adds a dependency for state manager sm. statemanager sm must wait for this to beflushed to the store before it can be written itself. statemanager sm is added to the list of objectsdepending on this and will be notified whenthis is written to the store. store updates tosm are disabled until then. this dependency isestablished to maintain referential integrity conditions in thedata store.",
	"Method": "void addUpdatedForeignReference(ForeignFieldDesc fieldDesc,SQLStateManager sm){\r\n    if (sm == this) {\r\n        return;\r\n    }\r\n    if (updatedForeignReferences == null) {\r\n        updatedForeignReferences = new HashSet();\r\n        if ((stateFlags & ST_REGISTERED) == 0) {\r\n            persistenceManager.registerInstance(this, getObjectId(), false, true);\r\n            stateFlags |= ST_REGISTERED;\r\n        }\r\n    }\r\n    if (updatedForeignReferences.add(new UpdatedForeignReference(fieldDesc, sm))) {\r\n        sm.stateFlags |= ST_UPDATE_DISABLED;\r\n        sm.referenceCount++;\r\n        if (logger.isLoggable()) {\r\n            String fieldName = (fieldDesc != null) ? fieldDesc.getName() : null;\r\n            Object[] items = new Object[] { this.persistentObject, fieldName, sm.persistentObject, new Integer(sm.referenceCount) };\r\n            logger.fine(\"sqlstore.sqlstatemanager.addupdate\", items);\r\n        }\r\n        if ((sm.stateFlags & ST_REGISTERED) == 0) {\r\n            persistenceManager.registerInstance(sm, sm.getObjectId(), false, true);\r\n            sm.stateFlags |= ST_REGISTERED;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.isByteArray",
	"Comment": "determines if the specified classname represents a byte array.",
	"Method": "boolean isByteArray(String className,String fieldName,boolean isByteArray,String className){\r\n    return (\"byte[]\".equals(className));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.concurrency.ConcurrencyCheckDirty.addConstraint",
	"Comment": "adds a comparison for local field lf and value valto the corresponding statements in updatequeryplan plan.",
	"Method": "void addConstraint(UpdateQueryPlan plan,LocalFieldDesc lf,Object val){\r\n    for (Iterator iter = lf.getColumnElements(); iter.hasNext(); ) {\r\n        ColumnElement c = (ColumnElement) iter.next();\r\n        for (int i = 0; i < plan.statements.size(); i++) {\r\n            Statement s = (Statement) plan.statements.get(i);\r\n            for (int j = 0; j < s.tableList.size(); j++) {\r\n                QueryTable t = (QueryTable) s.tableList.get(j);\r\n                if (t.getTableDesc().getTableElement() == c.getDeclaringTable()) {\r\n                    s.addConstraint(lf, val);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.UpdateStatement.getFormattedSQLText",
	"Comment": "gets formatted sql text corrsponding to this statement object. the textalso contains values for input to the statement.",
	"Method": "String getFormattedSQLText(UpdateObjectDescImpl updateDesc){\r\n    return formatSqlText(getText(), getInputValues(updateDesc));\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.XAResourceImpl.recover",
	"Comment": "obtain a list of prepared transaction branches from a resource manager.",
	"Method": "Xid[] recover(int flag){\r\n    return xar.recover(flag);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnUtils.aLoad",
	"Comment": "return the best instruction for loading a reference from a localvariable slot",
	"Method": "Insn aLoad(int i,ConstantPool pool){\r\n    if (i == 0)\r\n        return Insn.create(opc_aload_0);\r\n    else if (i == 1)\r\n        return Insn.create(opc_aload_1);\r\n    else if (i == 2)\r\n        return Insn.create(opc_aload_2);\r\n    else if (i == 3)\r\n        return Insn.create(opc_aload_3);\r\n    return Insn.create(opc_aload, i);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.getPersistenceClass",
	"Comment": "returns a persistenceclasselement created from the mapping class.",
	"Method": "PersistenceClassElement getPersistenceClass(String className,PersistenceClassElement getPersistenceClass,String className,ClassLoader classLoader,PersistenceClassElement getPersistenceClass,MappingClassElement mappingClass){\r\n    return ((mappingClass == null) ? null : ((MappingClassElementImpl) mappingClass).getPersistenceElement());\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.getManagedConnectionFactory",
	"Comment": "returns the managedconnectionfactory instance thatcreated this managedconnection instance.",
	"Method": "com.sun.gjc.spi.ManagedConnectionFactoryImpl getManagedConnectionFactory(){\r\n    return (com.sun.gjc.spi.ManagedConnectionFactoryImpl) mcf;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.util.TypeUtil.truncateFloat",
	"Comment": "truncate a float to the required number of significant digits.",
	"Method": "String truncateFloat(float f,int digits){\r\n    double factor = Math.pow(10, digits);\r\n    f = (float) (Math.round(f * factor) / factor);\r\n    return Float.toString(f);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.archivist.EjbInWarArchivist.getScanner",
	"Comment": "returns the scanner for this archivist, usually it is the scanner registeredwith the same module type as this archivist, but subclasses can return adifferent version",
	"Method": "ModuleScanner getScanner(){\r\n    return scanner.get();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.addFieldElement",
	"Comment": "adds a persistencefieldelement for the specified field to the\tsupplied persistenceclasselement, creating a relationshipelement if\tnecessary.",
	"Method": "boolean addFieldElement(PersistenceClassElement element,String fieldName){\r\n    String fieldType = getFieldType(element.getName(), fieldName);\r\n    boolean isCollection = isCollection(fieldType);\r\n    try {\r\n        if (isPersistent(fieldType) || isCollection) {\r\n            RelationshipElement relationship = new RelationshipElement(new RelationshipElementImpl(fieldName), element);\r\n            if (isCollection) {\r\n                relationship.setCollectionClass(getDefaultCollectionClass(fieldType));\r\n            } else\r\n                relationship.setUpperBound(1);\r\n            element.addField(relationship);\r\n        } else {\r\n            element.addField(new PersistenceFieldElement(new PersistenceFieldElementImpl(fieldName), element));\r\n        }\r\n        return true;\r\n    } catch (ModelException e) {\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.connection.ConnectionImpl.toString",
	"Comment": "return a string representation of this connectionimpl object.",
	"Method": "String toString(){\r\n    int xactIsolation = 0;\r\n    String buffer = \"Connect@\";\r\n    String strTran = // NOI18N\r\n    (this.transaction == null) ? \"  NULL\" : this.transaction.toString();\r\n    int hash = this.hashCode();\r\n    try {\r\n        xactIsolation = this.getTransactionIsolation();\r\n    } catch (SQLException ex) {\r\n        xactIsolation = -1;\r\n    }\r\n    buffer = buffer + hash + \"\\n\" + \"  pooled = \" + this.pooled + \"\\n\" + \"  freePending = \" + this.freePending + \"\\n\" + \"  xactIsolation = \" + xactIsolation + \"\\n\" + \"  Tran = \" + strTran + \"\\n\";\r\n    return buffer;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.BaseContainer.checkExceptionClientTx",
	"Comment": "also called from entitycontainer.removebean for cascaded deletes",
	"Method": "Throwable checkExceptionClientTx(EJBContextImpl context,Throwable exception){\r\n    return containerTransactionManager.checkExceptionClientTx(context, exception);\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.DeleteJMSResource.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (jndiName == null) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.jms.resource.noJndiName\", \"No JNDI name defined for JMS Resource.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    jndiNameForConnectionPool = jndiName + JNDINAME_APPENDER;\r\n    ActionReport subReport = report.addSubActionsReport();\r\n    ConnectorResource cresource = null;\r\n    Resource res = ConnectorsUtil.getResourceByName(domain.getResources(), ConnectorResource.class, jndiName);\r\n    if (res instanceof ConnectorResource) {\r\n        cresource = (ConnectorResource) res;\r\n    }\r\n    if (cresource == null) {\r\n        ParameterMap params = new ParameterMap();\r\n        params.set(\"jndi_name\", jndiName);\r\n        params.set(\"DEFAULT\", jndiName);\r\n        params.set(\"target\", target);\r\n        commandRunner.getCommandInvocation(\"delete-admin-object\", subReport, context.getSubject()).parameters(params).execute();\r\n        if (ActionReport.ExitCode.FAILURE.equals(subReport.getActionExitCode())) {\r\n            report.setMessage(localStrings.getLocalString(\"delete.jms.resource.cannotDeleteJMSAdminObject\", \"Unable to Delete Admin Object.\"));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    } else {\r\n        if (!cascade) {\r\n            Collection<ConnectorResource> connectorResources = domain.getResources().getResources(ConnectorResource.class);\r\n            String connPoolName = jndiName + JNDINAME_APPENDER;\r\n            int count = 0;\r\n            for (ConnectorResource resource : connectorResources) {\r\n                if (connPoolName.equals(resource.getPoolName())) {\r\n                    count++;\r\n                    if (count > 1)\r\n                        break;\r\n                }\r\n            }\r\n            if (count > 1) {\r\n                report.setMessage(localStrings.getLocalString(\"found.more.connector.resources\", \"Some connector resources are referencing connection pool {0}. Use 'cascade' option to delete them\", connPoolName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n        ActionReport listReport = habitat.getService(ActionReport.class);\r\n        ParameterMap listParams = new ParameterMap();\r\n        listParams.set(\"target\", target);\r\n        commandRunner.getCommandInvocation(\"list-jms-resources\", listReport, context.getSubject()).parameters(listParams).execute();\r\n        if (ActionReport.ExitCode.FAILURE.equals(listReport.getActionExitCode())) {\r\n            report.setMessage(localStrings.getLocalString(\"list.jms.resources.fail\", \"Unable to list JMS Resources\"));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n        Properties extraProps = listReport.getExtraProperties();\r\n        if (extraProps != null && extraProps.size() > 0) {\r\n            boolean resourceExist = false;\r\n            for (int i = 0; i < extraProps.size(); i++) {\r\n                List<Map<String, String>> nameList = (List) extraProps.get(\"jmsResources\");\r\n                for (Map<String, String> m : nameList) {\r\n                    String jndi = (String) m.get(\"name\");\r\n                    if (jndiName.equals(jndi)) {\r\n                        resourceExist = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (resourceExist)\r\n                    break;\r\n            }\r\n            if (!resourceExist) {\r\n                report.setMessage(localStrings.getLocalString(\"jms.resources.not.found\", \"JMS Resource {0} not found\", jndiName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n        String defPoolName = jndiNameForConnectionPool;\r\n        String poolName = cresource.getPoolName();\r\n        if (poolName != null && poolName.equals(defPoolName)) {\r\n            ParameterMap params = new ParameterMap();\r\n            params.set(\"DEFAULT\", jndiName);\r\n            params.set(\"connector_resource_name\", jndiName);\r\n            params.set(\"target\", target);\r\n            commandRunner.getCommandInvocation(\"delete-connector-resource\", subReport, context.getSubject()).parameters(params).execute();\r\n            if (ActionReport.ExitCode.FAILURE.equals(subReport.getActionExitCode())) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.jms.resource.cannotDeleteJMSResource\", \"Unable to Delete Connector Resource.\"));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n            params = new ParameterMap();\r\n            params.set(\"poolname\", jndiName);\r\n            params.set(\"cascade\", cascade.toString());\r\n            params.set(\"DEFAULT\", jndiNameForConnectionPool);\r\n            commandRunner.getCommandInvocation(\"delete-connector-connection-pool\", subReport, context.getSubject()).parameters(params).execute();\r\n            if (ActionReport.ExitCode.FAILURE.equals(subReport.getActionExitCode())) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.jms.resource.cannotDeleteJMSPool\", \"Unable to Delete Connector Connection Pool.\"));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n            subReport.setMessage(\"\");\r\n        } else {\r\n            ParameterMap params = new ParameterMap();\r\n            params.set(\"DEFAULT\", jndiName);\r\n            params.set(\"connector_resource_name\", jndiName);\r\n            params.set(\"target\", target);\r\n            commandRunner.getCommandInvocation(\"delete-connector-resource\", subReport, context.getSubject()).parameters(params).execute();\r\n            if (ActionReport.ExitCode.FAILURE.equals(subReport.getActionExitCode())) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.jms.resource.cannotDeleteJMSResource\", \"Unable to Delete Connector Resource.\"));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    ActionReport.ExitCode ec = ActionReport.ExitCode.SUCCESS;\r\n    report.setActionExitCode(ec);\r\n}"
}, {
	"Path": "org.glassfish.concurrent.admin.CreateManagedThreadFactory.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    HashMap attrList = new HashMap();\r\n    attrList.put(ResourceConstants.JNDI_NAME, jndiName);\r\n    attrList.put(ResourceConstants.CONTEXT_INFO_ENABLED, contextinfoenabled.toString());\r\n    attrList.put(ResourceConstants.CONTEXT_INFO, contextinfo);\r\n    attrList.put(ResourceConstants.THREAD_PRIORITY, threadpriority.toString());\r\n    attrList.put(ServerTags.DESCRIPTION, description);\r\n    attrList.put(ResourceConstants.ENABLED, enabled.toString());\r\n    ResourceStatus rs;\r\n    try {\r\n        rs = managedThreadFactoryMgr.create(domain.getResources(), attrList, properties, target);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"create.managed.thread.factory.failed\", \"Managed thread factory {0} creation failed\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    ActionReport.ExitCode ec = ActionReport.ExitCode.SUCCESS;\r\n    if (rs.getMessage() != null) {\r\n        report.setMessage(rs.getMessage());\r\n    }\r\n    if (rs.getStatus() == ResourceStatus.FAILURE) {\r\n        ec = ActionReport.ExitCode.FAILURE;\r\n        if (rs.getException() != null)\r\n            report.setFailureCause(rs.getException());\r\n    }\r\n    report.setActionExitCode(ec);\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.JMSDestination.getMQAdapter",
	"Comment": "starts the mq ra in the das, as all mq related operations are performed in das.",
	"Method": "ActiveJmsResourceAdapter getMQAdapter(ConnectorRuntime connectorRuntime){\r\n    ActiveJmsResourceAdapter air = (ActiveJmsResourceAdapter) java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction() {\r\n        public java.lang.Object run() throws Exception {\r\n            String module = ConnectorConstants.DEFAULT_JMS_ADAPTER;\r\n            String loc = ConnectorsUtil.getSystemModuleLocation(module);\r\n            connectorRuntime.createActiveResourceAdapter(loc, module, null);\r\n            return (ActiveJmsResourceAdapter) ConnectorRegistry.getInstance().getActiveResourceAdapter(module);\r\n        }\r\n    });\r\n    return air;\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.JMSDestination.getMQAdapter",
	"Comment": "starts the mq ra in the das, as all mq related operations are performed in das.",
	"Method": "ActiveJmsResourceAdapter getMQAdapter(ConnectorRuntime connectorRuntime){\r\n    String module = ConnectorConstants.DEFAULT_JMS_ADAPTER;\r\n    String loc = ConnectorsUtil.getSystemModuleLocation(module);\r\n    connectorRuntime.createActiveResourceAdapter(loc, module, null);\r\n    return (ActiveJmsResourceAdapter) ConnectorRegistry.getInstance().getActiveResourceAdapter(module);\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.database.PropertyHelper.loadFromResource",
	"Comment": "loads properties list from the specified resource into specified properties object.",
	"Method": "void loadFromResource(Properties properties,String resourceName,ClassLoader classLoader){\r\n    load(properties, resourceName, false, classLoader);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.common.wls.ResourceDescriptionNode.writeDescriptors",
	"Comment": "write all occurrences of the descriptor corresponding to the currentnode from the parent descriptor to an jaxp dom node and return itthis api will be invoked by the parent node when the parent nodewrites out a mix of statically and dynamically registered sub nodes.this method should be overriden by the sub classes if itneeds to be called by the parent node.",
	"Method": "Node writeDescriptors(Node parent,String nodeName,Descriptor parentDesc){\r\n    if (parentDesc instanceof ResourceReferenceContainer) {\r\n        ResourceReferenceContainer resourceReferenceContainer = (ResourceReferenceContainer) parentDesc;\r\n        Set<ResourceReferenceDescriptor> resourceReferenceDescriptors = resourceReferenceContainer.getResourceReferenceDescriptors();\r\n        for (ResourceReferenceDescriptor resourceReferenceDescriptor : resourceReferenceDescriptors) {\r\n            writeDescriptor(parent, nodeName, resourceReferenceDescriptor);\r\n        }\r\n    }\r\n    return parent;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.getType",
	"Comment": "returns the string representation of type of the specified element. \tif element denotes a field, it returns the type of the field. \tif element denotes a method, it returns the return type of the method. \tnote, element is either a field element as returned by getfield, or a \tmethod element as returned by getmethod executed on the same model \tinstance.",
	"Method": "String getType(Object element){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.ActiveJmsResourceAdapter.postRAConfiguration",
	"Comment": "method to perform any post ra configuration action by derivative subclasses.for example, this method is used by activejmsresourceadapterto set unsupported javabean property types on its ra javabean runtimeinstance.",
	"Method": "void postRAConfiguration(){\r\n    try {\r\n        if (dbProps == null)\r\n            dbProps = new Properties();\r\n        dbProps.setProperty(\"imq.cluster.dynamicChangeMasterBrokerEnabled\", \"true\");\r\n        Method mthds = this.resourceadapter_.getClass().getMethod(\"setBrokerProps\", Properties.class);\r\n        if (_logger.isLoggable(Level.FINE))\r\n            logFine(\"Setting property:\" + DB_HADB_PROPS + \"=\" + dbProps.toString());\r\n        mthds.invoke(this.resourceadapter_, new Object[] { dbProps });\r\n    } catch (Exception e) {\r\n        ConnectorRuntimeException crex = new ConnectorRuntimeException(e.getMessage());\r\n        throw (ConnectorRuntimeException) crex.initCause(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getObject",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object as an objectin the java programming language.if the value is an sql null,the driver returns a java null.this method uses the specified map object forcustom mapping if appropriate.",
	"Method": "Object getObject(int columnIndex,Object getObject,String columnName,Object getObject,int i,Map<String, Class<?>> map,Object getObject,String colName,Map<String, Class<?>> map){\r\n    return resultSet.getObject(colName, map);\r\n}"
}, {
	"Path": "org.glassfish.loadbalancer.admin.cli.reader.impl.IdempotentUrlPatternReaderImpl.getUrlPattern",
	"Comment": "returns a regular expression containing an url or url pattern.",
	"Method": "String getUrlPattern(){\r\n    return _pattern.getAttributeValue(IdempotentUrlPattern.URL_PATTERN);\r\n}"
}, {
	"Path": "com.sun.ejb.containers.util.cache.LruSessionCache.trimUnSortedTimedoutItems",
	"Comment": "this method picks idle items from a cache which does not have a sortedlru listnru cache at light loads and fifo caches do not maintain a lru list andhence they have to scan the entire cache and select victims",
	"Method": "void trimUnSortedTimedoutItems(int maxCount){\r\n    int maxIndex = buckets.length;\r\n    long idleThreshold = System.currentTimeMillis() - timeout;\r\n    ArrayList victims = new ArrayList();\r\n    int sz = 0;\r\n    int totalSize = 0;\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"[\" + cacheName + \"]: TrimUnsortedTimedoutBeans started...\");\r\n    }\r\n    for (int index = 0; index < maxIndex; index++) {\r\n        if (buckets[index] != null) {\r\n            synchronized (bucketLocks[index]) {\r\n                for (CacheItem item = buckets[index]; item != null; item = item.getNext()) {\r\n                    StatefulEJBContext ctx = (StatefulEJBContext) item.getValue();\r\n                    if ((ctx != null) && (ctx.getLastAccessTime() <= idleThreshold) && ctx.canBePassivated()) {\r\n                        LruCacheItem litem = (LruCacheItem) item;\r\n                        synchronized (this) {\r\n                            if (currentCacheState != STATE_RUNNING) {\r\n                                _logger.log(Level.WARNING, EXITING_TRIM_UNSORTED_TIMEDOUT_BEANS, new Object[] { cacheName, currentCacheState });\r\n                                break;\r\n                            }\r\n                            if (!litem.isTrimmed()) {\r\n                                itemRemoved(litem);\r\n                                litem.setTrimmed(true);\r\n                                victims.add(litem);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            sz = victims.size();\r\n            if (sz >= container.getPassivationBatchCount()) {\r\n                trimSelectedVictims(victims);\r\n                totalSize += sz;\r\n                victims.clear();\r\n            }\r\n        }\r\n    }\r\n    sz = victims.size();\r\n    if (sz > 0) {\r\n        trimSelectedVictims(victims);\r\n        totalSize += sz;\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"[\" + cacheName + \"]: TrimUnsortedTimedoutBeans \" + \" finished after removing \" + totalSize + \" idle beans\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.PreparedStatementWrapper40.setSQLXML",
	"Comment": "sets the designated parameter to the given java.sql.sqlxml object.the driver converts this to ansql xml value when it sends it to the database.",
	"Method": "void setSQLXML(int parameterIndex,SQLXML xmlObject){\r\n    preparedStatement.setSQLXML(parameterIndex, xmlObject);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxColumnNameLength",
	"Comment": "retrieves the maximum number of characters this database allowsfor a column name.",
	"Method": "int getMaxColumnNameLength(){\r\n    return databaseMetaData.getMaxColumnNameLength();\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.optional.BackupCommands.checkOptions",
	"Comment": "a method that checks the options and operand that the user supplied.these tests are slightly different for different cli commands",
	"Method": "void checkOptions(){\r\n    if (verbose && programOpts.isTerse())\r\n        throw new CommandValidationException(strings.get(\"NoVerboseAndTerseAtTheSameTime\"));\r\n    if (domainDirParam == null || domainDirParam.length() <= 0) {\r\n        try {\r\n            domainDirParam = DomainDirs.getDefaultDomainsDir().getPath();\r\n        } catch (IOException ioe) {\r\n            throw new CommandException(ioe.getMessage());\r\n        }\r\n    }\r\n    File domainsDirFile = new File(domainDirParam);\r\n    if (!domainsDirFile.isDirectory()) {\r\n        throw new CommandValidationException(strings.get(\"InvalidDomainPath\", domainDirParam));\r\n    }\r\n    if (domainName == null)\r\n        domainName = getDomainName();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.getRetainValues",
	"Comment": "returns the boolean value for the flag that will not cause the eviction of persistentinstances after transaction completion.",
	"Method": "boolean getRetainValues(){\r\n    return _persistenceManagerFactory.getRetainValues();\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnectionMetaData.getMaxConnections",
	"Comment": "returns maximum limit on number of active concurrent connectionsthat an eis instance can support across client processes.",
	"Method": "int getMaxConnections(){\r\n    try {\r\n        return dmd.getMaxConnections();\r\n    } catch (SQLException sqle) {\r\n        _logger.log(Level.SEVERE, \"jdbc.exc_eis_maxconn\");\r\n        throw new ResourceException(sqle.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.XAResourceImpl.forget",
	"Comment": "tell the resource manager to forget about a heuristically completed transaction branch.",
	"Method": "void forget(Xid xid){\r\n    xar.forget(xid);\r\n}"
}, {
	"Path": "org.glassfish.loadbalancer.admin.cli.helper.LbConfigHelper.exportWorkerProperties",
	"Comment": "exports the workser.properties from the config to the outputstream provided",
	"Method": "void exportWorkerProperties(LoadbalancerReader lbRdr,OutputStream out){\r\n    Loadbalancer _lb = new Loadbalancer();\r\n    Properties props = new Properties();\r\n    String WORKER = \"worker\";\r\n    String SEPARATOR = \".\";\r\n    String HOST = \"host\";\r\n    String PORT = \"port\";\r\n    String LIST = \"list\";\r\n    String TYPE = \"type\";\r\n    String TYPE_VALUE = \"ajp13\";\r\n    String LBFACTOR = \"lbfactor\";\r\n    String LBFACTOR_VALUE = \"1\";\r\n    String SOCKET_KEEPALIVE = \"socket_keepalive\";\r\n    String SOCKET_TIMEOUT = \"socket_timeout\";\r\n    String SOCKET_KEEPALIVE_VALUE = \"1\";\r\n    String SOCKET_TIMEOUT_VALUE = \"300\";\r\n    String LOADBALANCER = \"-lb\";\r\n    String BALANCER_WORKERS = \"balance_workers\";\r\n    String LB = \"lb\";\r\n    String CONTEXT_ROOT_MAPPING = \"CONTEXT_ROOT_MAPPING\";\r\n    String APP = \"APP\";\r\n    StringBuffer buffer = new StringBuffer();\r\n    String workerList = \"\";\r\n    LoadbalancerVisitor lbVstr = new LoadbalancerVisitor(_lb);\r\n    lbRdr.accept(lbVstr);\r\n    ClusterReader[] clusterReaders = lbRdr.getClusters();\r\n    int c;\r\n    buffer.append(\"worker.properties\");\r\n    for (int i = 0; i < clusterReaders.length; i++) {\r\n        String clusterWorkerList = \"\";\r\n        ClusterReader clusterReader = clusterReaders[i];\r\n        String clusterName = clusterReader.getName();\r\n        WebModuleReader[] webmoduleReaders = clusterReader.getWebModules();\r\n        InstanceReader[] instanceReaders = clusterReader.getInstances();\r\n        for (int j = 0; j < instanceReaders.length; j++) {\r\n            InstanceReader instanceReader = instanceReaders[j];\r\n            String listenerHost = \"\";\r\n            String listenerPort = \"\";\r\n            StringTokenizer st = new StringTokenizer(instanceReader.getListeners(), \" \");\r\n            while (st.hasMoreElements()) {\r\n                String listener = st.nextToken();\r\n                if (listener.contains(\"ajp://\")) {\r\n                    listenerHost = listener.substring(listener.lastIndexOf(\"/\") + 1, listener.lastIndexOf(\":\"));\r\n                    listenerPort = listener.substring(listener.lastIndexOf(\":\") + 1, listener.length());\r\n                    break;\r\n                }\r\n            }\r\n            String listenterName = instanceReader.getName();\r\n            props.setProperty(WORKER + SEPARATOR + listenterName + SEPARATOR + HOST, listenerHost);\r\n            props.setProperty(WORKER + SEPARATOR + listenterName + SEPARATOR + PORT, listenerPort);\r\n            props.setProperty(WORKER + SEPARATOR + listenterName + SEPARATOR + TYPE, TYPE_VALUE);\r\n            props.setProperty(WORKER + SEPARATOR + listenterName + SEPARATOR + LBFACTOR, LBFACTOR_VALUE);\r\n            props.setProperty(WORKER + SEPARATOR + listenterName + SEPARATOR + SOCKET_KEEPALIVE, SOCKET_KEEPALIVE_VALUE);\r\n            props.setProperty(WORKER + SEPARATOR + listenterName + SEPARATOR + SOCKET_TIMEOUT, SOCKET_TIMEOUT_VALUE);\r\n            workerList = workerList + listenterName + \",\";\r\n            clusterWorkerList = clusterWorkerList + listenterName + \",\";\r\n        }\r\n        workerList = workerList + clusterName + LOADBALANCER + \",\";\r\n        props.setProperty(WORKER + SEPARATOR + LIST, workerList.substring(0, workerList.length() - 1));\r\n        props.setProperty(WORKER + SEPARATOR + clusterName + LOADBALANCER + SEPARATOR + TYPE, LB);\r\n        props.setProperty(WORKER + SEPARATOR + clusterName + LOADBALANCER + SEPARATOR + BALANCER_WORKERS, clusterWorkerList.substring(0, clusterWorkerList.length() - 1));\r\n        for (int m = 0; m < webmoduleReaders.length; m++) {\r\n            buffer.append(\"\\n\" + CONTEXT_ROOT_MAPPING + SEPARATOR + webmoduleReaders[m].getContextRoot() + \"=\" + clusterName + LOADBALANCER);\r\n        }\r\n    }\r\n    try {\r\n        props.store(out, buffer.toString());\r\n    } finally {\r\n        if (out != null) {\r\n            out.close();\r\n            out = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.support.JDOHelper.getCollectionClassLoader",
	"Comment": "returns the class loader for the elements of the collection.if element is itself an instance of the java.util.collection oran array it is recursively checked for its class loader.",
	"Method": "ClassLoader getCollectionClassLoader(Collection col){\r\n    Object[] arr = col.toArray();\r\n    return getArrayClassLoader(arr);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.isValidByTableQuery",
	"Comment": "checks if a java.sql.connection is valid or notby querying a table.",
	"Method": "void isValidByTableQuery(java.sql.Connection con,String tableName){\r\n    if (con == null) {\r\n        throw new ResourceException(\"The connection is not valid as \" + \"the connection is null\");\r\n    }\r\n    java.sql.PreparedStatement stmt = null;\r\n    java.sql.ResultSet rs = null;\r\n    try {\r\n        final String statement = \"SELECT COUNT(*) FROM \" + tableName;\r\n        stmt = con.prepareStatement(statement);\r\n        rs = stmt.executeQuery();\r\n    } catch (Exception sqle) {\r\n        _logger.log(Level.INFO, \"jdbc.exc_table_validation\", tableName);\r\n        throw new ResourceException(sqle);\r\n    } finally {\r\n        try {\r\n            if (rs != null) {\r\n                rs.close();\r\n            }\r\n        } catch (Exception e1) {\r\n        }\r\n        try {\r\n            if (stmt != null) {\r\n                stmt.close();\r\n            }\r\n        } catch (Exception e2) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnConstOp.value",
	"Comment": "return the constant pool entry which is the immediate operand",
	"Method": "ConstBasic value(){\r\n    return constValue;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectorConnPoolStatsProvider.connectionMatchedEvent",
	"Comment": "when connection under test matches the current request ,increment numconnsuccessfullymatched.",
	"Method": "void connectionMatchedEvent(String poolName,String appName,String moduleName){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (logger.isLoggable(Level.FINEST)) {\r\n            logger.finest(\"Connection matched event received - \" + \"poolName = \" + poolName);\r\n        }\r\n        numConnSuccessfullyMatched.increment();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.mejb.IIOPMBeanServerImpl.getMBeanCount",
	"Comment": "returns the number of mbeans registered in the mbean server.",
	"Method": "Integer getMBeanCount(){\r\n    return server.getMBeanCount();\r\n}"
}, {
	"Path": "org.glassfish.jdbcruntime.JdbcPoolMonitoringExtension.registerPool",
	"Comment": "register jdbc connection pool to the statsprovidermanager.add the pool lifecycle listeners for the pool to receive events onchange of any of the monitoring attribute values.finally, add this provider to the list of jdbc providers maintained.",
	"Method": "void registerPool(PoolInfo poolInfo){\r\n    if (poolManager.getPool(poolInfo) != null) {\r\n        getProbeProviderUtil().createJdbcProbeProvider();\r\n        JdbcConnPoolStatsProvider jdbcPoolStatsProvider = new JdbcConnPoolStatsProvider(poolInfo, logger);\r\n        StatsProviderManager.register(\"jdbc-connection-pool\", PluginPoint.SERVER, ConnectorsUtil.getPoolMonitoringSubTreeRoot(poolInfo, true), jdbcPoolStatsProvider);\r\n        PoolLifeCycleListenerRegistry registry = connectionPoolStatsProviderBootstrapProvider.get().registerPool(poolInfo, getProbeProviderUtil().getJdbcProbeProvider());\r\n        jdbcPoolStatsProvider.setPoolRegistry(registry);\r\n        jdbcStatsProviders.add(jdbcPoolStatsProvider);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.web.integration.WebPermissionUtil.removePolicyStatements",
	"Comment": "remove all policy statements from configurationconfig must be in open state when this method is called",
	"Method": "void removePolicyStatements(PolicyConfiguration pc,WebBundleDescriptor wbd){\r\n    pc.removeUncheckedPolicy();\r\n    pc.removeExcludedPolicy();\r\n    Set<Role> roleSet = wbd.getRoles();\r\n    for (Role r : roleSet) {\r\n        pc.removeRole(r.getName());\r\n    }\r\n    pc.removeRole(\"*\");\r\n    pc.removeRole(\"*\");\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.ConnectionPool.prefetch",
	"Comment": "overridden in assocwiththreadresourcepool to fetch the resourcecached in the threadlocalin connectionpool this simply returns null.",
	"Method": "ResourceHandle prefetch(ResourceSpec spec,ResourceAllocator alloc,Transaction tran){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.PreparedStatementWrapper.setBoolean",
	"Comment": "sets the designated parameter to the given java boolean value.the driver converts thisto an sql bit value when it sends it to the database.",
	"Method": "void setBoolean(int parameterIndex,boolean x){\r\n    preparedStatement.setBoolean(parameterIndex, x);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.FieldDesc.createSCO",
	"Comment": "creates a new sco instance. therefore checks if persistencemanagersettings require sco creation. scos will typically be createdin a non managed environment.",
	"Method": "Object createSCO(Object value,StateManager sm){\r\n    Object retVal = null;\r\n    PersistenceManager pm = null;\r\n    if (sm != null) {\r\n        pm = (PersistenceManager) sm.getPersistenceManagerInternal();\r\n    }\r\n    if (pm != null && pm.getRequireTrackedSCO()) {\r\n        retVal = pm.newSCOInstanceInternal(fieldType, sm.getPersistent(), getName());\r\n        initializeSCO(retVal, value);\r\n    }\r\n    return retVal;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ApplicationClientDescriptor.getEjbReferenceByName",
	"Comment": "looks up an ejb reference with the given name. throws an illegalargumentexception if it is not found.",
	"Method": "EjbReferenceDescriptor getEjbReferenceByName(String name){\r\n    for (Iterator itr = this.getEjbReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        EjbReferenceDescriptor ejr = (EjbReferenceDescriptor) itr.next();\r\n        if (ejr.getName().equals(name)) {\r\n            return ejr;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"exceptionappclienthasnoejbrefbyname\", \"This application client [{0}] has no ejb reference by the name of [{1}]\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.JdbcTempHandler.updateJDBCPoolWizardStep1",
	"Comment": "this handler gets the datasource classname and properties and sets them in session",
	"Method": "void updateJDBCPoolWizardStep1(HandlerContext handlerCtx){\r\n    Map extra = (Map) handlerCtx.getFacesContext().getExternalContext().getSessionMap().get(\"wizardPoolExtra\");\r\n    String resType = (String) extra.get(\"resType\");\r\n    String dbVendorBox = (String) extra.get(\"DBVendorBox\");\r\n    String dbVendorField = (String) extra.get(\"DBVendorField\");\r\n    String introspect = (String) extra.get(\"introspect\");\r\n    if (introspect == null || introspect.isEmpty()) {\r\n        introspect = Boolean.toString(false);\r\n    }\r\n    String dbVendor = (GuiUtil.isEmpty(dbVendorField)) ? dbVendorBox : dbVendorField;\r\n    extra.put(\"DBVendor\", dbVendor);\r\n    String previousResType = (String) extra.get(\"PreviousResType\");\r\n    String previousDB = (String) extra.get(\"PreviousDB\");\r\n    String previousInstrospect = (String) extra.get(\"PreviousIntrospect\");\r\n    if (resType.equals(previousResType) && dbVendor.equals(previousDB) && introspect.equals(previousInstrospect)) {\r\n    } else {\r\n        if (!GuiUtil.isEmpty(resType) && !GuiUtil.isEmpty(dbVendor)) {\r\n            try {\r\n                List dsl = getJdbcDriverClassNames(dbVendor, resType, Boolean.valueOf(introspect));\r\n                if (guiLogger.isLoggable(Level.FINE)) {\r\n                    guiLogger.fine(\"======= getJdbcDriverClassNames(\" + dbVendor + \", \" + resType + \")\");\r\n                    guiLogger.fine(\"=======  # of items for JDBC_DRIVER_CLASS_NAMES_KEY  \" + dsl.size());\r\n                    for (int i = 0; i < dsl.size(); i++) {\r\n                        guiLogger.fine(\"classname[\" + i + \"] : \" + dsl.get(i));\r\n                    }\r\n                }\r\n                List<Map<String, String>> noprops = new ArrayList<Map<String, String>>();\r\n                String dslName = (dsl != null && (dsl.size() > 0)) ? (String) dsl.get(0) : \"\";\r\n                if (resType.equals(DRIVER)) {\r\n                    extra.put(\"DList\", dsl);\r\n                    extra.put(\"DSList\", \"\");\r\n                    extra.put(\"DatasourceClassnameField\", \"\");\r\n                    extra.put(\"dsClassname\", Boolean.FALSE);\r\n                    extra.put(\"driverClassname\", dslName);\r\n                } else {\r\n                    extra.put(\"DSList\", dsl);\r\n                    extra.put(\"DList\", \"\");\r\n                    extra.put(\"DriverClassnameField\", \"\");\r\n                    extra.put(\"dsClassname\", Boolean.TRUE);\r\n                    extra.put(\"datasourceClassname\", dslName);\r\n                }\r\n                if (guiLogger.isLoggable(Level.FINE)) {\r\n                    guiLogger.fine(\"===== getConnectionDefinitionPropertiesAndDefaults(\\\"\" + dslName + \"\\\",\" + resType + \")\");\r\n                }\r\n                Map<String, String> props = getConnectionDefinitionPropertiesAndDefaults(dslName, resType);\r\n                if (props.size() > 0) {\r\n                    if (guiLogger.isLoggable(Level.FINE)) {\r\n                        guiLogger.fine(\"=======  getConnectionDefinitionPropertiesAndDefaults returns # of properties: \" + props.size());\r\n                    }\r\n                    handlerCtx.getFacesContext().getExternalContext().getSessionMap().put(\"wizardPoolProperties\", GuiUtil.convertMapToListOfMap(props));\r\n                } else {\r\n                    if (guiLogger.isLoggable(Level.FINE)) {\r\n                        guiLogger.fine(\"======= getConnectionDefinitionPropertiesAndDefaults returns NULL\");\r\n                    }\r\n                    handlerCtx.getFacesContext().getExternalContext().getSessionMap().put(\"wizardPoolProperties\", noprops);\r\n                }\r\n            } catch (Exception ex) {\r\n                GuiUtil.getLogger().info(GuiUtil.getCommonMessage(\"log.error.updateJDBCPoolWizardStep1\" + ex.getLocalizedMessage()));\r\n                if (GuiUtil.getLogger().isLoggable(Level.FINE)) {\r\n                    ex.printStackTrace();\r\n                }\r\n            }\r\n        } else {\r\n            if (DRIVER.equals(resType)) {\r\n                extra.put(\"DatasourceClassnameField\", \"\");\r\n                extra.put(\"dsClassname\", Boolean.FALSE);\r\n            } else {\r\n                extra.put(\"DatasourceClassnameField\", \"\");\r\n                extra.put(\"dsClassname\", Boolean.TRUE);\r\n            }\r\n        }\r\n        extra.put(\"PreviousResType\", resType);\r\n        extra.put(\"PreviousDB\", dbVendor);\r\n        extra.put(\"PreviousIntrospect\", introspect);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.util.SQLTraceCache.initializeTimerTask",
	"Comment": "instantiate the timer task used to perform a purgeentries on the cache",
	"Method": "SQLTraceTimerTask initializeTimerTask(){\r\n    if (_logger.isLoggable(Level.FINEST)) {\r\n        _logger.finest(\"Initializing Sql Trace Caching timer task\");\r\n    }\r\n    return new SQLTraceTimerTask(this);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.markReplacement",
	"Comment": "marks this instance as a replacement for a deleted instance with the sameobjectid.",
	"Method": "void markReplacement(){\r\n    isReplacementInstance = true;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.meta.JDOMetaDataPropertyImpl.getManagedFields",
	"Comment": "returns an array of field names of all declared, persistent fieldsof a class.",
	"Method": "String[] getManagedFields(String classname){\r\n    JDOClass clazz = getJDOClass(classname);\r\n    return (clazz != null ? clazz.getManagedFieldNames() : new String[] {});\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.DatabaseMetaDataWrapper40.autoCommitFailureClosesAllResultSets",
	"Comment": "retrieves whether a sqlexception while autocommit is true inidcatesthat all open resultsets are closed, even ones that are holdable.when a sqlexception occurs whileautocommit is true, it is vendor specific whether the jdbc driver responds with a commit operation, arollback operation, or by doing neither a commit nor a rollback.a potential result of this differenceis in whether or not holdable resultsets are closed.",
	"Method": "boolean autoCommitFailureClosesAllResultSets(){\r\n    return databaseMetaData.autoCommitFailureClosesAllResultSets();\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.ResourceHandle.isMarkedForReclaim",
	"Comment": "to check if the resourcehandle is marked for leak reclaim or not.",
	"Method": "boolean isMarkedForReclaim(){\r\n    return markedReclaim;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBTimerService.timerOwnedByThisServer",
	"Comment": "checks whether this timer is owned by the server instance inwhich we are running.",
	"Method": "boolean timerOwnedByThisServer(String ownerId){\r\n    String ownerIdOfThisServer = getOwnerIdOfThisServer();\r\n    return ((ownerIdOfThisServer != null) && (ownerIdOfThisServer.equals(ownerId)));\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.EjbReferenceDescriptor.setBeanClassName",
	"Comment": "sets the bean instance business interface classname of the bean to which i refer.this interface is the local object or the remote interfaces depending if the reference is local or not.",
	"Method": "void setBeanClassName(String remoteClassName){\r\n    refIntf = remoteClassName;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.PoolTxHelper.resourceEnlisted",
	"Comment": "this method is called when a resource is enlisted intransation tran",
	"Method": "void resourceEnlisted(Transaction tran,ResourceHandle resource){\r\n    try {\r\n        JavaEETransaction j2eetran = (JavaEETransaction) tran;\r\n        Set set = j2eetran.getResources(poolInfo);\r\n        if (set == null) {\r\n            set = new HashSet();\r\n            j2eetran.setResources(set, poolInfo);\r\n        }\r\n        set.add(resource);\r\n    } catch (ClassCastException e) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Pool [ \" + poolInfo + \" ]: resourceEnlisted:\" + \"transaction is not J2EETransaction but a \" + tran.getClass().getName(), e);\r\n        }\r\n    }\r\n    ResourceState state = resource.getResourceState();\r\n    state.setEnlisted(true);\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"Pool [ \" + poolInfo + \" ]: resourceEnlisted: \" + resource);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOCodeGenerator.getCMP20Generator",
	"Comment": "returns instance of generator for cmp2.x beans in this module.",
	"Method": "JDOConcreteBeanGenerator getCMP20Generator(){\r\n    if (cmp20Generator == null) {\r\n        cmp20Generator = new JDOConcreteBean20Generator(loader, model, nameMapper);\r\n        addSignatures(cmp20Generator);\r\n    }\r\n    return cmp20Generator;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.QueryImpl.compile",
	"Comment": "verify the elements of the query and provide a hint to the query toprepare and optimize an execution plan.",
	"Method": "void compile(){\r\n    synchronized (this.paramtab) {\r\n        if (!this.compiled) {\r\n            if (logger.isLoggable(Logger.FINER))\r\n                logger.finer(\"LOG_CompileQuery\", this);\r\n            jqlc = new JQLC();\r\n            jqlc.setClass(candidateClass);\r\n            jqlc.declareImports(importDeclarations);\r\n            jqlc.declareParameters(parameterDeclarations);\r\n            jqlc.declareVariables(variableDeclarations);\r\n            jqlc.setOrdering(orderingSpecification);\r\n            jqlc.setResult(resultExpression);\r\n            jqlc.setFilter(filterExpression);\r\n            jqlc.setPrefetchEnabled(prefetchEnabled);\r\n            jqlc.semanticCheck(paramtab);\r\n            this.compiled = true;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.logging.LoggerJDK14.isLoggable",
	"Comment": "check if a message of the given level would actually be loggedby this logger.this check is based on the loggers effective level,which may be inherited from its parent.",
	"Method": "boolean isLoggable(boolean isLoggable,int levelValue){\r\n    return isLoggable(convertLevel(levelValue));\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.PersistenceDescriptor.getPkeyFieldInfoByName",
	"Comment": "return persistentfieldinfo object for the given pkey field.",
	"Method": "PersistentFieldInfo getPkeyFieldInfoByName(String fieldName){\r\n    if (!fieldInfoInitialized)\r\n        initializeFieldInfo();\r\n    for (int i = 0; i < pkeyFieldInfo.length; i++) {\r\n        if (pkeyFieldInfo[i].name.equals(fieldName))\r\n            return pkeyFieldInfo[i];\r\n    }\r\n    throw new DeploymentException(\"PersistentFieldInfo not found for pkey field \" + fieldName);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.writeStandardDeploymentDescriptors",
	"Comment": "writes the standard deployment descriptors to an abstract archive",
	"Method": "void writeStandardDeploymentDescriptors(WritableArchive out){\r\n    getStandardDDFile().setArchiveType(getModuleType());\r\n    OutputStream os = out.putNextEntry(getDeploymentDescriptorPath());\r\n    standardDD.write(getDescriptor(), os);\r\n    out.closeEntry();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.PreparedStatementWrapper.setClob",
	"Comment": "sets the designated parameter to the given clob object.the driver converts this to an sql clob value when itsends it to the database.",
	"Method": "void setClob(int i,Clob x){\r\n    preparedStatement.setClob(i, x);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStoreManager.throwJDOSqlException",
	"Comment": "constructs the exception message including the executed sql statementsqltext and throws a jdodatastoreexception passing theoriginal exception.",
	"Method": "void throwJDOSqlException(SQLException e,String sqlText){\r\n    String exceptionMessage = // NOI18N\r\n    I18NHelper.getMessage(// NOI18N\r\n    messages, \"core.persistencestore.jdbcerror\", sqlText);\r\n    throw new JDODataStoreException(exceptionMessage, e);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsMixedCaseQuotedIdentifiers",
	"Comment": "retrieves whether this database treats mixed case quoted sql identifiers ascase sensitive and as a result stores them in mixed case.",
	"Method": "boolean supportsMixedCaseQuotedIdentifiers(){\r\n    return databaseMetaData.supportsMixedCaseQuotedIdentifiers();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceElementCollection.setOwner",
	"Comment": "set the owner of this collection to the supplied implementation.\tthis method should only be used internally and for cloning and \tarchiving.",
	"Method": "void setOwner(PersistenceElementImpl owner){\r\n    _owner = owner;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.CorrelatedSelectPlan.addQueryTables",
	"Comment": "adds the query tables corresponding to the columns in columnlist.",
	"Method": "void addQueryTables(ArrayList columnList,ClassDesc config){\r\n    for (int i = 0; i < columnList.size(); i++) {\r\n        ColumnElement col = (ColumnElement) columnList.get(i);\r\n        addQueryTable(col.getDeclaringTable(), config);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.SunContainerHelper.removeByEJBLocalObject",
	"Comment": "remove a bean for a given ejblocalobject and container helper.this is suncontainerhelper specific code.",
	"Method": "void removeByEJBLocalObject(EJBLocalObject ejb,Object container){\r\n    try {\r\n        ((Container) container).removeBeanUnchecked(ejb);\r\n    } catch (Exception ex) {\r\n        processContainerException(ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.QueryImpl.declareVariables",
	"Comment": "bind the unbound variable statements to the query instance.this method defines the types and names of variables that will be usedin the filter but not provided as values by the execute method.variables might be used in the filter, and these variables must bedeclared with their type. the unbound variable declaration is astring containing one or more unbound variable declarations separated withsemicolons. it follows the syntax for local variables in the java language.",
	"Method": "void declareVariables(String variables){\r\n    synchronized (this.paramtab) {\r\n        this.variableDeclarations = variables;\r\n        this.compiled = false;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ee.SecuritySniffer.handles",
	"Comment": "returns true if the passed file or directory is recognized by thisinstance.",
	"Method": "boolean handles(DeploymentContext context,boolean handles,ReadableArchive location){\r\n    return (DeploymentUtils.isArchiveOfType(location, DOLUtils.warType(), habitat) || DeploymentUtils.isArchiveOfType(location, DOLUtils.earType(), habitat) || isJar(location));\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnUtils.dLoad",
	"Comment": "return the best instruction for loading a double from a localvariable slot",
	"Method": "Insn dLoad(int i,ConstantPool pool){\r\n    if (i == 0)\r\n        return Insn.create(opc_dload_0);\r\n    else if (i == 1)\r\n        return Insn.create(opc_dload_1);\r\n    else if (i == 2)\r\n        return Insn.create(opc_dload_2);\r\n    else if (i == 3)\r\n        return Insn.create(opc_dload_3);\r\n    return Insn.create(opc_dload, i);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.common.wls.SecurityRoleAssignmentNode.writeDescriptors",
	"Comment": "write all occurrences of the descriptor corresponding to the currentnode from the parent descriptor to an jaxp dom node and return itthis api will be invoked by the parent node when the parent nodewrites out a mix of statically and dynamically registered sub nodes.this method should be overriden by the sub classes if itneeds to be called by the parent node.",
	"Method": "Node writeDescriptors(Node parent,String nodeName,Descriptor parentDesc){\r\n    if (parentDesc instanceof WebBundleDescriptor) {\r\n        WebBundleDescriptor webBundleDescriptor = (WebBundleDescriptor) parentDesc;\r\n        SecurityRoleAssignment[] securityRoleAssignments = webBundleDescriptor.getSunDescriptor().getSecurityRoleAssignments();\r\n        for (SecurityRoleAssignment securityRoleAssignment : securityRoleAssignments) {\r\n            writeDescriptor(parent, nodeName, securityRoleAssignment);\r\n        }\r\n    }\r\n    return parent;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.util.ClassPath.findClass",
	"Comment": "locate a class file given a fully qualified class namestarting at the specified class path element",
	"Method": "ClassFileSource findClass(String className,ClassFileSource findClass,String className,ClassPathElement path){\r\n    for (ClassPathElement e = path; e != null; e = e.next()) {\r\n        ClassFileSource source = e.sourceOf(className);\r\n        if (source != null) {\r\n            source.setSourceElement(e);\r\n            return source;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.isAnsiTrim",
	"Comment": "returns true if this database need ansi style rtrim semantics.",
	"Method": "boolean isAnsiTrim(){\r\n    String s = (String) dbMap.get(ANSI_TRIM);\r\n    Boolean b = Boolean.valueOf(s);\r\n    if (logger.isLoggable()) {\r\n        logger.fine(\"sqlstore.database.dbvendor.isAnsiTrim\", b);\r\n    }\r\n    return b.booleanValue();\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.ext.BulkImportFinishedRequest.createExtendedResponse",
	"Comment": "creates an extended response object that corresponds to the ldap bulkimportfinished extended request.",
	"Method": "ExtendedResponse createExtendedResponse(String id,byte[] berValue,int offset,int length){\r\n    if ((id != null) && (!id.equals(OID))) {\r\n        throw new ConfigurationException(\"BulkImportFinished received the following response instead of \" + OID + \": \" + id);\r\n    }\r\n    return new EmptyExtendedResponse(id);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.PreparedStatementWrapper.setBigDecimal",
	"Comment": "sets the designated parameter to the given java.math.bigdecimal value.the driver converts this to an sql numeric value whenit sends it to the database.",
	"Method": "void setBigDecimal(int parameterIndex,BigDecimal x){\r\n    preparedStatement.setBigDecimal(parameterIndex, x);\r\n}"
}, {
	"Path": "com.sun.ejb.EjbInvocation.userTransactionLookupAllowed",
	"Comment": "called by the usertransaction lookup to verify access to the usertransaction itself.",
	"Method": "void userTransactionLookupAllowed(){\r\n    ((BaseContainer) container).checkUserTransactionLookup(this);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.deployment.annotation.handlers.RolesAllowedHandler.processEjbMethodSecurity",
	"Comment": "add roles and permissions to given method in ejbdescriptor.",
	"Method": "void processEjbMethodSecurity(Annotation authAnnotation,MethodDescriptor md,EjbDescriptor ejbDesc){\r\n    RolesAllowed rolesAllowedAn = (RolesAllowed) authAnnotation;\r\n    for (String roleName : rolesAllowedAn.value()) {\r\n        Role role = new Role(roleName);\r\n        ejbDesc.getEjbBundleDescriptor().addRole(role);\r\n        ejbDesc.addPermissionedMethod(new MethodPermission(role), md);\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.base.stats.StatefulSessionStoreStatsImpl.getActivationTime",
	"Comment": "returns the time spent on activating beans from the store including total, min, max",
	"Method": "AverageRangeStatistic getActivationTime(){\r\n    synchronized (activationTimeLock) {\r\n        return (AverageRangeStatistic) activationTime.unmodifiableView();\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.base.stats.HAStatefulSessionStoreStatsImpl.getCheckpointCount",
	"Comment": "returns the total number of sessions checkpointed into the store",
	"Method": "CountStatistic getCheckpointCount(){\r\n    synchronized (checkpointCountLock) {\r\n        checkpointCount.setCount(checkpointCountVal);\r\n        return (CountStatistic) checkpointCount.unmodifiableView();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.ConnectionLeakDetector.clearAllConnectionLeakTasks",
	"Comment": "clear all connection leak tracing tasks in case of connection leaktracing being turned off",
	"Method": "void clearAllConnectionLeakTasks(){\r\n    synchronized (connectionLeakLock) {\r\n        Iterator<Map.Entry<ResourceHandle, ConnectionLeakTask>> entries = connectionLeakTimerTaskHashMap.entrySet().iterator();\r\n        while (entries.hasNext()) {\r\n            Map.Entry<ResourceHandle, ConnectionLeakTask> connectionLeakTaskEntry = entries.next();\r\n            connectionLeakTaskEntry.getValue().cancel();\r\n        }\r\n        if (getTimer() != null)\r\n            getTimer().purge();\r\n        connectionLeakThreadStackHashMap.clear();\r\n        connectionLeakTimerTaskHashMap.clear();\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxRowSize",
	"Comment": "retrieves the maximum number of bytes this database allows ina single row.",
	"Method": "int getMaxRowSize(){\r\n    return databaseMetaData.getMaxRowSize();\r\n}"
}, {
	"Path": "org.glassfish.resources.module.ResourcesDeployer.extractRAName",
	"Comment": "extract the ra name for a connector resource. collecting for resource validation.",
	"Method": "String extractRAName(org.glassfish.resources.api.Resource resource){\r\n    if (resource.getType().equals(ADMIN_OBJECT_RESOURCE))\r\n        return (String) resource.getAttributes().get(RES_ADAPTER);\r\n    else\r\n        return (String) resource.getAttributes().get(RES_ADAPTER_NAME);\r\n}"
}, {
	"Path": "com.sun.web.security.RealmAdapter.getDefaultSystemProviderID",
	"Comment": "get the default provider id for system apps if one has been established.the default provider for system apps is established by defininga system property.",
	"Method": "String getDefaultSystemProviderID(){\r\n    String p = System.getProperty(SYSTEM_HTTPSERVLET_SECURITY_PROVIDER);\r\n    if (p != null) {\r\n        p = p.trim();\r\n        if (p.length() == 0) {\r\n            p = null;\r\n        }\r\n    }\r\n    return p;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MessageDestinationReferencerImpl.getMessageDestinationRefOwner",
	"Comment": "get the descriptor for the message destination reference owner.",
	"Method": "MessageDestinationReferenceDescriptor getMessageDestinationRefOwner(){\r\n    return ownerMsgDestRef;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.ActiveJmsResourceAdapter.deleteJmsHost",
	"Comment": "removes the jmshost from the mqaddresslist of the resource adapter.",
	"Method": "void deleteJmsHost(JmsHost host){\r\n    urlList.removeMQUrl(host);\r\n    setAddressList();\r\n}"
}, {
	"Path": "com.sun.ejb.containers.BaseContainer.createEJBLocalBusinessObjectImpl",
	"Comment": "only implemented in stateless , stateful, and singleton session containers",
	"Method": "EJBLocalObjectImpl createEJBLocalBusinessObjectImpl(boolean localBeanView,EJBLocalObjectImpl createEJBLocalBusinessObjectImpl,String clientIntf){\r\n    boolean useLocalBeanView = isLocalBeanClass(clientIntf);\r\n    return createEJBLocalBusinessObjectImpl(useLocalBeanView);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.UpdateStatement.bindInputColumn",
	"Comment": "binds the value in the specified update descriptor correspondingwith the specified column reference to the specified statement.",
	"Method": "void bindInputColumn(DBStatement stmt,ColumnRef columnRef,UpdateObjectDescImpl updateDesc,boolean getBeforeValue){\r\n    Object inputValue = getInputValue(updateDesc, columnRef, getBeforeValue);\r\n    stmt.bindInputColumn(columnRef.getIndex(), inputValue, columnRef.getColumnElement(), vendorType);\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.XAManagedConnectionFactory.createManagedConnection",
	"Comment": "creates a new physical connection to the underlying eis resourcemanager.",
	"Method": "javax.resource.spi.ManagedConnection createManagedConnection(javax.security.auth.Subject subject,ConnectionRequestInfo cxRequestInfo){\r\n    if (logWriter != null) {\r\n        logWriter.println(\"In createManagedConnection\");\r\n    }\r\n    PasswordCredential pc = SecurityUtils.getPasswordCredential(this, subject, cxRequestInfo);\r\n    if (dataSourceObj == null) {\r\n        if (dsObjBuilder == null) {\r\n            dsObjBuilder = new DataSourceObjectBuilder(spec);\r\n        }\r\n        try {\r\n            dataSourceObj = (javax.sql.XADataSource) dsObjBuilder.constructDataSourceObject();\r\n        } catch (ClassCastException cce) {\r\n            _logger.log(Level.SEVERE, \"jdbc.exc_cce\", cce);\r\n            throw new javax.resource.ResourceException(cce.getMessage());\r\n        }\r\n    }\r\n    javax.sql.XAConnection xaConn = null;\r\n    try {\r\n        if (isEqual(pc, getUser(), getPassword())) {\r\n            xaConn = dataSourceObj.getXAConnection();\r\n        } else {\r\n            xaConn = dataSourceObj.getXAConnection(pc.getUserName(), new String(pc.getPassword()));\r\n        }\r\n    } catch (java.sql.SQLException sqle) {\r\n        _logger.log(Level.FINE, \"jdbc.exc_create_xa_conn\", sqle);\r\n        throw new ResourceAllocationException(\"cannot allocate connection\", sqle);\r\n    }\r\n    com.sun.jdbcra.spi.ManagedConnection mc = new com.sun.jdbcra.spi.ManagedConnection(xaConn, null, pc, this);\r\n    mc.initializeConnectionType(ManagedConnection.ISXACONNECTION);\r\n    return mc;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.BundleDescriptor.isPackagedAsSingleModule",
	"Comment": "return true if the other bundle descriptor comes from the same module",
	"Method": "boolean isPackagedAsSingleModule(BundleDescriptor other){\r\n    return getModuleDescriptor().equals(other.getModuleDescriptor());\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.getEjbResourceReferenceDescriptors",
	"Comment": "return the set of references to resources held by ejbs defined in this module.",
	"Method": "Set<ResourceReferenceDescriptor> getEjbResourceReferenceDescriptors(){\r\n    Set<ResourceReferenceDescriptor> resourceReferences = new HashSet<ResourceReferenceDescriptor>();\r\n    for (Iterator itr = getEjbs().iterator(); itr.hasNext(); ) {\r\n        EjbDescriptor ejbDescriptor = (EjbDescriptor) itr.next();\r\n        resourceReferences.addAll(ejbDescriptor.getResourceReferenceDescriptors());\r\n    }\r\n    return resourceReferences;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.isInterface",
	"Comment": "determines if the specified classname represents an interface type.",
	"Method": "boolean isInterface(String className){\r\n    Class classElement = (Class) getClass(className);\r\n    return ((classElement != null) ? classElement.isInterface() : false);\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.ResourceHandlers.getConfigPropsInfo",
	"Comment": "this handler looks into the config properties, and confidential list, and returns a list of map for populating the properties table. this is called for creating new objects.",
	"Method": "void getConfigPropsInfo(HandlerContext handlerCtx){\r\n    Map<String, Object> extraProps = (Map) handlerCtx.getInputValue(\"extraProps\");\r\n    String key = (String) handlerCtx.getInputValue(\"key\");\r\n    String confidentialKey = (String) handlerCtx.getInputValue(\"confidentialKey\");\r\n    Boolean hasConfidential = true;\r\n    Map<String, String> allProps = (Map<String, String>) extraProps.get(key);\r\n    List<String> confidentialPropsNames = (List<String>) extraProps.get(confidentialKey);\r\n    if (confidentialPropsNames == null || confidentialPropsNames.isEmpty()) {\r\n        hasConfidential = false;\r\n    }\r\n    List<Map> result = new ArrayList();\r\n    for (Map.Entry<String, String> e : allProps.entrySet()) {\r\n        Map<String, Object> oneRow = new HashMap();\r\n        String name = e.getKey();\r\n        String value = (e.getValue() == null) ? \"\" : e.getValue();\r\n        oneRow.put(\"selected\", false);\r\n        oneRow.put(\"name\", name);\r\n        if (hasConfidential && confidentialPropsNames.contains(name)) {\r\n            oneRow.put(\"value\", \"\");\r\n            oneRow.put(\"confValue\", value);\r\n            oneRow.put(\"confValue2\", value);\r\n            oneRow.put(\"isConfidential\", true);\r\n        } else {\r\n            oneRow.put(\"value\", value);\r\n            oneRow.put(\"confValue\", \"\");\r\n            oneRow.put(\"confValue2\", \"\");\r\n            oneRow.put(\"isConfidential\", false);\r\n        }\r\n        result.add(oneRow);\r\n    }\r\n    handlerCtx.setOutputValue(\"result\", result);\r\n    handlerCtx.setOutputValue(\"hasConfidentialProps\", hasConfidential);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.getRequireTrackedSCO",
	"Comment": "returns the boolean value of the requiretrackedsco flagfor this persistencemanagerfactory. if set to false, by default thepersistencemanager will not create tracked sco instances fornew persistent instances at commit with retainvalues set to true and whileretrieving data from a datastore.",
	"Method": "boolean getRequireTrackedSCO(){\r\n    return _persistenceManagerFactory.getRequireTrackedSCO();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOCodeGenerator.getS1ASSpecificGeneratorClassesSignature",
	"Comment": "returns the signatures of the classes and properties which areinvolved in the codegen for s1as specific part.",
	"Method": "String getS1ASSpecificGeneratorClassesSignature(){\r\n    if (signatures == null) {\r\n        StringBuffer sb = // adding signature of JDOCodeGenerator\r\n        new StringBuffer().append(JDOCodeGenerator.SIGNATURE).append(// adding signature of NameMapper\r\n        CMPTemplateFormatter.signatureDelimiter_).append(NameMapper.SIGNATURE);\r\n        signatures = sb.toString();\r\n    }\r\n    return signatures;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.newSCOInstanceInternal",
	"Comment": "called by newscoinstance from the public interface or internallyby the runtimewill not result in marking field as dirtyreturns a new second class object instance of the type specified,",
	"Method": "Object newSCOInstanceInternal(Class type,Object owner,String fieldName){\r\n    Object obj = null;\r\n    if (type == java.sql.Date.class || type == com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlDate.class) {\r\n        obj = new com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlDate(owner, fieldName);\r\n    } else if (type == java.sql.Time.class || type == com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlTime.class) {\r\n        obj = new com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlTime(owner, fieldName);\r\n    } else if (type == java.sql.Timestamp.class || type == com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlTimestamp.class) {\r\n        obj = new com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlTimestamp(owner, fieldName);\r\n    } else if (type == com.sun.jdo.spi.persistence.support.sqlstore.sco.Date.class || Date.class.isAssignableFrom(type)) {\r\n        obj = new com.sun.jdo.spi.persistence.support.sqlstore.sco.Date(owner, fieldName);\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerimpl.newscoinstance.wrongclass\", type.getName()));\r\n    }\r\n    return obj;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingRelationshipElementImpl.removeColumn",
	"Comment": "removes a column from the list of columns mapped by this mapping field.\tthis method overrides the one in mappingfieldelement to\tremove the argument from the associated columns if necessary.",
	"Method": "void removeColumn(String columnName){\r\n    try {\r\n        super.removeColumn(columnName);\r\n    } catch (ModelException e) {\r\n        try {\r\n            fireVetoableChange(PROP_ASSOCIATED_COLUMNS, null, null);\r\n            if (!getAssociatedColumns().remove(columnName)) {\r\n                throw new ModelException(I18NHelper.getMessage(getMessages(), \"mapping.element.element_not_removed\", columnName));\r\n            }\r\n            firePropertyChange(PROP_ASSOCIATED_COLUMNS, null, null);\r\n            _associatedColumnObjects = null;\r\n        } catch (PropertyVetoException ve) {\r\n            throw new ModelVetoException(ve);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.web.security.WebProgrammaticLoginImpl.getSession",
	"Comment": "returns the underlying session object from the request, if one isavailable, or null.",
	"Method": "Session getSession(Request request){\r\n    HttpSession session = request.getSession(false);\r\n    if (session != null) {\r\n        Context context = request.getContext();\r\n        if (context != null) {\r\n            Manager manager = context.getManager();\r\n            if (manager != null) {\r\n                String sessionId = session.getId();\r\n                try {\r\n                    Session realSession = manager.findSession(sessionId);\r\n                    return realSession;\r\n                } catch (IOException e) {\r\n                    return null;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.AgentArguments.namedValues",
	"Comment": "returns the list of values associated with the specified keyword.",
	"Method": "List<String> namedValues(String keyword){\r\n    return actualOrEmptyList(keyword);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.node.runtime.EjbNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object newDescriptor){\r\n    if (newDescriptor instanceof MdbConnectionFactoryDescriptor) {\r\n        descriptor.getIASEjbExtraDescriptors().setMdbConnectionFactory((MdbConnectionFactoryDescriptor) newDescriptor);\r\n    } else if (newDescriptor instanceof BeanPoolDescriptor) {\r\n        descriptor.getIASEjbExtraDescriptors().setBeanPool((BeanPoolDescriptor) newDescriptor);\r\n    } else if (newDescriptor instanceof BeanCacheDescriptor) {\r\n        descriptor.getIASEjbExtraDescriptors().setBeanCache((BeanCacheDescriptor) newDescriptor);\r\n    } else if (newDescriptor instanceof FlushAtEndOfMethodDescriptor) {\r\n        descriptor.getIASEjbExtraDescriptors().setFlushAtEndOfMethodDescriptor((FlushAtEndOfMethodDescriptor) newDescriptor);\r\n    } else if (newDescriptor instanceof CheckpointAtEndOfMethodDescriptor) {\r\n        descriptor.getIASEjbExtraDescriptors().setCheckpointAtEndOfMethodDescriptor((CheckpointAtEndOfMethodDescriptor) newDescriptor);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getResultSetHoldability",
	"Comment": "retrieves the default holdability of this resultsetobject.",
	"Method": "int getResultSetHoldability(){\r\n    return databaseMetaData.getResultSetHoldability();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.MethodAnnotater.transferStackArgs",
	"Comment": "take all stack elements in fromstack and push them onto tostacksuch that they are in the same relative stack positions",
	"Method": "void transferStackArgs(Stack fromStack,Stack toStack){\r\n    if (!fromStack.empty()) {\r\n        Object o = fromStack.pop();\r\n        transferStackArgs(fromStack, toStack);\r\n        toStack.push(o);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.jws.servedcontent.CachingDynamicContentImpl.getExistingInstance",
	"Comment": "returns the cachingdynamiccontentimpl.instanceimpl for this template corresponding tothe specified substitution token values.",
	"Method": "Instance getExistingInstance(Properties tokenValues){\r\n    return getOrCreateInstance(tokenValues, false);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getResourceReferenceDescriptors",
	"Comment": "return the set of resource references this ejb declares thathave been resolved.",
	"Method": "Set<ResourceReferenceDescriptor> getResourceReferenceDescriptors(Set<ResourceReferenceDescriptor> getResourceReferenceDescriptors,boolean resolved){\r\n    Set<ResourceReferenceDescriptor> toReturn = new HashSet<ResourceReferenceDescriptor>();\r\n    for (Iterator itr = getResourceReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        ResourceReferenceDescriptor next = (ResourceReferenceDescriptor) itr.next();\r\n        if (next.isResolved() == resolved) {\r\n            toReturn.add(next);\r\n        }\r\n    }\r\n    return toReturn;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.registerPersistenceManager",
	"Comment": "registers persistencemanager in the transactional cache inmanaged environment in case of bmt with jdo transaction.there is no javax.transaction.transactionavailable before the user starts the transaction.",
	"Method": "void registerPersistenceManager(com.sun.jdo.spi.persistence.support.sqlstore.PersistenceManager pm,javax.transaction.Transaction t){\r\n    boolean debug = logger.isLoggable(Logger.FINEST);\r\n    if (debug) {\r\n        Object[] items = new Object[] { pm, t };\r\n        logger.finest(\"sqlstore.sqlpersistencemgrfactory.registerpersistencemgr.pmt\", items);\r\n    }\r\n    PersistenceManager pm1 = (PersistenceManager) pmCache.get(t);\r\n    if (pm1 == null) {\r\n        pmCache.put(t, pm);\r\n        ((PersistenceManagerImpl) pm).setJTATransaction(t);\r\n        return;\r\n    }\r\n    if (pm1 != pm) {\r\n        Object[] items = new Object[] { t, pm1 };\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerfactoryimpl.registerpm.registered\", items));\r\n    } else {\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ee.SecurityDeployer.commitPolicy",
	"Comment": "puts web bundle policy in service, repeats translation is descriptorindicate policy was changed by contextlistener.",
	"Method": "void commitPolicy(WebBundleDescriptor webBD){\r\n    try {\r\n        if (webBD != null) {\r\n            if (webBD.isPolicyModified()) {\r\n                loadPolicy(webBD, true);\r\n            }\r\n            String cid = SecurityUtil.getContextID(webBD);\r\n            websecurityProbeProvider.policyCreationStartedEvent(cid);\r\n            SecurityUtil.generatePolicyFile(cid);\r\n            websecurityProbeProvider.policyCreationEndedEvent(cid);\r\n            websecurityProbeProvider.policyCreationEvent(cid);\r\n        }\r\n    } catch (Exception se) {\r\n        String msg = \"Error in generating security policy for \" + webBD.getModuleDescriptor().getModuleName();\r\n        throw new DeploymentException(msg, se);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.getFloat",
	"Comment": "retrieves the value of a jdbc float parameter as a floatin the java programming language.",
	"Method": "float getFloat(int parameterIndex,float getFloat,String parameterName){\r\n    return callableStatement.getFloat(parameterName);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOConcreteBeanGenerator.generateTypeSpecificMethods",
	"Comment": "generate type specific methods for setters, getters,and any other methods that are completely differentbetween bean types.",
	"Method": "void generateTypeSpecificMethods(PersistenceFieldElement[] allFields,AbstractMethodHelper methodHelper){\r\n    if (isUpdateable) {\r\n        loadNonDFGBody = null;\r\n    } else {\r\n        loadNonDFGBody = new StringBuffer();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.isNativeOuterJoin",
	"Comment": "returns true if the this database needs native outer join semantics.",
	"Method": "boolean isNativeOuterJoin(){\r\n    String s = (String) dbMap.get(NATIVE_OUTER_JOIN);\r\n    Boolean b = Boolean.valueOf(s);\r\n    if (logger.isLoggable()) {\r\n        logger.fine(\"sqlstore.database.dbvendor.isNativeOuterJoin\", b);\r\n    }\r\n    return b.booleanValue();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.ResultDesc.getProjectedField",
	"Comment": "returns the projected field from the result set. this field isalways a local field. foreign fields are handled in setfields.we return the database value for projections on local fields.unless we flush for queries in optimistic transactions the valuefrom the database might be different from the value in memory.",
	"Method": "Object getProjectedField(ResultSet resultData){\r\n    FieldDesc f = fieldProjection.getFieldDesc();\r\n    if (debug) {\r\n        logger.finest(\"sqlstore.resultdesc.returning_field\", f.getName());\r\n    }\r\n    return getConvertedObject(resultData, fieldProjection.getColumnRef(), f, null);\r\n}"
}, {
	"Path": "org.glassfish.concurrent.admin.DeleteContextService.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        ResourceStatus rs = contextServiceMgr.delete(domain.getResources(), jndiName, target);\r\n        if (rs.getMessage() != null) {\r\n            report.setMessage(rs.getMessage());\r\n        }\r\n        if (rs.getStatus() == ResourceStatus.SUCCESS) {\r\n            report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n        } else {\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            if (rs.getException() != null)\r\n                report.setFailureCause(rs.getException());\r\n        }\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.context.service.failed\", \"Context service {0} deletion failed\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.connection.ConnectionManager.getMaxPool",
	"Comment": "gets the maximum number of pooled connections for the currentconnection manager.if this value is 0, the connection manager does not maintaina connection pool.when you request a connection with the getconnectionmethod, the getconnectionmethod always returns a new connection.to change the maximum number of pooled connections, use thesetmaxpool method.",
	"Method": "int getMaxPool(){\r\n    return (this.maxPool);\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnectionFactory.matchManagedConnections",
	"Comment": "returns a matched managedconnection from the candidate set of managedconnection objects.",
	"Method": "javax.resource.spi.ManagedConnection matchManagedConnections(java.util.Set connectionSet,javax.security.auth.Subject subject,ConnectionRequestInfo cxRequestInfo){\r\n    if (logWriter != null) {\r\n        logWriter.println(\"In matchManagedConnections\");\r\n    }\r\n    if (connectionSet == null) {\r\n        return null;\r\n    }\r\n    PasswordCredential pc = SecurityUtils.getPasswordCredential(this, subject, cxRequestInfo);\r\n    java.util.Iterator iter = connectionSet.iterator();\r\n    com.sun.jdbcra.spi.ManagedConnection mc = null;\r\n    while (iter.hasNext()) {\r\n        try {\r\n            mc = (com.sun.jdbcra.spi.ManagedConnection) iter.next();\r\n        } catch (java.util.NoSuchElementException nsee) {\r\n            _logger.log(Level.SEVERE, \"jdbc.exc_iter\");\r\n            throw new ResourceException(nsee.getMessage());\r\n        }\r\n        if (pc == null && this.equals(mc.getManagedConnectionFactory())) {\r\n            try {\r\n                isValid(mc);\r\n                return mc;\r\n            } catch (ResourceException re) {\r\n                _logger.log(Level.SEVERE, \"jdbc.exc_re\", re);\r\n                mc.connectionErrorOccurred(re, null);\r\n            }\r\n        } else if (SecurityUtils.isPasswordCredentialEqual(pc, mc.getPasswordCredential()) == true) {\r\n            try {\r\n                isValid(mc);\r\n                return mc;\r\n            } catch (ResourceException re) {\r\n                _logger.log(Level.SEVERE, \"jdbc.re\");\r\n                mc.connectionErrorOccurred(re, null);\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.deployapi.TargetModuleIDImpl.getChildTargetModuleID",
	"Comment": "returns the targetmoduleids representing submodules of this module deployed to the target.",
	"Method": "TargetModuleID[] getChildTargetModuleID(){\r\n    return children;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.visit",
	"Comment": "visit the descriptor and all sub descriptors with a dol visitor implementation",
	"Method": "void visit(DescriptorVisitor aVisitor){\r\n    if (aVisitor instanceof ApplicationVisitor) {\r\n        visit((ComponentVisitor) aVisitor);\r\n    } else {\r\n        super.visit(aVisitor);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.performOptionalPkgDependenciesCheck",
	"Comment": "perform optional packages dependencies checking on an archive",
	"Method": "boolean performOptionalPkgDependenciesCheck(ReadableArchive archive){\r\n    boolean dependenciesSatisfied = true;\r\n    Manifest m = archive.getManifest();\r\n    if (m != null) {\r\n        dependenciesSatisfied = InstalledLibrariesResolver.resolveDependencies(m, archive.getURI().getSchemeSpecificPart());\r\n    }\r\n    Vector<String> libs = getLibraries(archive);\r\n    if (libs != null) {\r\n        for (String libUri : libs) {\r\n            JarInputStream jis = null;\r\n            try {\r\n                jis = new JarInputStream(archive.getEntry(libUri));\r\n                m = jis.getManifest();\r\n                if (m != null) {\r\n                    if (!InstalledLibrariesResolver.resolveDependencies(m, libUri)) {\r\n                        dependenciesSatisfied = false;\r\n                    }\r\n                }\r\n            } finally {\r\n                if (jis != null)\r\n                    jis.close();\r\n            }\r\n        }\r\n    }\r\n    return dependenciesSatisfied;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jacc.provider.SimplePolicyConfiguration.removeExcludedPolicy",
	"Comment": "used to remove any excluded policy statements from thispolicyconfiguration.",
	"Method": "void removeExcludedPolicy(){\r\n    checkSetPolicyPermission();\r\n    pcwLock.lock();\r\n    try {\r\n        assertStateIsOpen();\r\n        excludedPermissions = null;\r\n    } finally {\r\n        pcwLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.MappingPolicy.getOverrideForScale",
	"Comment": "provides a string that can be recognized as a policy to override thedefault scale of a field.",
	"Method": "String getOverrideForScale(String className,String fieldName){\r\n    return className + DOT + fieldName + DOT + DatabaseGenerationConstants.INDICATOR_JDBC_SCALE;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOConcreteBeanGenerator.getException",
	"Comment": "verifies if expected exception or its superclass are part of the throws clause of the corresponding method in the abstract class. returns ejbexception if none of the requested exceptions is not found.",
	"Method": "String getException(String[] exc,String checkExc,String getException,String[] exc,String checkExc,String superExc){\r\n    String rc = CMPTemplateFormatter.ejbException_;\r\n    if (exc != null) {\r\n        for (int i = 0; i < exc.length; i++) {\r\n            if (exc[i].equals(checkExc) || exc[i].equals(superExc)) {\r\n                rc = checkExc;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "org.glassfish.javaee.full.deployment.EarSniffer.supportsArchiveType",
	"Comment": "this api is used to help determine if the sniffer should recognizethe current archive.if the sniffer does not support the archive type associated withthe current deployment, the sniffer should not recognize the archive.",
	"Method": "boolean supportsArchiveType(ArchiveType archiveType){\r\n    if (archiveType.equals(earType)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ResourceAdapterImpl.endpointActivation",
	"Comment": "empty method implementation for endpointactivationwhich just throws notsupportedexception",
	"Method": "void endpointActivation(MessageEndpointFactory mef,ActivationSpec as){\r\n    throw new NotSupportedException(\"This method is not supported for this JDBC connector\");\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.QueryPlan.addQueryTables",
	"Comment": "add all the tables from querytables to the currentquery plan.useful when transfering tables when joining query planstogether.",
	"Method": "void addQueryTables(ArrayList queryTables){\r\n    for (int i = 0; i < queryTables.size(); i++) {\r\n        QueryTable t = (QueryTable) queryTables.get(i);\r\n        if (tables.indexOf(t) == -1) {\r\n            tables.add(t);\r\n            t.getTableIndex().setValue(tables.size() - 1);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployapi.TargetModuleIDImpl.setWebURL",
	"Comment": "sets the url for running the web module, if this targetmoduleidrepresents a web module or submodule on a target.",
	"Method": "void setWebURL(String webURL){\r\n    target.getOwner().setWebURL(this, webURL);\r\n}"
}, {
	"Path": "org.glassfish.deployapi.ProgressObjectImpl.isStopSupported",
	"Comment": "tests whether the vendor supports a stopopertation for deployment activities.",
	"Method": "boolean isStopSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsCoreSQLGrammar",
	"Comment": "retrieves whether this database supports the odbc core sql grammar.",
	"Method": "boolean supportsCoreSQLGrammar(){\r\n    return databaseMetaData.supportsCoreSQLGrammar();\r\n}"
}, {
	"Path": "org.glassfish.admin.mejb.MEJBBean.getDefaultDomain",
	"Comment": "returns the default domain used for naming the managed object.the default domain name is used as the domain part in the objectnameof managed objects if no domain is specified by the user.",
	"Method": "String getDefaultDomain(){\r\n    return mDomain;\r\n}"
}, {
	"Path": "com.sun.ejb.EjbInvocation.getJaccEjb",
	"Comment": "used by jacc implementation to get an enterprise beaninstance for the enterprisebean policy handler.the jaccimplementation should use this method rather than directlyaccessing the ejb field.",
	"Method": "Object getJaccEjb(){\r\n    Object bean = null;\r\n    if (container != null) {\r\n        bean = ((Container) container).getJaccEjb(this);\r\n    }\r\n    return bean;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbEntityDescriptor.getPrimaryKeyClassName",
	"Comment": "return the classname of the primary key for this bean, or the empty string if none has been set.",
	"Method": "String getPrimaryKeyClassName(){\r\n    if (this.primaryKeyClassName == null) {\r\n        this.primaryKeyClassName = Object.class.getName();\r\n    }\r\n    return this.primaryKeyClassName;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.setUpdateTimeout",
	"Comment": "sets the number of seconds to wait for an update statementto execute in the datastore associated with this persistencemanagerfactory.",
	"Method": "void setUpdateTimeout(int timeout){\r\n    throw new JDOUnsupportedOptionException(// NOI18N\r\n    I18NHelper.getMessage(messages, \"jdo.persistencemanagerfactoryimpl.notsupported\"));\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ee.SecurityUtil.removePolicy",
	"Comment": "inform the policy module to take the named policy context out of service.the policy context is transitioned to the deleted state. in our providerimplementation, the corresponding policy file is deleted, as the presenceof a policy file in the repository is how we persistently remember whichpolicy contexts are in service.",
	"Method": "void removePolicy(String name){\r\n    assert name != null;\r\n    if (name == null) {\r\n        throw new IASSecurityException(\"Invalid Module Name\");\r\n    }\r\n    try {\r\n        boolean wasInService = PolicyConfigurationFactory.getPolicyConfigurationFactory().inService(name);\r\n        PolicyConfiguration pc = PolicyConfigurationFactory.getPolicyConfigurationFactory().getPolicyConfiguration(name, false);\r\n        pc.delete();\r\n        if (wasInService) {\r\n            Policy.getPolicy().refresh();\r\n        }\r\n    } catch (java.lang.ClassNotFoundException cnfe) {\r\n        String msg = localStrings.getLocalString(\"enterprise.security.securityutil.classnotfound\", \"Could not find PolicyConfigurationFactory class. Check javax.security.jacc.PolicyConfigurationFactory.provider property\");\r\n        throw new IASSecurityException(msg);\r\n    } catch (javax.security.jacc.PolicyContextException pce) {\r\n        throw new IASSecurityException(pce.toString());\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.ResultDesc.setFieldValue",
	"Comment": "sets value for the given field fand statemanager sm.also sets presence mask bit for the field in given sm.",
	"Method": "void setFieldValue(StateManager sm,FieldDesc f,Object value){\r\n    f.setValue(sm, value);\r\n    sm.setPresenceMaskBit(f.absoluteID);\r\n}"
}, {
	"Path": "admin.ClusterTest.testGetHealthStopRestartInstance",
	"Comment": "stop instance, check health, restart instance, and check again.this method relies on another for the actual call. it will waitfor a bit for a positive result since the gms notificationsmay take a few seconds to be sent.",
	"Method": "void testGetHealthStopRestartInstance(String c,String i){\r\n    if (!runGMSTests)\r\n        return;\r\n    final String stopped = \"stopped\";\r\n    final String started = \"started\";\r\n    final int tries = 6;\r\n    final int sleepSeconds = 10;\r\n    boolean success = false;\r\n    asadmin(\"stop-local-instance\", i);\r\n    for (int x = 0; x < tries; x++) {\r\n        sleep(sleepSeconds);\r\n        printf(\"Checking instance health for instance %s, expect %s\", i, stopped);\r\n        success = checkInstanceHealth(c, i, stopped);\r\n        if (success) {\r\n            break;\r\n        }\r\n    }\r\n    report(\"get-health-instance-stopped\", success);\r\n    success = false;\r\n    asadmin(\"start-local-instance\", i);\r\n    for (int x = 0; x < tries; x++) {\r\n        sleep(sleepSeconds);\r\n        printf(\"Checking instance health for instance %s, expect %s\", i, started);\r\n        success = checkInstanceHealth(c, i, started);\r\n        if (success) {\r\n            break;\r\n        }\r\n    }\r\n    report(\"get-health-instance-started\", success);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.StatementWrapper.getQueryTimeout",
	"Comment": "retrieves the number of seconds the driver willwait for a statement object to execute. if the limit is exceeded, asqlexception is thrown.",
	"Method": "int getQueryTimeout(){\r\n    return jdbcStatement.getQueryTimeout();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.getPersistenceField",
	"Comment": "returns the persistencefieldelement with the supplied fieldname found\tin the supplied classname.",
	"Method": "PersistenceFieldElement getPersistenceField(String className,String fieldName){\r\n    return getPersistenceFieldInternal(className, fieldName);\r\n}"
}, {
	"Path": "com.sun.ejb.containers.StatelessSessionContainer.releaseContext",
	"Comment": "called from preinvoke which is called from the ejbobjectfor local and remote invocations.",
	"Method": "void releaseContext(EjbInvocation inv){\r\n    SessionContextImpl sc = (SessionContextImpl) inv.context;\r\n    if (sc.getState() == EJBContextImpl.BeanState.DESTROYED)\r\n        return;\r\n    sc.setState(EJBContextImpl.BeanState.POOLED);\r\n    sc.setTransaction(null);\r\n    sc.touch();\r\n    pool.returnObject(sc);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getServiceReferenceByName",
	"Comment": "looks up an service reference with the given name.throws an illegalargumentexception if it is not found.",
	"Method": "ServiceReferenceDescriptor getServiceReferenceByName(String name){\r\n    if (env != null)\r\n        return env.getServiceReferenceByName(name);\r\n    for (Iterator itr = this.getServiceReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        ServiceReferenceDescriptor srd = (ServiceReferenceDescriptor) itr.next();\r\n        if (srd.getName().equals(name)) {\r\n            return srd;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionejbhasnoservicerefbyname\", \"This ejb [{0}] has no service reference by the name of [{1}]\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.SunContainerHelper.rollbackInternalTransaction",
	"Comment": "called in a unspecified transaction context of a managed environment.according to p.364 of ejb 2.0 spec, cmp may need to manageits own transaction when its transaction attribute isnotsupported, never, supports.this is a generic implementation.application server may like to overwrite this if necessary.",
	"Method": "void rollbackInternalTransaction(PersistenceManager pm){\r\n    pm.currentTransaction().rollback();\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ConnectionHolder.releaseSavepoint",
	"Comment": "removes the given savepoint object from the current transaction.",
	"Method": "void releaseSavepoint(Savepoint savepoint){\r\n    checkValidity();\r\n    con.releaseSavepoint(savepoint);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.perms.EarEEPermissionsProcessor.getAdjustedEEPermission",
	"Comment": "get the ee permissions which have the file path adjusted for the right module",
	"Method": "PermissionCollection getAdjustedEEPermission(CommponentType type){\r\n    return compTypeToEEGarntsMap.get(type);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.deployment.annotation.handlers.AbstractAuthAnnotationHandler.relatedAnnotationTypes",
	"Comment": "this method returns a list of related annotation types.those annotations should not be used with the given annotaton type.",
	"Method": "Class<? extends Annotation>[] relatedAnnotationTypes(){\r\n    return new Class[0];\r\n}"
}, {
	"Path": "com.sun.gjc.util.SQLTraceCache.purgeEntries",
	"Comment": "entries are removed from the list after sortingthem in the least frequently used order. only numtopqueriestoreport number ofentries are maintained in the list after the purgeentries.",
	"Method": "void purgeEntries(){\r\n    synchronized (list) {\r\n        Collections.sort(list, Collections.reverseOrder());\r\n        Iterator i = list.iterator();\r\n        while (i.hasNext()) {\r\n            SQLTrace cacheObj = (SQLTrace) i.next();\r\n            if (list.size() > numTopQueriesToReport) {\r\n                if (_logger.isLoggable(Level.FINEST)) {\r\n                    _logger.finest(\"removing sql=\" + cacheObj.getQueryName());\r\n                }\r\n                i.remove();\r\n            } else {\r\n                break;\r\n            }\r\n        }\r\n        Collections.sort(list);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.realizeForeignField",
	"Comment": "for foreign fields we want to take advantage of knowing therelationship key and only selecting the foreign rather than theprimary with the foreign attached.most of the work is infiguring out whether we can do that.",
	"Method": "boolean realizeForeignField(ForeignFieldDesc foreignField){\r\n    assert foreignField != null;\r\n    boolean isPresent = false;\r\n    boolean debug = logger.isLoggable();\r\n    if (debug) {\r\n        // NOI18N\r\n        logger.fine(\"sqlstore.sqlstatemanager.realizeforeignfield\", foreignField.getName());\r\n    }\r\n    for (int i = 0; i < foreignField.localFields.size(); i++) {\r\n        LocalFieldDesc lf = (LocalFieldDesc) foreignField.localFields.get(i);\r\n        isPresent = getPresenceMaskBit(lf.absoluteID);\r\n        if (!isPresent) {\r\n            break;\r\n        }\r\n    }\r\n    if (isPresent) {\r\n        populateForeignField(foreignField);\r\n    }\r\n    if (debug) {\r\n        // NOI18N\r\n        logger.fine(\"sqlstore.sqlstatemanager.realizeforeignfield.exit\", Boolean.valueOf(isPresent));\r\n    }\r\n    return isPresent;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.getLogWriter",
	"Comment": "gets the log writer for this managedconnectionimpl instance.",
	"Method": "PrintWriter getLogWriter(){\r\n    logFine(\"In getLogWriter\");\r\n    checkIfValid();\r\n    return logWriter;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.getEjbReferenceDescriptors",
	"Comment": "returns the generated xml directory feturn the set of ejb references this ejb declares.",
	"Method": "Set<EjbReference> getEjbReferenceDescriptors(){\r\n    return ejbReferences;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.CMPBeanHelper.logJDOExceptionWithFinderLogger",
	"Comment": "called from a cmp bean to log jdoexception message thrownfrom a any finder or selector method, with the finderlogger.",
	"Method": "void logJDOExceptionWithFinderLogger(String beanName,Object[] params,JDOException ex){\r\n    String msg = null;\r\n    if (params != null) {\r\n        msg = // NOI18N\r\n        I18NHelper.getMessage(cmpMessages, \"GEN.ejbSSReturnBody_exception\", beanName, findCallingMethodName(), java.util.Arrays.asList(params).toString());\r\n    } else {\r\n        msg = // NOI18N\r\n        I18NHelper.getMessage(cmpMessages, \"GEN.ejbSSReturnBody_exception_woparams\", beanName, findCallingMethodName());\r\n    }\r\n    cmpFinderLogger.log(Logger.WARNING, msg, ex);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.runtime.IASPersistenceManagerDescriptor.classesChanged",
	"Comment": "called from ejbcmpentitydescriptorwhen some classes in this object are updated.",
	"Method": "boolean classesChanged(){\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorSecurityAdminServiceImpl.getAuthenticationService",
	"Comment": "obtain the authentication service associated with rar module.currently only the basicpassword authentication is supported.",
	"Method": "AuthenticationService getAuthenticationService(String rarName,PoolInfo poolInfo){\r\n    ConnectorDescriptor cd = _registry.getDescriptor(rarName);\r\n    OutboundResourceAdapter obra = cd.getOutboundResourceAdapter();\r\n    Set authMechs = obra.getAuthMechanisms();\r\n    for (Object authMech : authMechs) {\r\n        AuthMechanism authMechanism = (AuthMechanism) authMech;\r\n        String mech = authMechanism.getAuthMechType();\r\n        if (mech.equals(\"BasicPassword\")) {\r\n            return new BasicPasswordAuthenticationService(rarName, poolInfo);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.jqlc.QueryValueFetcher.getValue",
	"Comment": "returns the parameter value for the specified parameter index",
	"Method": "Object getValue(int whichOne){\r\n    if (parameters == null || whichOne >= parameters.length) {\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jqlc.queryvaluefetcher.getvalue.invalidparam\", String.valueOf(whichOne), String.valueOf((parameters == null) ? 0 : parameters.length)));\r\n    }\r\n    return parameters[whichOne];\r\n}"
}, {
	"Path": "test.extension.ServiceFrameworkExtension.afterBeanDiscovery",
	"Comment": "observer for afterbeandiscovery events. this observer method is used to register beans for the frameworkservices that have been requested to be injected.",
	"Method": "void afterBeanDiscovery(AfterBeanDiscovery abd){\r\n    afterBeanDiscoveryCalled = true;\r\n    debug(\"After Bean Discovery\");\r\n    for (Iterator<Type> iterator = this.frameworkServicesToBeInjected.keySet().iterator(); iterator.hasNext(); ) {\r\n        Type type = iterator.next();\r\n        if (!(type instanceof Class)) {\r\n            System.out.println(\"Unknown type:\" + type);\r\n            abd.addDefinitionError(new UnsupportedOperationException(\"Injection target type \" + type + \"not supported\"));\r\n            break;\r\n        }\r\n        addBean(abd, type, this.frameworkServicesToBeInjected.get(type));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.WeakValueHashMap.getReferenceObject",
	"Comment": "a convenience method to return the object held by theweak reference or null if it does not exist.",
	"Method": "Object getReferenceObject(WeakReference ref){\r\n    return (ref == null) ? null : ref.get();\r\n}"
}, {
	"Path": "org.glassfish.jdbcruntime.JdbcPoolMonitoringExtension.registerConnectionPool",
	"Comment": "register the jdbc connection pool stats provider object to themonitoring framework under the specific application name monitoringsub tree.",
	"Method": "ConnectionPoolAppProbeProvider registerConnectionPool(PoolInfo poolInfo,String appName){\r\n    ConnectionPoolAppProbeProvider probeAppProvider = null;\r\n    ResourcePool pool = runtime.getConnectionPoolConfig(poolInfo);\r\n    if (pool instanceof JdbcConnectionPool) {\r\n        probeAppProvider = new JdbcConnPoolAppProbeProvider();\r\n        JdbcConnPoolAppStatsProvider jdbcPoolAppStatsProvider = new JdbcConnPoolAppStatsProvider(poolInfo, appName);\r\n        StatsProviderManager.register(\"jdbc-connection-pool\", PluginPoint.SERVER, \"resources/\" + ConnectorsUtil.escapeResourceNameForMonitoring(poolInfo.getName()) + \"/\" + appName, jdbcPoolAppStatsProvider);\r\n        jdbcPoolAppStatsProviders.add(jdbcPoolAppStatsProvider);\r\n    }\r\n    return probeAppProvider;\r\n}"
}, {
	"Path": "org.glassfish.deployapi.config.SunConfigBean.extractTextFromXML",
	"Comment": "convenience method extract node value from the passed xml fragment.",
	"Method": "String extractTextFromXML(String key,String xmlFragment){\r\n    String openingTag = \"<\" + key + \">\";\r\n    xmlFragment = xmlFragment.substring(xmlFragment.indexOf(openingTag) + openingTag.length());\r\n    return xmlFragment.substring(0, xmlFragment.indexOf(\"<\/\" + key + \">\"));\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.support.JDOHelper.getPersistenceManager",
	"Comment": "returns the associated persistencemanager of an object if there is one.for transactional and persistent objects, their associatedpersistencemanager is returned.for transient objects, null is returned.",
	"Method": "PersistenceManager getPersistenceManager(Object obj){\r\n    if (obj instanceof PersistenceCapable)\r\n        return ((PersistenceCapable) obj).jdoGetPersistenceManager();\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.SunContainerHelper.beginInternalTransaction",
	"Comment": "called in a unspecified transaction context of a managed environment.according to p.364 of ejb 2.0 spec, cmp may need to manageits own transaction when its transaction attribute isnotsupported, never, supports.this is a generic implementation.application server may like to overwrite this if necessary.",
	"Method": "void beginInternalTransaction(PersistenceManager pm){\r\n    pm.currentTransaction().begin();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.logging.LoggerJDK14.convertLevel",
	"Comment": "convert an int level used by jdo logger to the level instance usedby jdk 1.4 logger.this is done to allow components to use logging outside the jdk 1.4environment.",
	"Method": "Level convertLevel(int level){\r\n    switch(level) {\r\n        case 300:\r\n            return Level.FINEST;\r\n        case 400:\r\n            return Level.FINER;\r\n        case 500:\r\n            return Level.FINE;\r\n        case 700:\r\n            return Level.CONFIG;\r\n        case 800:\r\n            return Level.INFO;\r\n        case 900:\r\n            return Level.WARNING;\r\n        case 1000:\r\n            return Level.SEVERE;\r\n        default:\r\n            return Level.CONFIG;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.inbound.ConnectorMessageBeanClient.start",
	"Comment": "marks the completion of mdb deployment. unblocks the createendpointmethod call.",
	"Method": "void start(){\r\n    logger.logp(Level.FINEST, \"ConnectorMessageBeanClient\", \"start\", \"called...\");\r\n    started_ = true;\r\n    synchronized (this) {\r\n        myState = UNBLOCKED;\r\n        notifyAll();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.getTempFile",
	"Comment": "utility method to get a tmp file in the current user directory of the provideddirectory",
	"Method": "File getTempFile(String fileOrDirPath,File getTempFile,File fileOrDir){\r\n    File dir = null;\r\n    if (fileOrDir == null) {\r\n        dir = new File(System.getProperty(\"user.dir\"));\r\n    } else {\r\n        if (!fileOrDir.isDirectory()) {\r\n            dir = fileOrDir.getParentFile();\r\n            if (dir == null) {\r\n                dir = new File(System.getProperty(\"user.dir\"));\r\n            }\r\n        } else {\r\n            dir = fileOrDir;\r\n        }\r\n    }\r\n    return File.createTempFile(\"tmp\", \".jar\", dir);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.ConnectionFactoryImpl.setMsWait",
	"Comment": "sets the number of milliseconds to wait for an available connectionfrom the connection pool before throwing an exception",
	"Method": "void setMsWait(int msWait){\r\n    assertNotConfigured();\r\n    if (connectionManager == null) {\r\n        this.msWait = msWait;\r\n        return;\r\n    }\r\n    try {\r\n        connectionManager.setMsWait(msWait);\r\n    } catch (Exception e) {\r\n        throw new JDOFatalException(null, e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsTransactionIsolationLevel",
	"Comment": "retrieves whether this database supports the given transaction isolation level.",
	"Method": "boolean supportsTransactionIsolationLevel(int level){\r\n    return databaseMetaData.supportsTransactionIsolationLevel(level);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.support.SynchronizationManager.setDefaultCapacity",
	"Comment": "specify the default capacity of the list of synchronizations.",
	"Method": "void setDefaultCapacity(int capacity){\r\n    defaultCapacity = capacity;\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.Java2DBProcessorHelper.setCreateTablesValue",
	"Comment": "store user defined value for create tables for future reference.",
	"Method": "void setCreateTablesValue(boolean createTablesValue,String bundleName){\r\n    deploymentContextProps.setProperty(CREATE_TABLE_VALUE + bundleName, \"\" + createTablesValue);\r\n    if (logger.isLoggable(Level.FINE)) {\r\n        logger.fine(\"---> \" + CREATE_TABLE_VALUE + bundleName + \" \" + createTablesValue);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.state.LifeCycleState.needsRegister",
	"Comment": "return whether the object is registered with the persistence manager.",
	"Method": "boolean needsRegister(){\r\n    return needsRegister;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ServiceRefPortInfo.removeStubProperty",
	"Comment": "remove stub property, using property name as a key. this willremove the property value of an existing stub property withthe matching name.",
	"Method": "void removeStubProperty(NameValuePairDescriptor property){\r\n    NameValuePairDescriptor prop = getStubPropertyByName(property.getName());\r\n    if (prop != null) {\r\n        stubProperties.remove(property);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.JavaTypeHelper.getWrapperName",
	"Comment": "returns the name of the wrapper class associated with the supplied \tprimitive type name.",
	"Method": "String getWrapperName(String primitiveName){\r\n    return (String) _primitiveNamesToWrapperNames.get(primitiveName);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.EnhancerClassLoader.addURL",
	"Comment": "appends the specified url to the list of urls to search forclasses and resources.",
	"Method": "void addURL(URL url){\r\n    throw new UnsupportedOperationException(\"Not implemented yet: EnhancerClassLoader.addURL(URL)\");\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.stats.TimeStatisticImpl.getTotalTime",
	"Comment": "returns the amount of time that it took for all invocations, since measurement started.",
	"Method": "long getTotalTime(){\r\n    return totTime;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnReadEnv.getTarget",
	"Comment": "get the canonical insntarget instance for the specifiedpc within the method.",
	"Method": "InsnTarget getTarget(int targ){\r\n    return codeEnv.getTarget(targ);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.handlers.AbstractResourceHandler.processAnnotation",
	"Comment": "process annotation with given resourcecontainercontexts.",
	"Method": "HandlerProcessingResult processAnnotation(AnnotationInfo ainfo,ResourceContainerContext[] rcContexts,HandlerProcessingResult processAnnotation,AnnotationInfo ainfo){\r\n    AnnotatedElementHandler aeHandler = ainfo.getProcessingContext().getHandler();\r\n    if (aeHandler instanceof EjbBundleContext) {\r\n        EjbBundleContext ejbBundleContext = (EjbBundleContext) aeHandler;\r\n        aeHandler = ejbBundleContext.createContextForEjb();\r\n        if (aeHandler == null) {\r\n            aeHandler = ejbBundleContext.createContextForEjbInterceptor();\r\n        }\r\n        EjbBundleDescriptor bundleDesc = ejbBundleContext.getDescriptor();\r\n        RootDeploymentDescriptor enclosingBundle = bundleDesc.getModuleDescriptor().getDescriptor();\r\n        boolean ejbJar = enclosingBundle instanceof EjbBundleDescriptor;\r\n        if ((aeHandler == null) && ejbJar) {\r\n            aeHandler = ejbBundleContext;\r\n        }\r\n    }\r\n    if (aeHandler == null) {\r\n        return getInvalidAnnotatedElementHandlerResult(ainfo.getProcessingContext().getHandler(), ainfo);\r\n    }\r\n    ResourceContainerContext[] rcContexts = null;\r\n    if (aeHandler instanceof EjbsContext) {\r\n        EjbsContext ejbsContext = (EjbsContext) aeHandler;\r\n        rcContexts = (ResourceContainerContext[]) ejbsContext.getEjbContexts();\r\n    } else if (aeHandler instanceof WebComponentsContext) {\r\n        WebComponentsContext webCompsContext = (WebComponentsContext) aeHandler;\r\n        rcContexts = (ResourceContainerContext[]) webCompsContext.getWebComponentContexts();\r\n    } else if (aeHandler instanceof ResourceContainerContext) {\r\n        rcContexts = new ResourceContainerContext[] { (ResourceContainerContext) aeHandler };\r\n    } else {\r\n        return getInvalidAnnotatedElementHandlerResult(aeHandler, ainfo);\r\n    }\r\n    return processAnnotation(ainfo, rcContexts);\r\n}"
}, {
	"Path": "org.glassfish.concurrent.admin.ListContextServices.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        Collection<ContextService> contextServices = domain.getResources().getResources(ContextService.class);\r\n        List<Map<String, String>> resourcesList = new ArrayList<Map<String, String>>();\r\n        List<DefaultResourceProxy> drps = habitat.getAllServices(DefaultResourceProxy.class);\r\n        for (ContextService contextService : contextServices) {\r\n            String jndiName = contextService.getJndiName();\r\n            if (bindableResourcesHelper.resourceExists(jndiName, target)) {\r\n                ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n                part.setMessage(jndiName);\r\n                Map<String, String> resourceNameMap = new HashMap<String, String>();\r\n                String logicalName = DefaultResourceProxy.Util.getLogicalName(drps, jndiName);\r\n                if (logicalName != null) {\r\n                    resourceNameMap.put(\"logical-jndi-name\", logicalName);\r\n                }\r\n                resourceNameMap.put(\"name\", jndiName);\r\n                resourcesList.add(resourceNameMap);\r\n            }\r\n        }\r\n        Properties extraProperties = new Properties();\r\n        extraProperties.put(\"contextServices\", resourcesList);\r\n        report.setExtraProperties(extraProperties);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.context.service.failed\", \"List context services failed\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.perms.SMGlobalPolicyUtil.checkRestrictionOfComponentType",
	"Comment": "check a permission set against a restriction of a component type",
	"Method": "void checkRestrictionOfComponentType(PermissionCollection declaredPC,CommponentType type){\r\n    if (CommponentType.ear == type)\r\n        checkRestrictionOfEar(declaredPC);\r\n    PermissionCollection restrictedPC = compTypeToEERestrictedMap.get(type);\r\n    checkRestriction(declaredPC, restrictedPC);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRegistry.addManagedConnectionFactory",
	"Comment": "add mcf instance pertaining to the poolname to the registry.",
	"Method": "void addManagedConnectionFactory(PoolInfo poolInfo,PoolMetaData pmd){\r\n    factories.put(poolInfo, pmd);\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"Added MCF to connector registry for: \" + poolInfo);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.webservices.CommonServerSecurityPipe.preDestroy",
	"Comment": "this method is called once in server side and at most one in client side.",
	"Method": "void preDestroy(){\r\n    helper.disable();\r\n    try {\r\n        Packet request = new Packet();\r\n        PacketMessageInfo info = new PacketMapMessageInfo(request, new Packet());\r\n        Subject subj = new Subject();\r\n        ServerAuthContext sAC = helper.getServerAuthContext(info, subj);\r\n        if (sAC != null && WSIT_SERVER_AUTH_CONTEXT.equals(sAC.getClass().getName())) {\r\n            sAC.cleanSubject(info, subj);\r\n        }\r\n    } catch (Exception ex) {\r\n    }\r\n    next.preDestroy();\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.Java2DBProcessorHelper.setDropTablesValue",
	"Comment": "store user defined value for drop tables for future reference.",
	"Method": "void setDropTablesValue(boolean dropTablesValue,String bundleName){\r\n    deploymentContextProps.setProperty(DROP_TABLE_VALUE + bundleName, \"\" + dropTablesValue);\r\n    if (logger.isLoggable(Level.FINE)) {\r\n        logger.fine(\"---> \" + DROP_TABLE_VALUE + bundleName + \" \" + dropTablesValue);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.readMetaInfo",
	"Comment": "for backward compat, we are not implementing those methods directly",
	"Method": "Object readMetaInfo(ReadableArchive archive){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.getConnectionLoginTimeout",
	"Comment": "returns the number of seconds to wait for a new connection to beestablished to the data source",
	"Method": "int getConnectionLoginTimeout(){\r\n    return _persistenceManagerFactory.getConnectionLoginTimeout();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.MQAddressList.toString",
	"Comment": "creates a string representation of address list fromarray list. in short, it is a comma separated list.actual syntax of an mq url is inside mqurl class.",
	"Method": "String toString(){\r\n    StringBuilder builder = new StringBuilder();\r\n    Iterator it = urlList.iterator();\r\n    if (it.hasNext()) {\r\n        builder.append(it.next().toString());\r\n    }\r\n    while (it.hasNext()) {\r\n        builder.append(\",\").append(it.next().toString());\r\n    }\r\n    String s = builder.toString();\r\n    if (logger.isLoggable(Level.FINE))\r\n        logFine(\"toString returns :: \" + s);\r\n    return s;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingReferenceKeyElementImpl.getIndexOfColumnPair",
	"Comment": "convenience method which takes a pair and returns its index.",
	"Method": "int getIndexOfColumnPair(String searchPairName){\r\n    ArrayList myPairs = getColumnPairNames();\r\n    int count = ((myPairs != null) ? myPairs.size() : 0);\r\n    if (count > 0) {\r\n        int i;\r\n        for (i = 0; i < count; i++) {\r\n            if (myPairs.get(i).equals(searchPairName))\r\n                return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ee.audit.AppServerAuditManager.ejbAsWebServiceInvocation",
	"Comment": "this method is called for the web service calls with mls set and the endpoints deployed as servlets",
	"Method": "void ejbAsWebServiceInvocation(String endpoint,boolean validRequest){\r\n    if (auditOn) {\r\n        for (AuditModule am : myAuditModules()) {\r\n            try {\r\n                am.ejbAsWebServiceInvocation(endpoint, validRequest);\r\n            } catch (Exception ex) {\r\n                final String name = moduleName(am);\r\n                final String msg = _localStrings.getLocalString(AUDIT_MGR_EJB_AS_WS_INVOCATION_KEY, \" Audit Module {0} threw the following exception during ejb as web service invocation :\", name);\r\n                _logger.log(Level.INFO, msg, ex);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.apf.AnnotationProcessorException.getLocator",
	"Comment": "return information about the annotation and annotated element which caused the exception or null if it is not available.",
	"Method": "AnnotationInfo getLocator(){\r\n    return locator;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ApplicationClientDescriptor.visit",
	"Comment": "visit the descriptor and all sub descriptors with a dol visitor implementation",
	"Method": "void visit(DescriptorVisitor aVisitor){\r\n    if (aVisitor instanceof AppClientVisitor || aVisitor instanceof ComponentPostVisitor) {\r\n        visit((ComponentVisitor) aVisitor);\r\n    } else {\r\n        super.visit(aVisitor);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.getRequireTrackedSCO",
	"Comment": "returns the boolean value of the requiretrackedsco flagfor this persistencemanager. if set to false, this persistencemanagerwill not create tracked sco instances fornew persistent instances at commit with retainvalues set to trueand while retrieving data from a datastore.",
	"Method": "boolean getRequireTrackedSCO(){\r\n    return _requireTrackedSCO;\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.jws.servedcontent.AutoSignedContent.file",
	"Comment": "returns a file object for where the signed file will be once it iscreated.note that any use of the file returned by this method mustbe preceded by an invocation of isavailable.",
	"Method": "File file(){\r\n    return signedFile;\r\n}"
}, {
	"Path": "org.glassfish.admin.mejb.IIOPMBeanServerImpl.getDefaultDomain",
	"Comment": "returns the default domain used for naming the managed object.the default domain name is used as the domain part in the objectnameof managed objects if no domain is specified by the user.",
	"Method": "String getDefaultDomain(){\r\n    return server.getDefaultDomain();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.PreparedStatementWrapper40.executeQuery",
	"Comment": "executes the given sql statement, which returns a singleresultset object.",
	"Method": "java.sql.ResultSet executeQuery(java.sql.ResultSet executeQuery,String sql){\r\n    ResultSet rs = preparedStatement.executeQuery(sql);\r\n    incrementResultSetReferenceCount();\r\n    return new ResultSetWrapper40(this, rs);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.connection.ConnectionManager.waitForConnection",
	"Comment": "wait for a pool connection.the thread will wait msintervalmilliseconds between tries to get a connection from the pool.if no connection is available after mswait milliseconds, anexception is thrown.",
	"Method": "void waitForConnection(){\r\n    int interval = this.msInterval;\r\n    int wait = this.msWait;\r\n    int totalTime = 0;\r\n    boolean done = false;\r\n    Thread t = Thread.currentThread();\r\n    do {\r\n        if (this.freeList.size > 0) {\r\n            done = true;\r\n        } else {\r\n            if (this.poolSize < this.maxPool) {\r\n                try {\r\n                    expandPool(1);\r\n                    done = true;\r\n                } catch (SQLException se) {\r\n                    throw se;\r\n                }\r\n            } else {\r\n                if (totalTime >= wait) {\r\n                    SQLException se = new SQLException(StringScanner.createParamString(// NOI18N\r\n                    I18NHelper.getMessage(messages, \"connection.connectionmanager.conntimeout\")), SQL_CONN_FAIL);\r\n                    throw se;\r\n                } else {\r\n                    try {\r\n                        this.wait(interval);\r\n                    } catch (InterruptedException ie) {\r\n                        SQLException se = new SQLException(StringScanner.createParamString(I18NHelper.getMessage(messages, \"connection.connectionmanager.threaditerupted\")), SQL_CONN_FAIL);\r\n                        throw se;\r\n                    }\r\n                }\r\n                totalTime += interval;\r\n            }\r\n        }\r\n    } while (!done);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getURL",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object as a java.net.urlobject in the java programming language.",
	"Method": "URL getURL(int columnIndex,URL getURL,String columnName){\r\n    return resultSet.getURL(columnName);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.ParameterSupport.setParameterEjbName",
	"Comment": "set ejb name corresponding to the ejbql parameter by inputparameter declaration string.",
	"Method": "void setParameterEjbName(String ejbqlParamDecl,String ejbName){\r\n    parameterEjbNames[getParamNumber(ejbqlParamDecl) - 1] = ejbName;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createSerializableClassComponent",
	"Comment": "create a validation component which can check that the persistence \tcapable class implement methods readobject and writeobject, if the class \timplements the intreface java.io.serializable",
	"Method": "ValidationComponent createSerializableClassComponent(String className){\r\n    return new ValidationComponent() {\r\n        public void validate() throws ModelValidationException {\r\n            Model model = getModel();\r\n            Object pcClass = null;\r\n            if (className == null)\r\n                return;\r\n            pcClass = model.getClass(className);\r\n            if (pcClass == null)\r\n                return;\r\n            if (model.implementsInterface(pcClass, \"java.io.Serializable\")) {\r\n                Object readMethod = // NOI18N\r\n                model.getMethod(// NOI18N\r\n                className, \"readObject\", Model.getReadObjectArgs());\r\n                if (!matchesMethod(// NOI18N\r\n                readMethod, Modifier.PRIVATE, Modifier.SYNCHRONIZED, \"void\")) {\r\n                    throw new ModelValidationException(pcClass, I18NHelper.getMessage(getMessages(), \"util.validation.class_readobject\", className));\r\n                }\r\n                Object writeMethod = // NOI18N\r\n                model.getMethod(// NOI18N\r\n                className, \"writeObject\", Model.getWriteObjectArgs());\r\n                if (!matchesMethod(// NOI18N\r\n                writeMethod, Modifier.PRIVATE, Modifier.SYNCHRONIZED, \"void\")) {\r\n                    throw new ModelValidationException(pcClass, I18NHelper.getMessage(getMessages(), \"util.validation.class_writeobject\", className));\r\n                }\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createSerializableClassComponent",
	"Comment": "create a validation component which can check that the persistence \tcapable class implement methods readobject and writeobject, if the class \timplements the intreface java.io.serializable",
	"Method": "ValidationComponent createSerializableClassComponent(String className){\r\n    Model model = getModel();\r\n    Object pcClass = null;\r\n    if (className == null)\r\n        return;\r\n    pcClass = model.getClass(className);\r\n    if (pcClass == null)\r\n        return;\r\n    if (model.implementsInterface(pcClass, \"java.io.Serializable\")) {\r\n        Object readMethod = // NOI18N\r\n        model.getMethod(// NOI18N\r\n        className, \"readObject\", Model.getReadObjectArgs());\r\n        if (!matchesMethod(// NOI18N\r\n        readMethod, Modifier.PRIVATE, Modifier.SYNCHRONIZED, \"void\")) {\r\n            throw new ModelValidationException(pcClass, I18NHelper.getMessage(getMessages(), \"util.validation.class_readobject\", className));\r\n        }\r\n        Object writeMethod = // NOI18N\r\n        model.getMethod(// NOI18N\r\n        className, \"writeObject\", Model.getWriteObjectArgs());\r\n        if (!matchesMethod(// NOI18N\r\n        writeMethod, Modifier.PRIVATE, Modifier.SYNCHRONIZED, \"void\")) {\r\n            throw new ModelValidationException(pcClass, I18NHelper.getMessage(getMessages(), \"util.validation.class_writeobject\", className));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsIntegrityEnhancementFacility",
	"Comment": "retrieves whether this database supports the sql integrityenhancement facility.",
	"Method": "boolean supportsIntegrityEnhancementFacility(){\r\n    return databaseMetaData.supportsIntegrityEnhancementFacility();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsResultSetHoldability",
	"Comment": "retrieves whether this database supports the given result set holdability.",
	"Method": "boolean supportsResultSetHoldability(int holdability){\r\n    return databaseMetaData.supportsResultSetHoldability(holdability);\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.MonitoringHandlers.getMonitoringPools",
	"Comment": "returns the jdbc connection pools, connector connection pools,first jdbc element and first connector element for the given set ofpool namesand resources endpoint.",
	"Method": "void getMonitoringPools(HandlerContext handlerCtx){\r\n    List<String> poolNames = (List<String>) handlerCtx.getInputValue(\"poolNames\");\r\n    String endpoint = (String) handlerCtx.getInputValue(\"endpoint\");\r\n    List<String> jdbcMonitorList = new ArrayList<String>();\r\n    List<String> connectorMonitorList = new ArrayList<String>();\r\n    String fisrtJdbc = \"\";\r\n    String firstConnector = \"\";\r\n    try {\r\n        List<String> jdbcPools = new ArrayList<String>(RestUtil.getChildMap(endpoint + \"/jdbc-connection-pool\").keySet());\r\n        List<String> connectorPools = new ArrayList<String>(RestUtil.getChildMap(endpoint + \"/connector-connection-pool\").keySet());\r\n        for (String poolName : poolNames) {\r\n            if (jdbcPools.contains(poolName)) {\r\n                jdbcMonitorList.add(poolName);\r\n            } else if (connectorPools.contains(poolName)) {\r\n                connectorMonitorList.add(poolName);\r\n            }\r\n        }\r\n    } catch (Exception ex) {\r\n        GuiUtil.handleException(handlerCtx, ex);\r\n    }\r\n    handlerCtx.setOutputValue(\"jdbcList\", jdbcMonitorList);\r\n    handlerCtx.setOutputValue(\"firstJdbc\", fisrtJdbc);\r\n    handlerCtx.setOutputValue(\"connectorList\", connectorMonitorList);\r\n    handlerCtx.setOutputValue(\"firstConnector\", firstConnector);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.SelectStatement.appendAnsiJoinTableText",
	"Comment": "appends sql text corresponding to specified table to specified text.the linked list starting with table.nexttable is walked recursivelyto generate join text.",
	"Method": "void appendAnsiJoinTableText(StringBuffer text,QueryTable table){\r\n    if (table.joinOp == ActionDesc.OP_RIGHTJOIN) {\r\n        text.append(vendorType.getRightJoinPre());\r\n    }\r\n    if (table.prevTable == null) {\r\n        appendTableText(text, table);\r\n    }\r\n    for (int i = 0; i < table.nextTable.size(); i++) {\r\n        QueryTable toTable = (QueryTable) table.nextTable.get(i);\r\n        text.append(getJoinOperator(table.joinOp)).append(\" \");\r\n        appendTableText(text, toTable);\r\n        if (toTable.onClause != null) {\r\n            text.append(\" on \");\r\n            text.append(toTable.onClause);\r\n        }\r\n        if (toTable.nextTable != null) {\r\n            appendAnsiJoinTableText(text, toTable);\r\n        }\r\n        if (table.joinOp == ActionDesc.OP_LEFTJOIN) {\r\n            text.append(vendorType.getLeftJoinPost());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createCollectionClassComponent",
	"Comment": "create a validation component which can check whether the collection \tclass is valid given the relationship field type.",
	"Method": "ValidationComponent createCollectionClassComponent(RelationshipElement field){\r\n    return new ValidationComponent() {\r\n        public void validate() throws ModelValidationException {\r\n            String className = getClassName();\r\n            String fieldName = field.getName();\r\n            if (isCollection(className, fieldName)) {\r\n                Model model = getModel();\r\n                String collectionClass = field.getCollectionClass();\r\n                String fieldType = model.getFieldType(className, fieldName);\r\n                boolean missingCollectionClass = StringHelper.isEmpty(collectionClass);\r\n                if (!missingCollectionClass && !model.getSupportedCollectionClasses(fieldType).contains(collectionClass)) {\r\n                    throw constructFieldException(fieldName, \"util.validation.collection_class_invalid\");\r\n                }\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createCollectionClassComponent",
	"Comment": "create a validation component which can check whether the collection \tclass is valid given the relationship field type.",
	"Method": "ValidationComponent createCollectionClassComponent(RelationshipElement field){\r\n    String className = getClassName();\r\n    String fieldName = field.getName();\r\n    if (isCollection(className, fieldName)) {\r\n        Model model = getModel();\r\n        String collectionClass = field.getCollectionClass();\r\n        String fieldType = model.getFieldType(className, fieldName);\r\n        boolean missingCollectionClass = StringHelper.isEmpty(collectionClass);\r\n        if (!missingCollectionClass && !model.getSupportedCollectionClasses(fieldType).contains(collectionClass)) {\r\n            throw constructFieldException(fieldName, \"util.validation.collection_class_invalid\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.connection.ConnectionManager.setURL",
	"Comment": "sets the default database url for the data source. this default is onlyfor the current connection manager.to get a connection using a different data source than the default, use thegetconnection method that specifies a database url as a parameter.",
	"Method": "void setURL(String url){\r\n    if (url == null) {\r\n        SQLException se = new SQLException(StringScanner.createParamString(// NOI18N\r\n        I18NHelper.getMessage(messages, \"connection.connectionmanager.nullurl\")), SQL_INVALID_VALUE);\r\n        throw se;\r\n    }\r\n    this.url = url;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createSchemaExistenceComponent",
	"Comment": "create a validation component which can check whether the schema of \tthe given class exists.",
	"Method": "ValidationComponent createSchemaExistenceComponent(String className,ValidationComponent createSchemaExistenceComponent,String className,PersistenceFieldElement relatedField){\r\n    return new ValidationComponent() {\r\n        public void validate() throws ModelValidationException {\r\n            String schemaName = getSchemaForClass(className);\r\n            if ((schemaName != null) && (SchemaElement.forName(schemaName) == null)) {\r\n                Object[] args = (relatedField == null) ? new Object[] { schemaName, className } : new Object[] { schemaName, className, relatedField };\r\n                throw new ModelValidationException(ModelValidationException.WARNING, getOffendingObject(relatedField), I18NHelper.getMessage(getMessages(), getKey(\"util.validation.schema_not_found\", relatedField), args));\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createSchemaExistenceComponent",
	"Comment": "create a validation component which can check whether the schema of \tthe given class exists.",
	"Method": "ValidationComponent createSchemaExistenceComponent(String className,ValidationComponent createSchemaExistenceComponent,String className,PersistenceFieldElement relatedField){\r\n    String schemaName = getSchemaForClass(className);\r\n    if ((schemaName != null) && (SchemaElement.forName(schemaName) == null)) {\r\n        Object[] args = (relatedField == null) ? new Object[] { schemaName, className } : new Object[] { schemaName, className, relatedField };\r\n        throw new ModelValidationException(ModelValidationException.WARNING, getOffendingObject(relatedField), I18NHelper.getMessage(getMessages(), getKey(\"util.validation.schema_not_found\", relatedField), args));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.TypeSupport.isLocalInterfaceOfEjb",
	"Comment": "returns true if the specified type info denotes thelocal interface of the bean with the specified ejb name.",
	"Method": "boolean isLocalInterfaceOfEjb(Object typeInfo,String ejbName){\r\n    String typeName = getTypeName(typeInfo);\r\n    String localInterface = nameMapper.getLocalInterfaceForEjbName(ejbName);\r\n    return (localInterface != null) && localInterface.equals(typeName);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.FieldGroupElement.addFields",
	"Comment": "add the supplied fields to the collection of fields maintained by this\tholder.",
	"Method": "void addFields(PersistenceFieldElement[] fields){\r\n    getFieldGroupImpl().changeFields(fields, Impl.ADD);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerWrapper.getUserObject",
	"Comment": "the application can manage the persistencemanager instancesmore easily by having an application object associated with eachpersistencemanager instance.",
	"Method": "Object getUserObject(){\r\n    if (isValid) {\r\n        return pm.getUserObject();\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerwrapper.invalidpm\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.recovery.ConnectorsRecoveryResourceHandler.getTransactionSupport",
	"Comment": "provides the transaction support for the pool.if none specified in the pool, tx support at ra level will be returned.",
	"Method": "String getTransactionSupport(ConnectorConnectionPool pool){\r\n    String txSupport = pool.getTransactionSupport();\r\n    if (txSupport != null) {\r\n        return txSupport;\r\n    }\r\n    try {\r\n        txSupport = ConnectorRuntime.getRuntime().getConnectorDescriptor(pool.getResourceAdapterName()).getOutboundResourceAdapter().getTransSupport();\r\n    } catch (ConnectorRuntimeException cre) {\r\n        Object[] params = new Object[] { pool.getResourceAdapterName(), cre };\r\n        _logger.log(Level.WARNING, \"error.retrieving.tx-support.from.rar\", params);\r\n        if (_logger.isLoggable(Level.FINEST)) {\r\n            _logger.finest(\"setting no-tx-support as tx-support-level for pool : \" + pool.getName());\r\n        }\r\n        txSupport = ConnectorConstants.NO_TRANSACTION_TX_SUPPORT_STRING;\r\n    }\r\n    return txSupport;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.provider.PolicyConfigurationImpl.stateIs",
	"Comment": "checks if policycontex is in agrument state.detects implicpit state changes resulting fromdistribution of policy files by synchronizationsystem.",
	"Method": "boolean stateIs(int stateValue){\r\n    boolean inState = _stateIs(stateValue);\r\n    if (stateValue == INSERVICE_STATE && !inState) {\r\n        if (fileArrived(true) || fileArrived(false)) {\r\n            if (logger.isLoggable(Level.FINE)) {\r\n                logger.fine(\"JACC Policy Provider: file arrived transition to inService: \" + \" state: \" + (this.state == OPEN_STATE ? \"open \" : \"deleted \") + CONTEXT_ID);\r\n            }\r\n            initialize(false, false, true);\r\n        }\r\n        inState = _stateIs(INSERVICE_STATE);\r\n    }\r\n    return inState;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.SunContainerHelper.getPersistenceManagerFactory",
	"Comment": "called in a cmp environment to lookup persistencemanagerfactoryreferenced by this container instance as the cmp resource.this is suncontainerhelper specific code.",
	"Method": "PersistenceManagerFactory getPersistenceManagerFactory(Object container){\r\n    Object rc = null;\r\n    PersistenceManagerFactoryImpl pmf = null;\r\n    ResourceReferenceDescriptor cmpResource = ((Container) container).getEjbDescriptor().getEjbBundleDescriptor().getCMPResourceReference();\r\n    String name = cmpResource.getJndiName();\r\n    try {\r\n        InitialContext ic = new InitialContext();\r\n        rc = ic.lookup(name);\r\n        if (rc instanceof PersistenceManagerFactoryImpl) {\r\n            pmf = (PersistenceManagerFactoryImpl) rc;\r\n        } else if (rc instanceof javax.sql.DataSource) {\r\n            pmf = new PersistenceManagerFactoryImpl();\r\n            pmf.setConnectionFactoryName(ConnectorsUtil.getPMJndiName(name));\r\n            Iterator it = cmpResource.getProperties();\r\n            if (it != null) {\r\n                while (it.hasNext()) {\r\n                    NameValuePairDescriptor prop = (NameValuePairDescriptor) it.next();\r\n                    String n = prop.getName();\r\n                    boolean value = Boolean.valueOf(prop.getValue()).booleanValue();\r\n                    pmf.setBooleanProperty(n, value);\r\n                }\r\n            }\r\n        } else {\r\n            RuntimeException e = new JDOFatalUserException(// NOI18N\r\n            I18NHelper.getMessage(messages, \"ejb.jndi.unexpectedinstance\", name, rc.getClass().getName()));\r\n            logger.severe(e.toString());\r\n            throw e;\r\n        }\r\n    } catch (javax.naming.NamingException ex) {\r\n        RuntimeException e = new JDOFatalUserException(I18NHelper.getMessage(messages, \"ejb.jndi.lookupfailed\", name), ex);\r\n        logger.severe(e.toString());\r\n        throw e;\r\n    }\r\n    return pmf;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.generator.JavaClassWriterHelper.getWrapperType",
	"Comment": "returns java object wrapper class corresponding tothe primitive class if the passed class represents a primitive.if the parameter is of object type, it is returned.",
	"Method": "Class getWrapperType(Class cls){\r\n    Class rc = getWrapperClass(cls);\r\n    if (rc == null) {\r\n        rc = cls;\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.ExceptionTable.handlers",
	"Comment": "return an enumeration of the exception handlerseach element in the enumeration is an exceptionrange",
	"Method": "Enumeration handlers(){\r\n    return theVector.elements();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.QueryPlan.findQueryTable",
	"Comment": "finds the querytable object that this query plan is usingto describe the tabledesc indicated by the tabledesc parameter.",
	"Method": "QueryTable findQueryTable(TableElement tableElement,QueryTable findQueryTable,TableDesc tableDesc){\r\n    for (int i = 0; i < tables.size(); i++) {\r\n        QueryTable t = (QueryTable) tables.get(i);\r\n        if (t.getTableDesc() == tableDesc)\r\n            return t;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsSchemasInIndexDefinitions",
	"Comment": "retrieves whether a schema name can be used in an index definition statement.",
	"Method": "boolean supportsSchemasInIndexDefinitions(){\r\n    return databaseMetaData.supportsSchemasInIndexDefinitions();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.Insn.insert",
	"Comment": "insert an instruction sequence in the code sequence after this instruction.returns the final instruction.",
	"Method": "Insn insert(Insn i){\r\n    if (i == null)\r\n        return this;\r\n    Insn theNextInsn = nextInsn;\r\n    nextInsn = i;\r\n    i.prevInsn = this;\r\n    while (i.nextInsn != null) i = i.nextInsn;\r\n    i.nextInsn = theNextInsn;\r\n    if (theNextInsn != null)\r\n        theNextInsn.prevInsn = i;\r\n    return i;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MessageDestinationReferencerImpl.isLinkedToMessageDestination",
	"Comment": "true if this reference has been resolved to a valid messagedestinationobject.",
	"Method": "boolean isLinkedToMessageDestination(){\r\n    return (messageDestination != null);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsCatalogsInDataManipulation",
	"Comment": "retrieves whether a catalog name can be used in a data manipulation statement.",
	"Method": "boolean supportsCatalogsInDataManipulation(){\r\n    return databaseMetaData.supportsCatalogsInDataManipulation();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.wasNull",
	"Comment": "reports whetherthe last column read had a value of sql null.note that you must first call one of the getter methodson a column to try to read its value and then callthe method wasnull to see if the value read wassql null.",
	"Method": "boolean wasNull(){\r\n    return resultSet.wasNull();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.loadForUpdate",
	"Comment": "triggers the state transition for write and registers the instancein the transaction cache. prepares all dfg fields for update.",
	"Method": "void loadForUpdate(){\r\n    boolean debug = logger.isLoggable(Logger.FINER);\r\n    if (debug) {\r\n        logger.finer(\"sqlstore.sqlstatemanager.loadforupdate\");\r\n    }\r\n    persistenceManager.acquireShareLock();\r\n    try {\r\n        getLock();\r\n        byte oldFlags = persistenceManager.getFlags(persistentObject);\r\n        if (oldFlags == READ_WRITE_OK) {\r\n            return;\r\n        }\r\n        persistenceManager.setFlags(persistentObject, READ_WRITE_OK);\r\n        ArrayList fields = persistenceConfig.fields;\r\n        try {\r\n            for (int i = 0; i < fields.size(); i++) {\r\n                FieldDesc f = (FieldDesc) fields.get(i);\r\n                if (f.fetchGroup == FieldDesc.GROUP_DEFAULT) {\r\n                    prepareUpdateField(f, null);\r\n                }\r\n            }\r\n        } catch (JDOException e) {\r\n            persistenceManager.setFlags(persistentObject, oldFlags);\r\n            throw e;\r\n        }\r\n    } finally {\r\n        persistenceManager.releaseShareLock();\r\n        releaseLock();\r\n        if (debug) {\r\n            logger.finer(\"sqlstore.sqlstatemanager.loadforupdate.exit\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.FieldDesc.convertToDateFieldType",
	"Comment": "returns an unmanaged date instance. converts valueto the field type for this field according to enumfieldtype.",
	"Method": "Object convertToDateFieldType(Object value,StateManager sm,Object convertToDateFieldType,Object value){\r\n    Object retVal = value;\r\n    if (!fieldType.equals(value.getClass())) {\r\n        if (value instanceof Date) {\r\n            switch(enumFieldType) {\r\n                case FieldTypeEnumeration.UTIL_DATE:\r\n                    retVal = new java.util.Date(((Date) value).getTime());\r\n                    break;\r\n                case FieldTypeEnumeration.SQL_DATE:\r\n                    retVal = new java.sql.Date(((Date) value).getTime());\r\n                    break;\r\n                case FieldTypeEnumeration.SQL_TIME:\r\n                    retVal = new java.sql.Time(((Date) value).getTime());\r\n                    break;\r\n                case FieldTypeEnumeration.SQL_TIMESTAMP:\r\n                    retVal = new java.sql.Timestamp(((Date) value).getTime());\r\n                    if (value instanceof java.sql.Timestamp) {\r\n                        ((java.sql.Timestamp) retVal).setNanos(((java.sql.Timestamp) value).getNanos());\r\n                    }\r\n                    break;\r\n                default:\r\n            }\r\n        }\r\n    }\r\n    return retVal;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.acquireCacheLock",
	"Comment": "lock cache for getobjectbyid and result processing synchronization.",
	"Method": "void acquireCacheLock(){\r\n    _cacheLock.acquire();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.RetrieveDescImpl.addParameterConstraints",
	"Comment": "add constraints corresponding to given fields.the constraints are added as parameter constraints.index of the parameter starts at given startindex",
	"Method": "void addParameterConstraints(LocalFieldDesc[] fields,int startIndex){\r\n    for (int i = 0; i < fields.length; i++) {\r\n        LocalFieldDesc field = fields[i];\r\n        addParameterConstraint(field, i + startIndex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.generator.JavaClassWriterHelper.getParametersListWithSeparator",
	"Comment": "returns list of method parameters delimited by specifiedseparator",
	"Method": "String getParametersListWithSeparator(Method m,String sep){\r\n    int count = m.getParameterTypes().length;\r\n    StringBuffer rc = new StringBuffer();\r\n    for (int ii = 0; ii < count; ii++) {\r\n        if (ii > 0)\r\n            rc.append(sep);\r\n        rc.append(param_ + ii);\r\n    }\r\n    return rc.toString();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.web.integration.WebSecurityManager.getVirtualServers",
	"Comment": "virtual servers are maintained in the reference contained in server element. first, we need to find the serverand then get the virtual server from the correct reference",
	"Method": "String getVirtualServers(String appName){\r\n    String ret = null;\r\n    Server server = serverContext.getDefaultServices().getService(Server.class);\r\n    for (ApplicationRef appRef : server.getApplicationRef()) {\r\n        if (appRef.getRef().equals(appName)) {\r\n            return appRef.getVirtualServers();\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "admin.monitoring.Jira.test13905",
	"Comment": "nothing should be logged at the info level when the monitoring level ischanged. at the fine level we should see it.",
	"Method": "void test13905(){\r\n    LogListener listener = null;\r\n    try {\r\n        final String prepend = \"test13905::\";\r\n        listener = new LogListener(DOMAIN_NAME);\r\n        File logfile = listener.getFile();\r\n        if (logfile == null) {\r\n            report(false, \"LogListener.getFile() returned null\");\r\n            return;\r\n        }\r\n        report(logfile.exists(), prepend + \"logfile exists\");\r\n        report(logfile.isFile(), prepend + \"logfile is-a-file\");\r\n        report(logfile.canRead(), prepend + \"logfile is readable\");\r\n        report(logfile.length() > 0, prepend + \"logfile is not empty\");\r\n        report(asadmin(\"set-log-levels\", \"javax.enterprise.system.tools.monitor=INFO\"), \"set-log-level-back\");\r\n        listener.getLatest(3);\r\n        report(asadmin(\"enable-monitoring\", \"--modules\", \"web-container=LOW\"), prepend + \"change-mon-level-nolog-\");\r\n        String s = listener.getLatest(2);\r\n        report(s.indexOf(\"monitor\") < 0, prepend + \"no-log-output\");\r\n        report(asadmin(\"enable-monitoring\", \"--modules\", \"web-container=HIGH\"), prepend + \"change-mon-level-nolog-\");\r\n        s = listener.getLatest(2);\r\n        report(s.indexOf(\"monitor\") < 0, prepend + \"no-log-output\");\r\n        report(asadmin(\"set-log-levels\", \"javax.enterprise.system.tools.monitor=FINE\"), \"set-log-level-to-fine\");\r\n        s = listener.getLatest(5);\r\n        report(s.length() > 0, prepend + \"set-log-level was noticed\");\r\n        report(asadmin(\"enable-monitoring\", \"--modules\", \"web-container=LOW\"), prepend + \"change-mon-level-yeslog-\");\r\n        s = listener.getLatest(2);\r\n        report(s.indexOf(\"monitor\") >= 0, prepend + \"yes-log-output\");\r\n        report(asadmin(\"enable-monitoring\", \"--modules\", \"web-container=HIGH\"), prepend + \"change-mon-level-yeslog-\");\r\n        report(asadmin(\"set-log-levels\", \"javax.enterprise.system.tools.monitor=INFO\"), \"set-log-level-back\");\r\n        s = listener.getLatest(5);\r\n        report(s.length() > 0, prepend + \"set-log-level was noticed\");\r\n    } finally {\r\n        listener.close();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admingui.connector.GadgetUserPref.setRequired",
	"Comment": "boolean property indicating if the preference is required. the \tdefault is false.",
	"Method": "void setRequired(boolean required){\r\n    this.required = required;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.moveToCurrentRow",
	"Comment": "moves the cursor to the remembered cursor position, usually thecurrent row.this method has no effect if the cursor is not onthe insert row.",
	"Method": "void moveToCurrentRow(){\r\n    resultSet.moveToCurrentRow();\r\n}"
}, {
	"Path": "com.sun.gjc.common.DataSourceSpec.equals",
	"Comment": "checks whether two datasourcespec objectsare equal or not.",
	"Method": "boolean equals(Object obj){\r\n    if (obj instanceof DataSourceSpec) {\r\n        return this.details.equals(((DataSourceSpec) obj).details);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ee.Audit.authentication",
	"Comment": "invoked post authentication request for a user in a given realm",
	"Method": "void authentication(String user,String realm,boolean success){\r\n    if (auditFlag) {\r\n        StringBuffer sbuf = new StringBuffer(\"Audit: Authentication for user = (\");\r\n        sbuf.append(user);\r\n        sbuf.append(\") under realm = (\");\r\n        sbuf.append(realm).append(\") returned = \").append(success);\r\n        logger.log(Level.INFO, sbuf.toString());\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.SunContainerHelper.getNumericConverterPolicy",
	"Comment": "called in cmp environment to get numericconverter policy referencedby this container instance.",
	"Method": "int getNumericConverterPolicy(Object container){\r\n    return NumericConverter.DEFAULT_POLICY;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jmac.config.GFServerConfigProvider.loadConfigContext",
	"Comment": "this method is intended to be called by the admin configuration systemwhen the corresponding config object has changed. it relies on the slaves, since it is a static method.",
	"Method": "void loadConfigContext(Object config){\r\n    boolean hasSlaveFactory = false;\r\n    boolean hasSlaveProvider = false;\r\n    rwLock.readLock().lock();\r\n    try {\r\n        hasSlaveFactory = (slaveFactory != null);\r\n        hasSlaveProvider = (slaveProvider != null);\r\n    } finally {\r\n        rwLock.readLock().unlock();\r\n    }\r\n    if (slaveProvider == null) {\r\n        if (logger.isLoggable(Level.SEVERE)) {\r\n            logger.severe(\"unableToLoad.noSlaveProvider\");\r\n        }\r\n        return;\r\n    }\r\n    if (!hasSlaveFactory) {\r\n        rwLock.writeLock().lock();\r\n        try {\r\n            if (slaveFactory == null) {\r\n                slaveFactory = AuthConfigFactory.getFactory();\r\n            }\r\n        } finally {\r\n            rwLock.writeLock().unlock();\r\n        }\r\n    }\r\n    loadParser(slaveProvider, slaveFactory, config);\r\n}"
}, {
	"Path": "org.glassfish.admin.amxtest.base.AMXTest.checkSelfObjectName",
	"Comment": "verify that the objectname returned from the mbean is in fact itself.",
	"Method": "void checkSelfObjectName(ObjectName obj){\r\n    final ObjectName selfName = (ObjectName) getConnection().getAttribute(obj, AMXAttributes.ATTR_OBJECT_NAME);\r\n    assert (selfName.equals(obj));\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.pam.PamRealm.init",
	"Comment": "initialize a realm with some properties.this can be usedwhen instantiating realms from their descriptions.thismethod may only be called a single time.",
	"Method": "void init(Properties props){\r\n    super.init(props);\r\n    String jaasCtx = props.getProperty(JAAS_CONTEXT_PARAM);\r\n    if (jaasCtx == null) {\r\n        throw new BadRealmException(\"No jaas-context defined\");\r\n    }\r\n    this.setProperty(JAAS_CONTEXT_PARAM, jaasCtx);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.support.JDOHelper.isPersistent",
	"Comment": "tests whether an object is persistent.for objects whose state is stored in the data store, trueis returned.for transient objects, false is returned.",
	"Method": "boolean isPersistent(Object obj){\r\n    if (obj instanceof PersistenceCapable)\r\n        return ((PersistenceCapable) obj).jdoIsPersistent();\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getContainerTransaction",
	"Comment": "returns a containertransaction if all the transactional methods onthe ejb descriptor have the same transaction type else return null",
	"Method": "ContainerTransaction getContainerTransaction(){\r\n    Vector transactionalMethods = new Vector(this.getTransactionMethodDescriptors());\r\n    MethodDescriptor md = (MethodDescriptor) transactionalMethods.firstElement();\r\n    if (md != null) {\r\n        ContainerTransaction first = this.getContainerTransactionFor(md);\r\n        for (Enumeration e = transactionalMethods.elements(); e.hasMoreElements(); ) {\r\n            MethodDescriptor next = (MethodDescriptor) e.nextElement();\r\n            ContainerTransaction nextCt = this.getContainerTransactionFor(next);\r\n            if (nextCt != null && !nextCt.equals(first)) {\r\n                return null;\r\n            }\r\n        }\r\n        return first;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.TransactionImpl.rollback",
	"Comment": "rollback the transaction represented by this transaction object.",
	"Method": "void rollback(){\r\n    persistenceManager.acquireExclusiveLock();\r\n    try {\r\n        if (txType == CMT || txType == BMT_UT) {\r\n            throw new JDOUserException(// NOI18N\r\n            I18NHelper.getMessage(// NOI18N\r\n            messages, \"transaction.transactionimpl.mgd\", \"rollback\"));\r\n        }\r\n        this.setTrace();\r\n        if (this.tracing)\r\n            this.traceCall(\"rollback\");\r\n        if ((this.status != Status.STATUS_ACTIVE) && (this.status != Status.STATUS_MARKED_ROLLBACK)) {\r\n            throw new JDOUserException(// NOI18N\r\n            I18NHelper.getMessage(messages, \"transaction.transactionimpl.commit_rollback.notactive\", \"rollback\", this.statusString(this.status)));\r\n        }\r\n        this.setStatus(Status.STATUS_ROLLING_BACK);\r\n        this.internalRollback();\r\n        this.closeConnection();\r\n        if (txType == BMT_JDO) {\r\n            try {\r\n                EJBHelper.getLocalTransactionManager().rollback();\r\n            } catch (Exception e) {\r\n                throw new JDOException(\"\", e);\r\n            }\r\n        } else {\r\n            this.notifyAfterCompletion();\r\n        }\r\n    } finally {\r\n        persistenceManager.releaseExclusiveLock();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.logging.AbstractLogger.getMessage",
	"Comment": "this method returns a string from the bundle file if possible, \ttreating the message argument as the key.if no such key is found\tin the bundle, the message itself is returned.",
	"Method": "String getMessage(String message){\r\n    try {\r\n        return getBundle().getString(message);\r\n    } catch (MissingResourceException e) {\r\n        return message;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.archive.EjbSniffer.supportsArchiveType",
	"Comment": "this api is used to help determine if the sniffer should recognizethe current archive.if the sniffer does not support the archive type associated withthe current deployment, the sniffer should not recognize the archive.",
	"Method": "boolean supportsArchiveType(ArchiveType archiveType){\r\n    if (archiveType.equals(ejbType) || archiveType.toString().equals(ModuleType.WAR.toString())) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.stats.BoundedRangeStatisticImpl.getHighWaterMark",
	"Comment": "returns the highest value of this statistic, since measurement started.",
	"Method": "long getHighWaterMark(){\r\n    return highWaterMark;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.reconfigureConnectorConnectionPool",
	"Comment": "reconfigure a connection pool.this method compares the passed connector connection pool with the onein memory. if the pools are unequal and the mcf properties are changeda pool recreate is required. however if the pools are unequal and themcf properties are not changed a recreate is not required",
	"Method": "boolean reconfigureConnectorConnectionPool(ConnectorConnectionPool ccp,Set excludedProps){\r\n    return ccPoolAdmService.reconfigureConnectorConnectionPool(ccp, excludedProps);\r\n}"
}, {
	"Path": "org.glassfish.ejb.mdb.MessageBeanContextImpl.isUnitialized",
	"Comment": "returns true if this context has not progressed past its initialstate.",
	"Method": "boolean isUnitialized(){\r\n    return (state == EJBContextImpl.BeanState.CREATED);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.getDeclaringClass",
	"Comment": "returns the string representation of declaring class of \tthe specified member element.note, the member element is \teither a class element as returned by getclass, a field element \tas returned by getfield, a constructor element as returned by \tgetconstructor, or a method element as returned by getmethod \texecuted on the same model instance.",
	"Method": "String getDeclaringClass(Object memberElement){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.getJdbcDriverClassNames",
	"Comment": "get jdbc driver implementation class names list for the dbvendor andresource type supplied.",
	"Method": "Set<String> getJdbcDriverClassNames(String dbVendor,String resType,Set<String> getJdbcDriverClassNames,String dbVendor,String resType,boolean introspect){\r\n    return driverLoader.getJdbcDriverClassNames(dbVendor, resType, introspect);\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.ctl.SortResponseControl.getAttributeID",
	"Comment": "retrieves the id of the attribute that caused the sort to fail.returns null if no id was returned by the server.",
	"Method": "String getAttributeID(){\r\n    return badAttrId;\r\n}"
}, {
	"Path": "org.glassfish.admingui.devtests.EjbContainerTest.testEjbSettingsDefault",
	"Comment": "test that the default button in ejb settings will fill in the default value when pressed.",
	"Method": "void testEjbSettingsDefault(){\r\n    gotoDasPage();\r\n    clickAndWait(\"treeForm:tree:configurations:server-config:ejbContainer:ejbContainer_link\");\r\n    clickByIdAction(\"form1:propertySheet:generalPropertySection:commitOptionProp:optC\");\r\n    setFieldValue(\"form1:propertySheet:poolSettingSection:MinSizeProp:MinSize\", \"2\");\r\n    setFieldValue(\"form1:propertySheet:poolSettingSection:MaxSizeProp:MaxSize\", \"34\");\r\n    setFieldValue(\"form1:propertySheet:poolSettingSection:PoolResizeProp:PoolResize\", \"10\");\r\n    setFieldValue(\"form1:propertySheet:poolSettingSection:TimeoutProp:Timeout\", \"666\");\r\n    setFieldValue(\"form1:propertySheet:cacheSettingSection:MaxCacheProp:MaxCache\", \"520\");\r\n    setFieldValue(\"form1:propertySheet:cacheSettingSection:CacheResizeProp:CacheResize\", \"36\");\r\n    setFieldValue(\"form1:propertySheet:cacheSettingSection:RemTimoutProp:RemTimout\", \"5454\");\r\n    Select select1 = new Select(driver.findElement(By.id(\"form1:propertySheet:cacheSettingSection:RemPolicyProp:RemPolicy\")));\r\n    select1.selectByVisibleText(\"First In First Out (fifo)\");\r\n    setFieldValue(\"form1:propertySheet:cacheSettingSection:CacheIdleProp:CacheIdle\", \"666\");\r\n    clickAndWait(\"form1:propertyContentPage:topButtons:saveButton\");\r\n    assertTrue(isElementSaveSuccessful(\"label_sun4\", \"New values successfully saved.\"));\r\n    gotoDasPage();\r\n    clickAndWait(\"treeForm:tree:configurations:server-config:ejbContainer:ejbContainer_link\");\r\n    String location = getValue(\"form1:propertySheet:generalPropertySection:SessionStoreProp:SessionStore\", \"value\");\r\n    clickAndWait(\"form1:propertyContentPage:loadDefaultsButton\");\r\n    waitForButtonEnabled(\"form1:propertyContentPage:loadDefaultsButton\");\r\n    assertEquals(location, getValue(\"form1:propertySheet:generalPropertySection:SessionStoreProp:SessionStore\", \"value\"));\r\n    assertEquals(true, driver.findElement(By.id((\"form1:propertySheet:generalPropertySection:commitOptionProp:optB\"))).isSelected());\r\n    assertEquals(\"0\", getValue(\"form1:propertySheet:poolSettingSection:MinSizeProp:MinSize\", \"value\"));\r\n    assertEquals(\"32\", getValue(\"form1:propertySheet:poolSettingSection:MaxSizeProp:MaxSize\", \"value\"));\r\n    assertEquals(\"8\", getValue(\"form1:propertySheet:poolSettingSection:PoolResizeProp:PoolResize\", \"value\"));\r\n    assertEquals(\"600\", getValue(\"form1:propertySheet:poolSettingSection:TimeoutProp:Timeout\", \"value\"));\r\n    assertEquals(\"512\", getValue(\"form1:propertySheet:cacheSettingSection:MaxCacheProp:MaxCache\", \"value\"));\r\n    assertEquals(\"32\", getValue(\"form1:propertySheet:cacheSettingSection:CacheResizeProp:CacheResize\", \"value\"));\r\n    assertEquals(\"5400\", getValue(\"form1:propertySheet:cacheSettingSection:RemTimoutProp:RemTimout\", \"value\"));\r\n    assertEquals(\"nru\", getValue(\"form1:propertySheet:cacheSettingSection:RemPolicyProp:RemPolicy\", \"value\"));\r\n    assertEquals(\"600\", getValue(\"form1:propertySheet:cacheSettingSection:CacheIdleProp:CacheIdle\", \"value\"));\r\n    clickAndWait(\"form1:propertyContentPage:topButtons:saveButton\");\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.isFirst",
	"Comment": "retrieves whether the cursor is on the first row ofthis resultset object.",
	"Method": "boolean isFirst(){\r\n    return resultSet.isFirst();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.MethodAnnotater.avoidAnnotation",
	"Comment": "check to see if this is a special case that should not beannotated.",
	"Method": "boolean avoidAnnotation(){\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jacc.provider.SimplePolicyConfiguration.delete",
	"Comment": "causes all policy statements to be deleted from this policyconfigurationand sets its internal state such that calling any method, other thandelete, getcontextid, or inservice on the policyconfiguration willbe rejected and cause an unsupportedoperationexception to be thrown.this operation has no affect on any linked policyconfigurationsother than removing any links involving the deleted policyconfiguration.",
	"Method": "void delete(){\r\n    checkSetPolicyPermission();\r\n    SharedState.removeLinks(id);\r\n    pcwLock.lock();\r\n    try {\r\n        removePolicy();\r\n    } finally {\r\n        try {\r\n            setState(DELETED_STATE);\r\n        } finally {\r\n            pcwLock.unlock();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CacheObjectKey.hashCode",
	"Comment": "generate hashcode for this object using the sql and statementtype fields",
	"Method": "int hashCode(){\r\n    int hash = 7;\r\n    hash = 41 * hash + (this.sql != null ? this.sql.hashCode() : 0);\r\n    hash = 41 * hash + (this.statementType != null ? this.statementType.hashCode() : 0);\r\n    hash = 41 * hash + this.resultSetType;\r\n    hash = 41 * hash + this.resultSetConcurrency;\r\n    hash = 41 * hash + this.resultSetHoldability;\r\n    if (CacheObjectKey.PREPARED_STATEMENT.equals(this.statementType)) {\r\n        hash = 41 * hash + this.autoGeneratedKeys;\r\n        if (this.columnIndexes != null) {\r\n            for (int i : this.columnIndexes) {\r\n                hash = 41 * hash + ((Integer) i).hashCode();\r\n            }\r\n        }\r\n        if (this.columnNames != null) {\r\n            for (String str : columnNames) {\r\n                hash = 41 * hash + str.hashCode();\r\n            }\r\n        }\r\n    }\r\n    return hash;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.util.ClassPath.zipFileNameOf",
	"Comment": "return a file name which might reasonably identify a file containingthe specified class in a zip file.",
	"Method": "String zipFileNameOf(String className){\r\n    return fileNameOf(className, '/');\r\n}"
}, {
	"Path": "org.glassfish.persistence.ejb.entitybean.container.EntityContainer.releaseContext",
	"Comment": "this is called from basecontainer.postinvoke afterentitycontainer.preinvoketx has been called.",
	"Method": "void releaseContext(EjbInvocation inv){\r\n    EntityContextImpl context = (EntityContextImpl) inv.context;\r\n    boolean decrementedCalls = false;\r\n    if (context.isInState(BeanState.DESTROYED))\r\n        return;\r\n    try {\r\n        if (context.hasReentrantCall()) {\r\n            if (containerStateManager.isRemovedEJBObject(inv)) {\r\n                removeIncompleteTxEJB(context, true);\r\n                containerStateManager.disconnectContext(context);\r\n            } else {\r\n                if (context.isInState(BeanState.INVOKING)) {\r\n                    doFlush(inv);\r\n                }\r\n            }\r\n        } else if (containerStateManager.isNullEJBObject(context) && containerStateManager.isNullEJBLocalObject(context)) {\r\n            decrementedCalls = true;\r\n            context.decrementCalls();\r\n            if (!(inv.invocationInfo.startsWithCreate)) {\r\n                context.setTransaction(null);\r\n                addPooledEJB(context);\r\n            } else if (context.getTransaction() == null) {\r\n                addPooledEJB(context);\r\n            } else {\r\n                context.setState(BeanState.INCOMPLETE_TX);\r\n            }\r\n        } else if (containerStateManager.isRemovedEJBObject(inv)) {\r\n            removeIncompleteTxEJB(context, true);\r\n            containerStateManager.markObjectRemoved(context, false);\r\n            decrementedCalls = true;\r\n            context.decrementCalls();\r\n            if (context.getTransaction() == null) {\r\n                addPooledEJB(context);\r\n            } else {\r\n                context.setState(BeanState.INCOMPLETE_TX);\r\n            }\r\n        } else if (context.getTransaction() == null) {\r\n            int status = context.getLastTransactionStatus();\r\n            decrementedCalls = true;\r\n            context.decrementCalls();\r\n            context.setLastTransactionStatus(-1);\r\n            if (status == -1 || status == Status.STATUS_COMMITTED || status == Status.STATUS_NO_TRANSACTION)\r\n                addReadyEJB(context);\r\n            else\r\n                passivateAndPoolEJB(context);\r\n        } else {\r\n            context.setState(BeanState.INCOMPLETE_TX);\r\n            doFlush(inv);\r\n        }\r\n    } catch (Exception ex) {\r\n        _logger.log(Level.FINE, \"entitybean.container.release_context_exception\", logParams);\r\n        _logger.log(Level.FINE, \"\", ex);\r\n        throw new EJBException(ex);\r\n    } finally {\r\n        if (decrementedCalls == false) {\r\n            context.decrementCalls();\r\n        }\r\n        context.touch();\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.StatementWrapper.setQueryTimeout",
	"Comment": "sets the number of seconds the driver will wait for astatement object to execute to the given number of seconds.if the limit is exceeded, an sqlexception is thrown.",
	"Method": "void setQueryTimeout(int seconds){\r\n    jdbcStatement.setQueryTimeout(seconds);\r\n}"
}, {
	"Path": "org.glassfish.loadbalancer.admin.cli.helper.LbConfigHelper.exportXml",
	"Comment": "exports the loadbalancer.xml from the config to the outputstream provided",
	"Method": "void exportXml(LoadbalancerReader lbRdr,OutputStream out){\r\n    Loadbalancer _lb = new Loadbalancer();\r\n    LoadbalancerVisitor lbVstr = new LoadbalancerVisitor(_lb);\r\n    lbRdr.accept(lbVstr);\r\n    try {\r\n        String footer = LbLogUtil.getStringManager().getString(\"GeneratedFileFooter\", new Date().toString());\r\n        _lb.graphManager().setDoctype(PUBLICID, SYSTEMID);\r\n        _lb.write(out);\r\n        out.write(footer.getBytes());\r\n    } finally {\r\n        if (out != null) {\r\n            out.close();\r\n            out = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.CMPBeanHelper.assertNotContainerTransaction",
	"Comment": "called from a 1.1 cmp bean to verify that the bean method is not calledin a container transaction. throws illegalstateexception otherwise.",
	"Method": "void assertNotContainerTransaction(Object bean){\r\n    if (EJBHelper.getTransaction() != null) {\r\n        String msg = // NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        cmpMessages, \"JDO.containertransaction_exception\", bean);\r\n        cmpInternalLogger.log(Logger.SEVERE, msg);\r\n        throw new IllegalStateException(msg);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.getConnectionMaxPool",
	"Comment": "returns maximum number of connections in the connection pool",
	"Method": "int getConnectionMaxPool(){\r\n    return _persistenceManagerFactory.getConnectionMaxPool();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.deployment.AuthorizationConstraintImpl.getSecurityRoles",
	"Comment": "return the security roles involved in this constraint. the enumeration is empty if there are none.",
	"Method": "Enumeration getSecurityRoles(){\r\n    if (this.securityRoles == null) {\r\n        this.securityRoles = new HashSet();\r\n    }\r\n    return (new Vector(this.getSecurityRoleSet())).elements();\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.getServiceReferenceByName",
	"Comment": "looks up an service reference with the given name.throws an illegalargumentexception if it is not found.",
	"Method": "ServiceReferenceDescriptor getServiceReferenceByName(String name){\r\n    for (Iterator itr = getServiceReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        ServiceReferenceDescriptor srd = (ServiceReferenceDescriptor) itr.next();\r\n        if (srd.getName().equals(name)) {\r\n            return srd;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(\"No service ref of name \" + name);\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.DSManagedConnectionFactory.createManagedConnection",
	"Comment": "creates a new physical connection to the underlying eis resourcemanager.",
	"Method": "javax.resource.spi.ManagedConnection createManagedConnection(javax.security.auth.Subject subject,ConnectionRequestInfo cxRequestInfo){\r\n    if (logWriter != null) {\r\n        logWriter.println(\"In createManagedConnection\");\r\n    }\r\n    PasswordCredential pc = SecurityUtils.getPasswordCredential(this, subject, cxRequestInfo);\r\n    if (dataSourceObj == null) {\r\n        if (dsObjBuilder == null) {\r\n            dsObjBuilder = new DataSourceObjectBuilder(spec);\r\n        }\r\n        try {\r\n            dataSourceObj = (javax.sql.DataSource) dsObjBuilder.constructDataSourceObject();\r\n        } catch (ClassCastException cce) {\r\n            _logger.log(Level.SEVERE, \"jdbc.exc_cce\", cce);\r\n            throw new javax.resource.ResourceException(cce.getMessage());\r\n        }\r\n    }\r\n    java.sql.Connection dsConn = null;\r\n    try {\r\n        if (isEqual(pc, getUser(), getPassword())) {\r\n            dsConn = dataSourceObj.getConnection();\r\n        } else {\r\n            dsConn = dataSourceObj.getConnection(pc.getUserName(), new String(pc.getPassword()));\r\n        }\r\n    } catch (java.sql.SQLException sqle) {\r\n        sqle.printStackTrace();\r\n        _logger.log(Level.WARNING, \"jdbc.exc_create_conn\", sqle);\r\n        throw new javax.resource.spi.ResourceAllocationException(\"The connection could not be allocated: \" + sqle.getMessage());\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n    }\r\n    com.sun.jdbcra.spi.ManagedConnection mc = new com.sun.jdbcra.spi.ManagedConnection(null, dsConn, pc, this);\r\n    return mc;\r\n}"
}, {
	"Path": "org.glassfish.uberjar.osgimain.ModuleExtractor.copy",
	"Comment": "copies input to output. to avoid unnecessary allocation of byte buffers,this method takes a byte buffer as argument. it clears the byte bufferat the end of the operation.",
	"Method": "void copy(InputStream in,OutputStream out,ByteBuffer byteBuffer){\r\n    try {\r\n        ReadableByteChannel inChannel = Channels.newChannel(in);\r\n        WritableByteChannel outChannel = Channels.newChannel(out);\r\n        int read;\r\n        do {\r\n            read = inChannel.read(byteBuffer);\r\n            if (read > 0) {\r\n                byteBuffer.limit(byteBuffer.position());\r\n                byteBuffer.rewind();\r\n                int written = 0;\r\n                while ((written += outChannel.write(byteBuffer)) < read) {\r\n                }\r\n                if (logger.isLoggable(Level.FINER)) {\r\n                    if (logger.isLoggable(Level.FINER)) {\r\n                        logger.logp(Level.FINE, \"JarHelper\", \"write\", \"Copied {0} bytes\", new Object[] { read });\r\n                    }\r\n                }\r\n                byteBuffer.clear();\r\n            }\r\n        } while (read != -1);\r\n    } finally {\r\n        byteBuffer.clear();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.QueryImpl.readObject",
	"Comment": "define readobject to initialize the transient field paramtab after deserialization.this object is used for synchronization, thus it cannot be null.",
	"Method": "void readObject(java.io.ObjectInputStream in){\r\n    in.defaultReadObject();\r\n    this.paramtab = new ParameterTable();\r\n    this.createdBySerialization = true;\r\n}"
}, {
	"Path": "com.sun.jaspic.config.factory.RegStoreFileParser.checkAndRemoveFromList",
	"Comment": "if this registration context does not exist, this methodreturns false. otherwise it removes the entry and returnstrue to indicate that the configuration file should be written.this only makes sense for registry entries.",
	"Method": "boolean checkAndRemoveFromList(RegistrationContext target){\r\n    boolean retValue = false;\r\n    try {\r\n        ListIterator<EntryInfo> lit = entries.listIterator();\r\n        while (lit.hasNext()) {\r\n            EntryInfo info = lit.next();\r\n            if (info.isConstructorEntry()) {\r\n                continue;\r\n            }\r\n            Iterator<RegistrationContext> iter = info.getRegContexts().iterator();\r\n            while (iter.hasNext()) {\r\n                RegistrationContext ctx = iter.next();\r\n                if (ctx.equals(target)) {\r\n                    iter.remove();\r\n                    if (info.getRegContexts().isEmpty()) {\r\n                        lit.remove();\r\n                    }\r\n                    retValue = true;\r\n                }\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n    return retValue;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.isDistinctSupportedWithUpdateLock",
	"Comment": "returns true if this database supports distinct clause with update lock",
	"Method": "boolean isDistinctSupportedWithUpdateLock(){\r\n    String s = (String) dbMap.get(SUPPORTS_DISTINCT_WITH_UPDATE_LOCK);\r\n    Boolean b = Boolean.valueOf(s);\r\n    if (logger.isLoggable()) {\r\n        logger.fine(\"sqlstore.database.dbvendor.isdistinctupdatelocksupported\", b);\r\n    }\r\n    return b.booleanValue();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConnectionPoolAdminServiceImpl.reconfigureConnectorConnectionPool",
	"Comment": "reconfigure a connection pool.this method compares the passed connector connection pool with the onein memory. if the pools are unequal and the mcf properties are changeda pool recreate is required. however if the pools are unequal and themcf properties are not changed a recreate is not required",
	"Method": "boolean reconfigureConnectorConnectionPool(ConnectorConnectionPool ccp,Set excludedProps){\r\n    if (ccp == null) {\r\n        throw new ConnectorRuntimeException(\"No pool to reconfigure, new pool object is null\");\r\n    }\r\n    logFine(\"new ccp :\\n\" + ccp.toString());\r\n    PoolInfo poolInfo = ccp.getPoolInfo();\r\n    ConnectorConnectionPool origCcp = null;\r\n    try {\r\n        origCcp = getOriginalConnectorConnectionPool(poolInfo);\r\n    } catch (NamingException ne) {\r\n        throw new ConnectorRuntimeException(ne.getMessage());\r\n    }\r\n    if (origCcp == null) {\r\n        throw new ConnectorRuntimeException(\"No pool to reconfigure, original pool object is null\");\r\n    }\r\n    logFine(\"original ccp :\\n\" + origCcp.toString());\r\n    ConnectionPoolReconfigHelper.ReconfigAction action = ConnectionPoolReconfigHelper.compare(origCcp, ccp, excludedProps);\r\n    logFine(\"pool reconfig action == \" + action);\r\n    if (action == ConnectionPoolReconfigHelper.ReconfigAction.UPDATE_MCF_AND_ATTRIBUTES) {\r\n        updateMCFAndPoolAttributes(ccp);\r\n    } else if (action == ConnectionPoolReconfigHelper.ReconfigAction.RECREATE_POOL) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.prepareUpdateField",
	"Comment": "prepares the field described by fielddesc for update.this method is central to record changes to fields. the statetransitions to dirty. the instance is registered in thetransaction cache. if the field is set for the first time,the before image is prepared and the field is marked as modified.updated local fields are added to the column list to be updated.",
	"Method": "void prepareUpdateField(FieldDesc fieldDesc,ArrayList newlyRegisteredSMs){\r\n    if (fieldDesc.isKeyField()) {\r\n        return;\r\n    }\r\n    getUpdateDesc().markRelationshipChange(fieldDesc);\r\n    boolean debug = logger.isLoggable();\r\n    if (debug) {\r\n        Object[] items = new Object[] { fieldDesc.getName(), state };\r\n        logger.fine(\"sqlstore.sqlstatemanager.prepareupdatefield\", items);\r\n    }\r\n    boolean optimistic = persistenceManager.isOptimisticTransaction();\r\n    boolean xactActive = persistenceManager.isActiveTransaction();\r\n    boolean nontransactionalRead = persistenceManager.isNontransactionalRead();\r\n    if (state.needsReload(optimistic, nontransactionalRead, xactActive)) {\r\n        reload(fieldDesc);\r\n    }\r\n    LifeCycleState oldstate = state;\r\n    state = state.transitionWriteField(xactActive);\r\n    registerInstance(false, newlyRegisteredSMs, oldstate);\r\n    if (state == oldstate && getSetMaskBit(fieldDesc.absoluteID) && getPresenceMaskBit(fieldDesc.absoluteID)) {\r\n        return;\r\n    }\r\n    if (state.isBeforeImageUpdatable()) {\r\n        if (!getPresenceMaskBit(fieldDesc.absoluteID)) {\r\n            prepareGetField(fieldDesc);\r\n        }\r\n        updateBeforeImage(fieldDesc, null);\r\n    }\r\n    recordUpdatedField(fieldDesc);\r\n    if (debug) {\r\n        logger.fine(\"sqlstore.sqlstatemanager.prepareupdatefield.exit\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.jqlc.ParameterTable.isInlineType",
	"Comment": "returns true if the specified parameter denotes a typewhose values should be inlined by the query optimizer if a query parameter s is declared with such a type.",
	"Method": "boolean isInlineType(Object type){\r\n    if ((type instanceof StringType) || (type instanceof PrimitiveType) || (type instanceof WrapperClassType) || (type instanceof MathType) || (type instanceof DateType))\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnUtils.lLoad",
	"Comment": "return the best instruction for loading a long from a localvariable slot",
	"Method": "Insn lLoad(int i,ConstantPool pool){\r\n    if (i == 0)\r\n        return Insn.create(opc_lload_0);\r\n    else if (i == 1)\r\n        return Insn.create(opc_lload_1);\r\n    else if (i == 2)\r\n        return Insn.create(opc_lload_2);\r\n    else if (i == 3)\r\n        return Insn.create(opc_lload_3);\r\n    return Insn.create(opc_lload, i);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsGroupByBeyondSelect",
	"Comment": "retrieves whether this database supports using columns not included inthe select statement in a group by clauseprovided that all of the columns in the select statementare included in the group by clause.",
	"Method": "boolean supportsGroupByBeyondSelect(){\r\n    return databaseMetaData.supportsGroupByBeyondSelect();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.getIgnoreCache",
	"Comment": "returns the boolean value for the flag that allows the user to request that queries\tbe optimized to return approximate results by ignoring changed values in the cache.",
	"Method": "boolean getIgnoreCache(){\r\n    return ignoreCache;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.handlers.RolesAllowedHandler.processEjbMethodSecurity",
	"Comment": "add roles and permissions to given method in ejbdescriptor.",
	"Method": "void processEjbMethodSecurity(Annotation authAnnotation,MethodDescriptor md,EjbDescriptor ejbDesc){\r\n    RolesAllowed rolesAllowedAn = (RolesAllowed) authAnnotation;\r\n    for (String roleName : rolesAllowedAn.value()) {\r\n        Role role = new Role(roleName);\r\n        ejbDesc.getEjbBundleDescriptor().addRole(role);\r\n        ejbDesc.addPermissionedMethod(new MethodPermission(role), md);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.servlet.DownloadServlet.writeHeader",
	"Comment": "this method is responsible for setting the response header \tinformation.",
	"Method": "void writeHeader(DownloadServlet.ContentSource source,DownloadServlet.Context context){\r\n    ServletResponse resp = context.getServletResponse();\r\n    if (!(resp instanceof HttpServletResponse)) {\r\n        return;\r\n    }\r\n    long longTime = source.getLastModified(context);\r\n    if (longTime != -1) {\r\n        ((HttpServletResponse) resp).setDateHeader(\"Last-Modified\", longTime);\r\n    }\r\n    String contentType = (String) context.getAttribute(CONTENT_TYPE);\r\n    if (contentType == null) {\r\n        String ext = (String) context.getAttribute(EXTENSION);\r\n        if (ext != null) {\r\n            contentType = mimeTypes.get(ext);\r\n        }\r\n        if (contentType == null) {\r\n            contentType = DEFAULT_CONTENT_TYPE;\r\n        }\r\n    }\r\n    setHeaderNameValue((HttpServletResponse) resp, \"Content-type\", contentType);\r\n    Object o = context.getAttribute(HEADERS);\r\n    if (o instanceof Map) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        Map<String, String> headers = (Map<String, String>) o;\r\n        for (Map.Entry<String, String> h : headers.entrySet()) {\r\n            ((HttpServletResponse) resp).setHeader(h.getKey(), h.getValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceElementCollection.getElements",
	"Comment": "returns the collection of elements maintained by this holder in the form\tof an array.",
	"Method": "PersistenceElement[] getElements(){\r\n    return _elements;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ServiceRefPortInfo.removeCallProperty",
	"Comment": "remove call property, using property name as a key. this willremove the property value of an existing stub property withthe matching name.",
	"Method": "void removeCallProperty(NameValuePairDescriptor property){\r\n    NameValuePairDescriptor prop = getCallPropertyByName(property.getName());\r\n    if (prop != null) {\r\n        callProperties.remove(property);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.ConnectorConfigParserFactory.getParser",
	"Comment": "returns a specific connector configuration parser class based on thetype of configurations to parse.",
	"Method": "ConnectorConfigParser getParser(String type){\r\n    if (type == null) {\r\n        return null;\r\n    }\r\n    if (type.equals(ConnectorConfigParser.AOR)) {\r\n        return new AdminObjectConfigParserImpl();\r\n    } else if (type.equals(ConnectorConfigParser.MCF)) {\r\n        return new MCFConfigParserImpl();\r\n    } else if (type.equals(ConnectorConfigParser.RA)) {\r\n        return new ResourceAdapterConfigParserImpl();\r\n    } else if (type.equals(ConnectorConfigParser.MSL)) {\r\n        return new MessageListenerConfigParserImpl();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.EnvironmentProperty.hashCode",
	"Comment": "the hashcode of an environment property is the same as that of the name string.",
	"Method": "int hashCode(){\r\n    return this.getName().hashCode();\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.PersistenceDescriptor.invalidate",
	"Comment": "ensures that persistence descriptor will regenerate itsderived information after changes have been made to persistent characteristics.",
	"Method": "void invalidate(){\r\n    cmrFieldInfo = null;\r\n    persFieldInfo = null;\r\n    fieldInfoInitialized = false;\r\n    pkeyStuffInitialized = false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.jqlc.ParameterTable.inline",
	"Comment": "returns true if the parameter with the specified index should be inlinedby the optimizer.note, this method needs to be in sync with methodgetkeyforretrievedesccache.",
	"Method": "boolean inline(String paramName){\r\n    int index = names.indexOf(paramName);\r\n    Object value = values.get(index);\r\n    if (isInlineType(types.get(index)))\r\n        return true;\r\n    if (value == null)\r\n        return true;\r\n    if (value instanceof Boolean)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.setRoleMapper",
	"Comment": "sets the mapping of rolename to users and groups on a particular server.",
	"Method": "void setRoleMapper(SecurityRoleMapper roleMapper){\r\n    this.roleMapper = roleMapper;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getEntityManagerFactoryReferenceByName",
	"Comment": "return the entity manager factory reference descriptor corresponding tothe given name.",
	"Method": "EntityManagerFactoryReferenceDescriptor getEntityManagerFactoryReferenceByName(String name){\r\n    if (env != null)\r\n        return env.getEntityManagerFactoryReferenceByName(name);\r\n    for (EntityManagerFactoryReferenceDescriptor next : getEntityManagerFactoryReferenceDescriptors()) {\r\n        if (next.getName().equals(name)) {\r\n            return next;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionbeanhasnoentitymgrfactoryrefbyname\", \"This ejb {0} has no entity manager factory reference by the name of {1}\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "com.sun.ejb.containers.BaseContainer.addSchedule",
	"Comment": "call back from the timer migration process to add automatic timers to the map of scheduleids",
	"Method": "void addSchedule(TimerPrimaryKey timerId,EJBTimerSchedule ts){\r\n    for (Map.Entry<Method, List<ScheduledTimerDescriptor>> entry : schedules.entrySet()) {\r\n        Method m = entry.getKey();\r\n        if (m.getName().equals(ts.getTimerMethodName()) && m.getParameterTypes().length == ts.getMethodParamCount()) {\r\n            scheduleIds.put(timerId, m);\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"Adding schedule: \" + ts.getScheduleAsString() + \" FOR method: \" + m);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.FieldAction.createMethod",
	"Comment": "return the name of the static method on class field whichwill create a field of the appropriate type.",
	"Method": "String createMethod(){\r\n    return fieldTypeInfo.fieldCreateMethod;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.MappingGenerator.addAllTables",
	"Comment": "adds all table names referenced by this suncmpmapping elementto this set.",
	"Method": "void addAllTables(SunCmpMapping sunCmpMapping,Set tables){\r\n    EntityMapping[] beans = sunCmpMapping.getEntityMapping();\r\n    for (int i = 0; i < beans.length; i++) {\r\n        addTableName(beans[i].getTableName(), tables);\r\n        CmpFieldMapping[] cmpfields = beans[i].getCmpFieldMapping();\r\n        for (int j = 0; j < cmpfields.length; j++) {\r\n            String[] names = cmpfields[j].getColumnName();\r\n            for (int jj = 0; jj < names.length; jj++) {\r\n                addRelatedTableName(names[jj], tables);\r\n            }\r\n        }\r\n        CmrFieldMapping[] cmrfields = beans[i].getCmrFieldMapping();\r\n        for (int j = 0; j < cmrfields.length; j++) {\r\n            ColumnPair[] pairs = cmrfields[j].getColumnPair();\r\n            for (int jj = 0; jj < pairs.length; jj++) {\r\n                String[] names = pairs[jj].getColumnName();\r\n                for (int jjj = 0; jjj < names.length; jjj++) {\r\n                    addRelatedTableName(names[jjj], tables);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.JDOQLElements.setResultType",
	"Comment": "sets the result type. the result type is the name of the element type of the jdo query result set.",
	"Method": "void setResultType(String resultType){\r\n    this.resultType = resultType;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnectionFactory.getResourceAdapter",
	"Comment": "get the resourceadapter for this managedconnectionfactory instance.",
	"Method": "javax.resource.spi.ResourceAdapter getResourceAdapter(){\r\n    if (logWriter != null) {\r\n        logWriter.println(\"In getResourceAdapter\");\r\n    }\r\n    return ra;\r\n}"
}, {
	"Path": "com.sun.appserv.connectors.internal.api.ConnectorsUtil.isValidJndiSuffix",
	"Comment": "if the suffix is one of the valid context return true.return false, if that is not the case.",
	"Method": "boolean isValidJndiSuffix(String suffix){\r\n    if (suffix != null) {\r\n        for (String validSuffix : ConnectorConstants.JNDI_SUFFIX_VALUES) {\r\n            if (validSuffix.equals(suffix)) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.JDOEJB11HelperImpl.assertObjectIdNotNull",
	"Comment": "validates that the object id instance is not null.throws jdofatalinternalexception otherwise.",
	"Method": "void assertObjectIdNotNull(Object oid){\r\n    if (oid == null) {\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"EXC_oidnull_exception\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.util.ApplicationValidator.isExistsDescriptor",
	"Comment": "method to compare existing descriptor with other descriptors. if both descriptor is equal then deploymentshould be failed. scope is nothing but app level,connector level, ejb level etc., which is used later tocompare same jndi name is defined at different scope or not.",
	"Method": "boolean isExistsDescriptor(String name,ResourceDescriptor descriptor,String scope){\r\n    if (descriptor != null) {\r\n        CommonResourceValidator commonResourceValidator = allResourceDescriptors.get(name);\r\n        if (commonResourceValidator != null) {\r\n            Descriptor existingDescriptor = commonResourceValidator.getDescriptor();\r\n            if (descriptor instanceof MailSessionDescriptor && existingDescriptor instanceof MailSessionDescriptor) {\r\n                if (!descriptor.equals(existingDescriptor)) {\r\n                    allUniqueResource = false;\r\n                    return true;\r\n                } else {\r\n                    DOLUtils.getDefaultLogger().log(Level.SEVERE, \"enterprise.deployment.util.descriptor.duplicate\", new Object[] { descriptor.getName() });\r\n                }\r\n            } else if (descriptor instanceof DataSourceDefinitionDescriptor && existingDescriptor instanceof DataSourceDefinitionDescriptor) {\r\n                if (!descriptor.equals(existingDescriptor)) {\r\n                    allUniqueResource = false;\r\n                    return true;\r\n                } else {\r\n                    DOLUtils.getDefaultLogger().log(Level.SEVERE, \"enterprise.deployment.util.descriptor.duplicate\", new Object[] { descriptor.getName() });\r\n                }\r\n            } else if (descriptor instanceof ConnectionFactoryDefinitionDescriptor && existingDescriptor instanceof ConnectionFactoryDefinitionDescriptor) {\r\n                if (!descriptor.equals(existingDescriptor)) {\r\n                    allUniqueResource = false;\r\n                    return true;\r\n                } else {\r\n                    DOLUtils.getDefaultLogger().log(Level.SEVERE, \"enterprise.deployment.util.descriptor.duplicate\", new Object[] { descriptor.getName() });\r\n                }\r\n            } else if (descriptor instanceof AdministeredObjectDefinitionDescriptor && existingDescriptor instanceof AdministeredObjectDefinitionDescriptor) {\r\n                if (!descriptor.equals(existingDescriptor)) {\r\n                    allUniqueResource = false;\r\n                    return true;\r\n                } else {\r\n                    DOLUtils.getDefaultLogger().log(Level.SEVERE, \"enterprise.deployment.util.descriptor.duplicate\", new Object[] { descriptor.getName() });\r\n                }\r\n            }\r\n            Vector vectorScope = commonResourceValidator.getScope();\r\n            if (vectorScope != null) {\r\n                vectorScope.add(scope);\r\n            }\r\n            commonResourceValidator.setScope(vectorScope);\r\n            allResourceDescriptors.put(name, commonResourceValidator);\r\n        } else {\r\n            Vector<String> vectorScope = new Vector<String>();\r\n            vectorScope.add(scope);\r\n            allResourceDescriptors.put(name, new CommonResourceValidator(descriptor, name, vectorScope));\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ConnectionHolder.getWarnings",
	"Comment": "retrieves the the first warning reported by calls on the underlyingconnection object.",
	"Method": "SQLWarning getWarnings(){\r\n    checkValidity();\r\n    return con.getWarnings();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.connector.module.ConnectorSniffer.supportsArchiveType",
	"Comment": "this api is used to help determine if the sniffer should recognizethe current archive.if the sniffer does not support the archive type associated withthe current deployment, the sniffer should not recognize the archive.",
	"Method": "boolean supportsArchiveType(ArchiveType archiveType){\r\n    if (archiveType.equals(rarType)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.hasAssemblyInformation",
	"Comment": "return true if i have roles, permissioned roles or container transactions.",
	"Method": "boolean hasAssemblyInformation(){\r\n    return (!getRoles().isEmpty()) || hasPermissionedRoles() || hasContainerTransactions();\r\n}"
}, {
	"Path": "org.glassfish.resources.javamail.deployer.MailResourceDeployer.installResource",
	"Comment": "local method for calling the resourceinstaller for installingmail resource in runtime.",
	"Method": "void installResource(MailResource mailResource,ResourceInfo resourceInfo){\r\n    org.glassfish.resources.api.JavaEEResource j2eeRes = toMailJavaEEResource(mailResource, resourceInfo);\r\n    installMailResource((org.glassfish.resources.javamail.beans.MailResource) j2eeRes, resourceInfo);\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnection.destroy",
	"Comment": "destroys the physical connection to the underlying resource manager.",
	"Method": "void destroy(){\r\n    if (logWriter != null) {\r\n        logWriter.println(\"In destroy\");\r\n    }\r\n    if (isDestroyed == true) {\r\n        return;\r\n    }\r\n    activeConnectionHandle = null;\r\n    try {\r\n        if (connectionType == ISXACONNECTION || connectionType == ISPOOLEDCONNECTION) {\r\n            pc.close();\r\n            pc = null;\r\n            actualConnection = null;\r\n        } else {\r\n            actualConnection.close();\r\n            actualConnection = null;\r\n        }\r\n    } catch (SQLException sqle) {\r\n        isDestroyed = true;\r\n        passwdCredential = null;\r\n        connectionHandles = null;\r\n        throw new ResourceException(\"The following exception has occured during destroy: \" + sqle.getMessage());\r\n    }\r\n    isDestroyed = true;\r\n    passwdCredential = null;\r\n    connectionHandles = null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.meta.JDOMetaDataPropertyImpl.getFieldNo",
	"Comment": "returns the unique field index of a declared, persistent field of aclass.",
	"Method": "int getFieldNo(String classPath,String fieldName,int[] getFieldNo,String classPath,String[] fieldNames){\r\n    final int n = (fieldNames != null ? fieldNames.length : 0);\r\n    final int[] flags = new int[n];\r\n    for (int i = 0; i < n; i++) {\r\n        flags[i] = getFieldNo(classPath, fieldNames[i]);\r\n    }\r\n    return flags;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.registry.MonitoringLevel.hashCode",
	"Comment": "returns the hash code value for this object.the hash code returned is the hash code of the name of thismonitoringlevel object.",
	"Method": "int hashCode(){\r\n    return this.name.hashCode();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.MappingFile.loadConsistency",
	"Comment": "load consistency from schema2beans into mappingclasselement",
	"Method": "List loadConsistency(EntityMapping mapping,MappingClassElement mce){\r\n    Consistency c = mapping.getConsistency();\r\n    if (null == c) {\r\n        mce.setConsistencyLevel(MappingClassElement.NONE_CONSISTENCY);\r\n    } else {\r\n        CheckVersionOfAccessedInstances versionIns = (CheckVersionOfAccessedInstances) c.getCheckVersionOfAccessedInstances();\r\n        if (c.isCheckModifiedAtCommit())\r\n            mce.setConsistencyLevel(MappingClassElement.CHECK_MODIFIED_AT_COMMIT_CONSISTENCY);\r\n        else if (c.isLockWhenLoaded())\r\n            mce.setConsistencyLevel(MappingClassElement.LOCK_WHEN_LOADED_CONSISTENCY);\r\n        else if (c.isCheckAllAtCommit())\r\n            mce.setConsistencyLevel(MappingClassElement.CHECK_ALL_AT_COMMIT_CONSISTENCY);\r\n        else if (c.isLockWhenModified())\r\n            mce.setConsistencyLevel(MappingClassElement.LOCK_WHEN_MODIFIED_CONSISTENCY);\r\n        else if (c.isLockWhenModified() && c.isCheckAllAtCommit())\r\n            mce.setConsistencyLevel(MappingClassElement.LOCK_WHEN_MODIFIED_CHECK_ALL_AT_COMMIT_CONSISTENCY);\r\n        else if (c.isNone())\r\n            mce.setConsistencyLevel(MappingClassElement.NONE_CONSISTENCY);\r\n        else if (versionIns != null) {\r\n            mce.setConsistencyLevel(MappingClassElement.VERSION_CONSISTENCY);\r\n            List versionColumns = new ArrayList();\r\n            for (int i = 0; i < versionIns.sizeColumnName(); i++) {\r\n                versionColumns.add(versionIns.getColumnName(i));\r\n            }\r\n            return versionColumns;\r\n        } else {\r\n            throw new ConversionException(// NOI18N\r\n            I18NHelper.getMessage(// NOI18N\r\n            messages, \"ERR_INVALID_CONSISTENCY_VALUE\", mce));\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.TableDesc.getVersionField",
	"Comment": "returns the field representing the version column for thistable. the version column is used for verification with versionconsistency. each table can have only one version column.",
	"Method": "LocalFieldDesc getVersionField(){\r\n    return versionField;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.logging.AbstractLogger.info",
	"Comment": "log an info message.\tif the logger is currently enabled for the info message \tlevel then the given message is forwarded to all the\tregistered output handler objects.",
	"Method": "void info(String msg){\r\n    log(INFO, msg);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ProfiledConnectionWrapper40.getMetaData",
	"Comment": "retrieves the databasemetadataobject from the underlying connectionobject.",
	"Method": "DatabaseMetaData getMetaData(){\r\n    return new DatabaseMetaDataWrapper40(this, super.getMetaData());\r\n}"
}, {
	"Path": "org.glassfish.resources.api.Resource.hasSameIdentity",
	"Comment": "checks if the specified resource has the same identity asthis resource.",
	"Method": "boolean hasSameIdentity(Resource r){\r\n    if (BINDABLE_RESOURCES.contains(this.getType())) {\r\n        if (!BINDABLE_RESOURCES.contains(r.getType())) {\r\n            return false;\r\n        }\r\n    } else if (RESOURCE_POOL.contains(this.getType())) {\r\n        if (!RESOURCE_POOL.contains(r.getType())) {\r\n            return false;\r\n        }\r\n    } else if (!(r.getType().equals(this.getType()))) {\r\n        return false;\r\n    }\r\n    String rType = r.getType();\r\n    if (rType.equals(CUSTOM_RESOURCE) || rType.equals(EXTERNAL_JNDI_RESOURCE) || rType.equals(JDBC_RESOURCE) || rType.equals(PERSISTENCE_MANAGER_FACTORY_RESOURCE) || rType.equals(CONNECTOR_RESOURCE) || rType.equals(ADMIN_OBJECT_RESOURCE) || rType.equals(MAIL_RESOURCE)) {\r\n        return isEqualAttribute(r, JNDI_NAME);\r\n    }\r\n    if (rType.equals(JDBC_CONNECTION_POOL) || rType.equals(CONNECTOR_CONNECTION_POOL)) {\r\n        return isEqualAttribute(r, CONNECTION_POOL_NAME);\r\n    }\r\n    if (rType.equals(RESOURCE_ADAPTER_CONFIG)) {\r\n        return isEqualAttribute(r, RES_ADAPTER_NAME);\r\n    }\r\n    if (rType.equals(CONNECTOR_WORK_SECURITY_MAP)) {\r\n        return isEqualAttribute(r, WORK_SECURITY_MAP_NAME) && isEqualAttribute(r, WORK_SECURITY_MAP_RA_NAME);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.Environment.fieldWarningsSuppressed",
	"Comment": "check whether the named field in the named class should havewarnings suppressed.",
	"Method": "boolean fieldWarningsSuppressed(String classname,String fieldName){\r\n    return fieldSuppressions.get(classname + \".\" + fieldName) != null;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.RuntimeBundleNode.writeMessageDestinationInfo",
	"Comment": "writes the message destination references runtime information",
	"Method": "void writeMessageDestinationInfo(Node parent,BundleDescriptor descriptor){\r\n    for (Iterator iter = descriptor.getMessageDestinations().iterator(); iter.hasNext(); ) {\r\n        MessageDestinationRuntimeNode node = new MessageDestinationRuntimeNode();\r\n        node.writeDescriptor(parent, RuntimeTagNames.MESSAGE_DESTINATION, (MessageDestinationDescriptor) iter.next());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConnectionPoolAdminServiceImpl.obtainManagedConnectionFactory",
	"Comment": "returns the mcf instance. if the mcf is already created andpresent in connectorregistry that instance is returned. otherwise itis created explicitly and added to connectorregistry.",
	"Method": "ManagedConnectionFactory obtainManagedConnectionFactory(PoolInfo poolInfo,ManagedConnectionFactory obtainManagedConnectionFactory,PoolInfo poolInfo,Hashtable env){\r\n    try {\r\n        if (_registry.isMCFCreated(poolInfo)) {\r\n            return _registry.getManagedConnectionFactory(poolInfo);\r\n        } else {\r\n            ConnectorConnectionPool connectorConnectionPool = getConnectorConnectionPool(poolInfo, env);\r\n            ActiveResourceAdapter activeResourceAdapter = getResourceAdapter(connectorConnectionPool);\r\n            ClassLoader loader = activeResourceAdapter.getClassLoader();\r\n            ManagedConnectionFactory mcf = activeResourceAdapter.createManagedConnectionFactory(connectorConnectionPool, loader);\r\n            if (mcf != null) {\r\n                validateMCF(mcf, activeResourceAdapter.getModuleName());\r\n                ResourcePrincipal prin = getDefaultResourcePrincipal(poolInfo, mcf, env);\r\n                Subject s = ConnectionPoolObjectsUtils.createSubject(mcf, prin);\r\n                int txSupport = connectorConnectionPool.getTransactionSupport();\r\n                if (mcf instanceof javax.resource.spi.TransactionSupport) {\r\n                    TransactionSupport.TransactionSupportLevel mcfTS = ((javax.resource.spi.TransactionSupport) mcf).getTransactionSupport();\r\n                    int containerTxSupport = ConnectionPoolObjectsUtils.convertSpecTxSupportToContainerTxSupport(mcfTS);\r\n                    boolean isValidTxSupportLevel = ConnectionPoolObjectsUtils.isTxSupportConfigurationSane(containerTxSupport, activeResourceAdapter.getModuleName());\r\n                    if (isValidTxSupportLevel) {\r\n                        txSupport = containerTxSupport;\r\n                    } else {\r\n                        Object[] params = { mcfTS, activeResourceAdapter.getModuleName() };\r\n                        String i18nMsg = localStrings.getString(\"ccp_adm_service.incorrect_tx_support\", params);\r\n                        ConnectorRuntimeException cre = new ConnectorRuntimeException(i18nMsg);\r\n                        _logger.log(Level.SEVERE, \"rardeployment.incorrect_tx_support\", connectorConnectionPool.getName());\r\n                        throw cre;\r\n                    }\r\n                }\r\n                boolean isPM = connectorConnectionPool.isNonComponent();\r\n                boolean isNonTx = connectorConnectionPool.isNonTransactional();\r\n                ConnectorSecurityMap[] securityMaps = connectorConnectionPool.getSecurityMaps();\r\n                RuntimeSecurityMap runtimeSecurityMap = SecurityMapUtils.processSecurityMaps(securityMaps);\r\n                boolean lazyEnlistable = connectorConnectionPool.isLazyConnectionEnlist();\r\n                boolean lazyAssoc = connectorConnectionPool.isLazyConnectionAssoc();\r\n                if (isPM || isNonTx) {\r\n                    lazyEnlistable = false;\r\n                }\r\n                if (isPM) {\r\n                    if (lazyAssoc) {\r\n                        String str = System.getProperty(\"com.sun.enterprise.resource.AllowLazyAssociationWithPM\", \"FALSE\");\r\n                        if (str.toUpperCase(Locale.getDefault()).trim().equals(\"FALSE\")) {\r\n                            lazyAssoc = false;\r\n                        }\r\n                    }\r\n                }\r\n                PoolMetaData pmd = new PoolMetaData(poolInfo, mcf, s, txSupport, prin, isPM, isNonTx, lazyEnlistable, runtimeSecurityMap, lazyAssoc);\r\n                logFine(pmd.toString());\r\n                _registry.addManagedConnectionFactory(poolInfo, pmd);\r\n            }\r\n            PoolType pt = getPoolType(connectorConnectionPool);\r\n            createAndAddPool(poolInfo, pt, env);\r\n            return mcf;\r\n        }\r\n    } catch (NamingException ne) {\r\n        String i18nMsg = localStrings.getString(\"pingpool.name_not_bound\", poolInfo);\r\n        ConnectorRuntimeException cre = new ConnectorRuntimeException(i18nMsg);\r\n        cre.initCause(ne);\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"rardeployment.jndi_lookup_failed\", poolInfo);\r\n            _logger.log(Level.FINE, \"\", cre);\r\n        }\r\n        throw cre;\r\n    } catch (NullPointerException ne) {\r\n        String i18nMsg = localStrings.getString(\"ccp_adm.failed_to_register_mcf\", poolInfo);\r\n        ConnectorRuntimeException cre = new ConnectorRuntimeException(i18nMsg);\r\n        cre.initCause(ne);\r\n        _logger.log(Level.SEVERE, \"mcf_add_toregistry_failed\", poolInfo);\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"\", cre);\r\n        }\r\n        throw cre;\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.getShort",
	"Comment": "retrieves the value of a jdbc smallint parameter as a shortin the java programming language.",
	"Method": "short getShort(int parameterIndex,short getShort,String parameterName){\r\n    return callableStatement.getShort(parameterName);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getAllEjbReferencers",
	"Comment": "called from ejbentitydescriptor.replaceentitydescriptor etc",
	"Method": "Set getAllEjbReferencers(){\r\n    return ejbReferencersPointingToMe;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.removeCollectionRelationship",
	"Comment": "nullifies the relationship for the objects removed from a collection relationship.",
	"Method": "void removeCollectionRelationship(ForeignFieldDesc fieldDesc,ArrayList removedList,ForeignFieldDesc inverseFieldDesc,boolean updateInverseRelationshipField,boolean managedRelationshipInProgress){\r\n    for (int i = 0; i < removedList.size(); i++) {\r\n        SQLStateManager removedSM = getRemovedSM(removedList.get(i));\r\n        if (removedSM != null) {\r\n            if (!managedRelationshipInProgress) {\r\n                updateRelationshipInDataStore(fieldDesc, null, removedSM, inverseFieldDesc, false);\r\n                if (updateInverseRelationshipField && inverseFieldDesc != null) {\r\n                    removedSM.removeRelationship(inverseFieldDesc, this);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.provider.BasePolicyWrapper.getPermissions",
	"Comment": "evaluates the global policy and returns apermissioncollection object specifying the set ofpermissions allowed given the characteristics of theprotection domain.",
	"Method": "PermissionCollection getPermissions(CodeSource codesource,PermissionCollection getPermissions,ProtectionDomain domain){\r\n    String contextId = PolicyContext.getContextID();\r\n    PolicyConfigurationImpl pci = getPolicyConfigForContext(contextId);\r\n    Policy appPolicy = getPolicy(pci);\r\n    PermissionCollection perms = appPolicy.getPermissions(domain);\r\n    if (perms != null) {\r\n        perms = removeExcludedPermissions(pci, perms);\r\n    }\r\n    if (logger.isLoggable(Level.FINEST)) {\r\n        logger.finest(\"JACC Policy Provider: PolicyWrapper.getPermissions(d), context (\" + contextId + \") permissions: \" + perms);\r\n    }\r\n    return perms;\r\n}"
}, {
	"Path": "org.glassfish.deployapi.SunDeploymentManager.getSupportedLocales",
	"Comment": "returns an array of supported locales for this implementation.",
	"Method": "Locale[] getSupportedLocales(){\r\n    return supportedLocales;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.hasEjbByName",
	"Comment": "return whether the application contains the given ejb by name..",
	"Method": "boolean hasEjbByName(String ejbName){\r\n    for (EjbBundleDescriptor ebd : getBundleDescriptors(EjbBundleDescriptor.class)) {\r\n        if (ebd.hasEjbByName(ejbName)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.AppClientArchivist.validate",
	"Comment": "validates the dol objects associated with this archivist, usuallyit requires that a class loader being set on this archivist or passedas a parameter",
	"Method": "void validate(ClassLoader aClassLoader){\r\n    ClassLoader cl = aClassLoader;\r\n    if (cl == null) {\r\n        cl = classLoader;\r\n    }\r\n    if (cl == null) {\r\n        return;\r\n    }\r\n    descriptor.setClassLoader(cl);\r\n    descriptor.visit(new AppClientValidator());\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.RARUtils.isPrimitiveWrapper",
	"Comment": "determines if a class is one of the eight java primitive wrapper classes",
	"Method": "boolean isPrimitiveWrapper(Class clz){\r\n    return (clz.equals(Boolean.class) || clz.equals(Character.class) || clz.equals(Byte.class) || clz.equals(Short.class) || clz.equals(Integer.class) || clz.equals(Long.class) || clz.equals(Float.class) || clz.equals(Double.class));\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.MethodAnnotater.noteStack",
	"Comment": "note the following amount of stack used by a single annotation.",
	"Method": "void noteStack(int stk){\r\n    if (stk > annotationStack)\r\n        annotationStack = (short) stk;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.UtilHandlers.prepareSuccessful",
	"Comment": "this method displays the save successful message when the page refresh.",
	"Method": "void prepareSuccessful(HandlerContext handlerCtx){\r\n    GuiUtil.prepareSuccessful(handlerCtx);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.LocalVariableTableAttribute.variables",
	"Comment": "returns an enumeration of the local variables in the tableeach element is a localvariable",
	"Method": "Enumeration variables(){\r\n    return localTable.elements();\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.obj.GroupOfNames.removeMember",
	"Comment": "removes a member from the group.performs an ldap modify to remove the member.",
	"Method": "boolean removeMember(Principal member,boolean removeMember,String dn){\r\n    if (!isBound()) {\r\n        throw new IllegalStateException();\r\n    }\r\n    if (debug) {\r\n        System.out.println(\"[debug] removing the member: \" + dn);\r\n    }\r\n    return modifyMember(dn, DirContext.REMOVE_ATTRIBUTE);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.ClassControl.annotateable",
	"Comment": "return true if the class is one which should be a candidate forannotation.",
	"Method": "boolean annotateable(){\r\n    return (persistenceType >= PersistUnknown);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.Statement.bindInputValues",
	"Comment": "binds input valus corrsponding to this statement object todatabase statement s.",
	"Method": "void bindInputValues(DBStatement s){\r\n    for (int i = 0, size = inputDesc.values.size(); i < size; i++) {\r\n        InputValue inputVal = (InputValue) inputDesc.values.get(i);\r\n        s.bindInputColumn(i + 1, inputVal.getValue(), inputVal.getColumnElement(), vendorType);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.setModuleDescriptor",
	"Comment": "archivists can be associated with a module descriptor once thexml deployment descriptors have been read and the dol treeis initialized.",
	"Method": "void setModuleDescriptor(ModuleDescriptor<T> module){\r\n    setDescriptor(module.getDescriptor());\r\n    setManifest(module.getManifest());\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.Date.setYear",
	"Comment": "sets the year of this date object to be the specifiedvalue plus 1900.",
	"Method": "void setYear(int year){\r\n    this.makeDirty();\r\n    super.setYear(year);\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.DeleteConnectorSecurityMap.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    Collection<ConnectorConnectionPool> ccPools = domain.getResources().getResources(ConnectorConnectionPool.class);\r\n    if (!isResourceExists(ccPools)) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.connector.security.map.notFound\", \"A security map named {0} for connector connection pool {1} does not exist.\", mapName, poolName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        final ConnectorConnectionPool pool = getPool(poolName, ccPools);\r\n        ConfigSupport.apply(new SingleConfigCode<ConnectorConnectionPool>() {\r\n            public Object run(ConnectorConnectionPool param) throws PropertyVetoException, TransactionFailure {\r\n                final List<SecurityMap> securityMaps = param.getSecurityMap();\r\n                if (securityMaps != null) {\r\n                    for (SecurityMap map : securityMaps) {\r\n                        if (map.getName().equals(mapName)) {\r\n                            param.getSecurityMap().remove(map);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                return param;\r\n            }\r\n        }, pool);\r\n    } catch (TransactionFailure tfe) {\r\n        Logger.getLogger(DeleteConnectorSecurityMap.class.getName()).log(Level.SEVERE, \"delete-connector-security-map failed\", tfe);\r\n        report.setMessage(localStrings.getLocalString(\"delete.connector.security.map.fail\", \"Unable to delete security map {0} for connector connection pool {1}\", mapName, poolName) + \" \" + tfe.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.DeleteConnectorSecurityMap.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final List<SecurityMap> securityMaps = param.getSecurityMap();\r\n    if (securityMaps != null) {\r\n        for (SecurityMap map : securityMaps) {\r\n            if (map.getName().equals(mapName)) {\r\n                param.getSecurityMap().remove(map);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return param;\r\n}"
}, {
	"Path": "com.sun.enterprise.container.common.impl.EntityManagerFactoryWrapper.lookupEntityManagerFactory",
	"Comment": "lookup physical entitymanagerfactory based on current componentinvocation.",
	"Method": "EntityManagerFactory lookupEntityManagerFactory(InvocationManager invMgr,ComponentEnvManager compEnvMgr,String emfUnitName,EntityManagerFactory lookupEntityManagerFactory,ComponentInvocationType invType,String emfUnitName,Object descriptor){\r\n    Application app = null;\r\n    BundleDescriptor module = null;\r\n    EntityManagerFactory emf = null;\r\n    switch(invType) {\r\n        case EJB_INVOCATION:\r\n            if (descriptor instanceof EjbDescriptor) {\r\n                EjbDescriptor ejbDesc = (EjbDescriptor) descriptor;\r\n                module = (BundleDescriptor) ejbDesc.getEjbBundleDescriptor().getModuleDescriptor().getDescriptor();\r\n                app = module.getApplication();\r\n                break;\r\n            }\r\n        case SERVLET_INVOCATION:\r\n            module = (WebBundleDescriptor) descriptor;\r\n            app = module.getApplication();\r\n            break;\r\n        case APP_CLIENT_INVOCATION:\r\n            module = (ApplicationClientDescriptor) descriptor;\r\n            app = module.getApplication();\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n    if (module != null) {\r\n        if (emfUnitName != null) {\r\n            emf = module.getEntityManagerFactory(emfUnitName);\r\n        } else {\r\n            Set<EntityManagerFactory> emFactories = module.getEntityManagerFactories();\r\n            if (emFactories.size() == 1) {\r\n                emf = emFactories.iterator().next();\r\n            }\r\n        }\r\n    }\r\n    if ((app != null) && (emf == null)) {\r\n        if (emfUnitName != null) {\r\n            emf = app.getEntityManagerFactory(emfUnitName, module);\r\n        } else {\r\n            Set<EntityManagerFactory> emFactories = app.getEntityManagerFactories();\r\n            if (emFactories.size() == 1) {\r\n                emf = emFactories.iterator().next();\r\n            }\r\n        }\r\n    }\r\n    return emf;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.realizeField",
	"Comment": "retrieves a field specified by fielddesc from the datastore. if the field is part of a group then all unfetched fieldsin the group are retrieved.realizefield is part of dynamicnavigation. the field is marked as present.",
	"Method": "void realizeField(FieldDesc fieldDesc){\r\n    assert fieldDesc != null;\r\n    boolean debug = logger.isLoggable();\r\n    if (debug) {\r\n        logger.fine(\"sqlstore.sqlstatemanager.realizefield\", fieldDesc.getName());\r\n    }\r\n    if (!persistenceConfig.isNavigable()) {\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"core.statemanager.notnavigable\", fieldDesc.getName(), persistentObject.getClass().getName()));\r\n    }\r\n    boolean fieldRealized = false;\r\n    if (fieldDesc instanceof ForeignFieldDesc) {\r\n        ForeignFieldDesc ff = (ForeignFieldDesc) fieldDesc;\r\n        if (ff.fetchGroup <= FieldDesc.GROUP_NONE && persistenceConfig.getFetchGroup(ff.fetchGroup).size() <= 1 && !ff.useJoinTable()) {\r\n            fieldRealized = realizeForeignField(ff);\r\n        }\r\n    }\r\n    if (!fieldRealized) {\r\n        retrieve(fieldDesc);\r\n    }\r\n    if (debug) {\r\n        logger.fine(\"sqlstore.sqlstatemanager.realizefield.exit\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.CMPBeanHelper.handleJDODuplicateObjectIdAsEJBException",
	"Comment": "called from a cmp bean to process jdoduplicateobjectidexception.logs the message and throws ejbexception.",
	"Method": "void handleJDODuplicateObjectIdAsEJBException(String beanName,String paramList,JDOException ex){\r\n    String msg = // NOI18N\r\n    I18NHelper.getMessage(cmpMessages, \"GEN.ejbcreate_exception_dup\", beanName, findCallingMethodName(), paramList);\r\n    cmpLifecycleLogger.log(Logger.FINER, msg, ex);\r\n    throw new EJBException(msg);\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.PingConnectionPool.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    boolean status = false;\r\n    Resources resources = domain.getResources();\r\n    String scope = \"\";\r\n    if (moduleName != null) {\r\n        if (!poolUtil.isValidModule(applicationName, moduleName, poolName, report)) {\r\n            return;\r\n        }\r\n        Application application = applications.getApplication(applicationName);\r\n        Module module = application.getModule(moduleName);\r\n        resources = module.getResources();\r\n        scope = \"java:module/\";\r\n    } else if (applicationName != null) {\r\n        if (!poolUtil.isValidApplication(applicationName, poolName, report)) {\r\n            return;\r\n        }\r\n        Application application = applications.getApplication(applicationName);\r\n        resources = application.getResources();\r\n        scope = \"java:app/\";\r\n    }\r\n    if (!poolUtil.isValidPool(resources, poolName, scope, report)) {\r\n        return;\r\n    }\r\n    PoolInfo poolInfo = new PoolInfo(poolName, applicationName, moduleName);\r\n    try {\r\n        status = connRuntime.pingConnectionPool(poolInfo);\r\n        if (status) {\r\n            report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n        } else {\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            report.setMessage(localStrings.getLocalString(\"ping.connection.pool.fail\", \"Ping Connection Pool for {0} Failed\", poolInfo));\r\n        }\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"ping.connection.pool.fail\", \"Ping Connection Pool for {0} Failed\", poolInfo));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.jqlc.ParameterTable.add",
	"Comment": "adds a new query parameter with the specified type to the query parameter table.",
	"Method": "void add(String name,Type type){\r\n    names.add(name);\r\n    types.add(type);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.CMPBeanHelper.handleJDODuplicateObjectIdAsDuplicateKeyException",
	"Comment": "called from a cmp bean to process jdoduplicateobjectidexception.logs the message and throws duplicatekeyexception.",
	"Method": "void handleJDODuplicateObjectIdAsDuplicateKeyException(String beanName,String paramList,JDOException ex){\r\n    String msg = // NOI18N\r\n    I18NHelper.getMessage(cmpMessages, \"GEN.ejbcreate_exception_dup\", beanName, findCallingMethodName(), paramList);\r\n    cmpLifecycleLogger.log(Logger.FINER, msg, ex);\r\n    throw new DuplicateKeyException(msg);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceFieldElementImpl.isKey",
	"Comment": "determines whether this field element is a key field or not.",
	"Method": "boolean isKey(){\r\n    return _isKey;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlDate.setTimeInternal",
	"Comment": "sets the sqldate object without notification of the ownerfield. used internaly to populate date from db",
	"Method": "void setTimeInternal(long time){\r\n    super.setTime(time);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.archivist.EjbArchivist.setDescriptor",
	"Comment": "set the dol descriptorfor this archivist, used by super classes",
	"Method": "void setDescriptor(Application descriptor){\r\n    Set<EjbBundleDescriptorImpl> ejbBundles = descriptor.getBundleDescriptors(EjbBundleDescriptorImpl.class);\r\n    if (ejbBundles.size() > 0) {\r\n        this.descriptor = ejbBundles.iterator().next();\r\n        if (this.descriptor.getModuleDescriptor().isStandalone())\r\n            return;\r\n        else\r\n            this.descriptor = null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.rowUpdated",
	"Comment": "retrieves whether the current row has been updated.the value returneddepends on whether or not the result set can detect updates.",
	"Method": "boolean rowUpdated(){\r\n    return resultSet.rowUpdated();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.getRuntime",
	"Comment": "returns the connectorruntime instance.it follows singleton pattern and only one instance exists at any pointof time. external entities need to call this method to getconnectorruntime instance",
	"Method": "ConnectorRuntime getRuntime(){\r\n    if (_runtime == null) {\r\n        throw new RuntimeException(\"Connector Runtime not initialized\");\r\n    }\r\n    return _runtime;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOCodeGeneratorHelper.createGeneratorException",
	"Comment": "create generatorexception for this message key and bean name.",
	"Method": "GeneratorException createGeneratorException(String key,EjbBundleDescriptor bundle,GeneratorException createGeneratorException,String key,EjbBundleDescriptor bundle,Exception e,GeneratorException createGeneratorException,String key,String beanName,EjbBundleDescriptor bundle,GeneratorException createGeneratorException,String key,String beanName,EjbBundleDescriptor bundle,Exception e,GeneratorException createGeneratorException,String key,String beanName,EjbBundleDescriptor bundle,Exception e,StringBuffer buf,GeneratorException createGeneratorException,String key,String beanName,EjbBundleDescriptor bundle,String msg){\r\n    return new GeneratorException(I18NHelper.getMessage(messages, key, new Object[] { beanName, bundle.getApplication().getRegistrationName(), getModuleName(bundle), msg }));\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.stats.TimeStatisticImpl.getMaxTime",
	"Comment": "returns the maximum amount of time that it took for one invocation of anoperation, since measurement started.",
	"Method": "long getMaxTime(){\r\n    return maxTime;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getResourceEnvReferenceDescriptors",
	"Comment": "return the set of resource environment references this ejb declares.",
	"Method": "Set<ResourceEnvReferenceDescriptor> getResourceEnvReferenceDescriptors(){\r\n    if (env != null)\r\n        return env.getResourceEnvReferenceDescriptors();\r\n    else\r\n        return resourceEnvReferences;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MethodDescriptor.getJavaPrimitiveTypes",
	"Comment": "computes the mapping between java primitive type and class loaders identifierfor such types.",
	"Method": "Map getJavaPrimitiveTypes(){\r\n    if (javaPrimitivesTypes == null) {\r\n        javaPrimitivesTypes = new Hashtable();\r\n        javaPrimitivesTypes.put(\"char\", \"C\");\r\n        javaPrimitivesTypes.put(\"byte\", \"B\");\r\n        javaPrimitivesTypes.put(\"double\", \"D\");\r\n        javaPrimitivesTypes.put(\"float\", \"F\");\r\n        javaPrimitivesTypes.put(\"int\", \"I\");\r\n        javaPrimitivesTypes.put(\"long\", \"J\");\r\n        javaPrimitivesTypes.put(\"short\", \"S\");\r\n        javaPrimitivesTypes.put(\"boolean\", \"Z\");\r\n    }\r\n    return javaPrimitivesTypes;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.VMOp.resultTypes",
	"Comment": "return the type descriptor for the stack results of the operation.",
	"Method": "String resultTypes(){\r\n    return stackResultTypes;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.WebServiceEndpoint.addHandlerChain",
	"Comment": "append handlerchain to end of handlerchain for this endpoint.",
	"Method": "void addHandlerChain(WebServiceHandlerChain handlerChain){\r\n    handlerChains.addLast(handlerChain);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.loadFromResource",
	"Comment": "loads database properties list from the specified resourceinto specified properties object.",
	"Method": "void loadFromResource(String resourceName,Properties properties){\r\n    String fullResourceName = PATH + resourceName + EXT;\r\n    PropertyHelper.loadFromResource(properties, fullResourceName, DBVendorType.class.getClassLoader());\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.removeFromVersionConsistencyCache",
	"Comment": "removes given instance from the version consistency cache, if theinstance supports version consistency.",
	"Method": "StateManager removeFromVersionConsistencyCache(StateManager sm){\r\n    StateManager rc = null;\r\n    if (null != sm && sm.hasVersionConsistency()) {\r\n        Class pcType = sm.getPersistent().getClass();\r\n        Object oid = sm.getObjectId();\r\n        VersionConsistencyCache vcCache = persistenceManagerFactory.getVersionConsistencyCache();\r\n        rc = vcCache.remove(pcType, oid);\r\n        if (null == rc) {\r\n        }\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.ErrorMsg.log",
	"Comment": "this method is called when we want to log an exception in a given level.note that all other methods in this class do not log a stack trace.",
	"Method": "void log(int level,String text,Throwable nested){\r\n    logger.log(level, text, nested);\r\n    throw new EJBQLException(text, nested);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.nullsAreSortedAtEnd",
	"Comment": "retrieves whether null values are sorted at the end regardless ofsort order.",
	"Method": "boolean nullsAreSortedAtEnd(){\r\n    return databaseMetaData.nullsAreSortedAtEnd();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsANSI92EntryLevelSQL",
	"Comment": "retrieves whether this database supports the ansi92 entry level sqlgrammar.",
	"Method": "boolean supportsANSI92EntryLevelSQL(){\r\n    return databaseMetaData.supportsANSI92EntryLevelSQL();\r\n}"
}, {
	"Path": "org.glassfish.admin.mejb.IIOPMBeanServerImpl.setAttribute",
	"Comment": "sets the value of a specific attribute of a named mbean. the mbean is identified by its object name.",
	"Method": "void setAttribute(ObjectName name,Attribute attribute){\r\n    server.setAttribute(name, attribute);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.XAManagedConnectionFactory.createManagedConnection",
	"Comment": "creates a new physical connection to the underlying eis resourcemanager.",
	"Method": "javax.resource.spi.ManagedConnection createManagedConnection(javax.security.auth.Subject subject,ConnectionRequestInfo cxRequestInfo){\r\n    logFine(\"In createManagedConnection\");\r\n    PasswordCredential pc = SecurityUtils.getPasswordCredential(this, subject, cxRequestInfo);\r\n    javax.sql.XADataSource dataSource = getDataSource();\r\n    javax.sql.XAConnection xaConn = null;\r\n    ManagedConnectionImpl mc = null;\r\n    try {\r\n        if (isEqual(pc, getUser(), getPassword())) {\r\n            xaConn = dataSource.getXAConnection();\r\n        } else {\r\n            xaConn = dataSource.getXAConnection(pc.getUserName(), new String(pc.getPassword()));\r\n        }\r\n    } catch (java.sql.SQLException sqle) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"jdbc.exc_create_xa_conn\", sqle);\r\n        }\r\n        StringManager sm = StringManager.getManager(DataSourceObjectBuilder.class);\r\n        String msg = sm.getString(\"jdbc.cannot_allocate_connection\", sqle.getMessage());\r\n        throw new ResourceAllocationException(msg, sqle);\r\n    }\r\n    try {\r\n        mc = constructManagedConnection(xaConn, null, pc, this);\r\n        mc.initializeConnectionType(ManagedConnectionImpl.ISXACONNECTION);\r\n        validateAndSetIsolation(mc);\r\n    } finally {\r\n        if (mc == null) {\r\n            if (xaConn != null) {\r\n                try {\r\n                    xaConn.close();\r\n                } catch (SQLException e) {\r\n                    _logger.log(Level.FINEST, \"Exception while closing connection : createManagedConnection\" + xaConn);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return mc;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.MQAddressList.addMQUrl",
	"Comment": "creates an instance of mqurl from jmshost element inthe dtd and add it to the addresslist.",
	"Method": "void addMQUrl(JmsHost host){\r\n    MQUrl url = createUrl(host);\r\n    urlList.add(url);\r\n}"
}, {
	"Path": "admin.GetSetTest.filterSet",
	"Comment": "filter out set requests that are known not work. encode the request if necessary.",
	"Method": "String filterSet(String line){\r\n    if (line.contains(\"module-log-levels\"))\r\n        return null;\r\n    if (line.contains(\"log-service\"))\r\n        return null;\r\n    if (line.contains(\"jndi-name\"))\r\n        return null;\r\n    if (line.contains(\"jdbc-connection-pool\") && line.contains(\"name\"))\r\n        return null;\r\n    if (line.contains(\"connector-connection-pool\") && line.contains(\"name\"))\r\n        return null;\r\n    if (line.contains(\"jvm-options\"))\r\n        return null;\r\n    if (line.contains(\"ssl.ssl-inactivity-timeout\"))\r\n        return null;\r\n    if (line.contains(\"secure-admin-principal\"))\r\n        return null;\r\n    if (line.contains(\"applications.application\"))\r\n        return null;\r\n    if (line.contains(\"security-configurations\"))\r\n        return null;\r\n    final String[] dottedprops = { \"encryption.key.alias\", \"signature.key.alias\", \"dynamic.username.password\", \"security.config\", \"administrative.domain.name\" };\r\n    for (String dp : dottedprops) {\r\n        if (line.contains(dp)) {\r\n            line = line.replace(dp, dp.replace(\".\", \"\\\\.\"));\r\n            break;\r\n        }\r\n    }\r\n    return line;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.ConnectionPool.getUnenlistedResource",
	"Comment": "to provide an unenlisted,valid, matched resource from pool.",
	"Method": "ResourceHandle getUnenlistedResource(ResourceSpec spec,ResourceAllocator alloc,Transaction tran){\r\n    return getResourceFromPool(alloc, spec);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.QueryImpl.setFilter",
	"Comment": "bind the query filter to the query instance.the query filter is a java boolean expression, which tells whetherinstances in the candidate collection are to be returned in the result.",
	"Method": "void setFilter(String filter){\r\n    synchronized (this.paramtab) {\r\n        this.filterExpression = filter;\r\n        this.compiled = false;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.TransactionHelperImpl.registerSynchronization",
	"Comment": "called in a managed environment to register internal synchronization object with the transaction synchronization. if available, this registration provides special handling of the registered instance, calling it after all user defined synchronization instances.",
	"Method": "void registerSynchronization(Transaction jta,Synchronization sync){\r\n    jta.registerSynchronization(sync);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getAroundInvokeInterceptors",
	"Comment": "return the ordered list of interceptor info for aroundinvoke behaviorof a particular business method.this listinclude the infoon any bean class interceptor.if present, this would always be thelast element in the list because of the precedence defined by the spec.",
	"Method": "List<EjbInterceptor> getAroundInvokeInterceptors(MethodDescriptor businessMethod){\r\n    LinkedList<EjbInterceptor> aroundInvokeInterceptors = new LinkedList<EjbInterceptor>();\r\n    List<EjbInterceptor> classOrMethodInterceptors = getClassOrMethodInterceptors(businessMethod);\r\n    for (EjbInterceptor next : classOrMethodInterceptors) {\r\n        if (next.getAroundInvokeDescriptors().size() > 0) {\r\n            aroundInvokeInterceptors.add(next);\r\n        }\r\n    }\r\n    if (hasAroundInvokeMethod()) {\r\n        EjbInterceptor interceptorInfo = new EjbInterceptor();\r\n        interceptorInfo.setFromBeanClass(true);\r\n        interceptorInfo.addAroundInvokeDescriptors(getAroundInvokeDescriptors());\r\n        interceptorInfo.setInterceptorClassName(getEjbImplClassName());\r\n        aroundInvokeInterceptors.add(interceptorInfo);\r\n    }\r\n    return aroundInvokeInterceptors;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOConcreteBean20Generator.getSignaturesOfGeneratorClasses",
	"Comment": "returns the signatures of the classes and properties which areinvolved in the codegen.",
	"Method": "String getSignaturesOfGeneratorClasses(){\r\n    StringBuffer signatures = // adding signature of JDOConcreteBeanGenerator\r\n    new StringBuffer().append(super.getSignaturesOfGeneratorClasses()).append(// adding signature of JDOConcreteBean20Generator\r\n    CMPTemplateFormatter.signatureDelimiter_).append(JDOConcreteBean20Generator.SIGNATURE).append(// adding signature of CMP20Templates.properties\r\n    CMPTemplateFormatter.signatureDelimiter_).append(CMP20TemplateFormatter.signature2_0Template).append(// adding signature of EJBQLC\r\n    CMPTemplateFormatter.signatureDelimiter_).append(EJBQLC.SIGNATURE);\r\n    return signatures.toString();\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.PreferencesHandler.searchTags",
	"Comment": "this handler provides a way to search for tags.all 3 properties \tare optional.if none are specified, all tags will be returned. \tif more than one are specified, tags matching all specified \tcriteria will be returned.",
	"Method": "void searchTags(HandlerContext handlerCtx){\r\n    List<Tag> results = TagSupport.queryTags((String) handlerCtx.getInputValue(\"tagName\"), (String) handlerCtx.getInputValue(\"tagViewId\"), (String) handlerCtx.getInputValue(\"user\"));\r\n    handlerCtx.setOutputValue(\"results\", results);\r\n}"
}, {
	"Path": "org.glassfish.persistence.ejb.entitybean.container.EntityContextImpl.getEJBObject",
	"Comment": "implementation of entitycontext method, overrides ejbcontextimpl method.",
	"Method": "EJBObject getEJBObject(){\r\n    if (!isRemoteInterfaceSupported) {\r\n        throw new IllegalStateException(\"EJBObject not available\");\r\n    }\r\n    if (ejbStub == null) {\r\n        Object pkey = getPrimaryKey();\r\n        ejbStub = _container.getEJBObjectStub(pkey, null);\r\n    }\r\n    return ejbStub;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createClassMappingComponent",
	"Comment": "create a validation component which can check whether the class is\tunmapped.",
	"Method": "ValidationComponent createClassMappingComponent(PersistenceClassElement persistenceClass){\r\n    return new ValidationComponent() {\r\n        public void validate() throws ModelValidationException {\r\n            PersistenceFieldElement[] fields = persistenceClass.getFields();\r\n            String className = getClassName();\r\n            if ((fields == null) || fields.length == 0) {\r\n                throw constructClassException(ModelValidationException.WARNING, className, null, \"util.validation.class_no_fields\");\r\n            } else {\r\n                MappingClassElement mappingClass = getMappingClass(className);\r\n                if ((mappingClass == null) || (mappingClass.getTables().size() == 0)) {\r\n                    throw constructClassException(ModelValidationException.WARNING, className, null, \"util.validation.class_not_mapped\");\r\n                }\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createClassMappingComponent",
	"Comment": "create a validation component which can check whether the class is\tunmapped.",
	"Method": "ValidationComponent createClassMappingComponent(PersistenceClassElement persistenceClass){\r\n    PersistenceFieldElement[] fields = persistenceClass.getFields();\r\n    String className = getClassName();\r\n    if ((fields == null) || fields.length == 0) {\r\n        throw constructClassException(ModelValidationException.WARNING, className, null, \"util.validation.class_no_fields\");\r\n    } else {\r\n        MappingClassElement mappingClass = getMappingClass(className);\r\n        if ((mappingClass == null) || (mappingClass.getTables().size() == 0)) {\r\n            throw constructClassException(ModelValidationException.WARNING, className, null, \"util.validation.class_not_mapped\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.ListResourceAdapterConfigs.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        HashMap<String, List<Property>> raMap = new HashMap<String, List<Property>>();\r\n        boolean raExists = false;\r\n        Collection<ResourceAdapterConfig> resourceAdapterConfigs = domain.getResources().getResources(ResourceAdapterConfig.class);\r\n        for (ResourceAdapterConfig r : resourceAdapterConfigs) {\r\n            if (raName != null && !raName.isEmpty()) {\r\n                if (r.getResourceAdapterName().equals(raName)) {\r\n                    raMap.put(raName, r.getProperty());\r\n                    raExists = true;\r\n                    break;\r\n                }\r\n            } else {\r\n                raMap.put(r.getResourceAdapterName(), r.getProperty());\r\n            }\r\n        }\r\n        if (raName != null && !raName.isEmpty() && !raExists) {\r\n            report.setMessage(localStrings.getLocalString(\"delete.resource.adapter.config.notfound\", \"Resource adapter {0} not found.\", raName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n        if (long_opt) {\r\n            for (Entry<String, List<Property>> raEntry : raMap.entrySet()) {\r\n                final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n                part.setMessage(raEntry.getKey());\r\n                for (Property prop : raEntry.getValue()) {\r\n                    final ActionReport.MessagePart propPart = part.addChild();\r\n                    propPart.setMessage(\"\\t\" + prop.getName() + \"=\" + prop.getValue());\r\n                }\r\n            }\r\n        } else {\r\n            for (String ra : raMap.keySet()) {\r\n                final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n                part.setMessage(ra);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        String failMsg = localStrings.getLocalString(\"list.resource.adapter.configs.fail\", \"Unable to list resource adapter configs.\");\r\n        Logger.getLogger(ListResourceAdapterConfigs.class.getName()).log(Level.SEVERE, failMsg, e);\r\n        report.setMessage(failMsg + \" \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolAppEmitterImpl.decrementConnectionUsed",
	"Comment": "fires probe event related to the fact the given connection pool hasgot a decrement connection used event.",
	"Method": "void decrementConnectionUsed(){\r\n    poolAppProbeProvider.decrementConnectionUsedEvent(poolName, appName);\r\n}"
}, {
	"Path": "com.sun.gjc.util.SQLTraceDelegator.registerSQLTraceListener",
	"Comment": "add a listener to the list of sql trace listeners maintained by this registry.",
	"Method": "void registerSQLTraceListener(SQLTraceListener listener){\r\n    if (sqlTraceListenersList == null) {\r\n        sqlTraceListenersList = new ArrayList<SQLTraceListener>();\r\n    }\r\n    sqlTraceListenersList.add(listener);\r\n}"
}, {
	"Path": "admin.GetSetTest.testSets",
	"Comment": "test a list of set requests by running asadmin set repeatedly.",
	"Method": "void testSets(String tname,List<String> reqs){\r\n    String[] nvs = new String[20];\r\n    int nvi = 1;\r\n    int cnt = 0;\r\n    nvs[0] = \"set\";\r\n    for (String line : reqs) {\r\n        if (line.trim().length() == 0)\r\n            continue;\r\n        nvs[nvi++ % nvs.length] = line;\r\n        if (nvi % nvs.length == 0) {\r\n            boolean ret = asadmin(nvs);\r\n            if (ret) {\r\n                report(tname + \"set-\" + cnt, ret);\r\n            } else {\r\n                for (int i = 1; i < nvs.length; i++) {\r\n                    report(tname + \"set-\" + cnt + \"-\" + i, asadmin(\"set\", nvs[i]));\r\n                }\r\n            }\r\n            nvi = 1;\r\n            ++cnt;\r\n        }\r\n    }\r\n    for (int i = 1; i < nvi; i++) {\r\n        report(tname + \"set-end\" + \"-\" + i, asadmin(\"set\", nvs[i]));\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.CreateJMSResource.isSyntaxValid",
	"Comment": "modified this method to support wildcards in mq destinations...",
	"Method": "boolean isSyntaxValid(String name){\r\n    if (name.startsWith(\"mq.\")) {\r\n        return false;\r\n    }\r\n    try {\r\n        CharsetEncoder asciiEncoder = Charset.forName(\"US-ASCII\").newEncoder();\r\n        if (!asciiEncoder.canEncode(name))\r\n            return false;\r\n    } catch (Exception e) {\r\n    }\r\n    char[] namechars = name.toCharArray();\r\n    if (Character.isJavaIdentifierStart(namechars[0]) || namechars[0] == '*' || namechars[0] == '>') {\r\n        for (int i = 1; i < namechars.length; i++) {\r\n            if (!Character.isJavaIdentifierPart(namechars[i]) && !(namechars[i] == '.' || namechars[i] == '*' || namechars[i] == '>')) {\r\n                return false;\r\n            }\r\n        }\r\n    } else {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.perms.PermsArchiveDelegate.processModuleDeclaredAndEEPemirssions",
	"Comment": "get the declared permissions and ee permissions, then add them to the classloader",
	"Method": "void processModuleDeclaredAndEEPemirssions(SMGlobalPolicyUtil.CommponentType type,DeploymentContext context,ClassLoader classloader){\r\n    if (System.getSecurityManager() != null) {\r\n        if (!(classloader instanceof DDPermissionsLoader))\r\n            return;\r\n        if (!(context instanceof ExtendedDeploymentContext))\r\n            return;\r\n        DDPermissionsLoader ddcl = (DDPermissionsLoader) classloader;\r\n        if (((ExtendedDeploymentContext) context).getParentContext() == null) {\r\n            PermissionCollection declPc = getDeclaredPermissions(type, context);\r\n            ddcl.addDeclaredPermissions(declPc);\r\n        }\r\n        PermissionCollection eePc = processEEPermissions(type, context);\r\n        ddcl.addEEPermissions(eePc);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.ActiveJmsResourceAdapter.updateJmsHost",
	"Comment": "updates the jmshost information in the mqaddresslist of the resource adapter.",
	"Method": "void updateJmsHost(JmsHost host){\r\n    urlList.updateMQUrl(host);\r\n    setAddressList();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.Type.isOrderable",
	"Comment": "returns whether this represents a type with andefined order.",
	"Method": "boolean isOrderable(){\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.resources.module.ResourcesDeployer.getResourceDeployer",
	"Comment": "given a resource instance, appropriate deployer will be provided",
	"Method": "ResourceDeployer getResourceDeployer(Object resource){\r\n    return resourceManagerFactoryProvider.get().getResourceDeployer(resource);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ApplicationClientDescriptor.hasRuntimeInformation",
	"Comment": "return true if there is runtime information in this object that must be saved.",
	"Method": "boolean hasRuntimeInformation(){\r\n    for (Iterator itr = this.getNamedDescriptors().iterator(); itr.hasNext(); ) {\r\n        NamedDescriptor next = (NamedDescriptor) itr.next();\r\n        if (!\"\".equals(next.getJndiName())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.resizer.AssocWithThreadPoolResizer.removeInvalidResources",
	"Comment": "removes invalid resource handles in the pool while resizing the pool.uses the connector 1.5 spec 6.5.3.4 optional ra feature to obtaininvalid managedconnections",
	"Method": "int removeInvalidResources(Set<ResourceHandle> freeConnectionsToValidate){\r\n    int invalidConnectionsCount = 0;\r\n    try {\r\n        debug(\"Sending a set of free connections to RA, \" + \"of size : \" + freeConnectionsToValidate.size());\r\n        try {\r\n            for (ResourceHandle handle : freeConnectionsToValidate) {\r\n                if (handle != null) {\r\n                    Set connectionsToTest = new HashSet();\r\n                    connectionsToTest.add(handle.getResource());\r\n                    Set invalidConnections = handler.getInvalidConnections(connectionsToTest);\r\n                    if (invalidConnections != null && invalidConnections.size() > 0) {\r\n                        invalidConnectionsCount = validateAndRemoveResource(handle, invalidConnections);\r\n                    } else {\r\n                    }\r\n                }\r\n            }\r\n        } finally {\r\n            debug(\"No. of invalid connections received from RA : \" + invalidConnectionsCount);\r\n        }\r\n    } catch (ResourceException re) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"ResourceException while trying to get invalid connections from MCF\", re);\r\n        }\r\n    } catch (Exception e) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Exception while trying to get invalid connections from MCF\", e);\r\n        }\r\n    }\r\n    return invalidConnectionsCount;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.openWith",
	"Comment": "populated from previus reading of the standard deployment descriptor",
	"Method": "Application openWith(Application app,ReadableArchive archive){\r\n    setManifest(archive.getManifest());\r\n    if (app.isVirtual()) {\r\n        T descriptor = readRestDeploymentDescriptors((T) app.getStandaloneBundleDescriptor(), archive, archive, app);\r\n        if (descriptor != null) {\r\n            postOpen(descriptor, archive);\r\n            descriptor.setApplication(app);\r\n        }\r\n    }\r\n    return app;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ForeignFieldDesc.checkReferentialIntegrityUpdatesForCollectionField",
	"Comment": "checks, if datastore updates will be scheduled locally or onthe opposite relationship side.",
	"Method": "boolean checkReferentialIntegrityUpdatesForCollectionField(){\r\n    boolean refIntegrityUpdate;\r\n    ForeignFieldDesc inverseFieldDesc = getInverseRelationshipField();\r\n    if (inverseFieldDesc == null) {\r\n        refIntegrityUpdate = defineUpdatedSideXToM();\r\n    } else {\r\n        if (inverseFieldDesc.cardinalityUPB <= 1) {\r\n            refIntegrityUpdate = false;\r\n        } else {\r\n            refIntegrityUpdate = defineUpdatedSideNToM(inverseFieldDesc);\r\n        }\r\n    }\r\n    return refIntegrityUpdate;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.AdminObjectConfigParserImpl.getAdminObjectClassNames",
	"Comment": "gets the adminobjectclassnames pertaining to a rar & a specificadminobjectinterfacename",
	"Method": "String[] getAdminObjectClassNames(ConnectorDescriptor desc,String intfName){\r\n    if (desc == null) {\r\n        throw new ConnectorRuntimeException(\"Invalid arguments\");\r\n    }\r\n    Set adminObjectSet = desc.getAdminObjects();\r\n    if (adminObjectSet == null || adminObjectSet.size() == 0) {\r\n        return null;\r\n    }\r\n    Iterator it = adminObjectSet.iterator();\r\n    AdminObject aor = null;\r\n    Set<String> adminObjectClasses = new HashSet<String>();\r\n    for (int i = 0; it.hasNext(); ++i) {\r\n        aor = (AdminObject) it.next();\r\n        String adminObjectIntfName = aor.getAdminObjectInterface();\r\n        if (adminObjectIntfName.equals(intfName)) {\r\n            adminObjectClasses.add(aor.getAdminObjectClass());\r\n        }\r\n    }\r\n    String[] adminObjectClassNames = new String[adminObjectClasses.size()];\r\n    adminObjectClassNames = adminObjectClasses.toArray(adminObjectClassNames);\r\n    return adminObjectClassNames;\r\n}"
}, {
	"Path": "org.glassfish.jdbc.admin.cli.DeleteJdbcResource.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        ResourceStatus rs = jdbcResMgr.delete(domain.getResources(), jndiName, target);\r\n        if (rs.getMessage() != null) {\r\n            report.setMessage(rs.getMessage());\r\n        }\r\n        if (rs.getStatus() == ResourceStatus.SUCCESS) {\r\n            report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n        } else {\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            if (rs.getException() != null)\r\n                report.setFailureCause(rs.getException());\r\n        }\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.jdbc.resource.fail\", \"{0} delete failed \", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.cditest.user.model.UserImpl.getGender",
	"Comment": "get the gender for the usera gender is much better suited to our needs here as the pure biologicalsex is.",
	"Method": "Gender getGender(){\r\n    return gender;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jauth.callback.PrivateKeyCallback.getRequest",
	"Comment": "get the request object which identifies the private key to be returned.",
	"Method": "Request getRequest(){\r\n    return (Request) super.getRequest();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.utility.NumericConverterFactory.getNumericConverter",
	"Comment": "this method returns an instance of numericconverter for a given policy.",
	"Method": "NumericConverter getNumericConverter(int policy){\r\n    return defaultConverter;\r\n}"
}, {
	"Path": "org.glassfish.jdbc.pool.monitor.JdbcConnPoolStatsProvider.connectionValidationFailedEvent",
	"Comment": "whenever connection leak happens, increment numconnfailedvalidation",
	"Method": "void connectionValidationFailedEvent(String poolName,String appName,String moduleName,int increment){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (logger.isLoggable(Level.FINEST)) {\r\n            logger.finest(\"Connection Validation Failed event received - \" + \"poolName = \" + poolName);\r\n        }\r\n        numConnFailedValidation.increment(increment);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ConnectorDescriptor.isSpecVersionSet",
	"Comment": "enddeployment consolidation to suppport multiple deployment api clients",
	"Method": "boolean isSpecVersionSet(){\r\n    return specVersionSet;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.authentication.EisBackendPrincipal.isEqual",
	"Comment": "checks whether two strings are equal including the null stringcases.",
	"Method": "boolean isEqual(String first,String second){\r\n    if (first == null && second == null) {\r\n        return true;\r\n    }\r\n    if (first == null || second == null) {\r\n        return false;\r\n    }\r\n    return (second.equals(first));\r\n}"
}, {
	"Path": "org.glassfish.deployapi.SunDeploymentFactory.handlesURI",
	"Comment": "tests whether this factory can create a deploymentmanagerobject based on the specificed uri.this does not indicatewhether such an attempt will be successful, only whether thefactory can handle the uri.",
	"Method": "boolean handlesURI(String uri){\r\n    if (deplLogger.isLoggable(Level.FINE)) {\r\n        deplLogger.fine(\"handlesURI: URI [\" + uri + \"]\");\r\n    }\r\n    if (uri != null) {\r\n        try {\r\n            parseURIForHostInfo(uri);\r\n            return true;\r\n        } catch (Exception ex) {\r\n            deplLogger.log(Level.SEVERE, NO_DEPLOYMENT_MANAGER, uri);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.ejb.embedded.EJBContainerImpl.isOpen",
	"Comment": "returns true if there are deployed modules associated with this container.",
	"Method": "boolean isOpen(){\r\n    return state == RUNNING;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConnectionPoolAdminServiceImpl.getConnectorConnectionPool",
	"Comment": "returns the connector connection pool object correspondingto the pool name",
	"Method": "ConnectorConnectionPool getConnectorConnectionPool(PoolInfo poolInfo,ConnectorConnectionPool getConnectorConnectionPool,PoolInfo poolInfo,Hashtable env){\r\n    String jndiNameForPool = ConnectorAdminServiceUtils.getReservePrefixedJNDINameForPool(poolInfo);\r\n    ConnectorConnectionPool connectorConnectionPool = (ConnectorConnectionPool) _runtime.getResourceNamingService().lookup(poolInfo, jndiNameForPool, env);\r\n    if (connectorConnectionPool == null) {\r\n        String i18nMsg = localStrings.getString(\"ccp_adm.null_pool\", poolInfo);\r\n        ConnectorRuntimeException cre = new ConnectorRuntimeException(i18nMsg);\r\n        _logger.log(Level.SEVERE, \"rardeployment.connectionpool_object_null\", poolInfo);\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"\", cre);\r\n        }\r\n        throw cre;\r\n    }\r\n    return connectorConnectionPool;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.getEntityManagerReferenceByName",
	"Comment": "return the entity manager factory reference descriptor corresponding tothe given name.",
	"Method": "EntityManagerReferenceDescriptor getEntityManagerReferenceByName(String name){\r\n    for (EntityManagerReferenceDescriptor next : getEntityManagerReferenceDescriptors()) {\r\n        if (next.getName().equals(name)) {\r\n            return next;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionapphasnoentitymgrrefbyname\", \"This app {0} has no entity manager reference by the name of {1}\", new Object[] { getRegistrationName(), name }));\r\n}"
}, {
	"Path": "com.sun.ejb.base.stats.StatefulSessionStoreStatsImpl.getExpiredSessionCount",
	"Comment": "returns the total number of expired sessions that were removed by this store",
	"Method": "CountStatistic getExpiredSessionCount(){\r\n    synchronized (expiredSessionCountLock) {\r\n        expiredSessionCount.setCount(expiredSessionCountVal);\r\n        return (CountStatistic) expiredSessionCount.unmodifiableView();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.MQAddressList.getResolvedJmsHostForStandaloneServerInstance",
	"Comment": "used to get resolved local jmshost for a standalone server instance",
	"Method": "JmsHost getResolvedJmsHostForStandaloneServerInstance(String serverName){\r\n    if (logger.isLoggable(Level.FINE))\r\n        logFine(\" getresolved \" + serverName);\r\n    Server serverInstance = getServerByName(serverName);\r\n    if (logger.isLoggable(Level.FINE))\r\n        logFine(\"serverinstace \" + serverInstance);\r\n    JmsHost jmsHost = getResolvedJmsHost(serverInstance);\r\n    return jmsHost;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.connection.ConnectionManager.getMinPool",
	"Comment": "gets the minimum number of pooled connections for the currentconnection manager.if this value is 0, the connection manager does not maintaina connection pool until a connection is requested using thegetconnection method with no parameters.to change the minimum number of pooled connections, use thesetminpool method.",
	"Method": "int getMinPool(){\r\n    return (this.minPool);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createElementClassComponent",
	"Comment": "create a validation component which can check whether the \trelationship is mapped to columns even though the element class is null.",
	"Method": "ValidationComponent createElementClassComponent(RelationshipElement field){\r\n    return new ValidationComponent() {\r\n        public void validate() throws ModelValidationException {\r\n            String className = getClassName();\r\n            String fieldName = field.getName();\r\n            if (isCollection(className, fieldName)) {\r\n                String elementClass = field.getElementClass();\r\n                if (StringHelper.isEmpty(elementClass)) {\r\n                    MappingClassElement mappingClass = getMappingClass(className);\r\n                    MappingFieldElement mappingElement = ((mappingClass != null) ? mappingClass.getField(fieldName) : null);\r\n                    if ((mappingElement != null) && (mappingElement.getColumns().size() > 0)) {\r\n                        throw constructFieldException(fieldName, \"util.validation.element_class_not_found\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createElementClassComponent",
	"Comment": "create a validation component which can check whether the \trelationship is mapped to columns even though the element class is null.",
	"Method": "ValidationComponent createElementClassComponent(RelationshipElement field){\r\n    String className = getClassName();\r\n    String fieldName = field.getName();\r\n    if (isCollection(className, fieldName)) {\r\n        String elementClass = field.getElementClass();\r\n        if (StringHelper.isEmpty(elementClass)) {\r\n            MappingClassElement mappingClass = getMappingClass(className);\r\n            MappingFieldElement mappingElement = ((mappingClass != null) ? mappingClass.getField(fieldName) : null);\r\n            if ((mappingElement != null) && (mappingElement.getColumns().size() > 0)) {\r\n                throw constructFieldException(fieldName, \"util.validation.element_class_not_found\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdbcra.util.SecurityUtils.getPasswordCredential",
	"Comment": "this method returns the passwordcredential object, given the managedconnectionfactory, subject and the connectionrequestinfo. it first checks if the connectionrequestinfo is null or not. if it is not null, it constructs a passwordcredential object withthe user and password fields from the connectionrequestinfo and returns thispasswordcredential object. if the connectionrequestinfo is null, it retrieves the passwordcredential objects from the subject parameter and returns the firstpasswordcredential object which contains a managedconnectionfactory, instance equivalentto the managedconnectionfactory, parameter.",
	"Method": "PasswordCredential getPasswordCredential(ManagedConnectionFactory mcf,Subject subject,javax.resource.spi.ConnectionRequestInfo info){\r\n    if (info == null) {\r\n        if (subject == null) {\r\n            return null;\r\n        } else {\r\n            PasswordCredential pc = (PasswordCredential) AccessController.doPrivileged(new PrivilegedAction() {\r\n                public Object run() {\r\n                    Set passwdCredentialSet = subject.getPrivateCredentials(PasswordCredential.class);\r\n                    Iterator iter = passwdCredentialSet.iterator();\r\n                    while (iter.hasNext()) {\r\n                        PasswordCredential temp = (PasswordCredential) iter.next();\r\n                        if (temp.getManagedConnectionFactory().equals(mcf)) {\r\n                            return temp;\r\n                        }\r\n                    }\r\n                    return null;\r\n                }\r\n            });\r\n            if (pc == null) {\r\n                throw new javax.resource.spi.SecurityException(\"No PasswordCredential found\");\r\n            } else {\r\n                return pc;\r\n            }\r\n        }\r\n    } else {\r\n        com.sun.jdbcra.spi.ConnectionRequestInfo cxReqInfo = (com.sun.jdbcra.spi.ConnectionRequestInfo) info;\r\n        PasswordCredential pc = new PasswordCredential(cxReqInfo.getUser(), cxReqInfo.getPassword().toCharArray());\r\n        pc.setManagedConnectionFactory(mcf);\r\n        return pc;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdbcra.util.SecurityUtils.getPasswordCredential",
	"Comment": "this method returns the passwordcredential object, given the managedconnectionfactory, subject and the connectionrequestinfo. it first checks if the connectionrequestinfo is null or not. if it is not null, it constructs a passwordcredential object withthe user and password fields from the connectionrequestinfo and returns thispasswordcredential object. if the connectionrequestinfo is null, it retrieves the passwordcredential objects from the subject parameter and returns the firstpasswordcredential object which contains a managedconnectionfactory, instance equivalentto the managedconnectionfactory, parameter.",
	"Method": "PasswordCredential getPasswordCredential(ManagedConnectionFactory mcf,Subject subject,javax.resource.spi.ConnectionRequestInfo info){\r\n    Set passwdCredentialSet = subject.getPrivateCredentials(PasswordCredential.class);\r\n    Iterator iter = passwdCredentialSet.iterator();\r\n    while (iter.hasNext()) {\r\n        PasswordCredential temp = (PasswordCredential) iter.next();\r\n        if (temp.getManagedConnectionFactory().equals(mcf)) {\r\n            return temp;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.getOptimistic",
	"Comment": "returns the boolean value of the optimistic flag for all persistencemanagers",
	"Method": "boolean getOptimistic(){\r\n    return optimistic;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnection.addConnectionEventListener",
	"Comment": "adds a connection event listener to the managedconnection instance.",
	"Method": "void addConnectionEventListener(ConnectionEventListener listener){\r\n    this.listener = listener;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBTimerService.getOwnerIdOfThisServer",
	"Comment": "return the ownerid of the server instance inwhich we are running.",
	"Method": "String getOwnerIdOfThisServer(){\r\n    return ownerIdOfThisServer_;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.SunContainerHelper.processContainerException",
	"Comment": "checks the caught exception, and rethrows it if it isof one of known types, or converts to an ejbexceptionotherwise.",
	"Method": "void processContainerException(Exception ex){\r\n    if (ex instanceof EJBException) {\r\n        throw (EJBException) ex;\r\n    } else if (ex instanceof IllegalArgumentException || ex instanceof IllegalStateException) {\r\n        throw (RuntimeException) ex;\r\n    } else if (ex instanceof JDOException) {\r\n        throw (JDOException) ex;\r\n    } else {\r\n        throw new EJBException(ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.EjbReferenceDescriptor.setLocal",
	"Comment": "set whether this ejb reference uses local interfaces or remote",
	"Method": "void setLocal(boolean local){\r\n    this.isLocal = local;\r\n}"
}, {
	"Path": "org.glassfish.resources.admin.cli.CreateCustomResource.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    HashMap attrList = new HashMap();\r\n    attrList.put(\"factory-class\", factoryClass);\r\n    attrList.put(\"res-type\", resType);\r\n    attrList.put(ResourceConstants.ENABLED, enabled.toString());\r\n    attrList.put(JNDI_NAME, jndiName);\r\n    attrList.put(ServerTags.DESCRIPTION, description);\r\n    ResourceStatus rs;\r\n    try {\r\n        rs = customResMgr.create(domain.getResources(), attrList, properties, target);\r\n    } catch (Exception e) {\r\n        Logger.getLogger(CreateCustomResource.class.getName()).log(Level.SEVERE, \"Unable to create custom resource \" + jndiName, e);\r\n        String def = \"Custom resource: {0} could not be created, reason: {1}\";\r\n        report.setMessage(localStrings.getLocalString(\"create.custom.resource.fail\", def, jndiName) + \" \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    ActionReport.ExitCode ec = ActionReport.ExitCode.SUCCESS;\r\n    if (rs.getStatus() == ResourceStatus.FAILURE) {\r\n        ec = ActionReport.ExitCode.FAILURE;\r\n        if (rs.getMessage() == null) {\r\n            report.setMessage(localStrings.getLocalString(\"create.custom.resource.fail\", \"Custom resource {0} creation failed\", jndiName, \"\"));\r\n        }\r\n        if (rs.getException() != null)\r\n            report.setFailureCause(rs.getException());\r\n    }\r\n    if (rs.getMessage() != null) {\r\n        report.setMessage(rs.getMessage());\r\n    }\r\n    report.setActionExitCode(ec);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.ParameterSupport.getParameterType",
	"Comment": "returns the type of the ejbql parameter by number. note, the numbering of ejbql parameters starts with 1, so the method expects 1 as the number of the first parameter.",
	"Method": "Class getParameterType(String ejbqlParamDecl,Class getParameterType,int paramNumber){\r\n    return parameterTypes[paramNumber - 1];\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.Descriptor.reverseArgSig",
	"Comment": "given a stringbuffer, a method descriptor, and a index to the start of an argument descriptor, append the arguments to thestring buffer in reverse order.",
	"Method": "void reverseArgSig(StringBuffer buf,String methodSig,int idx){\r\n    char c = methodSig.charAt(idx);\r\n    if (c == ')')\r\n        return;\r\n    int startIdx = idx;\r\n    switch(c) {\r\n        case 'B':\r\n        case 'C':\r\n        case 'S':\r\n        case 'I':\r\n        case 'F':\r\n        case 'J':\r\n        case 'D':\r\n        case 'Z':\r\n            idx = idx + 1;\r\n            break;\r\n        case '[':\r\n            while (methodSig.charAt(idx) == '[' || methodSig.charAt(idx) == ']') idx++;\r\n            if (methodSig.charAt(idx) != 'L') {\r\n                idx++;\r\n                break;\r\n            }\r\n        case 'L':\r\n            idx = methodSig.indexOf(';', idx) + 1;\r\n            break;\r\n        default:\r\n            throw new InsnError(\"bad signature char\");\r\n    }\r\n    reverseArgSig(buf, methodSig, idx);\r\n    while (startIdx < idx) buf.append(methodSig.charAt(startIdx++));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.Statement.processConstraints",
	"Comment": "processes the constraint stack and adds it to the query.this means turning the constraint stack into sql text andadding it to the where clause.",
	"Method": "StringBuffer processConstraints(){\r\n    StringBuffer whereText = new StringBuffer();\r\n    List stack = constraint.getConstraints();\r\n    while (stack.size() > 0) {\r\n        ConstraintNode node = (ConstraintNode) stack.get(stack.size() - 1);\r\n        if (!(node instanceof ConstraintOperation)) {\r\n            throw new JDOFatalInternalException(// NOI18N\r\n            I18NHelper.getMessage(messages, // NOI18N\r\n            \"core.generic.notinstanceof\", node.getClass().getName(), \"ConstraintOperation\"));\r\n        }\r\n        processRootConstraint((ConstraintOperation) node, stack, whereText);\r\n    }\r\n    return whereText;\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.AppClientContainerTest.testNewContainer",
	"Comment": "test of newcontainer method, of class appclientcontainer.",
	"Method": "void testNewContainer(){\r\n    System.out.println(\"newContainer\");\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.CMPBeanHelper.assertCollectionNotNull",
	"Comment": "called from a cmp bean to verify that the argument fora collection set method is not null. throws illegalargumentexception if the argument is null.",
	"Method": "void assertCollectionNotNull(Collection c,String beanName){\r\n    if (c == null) {\r\n        String msg = // NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        cmpMessages, // NOI18N\r\n        \"GEN.cmrsettercol_nullexception\", beanName, findCallingMethodName());\r\n        cmpInternalLogger.log(Logger.SEVERE, msg);\r\n        throw new IllegalArgumentException(msg);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.DeploymentDescriptorNode.addNamespaceDeclaration",
	"Comment": "any node can now declare its own namespace. this apply to dds onlywhen dealing with deployment extensions. write any declared namespace declaration",
	"Method": "void addNamespaceDeclaration(Element node,Descriptor descriptor){\r\n    Map<String, String> prefixMapping = (descriptor != null) ? descriptor.getPrefixMapping() : null;\r\n    if (prefixMapping != null) {\r\n        Set<Map.Entry<String, String>> entrySet = prefixMapping.entrySet();\r\n        Iterator<Map.Entry<String, String>> entryIt = entrySet.iterator();\r\n        while (entryIt.hasNext()) {\r\n            Map.Entry<String, String> entry = entryIt.next();\r\n            String prefix = entry.getKey();\r\n            String namespaceURI = entry.getValue();\r\n            setAttributeNS(node, prefix, namespaceURI);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.connector.blackbox.LocalTxManagedConnectionFactory.validateConfigProperties",
	"Comment": "check whether the config properties booleanwithisbooleanaccessorand booleanwithgetbooleanaccessor are set to true",
	"Method": "void validateConfigProperties(){\r\n    if (!getBooleanWithGetBooleanAccessor()) {\r\n        throw new ResourceException(\"Blackbox RAR : Get Boolean Accessor is false\");\r\n    }\r\n    if (!isBooleanWithIsBooleanAccessor()) {\r\n        throw new ResourceException(\"Blackbox RAR : Is Boolean Accessor is false\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.ArrayList.remove",
	"Comment": "removes the first occurrence of the specified element in this arraylistif the arraylist does not contain the element, it is unchanged.",
	"Method": "boolean remove(Object o,Object remove,int index){\r\n    throwUnsupportedOption();\r\n    StateManager stateManager = this.makeDirty();\r\n    Object obj = super.remove(index);\r\n    if (added.remove(obj) == false)\r\n        removed.add(obj);\r\n    this.applyUpdates(stateManager, true);\r\n    return obj;\r\n}"
}, {
	"Path": "org.glassfish.deployment.client.AbstractDeploymentFacility.changeState",
	"Comment": "changes the state of an application.used for enable and disable.",
	"Method": "DFProgressObject changeState(Target[] targets,String moduleID,String commandName,String action){\r\n    ensureConnected();\r\n    targets = prepareTargets(targets);\r\n    ProgressObjectImpl po = new ProgressObjectImpl(targets);\r\n    if (commandName.equals(\"enable\")) {\r\n        po.setCommand(CommandType.START, null);\r\n    } else if (commandName.equals(\"disable\")) {\r\n        po.setCommand(CommandType.STOP, null);\r\n    }\r\n    List<TargetModuleIDImpl> targetModuleIDList = new ArrayList<TargetModuleIDImpl>();\r\n    try {\r\n        for (Target target : targets) {\r\n            Map commandParams = new HashMap();\r\n            commandParams.put(DFDeploymentProperties.TARGET, target.getName());\r\n            DFCommandRunner commandRunner = getDFCommandRunner(commandName, commandParams, new String[] { moduleID });\r\n            DFDeploymentStatus ds = commandRunner.run();\r\n            DFDeploymentStatus mainStatus = ds.getMainStatus();\r\n            if (!po.checkStatusAndAddStage((TargetImpl) target, localStrings.getLocalString(\"enterprise.deployment.client.change_state\", \"{0} of {1} in target {2}\", action, moduleID, target.getName()), mainStatus)) {\r\n                return po;\r\n            } else {\r\n                TargetModuleIDImpl targetModuleID = new TargetModuleIDImpl((TargetImpl) target, moduleID);\r\n                targetModuleIDList.add(targetModuleID);\r\n            }\r\n        }\r\n        TargetModuleIDImpl[] targetModuleIDs = new TargetModuleIDImpl[targetModuleIDList.size()];\r\n        targetModuleIDs = (TargetModuleIDImpl[]) targetModuleIDList.toArray(targetModuleIDs);\r\n        po.setupForNormalExit(localStrings.getLocalString(\"enterprise.deployment.client.change_state_all\", \"{0} of application in all targets\", action), (TargetImpl) targets[0], targetModuleIDs);\r\n        return po;\r\n    } catch (Throwable ioex) {\r\n        po.setupForAbnormalExit(localStrings.getLocalString(\"enterprise.deployment.client.state_change_failed\", \"Attempt to change the state of the application {0} failed - {1}\", moduleID, ioex.toString()), (TargetImpl) targets[0]);\r\n        return po;\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.util.SQLTraceCache.cancelTimerTask",
	"Comment": "cancel the timer task used to perform a purgeentries on the cache.",
	"Method": "void cancelTimerTask(){\r\n    if (_logger.isLoggable(Level.FINEST)) {\r\n        _logger.finest(\"Cancelling Sql Trace Caching timer task\");\r\n    }\r\n    if (sqlTraceTimerTask != null) {\r\n        sqlTraceTimerTask.cancel();\r\n    }\r\n    sqlTraceTimerTask = null;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsGroupBy",
	"Comment": "retrieves whether this database supports some form ofgroup by clause.",
	"Method": "boolean supportsGroupBy(){\r\n    return databaseMetaData.supportsGroupBy();\r\n}"
}, {
	"Path": "org.glassfish.apf.factory.Factory.isSkipAnnotationProcessing",
	"Comment": "check whether a certain class can skip annotation processing",
	"Method": "boolean isSkipAnnotationProcessing(String cName){\r\n    if (skipAnnotationClassList == null) {\r\n        initSkipAnnotationClassList();\r\n    }\r\n    return skipAnnotationClassList.contains(cName);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.FloatingPointType.getValue",
	"Comment": "converts the specified value into a value of this numeric type.e.g. an integer is converted into a double, if this represents the numeric type double.",
	"Method": "Number getValue(Number value){\r\n    Number ret = null;\r\n    if (value == null)\r\n        ret = null;\r\n    else if (\"double\".equals(getName()))\r\n        ret = new Double(value.doubleValue());\r\n    else if (\"float\".equals(getName()))\r\n        ret = new Float(value.floatValue());\r\n    return ret;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createTableExistenceComponent",
	"Comment": "create a validation component which can check whether the given table \texists.",
	"Method": "ValidationComponent createTableExistenceComponent(String tableName,ValidationComponent createTableExistenceComponent,String tableName,PersistenceFieldElement relatedField){\r\n    return new ValidationComponent() {\r\n        public void validate() throws ModelValidationException {\r\n            if (tableName != null) {\r\n                String className = getClassName();\r\n                boolean noRelated = (relatedField == null);\r\n                TableElement table = getTable(tableName, getSchemaForClass((noRelated ? className : getRelatedClass(relatedField))));\r\n                if (table == null) {\r\n                    Object[] args = noRelated ? new Object[] { tableName, className } : new Object[] { tableName, relatedField };\r\n                    throw new ModelValidationException(ModelValidationException.WARNING, getOffendingObject(relatedField), I18NHelper.getMessage(getMessages(), getKey(\"util.validation.table_not_found\", relatedField), args));\r\n                }\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createTableExistenceComponent",
	"Comment": "create a validation component which can check whether the given table \texists.",
	"Method": "ValidationComponent createTableExistenceComponent(String tableName,ValidationComponent createTableExistenceComponent,String tableName,PersistenceFieldElement relatedField){\r\n    if (tableName != null) {\r\n        String className = getClassName();\r\n        boolean noRelated = (relatedField == null);\r\n        TableElement table = getTable(tableName, getSchemaForClass((noRelated ? className : getRelatedClass(relatedField))));\r\n        if (table == null) {\r\n            Object[] args = noRelated ? new Object[] { tableName, className } : new Object[] { tableName, relatedField };\r\n            throw new ModelValidationException(ModelValidationException.WARNING, getOffendingObject(relatedField), I18NHelper.getMessage(getMessages(), getKey(\"util.validation.table_not_found\", relatedField), args));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.DeploymentDescriptorNode.addNodeDescriptor",
	"Comment": "adds a new dol descriptor instance to the descriptor associated with this xmlnode",
	"Method": "void addNodeDescriptor(DeploymentDescriptorNode node){\r\n    if (getDescriptor() == null) {\r\n        addDescriptor(node.getDescriptor());\r\n        return;\r\n    }\r\n    String xmlRootTag = node.getXMLRootTag().getQName();\r\n    if (addMethods != null && addMethods.containsKey(xmlRootTag)) {\r\n        try {\r\n            Method toInvoke = null;\r\n            if ((node.getDescriptor() instanceof ResourceDescriptor) && ((ResourceDescriptor) node.getDescriptor()).getResourceType() != null) {\r\n                toInvoke = getDescriptor().getClass().getMethod((String) addMethods.get(xmlRootTag), new Class[] { ResourceDescriptor.class });\r\n            } else {\r\n                toInvoke = getDescriptor().getClass().getMethod((String) addMethods.get(xmlRootTag), new Class[] { node.getDescriptor().getClass() });\r\n            }\r\n            toInvoke.invoke(getDescriptor(), new Object[] { node.getDescriptor() });\r\n        } catch (InvocationTargetException e) {\r\n            Throwable t = e.getTargetException();\r\n            if (t instanceof IllegalArgumentException) {\r\n                DOLUtils.getDefaultLogger().log(Level.SEVERE, \"enterprise.deployment.backend.addDescriptorFailure\", new Object[] { node.getDescriptor().getClass(), getDescriptor().getClass() });\r\n            } else {\r\n                DOLUtils.getDefaultLogger().log(Level.WARNING, \"Error occurred\", t);\r\n                DOLUtils.getDefaultLogger().log(Level.SEVERE, \"enterprise.deployment.backend.addDescriptorFailure\", new Object[] { t.toString(), null });\r\n            }\r\n        } catch (Throwable t) {\r\n            DOLUtils.getDefaultLogger().log(Level.SEVERE, \"enterprise.deployment.backend.addDescriptorFailure\", new Object[] { node.getDescriptor().getClass(), getDescriptor().getClass() });\r\n            DOLUtils.getDefaultLogger().log(Level.SEVERE, \"enterprise.deployment.backend.addDescriptorFailure\", new Object[] { t.toString(), null });\r\n            DOLUtils.getDefaultLogger().log(Level.WARNING, \"Error occurred\", t);\r\n        }\r\n    } else {\r\n        addDescriptor(node.getDescriptor());\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.MethodAnnotater.minimizeStack",
	"Comment": "assume that after the execution of state.insn there is a word onthe stack which is state.argdepth words deep.scan backwards through the instruction sequence, attempting tolocate an instruction after which the argument is at a minimaldepth w.r.t. the top of stack.update the state to indicateprogress.note that this method will not look back past a target.",
	"Method": "void minimizeStack(StackState state){\r\n    Insn i = state.insn;\r\n    int argDepth = state.argDepth;\r\n    Stack argTypesStack = new Stack();\r\n    Stack resultTypesStack = new Stack();\r\n    Stack stackTypes = new Stack();\r\n    copyStack(state.stackTypes, stackTypes);\r\n    for (; argDepth > 0; i = i.prev()) {\r\n        if (i.branches() || ((i instanceof InsnTarget) && ((InsnTarget) i).isBranchTarget()))\r\n            break;\r\n        int nArgs = i.nStackArgs();\r\n        int nResults = i.nStackResults();\r\n        String argTypes = i.argTypes();\r\n        String resultTypes = i.resultTypes();\r\n        argDepth -= nResults;\r\n        if (argDepth < 0)\r\n            break;\r\n        argDepth += nArgs;\r\n        if (i.opcode() == opc_swap) {\r\n            Object x = stackTypes.pop();\r\n            Object y = stackTypes.pop();\r\n            stackTypes.push(x);\r\n            stackTypes.push(y);\r\n        } else {\r\n            while (!argTypesStack.empty()) argTypesStack.pop();\r\n            while (!resultTypesStack.empty()) resultTypesStack.pop();\r\n            Descriptor.computeStackTypes(argTypes, argTypesStack);\r\n            Descriptor.computeStackTypes(resultTypes, resultTypesStack);\r\n            int expectWords = 0;\r\n            while (!resultTypesStack.empty()) expectWords += Descriptor.elementSize(((Integer) resultTypesStack.pop()).intValue());\r\n            while (expectWords > 0) expectWords -= Descriptor.elementSize(((Integer) stackTypes.pop()).intValue());\r\n            if (expectWords < 0) {\r\n                return;\r\n            }\r\n            transferStackArgs(argTypesStack, stackTypes);\r\n        }\r\n        if (argDepth >= 0 && argDepth < state.argDepth && knownTypes(stackTypes, argDepth)) {\r\n            state.argDepth = argDepth;\r\n            state.insn = i.prev();\r\n            copyStack(stackTypes, state.stackTypes);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.ConnectionExecutionContext.setContext",
	"Comment": "this method can be used to add a new hashtable for storing the thread specific context information. this method is useful to add a deserialized context information that arrived over the wire.",
	"Method": "void setContext(Hashtable ctxTable){\r\n    if (ctxTable != null) {\r\n        connCurrent.set(ctxTable);\r\n    } else {\r\n        connCurrent.set(new Hashtable());\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.concurrent.admin.CreateManagedExecutorService.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    HashMap attrList = new HashMap();\r\n    setAttributeList(attrList);\r\n    ResourceStatus rs;\r\n    try {\r\n        rs = managedExecutorServiceMgr.create(domain.getResources(), attrList, properties, target);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"create.managed.executor.service.failed\", \"Managed executor service {0} creation failed\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    ActionReport.ExitCode ec = ActionReport.ExitCode.SUCCESS;\r\n    if (rs.getMessage() != null) {\r\n        report.setMessage(rs.getMessage());\r\n    }\r\n    if (rs.getStatus() == ResourceStatus.FAILURE) {\r\n        ec = ActionReport.ExitCode.FAILURE;\r\n        if (rs.getException() != null)\r\n            report.setFailureCause(rs.getException());\r\n    }\r\n    report.setActionExitCode(ec);\r\n}"
}, {
	"Path": "org.glassfish.deployapi.SunDeploymentManager.getArchive",
	"Comment": "creates a new instance of archive which can be used to store application elements in a layout that can be directly used by the application server. implementation of this method should carefullyreturn the appropriate implementation of the interface that suits the server needs and provide the fastest deployment time.an archive may already exist at the location and elements may be read but not changed or added depending on the underlying medium.",
	"Method": "Archive getArchive(URI path,String name){\r\n    if (path == null) {\r\n        File root = File.createTempFile(name, \".jar\");\r\n        path = root.toURI();\r\n    }\r\n    ArchiveFactory factory = getArchiveFactory();\r\n    boolean exists = false;\r\n    if ((path.getScheme().equals(\"file\")) || (path.getScheme().equals(\"jar\"))) {\r\n        File target = new File(path);\r\n        exists = target.exists();\r\n    } else {\r\n        return null;\r\n    }\r\n    if (exists) {\r\n        return factory.openArchive(path);\r\n    } else {\r\n        return factory.createArchive(path);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getEjbReference",
	"Comment": "return a reference to another ejb by the same name or throw anillegalargumentexception.",
	"Method": "EjbReference getEjbReference(String name){\r\n    for (Iterator itr = getEjbReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        EjbReference er = (EjbReference) itr.next();\r\n        if (er.getName().equals(name)) {\r\n            return er;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionbeanhasnoejbrefbyname\", \"This bean {0} has no ejb reference by the name of {1}\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.JDOQLElements.isPCResult",
	"Comment": "returns whether the result of the jdoql query is a collection of pcinstances or not.",
	"Method": "boolean isPCResult(){\r\n    return isPCResult;\r\n}"
}, {
	"Path": "org.glassfish.ejb.security.application.EJBSecurityManager.authorize",
	"Comment": "this method is called by the ejb container to decide whether or nota method specified in the invocation should be allowed.",
	"Method": "boolean authorize(ComponentInvocation compInv){\r\n    if (!(compInv instanceof EjbInvocation)) {\r\n        return false;\r\n    }\r\n    EjbInvocation inv = (EjbInvocation) compInv;\r\n    if (inv.getAuth() != null) {\r\n        return inv.getAuth().booleanValue();\r\n    }\r\n    boolean ret = false;\r\n    CachedPermission cp = null;\r\n    Permission ejbmp = null;\r\n    if (inv.invocationInfo == null || inv.invocationInfo.cachedPermission == null) {\r\n        ejbmp = new EJBMethodPermission(ejbName, inv.getMethodInterface(), inv.method);\r\n        cp = new CachedPermissionImpl(uncheckedMethodPermissionCache, ejbmp);\r\n        if (inv.invocationInfo != null) {\r\n            inv.invocationInfo.cachedPermission = cp;\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.fine(\"JACC: permission initialized in InvocationInfo: EJBMethodPermission (Name) = \" + ejbmp.getName() + \" (Action) = \" + ejbmp.getActions());\r\n            }\r\n        }\r\n    } else {\r\n        cp = inv.invocationInfo.cachedPermission;\r\n        ejbmp = cp.getPermission();\r\n    }\r\n    String caller = null;\r\n    SecurityContext sc = null;\r\n    pcHandlerImpl.getHandlerData().setInvocation(inv);\r\n    ret = cp.checkPermission();\r\n    if (!ret) {\r\n        sc = SecurityContext.getCurrent();\r\n        Set principalSet = sc.getPrincipalSet();\r\n        ProtectionDomain prdm = getCachedProtectionDomain(principalSet, true);\r\n        try {\r\n            String oldContextId = setPolicyContext(this.contextId);\r\n            try {\r\n                ret = policy.implies(prdm, ejbmp);\r\n            } catch (SecurityException se) {\r\n                _logger.log(Level.SEVERE, \"jacc_access_exception\", se);\r\n                ret = false;\r\n            } catch (Throwable t) {\r\n                _logger.log(Level.SEVERE, \"jacc_access_exception\", t);\r\n                ret = false;\r\n            } finally {\r\n                resetPolicyContext(oldContextId, this.contextId);\r\n            }\r\n        } catch (Throwable t) {\r\n            _logger.log(Level.SEVERE, \"jacc_policy_context_exception\", t);\r\n            ret = false;\r\n        }\r\n    }\r\n    inv.setAuth((ret) ? Boolean.TRUE : Boolean.FALSE);\r\n    if (auditManager.isAuditOn()) {\r\n        if (sc == null) {\r\n            sc = SecurityContext.getCurrent();\r\n        }\r\n        caller = sc.getCallerPrincipal().getName();\r\n        auditManager.ejbInvocation(caller, ejbName, inv.method.toString(), ret);\r\n    }\r\n    if (ret && inv.isWebService && !inv.isPreInvokeDone()) {\r\n        preInvoke(inv);\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"JACC: Access Control Decision Result: \" + ret + \" EJBMethodPermission (Name) = \" + ejbmp.getName() + \" (Action) = \" + ejbmp.getActions() + \" (Caller) = \" + caller);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorAdminServicesFactory.getService",
	"Comment": "returns a specific connector admin service implemntation class basedon the type of service.",
	"Method": "ConnectorService getService(String type){\r\n    if (type == null) {\r\n        return null;\r\n    }\r\n    if (type.equals(ConnectorConstants.CCP)) {\r\n        return new ConnectorConnectionPoolAdminServiceImpl();\r\n    } else if (type.equals(ConnectorConstants.CR)) {\r\n        return new ConnectorResourceAdminServiceImpl();\r\n    } else if (type.equals(ConnectorConstants.RA)) {\r\n        return new ResourceAdapterAdminServiceImpl();\r\n    } else if (type.equals(ConnectorConstants.SEC)) {\r\n        return new ConnectorSecurityAdminServiceImpl();\r\n    } else if (type.equals(ConnectorConstants.AOR)) {\r\n        return new ConnectorAdminObjectAdminServiceImpl();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.DBStatement.executeBatch",
	"Comment": "delegates the executebatch call to the preparedstatement wrapped bythis dbstatement and resets the batch counter.",
	"Method": "int[] executeBatch(){\r\n    if (logger.isLoggable(Logger.FINER)) {\r\n        // NOI18N\r\n        logger.finer(\"sqlstore.sql.generator.dbstatement.executebatch\", new Integer(batchCounter));\r\n    }\r\n    batchCounter = 0;\r\n    return preparedStmt.executeBatch();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createRelatedSchemaMatchesComponent",
	"Comment": "create a validation component which can check whether the schema of \tthe related class matches that of the class we are checking.",
	"Method": "ValidationComponent createRelatedSchemaMatchesComponent(String relatedClass,PersistenceFieldElement relatedField){\r\n    return new ValidationComponent() {\r\n        public void validate() throws ModelValidationException {\r\n            if (relatedClass != null) {\r\n                String className = getClassName();\r\n                String mySchema = getSchemaForClass(className);\r\n                String relatedSchema = getSchemaForClass(relatedClass);\r\n                if ((mySchema != null) && (relatedSchema != null) && !(relatedSchema.equals(mySchema))) {\r\n                    String fieldName = relatedField.getName();\r\n                    throw new ModelValidationException(getModel().getField(className, fieldName), I18NHelper.getMessage(getMessages(), \"util.validation.schema_mismatch\", new Object[] { className, relatedClass, fieldName }));\r\n                }\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createRelatedSchemaMatchesComponent",
	"Comment": "create a validation component which can check whether the schema of \tthe related class matches that of the class we are checking.",
	"Method": "ValidationComponent createRelatedSchemaMatchesComponent(String relatedClass,PersistenceFieldElement relatedField){\r\n    if (relatedClass != null) {\r\n        String className = getClassName();\r\n        String mySchema = getSchemaForClass(className);\r\n        String relatedSchema = getSchemaForClass(relatedClass);\r\n        if ((mySchema != null) && (relatedSchema != null) && !(relatedSchema.equals(mySchema))) {\r\n            String fieldName = relatedField.getName();\r\n            throw new ModelValidationException(getModel().getField(className, fieldName), I18NHelper.getMessage(getMessages(), \"util.validation.schema_mismatch\", new Object[] { className, relatedClass, fieldName }));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.NameMapper.getEjbNameForRemoteInterface",
	"Comment": "gets the name of the ejb which corresponds to the specified \tremote interface name.",
	"Method": "String getEjbNameForRemoteInterface(String ejbName,String fieldName,String interfaceName){\r\n    EjbCMPEntityDescriptor descriptor = getRelatedEjbDescriptor(ejbName, fieldName);\r\n    return (((descriptor != null) && !StringHelper.isEmpty(interfaceName) && interfaceName.equals(descriptor.getRemoteClassName())) ? descriptor.getName() : null);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.connection.ConnectionImpl.internalRollback",
	"Comment": "used by transactionimpl to rollback the transaction on thisconnection.also disassociates this connection from thetransaction.",
	"Method": "void internalRollback(){\r\n    logger.finest(\"sqlstore.connectionimpl.internalrollback\");\r\n    try {\r\n        this.connection.rollback();\r\n    } catch (Exception e1) {\r\n    } finally {\r\n        this.clearXact();\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.PreparedStatementWrapper40.setPoolable",
	"Comment": "requests that a statement be pooled or not pooled.the valuespecified is a hint to the statement pool implementation indicatingwhether the applicaiton wants the statement to be pooled.it is up tothe statement pool manager as to whether the hint is used.the poolable value of a statement is applicable to both internalstatement caches implemented by the driver and external statement cachesimplemented by application servers and other applications.by default, a statement is not poolable when created, anda preparedstatement and callablestatementare poolable when created.",
	"Method": "void setPoolable(boolean poolable){\r\n    preparedStatement.setPoolable(poolable);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.getInputStreamForResource",
	"Comment": "returns the input stream with the supplied resource name found with\tthe supplied class name.",
	"Method": "BufferedInputStream getInputStreamForResource(String className,ClassLoader classLoader,String resourceName){\r\n    debug(\"getInputStreamForResource(\" + className + \",\" + resourceName + \")\");\r\n    InputStream is = (classLoader != null) ? classLoader.getResourceAsStream(resourceName) : ClassLoader.getSystemResourceAsStream(resourceName);\r\n    BufferedInputStream rc = null;\r\n    if (is != null && !(is instanceof BufferedInputStream)) {\r\n        rc = new BufferedInputStream(is);\r\n    } else {\r\n        rc = (BufferedInputStream) is;\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MessageDestinationReferenceDescriptor.getReferringBundleDescriptor",
	"Comment": "get the referring bundle, i.e. the bundle within which thismessage destination reference is declared.",
	"Method": "BundleDescriptor getReferringBundleDescriptor(){\r\n    return referringBundle;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.storesMixedCaseIdentifiers",
	"Comment": "retrieves whether this database treats mixed case unquoted sql identifiers ascase insensitive and stores them in mixed case.",
	"Method": "boolean storesMixedCaseIdentifiers(){\r\n    return databaseMetaData.storesMixedCaseIdentifiers();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxSchemaNameLength",
	"Comment": "retrieves the maximum number of characters that this database allows in aschema name.",
	"Method": "int getMaxSchemaNameLength(){\r\n    return databaseMetaData.getMaxSchemaNameLength();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ActiveOutboundResourceAdapter.setup",
	"Comment": "does the necessary initial setup. creates the default pool andresource.",
	"Method": "void setup(){\r\n    if (connectionDefs_ == null || connectionDefs_.length == 0) {\r\n        return;\r\n    }\r\n    if (isServer() && !isSystemRar(moduleName_)) {\r\n        createAllConnectorResources();\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"Completed Active Resource adapter setup\", moduleName_);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsPositionedDelete",
	"Comment": "retrieves whether this database supports positioned deletestatements.",
	"Method": "boolean supportsPositionedDelete(){\r\n    return databaseMetaData.supportsPositionedDelete();\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.stats.TimeStatisticImpl.getMinTime",
	"Comment": "returns the minimum amount of time that it took for one invocation of anoperation, since measurement started.",
	"Method": "long getMinTime(){\r\n    return minTime;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.ResultDesc.findOrCreateStateManager",
	"Comment": "returns a statemanager which pc instance to be populated with the values.if such instance exists in this persistencemanager cache,it is returned, otherwise a new instance is created.",
	"Method": "StateManager findOrCreateStateManager(ResultSet resultData,PersistenceManager pm){\r\n    try {\r\n        Class oidClass = config.getOidClass();\r\n        Object oid = oidClass.newInstance();\r\n        Field[] keyFields = config.getKeyFields();\r\n        String[] keyNames = config.getKeyFieldNames();\r\n        for (int i = 0; i < keyFields.length; i++) {\r\n            Field keyField = keyFields[i];\r\n            String keyName = keyNames[i];\r\n            FieldDesc fd = config.getField(keyName);\r\n            int index = fieldNames.indexOf(keyName);\r\n            ResultFieldDesc rfd = (ResultFieldDesc) fields.get(index);\r\n            Object v = getConvertedObject(resultData, rfd.getColumnRef(), fd, null);\r\n            if (debug) {\r\n                logger.finest(\"sqlstore.resultdesc.marking_key_field\", keyName);\r\n            }\r\n            if (v == null) {\r\n                return null;\r\n            }\r\n            keyField.set(oid, v);\r\n        }\r\n        return pm.findOrCreateStateManager(oid, config.getPersistenceCapableClass());\r\n    } catch (Exception e) {\r\n        throw new JDOFatalInternalException(e.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.javaee.full.deployment.EarHandler.initCompositeMetaData",
	"Comment": "do any necessary meta data initialization for composite handler",
	"Method": "void initCompositeMetaData(DeploymentContext context){\r\n    getApplicationHolder(context.getSource(), context, true);\r\n}"
}, {
	"Path": "org.glassfish.ejb.embedded.EJBContainerProviderImpl.getBooleanProperty",
	"Comment": "returns boolean value whether the original type is string or boolean",
	"Method": "boolean getBooleanProperty(Map<?, ?> properties,String key){\r\n    boolean result = false;\r\n    if (properties != null) {\r\n        Object value = properties.get(key);\r\n        if (value != null) {\r\n            if (value instanceof String) {\r\n                result = Boolean.valueOf((String) value);\r\n            } else {\r\n                try {\r\n                    result = (Boolean) value;\r\n                } catch (Exception e) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.pam.PamRealm.getPamService",
	"Comment": "this method retreives the pam service stack to be used by the realm classand login module uniformly",
	"Method": "String getPamService(){\r\n    return PAM_SERVICE;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxColumnsInGroupBy",
	"Comment": "retrieves the maximum number of columns this database allows in agroup by clause.",
	"Method": "int getMaxColumnsInGroupBy(){\r\n    return databaseMetaData.getMaxColumnsInGroupBy();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ConnectionHolder40.getClientInfo",
	"Comment": "returns a list containing the name and current value of each client infoproperty supported by the driver.the value of a client info propertymay be null if the property has not been set and does not have adefault value.",
	"Method": "String getClientInfo(String name,Properties getClientInfo){\r\n    checkValidity();\r\n    return con.getClientInfo();\r\n}"
}, {
	"Path": "com.sun.enterprise.naming.impl.SerialContext.lookup",
	"Comment": "lookup the specifed name in the context. returns the resolved object.",
	"Method": "Object lookup(String name,Object lookup,String name,int level,Object lookup,Name name){\r\n    return lookup(name.toString());\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.support.JDOException.getNestedException",
	"Comment": "the exception may have been caused by an exception in the runtime.",
	"Method": "Exception getNestedException(){\r\n    return nested;\r\n}"
}, {
	"Path": "org.glassfish.persistence.ejb.entitybean.container.EntityContainer.removeIncompleteTxEJB",
	"Comment": "called from releasecontext if ejb is removed, from aftercompletion,and from passivateejb.",
	"Method": "void removeIncompleteTxEJB(EntityContextImpl context,boolean updateTxBeanTable){\r\n    JavaEETransaction current = (JavaEETransaction) context.getTransaction();\r\n    if (current == null) {\r\n        return;\r\n    }\r\n    if ((containerStateManager.isNullEJBObject(context)) && (containerStateManager.isNullEJBLocalObject(context))) {\r\n        return;\r\n    }\r\n    ActiveTxCache activeTxCache = (ActiveTxCache) ejbContainerUtilImpl.getActiveTxCache(current);\r\n    if (activeTxCache != null) {\r\n        activeTxCache.remove(this, context.getPrimaryKey());\r\n    }\r\n    if (updateTxBeanTable) {\r\n        Vector beans = ejbContainerUtilImpl.getBeans(current);\r\n        beans.remove(context);\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.BaseContainer.getInvocationInfo",
	"Comment": "encapsulate logic used to map invocation method to invocation info.at present, we have two different maps, one for webservice invocationinfo and one for everything else.that might change in the future.",
	"Method": "InvocationInfo getInvocationInfo(EjbInvocation inv){\r\n    return inv.isWebService ? (InvocationInfo) webServiceInvocationInfoMap.get(inv.method) : (InvocationInfo) invocationInfoMap.get(inv.method);\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.database.DBVendorTypeHelper.initializeNameToVendorType",
	"Comment": "allocate and initialize nametovendortype if not already done.",
	"Method": "Properties initializeNameToVendorType(){\r\n    synchronized (DBVendorTypeHelper.class) {\r\n        if (_nameToVendorType == null) {\r\n            _nameToVendorType = new Properties();\r\n            String resourceName = System.getProperty(VENDOR_NAME_TO_TYPE_RESOURCE_PROPERTY, VENDOR_NAME_TO_TYPE_RESOURCE_DEFAULT_NAME);\r\n            try {\r\n                PropertyHelper.loadFromResource(_nameToVendorType, resourceName, DBVendorTypeHelper.class.getClassLoader());\r\n            } catch (IOException e) {\r\n                if (logger.isLoggable(Level.FINE)) {\r\n                    logger.log(Level.FINE, I18NHelper.getMessage(messages, \"database.DBVendorTypeHelper.couldNotLoadResource\", resourceName), e);\r\n                }\r\n            }\r\n            overrideWithSystemProperties(_nameToVendorType);\r\n        }\r\n    }\r\n    return _nameToVendorType;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.StatementWrapper40.isClosed",
	"Comment": "retrieves whether this statement object has been closed. a statement is closed if themethod close has been called on it, or if it is automatically closed.",
	"Method": "boolean isClosed(){\r\n    return jdbcStatement.isClosed();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsExpressionsInOrderBy",
	"Comment": "retrieves whether this database supports expressions inorder by lists.",
	"Method": "boolean supportsExpressionsInOrderBy(){\r\n    return databaseMetaData.supportsExpressionsInOrderBy();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.auth.realm.jdbc.JDBCRealm.init",
	"Comment": "initialize a realm with some properties.this can be usedwhen instantiating realms from their descriptions.thismethod may only be called a single time.",
	"Method": "void init(Properties props){\r\n    super.init(props);\r\n    String jaasCtx = props.getProperty(IASRealm.JAAS_CONTEXT_PARAM);\r\n    String dbUser = props.getProperty(PARAM_DB_USER);\r\n    String dbPassword = props.getProperty(PARAM_DB_PASSWORD);\r\n    String dsJndi = props.getProperty(PARAM_DATASOURCE_JNDI);\r\n    String digestAlgorithm = props.getProperty(PARAM_DIGEST_ALGORITHM, getDefaultDigestAlgorithm());\r\n    String encoding = props.getProperty(PARAM_ENCODING);\r\n    String charset = props.getProperty(PARAM_CHARSET);\r\n    String userTable = props.getProperty(PARAM_USER_TABLE);\r\n    String userNameColumn = props.getProperty(PARAM_USER_NAME_COLUMN);\r\n    String passwordColumn = props.getProperty(PARAM_PASSWORD_COLUMN);\r\n    String groupTable = props.getProperty(PARAM_GROUP_TABLE);\r\n    String groupNameColumn = props.getProperty(PARAM_GROUP_NAME_COLUMN);\r\n    String groupTableUserNameColumn = props.getProperty(PARAM_GROUP_TABLE_USER_NAME_COLUMN, userNameColumn);\r\n    cr = (ActiveDescriptor<ConnectorRuntime>) Util.getDefaultHabitat().getBestDescriptor(BuilderHelper.createContractFilter(ConnectorRuntime.class.getName()));\r\n    if (jaasCtx == null) {\r\n        String msg = sm.getString(\"realm.missingprop\", IASRealm.JAAS_CONTEXT_PARAM, \"JDBCRealm\");\r\n        throw new BadRealmException(msg);\r\n    }\r\n    if (dsJndi == null) {\r\n        String msg = sm.getString(\"realm.missingprop\", PARAM_DATASOURCE_JNDI, \"JDBCRealm\");\r\n        throw new BadRealmException(msg);\r\n    }\r\n    if (userTable == null) {\r\n        String msg = sm.getString(\"realm.missingprop\", PARAM_USER_TABLE, \"JDBCRealm\");\r\n        throw new BadRealmException(msg);\r\n    }\r\n    if (groupTable == null) {\r\n        String msg = sm.getString(\"realm.missingprop\", PARAM_GROUP_TABLE, \"JDBCRealm\");\r\n        throw new BadRealmException(msg);\r\n    }\r\n    if (userNameColumn == null) {\r\n        String msg = sm.getString(\"realm.missingprop\", PARAM_USER_NAME_COLUMN, \"JDBCRealm\");\r\n        throw new BadRealmException(msg);\r\n    }\r\n    if (passwordColumn == null) {\r\n        String msg = sm.getString(\"realm.missingprop\", PARAM_PASSWORD_COLUMN, \"JDBCRealm\");\r\n        throw new BadRealmException(msg);\r\n    }\r\n    if (groupNameColumn == null) {\r\n        String msg = sm.getString(\"realm.missingprop\", PARAM_GROUP_NAME_COLUMN, \"JDBCRealm\");\r\n        throw new BadRealmException(msg);\r\n    }\r\n    passwordQuery = \"SELECT \" + passwordColumn + \" FROM \" + userTable + \" WHERE \" + userNameColumn + \" = ?\";\r\n    groupQuery = \"SELECT \" + groupNameColumn + \" FROM \" + groupTable + \" WHERE \" + groupTableUserNameColumn + \" = ? \";\r\n    if (!NONE.equalsIgnoreCase(digestAlgorithm)) {\r\n        try {\r\n            md = MessageDigest.getInstance(digestAlgorithm);\r\n        } catch (NoSuchAlgorithmException e) {\r\n            String msg = sm.getString(\"jdbcrealm.notsupportdigestalg\", digestAlgorithm);\r\n            throw new BadRealmException(msg);\r\n        }\r\n    }\r\n    if (md != null && encoding == null) {\r\n        encoding = DEFAULT_ENCODING;\r\n    }\r\n    this.setProperty(IASRealm.JAAS_CONTEXT_PARAM, jaasCtx);\r\n    if (dbUser != null && dbPassword != null) {\r\n        this.setProperty(PARAM_DB_USER, dbUser);\r\n        this.setProperty(PARAM_DB_PASSWORD, dbPassword);\r\n    }\r\n    this.setProperty(PARAM_DATASOURCE_JNDI, dsJndi);\r\n    this.setProperty(PARAM_DIGEST_ALGORITHM, digestAlgorithm);\r\n    if (encoding != null) {\r\n        this.setProperty(PARAM_ENCODING, encoding);\r\n    }\r\n    if (charset != null) {\r\n        this.setProperty(PARAM_CHARSET, charset);\r\n    }\r\n    if (_logger.isLoggable(Level.FINEST)) {\r\n        _logger.finest(\"JDBCRealm : \" + IASRealm.JAAS_CONTEXT_PARAM + \"= \" + jaasCtx + \", \" + PARAM_DATASOURCE_JNDI + \" = \" + dsJndi + \", \" + PARAM_DB_USER + \" = \" + dbUser + \", \" + PARAM_DIGEST_ALGORITHM + \" = \" + digestAlgorithm + \", \" + PARAM_ENCODING + \" = \" + encoding + \", \" + PARAM_CHARSET + \" = \" + charset);\r\n    }\r\n    groupCache = new HashMap<String, Vector>();\r\n    emptyVector = new Vector<String>();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.getURL",
	"Comment": "retrieves the value of a jdbc datalink parameter as ajava.net.url object.",
	"Method": "URL getURL(int parameterIndex,URL getURL,String parameterName){\r\n    return callableStatement.getURL(parameterName);\r\n}"
}, {
	"Path": "org.glassfish.admin.amxtest.JMXTestBase.setGlobalConnection",
	"Comment": "set the global mbeanserverconnection.this is to support testing to aremote host.",
	"Method": "void setGlobalConnection(MBeanServerConnection conn){\r\n    _GlobalMBeanServerConnection = conn;\r\n}"
}, {
	"Path": "org.glassfish.resources.connector.ResourcesSniffer.handles",
	"Comment": "returns true if the passed file or directory is recognized by thisinstance.",
	"Method": "boolean handles(ReadableArchive archive){\r\n    return ResourceUtil.hasResourcesXML(archive, locator) && archive.getParentArchive() == null;\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.obj.RemoteToCorbaToAttrs.getStateToBind",
	"Comment": "returns the attributes required for storing a corba object. uses the utility supplied by corbatoattrs.",
	"Method": "DirStateFactory.Result getStateToBind(Object orig,Name name,Context ctx,Hashtable env,Attributes inAttrs,Object getStateToBind,Object orig,Name name,Context ctx,Hashtable env){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.getEntityManagerFactoryReferenceByName",
	"Comment": "return the entity manager factory reference descriptor corresponding tothe given name.",
	"Method": "EntityManagerFactoryReferenceDescriptor getEntityManagerFactoryReferenceByName(String name){\r\n    for (EntityManagerFactoryReferenceDescriptor next : getEntityManagerFactoryReferenceDescriptors()) {\r\n        if (next.getName().equals(name)) {\r\n            return next;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionapphasnoentitymgrfactoryrefbyname\", \"This app {0} has no entity manager factory reference by the name of {1}\", new Object[] { getRegistrationName(), name }));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlTimestamp.setSeconds",
	"Comment": "sets the seconds of this sqltimestamp to the specified value.",
	"Method": "void setSeconds(int seconds){\r\n    this.makeDirty();\r\n    super.setSeconds(seconds);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.CMPBeanHelper.assertPersistenceManagerIsNull",
	"Comment": "called from a cmp bean to verify that the persistencemanageris null. throws illegalstateexception if the argument is not null.",
	"Method": "void assertPersistenceManagerIsNull(PersistenceManager pm,Object bean,StringBuffer buf){\r\n    if (pm != null) {\r\n        String msg = // NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        cmpMessages, \"JDO.beaninuse_exception\", bean);\r\n        IllegalStateException e = new IllegalStateException(msg);\r\n        if (buf != null && buf.length() > 0) {\r\n            msg = (new StringBuffer(msg)).append(\" ...Last Instance Usage: \").append(buf).toString();\r\n        }\r\n        cmpInternalLogger.log(Logger.SEVERE, msg);\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.ctl.SortResponseControl.isSorted",
	"Comment": "determines if the search results have been successfully sorted.if an error occurred during sorting a namingexception is thrown.",
	"Method": "boolean isSorted(){\r\n    return (resultCode == 0);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.annotation.handlers.SingletonHandler.setEjbDescriptorInfo",
	"Comment": "set annotation information to descriptor.this method will also be invoked for an existing descriptor withannotation as user may not specific a complete xml.",
	"Method": "HandlerProcessingResult setEjbDescriptorInfo(EjbDescriptor ejbDesc,AnnotationInfo ainfo){\r\n    EjbSessionDescriptor ejbSingletonDescriptor = (EjbSessionDescriptor) ejbDesc;\r\n    Class ejbClass = (Class) ainfo.getAnnotatedElement();\r\n    Singleton singleton = (Singleton) ainfo.getAnnotation();\r\n    if (!ejbSingletonDescriptor.isSessionTypeSet()) {\r\n        ejbSingletonDescriptor.setSessionType(EjbSessionDescriptor.SINGLETON);\r\n    }\r\n    doDescriptionProcessing(singleton.description(), ejbDesc);\r\n    doMappedNameProcessing(singleton.mappedName(), ejbDesc);\r\n    doSingletonSpecificProcessing(ejbSingletonDescriptor, ejbClass);\r\n    return setBusinessAndHomeInterfaces(ejbDesc, ainfo);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.ApplicationArchivist.open",
	"Comment": "open a new application archive file, read all the deployment descriptors",
	"Method": "Application open(ReadableArchive appArchive){\r\n    setManifest(appArchive.getManifest());\r\n    Application appDesc = readStandardDeploymentDescriptor(appArchive);\r\n    return openWith(appDesc, appArchive);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.getModifiers",
	"Comment": "returns the modifier mask for the specified member element.\tnote, the member element is either a class element as returned by \tgetclass, a field element as returned by getfield, a constructor element \tas returned by getconstructor, or a method element as returned by \tgetmethod executed on the same model instance.",
	"Method": "int getModifiers(Object memberElement){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.FieldInfo.isPublic",
	"Comment": "checks whether this field is defined with the public modifier.",
	"Method": "boolean isPublic(){\r\n    return (field != null) && Modifier.isPublic(field.getModifiers());\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.getConcurrencyGroups",
	"Comment": "returns the collection of fields groups by this class in the form\tof an array.",
	"Method": "ConcurrencyGroupElement[] getConcurrencyGroups(ConcurrencyGroupElement[] getConcurrencyGroups){\r\n    return getClassImpl().getConcurrencyGroups();\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnection.cleanup",
	"Comment": "application server calls this method to force any cleanup on the managedconnection instance. this method calls the invalidatemethod on all connectionhandles associated with this managedconnection.",
	"Method": "void cleanup(){\r\n    if (logWriter != null) {\r\n        logWriter.println(\"In cleanup\");\r\n    }\r\n    checkIfValid();\r\n    if (connectionType == ISNOTAPOOLEDCONNECTION) {\r\n        try {\r\n            isolationLevelWhenCleaned = actualConnection.getTransactionIsolation();\r\n        } catch (SQLException sqle) {\r\n            throw new ResourceException(\"The isolation level for the physical connection \" + \"could not be retrieved\");\r\n        }\r\n    }\r\n    isClean = true;\r\n    activeConnectionHandle = null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.JavaTypeHelper.getPrimitiveName",
	"Comment": "returns the name of the primitive type associated with the supplied \twrapper class.",
	"Method": "String getPrimitiveName(Class wrapper){\r\n    return (String) _wrapperToPrimitiveNames.get(wrapper);\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.help.HelpTreeIndexAdaptor.getChildTreeNodeObjects",
	"Comment": "returns child indexitems for the given \tindexitem or index model object.if \tnull is supplied, null is returned \tany other object type will result in an \tillegalargumentexception.",
	"Method": "List getChildTreeNodeObjects(Object nodeObject){\r\n    if (nodeObject == null) {\r\n        return null;\r\n    }\r\n    List<IndexItem> result = null;\r\n    if (nodeObject instanceof IndexItem) {\r\n        result = new ArrayList<IndexItem>(((IndexItem) nodeObject).getIndexItems());\r\n    }\r\n    if (nodeObject instanceof Index) {\r\n        result = new ArrayList<IndexItem>(((Index) nodeObject).getIndexItems());\r\n    }\r\n    if (null != result) {\r\n        Collections.sort(result, new HelpTreeIndexAdaptor.IndexItemComparator());\r\n        return result;\r\n    }\r\n    throw new IllegalArgumentException(\"Invalid node type for Index: \" + nodeObject.getClass().getName());\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.getConnectionMsWait",
	"Comment": "returns the number of milliseconds to wait for an available connectionfrom the connection pool before throwing an exception",
	"Method": "int getConnectionMsWait(){\r\n    if (connectionFactory != null)\r\n        return connectionFactory.getMsWait();\r\n    return connectionMsWait;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingRelationshipElementImpl.addAssociatedColumn",
	"Comment": "adds a column to the list of associated columns mapped by this mapping\tfield.call this method instead of addcolumn when mapping\tjoin tables.this method is used to map between the join table column\tand the foreign table column, while addlocalcolumn is used\tto map between the local table and the join table.",
	"Method": "void addAssociatedColumn(ColumnPairElement column){\r\n    if (column != null) {\r\n        ArrayList columns = getAssociatedColumns();\r\n        String columnName = NameUtil.getRelativeMemberName(column.getName().getFullName());\r\n        if (!columns.contains(columnName)) {\r\n            try {\r\n                fireVetoableChange(PROP_ASSOCIATED_COLUMNS, null, null);\r\n                columns.add(columnName);\r\n                firePropertyChange(PROP_ASSOCIATED_COLUMNS, null, null);\r\n                _associatedColumnObjects = null;\r\n            } catch (PropertyVetoException e) {\r\n                throw new ModelVetoException(e);\r\n            }\r\n        } else {\r\n            throw new ModelException(// NOI18N\r\n            I18NHelper.getMessage(getMessages(), \"mapping.column.column_defined\", columnName));\r\n        }\r\n    } else {\r\n        throw new ModelException(// NOI18N\r\n        I18NHelper.getMessage(getMessages(), \"mapping.element.null_argument\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ConnectorDescriptor.setSunDescriptor",
	"Comment": "this sets the extra connector sun specific info not in the ri did.",
	"Method": "void setSunDescriptor(SunConnector connector){\r\n    this.sunConnector = connector;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.ClassFile.methods",
	"Comment": "return the list of the methods which the class definesthe contents are classmethod objects",
	"Method": "Vector methods(){\r\n    return classMethods;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBContainerStateManager.attachObject",
	"Comment": "associate ejb object with this invocation and this contextnote that some of the calls do not have context assosiated with thisinvocation, so context object is passed in separately",
	"Method": "void attachObject(EjbInvocation inv,EJBContextImpl context,EJBObjectImpl ejbObjImpl,EJBLocalObjectImpl localObjImpl){\r\n    if (ejbObjImpl != null && container.isRemoteObject() && (!inv.isLocal)) {\r\n        context.setEJBObjectImpl(ejbObjImpl);\r\n        context.setEJBStub((EJBObject) ejbObjImpl.getStub());\r\n    }\r\n    if (localObjImpl != null && container.isLocalObject()) {\r\n        context.setEJBLocalObjectImpl(localObjImpl);\r\n    }\r\n    if (inv.isLocal && localObjImpl != null) {\r\n        inv.ejbObject = localObjImpl;\r\n    } else if (ejbObjImpl != null) {\r\n        inv.ejbObject = ejbObjImpl;\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.CallableStatementWrapper40.isPoolable",
	"Comment": "returns avalue indicating whether the statementis poolable or not.",
	"Method": "boolean isPoolable(){\r\n    return callableStatement.isPoolable();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.getFieldsValidationList",
	"Comment": "computes and returns a collection of validationcomponents \trepresenting the field and relationship tests to be performed.",
	"Method": "Collection getFieldsValidationList(){\r\n    ArrayList list = new ArrayList();\r\n    Model model = getModel();\r\n    String className = getClassName();\r\n    PersistenceClassElement persistenceClass = getPersistenceClass(className);\r\n    if (persistenceClass != null) {\r\n        PersistenceFieldElement[] fields = persistenceClass.getFields();\r\n        int i, count = ((fields != null) ? fields.length : 0);\r\n        Iterator iterator = getMappingClass(className).getFields().iterator();\r\n        for (i = 0; i < count; i++) {\r\n            PersistenceFieldElement field = fields[i];\r\n            list.add(createFieldExistenceComponent(field));\r\n            if (model.hasField(className, field.getName())) {\r\n                list.add(createFieldPersistenceComponent(field));\r\n                list.add(createFieldPersistenceTypeComponent(field));\r\n                list.add(createFieldConsistencyComponent(field));\r\n                if (isLegalRelationship(field)) {\r\n                    RelationshipElement rel = (RelationshipElement) field;\r\n                    list.add(createElementClassComponent(rel));\r\n                    list.add(createRelatedClassMatchesComponent(rel));\r\n                }\r\n            }\r\n        }\r\n        while (iterator.hasNext()) {\r\n            MappingFieldElement field = (MappingFieldElement) iterator.next();\r\n            String fieldName = field.getName();\r\n            if (persistenceClass.getField(fieldName) == null) {\r\n                list.add(createFieldExistenceComponent(field));\r\n                if (model.hasField(className, fieldName))\r\n                    list.add(createFieldConsistencyComponent(field));\r\n            }\r\n            if (!isRelationship(field))\r\n                list.add(createColumnOverlapComponent(field));\r\n            if (Boolean.getBoolean(\"AllowManagedFieldsInDefaultFetchGroup\")) {\r\n            } else {\r\n                list.add(createFieldDefaultFetchGroupComponent(field));\r\n            }\r\n        }\r\n    }\r\n    return list;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.introspection.ClassFile.containsAnnotation",
	"Comment": "read the input channel and initialize instance datastructure.",
	"Method": "boolean containsAnnotation(ReadableByteChannel in,long size,boolean containsAnnotation,byte[] bytecode,boolean containsAnnotation,ByteBuffer headerBuffer){\r\n    if (headerBuffer.getInt() != magic) {\r\n        return false;\r\n    }\r\n    headerBuffer.getShort();\r\n    headerBuffer.getShort();\r\n    int constantPoolSize = headerBuffer.getShort();\r\n    return constantPoolInfo.containsAnnotation(constantPoolSize, headerBuffer);\r\n}"
}, {
	"Path": "com.sun.ejb.portable.HandleDelegateUtil.getJndiProperties",
	"Comment": "internal method for accessing jndi properties override.we onlylook for properties file at most once, whether it is present or not.",
	"Method": "Properties getJndiProperties(){\r\n    synchronized (HandleDelegateUtil.class) {\r\n        if (!checkedJndiProperties) {\r\n            FileInputStream fis = null;\r\n            try {\r\n                String jndiPropertyFileName = System.getProperty(JNDI_PROPERTY_FILE_NAME);\r\n                if (jndiPropertyFileName != null) {\r\n                    fis = new FileInputStream(jndiPropertyFileName);\r\n                    jndiProperties = new Properties();\r\n                    jndiProperties.load(fis);\r\n                }\r\n            } finally {\r\n                checkedJndiProperties = true;\r\n                if (fis != null) {\r\n                    try {\r\n                        fis.close();\r\n                    } catch (IOException e) {\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return jndiProperties;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.inbound.ActiveInboundResourceAdapterImpl.destroy",
	"Comment": "destroys default pools and resources. stops the resource adapterjava bean.",
	"Method": "void destroy(){\r\n    deactivateEndPoints();\r\n    super.destroy();\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbMessageBeanDescriptor.getMessageListenerInterfaceMethods",
	"Comment": "this returns the message listener onmessage method from the message listener interface itself, as opposed to the methodfrom the ejb class that implements it.",
	"Method": "Method[] getMessageListenerInterfaceMethods(ClassLoader classLoader){\r\n    List<Method> methods = new ArrayList<Method>();\r\n    try {\r\n        Class messageListenerClass = classLoader.loadClass(messageListenerType);\r\n        for (Method method : messageListenerClass.getDeclaredMethods()) {\r\n            methods.add(method);\r\n        }\r\n        final Class<?> ejbClass = classLoader.loadClass(getEjbClassName());\r\n        for (Method method : ejbClass.getMethods()) {\r\n            methods.add(method);\r\n        }\r\n    } catch (Exception e) {\r\n        NoSuchMethodException nsme = new NoSuchMethodException();\r\n        nsme.initCause(e);\r\n        throw nsme;\r\n    }\r\n    return methods.toArray(new Method[methods.size()]);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ClassDesc.registerVersionFieldWithTable",
	"Comment": "registers the version field versionfield with thecorresponding table.",
	"Method": "void registerVersionFieldWithTable(LocalFieldDesc versionField){\r\n    ColumnElement ce = (ColumnElement) versionField.getColumnElements().next();\r\n    Iterator iter = tables.iterator();\r\n    while (iter.hasNext()) {\r\n        TableDesc table = (TableDesc) iter.next();\r\n        if (!table.isJoinTable()) {\r\n            if (ce.getDeclaringTable() == table.getTableElement()) {\r\n                table.setVersionField(versionField);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.resources.connector.ResourcesCompositeSniffer.getContainersNames",
	"Comment": "returns the list of containers that this sniffer enables.the runtime will look up each container implementingusing the names provided in the habitat.",
	"Method": "String[] getContainersNames(){\r\n    return containerNames;\r\n}"
}, {
	"Path": "test.extension.ServiceFrameworkExtension.afterProcessBean",
	"Comment": "observer for processinjectiontarget events. this event isfired fire an event for each enabled bean, interceptor or decorator deployed in a bean archive, before registering the bean object. injections points of every discovered enabled java ee component is checked to see if there is a request for injection of a framework service.",
	"Method": "void afterProcessBean(ProcessBean pb){\r\n    afterProcessBeanCalled = true;\r\n    debug(\"afterProcessBean - \" + pb.getAnnotated().getBaseType());\r\n    Set<InjectionPoint> ips = pb.getBean().getInjectionPoints();\r\n    discoverServiceInjectionPoints(ips);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.getLong",
	"Comment": "retrieves the value of a jdbc bigint parameter as a longin the java programming language.",
	"Method": "long getLong(int parameterIndex,long getLong,String parameterName){\r\n    return callableStatement.getLong(parameterName);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingClassElementImpl.removeTable",
	"Comment": "removes the reference to the supplied table as a mapped table for this\tmapping class.this works whether the table is the primary table or a\tsecondary table.",
	"Method": "void removeTable(MappingTableElement table){\r\n    if (table != null) {\r\n        Collection tables = getTables();\r\n        Iterator iterator = null;\r\n        boolean found = false;\r\n        try {\r\n            fireVetoableChange(PROP_TABLES, null, null);\r\n            found = tables.remove(table);\r\n            firePropertyChange(PROP_TABLES, null, null);\r\n        } catch (PropertyVetoException e) {\r\n            throw new ModelVetoException(e);\r\n        }\r\n        iterator = tables.iterator();\r\n        while (iterator.hasNext()) {\r\n            MappingTableElement nextTable = (MappingTableElement) iterator.next();\r\n            nextTable.removeReference(table);\r\n        }\r\n        if (found) {\r\n            ArrayList fieldsToRemove = new ArrayList();\r\n            iterator = getFields().iterator();\r\n            while (iterator.hasNext()) {\r\n                MappingFieldElementImpl mappingField = (MappingFieldElementImpl) iterator.next();\r\n                if (mappingField.isMappedToTable(table))\r\n                    fieldsToRemove.add(mappingField);\r\n            }\r\n            iterator = fieldsToRemove.iterator();\r\n            while (iterator.hasNext()) {\r\n                MappingFieldElement mappingField = (MappingFieldElement) iterator.next();\r\n                boolean versionField = mappingField.isVersion();\r\n                removeField(mappingField);\r\n                if (versionField) {\r\n                    mappingField = new MappingFieldElementImpl(mappingField.getName(), this);\r\n                    mappingField.setVersion(true);\r\n                    addField(mappingField);\r\n                }\r\n            }\r\n        } else {\r\n            throw new ModelException(// NOI18N\r\n            I18NHelper.getMessage(getMessages(), \"mapping.element.element_not_removed\", table));\r\n        }\r\n    } else {\r\n        throw new ModelException(// NOI18N\r\n        I18NHelper.getMessage(getMessages(), \"mapping.element.null_argument\"));\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.annotation.handlers.StatefulHandler.isValidEjbDescriptor",
	"Comment": "check if the given ejbdescriptor matches the given annotation.",
	"Method": "boolean isValidEjbDescriptor(EjbDescriptor ejbDesc,Annotation annotation){\r\n    boolean isValid = EjbSessionDescriptor.TYPE.equals(ejbDesc.getType());\r\n    if (isValid) {\r\n        EjbSessionDescriptor sessionDesc = (EjbSessionDescriptor) ejbDesc;\r\n        if (sessionDesc.isSessionTypeSet() && !sessionDesc.isStateful()) {\r\n            isValid = false;\r\n        }\r\n    }\r\n    return isValid;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ApplicationClientDescriptor.getEnvironmentProperties",
	"Comment": "returns the set of environment properties of this app client.",
	"Method": "Set getEnvironmentProperties(){\r\n    if (this.environmentProperties == null) {\r\n        this.environmentProperties = new OrderedSet();\r\n    }\r\n    return this.environmentProperties = new OrderedSet(this.environmentProperties);\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBLocalHomeInvocationHandler.invokeTargetBeanMethod",
	"Comment": "allow subclasses to execute a protected method in basecontainer",
	"Method": "Object invokeTargetBeanMethod(BaseContainer container,Method beanClassMethod,EjbInvocation inv,Object target,Object[] params){\r\n    return container.invokeTargetBeanMethod(beanClassMethod, inv, target, params, null);\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.PoolLifeCycleRegistry.registerPoolLifeCycle",
	"Comment": "add a listener to the list of pool life cycle listeners maintained by this registry for the poolname.",
	"Method": "void registerPoolLifeCycle(PoolLifeCycle listener){\r\n    lifeCycleListeners.add(listener);\r\n    if (!(lifeCycleListeners.size() > 1)) {\r\n        PoolManager poolMgr = ConnectorRuntime.getRuntime().getPoolManager();\r\n        poolMgr.registerPoolLifeCycleListener(this);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.stats.StatisticImpl.getLastSampleTime",
	"Comment": "returns the time in millis, at which the last measurement was taken",
	"Method": "long getLastSampleTime(){\r\n    return this.sampleTime;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.ResultDesc.getValueFromResultSet",
	"Comment": "gets value at index from resultdata. resultdata is queried for passed resulttype.",
	"Method": "Object getValueFromResultSet(ResultSet resultData,ColumnRef columnRef,int resultType,Object getValueFromResultSet,ResultSet resultData,int index,int resultType,Object getValueFromResultSet,ResultSet resultData,int index,int resultType,int columnType){\r\n    Object retVal = null;\r\n    try {\r\n        switch(resultType) {\r\n            case FieldTypeEnumeration.BOOLEAN_PRIMITIVE:\r\n            case FieldTypeEnumeration.BOOLEAN:\r\n                boolean booleanValue = resultData.getBoolean(index);\r\n                if (!resultData.wasNull())\r\n                    retVal = new Boolean(booleanValue);\r\n                break;\r\n            case FieldTypeEnumeration.CHARACTER_PRIMITIVE:\r\n            case FieldTypeEnumeration.CHARACTER:\r\n                String strValue = resultData.getString(index);\r\n                if (strValue != null)\r\n                    retVal = FieldDesc.getCharFromString(strValue);\r\n                break;\r\n            case FieldTypeEnumeration.BYTE_PRIMITIVE:\r\n            case FieldTypeEnumeration.BYTE:\r\n                byte byteValue = resultData.getByte(index);\r\n                if (!resultData.wasNull())\r\n                    retVal = new Byte(byteValue);\r\n                break;\r\n            case FieldTypeEnumeration.SHORT_PRIMITIVE:\r\n            case FieldTypeEnumeration.SHORT:\r\n                short shortValue = resultData.getShort(index);\r\n                if (!resultData.wasNull())\r\n                    retVal = new Short(shortValue);\r\n                break;\r\n            case FieldTypeEnumeration.INTEGER_PRIMITIVE:\r\n            case FieldTypeEnumeration.INTEGER:\r\n                int intValue = resultData.getInt(index);\r\n                if (!resultData.wasNull())\r\n                    retVal = new Integer(intValue);\r\n                break;\r\n            case FieldTypeEnumeration.LONG_PRIMITIVE:\r\n            case FieldTypeEnumeration.LONG:\r\n                long longValue = resultData.getLong(index);\r\n                if (!resultData.wasNull())\r\n                    retVal = new Long(longValue);\r\n                break;\r\n            case FieldTypeEnumeration.FLOAT_PRIMITIVE:\r\n            case FieldTypeEnumeration.FLOAT:\r\n                float floatValue = resultData.getFloat(index);\r\n                if (!resultData.wasNull())\r\n                    retVal = new Float(floatValue);\r\n                break;\r\n            case FieldTypeEnumeration.DOUBLE_PRIMITIVE:\r\n            case FieldTypeEnumeration.DOUBLE:\r\n                double doubleValue = resultData.getDouble(index);\r\n                if (!resultData.wasNull())\r\n                    retVal = new Double(doubleValue);\r\n                break;\r\n            case FieldTypeEnumeration.BIGDECIMAL:\r\n            case FieldTypeEnumeration.BIGINTEGER:\r\n                retVal = resultData.getBigDecimal(index);\r\n                if ((resultType == FieldTypeEnumeration.BIGINTEGER) && (retVal != null)) {\r\n                    retVal = ((java.math.BigDecimal) retVal).toBigInteger();\r\n                }\r\n                break;\r\n            case FieldTypeEnumeration.STRING:\r\n                if (LocalFieldDesc.isCharLobType(columnType)) {\r\n                    Reader reader = resultData.getCharacterStream(index);\r\n                    retVal = readCharacterStreamToString(reader);\r\n                } else {\r\n                    retVal = resultData.getString(index);\r\n                }\r\n                break;\r\n            case FieldTypeEnumeration.SQL_DATE:\r\n                retVal = resultData.getDate(index);\r\n                break;\r\n            case FieldTypeEnumeration.SQL_TIME:\r\n                retVal = resultData.getTime(index);\r\n                break;\r\n            case FieldTypeEnumeration.UTIL_DATE:\r\n            case FieldTypeEnumeration.SQL_TIMESTAMP:\r\n                Timestamp ts;\r\n                ts = resultData.getTimestamp(index);\r\n                if (resultType == FieldTypeEnumeration.UTIL_DATE && ts != null) {\r\n                    retVal = new Date(ts.getTime());\r\n                } else {\r\n                    retVal = ts;\r\n                }\r\n                break;\r\n            case FieldTypeEnumeration.ARRAY_BYTE_PRIMITIVE:\r\n                InputStream is = resultData.getBinaryStream(index);\r\n                retVal = readInputStreamToByteArray(is);\r\n                break;\r\n            case FieldTypeEnumeration.NOT_ENUMERATED:\r\n                retVal = resultData.getObject(index);\r\n                break;\r\n            default:\r\n                throw new JDOFatalInternalException(I18NHelper.getMessage(messages, \"sqlstore.resultdesc.unknownfieldtype\", resultType));\r\n        }\r\n    } catch (SQLException e) {\r\n        if (logger.isLoggable(Logger.WARNING)) {\r\n            Object[] items = { new Integer(index), new Integer(resultType), new Integer(columnType), e };\r\n            logger.log(Logger.WARNING, \"sqlstore.resultdesc.errorgettingvalefromresulset\", items);\r\n        }\r\n        throw e;\r\n    }\r\n    if (LocalFieldDesc.isFixedCharType(columnType) && resultType != FieldTypeEnumeration.CHARACTER_PRIMITIVE && resultType != FieldTypeEnumeration.CHARACTER && retVal != null) {\r\n        retVal = StringHelper.rtrim(retVal.toString());\r\n    }\r\n    return retVal;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getConnection",
	"Comment": "retrieves the connection that produced this metadata object.",
	"Method": "Connection getConnection(){\r\n    return connection;\r\n}"
}, {
	"Path": "org.glassfish.deployapi.ProgressObjectImpl.initializeTargetModuleIDs",
	"Comment": "initialize the target module ids with the passed application moduleidand the descriptors",
	"Method": "void initializeTargetModuleIDs(String moduleID){\r\n    TargetModuleIDImpl parentTargetModuleID = new TargetModuleIDImpl(target, moduleID);\r\n    targetModuleIDs = new TargetModuleIDImpl[1];\r\n    targetModuleIDs[0] = parentTargetModuleID;\r\n}"
}, {
	"Path": "org.glassfish.resources.admin.cli.ResourcesXMLParser.sortNonConnectorResources",
	"Comment": "sort non connector resourcesjdbc pools are added first to the list, so that the conncetionpools can be created prior to any other jdbc resource definedin the resources configuration xml file.",
	"Method": "List<org.glassfish.resources.api.Resource> sortNonConnectorResources(List<org.glassfish.resources.api.Resource> nonConnectorResources){\r\n    List<org.glassfish.resources.api.Resource> jdbccps = new ArrayList<Resource>();\r\n    List<org.glassfish.resources.api.Resource> pmfs = new ArrayList<Resource>();\r\n    List<org.glassfish.resources.api.Resource> others = new ArrayList<Resource>();\r\n    List<org.glassfish.resources.api.Resource> finalSortedNonConnectorList = new ArrayList<org.glassfish.resources.api.Resource>();\r\n    for (Resource resource : nonConnectorResources) {\r\n        if (resource.getType().equals(org.glassfish.resources.api.Resource.JDBC_CONNECTION_POOL)) {\r\n            jdbccps.add(resource);\r\n        } else if (resource.getType().equals(org.glassfish.resources.api.Resource.PERSISTENCE_MANAGER_FACTORY_RESOURCE)) {\r\n            pmfs.add(resource);\r\n        } else {\r\n            others.add(resource);\r\n        }\r\n    }\r\n    finalSortedNonConnectorList.addAll(jdbccps);\r\n    finalSortedNonConnectorList.addAll(others);\r\n    finalSortedNonConnectorList.addAll(pmfs);\r\n    return finalSortedNonConnectorList;\r\n}"
}, {
	"Path": "admin.ConfigTests.testConfigChangeEvents",
	"Comment": "this tests that notifications are delivered for config changes.",
	"Method": "void testConfigChangeEvents(){\r\n    final String tn = \"configChange-\";\r\n    AsadminReturn ret;\r\n    report(tn + \"create-prop1\", asadmin(\"create-system-properties\", \"--target\", \"domain\", \"someport=1010\"));\r\n    report(tn + \"create-nl\", asadmin(\"create-network-listener\", \"--listenerport\", \"${someport}\", \"--protocol\", \"http-listener-1\", \"somelistener\"));\r\n    report(tn + \"create-vs\", asadmin(\"create-virtual-server\", \"--hosts\", \"localhost\", \"--networklisteners\", \"somelistener\", \"somevs\"));\r\n    ret = asadminWithOutput(\"_get-host-and-port\", \"--virtualserver\", \"somevs\");\r\n    report(tn + \"check-hap1\", ret.out.indexOf(\"1010\") != -1);\r\n    report(tn + \"setconfig\", asadmin(\"create-system-properties\", \"--target\", \"server-config\", \"someport=2020\"));\r\n    ret = asadminWithOutput(\"_get-host-and-port\", \"--virtualserver\", \"somevs\");\r\n    report(tn + \"check-hap2\", ret.out.indexOf(\"2020\") != -1);\r\n    report(tn + \"create-prop2\", asadmin(\"create-system-properties\", \"someport=3030\"));\r\n    ret = asadminWithOutput(\"_get-host-and-port\", \"--virtualserver\", \"somevs\");\r\n    report(tn + \"check-hap3\", ret.out.indexOf(\"3030\") != -1);\r\n    report(tn + \"delvs\", asadmin(\"delete-virtual-server\", \"somevs\"));\r\n    report(tn + \"delnl\", asadmin(\"delete-network-listener\", \"somelistener\"));\r\n    report(tn + \"delsp1\", asadmin(\"delete-system-property\", \"someport\"));\r\n    report(tn + \"delsp2\", asadmin(\"delete-system-property\", \"--target\", \"domain\", \"someport\"));\r\n    report(tn + \"delsp1\", asadmin(\"delete-system-property\", \"--target\", \"server-config\", \"someport\"));\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.DeleteConnectorResource.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (jndiName == null) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.connector.resource.noJndiName\", \"No JNDI name defined for connector resource.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    Resource r = ConnectorsUtil.getResourceByName(domain.getResources(), ConnectorResource.class, jndiName);\r\n    if (r == null) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.connector.resource.notfound\", \"A connector resource named {0} does not exist.\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (\"system-all-req\".equals(r.getObjectType())) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.connector.resource.notAllowed\", \"The {0} resource cannot be deleted as it is required to be configured in the system.\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (environment.isDas()) {\r\n        if (\"domain\".equals(target)) {\r\n            if (resourceUtil.getTargetsReferringResourceRef(jndiName).size() > 0) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.connector.resource.resource-ref.exist\", \"connector-resource [ {0} ] is referenced in an\" + \"instance/cluster target, Use delete-resource-ref on appropriate target\", jndiName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        } else {\r\n            if (!resourceUtil.isResourceRefInTarget(jndiName, target)) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.connector.resource.no.resource-ref\", \"connector-resource [ {0} ] is not referenced in target [ {1} ]\", jndiName, target));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n            if (resourceUtil.getTargetsReferringResourceRef(jndiName).size() > 1) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.connector.resource.multiple.resource-refs\", \"connector resource [ {0} ] is referenced in multiple \" + \"instance/cluster targets, Use delete-resource-ref on appropriate target\", jndiName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        resourceUtil.deleteResourceRef(jndiName, target);\r\n        if (ConfigSupport.apply(new SingleConfigCode<Resources>() {\r\n            public Object run(Resources param) throws PropertyVetoException, TransactionFailure {\r\n                ConnectorResource resource = (ConnectorResource) ConnectorsUtil.getResourceByName(domain.getResources(), ConnectorResource.class, jndiName);\r\n                return param.getResources().remove(resource);\r\n            }\r\n        }, domain.getResources()) == null) {\r\n            report.setMessage(localStrings.getLocalString(\"delete.connector.resource.fail\", \"Connector resource {0} delete failed \", jndiName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    } catch (TransactionFailure tfe) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.connector.resource.fail\", \"Connector resource {0} delete failed \", jndiName) + \" \" + tfe.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n    }\r\n    report.setMessage(localStrings.getLocalString(\"delete.connector.resource.success\", \"Connector resource {0} deleted successfully\", jndiName));\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.DeleteConnectorResource.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    ConnectorResource resource = (ConnectorResource) ConnectorsUtil.getResourceByName(domain.getResources(), ConnectorResource.class, jndiName);\r\n    return param.getResources().remove(resource);\r\n}"
}, {
	"Path": "org.glassfish.jdbcruntime.JdbcPoolMonitoringExtension.unRegisterConnectionPool",
	"Comment": "unregister the appstatsproviders registered for this connection pool.",
	"Method": "void unRegisterConnectionPool(){\r\n    Iterator jdbcProviders = jdbcPoolAppStatsProviders.iterator();\r\n    while (jdbcProviders.hasNext()) {\r\n        JdbcConnPoolAppStatsProvider jdbcPoolAppStatsProvider = (JdbcConnPoolAppStatsProvider) jdbcProviders.next();\r\n        StatsProviderManager.unregister(jdbcPoolAppStatsProvider);\r\n    }\r\n    jdbcPoolAppStatsProviders.clear();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.DataSourceDefinitionDescriptor.setIsolationLevel",
	"Comment": "annotation uses integer values and hence this mapping is needed",
	"Method": "void setIsolationLevel(String isolationLevelString){\r\n    if (!isIntegerIsolationLevelSet(isolationLevelString)) {\r\n        if (isolationLevelString.equals(TRANSACTION_READ_COMMITTED)) {\r\n            this.isolationLevel = Connection.TRANSACTION_READ_COMMITTED;\r\n        } else if (isolationLevelString.equals(TRANSACTION_READ_UNCOMMITTED)) {\r\n            this.isolationLevel = Connection.TRANSACTION_READ_UNCOMMITTED;\r\n        } else if (isolationLevelString.equals(TRANSACTION_REPEATABLE_READ)) {\r\n            this.isolationLevel = Connection.TRANSACTION_REPEATABLE_READ;\r\n        } else if (isolationLevelString.equals(TRANSACTION_SERIALIZABLE)) {\r\n            this.isolationLevel = Connection.TRANSACTION_SERIALIZABLE;\r\n        } else {\r\n            throw new IllegalStateException(\"Isolation level [ \" + isolationLevelString + \" ] not of of standard isolation levels.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsOuterJoins",
	"Comment": "retrieves whether this database supports some form of outer join.",
	"Method": "boolean supportsOuterJoins(){\r\n    return databaseMetaData.supportsOuterJoins();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsCatalogsInProcedureCalls",
	"Comment": "retrieves whether a catalog name can be used in a procedure call statement.",
	"Method": "boolean supportsCatalogsInProcedureCalls(){\r\n    return databaseMetaData.supportsCatalogsInProcedureCalls();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.setDescriptor",
	"Comment": "archivist read xml deployment descriptors and keep theparsed result in the dol descriptor instances. sets the descriptorfor a particular archivist type",
	"Method": "void setDescriptor(T descriptor){\r\n    this.descriptor = descriptor;\r\n}"
}, {
	"Path": "org.glassfish.deployapi.TargetModuleIDImpl.getParentTargetModuleID",
	"Comment": "returns the targetmoduleid for the containing module on the target, ifthis targetmoduleid represents a submodule.",
	"Method": "TargetModuleID getParentTargetModuleID(){\r\n    return parent;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.ClassAction.scanFields",
	"Comment": "scans the fields of a classfileif this is not a persistence capable class, do nothing.",
	"Method": "void scanFields(){\r\n    Enumeration e = classFile().fields().elements();\r\n    while (e.hasMoreElements()) {\r\n        final ClassField f = (ClassField) e.nextElement();\r\n        final String fieldName = f.name().asString();\r\n        final String fieldSig = f.signature().asString();\r\n        scanForJDOFields(fieldName, fieldSig);\r\n        FieldAction action = new FieldAction(this, f, env);\r\n        action.check();\r\n        fieldActionTable.add(action);\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBContainerTransactionManager.isAppExceptionRequiringRollback",
	"Comment": "returns true if this exception is an application exception andit requires rollback of the transaction in which it was thrown.",
	"Method": "boolean isAppExceptionRequiringRollback(Throwable exception){\r\n    boolean appExceptionRequiringRollback = false;\r\n    if (exception != null) {\r\n        Class clazz = exception.getClass();\r\n        String exceptionClassName = clazz.getName();\r\n        Map<String, EjbApplicationExceptionInfo> appExceptions = ejbDescriptor.getEjbBundleDescriptor().getApplicationExceptions();\r\n        while (clazz != null) {\r\n            String eClassName = clazz.getName();\r\n            if (appExceptions.containsKey(eClassName)) {\r\n                if (exceptionClassName.equals(eClassName) || appExceptions.get(eClassName).getInherited() == true) {\r\n                    appExceptionRequiringRollback = appExceptions.get(eClassName).getRollback();\r\n                }\r\n                break;\r\n            }\r\n            clazz = clazz.getSuperclass();\r\n        }\r\n    }\r\n    return appExceptionRequiringRollback;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.deployment.LoginConfigurationImpl.getRealmName",
	"Comment": "obtain the realm the server should use for basic authentication.",
	"Method": "String getRealmName(){\r\n    if (this.realmName == null) {\r\n        this.realmName = \"\";\r\n    }\r\n    return this.realmName;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.logging.AbstractLogger.warning",
	"Comment": "log a warning message.\tif the logger is currently enabled for the warning message \tlevel then the given message is forwarded to all the\tregistered output handler objects.",
	"Method": "void warning(String msg){\r\n    log(WARNING, msg);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.CallableStatementWrapper40.setPoolable",
	"Comment": "requests that a statement be pooled or not pooled.the valuespecified is a hint to the statement pool implementation indicatingwhether the applicaiton wants the statement to be pooled.it is up tothe statement pool manager as to whether the hint is used.the poolable value of a statement is applicable to both internalstatement caches implemented by the driver and external statement cachesimplemented by application servers and other applications.by default, a statement is not poolable when created, anda preparedstatement and callablestatementare poolable when created.",
	"Method": "void setPoolable(boolean poolable){\r\n    callableStatement.setPoolable(poolable);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.removeRelationship",
	"Comment": "updates the relationship field fielddesc between thisand removedsm.",
	"Method": "void removeRelationship(ForeignFieldDesc fieldDesc,SQLStateManager removedSM){\r\n    boolean isCollection = (fieldDesc.cardinalityUPB > 1);\r\n    if (!isCollection) {\r\n        prepareUpdateFieldSpecial(fieldDesc, removedSM.persistentObject, false);\r\n        updateTrackedFields(fieldDesc, null, null);\r\n        fieldDesc.setValue(this, null);\r\n    } else {\r\n        try {\r\n            prepareUpdateFieldSpecial(fieldDesc, null, true);\r\n            SCOCollection c = (SCOCollection) fieldDesc.getValue(this);\r\n            c.removeInternal(removedSM.persistentObject);\r\n            updateTrackedFields(fieldDesc, c, null);\r\n        } catch (ClassCastException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.web.security.SSLSocketFactory.init",
	"Comment": "specify whether the server will require client authentication.",
	"Method": "void init(SSLServerSocket socket){\r\n    socket.setNeedClientAuth(clientAuth);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.setLogWriter",
	"Comment": "set the log writer for this managedconnectionfactoryimpl instance.",
	"Method": "void setLogWriter(java.io.PrintWriter out){\r\n    logWriter = out;\r\n}"
}, {
	"Path": "org.glassfish.jdbc.pool.monitor.JdbcConnPoolStatsProvider.connectionMatchedEvent",
	"Comment": "when connection under test matches the current request ,increment numconnsuccessfullymatched.",
	"Method": "void connectionMatchedEvent(String poolName,String appName,String moduleName){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (logger.isLoggable(Level.FINEST)) {\r\n            logger.finest(\"Connection matched event received - \" + \"poolName = \" + poolName);\r\n        }\r\n        numConnSuccessfullyMatched.increment();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOConcreteBean11Generator.getJDOQLElementsForCMP11",
	"Comment": "creating a jdoqlelements object for cmp11 support. for cmp11 there is noejbql, thus we get the filter expression and parameter declaration fromthe dd.",
	"Method": "JDOQLElements getJDOQLElementsForCMP11(Method m,AbstractMethodHelper methodHelper){\r\n    String params = methodHelper.getJDOParameterDeclaration(m);\r\n    String variables = methodHelper.getJDOVariableDeclaration(m);\r\n    String filter = methodHelper.getJDOFilterExpression(m);\r\n    String ordering = methodHelper.getJDOOrderingSpecification(m);\r\n    return new JDOQLElements(pcname, params, variables, filter, ordering, \"this\", pcname, true, false, null);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.hashCode",
	"Comment": "computes the hash code of this persistencemanagerfactory.",
	"Method": "int hashCode(){\r\n    if (providedConnectionFactory == SET_AS_CONNECTIONFACTORY) {\r\n        return connectionFactory.hashCode();\r\n    } else if (providedConnectionFactory == SET_AS_DATASOURCE) {\r\n        return dataSource.hashCode();\r\n    } else if (connectionFactoryName != null) {\r\n        return connectionFactoryName.hashCode();\r\n    }\r\n    return URL.hashCode() + userName.hashCode() + password.hashCode() + driverName.hashCode();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.getQuoteSpecialOnly",
	"Comment": "returns true if only identifiers with special characters should be quotedfor this database",
	"Method": "boolean getQuoteSpecialOnly(){\r\n    String s = (String) dbMap.get(QUOTE_SPECIAL_ONLY);\r\n    Boolean b = Boolean.valueOf(s);\r\n    if (logger.isLoggable()) {\r\n        logger.fine(\"sqlstore.database.dbvendor.getquotespecialonly\", b);\r\n    }\r\n    return b.booleanValue();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.AbstractMethodHelper.getQueryString",
	"Comment": "gets the query string associated with the specified method if it \texists.",
	"Method": "String getQueryString(Method method){\r\n    QueryDescriptor queryDescriptor = getQueryDescriptor(method);\r\n    return ((queryDescriptor != null) ? queryDescriptor.getQuery() : null);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.getQueryTimeout",
	"Comment": "gets the number of seconds to wait for a query statement \tto execute in the datastore associated with this persistencemanagerfactory.",
	"Method": "int getQueryTimeout(){\r\n    return queryTimeout;\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecurityMechanismSelector.evaluateTrust",
	"Comment": "called by the target to interpret client credentials after validation.",
	"Method": "SecurityContext evaluateTrust(SecurityContext ctx,byte[] object_id,Socket socket){\r\n    SecurityContext ssc = null;\r\n    boolean ssl_used = false;\r\n    X509Certificate[] certChain = null;\r\n    if ((socket != null) && (socket instanceof SSLSocket)) {\r\n        ssl_used = true;\r\n        SSLSocket sslSock = (SSLSocket) socket;\r\n        SSLSession sslSession = sslSock.getSession();\r\n        try {\r\n            certChain = (X509Certificate[]) sslSession.getPeerCertificates();\r\n        } catch (Exception e) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"iiop.cannot_get_peercert\", e);\r\n            }\r\n        }\r\n    }\r\n    Long ClientID = ConnectionExecutionContext.readClientThreadID();\r\n    if (ClientID != null && ClientID == Thread.currentThread().getId() && ctx == null)\r\n        return null;\r\n    if (evaluate_client_conformance(ctx, object_id, ssl_used, certChain) == false) {\r\n        String msg = \"Trust evaluation failed because \";\r\n        msg = msg + \"client does not conform to configured security policies\";\r\n        throw new SecurityMechanismException(msg);\r\n    }\r\n    if (ctx == null) {\r\n        if (socket == null || !ssl_used || certChain == null) {\r\n            return null;\r\n        } else {\r\n            ssc = new SecurityContext();\r\n            X500Name x500Name = (X500Name) certChain[0].getSubjectDN();\r\n            ssc.subject = new Subject();\r\n            ssc.subject.getPublicCredentials().add(x500Name);\r\n            ssc.identcls = X500Name.class;\r\n            ssc.authcls = null;\r\n            return ssc;\r\n        }\r\n    } else {\r\n        ssc = ctx;\r\n    }\r\n    Class authCls = ctx.authcls;\r\n    Class identCls = ctx.identcls;\r\n    ssc.authcls = null;\r\n    ssc.identcls = null;\r\n    if (identCls != null)\r\n        ssc.identcls = identCls;\r\n    else if (authCls != null)\r\n        ssc.authcls = authCls;\r\n    else\r\n        ssc.identcls = AnonCredential.class;\r\n    return ssc;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.connection.ConnectionManager.getConnection",
	"Comment": "establishes a connection to the specifieddatabase url using the specified user name and password.",
	"Method": "Connection getConnection(Connection getConnection,String userName,char[] password,Connection getConnection,String url,String userName,String password){\r\n    boolean debug = logger.isLoggable(Logger.FINEST);\r\n    if (this.shutDownPending == true) {\r\n        SQLException se = new SQLException(StringScanner.createParamString(// NOI18N\r\n        I18NHelper.getMessage(messages, \"connection.connectionmanager.isdown\")), SQL_CONN_FAIL);\r\n        throw se;\r\n    }\r\n    ConnectionImpl conn = this.checkXact();\r\n    if (conn == null) {\r\n        if (freeConn != null) {\r\n            if (debug) {\r\n                logger.finest(\"sqlstore.connection.conncectiomgr.found\", freeConn);\r\n            }\r\n            conn = freeConn;\r\n            freeConn = null;\r\n        } else {\r\n            try {\r\n                conn = new ConnectionImpl(DriverManager.getConnection(this.expandAttribute(url), this.expandAttribute(userName), this.expandAttribute(password)), this.expandAttribute(url), this.expandAttribute(userName), this);\r\n                if (debug) {\r\n                    logger.finest(\"sqlstore.connection.conncectiomgr.getnewconn\", conn);\r\n                }\r\n            } catch (SQLException se) {\r\n                throw se;\r\n            }\r\n        }\r\n        conn.checkXact();\r\n    } else {\r\n        if ((!conn.getURL().equals(this.expandAttribute(url))) || (!conn.getUserName().equals(this.expandAttribute(userName)))) {\r\n            SQLException se = new SQLException(StringScanner.createParamString(// NOI18N\r\n            I18NHelper.getMessage(messages, \"connection.connectionmanager.getconnection.mismatch\")), SQL_NO_CONN);\r\n            throw se;\r\n        }\r\n    }\r\n    conn.setFreePending(false);\r\n    conn.setPooled(false);\r\n    this.busyList.insertAtTail((Linkable) conn);\r\n    return ((Connection) conn);\r\n}"
}, {
	"Path": "com.sun.enterprise.naming.impl.SerialContext.getReference",
	"Comment": "this method tries to check if the passed object is a reference orrefenciable. if it is a reference, it just casts it to a reference andreturns, else if it is a referenceable, it tries to get a reference fromthe referenceable and returns that, otherwise, it returns null.",
	"Method": "Reference getReference(Object obj){\r\n    Reference ref = null;\r\n    if (obj instanceof Reference) {\r\n        ref = (Reference) obj;\r\n    } else if (obj instanceof Referenceable) {\r\n        ref = ((Referenceable) (obj)).getReference();\r\n    }\r\n    return ref;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.copyValues",
	"Comment": "copies the value of fields into the arrayvalues. the values are copied into thearray starting at index startindex.",
	"Method": "void copyValues(Object[] values,LocalFieldDesc[] fields,int startIndex){\r\n    assert values.length - startIndex >= fields.length;\r\n    for (int i = 0; i < fields.length; i++) {\r\n        LocalFieldDesc field = fields[i];\r\n        values[i + startIndex] = field.getValue(this);\r\n        assert values[i + startIndex] != null;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.jdbcruntime.service.JdbcAdminServiceImpl.getValidationTableNames",
	"Comment": "get validation table names list for the catalog that the jdbc connection pool refers to. this is used for connection validation.",
	"Method": "Set<String> getValidationTableNames(PoolInfo poolInfo,Set<String> getValidationTableNames,java.sql.Connection con,String catalog){\r\n    SortedSet<String> tableNames = new TreeSet();\r\n    if (catalog.trim().equals(\"\")) {\r\n        catalog = null;\r\n    }\r\n    if (con != null) {\r\n        java.sql.ResultSet rs = null;\r\n        try {\r\n            DatabaseMetaData dmd = con.getMetaData();\r\n            rs = dmd.getTables(catalog, null, null, null);\r\n            while (rs.next()) {\r\n                String schemaName = rs.getString(2);\r\n                String tableName = rs.getString(3);\r\n                String actualTableName = tableName;\r\n                if (schemaName != null && !schemaName.equals(\"\")) {\r\n                    actualTableName = schemaName + \".\" + tableName;\r\n                }\r\n                tableNames.add(actualTableName);\r\n            }\r\n        } catch (Exception sqle) {\r\n            _logger.log(Level.INFO, \"pool.get_validation_table_names\");\r\n            throw new ResourceException(sqle);\r\n        } finally {\r\n            try {\r\n                if (rs != null) {\r\n                    rs.close();\r\n                }\r\n            } catch (Exception e1) {\r\n            }\r\n        }\r\n    } else {\r\n        throw new ResourceException(\"The connection is not valid as \" + \"the connection is null\");\r\n    }\r\n    return tableNames;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.MappingPolicy.init",
	"Comment": "initialize this mappingpolicy as per the values in the givenproperties.",
	"Method": "void init(Properties props){\r\n    for (Enumeration e = props.propertyNames(); e.hasMoreElements(); ) {\r\n        String name = (String) e.nextElement();\r\n        String value = props.getProperty(name);\r\n        if (name.equals(RESERVED_WORDS)) {\r\n            initReservedWords(value);\r\n            continue;\r\n        }\r\n        String indicator = null;\r\n        StringTokenizer nameParser = new StringTokenizer(name, String.valueOf(DOT));\r\n        while (nameParser.hasMoreTokens()) {\r\n            indicator = nameParser.nextToken();\r\n        }\r\n        if (indicator.equals(INDICATOR_SQL_FORMAT)) {\r\n            setSqlFormatEntry(name, value);\r\n        } else if (indicator.startsWith(INDICATOR_JDBC_PREFIX)) {\r\n            setJDBCInfoEntry(dbJdbcInfoMap, name, value, indicator);\r\n        } else if (indicator.equals(INDICATOR_MAXIMUM_LENGTH)) {\r\n            setLengthEntry(name, value);\r\n        } else if (indicator.equals(INDICATOR_TABLE_NAME) || indicator.equals(INDICATOR_COLUMN_NAME) || indicator.equals(INDICATOR_JOIN_TABLE_NAME) || indicator.equals(INDICATOR_CONSTRAINT_NAME)) {\r\n            setNamingEntry(name, value);\r\n        } else {\r\n            setSQLInfoEntry(name, value);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.DeploymentDescriptorNode.resolvePrefix",
	"Comment": "resolve a qname prefix to its corresponding namespace uri bysearching up node chain starting with child.",
	"Method": "String resolvePrefix(XMLElement element,String prefix){\r\n    return element.getPrefixURIMapping(prefix);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.StatementWrapper.setMaxFieldSize",
	"Comment": "sets the limit for the maximum number of bytes in a resultsetcolumn storing character or binary values tothe given number of bytes.this limit appliesonly to binary, varbinary,longvarbinary, char, varchar, andlongvarchar fields.if the limit is exceeded, the excess datais silently discarded. for maximum portability, use valuesgreater than 256.",
	"Method": "void setMaxFieldSize(int max){\r\n    jdbcStatement.setMaxFieldSize(max);\r\n}"
}, {
	"Path": "org.glassfish.resources.admin.cli.DeleteCustomResource.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (domain.getResources().getResourceByName(CustomResource.class, jndiName) == null) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.custom.resource.notfound\", \"A custom resource named {0} does not exist.\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (environment.isDas()) {\r\n        if (\"domain\".equals(target)) {\r\n            if (resourceUtil.getTargetsReferringResourceRef(jndiName).size() > 0) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.custom.resource.resource-ref.exist\", \"custom-resource [ {0} ] is referenced in an\" + \"instance/cluster target, Use delete-resource-ref on appropriate target\", jndiName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        } else {\r\n            if (!resourceUtil.isResourceRefInTarget(jndiName, target)) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.custom.resource.no.resource-ref\", \"custom-resource [ {0} ] is not referenced in target [ {1} ]\", jndiName, target));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n            if (resourceUtil.getTargetsReferringResourceRef(jndiName).size() > 1) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.custom.resource.multiple.resource-refs\", \"custom-resource [ {0} ] is referenced in multiple \" + \"instance/cluster targets, Use delete-resource-ref on appropriate target\", jndiName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        resourceUtil.deleteResourceRef(jndiName, target);\r\n        ConfigSupport.apply(new SingleConfigCode<Resources>() {\r\n            public Object run(Resources param) throws PropertyVetoException, TransactionFailure {\r\n                CustomResource resource = (CustomResource) domain.getResources().getResourceByName(CustomResource.class, jndiName);\r\n                if (resource != null && resource.getJndiName().equals(jndiName)) {\r\n                    return param.getResources().remove(resource);\r\n                }\r\n                return null;\r\n            }\r\n        }, domain.getResources());\r\n        report.setMessage(localStrings.getLocalString(\"delete.custom.resource.success\", \"Custom resource {0} deleted\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (TransactionFailure tfe) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.custom.resource.fail\", \"Unable to delete custom resource {0}\", jndiName) + \" \" + tfe.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.resources.admin.cli.DeleteCustomResource.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    CustomResource resource = (CustomResource) domain.getResources().getResourceByName(CustomResource.class, jndiName);\r\n    if (resource != null && resource.getJndiName().equals(jndiName)) {\r\n        return param.getResources().remove(resource);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.jqlc.ParameterTable.getValueFetcher",
	"Comment": "wraps the actual parameter array into a valuefetcher instnace.",
	"Method": "ValueFetcher getValueFetcher(){\r\n    return new QueryValueFetcher(values.toArray(new Object[values.size()]));\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.StatementWrapper40.isPoolable",
	"Comment": "returns avalue indicating whether the statementis poolable or not.",
	"Method": "boolean isPoolable(){\r\n    return jdbcStatement.isPoolable();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ActiveOutboundResourceAdapter.init",
	"Comment": "creates an active inbound resource adapter. sets all ra java beanproperties and issues a start.",
	"Method": "void init(ResourceAdapter ra,ConnectorDescriptor desc,String moduleName,ClassLoader jcl){\r\n    super.init(ra, desc, moduleName, jcl);\r\n    this.resourceadapter_ = ra;\r\n    if (resourceadapter_ != null) {\r\n        try {\r\n            loadRAConfiguration();\r\n            beanValidator.validateJavaBean(ra, moduleName);\r\n            ConnectorRegistry registry = ConnectorRegistry.getInstance();\r\n            String poolId = null;\r\n            ResourceAdapterConfig raConfig = registry.getResourceAdapterConfig(moduleName_);\r\n            if (raConfig != null) {\r\n                poolId = raConfig.getThreadPoolIds();\r\n            }\r\n            this.bootStrapContextImpl = new BootstrapContextImpl(poolId, moduleName_, jcl);\r\n            validateWorkContextSupport(desc);\r\n            startResourceAdapter(bootStrapContextImpl);\r\n        } catch (ResourceAdapterInternalException ex) {\r\n            _logger.log(Level.SEVERE, \"rardeployment.start_failed\", ex);\r\n            String i18nMsg = localStrings.getString(\"rardeployment.start_failed\", ex.getMessage());\r\n            ConnectorRuntimeException cre = new ConnectorRuntimeException(i18nMsg);\r\n            cre.initCause(ex);\r\n            throw cre;\r\n        } catch (Throwable t) {\r\n            _logger.log(Level.SEVERE, \"rardeployment.start_failed\", t);\r\n            String i18nMsg = localStrings.getString(\"rardeployment.start_failed\", t.getMessage());\r\n            ConnectorRuntimeException cre = new ConnectorRuntimeException(i18nMsg);\r\n            if (t.getCause() != null) {\r\n                cre.initCause(t.getCause());\r\n            } else {\r\n                cre.initCause(t);\r\n            }\r\n            throw cre;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.ActiveJmsResourceAdapter.getMQClusterName",
	"Comment": "generates an name for the mq cluster associated with theapplication server cluster.",
	"Method": "String getMQClusterName(){\r\n    return convertStringToValidMQIdentifier(getClusterName()) + \"_MQ\";\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.getConstructor",
	"Comment": "returns the constructor element for the specified argument types \tin the class with the specified name. types are specified as type \tnames for primitive type such as int, float or as fully qualified \tclass names.",
	"Method": "Object getConstructor(String className,String[] argTypeNames){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.MappingPolicy.load",
	"Comment": "initializes the given properties from the given resourcename.",
	"Method": "void load(String resourceName,Properties properties,boolean override){\r\n    if (logger.isLoggable(Logger.FINE)) {\r\n        logger.fine(\"load resource:\" + resourceName);\r\n    }\r\n    InputStream bin = null;\r\n    InputStream in = null;\r\n    try {\r\n        if (override) {\r\n            in = new FileInputStream(resourceName);\r\n        } else {\r\n            final ClassLoader loader = MappingPolicy.class.getClassLoader();\r\n            in = (InputStream) AccessController.doPrivileged(new PrivilegedAction() {\r\n                public Object run() {\r\n                    Object rc = null;\r\n                    if (loader != null) {\r\n                        rc = loader.getResourceAsStream(resourceName);\r\n                    } else {\r\n                        rc = ClassLoader.getSystemResourceAsStream(resourceName);\r\n                    }\r\n                    return rc;\r\n                }\r\n            });\r\n            if (in == null) {\r\n                throw new IOException(// NOI18N\r\n                I18NHelper.getMessage(// NOI18N\r\n                messages, \"EXC_ResourceNotFound\", resourceName));\r\n            }\r\n        }\r\n        bin = new BufferedInputStream(in);\r\n        properties.load(bin);\r\n        if (logger.isLoggable(Logger.FINE)) {\r\n            logger.fine(\"load \" + resourceName + \" successfuly\");\r\n        }\r\n    } finally {\r\n        try {\r\n            bin.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.MappingPolicy.load",
	"Comment": "initializes the given properties from the given resourcename.",
	"Method": "void load(String resourceName,Properties properties,boolean override){\r\n    Object rc = null;\r\n    if (loader != null) {\r\n        rc = loader.getResourceAsStream(resourceName);\r\n    } else {\r\n        rc = ClassLoader.getSystemResourceAsStream(resourceName);\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.UtilHandlers.convertMapToListOfMap",
	"Comment": "this method converts a map into a list of map with keyname and valuename.this is suitable for table dislay.",
	"Method": "void convertMapToListOfMap(HandlerContext handlerCtx){\r\n    Map map = ((Map) handlerCtx.getInputValue(\"map\"));\r\n    String keyName = ((String) handlerCtx.getInputValue(\"keyName\"));\r\n    String valueName = ((String) handlerCtx.getInputValue(\"valueName\"));\r\n    List result = new ArrayList();\r\n    for (Map.Entry entry : (Set<Map.Entry>) map.entrySet()) {\r\n        Map oneRow = new HashMap();\r\n        oneRow.put(keyName, entry.getKey());\r\n        oneRow.put(valueName, entry.getValue());\r\n        result.add(oneRow);\r\n    }\r\n    handlerCtx.setOutputValue(\"result\", result);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOConcreteBean20Generator.validate",
	"Comment": "validate this cmp bean. at this point, only ejbql validation is done for2.0 cmp beans. adds validation result to that of the super class.",
	"Method": "Collection validate(AbstractMethodHelper methodHelper,String beanName){\r\n    Collection rc = super.validate(methodHelper, beanName);\r\n    this.beanName = beanName;\r\n    rc.addAll(validateEJBQL(methodHelper));\r\n    return rc;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ee.SecuritySniffer.tearDown",
	"Comment": "tears down a container, remove all imported libraries from the modulesubsystem.",
	"Method": "void tearDown(){\r\n    if (lifecycle != null) {\r\n        lifecycle.destroy();\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.setURL",
	"Comment": "sets the designated parameter to the given java.net.url object.the driver converts this to an sql datalink value whenit sends it to the database.",
	"Method": "void setURL(String parameterName,URL val){\r\n    callableStatement.setURL(parameterName, val);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.webservices.CommonServerSecurityTube.preDestroy",
	"Comment": "this method is called once in server side and at most one in client side.",
	"Method": "void preDestroy(){\r\n    helper.disable();\r\n    next.preDestroy();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getBytes",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object asa byte array in the java programming language.the bytes represent the raw values returned by the driver.",
	"Method": "byte[] getBytes(int columnIndex,byte[] getBytes,String columnName){\r\n    return resultSet.getBytes(columnName);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.getReadObjectArgs",
	"Comment": "standard set of arguments for comparison with readobject method.",
	"Method": "String[] getReadObjectArgs(){\r\n    return new String[] { \"java.io.ObjectInputStream\" };\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.prepareToUpdatePhaseIII",
	"Comment": "this is the third phase of commit processing. it sets up the delete dependencies amongall the autopersistent instances that have been flushed to the database.",
	"Method": "void prepareToUpdatePhaseIII(){\r\n    boolean debug = logger.isLoggable();\r\n    if (debug) {\r\n        // NOI18N\r\n        logger.fine(\"sqlstore.sqlstatemanager.preparetoupdateph3\", persistenceConfig.getPersistenceCapableClass().getName());\r\n    }\r\n    if (!state.isPersistentInDataStore()) {\r\n        if (updateDesc != null) {\r\n            updateDesc.clearUpdatedJoinTableRelationships();\r\n        }\r\n        return;\r\n    }\r\n    ArrayList foreignFields = persistenceConfig.foreignFields;\r\n    int size = foreignFields.size();\r\n    for (int i = 0; i < size; i++) {\r\n        ForeignFieldDesc ff = (ForeignFieldDesc) foreignFields.get(i);\r\n        if (ff.cardinalityUPB <= 1) {\r\n            if (getPresenceMaskBit(ff.absoluteID)) {\r\n                Object v = ff.getValue(this);\r\n                if (v != null) {\r\n                    updateObjectField(ff, null, false, false);\r\n                }\r\n            }\r\n        } else {\r\n            Collection c = getCollectionValue(ff);\r\n            if (c != null) {\r\n                if (c.size() > 0) {\r\n                    ArrayList removed = new ArrayList(c);\r\n                    ArrayList added = null;\r\n                    processCollectionUpdates(ff, removed, added, null, false, false);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (debug) {\r\n        logger.fine(\"sqlstore.sqlstatemanager.preparetoupdateph3.exit\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.initializeContext",
	"Comment": "initializes this instance from another archivist, this is usedto transfer contextual information between archivists, forexample whether we should handle runtime information and such",
	"Method": "void initializeContext(Archivist other){\r\n    handleRuntimeInfo = other.isHandlingRuntimeInfo();\r\n    annotationProcessingRequested = other.isAnnotationProcessingRequested();\r\n    isValidatingXML = other.isValidatingXML;\r\n    validationLevel = other.validationLevel;\r\n    classLoader = other.classLoader;\r\n    annotationErrorHandler = other.annotationErrorHandler;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.TypeSupport.isNumericWrapperType",
	"Comment": "returns true if type is a wrapper class of a primitive numeric type such as java.lang.byte, java.lang.integer etc.",
	"Method": "boolean isNumericWrapperType(Object type){\r\n    return numericWrapperTypes.contains(type);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.getQueryTimeout",
	"Comment": "gets the number of seconds to wait for a query statementto execute in the datastore associated with this persistencemanagerfactory.",
	"Method": "int getQueryTimeout(){\r\n    return _persistenceManagerFactory.getQueryTimeout();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.PreparedStatementWrapper.setLong",
	"Comment": "sets the designated parameter to the given java long value.the driver converts thisto an sql bigint value when it sends it to the database.",
	"Method": "void setLong(int parameterIndex,long x){\r\n    preparedStatement.setLong(parameterIndex, x);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.introspection.ConstantPoolInfo.containsAnnotation",
	"Comment": "read the input channel and initialize instance datastructure.",
	"Method": "boolean containsAnnotation(int constantPoolSize,ByteBuffer buffer){\r\n    for (int i = 1; i < constantPoolSize; i++) {\r\n        final byte type = buffer.get();\r\n        switch(type) {\r\n            case ASCIZ:\r\n            case UNICODE:\r\n                final short length = buffer.getShort();\r\n                if (length < 0) {\r\n                    return true;\r\n                }\r\n                buffer.get(bytes, 0, length);\r\n                if (bytes[0] == 'L' && bytes[1] == 'j' && bytes[2] == 'a') {\r\n                    String stringValue;\r\n                    if (type == ASCIZ) {\r\n                        stringValue = new String(bytes, 0, length, \"US-ASCII\");\r\n                    } else {\r\n                        stringValue = new String(bytes, 0, length);\r\n                    }\r\n                    if (scanner.isAnnotation(stringValue)) {\r\n                        return true;\r\n                    }\r\n                }\r\n                break;\r\n            case CLASS:\r\n            case STRING:\r\n                buffer.getShort();\r\n                break;\r\n            case FIELDREF:\r\n            case METHODREF:\r\n            case INTERFACEMETHODREF:\r\n            case INTEGER:\r\n            case FLOAT:\r\n                buffer.position(buffer.position() + 4);\r\n                break;\r\n            case LONG:\r\n            case DOUBLE:\r\n                buffer.position(buffer.position() + 8);\r\n                i++;\r\n                break;\r\n            case NAMEANDTYPE:\r\n                buffer.getShort();\r\n                buffer.getShort();\r\n                break;\r\n            default:\r\n                DOLUtils.getDefaultLogger().severe(\"Unknow type constant pool \" + type + \" at position\" + i);\r\n                break;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.copyAnEntry",
	"Comment": "only copy the entry if the destination archive does not have this entry",
	"Method": "void copyAnEntry(ReadableArchive in,WritableArchive out,String entryName){\r\n    InputStream is = null;\r\n    InputStream is2 = null;\r\n    ReadableArchive in2 = archiveFactory.openArchive(out.getURI());\r\n    try {\r\n        is = in.getEntry(entryName);\r\n        is2 = in2.getEntry(entryName);\r\n        if (is != null && is2 == null) {\r\n            OutputStream os = out.putNextEntry(entryName);\r\n            ArchivistUtils.copyWithoutClose(is, os);\r\n        }\r\n    } finally {\r\n        in2.close();\r\n        if (is != null) {\r\n            is.close();\r\n        }\r\n        if (is2 != null) {\r\n            is2.close();\r\n        }\r\n        out.closeEntry();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.TypeSupport.isRelationship",
	"Comment": "returns true if the specified field info denotes a relationship field.",
	"Method": "boolean isRelationship(Object fieldInfo){\r\n    return (fieldInfo != null) && (fieldInfo instanceof RelationshipElement);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.ConnectionPoolObjectsUtils.setLazyEnlistAndLazyAssocProperties",
	"Comment": "validates and sets the values for lazyconnectionenlistment and lazyconnectionassociation.",
	"Method": "void setLazyEnlistAndLazyAssocProperties(String lazyAssocString,List<Property> properties,ConnectorConnectionPool conConnPool){\r\n    if (properties == null)\r\n        return;\r\n    Property lazyEnlistElement = null;\r\n    for (Property property : properties) {\r\n        if (property.getName().equalsIgnoreCase(\"LAZYCONNECTIONENLISTMENT\")) {\r\n            lazyEnlistElement = property;\r\n        }\r\n    }\r\n    boolean lazyAssoc = toBoolean(lazyAssocString, false);\r\n    if (lazyEnlistElement != null) {\r\n        boolean lazyEnlist = toBoolean(lazyEnlistElement.getValue(), false);\r\n        if (lazyAssoc) {\r\n            if (lazyEnlist) {\r\n                conConnPool.setLazyConnectionAssoc(true);\r\n                conConnPool.setLazyConnectionEnlist(true);\r\n            } else {\r\n                _logger.log(Level.SEVERE, \"conn_pool_obj_utils.lazy_enlist-lazy_assoc-invalid-combination\", conConnPool.getName());\r\n                String i18nMsg = localStrings.getString(\"cpou.lazy_enlist-lazy_assoc-invalid-combination\");\r\n                throw new RuntimeException(i18nMsg + conConnPool.getName());\r\n            }\r\n        } else {\r\n            conConnPool.setLazyConnectionAssoc(false);\r\n        }\r\n    } else {\r\n        if (lazyAssoc) {\r\n            conConnPool.setLazyConnectionAssoc(true);\r\n            conConnPool.setLazyConnectionEnlist(true);\r\n        } else {\r\n            conConnPool.setLazyConnectionAssoc(false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.ConnectionFactoryImpl.getMinPool",
	"Comment": "returns minimum number of connections in the connection pool",
	"Method": "int getMinPool(){\r\n    return minPool;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.isValid",
	"Comment": "checks if a managedconnection is to be validated or notand validates it or returns.",
	"Method": "void isValid(ManagedConnectionImpl mc){\r\n    if (mc == null || mc.isTransactionInProgress()) {\r\n        return;\r\n    }\r\n    String conVal = spec.getDetail(DataSourceSpec.CONNECTIONVALIDATIONREQUIRED);\r\n    boolean connectionValidationRequired = (conVal == null) ? false : Boolean.valueOf(conVal.toLowerCase(Locale.getDefault()));\r\n    if (!connectionValidationRequired) {\r\n        return;\r\n    }\r\n    String validationMethod = spec.getDetail(DataSourceSpec.VALIDATIONMETHOD).toLowerCase(Locale.getDefault());\r\n    mc.checkIfValid();\r\n    java.sql.Connection con = mc.getActualConnection();\r\n    if (validationMethod.equals(\"custom-validation\")) {\r\n        isValidByCustomValidation(con, spec.getDetail(DataSourceSpec.VALIDATIONCLASSNAME));\r\n    } else if (validationMethod.equals(\"auto-commit\")) {\r\n        isValidByAutoCommit(con);\r\n    } else if (validationMethod.equals(\"meta-data\")) {\r\n        isValidByMetaData(con);\r\n    } else if (validationMethod.equals(\"table\")) {\r\n        isValidByTableQuery(con, spec.getDetail(DataSourceSpec.VALIDATIONTABLENAME));\r\n    } else {\r\n        throw new ResourceException(\"The validation method is not proper\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.TypeSupport.binaryNumericPromotion",
	"Comment": "implements binary numeric promotion as defined in the java language specification section 5.6.2",
	"Method": "Object binaryNumericPromotion(Object left,Object right){\r\n    if (isNumericType(left) && isNumericType(right)) {\r\n        if (left.equals(doubleType) || right.equals(doubleType))\r\n            return doubleType;\r\n        else if (left.equals(floatType) || right.equals(floatType))\r\n            return floatType;\r\n        else if (left.equals(longType) || right.equals(longType))\r\n            return longType;\r\n        else\r\n            return intType;\r\n    }\r\n    return errorType;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.connector.module.ConnectorSniffer.setup",
	"Comment": "sets up the container libraries so that any imported bundle from theconnector jar file will now be known to the module subsystem",
	"Method": "Module[] setup(String containerHome,Logger logger){\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.CreateAdminObject.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    HashMap attrList = new HashMap();\r\n    attrList.put(RES_TYPE, resType);\r\n    attrList.put(ADMIN_OBJECT_CLASS_NAME, className);\r\n    attrList.put(ResourceConstants.ENABLED, enabled.toString());\r\n    attrList.put(JNDI_NAME, jndiName);\r\n    attrList.put(ServerTags.DESCRIPTION, description);\r\n    attrList.put(RES_ADAPTER, raName);\r\n    ResourceStatus rs;\r\n    try {\r\n        AdminObjectManager adminObjMgr = adminObjectManagerProvider.get();\r\n        rs = adminObjMgr.create(domain.getResources(), attrList, properties, target);\r\n    } catch (Exception e) {\r\n        Logger.getLogger(CreateAdminObject.class.getName()).log(Level.SEVERE, \"Something went wrong in create-admin-object\", e);\r\n        String def = \"Admin object: {0} could not be created, reason: {1}\";\r\n        report.setMessage(localStrings.getLocalString(\"create.admin.object.fail\", def, jndiName) + \" \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    ActionReport.ExitCode ec = ActionReport.ExitCode.SUCCESS;\r\n    if (rs.getMessage() != null) {\r\n        report.setMessage(rs.getMessage());\r\n    }\r\n    if (rs.getStatus() == ResourceStatus.FAILURE) {\r\n        ec = ActionReport.ExitCode.FAILURE;\r\n        if (rs.getMessage() == null) {\r\n            report.setMessage(localStrings.getLocalString(\"create.admin.object.fail\", \"Admin object {0} creation failed\", jndiName, \"\"));\r\n        }\r\n        if (rs.getException() != null)\r\n            report.setFailureCause(rs.getException());\r\n    }\r\n    report.setActionExitCode(ec);\r\n}"
}, {
	"Path": "org.glassfish.resources.javamail.LogOutputStream.expandCapacity",
	"Comment": "ensure that the buffer can hold at least len bytesbeyond the current position.",
	"Method": "void expandCapacity(int len){\r\n    while (pos + len > buf.length) {\r\n        byte[] nb = new byte[buf.length * 2];\r\n        System.arraycopy(buf, 0, nb, 0, pos);\r\n        buf = nb;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.provider.PolicyConfigurationImpl.delete",
	"Comment": "causes all policy statements to be deleted from this policyconfiguration and sets its internal state such that calling any method, other than delete, getcontextid, or inservice on the policyconfiguration willbe rejected and cause an unsupportedoperationexception to be thrown.this operation has no affect on any linked policyconfigurations other than removing any links involving the deleted policyconfiguration.",
	"Method": "void delete(){\r\n    checkSetPolicyPermission();\r\n    synchronized (refreshLock) {\r\n        try {\r\n            removePolicy();\r\n        } finally {\r\n            setState(DELETED_STATE);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerWrapper.newCollectionInstance",
	"Comment": "returns a new collection instance of the type specified, with theowner and field name to notify upon changes to the value of any of its fields.the collection class restricts the element types allowed to the elementtype orinstances assignable to the elementtype, and allows nulls to be added aselements based on the setting of allownulls. the collection has an initial sizeas specified by the initialsize parameter.",
	"Method": "Object newCollectionInstance(Class type,Object owner,String fieldName,Class elementType,boolean allowNulls,int initialSize){\r\n    if (isValid) {\r\n        return pm.newCollectionInstance(type, owner, fieldName, elementType, allowNulls, initialSize);\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerwrapper.invalidpm\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.AbstractMethodHelper.getDescriptor",
	"Comment": "gets the ejbcmpentitydescriptor which defines the \tinformation for this bean.",
	"Method": "EjbCMPEntityDescriptor getDescriptor(){\r\n    return _cmpDescriptor;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.CPManagedConnectionFactory.createManagedConnection",
	"Comment": "creates a new physical connection to the underlying eis resourcemanager.",
	"Method": "javax.resource.spi.ManagedConnection createManagedConnection(javax.security.auth.Subject subject,ConnectionRequestInfo cxRequestInfo){\r\n    logFine(\"In createManagedConnection\");\r\n    PasswordCredential pc = SecurityUtils.getPasswordCredential(this, subject, cxRequestInfo);\r\n    javax.sql.ConnectionPoolDataSource dataSource = getDataSource();\r\n    javax.sql.PooledConnection cpConn = null;\r\n    ManagedConnectionImpl mc = null;\r\n    try {\r\n        if (isEqual(pc, getUser(), getPassword())) {\r\n            cpConn = dataSource.getPooledConnection();\r\n        } else {\r\n            cpConn = dataSource.getPooledConnection(pc.getUserName(), new String(pc.getPassword()));\r\n        }\r\n    } catch (java.sql.SQLException sqle) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"jdbc.exc_create_ds_conn\", sqle);\r\n        }\r\n        StringManager sm = StringManager.getManager(DataSourceObjectBuilder.class);\r\n        String msg = sm.getString(\"jdbc.cannot_allocate_connection\", sqle.getMessage());\r\n        ResourceAllocationException rae = new ResourceAllocationException(msg, sqle);\r\n        throw rae;\r\n    }\r\n    try {\r\n        mc = constructManagedConnection(cpConn, null, pc, this);\r\n        mc.initializeConnectionType(ManagedConnectionImpl.ISPOOLEDCONNECTION);\r\n        validateAndSetIsolation(mc);\r\n    } finally {\r\n        if (mc == null) {\r\n            if (cpConn != null) {\r\n                try {\r\n                    cpConn.close();\r\n                } catch (SQLException e) {\r\n                    _logger.log(Level.FINEST, \"Exception while closing connection : createManagedConnection\" + cpConn);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return mc;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jmac.config.ConfigHelper.getHandlerContext",
	"Comment": "this method is invoked by the constructor and should beoverrided by subclass.",
	"Method": "HandlerContext getHandlerContext(Map map){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getDatabaseMajorVersion",
	"Comment": "retrieves the major version number of the underlying database.",
	"Method": "int getDatabaseMajorVersion(){\r\n    return databaseMetaData.getDatabaseMajorVersion();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.BucketizedHashtable.clone",
	"Comment": "creates and returns a shallow copy of this object.the keys and values are not cloned.",
	"Method": "Object clone(){\r\n    try {\r\n        BucketizedHashtable bt = (BucketizedHashtable) super.clone();\r\n        bt.bucketSize = bucketSize;\r\n        bt.hashtables = new Hashtable[bucketSize];\r\n        for (int i = 0; i < bucketSize; i++) {\r\n            bt.hashtables[i] = (Hashtable) hashtables[i].clone();\r\n        }\r\n        return bt;\r\n    } catch (CloneNotSupportedException e) {\r\n        throw new InternalError();\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ProfiledConnectionWrapper40.prepareCall",
	"Comment": "creates acallablestatementobject for calling databasestored procedures.",
	"Method": "CallableStatement prepareCall(String sql,CallableStatement prepareCall,String sql,int resultSetType,int resultSetConcurrency,CallableStatement prepareCall,String sql,int resultSetType,int resultSetConcurrency,int resultSetHoldability){\r\n    CallableStatement output = null;\r\n    Class[] intf = new Class[] { java.sql.CallableStatement.class };\r\n    try {\r\n        output = (java.sql.CallableStatement) getProxyObject(mc.prepareCachedCallableStatement(this, sql, resultSetType, resultSetConcurrency, resultSetHoldability), intf);\r\n    } catch (Exception e) {\r\n        throw new SQLException(e);\r\n    }\r\n    return output;\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.ACCLogger.chooseLevel",
	"Comment": "returns the logging level to use, checking the configured log level andusing the default if the configured value is absent or invalid.",
	"Method": "Level chooseLevel(LogService logService){\r\n    Level level = DEFAULT_ACC_LOG_LEVEL;\r\n    if (logService != null) {\r\n        String configLevelText = logService.getLevel();\r\n        if (configLevelText != null && (!configLevelText.equals(\"\"))) {\r\n            try {\r\n                level = Level.parse(configLevelText);\r\n            } catch (IllegalArgumentException e) {\r\n                Logger.getLogger(ACCLogger.class.getName()).warning(\"Logger.Level = \" + configLevelText + \"??\");\r\n            }\r\n        }\r\n    }\r\n    return level;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingFieldElementImpl.getConcurrencyGroups",
	"Comment": "returns the array of concurrency groups to which this field belongs.",
	"Method": "ConcurrencyGroupElement[] getConcurrencyGroups(){\r\n    return getPersistenceFieldElement().getConcurrencyGroups();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.findClassLoader",
	"Comment": "this method returns the class loader used to find mapping information \tfor the specified classname.if the classloader argument is not null, \tthe method updates the classloaders cache and returns the specified \tclassloader.otherwise it checks the cache for the specified classname \tand returns this class loader.if there is no cached class loader it \treturns the current class loader.",
	"Method": "ClassLoader findClassLoader(String className,ClassLoader classLoader){\r\n    ClassLoader cached = null;\r\n    if (className == null)\r\n        return null;\r\n    else if (className.startsWith(JAVA_PACKAGE) || isPrimitive(className))\r\n        return getClass().getClassLoader();\r\n    synchronized (classLoaders) {\r\n        cached = (ClassLoader) classLoaders.get(className);\r\n        if (classLoader == null) {\r\n            classLoader = (cached != null) ? cached : getClass().getClassLoader();\r\n        } else if (cached == null) {\r\n            classLoaders.put(className, classLoader);\r\n        } else if (classLoader != cached) {\r\n            Class clazz = null;\r\n            Class cachedClazz = null;\r\n            try {\r\n                String prop = ClassLoaderStrategy.getStrategy();\r\n                clazz = Class.forName(className, true, classLoader);\r\n                cachedClazz = Class.forName(className, true, cached);\r\n                if (clazz.getClassLoader() == cachedClazz.getClassLoader()) {\r\n                    return cached;\r\n                } else if (ClassLoaderStrategy.MULTIPLE_CLASS_LOADERS_IGNORE.equals(prop)) {\r\n                    return cached;\r\n                } else if (ClassLoaderStrategy.MULTIPLE_CLASS_LOADERS_RELOAD.equals(prop)) {\r\n                    removeResourcesFromCaches(cachedClazz.getClassLoader());\r\n                    classLoaders.put(className, classLoader);\r\n                    return classLoader;\r\n                } else {\r\n                    throw new IllegalArgumentException(// NOI18N\r\n                    I18NHelper.getMessage(getMessages(), \"classloader.multiple\", className));\r\n                }\r\n            } catch (ClassNotFoundException ex) {\r\n                if ((clazz != null) && (cachedClazz == null))\r\n                    classLoaders.put(className, classLoader);\r\n            }\r\n        }\r\n    }\r\n    return classLoader;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MailConfiguration.getMailStoreProtocol",
	"Comment": "get the default message access protocol for the mail session theserverwill provide.",
	"Method": "String getMailStoreProtocol(){\r\n    return this.storeProtocol;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingTableElementImpl.removeReference",
	"Comment": "removes the referencing key for the supplied table element from list \tof keys in this mapping table.",
	"Method": "void removeReference(MappingTableElement table){\r\n    if (table != null) {\r\n        Iterator keyIterator = getReferencingKeys().iterator();\r\n        while (keyIterator.hasNext()) {\r\n            MappingReferenceKeyElement nextKey = (MappingReferenceKeyElement) keyIterator.next();\r\n            if (nextKey.getTable().equals(table)) {\r\n                try {\r\n                    fireVetoableChange(PROP_REFERENCING_KEYS, null, null);\r\n                    keyIterator.remove();\r\n                    firePropertyChange(PROP_REFERENCING_KEYS, null, null);\r\n                } catch (PropertyVetoException e) {\r\n                    throw new ModelVetoException(e);\r\n                }\r\n            }\r\n        }\r\n    } else {\r\n        throw new ModelException(// NOI18N\r\n        I18NHelper.getMessage(getMessages(), \"mapping.element.null_argument\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.destroy",
	"Comment": "destroys the physical connection to the underlying resource manager.",
	"Method": "void destroy(){\r\n    logFine(\"In destroy\");\r\n    if (isDestroyed) {\r\n        return;\r\n    }\r\n    clearStatementCache();\r\n    if (leakDetector != null) {\r\n        leakDetector.clearAllStatementLeakTasks();\r\n    }\r\n    try {\r\n        if (connectionType == ISXACONNECTION || connectionType == ISPOOLEDCONNECTION) {\r\n            pc.close();\r\n            pc = null;\r\n            actualConnection = null;\r\n        } else {\r\n            actualConnection.close();\r\n            actualConnection = null;\r\n        }\r\n    } catch (SQLException sqle) {\r\n        isDestroyed = true;\r\n        passwdCredential = null;\r\n        connectionHandles = null;\r\n        String i18nMsg = localStrings.getString(\"jdbc.error_in_destroy\");\r\n        ResourceException re = new ResourceException(i18nMsg + sqle.getMessage(), sqle);\r\n        throw re;\r\n    }\r\n    isDestroyed = true;\r\n    passwdCredential = null;\r\n    connectionHandles = null;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.JmsResourceHandler.getJmsResourcesInfo",
	"Comment": "this handler return the list of jms resources to be displayed in the table.",
	"Method": "void getJmsResourcesInfo(HandlerContext handlerCtx){\r\n    List<Map<String, Object>> resourcesList = (List) handlerCtx.getInputValue(\"resourcesList\");\r\n    Boolean isConnectionFactory = (Boolean) handlerCtx.getInputValue(\"isConnectionFactory\");\r\n    String prefix = isConnectionFactory ? GuiUtil.getSessionValue(\"REST_URL\") + \"/resources/connector-resource/\" : GuiUtil.getSessionValue(\"REST_URL\") + \"/resources/admin-object-resource/\";\r\n    try {\r\n        for (Map<String, Object> one : resourcesList) {\r\n            String encodedName = URLEncoder.encode((String) one.get(\"name\"), \"UTF-8\");\r\n            String endpoint = prefix + encodedName;\r\n            Map attrs = (Map) RestUtil.getAttributesMap(endpoint);\r\n            String desc = null;\r\n            if (isConnectionFactory) {\r\n                String poolName = URLEncoder.encode((String) attrs.get(\"poolName\"), \"UTF-8\");\r\n                String e1 = (String) GuiUtil.getSessionValue(\"REST_URL\") + \"/resources/connector-connection-pool/\" + poolName;\r\n                Map poolAttrs = (Map) RestUtil.getAttributesMap(e1);\r\n                one.put(\"resType\", (String) poolAttrs.get(\"connectionDefinitionName\"));\r\n                String lname = (String) one.get(\"logical-jndi-name\");\r\n                one.put(\"logicalJndiName\", (lname == null) ? \"\" : lname);\r\n                one.put(\"encodedPoolName\", poolName);\r\n                one.put(\"objectType\", (String) attrs.get(\"objectType\"));\r\n                desc = (String) poolAttrs.get(\"description\");\r\n            } else {\r\n                one.put(\"resType\", (String) attrs.get(\"resType\"));\r\n                desc = (String) attrs.get(\"description\");\r\n            }\r\n            one.put(\"selected\", false);\r\n            one.put(\"enabled\", (String) attrs.get(\"enabled\"));\r\n            one.put(\"encodedName\", encodedName);\r\n            one.put(\"description\", (desc == null) ? \"\" : desc);\r\n        }\r\n    } catch (Exception ex) {\r\n        GuiUtil.getLogger().info(GuiUtil.getCommonMessage(\"log.error.getJMSResources\") + ex.getLocalizedMessage());\r\n        if (GuiUtil.getLogger().isLoggable(Level.FINE)) {\r\n            ex.printStackTrace();\r\n        }\r\n    }\r\n    handlerCtx.setOutputValue(\"result\", resourcesList);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxColumnsInOrderBy",
	"Comment": "retrieves the maximum number of columns this database allows in anorder by clause.",
	"Method": "int getMaxColumnsInOrderBy(){\r\n    return databaseMetaData.getMaxColumnsInOrderBy();\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolProbeProviderUtil.getJcaProbeProvider",
	"Comment": "get probe provider for connector connection pool related events",
	"Method": "ConnectionPoolProbeProvider getJcaProbeProvider(){\r\n    return jcaProbeProvider;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.DataSource.getConnection",
	"Comment": "retrieves the actual sqlconnection from the connection wrapperimplementation of sunone application server. if an actual connection issupplied as argument, then it will be just returned.",
	"Method": "Connection getConnection(Connection getConnection,String user,String pwd,Connection getConnection,Connection con){\r\n    Connection driverCon = con;\r\n    if (con instanceof com.sun.jdbcra.spi.ConnectionHolder) {\r\n        driverCon = ((com.sun.jdbcra.spi.ConnectionHolder) con).getConnection();\r\n    }\r\n    return driverCon;\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecServerRequestInterceptor.createSvcContext",
	"Comment": "cdr encode a sas context body and then construct a service context element.",
	"Method": "ServiceContext createSvcContext(SASContextBody sasctxtbody,ORB orb){\r\n    ServiceContext sc = null;\r\n    Any a = orb.create_any();\r\n    SASContextBodyHelper.insert(a, sasctxtbody);\r\n    byte[] cdr_encoded_saselm = {};\r\n    try {\r\n        cdr_encoded_saselm = codec.encode_value(a);\r\n    } catch (Exception e) {\r\n        _logger.log(Level.SEVERE, \"iiop.encode_exception\", e);\r\n    }\r\n    sc = new ServiceContext();\r\n    sc.context_id = SECURITY_ATTRIBUTE_SERVICE_ID;\r\n    sc.context_data = cdr_encoded_saselm;\r\n    return sc;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.JDOEJB11HelperImpl.assertPrimaryKeyNotNull",
	"Comment": "validates that the primary key instance is not null.throws illegalargumentexception otherwise.",
	"Method": "void assertPrimaryKeyNotNull(Object pk){\r\n    if (pk == null) {\r\n        throw new IllegalArgumentException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"EXC_pknull_exception\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsCatalogsInIndexDefinitions",
	"Comment": "retrieves whether a catalog name can be used in an index definition statement.",
	"Method": "boolean supportsCatalogsInIndexDefinitions(){\r\n    return databaseMetaData.supportsCatalogsInIndexDefinitions();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.Statement.getColumnElementForValueNode",
	"Comment": "gets the column information for the field to which nodeis bound.",
	"Method": "ColumnElement getColumnElementForValueNode(ConstraintValue node){\r\n    ColumnElement columnElement = null;\r\n    LocalFieldDesc field = node.getLocalField();\r\n    if (field != null) {\r\n        columnElement = field.getPrimaryColumn();\r\n    }\r\n    return columnElement;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectorConnPoolStatsProvider.connectionRequestServedEvent",
	"Comment": "event that a connection request is served in timetakeninmillis.",
	"Method": "void connectionRequestServedEvent(String poolName,String appName,String moduleName,long timeTakenInMillis){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (logger.isLoggable(Level.FINEST)) {\r\n            logger.finest(\"Connection request served event received - \" + \"poolName = \" + poolName);\r\n        }\r\n        connRequestWaitTime.setCurrent(timeTakenInMillis);\r\n        totalConnRequestWaitTime.increment(timeTakenInMillis);\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBTimerSchedule.isValid",
	"Comment": "returns true if this schedule can calculate its next timeoutwithout errors.",
	"Method": "boolean isValid(ScheduledTimerDescriptor s){\r\n    EJBTimerSchedule ts = new EJBTimerSchedule(s, null, 0);\r\n    ts.getNextTimeout();\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.Vector.cloneInternal",
	"Comment": "creates and returns a copy of this object without resetting the owner and field value.",
	"Method": "Object cloneInternal(){\r\n    return super.clone();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.setConnectionMsWait",
	"Comment": "sets the number of milliseconds to wait for an available connectionfrom the connection pool before throwing an exception",
	"Method": "void setConnectionMsWait(int MsWait){\r\n    throw new JDOUnsupportedOptionException(// NOI18N\r\n    I18NHelper.getMessage(messages, \"jdo.persistencemanagerfactoryimpl.notsupported\"));\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBLocalObjectImpl.getSerializableObjectFactory",
	"Comment": "called from ejbutils.ejbobjectoutputstream.replaceobject",
	"Method": "SerializableObjectFactory getSerializableObjectFactory(){\r\n    return new SerializableLocalObject(container.getEjbDescriptor().getUniqueId(), isLocalHomeView, isOptionalLocalBusinessView, primaryKey, getSfsbClientVersion());\r\n}"
}, {
	"Path": "org.glassfish.ejb.embedded.EJBContainerImpl.getContext",
	"Comment": "retrieve a naming context for looking up references to session beansexecuting in the embeddable container.",
	"Method": "Context getContext(){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"IN getContext()\");\r\n    }\r\n    try {\r\n        return new InitialContext();\r\n    } catch (Exception e) {\r\n        throw new EJBException(_logger.getResourceBundle().getString(\"ejb.embedded.cannot_create_context\"), e);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.jdbc.admin.cli.ListJdbcConnectionPools.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        Collection<JdbcConnectionPool> connPools = domain.getResources().getResources(JdbcConnectionPool.class);\r\n        for (JdbcConnectionPool pool : connPools) {\r\n            final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n            part.setMessage(pool.getName());\r\n        }\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.jdbc.connection.pools.failed\", \"List JDBC connection pools failed\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.getFields",
	"Comment": "returns the collection of fields maintained by this holder in the form\tof an array.",
	"Method": "PersistenceFieldElement[] getFields(PersistenceFieldElement[] getFields){\r\n    return getClassImpl().getFields();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createFieldPersistenceComponent",
	"Comment": "create a validation component which can check whether the field is\tpersistent.",
	"Method": "ValidationComponent createFieldPersistenceComponent(PersistenceFieldElement field){\r\n    return new ValidationComponent() {\r\n        public void validate() throws ModelValidationException {\r\n            boolean isPersistent = (PersistenceFieldElement.PERSISTENT == field.getPersistenceType());\r\n            String fieldName = field.getName();\r\n            if (isPersistent && !isPersistentAllowed(getClassName(), fieldName)) {\r\n                throw constructFieldException(fieldName, \"util.validation.field_persistent_not_allowed\");\r\n            }\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createFieldPersistenceComponent",
	"Comment": "create a validation component which can check whether the field is\tpersistent.",
	"Method": "ValidationComponent createFieldPersistenceComponent(PersistenceFieldElement field){\r\n    boolean isPersistent = (PersistenceFieldElement.PERSISTENT == field.getPersistenceType());\r\n    String fieldName = field.getName();\r\n    if (isPersistent && !isPersistentAllowed(getClassName(), fieldName)) {\r\n        throw constructFieldException(fieldName, \"util.validation.field_persistent_not_allowed\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsCorrelatedSubqueries",
	"Comment": "retrieves whether this database supports correlated subqueries.",
	"Method": "boolean supportsCorrelatedSubqueries(){\r\n    return databaseMetaData.supportsCorrelatedSubqueries();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MessageDestinationReferenceDescriptor.setReferringBundleDescriptor",
	"Comment": "set the referring bundle, i.e. the bundle within which thismessage destination reference is declared.",
	"Method": "void setReferringBundleDescriptor(BundleDescriptor referringBundle){\r\n    this.referringBundle = referringBundle;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.oracle.OracleSpecialDBOperation.initialize",
	"Comment": "initializes driver specific behavior classes by determining thecharacteristics of the jdbc driver used with this datasource.",
	"Method": "void initialize(DatabaseMetaData metaData,String identifier){\r\n    Connection con = metaData.getConnection();\r\n    PreparedStatement testPs = con.prepareStatement(TEST_STATEMENT);\r\n    {\r\n        dBDriverHandlerFactory = new DBDriverHandlerFactory() {\r\n            public DBDriverHandler createDBDriverHandler(PreparedStatement ps) {\r\n                return new NonOracleHandler(ps);\r\n            }\r\n            public boolean supportsDefineColumnType() {\r\n                return false;\r\n            }\r\n        };\r\n        if (logger.isLoggable(logger.CONFIG)) {\r\n            identifier = // NOI18N\r\n            identifier == null ? \"Connection Factory\" : identifier;\r\n            // NOI18N\r\n            logger.log(logger.CONFIG, \"sqlstore.database.oracle.nooracleavailable\", identifier);\r\n        }\r\n    }\r\n    testPs.close();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.oracle.OracleSpecialDBOperation.initialize",
	"Comment": "initializes driver specific behavior classes by determining thecharacteristics of the jdbc driver used with this datasource.",
	"Method": "void initialize(DatabaseMetaData metaData,String identifier){\r\n    return new NonOracleHandler(ps);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.oracle.OracleSpecialDBOperation.initialize",
	"Comment": "initializes driver specific behavior classes by determining thecharacteristics of the jdbc driver used with this datasource.",
	"Method": "void initialize(DatabaseMetaData metaData,String identifier){\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ConnectionHolder.prepareStatement",
	"Comment": "creates apreparedstatementobject for sending paramterized sql statements to database",
	"Method": "PreparedStatement prepareStatement(String sql,PreparedStatement prepareStatement,String sql,int autoGeneratedKeys,PreparedStatement prepareStatement,String sql,int[] columnIndexes,PreparedStatement prepareStatement,String sql,int resultSetType,int resultSetConcurrency,PreparedStatement prepareStatement,String sql,int resultSetType,int resultSetConcurrency,int resultSetHoldabilty,PreparedStatement prepareStatement,String sql,String[] columnNames){\r\n    checkValidity();\r\n    return con.prepareStatement(sql, columnNames);\r\n}"
}, {
	"Path": "com.sun.s1asdev.connector.txlevelswitch.test1.ejb.SimpleSessionBean.test1",
	"Comment": "get connection with one xa datasource and then getconnectionwith another xa datasource. do some work using both.this should work since for this test both our pools are xa",
	"Method": "boolean test1(){\r\n    System.out.println(\"************IN TEST 1*************\");\r\n    InitialContext ic = new InitialContext();\r\n    DataSource ds1 = (DataSource) ic.lookup(\"java:comp/env/DataSource1\");\r\n    DataSource ds2 = (DataSource) ic.lookup(\"java:comp/env/DataSource2\");\r\n    Connection conn1 = null;\r\n    Connection conn2 = null;\r\n    Statement stmt1 = null;\r\n    Statement stmt2 = null;\r\n    ResultSet rs1 = null;\r\n    ResultSet rs2 = null;\r\n    boolean passed = true;\r\n    try {\r\n        System.out.println(\"Before getConnection 1\");\r\n        conn1 = ds1.getConnection();\r\n        System.out.println(\"After getConnection 1\");\r\n        System.out.println(\"Before getConnection 2\");\r\n        conn2 = ds2.getConnection();\r\n        System.out.println(\"After getConnection 2\");\r\n        System.out.println(\"Before createStatement 1\");\r\n        stmt1 = conn1.createStatement();\r\n        System.out.println(\"After createStatement 1\");\r\n        System.out.println(\"Before createStatement 2\");\r\n        stmt2 = conn2.createStatement();\r\n        System.out.println(\"After createStatement 2\");\r\n        System.out.println(\"executing statement 1\");\r\n        rs1 = stmt1.executeQuery(\"SELECT * FROM TXLEVELSWITCH\");\r\n        System.out.println(\"executing statement 2\");\r\n        rs2 = stmt2.executeQuery(\"SELECT * FROM TXLEVELSWITCH2\");\r\n        System.out.println(\"finished executing statements\");\r\n        passed = rs1.next() & rs2.next();\r\n    } catch (Exception e) {\r\n        passed = false;\r\n        e.printStackTrace();\r\n    } finally {\r\n        if (rs1 != null) {\r\n            try {\r\n                rs1.close();\r\n            } catch (Exception e1) {\r\n            }\r\n        }\r\n        if (rs2 != null) {\r\n            try {\r\n                rs2.close();\r\n            } catch (Exception e1) {\r\n            }\r\n        }\r\n        if (stmt1 != null) {\r\n            try {\r\n                stmt1.close();\r\n            } catch (Exception e1) {\r\n            }\r\n        }\r\n        if (stmt2 != null) {\r\n            try {\r\n                stmt2.close();\r\n            } catch (Exception e1) {\r\n            }\r\n        }\r\n        if (conn1 != null) {\r\n            try {\r\n                conn1.close();\r\n            } catch (Exception e1) {\r\n            }\r\n        }\r\n        if (conn2 != null) {\r\n            try {\r\n                conn2.close();\r\n            } catch (Exception e1) {\r\n            }\r\n        }\r\n    }\r\n    return passed;\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.CreateConnectorResource.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    HashMap attrList = new HashMap();\r\n    attrList.put(POOL_NAME, poolName);\r\n    attrList.put(ResourceConstants.ENABLED, enabled.toString());\r\n    attrList.put(JNDI_NAME, jndiName);\r\n    attrList.put(ServerTags.DESCRIPTION, description);\r\n    attrList.put(ServerTags.OBJECT_TYPE, objectType);\r\n    ResourceStatus rs;\r\n    try {\r\n        rs = connResMgr.create(domain.getResources(), attrList, properties, target);\r\n    } catch (Exception e) {\r\n        Logger.getLogger(CreateConnectorResource.class.getName()).log(Level.SEVERE, \"Unable to create connector resource \" + jndiName, e);\r\n        String def = \"Connector resource: {0} could not be created, reason: {1}\";\r\n        report.setMessage(localStrings.getLocalString(\"create.connector.resource.fail\", def, jndiName) + \" \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    ActionReport.ExitCode ec = ActionReport.ExitCode.SUCCESS;\r\n    if (rs.getMessage() != null) {\r\n        report.setMessage(rs.getMessage());\r\n    }\r\n    if (rs.getStatus() == ResourceStatus.FAILURE) {\r\n        ec = ActionReport.ExitCode.FAILURE;\r\n        if (rs.getMessage() == null) {\r\n            report.setMessage(localStrings.getLocalString(\"create.connector.resource.fail\", \"Connector resource {0} creation failed\", jndiName, \"\"));\r\n        }\r\n        if (rs.getException() != null)\r\n            report.setFailureCause(rs.getException());\r\n    }\r\n    report.setActionExitCode(ec);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.Date.cloneInternal",
	"Comment": "creates and returns a copy of this object without resetting the owner and field value.",
	"Method": "Object cloneInternal(){\r\n    return super.clone();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jmac.callback.BaseContainerCallbackHandler.processCallback",
	"Comment": "gets the appropriate callback processor and hands the callback to processor to process the callback.",
	"Method": "void processCallback(Callback callback){\r\n    if (callback instanceof CallerPrincipalCallback) {\r\n        processCallerPrincipal((CallerPrincipalCallback) callback);\r\n    } else if (callback instanceof GroupPrincipalCallback) {\r\n        processGroupPrincipal((GroupPrincipalCallback) callback);\r\n    } else if (callback instanceof PasswordValidationCallback) {\r\n        processPasswordValidation((PasswordValidationCallback) callback);\r\n    } else if (callback instanceof PrivateKeyCallback) {\r\n        processPrivateKey((PrivateKeyCallback) callback);\r\n    } else if (callback instanceof TrustStoreCallback) {\r\n        TrustStoreCallback tstoreCallback = (TrustStoreCallback) callback;\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"JMAC: In TrustStoreCallback Processor\");\r\n        }\r\n        tstoreCallback.setTrustStore(sslUtils.getMergedTrustStore());\r\n    } else if (callback instanceof CertStoreCallback) {\r\n        processCertStore((CertStoreCallback) callback);\r\n    } else if (callback instanceof SecretKeyCallback) {\r\n        processSecretKey((SecretKeyCallback) callback);\r\n    } else {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"JMAC: UnsupportedCallback : \" + callback.getClass().getName());\r\n        }\r\n        throw new UnsupportedCallbackException(callback);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.embedded.DeploymentElement.getOrCreateApplication",
	"Comment": "create deployable application from a set of deploymentelements.",
	"Method": "ResultApplication getOrCreateApplication(Set<DeploymentElement> modules,String appName){\r\n    Object result = null;\r\n    boolean deleteOnExit = false;\r\n    if (modules == null || modules.size() == 0 || !DeploymentElement.hasEJBModule(modules)) {\r\n        _logger.severe(\"[DeploymentElement] No modules found\");\r\n    } else if (appName == null && DeploymentElement.countEJBModules(modules) == 1) {\r\n        if (modules.size() == 1) {\r\n            result = modules.iterator().next().getElement();\r\n        } else if (DeploymentElement.countEJBModules(modules) == 1 && DeploymentElement.hasWar(modules)) {\r\n            result = DeploymentElement.getWar(modules).getElement();\r\n        } else {\r\n            ScatteredArchive sa = null;\r\n            for (DeploymentElement m : modules) {\r\n                if (m.isEJBModule) {\r\n                    sa = new ScatteredArchive(m.mname, ScatteredArchive.Type.JAR);\r\n                    if (_logger.isLoggable(Level.INFO)) {\r\n                        _logger.info(\"[DeploymentElement] adding EJB module to ScatteredArchive \" + m.mname);\r\n                    }\r\n                    sa.addClassPath(m.element);\r\n                    break;\r\n                }\r\n            }\r\n            if (sa != null) {\r\n                for (DeploymentElement m : modules) {\r\n                    if (!m.isEJBModule) {\r\n                        if (_logger.isLoggable(Level.INFO)) {\r\n                            _logger.info(\"[DeploymentElement] adding library to ScatteredArchive \" + m.element.getName());\r\n                        }\r\n                        sa.addClassPath(m.element);\r\n                    }\r\n                }\r\n                result = sa;\r\n            }\r\n        }\r\n    } else {\r\n        File resultFile = File.createTempFile(\"ejb-app\", \"\");\r\n        File lib = null;\r\n        if (resultFile.delete() && resultFile.mkdirs()) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.fine(\"[DeploymentElement] temp dir created at \" + resultFile.getAbsolutePath());\r\n            }\r\n            if (DeploymentElement.hasLibrary(modules)) {\r\n                if (_logger.isLoggable(Level.FINE)) {\r\n                    _logger.fine(\"[DeploymentElement] lib dir added ... \");\r\n                }\r\n                lib = new File(resultFile, \"lib\");\r\n            }\r\n        } else {\r\n            throw new EJBException(\"Not able to create temp dir \" + resultFile.getAbsolutePath());\r\n        }\r\n        int duplicate_dir_counter = 0;\r\n        for (DeploymentElement m : modules) {\r\n            File f = m.element;\r\n            if (_logger.isLoggable(Level.INFO)) {\r\n                _logger.info(\"[DeploymentElement] adding \" + f.getName() + \" to exploded ear \" + \" isEJBModule? \" + m.isEJBModule + \" isWebApp? \" + m.isWebApp);\r\n            }\r\n            String filename = f.toURI().getSchemeSpecificPart();\r\n            if (filename.endsWith(File.separator) || filename.endsWith(\"/\")) {\r\n                int length = filename.length();\r\n                filename = filename.substring(0, length - 1);\r\n            }\r\n            int lastpart = filename.lastIndexOf(File.separatorChar);\r\n            if (lastpart == -1) {\r\n                lastpart = filename.lastIndexOf('/');\r\n            }\r\n            String name = filename.substring(lastpart + 1);\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.fine(\"[DeploymentElement] Converted file name: \" + filename + \" to \" + name);\r\n            }\r\n            File base = (m.isEJBModule) ? resultFile : lib;\r\n            if (!f.isDirectory() && m.isEJBModule) {\r\n                File out = new File(base, FileUtils.makeFriendlyFilename(name));\r\n                if (_logger.isLoggable(Level.FINE)) {\r\n                    _logger.fine(\"[DeploymentElement] Exploding jar to: \" + out);\r\n                }\r\n                ModuleExploder.explodeJar(f, out);\r\n            } else {\r\n                if (f.isDirectory()) {\r\n                    name = name + (m.isWebApp ? \"_war\" : (m.isEJBModule ? \"_jar\" : \".jar\"));\r\n                }\r\n                File out = new File(base, name);\r\n                if (out.exists()) {\r\n                    out = new File(base, \"d__\" + ++duplicate_dir_counter + \"__\" + name);\r\n                }\r\n                if (_logger.isLoggable(Level.FINE)) {\r\n                    _logger.fine(\"[DeploymentElement] Copying element to: \" + out);\r\n                }\r\n                FileUtils.copy(f, out);\r\n            }\r\n        }\r\n        deleteOnExit = !Boolean.getBoolean(EJBContainerProviderImpl.KEEP_TEMPORARY_FILES);\r\n        if (appName == null) {\r\n            appName = \"ejb-app\";\r\n        }\r\n        result = resultFile;\r\n    }\r\n    return new ResultApplication(result, appName, deleteOnExit);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jacc.provider.SimplePolicyConfiguration.removeRole",
	"Comment": "used to remove a role and all its permissions from thispolicyconfiguration.",
	"Method": "void removeRole(String roleName){\r\n    checkSetPolicyPermission();\r\n    pcwLock.lock();\r\n    try {\r\n        assertStateIsOpen();\r\n        if (roleName != null && roleTable != null) {\r\n            if (!roleTable.remove(new Role(roleName))) {\r\n                if (roleName.equals(\"*\")) {\r\n                    roleTable.clear();\r\n                    roleTable = null;\r\n                }\r\n            } else if (roleTable.isEmpty()) {\r\n                roleTable = null;\r\n            }\r\n        }\r\n    } finally {\r\n        pcwLock.unlock();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.jqlc.VariableTable.add",
	"Comment": "creates a new entry in the variable table with the specified name as key and an empty value.",
	"Method": "void add(String name){\r\n    declaredVars.add(name);\r\n    varInfos.put(name, new VarInfo());\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecurityMechanismSelector.selectSecurityMechanism",
	"Comment": "select the security mechanism from the list of compound securitymechanisms.",
	"Method": "CompoundSecMech selectSecurityMechanism(IOR ior,CompoundSecMech selectSecurityMechanism,CompoundSecMech[] mechList){\r\n    if (mechList == null || mechList.length == 0) {\r\n        return null;\r\n    }\r\n    CompoundSecMech mech = null;\r\n    for (int i = 0; i < mechList.length; i++) {\r\n        mech = mechList[i];\r\n        boolean useMech = useMechanism(mech);\r\n        if (useMech) {\r\n            return mech;\r\n        }\r\n    }\r\n    throw new SecurityMechanismException(\"Cannot use any of the \" + \" target's supported mechanisms\");\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.PreparedStatementWrapper40.isClosed",
	"Comment": "retrieves whether this statement object has been closed. a statement is closed if themethod close has been called on it, or if it is automatically closed.",
	"Method": "boolean isClosed(){\r\n    return preparedStatement.isClosed();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ClassDesc.buildQueryPlan",
	"Comment": "builds and initializes a new query plan based on the informationpassed with the desc parameter. the returned planand its related data structures will be readonly.",
	"Method": "UpdateQueryPlan buildQueryPlan(SQLStoreManager store,UpdateObjectDescImpl desc){\r\n    UpdateQueryPlan plan;\r\n    plan = new UpdateQueryPlan(desc, store);\r\n    plan.build(true);\r\n    plan.getStatements();\r\n    return plan;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.util.GuiUtil.getMapValue",
	"Comment": "get the value from a map, traversing a comma separated set of keys",
	"Method": "Object getMapValue(Map map,String mapKeys){\r\n    String[] keys = mapKeys.split(\",\");\r\n    int i = 0;\r\n    for (; i < keys.length - 1; i++) {\r\n        map = (Map) map.get(keys[i]);\r\n        if (map == null)\r\n            return null;\r\n    }\r\n    return map.get(keys[i]);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.overrideProperties",
	"Comment": "overrides default properties with the ones providedby the user",
	"Method": "void overrideProperties(Properties dbProperties,String vendorName){\r\n    boolean debug = logger.isLoggable();\r\n    Properties overridingProperties = new Properties();\r\n    try {\r\n        PropertyHelper.loadFromFile(overridingProperties, PROPERTY_OVERRIDE_FILE);\r\n    } catch (Exception e) {\r\n        if (debug) {\r\n            logger.fine(\"sqlstore.database.dbvendor.overrideproperties\");\r\n        }\r\n        return;\r\n    }\r\n    String cleanVendorName = vendorName.toLowerCase().replace(' ', '_');\r\n    cleanVendorName = cleanVendorName.replace('/', '_');\r\n    String propertyPrefix = \"database.\" + cleanVendorName + \".\";\r\n    for (int i = 0; i < props.length; i++) {\r\n        String o = overridingProperties.getProperty(propertyPrefix + props[i]);\r\n        if (o != null) {\r\n            if (debug) {\r\n                Object[] items = new Object[] { props[i], o };\r\n                logger.fine(\"sqlstore.database.dbvendor.overrideproperties.with\", items);\r\n            }\r\n            dbProperties.setProperty(props[i], o);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.work.CommonWorkManager.startWork",
	"Comment": "executes the work instance. the calling thread will wait until thestart of work execution.",
	"Method": "long startWork(Work work,long startWork,Work work,long startTimeout,ExecutionContext execContext,WorkListener workListener){\r\n    WorkContextHandlerImpl contextHandler = createWorkContextHandler();\r\n    validateWork(work, WorkCoordinator.getExecutionContext(execContext, work), contextHandler);\r\n    if (logger.isLoggable(Level.FINEST)) {\r\n        String msg = \"startWork for [\" + work.toString() + \"] START\";\r\n        logger.log(Level.FINEST, msg);\r\n    }\r\n    long acceptanceTime = System.currentTimeMillis();\r\n    WorkCoordinator wc = new WorkCoordinator(work, startTimeout, execContext, tp.getAnyWorkQueue(), workListener, this.probeProvider, runtime, raName, contextHandler);\r\n    wc.submitWork(WorkCoordinator.WAIT_UNTIL_START);\r\n    wc.lock();\r\n    WorkException we = wc.getException();\r\n    if (we != null) {\r\n        throw we;\r\n    }\r\n    if (logger.isLoggable(Level.FINEST)) {\r\n        String msg = \"startWork for [\" + work.toString() + \"] END\";\r\n        logger.log(Level.FINEST, msg);\r\n    }\r\n    long startTime = System.currentTimeMillis();\r\n    return (startTime - acceptanceTime);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.HashSet.add",
	"Comment": "adds the specified element to this set if it is not alreadypresent.",
	"Method": "boolean add(Object o){\r\n    if (allowNulls == false && o == null) {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"sco.nulls_not_allowed\"));\r\n    }\r\n    if (elementType != null && !elementType.isAssignableFrom(o.getClass())) {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        messages, \"sco.classcastexception\", elementType.getName()), new ClassCastException(), new Object[] { o });\r\n    }\r\n    if (owner != null) {\r\n        StateManager stateManager = owner.jdoGetStateManager();\r\n        if (stateManager != null) {\r\n            PersistenceManager pm = (PersistenceManager) stateManager.getPersistenceManagerInternal();\r\n            pm.acquireShareLock();\r\n            boolean modified = false;\r\n            try {\r\n                pm.acquireFieldUpdateLock();\r\n                try {\r\n                    stateManager.makeDirty(fieldName);\r\n                    modified = super.add(o);\r\n                    if (modified) {\r\n                        if (removed.remove(o) == false) {\r\n                            added.add(o);\r\n                        }\r\n                        stateManager.applyUpdates(fieldName, this);\r\n                    }\r\n                    return modified;\r\n                } finally {\r\n                    pm.releaseFieldUpdateLock();\r\n                }\r\n            } catch (JDOUserException e) {\r\n                Object[] failedObjects = e.getFailedObjectArray();\r\n                if (modified && (failedObjects != null)) {\r\n                    for (int i = 0; i < failedObjects.length; i++) {\r\n                        Object failedObject = failedObjects[i];\r\n                        if (failedObject == o) {\r\n                            super.remove(failedObject);\r\n                            break;\r\n                        }\r\n                    }\r\n                }\r\n                throw e;\r\n            } finally {\r\n                pm.releaseShareLock();\r\n            }\r\n        }\r\n    }\r\n    return super.add(o);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingClassElementImpl.setDatabaseRoot",
	"Comment": "set the database root for this mappingclasselement.\tthe root represents the database used by the tables mapped to \tthis mapping class.",
	"Method": "void setDatabaseRoot(SchemaElement root){\r\n    String old = getDatabaseRoot();\r\n    String newRoot = ((root != null) ? root.getName().getFullName() : null);\r\n    try {\r\n        fireVetoableChange(PROP_DATABASE_ROOT, old, newRoot);\r\n        _databaseRoot = newRoot;\r\n        firePropertyChange(PROP_DATABASE_ROOT, old, newRoot);\r\n    } catch (PropertyVetoException e) {\r\n        throw new ModelVetoException(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlTime.setTimeInternal",
	"Comment": "sets the sqltime object without notification of the ownerfield. used internaly to populate date from db",
	"Method": "void setTimeInternal(long time){\r\n    super.setTime(time);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getString",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object asa string in the java programming language.",
	"Method": "String getString(int columnIndex,String getString,String columnName){\r\n    return resultSet.getString(columnName);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.removeResourcesFromCaches",
	"Comment": "removes the classes cached with the specified class loader from all\tcaches. the method iterates the classloader cache to find classes\tcached with the specified class loader. these classes are removed\tfrom the classloader cache, the cache of mappingclasselements and\tthe set of classes known to be non pc. the associated schemaelements\tare removed from the schemaelement cache.",
	"Method": "void removeResourcesFromCaches(ClassLoader classLoader){\r\n    Collection classNames = new HashSet();\r\n    synchronized (classLoaders) {\r\n        for (Iterator i = classLoaders.entrySet().iterator(); i.hasNext(); ) {\r\n            Map.Entry next = (Map.Entry) i.next();\r\n            if (next.getValue() == classLoader) {\r\n                classNames.add(next.getKey());\r\n                i.remove();\r\n            }\r\n        }\r\n    }\r\n    removeResourcesFromCaches(classNames);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.convertFields",
	"Comment": "adds the allowable persistent fields from the supplied list \tto the persistent class with the specified name.",
	"Method": "void convertFields(String className,List fields){\r\n    PersistenceClassElement element = getPersistenceClass(className);\r\n    if (element != null) {\r\n        Iterator iterator = fields.iterator();\r\n        while (iterator.hasNext()) {\r\n            String fieldName = (String) iterator.next();\r\n            if (isPersistentAllowed(className, fieldName) && shouldBePersistent(className, fieldName)) {\r\n                addFieldElement(element, fieldName);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.work.context.WorkContextHandlerImpl.isContextSupported",
	"Comment": "indicates whether the provided workcontextclass is supported by the container",
	"Method": "boolean isContextSupported(boolean strict,String workContextClassName,boolean isContextSupported,Class contextClass){\r\n    return canContainerHandleSameContextType(contextClass.getClass().getName());\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.newInstance",
	"Comment": "returns a new instance of the object defined by the givenstatemanager",
	"Method": "Object newInstance(StateManager sm){\r\n    Object o = null;\r\n    PersistenceConfig config = sm.getPersistenceConfig();\r\n    if (config == null) {\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerimpl.newinstance.badsm\"));\r\n    }\r\n    Constructor constr = config.getConstructor();\r\n    try {\r\n        if (constr != null) {\r\n            o = constr.newInstance(new Object[] { sm });\r\n            sm.setPersistenceManager(this);\r\n            sm.setPersistent(o);\r\n        }\r\n    } catch (Exception e) {\r\n        throw new JDOFatalUserException(I18NHelper.getMessage(messages, \"jdo.persistencemanagerimpl.assertpersistencecapable.error\", config.getPersistenceCapableClass().getName()), e);\r\n    }\r\n    return o;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ConnectionHolder.getMetaData",
	"Comment": "retrieves the databasemetadataobject from the underlying connectionobject.",
	"Method": "DatabaseMetaData getMetaData(){\r\n    checkValidity();\r\n    return con.getMetaData();\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.help.HelpTreeAdaptor.getChildTreeNodeObjects",
	"Comment": "returns child tocitems for the given \ttocitem or toc model object.if \tnull is supplied, null is returned \tany other object type will result in an \tillegalargumentexception.",
	"Method": "List getChildTreeNodeObjects(Object nodeObject){\r\n    if (nodeObject == null) {\r\n        return null;\r\n    }\r\n    List<TOCItem> result = null;\r\n    if (nodeObject instanceof TOCItem) {\r\n        result = new ArrayList<TOCItem>(((TOCItem) nodeObject).getTOCItems());\r\n    }\r\n    if (nodeObject instanceof TOC) {\r\n        result = new ArrayList<TOCItem>(((TOC) nodeObject).getTOCItems());\r\n    }\r\n    if (null != result) {\r\n        Collections.sort(result, new HelpTreeAdaptor.TOCItemComparator());\r\n        return result;\r\n    }\r\n    throw new IllegalArgumentException(\"Invalid node type for TOC: \" + nodeObject.getClass().getName());\r\n}"
}, {
	"Path": "org.glassfish.jms.admin.cli.JMSAdminException.getMessage",
	"Comment": "returns the message along with the message from any linked exception.",
	"Method": "String getMessage(){\r\n    String retString = null;\r\n    if (_message != null) {\r\n        retString = _message;\r\n    }\r\n    Exception localLinkedException = linkedException;\r\n    if (localLinkedException != null && localLinkedException.getMessage() != null) {\r\n        if (retString != null) {\r\n            retString += retString + \"\\n\" + localLinkedException.getMessage();\r\n        } else {\r\n            retString = localLinkedException.getMessage();\r\n        }\r\n    }\r\n    return retString;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.convertMethodPermissions",
	"Comment": "convert all style 1 and style 2 method descriptors contained inour tables into style 3 method descriptors.",
	"Method": "void convertMethodPermissions(){\r\n    if (styledMethodDescriptors == null)\r\n        return;\r\n    Set allMethods = getMethodDescriptors();\r\n    Set unpermissionedMethods = getMethodDescriptors();\r\n    Set methodDescriptors = styledMethodDescriptors.entrySet();\r\n    for (Iterator styledMdItr = methodDescriptors.iterator(); styledMdItr.hasNext(); ) {\r\n        Map.Entry entry = (Map.Entry) styledMdItr.next();\r\n        MethodDescriptor styledMd = (MethodDescriptor) entry.getKey();\r\n        Set newPermissions = (Set) entry.getValue();\r\n        Vector mds = styledMd.doStyleConversion(this, allMethods);\r\n        for (Iterator mdItr = mds.iterator(); mdItr.hasNext(); ) {\r\n            MethodDescriptor md = (MethodDescriptor) mdItr.next();\r\n            unpermissionedMethods.remove(md);\r\n            for (Iterator newPermissionsItr = newPermissions.iterator(); newPermissionsItr.hasNext(); ) {\r\n                MethodPermission newMp = (MethodPermission) newPermissionsItr.next();\r\n                updateMethodPermissionForMethod(newMp, md);\r\n            }\r\n        }\r\n    }\r\n    MethodPermission mp = MethodPermission.getUncheckedMethodPermission();\r\n    Iterator iterator = unpermissionedMethods.iterator();\r\n    while (iterator.hasNext()) {\r\n        MethodDescriptor md = (MethodDescriptor) iterator.next();\r\n        if (getMethodPermissions(md).isEmpty()) {\r\n            addMethodPermissionForMethod(mp, md);\r\n        }\r\n    }\r\n    styledMethodDescriptors = null;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.CommonHandlers.filterProtocols",
	"Comment": "this handler filters out not required protocols from the list of protocols available",
	"Method": "List filterProtocols(HandlerContext context){\r\n    FilterTreeEvent event = FilterTreeEvent.class.cast(context.getEventObject());\r\n    List protocols = event.getChildObjects();\r\n    ArrayList result = new ArrayList();\r\n    if (protocols != null && protocols.size() > 0) {\r\n        for (int i = 0; i < protocols.size(); i++) {\r\n            String protocol = (String) protocols.get(i);\r\n            if (!(protocol.equals(ServerTags.PORT_UNIF_PROTOCOL_NAME) || protocol.equals(ServerTags.REDIRECT_PROTOCOL_NAME))) {\r\n                result.add(protocol);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.appserv.connectors.internal.api.ConnectorsUtil.getValidSuffix",
	"Comment": "check whether the jndi name has connector related suffix and return if any.",
	"Method": "String getValidSuffix(String name){\r\n    if (name != null) {\r\n        for (String validSuffix : ConnectorConstants.JNDI_SUFFIX_VALUES) {\r\n            if (name.endsWith(validSuffix)) {\r\n                return validSuffix;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.getUserObject",
	"Comment": "the application can manage the persistencemanager instancesmore easily by having an application object associated with eachpersistencemanager instance.",
	"Method": "Object getUserObject(){\r\n    return _userObject;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConfigurationParserServiceImpl.getActivationSpecClass",
	"Comment": "return the activationspecclass name for given rar and messagelistenertype",
	"Method": "String getActivationSpecClass(String rarName,String messageListenerType){\r\n    ConnectorDescriptor desc = getConnectorDescriptor(rarName);\r\n    if (desc != null) {\r\n        MessageListenerConfigParser messagelistenerConfigParser = (MessageListenerConfigParser) ConnectorConfigParserFactory.getParser(ConnectorConfigParser.MSL);\r\n        return messagelistenerConfigParser.getActivationSpecClass(desc, messageListenerType);\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.EjbConversionHelper.getInverseFieldName",
	"Comment": "this method return the fieldname of relation role on the other end.",
	"Method": "String getInverseFieldName(String ejbName,String fieldName){\r\n    RelationRoleDescriptor oppRole = getRelationRoleDescriptor(ejbName, fieldName, false);\r\n    String inverseName = oppRole.getCMRField();\r\n    if ((generateFields) && (inverseName == null))\r\n        inverseName = nameMapper.getGeneratedFieldForEjbField(ejbName, fieldName)[1];\r\n    return inverseName;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.PreparedStatementWrapper.setDouble",
	"Comment": "sets the designated parameter to the given java double value.the driver converts thisto an sql double value when it sends it to the database.",
	"Method": "void setDouble(int parameterIndex,double x){\r\n    preparedStatement.setDouble(parameterIndex, x);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.ClassFile.interfaces",
	"Comment": "return the list of the interfaces which the class implementsthe contents are constclass objects",
	"Method": "Vector interfaces(){\r\n    return classInterfaces;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.CPManagedConnectionFactory.equals",
	"Comment": "check if this managedconnectionfactory is equal toanother managedconnectionfactory.",
	"Method": "boolean equals(Object other){\r\n    logFine(\"In equals\");\r\n    if (other instanceof com.sun.gjc.spi.CPManagedConnectionFactory) {\r\n        com.sun.gjc.spi.CPManagedConnectionFactory otherMCF = (com.sun.gjc.spi.CPManagedConnectionFactory) other;\r\n        return this.spec.equals(otherMCF.spec);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.jqlc.ParameterTable.getParameterInfoForParamName",
	"Comment": "returns the parameter info for the specified parameter nameand associated field.if the associated field is not known, then null is used asinput parameter.",
	"Method": "ParameterInfo getParameterInfoForParamName(String paramName,ParameterInfo getParameterInfoForParamName,String paramName,String associatedField){\r\n    int index = names.indexOf(paramName);\r\n    Type type = (Type) types.get(index);\r\n    return new ParameterInfo(index, type.getEnumType(), associatedField);\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.util.RestUtil.getRestToken",
	"Comment": "this method returns the value of the rest token if it is successfully set in session scope.",
	"Method": "String getRestToken(){\r\n    String token = null;\r\n    FacesContext ctx = FacesContext.getCurrentInstance();\r\n    if (ctx != null) {\r\n        token = (String) ctx.getExternalContext().getSessionMap().get(AdminConsoleAuthModule.REST_TOKEN);\r\n    }\r\n    return token;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.EnvironmentProperty.getResolvedValueObject",
	"Comment": "returns the typed value object of this environment property. throws an illegalargumentexception if bounds checking is true and the value cannot bereconciled with the given type.",
	"Method": "Object getResolvedValueObject(){\r\n    if (this.valueObject == null) {\r\n        this.valueObject = \"\";\r\n    }\r\n    return getObjectFromString(this.getResolvedValue(), this.getValueType());\r\n}"
}, {
	"Path": "com.sun.ejb.containers.StatefulSessionContainer.createEJBLocalObjectImpl",
	"Comment": "called from createejbobject and activateejb and createejblocalobjectimpl",
	"Method": "EJBLocalObjectImpl createEJBLocalObjectImpl(EJBLocalObjectImpl createEJBLocalObjectImpl,SessionContextImpl context){\r\n    if (context.getEJBLocalObjectImpl() != null)\r\n        return context.getEJBLocalObjectImpl();\r\n    EJBLocalObjectImpl localObjImpl = instantiateEJBLocalObjectImpl(context.getInstanceKey());\r\n    context.setEJBLocalObjectImpl(localObjImpl);\r\n    localObjImpl.setContext(context);\r\n    if (hasLocalBusinessView) {\r\n        createEJBLocalBusinessObjectImpl(context);\r\n    }\r\n    if (hasOptionalLocalBusinessView) {\r\n        createOptionalEJBLocalBusinessObjectImpl(context);\r\n    }\r\n    if (hasRemoteHomeView) {\r\n        createEJBObjectImpl(context);\r\n    }\r\n    if (hasRemoteBusinessView) {\r\n        createRemoteBusinessObjectImpl(context);\r\n    }\r\n    return localObjImpl;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ConnectionHolder.clearWarnings",
	"Comment": "clears all warnings reported for the underlying connectionobject.",
	"Method": "void clearWarnings(){\r\n    checkValidity();\r\n    con.clearWarnings();\r\n}"
}, {
	"Path": "org.glassfish.admin.mejb.MEJBBean.queryNames",
	"Comment": "javax.management.j2ee.management implementation starts here",
	"Method": "Set<ObjectName> queryNames(ObjectName name,QueryExp query){\r\n    try {\r\n        return restrict(mbeanServer.queryNames(name, query));\r\n    } catch (Exception ex) {\r\n        throw new RemoteException(this.toString() + \"::queryNames\", ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jacc.provider.SimplePolicyConfiguration.implies",
	"Comment": "evaluates the policy to determine whether the permissions is granted tothe protectiondomain.",
	"Method": "int implies(ProtectionDomain domain,Permission p){\r\n    SimplePolicyConfiguration pc = SharedState.getActiveConfig();\r\n    return (pc == null ? 0 : pc.doImplies(domain, p));\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.MappingFile.setConsistency",
	"Comment": "set consistency from mappingclasselement into schema2beansconsistency bean.",
	"Method": "void setConsistency(MappingClassElement mce,EntityMapping beanMapping){\r\n    int consistency = mce.getConsistencyLevel();\r\n    if (MappingClassElement.NONE_CONSISTENCY != consistency) {\r\n        Consistency c = new Consistency();\r\n        if (MappingClassElement.LOCK_WHEN_MODIFIED_CHECK_ALL_AT_COMMIT_CONSISTENCY == consistency) {\r\n            c.setLockWhenModified(true);\r\n            c.setCheckAllAtCommit(true);\r\n        }\r\n        if (MappingClassElement.LOCK_WHEN_MODIFIED_CONSISTENCY == consistency)\r\n            c.setLockWhenModified(true);\r\n        if (MappingClassElement.CHECK_ALL_AT_COMMIT_CONSISTENCY == consistency)\r\n            c.setCheckAllAtCommit(true);\r\n        if (MappingClassElement.LOCK_WHEN_LOADED_CONSISTENCY == consistency)\r\n            c.setLockWhenLoaded(true);\r\n        if (MappingClassElement.CHECK_MODIFIED_AT_COMMIT_CONSISTENCY == consistency)\r\n            c.setCheckModifiedAtCommit(true);\r\n        if (MappingClassElement.VERSION_CONSISTENCY == consistency) {\r\n            CheckVersionOfAccessedInstances versionIns = new CheckVersionOfAccessedInstances();\r\n            Iterator iter = mce.getVersionFields().iterator();\r\n            while (iter.hasNext()) {\r\n                List columnNames = ((MappingFieldElement) iter.next()).getColumns();\r\n                if (columnNames != null && columnNames.size() > 0)\r\n                    versionIns.addColumnName((String) columnNames.get(0));\r\n            }\r\n            c.setCheckVersionOfAccessedInstances(versionIns);\r\n        }\r\n        beanMapping.setConsistency(c);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.getPersistenceField",
	"Comment": "returns the persistencefieldelement with the supplied fieldname found\tin the supplied classname.",
	"Method": "PersistenceFieldElement getPersistenceField(String className,String fieldName){\r\n    return (hasField(className, fieldName) ? getPersistenceFieldInternal(className, fieldName) : null);\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.ListConnectorResources.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        Collection<ConnectorResource> connectorResources = domain.getResources().getResources(ConnectorResource.class);\r\n        for (ConnectorResource resource : connectorResources) {\r\n            if (bindableResourcesHelper.resourceExists(resource.getJndiName(), target)) {\r\n                ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n                part.setMessage(resource.getJndiName());\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.connector.resources.fail\", \"List connector resources failed\") + \" \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingRelationshipElementImpl.addColumn",
	"Comment": "adds a column to the list of columns mapped by this mapping\trelationship.this method overrides the one in mappingfieldelement to\tcheck that the argument is a columnpairelement.",
	"Method": "void addColumn(DBMemberElement column){\r\n    if (column instanceof ColumnPairElement) {\r\n        if (!getAssociatedColumns().isEmpty()) {\r\n            throw new ModelException(I18NHelper.getMessage(getMessages(), \"mapping.column.associated_columns_defined\", NameUtil.getRelativeMemberName(column.getName().getFullName())));\r\n        }\r\n        super.addColumn(column);\r\n    } else {\r\n        throw new ModelException(// NOI18N\r\n        I18NHelper.getMessage(getMessages(), \"mapping.column.column_invalid\", NameUtil.getRelativeMemberName(column.getName().getFullName())));\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.handlers.EntityManagerFactoryReferenceHandler.getEmfReferenceDescriptors",
	"Comment": "return entitymanagerfactoryreferencedescriptors with given name if exists or a new one without name being set.",
	"Method": "EntityManagerFactoryReferenceDescriptor[] getEmfReferenceDescriptors(String logicalName,ResourceContainerContext[] rcContexts){\r\n    EntityManagerFactoryReferenceDescriptor[] emfRefs = new EntityManagerFactoryReferenceDescriptor[rcContexts.length];\r\n    for (int i = 0; i < rcContexts.length; i++) {\r\n        EntityManagerFactoryReferenceDescriptor emfRef = (EntityManagerFactoryReferenceDescriptor) rcContexts[i].getEntityManagerFactoryReference(logicalName);\r\n        if (emfRef == null) {\r\n            emfRef = new EntityManagerFactoryReferenceDescriptor();\r\n            rcContexts[i].addEntityManagerFactoryReferenceDescriptor(emfRef);\r\n        }\r\n        emfRefs[i] = emfRef;\r\n    }\r\n    return emfRefs;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ActiveResourceAdapterImpl.setLogWriter",
	"Comment": "sets the logwriter for the mcf being instantiated.resource adapter implementer can make use of this logwriter",
	"Method": "void setLogWriter(ManagedConnectionFactory mcf){\r\n    PrintWriterAdapter adapter = new PrintWriterAdapter(ConnectorRuntime.getRuntime().getResourceAdapterLogWriter());\r\n    try {\r\n        mcf.setLogWriter(adapter);\r\n    } catch (Exception e) {\r\n        Object[] params = new Object[] { mcf.getClass().getName(), e.toString() };\r\n        _logger.log(Level.WARNING, \"rardeployment.logwriter_error\", params);\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Unable to set LogWriter for ManagedConnectionFactory : \" + mcf.getClass().getName(), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.HashSet.removeAllInternal",
	"Comment": "remove c from the list if the hashset is not deferred.otherwise, add c to the removed list.",
	"Method": "void removeAllInternal(Collection c){\r\n    if (c == null) {\r\n        return;\r\n    }\r\n    Iterator iter = c.iterator();\r\n    while (iter.hasNext()) {\r\n        removeInternal(iter.next());\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.resources.api.GlobalResourceDeployer.getPropValuesAsStrArr",
	"Comment": "return an the element property values as an array of strings.",
	"Method": "String[] getPropValuesAsStrArr(Property[] props){\r\n    if (props == null) {\r\n        return null;\r\n    } else {\r\n        String[] result = new String[props.length];\r\n        for (int i = 0; i < props.length; i++) {\r\n            result[i] = props[i].getValue();\r\n        }\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.getBoolean",
	"Comment": "retrieves the value of a jdbc bit parameter as aboolean in the java programming language.",
	"Method": "boolean getBoolean(int parameterIndex,boolean getBoolean,String parameterName){\r\n    return callableStatement.getBoolean(parameterName);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.TransactionHelperImpl.getDDLNamePrefix",
	"Comment": "returns name prefix for ddl files extracted from the info instance by theapplication server specific code.",
	"Method": "String getDDLNamePrefix(Object info){\r\n    return DEFAULT_STRING;\r\n}"
}, {
	"Path": "com.sun.gjc.monitoring.JdbcStatsProvider.statementCacheMissEvent",
	"Comment": "whenever statement cache miss happens, increment numstatementcachemiss count.",
	"Method": "void statementCacheMissEvent(String poolName,String appName,String moduleName){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        numStatementCacheMiss.increment();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.DeploymentDescriptorNode.writeEntityManagerFactoryReferenceDescriptors",
	"Comment": "write a list of entity manager factory reference descriptors toa dom tree",
	"Method": "void writeEntityManagerFactoryReferenceDescriptors(Node parentNode,Iterator entityMgrFactoryRefs){\r\n    if (entityMgrFactoryRefs == null || !entityMgrFactoryRefs.hasNext())\r\n        return;\r\n    EntityManagerFactoryReferenceNode subNode = new EntityManagerFactoryReferenceNode();\r\n    for (; entityMgrFactoryRefs.hasNext(); ) {\r\n        EntityManagerFactoryReferenceDescriptor aEntityMgrFactoryRef = (EntityManagerFactoryReferenceDescriptor) entityMgrFactoryRefs.next();\r\n        subNode.writeDescriptor(parentNode, TagNames.PERSISTENCE_UNIT_REF, aEntityMgrFactoryRef);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.HashSet.applyDeferredUpdates",
	"Comment": "if the hashset is deferred, we first initialize the internal collectionwith c and they apply any deferred updates specified by the added andremoved lists.",
	"Method": "void applyDeferredUpdates(Collection c){\r\n    if (!isDeferred) {\r\n        return;\r\n    }\r\n    isDeferred = false;\r\n    addAllInternal(c);\r\n    addAllInternal(added);\r\n    removeAllInternal(removed);\r\n    added.clear();\r\n    removed.clear();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlTimestamp.cloneInternal",
	"Comment": "creates and returns a copy of this object without resetting the owner and field value.",
	"Method": "Object cloneInternal(){\r\n    return super.clone();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingTableElementImpl.addKeyColumnInternal",
	"Comment": "adds a column to the primary key of columns in this mapping table.\tthis method is used internally to manipulate primary key columns \tthat have passed the null and duplicate tests in addkeycolumn and \tsecondary table key columns when pairs are being set up and ignoring \tduplicates is done at the pair level.",
	"Method": "void addKeyColumnInternal(ColumnElement column){\r\n    ArrayList key = getKey();\r\n    String columnName = NameUtil.getRelativeMemberName(column.getName().getFullName());\r\n    try {\r\n        fireVetoableChange(PROP_KEY_COLUMNS, null, null);\r\n        key.add(columnName);\r\n        firePropertyChange(PROP_KEY_COLUMNS, null, null);\r\n        _keyObjects = null;\r\n    } catch (PropertyVetoException e) {\r\n        throw new ModelVetoException(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.JDOQLElements.getResultType",
	"Comment": "returns the result type. the result type is the name of the element type of the jdo query result set.",
	"Method": "String getResultType(){\r\n    return resultType;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.support.JDOHelper.isNew",
	"Comment": "tests whether the object has been newly made persistent.for objects that have been made persistent in the current transaction, true is returned.for transient or objects, false is returned.",
	"Method": "boolean isNew(Object obj){\r\n    if (obj instanceof PersistenceCapable)\r\n        return ((PersistenceCapable) obj).jdoIsNew();\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ManagedBeanDescriptor.getAroundInvokeInterceptors",
	"Comment": "return the ordered list of interceptor info for aroundinvoke behaviorof a particular business method.this listinclude the infoon any bean class interceptor.if present, this would always be thelast element in the list because of the precedence defined by the spec.",
	"Method": "List<InterceptorDescriptor> getAroundInvokeInterceptors(Method m){\r\n    MethodDescriptor mDesc = new MethodDescriptor(m);\r\n    List<InterceptorDescriptor> aroundInvokeInterceptors = methodInterceptorsMap.get(mDesc);\r\n    if (aroundInvokeInterceptors == null) {\r\n        aroundInvokeInterceptors = new LinkedList<InterceptorDescriptor>();\r\n        for (InterceptorDescriptor desc : classInterceptorChain) {\r\n            if (desc.hasAroundInvokeDescriptor()) {\r\n                aroundInvokeInterceptors.add(desc);\r\n            }\r\n        }\r\n    }\r\n    if (hasAroundInvokeMethod()) {\r\n        EjbInterceptor interceptorInfo = new EjbInterceptor();\r\n        interceptorInfo.setFromBeanClass(true);\r\n        interceptorInfo.addAroundInvokeDescriptors(getAroundInvokeDescriptors());\r\n        interceptorInfo.setInterceptorClassName(beanClassName);\r\n        aroundInvokeInterceptors.add(interceptorInfo);\r\n    }\r\n    return aroundInvokeInterceptors;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.isSerializable",
	"Comment": "determines if the specified field element has a serializable type. \ta type is serializable if it is a primitive type, a class that implements\tjava.io.serializable or an interface that inherits from \tjava.io.serializable. \tnote, the field element is a model specific field representation as \treturned by a getfield call executed on the same model instance. this \timplementation expects the field element being a reflection instance.",
	"Method": "boolean isSerializable(Object fieldElement){\r\n    Class type = getTypeObject(fieldElement);\r\n    while ((type != null) && type.isArray()) type = type.getComponentType();\r\n    return ((type != null) ? (type.isPrimitive() || implementsInterface(type, SERIALIZABLE)) : false);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerWrapper.getObjectById",
	"Comment": "this method locates a persistent instance in the cache of instancesmanaged by this persistencemanager.if an instance with the same objectidis found it is returned.otherwise, a new instance is created andassociated with the objectid.if the instance does not exist in the data store, then this method willnot fail.however, a request to access fields of the instance willthrow an exception.",
	"Method": "Object getObjectById(Object oid,Object getObjectById,Object oid,boolean validate){\r\n    if (isValid) {\r\n        return pm.getObjectById(oid, validate);\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerwrapper.invalidpm\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.TransactionImpl.getConnection",
	"Comment": "returns a connection. if there is no existing one, asksconnectionfactory for a new connection",
	"Method": "Connection getConnection(){\r\n    boolean debug = logger.isLoggable(Logger.FINEST);\r\n    if (_connection == null) {\r\n        if (connectionFactory == null) {\r\n            throw new JDOFatalInternalException(// NOI18N\r\n            I18NHelper.getMessage(messages, \"transaction.transactionimpl.getconnection.nullcf\"));\r\n        }\r\n        _connection = this.getConnectionInternal();\r\n    }\r\n    _connectionReferenceCount++;\r\n    if (debug) {\r\n        Object[] items = new Object[] { _connection, Boolean.valueOf(optimistic), new Integer(_connectionReferenceCount), persistenceManager };\r\n        logger.finest(\"sqlstore.transactionimpl.getconnection\", items);\r\n    }\r\n    if (!EJBHelper.isManaged()) {\r\n        try {\r\n            if ((!optimistic && isActive()) || startedCommit) {\r\n                if (_connection.getAutoCommit()) {\r\n                    _connection.setAutoCommit(false);\r\n                }\r\n            } else {\r\n                _connection.setAutoCommit(true);\r\n            }\r\n        } catch (java.sql.SQLException e) {\r\n            logger.log(Logger.WARNING, \"sqlstore.exception.log\", e);\r\n        }\r\n    }\r\n    return _connection;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.support.JDOHelper.getObjectId",
	"Comment": "returns a copy of the jdo identity associated with an object.persistent objects of persistencecapable classes have a jdo identitymanaged by the persistencemanager.this method returns a copy of theobjectid that represents the jdo identity of a persistent object.for transient objects, null is returned. the objectid may be serialized and later restored, and used witha persistencemanager from the same jdo implementation to locate apersistent object with the same data store identity.if the jdo identity is managed by the application, then theobjectid may be used with a persistencemanager from any jdoimplementation that supports the persistencecapable class.if the jdo identity is not managed by the application or thedata store, then the objectid returned is only valid within thecurrent transaction.",
	"Method": "Object getObjectId(Object obj){\r\n    if (obj instanceof PersistenceCapable)\r\n        return ((PersistenceCapable) obj).jdoGetObjectId();\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.ApplicationNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object newDescriptor){\r\n    if (newDescriptor instanceof BundleDescriptor) {\r\n        if (DOLUtils.getDefaultLogger().isLoggable(Level.FINE)) {\r\n            DOLUtils.getDefaultLogger().fine(\"In  \" + toString() + \" adding descriptor \" + newDescriptor);\r\n        }\r\n        descriptor.addBundleDescriptor((BundleDescriptor) newDescriptor);\r\n    } else if (newDescriptor instanceof EjbReference) {\r\n        descriptor.addEjbReferenceDescriptor((EjbReference) newDescriptor);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.DriverLoader.introspectAndLoadJar",
	"Comment": "returns a list of all driver class names that were loaded from the jar file.",
	"Method": "Set<String> introspectAndLoadJar(File f,String resType,String dbVendor,String origDbVendor){\r\n    if (logger.isLoggable(Level.FINEST)) {\r\n        logger.finest(\"DriverLoader : introspectAndLoadJar \");\r\n    }\r\n    return getImplClassesByIteration(f, resType, dbVendor, origDbVendor);\r\n}"
}, {
	"Path": "org.glassfish.deployment.client.DFDeploymentPropertiesTest.testGetProperties",
	"Comment": "test of getproperties method, of class dfdeploymentproperties.",
	"Method": "void testGetProperties(){\r\n    DFDeploymentProperties instance = new DFDeploymentProperties();\r\n    instance.put(DFDeploymentProperties.PROPERTY, \"keepSessions=true:foo=bar\");\r\n    Properties expResult = new Properties();\r\n    expResult.setProperty(\"keepSessions\", \"true\");\r\n    expResult.setProperty(\"foo\", \"bar\");\r\n    Properties result = instance.getProperties();\r\n    assertEquals(expResult, result);\r\n}"
}, {
	"Path": "com.sun.ejb.containers.TimerWrapper.checkCallPermission",
	"Comment": "verify that timer method access is allowed from this context.this method is static so that timerhandle can call it evenbefore it has created a timerwrapper instance.",
	"Method": "void checkCallPermission(){\r\n    EjbContainerUtil ejbContainerUtil = EjbContainerUtilImpl.getInstance();\r\n    EJBTimerService timerService = EJBTimerService.getEJBTimerService();\r\n    if (timerService == null) {\r\n        throw new IllegalStateException(\"EJBTimerService is not available\");\r\n    }\r\n    ComponentInvocation inv = ejbContainerUtil.getCurrentInvocation();\r\n    if (inv == null) {\r\n        throw new IllegalStateException(\"Invocation cannot be null\");\r\n    }\r\n    ComponentInvocation.ComponentInvocationType invType = inv.getInvocationType();\r\n    if (invType == ComponentInvocation.ComponentInvocationType.EJB_INVOCATION) {\r\n        if (inv instanceof EjbInvocation) {\r\n            ComponentContext context = ((EjbInvocation) inv).context;\r\n            context.checkTimerServiceMethodAccess();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.SetMethodAction.getMutatorMethod",
	"Comment": "retrieves the appropriate setter method in the resurce adapter java beanclass",
	"Method": "Method getMutatorMethod(String propertyName,Class type){\r\n    String setterMethodName = \"set\" + getCamelCasedPropertyName(propertyName);\r\n    Method m = null;\r\n    Method[] setterMethods = findMethod(setterMethodName);\r\n    if (setterMethods.length == 1) {\r\n        m = (Method) setterMethods[0];\r\n    } else {\r\n        for (int i = 0; i < setterMethods.length; i++) {\r\n            Class[] paramTypes = setterMethods[i].getParameterTypes();\r\n            if (paramTypes.length > 0) {\r\n                if (paramTypes[0].equals(type) && paramTypes.length == 1) {\r\n                    if (logger.isLoggable(Level.FINER)) {\r\n                        logger.log(Level.FINER, \"Method [ \" + methods[i] + \" ] matches with the right arg type\");\r\n                    }\r\n                    m = setterMethods[i];\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (m != null) {\r\n        return m;\r\n    } else {\r\n        logger.log(Level.WARNING, \"no.such.method\", new Object[] { setterMethodName, bean.getClass().getName() });\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.DeleteResourceAdapterConfig.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (raName == null) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.resource.adapter.config.noRARName\", \"No RAR name defined for resource adapter config.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (ConnectorsUtil.getResourceByName(domain.getResources(), ResourceAdapterConfig.class, raName) == null) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.resource.adapter.config.notfound\", \"Resource-Adapter-Config for {0} does not exist.\", raName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        if (ConfigSupport.apply(new SingleConfigCode<Resources>() {\r\n            public Object run(Resources param) throws PropertyVetoException, TransactionFailure {\r\n                ResourceAdapterConfig resource = (ResourceAdapterConfig) ConnectorsUtil.getResourceByName(domain.getResources(), ResourceAdapterConfig.class, raName);\r\n                if (resource != null && resource.getResourceAdapterName().equals(raName)) {\r\n                    return param.getResources().remove(resource);\r\n                }\r\n                return null;\r\n            }\r\n        }, domain.getResources()) == null) {\r\n            report.setMessage(localStrings.getLocalString(\"delete.resource.adapter.config.fail\", \"Unable to delete resource adapter config {0}\", raName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    } catch (TransactionFailure tfe) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.resource.adapter.config.fail\", \"Unable to delete resource adapter config {0}\", raName) + \" \" + tfe.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.DeleteResourceAdapterConfig.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    ResourceAdapterConfig resource = (ResourceAdapterConfig) ConnectorsUtil.getResourceByName(domain.getResources(), ResourceAdapterConfig.class, raName);\r\n    if (resource != null && resource.getResourceAdapterName().equals(raName)) {\r\n        return param.getResources().remove(resource);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.setFetchSize",
	"Comment": "gives the jdbc driver a hint as to the number of rows that shouldbe fetched from the database when more rows are needed for thisresultset object.if the fetch size specified is zero, the jdbc driverignores the value and is free to make its own best guess as to whatthe fetch size should be.the default value is set by thestatement objectthat created the result set.the fetch size may be changed at any time.",
	"Method": "void setFetchSize(int rows){\r\n    resultSet.setFetchSize(rows);\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.PoolManagerImpl.afterPostInvoke",
	"Comment": "called by the invocationmanager at methodend. this method will disassociate managedconnection instances from connection handles if the resourceadapter supports that.",
	"Method": "void afterPostInvoke(ComponentInvocation.ComponentInvocationType invType,ComponentInvocation prevInv,ComponentInvocation curInv){\r\n    postInvoke(curInv);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.support.SynchronizationManager.afterCompletion",
	"Comment": "this method will be called during transaction completion.no resourceaccess is allowed.this method in turn calls each registered instance aftercompletionmethod.after this method completes, instances must register again in the new transaction, butthe synchronization manager remains bound to the persistence managertransaction instance.",
	"Method": "void afterCompletion(int status){\r\n    int size = synchronizations.size();\r\n    StringBuffer sb = null;\r\n    for (int i = 0; i < size; ++i) {\r\n        Synchronization instance = (Synchronization) synchronizations.get(i);\r\n        try {\r\n            instance.afterCompletion(status);\r\n        } catch (Exception e) {\r\n            if (sb == null) {\r\n                sb = new StringBuffer();\r\n            }\r\n            sb.append(e.getMessage()).append('\\n');\r\n        }\r\n    }\r\n    synchronizations.clear();\r\n    if (sb != null) {\r\n        throw new JDOUserException(sb.toString());\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.enterprise.iiop.impl.GlassFishORBManager.getORB",
	"Comment": "return the shared orb instance for the app server.if the orb is not already initialized, it is createdwith the standard server properties, which can beoverridden by properties passed in the props argument.",
	"Method": "ORB getORB(Properties props){\r\n    try {\r\n        finestLog(\"GlassFishORBManager.getORB->: {0}\", orb);\r\n        if (orb == null) {\r\n            initORB(props);\r\n        }\r\n        return orb;\r\n    } finally {\r\n        finestLog(\"GlassFishORBManager.getORB<-: {0}\", orb);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.Descriptor.userMethodArgs",
	"Comment": "produce a user consumable representation of a method argument listfrom the method signature.the return value is ignored.",
	"Method": "String userMethodArgs(String methodSig){\r\n    if (methodSig.charAt(0) != '(')\r\n        throw new InsnError(\"Invalid method signature\");\r\n    StringBuffer buf = new StringBuffer();\r\n    buf.append('(');\r\n    int idx = 1;\r\n    boolean firstArg = true;\r\n    while (methodSig.charAt(idx) != ')') {\r\n        if (firstArg)\r\n            firstArg = false;\r\n        else\r\n            buf.append(\", \");\r\n        buf.append(userFieldSig(methodSig, idx));\r\n        idx = nextSigElement(methodSig, idx);\r\n    }\r\n    buf.append(')');\r\n    return buf.toString();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ConnectionHolder40.close",
	"Comment": "closes the logical connection.cleans up client specific details",
	"Method": "void close(){\r\n    if (isClosed) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"jdbc.duplicate_close_connection\", this);\r\n        }\r\n        return;\r\n    }\r\n    if (!jdbc30Connection) {\r\n        try {\r\n            checkValidity();\r\n            if (isSupportClientInfo()) {\r\n                if (defaultClientInfo == null) {\r\n                    setClientInfo(new Properties());\r\n                } else {\r\n                    setClientInfo(defaultClientInfo);\r\n                }\r\n            }\r\n        } catch (Throwable e) {\r\n            _logger.log(Level.INFO, \"jdbc.unable_to_set_client_info\", e.getMessage());\r\n            if (_logger.isLoggable(Level.FINEST)) {\r\n                _logger.log(Level.FINEST, \"jdbc.unable_to_set_client_info\", e);\r\n            }\r\n        }\r\n    }\r\n    super.close();\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.CSIV2TaggedComponentInfo.createSASContextSec",
	"Comment": "create the sas layer context within a compound mechanism definition.",
	"Method": "SAS_ContextSec createSASContextSec(EjbIORConfigurationDescriptor iorDesc){\r\n    SAS_ContextSec sasContext = null;\r\n    int target_supports = 0;\r\n    int target_requires = 0;\r\n    ServiceConfiguration[] priv = new ServiceConfiguration[0];\r\n    String callerPropagation = null;\r\n    byte[][] mechanisms = {};\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"IIOP: Creating SAS_Context\");\r\n    }\r\n    int supported_identity_token_type = 0;\r\n    if (iorDesc != null) {\r\n        callerPropagation = iorDesc.getCallerPropagation();\r\n    }\r\n    if ((callerPropagation != null) && (callerPropagation.equalsIgnoreCase(EjbIORConfigurationDescriptor.NONE))) {\r\n        sasContext = new SAS_ContextSec((short) target_supports, (short) target_requires, priv, mechanisms, supported_identity_token_type);\r\n        return sasContext;\r\n    }\r\n    target_supports = IdentityAssertion.value;\r\n    byte[] upm = GSSUtils.getMechanism();\r\n    mechanisms = new byte[1][upm.length];\r\n    for (int i = 0; i < upm.length; i++) {\r\n        mechanisms[0][i] = upm[i];\r\n    }\r\n    if (target_supports != 0) {\r\n        supported_identity_token_type = SUPPORTED_IDENTITY_TOKEN_TYPES;\r\n    }\r\n    sasContext = new SAS_ContextSec((short) target_supports, (short) target_requires, priv, mechanisms, supported_identity_token_type);\r\n    return sasContext;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.getMethod",
	"Comment": "returns the method element for the specified method name and argument \ttypes in the class with the specified name. types are specified as \ttype names for primitive type such as int, float or as fully qualified \tclass names.",
	"Method": "Object getMethod(String className,String methodName,String[] argTypeNames){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.PersistenceManagerServiceImpl.forceInit",
	"Comment": "forces the initialization of the class pertaining to the specifiedclass object. this method does nothing if the class is alreadyinitialized prior to invocation.",
	"Method": "Class<T> forceInit(Class<T> klass){\r\n    try {\r\n        Class.forName(klass.getName(), true, klass.getClassLoader());\r\n    } catch (ClassNotFoundException e) {\r\n        throw new AssertionError(e);\r\n    }\r\n    return klass;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.getUpdateTimeout",
	"Comment": "gets the number of seconds to wait for an update statementto execute in the datastore associated with this persistencemanagerfactory.",
	"Method": "int getUpdateTimeout(){\r\n    return _persistenceManagerFactory.getUpdateTimeout();\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.CLIBootstrap.initCommandLineElements",
	"Comment": "populates the command line elements collection to contain the elementsfrom most specific matching pattern to least specific.",
	"Method": "void initCommandLineElements(){\r\n    elementsInScanOrder = new CommandLineElement[] { extDirs, endorsedDirs, accValuedOptions, accUnvaluedOptions, jvmValuedOptions, jvmPropertySettings, jvmMainSetting, otherJVMOptions, arguments };\r\n    int major = JDK.getMajor();\r\n    if (major >= 9) {\r\n        elementsInOutputOrder = new CommandLineElement[] { jvmValuedOptions, jvmPropertySettings, otherJVMOptions, accUnvaluedOptions, accValuedOptions, jvmMainSetting, arguments };\r\n    } else {\r\n        elementsInOutputOrder = new CommandLineElement[] { jvmValuedOptions, jvmPropertySettings, otherJVMOptions, extDirs, endorsedDirs, accUnvaluedOptions, accValuedOptions, jvmMainSetting, arguments };\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBLocalHomeInvocationHandler.handleSpecialEJBLocalHomeMethod",
	"Comment": "default impl to be overridden in subclasses if special invoke is necessary",
	"Method": "boolean handleSpecialEJBLocalHomeMethod(Method method,Class methodClass){\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.resources.javamail.admin.cli.DeleteJavaMailResource.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (!isResourceExists(domain.getResources(), jndiName)) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.mail.resource.notfound\", \"A Mail resource named {0} does not exist.\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (environment.isDas()) {\r\n        if (\"domain\".equals(target)) {\r\n            if (resourceUtil.getTargetsReferringResourceRef(jndiName).size() > 0) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.mail.resource.resource-ref.exist\", \"mail-resource [ {0} ] is referenced in an\" + \"instance/cluster target, Use delete-resource-ref on appropriate target\", jndiName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        } else {\r\n            if (!resourceUtil.isResourceRefInTarget(jndiName, target)) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.mail.resource.no.resource-ref\", \"mail-resource [ {0} ] is not referenced in target [ {1} ]\", jndiName, target));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n            if (resourceUtil.getTargetsReferringResourceRef(jndiName).size() > 1) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.mail.resource.multiple.resource-refs\", \"mail-resource [ {0} ] is referenced in multiple \" + \"instance/cluster targets, Use delete-resource-ref on appropriate target\", jndiName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        resourceUtil.deleteResourceRef(jndiName, target);\r\n        ConfigSupport.apply(new SingleConfigCode<Resources>() {\r\n            public Object run(Resources param) throws PropertyVetoException, TransactionFailure {\r\n                MailResource resource = (MailResource) ResourceUtil.getBindableResourceByName(domain.getResources(), jndiName);\r\n                return param.getResources().remove(resource);\r\n            }\r\n        }, domain.getResources());\r\n        report.setMessage(localStrings.getLocalString(\"delete.mail.resource.success\", \"Mail resource {0} deleted\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (TransactionFailure tfe) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.mail.resource.failed\", \"Unable to delete mail resource {0}\", jndiName) + \" \" + tfe.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.resources.javamail.admin.cli.DeleteJavaMailResource.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    MailResource resource = (MailResource) ResourceUtil.getBindableResourceByName(domain.getResources(), jndiName);\r\n    return param.getResources().remove(resource);\r\n}"
}, {
	"Path": "org.glassfish.deployapi.ProgressObjectImpl.addProgressListener",
	"Comment": "add a listener to receive progress events on deploymentactions.",
	"Method": "void addProgressListener(ProgressListener pol){\r\n    synchronized (listeners) {\r\n        listeners.add(pol);\r\n        if (deliveredEvents.size() > 0) {\r\n            for (Iterator i = deliveredEvents.iterator(); i.hasNext(); ) {\r\n                pol.handleProgressEvent((ProgressEvent) i.next());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.afterLast",
	"Comment": "moves the cursor to the end ofthis resultset object, just after thelast row. this method has no effect if the result set contains no rows.",
	"Method": "void afterLast(){\r\n    resultSet.afterLast();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlTimestamp.setTimeInternal",
	"Comment": "sets the sqltimestamp object without notification of the ownerfield. used internaly to populate date from db",
	"Method": "void setTimeInternal(long time){\r\n    super.setTime(time);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.setFields",
	"Comment": "sets the collection of fields maintained by this holder to the contents\tof the supplied array.",
	"Method": "void setFields(PersistenceFieldElement[] fields){\r\n    getClassImpl().changeFields(fields, Impl.SET);\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.CSIV2TaggedComponentInfo.getSSLInformation",
	"Comment": "retrieve the ssl tagged component from the compound securitymechanism.",
	"Method": "TLS_SEC_TRANS getSSLInformation(CompoundSecMech mech){\r\n    org.omg.IOP.TaggedComponent pcomp = mech.transport_mech;\r\n    TLS_SEC_TRANS ssl = getSSLComponent(pcomp);\r\n    return ssl;\r\n}"
}, {
	"Path": "org.glassfish.resources.module.ResourcesDeployer.extractJNDIName",
	"Comment": "extract the jndi name from the resource. collecting for resource valitation.",
	"Method": "String extractJNDIName(org.glassfish.resources.api.Resource resource){\r\n    HashMap attrs = resource.getAttributes();\r\n    return (String) attrs.get(JNDI_NAME);\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.tree.ListTreeAdaptor.getInstance",
	"Comment": "this method provides access to an listtreeadaptor \tinstance.each time it is invoked, it returns a new instance.",
	"Method": "TreeAdaptor getInstance(FacesContext ctx,LayoutComponent desc,UIComponent parent){\r\n    return new ListTreeAdaptor(desc, parent);\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.connectionCreated",
	"Comment": "fires probe event that a connection is created for the given jdbcconnection pool.",
	"Method": "void connectionCreated(){\r\n    poolProbeProvider.connectionCreatedEvent(poolName, appName, moduleName);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.Statement.findQueryTable",
	"Comment": "matches the table element tableelement to thecorresponding query table from the list tablelist.",
	"Method": "QueryTable findQueryTable(TableElement tableElement){\r\n    QueryTable table = null;\r\n    for (Iterator iter = tableList.iterator(); iter.hasNext() && table == null; ) {\r\n        QueryTable t = (QueryTable) iter.next();\r\n        if (t.getTableDesc().getTableElement() == tableElement) {\r\n            table = t;\r\n        }\r\n    }\r\n    return table;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.ParameterSupport.getParamNumber",
	"Comment": "internal method to extract the number from a parameter application in ejbql.",
	"Method": "int getParamNumber(String ejbqlParamDecl){\r\n    int paramNum = 0;\r\n    try {\r\n        paramNum = Integer.parseInt(ejbqlParamDecl.substring(1));\r\n    } catch (Exception ex) {\r\n        ErrorMsg.error(I18NHelper.getMessage(msgs, \"EXC_InvalidParameterIndex\", ejbqlParamDecl, String.valueOf(parameterTypes.length)));\r\n    }\r\n    if (paramNum < 1 || paramNum > parameterTypes.length) {\r\n        ErrorMsg.error(// NOI18N\r\n        I18NHelper.getMessage(msgs, \"EXC_InvalidParameterIndex\", ejbqlParamDecl, String.valueOf(parameterTypes.length)));\r\n    }\r\n    return paramNum;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.WeakHashSet.add",
	"Comment": "adds the specified element to this set if it is not alreadypresent.",
	"Method": "boolean add(Object o){\r\n    processQueue();\r\n    return super.add(WeakElement.create(o, this.queue));\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingRelationshipElementImpl.stripSchemaName",
	"Comment": "boston to pilsen conversion.\tthis method converts the absolute column names to relative names.",
	"Method": "void stripSchemaName(){\r\n    super.stripSchemaName();\r\n    if (_associatedColumns != null) {\r\n        ListIterator i = _associatedColumns.listIterator();\r\n        while (i.hasNext()) i.set(NameUtil.getRelativeMemberName((String) i.next()));\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.ConnectorClassLoader.addResourceAdapter",
	"Comment": "adds the requested resource adapter to the connectorclassloader. aconnectorclassloader is created with the moduledir as its search pathand this classloader is added to the classloader chain.",
	"Method": "void addResourceAdapter(String rarName,String moduleDir){\r\n    try {\r\n        File file = new File(moduleDir);\r\n        ASURLClassLoader cl = AccessController.doPrivileged(new PrivilegedAction<ASURLClassLoader>() {\r\n            public ASURLClassLoader run() {\r\n                return new ASURLClassLoader(parent);\r\n            }\r\n        });\r\n        cl.appendURL(file.toURI().toURL());\r\n        appendJars(file, cl);\r\n        classLoaderChain.add(cl);\r\n        rarModuleClassLoaders.put(rarName, cl);\r\n    } catch (MalformedURLException ex) {\r\n        _logger.log(Level.SEVERE, \"enterprise_util.connector_malformed_url\", ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.ConnectorClassLoader.addResourceAdapter",
	"Comment": "adds the requested resource adapter to the connectorclassloader. aconnectorclassloader is created with the moduledir as its search pathand this classloader is added to the classloader chain.",
	"Method": "void addResourceAdapter(String rarName,String moduleDir){\r\n    return new ASURLClassLoader(parent);\r\n}"
}, {
	"Path": "com.sun.gjc.util.StatementLeakDetector.printStatementLeakTrace",
	"Comment": "prints the stack trace of thread leaking statement to server logs",
	"Method": "void printStatementLeakTrace(StackTraceElement[] threadStackTrace){\r\n    StringBuffer stackTrace = new StringBuffer();\r\n    String msg = localStrings.getStringWithDefault(\"potential.statement.leak.msg\", \"A potential statement leak detected for connection pool \" + poolInfo + \". The stack trace of the thread is provided below : \", new Object[] { poolInfo });\r\n    stackTrace.append(msg);\r\n    stackTrace.append(\"\\n\");\r\n    for (int i = 2; i < threadStackTrace.length; i++) {\r\n        stackTrace.append(threadStackTrace[i].toString());\r\n        stackTrace.append(\"\\n\");\r\n    }\r\n    _logger.log(Level.WARNING, stackTrace.toString(), \"ConnectionPoolName=\" + poolInfo);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOConcreteBeanGenerator.getExceptionList",
	"Comment": "returns list of the declared exceptions for the method with this namein the abstract bean. returns null if such method does not existor does not have checked exceptions.",
	"Method": "String[] getExceptionList(AbstractMethodHelper methodHelper,String mname,String[] paramTypeNames,String[] getExceptionList,AbstractMethodHelper methodHelper,String mname){\r\n    return getExceptionList(methodHelper, mname, null);\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.jws.ExtensionFileManager.buildExtensionForJar",
	"Comment": "creates an extension extension for a jar file if the jar is in fact an extension.",
	"Method": "Extension buildExtensionForJar(File file,int extDirectoryNumber){\r\n    Extension result = null;\r\n    JarFile jarFile = null;\r\n    try {\r\n        jarFile = new JarFile(file);\r\n        ExtensionKey key = getDefinedExtensionKey(jarFile);\r\n        if (key != null) {\r\n            result = new Extension(key, file, extDirectoryNumber);\r\n        }\r\n        return result;\r\n    } finally {\r\n        if (jarFile != null) {\r\n            jarFile.close();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnectionFactory.resetIsolation",
	"Comment": "resets the isolation level for the managedconnection passed.if the transaction level is to be guaranteed to be the same as the onepresent when this managedconnection was created, as specifiedby the connectionrequestinfo passed, it sets the transactionisolation level from the connectionrequestinfo passed. else,it sets it to the transaction isolation passed.",
	"Method": "void resetIsolation(com.sun.jdbcra.spi.ManagedConnection mc,int tranIsol){\r\n    java.sql.Connection con = mc.getActualConnection();\r\n    if (con == null) {\r\n        return;\r\n    }\r\n    String tranIsolation = spec.getDetail(DataSourceSpec.TRANSACTIONISOLATION);\r\n    if (tranIsolation != null && tranIsolation.equals(\"\") == false) {\r\n        String guaranteeIsolationLevel = spec.getDetail(DataSourceSpec.GUARANTEEISOLATIONLEVEL);\r\n        if (guaranteeIsolationLevel != null && guaranteeIsolationLevel.equals(\"\") == false) {\r\n            boolean guarantee = (new Boolean(guaranteeIsolationLevel.toLowerCase())).booleanValue();\r\n            if (guarantee) {\r\n                int tranIsolationInt = getTransactionIsolationInt(tranIsolation);\r\n                try {\r\n                    if (tranIsolationInt != con.getTransactionIsolation()) {\r\n                        con.setTransactionIsolation(tranIsolationInt);\r\n                    }\r\n                } catch (java.sql.SQLException sqle) {\r\n                    _logger.log(Level.SEVERE, \"jdbc.exc_tx_level\");\r\n                    throw new ResourceException(\"The isolation level could not be set: \" + sqle.getMessage());\r\n                }\r\n            } else {\r\n                try {\r\n                    if (tranIsol != con.getTransactionIsolation()) {\r\n                        con.setTransactionIsolation(tranIsol);\r\n                    }\r\n                } catch (java.sql.SQLException sqle) {\r\n                    _logger.log(Level.SEVERE, \"jdbc.exc_tx_level\");\r\n                    throw new ResourceException(\"The isolation level could not be set: \" + sqle.getMessage());\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.help.HelpTreeIndexAdaptor.getId",
	"Comment": "this method returns the id for the given tree node \tmodel object.",
	"Method": "String getId(Object nodeObject){\r\n    String id = \"invalideNodeObjectType\";\r\n    if (nodeObject == null) {\r\n        id = \"nullNodeObject\";\r\n    } else if (nodeObject instanceof IndexItem) {\r\n        String target = ((IndexItem) nodeObject).getTarget();\r\n        id = genId(null != target ? target : \"i\" + Integer.toString(nodeObject.hashCode()));\r\n    } else if (nodeObject instanceof Index) {\r\n        id = getLayoutComponent().getId(FacesContext.getCurrentInstance(), getParentUIComponent());\r\n    }\r\n    return id;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.DBStatement.executeUpdate",
	"Comment": "delegates the executeupdate call to the preparedstatement wrapped bythis dbstatement.",
	"Method": "int executeUpdate(){\r\n    return preparedStmt.executeUpdate();\r\n}"
}, {
	"Path": "org.glassfish.admin.mejb.IIOPMBeanServerImpl.getMBeanInfo",
	"Comment": "this method discovers the attributes and operations that an mbean exposes for management.",
	"Method": "MBeanInfo getMBeanInfo(ObjectName name){\r\n    return server.getMBeanInfo(name);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.newQuery",
	"Comment": "create a new query with the class of the results, candidate collection,and filter.",
	"Method": "Query newQuery(Query newQuery,Object compiled,Query newQuery,Class cls,Query newQuery,Class cls,Collection cln,Query newQuery,Class cls,String filter,Query newQuery,Class cls,Collection cln,String filter){\r\n    assertIsOpen();\r\n    QueryImpl q = new QueryImpl(this, cls, cln, filter);\r\n    registerQuery(q);\r\n    return q;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.CallableStatementWrapper40.getResultSet",
	"Comment": "retrieves the current result as a resultset object.this method should be called only once per result.",
	"Method": "java.sql.ResultSet getResultSet(){\r\n    ResultSet rs = callableStatement.getResultSet();\r\n    if (rs == null)\r\n        return null;\r\n    incrementResultSetReferenceCount();\r\n    return new ResultSetWrapper40(this, rs);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getInputStreamForResource",
	"Comment": "returns the input stream with the supplied resource name found with \tthe supplied class name.\tnote, this implementation assumes the specified class loader is not null\tand needs not to be validated. any validation is done by getmappingclass\twhich is the only caller of this method.",
	"Method": "BufferedInputStream getInputStreamForResource(String className,ClassLoader classLoader,String resourceName){\r\n    InputStream is = ((className != null) ? classLoader.getResourceAsStream(resourceName) : null);\r\n    BufferedInputStream rc = null;\r\n    if (is != null && !(is instanceof BufferedInputStream)) {\r\n        rc = new BufferedInputStream(is);\r\n    } else {\r\n        rc = (BufferedInputStream) is;\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.setEJBLocalObjectImplClassName",
	"Comment": "sets the ejblocalobject implementation classname of the ejb.",
	"Method": "void setEJBLocalObjectImplClassName(String name){\r\n    this.ejbLocalObjectImplClassName = name;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.CMPBeanHelper.logJDOExceptionFromPKSetter",
	"Comment": "called from a cmp bean to log jdoexception message thrownfrom a pk setter method, with the internallogger. returns generated message to the caller to be used for aillegalstateexception.",
	"Method": "String logJDOExceptionFromPKSetter(String beanName,JDOException ex){\r\n    // NOI18N\r\n    String msg = // NOI18N\r\n    I18NHelper.getMessage(cmpMessages, \"EXC_PKUpdate\", beanName, findCallingMethodName());\r\n    if (cmpInternalLogger.isLoggable(Logger.FINE)) {\r\n        cmpInternalLogger.log(Logger.FINE, msg, ex);\r\n    }\r\n    return msg;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.ConnectionDefinitionUtils.getConnectionDefinitionProperties",
	"Comment": "gets the properties of the java bean connection definition class that\thave setter methods defined",
	"Method": "Set getConnectionDefinitionProperties(String connectionDefinitionClassName){\r\n    TreeMap propertySet = new TreeMap();\r\n    try {\r\n        Method[] methods = ConnectorRuntime.getRuntime().getConnectorClassLoader().loadClass(connectionDefinitionClassName).getMethods();\r\n        for (int i = 0; i < methods.length; i++) {\r\n            if (isValidSetterMethod(methods[i])) {\r\n                String name = methods[i].getName();\r\n                String propertyName = name.substring((name.indexOf(\"set\") + \"set\".length()), name.length());\r\n                propertySet.put(propertyName, propertyName);\r\n            }\r\n        }\r\n    } catch (SecurityException e) {\r\n        handleException(e, connectionDefinitionClassName);\r\n    } catch (ClassNotFoundException e) {\r\n        handleException(e, connectionDefinitionClassName);\r\n    }\r\n    ignoreOracle10gProperties(connectionDefinitionClassName, propertySet);\r\n    return propertySet.keySet();\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.obj.GroupOfNames.addMember",
	"Comment": "adds a member to the group.performs an ldap modify to add the member.",
	"Method": "boolean addMember(Principal member,boolean addMember,String dn){\r\n    if (!isBound()) {\r\n        throw new IllegalStateException();\r\n    }\r\n    if (debug) {\r\n        System.out.println(\"[debug] adding the member: \" + dn);\r\n    }\r\n    return modifyMember(dn, DirContext.ADD_ATTRIBUTE);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.createClassExistenceComponent",
	"Comment": "create a validation component which can check whether the class exists.",
	"Method": "ValidationComponent createClassExistenceComponent(String className,PersistenceFieldElement relatedField,ValidationComponent createClassExistenceComponent,String className){\r\n    return createClassExistenceComponent(className, null);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.PreparedStatementWrapper40.setRowId",
	"Comment": "sets the designated parameter to the given java.sql.rowid object. thedriver converts this to a sql rowid value when it sends itto the database",
	"Method": "void setRowId(int parameterIndex,RowId x){\r\n    preparedStatement.setRowId(parameterIndex, x);\r\n}"
}, {
	"Path": "org.glassfish.ejb.embedded.EJBContainerProviderImpl.getValidFile",
	"Comment": "create a file object from the location and report an errorif such file does not exist.returns null if such file does not exist.",
	"Method": "File getValidFile(String location,String msg_key){\r\n    File f = new File(location);\r\n    if (!f.exists()) {\r\n        _logger.log(Level.WARNING, msg_key, location);\r\n        f = null;\r\n    }\r\n    return f;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingTableElementImpl.getKey",
	"Comment": "returns the list of column names in the primary key for this \tmapping table.",
	"Method": "ArrayList getKey(){\r\n    if (_key == null)\r\n        _key = new ArrayList();\r\n    return _key;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.invalidateAllConnectionHandles",
	"Comment": "this method removes all the connection handles from the tableof connection handles and invalidates all of them so that anyoperation on those connection handles throws an exception.",
	"Method": "void invalidateAllConnectionHandles(){\r\n    Set handles = connectionHandles.keySet();\r\n    Iterator iter = handles.iterator();\r\n    try {\r\n        while (iter.hasNext()) {\r\n            ConnectionHolder ch = (ConnectionHolder) iter.next();\r\n            ch.invalidate();\r\n        }\r\n    } catch (java.util.NoSuchElementException nsee) {\r\n        throw new ResourceException(\"Could not find the connection handle: \" + nsee.getMessage());\r\n    }\r\n    connectionHandles.clear();\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.AppclientCommandArguments.newInstance",
	"Comment": "creates and returns a new appclientcommandarguments object from whichthe acc argument settings and the arguments to be passed to the appclient can be retrieved.",
	"Method": "AppclientCommandArguments newInstance(List<String> appclientCommandArgs){\r\n    AppclientCommandArguments result = new AppclientCommandArguments();\r\n    result.processAppclientArgs(appclientCommandArgs);\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.decrementNumConnFree",
	"Comment": "fires probe event related to the fact the given jdbc connection pool hasgot a decrement free connections size event.",
	"Method": "void decrementNumConnFree(){\r\n    poolProbeProvider.decrementNumConnFreeEvent(poolName, appName, moduleName);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.applyUpdates",
	"Comment": "this method is central to record changes to scocollections.",
	"Method": "void applyUpdates(String fieldName,SCOCollection c){\r\n    boolean debug = logger.isLoggable();\r\n    if (debug) {\r\n        logger.fine(\"sqlstore.sqlstatemanager.applyupdates\", fieldName);\r\n    }\r\n    FieldDesc fieldDesc = persistenceConfig.getField(fieldName);\r\n    if (fieldDesc instanceof ForeignFieldDesc) {\r\n        ArrayList removed = new ArrayList(c.getRemoved());\r\n        ArrayList added = new ArrayList(c.getAdded());\r\n        c.reset();\r\n        processCollectionUpdates((ForeignFieldDesc) fieldDesc, removed, added, null, true, false);\r\n    }\r\n    if (debug) {\r\n        logger.fine(\"sqlstore.sqlstatemanager.applyupdates.exit\");\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.resources.admin.cli.AddResources.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (!xmlFile.exists()) {\r\n        report.setMessage(localStrings.getLocalString(\"FileNotFound\", \"The system cannot find the path specified: {0}\", xmlFile.getName()));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        final ArrayList results = ResourcesManager.createResources(domain.getResources(), xmlFile, target, resourceFactory);\r\n        final Iterator resultsIter = results.iterator();\r\n        report.getTopMessagePart().setChildrenType(\"Command\");\r\n        boolean isSuccess = false;\r\n        while (resultsIter.hasNext()) {\r\n            ResourceStatus rs = ((ResourceStatus) resultsIter.next());\r\n            final String msgToAdd = rs.getMessage();\r\n            if ((msgToAdd != null) && (!msgToAdd.equals(\"\"))) {\r\n                final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n                part.setMessage(msgToAdd);\r\n            }\r\n            if (rs.getStatus() == ResourceStatus.SUCCESS || rs.isAlreadyExists())\r\n                isSuccess = true;\r\n        }\r\n        report.setActionExitCode((isSuccess) ? ActionReport.ExitCode.SUCCESS : ActionReport.ExitCode.FAILURE);\r\n        if (!isSuccess)\r\n            report.setMessage(localStrings.getLocalString(\"add.resources.failed\", \"add-resources <{0}> failed\", xmlFile.getName()));\r\n    } catch (Exception ex) {\r\n        Logger.getLogger(AddResources.class.getName()).log(Level.SEVERE, \"Something went wrong in add-resources\", ex);\r\n        report.setMessage(localStrings.getLocalString(\"add.resources.failed\", \"add-resources <{0}> failed\", xmlFile.getName()));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.Insn.setNext",
	"Comment": "insert the single instruction in the code sequence after this instruction.returns the inserted instruction.",
	"Method": "Insn setNext(Insn i){\r\n    if (nextInsn != null)\r\n        nextInsn.prevInsn = i;\r\n    if (i != null) {\r\n        i.nextInsn = nextInsn;\r\n        i.prevInsn = this;\r\n    }\r\n    nextInsn = i;\r\n    return i;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingElementImpl.compareTo",
	"Comment": "compares this object with the specified object for order. returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.the specified object must be mapping element, meaning it must be an instance of class mappingelementimpl or any subclass. if not a classcastexception is thrown.the order of mappingelementimpl objects is defined by the order of their names.mapping elements without name are considered to be less than any named mapping element.",
	"Method": "int compareTo(Object o){\r\n    if (o == null)\r\n        throw new ClassCastException();\r\n    if (o == this)\r\n        return 0;\r\n    String thisName = getName();\r\n    String otherName = ((MappingElementImpl) o).getName();\r\n    if (thisName == null)\r\n        return (otherName == null) ? 0 : -1;\r\n    if (otherName == null)\r\n        return 1;\r\n    int ret = Collator.getInstance().compare(thisName, otherName);\r\n    if ((ret == 0) && (getClass() != o.getClass()))\r\n        ret = getClass().getName().compareTo(o.getClass().getName());\r\n    return ret;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.WeakValueHashMap.containsKey",
	"Comment": "returns true if this map contains a mapping for the specifiedkey.",
	"Method": "boolean containsKey(Object key){\r\n    processQueue();\r\n    return super.containsKey(key);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.MappingGenerator.ensureDBSchemaExistence",
	"Comment": "check that there is a dbschema for each element of the suncmpmappings. for those which are missing, create a corresponding .dbschema file.",
	"Method": "void ensureDBSchemaExistence(ResourceReferenceDescriptor cmpResource,SunCmpMappings sunCmpMappings,String inputFilesPath,File classout){\r\n    String generatedSchemaName = getInfoHelper().getSchemaNameToGenerate();\r\n    Set tables = new HashSet();\r\n    int size = sunCmpMappings.sizeSunCmpMapping();\r\n    for (int i = 0; i < size; i++) {\r\n        SunCmpMapping sunCmpMapping = sunCmpMappings.getSunCmpMapping(i);\r\n        String schemaName = sunCmpMapping.getSchema();\r\n        if (StringHelper.isEmpty(schemaName)) {\r\n            if (!isVerifyFlag) {\r\n                addAllTables(sunCmpMapping, tables);\r\n                sunCmpMapping.setSchema(generatedSchemaName);\r\n            } else {\r\n                getConversionHelper().setEnsureValidation(false);\r\n            }\r\n        } else {\r\n            File dbschemaFile = new File(new StringBuffer(inputFilesPath).append(File.separator).append(schemaName).append(DBSCHEMA_EXTENSION).toString());\r\n            if (!(dbschemaFile.exists() && dbschemaFile.isFile() && dbschemaFile.canRead())) {\r\n                throw new GeneratorException(// NOI18N\r\n                I18NHelper.getMessage(messages, \"CMG.MissingDBSchema\", bundle.getApplication().getRegistrationName(), JDOCodeGeneratorHelper.getModuleName(bundle), schemaName));\r\n            }\r\n        }\r\n    }\r\n    if (tables.size() > 0) {\r\n        String userSchema = null;\r\n        Connection con = DeploymentHelper.getConnection(cmpResource.getJndiName());\r\n        DatabaseMetaData dmd = con.getMetaData();\r\n        if (DBVendorTypeHelper.requireUpperCaseSchema(dmd)) {\r\n            userSchema = dmd.getUserName().trim().toUpperCase();\r\n        }\r\n        ConnectionProvider cp = new ConnectionProvider(con, dmd.getDriverName().trim());\r\n        if (userSchema != null) {\r\n            cp.setSchema(userSchema);\r\n        }\r\n        OutputStream outstream = null;\r\n        try {\r\n            SchemaElementImpl outSchemaImpl = new SchemaElementImpl(cp);\r\n            SchemaElement schemaElement = new SchemaElement(outSchemaImpl);\r\n            schemaElement.setName(DBIdentifier.create(generatedSchemaName));\r\n            if (dmd.getDatabaseProductName().compareToIgnoreCase(\"MYSQL\") == 0)\r\n                outSchemaImpl.initTables(cp, new LinkedList(tables), new LinkedList(), true);\r\n            else\r\n                outSchemaImpl.initTables(cp, new LinkedList(tables), new LinkedList(), false);\r\n            outstream = new FileOutputStream(new File(classout, new StringBuffer(generatedSchemaName).append(DBSCHEMA_EXTENSION).toString()));\r\n            schemaElement.save(outstream);\r\n        } catch (IOException ex) {\r\n            throw JDOCodeGeneratorHelper.createGeneratorException(\"CMG.CannotSaveDBSchema\", bundle, ex);\r\n        } finally {\r\n            cp.closeConnection();\r\n            try {\r\n                if (outstream != null) {\r\n                    outstream.close();\r\n                }\r\n            } catch (IOException ex) {\r\n                if (logger.isLoggable(Logger.FINE))\r\n                    logger.fine(ex.toString());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.StatementWrapper.getMaxRows",
	"Comment": "retrieves the maximum number of rows that aresultset object produced by thisstatement object can contain.if this limit is exceeded,the excess rows are silently dropped.",
	"Method": "int getMaxRows(){\r\n    return jdbcStatement.getMaxRows();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.getMinPool",
	"Comment": "returns minimum number of persistencemanager instances in the pool",
	"Method": "int getMinPool(){\r\n    return minPool;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.clearWarnings",
	"Comment": "clears all warnings reported on this resultset object.after this method is called, the method getwarningsreturns null until a new warning isreported for this resultset object.",
	"Method": "void clearWarnings(){\r\n    resultSet.clearWarnings();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.codegen.CMPDeployerImpl.deploy",
	"Comment": "generates the concrete impls for all cmps in the application.",
	"Method": "void deploy(DeploymentContext ctx){\r\n    Application application = null;\r\n    EjbBundleDescriptorImpl bundle = null;\r\n    String beanName = null;\r\n    StringBuffer generatorExceptionMsg = null;\r\n    try {\r\n        CMPGenerator gen = new JDOCodeGenerator();\r\n        File stubsDir = ctx.getScratchDir(\"ejb\");\r\n        application = ctx.getModuleMetaData(Application.class);\r\n        if (_logger.isLoggable(Logger.FINE)) {\r\n            // NOI18N\r\n            _logger.fine(\"cmpc.processing_cmp\", application.getRegistrationName());\r\n        }\r\n        List<File> cmpFiles = new ArrayList<File>();\r\n        final ClassLoader jcl = application.getClassLoader();\r\n        bundle = ctx.getModuleMetaData(EjbBundleDescriptorImpl.class);\r\n        String archiveUri = ctx.getSource().getURI().getSchemeSpecificPart();\r\n        if (_logger.isLoggable(Logger.FINE)) {\r\n            // NOI18N\r\n            _logger.fine(\"[CMPC] Module Dir name is \" + archiveUri);\r\n        }\r\n        String generatedXmlsPath = ctx.getScratchDir(\"xml\").getCanonicalPath();\r\n        if (_logger.isLoggable(Logger.FINE)) {\r\n            // NOI18N\r\n            _logger.fine(\"[CMPC] Generated XML Dir name is \" + generatedXmlsPath);\r\n        }\r\n        try {\r\n            long start = System.currentTimeMillis();\r\n            gen.init(bundle, ctx, archiveUri, generatedXmlsPath);\r\n            Iterator ejbs = bundle.getEjbs().iterator();\r\n            while (ejbs.hasNext()) {\r\n                EjbDescriptor desc = (EjbDescriptor) ejbs.next();\r\n                beanName = desc.getName();\r\n                if (_logger.isLoggable(Logger.FINE)) {\r\n                    // NOI18N\r\n                    _logger.fine(\"[CMPC] Ejb Class Name: \" + desc.getEjbClassName());\r\n                }\r\n                if (desc instanceof IASEjbCMPEntityDescriptor) {\r\n                    IASEjbCMPEntityDescriptor entd = (IASEjbCMPEntityDescriptor) desc;\r\n                    if (_logger.isLoggable(Logger.FINE)) {\r\n                        // NOI18N\r\n                        _logger.fine(\"[CMPC] Home Object Impl name  is \" + entd.getLocalHomeImplClassName());\r\n                    }\r\n                    ClassLoader ocl = entd.getClassLoader();\r\n                    entd.setClassLoader(jcl);\r\n                    try {\r\n                        gen.generate(entd, stubsDir, stubsDir);\r\n                    } catch (GeneratorException e) {\r\n                        String msg = e.getMessage();\r\n                        _logger.warning(msg);\r\n                        generatorExceptionMsg = addGeneratorExceptionMessage(msg, generatorExceptionMsg);\r\n                    } finally {\r\n                        entd.setClassLoader(ocl);\r\n                    }\r\n                }\r\n            }\r\n            beanName = null;\r\n            cmpFiles.addAll(gen.cleanup());\r\n            long end = System.currentTimeMillis();\r\n            _logger.fine(\"CMP Generation: \" + (end - start) + \" msec\");\r\n        } catch (GeneratorException e) {\r\n            String msg = e.getMessage();\r\n            _logger.warning(msg);\r\n            generatorExceptionMsg = addGeneratorExceptionMessage(msg, generatorExceptionMsg);\r\n        }\r\n        bundle = null;\r\n        if (generatorExceptionMsg == null) {\r\n            long start = System.currentTimeMillis();\r\n            compileClasses(ctx, cmpFiles, stubsDir);\r\n            long end = System.currentTimeMillis();\r\n            _logger.fine(\"Java Compilation: \" + (end - start) + \" msec\");\r\n            start = System.currentTimeMillis();\r\n            CMPProcessor processor = new CMPProcessor(ctx);\r\n            processor.process();\r\n            end = System.currentTimeMillis();\r\n            _logger.fine(\"Java2DB processing: \" + (end - start) + \" msec\");\r\n            _logger.fine(\"cmpc.done_processing_cmp\", application.getRegistrationName());\r\n        }\r\n    } catch (GeneratorException e) {\r\n        _logger.warning(e.getMessage());\r\n        throw new DeploymentException(e);\r\n    } catch (Throwable e) {\r\n        String eType = e.getClass().getName();\r\n        String appName = application.getRegistrationName();\r\n        String exMsg = e.getMessage();\r\n        String msg = null;\r\n        if (bundle == null) {\r\n            msg = I18NHelper.getMessage(messages, \"cmpc.cmp_app_error\", eType, appName, exMsg);\r\n        } else {\r\n            String bundleName = bundle.getModuleDescriptor().getArchiveUri();\r\n            if (beanName == null) {\r\n                msg = I18NHelper.getMessage(messages, \"cmpc.cmp_module_error\", new Object[] { eType, appName, bundleName, exMsg });\r\n            } else {\r\n                msg = I18NHelper.getMessage(messages, \"cmpc.cmp_bean_error\", new Object[] { eType, beanName, appName, bundleName, exMsg });\r\n            }\r\n        }\r\n        _logger.log(Logger.SEVERE, msg, e);\r\n        throw new DeploymentException(msg);\r\n    }\r\n    if (generatorExceptionMsg != null) {\r\n        throw new DeploymentException(generatorExceptionMsg.toString());\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.connection.ConnectionManager.setPassword",
	"Comment": "sets the default database password for the current connection manager.",
	"Method": "void setPassword(char[] password){\r\n    this.password = password;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOConcreteBeanGenerator.getConcreteBeanForPCClass",
	"Comment": "returns the name of the concrete bean class for the specified name ofthe persistence capable class.",
	"Method": "String getConcreteBeanForPCClass(String pcClass){\r\n    return nameMapper.getConcreteBeanClassForEjbName(nameMapper.getEjbNameForPersistenceClass(pcClass));\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsConvert",
	"Comment": "retrieves whether this database supports the convertfor two given sql types.",
	"Method": "boolean supportsConvert(boolean supportsConvert,int fromType,int toType){\r\n    return databaseMetaData.supportsConvert(fromType, toType);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.J2EEDocumentBuilder.getDocument",
	"Comment": "return a document containing a result node based on the given result descriptor.",
	"Method": "Document getDocument(Descriptor descriptor,XMLNode node){\r\n    try {\r\n        Node domNode = node.writeDescriptor(newDocument(), descriptor);\r\n        if (domNode instanceof Document)\r\n            return (Document) domNode;\r\n        else\r\n            return domNode.getOwnerDocument();\r\n    } catch (Exception e) {\r\n        DOLUtils.getDefaultLogger().log(Level.WARNING, \"Error occurred\", e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingReferenceKeyElementImpl.getReferencedTable",
	"Comment": "get the referenced table of the reference key.this method is \tprovided as part of the implementation of the referencekey interface\tbut should only be used when a referencekey object is used or by \tthe runtime.",
	"Method": "TableElement getReferencedTable(){\r\n    ColumnPairElement[] columnPairs = getColumnPairs();\r\n    if ((columnPairs != null) && (columnPairs.length > 0))\r\n        return columnPairs[0].getReferencedColumn().getDeclaringTable();\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.JDOEJB11HelperImpl.assertPrimaryKeyFieldNotNull",
	"Comment": "validates that the primary key field of an object typeis not null.throws illegalargumentexception otherwise.",
	"Method": "void assertPrimaryKeyFieldNotNull(Object pkfield,String pkfieldName,String beanName){\r\n    if (pkfield == null) {\r\n        throw new IllegalArgumentException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"EXC_pkfieldnull_exception\", pkfieldName, beanName));\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.NestedAppClientDeployerHelper.processDependencies",
	"Comment": "creates downloadable artifacts for any jars or directory contents onwhich this nested app client might depend and adds them to thecollection of downloadable artifacts for this ear.",
	"Method": "void processDependencies(){\r\n    signedJARManager = new ApplicationSignedJARManager(JWSAdapterManager.signingAlias(dc()), jarSigner, habitat, dc(), this, earURI, earDirUserURI(dc()));\r\n    URI appClientURI = URI.create(Util.getURIName(appClientUserURI(dc())));\r\n    classPathForFacade.append(appClientURI);\r\n    final URI groupFacadeURIRelativeToFacade = facadeUserURI(dc()).relativize(relativeURIToGroupFacade());\r\n    classPathForFacade.append(\" \").append(groupFacadeURIRelativeToFacade.toASCIIString());\r\n    clientLevelDownloads.add(new Artifacts.FullAndPartURIs(facadeServerURI(dc()), facadeUserURI(dc())));\r\n    Set<URI> dependencyURIsProcessed = new HashSet<URI>();\r\n    URI appClientURIWithinEAR = URI.create(appClientDesc().getModuleDescriptor().getArchiveUri());\r\n    final Artifact appClientJARArtifact = newArtifact(appClientURIWithinEAR);\r\n    appClientJARArtifact.processArtifact(dependencyURIsProcessed, clientLevelDownloads(), earLevelDownloads());\r\n    addLibraryJARs(classPathForFacade, PUScanTargetsForFacade, dependencyURIsProcessed);\r\n    if (DeploymentUtils.useV2Compatibility(dc()) && !appClientDesc().getApplication().isVirtual()) {\r\n        addEJBJARs(classPathForFacade, dependencyURIsProcessed);\r\n        addTopLevelJARs(classPathForFacade, PUScanTargetsForFacade, dependencyURIsProcessed);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsResultSetConcurrency",
	"Comment": "retrieves whether this database supports the given concurrency typein combination with the given result set type.",
	"Method": "boolean supportsResultSetConcurrency(int type,int concurrency){\r\n    return databaseMetaData.supportsResultSetConcurrency(type, concurrency);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.LocalFieldDesc.computeTypePrecedence",
	"Comment": "this method computes the type precedence for the given field f.",
	"Method": "int computeTypePrecedence(){\r\n    ColumnElement c = (ColumnElement) columnDescs.get(0);\r\n    int sqlType = c.getType();\r\n    Class type = getType();\r\n    boolean isNullable = c.isNullable();\r\n    int precedence = Integer.MAX_VALUE;\r\n    switch(sqlType) {\r\n        case Types.TINYINT:\r\n        case Types.SMALLINT:\r\n        case Types.INTEGER:\r\n        case Types.BIGINT:\r\n            if (isNullable) {\r\n                precedence = lookupTypePrecedence(type, nullableNonScaledTypes);\r\n            } else {\r\n                precedence = lookupTypePrecedence(type, nonNullableNonScaledTypes);\r\n            }\r\n            break;\r\n        case Types.REAL:\r\n        case Types.FLOAT:\r\n        case Types.DOUBLE:\r\n            if (isNullable) {\r\n                precedence = lookupTypePrecedence(type, nullableScaledTypes);\r\n            } else {\r\n                precedence = lookupTypePrecedence(type, nonNullableScaledTypes);\r\n            }\r\n            break;\r\n        case Types.NUMERIC:\r\n        case Types.DECIMAL:\r\n            int scale = -1;\r\n            if ((scale = c.getScale().intValue()) == 0) {\r\n                if (isNullable) {\r\n                    precedence = lookupTypePrecedence(type, nullableNonScaledTypes);\r\n                } else {\r\n                    precedence = lookupTypePrecedence(type, nonNullableNonScaledTypes);\r\n                }\r\n            } else if (scale > 0) {\r\n                if (isNullable) {\r\n                    precedence = lookupTypePrecedence(type, nullableScaledTypes);\r\n                } else {\r\n                    precedence = lookupTypePrecedence(type, nonNullableScaledTypes);\r\n                }\r\n            }\r\n            break;\r\n        case Types.CHAR:\r\n        case Types.VARCHAR:\r\n        case Types.LONGVARCHAR:\r\n            if (type == String.class) {\r\n                precedence = 0;\r\n            }\r\n            break;\r\n        case Types.DATE:\r\n        case Types.TIMESTAMP:\r\n            if (java.util.Date.class.isAssignableFrom(type)) {\r\n                precedence = 0;\r\n            }\r\n            break;\r\n        case Types.BIT:\r\n            if (type == Boolean.class) {\r\n                if (isNullable) {\r\n                    precedence = 0;\r\n                } else {\r\n                    precedence = 1;\r\n                }\r\n            } else if (type == Boolean.TYPE) {\r\n                if (isNullable) {\r\n                    precedence = 1;\r\n                } else {\r\n                    precedence = 0;\r\n                }\r\n            }\r\n            break;\r\n    }\r\n    return precedence;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.work.WorkCoordinator.checkStateBeforeLocking",
	"Comment": "it is possible that state is modified just beforethe lock is obtained. so check it again.access the variable directly to avoid nested locking.",
	"Method": "boolean checkStateBeforeLocking(){\r\n    if (waitMode == WAIT_UNTIL_FINISH) {\r\n        return state < COMPLETED;\r\n    }\r\n    if (waitMode == WAIT_UNTIL_START) {\r\n        return state < STARTED;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.WebServiceHandlerChain.getHandlers",
	"Comment": "get ordered list of webservicehandler handlers for this endpoint.",
	"Method": "List<WebServiceHandler> getHandlers(){\r\n    return handlers;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.MappingPolicy.getUniqueLocalName",
	"Comment": "return a unique name for a column.the column will be unique withinthe named table.",
	"Method": "String getUniqueLocalName(String colName,String tableName,int maxLen){\r\n    return getUniqueName(colName, tableName, maxLen);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.UpdateStatement.processConstraintValue",
	"Comment": "redefines processconstraintvalue in order to skip the creation ofan inputvalue in the case of batch.",
	"Method": "void processConstraintValue(ConstraintValue node,StringBuffer result){\r\n    result.append(\"?\");\r\n    if (!batch)\r\n        generateInputValueForConstraintValueNode(node);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerWrapper.getObjectIdClass",
	"Comment": "in order for the application to construct instance of the objectid classit needs to know the class being used by the jdo implementation.",
	"Method": "Class getObjectIdClass(Class cls){\r\n    if (isValid) {\r\n        return pm.getObjectIdClass(cls);\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerwrapper.invalidpm\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.appclient.AppClientNode.registerBundle",
	"Comment": "register this node as a root node capable of loading entire dd files",
	"Method": "String registerBundle(Map publicIDToDTD){\r\n    publicIDToDTD.put(PUBLIC_DTD_ID, SYSTEM_ID);\r\n    publicIDToDTD.put(PUBLIC_DTD_ID_12, SYSTEM_ID_12);\r\n    return tag.getQName();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.ConstBasic.setIndex",
	"Comment": "sets the index of this constant with its containing constant pool",
	"Method": "void setIndex(int ind){\r\n    index = ind;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.getRelationships",
	"Comment": "returns the subset of the collection of fields which are relationahips.",
	"Method": "RelationshipElement[] getRelationships(){\r\n    PersistenceFieldElement[] fields = getFields();\r\n    int i, count = ((fields != null) ? fields.length : 0);\r\n    ArrayList relationships = new ArrayList(count);\r\n    for (i = 0; i < count; i++) {\r\n        PersistenceFieldElement field = fields[i];\r\n        if (field instanceof RelationshipElement)\r\n            relationships.add(field);\r\n    }\r\n    count = relationships.size();\r\n    return ((RelationshipElement[]) relationships.toArray(new RelationshipElement[count]));\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.j2ee.RegistrationSupport.processResourceRef",
	"Comment": "examine the mbean to see if it is a resourceref that should be manifested under this server,and if so, register a jsr 77 mbean for it.",
	"Method": "ObjectName processResourceRef(ResourceRef ref){\r\n    if (ref == null) {\r\n        throw new IllegalArgumentException(\"resource-ref is null\");\r\n    }\r\n    if (!mServer.getName().equals(ref.getParent(Server.class).getName())) {\r\n        cdebug(\"ResourceRef is not a child of server \" + getObjectName(mServer));\r\n        return null;\r\n    }\r\n    Resource res = null;\r\n    List<Resource> resources = getDomain().getResources().getResources();\r\n    for (Resource resource : resources) {\r\n        String name = null;\r\n        if (resource instanceof BindableResource) {\r\n            name = ((BindableResource) resource).getJndiName();\r\n        }\r\n        if (resource instanceof Named) {\r\n            name = ((Named) resource).getName();\r\n        }\r\n        if (resource instanceof ResourcePool) {\r\n            name = ((ResourcePool) resource).getName();\r\n        }\r\n        if (name != null && name.equals(ref.getRef()))\r\n            res = resource;\r\n    }\r\n    if (res == null) {\r\n        throw new IllegalArgumentException(\"ResourceRef refers to non-existent resource: \" + ref);\r\n    }\r\n    final String configType = Util.getTypeProp(getObjectName(res));\r\n    final Class<J2EEManagedObjectImplBase> implClass = CONFIG_RESOURCE_TYPES.get(configType);\r\n    if (implClass == null) {\r\n        mLogger.fine(\"Unrecognized resource type for JSR 77 purposes: \" + getObjectName(res));\r\n        return null;\r\n    }\r\n    final Class<J2EEManagedObject> intf = (Class) ClassUtil.getFieldValue(implClass, \"INTF\");\r\n    ObjectName mbean77 = null;\r\n    try {\r\n        final MetadataImpl meta = new MetadataImpl();\r\n        meta.setCorrespondingRef(getObjectName(ref));\r\n        meta.setCorrespondingConfig(getObjectName(res));\r\n        mbean77 = registerJ2EEChild(mJ2EEServer.objectName(), meta, intf, implClass, Util.getNameProp(getObjectName(res)));\r\n        synchronized (mConfigRefTo77) {\r\n            mConfigRefTo77.put(getObjectName(ref), mbean77);\r\n        }\r\n    } catch (final Exception e) {\r\n        mLogger.log(Level.INFO, AMXEELoggerInfo.cantRegisterMbean, new Object[] { getObjectName(ref), e });\r\n    }\r\n    return mbean77;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.ConnectionPool.performMaxConnectionUsageOperation",
	"Comment": "if the resource is used for maxconnectionusage times, destroy and create one",
	"Method": "void performMaxConnectionUsageOperation(ResourceHandle handle){\r\n    ds.removeResource(handle);\r\n    _logger.log(Level.INFO, \"resource_pool.remove_max_used_conn\", new Object[] { handle.getId(), handle.getUsageCount() });\r\n    if (poolLifeCycleListener != null) {\r\n        poolLifeCycleListener.decrementConnectionUsed(handle.getId());\r\n    }\r\n    if (ds.getResourcesSize() < steadyPoolSize) {\r\n        try {\r\n            createResourceAndAddToPool(handle.getResourceAllocator());\r\n        } catch (Exception e) {\r\n            _logger.log(Level.WARNING, \"resource_pool.failed_creating_resource\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.EjbReferenceDescriptor.setReferringBundleDescriptor",
	"Comment": "set the referring bundle, i.e. the bundle within which thisejb reference is declared.",
	"Method": "void setReferringBundleDescriptor(BundleDescriptor referringBundle){\r\n    this.referringBundle = referringBundle;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.logging.AbstractLogger.config",
	"Comment": "log a config message.\tif the logger is currently enabled for the config message \tlevel then the given message is forwarded to all the\tregistered output handler objects.",
	"Method": "void config(String msg){\r\n    log(CONFIG, msg);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getFloat",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object asa float in the java programming language.",
	"Method": "float getFloat(int columnIndex,float getFloat,String columnName){\r\n    return resultSet.getFloat(columnName);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.registry.MonitoredObjectType.getMonitoredObjectType",
	"Comment": "get a monitoredobjecttype instance for the specified string type.",
	"Method": "MonitoredObjectType getMonitoredObjectType(String typeName){\r\n    MonitoredObjectType type = getMonitoredObjectTypeOrNull(typeName);\r\n    if (type == null) {\r\n        String msg = \"admin.monitor.unknown_type_name:\" + typeName;\r\n        throw new IllegalArgumentException(msg);\r\n    }\r\n    return type;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOConcreteBean11Generator.getSignaturesOfGeneratorClasses",
	"Comment": "returns the signatures of the classes and properties which areinvolved in the codegen.",
	"Method": "String getSignaturesOfGeneratorClasses(){\r\n    StringBuffer signatures = // adding signature of JDOConcreteBeanGenerator\r\n    new StringBuffer().append(super.getSignaturesOfGeneratorClasses()).append(// adding signature of JDOConcreteBean11Generator\r\n    CMPTemplateFormatter.signatureDelimiter_).append(JDOConcreteBean11Generator.SIGNATURE).append(// adding signature of CMP11Templates.properties\r\n    CMPTemplateFormatter.signatureDelimiter_).append(CMP11TemplateFormatter.signature1_1Template);\r\n    return signatures.toString();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.SunTransactionHelper.cleanUpResources",
	"Comment": "removes all entries that correspond to the same connection factory name.",
	"Method": "void cleanUpResources(String name){\r\n    synchronized (pmf_listSyncObject) {\r\n        for (Iterator it = pmf_list.iterator(); it.hasNext(); ) {\r\n            PersistenceManagerFactory pmf = (PersistenceManagerFactory) it.next();\r\n            if (pmf.getConnectionFactoryName().equals(name)) {\r\n                it.remove();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.resources.module.ResourceUtilities.resolveResourceDuplicatesConflictsWithinArchive",
	"Comment": "resolves all duplicates and conflicts within an archive and returns a set of resources that needs to be created for the archive being deployed. the deployment backend would then use these set of resources to check for conflicts with resources existing in domain.xml and then continue with deployment. all resource duplicates within an archive found are flagged with a warning and only one resource is added in the final resource set returned. we currently do not handle any resource conflicts found within the archive and the method throws an exception when this condition is detected.",
	"Method": "Set<org.glassfish.resources.api.Resource> resolveResourceDuplicatesConflictsWithinArchive(List<org.glassfish.resources.admin.cli.SunResourcesXML> sunResList){\r\n    boolean conflictExist = false;\r\n    StringBuffer conflictingResources = new StringBuffer();\r\n    Set<org.glassfish.resources.api.Resource> resourceSet = new HashSet<org.glassfish.resources.api.Resource>();\r\n    Iterator<org.glassfish.resources.admin.cli.SunResourcesXML> sunResourcesXMLIter = sunResList.iterator();\r\n    while (sunResourcesXMLIter.hasNext()) {\r\n        org.glassfish.resources.admin.cli.SunResourcesXML sunResXML = sunResourcesXMLIter.next();\r\n        List<org.glassfish.resources.api.Resource> resources = sunResXML.getResourcesList();\r\n        Iterator<org.glassfish.resources.api.Resource> resourcesIter = resources.iterator();\r\n        while (resourcesIter.hasNext()) {\r\n            org.glassfish.resources.api.Resource res = resourcesIter.next();\r\n            Iterator<org.glassfish.resources.api.Resource> resSetIter = resourceSet.iterator();\r\n            boolean addResource = true;\r\n            while (resSetIter.hasNext()) {\r\n                Resource existingRes = resSetIter.next();\r\n                if (existingRes.equals(res)) {\r\n                    addResource = false;\r\n                    _logger.warning(localStrings.getString(\"duplicate.resource.sun.resource.xml\", getIdToCompare(res), sunResXML.getXMLPath()));\r\n                    break;\r\n                }\r\n                if (existingRes.isAConflict(res)) {\r\n                    addResource = false;\r\n                    conflictingResources.append(\"\\n\");\r\n                    String message = localStrings.getString(\"conflict.resource.sun.resource.xml\", getIdToCompare(res), sunResXML.getXMLPath());\r\n                    conflictingResources.append(message);\r\n                    _logger.warning(message);\r\n                    if (_logger.isLoggable(Level.FINE))\r\n                        logAttributes(res);\r\n                }\r\n            }\r\n            if (addResource)\r\n                resourceSet.add(res);\r\n        }\r\n    }\r\n    if (conflictingResources.toString().length() > 0) {\r\n        throw new ResourceConflictException(conflictingResources.toString());\r\n    }\r\n    return resourceSet;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.logging.LogHelper.isJDK14",
	"Comment": "check to see if the jdk 1.4 logging environment is available.",
	"Method": "boolean isJDK14(){\r\n    try {\r\n        Class logger = Class.forName(\"java.util.logging.Logger\");\r\n        return true;\r\n    } catch (ClassNotFoundException ex) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.archivist.Archivist.open",
	"Comment": "open a new archive file, read the xml descriptor and set theconstructeddol descriptor instance",
	"Method": "T open(ReadableArchive archive,T open,ReadableArchive descriptorArchive,ReadableArchive contentArchive,T open,ReadableArchive descriptorArchive,ReadableArchive contentArchive,Application app,T open,ReadableArchive archive,Application app,T open,String path,T open,File file){\r\n    path = file.getAbsolutePath();\r\n    ReadableArchive archive = archiveFactory.openArchive(file);\r\n    T descriptor = open(archive);\r\n    archive.close();\r\n    validate(null);\r\n    return descriptor;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.ConnectionPoolObjectsUtils.getTransactionSupport",
	"Comment": "a utility method to map transactionsupport ints as representedin connectorconstants to the new transactionsupport enum",
	"Method": "TransactionSupport getTransactionSupport(int ts){\r\n    switch(ts) {\r\n        case ConnectorConstants.NO_TRANSACTION_INT:\r\n            return TransactionSupport.NO_TRANSACTION;\r\n        case ConnectorConstants.LOCAL_TRANSACTION_INT:\r\n            return TransactionSupport.LOCAL_TRANSACTION;\r\n        case ConnectorConstants.XA_TRANSACTION_INT:\r\n            return TransactionSupport.XA_TRANSACTION;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.JDOQLElements.isAggregate",
	"Comment": "returns whether the result of the jdoql query is associated toan aggregate function.",
	"Method": "boolean isAggregate(){\r\n    return isAggregate;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.ModelValidator.constructClassException",
	"Comment": "constructs a modelvalidationexception for class validation tests \tusing the supplied class name, related field, and key base.",
	"Method": "ModelValidationException constructClassException(String className,Object relatedField,String keyBase,ModelValidationException constructClassException,int errorType,String className,Object relatedField,String keyBase){\r\n    return new ModelValidationException(errorType, getOffendingObject(relatedField), I18NHelper.getMessage(getMessages(), getKey(keyBase, relatedField), getArguments(className, relatedField)));\r\n}"
}, {
	"Path": "com.sun.enterprise.naming.impl.TransientContext.resolveContext",
	"Comment": "finds if the name searched for is a type of context or anyother type of object.",
	"Method": "TransientContext resolveContext(String s){\r\n    TransientContext ctx;\r\n    Object obj = bindings.get(s);\r\n    if (obj == null) {\r\n        throw new NameNotFoundException(s);\r\n    }\r\n    if (obj instanceof TransientContext) {\r\n        ctx = (TransientContext) obj;\r\n    } else {\r\n        throw new NameAlreadyBoundException(s);\r\n    }\r\n    return ctx;\r\n}"
}, {
	"Path": "org.glassfish.persistence.ejb.entitybean.container.EntityContextImpl.doesMatch",
	"Comment": "called from incompletetxcache to get an already cached context",
	"Method": "boolean doesMatch(BaseContainer baseContainer,int pkHashCode,Object pk){\r\n    return ((container == baseContainer) && (_pkHashCode == pkHashCode) && (_primaryKey.equals(pk)));\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ConnectionHolder.prepareCall",
	"Comment": "creates acallablestatementobject for calling databasestored procedures.",
	"Method": "CallableStatement prepareCall(String sql,CallableStatement prepareCall,String sql,int resultSetType,int resultSetConcurrency,CallableStatement prepareCall,String sql,int resultSetType,int resultSetConcurrency,int resultSetHoldability){\r\n    checkValidity();\r\n    jdbcPreInvoke();\r\n    CallableStatement stmt = con.prepareCall(sql, resultSetType, resultSetConcurrency, resultSetHoldability);\r\n    if (statementTimeoutEnabled) {\r\n        stmt.setQueryTimeout(statementTimeout);\r\n    }\r\n    return stmt;\r\n}"
}, {
	"Path": "org.glassfish.resources.admin.cli.DeleteJndiResource.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (!doesResourceExist(domain.getResources(), jndiName)) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.jndi.resource.notfound\", \"A jndi resource named {0} does not exist.\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (environment.isDas()) {\r\n        if (\"domain\".equals(target)) {\r\n            if (resourceUtil.getTargetsReferringResourceRef(jndiName).size() > 0) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.jndi.resource.resource-ref.exist\", \"external-jndi-resource [ {0} ] is referenced in an\" + \"instance/cluster target, Use delete-resource-ref on appropriate target\", jndiName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        } else {\r\n            if (!resourceUtil.isResourceRefInTarget(jndiName, target)) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.jndi.resource.no.resource-ref\", \"external-jndi-resource [ {0} ] is not referenced in target [ {1} ]\", jndiName, target));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n            if (resourceUtil.getTargetsReferringResourceRef(jndiName).size() > 1) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.jndi.resource.multiple.resource-refs\", \"external-jndi-resource [ {0} ] is referenced in multiple \" + \"instance/cluster targets, Use delete-resource-ref on appropriate target\", jndiName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        resourceUtil.deleteResourceRef(jndiName, target);\r\n        ConfigSupport.apply(new SingleConfigCode<Resources>() {\r\n            public Object run(Resources param) throws PropertyVetoException, TransactionFailure {\r\n                ExternalJndiResource resource = (ExternalJndiResource) domain.getResources().getResourceByName(ExternalJndiResource.class, jndiName);\r\n                if (resource.getJndiName().equals(jndiName)) {\r\n                    return param.getResources().remove(resource);\r\n                }\r\n                return null;\r\n            }\r\n        }, domain.getResources());\r\n        report.setMessage(localStrings.getLocalString(\"\" + \"delete.jndi.resource.success\", \"Jndi resource {0} deleted.\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (TransactionFailure tfe) {\r\n        report.setMessage(localStrings.getLocalString(\"\" + \"delete.jndi.resource.fail\", \"Unable to delete jndi resource {0}.\", jndiName) + \" \" + tfe.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.resources.admin.cli.DeleteJndiResource.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    ExternalJndiResource resource = (ExternalJndiResource) domain.getResources().getResourceByName(ExternalJndiResource.class, jndiName);\r\n    if (resource.getJndiName().equals(jndiName)) {\r\n        return param.getResources().remove(resource);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.MappingPolicy.getOverrideForLength",
	"Comment": "provides a string that can be recognized as a policy to override thedefault length of a field.",
	"Method": "String getOverrideForLength(String className,String fieldName){\r\n    return className + DOT + fieldName + DOT + DatabaseGenerationConstants.INDICATOR_JDBC_LENGTH;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceElementCollection.setElements",
	"Comment": "set the collection of elements maintained by this holder to the \tsupplied array.this method should only be used internally and for \tcloning and archiving.",
	"Method": "void setElements(PersistenceElement[] elements){\r\n    _elements = elements;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.lookupFromVersionConsistencyCache",
	"Comment": "looks up given instance from the version consistency cache, if theinstance supports version consistency.",
	"Method": "StateManager lookupFromVersionConsistencyCache(StateManager sm){\r\n    StateManager rc = null;\r\n    if (null != sm && sm.hasVersionConsistency()) {\r\n        Class pcType = sm.getPersistent().getClass();\r\n        Object oid = sm.getObjectId();\r\n        VersionConsistencyCache vcCache = persistenceManagerFactory.getVersionConsistencyCache();\r\n        rc = vcCache.get(pcType, oid);\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxUserNameLength",
	"Comment": "retrieves the maximum number of characters this database allows ina user name.",
	"Method": "int getMaxUserNameLength(){\r\n    return databaseMetaData.getMaxUserNameLength();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MailConfiguration.getMailFrom",
	"Comment": "get the mail from address for the mail session the server will provide.",
	"Method": "String getMailFrom(){\r\n    return this.mailFrom;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBContextImpl.registerResource",
	"Comment": "register a resource opened by the ejb instanceassociated with this context.",
	"Method": "void registerResource(ResourceHandle h){\r\n    if (resources == null)\r\n        resources = new ArrayList();\r\n    resources.add(h);\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbSessionDescriptor.print",
	"Comment": "returns a formatted string of the attributes of this object.",
	"Method": "void print(StringBuffer toStringBuffer){\r\n    toStringBuffer.append(\"Session descriptor\");\r\n    toStringBuffer.append(\"\\n sessionType \").append(getSessionType());\r\n    super.print(toStringBuffer);\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.connectionMatched",
	"Comment": "fires probe event that a connection under test matches the currentrequest for the given jdbc connection pool.",
	"Method": "void connectionMatched(){\r\n    poolProbeProvider.connectionMatchedEvent(poolName, appName, moduleName);\r\n}"
}, {
	"Path": "org.glassfish.jdbc.admin.cli.CreateJdbcResourceTest.getFileName",
	"Comment": "returns the domaintest file name without the .xml extension to load the test configurationfrom.",
	"Method": "String getFileName(){\r\n    return \"DomainTest\";\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ConnectionHolder.setHoldability",
	"Comment": "sets the holdability of resultset objects created using this connection object.",
	"Method": "void setHoldability(int holdability){\r\n    checkValidity();\r\n    con.setHoldability(holdability);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.connector.ConnectorNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object newDescriptor){\r\n    if (newDescriptor instanceof ResourceAdapter) {\r\n        getSunConnectorDescriptor().setResourceAdapter((ResourceAdapter) newDescriptor);\r\n    } else if (newDescriptor instanceof RoleMap) {\r\n        getSunConnectorDescriptor().setRoleMap((RoleMap) newDescriptor);\r\n    } else {\r\n        super.addDescriptor(newDescriptor);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorService.getConnectorDescriptor",
	"Comment": "obtains the connector descriptor pertaining to rar.if connectordescriptor is present in registry, it is obtained fromregistry and returned. else it is explicitly read from directorywhere rar is exploded.",
	"Method": "ConnectorDescriptor getConnectorDescriptor(String rarName){\r\n    if (rarName == null) {\r\n        return null;\r\n    }\r\n    ConnectorDescriptor desc = null;\r\n    desc = _registry.getDescriptor(rarName);\r\n    if (desc != null) {\r\n        return desc;\r\n    }\r\n    String moduleDir;\r\n    if (rarName.indexOf(ConnectorConstants.EMBEDDEDRAR_NAME_DELIMITER) != -1) {\r\n        try {\r\n            desc = loadConnectorDescriptorForEmbeddedRAR(rarName);\r\n            if (desc != null)\r\n                return desc;\r\n        } catch (ConnectorRuntimeException e) {\r\n            throw e;\r\n        }\r\n    }\r\n    if (ConnectorsUtil.belongsToSystemRA(rarName)) {\r\n        moduleDir = ConnectorsUtil.getSystemModuleLocation(rarName);\r\n    } else {\r\n        moduleDir = ConnectorsUtil.getLocation(rarName);\r\n    }\r\n    if (moduleDir != null) {\r\n        desc = ConnectorDDTransformUtils.getConnectorDescriptor(moduleDir, rarName);\r\n    } else {\r\n        _logger.log(Level.SEVERE, \"rardeployment.no_module_deployed\", rarName);\r\n    }\r\n    return desc;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ApplicationClientDescriptor.getEnvironmentPropertyByName",
	"Comment": "returns the environment property object searching on the supplied key.throws an illegal argument exception if no such environment property exists.",
	"Method": "EnvironmentProperty getEnvironmentPropertyByName(String name){\r\n    for (Iterator itr = this.getEnvironmentProperties().iterator(); itr.hasNext(); ) {\r\n        EnvironmentProperty ev = (EnvironmentProperty) itr.next();\r\n        if (ev.getName().equals(name)) {\r\n            return ev;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionappclienthasnoenvpropertybyname\", \"This application client [{0}] has no environment property by the name of [{1}]\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "org.glassfish.javaee.core.deployment.JavaEEDeployer.getModuleClassPath",
	"Comment": "returns the classpath associated with this modulecan be used to compile generated cmp classes,rmi stubs etc.",
	"Method": "String getModuleClassPath(DeploymentContext ctx){\r\n    StringBuilder classpath = new StringBuilder(ASClassLoaderUtil.getModuleClassPath(habitat, ctx));\r\n    try {\r\n        classpath.append(ctx.getSourceDir().toURI().getPath());\r\n        classpath.append(File.pathSeparator);\r\n        classpath.append(ctx.getScratchDir(\"ejb\").toURI().getPath());\r\n        classpath.append(File.pathSeparator);\r\n        Application app = ctx.getModuleMetaData(Application.class);\r\n        if (!app.isVirtual()) {\r\n            ReadableArchive parentArchive = ctx.getSource().getParentArchive();\r\n            String compatProp = ctx.getAppProps().getProperty(DeploymentProperties.COMPATIBILITY);\r\n            List<URL> earLibURLs = ASClassLoaderUtil.getAppLibDirLibrariesAsList(new File(parentArchive.getURI()), app.getLibraryDirectory(), compatProp);\r\n            for (URL url : earLibURLs) {\r\n                classpath.append(url.toURI().getPath());\r\n                classpath.append(File.pathSeparator);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n    }\r\n    return classpath.toString();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jacc.provider.SimplePolicyProvider.implies",
	"Comment": "evaluates the global policy for the permissions granted tothe protectiondomain and tests whether the permission isgranted.",
	"Method": "boolean implies(ProtectionDomain domain,Permission permission){\r\n    byte[] alreadyCalled = (byte[]) reentrancyStatus.get();\r\n    if (alreadyCalled[0] == 1) {\r\n        return true;\r\n    } else {\r\n        alreadyCalled[0] = 1;\r\n        try {\r\n            return doImplies(domain, permission);\r\n        } finally {\r\n            alreadyCalled[0] = 0;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.QueryDescriptor.getHasRemoteReturnTypeMapping",
	"Comment": "returns true only if a remote return type has been specified.",
	"Method": "boolean getHasRemoteReturnTypeMapping(){\r\n    return (returnTypeMapping == RETURN_REMOTE_TYPES);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ActiveResourceAdapterImpl.createAllConnectorResources",
	"Comment": "creates both the default connector connection pools and resources",
	"Method": "void createAllConnectorResources(){\r\n    try {\r\n        if (desc_.getSunDescriptor() != null && desc_.getSunDescriptor().getResourceAdapter() != null) {\r\n            String jndiName = (String) desc_.getSunDescriptor().getResourceAdapter().getValue(ResourceAdapter.JNDI_NAME);\r\n            if (jndiName == null || jndiName.equals(\"\")) {\r\n                createDefaultConnectorConnectionPools(true);\r\n            } else {\r\n                createSunRAConnectionPool();\r\n                createDefaultConnectorConnectionPools(false);\r\n            }\r\n        } else {\r\n            createDefaultConnectorConnectionPools(false);\r\n        }\r\n        createDefaultConnectorResources();\r\n    } catch (ConnectorRuntimeException cre) {\r\n        _logger.log(Level.SEVERE, \"rardeployment.defaultpoolresourcecreation.failed\", cre);\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Error while trying to create the default connector\" + \"connection pool and resource\", cre);\r\n        }\r\n    } catch (Exception e) {\r\n        _logger.log(Level.SEVERE, \"rardeployment.defaultpoolresourcecreation.failed\", e);\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Error while trying to create the default connector\" + \"connection pool and resource\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.HashSet.addAllInternal",
	"Comment": "adds a collection to the list without recording changes if the hashset isnot deferred. otherwise, add o to the removed list.",
	"Method": "void addAllInternal(Collection c){\r\n    if (c == null) {\r\n        return;\r\n    }\r\n    Iterator iter = c.iterator();\r\n    while (iter.hasNext()) {\r\n        addInternal(iter.next());\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.matchManagedConnections",
	"Comment": "returns a matched managedconnection from the candidateset of managedconnection objects.",
	"Method": "javax.resource.spi.ManagedConnection matchManagedConnections(java.util.Set connectionSet,javax.security.auth.Subject subject,ConnectionRequestInfo cxRequestInfo){\r\n    logFine(\"In matchManagedConnections\");\r\n    if (connectionSet == null) {\r\n        return null;\r\n    }\r\n    PasswordCredential pc = SecurityUtils.getPasswordCredential(this, subject, cxRequestInfo);\r\n    java.util.Iterator iter = connectionSet.iterator();\r\n    ManagedConnectionImpl mc = null;\r\n    while (iter.hasNext()) {\r\n        try {\r\n            mc = (ManagedConnectionImpl) iter.next();\r\n        } catch (java.util.NoSuchElementException nsee) {\r\n            _logger.log(Level.SEVERE, \"jdbc.exc_iter\");\r\n            throw new ResourceException(nsee.getMessage());\r\n        }\r\n        if (pc == null && this.equals(mc.getManagedConnectionFactory())) {\r\n            return mc;\r\n        } else if (SecurityUtils.isPasswordCredentialEqual(pc, mc.getPasswordCredential())) {\r\n            return mc;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ConnectionHolder.getTypeMap",
	"Comment": "retrieves the map object associated with connection object.",
	"Method": "Map<String, Class<?>> getTypeMap(){\r\n    checkValidity();\r\n    return con.getTypeMap();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.CallableStatementWrapper40.getNClob",
	"Comment": "retrieves the value of a jdbc nclob parameter as ajava.sql.nclob object in the java programming language.",
	"Method": "NClob getNClob(int parameterIndex,NClob getNClob,String parameterName){\r\n    return callableStatement.getNClob(parameterName);\r\n}"
}, {
	"Path": "org.glassfish.appclient.server.core.AppClientDeployerHelper.JAROfExpandedSubmodule",
	"Comment": "if the specified uri is for an expanded submodule, makes a copy ofthe submodule as a jar and returns the uri for the copy.",
	"Method": "File JAROfExpandedSubmodule(URI candidateSubmoduleURI){\r\n    ReadableArchive source = new FileArchive();\r\n    source.open(dc().getSource().getParentArchive().getURI().resolve(expandedDirURI(candidateSubmoduleURI)));\r\n    OutputJarArchive target = new OutputJarArchive();\r\n    target.create(dc().getScratchDir(\"xml\").toURI().resolve(candidateSubmoduleURI));\r\n    Manifest mf = source.getManifest();\r\n    OutputStream os = target.putNextEntry(JarFile.MANIFEST_NAME);\r\n    mf.write(os);\r\n    target.closeEntry();\r\n    copyArchive(source, target, Collections.EMPTY_SET);\r\n    target.close();\r\n    return new File(target.getURI());\r\n}"
}, {
	"Path": "org.glassfish.deployapi.ProgressObjectImpl.getClientConfiguration",
	"Comment": "return the clientconfiguration object associated with thetargetmoduleid.",
	"Method": "ClientConfiguration getClientConfiguration(TargetModuleID id){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.database.DBVendorType.isPositionThreeArgs",
	"Comment": "returns true if position has three argument for this database",
	"Method": "boolean isPositionThreeArgs(){\r\n    String s = (String) dbMap.get(POSITION_THREE_ARGS);\r\n    Boolean b = Boolean.valueOf(s);\r\n    if (logger.isLoggable()) {\r\n        logger.fine(\"sqlstore.database.dbvendor.getposition3args\", b);\r\n    }\r\n    return b.booleanValue();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.provider.BasePolicyWrapper.implies",
	"Comment": "evaluates the global policy for the permissions granted tothe protectiondomain and tests whether the permission isgranted.",
	"Method": "boolean implies(ProtectionDomain domain,Permission permission){\r\n    if (avoidReentrancy) {\r\n        byte[] alreadyCalled = (byte[]) reentrancyStatus.get();\r\n        if (alreadyCalled[0] == 1) {\r\n            return true;\r\n        } else {\r\n            alreadyCalled[0] = 1;\r\n            try {\r\n                return doImplies(domain, permission);\r\n            } finally {\r\n                alreadyCalled[0] = 0;\r\n            }\r\n        }\r\n    } else {\r\n        return doImplies(domain, permission);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingRelationshipElementImpl.getAssociatedColumns",
	"Comment": "returns the list of associated column names to which this\tmapping field is mapped.this is used for join tables.",
	"Method": "ArrayList getAssociatedColumns(){\r\n    if (_associatedColumns == null)\r\n        _associatedColumns = new ArrayList();\r\n    return _associatedColumns;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.RelationshipDescriptor.hasParticipant",
	"Comment": "checks whether an ejbcmpentitydescriptoris a participant in this relationship.",
	"Method": "boolean hasParticipant(Descriptor desc){\r\n    return ((source.getOwner() == desc) || (sink.getOwner() == desc));\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.DriverLoader.isLoaded",
	"Comment": "check if the classname has been loaded and if it is a driver or a datasource impl.",
	"Method": "boolean isLoaded(String classname,String resType){\r\n    Class cls = null;\r\n    try {\r\n        cls = ConnectorRuntime.getRuntime().getConnectorClassLoader().loadClass(classname);\r\n    } catch (Exception ex) {\r\n        cls = null;\r\n    } catch (Throwable t) {\r\n        cls = null;\r\n    }\r\n    return (isResType(cls, resType));\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.ModelVetoException.getMessage",
	"Comment": "returns the error message string of this throwable object.",
	"Method": "String getMessage(){\r\n    String message = super.getMessage();\r\n    if (StringHelper.isEmpty(message)) {\r\n        Throwable target = getTargetException();\r\n        message = target.getMessage();\r\n    }\r\n    return message;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.util.DumpMapping.dumpMappingCache",
	"Comment": "print out the cache of mappingclasselements to the specified printstream.",
	"Method": "void dumpMappingCache(PrintStream stream){\r\n    stream.println(\"Mapping cache (class names -> MappingClassElements)\");\r\n    for (Iterator i = model.getMappingCache().entrySet().iterator(); i.hasNext(); ) {\r\n        Map.Entry entry = (Map.Entry) i.next();\r\n        String className = (String) entry.getKey();\r\n        MappingClassElement mce = (MappingClassElement) entry.getValue();\r\n        // NOI18N\r\n        String mceRepr = mce.getClass() + \"@\" + Integer.toHexString(System.identityHashCode(mce));\r\n        // NOI18N\r\n        stream.println(\"\\t\" + className + \" ->\\t\" + mceRepr);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.backup.BackupFilenameManager.padWithLeadingZeroes",
	"Comment": "convert the array of zip filenames into an array of the number suffixes.",
	"Method": "String padWithLeadingZeroes(int num){\r\n    if (num < 10)\r\n        return \"0000\" + num;\r\n    if (num < 100)\r\n        return \"000\" + num;\r\n    if (num < 1000)\r\n        return \"00\" + num;\r\n    if (num < 10000)\r\n        return \"0\" + num;\r\n    if (num < 100000)\r\n        return \"\" + num;\r\n    throw new BackupException(\"Latest version >= 100,000.  Delete some backup files.\");\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ProfiledConnectionWrapper40.prepareStatement",
	"Comment": "creates apreparedstatementobject for sendingparamterized sql statements to database",
	"Method": "PreparedStatement prepareStatement(String sql,PreparedStatement prepareStatement,String sql,int autoGeneratedKeys,PreparedStatement prepareStatement,String sql,int[] columnIndexes,PreparedStatement prepareStatement,String sql,int resultSetType,int resultSetConcurrency,PreparedStatement prepareStatement,String sql,int resultSetType,int resultSetConcurrency,int resultSetHoldability,PreparedStatement prepareStatement,String sql,String[] columnNames){\r\n    checkValidity();\r\n    jdbcPreInvoke();\r\n    PreparedStatement output = null;\r\n    Class[] intf = new Class[] { java.sql.PreparedStatement.class };\r\n    try {\r\n        output = (PreparedStatement) getProxyObject(mc.prepareCachedStatement(this, sql, columnNames), intf);\r\n    } catch (Exception e) {\r\n        throw new SQLException(e);\r\n    }\r\n    return output;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.BundleDescriptor.findDefaultPU",
	"Comment": "this method is responsible for finding default persistence unit fora bundle descriptor.",
	"Method": "PersistenceUnitDescriptor findDefaultPU(){\r\n    PersistenceUnitDescriptor pu = null;\r\n    int totalNumberOfPUInBundle = 0;\r\n    for (PersistenceUnitsDescriptor nextPUs : getModuleDescriptor().getDescriptor().getExtensionsDescriptors(PersistenceUnitsDescriptor.class)) {\r\n        for (PersistenceUnitDescriptor nextPU : nextPUs.getPersistenceUnitDescriptors()) {\r\n            pu = nextPU;\r\n            totalNumberOfPUInBundle++;\r\n        }\r\n    }\r\n    if (totalNumberOfPUInBundle == 1) {\r\n        return pu;\r\n    } else if (totalNumberOfPUInBundle == 0) {\r\n        int totalNumberOfPUInEar = 0;\r\n        for (PersistenceUnitsDescriptor nextPUs : getApplication().getExtensionsDescriptors(PersistenceUnitsDescriptor.class)) {\r\n            for (PersistenceUnitDescriptor nextPU : nextPUs.getPersistenceUnitDescriptors()) {\r\n                pu = nextPU;\r\n                totalNumberOfPUInEar++;\r\n            }\r\n        }\r\n        if (totalNumberOfPUInEar == 1) {\r\n            return pu;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.TransactionImpl.beforeCompletion",
	"Comment": "called in the managed environment only for transaction completion",
	"Method": "void beforeCompletion(){\r\n    if (txType == NON_MGD) {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        messages, \"transaction.transactionimpl.nonmgd\", \"beforeCompletion\"));\r\n    }\r\n    Object o = null;\r\n    try {\r\n        o = EJBHelper.preInvoke(new Object[] { this, persistenceManager, jta });\r\n        this.commitBefore();\r\n        this.commitPrepare();\r\n        this.commitComplete();\r\n    } finally {\r\n        this.closeConnection();\r\n        EJBHelper.postInvoke(o);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStoreManager.execute",
	"Comment": "executes the list of sql requests contained in actions.requests can be insert, update or delete operations.",
	"Method": "void execute(PersistenceManager pm,Collection actions){\r\n    Iterator iter = actions.iterator();\r\n    while (iter.hasNext()) {\r\n        ActionDesc action = (ActionDesc) iter.next();\r\n        if (action instanceof UpdateObjectDescImpl) {\r\n            UpdateObjectDescImpl request = (UpdateObjectDescImpl) action;\r\n            UpdateQueryPlan plan = new UpdateQueryPlan(request, this);\r\n            plan.build();\r\n            for (int i = 0, size = plan.statements.size(); i < size; i++) {\r\n                UpdateStatement s = (UpdateStatement) plan.statements.get(i);\r\n                if (s != null) {\r\n                    executeUpdate(pm, s, request);\r\n                }\r\n            }\r\n        } else {\r\n            throw new JDOFatalInternalException(// NOI18N\r\n            I18NHelper.getMessage(messages, // NOI18N\r\n            \"core.generic.notinstanceof\", action.getClass().getName(), \"UpdateObjectDescImpl\"));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.module.RarHandler.isEmbedded",
	"Comment": "indicates whether the .rar being deployed is standalone or embedded",
	"Method": "boolean isEmbedded(DeploymentContext context){\r\n    ReadableArchive archive = context.getSource();\r\n    return (archive != null && archive.getParentArchive() != null);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.J2EEDocumentBuilder.newDocument",
	"Comment": "creates and return a new dom document based on the current configuration",
	"Method": "Document newDocument(){\r\n    try {\r\n        ClassLoader currentLoader = Thread.currentThread().getContextClassLoader();\r\n        Thread.currentThread().setContextClassLoader(J2EEDocumentBuilder.class.getClassLoader());\r\n        DocumentBuilderFactory factory = null;\r\n        try {\r\n            factory = DocumentBuilderFactory.newInstance();\r\n        } finally {\r\n            Thread.currentThread().setContextClassLoader(currentLoader);\r\n        }\r\n        DocumentBuilder builder = factory.newDocumentBuilder();\r\n        DOMImplementation domImplementation = builder.getDOMImplementation();\r\n        Document document = builder.newDocument();\r\n        return document;\r\n    } catch (Exception e) {\r\n        DOLUtils.getDefaultLogger().log(Level.SEVERE, \"enterprise.deployment.backend.saxParserError\", new Object[] { \"JAXP configuration error\" });\r\n        DOLUtils.getDefaultLogger().log(Level.WARNING, \"Error occurred\", e);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.ejb.security.application.EJBSecurityManager.doAsPrivileged",
	"Comment": "this method is used by securityutil runmethod to run theaction as the subject encapsulated in the currentsecuritycontext.",
	"Method": "Object doAsPrivileged(PrivilegedExceptionAction pea){\r\n    SecurityContext sc = SecurityContext.getCurrent();\r\n    Set principalSet = sc.getPrincipalSet();\r\n    AccessControlContext acc = (AccessControlContext) accessControlContextCache.get(principalSet);\r\n    if (acc == null) {\r\n        final ProtectionDomain[] pdArray = new ProtectionDomain[1];\r\n        pdArray[0] = getCachedProtectionDomain(principalSet, false);\r\n        try {\r\n            if (principalSet != null) {\r\n                final Subject s = sc.getSubject();\r\n                acc = (AccessControlContext) AccessController.doPrivileged(new PrivilegedExceptionAction() {\r\n                    public Object run() throws Exception {\r\n                        return new AccessControlContext(new AccessControlContext(pdArray), new SubjectDomainCombiner(s));\r\n                    }\r\n                });\r\n            } else {\r\n                acc = new AccessControlContext(pdArray);\r\n            }\r\n            if (principalSet != null) {\r\n                accessControlContextCache.put(new HashSet(principalSet), acc);\r\n            }\r\n            _logger.fine(\"JACC: new AccessControlContext added to cache\");\r\n        } catch (Exception e) {\r\n            _logger.log(Level.SEVERE, \"java_security.security_context_exception\", e);\r\n            acc = null;\r\n            throw e;\r\n        }\r\n    }\r\n    Object rvalue = null;\r\n    String oldContextId = setPolicyContext(this.contextId);\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"JACC: doAsPrivileged contextId(\" + this.contextId + \")\");\r\n    }\r\n    try {\r\n        rvalue = AccessController.doPrivileged(pea, acc);\r\n    } finally {\r\n        resetPolicyContext(oldContextId, this.contextId);\r\n    }\r\n    return rvalue;\r\n}"
}, {
	"Path": "org.glassfish.ejb.security.application.EJBSecurityManager.doAsPrivileged",
	"Comment": "this method is used by securityutil runmethod to run theaction as the subject encapsulated in the currentsecuritycontext.",
	"Method": "Object doAsPrivileged(PrivilegedExceptionAction pea){\r\n    return new AccessControlContext(new AccessControlContext(pdArray), new SubjectDomainCombiner(s));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.jqlc.JQLAST.getRetrieveDescRepr",
	"Comment": "returns a string representation of the spceified retrievedesc.",
	"Method": "String getRetrieveDescRepr(RetrieveDesc rd){\r\n    StringBuffer buf = new StringBuffer();\r\n    buf.append(\"RD:\");\r\n    if (rd == null) {\r\n        buf.append(\"null\");\r\n    } else {\r\n        String pcClassName = rd.getPersistenceCapableClass().toString();\r\n        if (pcClassName.startsWith(\"class \"))\r\n            buf.append(pcClassName.substring(6));\r\n        else\r\n            buf.append(pcClassName);\r\n        buf.append(\"@\");\r\n        buf.append(System.identityHashCode(rd));\r\n    }\r\n    return buf.toString();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.util.ConnectorTimerProxy.handleTimerException",
	"Comment": "handle any exception occured during scheduling timer. in case of unchecked exceptions, the timer is recreated to be used by the subsequent requests for scheduling.",
	"Method": "void handleTimerException(Exception ex){\r\n    _logger.log(Level.WARNING, \"exception_scheduling_timer\", ex.getMessage());\r\n    _logger.info(\"Recreating Timer and scheduling at fixed rate\");\r\n    timerException = true;\r\n    timer = getTimer();\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.ActiveJmsResourceAdapter.getMasterBroker",
	"Comment": "master broker name in the cluster, assumes the first broker inin the list is the master broker , and this consistency has tobe maintained in all the instances.",
	"Method": "String getMasterBroker(){\r\n    return urlList.getMasterBroker(getClusterName());\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRuntime.isACCRuntime",
	"Comment": "checks whether the executing environment is appclient container runtime",
	"Method": "boolean isACCRuntime(){\r\n    return ProcessEnvironment.ProcessType.ACC.equals(processType);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.ConstBasic.indexAsString",
	"Comment": "return the index of this constant in the constant pool asa decimal formatted string.",
	"Method": "String indexAsString(){\r\n    return Integer.toString(index);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.MappingGenerator.updateProperty",
	"Comment": "this method updates property. if the value is not null,update the property. if the value is null, remove the property.",
	"Method": "void updateProperty(Properties prop,String key,Integer value){\r\n    if (value != null) {\r\n        prop.setProperty(key, value.toString());\r\n    } else {\r\n        prop.remove(key);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.AbstractMethodHelper.categorizeMethods",
	"Comment": "reads all known methods and sorts them by name into specific\tcollections for further processing.",
	"Method": "void categorizeMethods(){\r\n    EjbCMPEntityDescriptor descriptor = getDescriptor();\r\n    Iterator iterator = descriptor.getMethodDescriptors().iterator();\r\n    while (iterator.hasNext()) {\r\n        MethodDescriptor methodDescriptor = (MethodDescriptor) iterator.next();\r\n        Method method = methodDescriptor.getMethod(descriptor);\r\n        String methodName = methodDescriptor.getName();\r\n        if (methodName.startsWith(CMPTemplateFormatter.find_))\r\n            finders.add(method);\r\n        else if (methodName.startsWith(CMPTemplateFormatter.ejbSelect_))\r\n            selectors.add(method);\r\n        else if (methodName.startsWith(CMPTemplateFormatter.create_))\r\n            createMethods.add(method);\r\n        else if (methodName.startsWith(CMPTemplateFormatter.get_) || methodName.startsWith(CMPTemplateFormatter.set_)) {\r\n            ;\r\n        }\r\n        methodNames.put(methodName, method);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.DeleteAdminObject.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (jndiName == null) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.admin.object.noJndiName\", \"No JNDI name defined for administered object.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (!isResourceExists(domain.getResources(), jndiName)) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.admin.object.notfound\", \"An administered object named {0} does not exist.\", jndiName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (environment.isDas()) {\r\n        if (domain.getConfigNamed(target) != null) {\r\n            if (resourceUtil.getTargetsReferringResourceRef(jndiName).size() > 0) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.admin.object.resource-ref.exist\", \"admin-object [ {0} ] is referenced in an\" + \"instance/cluster target, Use delete-resource-ref on appropriate target\", jndiName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        } else {\r\n            if (!resourceUtil.isResourceRefInTarget(jndiName, target)) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.admin.object.no.resource-ref\", \"admin-object [ {0} ] is not referenced in target [ {1} ]\", jndiName, target));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n            if (resourceUtil.getTargetsReferringResourceRef(jndiName).size() > 1) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.admin.object.multiple.resource-refs\", \"admin-object [ {0} ] is referenced in multiple \" + \"instance/cluster targets, Use delete-resource-ref on appropriate target\", jndiName));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n    }\r\n    try {\r\n        resourceUtil.deleteResourceRef(jndiName, target);\r\n        if (ConfigSupport.apply(new SingleConfigCode<Resources>() {\r\n            public Object run(Resources param) throws PropertyVetoException, TransactionFailure {\r\n                Resource resource = ConnectorsUtil.getResourceByName(domain.getResources(), AdminObjectResource.class, jndiName);\r\n                return param.getResources().remove(resource);\r\n            }\r\n        }, domain.getResources()) == null) {\r\n            report.setMessage(localStrings.getLocalString(\"delete.admin.object.fail\", \"Unable to delete administered object {0}\", jndiName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    } catch (TransactionFailure tfe) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.admin.object.fail\", \"Unable to delete administered object {0}\", jndiName) + \" \" + tfe.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n    }\r\n    report.setMessage(localStrings.getLocalString(\"delete.admin.object.success\", \"Administered object {0} deleted\", jndiName));\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.connectors.admin.cli.DeleteAdminObject.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Resource resource = ConnectorsUtil.getResourceByName(domain.getResources(), AdminObjectResource.class, jndiName);\r\n    return param.getResources().remove(resource);\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.XAResourceImpl.start",
	"Comment": "start work on behalf of a transaction branch specified in xid.",
	"Method": "void start(Xid xid,int flags){\r\n    mc.transactionStarted();\r\n    xar.start(xid, flags);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.getConnectionMaxPool",
	"Comment": "returns maximum number of connections in the connection pool",
	"Method": "int getConnectionMaxPool(){\r\n    if (connectionFactory != null)\r\n        return connectionFactory.getMaxPool();\r\n    return connectionMaxPool;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.PersistenceUnitsDescriptor.addPersistenceUnitDescriptor",
	"Comment": "this method does not do any validation like checking for unique namesof persistenceunits.",
	"Method": "void addPersistenceUnitDescriptor(PersistenceUnitDescriptor pud){\r\n    persistenceUnitDescriptors.add(pud);\r\n    pud.setParent(this);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.connector.ConnectionDefNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object obj){\r\n    if (obj instanceof ConnectorConfigProperty) {\r\n        descriptor.addConfigProperty((ConnectorConfigProperty) obj);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.TypeSupport.isFloatingPointType",
	"Comment": "returns true if type is a floating point type orwrapper class of a floating point type.",
	"Method": "boolean isFloatingPointType(Object type){\r\n    return doubleType.equals(type) || doubleClassType.equals(type) || floatType.equals(type) || floatClassType.equals(type);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxStatementLength",
	"Comment": "retrieves the maximum number of characters this database allows inan sql statement.",
	"Method": "int getMaxStatementLength(){\r\n    return databaseMetaData.getMaxStatementLength();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.EjbReferenceDescriptor.getReferringBundleDescriptor",
	"Comment": "get the referring bundle, i.e. the bundle within which thisejb reference is declared.",
	"Method": "BundleDescriptor getReferringBundleDescriptor(){\r\n    return referringBundle;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getShort",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object asa short in the java programming language.",
	"Method": "short getShort(int columnIndex,short getShort,String columnName){\r\n    return resultSet.getShort(columnName);\r\n}"
}, {
	"Path": "org.glassfish.admin.amxtest.config.CustomMBeanConfigTest.createProps",
	"Comment": "create some dummy properties for creating a custommbeanconfig",
	"Method": "Map<String, String> createProps(){\r\n    final String PRP = PropertiesAccess.PROPERTY_PREFIX;\r\n    final Map<String, String> optional = new HashMap<String, String>();\r\n    optional.put(PRP + \"Attr1\", \"hello\");\r\n    optional.put(PRP + \"Attr2\", \"world\");\r\n    return optional;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.getMethodContainerTransactions",
	"Comment": "return a copy of the mapping held internally of method descriptors to container transaction objects.",
	"Method": "Hashtable getMethodContainerTransactions(){\r\n    if (this.methodContainerTransactions == null) {\r\n        this.methodContainerTransactions = new Hashtable();\r\n    }\r\n    return methodContainerTransactions;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnection.isTransactionInProgress",
	"Comment": "checks if a this managedconnection is involved in a transactionor not.",
	"Method": "boolean isTransactionInProgress(){\r\n    return transactionInProgress;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.EJBHelper.registerTransactionHelper",
	"Comment": "register class that implements transactionhelper interface should be called by a static method at class initialization time. if null is passed, sets the reference to the defaulttransactionhelper.",
	"Method": "void registerTransactionHelper(TransactionHelper h){\r\n    myHelper = h;\r\n    if (myHelper == null) {\r\n        myHelper = DefaultTransactionHelper.getInstance();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.embedded.EJBContainerProviderImpl.copyUserProperties",
	"Comment": "copy user specified properties into a proprties object that will be usedto create glassfishproperties.",
	"Method": "void copyUserProperties(Map<?, ?> properties,Properties props){\r\n    for (Map.Entry<?, ?> entry : properties.entrySet()) {\r\n        Object key = entry.getKey();\r\n        if (key instanceof String) {\r\n            String sk = (String) key;\r\n            if (!sk.startsWith(GF_EJB_EMBEDDED_PROPERTY_START)) {\r\n                for (String prefix : KNOWN_PACKAGES) {\r\n                    if (sk.startsWith(prefix)) {\r\n                        Object value = entry.getValue();\r\n                        if (value instanceof String) {\r\n                            props.setProperty(sk, (String) value);\r\n                        } else {\r\n                            props.setProperty(sk, value.toString());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.getLogWriter",
	"Comment": "get the log writer for this managedconnectionfactoryimpl instance.",
	"Method": "java.io.PrintWriter getLogWriter(){\r\n    return logWriter;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ConnectionHolder40.abort",
	"Comment": "abort operation to mark the connection internally as a bad connectionfor removal and to close the connection. this ensures that at the endof the transaction, the connection is destroyed. a running threadholding a connection will run to completion before the connection isdestroyed",
	"Method": "void abort(Executor executor){\r\n    if (DataSourceObjectBuilder.isJDBC41()) {\r\n        getManagedConnection().markForRemoval(true);\r\n        getManagedConnection().setAborted(true);\r\n        if (!getManagedConnection().isTransactionInProgress()) {\r\n            close();\r\n        }\r\n    } else {\r\n        throw new UnsupportedOperationException(\"Operation not supported in this runtime.\");\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.saveMethodPermissionFromDD",
	"Comment": "keep a record of all the method permissions exactly as they were in the dd",
	"Method": "void saveMethodPermissionFromDD(MethodPermission mp,MethodDescriptor md){\r\n    if (methodPermissionsFromDD == null) {\r\n        methodPermissionsFromDD = new HashMap();\r\n    }\r\n    ArrayList descriptors = (ArrayList) methodPermissionsFromDD.get(mp);\r\n    if (descriptors == null)\r\n        descriptors = new ArrayList();\r\n    descriptors.add(md);\r\n    methodPermissionsFromDD.put(mp, descriptors);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.EnhancerModel.isArray",
	"Comment": "determines if a field with the specified fieldname in the class\twith the specified classname is an array.",
	"Method": "boolean isArray(String className,String fieldName){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.constraint.Constraint.addJoinConstraint",
	"Comment": "adds specified join constraint. equi joins are added to theconstraint stack, outer joins are added to a separate stack, theouterjoinstack.",
	"Method": "void addJoinConstraint(ConstraintJoin join){\r\n    if (join.operation == ActionDesc.OP_EQUIJOIN) {\r\n        stack.add(join);\r\n    } else {\r\n        assert join.operation == ActionDesc.OP_LEFTJOIN;\r\n        outerJoinStack.add(join);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.ee.SecuritySniffer.supportsArchiveType",
	"Comment": "this api is used to help determine if the sniffer should recognizethe current archive.if the sniffer does not support the archive type associated withthe current deployment, the sniffer should not recognize the archive.",
	"Method": "boolean supportsArchiveType(ArchiveType archiveType){\r\n    if (archiveType.toString().equals(ModuleType.WAR.toString()) || archiveType.toString().equals(ModuleType.EJB.toString())) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.registry.MonitoringLevel.equals",
	"Comment": "checks two monitoringlevel objects for equality.checks that obj is a monitoringlevel, and has the same name asthis object.",
	"Method": "boolean equals(Object obj){\r\n    if (obj == this)\r\n        return true;\r\n    if (!(obj instanceof MonitoringLevel))\r\n        return false;\r\n    MonitoringLevel that = (MonitoringLevel) obj;\r\n    return (this.name.equals(that.name));\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.archivist.EjbArchivist.validate",
	"Comment": "validates the dol objects associated with this archivist, usuallyit requires that a class loader being set on this archivist or passedas a parameter",
	"Method": "void validate(ClassLoader aClassLoader){\r\n    ClassLoader cl = aClassLoader;\r\n    if (cl == null) {\r\n        cl = classLoader;\r\n    }\r\n    if (cl == null) {\r\n        return;\r\n    }\r\n    descriptor.setClassLoader(cl);\r\n    descriptor.visit(new EjbBundleValidator());\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ConnectorDescriptor.getSunDescriptor",
	"Comment": "this returns the extra ejb sun specific info not in the ri did.",
	"Method": "SunConnector getSunDescriptor(){\r\n    return sunConnector;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.getMaxBinaryLiteralLength",
	"Comment": "retrieves the maximum number of hex characters this database allows in aninline binary literal.",
	"Method": "int getMaxBinaryLiteralLength(){\r\n    return databaseMetaData.getMaxBinaryLiteralLength();\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.util.GuiUtil.prepareSuccessful",
	"Comment": "this method sets up the attributes of themessage box so that asaved sucessfully message will be displayed during refresh.",
	"Method": "void prepareSuccessful(HandlerContext handlerCtx){\r\n    prepareAlert(\"success\", GuiUtil.getMessage(\"msg.saveSuccessful\"), null);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsMinimumSQLGrammar",
	"Comment": "retrieves whether this database supports the odbc minimum sql grammar.",
	"Method": "boolean supportsMinimumSQLGrammar(){\r\n    return databaseMetaData.supportsMinimumSQLGrammar();\r\n}"
}, {
	"Path": "com.sun.enterprise.naming.impl.WrappedSerialContext.getURLScheme",
	"Comment": "return url scheme component from this string. returns null if thereis no scheme.",
	"Method": "String getURLScheme(String str){\r\n    int colon_posn = str.indexOf(':');\r\n    int slash_posn = str.indexOf('/');\r\n    if (colon_posn > 0 && (slash_posn == -1 || colon_posn < slash_posn)) {\r\n        return str.substring(0, colon_posn);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.ConnectionFactoryImpl.getLoginTimeout",
	"Comment": "returns the number of seconds to wait for a new connection to beestablished to the data source",
	"Method": "int getLoginTimeout(){\r\n    if (connectionManager == null)\r\n        return loginTimeout;\r\n    try {\r\n        return connectionManager.getLoginTimeout();\r\n    } catch (Exception e) {\r\n        return 0;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.database.DBVendorTypeHelper.requireUpperCaseSchema",
	"Comment": "determines whether to use uppercase schema name for a give database.",
	"Method": "boolean requireUpperCaseSchema(DatabaseMetaData dmd){\r\n    int vendorTypeEnum = getEnumDBType(dmd);\r\n    return ORACLE_ENUM == vendorTypeEnum || POINTBASE_ENUM == vendorTypeEnum;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ActiveResourceAdapterImpl.isServer",
	"Comment": "check if the execution environment is appserver runtime or applicationclient container.",
	"Method": "boolean isServer(){\r\n    if (connectorRuntime_.isServer()) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.jdbc.admin.cli.DeleteJdbcResourceTest.getFileName",
	"Comment": "returns the domaintest file name without the .xml extension to load the test configurationfrom.",
	"Method": "String getFileName(){\r\n    return \"DomainTest\";\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.CodeAttribute.exceptionHandlers",
	"Comment": "return the exception ranges and handlers which apply to the code inthis method.",
	"Method": "ExceptionTable exceptionHandlers(){\r\n    makeValid();\r\n    return exceptionTable;\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnectionFactory.getTransactionIsolationInt",
	"Comment": "gets the integer equivalent of the string specifyingthe transaction isolation.",
	"Method": "int getTransactionIsolationInt(String tranIsolation){\r\n    if (tranIsolation.equalsIgnoreCase(\"read-uncommitted\")) {\r\n        return java.sql.Connection.TRANSACTION_READ_UNCOMMITTED;\r\n    } else if (tranIsolation.equalsIgnoreCase(\"read-committed\")) {\r\n        return java.sql.Connection.TRANSACTION_READ_COMMITTED;\r\n    } else if (tranIsolation.equalsIgnoreCase(\"repeatable-read\")) {\r\n        return java.sql.Connection.TRANSACTION_REPEATABLE_READ;\r\n    } else if (tranIsolation.equalsIgnoreCase(\"serializable\")) {\r\n        return java.sql.Connection.TRANSACTION_SERIALIZABLE;\r\n    } else {\r\n        throw new ResourceException(\"Invalid transaction isolation; the transaction \" + \"isolation level can be empty or any of the following: \" + \"read-uncommitted, read-committed, repeatable-read, serializable\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.findColumn",
	"Comment": "maps the given resultset column name to itsresultset column index.",
	"Method": "int findColumn(String columnName){\r\n    return resultSet.findColumn(columnName);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.JMSConfigListener.changed",
	"Comment": "implementation of org.jvnet.hk2.config.configlistener",
	"Method": "UnprocessedChangeEvents changed(PropertyChangeEvent[] events){\r\n    jmsService = serverConfig.getExtensionByType(JmsService.class);\r\n    List<UnprocessedChangeEvent> unprocessedEvents = new ArrayList<UnprocessedChangeEvent>();\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"In JMSConfigListener - received config event\");\r\n    }\r\n    Domain domain = Globals.get(Domain.class);\r\n    String jmsProviderPort = null;\r\n    ServerContext serverContext = Globals.get(ServerContext.class);\r\n    Server thisServer = domain.getServerNamed(serverContext.getInstanceName());\r\n    {\r\n    }\r\n    for (int i = 0; i < events.length; i++) {\r\n        PropertyChangeEvent event = events[i];\r\n        String eventName = event.getPropertyName();\r\n        Object oldValue = event.getOldValue();\r\n        Object newValue = event.getNewValue();\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"In JMSConfigListener \" + eventName + oldValue + newValue);\r\n        }\r\n        if (oldValue != null && oldValue.equals(newValue)) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"Event \" + eventName + \" did not change existing value of \" + oldValue);\r\n            }\r\n            continue;\r\n        }\r\n        if (event.getSource().toString().indexOf(\"connectors.jms.config.JmsService\") != -1) {\r\n            boolean notifyFlag = true;\r\n            if (oldValue != null && newValue == null && \"jms-host\".equals(event.getPropertyName())) {\r\n                JmsHost jmsHost = (JmsHost) oldValue;\r\n                String name = ActiveJmsResourceAdapter.GRIZZLY_PROXY_PREFIX + jmsHost.getName();\r\n                ActiveJmsResourceAdapter adapter = Globals.get(ActiveJmsResourceAdapter.class);\r\n                if (adapter.getGrizzlyListeners().contains(name)) {\r\n                    GrizzlyService grizzlyService = Globals.get(GrizzlyService.class);\r\n                    synchronized (adapter.getGrizzlyListeners()) {\r\n                        if (_logger.isLoggable(Level.FINE)) {\r\n                            _logger.log(Level.FINE, \"Stopping Grizzly proxy \" + name);\r\n                        }\r\n                        grizzlyService.removeNetworkProxy(name);\r\n                        adapter.getGrizzlyListeners().remove(name);\r\n                    }\r\n                    notifyFlag = false;\r\n                }\r\n            }\r\n            if (notifyFlag) {\r\n                UnprocessedChangeEvent uchangeEvent = new UnprocessedChangeEvent(event, \"restart required\");\r\n                unprocessedEvents.add(uchangeEvent);\r\n            }\r\n        } else if (event.getSource().toString().indexOf(\"connectors.jms.config.JmsHost\") != -1) {\r\n            if (oldValue == null && newValue != null && \"name\".equals(event.getPropertyName())) {\r\n                JmsProviderLifecycle lifecycle = Globals.get(JmsProviderLifecycle.class);\r\n                JmsHost jmsHost = (JmsHost) event.getSource();\r\n                if (ActiveJmsResourceAdapter.EMBEDDED.equalsIgnoreCase(jmsService.getType())) {\r\n                    ActiveJmsResourceAdapter adapter = Globals.get(ActiveJmsResourceAdapter.class);\r\n                    if (!adapter.getDoBind()) {\r\n                        if (Boolean.valueOf(jmsHost.getLazyInit())) {\r\n                            String host = null;\r\n                            if (jmsHost.getHost() != null && \"localhost\".equals(jmsHost.getHost())) {\r\n                                host = \"0.0.0.0\";\r\n                            } else {\r\n                                host = jmsHost.getHost();\r\n                            }\r\n                            try {\r\n                                GrizzlyService grizzlyService = Globals.get(GrizzlyService.class);\r\n                                NetworkListener dummy = new DummyNetworkListener();\r\n                                dummy.setPort(jmsHost.getPort());\r\n                                dummy.setAddress(host);\r\n                                dummy.setType(\"proxy\");\r\n                                dummy.setProtocol(ActiveJmsResourceAdapter.JMS_SERVICE);\r\n                                dummy.setTransport(\"tcp\");\r\n                                String name = ActiveJmsResourceAdapter.GRIZZLY_PROXY_PREFIX + jmsHost.getName();\r\n                                dummy.setName(name);\r\n                                synchronized (adapter.getGrizzlyListeners()) {\r\n                                    if (_logger.isLoggable(Level.FINE)) {\r\n                                        _logger.log(Level.FINE, \"Starting Grizzly proxy \" + name + \" on port \" + jmsHost.getPort());\r\n                                    }\r\n                                    grizzlyService.createNetworkProxy(dummy);\r\n                                    adapter.getGrizzlyListeners().add(name);\r\n                                }\r\n                                return unprocessedEvents.size() > 0 ? new UnprocessedChangeEvents(unprocessedEvents) : null;\r\n                            } catch (Exception e) {\r\n                                LogHelper.log(_logger, Level.WARNING, JMSLoggerInfo.GRIZZLY_START_FAILURE, e);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (\"JMS_PROVIDER_PORT\".equals(newValue)) {\r\n            PropertyChangeEvent nextevent = events[i + 1];\r\n            jmsProviderPort = (String) nextevent.getNewValue();\r\n        }\r\n        if (event.getSource() instanceof JmsService) {\r\n            if (eventName.equals(ServerTags.MASTER_BROKER)) {\r\n                String oldMB = oldValue != null ? oldValue.toString() : null;\r\n                String newMB = newValue != null ? newValue.toString() : null;\r\n                if (_logger.isLoggable(Level.FINE)) {\r\n                    _logger.log(Level.FINE, \"Got JmsService Master Broker change event \" + event.getSource() + \" \" + eventName + \" \" + oldMB + \" \" + newMB);\r\n                }\r\n                if (newMB != null) {\r\n                    Server newMBServer = domain.getServerNamed(newMB);\r\n                    if (newMBServer != null) {\r\n                        Node node = domain.getNodeNamed(newMBServer.getNodeRef());\r\n                        String newMasterBrokerPort = JmsRaUtil.getJMSPropertyValue(newMBServer);\r\n                        if (newMasterBrokerPort == null)\r\n                            newMasterBrokerPort = getDefaultJmsHost(jmsService).getPort();\r\n                        String newMasterBrokerHost = node.getNodeHost();\r\n                        aresourceAdapter.setMasterBroker(newMasterBrokerHost + \":\" + newMasterBrokerPort);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (eventName.equals(ServerTags.SERVER_REF)) {\r\n            String oldServerRef = oldValue != null ? oldValue.toString() : null;\r\n            String newServerRef = newValue != null ? newValue.toString() : null;\r\n            if (oldServerRef != null && newServerRef == null && !thisServer.isDas()) {\r\n                if (_logger.isLoggable(Level.FINE)) {\r\n                    _logger.log(Level.FINE, \"Got Cluster change event for server_ref\" + event.getSource() + \" \" + eventName + \" \" + oldServerRef + \" \" + null);\r\n                }\r\n                String url = getBrokerList();\r\n                aresourceAdapter.setClusterBrokerList(url);\r\n                break;\r\n            }\r\n        }\r\n        if (event.getSource() instanceof Server) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"In JMSConfigListener - recieved cluster event \" + event.getSource());\r\n            }\r\n            Server changedServer = (Server) event.getSource();\r\n            if (thisServer.isDas())\r\n                return null;\r\n            if (jmsProviderPort != null) {\r\n                String nodeName = changedServer.getNodeRef();\r\n                String nodeHost = null;\r\n                if (nodeName != null)\r\n                    nodeHost = domain.getNodeNamed(nodeName).getNodeHost();\r\n                String url = getBrokerList();\r\n                url = url + \",mq://\" + nodeHost + \":\" + jmsProviderPort;\r\n                aresourceAdapter.setClusterBrokerList(url);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return unprocessedEvents.size() > 0 ? new UnprocessedChangeEvents(unprocessedEvents) : null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.connection.ConnectionManager.getMsWait",
	"Comment": "gets the amount of time, in milliseconds, the connection manager should spend tryingto get a pooled connection, which is the amount of time a requester might wait. this value is only meaningful when you use the getconnectionto get a pooled connection, which means that no database url, user name, orpassword is specified.",
	"Method": "int getMsWait(){\r\n    return (this.msWait);\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.Java2DBProcessorHelper.getDropTables",
	"Comment": "calculate droptables value based on the parameter stored on deploy",
	"Method": "boolean getDropTables(boolean param,boolean getDropTables,String bundleName){\r\n    return getDropTables(Boolean.valueOf(deploymentContextProps.getProperty(DROP_TABLE_VALUE + bundleName)));\r\n}"
}, {
	"Path": "com.sun.enterprise.security.jmac.provider.SOAPAuthParam.setResponsePacket",
	"Comment": "set the response packet.has the side effect of resetting the soap response message.",
	"Method": "void setResponsePacket(Object p){\r\n    if (classLoadingException != null) {\r\n        throw new RuntimeException(classLoadingException);\r\n    }\r\n    if (p == null || p instanceof Packet) {\r\n        getMap().put(RES_PACKET, p);\r\n        this.responseInPacket = (p == null ? false : true);\r\n        this.response = null;\r\n    } else {\r\n        throw new RuntimeException(\"argument is not packet\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingRelationshipElementImpl.addLocalColumn",
	"Comment": "adds a column to the list of columns mapped by this mapping field.\tcall this method instead of addcolumn when mapping join\ttables.this method is used to map between the local column and the\tjoin table, while addassociatedcolumn is used to\tmap between the join table and the foreign table.",
	"Method": "void addLocalColumn(ColumnPairElement column){\r\n    super.addColumn(column);\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.callbackhandler.DefaultGUICallbackHandlerTest.testHandle",
	"Comment": "the following test is here just to give example code for drivingthe callback mechanism.",
	"Method": "void testHandle(){\r\n    run();\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.ctl.AuthorizationIDResponseControl.getAuthorizationID",
	"Comment": "retrieves the authorization identity.an empty string is returned when anonymous authentication is used.",
	"Method": "String getAuthorizationID(){\r\n    return authzId;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.Environment.classWarningsSuppressed",
	"Comment": "check whether the named class should have warnings suppressed.",
	"Method": "boolean classWarningsSuppressed(String classname){\r\n    return classSuppressions.get(classname) != null;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnMultiDimArrayNew.nDims",
	"Comment": "return the number of dimensions of the array class being created",
	"Method": "int nDims(){\r\n    return nDimsOp;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.cmp.CMPBeanHelper.logFinderException",
	"Comment": "called from a cmp bean to log jdoexception message thrownfrom a any finder or selector method, with the finderlogger.",
	"Method": "void logFinderException(int level,String beanName,Exception ex){\r\n    if (cmpFinderLogger.isLoggable(level)) {\r\n        cmpFinderLogger.log(level, // NOI18N\r\n        I18NHelper.getMessage(cmpMessages, \"GEN.generic_method_exception\", beanName, findCallingMethodName()), ex);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.AppClientContainer.prepareURLStreamHandling",
	"Comment": "assigns the url stream handler factory.needed for web services support.",
	"Method": "void prepareURLStreamHandling(){\r\n    java.security.AccessController.doPrivileged(new java.security.PrivilegedAction() {\r\n        @Override\r\n        public Object run() {\r\n            URL.setURLStreamHandlerFactory(new DirContextURLStreamHandlerFactory());\r\n            return null;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.AppClientContainer.prepareURLStreamHandling",
	"Comment": "assigns the url stream handler factory.needed for web services support.",
	"Method": "void prepareURLStreamHandling(){\r\n    URL.setURLStreamHandlerFactory(new DirContextURLStreamHandlerFactory());\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.connection.ConnectionImpl.clearXact",
	"Comment": "clear this connectionimpl of any knowledge of a transaction.also informs the parent connectionmanager to clear its knowledgeof the transaction as well.",
	"Method": "void clearXact(){\r\n    logger.finest(\"sqlstore.connectionimpl.clearxact\");\r\n    try {\r\n        if (this.freePending) {\r\n            this.freePending = false;\r\n            if (this.pooled) {\r\n                this.connectionManager.disassociateXact(this.transaction, this, true);\r\n                logger.finest(\"sqlstore.connectionimpl.pendingdisassocxact\");\r\n            } else {\r\n                this.connectionManager.disassociateXact(this.transaction, this, false);\r\n                this.connection.close();\r\n                logger.finest(\"sqlstore.connectionimpl.clearxact.close\");\r\n            }\r\n        } else {\r\n            this.connectionManager.disassociateXact(this.transaction, this, false);\r\n            logger.finest(\"sqlstore.connectionimpl.clearxact.disassocxact\");\r\n        }\r\n        this.connection.setAutoCommit(true);\r\n    } catch (SQLException ex) {\r\n    } finally {\r\n        this.transaction = null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStoreManager.closeConnection",
	"Comment": "delegates the closure of the jdbc connection cto the transaction t.",
	"Method": "void closeConnection(Transaction t,Connection c){\r\n    if (t != null && c != null) {\r\n        t.releaseConnection();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.ejb.embedded.DomainXmlTransformer.getReplaceAttributeInStartEvent",
	"Comment": "create a new start element based on the original but that replaces attribute value",
	"Method": "StartElement getReplaceAttributeInStartEvent(XMLEvent event,String attr_name,String attr_value){\r\n    Set attributes = new HashSet();\r\n    for (java.util.Iterator i = event.asStartElement().getAttributes(); i.hasNext(); ) {\r\n        Attribute a = (Attribute) i.next();\r\n        if (!a.getName().getLocalPart().equals(attr_name)) {\r\n            attributes.add(a);\r\n        }\r\n    }\r\n    Attribute newAttribute = xmlEventFactory.createAttribute(attr_name, attr_value);\r\n    attributes.add(newAttribute);\r\n    StartElement oldStartEvent = event.asStartElement();\r\n    return xmlEventFactory.createStartElement(oldStartEvent.getName(), attributes.iterator(), oldStartEvent.getNamespaces());\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.ConnectionPool.scheduleResizerTask",
	"Comment": "schedules the resizer timer task. if a task is currently scheduled,it would be canceled and a new one is scheduled.",
	"Method": "void scheduleResizerTask(){\r\n    if (resizerTask != null) {\r\n        resizerTask.cancel();\r\n        resizerTask = null;\r\n    }\r\n    resizerTask = initializeResizer();\r\n    if (timer == null) {\r\n        timer = ConnectorRuntime.getRuntime().getTimer();\r\n    }\r\n    timer.scheduleAtFixedRate(resizerTask, idletime, idletime);\r\n    if (_logger.isLoggable(Level.FINEST)) {\r\n        _logger.finest(\"scheduled resizer task\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.Model.getMappingClass",
	"Comment": "returns the mappingclasselement created for the specified class name.\tthis method looks up the class in the internal cache. if not present \tit loads the corresponding xml file containing the mapping information.",
	"Method": "MappingClassElement getMappingClass(String className,MappingClassElement getMappingClass,String className,ClassLoader classLoader){\r\n    synchronized (this._classes) {\r\n        MappingClassElement mappingClass = (MappingClassElement) _classes.get(className);\r\n        if (mappingClass == null) {\r\n            if (_nonPCClasses.contains(className))\r\n                return null;\r\n            try {\r\n                InputStream stream = getInputStreamForResource(className, classLoader, getResourceNameWithExtension(className));\r\n                if (stream != null) {\r\n                    if (stream.available() > 0) {\r\n                        XMLInputStream xmlInput = new XMLInputStream(stream, getClass().getClassLoader());\r\n                        mappingClass = (MappingClassElement) xmlInput.readObject();\r\n                        xmlInput.close();\r\n                        mappingClass.postUnarchive();\r\n                        _classes.put(className, mappingClass);\r\n                        mappingClass.setModified(false);\r\n                        getPersistenceClass(mappingClass).setModified(false);\r\n                    }\r\n                } else {\r\n                    _nonPCClasses.add(className);\r\n                }\r\n            } catch (ModelException e) {\r\n                LogHelperModel.getLogger().log(Logger.WARNING, e.getMessage());\r\n                return null;\r\n            } catch (Exception e) {\r\n                LogHelperModel.getLogger().log(Logger.WARNING, I18NHelper.getMessage(getMessages(), \"file.cannot_read\", className, e.toString()));\r\n            }\r\n        }\r\n        return mappingClass;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingReferenceKeyElementImpl.addKeyColumn",
	"Comment": "adds a column to the list of key columns in this referencing key.\tthis method is only called privately from addcolumnpairs and assumes\tthat the column is not null.",
	"Method": "void addKeyColumn(ColumnElement column){\r\n    ArrayList referencingKey = getReferencingKey();\r\n    String columnName = NameUtil.getRelativeMemberName(column.getName().getFullName());\r\n    try {\r\n        fireVetoableChange(PROP_KEY_COLUMNS, null, null);\r\n        referencingKey.add(columnName);\r\n        firePropertyChange(PROP_KEY_COLUMNS, null, null);\r\n    } catch (PropertyVetoException e) {\r\n        throw new ModelVetoException(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBHomeImpl.getHomeHandle",
	"Comment": "this is the implementation of the javax.ejb.ejbhome gethomehandlemethod.",
	"Method": "HomeHandle getHomeHandle(){\r\n    container.authorizeRemoteMethod(BaseContainer.EJBHome_getHomeHandle);\r\n    return new HomeHandleImpl(container.getEJBHomeStub());\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnUtils.iStore",
	"Comment": "return the best instruction for storing an int to a localvariable slot",
	"Method": "Insn iStore(int i,ConstantPool pool){\r\n    if (i == 0)\r\n        return Insn.create(opc_istore_0);\r\n    else if (i == 1)\r\n        return Insn.create(opc_istore_1);\r\n    else if (i == 2)\r\n        return Insn.create(opc_istore_2);\r\n    else if (i == 3)\r\n        return Insn.create(opc_istore_3);\r\n    return Insn.create(opc_istore, i);\r\n}"
}, {
	"Path": "com.sun.appserv.ProxyHandler.getSSLKeysize",
	"Comment": "returns the ssl keysize with which the original client request thatwas intercepted by the ssl offloader has been protected, and whichthe ssl offloader has added as a custom request header on thegiven request.",
	"Method": "int getSSLKeysize(HttpServletRequest request){\r\n    return -1;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.query.util.type.TypeTable.isJavaLangMathType",
	"Comment": "returns true if type denotes a collection type.note, it returns false for non classtype values, especially fornulltype and errortype.",
	"Method": "boolean isJavaLangMathType(Type type){\r\n    Type mathType = checkType(\"java.lang.Math\");\r\n    return (type instanceof ClassType) && type.isCompatibleWith(mathType);\r\n}"
}, {
	"Path": "org.glassfish.admingui.theme.AdminguiThemeContext.getInstance",
	"Comment": "return an instance of themecontext\tusing properties provided via integration point.",
	"Method": "ThemeContext getInstance(FacesContext context,String themeName,String themeVersion,ThemeContext getInstance,FacesContext context,Properties propMap){\r\n    Map map = context.getExternalContext().getApplicationMap();\r\n    String themeName = (String) propMap.get(THEME_NAME_KEY);\r\n    String themeVersion = (String) propMap.get(THEME_VERSION_KEY);\r\n    String themeKey = THEME_CONTEXT + themeName + themeVersion;\r\n    ThemeContext themeContext = (ThemeContext) map.get(themeKey);\r\n    if (themeContext == null) {\r\n        themeContext = new AdminguiThemeContext(themeName, themeVersion);\r\n        map.put(themeKey, themeContext);\r\n    }\r\n    return themeContext;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingFieldElementImpl.getColumns",
	"Comment": "returns the list of column names to which this mapping field is\tmapped.",
	"Method": "ArrayList getColumns(){\r\n    if (_columns == null)\r\n        _columns = new ArrayList();\r\n    return _columns;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.MappingGenerator.updateProperties",
	"Comment": "this method updates properties which stores user override policy.",
	"Method": "void updateProperties(Properties prop,String className,String fieldName,int jdbcType,Integer length,Integer scale,Integer precision){\r\n    prop.setProperty(MappingPolicy.getOverrideForType(className, fieldName), MappingPolicy.getJdbcTypeName(jdbcType));\r\n    updateProperty(prop, MappingPolicy.getOverrideForLength(className, fieldName), length);\r\n    updateProperty(prop, MappingPolicy.getOverrideForScale(className, fieldName), scale);\r\n    updateProperty(prop, MappingPolicy.getOverrideForPrecision(className, fieldName), precision);\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecClientRequestInterceptor.createIdToken",
	"Comment": "create and return an identity token from the credential.the identity token is cdr encoded.",
	"Method": "IdentityToken createIdToken(java.lang.Object cred,Class cls,ORB orb){\r\n    IdentityToken idtok = null;\r\n    DerOutputStream dos = new DerOutputStream();\r\n    DerValue[] derval = null;\r\n    Any any = orb.create_any();\r\n    idtok = new IdentityToken();\r\n    if (X500Name.class.isAssignableFrom(cls)) {\r\n        _logger.log(Level.FINE, \"Constructing an X500 DN Identity Token\");\r\n        X500Name credname = (X500Name) cred;\r\n        credname.encode(dos);\r\n        X501DistinguishedNameHelper.insert(any, dos.toByteArray());\r\n        idtok.dn(codec.encode_value(any));\r\n    } else if (X509CertificateCredential.class.isAssignableFrom(cls)) {\r\n        _logger.log(Level.FINE, \"Constructing an X509 Certificate Chain Identity Token\");\r\n        X509CertificateCredential certcred = (X509CertificateCredential) cred;\r\n        X509Certificate[] certchain = certcred.getX509CertificateChain();\r\n        _logger.log(Level.FINE, \"Certchain length = \" + certchain.length);\r\n        derval = new DerValue[certchain.length];\r\n        for (int i = 0; i < certchain.length; i++) derval[i] = new DerValue(certchain[i].getEncoded());\r\n        dos.putSequence(derval);\r\n        X509CertificateChainHelper.insert(any, dos.toByteArray());\r\n        idtok.certificate_chain(codec.encode_value(any));\r\n    } else if (AnonCredential.class.isAssignableFrom(cls)) {\r\n        _logger.log(Level.FINE, \"Constructing an Anonymous Identity Token\");\r\n        idtok.anonymous(true);\r\n    } else if (GSSUPName.class.isAssignableFrom(cls)) {\r\n        _logger.log(Level.FINE, \"Constructing a GSS Exported name Identity Token\");\r\n        GSSUPName gssname = (GSSUPName) cred;\r\n        byte[] expname = gssname.getExportedName();\r\n        GSS_NT_ExportedNameHelper.insert(any, expname);\r\n        idtok.principal_name(codec.encode_value(any));\r\n    }\r\n    return (idtok);\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolStatsProviderBootstrap.registerCcPool",
	"Comment": "register connector connection pool to the statsprovidermanager. add the pool lifecycle listeners for the pool to receive events on change of any of the monitoring attribute values. finally, add this provider to the list of connector connection pool providers maintained.",
	"Method": "void registerCcPool(PoolInfo poolInfo){\r\n    if (poolManager.getPool(poolInfo) != null) {\r\n        getProbeProviderUtil().createJcaProbeProvider();\r\n        ConnectorConnPoolStatsProvider ccPoolStatsProvider = new ConnectorConnPoolStatsProvider(poolInfo, logger);\r\n        StatsProviderManager.register(\"connector-connection-pool\", PluginPoint.SERVER, ConnectorsUtil.getPoolMonitoringSubTreeRoot(poolInfo, true), ccPoolStatsProvider);\r\n        PoolLifeCycleListenerRegistry registry = registerPool(poolInfo, getProbeProviderUtil().getJcaProbeProvider());\r\n        ccPoolStatsProvider.setPoolRegistry(registry);\r\n        ccStatsProviders.add(ccPoolStatsProvider);\r\n        if (!ConnectorsUtil.isApplicationScopedResource(poolInfo)) {\r\n            ResourcesUtil resourcesUtil = ResourcesUtil.createInstance();\r\n            ResourcePool pool = resourcesUtil.getPoolConfig(poolInfo);\r\n            Resources resources = resourcesUtil.getResources(poolInfo);\r\n            String raName = resourcesUtil.getRarNameOfResource(pool, resources);\r\n            ConnectorConnPoolStatsProvider connectorServicePoolStatsProvider = new ConnectorConnPoolStatsProvider(poolInfo, logger);\r\n            String dottedNamesHierarchy = null;\r\n            String monitoringModuleName = null;\r\n            if (ConnectorsUtil.isJMSRA(raName)) {\r\n                monitoringModuleName = ConnectorConstants.MONITORING_JMS_SERVICE_MODULE_NAME;\r\n                dottedNamesHierarchy = ConnectorConstants.MONITORING_JMS_SERVICE + ConnectorConstants.MONITORING_SEPARATOR + ConnectorConstants.MONITORING_CONNECTION_FACTORIES + ConnectorConstants.MONITORING_SEPARATOR + ConnectorsUtil.escapeResourceNameForMonitoring(poolInfo.getName());\r\n            } else {\r\n                monitoringModuleName = ConnectorConstants.MONITORING_CONNECTOR_SERVICE_MODULE_NAME;\r\n                dottedNamesHierarchy = ConnectorConstants.MONITORING_CONNECTOR_SERVICE_MODULE_NAME + ConnectorConstants.MONITORING_SEPARATOR + raName + ConnectorConstants.MONITORING_SEPARATOR + ConnectorsUtil.escapeResourceNameForMonitoring(poolInfo.getName());\r\n            }\r\n            StatsProviderManager.register(monitoringModuleName, PluginPoint.SERVER, dottedNamesHierarchy, connectorServicePoolStatsProvider);\r\n            if (logger.isLoggable(Level.FINE)) {\r\n                logger.log(Level.FINE, \"Registered pool-monitoring stats [ \" + dottedNamesHierarchy + \" ]  \" + \"for [ \" + raName + \" ] with monitoring-stats-registry.\");\r\n            }\r\n            connectorServicePoolStatsProvider.setPoolRegistry(registry);\r\n            ccStatsProviders.add(connectorServicePoolStatsProvider);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ManagedConnectionMetaData.getEISProductVersion",
	"Comment": "returns product version of the underlying eis instance connectedthrough the managedconnection.",
	"Method": "String getEISProductVersion(){\r\n    try {\r\n        return dmd.getDatabaseProductVersion();\r\n    } catch (SQLException sqle) {\r\n        _logger.log(Level.SEVERE, \"jdbc.exc_eis_prodvers\", sqle);\r\n        throw new ResourceException(sqle.getMessage(), sqle.getMessage());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.RuntimeDescriptorFactory.register",
	"Comment": "register a new descriptor class handling a particular xpath in the dtd.",
	"Method": "void register(XMLElement xmlPath,Class clazz){\r\n    if (DOLUtils.getDefaultLogger().isLoggable(Level.FINE)) {\r\n        DOLUtils.getDefaultLogger().fine(\"Register \" + clazz + \" to handle \" + xmlPath.getQName());\r\n    }\r\n    descriptorClasses.put(xmlPath.getQName(), clazz);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsCatalogsInPrivilegeDefinitions",
	"Comment": "retrieves whether a catalog name can be used in a privilege definition statement.",
	"Method": "boolean supportsCatalogsInPrivilegeDefinitions(){\r\n    return databaseMetaData.supportsCatalogsInPrivilegeDefinitions();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ConnectionHolder.setTypeMap",
	"Comment": "installs the given map object as the tyoe map for this connectionobject.",
	"Method": "void setTypeMap(java.util.Map<String, Class<?>> map){\r\n    checkValidity();\r\n    con.setTypeMap(map);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.classfile.InsnUtils.dStore",
	"Comment": "return the best instruction for storing a double to a localvariable slot",
	"Method": "Insn dStore(int i,ConstantPool pool){\r\n    if (i == 0)\r\n        return Insn.create(opc_dstore_0);\r\n    else if (i == 1)\r\n        return Insn.create(opc_dstore_1);\r\n    else if (i == 2)\r\n        return Insn.create(opc_dstore_2);\r\n    else if (i == 3)\r\n        return Insn.create(opc_dstore_3);\r\n    return Insn.create(opc_dstore, i);\r\n}"
}, {
	"Path": "com.sun.jndi.ldap.ctl.SortKey.getMatchingRuleID",
	"Comment": "retrieves the matching rule id used to order the attribute values.",
	"Method": "String getMatchingRuleID(){\r\n    return matchingRuleID;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.generator.database.MappingPolicy.getJdbcType",
	"Comment": "returns the boxed form of the java.sql.types value corresponding to thegiven name.",
	"Method": "Integer getJdbcType(String jdbcTypeName){\r\n    return (Integer) jdbcTypes.get(jdbcTypeName.toUpperCase());\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbqlc.ErrorMsg.unsupported",
	"Comment": "this method throws an unsupportedoperationexception indicating an unsupported feature.",
	"Method": "void unsupported(int line,int col,String text){\r\n    UnsupportedOperationException ex;\r\n    if (line > 1) {\r\n        Object[] args = { new Integer(line), new Integer(col), text };\r\n        ex = new UnsupportedOperationException(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        msgs, \"EXC_PositionInfoMsgLineColumn\", args));\r\n    } else if (col > 0) {\r\n        Object[] args = { new Integer(col), text };\r\n        ex = new UnsupportedOperationException(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        msgs, \"EXC_PositionInfoMsgColumn\", args));\r\n    } else {\r\n        Object[] args = { text };\r\n        ex = new UnsupportedOperationException(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        msgs, \"EXC_PositionInfoMsg\", args));\r\n    }\r\n    throw ex;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.JavaTypeHelper.getPrimitiveClass",
	"Comment": "returns the primitive class associated with the supplied primitive \ttype name.",
	"Method": "Class getPrimitiveClass(String primitiveName){\r\n    return (Class) _primitiveNamesToPrimitives.get(primitiveName);\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.monitor.ConnectionPoolEmitterImpl.incrementNumConnFree",
	"Comment": "fires probe event related to the fact the given jdbc connection pool hasgot a decrement free connections size event.",
	"Method": "void incrementNumConnFree(boolean beingDestroyed,int steadyPoolSize){\r\n    poolProbeProvider.incrementNumConnFreeEvent(poolName, appName, moduleName, beingDestroyed, steadyPoolSize);\r\n}"
}, {
	"Path": "com.sun.enterprise.naming.impl.RemoteSerialContextProviderImpl.initSerialContextProvider",
	"Comment": "create the remote object and publish it in the cosnaming name service.",
	"Method": "Remote initSerialContextProvider(ORB orb,TransientContext rootContext){\r\n    return new RemoteSerialContextProviderImpl(orb, rootContext);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ConnectorRegistry.getAllActiveResourceAdapters",
	"Comment": "returns all active resource adapters in the connector runtime.",
	"Method": "ActiveResourceAdapter[] getAllActiveResourceAdapters(){\r\n    ActiveResourceAdapter[] araArray = new ActiveResourceAdapter[this.resourceAdapters.size()];\r\n    return this.resourceAdapters.values().toArray(araArray);\r\n}"
}, {
	"Path": "org.glassfish.deployapi.TargetModuleIDImpl.getWebURL",
	"Comment": "returns the url for running the web module, if this targetmoduleid represents a web module or submodule on a target.",
	"Method": "String getWebURL(){\r\n    return target.getOwner().getWebURL(this);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStoreManager.closeDBStatements",
	"Comment": "removes all dbstatements for specified plan and closes the jdbc statementwrapped by the dbstatement.",
	"Method": "void closeDBStatements(UpdateQueryPlan plan,Transaction tran){\r\n    if ((plan != null) && (tran != null)) {\r\n        for (Iterator i = plan.getStatements().iterator(); i.hasNext(); ) {\r\n            UpdateStatement updateStmt = (UpdateStatement) i.next();\r\n            DBStatement s = updateStmt.removeDBStatement(tran);\r\n            close(s);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.application.wls.WeblogicApplicationNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object newDescriptor){\r\n    if (newDescriptor instanceof EnvironmentProperty) {\r\n        descriptor.addApplicationParam((ApplicationParam) newDescriptor);\r\n    } else\r\n        super.addDescriptor(newDescriptor);\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.DSManagedConnectionFactory.equals",
	"Comment": "check if this managedconnectionfactory is equal to another managedconnectionfactory.",
	"Method": "boolean equals(Object other){\r\n    if (logWriter != null) {\r\n        logWriter.println(\"In equals\");\r\n    }\r\n    if (other instanceof com.sun.jdbcra.spi.DSManagedConnectionFactory) {\r\n        com.sun.jdbcra.spi.DSManagedConnectionFactory otherMCF = (com.sun.jdbcra.spi.DSManagedConnectionFactory) other;\r\n        return this.spec.equals(otherMCF.spec);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbDescriptor.addScheduledTimerDescriptorFromDD",
	"Comment": "special method for overrides because more than one schedule can be specified on a single method",
	"Method": "void addScheduledTimerDescriptorFromDD(ScheduledTimerDescriptor scheduleDescriptor){\r\n    timerMethodDescriptors.add(scheduleDescriptor.getTimeoutMethod());\r\n    timerSchedules.add(scheduleDescriptor);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.deployment.SecurityConstraintImpl.removeWebResourceCollection",
	"Comment": "removes the given web resource collection from this constraint.",
	"Method": "void removeWebResourceCollection(WebResourceCollection webResourceCollection){\r\n    this.getWebResourceCollections().remove(webResourceCollection);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.DeploymentHelper.handleUnexpectedInstance",
	"Comment": "create a runtimeexception for unexpected instance returnedfrom jndi lookup.",
	"Method": "void handleUnexpectedInstance(String name,Object value){\r\n    RuntimeException e = new JDOFatalUserException(// NOI18N\r\n    I18NHelper.getMessage(messages, \"ejb.jndi.unexpectedinstance\", name, value.getClass().getName()));\r\n    logger.severe(e.toString());\r\n    throw e;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.EJBHelper.getDDLNamePrefix",
	"Comment": "returns name prefix for ddl files extracted from the info instance by theapplication server specific code.",
	"Method": "String getDDLNamePrefix(Object info,String getDDLNamePrefix,Object info){\r\n    return myHelper.getDDLNamePrefix(info);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.constraint.Constraint.addOperation",
	"Comment": "adds an operation to the constraint stack.addoperation creates a constraintoperation node whose operation isoperation and adds it to the constraint stack.",
	"Method": "void addOperation(int operation){\r\n    stack.add(new ConstraintOperation(operation));\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingMemberElementImpl.fireVetoableChange",
	"Comment": "fires vetoable change event.this method overrides that of \tmappingelementimpl to give listeners a chance to block \tchanges on the mapping class element modified status.",
	"Method": "void fireVetoableChange(String name,Object o,Object n){\r\n    boolean noChange = ((o != null) && (n != null) && o.equals(n));\r\n    MappingClassElement classElement = getDeclaringClass();\r\n    super.fireVetoableChange(name, o, n);\r\n    if ((classElement != null) && !noChange) {\r\n        ((MappingClassElementImpl) classElement).fireVetoableChange(PROP_MODIFIED, Boolean.FALSE, Boolean.TRUE);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.client.DFProgressObject.waitFor",
	"Comment": "waits for the operation which this progress object is monitoring to complete.",
	"Method": "DFDeploymentStatus waitFor(){\r\n    DFDeploymentStatus status = null;\r\n    do {\r\n        try {\r\n            Thread.currentThread().sleep(100);\r\n        } catch (InterruptedException ie) {\r\n        }\r\n        status = getCompletedStatus();\r\n    } while (status == null);\r\n    return status;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStateManager.addCollectionRelationship",
	"Comment": "sets the relationship for the objects added to a collection relationship.",
	"Method": "void addCollectionRelationship(ForeignFieldDesc fieldDesc,ArrayList addedList,ForeignFieldDesc inverseFieldDesc,ArrayList newlyRegisteredSMs,boolean updateInverseRelationshipField,boolean managedRelationshipInProgress){\r\n    JDOUserException ex = null;\r\n    for (int i = 0; i < addedList.size(); i++) {\r\n        Object addedObject = addedList.get(i);\r\n        SQLStateManager addedSM = getAddedSM(addedObject, newlyRegisteredSMs);\r\n        if (addedSM != null) {\r\n            if (addedSM.isDeleted()) {\r\n                if (inverseFieldDesc != null) {\r\n                    if (ex == null) {\r\n                        ex = new JDOUserException(// NOI18N\r\n                        I18NHelper.getMessage(messages, \"jdo.lifecycle.deleted.accessField\"));\r\n                    }\r\n                    ex.addFailedObject(addedObject);\r\n                }\r\n                continue;\r\n            }\r\n            if (!managedRelationshipInProgress) {\r\n                updateRelationshipInDataStore(fieldDesc, addedSM, null, inverseFieldDesc, false);\r\n                if (updateInverseRelationshipField && inverseFieldDesc != null) {\r\n                    addedSM.addRelationship(inverseFieldDesc, this);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (ex != null) {\r\n        throw ex;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.TransactionImpl.setRollbackOnly",
	"Comment": "modify the transaction object such that the only possible outcome ofthe transaction is to roll back.",
	"Method": "void setRollbackOnly(){\r\n    if (this.tracing)\r\n        this.traceCall(\"setRollbackOnly\");\r\n    if ((this.status == Status.STATUS_ROLLING_BACK) || (this.status == Status.STATUS_ROLLEDBACK) || (this.status == Status.STATUS_MARKED_ROLLBACK)) {\r\n        return;\r\n    }\r\n    if (txType != NON_MGD) {\r\n        try {\r\n            jta.setRollbackOnly();\r\n        } catch (Exception e) {\r\n            throw new JDOException(\"\", e);\r\n        }\r\n    } else {\r\n        this.setStatus(Status.STATUS_MARKED_ROLLBACK);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getDate",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object as a java.sql.date objectin the java programming language.this method uses the given calendar to construct an appropriate millisecondvalue for the date if the underlying database does not storetimezone information.",
	"Method": "Date getDate(int columnIndex,Date getDate,String columnName,Date getDate,int columnIndex,Calendar cal,Date getDate,String columnName,Calendar cal){\r\n    return resultSet.getDate(columnName, cal);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.RuntimeModel.getDeclaringClass",
	"Comment": "returns the string representation of declaring class of \tthe specified member element.note, the member element is \teither a class element as returned by getclass, a field element \tas returned by getfield, a constructor element as returned by \tgetconstructor, or a method element as returned by getmethod \texecuted on the same model instance.this implementation \texpects the member element to be a reflection instance.",
	"Method": "String getDeclaringClass(Object memberElement){\r\n    Class classElement = null;\r\n    if ((memberElement != null) && (memberElement instanceof Member))\r\n        classElement = ((Member) memberElement).getDeclaringClass();\r\n    return ((classElement != null) ? classElement.getName() : null);\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.support.JDOHelper.isDirty",
	"Comment": "tests whether an object is dirty.if the object have been modified, deleted, or newly made persistent in the current transaction, true is returned.for transient objects, false is returned.",
	"Method": "boolean isDirty(Object obj){\r\n    if (obj instanceof PersistenceCapable)\r\n        return ((PersistenceCapable) obj).jdoIsDirty();\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.persistence.common.database.DBVendorTypeHelper.matchPattern",
	"Comment": "matches target to pattern specified regexp. returns false if there is any error compiling regexp.",
	"Method": "boolean matchPattern(String regExp,String target){\r\n    boolean matches = false;\r\n    try {\r\n        matches = Pattern.matches(regExp, target);\r\n    } catch (PatternSyntaxException e) {\r\n        logger.log(Level.FINE, I18NHelper.getMessage(messages, \"database.DBVendorTypeHelper.patternSyntaxException\"), e);\r\n    }\r\n    return matches;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.MonitoringHandlers.getStats",
	"Comment": "this handler returns a list of statistical data for an endpoint.useful for populating table",
	"Method": "void getStats(HandlerContext handlerCtx){\r\n    String endpoint = (String) handlerCtx.getInputValue(\"endpoint\");\r\n    String statType = (String) handlerCtx.getInputValue(\"statType\");\r\n    String type = (String) handlerCtx.getInputValue(\"type\");\r\n    Locale locale = GuiUtil.getLocale();\r\n    DateFormat df = DateFormat.getDateTimeInstance(DateFormat.DEFAULT, DateFormat.DEFAULT, locale);\r\n    List result = new ArrayList();\r\n    try {\r\n        if ((type == null || statType == null) || type.equals(statType)) {\r\n            if (RestUtil.doesProxyExist(endpoint)) {\r\n                Map<String, Object> stats = getMonitoringStatInfo(endpoint);\r\n                if (statType != null && statType.equals(\"jersey\")) {\r\n                    Map<String, Object> jerseyStats = new HashMap<String, Object>();\r\n                    for (Map.Entry<String, Object> e : stats.entrySet()) {\r\n                        Map<String, Object> jerseyStat = (Map<String, Object>) e.getValue();\r\n                        if (jerseyStat != null) {\r\n                            jerseyStats.putAll(jerseyStat);\r\n                        }\r\n                    }\r\n                    stats = jerseyStats;\r\n                }\r\n                for (Map.Entry<String, Object> e : stats.entrySet()) {\r\n                    if (!(e.getValue().getClass().equals(HashMap.class))) {\r\n                        continue;\r\n                    }\r\n                    Map<String, Object> monAttrs = (Map<String, Object>) e.getValue();\r\n                    Map<String, String> statMap = new HashMap();\r\n                    String val = \"\";\r\n                    String details = \"--\";\r\n                    String desc = \"--\";\r\n                    String start = \"--\";\r\n                    String last = \"--\";\r\n                    String unit = \"\";\r\n                    String mname = null;\r\n                    String runtimes = null;\r\n                    String queuesize = null;\r\n                    String thresholds = \"--\";\r\n                    if (!monAttrs.isEmpty()) {\r\n                        if (monAttrs.containsKey(\"name\")) {\r\n                            mname = (String) monAttrs.get(\"name\");\r\n                        } else if (monAttrs.containsKey(\"appname\")) {\r\n                            mname = (String) monAttrs.get(\"appname\");\r\n                        }\r\n                        unit = (String) monAttrs.get(\"unit\");\r\n                        desc = (String) monAttrs.get(\"description\");\r\n                        Long lastTime = (Long) monAttrs.get(\"lastsampletime\");\r\n                        if (lastTime != -1) {\r\n                            last = df.format(new Date(lastTime));\r\n                        }\r\n                        Long startTime = (Long) monAttrs.get(\"starttime\");\r\n                        if (startTime != -1) {\r\n                            start = df.format(new Date(startTime));\r\n                        }\r\n                        if (monAttrs.containsKey(\"count\")) {\r\n                            val = monAttrs.get(\"count\") + \" \" + unit;\r\n                        } else if (monAttrs.containsKey(\"current\")) {\r\n                            if (unit != null) {\r\n                                if (unit.equals(\"String\")) {\r\n                                    if (mname.equals(\"LiveThreads\")) {\r\n                                        String str = (String) monAttrs.get(\"current\");\r\n                                        val = formatStringForDisplay(str);\r\n                                    } else {\r\n                                        val = (String) monAttrs.get(\"current\");\r\n                                    }\r\n                                } else if (unit.equals(\"List\")) {\r\n                                    String str = (String) monAttrs.get(\"current\");\r\n                                    String formatStr = formatActiveIdsForDisplay(str);\r\n                                    if (!formatStr.isEmpty() && !formatStr.equals(\"\")) {\r\n                                        val = formatStr;\r\n                                    }\r\n                                } else {\r\n                                    Long currentVal = (Long) monAttrs.get(\"current\");\r\n                                    val = currentVal + unit;\r\n                                }\r\n                            }\r\n                        } else if (monAttrs.containsKey(\"applicationtype\")) {\r\n                            val = (String) monAttrs.get(\"applicationtype\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"appName\")) {\r\n                            details = (GuiUtil.getMessage(\"msg.AppName\") + \": \" + monAttrs.get(\"appName\") + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"appname\")) {\r\n                            details = (GuiUtil.getMessage(\"msg.AppName\") + \": \" + monAttrs.get(\"appname\") + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"environment\")) {\r\n                            details = details + (GuiUtil.getMessage(\"msg.Environment\") + \": \" + monAttrs.get(\"environment\") + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"address\")) {\r\n                            details = details + (GuiUtil.getMessage(\"msg.Address\") + \": \" + monAttrs.get(\"address\") + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"deploymenttype\")) {\r\n                            details = details + (GuiUtil.getMessage(\"msg.DepType\") + \": \" + monAttrs.get(\"deploymenttype\") + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"endpointname\")) {\r\n                            details = details + (GuiUtil.getMessage(\"msg.EndPointName\") + \": \" + monAttrs.get(\"endpointname\") + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"classname\")) {\r\n                            details = (GuiUtil.getMessage(\"msg.ClassName\") + \": \" + monAttrs.get(\"classname\") + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"impltype\")) {\r\n                            details = details + (GuiUtil.getMessage(\"msg.ImplClass\") + \": \" + monAttrs.get(\"implclass\") + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"implclass\") && monAttrs.containsKey(\"impltype\")) {\r\n                            details = details + (GuiUtil.getMessage(\"msg.ImplType\") + \": \" + monAttrs.get(\"impltype\") + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"namespace\")) {\r\n                            details = details + (GuiUtil.getMessage(\"msg.NameSpace\") + \": \" + monAttrs.get(\"namespace\") + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"portname\")) {\r\n                            details = details + (GuiUtil.getMessage(\"msg.PortName\") + \": \" + monAttrs.get(\"portname\") + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"servicename\")) {\r\n                            details = details + (GuiUtil.getMessage(\"msg.ServiceName\") + \": \" + monAttrs.get(\"servicename\") + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"tester\")) {\r\n                            details = details + (GuiUtil.getMessage(\"msg.Tester\") + \": \" + monAttrs.get(\"tester\") + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"wsdl\")) {\r\n                            details = details + (GuiUtil.getMessage(\"msg.WSDL\") + \": \" + monAttrs.get(\"wsdl\") + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"maxtime\")) {\r\n                            details = (GuiUtil.getMessage(\"msg.MaxTime\") + \": \" + monAttrs.get(\"maxtime\") + \" \" + unit + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"mintime\")) {\r\n                            details = details + (GuiUtil.getMessage(\"msg.MinTime\") + \": \" + monAttrs.get(\"mintime\") + \" \" + unit + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"totaltime\")) {\r\n                            details = details + (GuiUtil.getMessage(\"msg.TotalTime\") + \": \" + monAttrs.get(\"totaltime\") + \" \" + unit + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"highwatermark\")) {\r\n                            details = (GuiUtil.getMessage(\"msg.HWaterMark\") + \": \" + monAttrs.get(\"highwatermark\") + \" \" + unit + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"lowwatermark\")) {\r\n                            details = details + (GuiUtil.getMessage(\"msg.LWaterMark\") + \": \" + monAttrs.get(\"lowwatermark\") + \" \" + unit + \"<br/>\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"activeruntimes\")) {\r\n                            runtimes = (String) monAttrs.get(\"activeruntimes\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"queuesize\")) {\r\n                            queuesize = (String) monAttrs.get(\"queuesize\");\r\n                        }\r\n                        if (monAttrs.containsKey(\"hardmaximum\") && monAttrs.get(\"hardmaximum\") != null) {\r\n                            val = monAttrs.get(\"hardmaximum\") + \" \" + \"hard max \" + \"<br/>\" + monAttrs.get(\"hardminimum\") + \" \" + \"hard min\";\r\n                        }\r\n                        if (monAttrs.containsKey(\"newthreshold\") && monAttrs.get(\"newThreshold\") != null) {\r\n                            thresholds = monAttrs.get(\"newthreshold\") + \" \" + \"new \" + \"<br/>\" + monAttrs.get(\"queuedownthreshold\") + \" \" + \"queue down\";\r\n                        }\r\n                        if (monAttrs.containsKey(\"queuesize\") && monAttrs.containsKey(\"environment\")) {\r\n                            details = details + monAttrs.get(\"environment\");\r\n                        }\r\n                        statMap.put(\"name\", mname);\r\n                        statMap.put(\"startTime\", start);\r\n                        statMap.put(\"lastTime\", last);\r\n                        statMap.put(\"description\", desc);\r\n                        statMap.put(\"value\", (val == null) ? \"\" : val);\r\n                        statMap.put(\"details\", details);\r\n                        statMap.put(\"thresholds\", thresholds);\r\n                        statMap.put(\"queueSize\", (queuesize == null) ? \"--\" : queuesize);\r\n                        statMap.put(\"runtimes\", (runtimes == null) ? \"--\" : runtimes);\r\n                        result.add(statMap);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        handlerCtx.setOutputValue(\"result\", result);\r\n        handlerCtx.setOutputValue(\"hasStats\", (result.size() == 0) ? false : true);\r\n    } catch (Exception ex) {\r\n        GuiUtil.handleException(handlerCtx, ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.application.wls.ApplicationParamNode.writeDescriptors",
	"Comment": "write all occurrences of the descriptor corresponding to the currentnode from the parent descriptor to an jaxp dom node and return itthis api will be invoked by the parent node when the parent nodewrites out a mix of statically and dynamically registered sub nodes.this method should be overriden by the sub classes if itneeds to be called by the parent node.",
	"Method": "Node writeDescriptors(Node parent,String nodeName,Descriptor parentDesc){\r\n    if (parentDesc instanceof Application) {\r\n        Application application = (Application) parentDesc;\r\n        Set<ApplicationParam> applicationParams = application.getApplicationParams();\r\n        for (ApplicationParam appParam : applicationParams) {\r\n            writeDescriptor(parent, nodeName, (EnvironmentProperty) appParam);\r\n        }\r\n    }\r\n    return parent;\r\n}"
}, {
	"Path": "com.sun.enterprise.resource.pool.ConnectionLeakDetector.printConnectionLeakTrace",
	"Comment": "prints the stack trace of thread leaking connection to server logs",
	"Method": "void printConnectionLeakTrace(StackTraceElement[] threadStackTrace,ConnectionLeakListener connLeakListener){\r\n    StringBuffer stackTrace = new StringBuffer();\r\n    String msg = localStrings.getStringWithDefault(\"potential.connection.leak.msg\", \"A potential connection leak detected for connection pool \" + connectionPoolInfo + \". The stack trace of the thread is provided below : \", new Object[] { connectionPoolInfo });\r\n    stackTrace.append(msg);\r\n    stackTrace.append(\"\\n\");\r\n    for (int i = 2; i < threadStackTrace.length; i++) {\r\n        stackTrace.append(threadStackTrace[i].toString());\r\n        stackTrace.append(\"\\n\");\r\n    }\r\n    connLeakListener.printConnectionLeakTrace(stackTrace);\r\n    _logger.log(Level.WARNING, stackTrace.toString(), \"ConnectionPoolName=\" + connectionPoolInfo);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerFactoryImpl.setMinPool",
	"Comment": "sets minimum number of persistencemanager instances in the pool",
	"Method": "void setMinPool(int MinPool){\r\n    assertNotConfigured();\r\n    this.minPool = MinPool;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.SelectQueryPlan.mergeStatements",
	"Comment": "merge the foreign statement with us.if there is no foreign statement,this method just returns.",
	"Method": "void mergeStatements(SelectQueryPlan foreignPlan,int joinOperation){\r\n    SelectStatement fromStatement;\r\n    SelectStatement toStatement;\r\n    if (foreignPlan.statements.size() > 0) {\r\n        toStatement = (SelectStatement) foreignPlan.statements.get(0);\r\n        if (statements.size() > 0) {\r\n            fromStatement = (SelectStatement) statements.get(0);\r\n            fromStatement.copyColumns(toStatement);\r\n            if (joinOperation == ActionDesc.OP_NONREL_JOIN) {\r\n                fromStatement.tableList.addAll(toStatement.tableList);\r\n            }\r\n            mergeResultDesc(foreignPlan);\r\n            if (foreignPlan.prefetched) {\r\n                resultDesc.setPrefetching();\r\n            }\r\n            this.options |= foreignPlan.options;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.meta.JDOMetaDataModelImpl.getFieldNo",
	"Comment": "returns the unique field index of a declared, persistent field of aclass.",
	"Method": "int getFieldNo(String classPath,String fieldName){\r\n    final String className = pathToName(classPath);\r\n    final PersistenceFieldElement pfe = model.getPersistenceField(className, fieldName);\r\n    if (pfe == null || pfe.getPersistenceType() != PersistenceFieldElement.PERSISTENT)\r\n        return -1;\r\n    return pfe.getFieldNumber();\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ConnectionHolder.isClosed",
	"Comment": "retrieves whether underlying connection object is closed.",
	"Method": "boolean isClosed(){\r\n    return isClosed;\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.ACCLogger.createHandler",
	"Comment": "creates a logging handler to send logging to the specified file, usingthe indicated level.",
	"Method": "Handler createHandler(LogService logService,Level level){\r\n    Handler handler = null;\r\n    final String filePath = (logService == null) ? null : logService.getFile();\r\n    if (filePath == null || filePath.equals(\"\")) {\r\n        return null;\r\n    }\r\n    handler = new FileHandler(filePath, true);\r\n    handler.setFormatter(new SimpleFormatter());\r\n    handler.setLevel(level);\r\n    File lockFile = new File(filePath + \".lck\");\r\n    lockFile.deleteOnExit();\r\n    return handler;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.JDOConcreteBeanGenerator.containsException",
	"Comment": "verifies if expected exception is part of the throws clause of thecorresponding method in the abstract class.",
	"Method": "boolean containsException(String[] exc,String checkExc){\r\n    boolean rc = false;\r\n    if (exc != null) {\r\n        for (int i = 0; i < exc.length; i++) {\r\n            if (exc[i].equals(checkExc)) {\r\n                rc = true;\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "org.glassfish.resources.admin.cli.ListJndiResources.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        List<String> list = new ArrayList<String>();\r\n        Collection<ExternalJndiResource> jndiResources = domain.getResources().getResources(ExternalJndiResource.class);\r\n        for (ExternalJndiResource jndiResource : jndiResources) {\r\n            if (bindableResourcesHelper.resourceExists(jndiResource.getJndiName(), targetOperand)) {\r\n                list.add(jndiResource.getJndiName());\r\n            }\r\n        }\r\n        for (String jndiName : list) {\r\n            final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n            part.setMessage(jndiName);\r\n        }\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"\" + \"list.jndi.resources.fail\", \"Unable to list jndi resources.\") + \" \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.resources.admin.cli.ResourcesXMLParser.sortConnectorResources",
	"Comment": "sort connector resourcesresource adapter configs are added first.pools are then added to the list, so that the connectionpools can be created prior to any other connector resource definedin the resources configuration xml file.",
	"Method": "List<Resource> sortConnectorResources(List<org.glassfish.resources.api.Resource> connectorResources){\r\n    List<org.glassfish.resources.api.Resource> raconfigs = new ArrayList<Resource>();\r\n    List<Resource> ccps = new ArrayList<org.glassfish.resources.api.Resource>();\r\n    List<org.glassfish.resources.api.Resource> others = new ArrayList<org.glassfish.resources.api.Resource>();\r\n    List<Resource> finalSortedConnectorList = new ArrayList<Resource>();\r\n    for (Resource resource : connectorResources) {\r\n        if (resource.getType().equals(org.glassfish.resources.api.Resource.RESOURCE_ADAPTER_CONFIG)) {\r\n            raconfigs.add(resource);\r\n        } else if (resource.getType().equals(org.glassfish.resources.api.Resource.CONNECTOR_CONNECTION_POOL)) {\r\n            ccps.add(resource);\r\n        } else {\r\n            others.add(resource);\r\n        }\r\n    }\r\n    finalSortedConnectorList.addAll(raconfigs);\r\n    finalSortedConnectorList.addAll(ccps);\r\n    finalSortedConnectorList.addAll(others);\r\n    return finalSortedConnectorList;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.MappingGenerator.updateColumn",
	"Comment": "update column in the schemaelement with jdbc type and its length, scale and precision.",
	"Method": "void updateColumn(ColumnElement column,int jdbcType,Integer length,Integer scale,Integer precision){\r\n    column.setType(jdbcType);\r\n    column.setLength(length);\r\n    column.setScale(scale);\r\n    column.setPrecision(precision);\r\n}"
}, {
	"Path": "com.sun.jdbcra.spi.ConnectionHolder.setSavepoint",
	"Comment": "creates a savepoint with the name and returns an object corresponding to that.",
	"Method": "Savepoint setSavepoint(Savepoint setSavepoint,String name){\r\n    checkValidity();\r\n    return con.setSavepoint(name);\r\n}"
}, {
	"Path": "test.extension.ServiceFrameworkExtension.discoverServiceInjectionPoints",
	"Comment": "discover injection points where the framework service is requestedthrough the frameworkservice qualifier and a map is populated for all framework services that have been requested.",
	"Method": "void discoverServiceInjectionPoints(Set<InjectionPoint> ips){\r\n    for (Iterator<InjectionPoint> iterator = ips.iterator(); iterator.hasNext(); ) {\r\n        InjectionPoint injectionPoint = iterator.next();\r\n        Set<Annotation> qualifs = injectionPoint.getQualifiers();\r\n        for (Iterator<Annotation> qualifIter = qualifs.iterator(); qualifIter.hasNext(); ) {\r\n            Annotation annotation = qualifIter.next();\r\n            if (annotation.annotationType().equals(FrameworkService.class)) {\r\n                printDebugForInjectionPoint(injectionPoint);\r\n                System.out.println(\"---- Injection requested for \" + \"framework service type \" + injectionPoint.getType() + \" and annotated with dynamic=\" + injectionPoint.getAnnotated().getAnnotation(FrameworkService.class).dynamic() + \", serviceCriteria=\" + injectionPoint.getAnnotated().getAnnotation(FrameworkService.class).serviceCriteria());\r\n                Type key = injectionPoint.getType();\r\n                FrameworkService value = injectionPoint.getAnnotated().getAnnotation(FrameworkService.class);\r\n                if (!frameworkServicesToBeInjected.containsKey(key)) {\r\n                    frameworkServicesToBeInjected.put(key, new HashSet<FrameworkService>());\r\n                }\r\n                frameworkServicesToBeInjected.get(key).add(value);\r\n                System.out.println(frameworkServicesToBeInjected.get(key).size());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.ejb.ejbc.EjbConversionHelper.getRelationshipFieldType",
	"Comment": "this api will only be called from mappingfile when multiplicity is manyon the other role.",
	"Method": "String getRelationshipFieldType(String ejbName,String fieldName){\r\n    if (isGeneratedRelationship(ejbName, fieldName)) {\r\n        return java.util.Collection.class.getName();\r\n    } else {\r\n        PersistenceDescriptor pers = (PersistenceDescriptor) ejbPerDescMap.get(ejbName);\r\n        return pers.getCMRFieldReturnType(fieldName);\r\n    }\r\n}"
}, {
	"Path": "com.sun.ejb.containers.BaseContainer.onShutdown",
	"Comment": "container shutdown event. this happens for every kind ofshutdown other than undeploy.it could mean the serveris shutting down or that the app has been disabled whilethe server is still running.the two cases are handledthe same. we must be able to gracefully handle redundantshutdown calls for the same container instance.",
	"Method": "void onShutdown(){\r\n    try {\r\n        if (!isStopped()) {\r\n            setStoppedState();\r\n            try {\r\n                stopTimers();\r\n            } catch (Exception e) {\r\n                _logger.log(Level.FINE, \"Error stopping timers for \" + ejbDescriptor.getName(), e);\r\n            }\r\n            doConcreteContainerShutdown(false);\r\n            doContainerCleanup();\r\n        }\r\n    } catch (Throwable t) {\r\n        _logger.log(Level.FINE, \"BsaeContainer::onShutdown exception\", t);\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.ResultSetWrapper40.getNString",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object asa string in the java programming language.it is intended for use whenaccessingnchar,nvarcharand longnvarchar columns.",
	"Method": "String getNString(int columnIndex,String getNString,String columnLabel){\r\n    return resultSet.getNString(columnLabel);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.StatementWrapper.setMaxRows",
	"Comment": "sets the limit for the maximum number of rows that anyresultset object can contain to the given number.if the limit is exceeded, the excessrows are silently dropped.",
	"Method": "void setMaxRows(int max){\r\n    jdbcStatement.setMaxRows(max);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.MailConfiguration.getMailHost",
	"Comment": "get the mail hostname for the mail session the server will provide.",
	"Method": "String getMailHost(){\r\n    return this.mailHost;\r\n}"
}, {
	"Path": "org.glassfish.deployapi.SunDeploymentManager.getCurrentLocale",
	"Comment": "returns the active locale this implementation of javax.enterprise.deploy.spi subpackages is running.",
	"Method": "Locale getCurrentLocale(){\r\n    return currentLocale;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.getBundleDescriptorsOfType",
	"Comment": "obtain a full set of bundle descriptors for a particular type",
	"Method": "Set<BundleDescriptor> getBundleDescriptorsOfType(ArchiveType bundleType){\r\n    if (bundleType == null) {\r\n        return Collections.emptySet();\r\n    }\r\n    Set<BundleDescriptor> bundleSet = new OrderedSet<BundleDescriptor>();\r\n    for (ModuleDescriptor aModule : getModules()) {\r\n        if (aModule.getDescriptor().getModuleType() == bundleType) {\r\n            bundleSet.add((BundleDescriptor) aModule.getDescriptor());\r\n        }\r\n        for (RootDeploymentDescriptor rd : aModule.getDescriptor().getExtensionsDescriptors()) {\r\n            if (rd instanceof BundleDescriptor) {\r\n                if (((BundleDescriptor) rd).getModuleType() == bundleType) {\r\n                    bundleSet.add((BundleDescriptor) rd);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return bundleSet;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbBundleDescriptorImpl.getUniqueId",
	"Comment": "returns the unique id used in a stand alone ejb module.for application, this will return zero.",
	"Method": "long getUniqueId(){\r\n    return uniqueId;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.notifyOptimistic",
	"Comment": "for transaction to notify persistencemanager thatoptimistic flag is changed",
	"Method": "void notifyOptimistic(boolean optimistic){\r\n    this._optimistic = optimistic;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.common.wls.ResourceEnvDescriptionNode.writeDescriptors",
	"Comment": "write all occurrences of the descriptor corresponding to the currentnode from the parent descriptor to an jaxp dom node and return itthis api will be invoked by the parent node when the parent nodewrites out a mix of statically and dynamically registered sub nodes.this method should be overriden by the sub classes if itneeds to be called by the parent node.",
	"Method": "Node writeDescriptors(Node parent,String nodeName,Descriptor parentDesc){\r\n    if (parentDesc instanceof ResourceEnvReferenceContainer) {\r\n        ResourceEnvReferenceContainer resourceEnvReferenceContainer = (ResourceEnvReferenceContainer) parentDesc;\r\n        Set<ResourceEnvReferenceDescriptor> resourceEnvReferenceDescriptors = resourceEnvReferenceContainer.getResourceEnvReferenceDescriptors();\r\n        for (ResourceEnvReferenceDescriptor resourceEnvReferenceDescriptor : resourceEnvReferenceDescriptors) {\r\n            writeDescriptor(parent, nodeName, resourceEnvReferenceDescriptor);\r\n        }\r\n    }\r\n    return parent;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionImpl.getPasswordCredential",
	"Comment": "returns the passwordcredential object associated with this managedconnection.",
	"Method": "PasswordCredential getPasswordCredential(){\r\n    return passwdCredential;\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.SecurityMechanismSelector.getSecurityContextForWebOrEJB",
	"Comment": "create the security context to be used by the csiv2 layerto marshal in the service context of the iiop message from an webcomponent or ejb invoking another ejb.",
	"Method": "SecurityContext getSecurityContextForWebOrEJB(ComponentInvocation ci,boolean sslUsed,boolean clientAuthOccurred,CompoundSecMech mechanism){\r\n    SecurityContext ctx = null;\r\n    if (!sslUsed) {\r\n        ctx = propagateIdentity(false, ci, mechanism);\r\n    } else {\r\n        ctx = propagateIdentity(clientAuthOccurred, ci, mechanism);\r\n    }\r\n    return ctx;\r\n}"
}, {
	"Path": "com.sun.ejb.containers.StatefulSessionContainer.createEJBObjectImpl",
	"Comment": "called from createejbobject and activateejb and createejblocalobjectimpl",
	"Method": "EJBObjectImpl createEJBObjectImpl(EJBObjectImpl createEJBObjectImpl,SessionContextImpl context){\r\n    if (context.getEJBObjectImpl() != null)\r\n        return context.getEJBObjectImpl();\r\n    Object sessionKey = context.getInstanceKey();\r\n    EJBObjectImpl ejbObjImpl = instantiateEJBObjectImpl(null, sessionKey);\r\n    context.setEJBObjectImpl(ejbObjImpl);\r\n    ejbObjImpl.setContext(context);\r\n    byte[] sessionOID = uuidGenerator.keyToByteArray(sessionKey);\r\n    EJBObject ejbStub = (EJBObject) remoteHomeRefFactory.createRemoteReference(sessionOID);\r\n    context.setEJBStub(ejbStub);\r\n    ejbObjImpl.setStub(ejbStub);\r\n    if (hasRemoteBusinessView) {\r\n        createRemoteBusinessObjectImpl(context);\r\n    }\r\n    if (isLocal) {\r\n        if (hasLocalHomeView) {\r\n            createEJBLocalObjectImpl(context);\r\n        }\r\n        if (hasLocalBusinessView) {\r\n            createEJBLocalBusinessObjectImpl(context);\r\n        }\r\n        if (hasOptionalLocalBusinessView) {\r\n            createOptionalEJBLocalBusinessObjectImpl(context);\r\n        }\r\n    }\r\n    return ejbObjImpl;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.VersionConsistencyCacheImpl.create",
	"Comment": "create a cache.the performance characteristics of the cache dependson the setting of the runtime properties.if the flagcom.sun.jdo.spi.persistence.support.sqlstore.impl.versionconsistency.lrucacheis true, then the lrucache cache is used.if it has some other value,the bucketizedhashtable cache is used.if not set, but we can load the lrucache class, the lrucache cache is used.otherwise, we usethe bucketizedhashtable cache.other properties control particularsof those two caches.",
	"Method": "VersionConsistencyCache create(VCCache create,VCCache create,VCCache create){\r\n    return new VersionConsistencyCacheImpl();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerWrapper.newSCOInstance",
	"Comment": "returns a new second class object instance of the type specified,with the owner and field name to notify upon changes to the valueof any of its fields. if a collection class is created, then theclass does not restrict the element types, and allows nulls to be added as elements.",
	"Method": "Object newSCOInstance(Class type,Object owner,String fieldName){\r\n    if (isValid) {\r\n        return pm.newSCOInstance(type, owner, fieldName);\r\n    } else {\r\n        throw new JDOUserException(// NOI18N\r\n        I18NHelper.getMessage(messages, \"jdo.persistencemanagerwrapper.invalidpm\"));\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.tree.ListTreeAdaptor.getId",
	"Comment": "this method returns the id for the given tree node \tmodel object.",
	"Method": "String getId(Object nodeObject){\r\n    if (nodeObject == null) {\r\n        return \"nullNodeObject\";\r\n    }\r\n    if ((nodeObject instanceof Integer) && nodeObject.equals(TOP_ID)) {\r\n        return getLayoutComponent().getId(FacesContext.getCurrentInstance(), getParentUIComponent());\r\n    }\r\n    return GuiUtil.genId(nodeObject.toString());\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsExtendedSQLGrammar",
	"Comment": "retrieves whether this database supports the odbc extended sql grammar.",
	"Method": "boolean supportsExtendedSQLGrammar(){\r\n    return databaseMetaData.supportsExtendedSQLGrammar();\r\n}"
}, {
	"Path": "org.glassfish.persistence.ejb.entitybean.container.EntityBeanHomeImpl.createEJBObjectImpl",
	"Comment": "ejbobjectimpl is created directly by the container, not by this call",
	"Method": "EJBObjectImpl createEJBObjectImpl(){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.moveToInsertRow",
	"Comment": "moves the cursor to the insert row.the current cursor position isremembered while the cursor is positioned on the insert row.the insert row is a special row associated with an updatableresult set.it is essentially a buffer where a new row maybe constructed by calling the updater methods prior toinserting the row into the result set.only the updater, getter,and insertrow methods may becalled when the cursor is on the insert row.all of the columns ina result set must be given a value each time this method iscalled before calling insertrow.an updater method must be called before agetter method can be called on a column value.",
	"Method": "void moveToInsertRow(){\r\n    resultSet.moveToInsertRow();\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.DBStatement.addBatch",
	"Comment": "increases the batch counter and delegates the addbatch call to thepreparedstatement wrapped by this dbstatement.",
	"Method": "void addBatch(){\r\n    batchCounter++;\r\n    if (logger.isLoggable(Logger.FINER)) {\r\n        // NOI18N\r\n        logger.finer(\"sqlstore.sql.generator.dbstatement.addbatch\", new Integer(batchCounter));\r\n    }\r\n    preparedStmt.addBatch();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.mapping.impl.MappingFieldElementImpl.isInConcurrencyCheck",
	"Comment": "determines whether this field element is in a concurrency check or not.",
	"Method": "boolean isInConcurrencyCheck(){\r\n    return getProperty(IN_CONCURRENCY_CHECK);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.ManagedConnectionFactoryImpl.isValidByMetaData",
	"Comment": "checks if a java.sql.connection is valid or notby checking its meta data.",
	"Method": "void isValidByMetaData(java.sql.Connection con){\r\n    if (con == null) {\r\n        throw new ResourceException(\"The connection is not valid as \" + \"the connection is null\");\r\n    }\r\n    try {\r\n        con.getMetaData();\r\n    } catch (Exception sqle) {\r\n        _logger.log(Level.INFO, \"jdbc.exc_metadata_validation\");\r\n        throw new ResourceException(sqle);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.deployment.LoginConfigurationImpl.setRealmName",
	"Comment": "set the realm the server should use for basic authentication.",
	"Method": "void setRealmName(String realmName){\r\n    this.realmName = realmName;\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.HTTPInputArchive.entryNames",
	"Comment": "returns a collection containing the names of all entries in thearchive.",
	"Method": "Collection<String> entryNames(){\r\n    if (cachedEntryNames == null) {\r\n        cachedEntryNames = new ArrayList<String>();\r\n        final JarInputStream jis = new JarInputStream(archiveURL.openStream());\r\n        JarEntry entry;\r\n        try {\r\n            while ((entry = jis.getNextJarEntry()) != null) {\r\n                cachedEntryNames.add(entry.getName());\r\n            }\r\n        } finally {\r\n            jis.close();\r\n        }\r\n    }\r\n    return cachedEntryNames;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.ejb.CMPHelper.rollbackInternalTransaction",
	"Comment": "called in a unspecified transaction context of a managed environment.according to p.364 of ejb 2.0 spec, cmp may need to manageits own transaction when its transaction attribute isnotsupported, never, supports.",
	"Method": "void rollbackInternalTransaction(PersistenceManager pm){\r\n    getContainerHelper().rollbackInternalTransaction(pm);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sco.SqlTimestamp.writeReplace",
	"Comment": "use java.sql.timestamp as the designated object to be used when writing this object to the stream.",
	"Method": "Object writeReplace(){\r\n    java.sql.Timestamp t = new java.sql.Timestamp(getTime());\r\n    t.setNanos(this.getNanos());\r\n    return t;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.generator.SelectQueryPlan.processForeignField",
	"Comment": "process the projected foreign field at index index.initializes and builds a new selectqueryplan for this field andadds selected columns to the result descriptor. if the field isnavigated only, just adds the statement and table alias.",
	"Method": "void processForeignField(ConstraintFieldName cfn,ArrayList localFields){\r\n    SelectQueryPlan fp = new SelectQueryPlan(cfn.desc, store, concurrency);\r\n    fp.prefetched = cfn.isPrefetched();\r\n    if (fp.prefetched) {\r\n        fp.options |= RetrieveDescImpl.OPT_ADD_FETCHGROUPS;\r\n    }\r\n    fp.processParentField(config, cfn.name);\r\n    fp.build();\r\n    for (int i = 0; i < fp.parentField.localFields.size(); i++) {\r\n        LocalFieldDesc la = (LocalFieldDesc) fp.parentField.localFields.get(i);\r\n        if (!getFieldMask(la.absoluteID)) {\r\n            if ((options & RetrieveDescImpl.OPT_ADD_FETCHGROUPS) > 0) {\r\n                localFields.add(la);\r\n            } else {\r\n                addTable(la);\r\n            }\r\n        }\r\n    }\r\n    foreignPlans.add(fp);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.setByte",
	"Comment": "sets the designated parameter to the given java byte value.the driver converts thisto an sql tinyint value when it sends it to the database.",
	"Method": "void setByte(String parameterName,byte x){\r\n    callableStatement.setByte(parameterName, x);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ResourceDescriptorRegistry.getAllResourcesDescriptors",
	"Comment": "this method returns all descriptors associated with the app.",
	"Method": "Set<ResourceDescriptor> getAllResourcesDescriptors(Set<ResourceDescriptor> getAllResourcesDescriptors,Class givenClazz){\r\n    Set<ResourceDescriptor> allResourceDescriptors = new HashSet<ResourceDescriptor>();\r\n    for (JavaEEResourceType javaEEResourceType : JavaEEResourceType.values()) {\r\n        Set<Class> invalidClassSet = invalidResourceTypeScopes.get(javaEEResourceType);\r\n        if (invalidClassSet != null && invalidClassSet.size() > 0) {\r\n            for (Class invalidClass : invalidClassSet) {\r\n                if (!invalidClass.isAssignableFrom(givenClazz)) {\r\n                    allResourceDescriptors.addAll(this.getResourceDescriptors(javaEEResourceType));\r\n                }\r\n            }\r\n        } else if (invalidClassSet != null) {\r\n            allResourceDescriptors.addAll(this.getResourceDescriptors(javaEEResourceType));\r\n        }\r\n    }\r\n    return allResourceDescriptors;\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.handlers.CommonHandlers.initProductInfoAttributes",
	"Comment": "this function is called in login.jsf to set the various product specific attributes such as theproduct gifs and product names. a similar function is called for sailfin to set sailfin specific product gifs and name. the function is defined in com.sun.extensions.comms.siputilities",
	"Method": "void initProductInfoAttributes(HandlerContext handlerCtx){\r\n    Map sessionMap = handlerCtx.getFacesContext().getExternalContext().getSessionMap();\r\n    Object initialized = sessionMap.get(\"_INFO_SESSION_INITIALIZED\");\r\n    if (initialized != null) {\r\n        return;\r\n    }\r\n    sessionMap.put(\"productImageURL\", GuiUtil.getMessage(\"productImage.URL\"));\r\n    sessionMap.put(\"productImageWidth\", Integer.parseInt(GuiUtil.getMessage(\"productImage.width\")));\r\n    sessionMap.put(\"productImageHeight\", Integer.parseInt(GuiUtil.getMessage(\"productImage.height\")));\r\n    sessionMap.put(\"loginProductImageURL\", GuiUtil.getMessage(\"login.productImage.URL\"));\r\n    sessionMap.put(\"loginProductImageWidth\", Integer.parseInt(GuiUtil.getMessage(\"login.productImage.width\")));\r\n    sessionMap.put(\"loginProductImageHeight\", Integer.parseInt(GuiUtil.getMessage(\"login.productImage.height\")));\r\n    sessionMap.put(\"fullProductName\", GuiUtil.getMessage(\"versionImage.description\"));\r\n    sessionMap.put(\"loginButtonTooltip\", GuiUtil.getMessage(\"loginButtonTooltip\"));\r\n    sessionMap.put(\"mastHeadDescription\", GuiUtil.getMessage(\"mastHeadDescription\"));\r\n    sessionMap.put(\"_INFO_SESSION_INITIALIZED\", \"TRUE\");\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.node.runtime.application.wls.WeblogicApplicationNode.registerBundle",
	"Comment": "register this node as a root node capable of loading entire dd files",
	"Method": "String registerBundle(Map publicIDToDTD,Map<String, List<Class>> versionUpgrades){\r\n    publicIDToDTD.put(PUBLIC_DTD_ID_2, SYSTEM_ID_2);\r\n    List<Class> list = new ArrayList<Class>();\r\n    list.add(DataSourceNameVersionUpgrade.class);\r\n    list.add(StartMdbsWithApplicationVersionUpgrade.class);\r\n    versionUpgrades.put(RuntimeTagNames.WLS_APPLICATION_RUNTIME_TAG, list);\r\n    return RuntimeTagNames.WLS_APPLICATION_RUNTIME_TAG;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.ActiveResourceAdapterImpl.destroy",
	"Comment": "uninitializes the resource adapter. it also destroys the default poolsand resources",
	"Method": "void destroy(){\r\n    if (isServer()) {\r\n        destroyAllConnectorResources();\r\n    }\r\n}"
}, {
	"Path": "com.sun.gjc.common.DataSourceObjectBuilder.parseDriverProperties",
	"Comment": "get the extra driver properties from the datasourcespec object andparse them to a set of methodname and parameters. prepare a hashtablecontaining these details and return.",
	"Method": "Hashtable parseDriverProperties(DataSourceSpec spec,boolean returnUpperCase,Hashtable parseDriverProperties,String values,String escape,String delimiter,boolean returnUpperCase){\r\n    Hashtable result = new Hashtable();\r\n    String parsedValue = \"\";\r\n    String name = \"\";\r\n    String value = \"\";\r\n    char escapeChar = escape.charAt(0);\r\n    char delimiterChar = delimiter.charAt(0);\r\n    while (values.length() > 0) {\r\n        if (values.charAt(0) == delimiterChar) {\r\n            if (values.length() > 1 && values.charAt(1) == delimiterChar) {\r\n                if (values.length() > 2 && values.charAt(2) == delimiterChar) {\r\n                    if (returnUpperCase) {\r\n                        name = parsedValue.toUpperCase(Locale.getDefault());\r\n                    } else {\r\n                        name = parsedValue;\r\n                    }\r\n                    parsedValue = \"\";\r\n                }\r\n                value = parsedValue;\r\n                Vector v = new Vector();\r\n                v.add(value);\r\n                result.put(name, v);\r\n                parsedValue = \"\";\r\n                values = values.substring(2);\r\n            } else {\r\n                if (returnUpperCase) {\r\n                    name = parsedValue.toUpperCase(Locale.getDefault());\r\n                } else {\r\n                    name = parsedValue;\r\n                }\r\n                parsedValue = \"\";\r\n                values = values.substring(1);\r\n            }\r\n        } else if (values.charAt(0) == escapeChar) {\r\n            if (values.charAt(1) == escapeChar) {\r\n                parsedValue += values.charAt(1);\r\n            } else if (values.charAt(1) == delimiterChar) {\r\n                parsedValue += values.charAt(1);\r\n            }\r\n            values = values.substring(2);\r\n        } else if (values.charAt(0) != escapeChar) {\r\n            parsedValue += values.charAt(0);\r\n            values = values.substring(1);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.DatabaseMetaDataWrapper.supportsAlterTableWithDropColumn",
	"Comment": "retrieves whether this database supports alter tablewith drop column.",
	"Method": "boolean supportsAlterTableWithDropColumn(){\r\n    return databaseMetaData.supportsAlterTableWithDropColumn();\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.enhancer.impl.FieldAction.getMethodSig",
	"Comment": "return the type signature of the static method on class genericobjectwhich will get the field value.",
	"Method": "String getMethodSig(){\r\n    return fieldTypeInfo.fieldGetMethodSig;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.perms.SMGlobalPolicyUtil.getEECompGrantededPerms",
	"Comment": "get the default granted permissions of a specified component type",
	"Method": "PermissionCollection getEECompGrantededPerms(CommponentType type,PermissionCollection getEECompGrantededPerms,String type){\r\n    CommponentType compType = convertComponentType(type);\r\n    return getEECompGrantededPerms(compType);\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.LocalFieldDesc.getPrimaryColumn",
	"Comment": "gets the columnelement for the primary column of this field.",
	"Method": "ColumnElement getPrimaryColumn(){\r\n    return ((ColumnElement) columnDescs.get(0));\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.annotation.introspection.EjbComponentAnnotationScanner.isAnnotation",
	"Comment": "test if the passed constant pool string is a reference to a type.type annotation of a j2ee component",
	"Method": "boolean isAnnotation(String value){\r\n    if (annotations == null) {\r\n        synchronized (EjbComponentAnnotationScanner.class) {\r\n            if (annotations == null)\r\n                init();\r\n        }\r\n    }\r\n    return annotations.contains(value);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.service.ConnectorConnectionPoolAdminServiceImpl.getPoolNameFromResourceJndiName",
	"Comment": "gets the pool name that this jdbc resource points to. in case of a pmf resourcegets the pool name of the pool pointed to by jdbc resource being pointed to bythe pmf resource",
	"Method": "PoolInfo getPoolNameFromResourceJndiName(ResourceInfo resourceInfo){\r\n    PoolInfo poolInfo = null;\r\n    Collection<ConnectorRuntimeExtension> extensions = Globals.getDefaultHabitat().getAllServices(ConnectorRuntimeExtension.class);\r\n    for (ConnectorRuntimeExtension extension : extensions) {\r\n        poolInfo = extension.getPoolNameFromResourceJndiName(resourceInfo);\r\n    }\r\n    return poolInfo;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.annotation.handlers.SingletonHandler.isValidEjbDescriptor",
	"Comment": "check if the given ejbdescriptor matches the given annotation.",
	"Method": "boolean isValidEjbDescriptor(EjbDescriptor ejbDesc,Annotation annotation){\r\n    boolean isValid = EjbSessionDescriptor.TYPE.equals(ejbDesc.getType());\r\n    if (isValid) {\r\n        EjbSessionDescriptor sessionDesc = (EjbSessionDescriptor) ejbDesc;\r\n        if (sessionDesc.isSessionTypeSet() && !sessionDesc.isSingleton()) {\r\n            isValid = false;\r\n        }\r\n    }\r\n    return isValid;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.model.ForeignFieldDesc.checkReferentialIntegrityUpdatesForObjectField",
	"Comment": "checks, if datastore updates will be scheduled locally or onthe opposite relationship side.",
	"Method": "boolean checkReferentialIntegrityUpdatesForObjectField(){\r\n    boolean refIntegrityUpdate;\r\n    ForeignFieldDesc inverseFieldDesc = getInverseRelationshipField();\r\n    if (inverseFieldDesc == null) {\r\n        refIntegrityUpdate = true;\r\n    } else {\r\n        if (inverseFieldDesc.cardinalityUPB > 1) {\r\n            refIntegrityUpdate = true;\r\n        } else {\r\n            refIntegrityUpdate = defineUpdatedSide1To1(inverseFieldDesc);\r\n        }\r\n    }\r\n    return refIntegrityUpdate;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.module.ConnectorDeployer.postConstruct",
	"Comment": "the component has been injected with any dependency andwill be placed into commission by the subsystem.",
	"Method": "void postConstruct(){\r\n    resources = domain.getResources();\r\n    events.register(this);\r\n}"
}, {
	"Path": "com.sun.web.security.WebProgrammaticLoginImpl.login",
	"Comment": "login and set up principal in request and session. this implementsprogrammatic login for servlets. due to a number of bugs in ri the security context is notshared between web container and ejb container. in order for anidentity established by programmatic login to be known to bothcontainers, it needs to be set not only in the security context butalso in the current request and, if applicable, the session object.if a session does not exist this method does not create one.see bugs 4646134, 4688449 and other referenced bugs for morebackground.note also that this login does not hook up into sso.",
	"Method": "Boolean login(String user,char[] password,String realm,HttpServletRequest request,HttpServletResponse response){\r\n    Request req = getUnwrappedCoyoteRequest(request);\r\n    if (req == null) {\r\n        return Boolean.valueOf(false);\r\n    }\r\n    LoginContextDriver.login(user, password, realm);\r\n    SecurityContext secCtx = SecurityContext.getCurrent();\r\n    assert (secCtx != null);\r\n    WebPrincipal principal = new WebPrincipal(user, password, secCtx);\r\n    req.setUserPrincipal(principal);\r\n    req.setAuthType(WEBAUTH_PROGRAMMATIC);\r\n    if (logger.isLoggable(Level.FINE)) {\r\n        logger.log(Level.FINE, \"Programmatic login set principal in http request to: \" + user);\r\n    }\r\n    Session realSession = getSession(req);\r\n    if (realSession != null) {\r\n        realSession.setPrincipal((Principal) principal);\r\n        realSession.setAuthType(WEBAUTH_PROGRAMMATIC);\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.log(Level.FINE, \"Programmatic login set principal in session.\");\r\n        }\r\n    } else {\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.log(Level.FINE, \"Programmatic login: No session available.\");\r\n        }\r\n    }\r\n    return Boolean.valueOf(true);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.web.integration.WebSecurityManager.hasNoConstrainedResources",
	"Comment": "returns true to indicate that a policy check was made and there were no constrained resources. when caching is disabled must always return false, which will ensure that policy is consulted to authorize each request.",
	"Method": "boolean hasNoConstrainedResources(){\r\n    boolean result = false;\r\n    if (allResourcesCP != null && allConnectionsCP != null) {\r\n        boolean x = allResourcesCP.checkPermission();\r\n        boolean y = allConnectionsCP.checkPermission();\r\n        result = x && y;\r\n        if (result) {\r\n            try {\r\n                setPolicyContext(CONTEXT_ID);\r\n            } catch (Throwable t) {\r\n                throw new RuntimeException(t);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.ejb.deployment.descriptor.EjbMessageBeanDescriptor.getActivationConfigDescriptor",
	"Comment": "through the other accessors on the message bean descriptor.",
	"Method": "ActivationConfigDescriptor getActivationConfigDescriptor(){\r\n    return activationConfig;\r\n}"
}, {
	"Path": "test.extension.ServiceFrameworkExtension.addBean",
	"Comment": "add a bean for the framework service requested. instantiateor discover the bean from the framework service registry, and return a reference to the service if a dynamic reference is requested.",
	"Method": "void addBean(AfterBeanDiscovery abd,Type type,Set<FrameworkService> frameworkServices){\r\n    for (Iterator<FrameworkService> iterator = frameworkServices.iterator(); iterator.hasNext(); ) {\r\n        final FrameworkService frameworkService = iterator.next();\r\n        System.out.println(\" --- Adding a framework service BEAN \" + type + \" for \" + frameworkService);\r\n        abd.addBean(new FrameworkServiceBean(type, frameworkService));\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.Application.getServiceReferenceByName",
	"Comment": "looks up an service reference with the given name.throws an illegalargumentexception if it is not found.",
	"Method": "ServiceReferenceDescriptor getServiceReferenceByName(String name){\r\n    for (Iterator itr = this.getServiceReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        ServiceReferenceDescriptor srd = (ServiceReferenceDescriptor) itr.next();\r\n        if (srd.getName().equals(name)) {\r\n            return srd;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"enterprise.deployment.exceptionapphasnoservicerefbyname\", \"This app [{0}] has no service reference by the name of [{1}]\", new Object[] { getRegistrationName(), name }));\r\n}"
}, {
	"Path": "com.sun.ejb.containers.BaseContainer.doTimerInvocationInit",
	"Comment": "this is implemented by concrete containers that support timedobjects.",
	"Method": "void doTimerInvocationInit(EjbInvocation inv,Object primaryKey){\r\n    throw new EJBException(\"This container doesn't support TimedObjects\");\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.SQLPersistenceManagerFactory.getConnectionTransactionIsolation",
	"Comment": "returns current transaction isolation level for connections of this persistencemanagerfactory.",
	"Method": "int getConnectionTransactionIsolation(){\r\n    return _persistenceManagerFactory.getConnectionTransactionIsolation();\r\n}"
}, {
	"Path": "com.sun.gjc.spi.jdbc40.CallableStatementWrapper40.isClosed",
	"Comment": "retrieves whether this statement object has been closed. a statement is closed if themethod close has been called on it, or if it is automatically closed.",
	"Method": "boolean isClosed(){\r\n    return callableStatement.isClosed();\r\n}"
}, {
	"Path": "com.sun.ejb.containers.EJBTimerService.getNextTimerId",
	"Comment": "generate a unique key for the persistent timer object.key must be unique across server shutdown and startup, andwithin all server instances sharing the same timer table.",
	"Method": "String getNextTimerId(){\r\n    if (nextTimerIdCounter_ <= 0) {\r\n        nextTimerIdMillis_ = System.currentTimeMillis();\r\n        nextTimerIdCounter_ = 1;\r\n    } else {\r\n        nextTimerIdCounter_++;\r\n    }\r\n    return \"\" + nextTimerIdCounter_ + TIMER_ID_SEP + nextTimerIdMillis_ + TIMER_ID_SEP + ownerIdOfThisServer_ + TIMER_ID_SEP + domainName_;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.mapping.ejb.MappingGenerator.generateMappingClasses",
	"Comment": "create mapping classes and schema based on database vendor name.",
	"Method": "DatabaseGenerator.Results generateMappingClasses(String dbName,Boolean uniqueTableNames,Properties userPolicy,String inputFilesPath){\r\n    SunCmpMappings sunCmpMappings = null;\r\n    List pcClasses = new ArrayList();\r\n    sunCmpMappings = getPartialSunCmpMappings(pcClasses, (uniqueTableNames != null) ? uniqueTableNames.booleanValue() : false);\r\n    ddHelper.setEnsureValidation(false);\r\n    SchemaElement fakeSchema = new SchemaElement(new SchemaElementImpl());\r\n    fakeSchema.setName(DBIdentifier.create(FAKE_NAME));\r\n    SchemaElement.addToCache(fakeSchema);\r\n    loadMappingClasses(sunCmpMappings, null);\r\n    DatabaseGenerator.Results results = generateSchema(pcClasses, dbName, uniqueTableNames, userPolicy);\r\n    SchemaElement schema = results.getSchema();\r\n    Set mappingClasses = results.getMappingClasses();\r\n    SchemaElement.removeFromCache(FAKE_NAME);\r\n    SchemaElement.removeFromCache(schema.getName().getName());\r\n    SchemaElement.addToCache(schema);\r\n    updateMappingClasses(mappingClasses);\r\n    if (skipGeneratedFields) {\r\n        Iterator iter = mappingClasses.iterator();\r\n        while (iter.hasNext()) {\r\n            MappingClassElement mapClassElt = (MappingClassElement) iter.next();\r\n            if (mapClassElt != null) {\r\n                String className = mapClassElt.getName();\r\n                String ejbName = nameMapper.getEjbNameForPersistenceClass(className);\r\n                PersistenceClassElement pce = (PersistenceClassElement) model.getPersistenceClass(className);\r\n                PersistenceFieldElement[] allFields = pce.getFields();\r\n                if (allFields != null) {\r\n                    List generatedFieldList = new ArrayList();\r\n                    for (int i = 0; i < allFields.length; i++) {\r\n                        PersistenceFieldElement pfe = allFields[i];\r\n                        if (pfe != null) {\r\n                            String pFieldName = pfe.getName();\r\n                            String ejbFieldName = nameMapper.getEjbFieldForPersistenceField(className, pFieldName);\r\n                            if (nameMapper.isGeneratedField(ejbName, ejbFieldName)) {\r\n                                generatedFieldList.add(pfe);\r\n                            }\r\n                        }\r\n                    }\r\n                    Iterator iterator = generatedFieldList.iterator();\r\n                    while (iterator.hasNext()) {\r\n                        PersistenceFieldElement pfe = (PersistenceFieldElement) iterator.next();\r\n                        MappingFieldElement mfe = mapClassElt.getField(pfe.getName());\r\n                        if (mfe != null && (!mfe.isVersion())) {\r\n                            model.removeFieldElement(pfe);\r\n                            mapClassElt.removeField(mfe);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.impl.PersistenceClassElementImpl.getGroupCollection",
	"Comment": "returns the concurrency group collection of this class element.\tthis method should only be used internally and for cloning and \tarchiving.",
	"Method": "PersistenceElementCollection getGroupCollection(){\r\n    return _groups;\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.connector.module.ConnectorSniffer.getDeploymentConfigurationPaths",
	"Comment": "returns the descriptor paths that might exist in a connector app.",
	"Method": "List<String> getDeploymentConfigurationPaths(){\r\n    return deploymentConfigurationPaths;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.ApplicationClientDescriptor.getMessageDestinationReferenceByName",
	"Comment": "looks up an message destination reference with the given name. throws an illegalargumentexception if it is not found.",
	"Method": "MessageDestinationReferenceDescriptor getMessageDestinationReferenceByName(String name){\r\n    for (Iterator itr = this.getMessageDestinationReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        MessageDestinationReferenceDescriptor mdr = (MessageDestinationReferenceDescriptor) itr.next();\r\n        if (mdr.getName().equals(name)) {\r\n            return mdr;\r\n        }\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"exceptionappclienthasnomsgdestrefbyname\", \"This application client [{0}] has no message destination reference by the name of [{1}]\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.sql.RetrieveDescImpl.getNavigationalId",
	"Comment": "returns the navigational id of this retrieve descriptor. this idwill be used to discriminate different retrieve descriptors whichuse the same navigational field. if not set, the field name is used.",
	"Method": "Object getNavigationalId(){\r\n    return navigationalId;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.SQLStoreManager.retrieve",
	"Comment": "the retrieve method builds and executes the sql query described bythe action parameter.",
	"Method": "Object retrieve(PersistenceManager pm,RetrieveDesc action,ValueFetcher parameters){\r\n    if (action == null) {\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(// NOI18N\r\n        messages, \"core.generic.nullparam\", \"action\"));\r\n    }\r\n    if (!(action instanceof RetrieveDescImpl)) {\r\n        throw new JDOFatalInternalException(// NOI18N\r\n        I18NHelper.getMessage(messages, // NOI18N\r\n        \"core.generic.notinstanceof\", action.getClass().getName(), \"RetrieveDescImpl\"));\r\n    }\r\n    RetrieveDescImpl retrieveAction = ((RetrieveDescImpl) action);\r\n    ClassDesc config = retrieveAction.getConfig();\r\n    Concurrency concurrency = config.getConcurrency(pm.isOptimisticTransaction());\r\n    SelectQueryPlan plan = retrieveAction.buildQueryPlan(this, concurrency);\r\n    ArrayList statements = plan.getStatements();\r\n    Object result = null;\r\n    SelectStatement s = (SelectStatement) statements.get(0);\r\n    result = executeQuery(pm, s, concurrency, parameters);\r\n    if ((plan.options & RetrieveDescImpl.OPT_AGGREGATE) == 0) {\r\n        if ((plan.options & RetrieveDescImpl.OPT_DISTINCT) > 0) {\r\n            if (((plan.options & RetrieveDescImpl.OPT_FOR_UPDATE) > 0 && !vendorType.isDistinctSupportedWithUpdateLock())) {\r\n                HashSet hash = new HashSet();\r\n                for (Iterator iter = ((Collection) result).iterator(); iter.hasNext(); ) {\r\n                    Object temp = iter.next();\r\n                    if (!hash.contains(temp)) {\r\n                        hash.add(temp);\r\n                    } else {\r\n                        iter.remove();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.CallableStatementWrapper.getClob",
	"Comment": "retrieves the value of a jdbc clob parameter as aclob object in the java programming language.",
	"Method": "Clob getClob(int i,Clob getClob,String parameterName){\r\n    return callableStatement.getClob(parameterName);\r\n}"
}, {
	"Path": "com.sun.enterprise.connectors.jms.system.MQAddressList.updateMQUrl",
	"Comment": "updates the information about the jmshostin the address list.",
	"Method": "void updateMQUrl(JmsHost host){\r\n    MQUrl url = createUrl(host);\r\n    urlList.remove(url);\r\n    urlList.add(url);\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getBigDecimal",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object as ajava.math.bigdecimal with full precision.",
	"Method": "BigDecimal getBigDecimal(int columnIndex,int scale,BigDecimal getBigDecimal,String columnName,int scale,BigDecimal getBigDecimal,int columnIndex,BigDecimal getBigDecimal,String columnName){\r\n    return resultSet.getBigDecimal(columnName);\r\n}"
}, {
	"Path": "org.glassfish.appclient.client.acc.StandAloneAppClientInfo.fixupWSDLEntries",
	"Comment": "adjusts the web services wsdl entries corresponding to where they actually reside.",
	"Method": "void fixupWSDLEntries(){\r\n    ApplicationClientDescriptor ac = getAppClient();\r\n    URI uri = (new File(getAppClientRoot(appClientArchive, ac))).toURI();\r\n    File moduleFile = new File(uri);\r\n    for (Iterator itr = ac.getServiceReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n        ServiceReferenceDescriptor serviceRef = (ServiceReferenceDescriptor) itr.next();\r\n        if (serviceRef.getWsdlFileUri() != null) {\r\n            String wsdlURI = serviceRef.getWsdlFileUri();\r\n            File wsdlFile = new File(wsdlURI);\r\n            if (wsdlFile.isAbsolute()) {\r\n                serviceRef.setWsdlFileUrl(wsdlFile.toURI().toURL());\r\n            } else {\r\n                serviceRef.setWsdlFileUrl(getEntryAsUrl(moduleFile, serviceRef.getWsdlFileUri()));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.connection.ConnectionImpl.xactPending",
	"Comment": "indicates whether this connection is participating in a transaction.",
	"Method": "boolean xactPending(){\r\n    return ((this.transaction != null) ? true : false);\r\n}"
}, {
	"Path": "com.sun.enterprise.iiop.security.GSSUtils.getMechanism",
	"Comment": "return the asn.1 encoded representation of a gss mechanism identifier.currently only the gssup mechanism is supported.",
	"Method": "byte[] getMechanism(){\r\n    byte[] mechCopy = Arrays.copyOf(mech, mech.length);\r\n    return mechCopy;\r\n}"
}, {
	"Path": "org.glassfish.jdbc.pool.monitor.JdbcConnPoolStatsProvider.connectionDestroyedEvent",
	"Comment": "when connection destroyed event is got increment numconndestroyed.",
	"Method": "void connectionDestroyedEvent(String poolName,String appName,String moduleName){\r\n    PoolInfo poolInfo = new PoolInfo(poolName, appName, moduleName);\r\n    if (this.poolInfo.equals(poolInfo)) {\r\n        if (logger.isLoggable(Level.FINEST)) {\r\n            logger.finest(\"Connection destroyed event received - \" + \"poolName = \" + poolName);\r\n        }\r\n        numConnDestroyed.increment();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jdo.api.persistence.model.jdo.PersistenceClassElement.getConcurrencyGroup",
	"Comment": "returns the concurrency group with the supplied name from the \tcollection of groups maintained by this class.",
	"Method": "ConcurrencyGroupElement getConcurrencyGroup(String name,ConcurrencyGroupElement getConcurrencyGroup,String name){\r\n    return getClassImpl().getConcurrencyGroup(name);\r\n}"
}, {
	"Path": "org.glassfish.persistence.ejb.entitybean.container.EntityContextImpl.cachePrimaryKey",
	"Comment": "called from entitycontainer after an ejb is obtained from the pool.",
	"Method": "void cachePrimaryKey(){\r\n    Object pk = getPrimaryKey();\r\n    this._primaryKey = pk;\r\n    this._pkHashCode = pk.hashCode();\r\n}"
}, {
	"Path": "org.glassfish.admingui.common.help.HelpHandlers.getHelpLocalePath",
	"Comment": "this method calculates the correct locale portion of the help path \tfor the requested locale.",
	"Method": "String getHelpLocalePath(Locale locale,ConsolePluginService cps){\r\n    ClassLoader loader = cps.getModuleClassLoader(\"common\");\r\n    String path = PluginHandlers.getHelpPathForResource(\"toc.xml\", locale, loader);\r\n    if (path == null) {\r\n        path = PluginHandlers.getHelpPathForResource(\"toc.xml\", Locale.getDefault(), loader);\r\n        if (path == null) {\r\n            path = \"/en/\";\r\n        }\r\n    }\r\n    return path.substring(1, path.indexOf('/', 1));\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.support.sqlstore.impl.PersistenceManagerImpl.setUserObject",
	"Comment": "the application can manage the persistencemanager instancesmore easily by having an application object associated with eachpersistencemanager instance.",
	"Method": "void setUserObject(Object o){\r\n    this._userObject = o;\r\n}"
}, {
	"Path": "com.sun.jdo.spi.persistence.utility.DoubleLinkedList.toString",
	"Comment": "return a string representation of this doublelinkedlist object.",
	"Method": "String toString(){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.gjc.spi.base.ResultSetWrapper.getRef",
	"Comment": "retrieves the value of the designated column in the current rowof this resultset object as a ref objectin the java programming language.",
	"Method": "Ref getRef(int i,Ref getRef,String colName){\r\n    return resultSet.getRef(colName);\r\n}"
}, {
	"Path": "org.glassfish.ejb.security.application.EJBSecurityManager.convertEJBRoleReferences",
	"Comment": "this method converts ejb role references to jacc permission objectsand adds them to the policy configuration objectit gets the list of role references from the ejb descriptor. for eachsuch role reference, create a ejbrolerefpermission and add it to thepolicyconfiguration object.",
	"Method": "void convertEJBRoleReferences(EjbDescriptor eDescriptor,String pcid){\r\n    PolicyConfiguration pc = getPolicyFactory().getPolicyConfiguration(pcid, false);\r\n    assert pc != null;\r\n    Set<Role> roleset = eDescriptor.getEjbBundleDescriptor().getRoles();\r\n    Role anyAuthUserRole = new Role(\"**\");\r\n    boolean rolesetContainsAnyAuthUserRole = roleset.contains(anyAuthUserRole);\r\n    List<Role> role = new ArrayList<Role>();\r\n    String eName = eDescriptor.getName();\r\n    for (RoleReference roleRef : eDescriptor.getRoleReferences()) {\r\n        String rolename = roleRef.getRoleName();\r\n        EJBRoleRefPermission ejbrr = new EJBRoleRefPermission(eName, rolename);\r\n        String rolelink = roleRef.getSecurityRoleLink().getName();\r\n        role.add(new Role(rolename));\r\n        pc.addToRole(rolelink, ejbrr);\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.fine(\"JACC: Converting role-ref -> \" + roleRef.toString() + \" to permission with name(\" + ejbrr.getName() + \") and actions (\" + ejbrr.getActions() + \")\" + \"mapped to role (\" + rolelink + \")\");\r\n        }\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, \"JACC: Converting role-ref: Going through the list of roles not present in RoleRef elements and creating EJBRoleRefPermissions \");\r\n    }\r\n    for (Role r : roleset) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"JACC: Converting role-ref: Looking at Role =  \" + r.getName());\r\n        }\r\n        if (!role.contains(r)) {\r\n            String action = r.getName();\r\n            EJBRoleRefPermission ejbrr = new EJBRoleRefPermission(eName, action);\r\n            pc.addToRole(action, ejbrr);\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.fine(\"JACC: Converting role-ref: Role =  \" + r.getName() + \" is added as a permission with name(\" + ejbrr.getName() + \") and actions (\" + ejbrr.getActions() + \")\" + \"mapped to role (\" + action + \")\");\r\n            }\r\n        }\r\n    }\r\n    if ((!role.contains(anyAuthUserRole)) && !rolesetContainsAnyAuthUserRole) {\r\n        String rolename = anyAuthUserRole.getName();\r\n        EJBRoleRefPermission ejbrr = new EJBRoleRefPermission(eName, rolename);\r\n        pc.addToRole(rolename, ejbrr);\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.fine(\"JACC: Converting role-ref: Adding any authenticated user role-ref \" + \" to permission with name(\" + ejbrr.getName() + \") and actions (\" + ejbrr.getActions() + \")\" + \"mapped to role (\" + rolename + \")\");\r\n        }\r\n    }\r\n}"
}]