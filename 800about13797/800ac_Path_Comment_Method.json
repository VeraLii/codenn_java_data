[{
	"Path": "org.apache.catalina.core.StandardContext.getWelcomeFiles",
	"Comment": "return the naming resources associated with this web application.",
	"Method": "String[] getWelcomeFiles(){\r\n    return findWelcomeFiles();\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.addFilter",
	"Comment": "adds the filter with the given name and class type to this servletcontext.",
	"Method": "FilterRegistration.Dynamic addFilter(String filterName,String className,FilterRegistration.Dynamic addFilter,String filterName,Filter filter,FilterRegistration.Dynamic addFilter,String filterName,Class<? extends Filter> filterClass){\r\n    if (isRestricted) {\r\n        throw new UnsupportedOperationException(rb.getString(LogFacade.UNSUPPORTED_OPERATION_EXCEPTION));\r\n    }\r\n    return context.addFilter(filterName, filterClass);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.commands.DeleteThreadpool.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    ActionReport report = context.getActionReport();\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<ThreadPools>() {\r\n            public Object run(ThreadPools param) throws PropertyVetoException, TransactionFailure {\r\n                List<ThreadPool> poolList = param.getThreadPool();\r\n                for (ThreadPool pool : poolList) {\r\n                    String currPoolId = pool.getName();\r\n                    if (currPoolId != null && currPoolId.equals(threadpool_id)) {\r\n                        poolList.remove(pool);\r\n                        break;\r\n                    }\r\n                }\r\n                return poolList;\r\n            }\r\n        }, threadPools);\r\n        report.setActionExitCode(ExitCode.SUCCESS);\r\n    } catch (TransactionFailure e) {\r\n        String str = e.getMessage();\r\n        report.setMessage(localStrings.getLocalString(\"delete.threadpool\" + \".failed\", \"Delete Thread Pool failed because of: \", str));\r\n        report.setActionExitCode(ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.commands.DeleteThreadpool.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    List<ThreadPool> poolList = param.getThreadPool();\r\n    for (ThreadPool pool : poolList) {\r\n        String currPoolId = pool.getName();\r\n        if (currPoolId != null && currPoolId.equals(threadpool_id)) {\r\n            poolList.remove(pool);\r\n            break;\r\n        }\r\n    }\r\n    return poolList;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.core.proxy.ProxyFactory.toProxyList",
	"Comment": "resulting list could differ in size if some mbeans are no longerregistered",
	"Method": "List<AMXProxy> toProxyList(Collection<ObjectName> objectNames,List<AMXProxy> toProxyList,ObjectName[] objectNames,Class<? extends AMXProxy> intf){\r\n    final List<AMXProxy> result = new ArrayList<AMXProxy>();\r\n    for (final ObjectName objectName : objectNames) {\r\n        final AMXProxy proxy = getProxy(objectName, intf);\r\n        if (proxy != null) {\r\n            result.add(proxy);\r\n        }\r\n    }\r\n    return (result);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationDispatcher.wrapRequest",
	"Comment": "create and return a request wrapper that has been inserted in theappropriate spot in the request chain.",
	"Method": "ServletRequest wrapRequest(State state){\r\n    ServletRequest previous = null;\r\n    ServletRequest current = state.outerRequest;\r\n    while (current != null) {\r\n        if (state.hrequest == null && (current instanceof HttpServletRequest)) {\r\n            state.hrequest = (HttpServletRequest) current;\r\n        }\r\n        if (\"org.apache.catalina.servlets.InvokerHttpRequest\".equals(current.getClass().getName())) {\r\n            break;\r\n        }\r\n        if (!(current instanceof ServletRequestWrapper)) {\r\n            break;\r\n        }\r\n        if (current instanceof ApplicationHttpRequest) {\r\n            break;\r\n        }\r\n        if (current instanceof ApplicationRequest) {\r\n            break;\r\n        }\r\n        previous = current;\r\n        current = ((ServletRequestWrapper) current).getRequest();\r\n    }\r\n    ServletRequest wrapper = null;\r\n    if ((current instanceof ApplicationHttpRequest) || (current instanceof Request) || (current instanceof HttpServletRequest)) {\r\n        HttpServletRequest hcurrent = (HttpServletRequest) current;\r\n        boolean crossContext = false;\r\n        if ((state.outerRequest instanceof ApplicationHttpRequest) || (state.outerRequest instanceof Request) || (state.outerRequest instanceof HttpServletRequest)) {\r\n            HttpServletRequest houterRequest = (HttpServletRequest) state.outerRequest;\r\n            Object contextPath = houterRequest.getAttribute(RequestDispatcher.INCLUDE_CONTEXT_PATH);\r\n            if (contextPath == null) {\r\n                contextPath = houterRequest.getContextPath();\r\n            }\r\n            crossContext = !(context.getPath().equals(contextPath));\r\n        }\r\n        crossContextFlag = Boolean.valueOf(crossContext);\r\n        if (this.name != null) {\r\n            this.mappingForDispatch = computeNamedDispatchHttpServletMapping(context, hcurrent);\r\n        }\r\n        if (DispatcherType.ASYNC.equals(state.dispatcherType)) {\r\n            this.mappingForDispatch = hcurrent.getHttpServletMapping();\r\n        }\r\n        wrapper = new ApplicationHttpRequest(hcurrent, context, crossContext, mappingForDispatch, state.dispatcherType);\r\n    } else {\r\n        wrapper = new ApplicationRequest(current);\r\n    }\r\n    if (previous == null) {\r\n        state.outerRequest = wrapper;\r\n    } else {\r\n        ((ServletRequestWrapper) previous).setRequest(wrapper);\r\n    }\r\n    state.wrapRequest = wrapper;\r\n    return wrapper;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.domain.DomainBuilder.run",
	"Comment": "performs all the domain configurations which includes security, configuration processing,substitution of parameters... etc.",
	"Method": "void run(){\r\n    File domainDir = FileUtils.safeGetCanonicalFile(new File(_domainConfig.getRepositoryRoot(), _domainConfig.getDomainName()));\r\n    createDirectory(domainDir);\r\n    try {\r\n        byte[] buffer = new byte[10000];\r\n        for (Enumeration<JarEntry> entry = _templateJar.entries(); entry.hasMoreElements(); ) {\r\n            JarEntry jarEntry = (JarEntry) entry.nextElement();\r\n            String entryName = jarEntry.getName();\r\n            if (entryName.startsWith(META_DIR_NAME)) {\r\n                continue;\r\n            }\r\n            if (_extractedEntries.contains(entryName)) {\r\n                continue;\r\n            }\r\n            if (jarEntry.isDirectory()) {\r\n                File dir = new File(domainDir, jarEntry.getName());\r\n                if (!dir.exists()) {\r\n                    if (!dir.mkdir()) {\r\n                        _logger.log(Level.WARNING, SLogger.DIR_CREATION_ERROR, dir.getName());\r\n                    }\r\n                }\r\n                continue;\r\n            }\r\n            InputStream in = null;\r\n            BufferedOutputStream outputStream = null;\r\n            try {\r\n                in = _templateJar.getInputStream(jarEntry);\r\n                outputStream = new BufferedOutputStream(new FileOutputStream(new File(domainDir.getAbsolutePath(), jarEntry.getName())));\r\n                int i = 0;\r\n                while ((i = in.read(buffer)) != -1) {\r\n                    outputStream.write(buffer, 0, i);\r\n                }\r\n            } finally {\r\n                if (in != null) {\r\n                    try {\r\n                        in.close();\r\n                    } catch (Exception io) {\r\n                    }\r\n                }\r\n                if (outputStream != null) {\r\n                    try {\r\n                        outputStream.close();\r\n                    } catch (Exception io) {\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        File configDir = new File(domainDir, DomainConstants.CONFIG_DIR);\r\n        String user = (String) _domainConfig.get(DomainConfig.K_USER);\r\n        String password = (String) _domainConfig.get(DomainConfig.K_PASSWORD);\r\n        String[] adminUserGroups = ((String) _domainConfig.get(DomainConfig.K_INITIAL_ADMIN_USER_GROUPS)).split(\",\");\r\n        String masterPassword = (String) _domainConfig.get(DomainConfig.K_MASTER_PASSWORD);\r\n        Boolean saveMasterPassword = (Boolean) _domainConfig.get(DomainConfig.K_SAVE_MASTER_PASSWORD);\r\n        DomainSecurity domainSecurity = new DomainSecurity();\r\n        domainSecurity.processAdminKeyFile(new File(configDir, DomainConstants.ADMIN_KEY_FILE), user, password, adminUserGroups);\r\n        try {\r\n            domainSecurity.createSSLCertificateDatabase(configDir, _domainConfig, masterPassword);\r\n        } catch (Exception e) {\r\n            String msg = _strings.getString(\"SomeProblemWithKeytool\", e.getMessage());\r\n            System.err.println(msg);\r\n            FileOutputStream fos = null;\r\n            try {\r\n                File keystoreFile = new File(configDir, DomainConstants.KEYSTORE_FILE);\r\n                fos = new FileOutputStream(keystoreFile);\r\n                fos.write(_keystoreBytes);\r\n            } catch (Exception ex) {\r\n                getLogger().log(Level.SEVERE, UNHANDLED_EXCEPTION, ex);\r\n            } finally {\r\n                if (fos != null)\r\n                    fos.close();\r\n            }\r\n        }\r\n        domainSecurity.changeMasterPasswordInMasterPasswordFile(new File(domainDir, DomainConstants.MASTERPASSWORD_FILE), masterPassword, saveMasterPassword);\r\n        domainSecurity.createPasswordAliasKeystore(new File(configDir, DomainConstants.DOMAIN_PASSWORD_FILE), masterPassword);\r\n        CustomTokenClient tokenClient = new CustomTokenClient(_domainConfig);\r\n        Map<String, String> generatedTokens = tokenClient.getSubstitutableTokens();\r\n        if (_domainTempalte.hasStringsubs()) {\r\n            StringSubstitutor substitutor = _domainTempalte.getStringSubs();\r\n            Map<String, String> lookUpMap = SubstitutableTokens.getSubstitutableTokens(_domainConfig);\r\n            lookUpMap.putAll(generatedTokens);\r\n            substitutor.setAttributePreprocessor(new AttributePreprocessorImpl(lookUpMap));\r\n            substitutor.substituteAll();\r\n        }\r\n        try {\r\n            File binDir = new File(domainDir, DomainConstants.BIN_DIR);\r\n            if (binDir.exists() && binDir.isDirectory()) {\r\n                domainSecurity.changeMode(\"-R u+x \", binDir);\r\n            }\r\n            domainSecurity.changeMode(\"-R g-rwx,o-rwx \", configDir);\r\n        } catch (Exception e) {\r\n            throw new DomainException(_strings.get(\"setPermissionError\"), e);\r\n        }\r\n        DomainInfoManager domainInfoManager = new DomainInfoManager();\r\n        domainInfoManager.process(_domainTempalte, domainDir);\r\n    } catch (DomainException de) {\r\n        FileUtils.liquidate(domainDir);\r\n        throw de;\r\n    } catch (Exception ex) {\r\n        FileUtils.liquidate(domainDir);\r\n        throw new DomainException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.addMimeMapping",
	"Comment": "add a new mime mapping, replacing any existing mapping forthe specified extension.",
	"Method": "void addMimeMapping(String extension,String mimeType){\r\n    mimeMappings.put(extension.toLowerCase(Locale.ENGLISH), mimeType);\r\n    if (notifyContainerListeners) {\r\n        fireContainerEvent(\"addMimeMapping\", extension);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentTransaction.numActive",
	"Comment": "returns the number of thread associations currently active for the giventransaction identifier.a boolean value indicating whether there are outstanding requests is returnedas an output parameter.",
	"Method": "int numActive(Long localTID,boolean[] outstanding){\r\n    if (!statsOn) {\r\n        throw new NO_IMPLEMENT(\"statistics not on\");\r\n    }\r\n    int result = 0;\r\n    outstanding[0] = false;\r\n    StatusHolder outStatus = new StatusHolder();\r\n    Enumeration controls = threadContexts.elements();\r\n    while (controls.hasMoreElements()) {\r\n        ControlImpl current = (ControlImpl) controls.nextElement();\r\n        outStatus.value = Status.StatusRolledBack;\r\n        try {\r\n            Long currentLocalTID = current.getLocalTID(outStatus);\r\n            if (outStatus.value == Status.StatusActive)\r\n                if (currentLocalTID.equals(localTID)) {\r\n                    outstanding[0] |= current.isOutgoing();\r\n                    result++;\r\n                }\r\n        } catch (Throwable exc) {\r\n            _logger.log(Level.FINE, \"\", exc);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.getParent",
	"Comment": "gets the parent coordinator of the transaction.as this is a top levelcoordinator, a parent does not exist so null is returned.",
	"Method": "Coordinator getParent(){\r\n    Coordinator result = null;\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.web.WebVerifier.getJspOutDir",
	"Comment": "if precompilejsp is set in the backend then return the jspoutput directory set in the frameworkcontext. otherwise create a new unique directory and return it.",
	"Method": "File getJspOutDir(){\r\n    File jspOutDir = verifierFrameworkContext.getJspOutDir();\r\n    if (jspOutDir != null) {\r\n        ModuleDescriptor moduleDescriptor = webd.getModuleDescriptor();\r\n        if (moduleDescriptor.isStandalone())\r\n            return jspOutDir;\r\n        return new File(jspOutDir, FileUtils.makeFriendlyFilename(moduleDescriptor.getArchiveUri()));\r\n    }\r\n    SecureRandom random = new SecureRandom();\r\n    String prefix = System.getProperty(\"java.io.tmpdir\") + File.separator + \".jspc\";\r\n    do {\r\n        float f = random.nextFloat();\r\n        String outDirPath = new String(prefix + f);\r\n        File out = new File(outDirPath);\r\n        if (out.mkdirs())\r\n            return out;\r\n    } while (true);\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.AuthenticatorBase.isSecurePagesWithPragma",
	"Comment": "return the flag that states, if proxy caching is disabled, what headerswe add to disable the caching.",
	"Method": "boolean isSecurePagesWithPragma(){\r\n    return securePagesWithPragma;\r\n}"
}, {
	"Path": "com.sun.appserv.util.cache.mbeans.JmxBaseCache.getName",
	"Comment": "returns a unique identifier for this mbean inside the domain",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "org.apache.catalina.util.ParameterMap.put",
	"Comment": "associate the specified value with the specified key in this map.ifthe map previously contained a mapping for this key, the old value isreplaced.",
	"Method": "V put(K key,V value){\r\n    if (locked)\r\n        throw new IllegalStateException(rb.getString(LogFacade.MAP_IS_LOCKED_EXCEPTION));\r\n    return (super.put(key, value));\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.server.DomainXmlPersistence.touch",
	"Comment": "update the modified time of the persisted domain.xml so that instances will detect it as changed.this is for triggering instance synchronization to occur.",
	"Method": "void touch(){\r\n    getDestination().setLastModified(System.currentTimeMillis());\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.getProxyHandler",
	"Comment": "gets the proxyhandler instance associated with this coyoteconnector.",
	"Method": "ProxyHandler getProxyHandler(){\r\n    return proxyHandler;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.ServerConfigLookup.getPersistenceFrequencyFromConfig",
	"Comment": "get the persistencefrequency from domain.xml.return null if not found",
	"Method": "String getPersistenceFrequencyFromConfig(){\r\n    WebContainerAvailability webContainerAvailabilityBean = getWebContainerAvailability();\r\n    if (webContainerAvailabilityBean == null) {\r\n        return null;\r\n    }\r\n    return webContainerAvailabilityBean.getPersistenceFrequency();\r\n}"
}, {
	"Path": "com.sun.enterprise.deploy.shared.FileArchive.exists",
	"Comment": "returns the existence of the given entry namethe file name must be relative to the root of the module.",
	"Method": "boolean exists(boolean exists,String name){\r\n    name = name.replace('/', File.separatorChar);\r\n    File input = new File(archive, name);\r\n    return input.exists() && isEntryValid(input);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.DefaultConnectionManagerExistence.check",
	"Comment": "all connector tests should implement this method. it run an individualtest against the resource adapter deployment descriptor.",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!descriptor.getOutBoundDefined()) {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.managed.notApplicableForInboundRA\", \"Resource Adapter does not provide outbound communication\"));\r\n        return result;\r\n    }\r\n    findImplementorOf(descriptor, \"javax.resource.spi.ConnectionManager\", result);\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.recycle",
	"Comment": "release all object references, and initialize instance variables, inpreparation for reuse of this object.",
	"Method": "void recycle(){\r\n    if (isAsyncStarted()) {\r\n        return;\r\n    }\r\n    context = null;\r\n    servletContext = null;\r\n    contextPath = null;\r\n    servletPath = null;\r\n    pathInfo = null;\r\n    wrapper = null;\r\n    dispatcherTypeAttr = null;\r\n    requestDispatcherPath = null;\r\n    authType = null;\r\n    requestURI = null;\r\n    inputBuffer.recycle();\r\n    usingInputStream = false;\r\n    usingReader = false;\r\n    userPrincipal = null;\r\n    subject = null;\r\n    sessionParsed = false;\r\n    parametersProcessed = false;\r\n    cookiesParsed = false;\r\n    locales.clear();\r\n    localesParsed = false;\r\n    secure = false;\r\n    remoteAddr = null;\r\n    remoteHost = null;\r\n    remotePort = -1;\r\n    localPort = -1;\r\n    localAddr = null;\r\n    localName = null;\r\n    multipart = null;\r\n    jrouteId = null;\r\n    upgrade = false;\r\n    afterService = false;\r\n    resume = false;\r\n    attributes.clear();\r\n    notes.clear();\r\n    cookies.clear();\r\n    unsuccessfulSessionFind = false;\r\n    if (session != null) {\r\n        session.endAccess();\r\n    }\r\n    session = null;\r\n    requestedSessionCookie = false;\r\n    requestedSessionId = null;\r\n    requestedSessionCookiePath = null;\r\n    requestedSessionURL = false;\r\n    uriParamsCC.recycle();\r\n    sessionTracker.reset();\r\n    dispatchDepth = 0;\r\n    parameterMap.setLocked(false);\r\n    parameterMap.clear();\r\n    mappingData.recycle();\r\n    initRequestFacadeHelper = false;\r\n    if (enforceScope) {\r\n        if (facade != null) {\r\n            facade.clear();\r\n            facade = null;\r\n        }\r\n        if (defaultContextMaskingFacade != null) {\r\n            defaultContextMaskingFacade.clear();\r\n            defaultContextMaskingFacade = null;\r\n        }\r\n        if (inputStream != null) {\r\n            inputStream.clear();\r\n            inputStream = null;\r\n        }\r\n        if (reader != null) {\r\n            reader.clear();\r\n            reader = null;\r\n        }\r\n    }\r\n    if (asyncContext != null) {\r\n        asyncContext.clear();\r\n        asyncContext = null;\r\n    }\r\n    isAsyncSupported = true;\r\n    asyncStarted.set(false);\r\n    asyncStartedThread = null;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.getEffectiveSessionTrackingModes",
	"Comment": "gets the session tracking modes that are in effect for thisservletcontext.",
	"Method": "Set<SessionTrackingMode> getEffectiveSessionTrackingModes(){\r\n    if (SecurityUtil.isPackageProtectionEnabled()) {\r\n        return (Set<SessionTrackingMode>) doPrivileged(\"getEffectiveSessionTrackingModes\", null);\r\n    } else {\r\n        return context.getEffectiveSessionTrackingModes();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.setAttribute",
	"Comment": "bind the specified value with the specified context attribute name,replacing any existing value for that name.",
	"Method": "void setAttribute(String name,Object value){\r\n    if (name == null)\r\n        throw new NullPointerException(rb.getString(LogFacade.NULL_NAME_EXCEPTION));\r\n    if (value == null) {\r\n        removeAttribute(name);\r\n        return;\r\n    }\r\n    Object oldValue = null;\r\n    boolean replaced = false;\r\n    synchronized (attributesLock) {\r\n        if (readOnlyAttributes.containsKey(name))\r\n            return;\r\n        oldValue = attributes.get(name);\r\n        if (oldValue != null)\r\n            replaced = true;\r\n        attributes.put(name, value);\r\n    }\r\n    if (name.equals(Globals.CLASS_PATH_ATTR) || name.equals(Globals.JSP_TLD_URI_TO_LOCATION_MAP)) {\r\n        setAttributeReadOnly(name);\r\n    }\r\n    List<EventListener> listeners = context.getApplicationEventListeners();\r\n    if (listeners.isEmpty()) {\r\n        return;\r\n    }\r\n    ServletContextAttributeEvent event = null;\r\n    if (replaced) {\r\n        event = new ServletContextAttributeEvent(context.getServletContext(), name, oldValue);\r\n    } else {\r\n        event = new ServletContextAttributeEvent(context.getServletContext(), name, value);\r\n    }\r\n    Iterator<EventListener> iter = listeners.iterator();\r\n    while (iter.hasNext()) {\r\n        EventListener eventListener = iter.next();\r\n        if (!(eventListener instanceof ServletContextAttributeListener)) {\r\n            continue;\r\n        }\r\n        ServletContextAttributeListener listener = (ServletContextAttributeListener) eventListener;\r\n        try {\r\n            if (replaced) {\r\n                context.fireContainerEvent(ContainerEvent.BEFORE_CONTEXT_ATTRIBUTE_REPLACED, listener);\r\n                listener.attributeReplaced(event);\r\n                context.fireContainerEvent(ContainerEvent.AFTER_CONTEXT_ATTRIBUTE_REPLACED, listener);\r\n            } else {\r\n                context.fireContainerEvent(ContainerEvent.BEFORE_CONTEXT_ATTRIBUTE_ADDED, listener);\r\n                listener.attributeAdded(event);\r\n                context.fireContainerEvent(ContainerEvent.AFTER_CONTEXT_ATTRIBUTE_ADDED, listener);\r\n            }\r\n        } catch (Throwable t) {\r\n            if (replaced) {\r\n                context.fireContainerEvent(ContainerEvent.AFTER_CONTEXT_ATTRIBUTE_REPLACED, listener);\r\n            } else {\r\n                context.fireContainerEvent(ContainerEvent.AFTER_CONTEXT_ATTRIBUTE_ADDED, listener);\r\n            }\r\n            log.log(Level.WARNING, LogFacade.ATTRIBUTES_EVENT_LISTENER_EXCEPTION, t);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.KeystoreManager.changeS1ASAliasPassword",
	"Comment": "changes the key password for the default cert whose alias is s1as. theassumption here is that the keystore password is not the same as the keypassword. this is due to the fact that the keystore password should firstbe changed followed next by the key password. the end result is that thekeystore and s1as key both have the same passwords. this function willtolerate deletion of the s1as alias, but it will not tolerate changingthe s1as key from something other than the database password.",
	"Method": "void changeS1ASAliasPassword(RepositoryConfig config,String storePassword,String oldKeyPassword,String newKeyPassword){\r\n    if (!storePassword.equals(oldKeyPassword) && !oldKeyPassword.equals(newKeyPassword)) {\r\n        final PEFileLayout layout = getFileLayout(config);\r\n        final File keystore = layout.getKeyStore();\r\n        String keyStoreType = System.getProperty(\"javax.net.ssl.keyStoreType\");\r\n        if (keyStoreType == null) {\r\n            keyStoreType = KeyStore.getDefaultType();\r\n        }\r\n        List<String> aliases = new ArrayList<String>();\r\n        FileInputStream is = null;\r\n        try {\r\n            KeyStore keyStore = KeyStore.getInstance(keyStoreType);\r\n            is = new FileInputStream(keystore);\r\n            keyStore.load(is, storePassword.toCharArray());\r\n            Enumeration<String> all = keyStore.aliases();\r\n            while (all.hasMoreElements()) {\r\n                aliases.add(all.nextElement());\r\n            }\r\n        } catch (Exception e) {\r\n            aliases.add(CERTIFICATE_ALIAS);\r\n        } finally {\r\n            if (is != null) {\r\n                try {\r\n                    is.close();\r\n                } catch (IOException ex) {\r\n                    getLogger().log(Level.SEVERE, UNHANDLED_EXCEPTION, ex);\r\n                }\r\n            }\r\n        }\r\n        String[] keytoolCmd = { \"-list\", \"-keystore\", keystore.getAbsolutePath(), \"-alias\", CERTIFICATE_ALIAS };\r\n        KeytoolExecutor p = new KeytoolExecutor(keytoolCmd, 30, new String[] { storePassword });\r\n        try {\r\n            p.execute(\"s1asKeyPasswordNotChanged\", keystore);\r\n        } catch (RepositoryException ex) {\r\n            return;\r\n        }\r\n        for (String alias : aliases) {\r\n            keytoolCmd = new String[] { \"-keypasswd\", \"-keystore\", keystore.getAbsolutePath(), \"-alias\", alias };\r\n            p = new KeytoolExecutor(keytoolCmd, 30, new String[] { storePassword, oldKeyPassword, newKeyPassword, newKeyPassword });\r\n            p.execute(\"s1asKeyPasswordNotChanged\", keystore);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.delegated_reconstruct",
	"Comment": "directs the topcoordinator to recover its state after a failure,based on the given coordinatorlog object for the given logpath.if the topcoordinator has already been defined or recovered, the operation returns immediately. otherwise thetopcoordinator restores the state of its internal objects using theirrecovery operations, which in turn recover their state from thecoordinatorlog object.",
	"Method": "void delegated_reconstruct(CoordinatorLog log,String logPath){\r\n    rollbackOnly = false;\r\n    registered = false;\r\n    registeredSync = false;\r\n    root = false;\r\n    dying = false;\r\n    temporary = false;\r\n    terminator = null;\r\n    logRecord = log;\r\n    name = null;\r\n    nestingInfo = null;\r\n    synchronizations = null;\r\n    delegated = true;\r\n    this.logPath = logPath;\r\n    tranState = new TransactionState();\r\n    int state = tranState.reconstruct(log);\r\n    if (state == TransactionState.STATE_NONE || state == TransactionState.STATE_COMMITTED || state == TransactionState.STATE_ROLLED_BACK) {\r\n        CoordinatorLog.removeLog(log.localTID, logPath);\r\n        destroy();\r\n    } else {\r\n        participants = new RegisteredResources(this);\r\n        participants.reconstruct(log);\r\n        superInfo = new SuperiorInfo();\r\n        superInfo.delegated_reconstruct(log, this, logPath);\r\n        name = superInfo.globalTID.toString();\r\n        hash = superInfo.globalTID.hashCode();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RecoveryManager.initialise",
	"Comment": "initialises the static state of the recoverymanager class.",
	"Method": "void initialise(){\r\n    if (initialised) {\r\n        return;\r\n    }\r\n    initialised = true;\r\n    if (Configuration.isRecoverable()) {\r\n        resyncThread = new ResyncThread();\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.logp(Level.FINE, \"RecoveryManager\", \"initialise()\", \"Before starting ResyncThread \");\r\n        }\r\n    } else {\r\n        if (!Configuration.isAppClientContainer()) {\r\n            String serverName = Configuration.getServerName();\r\n            if (serverName != null && Log.checkFileExists(serverName)) {\r\n                _logger.log(Level.INFO, \"jts.log_file_transient_server\", serverName);\r\n            }\r\n        }\r\n        try {\r\n            recoveryInProgress.post();\r\n            resyncComplete(false, false);\r\n        } catch (Throwable exc) {\r\n            exc.printStackTrace();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.get_parent_status",
	"Comment": "gets the local state of the parent transaction.this operation references no instance variables and so can beimplemented locally in the proxy class.",
	"Method": "Status get_parent_status(){\r\n    Status result = Status.StatusNoTransaction;\r\n    if (tranState != null) {\r\n        CoordinatorImpl parent = nestingInfo.getParent(false);\r\n        if (parent != null) {\r\n            result = parent.get_status();\r\n        }\r\n    } else {\r\n        INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.Completed, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.isMaxDispatchDepthReached",
	"Comment": "check if the application dispatching has reached the maximum",
	"Method": "boolean isMaxDispatchDepthReached(){\r\n    return dispatchDepth > maxDispatchDepth;\r\n}"
}, {
	"Path": "com.sun.enterprise.util.io.FileUtils.mkdirsMaybe",
	"Comment": "wrapper for file.mkdirsthis version will return true if the directory exists when the method returns.unlike file.mkdirs which returns false if the directory already exists.",
	"Method": "boolean mkdirsMaybe(File f){\r\n    return f != null && (f.isDirectory() || f.mkdirs());\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.SynchronizeInstanceCommand.getModTimes",
	"Comment": "return a syncrequest with the mod times for all thefiles in the specified directory.",
	"Method": "SyncRequest getModTimes(String dir,SyncLevel level){\r\n    SyncRequest sr = new SyncRequest();\r\n    sr.instance = instanceName;\r\n    sr.dir = dir;\r\n    File fdir = new File(instanceDir, dir);\r\n    if (!fdir.exists())\r\n        return sr;\r\n    getFileModTimes(fdir, fdir, sr, level);\r\n    return sr;\r\n}"
}, {
	"Path": "org.apache.catalina.util.ManifestResource.containsExtension",
	"Comment": "convenience method to check if this manifestresourcehas an extension available.",
	"Method": "boolean containsExtension(String key){\r\n    return (availableExtensions != null) ? availableExtensions.containsKey(key) : false;\r\n}"
}, {
	"Path": "components.renderkit.MenuBarRenderer.href",
	"Comment": "returns a string that is rendered as the value ofhref attribute after prepending the contextpath if necessary.",
	"Method": "String href(String action){\r\n    if (action != null && !(action.startsWith(\"/\"))) {\r\n        return action;\r\n    }\r\n    StringBuffer sb = new StringBuffer();\r\n    if (action.startsWith(\"/\")) {\r\n        sb.append(context.getExternalContext().getRequestContextPath());\r\n    }\r\n    sb.append(action);\r\n    return (sb.toString());\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.SimpleDeployer.clean",
	"Comment": "clean any files and artifacts that were created during the executionof the prepare method.",
	"Method": "void clean(DeploymentContext context){\r\n    try {\r\n        if (context.getCommandParameters(OpsParams.class).origin.needsCleanArtifacts()) {\r\n            cleanArtifacts(context);\r\n        }\r\n    } catch (Exception ex) {\r\n        RuntimeException re = new RuntimeException(ex.getMessage());\r\n        re.initCause(ex);\r\n        throw re;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.AdminUtil.getAllTIDs",
	"Comment": "returned enumeration of globaltids of existing transactions.",
	"Method": "Enumeration getAllTIDs(){\r\n    return RecoveryManager.getCoordsByGlobalTID().keys();\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.CLIUtil.displayClosestMatch",
	"Comment": "display the commands from the list that are the closest matchto the specified command.",
	"Method": "void displayClosestMatch(String commandName,String[] commands,String msg,Logger logger){\r\n    try {\r\n        int beginIndex = 0;\r\n        int endIndex = commandName.length();\r\n        if (commandName.startsWith(\"*\"))\r\n            beginIndex = 1;\r\n        if (commandName.endsWith(\"*\"))\r\n            endIndex = commandName.length() - 1;\r\n        final String trimmedCommandName = commandName.substring(beginIndex, endIndex);\r\n        if (!trimmedCommandName.startsWith(\"_\")) {\r\n            List<String> ncl = new ArrayList<String>();\r\n            for (String cmd : Arrays.asList(commands)) if (!cmd.startsWith(\"_\"))\r\n                ncl.add(cmd);\r\n            commands = ncl.toArray(new String[ncl.size()]);\r\n        }\r\n        Arrays.sort(commands);\r\n        final String[] matchedCommands = getMatchedCommands(trimmedCommandName, commands);\r\n        StringWriter sw = new StringWriter();\r\n        PrintWriter pw = new PrintWriter(sw);\r\n        if (matchedCommands.length > 0 && matchedCommands.length < MAX_COMMANDS_TO_DISPLAY) {\r\n            pw.println(msg != null ? msg : strings.get(\"ClosestMatchedCommands\"));\r\n            for (String eachCommand : matchedCommands) pw.println(\"    \" + eachCommand);\r\n        } else {\r\n            final String nearestString = StringEditDistance.findNearest(trimmedCommandName, commands);\r\n            if (StringEditDistance.editDistance(trimmedCommandName, nearestString) < 5) {\r\n                pw.println(msg != null ? msg : strings.get(\"ClosestMatchedCommands\"));\r\n                pw.println(\"    \" + nearestString);\r\n            } else\r\n                throw new InvalidCommandException(commandName);\r\n        }\r\n        pw.flush();\r\n        logger.severe(sw.toString());\r\n    } catch (Exception e) {\r\n        throw new InvalidCommandException(commandName);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.MethodUtils.methodEquals",
	"Comment": "returns true if method names, return types and parameters match. otherwiseit returns false.",
	"Method": "boolean methodEquals(Method classMethod,Method intfMethod){\r\n    return classMethod.getName().equals(intfMethod.getName()) && intfMethod.getReturnType().isAssignableFrom(classMethod.getReturnType()) && Arrays.equals(classMethod.getParameterTypes(), intfMethod.getParameterTypes());\r\n}"
}, {
	"Path": "org.apache.naming.resources.ResourceCache.insertCache",
	"Comment": "insert into the right place in a sorted mapelement array, and preventduplicates.",
	"Method": "boolean insertCache(CacheEntry newElement){\r\n    CacheEntry[] oldCache = cache;\r\n    int pos = find(oldCache, newElement.name);\r\n    if ((pos != -1) && (newElement.name.equals(oldCache[pos].name))) {\r\n        return false;\r\n    }\r\n    CacheEntry[] newCache = new CacheEntry[cache.length + 1];\r\n    System.arraycopy(oldCache, 0, newCache, 0, pos + 1);\r\n    newCache[pos + 1] = newElement;\r\n    System.arraycopy(oldCache, pos + 1, newCache, pos + 2, oldCache.length - pos - 1);\r\n    cache = newCache;\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.catalina.valves.AccessLogValve.setCondition",
	"Comment": "set the servletrequest.attribute to look for to performconditional logging. set to null to log everything.",
	"Method": "void setCondition(String condition){\r\n    this.condition = condition;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentTransaction.getCurrent",
	"Comment": "returns the current control object.that is, the control object that corresponds to the threadunder which the operation was invoked. if there is no such association thenull value is returned.",
	"Method": "ControlImpl getCurrent(){\r\n    ControlImpl result = (ControlImpl) m_tid.get();\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServerPipeline.addRedirect",
	"Comment": "adds the given redirect instruction to this virtualserverpipeline.",
	"Method": "void addRedirect(String from,String url,String urlPrefix,boolean escape){\r\n    if (redirects == null) {\r\n        redirects = new ArrayList<RedirectParameters>();\r\n    }\r\n    redirects.add(new RedirectParameters(from, url, urlPrefix, escape));\r\n}"
}, {
	"Path": "org.apache.catalina.loader.WebappLoader.modified",
	"Comment": "has the internal repository associated with this loader been modified,such that the loaded classes should be reloaded?",
	"Method": "boolean modified(){\r\n    return (classLoader.modified());\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.addTransformer",
	"Comment": "add a new classfiletransformer to this class loader. this transfomer should be called for each class loading event.",
	"Method": "void addTransformer(ClassFileTransformer transformer){\r\n    final WebappClassLoader cl = this;\r\n    addByteCodePreprocessor(new BytecodePreprocessor() {\r\n        public boolean initialize(Hashtable parameters) {\r\n            return true;\r\n        }\r\n        public byte[] preprocess(String resourceName, byte[] classBytes) {\r\n            try {\r\n                String classname = // \".class\" size = 6\r\n                resourceName.substring(0, resourceName.length() - 6);\r\n                byte[] newBytes = transformer.transform(cl, classname, null, null, classBytes);\r\n                return newBytes == null ? classBytes : newBytes;\r\n            } catch (IllegalClassFormatException e) {\r\n                logger.logp(Level.WARNING, \"WebModuleListener$InstrumentableClassLoader$BytecodePreprocessor\", \"preprocess\", e.getMessage());\r\n                throw new RuntimeException(e);\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.addTransformer",
	"Comment": "add a new classfiletransformer to this class loader. this transfomer should be called for each class loading event.",
	"Method": "void addTransformer(ClassFileTransformer transformer){\r\n    return true;\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.addTransformer",
	"Comment": "add a new classfiletransformer to this class loader. this transfomer should be called for each class loading event.",
	"Method": "void addTransformer(ClassFileTransformer transformer){\r\n    try {\r\n        String classname = // \".class\" size = 6\r\n        resourceName.substring(0, resourceName.length() - 6);\r\n        byte[] newBytes = transformer.transform(cl, classname, null, null, classBytes);\r\n        return newBytes == null ? classBytes : newBytes;\r\n    } catch (IllegalClassFormatException e) {\r\n        logger.logp(Level.WARNING, \"WebModuleListener$InstrumentableClassLoader$BytecodePreprocessor\", \"preprocess\", e.getMessage());\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.ModuleDescriptor.setAlternateDescriptor",
	"Comment": "sets the path to the alternate deployment descriptorsin the application archive",
	"Method": "void setAlternateDescriptor(String altDD){\r\n    this.altDD = altDD;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebComponentDescriptorImpl.removeSecurityRoleReference",
	"Comment": "removes the given security role reference from this web component.",
	"Method": "void removeSecurityRoleReference(SecurityRoleReference securityRoleReference){\r\n    getSecurityRoleReferenceSet().remove(securityRoleReference);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.remote.RemoteCommand.getUsage",
	"Comment": "get the usage text.if we got usage information from the server, use it.",
	"Method": "String getUsage(){\r\n    if (usage == null) {\r\n        if (rac == null) {\r\n            return getCommandUsage();\r\n        }\r\n        usage = rac.getUsage();\r\n    }\r\n    if (usage == null)\r\n        return super.getUsage();\r\n    StringBuilder usageText = new StringBuilder();\r\n    usageText.append(strings.get(\"Usage\", getBriefCommandUsage()));\r\n    usageText.append(\" \");\r\n    usageText.append(usage);\r\n    return usageText.toString();\r\n}"
}, {
	"Path": "com.sun.enterprise.web.connector.coyote.PECoyoteConnector.setSecondsMaxAge",
	"Comment": "the timeout in seconds before remove a filecacheentryfrom the filecache",
	"Method": "void setSecondsMaxAge(int sMaxAges){\r\n    secondsMaxAge = sMaxAges;\r\n    setProperty(\"secondsMaxAge\", String.valueOf(secondsMaxAge));\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.SingleSignOn.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (info);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.GlobalTID.write",
	"Comment": "writes the contents of the global identifier to the given stream.",
	"Method": "void write(DataOutputStream dataOut){\r\n    try {\r\n        dataOut.writeInt(realTID.formatID);\r\n        dataOut.writeInt(realTID.bqual_length);\r\n        dataOut.writeShort(realTID.tid.length);\r\n        dataOut.write(realTID.tid, 0, realTID.tid.length);\r\n    } catch (Throwable exc) {\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.weld.connector.WeldUtils.isValidBdaBasedOnExtensionAndBeansXml",
	"Comment": "determine if an archive is a valid bda based on what the spec says about extensions.see section 12.1 which states that if an archive contains an extension but no beans.xml then it is nota valid bean deployment archive.",
	"Method": "boolean isValidBdaBasedOnExtensionAndBeansXml(ReadableArchive archive){\r\n    boolean retVal = true;\r\n    try {\r\n        if (archive.exists(META_INF_SERVICES_EXTENSION)) {\r\n            retVal = false;\r\n            InputStream inputStream = getBeansXmlInputStream(archive);\r\n            if (inputStream != null) {\r\n                retVal = true;\r\n                try {\r\n                    inputStream.close();\r\n                } catch (IOException ignore) {\r\n                }\r\n            }\r\n        }\r\n    } catch (IOException ignore) {\r\n    }\r\n    return retVal;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.web.GlassFishSingleSignOn.threadSleep",
	"Comment": "sleep for the duration specified by the ssoreapintervalproperty.",
	"Method": "void threadSleep(){\r\n    try {\r\n        Thread.sleep(ssoReapInterval * 1000L);\r\n    } catch (InterruptedException e) {\r\n        ;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.startup.ContextConfig.createContextDigester",
	"Comment": "create and return a digester configured to process thecontext configuration descriptor for an application.",
	"Method": "Digester createContextDigester(){\r\n    Digester digester = new Digester();\r\n    digester.setValidating(false);\r\n    RuleSet contextRuleSet = new ContextRuleSet(\"\", false);\r\n    digester.addRuleSet(contextRuleSet);\r\n    RuleSet namingRuleSet = new NamingRuleSet(\"Context/\");\r\n    digester.addRuleSet(namingRuleSet);\r\n    digester.getParser();\r\n    return digester;\r\n}"
}, {
	"Path": "org.glassfish.cdi.hk2.HK2IntegrationExtension.afterDeploymentValidation",
	"Comment": "called by cdi after it has been completely validated.will add the jit resolver to hk2with the beanmanager",
	"Method": "void afterDeploymentValidation(AfterDeploymentValidation event){\r\n    if (locator == null)\r\n        return;\r\n    DynamicConfigurationService dcs = locator.getService(DynamicConfigurationService.class);\r\n    DynamicConfiguration config = dcs.createDynamicConfiguration();\r\n    config.addActiveDescriptor(CDISecondChanceResolver.class);\r\n    config.addActiveDescriptor(CDIContextBridge.class);\r\n    config.commit();\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.ListHttpListeners.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the parameter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    final ActionReport report = context.getActionReport();\r\n    List<NetworkListener> list = config.getNetworkConfig().getNetworkListeners().getNetworkListener();\r\n    int size = 0;\r\n    for (NetworkListener networkListener : list) {\r\n        size = Math.max(size, networkListener.getName().length());\r\n    }\r\n    final String format = \"%-\" + (size + 2) + \"s %-6s\";\r\n    if (verbose) {\r\n        report.getTopMessagePart().addChild().setMessage(String.format(format, \"NAME\", \"PORT\"));\r\n    }\r\n    for (NetworkListener listener : list) {\r\n        if (listener.findHttpProtocol().getHttp() != null) {\r\n            report.getTopMessagePart().addChild().setMessage(String.format(format, listener.getName(), verbose ? listener.getPort() : \"\"));\r\n        }\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.DefaultAccessLogFormatterImpl.appendHeaderAccept",
	"Comment": "appends the accept header of the given request to the given charbuffer.",
	"Method": "void appendHeaderAccept(CharBuffer cb,HttpServletRequest hreq){\r\n    cb.put(QUOTE);\r\n    String accept = hreq.getHeader(HTTP_HEADER_ACCEPT);\r\n    if (accept == null) {\r\n        accept = \"NULL-HEADER-ACCEPT\";\r\n    }\r\n    cb.put(accept);\r\n    cb.put(QUOTE);\r\n}"
}, {
	"Path": "com.sun.s1peqe.ejb.bmp.enroller.ejb.EnrollerBean.getCourseIds",
	"Comment": "return an arraylist of courseids that student is enroller in",
	"Method": "ArrayList getCourseIds(String studentId){\r\n    try {\r\n        return selectCourse(studentId);\r\n    } catch (Exception ex) {\r\n        throw new EJBException(\"getCourseIds: \" + ex.getMessage());\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.resources.ResourceCache.find",
	"Comment": "find a map elemnt given its name in a sorted array of map elements.this will return the index for the closest inferior or equal item in thegiven array.",
	"Method": "int find(CacheEntry[] map,String name){\r\n    int a = 0;\r\n    int b = map.length - 1;\r\n    if (b == -1) {\r\n        return -1;\r\n    }\r\n    if (name.compareTo(map[0].name) < 0) {\r\n        return -1;\r\n    }\r\n    if (b == 0) {\r\n        return 0;\r\n    }\r\n    int i = 0;\r\n    while (true) {\r\n        i = (b + a) >>> 1;\r\n        int result = name.compareTo(map[i].name);\r\n        if (result > 0) {\r\n            a = i;\r\n        } else if (result == 0) {\r\n            return i;\r\n        } else {\r\n            b = i;\r\n        }\r\n        if ((b - a) == 1) {\r\n            int result2 = name.compareTo(map[b].name);\r\n            if (result2 < 0) {\r\n                return a;\r\n            } else {\r\n                return b;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.ResultManager.addToResult",
	"Comment": "add the result object to specific vector based on the status.",
	"Method": "void addToResult(Result r){\r\n    if (r.getStatus() == Result.FAILED) {\r\n        failedResults.add(r);\r\n    } else if (r.getStatus() == Result.PASSED) {\r\n        okayResults.add(r);\r\n    } else if (r.getStatus() == Result.WARNING) {\r\n        warningResults.add(r);\r\n    } else if ((r.getStatus() == Result.NOT_APPLICABLE) || (r.getStatus() == Result.NOT_RUN) || (r.getStatus() == Result.NOT_IMPLEMENTED)) {\r\n        naResults.add(r);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.servlets.WebdavServlet.sendReport",
	"Comment": "send a multistatus element containing a complete error report to theclient.",
	"Method": "void sendReport(HttpServletRequest req,HttpServletResponse resp,Hashtable<String, Integer> errorList){\r\n    resp.setStatus(WebdavStatus.SC_MULTI_STATUS);\r\n    String absoluteUri = req.getRequestURI();\r\n    String relativePath = getRelativePath(req);\r\n    XMLWriter generatedXML = new XMLWriter();\r\n    generatedXML.writeXMLHeader();\r\n    generatedXML.writeElement(null, \"multistatus\" + generateNamespaceDeclarations(), XMLWriter.OPENING);\r\n    Enumeration<String> pathList = errorList.keys();\r\n    while (pathList.hasMoreElements()) {\r\n        String errorPath = pathList.nextElement();\r\n        int errorCode = errorList.get(errorPath).intValue();\r\n        generatedXML.writeElement(null, \"response\", XMLWriter.OPENING);\r\n        generatedXML.writeElement(null, \"href\", XMLWriter.OPENING);\r\n        String toAppend = errorPath.substring(relativePath.length());\r\n        if (!toAppend.startsWith(\"/\"))\r\n            toAppend = \"/\" + toAppend;\r\n        generatedXML.writeText(absoluteUri + toAppend);\r\n        generatedXML.writeElement(null, \"href\", XMLWriter.CLOSING);\r\n        generatedXML.writeElement(null, \"status\", XMLWriter.OPENING);\r\n        generatedXML.writeText(\"HTTP/1.1 \" + errorCode + \" \" + WebdavStatus.getStatusText(errorCode));\r\n        generatedXML.writeElement(null, \"status\", XMLWriter.CLOSING);\r\n        generatedXML.writeElement(null, \"response\", XMLWriter.CLOSING);\r\n    }\r\n    generatedXML.writeElement(null, \"multistatus\", XMLWriter.CLOSING);\r\n    Writer writer = resp.getWriter();\r\n    writer.write(generatedXML.toString());\r\n    writer.close();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TimeoutManager.setTimeout",
	"Comment": "sets the timeout for the transaction to the specified type and time inseconds.if the type is none, the timeout for the transaction iscancelled, otherwise the current timeout for the transaction is modifiedto be of the new type and duration.",
	"Method": "boolean setTimeout(Long localTID,int timeoutType,int seconds){\r\n    boolean result = true;\r\n    if (timeoutActive) {\r\n        TimeoutInfo timeoutInfo = null;\r\n        switch(timeoutType) {\r\n            case TimeoutManager.ACTIVE_TIMEOUT:\r\n                if (!isSetTimeout) {\r\n                    initSetTimeout();\r\n                }\r\n                timeoutInfo = new TimeoutInfo();\r\n                timeoutInfo.expireTime = new Date().getTime() + seconds * 1000L;\r\n                timeoutInfo.localTID = localTID;\r\n                timeoutInfo.timeoutType = timeoutType;\r\n                pendingTimeouts.put(localTID, timeoutInfo);\r\n                break;\r\n            case TimeoutManager.IN_DOUBT_TIMEOUT:\r\n                if (!isSetTimeout) {\r\n                    initSetTimeout();\r\n                }\r\n                timeoutInfo = new TimeoutInfo();\r\n                timeoutInfo.expireTime = new Date().getTime() + seconds * 1000L;\r\n                timeoutInfo.localTID = localTID;\r\n                timeoutInfo.timeoutType = timeoutType;\r\n                indoubtTimeouts.put(localTID, timeoutInfo);\r\n                break;\r\n            default:\r\n                if (!isSetTimeout)\r\n                    break;\r\n                result = (pendingTimeouts.remove(localTID) != null);\r\n                if (!result)\r\n                    result = (indoubtTimeouts.remove(localTID) != null);\r\n                if (quiescing && pendingTimeouts.isEmpty() && indoubtTimeouts.isEmpty()) {\r\n                    timeoutThread.stop();\r\n                    timeoutActive = false;\r\n                }\r\n                break;\r\n        }\r\n    } else {\r\n        result = false;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.BasicAuthenticator.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (this.info);\r\n}"
}, {
	"Path": "org.apache.catalina.startup.Embedded.createLoader",
	"Comment": "create and return a class loader manager that can be customized, andthen attached to a context, before it is started.",
	"Method": "Loader createLoader(ClassLoader parent){\r\n    if (log.isLoggable(Level.FINEST))\r\n        log.log(Level.FINEST, \"Creating Loader with parent class loader '\" + parent + \"'\");\r\n    WebappLoader loader = new WebappLoader(parent);\r\n    return (loader);\r\n}"
}, {
	"Path": "org.apache.catalina.session.FileStore.remove",
	"Comment": "remove the session with the specified session identifier fromthis store, if present.if no such session is present, this methodtakes no action.",
	"Method": "void remove(String id){\r\n    File file = file(id);\r\n    if (file == null) {\r\n        return;\r\n    }\r\n    if (debug >= 1) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.REMOVING_SESSION_FROM_FILE), new Object[] { id, file.getAbsolutePath() });\r\n        log(msg);\r\n    }\r\n    sessions.remove(id);\r\n    if (!file.delete() && log.isLoggable(Level.FINE)) {\r\n        log.log(Level.FINE, \"Cannot delete file: \" + file);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.core.proxy.ProxyFactory.getInstance",
	"Comment": "get an instance of the proxyfactory for the mbeanserver. generally notapplicable for remote clients.",
	"Method": "ProxyFactory getInstance(MBeanServer server,ProxyFactory getInstance,MBeanServerConnection conn,ProxyFactory getInstance,MBeanServerConnection conn,boolean useMBeanServerID){\r\n    ProxyFactory instance = findInstance(conn);\r\n    if (instance == null) {\r\n        try {\r\n            if (useMBeanServerID) {\r\n                final String id = JMXUtil.getMBeanServerID(conn);\r\n                instance = findInstanceByID(id);\r\n            }\r\n            if (instance == null) {\r\n                instance = new ProxyFactory(conn);\r\n                INSTANCES.put(conn, instance);\r\n            }\r\n        } catch (Exception e) {\r\n            warning(\"ProxyFactory.getInstance: failure creating ProxyFactory: \", e);\r\n            throw new RuntimeException(e);\r\n        }\r\n    }\r\n    return (instance);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.services.SMFService.getManifestFileTemplatePath",
	"Comment": "returns the absolute location of the template for the given service.if the file can not be found at its required location then the file will becopied from inside this jar file to the file system.the type of the service must be set before calling this method, otherwisea runtime exception results.",
	"Method": "String getManifestFileTemplatePath(){\r\n    String ir = System.getProperty(SystemPropertyConstants.INSTALL_ROOT_PROPERTY);\r\n    if (!ok(ir))\r\n        throw new RuntimeException(\"Internal Error - System Property not set: \" + SystemPropertyConstants.INSTALL_ROOT_PROPERTY);\r\n    File rootDir = SmartFile.sanitize(new File(ir));\r\n    if (!rootDir.isDirectory())\r\n        throw new RuntimeException(\"Internal Error - Not a directory: \" + rootDir);\r\n    File templatesDir = new File(rootDir, REL_PATH_TEMPLATES);\r\n    String filename = MANIFEST_FILE_TEMPL_SUFFIX;\r\n    File f = new File(templatesDir, filename);\r\n    return f.getPath();\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.messagebean.EjbCreateExists.check",
	"Comment": "run a verifier test against an individual declared messagedrive bean component",
	"Method": "Result check(EjbMessageBeanDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    Class mbc = loadMessageBeanClass(descriptor, result);\r\n    if (mbc != null) {\r\n        Method m = getMethod(mbc, getMethodName(), null);\r\n        if (m != null) {\r\n            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.passed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.messagebean.EjbCreateExists.passed\", \"Message-Drive bean [ {0} ] provide an {1} implementation with no argument\", new Object[] { (descriptor).getEjbClassName(), getMethodName() }));\r\n        } else {\r\n            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.failed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.messagebean.EjbCreateExists.failed\", \"Error: Message-Drive bean [ {0} ] does not implement an {1} with no arguments\", new Object[] { (descriptor).getEjbClassName(), getMethodName() }));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.ListCommandsCommand.matchCommands",
	"Comment": "filter the command list to only those matching the patterns.",
	"Method": "String[] matchCommands(String[] commands){\r\n    List<String> matched = new ArrayList<String>();\r\n    for (String cmd : commands) {\r\n        if (patterns.size() == 0) {\r\n            if (!cmd.startsWith(\"_\"))\r\n                matched.add(cmd);\r\n        } else {\r\n            for (Pattern re : patterns) if (re.matcher(cmd).find())\r\n                if (!cmd.startsWith(\"_\") || re.pattern().startsWith(\"_\"))\r\n                    matched.add(cmd);\r\n        }\r\n    }\r\n    return matched.toArray(new String[matched.size()]);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.getValveNames",
	"Comment": "return the mbean names of the valves associated with this host",
	"Method": "String[] getValveNames(){\r\n    GlassFishValve[] valves = this.getValves();\r\n    String[] mbeanNames = new String[valves.length];\r\n    for (int i = 0; i < valves.length; i++) {\r\n        if (valves[i] == null)\r\n            continue;\r\n        if (((ValveBase) valves[i]).getObjectName() == null)\r\n            continue;\r\n        mbeanNames[i] = ((ValveBase) valves[i]).getObjectName().toString();\r\n    }\r\n    return mbeanNames;\r\n}"
}, {
	"Path": "org.apache.catalina.session.ManagerBase.changeSessionId",
	"Comment": "change the session id of the current session to a new randomly generatedsession id.",
	"Method": "void changeSessionId(Session session){\r\n    session.setId(generateSessionId());\r\n}"
}, {
	"Path": "com.sun.enterprise.web.pwc.PwcWebModule.getSTMPoolSize",
	"Comment": "return maximum number of instances that will be allocated when a singlethread model servlet is used in this web module.",
	"Method": "int getSTMPoolSize(){\r\n    return (this.stmPoolSize);\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.ListVirtualServers.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    final ActionReport report = context.getActionReport();\r\n    List<VirtualServer> list = config.getHttpService().getVirtualServer();\r\n    for (final VirtualServer virtualServer : list) {\r\n        final MessagePart part = report.getTopMessagePart().addChild();\r\n        part.setMessage(virtualServer.getId());\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.WelcomeFile.check",
	"Comment": "welcome file element contains the file name to use as a default welcome filewithin web application test.",
	"Method": "Result check(WebBundleDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!isApplicable(descriptor, result)) {\r\n        return result;\r\n    }\r\n    boolean syntaxOK = checkSyntax(descriptor, result);\r\n    boolean exists = true;\r\n    if (!syntaxOK) {\r\n        result.setStatus(Result.FAILED);\r\n    } else if (!exists) {\r\n        result.setStatus(Result.WARNING);\r\n    } else {\r\n        result.setStatus(Result.PASSED);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.EmbeddedWebContainer.loadListener",
	"Comment": "util method to load classes that might get compiled after this class iscompiled.",
	"Method": "ContainerListener loadListener(String className){\r\n    try {\r\n        Class clazz = Class.forName(className);\r\n        return (ContainerListener) clazz.newInstance();\r\n    } catch (Throwable ex) {\r\n        String msg = logger.getResourceBundle().getString(LogFacade.UNABLE_TO_INSTANTIATE_CONTAINER_LISTENER);\r\n        msg = MessageFormat.format(msg, className);\r\n        logger.log(Level.SEVERE, msg, ex);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.CoyoteServerSocketFactory.setKeyAlias",
	"Comment": "sets the alias name of the keypair and supporting certificate chainused by the server to authenticate itself to ssl clients.",
	"Method": "void setKeyAlias(String alias){\r\n    this.keyAlias = alias;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.readers.XmlInputObject.parse",
	"Comment": "scan the content following the named tag, attaching it to the context.",
	"Method": "boolean parse(XmlInputReader reader,XmlInputObject context,String name){\r\n    char character;\r\n    int i;\r\n    String n;\r\n    XmlInputObject subContext;\r\n    String string;\r\n    Object token;\r\n    token = reader.nextToken();\r\n    if (BANG.equals(token)) {\r\n        character = reader.next();\r\n        if (character == '-') {\r\n            if (reader.next() == '-') {\r\n                reader.skipPast(\"-->\");\r\n                return false;\r\n            }\r\n            reader.back();\r\n        } else if (character == '[') {\r\n            token = reader.nextToken();\r\n            if (\"CDATA\".equals(token)) {\r\n                if (reader.next() == '[') {\r\n                    string = reader.nextCDATA();\r\n                    if (string.length() > 0) {\r\n                        context.put(\"content\", string);\r\n                    }\r\n                    return false;\r\n                }\r\n            }\r\n            throw reader.error(\"Expected 'CDATA['\");\r\n        }\r\n        i = 1;\r\n        do {\r\n            token = reader.nextMeta();\r\n            if (token == null) {\r\n                throw reader.error(\"Missing '>' after '<!'.\");\r\n            } else if (LT.equals(token)) {\r\n                i += 1;\r\n            } else if (GT.equals(token)) {\r\n                i -= 1;\r\n            }\r\n        } while (i > 0);\r\n        return false;\r\n    } else if (QUEST.equals(token)) {\r\n        reader.skipPast(\"?>\");\r\n        return false;\r\n    } else if (SLASH.equals(token)) {\r\n        token = reader.nextToken();\r\n        if (name == null) {\r\n            throw reader.error(\"Mismatched close tag \" + token);\r\n        }\r\n        if (!name.equals(token)) {\r\n            throw reader.error(\"Mismatched \" + name + \" and \" + token);\r\n        }\r\n        if (!GT.equals(reader.nextToken())) {\r\n            throw reader.error(\"Misshaped close tag\");\r\n        }\r\n        return true;\r\n    } else if (token instanceof Character) {\r\n        throw reader.error(\"Misshaped tag\");\r\n    } else {\r\n        n = (String) token;\r\n        token = null;\r\n        subContext = new XmlInputObject(reader);\r\n        for (; ; ) {\r\n            if (token == null) {\r\n                token = reader.nextToken();\r\n            }\r\n            if (token instanceof String) {\r\n                string = (String) token;\r\n                token = reader.nextToken();\r\n                if (EQ.equals(token)) {\r\n                    token = reader.nextToken();\r\n                    if (!(token instanceof String)) {\r\n                        throw reader.error(\"Missing value\");\r\n                    }\r\n                    subContext.put(string, XmlInputObject.stringToValue((String) token));\r\n                    token = null;\r\n                } else {\r\n                    subContext.put(string, \"\");\r\n                }\r\n            } else if (SLASH.equals(token)) {\r\n                if (!reader.nextToken().equals(GT)) {\r\n                    throw reader.error(\"Misshaped tag\");\r\n                }\r\n                context.putMap(n, subContext.getMap());\r\n                return false;\r\n            } else if (GT.equals(token)) {\r\n                for (; ; ) {\r\n                    token = reader.nextContent();\r\n                    if (token == null) {\r\n                        if (n != null) {\r\n                            throw reader.error(\"Unclosed tag \" + n);\r\n                        }\r\n                        return false;\r\n                    } else if (token instanceof String) {\r\n                        string = (String) token;\r\n                        if (string.length() > 0) {\r\n                            subContext.put(\"content\", XmlInputObject.stringToValue(string));\r\n                        }\r\n                    } else if (LT.equals(token)) {\r\n                        if (parse(reader, subContext, n)) {\r\n                            if (subContext.length() == 0) {\r\n                                context.put(n, \"\");\r\n                            } else if (subContext.length() == 1 && subContext.get(\"content\") != null) {\r\n                                context.put(n, subContext.get(\"content\"));\r\n                            } else {\r\n                                context.putMap(n, subContext.getMap());\r\n                            }\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                throw reader.error(\"Misshaped tag\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.appserv.util.cache.MultiLruCache.handleOverflow",
	"Comment": "cache has reached threshold so trim its size. subclasses are expectedto provide a robust cache replacement algorithm.",
	"Method": "void handleOverflow(){\r\n    LruCacheItem l = null;\r\n}"
}, {
	"Path": "org.apache.catalina.util.LifecycleSupport.fireLifecycleEvent",
	"Comment": "notify all lifecycle event listeners that a particular event hasoccurred for this container.the default implementation performsthis notification synchronously using the calling thread.",
	"Method": "void fireLifecycleEvent(String type,Object data){\r\n    LifecycleListener[] listenersArray = null;\r\n    synchronized (listeners) {\r\n        if (listeners.isEmpty()) {\r\n            return;\r\n        }\r\n        listenersArray = listeners.toArray(new LifecycleListener[listeners.size()]);\r\n    }\r\n    LifecycleEvent event = new LifecycleEvent(lifecycle, type, data);\r\n    for (int i = 0; i < listenersArray.length; i++) {\r\n        listenersArray[i].lifecycleEvent(event);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ContainerBase.getPipeline",
	"Comment": "return the pipeline object that manages the valves associated withthis container.",
	"Method": "Pipeline getPipeline(){\r\n    return (this.pipeline);\r\n}"
}, {
	"Path": "com.sun.enterprise.util.net.JarURIPattern.getJarEntries",
	"Comment": "this method is used to extract uri of jar entries that matcha given pattern.",
	"Method": "List<String> getJarEntries(URI uri,Pattern pattern){\r\n    List<String> results = new ArrayList<String>();\r\n    File file = null;\r\n    try {\r\n        file = new File(uri);\r\n    } catch (Exception ex) {\r\n    }\r\n    if (file == null || file.isDirectory()) {\r\n        return results;\r\n    }\r\n    String fileName = file.getName();\r\n    if (fileName.endsWith(\".jar\")) {\r\n        JarFile jarFile = null;\r\n        try {\r\n            jarFile = new JarFile(new File(uri));\r\n            Enumeration<JarEntry> entries = jarFile.entries();\r\n            while (entries.hasMoreElements()) {\r\n                JarEntry entry = (JarEntry) entries.nextElement();\r\n                String entryName = entry.getName();\r\n                if (pattern.matcher(entryName).matches()) {\r\n                    results.add(entryName);\r\n                }\r\n            }\r\n        } catch (Exception ex) {\r\n            if (logger.isLoggable(Level.WARNING)) {\r\n                logger.log(Level.WARNING, CULoggerInfo.getString(CULoggerInfo.exceptionJarOpen, fileName), ex);\r\n            }\r\n            throw new RuntimeException(ex);\r\n        } finally {\r\n            if (jarFile != null) {\r\n                try {\r\n                    jarFile.close();\r\n                } catch (Throwable t) {\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getNamedDispatcher",
	"Comment": "return a requestdispatcher object that acts as awrapper for the named servlet.",
	"Method": "RequestDispatcher getNamedDispatcher(String name){\r\n    return context.getNamedDispatcher(name);\r\n}"
}, {
	"Path": "com.sun.appserv.web.cache.mapping.CacheMapping.findMethod",
	"Comment": "return true if the specified http request method isallowed for caching",
	"Method": "boolean findMethod(String method){\r\n    if (methods.length == 0)\r\n        return (true);\r\n    for (int i = 0; i < methods.length; i++) {\r\n        if (methods[i].equals(method))\r\n            return (true);\r\n    }\r\n    return (false);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.server.ApplicationLifecycle.getArchiveHandler",
	"Comment": "returns the archivehandler for the passed archive abstraction or nullif there are none.",
	"Method": "ArchiveHandler getArchiveHandler(ReadableArchive archive,ArchiveHandler getArchiveHandler,ReadableArchive archive,String type){\r\n    if (type != null) {\r\n        return habitat.<ArchiveDetector>getService(ArchiveDetector.class, type).getArchiveHandler();\r\n    }\r\n    List<ArchiveDetector> detectors = new ArrayList<ArchiveDetector>(habitat.<ArchiveDetector>getAllServices(ArchiveDetector.class));\r\n    Collections.sort(detectors, new Comparator<ArchiveDetector>() {\r\n        @Override\r\n        public int compare(ArchiveDetector o1, ArchiveDetector o2) {\r\n            return o1.rank() - o2.rank();\r\n        }\r\n    });\r\n    for (ArchiveDetector ad : detectors) {\r\n        if (ad.handles(archive)) {\r\n            return ad.getArchiveHandler();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.server.ApplicationLifecycle.getArchiveHandler",
	"Comment": "returns the archivehandler for the passed archive abstraction or nullif there are none.",
	"Method": "ArchiveHandler getArchiveHandler(ReadableArchive archive,ArchiveHandler getArchiveHandler,ReadableArchive archive,String type){\r\n    return o1.rank() - o2.rank();\r\n}"
}, {
	"Path": "org.apache.catalina.valves.JDBCAccessLogValve.setBytesField",
	"Comment": "sets the name of the field containing the number of bytes returned.",
	"Method": "void setBytesField(String bytesField){\r\n    this.bytesField = bytesField;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.addResourceEnvRef",
	"Comment": "add a resource environment reference for this web application.",
	"Method": "void addResourceEnvRef(String name,String type){\r\n    namingResources.addResourceEnvRef(name, type);\r\n    if (notifyContainerListeners) {\r\n        fireContainerEvent(\"addResourceEnvRef\", name);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebApplication.getDescriptor",
	"Comment": "returns the deployment descriptor associated with this application",
	"Method": "WebBundleDescriptorImpl getDescriptor(){\r\n    return wmInfo.getDescriptor();\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.provider.OptionsResultXmlProvider.getContent",
	"Comment": "get json representation for the given optionsresult object",
	"Method": "String getContent(OptionsResult proxy){\r\n    String result;\r\n    String indent = Constants.INDENT;\r\n    result = \"<\" + proxy.getName() + \">\";\r\n    result = result + getRespresenationForMethodMetaData(proxy, indent);\r\n    result = result + \"\\n\" + getEndXmlElement(proxy.getName());\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.ListProtocols.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    final ActionReport report = context.getActionReport();\r\n    List<Protocol> list = config.getNetworkConfig().getProtocols().getProtocol();\r\n    for (Protocol protocol : list) {\r\n        report.getTopMessagePart().addChild().setMessage(protocol.getName());\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.JvmOptionsHelper.last",
	"Comment": "returns the last jvmoptionselement in the chain of responsibility.",
	"Method": "JvmOptionsElement last(){\r\n    JvmOptionsElement current = head;\r\n    while (current.hasNext()) {\r\n        current = current.next();\r\n    }\r\n    return current;\r\n}"
}, {
	"Path": "org.apache.catalina.loader.WebappLoader.copy",
	"Comment": "copy a file to the specified temp directory. this is required onlybecause jasper depends on it.",
	"Method": "boolean copy(InputStream is,OutputStream os){\r\n    try {\r\n        byte[] buf = new byte[4096];\r\n        while (true) {\r\n            int len = is.read(buf);\r\n            if (len < 0)\r\n                break;\r\n            os.write(buf, 0, len);\r\n        }\r\n    } catch (IOException e) {\r\n        return false;\r\n    } finally {\r\n        try {\r\n            is.close();\r\n        } catch (Exception e) {\r\n        }\r\n        try {\r\n            os.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.catalina.session.JDBCStore.stop",
	"Comment": "gracefully terminate everything associated with our db.called once when this store is stoping.",
	"Method": "void stop(){\r\n    super.stop();\r\n    if (conn != null) {\r\n        try {\r\n            conn.commit();\r\n        } catch (SQLException e) {\r\n        }\r\n        if (preparedSizeSql != null) {\r\n            try {\r\n                preparedSizeSql.close();\r\n            } catch (SQLException e) {\r\n            }\r\n        }\r\n        if (preparedKeysSql != null) {\r\n            try {\r\n                preparedKeysSql.close();\r\n            } catch (SQLException e) {\r\n            }\r\n        }\r\n        if (preparedSaveSql != null) {\r\n            try {\r\n                preparedSaveSql.close();\r\n            } catch (SQLException e) {\r\n            }\r\n        }\r\n        if (preparedClearSql != null) {\r\n            try {\r\n                preparedClearSql.close();\r\n            } catch (SQLException e) {\r\n            }\r\n        }\r\n        if (preparedRemoveSql != null) {\r\n            try {\r\n                preparedRemoveSql.close();\r\n            } catch (SQLException e) {\r\n            }\r\n        }\r\n        if (preparedLoadSql != null) {\r\n            try {\r\n                preparedLoadSql.close();\r\n            } catch (SQLException e) {\r\n            }\r\n        }\r\n        try {\r\n            conn.close();\r\n        } catch (SQLException e) {\r\n        }\r\n        this.preparedSizeSql = null;\r\n        this.preparedKeysSql = null;\r\n        this.preparedSaveSql = null;\r\n        this.preparedClearSql = null;\r\n        this.preparedRemoveSql = null;\r\n        this.preparedLoadSql = null;\r\n        this.conn = null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.CommandRunnerImpl.getCommand",
	"Comment": "obtain and return the command implementation defined bythe passed commandname.",
	"Method": "AdminCommand getCommand(String commandName,ActionReport report,Logger logger,AdminCommand getCommand,String scope,String commandName,ActionReport report,Logger logger){\r\n    AdminCommand command = null;\r\n    String commandServiceName = (scope != null) ? scope + commandName : commandName;\r\n    try {\r\n        command = habitat.getService(AdminCommand.class, commandServiceName);\r\n    } catch (MultiException e) {\r\n        report.setFailureCause(e);\r\n    }\r\n    if (command == null) {\r\n        String msg;\r\n        if (!ok(commandName)) {\r\n            msg = adminStrings.getLocalString(\"adapter.command.nocommand\", \"No command was specified.\");\r\n        } else {\r\n            if (habitat.getServiceHandle(AdminCommand.class, commandServiceName) == null) {\r\n                msg = adminStrings.getLocalString(\"adapter.command.notfound\", \"Command {0} not found\", commandName);\r\n            } else {\r\n                msg = adminStrings.getLocalString(\"adapter.command.notcreated\", \"Implementation for the command {0} exists in \" + \"the system, but it has some errors, \" + \"check server.log for details\", commandName);\r\n            }\r\n        }\r\n        report.setMessage(msg);\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        KernelLoggerInfo.getLogger().fine(msg);\r\n        return null;\r\n    }\r\n    Class<? extends Annotation> myScope = getScope(command.getClass());\r\n    if (myScope == null) {\r\n        String msg = adminStrings.getLocalString(\"adapter.command.noscope\", \"Implementation for the command {0} exists in the \" + \"system,\\nbut it has no @Scoped annotation\", commandName);\r\n        report.setMessage(msg);\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        KernelLoggerInfo.getLogger().fine(msg);\r\n        command = null;\r\n    } else if (Singleton.class.equals(myScope)) {\r\n        CommandModel model = getModel(command);\r\n        if (model.getParameters().size() > 0) {\r\n            String msg = adminStrings.getLocalString(\"adapter.command.hasparams\", \"Implementation for the command {0} exists in the \" + \"system,\\nbut it's a singleton that also has \" + \"parameters\", commandName);\r\n            report.setMessage(msg);\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            KernelLoggerInfo.getLogger().fine(msg);\r\n            command = null;\r\n        }\r\n    }\r\n    return command;\r\n}"
}, {
	"Path": "test.TestBean.testA2WithFlush",
	"Comment": "run test for cmp2.x bean with flush after businessmethod. this method will fail at flush and the clientwill get our flushexception.",
	"Method": "void testA2WithFlush(){\r\n    a2bean = a2Home.create(\"B2\");\r\n    try {\r\n        a2bean.setNameWithFlush(\"A12345678901234567890\");\r\n    } catch (EJBException e) {\r\n        if (isExpectedException(e))\r\n            throw new FlushException(e.toString());\r\n        else\r\n            throw e;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.PEAccessLogValve.setCondition",
	"Comment": "set the servletrequest.attribute to look for to performconditional logging. set to null to log everything.",
	"Method": "void setCondition(String condition){\r\n    this.condition = condition;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.CommandRunnable.setName",
	"Comment": "set a name on the runnable. the name is not interpreted to meananything so the caller can use it for whatever it likes.",
	"Method": "void setName(String s){\r\n    this.name = s;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.beanclass.EjbClassConstructor.check",
	"Comment": "enterprise java bean class constuctor test.the class must have a public constructor that takes no parameters.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    Class c = loadEjbClass(descriptor, result);\r\n    if (c != null) {\r\n        boolean foundOne = false;\r\n        Constructor[] constructors = c.getConstructors();\r\n        for (int i = 0; i < constructors.length; i++) {\r\n            int modifiers = constructors[i].getModifiers();\r\n            if (Modifier.isPublic(modifiers)) {\r\n                Class[] constructorParameterTypes;\r\n                constructorParameterTypes = constructors[i].getParameterTypes();\r\n                if (constructorParameterTypes.length > 0) {\r\n                    continue;\r\n                } else {\r\n                    foundOne = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (foundOne) {\r\n            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"Valid: This bean [ {0} ] has a public constructor method with no \" + \" \\n parameters.  Enterprise beans must have a public constructor \" + \" \\n method with no parameters.\", new Object[] { descriptor.getEjbClassName() }));\r\n        } else {\r\n            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: There is no public constructor method with no parameters\" + \"\\n defined within bean [ {0} ].  Enterprise beans must have a \" + \"\\n public constructor methods with no parameters.\", new Object[] { descriptor.getEjbClassName() }));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.pe.PEFileLayout.createJbiSystemComponentsLayout",
	"Comment": "this method is used to create the file layout forjbi system components, httpsoapbc, javaeese, wsdlsl",
	"Method": "void createJbiSystemComponentsLayout(){\r\n    try {\r\n        createDirectory(getHttpBcDir());\r\n        createDirectory(getHttpBcInstallRoot());\r\n        createDirectory(getJavaEESEDir());\r\n        createDirectory(getJavaEESEInstallRoot());\r\n        createDirectory(getWSDLSLDir());\r\n        createDirectory(getWSDLSLInstallRoot());\r\n        createDirectory(getHttpBcWorkSpace());\r\n        createDirectory(getJavaEESEWorkSpace());\r\n    } catch (Exception e) {\r\n        throw new RepositoryException(e);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.unlockForegroundCompletely",
	"Comment": "unlock the session completelyirregardless of whether it was foreground or background locked",
	"Method": "void unlockForegroundCompletely(){\r\n    if (_sessionLock == null)\r\n        return;\r\n    synchronized (sessionLockMonitor) {\r\n        _sessionLock.unlockForegroundCompletely();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.rollback",
	"Comment": "directs the topcoordinator to roll back the transaction.the topcoordinator directs all registered resources to rollback.if any resources raise heuristic exceptions,the information is recorded, and the resources are directedto forget the transaction before thecoordinator returns a heuristic exception to its caller.",
	"Method": "void rollback(boolean force){\r\n    synchronized (this) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.logp(Level.FINE, \"TopCoordinator\", \"rollback()\", \"Within TopCoordinator.rollback() :\" + \"GTID is : \" + superInfo.globalTID.toString());\r\n        }\r\n        if (tranState == null) {\r\n            return;\r\n        }\r\n        if (tranState.state == TransactionState.STATE_ROLLED_BACK) {\r\n            return;\r\n        }\r\n        if (tranState.state == TransactionState.STATE_COMMITTED) {\r\n            return;\r\n        }\r\n        if (!force && ((tranState.state == TransactionState.STATE_PREPARED_SUCCESS) || (!tranState.setState(TransactionState.STATE_ROLLING_BACK)))) {\r\n            return;\r\n        }\r\n        if (!temporary && !tranState.setState(TransactionState.STATE_ROLLING_BACK)) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"TopCoordinator - setState(TransactionState.STATE_ROLLED_BACK) returned false\");\r\n            }\r\n        }\r\n        if (nestingInfo != null) {\r\n            nestingInfo.rollbackFamily();\r\n        }\r\n    }\r\n    Throwable heuristicExc = null;\r\n    if (participants != null) {\r\n        try {\r\n            participants.distributeRollback(false);\r\n        } catch (Throwable exc) {\r\n            if (exc instanceof HeuristicMixed || exc instanceof HeuristicHazard) {\r\n                heuristicExc = exc;\r\n            } else if (exc instanceof INTERNAL) {\r\n                throw (INTERNAL) exc;\r\n            } else {\r\n                _logger.log(Level.WARNING, \"\", exc);\r\n            }\r\n        }\r\n    }\r\n    synchronized (this) {\r\n        if (!temporary && !tranState.setState(TransactionState.STATE_ROLLED_BACK)) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"TopCoordinator - setState(TransactionState.STATE_ROLLED_BACK) returned false\");\r\n            }\r\n        }\r\n        if (terminator != null) {\r\n            terminator.setCompleted(true, heuristicExc != null);\r\n        }\r\n        if (!root) {\r\n            afterCompletion(Status.StatusRolledBack);\r\n        }\r\n        if (heuristicExc != null) {\r\n            if (heuristicExc instanceof HeuristicMixed) {\r\n                throw (HeuristicMixed) heuristicExc;\r\n            } else {\r\n                throw (HeuristicHazard) heuristicExc;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.getInfo",
	"Comment": "return descriptive information about this connector implementation.",
	"Method": "String getInfo(){\r\n    return info;\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ReplicationStore.load",
	"Comment": "load and return the session associated with the specified session identifier from this store, without removing it.if there is no such stored session, return null.",
	"Method": "Session load(String id,Session load,String id,String version){\r\n    try {\r\n        return loadFromBackingStore(id, version);\r\n    } catch (BackingStoreException ex) {\r\n        IOException ex1 = (IOException) new IOException(\"Error during load: \" + ex.getMessage()).initCause(ex);\r\n        throw ex1;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.jndi.JndiNameLookupHelper.toNameClassPairArray",
	"Comment": "changes a namingenumeration object into an arraylist ofnameclasspair objects.",
	"Method": "ArrayList<String> toNameClassPairArray(NamingEnumeration ee){\r\n    ArrayList<String> names = new ArrayList<String>();\r\n    while (ee.hasMore()) {\r\n        Object o = ee.next();\r\n        if (o.toString().indexOf(SYSTEM_SUBCONTEXT) == -1) {\r\n            names.add(o.toString());\r\n        }\r\n    }\r\n    return names;\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.Descriptor.createUniqueNameAmongst",
	"Comment": "returns string based on the trial name that is guaramteed to be differentfrom any of the strings in the vector of string names.",
	"Method": "String createUniqueNameAmongst(String trialName,Vector<String> otherNames){\r\n    return uniquifyString(trialName, otherNames, 0);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentTransaction.release",
	"Comment": "disassociates the current thread of control from the specified transaction.",
	"Method": "void release(GlobalTID tid){\r\n    Thread thread = (Thread) RecoveryManager.getThreadFromTxMap(tid);\r\n    if (thread == null || (thread != Thread.currentThread())) {\r\n        return;\r\n    } else {\r\n        RecoveryManager.removeFromTxMap(tid);\r\n    }\r\n    boolean[] outBoolean = new boolean[1];\r\n    ControlImpl control = endAborted(outBoolean, true);\r\n    if (outBoolean[0]) {\r\n        importedTransactions.remove(Thread.currentThread());\r\n        return;\r\n    }\r\n    GlobalTID importedTID = (GlobalTID) importedTransactions.remove(thread);\r\n    StatusHolder outStatus = new StatusHolder();\r\n    try {\r\n        if (importedTID == null || control == null || !importedTID.isSameTID(control.getGlobalTID(outStatus)) || outStatus.value != Status.StatusActive) {\r\n            INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.WrongContextOnReply, CompletionStatus.COMPLETED_YES);\r\n            throw exc;\r\n        }\r\n    } catch (SystemException ex) {\r\n        _logger.log(Level.FINE, \"\", ex);\r\n        INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.WrongContextOnReply, CompletionStatus.COMPLETED_YES);\r\n        throw exc;\r\n    }\r\n    endCurrent(false);\r\n    control.destroy();\r\n}"
}, {
	"Path": "org.apache.naming.SelectorContext.list",
	"Comment": "enumerates the names bound in the named context, along with the class names of objects bound to them.",
	"Method": "NamingEnumeration<NameClassPair> list(Name name,NamingEnumeration<NameClassPair> list,String name){\r\n    return getBoundContext().list(parseName(name));\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Response.getOutputStream",
	"Comment": "return the servlet output stream associated with this response.",
	"Method": "ServletOutputStream getOutputStream(){\r\n    if (usingWriter)\r\n        throw new IllegalStateException(rb.getString(LogFacade.GET_WRITER_BEEN_CALLED_EXCEPTION));\r\n    usingOutputStream = true;\r\n    if (outputStream == null) {\r\n        outputStream = new CoyoteOutputStream(outputBuffer);\r\n    }\r\n    return outputStream;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.ConnectionRequestInfoImplEquals.check",
	"Comment": "test wether the implementatin of the connectionrequestinfo interfaceproperly overrides the equals method.",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    Class c = findImplementorOf(descriptor, \"javax.resource.spi.ConnectionRequestInfo\");\r\n    if (c == null) {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.ConnectorTest.optionalInterfaceMissing\", \"Warning: There is no implementation of the optional [ {0} ] interface\", new Object[] { \"javax.resource.spi.ConnectionRequestInfo\" }));\r\n    } else {\r\n        checkMethodImpl(c, \"equals\", new Class[] { Object.class }, \"public boolean equals(java.lang.Object)\", result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.setSecure",
	"Comment": "set the secure connection flag that will be assigned to requestsreceived through this connector.",
	"Method": "void setSecure(boolean secure){\r\n    this.secure = secure;\r\n    setProperty(\"secure\", String.valueOf(secure));\r\n}"
}, {
	"Path": "org.glassfish.config.support.GenericListCommand.arrayToString",
	"Comment": "convert an array of string to a string containing a comma separated list",
	"Method": "String arrayToString(String[] a){\r\n    if (a == null || a.length == 0) {\r\n        return \"\";\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(a[0]);\r\n    for (int i = 1; i < a.length; i++) {\r\n        sb.append(\", \").append(a[i]);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.glassfish.internal.data.EngineRef.stop",
	"Comment": "stops a module, meaning that components implemented by this module should not be accessedby external modules",
	"Method": "boolean stop(ApplicationContext context){\r\n    return appCtr.stop(context);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.RealmName.check",
	"Comment": "the web realm name specifies the realm name to use in http basic authentication",
	"Method": "Result check(WebBundleDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (descriptor.getLoginConfiguration() != null) {\r\n        String realmName = descriptor.getLoginConfiguration().getRealmName();\r\n        if (realmName.length() > 0) {\r\n            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"The realm name [ {0} ] value specifies the realm name to use in HTTP Basic authentication within web application [ {1} ]\", new Object[] { realmName, descriptor.getName() }));\r\n        } else {\r\n            result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable1\", \"Not Applicable: The realm name [ {0} ] value does not specify the realm name to use in HTTP Basic authentication within web application [ {1} ]\", new Object[] { realmName, descriptor.getName() }));\r\n        }\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"There are no realm name elements within this web archive [ {0} ]\", new Object[] { descriptor.getName() }));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.UserTransactionImpl.readResolve",
	"Comment": "return instance with all injected values from deserialization if possible",
	"Method": "Object readResolve(){\r\n    ServiceLocator h = Globals.getDefaultHabitat();\r\n    if (h != null) {\r\n        return h.getService(UserTransactionImpl.class);\r\n    }\r\n    return this;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.adapter.RestAdapter.exposeContext",
	"Comment": "dynamically load the class that contains all references to jersey apisso that jersey is not loaded when the restadapter is loaded at boot timegain a few 100 millis at glassfish startup time",
	"Method": "JerseyContainer exposeContext(){\r\n    Set<Class<?>> classes = getRestResourceProvider().getResourceClasses(habitat);\r\n    ClassLoader originalContextClassLoader = Thread.currentThread().getContextClassLoader();\r\n    try {\r\n        ClassLoader apiClassLoader = sc.getCommonClassLoader();\r\n        Thread.currentThread().setContextClassLoader(apiClassLoader);\r\n        ResourceConfig rc = getRestResourceProvider().getResourceConfig(classes, sc, habitat, getAdditionalBinders());\r\n        return getJerseyContainer(rc);\r\n    } finally {\r\n        Thread.currentThread().setContextClassLoader(originalContextClassLoader);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.codegen.otsidl._JControlStub.getLocalTID",
	"Comment": "transaction, and a value that indicates the state of the transaction.",
	"Method": "long getLocalTID(org.omg.CosTransactions.StatusHolder status){\r\n    org.omg.CORBA.portable.InputStream $in = null;\r\n    try {\r\n        org.omg.CORBA.portable.OutputStream $out = _request(\"getLocalTID\", true);\r\n        $in = _invoke($out);\r\n        long $result = $in.read_longlong();\r\n        status.value = org.omg.CosTransactions.StatusHelper.read($in);\r\n        return $result;\r\n    } catch (org.omg.CORBA.portable.ApplicationException $ex) {\r\n        $in = $ex.getInputStream();\r\n        String _id = $ex.getId();\r\n        throw new org.omg.CORBA.MARSHAL(_id);\r\n    } catch (org.omg.CORBA.portable.RemarshalException $rm) {\r\n        return getLocalTID(status);\r\n    } finally {\r\n        _releaseReply($in);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModuleListener.getJasperLogLevel",
	"Comment": "determine the debug setting for jspservlet based on the ias loglevel.",
	"Method": "String getJasperLogLevel(){\r\n    Level level = _logger.getLevel();\r\n    if (level == null)\r\n        return \"warning\";\r\n    if (level.equals(Level.WARNING))\r\n        return \"warning\";\r\n    else if (level.equals(Level.FINE))\r\n        return \"information\";\r\n    else if (level.equals(Level.FINER) || level.equals(Level.FINEST))\r\n        return \"debug\";\r\n    else\r\n        return \"warning\";\r\n}"
}, {
	"Path": "org.glassfish.api.admin.SSHCommandExecutionException.setSSHSettings",
	"Comment": "stores the settings for the ssh connection that apply to node that wasused in the command execution",
	"Method": "void setSSHSettings(String sshSettings){\r\n    SSHSettings = sshSettings;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.cci.ConnectionFactoryGetConnection.check",
	"Comment": "all connector tests should implement this method. it run an individualtest against the resource adapter deployment descriptor.",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (isCCIImplemented(descriptor, result)) {\r\n        Class cf = testConnectionFactoryImpl(descriptor, result);\r\n        if (cf == null)\r\n            return result;\r\n        String className = cf.getName();\r\n        do {\r\n            Method[] allMethods = cf.getMethods();\r\n            for (int i = 0; i < allMethods.length; i++) {\r\n                if (allMethods[i].getName().equals(\"getConnection\")) {\r\n                    String connection = getConnectionInterface(descriptor, result);\r\n                    if (isSubclassOf(allMethods[i].getReturnType(), connection)) {\r\n                        result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"The getConnection method of the [ {0} ] returns the [ {1} ] interface\", new Object[] { cf.getName(), connection }));\r\n                    } else {\r\n                        result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: The getConnection method of the [ {0} ] does not return the [ {1} ] interface\", new Object[] { cf.getName(), connection }));\r\n                    }\r\n                    return result;\r\n                }\r\n            }\r\n            cf = cf.getSuperclass();\r\n        } while (cf != null);\r\n        result.addWarningDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.warning(smh.getLocalString(getClass().getName() + \".warning\", \"Warning: The getConnection method is not defined by [ {0} ]\", new Object[] { className }));\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.cci.notApp\", \"The CCI interfaces do not seem to be implemented by this resource adapter\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ValveBase.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (info);\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.config.AMXConfigLoader.quoteIfNeeded",
	"Comment": "quotes the name string if it contains any characters that are illegalin mbean names.",
	"Method": "String quoteIfNeeded(String name){\r\n    if (name != null && ILLEGAL_JMX_NAME_PATTERN.matcher(name).matches()) {\r\n        return \"\\\"\" + name + \"\\\"\";\r\n    } else {\r\n        return name;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.VirtualServerConfig.getDefaultWebXml",
	"Comment": "gets the location of the default web.xml configuration file.",
	"Method": "String getDefaultWebXml(){\r\n    return defaultWebXml;\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.Descriptor.visit",
	"Comment": "visitor api implementation, all descriptors must be visitable",
	"Method": "void visit(DescriptorVisitor aVisitor){\r\n    aVisitor.accept(this);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.connector.MapperListener.isNotificationEnabled",
	"Comment": "filters out any notifications corresponding to mbeans belonging toa different server instance than the server instance on which thismapperlistener is running.",
	"Method": "boolean isNotificationEnabled(Notification notification){\r\n    if (notification instanceof MBeanServerNotification) {\r\n        ObjectName objectName = ((MBeanServerNotification) notification).getMBeanName();\r\n        String otherDomain = objectName.getDomain();\r\n        if (this.domain != null && !(this.domain.equals(otherDomain))) {\r\n            return false;\r\n        }\r\n        String otherInstance = objectName.getKeyProperty(\"J2EEServer\");\r\n        if (myInstance != null && otherInstance != null && !otherInstance.equals(myInstance)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.getSelectorThreadImpl",
	"Comment": "get the underlying selectorthread implementation, null if the default is used.",
	"Method": "String getSelectorThreadImpl(){\r\n    return selectorThreadImpl;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityCollection.toString",
	"Comment": "return a string representation of this security collection.",
	"Method": "String toString(){\r\n    StringBuilder sb = new StringBuilder(\"SecurityCollection: \");\r\n    sb.append(\" name: \").append(name);\r\n    sb.append(\" description \").append(description);\r\n    for (String method : methods) {\r\n        sb.append(\" method: \").append(method);\r\n    }\r\n    for (String methodOmission : methodOmissions) {\r\n        sb.append(\" methodOmission \").append(methodOmission);\r\n    }\r\n    for (String pattern : patterns) {\r\n        sb.append(\" pattern \").append(pattern);\r\n    }\r\n    return (sb.toString());\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebComponentDescriptorImpl.setWebComponentImplementation",
	"Comment": "sets the implementation file for this web component, theimplementation file is either a servlet class name of a jspfile name.",
	"Method": "void setWebComponentImplementation(String implFile){\r\n    if (!isServlet && !implFile.startsWith(\"/\")) {\r\n        implFile = \"/\" + implFile;\r\n    }\r\n    this.implFile = implFile;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.readers.XmlInputReader.skipPast",
	"Comment": "skip characters until past the requested string.if it is not found, we are left at the end of the source with a result of false.",
	"Method": "boolean skipPast(String to){\r\n    boolean b;\r\n    char c;\r\n    int i;\r\n    int j;\r\n    int offset = 0;\r\n    int n = to.length();\r\n    char[] circle = new char[n];\r\n    for (i = 0; i < n; i += 1) {\r\n        c = next();\r\n        if (c == 0) {\r\n            return false;\r\n        }\r\n        circle[i] = c;\r\n    }\r\n    for (; ; ) {\r\n        j = offset;\r\n        b = true;\r\n        for (i = 0; i < n; i += 1) {\r\n            if (circle[j] != to.charAt(i)) {\r\n                b = false;\r\n                break;\r\n            }\r\n            j += 1;\r\n            if (j >= n) {\r\n                j -= n;\r\n            }\r\n        }\r\n        if (b) {\r\n            return true;\r\n        }\r\n        c = next();\r\n        if (c == 0) {\r\n            return false;\r\n        }\r\n        circle[offset] = c;\r\n        offset += 1;\r\n        if (offset >= n) {\r\n            offset -= n;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.getRules",
	"Comment": "return the rules implementation object containing ourrules collection and associated matching policy.if none has beenestablished, a default implementation will be created and returned.",
	"Method": "Rules getRules(){\r\n    if (this.rules == null) {\r\n        this.rules = new RulesBase();\r\n        this.rules.setDigester(this);\r\n    }\r\n    return (this.rules);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getContextPath",
	"Comment": "gets the portion of the request uri used to select the contextof the request.",
	"Method": "String getContextPath(String getContextPath,boolean maskDefaultContextMapping){\r\n    if (isDefaultContext && maskDefaultContextMapping) {\r\n        return \"\";\r\n    } else {\r\n        return contextPath;\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.resources.BaseDirContext.createSubcontext",
	"Comment": "creates and binds a new context, along with associated attributes.",
	"Method": "Context createSubcontext(Name name,Context createSubcontext,String name,DirContext createSubcontext,Name name,Attributes attrs,DirContext createSubcontext,String name,Attributes attrs){\r\n    return createSubcontext(name.toString(), attrs);\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ExtendedAccessLogValve.rotate",
	"Comment": "rename the existing log file to something else. then open theold log file name up once again. intended to be called by a jmxagent.",
	"Method": "boolean rotate(String newFileName){\r\n    if (currentLogFile != null) {\r\n        File holder = currentLogFile;\r\n        close();\r\n        try {\r\n            if (!holder.renameTo(new File(newFileName))) {\r\n                String msg = MessageFormat.format(rb.getString(LogFacade.FAILED_RENAME_LOG_FILE), newFileName);\r\n                log.log(Level.SEVERE, msg);\r\n            }\r\n        } catch (Throwable e) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.FAILED_RENAME_LOG_FILE), newFileName);\r\n            log.log(Level.SEVERE, msg, e);\r\n        }\r\n        currentDate = new Date();\r\n        fileDateFormatter = new ThreadLocal<SimpleDateFormat>() {\r\n            @Override\r\n            protected SimpleDateFormat initialValue() {\r\n                return new SimpleDateFormat(\"yyyy-MM-dd\");\r\n            }\r\n        };\r\n        dateStamp = dateFormatter.get().format(currentDate);\r\n        open();\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ExtendedAccessLogValve.rotate",
	"Comment": "rename the existing log file to something else. then open theold log file name up once again. intended to be called by a jmxagent.",
	"Method": "boolean rotate(String newFileName){\r\n    return new SimpleDateFormat(\"yyyy-MM-dd\");\r\n}"
}, {
	"Path": "org.glassfish.webservices.WsUtil.privilegedGetServiceRefWsdl",
	"Comment": "accessing wsdl url might involve file system access, so wrapoperation in a doprivileged block.",
	"Method": "URL privilegedGetServiceRefWsdl(ServiceReferenceDescriptor desc){\r\n    URL wsdlFileURL;\r\n    try {\r\n        final ServiceReferenceDescriptor serviceRef = desc;\r\n        wsdlFileURL = (URL) java.security.AccessController.doPrivileged(new java.security.PrivilegedExceptionAction() {\r\n            public java.lang.Object run() throws Exception {\r\n                URL retVal;\r\n                if (serviceRef.hasWsdlOverride()) {\r\n                    retVal = serviceRef.getWsdlOverride();\r\n                } else {\r\n                    if (serviceRef.getWsdlFileUrl() != null) {\r\n                        retVal = serviceRef.getWsdlFileUrl();\r\n                    } else {\r\n                        if (serviceRef.getWsdlFileUri().startsWith(\"http\")) {\r\n                            retVal = new URL(serviceRef.getWsdlFileUri());\r\n                        } else {\r\n                            if ((serviceRef.getWsdlFileUri().startsWith(\"WEB-INF\") || serviceRef.getWsdlFileUri().startsWith(\"META-INF\"))) {\r\n                                WebServiceContractImpl wscImpl = WebServiceContractImpl.getInstance();\r\n                                ServerEnvironment se = wscImpl.getServerEnvironment();\r\n                                File appFile = new File(se.getApplicationRepositoryPath(), serviceRef.getBundleDescriptor().getApplication().getAppName());\r\n                                if (appFile.exists()) {\r\n                                    retVal = new File(appFile, serviceRef.getWsdlFileUri()).toURL();\r\n                                } else {\r\n                                    retVal = Thread.currentThread().getContextClassLoader().getResource(serviceRef.getWsdlFileUri());\r\n                                }\r\n                            } else {\r\n                                retVal = new File(serviceRef.getWsdlFileUri()).toURL();\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n                return retVal;\r\n            }\r\n        });\r\n    } catch (PrivilegedActionException pae) {\r\n        logger.log(Level.WARNING, LogUtils.EXCEPTION_THROWN, pae);\r\n        Exception e = new Exception();\r\n        e.initCause(pae.getCause());\r\n        throw e;\r\n    }\r\n    return wsdlFileURL;\r\n}"
}, {
	"Path": "org.glassfish.webservices.WsUtil.privilegedGetServiceRefWsdl",
	"Comment": "accessing wsdl url might involve file system access, so wrapoperation in a doprivileged block.",
	"Method": "URL privilegedGetServiceRefWsdl(ServiceReferenceDescriptor desc){\r\n    URL retVal;\r\n    if (serviceRef.hasWsdlOverride()) {\r\n        retVal = serviceRef.getWsdlOverride();\r\n    } else {\r\n        if (serviceRef.getWsdlFileUrl() != null) {\r\n            retVal = serviceRef.getWsdlFileUrl();\r\n        } else {\r\n            if (serviceRef.getWsdlFileUri().startsWith(\"http\")) {\r\n                retVal = new URL(serviceRef.getWsdlFileUri());\r\n            } else {\r\n                if ((serviceRef.getWsdlFileUri().startsWith(\"WEB-INF\") || serviceRef.getWsdlFileUri().startsWith(\"META-INF\"))) {\r\n                    WebServiceContractImpl wscImpl = WebServiceContractImpl.getInstance();\r\n                    ServerEnvironment se = wscImpl.getServerEnvironment();\r\n                    File appFile = new File(se.getApplicationRepositoryPath(), serviceRef.getBundleDescriptor().getApplication().getAppName());\r\n                    if (appFile.exists()) {\r\n                        retVal = new File(appFile, serviceRef.getWsdlFileUri()).toURL();\r\n                    } else {\r\n                        retVal = Thread.currentThread().getContextClassLoader().getResource(serviceRef.getWsdlFileUri());\r\n                    }\r\n                } else {\r\n                    retVal = new File(serviceRef.getWsdlFileUri()).toURL();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return retVal;\r\n}"
}, {
	"Path": "org.apache.naming.resources.BaseDirContext.getAttributes",
	"Comment": "retrieves selected attributes associated with a named object.",
	"Method": "Attributes getAttributes(Name name,Attributes getAttributes,String name,Attributes getAttributes,Name name,String[] attrIds,Attributes getAttributes,String name,String[] attrIds){\r\n    return getAttributes(name.toString(), attrIds);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.createHttpUpgradeHandlerInstance",
	"Comment": "instantiates and injects the given httpupgradehandler class for thegiven webmodule",
	"Method": "T createHttpUpgradeHandlerInstance(WebModule module,Class<T> clazz){\r\n    validateJSR299Scope(clazz);\r\n    WebComponentInvocation inv = new WebComponentInvocation(module);\r\n    try {\r\n        invocationMgr.preInvoke(inv);\r\n        return injectionMgr.createManagedObject(clazz);\r\n    } finally {\r\n        invocationMgr.postInvoke(inv);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.mbean.AMXImplBase.preRegisterHook",
	"Comment": "this is an opportunity for a subclass to do initializationand optionally to modify the objectname one last time.",
	"Method": "ObjectName preRegisterHook(MBeanServer server,ObjectName selfObjectName){\r\n    return selfObjectName;\r\n}"
}, {
	"Path": "org.glassfish.internal.embedded.Server.getDeployer",
	"Comment": "returns the embedded deployer implementation, can be used togenerically deploy applications to the embedded server.",
	"Method": "EmbeddedDeployer getDeployer(){\r\n    return habitat.getService(EmbeddedDeployer.class);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.setMinProcessors",
	"Comment": "set the minimum number of processors to start at initialization.",
	"Method": "void setMinProcessors(int minProcessors){\r\n    this.minProcessors = minProcessors;\r\n    setProperty(\"minThreads\", String.valueOf(minProcessors));\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebResourceCollectionImpl.removeHttpMethod",
	"Comment": "removes the given http method from the collection of http methods.",
	"Method": "void removeHttpMethod(String httpMethod){\r\n    this.getHttpMethods().remove(httpMethod);\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.SSLAuthenticator.authenticate",
	"Comment": "authenticate the user by checking for the existence of a certificatechain, and optionally asking a trust manager to validate that we trustthis user.",
	"Method": "boolean authenticate(HttpRequest request,HttpResponse response,LoginConfig config){\r\n    Principal principal = ((HttpServletRequest) request.getRequest()).getUserPrincipal();\r\n    if (principal != null) {\r\n        if (debug >= 1) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.PRINCIPAL_BEEN_AUTHENTICATED_INFO), principal.getName());\r\n            log(msg);\r\n        }\r\n        return (true);\r\n    }\r\n    HttpServletResponse hres = (HttpServletResponse) response.getResponse();\r\n    if (debug >= 1)\r\n        log(rb.getString(LogFacade.LOOK_UP_CERTIFICATE_INFO));\r\n    X509Certificate[] certs = (X509Certificate[]) request.getRequest().getAttribute(Globals.CERTIFICATES_ATTR);\r\n    if ((certs == null) || (certs.length < 1)) {\r\n        certs = (X509Certificate[]) request.getRequest().getAttribute(Globals.SSL_CERTIFICATE_ATTR);\r\n    }\r\n    if ((certs == null) || (certs.length < 1)) {\r\n        if (debug >= 1)\r\n            log(rb.getString(LogFacade.NO_CERTIFICATE_INCLUDED_INFO));\r\n        hres.sendError(HttpServletResponse.SC_BAD_REQUEST);\r\n        response.setDetailMessage(rb.getString(LogFacade.NO_CLIENT_CERTIFICATE_CHAIN));\r\n        return (false);\r\n    }\r\n    principal = context.getRealm().authenticate(certs);\r\n    if (principal == null) {\r\n        if (debug >= 1)\r\n            log(\"Realm.authenticate() returned false\");\r\n        hres.sendError(HttpServletResponse.SC_UNAUTHORIZED);\r\n        response.setDetailMessage(rb.getString(LogFacade.CANNOT_AUTHENTICATE_WITH_CREDENTIALS));\r\n        return (false);\r\n    }\r\n    register(request, response, principal, Constants.CERT_METHOD, null, null);\r\n    String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);\r\n    if (ssoId != null) {\r\n        getSession(request, true);\r\n    }\r\n    return (true);\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.core.Util.typeFromName",
	"Comment": "generate the default mbean type from a string, eg from a classname.",
	"Method": "String typeFromName(String s){\r\n    if (s.indexOf(\"-\") >= 0) {\r\n        return s;\r\n    }\r\n    String simpleName = s;\r\n    final int idx = s.lastIndexOf(\".\");\r\n    if (idx >= 0) {\r\n        simpleName = s.substring(idx + 1);\r\n    }\r\n    return domConvertName(simpleName);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.web.GlassFishSingleSignOn.removeSession",
	"Comment": "remove a single session from a singlesignon.called whena session is timed out and no longer active.",
	"Method": "void removeSession(String ssoId,Session session){\r\n    if (logger.isLoggable(Level.FINE)) {\r\n        logger.log(Level.FINE, LogFacade.REMOVE_SESSION_FROM_SSO, new Object[] { session.toString(), ssoId });\r\n    }\r\n    SingleSignOnEntry entry = lookup(ssoId);\r\n    if (entry == null)\r\n        return;\r\n    entry.removeSession(session);\r\n    if (entry.isEmpty()) {\r\n        deregister(ssoId);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.CreateTransport.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    final ActionReport report = context.getActionReport();\r\n    NetworkConfig networkConfig = config.getNetworkConfig();\r\n    Transports transports = networkConfig.getTransports();\r\n    for (Transport transport : transports.getTransport()) {\r\n        if (transportName != null && transportName.equalsIgnoreCase(transport.getName())) {\r\n            report.setMessage(MessageFormat.format(rb.getString(LogFacade.CREATE_TRANSPORT_FAIL_DUPLICATE), transportName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<Transports>() {\r\n            public Object run(Transports param) throws PropertyVetoException, TransactionFailure {\r\n                boolean docrootAdded = false;\r\n                boolean accessLogAdded = false;\r\n                Transport newTransport = param.createChild(Transport.class);\r\n                newTransport.setName(transportName);\r\n                newTransport.setAcceptorThreads(acceptorThreads);\r\n                newTransport.setBufferSizeBytes(bufferSizeBytes);\r\n                newTransport.setByteBufferType(byteBufferType);\r\n                newTransport.setClassname(className);\r\n                newTransport.setDisplayConfiguration(displayConfiguration.toString());\r\n                newTransport.setEnableSnoop(enableSnoop.toString());\r\n                newTransport.setIdleKeyTimeoutSeconds(idleKeyTimeoutSeconds);\r\n                newTransport.setMaxConnectionsCount(maxConnectionsCount);\r\n                newTransport.setName(transportName);\r\n                newTransport.setReadTimeoutMillis(readTimeoutMillis);\r\n                newTransport.setSelectionKeyHandler(selectionKeyHandler);\r\n                newTransport.setSelectorPollTimeoutMillis(selectorPollTimeoutMillis);\r\n                newTransport.setWriteTimeoutMillis(writeTimeoutMillis);\r\n                newTransport.setTcpNoDelay(tcpNoDelay.toString());\r\n                param.getTransport().add(newTransport);\r\n                return newTransport;\r\n            }\r\n        }, transports);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.CREATE_TRANSPORT_FAIL), transportName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.CreateTransport.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    boolean docrootAdded = false;\r\n    boolean accessLogAdded = false;\r\n    Transport newTransport = param.createChild(Transport.class);\r\n    newTransport.setName(transportName);\r\n    newTransport.setAcceptorThreads(acceptorThreads);\r\n    newTransport.setBufferSizeBytes(bufferSizeBytes);\r\n    newTransport.setByteBufferType(byteBufferType);\r\n    newTransport.setClassname(className);\r\n    newTransport.setDisplayConfiguration(displayConfiguration.toString());\r\n    newTransport.setEnableSnoop(enableSnoop.toString());\r\n    newTransport.setIdleKeyTimeoutSeconds(idleKeyTimeoutSeconds);\r\n    newTransport.setMaxConnectionsCount(maxConnectionsCount);\r\n    newTransport.setName(transportName);\r\n    newTransport.setReadTimeoutMillis(readTimeoutMillis);\r\n    newTransport.setSelectionKeyHandler(selectionKeyHandler);\r\n    newTransport.setSelectorPollTimeoutMillis(selectorPollTimeoutMillis);\r\n    newTransport.setWriteTimeoutMillis(writeTimeoutMillis);\r\n    newTransport.setTcpNoDelay(tcpNoDelay.toString());\r\n    param.getTransport().add(newTransport);\r\n    return newTransport;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ContainerBase.getMappingObject",
	"Comment": "return an object which may be utilized for mapping to this component.",
	"Method": "Object getMappingObject(){\r\n    return this;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.Configuration.isLocalFactory",
	"Comment": "determines whether we hava a local factory or a remote factory.",
	"Method": "boolean isLocalFactory(){\r\n    boolean result = localFactory;\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.core.proxy.ProxyFactory.toProxyMap",
	"Comment": "resulting map could differ in size if some mbeans are no longerregistered",
	"Method": "Map<String, AMXProxy> toProxyMap(Map<String, ObjectName> objectNameMap,Map<String, AMXProxy> toProxyMap,ObjectName[] objectNames,Class<? extends AMXProxy> intf){\r\n    final Map<String, AMXProxy> resultMap = new HashMap<String, AMXProxy>();\r\n    for (final ObjectName objectName : objectNames) {\r\n        final String key = Util.unquoteIfNeeded(objectName.getKeyProperty(NAME_KEY));\r\n        final AMXProxy proxy = getProxy(objectName, intf);\r\n        if (proxy != null) {\r\n            resultMap.put(key, proxy);\r\n        }\r\n    }\r\n    return (resultMap);\r\n}"
}, {
	"Path": "org.glassfish.deployment.versioning.VersioningUtilsTest.testIsVersionExpression",
	"Comment": "test of isversionexpression method, of class versioningutils.",
	"Method": "void testIsVersionExpression(){\r\n    assertEquals(false, VersioningUtils.isVersionExpression(null));\r\n    assertEquals(false, VersioningUtils.isVersionExpression(APPLICATION_NAME));\r\n    assertEquals(true, VersioningUtils.isVersionExpression(APPLICATION_NAME + \":BETA\"));\r\n    assertEquals(true, VersioningUtils.isVersionExpression(APPLICATION_NAME + \"::\"));\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.FileValidator.validateConstraints",
	"Comment": "validates the given file against the current constraint set.",
	"Method": "void validateConstraints(File file){\r\n    final File f = FileUtils.safeGetCanonicalFile(file);\r\n    final String constriants = getConstraints();\r\n    char[] ca = constriants.toCharArray();\r\n    for (int i = 0; i < ca.length; i++) {\r\n        switch(ca[i]) {\r\n            case 'r':\r\n                if (!f.canRead()) {\r\n                    throw new InvalidConfigException(strMgr.getString(\"fileValidator.no_read\", f.getAbsolutePath()));\r\n                }\r\n                break;\r\n            case 'w':\r\n                if (!f.canWrite()) {\r\n                    throw new InvalidConfigException(strMgr.getString(\"fileValidator.no_write\", f.getAbsolutePath()));\r\n                }\r\n                break;\r\n            case 'd':\r\n                if (!f.isDirectory()) {\r\n                    throw new InvalidConfigException(strMgr.getString(\"fileValidator.not_a_dir\", f.getAbsolutePath()));\r\n                }\r\n                break;\r\n            case 'x':\r\n                break;\r\n            default:\r\n                break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getSessionCookieName",
	"Comment": "gets the name that will be assigned to any session trackingcookies created on behalf of this context",
	"Method": "String getSessionCookieName(){\r\n    return sessionCookieName;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ContainerBase.setResources",
	"Comment": "set the resources dircontext object with which this container isassociated.",
	"Method": "void setResources(DirContext resources){\r\n    DirContext oldResources;\r\n    try {\r\n        writeLock.lock();\r\n        oldResources = this.resources;\r\n        if (oldResources == resources)\r\n            return;\r\n        Hashtable<String, String> env = new Hashtable<String, String>();\r\n        if (getParent() != null)\r\n            env.put(ProxyDirContext.HOST, getParent().getName());\r\n        env.put(ProxyDirContext.CONTEXT, getName());\r\n        this.resources = new ProxyDirContext(env, resources);\r\n    } finally {\r\n        writeLock.unlock();\r\n    }\r\n    support.firePropertyChange(\"resources\", oldResources, this.resources);\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.OrderingDescriptor.isCircleWithOthersAndNoRemaining",
	"Comment": "this method will check whether the graph does not have remaining verticesand is a circle with others. it return the sorted result in sortednodes.",
	"Method": "boolean isCircleWithOthersAndNoRemaining(List<Node> graph,boolean hasRemaining,List<Node> sortedNodes){\r\n    boolean circleWithOthersAndNoRemaining = false;\r\n    int size = graph.size();\r\n    if (size == 0 || hasRemaining) {\r\n        return circleWithOthersAndNoRemaining;\r\n    }\r\n    Node nextNode = graph.get(size - 1);\r\n    if (nextNode.isOthers()) {\r\n        Set<Node> set = new LinkedHashSet<Node>();\r\n        int count = 0;\r\n        while ((count < size) && nextNode.getOutEdges().size() == 1 && nextNode.getInEdges().size() == 1) {\r\n            if (!set.add(nextNode)) {\r\n                break;\r\n            }\r\n            nextNode = nextNode.getOutEdges().iterator().next().getToNode();\r\n            count++;\r\n        }\r\n        if (set.size() == size) {\r\n            circleWithOthersAndNoRemaining = true;\r\n            Iterator<Node> iter = set.iterator();\r\n            if (iter.hasNext()) {\r\n                iter.next();\r\n            }\r\n            while (iter.hasNext()) {\r\n                sortedNodes.add(iter.next());\r\n            }\r\n        }\r\n    }\r\n    return circleWithOthersAndNoRemaining;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.DelegatedTimeoutManager.timeLeft",
	"Comment": "returns the amount of time left before the given transaction times out.",
	"Method": "long timeLeft(Long localTID){\r\n    DelegatedTimeoutInfo timeoutInfo = (DelegatedTimeoutInfo) pendingTimeouts.get(localTID);\r\n    if (timeoutInfo == null)\r\n        timeoutInfo = (DelegatedTimeoutInfo) indoubtTimeouts.get(localTID);\r\n    long result = -1;\r\n    if (timeoutInfo != null) {\r\n        result = timeoutInfo.expireTime - new Date().getTime();\r\n        if (result < 0) {\r\n            result = 0;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.naming.factory.MailSessionFactory.getObjectInstance",
	"Comment": "create and return an object instance based on the specifiedcharacteristics.",
	"Method": "Object getObjectInstance(Object refObj,Name name,Context context,Hashtable<?, ?> env){\r\n    final Reference ref = (Reference) refObj;\r\n    if (!ref.getClassName().equals(factoryType))\r\n        return (null);\r\n    return AccessController.doPrivileged(new PrivilegedAction<Session>() {\r\n        public Session run() {\r\n            Properties props = new Properties();\r\n            props.put(\"mail.transport.protocol\", \"smtp\");\r\n            props.put(\"mail.smtp.host\", \"localhost\");\r\n            Enumeration<RefAddr> attrs = ref.getAll();\r\n            while (attrs.hasMoreElements()) {\r\n                RefAddr attr = attrs.nextElement();\r\n                if (\"factory\".equals(attr.getType()))\r\n                    continue;\r\n                props.put(attr.getType(), attr.getContent());\r\n            }\r\n            Session session = Session.getInstance(props, null);\r\n            return (session);\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.apache.naming.factory.MailSessionFactory.getObjectInstance",
	"Comment": "create and return an object instance based on the specifiedcharacteristics.",
	"Method": "Object getObjectInstance(Object refObj,Name name,Context context,Hashtable<?, ?> env){\r\n    Properties props = new Properties();\r\n    props.put(\"mail.transport.protocol\", \"smtp\");\r\n    props.put(\"mail.smtp.host\", \"localhost\");\r\n    Enumeration<RefAddr> attrs = ref.getAll();\r\n    while (attrs.hasMoreElements()) {\r\n        RefAddr attr = attrs.nextElement();\r\n        if (\"factory\".equals(attr.getType()))\r\n            continue;\r\n        props.put(attr.getType(), attr.getContent());\r\n    }\r\n    Session session = Session.getInstance(props, null);\r\n    return (session);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.FilterClassImplementsValidInterface.runIndividualFilterTest",
	"Comment": "run the verifier test against a declared individual filter class",
	"Method": "boolean runIndividualFilterTest(Result result,Class filterClass){\r\n    if (filterClass == null) {\r\n        return false;\r\n    }\r\n    return testImplementationOf(filterClass, \"javax.servlet.Filter\", result);\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.DeleteHttpListener.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    ActionReport report = context.getActionReport();\r\n    networkConfig = config.getNetworkConfig();\r\n    if (!exists()) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.DELETE_HTTP_LISTENER_NOT_EXISTS), listenerId));\r\n        report.setActionExitCode(ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        NetworkListener ls = networkConfig.getNetworkListener(listenerId);\r\n        final String name = ls.getProtocol();\r\n        VirtualServer vs = config.getHttpService().getVirtualServerByName(ls.findHttpProtocol().getHttp().getDefaultVirtualServer());\r\n        ConfigSupport.apply(new DeleteNetworkListener(), networkConfig.getNetworkListeners());\r\n        ConfigSupport.apply(new UpdateVirtualServer(), vs);\r\n        cleanUp(name);\r\n        report.setActionExitCode(ExitCode.SUCCESS);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.DELETE_HTTP_LISTENER_FAIL), listenerId));\r\n        report.setActionExitCode(ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.setXmlNamespaceAware",
	"Comment": "set the namespace aware feature of the xml parser used whenparsing xml instances.",
	"Method": "void setXmlNamespaceAware(boolean xmlNamespaceAware){\r\n    this.xmlNamespaceAware = xmlNamespaceAware;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getFilterRegistration",
	"Comment": "gets the filterregistration corresponding to the filter with thegiven filtername.",
	"Method": "FilterRegistration getFilterRegistration(String filterName){\r\n    return filterRegisMap.get(filterName);\r\n}"
}, {
	"Path": "org.glassfish.api.admin.AdminCommandLock.getLockMessage",
	"Comment": "get the message to be returned if the lock could not be acquired.",
	"Method": "String getLockMessage(){\r\n    return lockMessage;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.removeWatchedResources",
	"Comment": "clears any watched resources defined for this web application.",
	"Method": "void removeWatchedResources(){\r\n    synchronized (watchedResources) {\r\n        if (notifyContainerListeners) {\r\n            Iterator<String> i = watchedResources.iterator();\r\n            while (i.hasNext()) {\r\n                fireContainerEvent(\"removeWatchedResource\", i.next());\r\n            }\r\n        }\r\n        watchedResources.clear();\r\n    }\r\n}"
}, {
	"Path": "com.sun.appserv.web.cache.filter.CachingResponseWrapper.createCachingOutputStreamWrapper",
	"Comment": "create and return a servletoutputstream to write the contentassociated with this response.",
	"Method": "CachingOutputStreamWrapper createCachingOutputStreamWrapper(){\r\n    return new CachingOutputStreamWrapper();\r\n}"
}, {
	"Path": "org.apache.catalina.core.NamingContextListener.addEnvironment",
	"Comment": "set the specified environment entries in the naming context.",
	"Method": "void addEnvironment(ContextEnvironment env){\r\n    Object value = null;\r\n    String type = env.getType();\r\n    try {\r\n        if (type.equals(\"java.lang.String\")) {\r\n            value = env.getValue();\r\n        } else if (type.equals(\"java.lang.Byte\")) {\r\n            if (env.getValue() == null) {\r\n                value = Byte.valueOf((byte) 0);\r\n            } else {\r\n                value = Byte.decode(env.getValue());\r\n            }\r\n        } else if (type.equals(\"java.lang.Short\")) {\r\n            if (env.getValue() == null) {\r\n                value = Short.valueOf((short) 0);\r\n            } else {\r\n                value = Short.decode(env.getValue());\r\n            }\r\n        } else if (type.equals(\"java.lang.Integer\")) {\r\n            if (env.getValue() == null) {\r\n                value = Integer.valueOf(0);\r\n            } else {\r\n                value = Integer.decode(env.getValue());\r\n            }\r\n        } else if (type.equals(\"java.lang.Long\")) {\r\n            if (env.getValue() == null) {\r\n                value = Long.valueOf(0);\r\n            } else {\r\n                value = Long.decode(env.getValue());\r\n            }\r\n        } else if (type.equals(\"java.lang.Boolean\")) {\r\n            value = Boolean.valueOf(env.getValue());\r\n        } else if (type.equals(\"java.lang.Double\")) {\r\n            if (env.getValue() == null) {\r\n                value = Double.valueOf(0);\r\n            } else {\r\n                value = Double.valueOf(env.getValue());\r\n            }\r\n        } else if (type.equals(\"java.lang.Float\")) {\r\n            if (env.getValue() == null) {\r\n                value = Float.valueOf(0);\r\n            } else {\r\n                value = Float.valueOf(env.getValue());\r\n            }\r\n        } else if (type.equals(\"java.lang.Character\")) {\r\n            if (env.getValue() == null) {\r\n                value = Character.valueOf((char) 0);\r\n            } else {\r\n                if (env.getValue().length() == 1) {\r\n                    value = Character.valueOf(env.getValue().charAt(0));\r\n                } else {\r\n                    throw new IllegalArgumentException();\r\n                }\r\n            }\r\n        } else {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.ENV_ENTRY_INVALID_TYPE), env.getName());\r\n            log(msg);\r\n        }\r\n    } catch (NumberFormatException e) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.ENV_ENTRY_INVALID_VALUE), env.getName());\r\n        log(msg);\r\n    } catch (IllegalArgumentException e) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.ENV_ENTRY_INVALID_VALUE), env.getName());\r\n        log(msg);\r\n    }\r\n    if (value != null) {\r\n        try {\r\n            if (debug >= 2)\r\n                log(\"  Adding environment entry \" + env.getName());\r\n            createSubcontexts(envCtx, env.getName());\r\n            envCtx.bind(env.getName(), value);\r\n        } catch (NamingException e) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.ENV_ENTRY_INVALID_VALUE), env.getName());\r\n            log(msg);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.LocalInstanceCommand.matchingHostnames",
	"Comment": "check if two hostnames refer to the same host. we start with a cheapstring comparison. if that fails we see if the hostnames refer to thesame host.",
	"Method": "boolean matchingHostnames(String host1,String host2){\r\n    if (!StringUtils.ok(host1) || !StringUtils.ok(host2)) {\r\n        if (!StringUtils.ok(host1) && !StringUtils.ok(host2)) {\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n    if (host1.equalsIgnoreCase(host2)) {\r\n        return true;\r\n    }\r\n    if (NetUtils.isEqual(host1, host2)) {\r\n        return true;\r\n    }\r\n    if (NetUtils.isThisHostLocal(host1) && NetUtils.isThisHostLocal(host2)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.catalina.session.ManagerBase.getName",
	"Comment": "return the descriptive short name of this manager implementation.",
	"Method": "String getName(){\r\n    return (name);\r\n}"
}, {
	"Path": "org.apache.catalina.session.PersistentManagerBase.getMaxIdleSwap",
	"Comment": "the time in seconds after which a session should be swapped out ofmemory to disk.",
	"Method": "int getMaxIdleSwap(){\r\n    return maxIdleSwap;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.SessionTracker.getSessionId",
	"Comment": "gets the id of the sessions that are being tracked.notice that since all sessions are associated with the same request,albeit in different context, they all share the same id.",
	"Method": "String getSessionId(){\r\n    return trackedSessionId;\r\n}"
}, {
	"Path": "org.apache.catalina.realm.RealmBase.hasResourcePermission",
	"Comment": "perform access control based on the specified authorization constraint.return true if this constraint is satisfied and processingshould continue, or false otherwise.",
	"Method": "boolean hasResourcePermission(HttpRequest request,HttpResponse response,SecurityConstraint[] constraints,Context context){\r\n    if (constraints == null || constraints.length == 0)\r\n        return (true);\r\n    Principal principal = ((HttpServletRequest) request.getRequest()).getUserPrincipal();\r\n    for (int i = 0; i < constraints.length; i++) {\r\n        SecurityConstraint constraint = constraints[i];\r\n        String[] roles = constraint.findAuthRoles();\r\n        if (roles == null)\r\n            roles = new String[0];\r\n        if (constraint.getAllRoles())\r\n            return (true);\r\n        if (log.isLoggable(Level.FINE))\r\n            log.log(Level.FINE, \"  Checking roles \" + principal);\r\n        if (roles.length == 0) {\r\n            if (constraint.getAuthConstraint()) {\r\n                ((HttpServletResponse) response.getResponse()).sendError(HttpServletResponse.SC_FORBIDDEN);\r\n                response.setDetailMessage(rb.getString(LogFacade.ACCESS_RESOURCE_DENIED));\r\n                if (log.isLoggable(Level.FINE))\r\n                    log.log(Level.FINE, \"No roles \");\r\n                return (false);\r\n            } else {\r\n                if (log.isLoggable(Level.FINE)) {\r\n                    log.log(Level.FINE, \"Passing all access\");\r\n                }\r\n                return (true);\r\n            }\r\n        } else if (principal == null) {\r\n            if (log.isLoggable(Level.FINE))\r\n                log.log(Level.FINE, \"  No user authenticated, cannot grant access\");\r\n            ((HttpServletResponse) response.getResponse()).sendError(HttpServletResponse.SC_FORBIDDEN);\r\n            response.setDetailMessage(rb.getString(LogFacade.CONFIG_ERROR_NOT_AUTHENTICATED));\r\n            return (false);\r\n        }\r\n        for (int j = 0; j < roles.length; j++) {\r\n            if (hasRole(principal, roles[j])) {\r\n                if (log.isLoggable(Level.FINE))\r\n                    log.log(Level.FINE, \"Role found:  \" + roles[j]);\r\n                return (true);\r\n            } else {\r\n                if (log.isLoggable(Level.FINE))\r\n                    log.log(Level.FINE, \"No role found:  \" + roles[j]);\r\n            }\r\n        }\r\n    }\r\n    ((HttpServletResponse) response.getResponse()).sendError(HttpServletResponse.SC_FORBIDDEN);\r\n    response.setDetailMessage(rb.getString(LogFacade.ACCESS_RESOURCE_DENIED));\r\n    return (false);\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.FilterDef.addInitParameter",
	"Comment": "adds the initialization parameter with the given name and valueon this filter.if an init param with the given name already exists, its valuewill be overridden.",
	"Method": "void addInitParameter(String name,String value){\r\n    setInitParameter(name, value, true);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.getErrorReportValveClass",
	"Comment": "return the java class name of the error report valve classfor new web applications.",
	"Method": "String getErrorReportValveClass(){\r\n    return (this.errorReportValveClass);\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.peek",
	"Comment": "return the top object on the stack without removing it.if there areno objects on the stack, return null.",
	"Method": "Object peek(Object peek,int n,Object peek,String stackName){\r\n    Object result = null;\r\n    ArrayStack<Object> namedStack = stacksByName.get(stackName);\r\n    if (namedStack == null) {\r\n        if (log.isLoggable(Level.FINE)) {\r\n            log.log(Level.FINE, \"Stack '\" + stackName + \"' is empty\");\r\n        }\r\n        throw new EmptyStackException();\r\n    } else {\r\n        result = namedStack.peek();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.clearParameters",
	"Comment": "clear the collection of parameters associated with this requestand reset the query string encoding charset.",
	"Method": "void clearParameters(){\r\n    coyoteRequest.getParameters().recycle();\r\n    coyoteRequest.getParameters().setQueryStringEncoding(Charsets.lookupCharset(getConnector().getURIEncoding()));\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.CompositeResource.getResponse",
	"Comment": "convenience methods for creating responses from response bodies",
	"Method": "Response getResponse(ResponseBody responseBody,Response getResponse,Status status,ResponseBody responseBody){\r\n    return Response.status(status).entity(responseBody).build();\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.LocalInstanceCommand.isDirectory",
	"Comment": "override this method if your class does not want commandexception thrownif directory does not exist.",
	"Method": "boolean isDirectory(File f){\r\n    return f.isDirectory();\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.createListener",
	"Comment": "instantiates the given eventlistener class and performs anyrequired resource injection into the new eventlistener instancebefore returning it.",
	"Method": "T createListener(Class<T> clazz){\r\n    if (isRestricted) {\r\n        throw new UnsupportedOperationException(rb.getString(LogFacade.UNSUPPORTED_OPERATION_EXCEPTION));\r\n    }\r\n    return context.createListener(clazz);\r\n}"
}, {
	"Path": "com.sun.enterprise.glassfish.bootstrap.osgi.BundleProvisioner.discoverJars",
	"Comment": "goes through the list of uris configured via the config properties and converst them intobundle jar objects. it delegates to the customizer to discover the bundle jars.",
	"Method": "List<Jar> discoverJars(){\r\n    List<Jar> jars = new ArrayList<Jar>();\r\n    for (URI uri : getAutoInstallLocations()) {\r\n        jars.add(new Jar(uri));\r\n    }\r\n    return jars;\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.getNote",
	"Comment": "return the object bound with the specified name to the internal notesfor this session, or null if no such binding exists.",
	"Method": "Object getNote(String name){\r\n    return (notes.get(name));\r\n}"
}, {
	"Path": "org.glassfish.api.invocation.ComponentInvocation.setRegistryFor",
	"Comment": "associate given registry with given key for this invocation",
	"Method": "void setRegistryFor(Class key,Object payLoad){\r\n    if (registry == null) {\r\n        registry = new HashMap<Class, Object>();\r\n    }\r\n    registry.put(key, payLoad);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.session.SessionCookieConfig.getComment",
	"Comment": "return the urlencoded form of the comment that identifies the sessioncookie.",
	"Method": "String getComment(){\r\n    return _comment;\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.findClass",
	"Comment": "find the specified class in our local repositories, if possible.ifnot found, throw classnotfoundexception.",
	"Method": "Class<?> findClass(String name){\r\n    if (logger.isLoggable(Level.FINER))\r\n        logger.log(Level.FINER, \"    findClass(\" + name + \")\");\r\n    if (securityManager != null && packageDefinitionEnabled) {\r\n        int i = name.lastIndexOf('.');\r\n        if (i >= 0) {\r\n            try {\r\n                if (logger.isLoggable(Level.FINER))\r\n                    logger.log(Level.FINER, \"      securityManager.checkPackageDefinition\");\r\n                securityManager.checkPackageDefinition(name.substring(0, i));\r\n            } catch (Exception se) {\r\n                if (logger.isLoggable(Level.FINER))\r\n                    logger.log(Level.FINER, \"      -->Exception-->ClassNotFoundException\", se);\r\n                throw new ClassNotFoundException(name, se);\r\n            }\r\n        }\r\n    }\r\n    Class<?> clazz = null;\r\n    try {\r\n        if (logger.isLoggable(Level.FINER))\r\n            logger.log(Level.FINER, \"      findClassInternal(\" + name + \")\");\r\n        try {\r\n            ResourceEntry entry = findClassInternal(name);\r\n            CodeSource codeSource = new CodeSource(entry.codeBase, entry.certificates);\r\n            synchronized (this) {\r\n                if (entry.loadedClass == null) {\r\n                    byte[] binaryContent = entry.binaryContent;\r\n                    if (!byteCodePreprocessors.isEmpty()) {\r\n                        String resourceName = name.replace('.', '/') + \".class\";\r\n                        for (BytecodePreprocessor preprocessor : byteCodePreprocessors) {\r\n                            binaryContent = preprocessor.preprocess(resourceName, binaryContent);\r\n                        }\r\n                    }\r\n                    clazz = defineClass(name, binaryContent, 0, binaryContent.length, codeSource);\r\n                    entry.loadedClass = clazz;\r\n                    entry.binaryContent = null;\r\n                    entry.source = null;\r\n                    entry.codeBase = null;\r\n                    entry.manifest = null;\r\n                    entry.certificates = null;\r\n                } else {\r\n                    clazz = entry.loadedClass;\r\n                }\r\n            }\r\n        } catch (ClassNotFoundException cnfe) {\r\n            if (!hasExternalRepositories) {\r\n                throw cnfe;\r\n            }\r\n        } catch (UnsupportedClassVersionError ucve) {\r\n            throw new UnsupportedClassVersionError(getString(LogFacade.UNSUPPORTED_VERSION, name, getJavaVersion()));\r\n        } catch (AccessControlException ace) {\r\n            if (logger.isLoggable(Level.WARNING)) {\r\n                logger.log(Level.WARNING, LogFacade.FIND_CLASS_INTERNAL_SECURITY_EXCEPTION, new Object[] { name, ace.getMessage() });\r\n            }\r\n            throw new ClassNotFoundException(name, ace);\r\n        } catch (RuntimeException rex) {\r\n            throw rex;\r\n        } catch (Error err) {\r\n            throw err;\r\n        } catch (Throwable t) {\r\n            throw new RuntimeException(getString(LogFacade.UNABLE_TO_LOAD_CLASS, name, t.toString()), t);\r\n        }\r\n        if ((clazz == null) && hasExternalRepositories) {\r\n            try {\r\n                clazz = super.findClass(name);\r\n            } catch (AccessControlException ace) {\r\n                if (logger.isLoggable(Level.WARNING)) {\r\n                    String msg = getString(LogFacade.FIND_CLASS_INTERNAL_SECURITY_EXCEPTION, new Object[] { name, ace.getMessage() });\r\n                    logger.log(Level.WARNING, msg, ace);\r\n                }\r\n                throw new ClassNotFoundException(name, ace);\r\n            } catch (RuntimeException e) {\r\n                if (logger.isLoggable(Level.FINER))\r\n                    logger.log(Level.FINER, \"      -->RuntimeException Rethrown\", e);\r\n                throw e;\r\n            }\r\n        }\r\n        if (clazz == null) {\r\n            if (logger.isLoggable(Level.FINER))\r\n                logger.log(Level.FINER, \"    --> Returning ClassNotFoundException\");\r\n            throw new ClassNotFoundException(name);\r\n        }\r\n    } catch (ClassNotFoundException e) {\r\n        if (logger.isLoggable(Level.FINER))\r\n            logger.log(Level.FINER, \"    --> Passing on ClassNotFoundException\");\r\n        throw e;\r\n    }\r\n    if (logger.isLoggable(Level.FINER))\r\n        logger.log(Level.FINER, \"      Returning class \" + clazz);\r\n    if (logger.isLoggable(Level.FINER)) {\r\n        ClassLoader cl;\r\n        if (securityManager != null) {\r\n            cl = AccessController.doPrivileged(new PrivilegedGetClassLoader(clazz));\r\n        } else {\r\n            cl = clazz.getClassLoader();\r\n        }\r\n        logger.log(Level.FINER, \"      Loaded by \" + cl);\r\n    }\r\n    return (clazz);\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ReplicationStore.updateLastAccessTime",
	"Comment": "update the lastaccess time of the specified session into this store.",
	"Method": "void updateLastAccessTime(Session session){\r\n    if (!(session instanceof BaseHASession)) {\r\n        return;\r\n    }\r\n    BackingStore<String, ? extends Storeable> backingStore = getStoreableBackingStore();\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"ReplicationStore>>updateLastAccessTime: replicator: \" + backingStore);\r\n    }\r\n    try {\r\n        String time = backingStore.updateTimestamp(session.getIdInternal(), \"\" + session.getVersion(), ((BaseHASession) session).getLastAccessedTimeInternal());\r\n    } catch (BackingStoreException ex) {\r\n    }\r\n}"
}, {
	"Path": "components.components.ScrollerComponent.getAnchorAttrs",
	"Comment": "build and return the string consisting of the attibutes for aresult set navigation link anchor.",
	"Method": "String getAnchorAttrs(FacesContext context,String clientId,int action){\r\n    int currentPage = 1;\r\n    int formNumber = getFormNumber(context);\r\n    Integer curPage = (Integer) getAttributes().get(\"currentPage\");\r\n    if (curPage != null) {\r\n        currentPage = curPage.intValue();\r\n    }\r\n    String result = \"href=\\\"#\\\" \" + \"onmousedown=\\\"\" + \"document.forms[\" + formNumber + \"]['\" + clientId + \"_action'].value='\" + action + \"'; \" + \"document.forms[\" + formNumber + \"]['\" + clientId + \"_curPage'].value='\" + currentPage + \"'; \" + \"document.forms[\" + formNumber + \"].submit()\\\"\";\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.diagnostics.context.impl.ContextImplUnitTest.testConstructorsLocation",
	"Comment": "test that the location field of contextimpl uses the location object used at construction and that the location returned from the contextimpl does not then change over the lifetime of the contextimpl.",
	"Method": "void testConstructorsLocation(Location mockedLocation,View mockedView){\r\n    final String mockedLocationIdReturnValue = \"mockedLocationIdReturnValue\";\r\n    final String mockedOriginReturnValue = \"mockedOriginReturnValue\";\r\n    new MockUp<Location>() {\r\n        @Mock\r\n        public String getLocationId() {\r\n            return mockedLocationIdReturnValue;\r\n        }\r\n        @Mock\r\n        public String getOrigin() {\r\n            return mockedOriginReturnValue;\r\n        }\r\n    };\r\n    ContextImpl contextImpl = new ContextImpl(mockedView, mockedLocation);\r\n    Location location1 = contextImpl.getLocation();\r\n    Assert.assertSame(\"Location from contextImpl.getLocation() should be the instance passed in on construction.\", mockedLocation, location1);\r\n    Location location2 = contextImpl.getLocation();\r\n    Assert.assertSame(\"Location from contextImpl.getLocation() should still be the instance passed in on construction.\", mockedLocation, location2);\r\n}"
}, {
	"Path": "org.glassfish.diagnostics.context.impl.ContextImplUnitTest.testConstructorsLocation",
	"Comment": "test that the location field of contextimpl uses the location object used at construction and that the location returned from the contextimpl does not then change over the lifetime of the contextimpl.",
	"Method": "void testConstructorsLocation(Location mockedLocation,View mockedView){\r\n    return mockedLocationIdReturnValue;\r\n}"
}, {
	"Path": "org.glassfish.diagnostics.context.impl.ContextImplUnitTest.testConstructorsLocation",
	"Comment": "test that the location field of contextimpl uses the location object used at construction and that the location returned from the contextimpl does not then change over the lifetime of the contextimpl.",
	"Method": "void testConstructorsLocation(Location mockedLocation,View mockedView){\r\n    return mockedOriginReturnValue;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationHttpRequest.initSpecialAttributes",
	"Comment": "initializes the special attributes of this request wrapper.",
	"Method": "void initSpecialAttributes(String requestUri,String contextPath,String servletPath,String pathInfo,String queryString){\r\n    specialAttributes = new HashMap<String, Object>(5);\r\n    HttpServletMapping originalMapping;\r\n    switch(dispatcherType) {\r\n        case INCLUDE:\r\n            specialAttributes.put(RequestDispatcher.INCLUDE_REQUEST_URI, requestUri);\r\n            specialAttributes.put(RequestDispatcher.INCLUDE_CONTEXT_PATH, contextPath);\r\n            specialAttributes.put(RequestDispatcher.INCLUDE_SERVLET_PATH, servletPath);\r\n            specialAttributes.put(RequestDispatcher.INCLUDE_MAPPING, mappingForDispatch);\r\n            specialAttributes.put(RequestDispatcher.INCLUDE_PATH_INFO, pathInfo);\r\n            specialAttributes.put(RequestDispatcher.INCLUDE_QUERY_STRING, queryString);\r\n            break;\r\n        case FORWARD:\r\n        case ERROR:\r\n            specialAttributes.put(RequestDispatcher.FORWARD_REQUEST_URI, requestUri);\r\n            specialAttributes.put(RequestDispatcher.FORWARD_CONTEXT_PATH, contextPath);\r\n            specialAttributes.put(RequestDispatcher.FORWARD_SERVLET_PATH, servletPath);\r\n            specialAttributes.put(RequestDispatcher.FORWARD_PATH_INFO, pathInfo);\r\n            specialAttributes.put(RequestDispatcher.FORWARD_QUERY_STRING, queryString);\r\n            originalMapping = ((HttpServletRequest) getRequest()).getHttpServletMapping();\r\n            specialAttributes.put(RequestDispatcher.FORWARD_MAPPING, originalMapping);\r\n            break;\r\n        case ASYNC:\r\n            specialAttributes.put(AsyncContext.ASYNC_REQUEST_URI, requestUri);\r\n            specialAttributes.put(AsyncContext.ASYNC_CONTEXT_PATH, contextPath);\r\n            specialAttributes.put(AsyncContext.ASYNC_SERVLET_PATH, servletPath);\r\n            originalMapping = ((HttpServletRequest) getRequest()).getHttpServletMapping();\r\n            specialAttributes.put(AsyncContext.ASYNC_MAPPING, originalMapping);\r\n            specialAttributes.put(AsyncContext.ASYNC_PATH_INFO, pathInfo);\r\n            specialAttributes.put(AsyncContext.ASYNC_QUERY_STRING, queryString);\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.JDBCStore.load",
	"Comment": "load the session associated with the id id.if no such session is found null is returned.",
	"Method": "Session load(String id){\r\n    ResultSet rst = null;\r\n    StandardSession _session = null;\r\n    Loader loader = null;\r\n    ClassLoader classLoader = null;\r\n    ObjectInputStream ois = null;\r\n    BufferedInputStream bis = null;\r\n    Container container = manager.getContainer();\r\n    String loadSql = \"SELECT \" + sessionIdCol + \", \" + sessionDataCol + \" FROM \" + sessionTable + \" WHERE \" + sessionIdCol + \" = ? AND \" + sessionAppCol + \" = ?\";\r\n    synchronized (this) {\r\n        Connection _conn = getConnection();\r\n        if (_conn == null) {\r\n            return (null);\r\n        }\r\n        try {\r\n            if (preparedLoadSql == null) {\r\n                preparedLoadSql = _conn.prepareStatement(loadSql);\r\n            }\r\n            preparedLoadSql.setString(1, id);\r\n            preparedLoadSql.setString(2, getName());\r\n            rst = preparedLoadSql.executeQuery();\r\n            if (rst.next()) {\r\n                bis = new BufferedInputStream(rst.getBinaryStream(2));\r\n                if (container != null) {\r\n                    loader = container.getLoader();\r\n                }\r\n                if (loader != null) {\r\n                    classLoader = loader.getClassLoader();\r\n                }\r\n                if (classLoader != null) {\r\n                    ois = new CustomObjectInputStream(bis, classLoader);\r\n                } else {\r\n                    ois = new ObjectInputStream(bis);\r\n                }\r\n                if (debug > 0) {\r\n                    String msg = MessageFormat.format(rb.getString(LogFacade.LOADING_SESSION_FROM_DATABASE), new Object[] { id, sessionTable });\r\n                    log(msg);\r\n                }\r\n                _session = StandardSession.deserialize(ois, manager);\r\n                _session.setManager(manager);\r\n            } else if (debug > 0) {\r\n                log(getStoreName() + \": No persisted data object found\");\r\n            }\r\n        } catch (SQLException e) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.SQL_ERROR), e);\r\n            log(msg);\r\n        } finally {\r\n            try {\r\n                if (rst != null) {\r\n                    rst.close();\r\n                }\r\n            } catch (SQLException e) {\r\n            }\r\n            if (ois != null) {\r\n                try {\r\n                    ois.close();\r\n                } catch (IOException e) {\r\n                }\r\n            }\r\n            release(_conn);\r\n        }\r\n    }\r\n    return (_session);\r\n}"
}, {
	"Path": "org.glassfish.cdi.hk2.HK2IntegrationExtension.injectionTargetObserver",
	"Comment": "called by cdi, gathers up all of the injection points known to hk2.",
	"Method": "void injectionTargetObserver(ProcessInjectionTarget<T> pit){\r\n    if (locator == null)\r\n        return;\r\n    InjectionTarget<?> injectionTarget = pit.getInjectionTarget();\r\n    Set<InjectionPoint> injectionPoints = injectionTarget.getInjectionPoints();\r\n    for (InjectionPoint injectionPoint : injectionPoints) {\r\n        Injectee injectee = HK2IntegrationUtilities.convertInjectionPointToInjectee(injectionPoint);\r\n        ActiveDescriptor<?> descriptor = locator.getInjecteeDescriptor(injectee);\r\n        if (descriptor == null || descriptor.getServiceId() == null)\r\n            continue;\r\n        foundWithHK2.put(descriptor.getServiceId(), descriptor);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.CheckMgr.getBundleDescriptor",
	"Comment": "ejbcheckmgrimpl, webserviceclientcheckmgrimpl and webservicecheckmgrimplclasses override this method. for each of these areas the tests are runon descriptors rather than bundle descriptors.",
	"Method": "BundleDescriptor getBundleDescriptor(Descriptor descriptor){\r\n    return (BundleDescriptor) descriptor;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.OutputBuffer.addSessionCookieWithJvmRoute",
	"Comment": "adds jsessionid cookie whose value includes jvmroute if necessary.",
	"Method": "void addSessionCookieWithJvmRoute(Request request,StandardContext ctx,Session sess){\r\n    if (ctx.getJvmRoute() == null || sess == null) {\r\n        return;\r\n    }\r\n    Cookie cookie = getSafeCookie(ctx.getSessionCookieName(), sess.getIdInternal() + \".\" + ctx.getJvmRoute());\r\n    request.configureSessionCookie(cookie);\r\n    grizzlyResponse.addHeader(SET_COOKIE_HEADER, response.getCookieString(cookie));\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.TransactionSynchronizationRegistryImpl.getResource",
	"Comment": "get an object from the map of resources being managed forthe current transaction. the key must have been supplied earlierby a call to putresouce in the same transaction. if the key cannot be found in the current resource map, null is returned.",
	"Method": "Object getResource(Object key){\r\n    try {\r\n        JavaEETransactionImpl tran = (JavaEETransactionImpl) transactionManager.getTransaction();\r\n        if (tran == null)\r\n            throw new IllegalStateException(sm.getString(\"enterprise_distributedtx.no_transaction\"));\r\n        return tran.getUserResource(key);\r\n    } catch (SystemException ex) {\r\n        throw new IllegalStateException(sm.getString(\"enterprise_distributedtx.no_transaction\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.appserv.web.taglibs.cache.CacheSessionListener.sessionCreated",
	"Comment": "receives notification that a session was created, and adds newlycreated cache for jsp tag body invocations as a session attribute.",
	"Method": "void sessionCreated(HttpSessionEvent hse){\r\n    HttpSession session = hse.getSession();\r\n    ServletContext context = session.getServletContext();\r\n    CacheManager cm = (CacheManager) context.getAttribute(CacheManager.CACHE_MANAGER_ATTR_NAME);\r\n    if (cm == null) {\r\n        cm = new CacheManager();\r\n    }\r\n    Cache cache = null;\r\n    try {\r\n        cache = cm.createCache();\r\n    } catch (Exception ex) {\r\n    }\r\n    if (cache != null) {\r\n        session.setAttribute(Constants.JSPTAG_CACHE_KEY, cache);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.deploy.shared.JarArchive.exists",
	"Comment": "returns the existence of the given entry namethe file name must be relative to the root of the module.",
	"Method": "boolean exists(String name){\r\n    return getJarEntry(name) != null;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.ReportHandler.generateAllReports",
	"Comment": "this api is called from verfier framework to generate the final report",
	"Method": "void generateAllReports(){\r\n    try {\r\n        createResultsDocument(verifierFrameworkContext.getReportLevel());\r\n        writeToXmlFile();\r\n        writeToTxtFile();\r\n        writeToConsole();\r\n    } catch (IOException e) {\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.security.common.FileRealmHelper.authenticate",
	"Comment": "authenticates a user.this method is invoked by the fileloginmodule in order toauthenticate a user in the file realm. the authentication decisionis kept within the realm class implementation in order to keepthe password cache in a single location with no public accessors,to simplify future improvements.",
	"Method": "String[] authenticate(String user,char[] password){\r\n    User ud = userTable.get(user);\r\n    if (ud == null) {\r\n        return null;\r\n    }\r\n    if (resetKey.equals(ud.getAlgo())) {\r\n        return null;\r\n    }\r\n    boolean ok = false;\r\n    try {\r\n        ok = SSHA.verify(ud.getSalt(), ud.getHash(), Utility.convertCharArrayToByteArray(password, Charset.defaultCharset().displayName()), ud.getAlgo());\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n    if (!ok) {\r\n        return null;\r\n    }\r\n    return ud.getGroups();\r\n}"
}, {
	"Path": "org.apache.catalina.ssi.ResponseIncludeWrapper.getOutputStream",
	"Comment": "return a outputstream, throws and exception if a printwriter alreadybeen returned.",
	"Method": "ServletOutputStream getOutputStream(){\r\n    if (printWriter == null) {\r\n        if (servletOutputStream == null) {\r\n            servletOutputStream = captureServletOutputStream;\r\n        }\r\n        return servletOutputStream;\r\n    }\r\n    throw new IllegalStateException();\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.getServletRegistration",
	"Comment": "gets the servletregistration corresponding to the servlet with thegiven servletname.",
	"Method": "ServletRegistration getServletRegistration(String servletName){\r\n    if (SecurityUtil.isPackageProtectionEnabled()) {\r\n        return (ServletRegistration) doPrivileged(\"getServletRegistration\", new Object[] { servletName });\r\n    } else {\r\n        return context.getServletRegistration(servletName);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.embed.impl.WebContainerImpl.getWebListeners",
	"Comment": "gets the collection of weblistener instances registeredwith this webcontainer.",
	"Method": "Collection<WebListener> getWebListeners(){\r\n    return listeners;\r\n}"
}, {
	"Path": "org.glassfish.web.plugin.common.WebModuleConfigCommand.application",
	"Comment": "returns the application corresponding to the app specified in thecommand arguments.",
	"Method": "Application application(){\r\n    final Application result = apps.getModule(Application.class, appName());\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.createServlet",
	"Comment": "instantiates the given servlet class and performs any requiredresource injection into the new servlet instance before returningit.",
	"Method": "T createServlet(Class<T> clazz){\r\n    try {\r\n        return createServletInstance(clazz);\r\n    } catch (Throwable t) {\r\n        throw new ServletException(\"Unable to create Servlet from \" + \"class \" + clazz.getName(), t);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.ejb.EjbVerifier.createClosureCompiler",
	"Comment": "creates the closurecompiler for the ejb module and sets it to theverifier context. this is used to compute the closure on the classes usedin the ejb archive.",
	"Method": "void createClosureCompiler(){\r\n    String specVer = SpecVersionMapper.getEJBVersion(verifierFrameworkContext.getJavaEEVersion());\r\n    Object arg = (isASMode) ? ejbd.getClassLoader() : (Object) getClassPath();\r\n    EjbClosureCompiler cc = new EjbClosureCompiler(specVer, ClassFileLoaderFactory.newInstance(new Object[] { arg }));\r\n    context.setClosureCompiler(cc);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.getName",
	"Comment": "return the canonical, fully qualified, name of the virtual hostthis container represents.",
	"Method": "String getName(){\r\n    return (name);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServerFacade.removeContext",
	"Comment": "stops the given context and removes it from thisvirtualserver.",
	"Method": "void removeContext(Context context){\r\n    if (vs != null) {\r\n        vs.removeContext(context);\r\n    } else {\r\n        throw new GlassFishException(\"Virtual server \" + id + \" has not been added\");\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.clear",
	"Comment": "clear the current contents of the object stack.calling this method might allow another document of the same typeto be correctly parsed. however this method was not intended for this purpose. in general, a separate digester object should be created foreach document to be parsed.",
	"Method": "void clear(){\r\n    match = \"\";\r\n    bodyTexts.clear();\r\n    params.clear();\r\n    publicId = null;\r\n    stack.clear();\r\n    log = null;\r\n    saxLog = null;\r\n    configured = false;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.connector.coyote.PECoyoteConnector.getJSSECipher",
	"Comment": "converts the given cipher suite name to the corresponding jsse cipher.",
	"Method": "String getJSSECipher(String cipher){\r\n    String jsseCipher = null;\r\n    CipherInfo ci = CipherInfo.getCipherInfo(cipher);\r\n    if (ci != null) {\r\n        jsseCipher = ci.getCipherName();\r\n    }\r\n    return jsseCipher;\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.SingleSignOn.stop",
	"Comment": "gracefully terminate the active use of the public methods of thiscomponent.this method should be the last one called on a giveninstance of this component.",
	"Method": "void stop(){\r\n    if (!started)\r\n        return;\r\n    if (debug >= 1)\r\n        log(rb.getString(LogFacade.STOP_COMPONENT_INFO));\r\n    super.stop();\r\n}"
}, {
	"Path": "org.apache.catalina.realm.JAASRealm.start",
	"Comment": "prepare for active use of the public methods of this component.",
	"Method": "void start(){\r\n    super.start();\r\n}"
}, {
	"Path": "org.apache.catalina.realm.RealmBase.getContainer",
	"Comment": "return the container with which this realm has been associated.",
	"Method": "Container getContainer(){\r\n    return (container);\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.SSLAuthenticator.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (this.info);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getConnector",
	"Comment": "return the connector through which this request was received.",
	"Method": "org.apache.catalina.Connector getConnector(){\r\n    return connector;\r\n}"
}, {
	"Path": "org.glassfish.internal.api.Target.getClusterForInstance",
	"Comment": "given an instance that is part of a cluster, returns the cluster element of the cluster to which thegiven instance belongs",
	"Method": "Cluster getClusterForInstance(String targetName){\r\n    return domain.getClusterForInstance(targetName);\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.CreateHttpListener.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (!validateInputs(report)) {\r\n        return;\r\n    }\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    networkConfig = config.getNetworkConfig();\r\n    HttpService httpService = config.getHttpService();\r\n    if (!(verifyUniqueName(report, networkConfig) && verifyUniquePort(report, networkConfig) && verifyDefaultVirtualServer(report))) {\r\n        return;\r\n    }\r\n    VirtualServer vs = httpService.getVirtualServerByName(defaultVirtualServer);\r\n    boolean listener = false;\r\n    boolean protocol = false;\r\n    boolean transport = false;\r\n    try {\r\n        transport = createOrGetTransport(null);\r\n        protocol = createProtocol(context);\r\n        createHttp(context);\r\n        final ThreadPool threadPool = getThreadPool(networkConfig);\r\n        listener = createNetworkListener(networkConfig, transport, threadPool);\r\n        updateVirtualServer(vs);\r\n    } catch (TransactionFailure e) {\r\n        try {\r\n            if (listener) {\r\n                deleteListener(context);\r\n            }\r\n            if (protocol) {\r\n                deleteProtocol(context);\r\n            }\r\n            if (transport) {\r\n                deleteTransport(context);\r\n            }\r\n        } catch (Exception e1) {\r\n            if (logger.isLoggable(Level.INFO)) {\r\n                logger.log(Level.INFO, e.getMessage(), e);\r\n            }\r\n            throw new RuntimeException(e.getMessage());\r\n        }\r\n        if (logger.isLoggable(Level.INFO)) {\r\n            logger.log(Level.INFO, e.getMessage(), e);\r\n        }\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.CREATE_HTTP_LISTENER_FAIL), listenerId, e.getMessage()));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.CreateHttp.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parametervalues.",
	"Method": "void execute(AdminCommandContext context){\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    final ActionReport report = context.getActionReport();\r\n    Protocols protocols = config.getNetworkConfig().getProtocols();\r\n    Protocol protocol = null;\r\n    for (Protocol p : protocols.getProtocol()) {\r\n        if (protocolName.equals(p.getName())) {\r\n            protocol = p;\r\n        }\r\n    }\r\n    if (protocol == null) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.CREATE_HTTP_FAIL_PROTOCOL_NOT_FOUND), protocolName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (protocol.getHttp() != null) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.CREATE_HTTP_FAIL_DUPLICATE), protocolName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<Protocol>() {\r\n            public Object run(Protocol param) throws TransactionFailure {\r\n                Http http = param.createChild(Http.class);\r\n                final FileCache cache = http.createChild(FileCache.class);\r\n                cache.setEnabled(\"false\");\r\n                http.setFileCache(cache);\r\n                http.setDefaultVirtualServer(defaultVirtualServer);\r\n                http.setDnsLookupEnabled(dnsLookupEnabled == null ? null : dnsLookupEnabled.toString());\r\n                http.setMaxConnections(maxConnections);\r\n                http.setRequestTimeoutSeconds(requestTimeoutSeconds);\r\n                http.setTimeoutSeconds(timeoutSeconds);\r\n                http.setXpoweredBy(xPoweredBy == null ? null : xPoweredBy.toString());\r\n                http.setServerName(serverName);\r\n                param.setHttp(http);\r\n                return http;\r\n            }\r\n        }, protocol);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.CREATE_HTTP_REDIRECT_FAIL), protocolName, e.getMessage() == null ? \"No reason given.\" : e.getMessage()));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.CreateHttp.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parametervalues.",
	"Method": "void execute(AdminCommandContext context){\r\n    Http http = param.createChild(Http.class);\r\n    final FileCache cache = http.createChild(FileCache.class);\r\n    cache.setEnabled(\"false\");\r\n    http.setFileCache(cache);\r\n    http.setDefaultVirtualServer(defaultVirtualServer);\r\n    http.setDnsLookupEnabled(dnsLookupEnabled == null ? null : dnsLookupEnabled.toString());\r\n    http.setMaxConnections(maxConnections);\r\n    http.setRequestTimeoutSeconds(requestTimeoutSeconds);\r\n    http.setTimeoutSeconds(timeoutSeconds);\r\n    http.setXpoweredBy(xPoweredBy == null ? null : xPoweredBy.toString());\r\n    http.setServerName(serverName);\r\n    param.setHttp(http);\r\n    return http;\r\n}"
}, {
	"Path": "org.apache.catalina.util.ManifestResource.isFulfilled",
	"Comment": "returns true if all required extension dependencieshave been meet for this manifestresource object.",
	"Method": "boolean isFulfilled(){\r\n    if (requiredExtensions == null) {\r\n        return true;\r\n    }\r\n    Iterator<Extension> it = requiredExtensions.iterator();\r\n    while (it.hasNext()) {\r\n        Extension ext = it.next();\r\n        if (!ext.isFulfilled())\r\n            return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.cci.ConnectionFactoryDefaultConstructor.check",
	"Comment": "test that the implementation class forjavax.resource.cci.connectionfactory provides a default constructor",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    Class connFactoryImpl = null;\r\n    if (isCCIImplemented(descriptor, result)) {\r\n        connFactoryImpl = testConnectionFactoryImpl(descriptor, result);\r\n        if (connFactoryImpl == null)\r\n            return result;\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.cci.notApp\", \"The CCI interfaces do not seem to be implemented by this resource adapter\"));\r\n        return result;\r\n    }\r\n    try {\r\n        connFactoryImpl.getConstructor(new Class[0]);\r\n        result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.passed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.cci.ConnectionFactoryDefaultConstructor.defConstr\", \"The connectionfactory-impl-class: [ {0} ] provides a default constructor.\", new Object[] { connFactoryImpl.getName() }));\r\n    } catch (NoSuchMethodException nsme) {\r\n        result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.failed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.cci.ConnectionFactoryDefaultConstructor.noDefConstr\", \"Error: The connectionfactory-impl-class: [ {0} ] must provide a default constructor.\", new Object[] { connFactoryImpl.getName() }));\r\n    } catch (SecurityException se) {\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getNamedDispatcher",
	"Comment": "return a requestdispatcher object that acts as awrapper for the named servlet.",
	"Method": "RequestDispatcher getNamedDispatcher(String name){\r\n    if (name == null)\r\n        return (null);\r\n    Wrapper wrapper = (Wrapper) findChild(name);\r\n    if (wrapper == null)\r\n        return (null);\r\n    return new ApplicationDispatcher(wrapper, null, null, null, null, null, name);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.directRegisterResource",
	"Comment": "registers the given resource object with the coordinator with no regardfor the state of the transaction or registration with the superior.this is intended to be used during recovery to enable xa resourcemanagers to participate in resync without needing the xa resourceobjects to have persistent references.the resource object parameter should only refer to a local object.",
	"Method": "void directRegisterResource(Resource res){\r\n    if (participants == null) {\r\n        participants = new RegisteredResources(null, this);\r\n    }\r\n    participants.addRes(res);\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.logp(Level.FINE, \"TopCoordinator\", \"directRegisterResource()\", \"Registered resource :\" + res);\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.startPrefixMapping",
	"Comment": "process notification that a namespace prefix is coming in to scope.",
	"Method": "void startPrefixMapping(String prefix,String namespaceURI){\r\n    if (saxLog.isLoggable(Level.FINE)) {\r\n        saxLog.log(Level.FINE, \"startPrefixMapping(\" + prefix + \",\" + namespaceURI + \")\");\r\n    }\r\n    ArrayStack<String> stack = namespaces.get(prefix);\r\n    if (stack == null) {\r\n        stack = new ArrayStack<String>();\r\n        namespaces.put(prefix, stack);\r\n    }\r\n    stack.push(namespaceURI);\r\n}"
}, {
	"Path": "org.glassfish.internal.deployment.GenericHandler.requiresAnnotationScanning",
	"Comment": "returns whether this archive requires annotation scanning.",
	"Method": "boolean requiresAnnotationScanning(ReadableArchive archive){\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.NamingResources.setContainer",
	"Comment": "set the container with which the naming resources are associated.",
	"Method": "void setContainer(Object container){\r\n    this.container = container;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.cci.InteractionSpecJavaBeansCompliance.check",
	"Comment": "all connector tests should implement this method. it run an individualtest against the resource adapter deployment descriptor.",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    boolean oneFailed = false;\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (isCCIImplemented(descriptor, result)) {\r\n        Class mcf = findImplementorOf(descriptor, \"javax.resource.cci.InteractionSpec\");\r\n        if (mcf != null) {\r\n            try {\r\n                BeanInfo bi = Introspector.getBeanInfo(mcf, Object.class);\r\n                PropertyDescriptor[] properties = bi.getPropertyDescriptors();\r\n                for (int i = 0; i < properties.length; i++) {\r\n                    if (properties[i].getReadMethod() == null || properties[i].getWriteMethod() == null) {\r\n                        oneFailed = true;\r\n                        result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: The javax.resource.cci.InteractionSpec implementation [ {0} ] of the property [ {1} ] is not JavaBeans compliant\", new Object[] { mcf.getName(), properties[i].getName() }));\r\n                    }\r\n                    if (!properties[i].isConstrained() && !properties[i].isBound()) {\r\n                        oneFailed = true;\r\n                        result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.failed(smh.getLocalString(getClass().getName() + \".failed2\", \"Error: The property [ {0} ] of the javax.resource.cci.InteractionSpec implementation [ {1} ] is not bound or constrained\", new Object[] { properties[i].getName(), mcf.getName() }));\r\n                    }\r\n                }\r\n            } catch (IntrospectionException ie) {\r\n                result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.notApplicable(smh.getLocalString(getClass().getName() + \".failed\", \"Error: The javax.resource.cci.InteractionSpec implementation [ {0} ] is not JavaBeans compliant\", new Object[] { mcf.getName() }));\r\n                return result;\r\n            }\r\n        } else {\r\n            result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.notApplicable(smh.getLocalString(getClass().getName() + \".nonexist\", \"Error: While the CCI interfaces are implemented, the javax.resource.cci.InteractionSpec is not\"));\r\n            return result;\r\n        }\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.cci.InteractionExistence.notapp\", \"NotApplicable : The CCI interfaces do not seem to be implemented by this resource adapter\"));\r\n        return result;\r\n    }\r\n    if (!oneFailed) {\r\n        result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"The javax.resource.cci.InteractionSpec implementation is JavaBeans compliant\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "components.renderkit.Util.generateId",
	"Comment": "generate a new identifier currently used to uniquely identifycomponents.",
	"Method": "String generateId(){\r\n    if (id == Long.MAX_VALUE) {\r\n        id = 0;\r\n    } else {\r\n        id++;\r\n    }\r\n    return Long.toHexString(id);\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.jmx.MBeanProxyHandler.setAttributes",
	"Comment": "same as xattributesaccess.setattributes, but with exceptions",
	"Method": "AttributeList setAttributes(AttributeList requested){\r\n    final AttributeList results = getMBeanServerConnection().setAttributes(getObjectName(), requested);\r\n    postSetAttributesHook(requested, results);\r\n    return (results);\r\n}"
}, {
	"Path": "org.glassfish.common.util.timer.TimerSchedule.parseDaysOfMonth",
	"Comment": "preprocess data that represents days of the month.input data can be one or more of a positive or a negative number, an order,or a case insensitive abbreviated name.",
	"Method": "void parseDaysOfMonth(){\r\n    if (dayOfMonth_.equals(\"*\")) {\r\n        daysOfMonth.set(1, 32);\r\n        return;\r\n    }\r\n    if (dayOfMonth_.indexOf(',') > 0) {\r\n        String[] arr = splitList(dayOfMonth_);\r\n        for (String s0 : arr) {\r\n            if (s0.indexOf(rangeChar, 1) > 0) {\r\n                processRangeDaysOfMonth(s0);\r\n            } else {\r\n                processDayOfMonth(s0);\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    if (dayOfMonth_.indexOf(rangeChar, 1) > 0) {\r\n        processRangeDaysOfMonth(dayOfMonth_);\r\n        return;\r\n    }\r\n    processDayOfMonth(dayOfMonth_);\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.FilterDef.isAsyncSupported",
	"Comment": "checks if this filter has been annotated or flagged in the deploymentdescriptor as being able to support asynchronous operations.",
	"Method": "boolean isAsyncSupported(){\r\n    return isAsyncSupported;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityCollection.findMethod",
	"Comment": "return true if the specified http request method ispart of this web resource collection.",
	"Method": "boolean findMethod(String method){\r\n    if (methods.length == 0)\r\n        return (true);\r\n    for (int i = 0; i < methods.length; i++) {\r\n        if (methods[i].equals(method))\r\n            return (true);\r\n    }\r\n    return (false);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.ServerSynchronizer.attachAppDir",
	"Comment": "attach the application directory and all its contents to the payload.",
	"Method": "void attachAppDir(File dir,Payload.Outbound payload){\r\n    if (logger.isLoggable(Level.FINER))\r\n        logger.finer(\"ServerSynchronizer: attach directory \" + domainRootUri.relativize(dir.toURI()));\r\n    if (!dir.exists()) {\r\n        logger.finer(\"ServerSynchronizer: nothing to attach\");\r\n        return;\r\n    }\r\n    payload.requestFileReplacement(\"application/octet-stream\", domainRootUri.relativize(dir.toURI()), \"configChange\", null, dir, true);\r\n}"
}, {
	"Path": "com.sun.enterprise.util.i18n.StringManagerBase.getStringManager",
	"Comment": "returns a local string manager for the given resourcebundle name.",
	"Method": "StringManagerBase getStringManager(String resourceBundleName,ClassLoader classLoader){\r\n    StringManagerBase mgr = (StringManagerBase) managers.get(resourceBundleName);\r\n    if (mgr == null) {\r\n        mgr = new StringManagerBase(resourceBundleName, classLoader);\r\n        try {\r\n            managers.put(resourceBundleName, mgr);\r\n        } catch (Exception e) {\r\n            _logger.log(Level.SEVERE, CULoggerInfo.exceptionCachingStringManager, e);\r\n        }\r\n    }\r\n    return mgr;\r\n}"
}, {
	"Path": "com.sun.appserv.server.util.Version.getAdminClientCommandName",
	"Comment": "returns the admin client command string which represents the name of thecommand use for performing admin related domain tasks.",
	"Method": "String getAdminClientCommandName(){\r\n    return getProperty(ADMIN_CLIENT_COMMAND_NAME_KEY, \"nadmin\");\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.mbean.LoggingImpl.privateLoggingHook",
	"Comment": "internal use only, called bycom.sun.enterprise.server.logging.amxlogginghook.",
	"Method": "void privateLoggingHook(LogRecord logRecord,Formatter formatter){\r\n    if (logRecord.getThreadID() == mMyThreadID) {\r\n        debug(\"privateLoggingHook: recusive call!!!\");\r\n        throw new RuntimeException(\"recursive call\");\r\n    }\r\n    synchronized (this) {\r\n        mMyThreadID = Thread.currentThread().getId();\r\n        final Level level = logRecord.getLevel();\r\n        try {\r\n            if (getLogLevelListenerCount(level) != 0) {\r\n                final String notifType = logLevelToNotificationType(level);\r\n                final NotificationBuilder builder = notificationTypeToNotificationBuilder(notifType);\r\n                final String logRecordAsString = formatter.format(logRecord);\r\n                final Map<String, Serializable> userData = logRecordToMap(logRecord, logRecordAsString);\r\n                final Notification notif = builder.buildNewWithMap(logRecordAsString, userData);\r\n                debug(\"privateLoggingHook: sending: \" + notif);\r\n                sendNotification(notif);\r\n            } else {\r\n            }\r\n        } finally {\r\n            mMyThreadID = -1;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.addJspFile",
	"Comment": "adds the servlet with the given name and jsp file to thisservlet context.",
	"Method": "ServletRegistration.Dynamic addJspFile(String servletName,String jspFile){\r\n    if (isRestricted) {\r\n        throw new UnsupportedOperationException(rb.getString(LogFacade.UNSUPPORTED_OPERATION_EXCEPTION));\r\n    }\r\n    return context.addJspFile(servletName, jspFile);\r\n}"
}, {
	"Path": "org.apache.catalina.startup.ContextConfig.authenticatorConfig",
	"Comment": "set up an authenticator automatically if required, and one has notalready been configured.",
	"Method": "void authenticatorConfig(){\r\n    LoginConfig loginConfig = context.getLoginConfig();\r\n    if (loginConfig == null) {\r\n        loginConfig = new LoginConfig(\"NONE\", null, null, null);\r\n        context.setLoginConfig(loginConfig);\r\n    }\r\n    if (context instanceof Authenticator)\r\n        return;\r\n    if (context instanceof ContainerBase) {\r\n        Pipeline pipeline = ((ContainerBase) context).getPipeline();\r\n        if (pipeline != null) {\r\n            GlassFishValve basic = pipeline.getBasic();\r\n            if ((basic != null) && (basic instanceof Authenticator))\r\n                return;\r\n            GlassFishValve[] valves = pipeline.getValves();\r\n            for (int i = 0; i < valves.length; i++) {\r\n                if (valves[i] instanceof Authenticator)\r\n                    return;\r\n            }\r\n        }\r\n    } else {\r\n        return;\r\n    }\r\n    Realm rlm = context.getRealm();\r\n    if (rlm == null) {\r\n        throw new LifecycleException(rb.getString(LogFacade.NO_REALM_BEEN_CONFIGURED_EXCEPTION));\r\n    }\r\n    rlm.setRealmName(loginConfig.getRealmName(), loginConfig.getAuthMethod());\r\n    if (!context.hasConstraints()) {\r\n        return;\r\n    }\r\n    GlassFishValve authenticator = null;\r\n    if (customAuthenticators != null) {\r\n        String loginMethod = loginConfig.getAuthMethod();\r\n        if (loginMethod != null && customAuthenticators.containsKey(loginMethod)) {\r\n            authenticator = getGlassFishValveAuthenticator(loginMethod);\r\n            if (authenticator == null) {\r\n                String msg = MessageFormat.format(rb.getString(LogFacade.CANNOT_CONFIG_AUTHENTICATOR_EXCEPTION), loginMethod);\r\n                throw new LifecycleException(msg);\r\n            }\r\n        }\r\n    }\r\n    if (authenticator == null) {\r\n        String authenticatorName = null;\r\n        String authMethod = loginConfig.getAuthMethod();\r\n        if (authMethod == null) {\r\n            authMethod = \"NONE\";\r\n        }\r\n        authenticatorName = authenticators.getProperty(authMethod);\r\n        if (authenticatorName == null) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.CANNOT_CONFIG_AUTHENTICATOR_EXCEPTION), loginConfig.getAuthMethod());\r\n            throw new LifecycleException(msg);\r\n        }\r\n        try {\r\n            Class authenticatorClass = Class.forName(authenticatorName);\r\n            authenticator = (GlassFishValve) authenticatorClass.newInstance();\r\n        } catch (Throwable t) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.CANNOT_INSTANTIATE_AUTHENTICATOR_EXCEPTION), authenticatorName);\r\n            throw new LifecycleException(msg, t);\r\n        }\r\n    }\r\n    if (authenticator != null && context instanceof ContainerBase) {\r\n        Pipeline pipeline = ((ContainerBase) context).getPipeline();\r\n        if (pipeline != null) {\r\n            ((ContainerBase) context).addValve(authenticator);\r\n            if (log.isLoggable(Level.FINE)) {\r\n                log.log(Level.FINE, LogFacade.CONFIGURED_AUTHENTICATOR_FINE, loginConfig.getAuthMethod());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getNoteNames",
	"Comment": "return an iterator containing the string names of all notes bindingsthat exist for this request.",
	"Method": "Iterator<String> getNoteNames(){\r\n    return notes.keySet().iterator();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TransactionFactoryImpl.deactivate",
	"Comment": "prevents any further transactional activity in the process.",
	"Method": "void deactivate(){\r\n    active = false;\r\n    TimeoutManager.shutdown(false);\r\n    RecoveryManager.shutdown(false);\r\n    DelegatedRecoveryManager.shutdown(false);\r\n}"
}, {
	"Path": "org.glassfish.webservices.transport.tcp.AppServRegistry.getEjbRuntimeEndpointInfo",
	"Comment": "method is used by ws invoker to clear some ejb invoker state ???",
	"Method": "EjbRuntimeEndpointInfo getEjbRuntimeEndpointInfo(String wsPath){\r\n    final WSEndpointDescriptor wsEndpointDescriptor = WSTCPAdapterRegistryImpl.getInstance().lookupEndpoint(wsPath);\r\n    EjbRuntimeEndpointInfo endpointInfo = null;\r\n    if (wsEndpointDescriptor.isEJB()) {\r\n        endpointInfo = (EjbRuntimeEndpointInfo) V3Module.getWSEjbEndpointRegistry().getEjbWebServiceEndpoint(wsEndpointDescriptor.getURI(), \"POST\", null);\r\n    }\r\n    return endpointInfo;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.session.SessionCookieConfig.setPath",
	"Comment": "set the path to use when creating the session tracking cookie.",
	"Method": "void setPath(String path){\r\n    _path = path;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.ServerSynchronizer.synchronizeApplications",
	"Comment": "synchronize all the applications in the applications directory.we use the mod time of the application directory to decide ifthe application has changed.if it has changed, we also sendany of the generated content.",
	"Method": "void synchronizeApplications(Payload.Outbound payload,Server server,SyncRequest sr){\r\n    if (logger.isLoggable(Level.FINER))\r\n        logger.finer(\"ServerSynchronizer: \" + \"synchronize application instance \" + sr.instance);\r\n    Map<String, Application> apps = getApps(server);\r\n    File appsDir = env.getApplicationRepositoryPath();\r\n    for (ModTime mt : sr.files) {\r\n        if (apps.containsKey(mt.name)) {\r\n            syncApp(apps.get(mt.name), appsDir, mt, payload);\r\n            apps.remove(mt.name);\r\n        } else\r\n            removeApp(apps.get(mt.name), appsDir, mt, payload);\r\n    }\r\n    for (Map.Entry<String, Application> e : apps.entrySet()) syncApp(e.getValue(), appsDir, new ModTime(e.getKey(), 0), payload);\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.RootDeploymentDescriptor.setSpecVersion",
	"Comment": "sets the specification version of the deployment descriptor",
	"Method": "void setSpecVersion(String specVersion){\r\n    this.specVersion = specVersion;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.Configuration.setFactory",
	"Comment": "sets the identity of the transactionfactory and indicates if it is localor remote.",
	"Method": "void setFactory(TransactionFactory newFactory,boolean localTxFactory){\r\n    factory = newFactory;\r\n    localFactory = localTxFactory;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.addJspFile",
	"Comment": "adds the servlet with the given name and jsp file to thisservlet context.",
	"Method": "ServletRegistration.Dynamic addJspFile(String servletName,String jspFile){\r\n    if (SecurityUtil.isPackageProtectionEnabled()) {\r\n        return (ServletRegistration.Dynamic) doPrivileged(\"addJspFile\", new Object[] { servletName, jspFile });\r\n    } else {\r\n        return context.addJspFile(servletName, jspFile);\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.WithDefaultsRulesWrapper.add",
	"Comment": "adds a rule to be fired on given pattern.pattern matching is delegated to wrapped implementation.",
	"Method": "void add(String pattern,Rule rule){\r\n    wrappedRules.add(pattern, rule);\r\n    allRules.add(rule);\r\n}"
}, {
	"Path": "testmbeans.ObjectNameSelfProvider.setAttribute",
	"Comment": "sets the value of the specified attribute of the dynamicmbean.",
	"Method": "void setAttribute(Attribute attribute){\r\n    throw new AttributeNotFoundException(\"Unknown Attribute \" + attribute.getName());\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.Configuration.getServerName",
	"Comment": "returns the name of the server for the given log path. added for delegated recovery support.",
	"Method": "String getServerName(String getServerName,String logPath){\r\n    return (String) logPathToServernametable.get(logPath);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.ServerSynchronizer.syncApp",
	"Comment": "synchronize the application named by mt.name in thebase directory.if the application is out of date,add the application files to the payload, includingthe generated files.",
	"Method": "boolean syncApp(Application app,File base,ModTime mt,Payload.Outbound payload){\r\n    if (logger.isLoggable(Level.FINER))\r\n        logger.finer(\"ServerSynchronizer: sync app \" + mt.name);\r\n    try {\r\n        File appDir = fileOf(base, mt.name);\r\n        if (syncArchive) {\r\n            File archive = app.application();\r\n            if (logger.isLoggable(Level.FINEST))\r\n                logger.finest(\"ServerSynchronizer: check archive \" + archive);\r\n            if (mt.time != 0 && archive.lastModified() == mt.time)\r\n                return false;\r\n            attachAppArchive(archive, payload);\r\n        } else {\r\n            if (logger.isLoggable(Level.FINEST))\r\n                logger.finest(\"ServerSynchronizer: check app dir \" + appDir);\r\n            if (mt.time != 0 && appDir.lastModified() == mt.time)\r\n                return false;\r\n            if (logger.isLoggable(Level.FINE))\r\n                logger.fine(\"ServerSynchronizer: sending files for \" + \"application \" + mt.name + (mt.time == 0 ? \" because it doesn't exist on the instance\" : \" because it was out of date\"));\r\n            attachAppDir(appDir, payload);\r\n        }\r\n        File gdir;\r\n        gdir = env.getApplicationCompileJspPath();\r\n        attachAppDir(fileOf(gdir, mt.name), payload);\r\n        gdir = env.getApplicationGeneratedXMLPath();\r\n        attachAppDir(fileOf(gdir, mt.name), payload);\r\n        gdir = env.getApplicationEJBStubPath();\r\n        attachAppDir(fileOf(gdir, mt.name), payload);\r\n        gdir = new File(env.getApplicationStubPath(), \"policy\");\r\n        attachAppDir(fileOf(gdir, mt.name), payload);\r\n        gdir = env.getApplicationAltDDPath();\r\n        attachAppDir(fileOf(gdir, mt.name), payload);\r\n    } catch (IOException ioex) {\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.fine(\"ServerSynchronizer: IOException syncing app \" + mt.name);\r\n            logger.fine(ioex.toString());\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationFilterFactory.createFilterChain",
	"Comment": "construct and return a filterchain implementation that will wrap theexecution of the specified servlet instance.if we should not executea filter chain at all, return null.",
	"Method": "ApplicationFilterChain createFilterChain(ServletRequest request,Wrapper wrapper,Servlet servlet){\r\n    if (servlet == null)\r\n        return (null);\r\n    ApplicationFilterChain filterChain = null;\r\n    StandardContext context = (StandardContext) wrapper.getParent();\r\n    List<FilterMap> filterMaps = context.findFilterMaps();\r\n    if (filterMaps.isEmpty()) {\r\n        return (filterChain);\r\n    }\r\n    DispatcherType dispatcher = request.getDispatcherType();\r\n    String requestPath = null;\r\n    Object attribute = request.getAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR);\r\n    if (attribute != null) {\r\n        requestPath = attribute.toString();\r\n    }\r\n    String servletName = wrapper.getName();\r\n    int n = 0;\r\n    Iterator<FilterMap> i = filterMaps.iterator();\r\n    while (i.hasNext()) {\r\n        FilterMap filterMap = i.next();\r\n        if (!filterMap.getDispatcherTypes().contains(dispatcher)) {\r\n            continue;\r\n        }\r\n        if (!matchFiltersURL(filterMap, requestPath, context.isCaseSensitiveMapping()))\r\n            continue;\r\n        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) context.findFilterConfig(filterMap.getFilterName());\r\n        if (filterConfig == null) {\r\n            continue;\r\n        }\r\n        if (filterChain == null)\r\n            filterChain = internalCreateFilterChain(request, wrapper, servlet);\r\n        filterChain.addFilter(filterConfig);\r\n        n++;\r\n    }\r\n    i = filterMaps.iterator();\r\n    while (i.hasNext()) {\r\n        FilterMap filterMap = i.next();\r\n        if (!filterMap.getDispatcherTypes().contains(dispatcher)) {\r\n            continue;\r\n        }\r\n        if (!matchFiltersServlet(filterMap, servletName))\r\n            continue;\r\n        ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) context.findFilterConfig(filterMap.getFilterName());\r\n        if (filterConfig == null) {\r\n            continue;\r\n        }\r\n        if (filterChain == null)\r\n            filterChain = internalCreateFilterChain(request, wrapper, servlet);\r\n        filterChain.addFilter(filterConfig);\r\n        n++;\r\n    }\r\n    return (filterChain);\r\n}"
}, {
	"Path": "org.glassfish.common.util.admin.ParamTokenizer.nextTokenKeepEscapes",
	"Comment": "return the next token from this tokenizer.keep escapes and quotes intact.",
	"Method": "String nextTokenKeepEscapes(){\r\n    if (currentPosition >= maxPosition) {\r\n        throw new NoSuchElementException(localStrings.getLocalString(\"NoMoreTokens\", \"No more tokens\"));\r\n    }\r\n    return scanToken(true);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.asyncTimeout",
	"Comment": "invokes all registered asynclistener instances at theirontimeout method.this method also performs an error dispatch and completes the responseif none of the listeners have done so.",
	"Method": "void asyncTimeout(){\r\n    if (asyncContext != null) {\r\n        asyncContext.notifyAsyncListeners(AsyncContextImpl.AsyncEventType.TIMEOUT, null);\r\n    }\r\n    inputBuffer.disableReadHandler();\r\n    if (response instanceof Response) {\r\n        ((Response) response).disableWriteHandler();\r\n    }\r\n    errorDispatchAndComplete(null);\r\n}"
}, {
	"Path": "com.sun.s1peqe.ejb.stateless.converter.client.ConverterClient.main",
	"Comment": "the main method of the client. this invokes the converterbean to use its services. it then asks the bean to convert 100 dollars to yen and 100 yen to euro. the results are printed at the terminal where the client is run. see appclient documentation in sunone app server to run the clinet.",
	"Method": "void main(String[] args){\r\n    ConverterClient client = new ConverterClient();\r\n    client.run(args);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.EventSemaphore.waitEvent",
	"Comment": "waits for the event to be posted.if the event has already been posted, then the operation returns immediately.",
	"Method": "void waitEvent(){\r\n    if (!posted)\r\n        wait();\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.VerifierTest.checkIfPrimitive",
	"Comment": "if the param string is of primitive type this method return that classrepresentation of the primitive type",
	"Method": "Class checkIfPrimitive(String param){\r\n    if (param.equals(\"int\"))\r\n        return int.class;\r\n    if (param.equals(\"boolean\"))\r\n        return boolean.class;\r\n    if (param.equals(\"float\"))\r\n        return float.class;\r\n    if (param.equals(\"double\"))\r\n        return (double.class);\r\n    if (param.equals(\"byte\"))\r\n        return byte.class;\r\n    if (param.equals(\"long\"))\r\n        return long.class;\r\n    if (param.equals(\"char\"))\r\n        return char.class;\r\n    if (param.equals(\"short\"))\r\n        return short.class;\r\n    if (param.equals(\"void\"))\r\n        return void.class;\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.ErrorCode.check",
	"Comment": "error code element contains an http error code within web application test. i.e. 404",
	"Method": "Result check(WebBundleDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (((WebBundleDescriptorImpl) descriptor).getErrorPageDescriptors().hasMoreElements()) {\r\n        boolean oneFailed = false;\r\n        boolean foundIt = false;\r\n        int oneErrorCode = 0;\r\n        int oneNA = 0;\r\n        for (Enumeration e = ((WebBundleDescriptorImpl) descriptor).getErrorPageDescriptors(); e.hasMoreElements(); ) {\r\n            foundIt = false;\r\n            oneErrorCode++;\r\n            ErrorPageDescriptor errorpage = (ErrorPageDescriptor) e.nextElement();\r\n            String exceptionType = errorpage.getExceptionType();\r\n            if (!((exceptionType != null) && (exceptionType.length() > 0))) {\r\n                Integer errorCode = new Integer(errorpage.getErrorCode());\r\n                if (isValidErrorCode(errorCode)) {\r\n                    foundIt = true;\r\n                } else {\r\n                    foundIt = false;\r\n                }\r\n                if (foundIt) {\r\n                    result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                    result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"Error code [ {0} ] contains valid HTTP error code within web application [ {1} ]\", new Object[] { errorCode.toString(), descriptor.getName() }));\r\n                } else {\r\n                    if (!oneFailed) {\r\n                        oneFailed = true;\r\n                    }\r\n                    result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                    result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: error-code [ {0} ] does not contain valid HTTP error code within web application [ {1} ]\", new Object[] { errorCode.toString(), descriptor.getName() }));\r\n                }\r\n            } else {\r\n                result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.addNaDetails(smh.getLocalString(getClass().getName() + \".notApplicable1\", \"Not Applicable: Error-code is [ {0} ], using [ {1} ] instead within web application [ {2} ]\", new Object[] { new Integer(errorpage.getErrorCode()), exceptionType, descriptor.getName() }));\r\n                oneNA++;\r\n            }\r\n        }\r\n        if (oneFailed) {\r\n            result.setStatus(Result.FAILED);\r\n        } else if (oneNA == oneErrorCode) {\r\n            result.setStatus(Result.NOT_APPLICABLE);\r\n        } else {\r\n            result.setStatus(Result.PASSED);\r\n        }\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"There are no error-code elements within the web archive [ {0} ]\", new Object[] { descriptor.getName() }));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.connector.ConnectorVerifier.createClosureCompiler",
	"Comment": "creates the closurecompiler for the rar module and sets it to theverifier context. this is used to compute the closure on the classes usedin the rar.",
	"Method": "void createClosureCompiler(){\r\n    String specVer = SpecVersionMapper.getJCAVersion(verifierFrameworkContext.getJavaEEVersion());\r\n    Object arg = (isASMode) ? cond.getClassLoader() : (Object) getClassPath();\r\n    ConnectorClosureCompiler cc = new ConnectorClosureCompiler(specVer, ClassFileLoaderFactory.newInstance(new Object[] { arg }));\r\n    context.setClosureCompiler(cc);\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.utils.Util.parameterMap",
	"Comment": "convenience wrapper around parametermap constructor to make it easier to use its fluent api",
	"Method": "ParameterMap parameterMap(){\r\n    return new ParameterMap();\r\n}"
}, {
	"Path": "testmbeans.ImplementsMBeanRegistrationDynamicSupport.getAttributes",
	"Comment": "enables the get values of several attributes of the dynamic mbean.",
	"Method": "AttributeList getAttributes(String[] attributeNames){\r\n    AttributeList resultList = new AttributeList();\r\n    for (int i = 0; i < attributeNames.length; i++) {\r\n        try {\r\n            Object value = getAttribute((String) attributeNames[i]);\r\n            resultList.add(new Attribute(attributeNames[i], value));\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return resultList;\r\n}"
}, {
	"Path": "org.apache.catalina.startup.Catalina.createStartDigester",
	"Comment": "create and configure the digester we will be using for startup.",
	"Method": "Digester createStartDigester(){\r\n    long t1 = System.currentTimeMillis();\r\n    Digester digester = new Digester();\r\n    if (debug > 0)\r\n        digester.setDebug(debug);\r\n    digester.setValidating(false);\r\n    digester.setClassLoader(standardServerClassLoader);\r\n    digester.addObjectCreate(\"Server\", \"org.apache.catalina.core.StandardServer\", \"className\");\r\n    digester.addSetProperties(\"Server\");\r\n    digester.addSetNext(\"Server\", \"setServer\", \"org.apache.catalina.Server\");\r\n    digester.addObjectCreate(\"Server/GlobalNamingResources\", \"org.apache.catalina.deploy.NamingResources\");\r\n    digester.addSetProperties(\"Server/GlobalNamingResources\");\r\n    digester.addSetNext(\"Server/GlobalNamingResources\", \"setGlobalNamingResources\", \"org.apache.catalina.deploy.NamingResources\");\r\n    // MUST be specified in the element\r\n    digester.addObjectCreate(\"Server/Listener\", null, \"className\");\r\n    digester.addSetProperties(\"Server/Listener\");\r\n    digester.addSetNext(\"Server/Listener\", \"addLifecycleListener\", \"org.apache.catalina.LifecycleListener\");\r\n    digester.addObjectCreate(\"Server/Service\", \"org.apache.catalina.core.StandardService\", \"className\");\r\n    digester.addSetProperties(\"Server/Service\");\r\n    digester.addSetNext(\"Server/Service\", \"addService\", \"org.apache.catalina.Service\");\r\n    // MUST be specified in the element\r\n    digester.addObjectCreate(\"Server/Service/Listener\", null, \"className\");\r\n    digester.addSetProperties(\"Server/Service/Listener\");\r\n    digester.addSetNext(\"Server/Service/Listener\", \"addLifecycleListener\", \"org.apache.catalina.LifecycleListener\");\r\n    digester.addObjectCreate(\"Server/Service/Connector\", \"org.apache.catalina.connector.CoyoteConnector\", \"className\");\r\n    digester.addRule(\"Server/Service/Connector\", new SetAllPropertiesRule());\r\n    digester.addSetNext(\"Server/Service/Connector\", \"addConnector\", \"org.apache.catalina.Connector\");\r\n    digester.addObjectCreate(\"Server/Service/Connector/Factory\", \"org.apache.catalina.connector.CoyoteServerSocketFactory\", \"className\");\r\n    digester.addSetProperties(\"Server/Service/Connector/Factory\");\r\n    digester.addSetNext(\"Server/Service/Connector/Factory\", \"setFactory\", \"org.apache.catalina.net.ServerSocketFactory\");\r\n    // MUST be specified in the element\r\n    digester.addObjectCreate(\"Server/Service/Connector/Listener\", null, \"className\");\r\n    digester.addSetProperties(\"Server/Service/Connector/Listener\");\r\n    digester.addSetNext(\"Server/Service/Connector/Listener\", \"addLifecycleListener\", \"org.apache.catalina.LifecycleListener\");\r\n    digester.addRuleSet(new NamingRuleSet(\"Server/GlobalNamingResources/\"));\r\n    digester.addRuleSet(new EngineRuleSet(\"Server/Service/\"));\r\n    digester.addRuleSet(new HostRuleSet(\"Server/Service/Engine/\"));\r\n    digester.addRuleSet(new ContextRuleSet(\"Server/Service/Engine/Default\"));\r\n    digester.addRuleSet(new NamingRuleSet(\"Server/Service/Engine/DefaultContext/\"));\r\n    digester.addRuleSet(new ContextRuleSet(\"Server/Service/Engine/Host/Default\"));\r\n    digester.addRuleSet(new NamingRuleSet(\"Server/Service/Engine/Host/DefaultContext/\"));\r\n    digester.addRuleSet(new ContextRuleSet(\"Server/Service/Engine/Host/\"));\r\n    digester.addRuleSet(new NamingRuleSet(\"Server/Service/Engine/Host/Context/\"));\r\n    digester.addRule(\"Server/Service/Engine\", new SetParentClassLoaderRule(digester, parentClassLoader));\r\n    long t2 = System.currentTimeMillis();\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \"Digester for server.xml created \" + (t2 - t1));\r\n    return (digester);\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.results.ActionReportResult.getCommandDisplayName",
	"Comment": "returns display name for command associated with the command resource.",
	"Method": "String getCommandDisplayName(){\r\n    return commandDisplayName;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.Environment.getStringOption",
	"Comment": "return the value of the environment entry correspondingto the named option.",
	"Method": "String getStringOption(String name){\r\n    return env.get(optionToEnv(name));\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.jts.ResourceRecoveryManagerImpl.beforeRecovery",
	"Comment": "notifies the event listeners that recovery is about to start",
	"Method": "void beforeRecovery(boolean delegated,String instance){\r\n    Set<RecoveryEventListener> listeners = recoveryListenersRegistry.getEventListeners();\r\n    for (RecoveryEventListener erl : listeners) {\r\n        try {\r\n            erl.beforeRecovery(delegated, instance);\r\n        } catch (Throwable e) {\r\n            _logger.log(Level.WARNING, \"\", e);\r\n            _logger.log(Level.WARNING, \"jts.before_recovery_excep\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.invokeMethod",
	"Comment": "use reflection to invoke the requested method. cache the method object to speed up the process",
	"Method": "Object invokeMethod(ApplicationContext appContext,String methodName,Object[] params){\r\n    try {\r\n        Method method = objectCache.get(methodName);\r\n        if (method == null) {\r\n            method = appContext.getClass().getMethod(methodName, classCache.get(methodName));\r\n            objectCache.put(methodName, method);\r\n        }\r\n        return executeMethod(method, appContext, params);\r\n    } catch (Exception ex) {\r\n        handleException(ex, methodName);\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "components.renderkit.RepeaterRenderer.getColumnCount",
	"Comment": "return the number of child components of type uicolumnare registered with the specified uidata component.",
	"Method": "int getColumnCount(UIData data){\r\n    int n = 0;\r\n    Iterator kids = data.getChildren().iterator();\r\n    while (kids.hasNext()) {\r\n        if (kids.next() instanceof UIColumn) {\r\n            n++;\r\n        }\r\n    }\r\n    return (n);\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ModifiedAttributeHASession.getModifiedAttributes",
	"Comment": "return an arraylist of stringswhose elements are the names of the modified attributesattributes must dirty, persistent and not deleted",
	"Method": "List<String> getModifiedAttributes(){\r\n    List<String> resultList = new ArrayList<String>();\r\n    for (Map.Entry<String, SessionAttributeState> entry : _attributeStates.entrySet()) {\r\n        SessionAttributeState nextAttrState = entry.getValue();\r\n        String nextAttrName = entry.getKey();\r\n        if (nextAttrState.isDirty() && nextAttrState.isPersistent() && (!nextAttrState.isDeleted())) {\r\n            resultList.add(nextAttrName);\r\n        }\r\n    }\r\n    return resultList;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.setSslSessionTimeout",
	"Comment": "sets the number of seconds after which ssl sessions expire and areremoved from the ssl sessions cache.",
	"Method": "void setSslSessionTimeout(String timeout){\r\n    setProperty(\"sslSessionTimeout\", timeout);\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.findResource",
	"Comment": "find the specified resource in our local repository, and return aurl referring to it, or null if this resourcecannot be found.",
	"Method": "URL findResource(String name){\r\n    if (logger.isLoggable(Level.FINER))\r\n        logger.log(Level.FINER, \"    findResource(\" + name + \")\");\r\n    URL url = null;\r\n    if (\".\".equals(name)) {\r\n        name = \"\";\r\n    }\r\n    ResourceEntry entry = resourceEntries.get(name);\r\n    if (entry == null) {\r\n        entry = findResourceInternal(name, name);\r\n    }\r\n    if (entry != null) {\r\n        url = entry.source;\r\n    }\r\n    if ((url == null) && hasExternalRepositories)\r\n        url = super.findResource(name);\r\n    if (logger.isLoggable(Level.FINER)) {\r\n        if (url != null)\r\n            logger.log(Level.FINER, \"    --> Returning '\" + url.toString() + \"'\");\r\n        else\r\n            logger.log(Level.FINER, \"    --> Resource not found, returning null\");\r\n    }\r\n    return (url);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.intf.InterfaceMatchMethodArgs.runIndividualMethodTest",
	"Comment": "run an individual verifier test against a declared method of the local interface.",
	"Method": "boolean runIndividualMethodTest(EjbDescriptor descriptor,Method method,Result result){\r\n    boolean businessMethodFound, signaturesMatch;\r\n    ComponentNameConstructor compName = null;\r\n    try {\r\n        compName = getVerifierContext().getComponentNameConstructor();\r\n        ClassLoader jcl = getVerifierContext().getClassLoader();\r\n        Class EJBClass = Class.forName(descriptor.getEjbClassName(), false, jcl);\r\n        Class[] methodParameterTypes = method.getParameterTypes();\r\n        do {\r\n            businessMethodFound = false;\r\n            signaturesMatch = false;\r\n            for (Method businessMethod : EJBClass.getDeclaredMethods()) {\r\n                if (method.getName().equals(businessMethod.getName())) {\r\n                    businessMethodFound = true;\r\n                    Class[] businessMethodParameterTypes = businessMethod.getParameterTypes();\r\n                    if (Arrays.equals(methodParameterTypes, businessMethodParameterTypes)) {\r\n                        signaturesMatch = true;\r\n                        break;\r\n                    }\r\n                } else {\r\n                    continue;\r\n                }\r\n            }\r\n            if (businessMethodFound && signaturesMatch) {\r\n                addGoodDetails(result, compName);\r\n                result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"The corresponding business method with a matching \" + \"parameters was found.\"));\r\n                return true;\r\n            } else if (businessMethodFound && !signaturesMatch) {\r\n                logger.log(Level.FINE, getClass().getName() + \".debug1\", new Object[] { method.getDeclaringClass().getName(), method.getName() });\r\n                logger.log(Level.FINE, getClass().getName() + \".debug3\", new Object[] { method.getName() });\r\n                logger.log(Level.FINE, getClass().getName() + \".debug2\");\r\n            }\r\n        } while (((EJBClass = EJBClass.getSuperclass()) != null) && (!(businessMethodFound && signaturesMatch)));\r\n        if (!signaturesMatch) {\r\n            addErrorDetails(result, compName);\r\n            result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: No corresponding business method with matching \" + \"arguments was found for method [ {0} ].\", new Object[] { method.getName() }));\r\n        }\r\n    } catch (ClassNotFoundException e) {\r\n        Verifier.debug(e);\r\n        addErrorDetails(result, compName);\r\n        result.failed(smh.getLocalString(getClass().getName() + \".failedException\", \"Error: \" + getInterfaceType() + \" interface [ {0} ] does not \" + \"exist or is not loadable within bean [ {1} ]\", new Object[] { getClassName(descriptor), descriptor.getName() }));\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.ejbfindbyprimarykey.EjbFindByPrimaryKeyPublic.check",
	"Comment": "define ejbfindbyprimarykey method public test.every entity enterprise bean class must define the ejbfindbyprimarykey method. an ejbfindbyprimarykey method must be declared as public.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (descriptor instanceof EjbEntityDescriptor) {\r\n        String persistentType = ((EjbEntityDescriptor) descriptor).getPersistenceType();\r\n        if (EjbEntityDescriptor.BEAN_PERSISTENCE.equals(persistentType)) {\r\n            boolean ejbFindByPrimaryKeyMethodFound = false;\r\n            boolean isPublic = false;\r\n            boolean oneFailed = false;\r\n            int findMethodModifiers = 0;\r\n            try {\r\n                VerifierTestContext context = getVerifierContext();\r\n                ClassLoader jcl = context.getClassLoader();\r\n                Class EJBClass = Class.forName(descriptor.getEjbClassName(), false, getVerifierContext().getClassLoader());\r\n                do {\r\n                    Method[] ejbFinderMethods = EJBClass.getDeclaredMethods();\r\n                    for (int j = 0; j < ejbFinderMethods.length; ++j) {\r\n                        if (ejbFinderMethods[j].getName().equals(\"ejbFindByPrimaryKey\")) {\r\n                            ejbFindByPrimaryKeyMethodFound = true;\r\n                            findMethodModifiers = ejbFinderMethods[j].getModifiers();\r\n                            if (Modifier.isPublic(findMethodModifiers)) {\r\n                                isPublic = true;\r\n                            }\r\n                            if (ejbFindByPrimaryKeyMethodFound && isPublic) {\r\n                                result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                                result.addGoodDetails(smh.getLocalString(getClass().getName() + \".debug1\", \"For EJB Class [ {0} ] Finder Method [ {1} ]\", new Object[] { EJBClass.getName(), ejbFinderMethods[j].getName() }));\r\n                                result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"The public [ {0} ] method was found.\", new Object[] { ejbFinderMethods[j].getName() }));\r\n                            } else if (ejbFindByPrimaryKeyMethodFound && !isPublic) {\r\n                                oneFailed = true;\r\n                                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                                result.addErrorDetails(smh.getLocalString(getClass().getName() + \".debug1\", \"For EJB Class [ {0} ] Finder Method [ {1} ]\", new Object[] { EJBClass.getName(), ejbFinderMethods[j].getName() }));\r\n                                result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: An [ {0} ] method was found, but was not public.\", new Object[] { ejbFinderMethods[j].getName() }));\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                } while (((EJBClass = EJBClass.getSuperclass()) != null) && (!ejbFindByPrimaryKeyMethodFound));\r\n                if (!ejbFindByPrimaryKeyMethodFound) {\r\n                    oneFailed = true;\r\n                    result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                    result.addErrorDetails(smh.getLocalString(getClass().getName() + \".debug3\", \"For EJB Class [ {0} ]\", new Object[] { descriptor.getEjbClassName() }));\r\n                    result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed1\", \"Error: No ejbFindByPrimaryKey method was found in bean class.\"));\r\n                }\r\n            } catch (ClassNotFoundException e) {\r\n                Verifier.debug(e);\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.failed(smh.getLocalString(getClass().getName() + \".failedException\", \"Error: EJB Class [ {0} ] does not exist or is not loadable.\", new Object[] { descriptor.getEjbClassName() }));\r\n                oneFailed = true;\r\n            }\r\n            if (oneFailed) {\r\n                result.setStatus(result.FAILED);\r\n            } else {\r\n                result.setStatus(result.PASSED);\r\n            }\r\n        } else {\r\n            result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable2\", \"Expected persistence type [ {0} ], but bean [ {1} ] has persistence type [ {2} ]\", new Object[] { EjbEntityDescriptor.BEAN_PERSISTENCE, descriptor.getName(), persistentType }));\r\n        }\r\n        return result;\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"[ {0} ] expected {1} bean, but called with {2} bean.\", new Object[] { getClass(), \"Entity\", \"Session\" }));\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.security.common.FileRealmHelper.persist",
	"Comment": "write keyfile data out to disk. the file generation is sychronizedwithin this class only, caller is responsible for any otherfile locking or revision management as deemed necessary.",
	"Method": "void persist(){\r\n    synchronized (FileRealmHelper.class) {\r\n        FileOutputStream out = null;\r\n        try {\r\n            out = new FileOutputStream(keyfile);\r\n            for (Map.Entry<String, User> uval : userTable.entrySet()) {\r\n                String algo = uval.getValue().getAlgo();\r\n                String entry = encodeUser(uval.getKey(), uval.getValue(), algo);\r\n                out.write(entry.getBytes());\r\n            }\r\n        } catch (IOException e) {\r\n            throw e;\r\n        } catch (Exception e) {\r\n            String msg = sm.getString(\"filerealm.badwrite\", e.toString());\r\n            throw new IOException(msg);\r\n        } finally {\r\n            if (out != null) {\r\n                out.close();\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.jmx.AttributeListUtils.containsNamedAttribute",
	"Comment": "checks whether an attribute with the name same as that of the givenattribute exists in this list. the given name may not be null.",
	"Method": "boolean containsNamedAttribute(AttributeList al,String name,boolean containsNamedAttribute,AttributeList al,Attribute a){\r\n    if (al == null || a == null) {\r\n        throw new IllegalArgumentException(\"null arg\");\r\n    }\r\n    return (containsNamedAttribute(al, a.getName()));\r\n}"
}, {
	"Path": "org.apache.catalina.loader.StandardClassLoader.findClass",
	"Comment": "find the specified class in our local repositories, if possible.ifnot found, throw classnotfoundexception.",
	"Method": "Class findClass(String name){\r\n    if (debug >= 3)\r\n        log(\"    findClass(\" + name + \")\");\r\n    if (securityManager != null) {\r\n        int i = name.lastIndexOf('.');\r\n        if (i >= 0) {\r\n            try {\r\n                if (debug >= 4)\r\n                    log(\"      securityManager.checkPackageDefinition\");\r\n                securityManager.checkPackageDefinition(name.substring(0, i));\r\n            } catch (Exception se) {\r\n                if (debug >= 4)\r\n                    log(\"      -->Exception-->ClassNotFoundException\", se);\r\n                throw new ClassNotFoundException(name, se);\r\n            }\r\n        }\r\n    }\r\n    Class clazz = null;\r\n    try {\r\n        if (debug >= 4)\r\n            log(\"      super.findClass(\" + name + \")\");\r\n        try {\r\n            synchronized (this) {\r\n                clazz = findLoadedClass(name);\r\n                if (clazz != null)\r\n                    return clazz;\r\n                clazz = super.findClass(name);\r\n            }\r\n        } catch (AccessControlException ace) {\r\n            throw new ClassNotFoundException(name, ace);\r\n        } catch (RuntimeException e) {\r\n            if (debug >= 4)\r\n                log(\"      -->RuntimeException Rethrown\", e);\r\n            throw e;\r\n        }\r\n        if (clazz == null) {\r\n            if (debug >= 3)\r\n                log(\"    --> Returning ClassNotFoundException\");\r\n            throw new ClassNotFoundException(name);\r\n        }\r\n    } catch (ClassNotFoundException e) {\r\n        if (debug >= 3)\r\n            log(\"    --> Passing on ClassNotFoundException\", e);\r\n        throw e;\r\n    }\r\n    if (debug >= 4) {\r\n        log(\"      Returning class \" + clazz);\r\n        log(\"      Loaded by \" + clazz.getClassLoader());\r\n    }\r\n    return (clazz);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TerminatorImpl.rollback",
	"Comment": "demands that the transaction represented by the terminator objectbe rolled back.no heuristics are reported by this operation so if the root coordinatorraises a heuristic exception, it is cleared before the operationreturns to the caller.this operation is part of the omg interface and must not returnany exceptions other than those defined in the omg interface.",
	"Method": "void rollback(){\r\n    preCompletionCheck();\r\n    try {\r\n        coordTerm.rollback();\r\n    } catch (HeuristicMixed exc) {\r\n        control.destroy();\r\n    } catch (HeuristicHazard exc) {\r\n        control.destroy();\r\n    } catch (TRANSACTION_ROLLEDBACK exc) {\r\n        control.destroy();\r\n        throw exc;\r\n    } catch (LogicErrorException exc) {\r\n        control.destroy();\r\n        INTERNAL ex2 = new INTERNAL(MinorCode.LogicError, CompletionStatus.COMPLETED_NO);\r\n        throw ex2;\r\n    } catch (INTERNAL exc) {\r\n        control.destroy();\r\n        throw (INTERNAL) exc;\r\n    }\r\n    control.destroy();\r\n}"
}, {
	"Path": "com.sun.appserv.web.taglibs.cache.CacheUtil.getCache",
	"Comment": "this is used to get the cache itself. the cache is stored as anattribute in the specified scope.",
	"Method": "Cache getCache(PageContext pc,int scope){\r\n    return (Cache) pc.getAttribute(Constants.JSPTAG_CACHE_KEY, scope);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.webservices.WebServiceCheckMgrImpl.getTestsListFileName",
	"Comment": "return the configuration file name for the list of tests pertinent to theconnector architecture",
	"Method": "String getTestsListFileName(){\r\n    return testsListFileName;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.metadata.RestMethodMetadata.toJson",
	"Comment": "build and return a json object representing the metadata for the resource method",
	"Method": "JSONObject toJson(){\r\n    JSONObject o = new JSONObject();\r\n    if (path != null) {\r\n        o.put(\"path\", path);\r\n    }\r\n    JSONObject queryParamJson = new JSONObject();\r\n    for (ParamMetadata pmd : queryParameters) {\r\n        queryParamJson.put(pmd.getName(), pmd.toJson());\r\n    }\r\n    if (consumes != null) {\r\n        JSONArray array = new JSONArray();\r\n        for (String type : consumes) {\r\n            array.put(type);\r\n        }\r\n        o.put(\"accepts\", array);\r\n    }\r\n    if (produces != null) {\r\n        JSONArray array = new JSONArray();\r\n        for (String type : produces) {\r\n            array.put(type);\r\n        }\r\n        o.put(\"produces\", array);\r\n    }\r\n    o.put(\"queryParams\", queryParamJson);\r\n    if (requestPayload != null) {\r\n        JSONObject requestProps = new JSONObject();\r\n        requestProps.put(\"isCollection\", isCollection);\r\n        requestProps.put(\"dataType\", getTypeString(requestPayload));\r\n        requestProps.put(\"properties\", getProperties(requestPayload));\r\n        o.put(\"request\", requestProps);\r\n    }\r\n    if (returnPayload != null) {\r\n        JSONObject returnProps = new JSONObject();\r\n        returnProps.put(\"isCollection\", isCollection);\r\n        returnProps.put(\"dataType\", getTypeString(returnPayload));\r\n        returnProps.put(\"properties\", getProperties(returnPayload));\r\n        o.put(\"response\", returnProps);\r\n    }\r\n    return o;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.apiscan.packaging.DeweyDecimal.hashCode",
	"Comment": "provides value semantics, hence we should overrise hashcode and equals method.",
	"Method": "int hashCode(){\r\n    return major + minor + micro;\r\n}"
}, {
	"Path": "test.TestBean.testA1WithFlush",
	"Comment": "run test for cmp1.1 bean with flush after businessmethod. this method will fail at flush and the clientwill get our flushexception.",
	"Method": "void testA1WithFlush(){\r\n    a1bean = a1Home.create(\"B1\");\r\n    try {\r\n        a1bean.setNameWithFlush(\"A12345678901234567890\");\r\n    } catch (EJBException e) {\r\n        if (isExpectedException(e))\r\n            throw new FlushException(e.toString());\r\n        else\r\n            throw e;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.setRequestedSessionCookie",
	"Comment": "set a flag indicating whether or not the requested session id for thisrequest came in through a cookie.this is normally called by thehttp connector, when it parses the request headers.",
	"Method": "void setRequestedSessionCookie(boolean flag){\r\n    this.requestedSessionCookie = flag;\r\n}"
}, {
	"Path": "org.glassfish.internal.logging.Loggable.getMessageBody",
	"Comment": "gets the contents of the message body without appending a stack trace. thisis particularly useful when using the value of a loggables message as thevalue when creating an exception.",
	"Method": "String getMessageBody(){\r\n    return getMessage(true, false);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmpFieldNameStartLowercase.runIndividualCmpFieldTest",
	"Comment": "run an individual verifier test of a declated cmp field of the class",
	"Method": "boolean runIndividualCmpFieldTest(Descriptor entity,Descriptor persistentField,Class c,Result result){\r\n    return startWithLowercasedLetter(persistentField.getName(), result);\r\n}"
}, {
	"Path": "org.glassfish.admin.monitor.StatsProviderManagerDelegateImpl.disableStatsProviders",
	"Comment": "called from smpd, when monitoring level for a module is turned off",
	"Method": "void disableStatsProviders(String configElement){\r\n    if (logger.isLoggable(Level.FINE))\r\n        logger.fine(\"Disabling all the statsProviders for - \" + configElement);\r\n    List<StatsProviderRegistryElement> spreList = statsProviderRegistry.getStatsProviderRegistryElement(configElement);\r\n    if (spreList == null)\r\n        return;\r\n    for (StatsProviderRegistryElement spre : spreList) {\r\n        if (spre.isEnabled())\r\n            disableStatsProvider(spre);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.CLICommand.quote",
	"Comment": "quote a value, if the value contains any special characters.",
	"Method": "String quote(String value){\r\n    int len = value.length();\r\n    if (len == 0)\r\n        return \"\\\"\\\"\";\r\n    boolean needQuoting = false;\r\n    for (int i = 0; i < len; i++) {\r\n        char c = value.charAt(i);\r\n        if (c == '\"' || c == '\\\\' || c == '\\r' || c == '\\n') {\r\n            StringBuffer sb = new StringBuffer(len + 3);\r\n            sb.append('\"');\r\n            sb.append(value.substring(0, i));\r\n            int lastc = 0;\r\n            for (int j = i; j < len; j++) {\r\n                char cc = value.charAt(j);\r\n                if ((cc == '\"') || (cc == '\\\\') || (cc == '\\r') || (cc == '\\n'))\r\n                    if (cc == '\\n' && lastc == '\\r')\r\n                        ;\r\n                    else\r\n                        sb.append('\\\\');\r\n                sb.append(cc);\r\n                lastc = cc;\r\n            }\r\n            sb.append('\"');\r\n            return sb.toString();\r\n        } else if (c <= 040 || c >= 0177)\r\n            needQuoting = true;\r\n    }\r\n    if (needQuoting) {\r\n        StringBuffer sb = new StringBuffer(len + 2);\r\n        sb.append('\"').append(value).append('\"');\r\n        return sb.toString();\r\n    } else\r\n        return value;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.getUrlPatternToServletNameMap",
	"Comment": "this method is used by webcomponentdescriptor only.the returned map is supposed to be only modified by the corresponding url patterns set.",
	"Method": "Map<String, String> getUrlPatternToServletNameMap(){\r\n    if (urlPattern2ServletName == null) {\r\n        urlPattern2ServletName = new HashMap<String, String>();\r\n        for (WebComponentDescriptor wc : getWebComponentDescriptors()) {\r\n            String name = wc.getCanonicalName();\r\n            for (String up : wc.getUrlPatternsSet()) {\r\n                String oldName = urlPattern2ServletName.put(up, name);\r\n                if (oldName != null && (!oldName.equals(name))) {\r\n                    throw new RuntimeException(localStrings.getLocalString(\"web.deployment.exceptionsameurlpattern\", \"Servlet [{0}] and Servlet [{1}] have the same url pattern: [{2}]\", new Object[] { oldName, name, up }));\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return urlPattern2ServletName;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.appclient.AppClientCheckMgrImpl.getSunONETestsListFileName",
	"Comment": "return the configuration file name for the list of tests pertinent to theapplication client architecture",
	"Method": "String getSunONETestsListFileName(){\r\n    return sunONETestsListFileName;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.getFeature",
	"Comment": "returns a flag indicating whether the requested feature is supportedby the underlying implementation of org.xml.sax.xmlreader.see for information about the standard sax2 feature flags.",
	"Method": "boolean getFeature(String feature){\r\n    return (getFactory().getFeature(feature));\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.PartItem.get",
	"Comment": "returns the contents of the file as an array of bytes.if thecontents of the file were not yet cached in memory, they will beloaded from the disk storage and cached.",
	"Method": "byte[] get(){\r\n    if (isInMemory()) {\r\n        if (cachedContent == null) {\r\n            cachedContent = dfos.getData();\r\n        }\r\n        return cachedContent;\r\n    }\r\n    byte[] fileData = new byte[(int) getSize()];\r\n    FileInputStream fis = null;\r\n    try {\r\n        fis = new FileInputStream(dfos.getFile());\r\n        if (fis.read(fileData) != (int) getSize())\r\n            if (log.isLoggable(Level.INFO))\r\n                log.log(Level.INFO, LogFacade.FILE_DATA_IS_EMPTY_INFO);\r\n    } catch (IOException e) {\r\n        fileData = null;\r\n    } finally {\r\n        if (fis != null) {\r\n            try {\r\n                fis.close();\r\n            } catch (IOException e) {\r\n            }\r\n        }\r\n    }\r\n    return fileData;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmpFieldAccessorModifiers.runIndividualCmpFieldTest",
	"Comment": "run an individual verifier test of a declated cmp field of the class",
	"Method": "boolean runIndividualCmpFieldTest(Descriptor entity,Descriptor persistentField,Class c,Result result){\r\n    return accessorMethodModifiers(persistentField.getName(), c, result);\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.DeploymentContextImpl.getModuleProps",
	"Comment": "returns the module level properties that will be persisted as akey value pair at then end of deployment. that allows individualdeployers implementation to store some information at the modulelevel that should be available upon server restart.module level properties are only visible to the current module.",
	"Method": "Properties getModuleProps(){\r\n    if (props == null) {\r\n        props = new Properties();\r\n    }\r\n    return props;\r\n}"
}, {
	"Path": "com.sun.web.server.WebContainerListener.preDestroy",
	"Comment": "invokes predestroy on the instance embedded in the given containerevent.",
	"Method": "void preDestroy(ContainerEvent event){\r\n    try {\r\n        injectionMgr.destroyManagedObject(event.getData(), false);\r\n    } catch (Throwable t) {\r\n        String msg = rb.getString(LogFacade.EXCEPTION_DURING_DESTROY_MANAGED_OBJECT);\r\n        msg = MessageFormat.format(msg, new Object[] { event.getData(), event.getContainer() });\r\n        _logger.log(Level.SEVERE, msg, t);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.managed.ManagedConnectionFactoryTest.getManagedConnectionFactoryImpl",
	"Comment": "get the class object of the class declared to be implementingthe javax.resource.spi.managedconnectionfactory interface in the archive deployment descriptor",
	"Method": "Class getManagedConnectionFactoryImpl(ConnectorDescriptor descriptor){\r\n    OutboundResourceAdapter outboundRA = descriptor.getOutboundResourceAdapter();\r\n    if (outboundRA == null) {\r\n        return null;\r\n    }\r\n    Set connDefs = outboundRA.getConnectionDefs();\r\n    Iterator iter = connDefs.iterator();\r\n    while (iter.hasNext()) {\r\n        ConnectionDefDescriptor connDefDesc = (ConnectionDefDescriptor) iter.next();\r\n        managedConnectionFactoryImpl = connDefDesc.getManagedConnectionFactoryImpl();\r\n        Class implClass = Class.forName(managedConnectionFactoryImpl, false, getVerifierContext().getClassLoader());\r\n        if (isImplementorOf(implClass, \"javax.resource.spi.ManagedConnectionFactory\")) {\r\n            return implClass;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.web.embed.impl.WebContainerImpl.removeVirtualServer",
	"Comment": "stops the given virtualserver and removes it from thiswebcontainer.",
	"Method": "void removeVirtualServer(VirtualServer virtualServer){\r\n    if (!initialized) {\r\n        init();\r\n    }\r\n    if (virtualServer instanceof Container) {\r\n        engine.removeChild((Container) virtualServer);\r\n    } else if (virtualServer instanceof VirtualServerFacade) {\r\n        engine.removeChild(((VirtualServerFacade) virtualServer).getVirtualServer());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.InstanceDirUtils.getLocalInstanceDir",
	"Comment": "returns the directory for the selected instance that is on the localsystem.",
	"Method": "File getLocalInstanceDir(String instance){\r\n    String nodeDir = node.getNodeDirAbsolute();\r\n    final File nodeDirFile = (nodeDir != null ? new File(nodeDir) : defaultLocalNodeDirFile());\r\n    InstanceDirs instanceDirs = new InstanceDirs(nodeDirFile.toString(), node.getName(), instance);\r\n    return instanceDirs.getInstanceDir();\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHostDeployer.getName",
	"Comment": "return the name of the container with which this deployer is associated.",
	"Method": "String getName(){\r\n    return (host.getName());\r\n}"
}, {
	"Path": "org.glassfish.common.util.admin.ManPageFinder.getCommandManPage",
	"Comment": "get the man page for the given command for the given localeusing the given classloader.",
	"Method": "BufferedReader getCommandManPage(String cmdName,String cmdClass,Locale locale,ClassLoader classLoader,Logger logger){\r\n    InputStream s = null;\r\n    Iterator it = getPossibleLocations(cmdName, cmdClass, locale, logger);\r\n    while (s == null && it.hasNext()) {\r\n        s = classLoader.getResourceAsStream((String) it.next());\r\n    }\r\n    if (s == null)\r\n        return null;\r\n    Reader r;\r\n    try {\r\n        r = new InputStreamReader(s, \"utf-8\");\r\n    } catch (UnsupportedEncodingException ex) {\r\n        r = new InputStreamReader(s);\r\n    }\r\n    return new BufferedReader(r);\r\n}"
}, {
	"Path": "com.sun.enterprise.util.Utility.setContextClassLoader",
	"Comment": "utility routine for setting the context class loader.returns previous class loader.",
	"Method": "ClassLoader setContextClassLoader(ClassLoader newClassLoader){\r\n    final ClassLoader classLoaderToSet = newClassLoader;\r\n    final Thread currentThread = Thread.currentThread();\r\n    ClassLoader originalClassLoader = currentThread.getContextClassLoader();\r\n    if (classLoaderToSet != originalClassLoader) {\r\n        if (System.getSecurityManager() == null) {\r\n            currentThread.setContextClassLoader(classLoaderToSet);\r\n        } else {\r\n            java.security.AccessController.doPrivileged(new java.security.PrivilegedAction() {\r\n                public java.lang.Object run() {\r\n                    currentThread.setContextClassLoader(classLoaderToSet);\r\n                    return null;\r\n                }\r\n            });\r\n        }\r\n    }\r\n    return originalClassLoader;\r\n}"
}, {
	"Path": "com.sun.enterprise.util.Utility.setContextClassLoader",
	"Comment": "utility routine for setting the context class loader.returns previous class loader.",
	"Method": "ClassLoader setContextClassLoader(ClassLoader newClassLoader){\r\n    currentThread.setContextClassLoader(classLoaderToSet);\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.setRequestURI",
	"Comment": "set the unparsed request uri for this request.this will normally becalled by the http connector, when it parses the request headers.used by fbl when restoring original request after successful authentication.",
	"Method": "void setRequestURI(String uri){\r\n    coyoteRequest.setRequestURI(uri);\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebResourceCollectionImpl.getHttpMethods",
	"Comment": "return the enumeration of http methods this collection has.",
	"Method": "Set<String> getHttpMethods(){\r\n    if (this.httpMethods == null) {\r\n        this.httpMethods = new HashSet<String>();\r\n    }\r\n    return this.httpMethods;\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionState.beforeCompletion",
	"Comment": "this is called via callback of synchronizationright before a transaction commit or rollbackto ensure that all xaresources are properly delisted",
	"Method": "void beforeCompletion(){\r\n    boolean exceptionThrown = false;\r\n    XAResource res = null;\r\n    Iterator e = resourceStates.keySet().iterator();\r\n    while (e.hasNext()) {\r\n        try {\r\n            res = (XAResource) e.next();\r\n            int XAState = getXAState(res);\r\n            switch(XAState) {\r\n                case NOT_ASSOCIATED:\r\n                case FAILED:\r\n                    break;\r\n                case ASSOCIATION_SUSPENDED:\r\n                case ASSOCIATED:\r\n                    Xid xid = (Xid) resourceList.get(res);\r\n                    res.end(xid, XAResource.TMSUCCESS);\r\n                    setXAState(res, NOT_ASSOCIATED);\r\n                    break;\r\n                case ROLLING_BACK:\r\n                case NOT_EXIST:\r\n                default:\r\n                    throw new IllegalStateException(\"Wrong XA State: \" + XAState);\r\n            }\r\n        } catch (Exception ex) {\r\n            setXAState(res, FAILED);\r\n            _logger.log(Level.WARNING, \"jts.delist_exception\", ex);\r\n            exceptionThrown = true;\r\n        }\r\n    }\r\n    if (exceptionThrown) {\r\n        try {\r\n            tran.setRollbackOnly();\r\n        } catch (Exception ex) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.kernel.embedded.EmbeddedDomainPersistence.getDestination",
	"Comment": "returns the destination file for saving the embedded configuration file,when set.",
	"Method": "File getDestination(){\r\n    String configFileReadOnly = startupContext.getArguments().getProperty(\"org.glassfish.embeddable.configFileReadOnly\");\r\n    if (configFileReadOnly != null && !Boolean.valueOf(configFileReadOnly).booleanValue()) {\r\n        try {\r\n            URI uri = EmbeddedDomainXml.getDomainXml(startupContext).toURI();\r\n            if (\"file\".equalsIgnoreCase(uri.getScheme())) {\r\n                return new File(uri);\r\n            } else {\r\n                throw new IOException(\"configurationFile is writable but is not a file\");\r\n            }\r\n        } catch (URISyntaxException ex) {\r\n            throw new IOException(ex);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.webservices.monitoring.WebServiceEngineImpl.postProcessResponse",
	"Comment": "callback when a web service response has finished being processedby the container and was sent back to the client",
	"Method": "void postProcessResponse(String messageID,TransportInfo info){\r\n    if (globalMessageListener == null)\r\n        return;\r\n    globalMessageListener.postProcessResponse(messageID, info);\r\n}"
}, {
	"Path": "com.sun.jts.utils.LogFormatter.convertXidArrayToString",
	"Comment": "converts an array of xids to string that can be printed. its a helper method.",
	"Method": "String convertXidArrayToString(Xid[] xidArray){\r\n    if (xidArray.length != 0) {\r\n        int i;\r\n        StringBuffer strBuf = new StringBuffer(\"Xid class name is \" + xidArray[0].getClass().getName() + \" Number of Xids are \" + xidArray.length + \" [ \");\r\n        for (i = 0; i < xidArray.length - 1; i++) {\r\n            strBuf.append(xidArray[i]).append(\"\\n\");\r\n        }\r\n        strBuf.append(xidArray[xidArray.length - 1]).append(\" ]\");\r\n        return strBuf.toString();\r\n    } else\r\n        return \" null \";\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.EntityBeanInterface.check",
	"Comment": "implements the entitybeaan interface test.all entity beans must implement, directly or indirectly, the entitybean interface.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (descriptor instanceof EjbEntityDescriptor) {\r\n        try {\r\n            Class c = Class.forName(descriptor.getEjbClassName(), false, getVerifierContext().getClassLoader());\r\n            boolean validBean = false;\r\n            do {\r\n                Class[] interfaces = c.getInterfaces();\r\n                for (int i = 0; i < interfaces.length; i++) {\r\n                    logger.log(Level.FINE, getClass().getName() + \".debug1\", new Object[] { interfaces[i].getName() });\r\n                    if (interfaces[i].getName().equals(\"javax.ejb.EntityBean\") && descriptor instanceof EjbEntityDescriptor) {\r\n                        validBean = true;\r\n                        result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"[ {0} ] properly implements the EntityBean interface.\", new Object[] { descriptor.getEjbClassName() }));\r\n                        break;\r\n                    }\r\n                }\r\n            } while ((((c = c.getSuperclass()) != null) && (!validBean)));\r\n            if (!validBean) {\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: [ {0} ] does not properly implement the EntityBean interface.  All entity beans must implement the EntityBean interface.  [ {1} ] is not a valid bean.\", new Object[] { descriptor.getEjbClassName(), descriptor.getEjbClassName() }));\r\n            }\r\n        } catch (ClassNotFoundException e) {\r\n            Verifier.debug(e);\r\n            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.failed(smh.getLocalString(getClass().getName() + \".failedException\", \"Error: [ {0} ] class not found.\", new Object[] { descriptor.getEjbClassName() }));\r\n        }\r\n        return result;\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"[ {0} ] expected {1} bean, but called with {2} bean.\", new Object[] { getClass(), \"Entity\", \"Session\" }));\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.AuthenticatorBase.setChangeSessionIdOnAuthentication",
	"Comment": "set the value of the flag that states if we should change the session idof an existing session upon successful authentication.",
	"Method": "void setChangeSessionIdOnAuthentication(boolean changeSessionIdOnAuthentication){\r\n    this.changeSessionIdOnAuthentication = changeSessionIdOnAuthentication;\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.HAStoreBase.remove",
	"Comment": "remove the session with the specified session identifier from this store, if present.if no such session is present, this method takes no action.",
	"Method": "void remove(String id){\r\n    if (_debug > 0) {\r\n        debug(\"in remove\");\r\n    }\r\n    if (id == null) {\r\n        if (_debug > 0) {\r\n            debug(\"In remove, got a null id\");\r\n        }\r\n        return;\r\n    }\r\n    Manager mgr = this.getManager();\r\n    if (mgr instanceof ReplicationManagerBase) {\r\n        ReplicationManagerBase pMgr = (ReplicationManagerBase) mgr;\r\n        pMgr.doRemove(id);\r\n    } else {\r\n        this.removeSynchronized(id);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.getEntityManagerReferenceByName",
	"Comment": "return the entity manager factory reference descriptor corresponding tothe given name.",
	"Method": "EntityManagerReferenceDescriptor getEntityManagerReferenceByName(String name){\r\n    EntityManagerReferenceDescriptor emr = _getEntityManagerReferenceByName(name);\r\n    if (emr != null) {\r\n        return emr;\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"web.deployment.exceptionwebapphasnoentitymgrrefbyname\", \"This web app [{0}] has no entity manager reference by the name of [{1}]\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "org.apache.catalina.util.StringParser.findWhite",
	"Comment": "return the index of the next occurrence of a whitespace character,or the index of the character after the last position of the stringif no more whitespace characters are found.the current parsingposition is updated to the returned value.",
	"Method": "int findWhite(){\r\n    while ((index < length) && !isWhite(chars[index])) index++;\r\n    return (index);\r\n}"
}, {
	"Path": "org.glassfish.security.common.FileRealmHelper.addGroupNames",
	"Comment": "add group names to the groups table. it is assumed all entries arevalid group names.",
	"Method": "void addGroupNames(String[] groupList){\r\n    if (groupList != null) {\r\n        for (int i = 0; i < groupList.length; i++) {\r\n            Integer groupSize = groupSizeMap.get(groupList[i]);\r\n            groupSizeMap.put(groupList[i], Integer.valueOf((groupSize != null) ? (groupSize.intValue() + 1) : 1));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getServletContext",
	"Comment": "gets the servlet context to which this servlet request was lastdispatched.",
	"Method": "ServletContext getServletContext(){\r\n    return servletContext;\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.DeploymentContextImpl.getClassLoader",
	"Comment": "returns the class loader associated to this deployment request.classloader instances are usually obtained by the getclassloader api onthe associated archivehandler for the archive type being deployed.this can return null and the container should allocate a classloaderwhile loading the application.",
	"Method": "ClassLoader getClassLoader(ClassLoader getClassLoader,boolean sharable){\r\n    if (phase == Phase.PREPARE) {\r\n        if (sharable) {\r\n            return sharableTemp;\r\n        } else {\r\n            InstrumentableClassLoader cl = InstrumentableClassLoader.class.cast(sharableTemp);\r\n            return cl.copy();\r\n        }\r\n    } else {\r\n        if (sharableTemp != null) {\r\n            try {\r\n                PreDestroy.class.cast(sharableTemp).preDestroy();\r\n            } catch (Exception e) {\r\n            }\r\n            sharableTemp = null;\r\n        }\r\n        return cloader;\r\n    }\r\n}"
}, {
	"Path": "components.components.ScrollerComponent.getTotalPages",
	"Comment": "returns the total number of pages in the result set based onrows and rowcount of uidatacomponent that this scroller is associated with.for the purposes of this demo, we are assuming the uidata tobe child of uiform component and not nested inside a customnamingcontainer.",
	"Method": "int getTotalPages(FacesContext context){\r\n    String forValue = (String) getAttributes().get(\"for\");\r\n    UIData uiData = (UIData) getForm(context).findComponent(forValue);\r\n    if (uiData == null) {\r\n        return 0;\r\n    }\r\n    int rowsPerPage = uiData.getRows();\r\n    int totalRows = 0;\r\n    int result = 0;\r\n    totalRows = uiData.getRowCount();\r\n    result = totalRows / rowsPerPage;\r\n    if (0 != (totalRows % rowsPerPage)) {\r\n        result++;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.pe.PEDomainConfigValidator.getNextDuplicate",
	"Comment": "get next entry from iterator whose value is a set ofcardinality greater than 1",
	"Method": "Map.Entry getNextDuplicate(Iterator it){\r\n    while (it.hasNext()) {\r\n        Map.Entry result = (Map.Entry) it.next();\r\n        if (((Set) result.getValue()).size() > 1) {\r\n            return result;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.getMaxSavePostSize",
	"Comment": "return the maximum size of a post which will be saved by the containerduring authentication.",
	"Method": "int getMaxSavePostSize(){\r\n    return (maxSavePostSize);\r\n}"
}, {
	"Path": "org.glassfish.common.util.admin.CommandModelImpl.unknownOptionsAreOperands",
	"Comment": "should an unknown option be considered an operand by asadmin?",
	"Method": "boolean unknownOptionsAreOperands(){\r\n    return dashOk;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.JobManagerService.getCompletedJobs",
	"Comment": "this will load the jobs which have already completedand persisted in the jobs.xml",
	"Method": "JobInfos getCompletedJobs(File jobsFile){\r\n    synchronized (jobsFile) {\r\n        try {\r\n            if (jaxbContext == null)\r\n                jaxbContext = JAXBContext.newInstance(JobInfos.class);\r\n            Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();\r\n            if (jobsFile != null && jobsFile.exists()) {\r\n                JobInfos jobInfos = (JobInfos) unmarshaller.unmarshal(jobsFile);\r\n                return jobInfos;\r\n            }\r\n        } catch (JAXBException e) {\r\n            throw new RuntimeException(adminStrings.getLocalString(\"error.reading.completed.jobs\", \"Error reading completed jobs \", e.getLocalizedMessage()), e);\r\n        }\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.appserv.web.taglibs.cache.FlushTag.setKey",
	"Comment": "this is set a key for the cache element that needs to be cleared",
	"Method": "void setKey(String key){\r\n    if (key != null && key.length() > 0)\r\n        _key = key;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteAdminCommand.setCommandModel",
	"Comment": "set the commandmodel used by this command.normally thecommandmodel will be fetched from the server using thegetcommandmodel method, which will also save the commandmodelfor further use.if the commandmodel is known in advance, itcan be set with this method and avoid the call to the server.",
	"Method": "void setCommandModel(CommandModel commandModel){\r\n    this.commandModel = commandModel;\r\n    this.commandModelFromCache = false;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.mbean.SystemInfoImpl.getPerformanceMillis",
	"Comment": "return a map keyed by an arbitrary string denoting some feature.the valueis the time in milliseconds.code should not rely on the keys as they are subject tochanges, additions, or removal at any time, except as otherwise documented.even documented items should be used only for informational purposes,such as assessing performance.",
	"Method": "Map<String, Long> getPerformanceMillis(){\r\n    return new HashMap<String, Long>();\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.createServlet",
	"Comment": "instantiates the given servlet class and performs any requiredresource injection into the new servlet instance before returningit.",
	"Method": "T createServlet(Class<T> clazz){\r\n    if (SecurityUtil.isPackageProtectionEnabled()) {\r\n        return (T) doPrivileged(\"createServlet\", new Object[] { clazz });\r\n    } else {\r\n        return context.createServlet(clazz);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.getFilterRegistrations",
	"Comment": "gets a map of the filterregistration objects corresponding to allcurrently registered filters.",
	"Method": "Map<String, ? extends FilterRegistration> getFilterRegistrations(){\r\n    if (SecurityUtil.isPackageProtectionEnabled()) {\r\n        return (Map<String, FilterRegistration>) doPrivileged(\"getFilterRegistrations\", null);\r\n    } else {\r\n        return context.getFilterRegistrations();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.NamingContextListener.logName",
	"Comment": "return the abbreviated name of this container for logging messsages",
	"Method": "String logName(){\r\n    String className = this.getClass().getName();\r\n    int period = className.lastIndexOf(\".\");\r\n    if (period >= 0)\r\n        className = className.substring(period + 1);\r\n    return (className + \"[\" + getName() + \"]\");\r\n}"
}, {
	"Path": "org.apache.catalina.util.ResponseUtil.copy",
	"Comment": "copies the contents of the specified input stream to the specifiedoutput stream.",
	"Method": "IOException copy(InputStream istream,ServletOutputStream ostream,IOException copy,Reader reader,PrintWriter writer){\r\n    IOException exception = null;\r\n    char[] buffer = new char[2048];\r\n    int len;\r\n    while (true) {\r\n        try {\r\n            len = reader.read(buffer);\r\n            if (len == -1)\r\n                break;\r\n            writer.write(buffer, 0, len);\r\n        } catch (IOException e) {\r\n            exception = e;\r\n            len = -1;\r\n            break;\r\n        }\r\n    }\r\n    return exception;\r\n}"
}, {
	"Path": "components.taglib.GraphMenuBarTag.setUnselectedClass",
	"Comment": "the css style class to be applied to the textof unselected nodes. this can be value or a value binding referenceexpression.",
	"Method": "void setUnselectedClass(String styleUnselected){\r\n    this.unselectedClass = styleUnselected;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.MimeMap.getID",
	"Comment": "gets the mime id of the mime element which this mimemap represents.",
	"Method": "String getID(){\r\n    return this.id;\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.getAttribute",
	"Comment": "return the object bound with the specified name in this session, ornull if no object is bound with that name.",
	"Method": "Object getAttribute(String name){\r\n    if (!isValid())\r\n        throw new IllegalStateException(\"getAttribute: \" + rb.getString(LogFacade.SESSION_INVALIDATED_EXCEPTION));\r\n    if (name == null)\r\n        return null;\r\n    return (attributes.get(name));\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.get_transaction_name",
	"Comment": "removed synchronization at method level since only transtate requires\tlocking",
	"Method": "String get_transaction_name(){\r\n    String result = null;\r\n    if (tranState != null) {\r\n        if (name == null)\r\n            name = superInfo.globalTID.toString();\r\n        result = name;\r\n    } else {\r\n        INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.Completed, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.webservices.WSTest.check",
	"Comment": "run an individual test against the deployment descriptor for the archive the verifier is performing compliance tests against.",
	"Method": "Result check(Descriptor descriptor,Result check,WebServiceEndpoint descriptor){\r\n    return check((WebServiceEndpoint) descriptor);\r\n}"
}, {
	"Path": "org.apache.naming.NamingContextBindingsEnumeration.hasMore",
	"Comment": "determines whether there are any more elements in the enumeration.",
	"Method": "boolean hasMore(){\r\n    return iterator.hasNext();\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.TransactionSynchronizationRegistryImpl.setRollbackOnly",
	"Comment": "set the rollbackonly status of the transaction bound to thecurrent thread.",
	"Method": "void setRollbackOnly(){\r\n    try {\r\n        transactionManager.setRollbackOnly();\r\n    } catch (SystemException ex) {\r\n        throw new IllegalStateException(sm.getString(\"enterprise_distributedtx.no_transaction\"));\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContextValve.setContainer",
	"Comment": "cast to a standardcontext right away, as it will be needed later.",
	"Method": "void setContainer(Container container){\r\n    super.setContainer(container);\r\n    if (container instanceof StandardContext) {\r\n        context = (StandardContext) container;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.loader.ServletContainerInitializerUtil.getServletContainerInitializers",
	"Comment": "given a class loader, check for servletcontainerinitializerimplementations in any jar file in the classpath",
	"Method": "Iterable<ServletContainerInitializer> getServletContainerInitializers(Map<String, String> webFragmentMap,List<Object> absoluteOrderingList,boolean hasOthers,ClassLoader cl){\r\n    if ((absoluteOrderingList != null) && !hasOthers) {\r\n        if (!(cl instanceof URLClassLoader)) {\r\n            log.log(Level.WARNING, LogFacade.WRONG_CLASSLOADER_TYPE, cl.getClass().getCanonicalName());\r\n            return null;\r\n        }\r\n        final URLClassLoader webAppCl = (URLClassLoader) cl;\r\n        List<URL> newClassLoaderUrlList = new ArrayList<URL>();\r\n        for (URL classLoaderUrl : webAppCl.getURLs()) {\r\n            if (!\"file\".equals(classLoaderUrl.getProtocol())) {\r\n                continue;\r\n            }\r\n            File file = new File(classLoaderUrl.getFile());\r\n            try {\r\n                file = file.getCanonicalFile();\r\n            } catch (IOException e) {\r\n            }\r\n            if (!file.exists()) {\r\n                continue;\r\n            }\r\n            String path = file.getAbsolutePath();\r\n            if (!path.endsWith(\".jar\")) {\r\n                continue;\r\n            }\r\n            if (!isFragmentMissingFromAbsoluteOrdering(file.getName(), webFragmentMap, absoluteOrderingList)) {\r\n                newClassLoaderUrlList.add(classLoaderUrl);\r\n            }\r\n        }\r\n        URL[] urlsForNewClassLoader = new URL[newClassLoaderUrlList.size()];\r\n        final URL[] urlArray = newClassLoaderUrlList.toArray(urlsForNewClassLoader);\r\n        cl = AccessController.doPrivileged(new PrivilegedAction<URLClassLoader>() {\r\n            @Override\r\n            public URLClassLoader run() {\r\n                return new URLClassLoader(urlArray, webAppCl.getParent());\r\n            }\r\n        });\r\n    }\r\n    return ServiceLoader.load(ServletContainerInitializer.class, cl);\r\n}"
}, {
	"Path": "org.glassfish.web.loader.ServletContainerInitializerUtil.getServletContainerInitializers",
	"Comment": "given a class loader, check for servletcontainerinitializerimplementations in any jar file in the classpath",
	"Method": "Iterable<ServletContainerInitializer> getServletContainerInitializers(Map<String, String> webFragmentMap,List<Object> absoluteOrderingList,boolean hasOthers,ClassLoader cl){\r\n    return new URLClassLoader(urlArray, webAppCl.getParent());\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getWrapper",
	"Comment": "return the wrapper within which this request is being processed.",
	"Method": "Wrapper getWrapper(){\r\n    return wrapper;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.GenericAdminAuthenticator.loginAsAdmin",
	"Comment": "attempts to authenticate the user submitting the request as an administrator.",
	"Method": "Subject loginAsAdmin(String user,String password,String realm,String originHost,Subject loginAsAdmin,Request request,Subject loginAsAdmin,Request request,String hostname){\r\n    final Subject s;\r\n    try {\r\n        s = authenticate(request, hostname);\r\n        return s;\r\n    } catch (IOException ex) {\r\n        final LoginException lex = new LoginException();\r\n        lex.initCause(ex);\r\n        throw lex;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModuleConfig.getVirtualServers",
	"Comment": "return the list of virtual servers to which the web application isdeployed.",
	"Method": "String getVirtualServers(){\r\n    return _vsIDs;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.MultimodeCommand.executeCommands",
	"Comment": "read commands from the specified bufferedreader and execute them. ifprintprompt is set, prompt first.",
	"Method": "int executeCommands(BufferedReader reader){\r\n    String line;\r\n    int rc = 0;\r\n    programOpts.toEnvironment(env);\r\n    String prompt = programOpts.getCommandName() + \"> \";\r\n    for (; ; ) {\r\n        if (printPrompt) {\r\n            System.out.print(prompt);\r\n            System.out.flush();\r\n        }\r\n        if ((line = reader.readLine()) == null) {\r\n            if (printPrompt)\r\n                System.out.println();\r\n            break;\r\n        }\r\n        if (line.trim().startsWith(\"#\"))\r\n            continue;\r\n        String[] args;\r\n        try {\r\n            args = getArgs(line);\r\n        } catch (ArgumentTokenizer.ArgumentException ex) {\r\n            logger.info(ex.getMessage());\r\n            continue;\r\n        }\r\n        if (args.length == 0)\r\n            continue;\r\n        String command = args[0];\r\n        if (command.length() == 0)\r\n            continue;\r\n        if (command.equals(\"exit\") || command.equals(\"quit\"))\r\n            break;\r\n        CLICommand cmd = null;\r\n        ProgramOptions po = null;\r\n        try {\r\n            po = new ProgramOptions(env);\r\n            po.setClassPath(programOpts.getClassPath());\r\n            po.setClassName(programOpts.getClassName());\r\n            po.setCommandName(programOpts.getCommandName());\r\n            atomicReplace(habitat, po);\r\n            cmd = CLICommand.getCommand(habitat, command);\r\n            rc = cmd.execute(args);\r\n        } catch (CommandValidationException cve) {\r\n            logger.severe(cve.getMessage());\r\n            if (cmd != null)\r\n                logger.severe(cmd.getUsage());\r\n            rc = ERROR;\r\n        } catch (InvalidCommandException ice) {\r\n            logger.severe(ice.getMessage());\r\n            try {\r\n                if (po != null)\r\n                    CLIUtil.displayClosestMatch(command, CLIUtil.getAllCommands(container, po, env), strings.get(\"ClosestMatchedLocalAndRemoteCommands\"), logger);\r\n            } catch (InvalidCommandException e) {\r\n            }\r\n            rc = ERROR;\r\n        } catch (CommandException ce) {\r\n            if (ce.getCause() instanceof java.net.ConnectException) {\r\n                logger.severe(ce.getMessage());\r\n                try {\r\n                    CLIUtil.displayClosestMatch(command, CLIUtil.getLocalCommands(container), strings.get(\"ClosestMatchedLocalCommands\"), logger);\r\n                } catch (InvalidCommandException e) {\r\n                    logger.info(strings.get(\"InvalidRemoteCommand\", command));\r\n                }\r\n            } else\r\n                logger.severe(ce.getMessage());\r\n            rc = ERROR;\r\n        } finally {\r\n            atomicReplace(habitat, programOpts);\r\n        }\r\n        switch(rc) {\r\n            case SUCCESS:\r\n                if (!programOpts.isTerse())\r\n                    logger.fine(strings.get(\"CommandSuccessful\", command));\r\n                break;\r\n            case ERROR:\r\n            case INVALID_COMMAND_ERROR:\r\n            case CONNECTION_ERROR:\r\n            default:\r\n                logger.fine(strings.get(\"CommandUnSuccessful\", command));\r\n                break;\r\n        }\r\n        CLIUtil.writeCommandToDebugLog(programOpts.getCommandName() + \"[multimode]\", env, args, rc);\r\n    }\r\n    return rc;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setDocBase",
	"Comment": "set the document root for this context.this can be an absolutepathname, a relative pathname, or a url.",
	"Method": "void setDocBase(String docBase){\r\n    synchronized (this) {\r\n        this.docBase = docBase;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.util.shared.ArchivistUtils.copyWithoutClose",
	"Comment": "utility method that eads the input stream fully and writes the bytes to the current entry in the output stream.",
	"Method": "void copyWithoutClose(InputStream is,OutputStream os){\r\n    byte[] buf = new byte[4096];\r\n    int len = 0;\r\n    while (len != -1) {\r\n        try {\r\n            len = is.read(buf, 0, buf.length);\r\n        } catch (EOFException eof) {\r\n            break;\r\n        }\r\n        if (len != -1) {\r\n            os.write(buf, 0, len);\r\n        }\r\n    }\r\n    os.flush();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.DelegatedTimeoutManager.shutdown",
	"Comment": "informs the timeoutmanager that the transaction serviceis being shut down. for immediate shutdown, the timeout thread isstopped and all timeout information discarded.for quiesce, the timeout thread is stopped when there are no runningtransactions left.",
	"Method": "void shutdown(boolean immediate){\r\n    if (immediate || pendingTimeouts == null || pendingTimeouts.isEmpty()) {\r\n        if (timeoutThread != null) {\r\n            timeoutThread.stop();\r\n        }\r\n        if (pendingTimeouts != null) {\r\n            pendingTimeouts.clear();\r\n        }\r\n        pendingTimeouts = null;\r\n        timeoutThread = null;\r\n        timeoutActive = false;\r\n    } else {\r\n        quiescing = true;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.RootDeploymentDescriptor.getExtensionsDescriptors",
	"Comment": "this method returns one extension of the passed type in the scope with the right index",
	"Method": "Collection<RootDeploymentDescriptor> getExtensionsDescriptors(Collection<T> getExtensionsDescriptors,Class<T> type,T getExtensionsDescriptors,Class<? extends RootDeploymentDescriptor> type,String index){\r\n    for (T extension : (Collection<T>) getExtensionsDescriptors(type)) {\r\n        String extensionIndex = ((RootDeploymentDescriptor) extension).index;\r\n        if (index == null) {\r\n            if (extensionIndex == null) {\r\n                return extension;\r\n            }\r\n        } else {\r\n            if (index.equals(extensionIndex)) {\r\n                return extension;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardPipeline.stop",
	"Comment": "gracefully shut down active use of the public methods of this component.",
	"Method": "void stop(){\r\n    if (!started)\r\n        throw new LifecycleException(rb.getString(LogFacade.PIPLINE_NOT_STARTED));\r\n    started = false;\r\n    lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, null);\r\n    lifecycle.fireLifecycleEvent(STOP_EVENT, null);\r\n    if ((basic != null) && (basic instanceof Lifecycle))\r\n        ((Lifecycle) basic).stop();\r\n    for (int i = 0; i < valves.length; i++) {\r\n        if (valves[i] instanceof Lifecycle)\r\n            ((Lifecycle) valves[i]).stop();\r\n    }\r\n    lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, null);\r\n}"
}, {
	"Path": "com.sun.enterprise.config.serverbeans.ConfigBeansUtilities.getApplicationRefsInServer",
	"Comment": "lists the app refs for apps assigned to the specified server, excluding system apps from the result if requested.",
	"Method": "List<ApplicationRef> getApplicationRefsInServer(String sn,List<ApplicationRef> getApplicationRefsInServer,String sn,boolean excludeSystemApps){\r\n    Servers ss = domain.getServers();\r\n    List<Server> list = ss.getServer();\r\n    Server theServer = null;\r\n    for (Server s : list) {\r\n        if (s.getName().equals(sn)) {\r\n            theServer = s;\r\n            break;\r\n        }\r\n    }\r\n    if (theServer != null) {\r\n        List<ApplicationName> modulesToExclude = excludeSystemApps ? domain.getSystemApplications().getModules() : Collections.<ApplicationName>emptyList();\r\n        List<ApplicationRef> result = new ArrayList<ApplicationRef>();\r\n        for (ApplicationRef candidateRef : theServer.getApplicationRef()) {\r\n            String appRefModuleName = candidateRef.getRef();\r\n            boolean isSystem = false;\r\n            for (ApplicationName sysModule : modulesToExclude) {\r\n                if (sysModule.getName().equals(appRefModuleName)) {\r\n                    isSystem = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!isSystem) {\r\n                result.add(candidateRef);\r\n            }\r\n        }\r\n        return result;\r\n    } else {\r\n        return Collections.<ApplicationRef>emptyList();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RegisteredResources.addRes",
	"Comment": "adds a reference to a resource object to the list in theregistered state.",
	"Method": "int addRes(Resource obj){\r\n    resourceObjects.add(obj);\r\n    nRes++;\r\n    resourceStates.add(ResourceStatus.Registered);\r\n    return nRes;\r\n}"
}, {
	"Path": "org.apache.catalina.valves.AccessLogValve.invoke",
	"Comment": "log a message summarizing the specified request and response, accordingto the format specified by the pattern property.",
	"Method": "int invoke(Request request,Response response){\r\n    request.setNote(REQUEST_START_TIME_NOTE, Long.valueOf(System.currentTimeMillis()));\r\n    return INVOKE_NEXT;\r\n}"
}, {
	"Path": "com.sun.enterprise.util.i18n.StringManagerBase.getString",
	"Comment": "returns a local string for the caller and format the argumentsaccordingly.",
	"Method": "String getString(String key,String getString,String key,Object arg1,String getString,String key,Object arg1,Object arg2,String getString,String key,Object arg1,Object arg2,Object arg3,String getString,String key,Object arg1,Object arg2,Object arg3,Object arg4,String getString,String key,Object[] args){\r\n    return getStringWithDefault(key, NO_DEFAULT, args);\r\n}"
}, {
	"Path": "com.sun.jts.jta.UserTransactionImpl.commit",
	"Comment": "complete the transaction associated with the current thread. when thismethod completes, the thread becomes associated with no transaction.",
	"Method": "void commit(){\r\n    if (transactionManager == null)\r\n        init();\r\n    this.transactionManager.commit();\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.JavaEETransactionManagerSimplified.getPurgeCancelledTtransactionsAfter",
	"Comment": "returns the value to be used to purge transaction tasks after the specified number of cancelled tasks.",
	"Method": "int getPurgeCancelledTtransactionsAfter(){\r\n    return purgeCancelledTtransactions;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardService.getBroadcaster",
	"Comment": "return the notificationbroadcastersupport that sends notification for this service.",
	"Method": "NotificationBroadcasterSupport getBroadcaster(){\r\n    return broadcaster;\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.findResourceInternal",
	"Comment": "attempts to find the specified resource in local repositories.",
	"Method": "ResourceEntry findResourceInternal(File file,String path,ResourceEntry findResourceInternal,String name,String path){\r\n    if (!started) {\r\n        throw new IllegalStateException(getString(LogFacade.NOT_STARTED, name));\r\n    }\r\n    if ((name == null) || (path == null)) {\r\n        return null;\r\n    }\r\n    ResourceEntry entry = resourceEntries.get(name);\r\n    if (entry != null) {\r\n        return entry;\r\n    } else if (notFoundResources.containsKey(name)) {\r\n        return null;\r\n    }\r\n    entry = findResourceInternalFromRepositories(name, path);\r\n    if (entry == null) {\r\n        synchronized (jarFiles) {\r\n            entry = findResourceInternalFromJars(name, path);\r\n        }\r\n    }\r\n    if (entry == null) {\r\n        notFoundResources.put(name, name);\r\n        return null;\r\n    }\r\n    ResourceEntry entry2 = resourceEntries.putIfAbsent(name, entry);\r\n    if (entry2 != null) {\r\n        entry = entry2;\r\n    }\r\n    return entry;\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.VirtualServerConfig.setHostNames",
	"Comment": "sets the host names that will be assigned to anyvirtualserver configured via thisvirtualserverconfig separated by commas.",
	"Method": "void setHostNames(String hostNames){\r\n    this.hostNames = hostNames;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.createFilterInstance",
	"Comment": "instantiates and injects the given filter class for the givenwebmodule",
	"Method": "T createFilterInstance(WebModule module,Class<T> clazz){\r\n    validateJSR299Scope(clazz);\r\n    WebComponentInvocation inv = new WebComponentInvocation(module);\r\n    try {\r\n        invocationMgr.preInvoke(inv);\r\n        return injectionMgr.createManagedObject(clazz);\r\n    } finally {\r\n        invocationMgr.postInvoke(inv);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.util.StringUtilsTest.removeEnclosingQuotes",
	"Comment": "test of removeenclosingquotes method, of class stringutils.",
	"Method": "void removeEnclosingQuotes(){\r\n    String a = \"\\\"hello\\\"\";\r\n    String b = \"'hello'\";\r\n    String c = \"\\\"hello'\";\r\n    String d = \"\\\"\\\"hello\";\r\n    assertEquals(StringUtils.removeEnclosingQuotes(a), \"hello\");\r\n    assertEquals(StringUtils.removeEnclosingQuotes(b), \"hello\");\r\n    assertEquals(StringUtils.removeEnclosingQuotes(c), \"\\\"hello\\'\");\r\n    assertEquals(StringUtils.removeEnclosingQuotes(d), \"\\\"\\\"hello\");\r\n    assertEquals(StringUtils.removeEnclosingQuotes(\"\\\"\"), \"\\\"\");\r\n    assertEquals(StringUtils.removeEnclosingQuotes(\"'\"), \"'\");\r\n    assertEquals(StringUtils.removeEnclosingQuotes(\"''\"), \"\");\r\n    assertEquals(StringUtils.removeEnclosingQuotes(\"\\\"\\\"\"), \"\");\r\n    assertEquals(StringUtils.removeEnclosingQuotes(\"\"), \"\");\r\n    assertNull(StringUtils.removeEnclosingQuotes(null));\r\n}"
}, {
	"Path": "org.glassfish.api.invocation.ComponentInvocation.getOldSecurityContext",
	"Comment": "gets the security context of the call that came inbefore a new context for runas is made",
	"Method": "Object getOldSecurityContext(){\r\n    return oldSecurityContext;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.clearHeaders",
	"Comment": "clear the collection of headers associated with this request.",
	"Method": "void clearHeaders(){\r\n    coyoteRequest.getRequest().getHeaders().recycle();\r\n}"
}, {
	"Path": "com.sun.enterprise.util.JDK.toStringStatic",
	"Comment": "no instances are allowed so it is pointless to override tostring",
	"Method": "String toStringStatic(){\r\n    return \"major: \" + JDK.getMajor() + \"\\nminor: \" + JDK.getMinor() + \"\\nsubminor: \" + JDK.getSubMinor() + \"\\nupdate: \" + JDK.getUpdate() + \"\\nOK ==>\" + JDK.ok();\r\n}"
}, {
	"Path": "org.glassfish.internal.deployment.GenericSniffer.handles",
	"Comment": "returns true if the passed file or directory is recognized by thisinstance.",
	"Method": "boolean handles(DeploymentContext context,boolean handles,ReadableArchive location){\r\n    if (appStigma != null) {\r\n        try {\r\n            if (location.exists(appStigma)) {\r\n                return true;\r\n            }\r\n        } catch (IOException e) {\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.core.proxy.AMXProxyHandler.invokeSingleProxyGetter",
	"Comment": "the method is one that requests a proxy. the method could retrieve a real attribute,but if there is no real attribute, attempt to find a child of the matching type.",
	"Method": "AMXProxy invokeSingleProxyGetter(Object myProxy,Method method,Object[] args){\r\n    final String methodName = method.getName();\r\n    final int numArgs = (args == null) ? 0 : args.length;\r\n    final Class<? extends AMXProxy> returnClass = method.getReturnType().asSubclass(AMXProxy.class);\r\n    ObjectName objectName = null;\r\n    if (numArgs == 0) {\r\n        final String attrName = JMXUtil.getAttributeName(method);\r\n        if (getAttributeInfo(attrName) != null) {\r\n            objectName = (ObjectName) invokeTarget(methodName, null, null);\r\n        } else {\r\n            final String type = Util.deduceType(returnClass);\r\n            final AMXProxy childProxy = child(type);\r\n            objectName = childProxy == null ? null : childProxy.extra().objectName();\r\n        }\r\n    } else {\r\n        objectName = (ObjectName) invokeTarget(methodName, args, STRING_SIG);\r\n    }\r\n    return objectName == null ? null : getProxy(objectName, returnClass);\r\n}"
}, {
	"Path": "org.glassfish.weld.DeploymentImpl.scanArchive",
	"Comment": "produce beandeploymentarchives for this deploymentfrom information from the provided readablearchive.this method is called for subsequent modules after this deployment hasbeen created.",
	"Method": "void scanArchive(ReadableArchive archive,Collection<EjbDescriptor> ejbs,DeploymentContext context){\r\n    if (libJarRootBdas == null) {\r\n        libJarRootBdas = scanForLibJars(archive, ejbs, context);\r\n        if ((libJarRootBdas != null) && libJarRootBdas.size() > 0) {\r\n            return;\r\n        }\r\n    }\r\n    this.context = context;\r\n    createModuleBda(archive, ejbs, context);\r\n}"
}, {
	"Path": "org.apache.catalina.logger.LoggerBase.stop",
	"Comment": "gracefully terminate the active use of the public methods of thiscomponent.this method should be the last one called on a giveninstance of this component.",
	"Method": "void stop(){\r\n    if (getObjectName() != null) {\r\n        ObjectName oname = createObjectName();\r\n        try {\r\n            if (log.isLoggable(Level.FINE)) {\r\n                log.log(Level.FINE, neutralizeForLog(\"Unregistering logger \" + oname));\r\n            }\r\n        } catch (Exception ex) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.CANNOT_REGISTER_LOGGER_EXCEPTION), oname);\r\n            log.log(Level.SEVERE, neutralizeForLog(msg), ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.CoyotePrincipal.toString",
	"Comment": "return a string representation of this object, which exposes onlyinformation that should be public.",
	"Method": "String toString(){\r\n    StringBuilder sb = new StringBuilder(\"CoyotePrincipal[\");\r\n    sb.append(this.name);\r\n    sb.append(\"]\");\r\n    return (sb.toString());\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.services.impl.monitor.GrizzlyMonitoring.unregisterConnectionQueueStatsProvider",
	"Comment": "unregister connection queue statistics provider for a network listener",
	"Method": "void unregisterConnectionQueueStatsProvider(String name){\r\n    final ConnectionQueueStatsProvider connectionQueueStatsProvider = connectionQueueStatsProvidersMap.remove(name);\r\n    if (connectionQueueStatsProvider != null) {\r\n        StatsProviderManager.unregister(connectionQueueStatsProvider);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogFile.write",
	"Comment": "writes a log record to the physical log.supports either a force or unforced option with force requiring an immediatewrite to the log and unforced keeping the data until a force is done somewhereelse in the log service.the lsn of the written log record is an output parameter.returns true if the write completed successfully and false if the writedid not complete.",
	"Method": "boolean write(int writeType,byte[] record,int recordType,LogLSN recordLSN){\r\n    boolean result = true;\r\n    try {\r\n        LogLSN resultLSN = handle.writeRecord(record, recordType, (writeType == LogFile.FORCED ? LogHandle.FORCE : LogHandle.BUFFER));\r\n        if (recordLSN != null)\r\n            recordLSN.copy(resultLSN);\r\n    } catch (LogException le) {\r\n        _logger.log(Level.SEVERE, \"jts.log_error\", le.toString());\r\n        String msg = LogFormatter.getLocalizedMessage(_logger, \"jts.log_error\", new java.lang.Object[] { le.toString() });\r\n        throw (org.omg.CORBA.INTERNAL) (new org.omg.CORBA.INTERNAL(msg)).initCause(le);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.internal.api.DelegatingClassLoader.removeDelegate",
	"Comment": "removes a classfinder from list of delegates. this method must not be usedonce this classloader has beed used to load any class. if attempted todo so, this method throws illegalstateexception",
	"Method": "boolean removeDelegate(ClassFinder d){\r\n    return delegates.remove(d);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogFile.writeRestart",
	"Comment": "writes the given information in the restart record for the log.",
	"Method": "boolean writeRestart(byte[] record){\r\n    boolean result = false;\r\n    try {\r\n        handle.writeRestart(record);\r\n        result = true;\r\n    } catch (LogException le) {\r\n        result = false;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.security.common.FileRealmHelper.encodeUser",
	"Comment": "encodes one user entry containing info stored in filerealmuser object.",
	"Method": "String encodeUser(String name,User ud,String algo){\r\n    StringBuilder sb = new StringBuilder();\r\n    String cryptPwd = null;\r\n    sb.append(name);\r\n    sb.append(FIELD_SEP);\r\n    if (resetKey.equals(algo)) {\r\n        sb.append(resetKey);\r\n    } else {\r\n        String ssha = SSHA.encode(ud.getSalt(), ud.getHash(), algo);\r\n        sb.append(ssha);\r\n    }\r\n    sb.append(FIELD_SEP);\r\n    String[] groups = ud.getGroups();\r\n    if (groups != null) {\r\n        for (int grp = 0; grp < groups.length; grp++) {\r\n            if (grp > 0) {\r\n                sb.append(GROUP_SEP);\r\n            }\r\n            sb.append((String) groups[grp]);\r\n        }\r\n    }\r\n    sb.append(\"\\n\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.addLocalEjb",
	"Comment": "add a local ejb resource reference for this web application.",
	"Method": "void addLocalEjb(ContextLocalEjb ejb){\r\n    namingResources.addLocalEjb(ejb);\r\n    if (notifyContainerListeners) {\r\n        fireContainerEvent(\"addLocalEjb\", ejb.getName());\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.SslConfig.getCertNickname",
	"Comment": "gets the nickname of the server certificate in the certificate database",
	"Method": "String getCertNickname(){\r\n    return this.certNickname;\r\n}"
}, {
	"Path": "com.sun.enterprise.security.store.PasswordAdapter.loadKeyStore",
	"Comment": "construct a passwordadapter with given shared master password,smp.",
	"Method": "KeyStore loadKeyStore(File keyStoreFile,char[] masterPassword){\r\n    final KeyStore keyStore = KeyStore.getInstance(\"JCEKS\");\r\n    if (keyStoreFile.exists()) {\r\n        final FileInputStream input = new FileInputStream(keyStoreFile);\r\n        try {\r\n            keyStore.load(input, masterPassword);\r\n        } finally {\r\n            input.close();\r\n        }\r\n    } else {\r\n        keyStore.load(null, masterPassword);\r\n    }\r\n    return keyStore;\r\n}"
}, {
	"Path": "com.sun.appserv.web.taglibs.cache.FlushTag.doStartTag",
	"Comment": "dostarttag is called when the flush tag is encountered. bythe time this is called, the tag attributes are already set.",
	"Method": "int doStartTag(){\r\n    Cache cache = CacheUtil.getCache(pageContext, _scope);\r\n    if (_key != null) {\r\n        String key = CacheUtil.generateKey(_key, pageContext);\r\n        cache.remove(key);\r\n        if (_logger.isLoggable(Level.FINE))\r\n            _logger.log(Level.FINE, LogFacade.FLUSH_TAG_CLEAR_KEY, key);\r\n    } else {\r\n        cache.clear();\r\n        if (_logger.isLoggable(Level.FINE))\r\n            _logger.log(Level.FINE, LogFacade.FLUSH_TAG_CLEAR_CACHE);\r\n    }\r\n    return SKIP_BODY;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.CoyoteServerSocketFactory.getClientAuth",
	"Comment": "provides information about whether client authentication is enforced.",
	"Method": "boolean getClientAuth(){\r\n    return (this.clientAuth);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.TomcatDeploymentConfig.configureContextParam",
	"Comment": "configure context parameter defined in the deployment descriptor.",
	"Method": "void configureContextParam(WebModule webModule,WebBundleDescriptorImpl wmd){\r\n    for (ContextParameter ctxParam : wmd.getContextParametersSet()) {\r\n        if (\"com.sun.faces.injectionProvider\".equals(ctxParam.getName()) && \"com.sun.faces.vendor.GlassFishInjectionProvider\".equals(ctxParam.getValue())) {\r\n            continue;\r\n        }\r\n        webModule.addParameter(ctxParam.getName(), ctxParam.getValue());\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.webservices.EjbRuntimeEndpointInfo.initRuntimeInfo",
	"Comment": "force initialization of the endpoint runtime informationas well as the handlers injection",
	"Method": "void initRuntimeInfo(ServletAdapterList list){\r\n    AdapterInvocationInfo aInfo = null;\r\n    try {\r\n        this.adapterList = list;\r\n        aInfo = (AdapterInvocationInfo) prepareInvocation(true);\r\n    } finally {\r\n        if (aInfo != null) {\r\n            releaseImplementor(aInfo.getInv());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.MapUtil.toStringStringMap",
	"Comment": "convert an arbitrary map to one whose keys and valuesare both of type string.",
	"Method": "Map<String, String> toStringStringMap(Map<?, ?> m){\r\n    if (m == null) {\r\n        return null;\r\n    }\r\n    Map<String, String> result;\r\n    if (isAllStrings(m)) {\r\n        result = TypeCast.asMap(m);\r\n    } else {\r\n        result = new HashMap<String, String>();\r\n        for (final Map.Entry<?, ?> me : m.entrySet()) {\r\n            final Object key = me.getKey();\r\n            final Object value = me.getValue();\r\n            if ((key instanceof String) && (value instanceof String)) {\r\n                result.put((String) key, (String) value);\r\n            } else {\r\n                result.put(\"\" + key, \"\" + value);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.ThresholdingOutputStream.isThresholdExceeded",
	"Comment": "determines whether or not the configured threshold has been exceeded forthis output stream.",
	"Method": "boolean isThresholdExceeded(){\r\n    return (written > threshold);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.cci.InteractionSpecExistence.check",
	"Comment": "test if a javax.resource.cci.interfactionspec implementation has been provided in the rar file",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (isCCIImplemented(descriptor, result)) {\r\n        findImplementorOf(descriptor, \"javax.resource.cci.InteractionSpec\", result);\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.cci.InteractionExistence.notapp\", \"NotApplicable : The CCI interfaces do not seem to be implemented by this resource adapter\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.naming.resources.DirContextURLConnection.connect",
	"Comment": "connect to the dircontext, and retrive the bound object, as well asits attributes. if no object is bound with the name specified in theurl, then an ioexception is thrown.",
	"Method": "void connect(){\r\n    if (!connected) {\r\n        try {\r\n            date = System.currentTimeMillis();\r\n            String path = getURL().getFile();\r\n            if (context instanceof ProxyDirContext) {\r\n                ProxyDirContext proxyDirContext = (ProxyDirContext) context;\r\n                String hostName = proxyDirContext.getHostName();\r\n                String contextName = proxyDirContext.getContextName();\r\n                if (hostName != null) {\r\n                    if (!path.startsWith(\"/\" + hostName + \"/\"))\r\n                        return;\r\n                    path = path.substring(hostName.length() + 1);\r\n                }\r\n                if (contextName != null) {\r\n                    if (!path.startsWith(contextName + \"/\")) {\r\n                        return;\r\n                    } else {\r\n                        path = path.substring(contextName.length());\r\n                    }\r\n                }\r\n            }\r\n            path = URLDecoder.decode(path, \"UTF-8\");\r\n            object = context.lookup(path);\r\n            attributes = context.getAttributes(path);\r\n            if (object instanceof Resource)\r\n                resource = (Resource) object;\r\n            if (object instanceof DirContext)\r\n                collection = (DirContext) object;\r\n        } catch (NamingException e) {\r\n        }\r\n        connected = true;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.DeleteLocalInstanceCommand.mkdirs",
	"Comment": "we most definitely do not want to create directories for nodes here!!",
	"Method": "boolean mkdirs(File f){\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.session.stateless.StatelessCreateNoArgs.check",
	"Comment": "stateless session are only allowed to have create methods with no arguments.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    result = getInitializedResult();\r\n    compName = getVerifierContext().getComponentNameConstructor();\r\n    if (descriptor instanceof EjbSessionDescriptor) {\r\n        String stateType = ((EjbSessionDescriptor) descriptor).getSessionType();\r\n        if (EjbSessionDescriptor.STATELESS.equals(stateType)) {\r\n            if (descriptor.getHomeClassName() != null && !\"\".equals(descriptor.getHomeClassName()))\r\n                commonToBothInterfaces(descriptor.getHomeClassName(), (EjbSessionDescriptor) descriptor);\r\n            if (descriptor.getLocalHomeClassName() != null && !\"\".equals(descriptor.getLocalHomeClassName()))\r\n                commonToBothInterfaces(descriptor.getLocalHomeClassName(), (EjbSessionDescriptor) descriptor);\r\n        }\r\n    }\r\n    if (result.getStatus() != Result.FAILED) {\r\n        addGoodDetails(result, compName);\r\n        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"The bean's Home Interface properly defines one create Method with no args\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionImpl.rollback",
	"Comment": "rollback the transaction represented by this transaction object.",
	"Method": "void rollback(){\r\n    try {\r\n        if (Configuration.isLocalFactory()) {\r\n            ((ControlImpl) control).get_localTerminator().rollback();\r\n        } else {\r\n            control.get_terminator().rollback();\r\n        }\r\n    } catch (INVALID_TRANSACTION ex) {\r\n        throw new IllegalStateException();\r\n    } catch (TRANSACTION_ROLLEDBACK ex) {\r\n        throw new IllegalStateException();\r\n    } catch (Unavailable ex) {\r\n        SystemException sException = new SystemException();\r\n        sException.initCause(ex);\r\n        throw sException;\r\n    } catch (Exception ex) {\r\n        SystemException sException = new SystemException();\r\n        sException.initCause(ex);\r\n        throw sException;\r\n    }\r\n}"
}, {
	"Path": "com.sun.corba.ee.impl.orbutil.newtimer.TimerPointSourceGenerator.parseDescription",
	"Comment": "return the package for the file to generate and a timerfactorythat contains all of the information from the xml source filegiven by filename.",
	"Method": "Pair<String, TimerFactory> parseDescription(String fileName,Pair<String, TimerFactory> parseDescription,String fileName,boolean debug){\r\n    Handler handler = new Handler(debug);\r\n    SAXParserFactory factory = SAXParserFactory.newInstance();\r\n    factory.setValidating(true);\r\n    File file = null;\r\n    try {\r\n        SAXParser saxParser = factory.newSAXParser();\r\n        file = new File(fileName);\r\n        saxParser.parse(file, handler);\r\n    } catch (Exception exc) {\r\n        System.out.println(\"Exception in processing \" + file + \": \" + exc);\r\n        exc.printStackTrace();\r\n        return null;\r\n    }\r\n    return handler.getResult();\r\n}"
}, {
	"Path": "com.sun.enterprise.config.modularity.ConfigModularityJustInTimeInjectionResolver.isInjectionSupported",
	"Comment": "this method will go away eventually when we are done with supporting all types.",
	"Method": "boolean isInjectionSupported(Class c){\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.server.LifecycleModuleService.isEnabled",
	"Comment": "returns true if life cycle module is enabled in the applicationlevel and in the application ref level.",
	"Method": "boolean isEnabled(String name,String enabled){\r\n    return (Boolean.valueOf(enabled) && Boolean.valueOf(configBeansUtilities.getEnabled(server.getName(), name)));\r\n}"
}, {
	"Path": "org.apache.naming.resources.ProxyDirContext.addToEnvironment",
	"Comment": "adds a new environment property to the environment of this context. if the property already exists, its value is overwritten.",
	"Method": "Object addToEnvironment(String propName,Object propVal){\r\n    return dirContext.addToEnvironment(propName, propVal);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.connector.coyote.PECoyoteConnector.setQueueSizeInBytes",
	"Comment": "set the maximum pending connection this connectorcan handle.",
	"Method": "void setQueueSizeInBytes(int queueSizeInBytes){\r\n    this.queueSizeInBytes = queueSizeInBytes;\r\n    setProperty(\"queueSizeInBytes\", String.valueOf(queueSizeInBytes));\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.setRuleNamespaceURI",
	"Comment": "set the namespace uri that will be applied to all subsequentlyadded rule objects.",
	"Method": "void setRuleNamespaceURI(String ruleNamespaceURI){\r\n    getRules().setNamespaceURI(ruleNamespaceURI);\r\n}"
}, {
	"Path": "org.glassfish.cluster.ssh.util.SSHUtil.validateKeyFile",
	"Comment": "this method validates either private or public key file. in case of privatekey, it parses the key file contents to verify if it indeed contains a key",
	"Method": "boolean validateKeyFile(String file){\r\n    boolean ret = false;\r\n    File f = new File(file);\r\n    if (f.exists()) {\r\n        if (!f.getName().endsWith(\".pub\")) {\r\n            String key = null;\r\n            try {\r\n                key = FileUtils.readSmallFile(file);\r\n            } catch (IOException ioe) {\r\n                throw new CommandException(Strings.get(\"unable.to.read.key\", file, ioe.getMessage()));\r\n            }\r\n            if (!key.startsWith(\"-----BEGIN \") && !key.endsWith(\" PRIVATE KEY-----\" + NL)) {\r\n                throw new CommandException(Strings.get(\"invalid.key.file\", file));\r\n            }\r\n        }\r\n        ret = true;\r\n    } else {\r\n        throw new CommandException(Strings.get(\"key.does.not.exist\", file));\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.apache.catalina.session.JDBCStore.remove",
	"Comment": "remove the session with the specified session identifier fromthis store, if present.if no such session is present, this methodtakes no action.",
	"Method": "void remove(String id){\r\n    String removeSql = \"DELETE FROM \" + sessionTable + \" WHERE \" + sessionIdCol + \" = ?  AND \" + sessionAppCol + \" = ?\";\r\n    synchronized (this) {\r\n        Connection _conn = getConnection();\r\n        if (_conn == null) {\r\n            return;\r\n        }\r\n        try {\r\n            if (preparedRemoveSql == null) {\r\n                preparedRemoveSql = _conn.prepareStatement(removeSql);\r\n            }\r\n            preparedRemoveSql.setString(1, id);\r\n            preparedRemoveSql.setString(2, getName());\r\n            preparedRemoveSql.execute();\r\n        } catch (SQLException e) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.SQL_ERROR), e);\r\n            log(msg);\r\n        } finally {\r\n            release(_conn);\r\n        }\r\n    }\r\n    if (debug > 0) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.REMOVING_SESSION_FROM_DATABASE), new Object[] { id, sessionTable });\r\n        log(msg);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.getValue",
	"Comment": "return the object bound with the specified name in this session, ornull if no object is bound with that name.",
	"Method": "Object getValue(String name){\r\n    return (getAttribute(name));\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.config.AMXConfigImpl.handleCollection",
	"Comment": "handle an update to a collection, returning the list that results.",
	"Method": "List<String> handleCollection(WriteableView writeable,ConfigModel.Property prop,List<String> argValues){\r\n    final Object o = writeable.getter(prop, getCollectionGenericType());\r\n    final List<String> masterList = TypeCast.checkList(TypeCast.asList(o), String.class);\r\n    masterList.retainAll(argValues);\r\n    for (final String s : argValues) {\r\n        if (!masterList.contains(s)) {\r\n            masterList.add(s);\r\n        }\r\n    }\r\n    return new ArrayList<String>(masterList);\r\n}"
}, {
	"Path": "org.apache.catalina.session.StoreBase.load",
	"Comment": "load and return the session associated with the specified sessionidentifier from this store, without removing it.if there is nosuch stored session, return null.",
	"Method": "Session load(String id,String version){\r\n    return load(id);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.CreateInstanceCommand.bootstrapSecureAdminRemotely",
	"Comment": "delivers bootstrap files for secure admin remotely, because the instanceis not on the same system as the das.",
	"Method": "int bootstrapSecureAdminRemotely(){\r\n    ActionReport report = ctx.getActionReport();\r\n    String thisNodeDir = null;\r\n    if (nodeDir != null)\r\n        thisNodeDir = nodeDir + \"/\" + node;\r\n    try {\r\n        final SecureAdminBootstrapHelper bootHelper = SecureAdminBootstrapHelper.getRemoteHelper(habitat, getDomainInstanceDir(), thisNodeDir, instance, theNode, logger);\r\n        bootHelper.bootstrapInstance();\r\n        bootHelper.close();\r\n        return 0;\r\n    } catch (Exception ex) {\r\n        String exmsg = ex.getMessage();\r\n        if (exmsg == null) {\r\n            exmsg = ExceptionUtil.getRootCause(ex).toString();\r\n        }\r\n        String msg = Strings.get(\"create.instance.remote.boot.failed\", instance, (ex instanceof SecureAdminBootstrapHelper.BootstrapException ? ((SecureAdminBootstrapHelper.BootstrapException) ex).sshSettings() : null), exmsg, nodeHost);\r\n        logger.log(Level.SEVERE, msg, ex);\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setMessage(msg);\r\n        return 1;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ReplicationStore.doSave",
	"Comment": "save the specified session into this store.any previously savedinformation for the associated session identifier is replaced.",
	"Method": "void doSave(Session session){\r\n    if (!(session instanceof HASession)) {\r\n        return;\r\n    }\r\n    byte[] sessionState = this.getByteArray(session, isReplicationCompressionEnabled());\r\n    BackingStore<String, SimpleMetadata> backingStore = getSimpleMetadataBackingStore();\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"ReplicationStore>>save: backing store : \" + backingStore);\r\n    }\r\n    // version\r\n    SimpleMetadata simpleMetadata = // version\r\n    SimpleMetadataFactory.createSimpleMetadata(session.getVersion(), session.getLastAccessedTime(), session.getMaxInactiveInterval() * 1000L, sessionState);\r\n    try {\r\n        // id\r\n        backingStore.save(// TODO: Revist the last param\r\n        session.getIdInternal(), simpleMetadata, !((HASession) session).isPersistent());\r\n    } catch (BackingStoreException ex) {\r\n        IOException ex1 = (IOException) new IOException(\"Error during save: \" + ex.getMessage()).initCause(ex);\r\n        throw ex1;\r\n    }\r\n}"
}, {
	"Path": "testmbeans.OneClassDynamicMBean.getAttribute",
	"Comment": "gets the value of the specified attribute of the dynamicmbean.",
	"Method": "Object getAttribute(String attributeName){\r\n    if (attributeName.equals(\"A1\")) {\r\n        return null;\r\n    }\r\n    if (attributeName.equals(\"A2\")) {\r\n        return null;\r\n    }\r\n    if (attributeName.equals(\"A3\")) {\r\n        return null;\r\n    }\r\n    throw new AttributeNotFoundException(\"Unknown Attribute \" + attributeName);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.addFilter",
	"Comment": "adds the filter with the given name and class type to this servletcontext.",
	"Method": "FilterRegistration.Dynamic addFilter(String filterName,String className,FilterRegistration.Dynamic addFilter,String filterName,Filter filter,FilterRegistration.Dynamic addFilter,String filterName,Class<? extends Filter> filterClass){\r\n    if (isContextInitializedCalled) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.SERVLET_CONTEXT_ALREADY_INIT_EXCEPTION), new Object[] { \"addFilter\", getName() });\r\n        throw new IllegalStateException(msg);\r\n    }\r\n    if (filterName == null || filterName.length() == 0) {\r\n        throw new IllegalArgumentException(rb.getString(LogFacade.NULL_EMPTY_FILTER_NAME_EXCEPTION));\r\n    }\r\n    synchronized (filterDefs) {\r\n        if (findFilterDef(filterName) != null) {\r\n            return null;\r\n        }\r\n        DynamicFilterRegistrationImpl regis = (DynamicFilterRegistrationImpl) filterRegisMap.get(filterName);\r\n        FilterDef filterDef = null;\r\n        if (null == regis) {\r\n            filterDef = new FilterDef();\r\n        } else {\r\n            filterDef = regis.getFilterDefinition();\r\n        }\r\n        filterDef.setFilterName(filterName);\r\n        filterDef.setFilterClass(filterClass);\r\n        addFilterDef(filterDef, true, (regis == null));\r\n        if (null == regis) {\r\n            regis = (DynamicFilterRegistrationImpl) filterRegisMap.get(filterName);\r\n        }\r\n        return regis;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.messagebean.HasValidMethodDescriptor.check",
	"Comment": "run a verifier test against an individual declared messagedrive bean component",
	"Method": "Result check(EjbMessageBeanDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (descriptor.getTransactionType().equals(EjbDescriptor.CONTAINER_TRANSACTION_TYPE)) {\r\n        Collection methods = descriptor.getTransactionMethodDescriptors();\r\n        if (methods.size() == 0) {\r\n            addNaDetails(result, compName);\r\n            result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable1\", \"Message-driven bean [ {0} ] does not define any method\", new Object[] { descriptor.getName() }));\r\n            return result;\r\n        }\r\n        Iterator iterator = methods.iterator();\r\n        while (iterator.hasNext()) {\r\n            MethodDescriptor method = (MethodDescriptor) iterator.next();\r\n            if (descriptor.isTimedObject() && (method.getName()).equals(\"ejbTimeout\"))\r\n                continue;\r\n            ContainerTransaction txAttr = descriptor.getContainerTransactionFor(method);\r\n            if (txAttr == null) {\r\n                if (getVerifierContext().getJavaEEVersion().compareTo(SpecVersionMapper.JavaEEVersion_5) < 0) {\r\n                    addErrorDetails(result, compName);\r\n                    result.failed(smh.getLocalString(getClass().getName() + \".failed4\", \"Error : Message-driven bean [ {0} ] method definition [ {1} ] does not have a valid container transaction descriptor.\", new Object[] { descriptor.getName(), method.getName() }));\r\n                }\r\n                continue;\r\n            }\r\n            String ta = txAttr.getTransactionAttribute();\r\n            if (ContainerTransaction.REQUIRED.equals(ta) || ContainerTransaction.NOT_SUPPORTED.equals(ta)) {\r\n                addGoodDetails(result, compName);\r\n                result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"Message-driven bean [ {0} ] method definition [ {1} ] in assembly-descriptor is correct\", new Object[] { descriptor.getName(), method.getName() }));\r\n            } else {\r\n                addErrorDetails(result, compName);\r\n                result.failed(smh.getLocalString(getClass().getName() + \".failed3\", \"Error : Message-driven bean [ {0} ] method definition [ {1} ] transaction attribute must be Required or NotSupported\", new Object[] { descriptor.getName(), method.getName() }));\r\n            }\r\n        }\r\n        return result;\r\n    } else {\r\n        addNaDetails(result, compName);\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable2\", \"Message-driven bean [ {0} ] does not use container-managed transaction\", new Object[] { descriptor.getName() }));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.naming.TransactionRef.getFactoryClassName",
	"Comment": "retrieves the class name of the factory of the object to which this reference refers.",
	"Method": "String getFactoryClassName(){\r\n    String factory = super.getFactoryClassName();\r\n    if (factory != null) {\r\n        return factory;\r\n    } else {\r\n        factory = System.getProperty(Context.OBJECT_FACTORIES);\r\n        if (factory != null) {\r\n            return null;\r\n        } else {\r\n            return DEFAULT_FACTORY;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.node.WebBundleNode.registerBundle",
	"Comment": "register this node as a root node capable of loading entire dd files",
	"Method": "String registerBundle(Map<String, String> publicIDToDTD){\r\n    publicIDToDTD.put(PUBLIC_DTD_ID, SYSTEM_ID);\r\n    publicIDToDTD.put(PUBLIC_DTD_ID_12, SYSTEM_ID_12);\r\n    return tag.getQName();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.deploy.shared.DeploymentPlanArchive.getURI",
	"Comment": "returns the path used to create or open the underlying archive",
	"Method": "URI getURI(){\r\n    return uri;\r\n}"
}, {
	"Path": "org.apache.catalina.startup.Catalina.setCatalinaBase",
	"Comment": "set the catalina.base system property to the currentworking directory if it has not been set.",
	"Method": "void setCatalinaBase(){\r\n    initDirs();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.getLocalTID",
	"Comment": "returns the internal identifier for the transaction.this method is currently not synchronized because that causes a deadlockin resync.",
	"Method": "long getLocalTID(){\r\n    long result = superInfo.localTID.longValue();\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.appserv.management.sample.SampleListener.addNotif",
	"Comment": "keep a map, keyed by notification type, of all notifications received.",
	"Method": "void addNotif(Notification notif){\r\n    final String type = notif.getType();\r\n    List list = null;\r\n    if (!mNotifs.keySet().contains(type)) {\r\n        clearNotifs(type);\r\n    }\r\n    list = (List) mNotifs.get(type);\r\n    list.add(notif);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.SetupSshCommand.getSSHPassphrase",
	"Comment": "get ssh key passphrase. obtain real passphrase in case it is an alias.",
	"Method": "String getSSHPassphrase(){\r\n    String key = \"\";\r\n    if (sshkeypassphrase != null && !sshkeypassphrase.isEmpty()) {\r\n        key = sshL.expandPasswordAlias(sshkeypassphrase);\r\n        if (key == null) {\r\n            throw new CommandException(\"setup.ssh.null.keypassphrase\");\r\n        }\r\n    }\r\n    return key;\r\n}"
}, {
	"Path": "org.apache.catalina.valves.PersistentValve.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (info);\r\n}"
}, {
	"Path": "org.apache.naming.resources.ResourceCache.setMaxAllocateIterations",
	"Comment": "set the maximum amount of iterations during a space allocation.",
	"Method": "void setMaxAllocateIterations(int maxAllocateIterations){\r\n    this.maxAllocateIterations = maxAllocateIterations;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModuleConfig.setVirtualServers",
	"Comment": "return the list of virtual servers to which the web application isdeployed.",
	"Method": "void setVirtualServers(String virtualServers){\r\n    _vsIDs = virtualServers;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHostValve.handleHostErrorPage",
	"Comment": "copies the contents of the given error page to the response, andupdates the status message with the reason string of the error page.",
	"Method": "void handleHostErrorPage(Response response,ErrorPage errorPage,int statusCode){\r\n    ServletOutputStream ostream = null;\r\n    PrintWriter writer = null;\r\n    FileReader reader = null;\r\n    BufferedInputStream istream = null;\r\n    IOException ioe = null;\r\n    if (!response.getResponse().isCommitted()) {\r\n        response.resetBuffer(true);\r\n    }\r\n    String message = errorPage.getReason();\r\n    if (message != null) {\r\n        ((HttpResponse) response).reset(statusCode, message);\r\n    }\r\n    try {\r\n        ostream = response.getResponse().getOutputStream();\r\n    } catch (IllegalStateException e) {\r\n        writer = response.getResponse().getWriter();\r\n    }\r\n    if (writer != null) {\r\n        reader = new FileReader(errorPage.getLocation());\r\n        ioe = ResponseUtil.copy(reader, writer);\r\n        try {\r\n            reader.close();\r\n        } catch (Throwable t) {\r\n            ;\r\n        }\r\n    } else {\r\n        istream = new BufferedInputStream(new FileInputStream(errorPage.getLocation()));\r\n        ioe = ResponseUtil.copy(istream, ostream);\r\n        try {\r\n            istream.close();\r\n        } catch (Throwable t) {\r\n            ;\r\n        }\r\n    }\r\n    if (ioe != null) {\r\n        throw ioe;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.CommandRunnerImpl.getManPage",
	"Comment": "return an inputstream for the man page for the named command.",
	"Method": "BufferedReader getManPage(String commandName,CommandModel model){\r\n    Class clazz = model.getCommandClass();\r\n    if (clazz == null) {\r\n        return null;\r\n    }\r\n    return ManPageFinder.getCommandManPage(commandName, clazz.getName(), Locale.getDefault(), clazz.getClassLoader(), logger);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationHttpRequest.parseParameters",
	"Comment": "parses the parameters of this request.if parameters are present in both the query string and the requestcontent, they are merged.",
	"Method": "void parseParameters(){\r\n    if (parsedParams) {\r\n        return;\r\n    }\r\n    parameters = new HashMap<String, String[]>();\r\n    synchronized (parameters) {\r\n        copyMap(getRequest().getParameterMap(), parameters);\r\n        mergeParameters();\r\n        parsedParams = true;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.InstalledLibrariesResolver.initializeInstalledLibRegistry",
	"Comment": "check whether the optional packages have all their internal dependencies resolved",
	"Method": "void initializeInstalledLibRegistry(String libDir){\r\n    initializeInstalledLibRegistryForExtDirs();\r\n    initializeInstalledLibRegistryForApplibs(libDir);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.CreateProfiler.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (javaConfig.getProfiler() != null) {\r\n        System.out.println(\"profiler exists. Please delete it first\");\r\n        report.setMessage(localStrings.getLocalString(\"create.profiler.alreadyExists\", \"profiler exists. Please delete it first\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<JavaConfig>() {\r\n            public Object run(JavaConfig param) throws PropertyVetoException, TransactionFailure {\r\n                Profiler newProfiler = param.createChild(Profiler.class);\r\n                newProfiler.setName(name);\r\n                newProfiler.setClasspath(classpath);\r\n                newProfiler.setEnabled(enabled.toString());\r\n                newProfiler.setNativeLibraryPath(nativeLibraryPath);\r\n                if (properties != null) {\r\n                    for (Map.Entry e : properties.entrySet()) {\r\n                        Property prop = newProfiler.createChild(Property.class);\r\n                        prop.setName((String) e.getKey());\r\n                        prop.setValue((String) e.getValue());\r\n                        newProfiler.getProperty().add(prop);\r\n                    }\r\n                }\r\n                param.setProfiler(newProfiler);\r\n                return newProfiler;\r\n            }\r\n        }, javaConfig);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(localStrings.getLocalString(\"create.profiler.fail\", \"{0} create failed \", name));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.CreateProfiler.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Profiler newProfiler = param.createChild(Profiler.class);\r\n    newProfiler.setName(name);\r\n    newProfiler.setClasspath(classpath);\r\n    newProfiler.setEnabled(enabled.toString());\r\n    newProfiler.setNativeLibraryPath(nativeLibraryPath);\r\n    if (properties != null) {\r\n        for (Map.Entry e : properties.entrySet()) {\r\n            Property prop = newProfiler.createChild(Property.class);\r\n            prop.setName((String) e.getKey());\r\n            prop.setValue((String) e.getValue());\r\n            newProfiler.getProperty().add(prop);\r\n        }\r\n    }\r\n    param.setProfiler(newProfiler);\r\n    return newProfiler;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogFile.close",
	"Comment": "closes the portion of the log defined by the logfile object reference.deletes the associated logfile if requested.",
	"Method": "boolean close(boolean deleteFile){\r\n    boolean result = true;\r\n    try {\r\n        handle.closeFile(deleteFile);\r\n    } catch (LogException le) {\r\n        result = false;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.commands.CreateSsl.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    Target targetUtil = habitat.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    if (!\"iiop-service\".equals(type)) {\r\n        if (listenerId == null) {\r\n            report.setMessage(localStrings.getLocalString(\"create.ssl.listenerid.missing\", \"Listener id needs to be specified\"));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    SslConfigHandler configHandler = habitat.getService(SslConfigHandler.class, type);\r\n    if (configHandler != null) {\r\n        configHandler.create(this, report);\r\n    } else if (\"jmx-connector\".equals(type)) {\r\n        addSslToJMXConnector(config, report);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.services.SMFService.init_old_delete_me",
	"Comment": "todo todo todo todo todo todo todo todo todo todo todo todo todo todo",
	"Method": "void init_old_delete_me(){\r\n    getTokenMap().put(START_INSTANCES_TN, START_INSTANCES_DEFAULT_VAL);\r\n    getTokenMap().put(AS_ADMIN_USER_TN, AS_ADMIN_USER_DEF_VAL);\r\n    getTokenMap().put(TIMEOUT_SECONDS_TN, TIMEOUT_SECONDS_DV);\r\n    getTokenMap().put(PRIVILEGES_TN, BASIC_NETADDR_PRIV_VAL);\r\n    getTokenMap().put(CREDENTIALS_TN, \" \");\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.isCaseSensitiveMapping",
	"Comment": "are filters and security constraints mapped in a case sensitive manner?",
	"Method": "boolean isCaseSensitiveMapping(){\r\n    return caseSensitiveMapping;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.logName",
	"Comment": "log the abbreviated name of this container for logging messages.",
	"Method": "String logName(){\r\n    StringBuilder sb = new StringBuilder(\"StandardWrapper[\");\r\n    if (getParent() != null)\r\n        sb.append(getParent().getName());\r\n    else\r\n        sb.append(\"null\");\r\n    sb.append(':');\r\n    sb.append(getName());\r\n    sb.append(']');\r\n    return (sb.toString());\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.ejbfindermethod.EjbFinderMethodDescription.check",
	"Comment": "note that the ejbfind names and parameter signatures do not provide the container tools with sufficient information for automatically generating the implementation of the finder methods for methods other than ejbfindbyprimarykey. therefore, the bean provider is responsible for providing a description of each finder method. the entity bean deployer uses container tools to generate the implementation of the finder methods based in the description supplied by the bean provider. the enterprise javabeans architecture does not specify the format of the finder method description.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    result.setStatus(Result.NOT_IMPLEMENTED);\r\n    result.addNaDetails(smh.getLocalString(getClass().getName() + \".notImplemented\", \"No static testing done - yet.\"));\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.beanclass.EjbClassModifiersAbstract.check",
	"Comment": "enterprise java bean class modifiers test.the class must not be definedas abstract.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    boolean shouldBeAbstract = false;\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (descriptor instanceof EjbEntityDescriptor) {\r\n        String persistentType = ((EjbEntityDescriptor) descriptor).getPersistenceType();\r\n        if (EjbEntityDescriptor.CONTAINER_PERSISTENCE.equals(persistentType)) {\r\n            if (EjbCMPEntityDescriptor.CMP_1_1 != ((EjbCMPEntityDescriptor) descriptor).getCMPVersion()) {\r\n                shouldBeAbstract = true;\r\n            }\r\n        }\r\n    }\r\n    Class c = loadEjbClass(descriptor, result);\r\n    if (c != null) {\r\n        boolean isAbstract = false;\r\n        int modifiers = c.getModifiers();\r\n        if (Modifier.isAbstract(modifiers)) {\r\n            isAbstract = true;\r\n        }\r\n        if (!isAbstract && !shouldBeAbstract) {\r\n            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"[ {0} ] properly declares non-abstract class modifier.\", new Object[] { descriptor.getEjbClassName() }));\r\n        }\r\n        if (isAbstract && shouldBeAbstract) {\r\n            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.passed(smh.getLocalString(getClass().getName() + \".passed2\", \"[ {0} ] properly declares abstract class modifier.\", new Object[] { descriptor.getEjbClassName() }));\r\n        }\r\n        if (isAbstract && !shouldBeAbstract) {\r\n            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Ejb Class [ {0} ] was found, but was declared as abstract.  The class  [ {1} ] must not be abstract.\", new Object[] { descriptor.getEjbClassName(), descriptor.getEjbClassName() }));\r\n        }\r\n        if (!isAbstract && shouldBeAbstract) {\r\n            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.failed(smh.getLocalString(getClass().getName() + \".failed2\", \"Error: CMP 2.0 Entity Bean Class [ {0} ] was found, but was declared as non abstract.  The class  [ {1} ] must be abstract.\", new Object[] { descriptor.getEjbClassName(), descriptor.getEjbClassName() }));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.SslConfig.setHandshakeTimeout",
	"Comment": "sets the timeout within which there must be activity from the client",
	"Method": "void setHandshakeTimeout(int timeoutMilliSeconds){\r\n    this.timeoutMilliSeconds = timeoutMilliSeconds;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.hashCode",
	"Comment": "returns a hash code for the object.this very basic method is used by the trace facility and shouldnot call any method which is traced.",
	"Method": "int hashCode(){\r\n    return hash;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.pwc.PwcWebModule.getEndpointAddresses",
	"Comment": "gets the url addresses corresponding to the web services endpoints of this web module.",
	"Method": "String[] getEndpointAddresses(){\r\n    return endpointAddresses;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHostValve.custom",
	"Comment": "handle an http status code or java exception by forwarding controlto the location included in the specified errorpage object.it isassumed that the caller has already recorded any request attributesthat are to be forwarded to this page.return true ifwe successfully utilized the specified error page location, orfalse if the default error report should be rendered.",
	"Method": "boolean custom(Request request,Response response,ErrorPage errorPage){\r\n    if (debug >= 1)\r\n        log(\"Processing \" + errorPage);\r\n    HttpServletRequest hreq = (HttpServletRequest) request.getRequest();\r\n    HttpServletResponse hres = (HttpServletResponse) response.getResponse();\r\n    ((HttpRequest) request).setPathInfo(errorPage.getLocation());\r\n    try {\r\n        Integer statusCodeObj = (Integer) hreq.getAttribute(RequestDispatcher.ERROR_STATUS_CODE);\r\n        int statusCode = statusCodeObj.intValue();\r\n        String message = (String) hreq.getAttribute(RequestDispatcher.ERROR_MESSAGE);\r\n        hres.setStatus(statusCode, message);\r\n        ServletContext servletContext = request.getContext().getServletContext();\r\n        ApplicationDispatcher dispatcher = (ApplicationDispatcher) servletContext.getRequestDispatcher(errorPage.getLocation());\r\n        if (hres.isCommitted()) {\r\n            dispatcher.include(hreq, hres);\r\n        } else {\r\n            response.resetBuffer(true);\r\n            dispatcher.dispatch(hreq, hres, DispatcherType.ERROR);\r\n            response.setSuspended(false);\r\n        }\r\n        return (true);\r\n    } catch (Throwable t) {\r\n        log(\"Exception Processing \" + errorPage, t);\r\n        return (false);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.PersistentManagerBase.propertyChange",
	"Comment": "process property change events from our associated context.",
	"Method": "void propertyChange(PropertyChangeEvent event){\r\n    if (!(event.getSource() instanceof Context))\r\n        return;\r\n    if (event.getPropertyName().equals(\"sessionTimeout\")) {\r\n        try {\r\n            setMaxInactiveIntervalSeconds(((Integer) event.getNewValue()).intValue() * 60);\r\n        } catch (NumberFormatException e) {\r\n            log.log(Level.SEVERE, LogFacade.INVALID_SESSION_TIMEOUT_SETTING_EXCEPTION, event.getNewValue().toString());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.webservices.WsUtil.getServiceForPort",
	"Comment": "find a service in which a particular port is defined.assumes portqname is unique within a wsdl.",
	"Method": "Service getServiceForPort(Model model,QName thePortName){\r\n    for (Iterator serviceIter = model.getServices(); serviceIter.hasNext(); ) {\r\n        Service nextService = (Service) serviceIter.next();\r\n        for (Iterator portIter = nextService.getPorts(); portIter.hasNext(); ) {\r\n            Port nextPort = (Port) portIter.next();\r\n            if (portsEqual(nextPort, thePortName)) {\r\n                return nextService;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.common.util.admin.MapInjectionResolver.setContext",
	"Comment": "set the context that is passed to the dynamicparamimpl.defaultvalue method.",
	"Method": "void setContext(ExecutionContext context){\r\n    this.context = context;\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.deleteDir",
	"Comment": "delete the specified directory, including all of its contents andsubdirectories recursively.",
	"Method": "void deleteDir(File dir){\r\n    String[] files = dir.list();\r\n    if (files == null) {\r\n        files = new String[0];\r\n    }\r\n    for (int i = 0; i < files.length; i++) {\r\n        File file = new File(dir, files[i]);\r\n        if (file.isDirectory()) {\r\n            deleteDir(file);\r\n        } else {\r\n            if (!FileUtils.deleteFileMaybe(file)) {\r\n                logger.log(Level.WARNING, LogFacade.UNABLE_TO_DELETE, file.toString());\r\n            }\r\n        }\r\n    }\r\n    if (!FileUtils.deleteFileMaybe(dir)) {\r\n        logger.log(Level.WARNING, LogFacade.UNABLE_TO_DELETE, dir.toString());\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getRequestDispatcher",
	"Comment": "return a requestdispatcher that wraps the resource at the specifiedpath, which may be interpreted as relative to the current request path.",
	"Method": "RequestDispatcher getRequestDispatcher(String path){\r\n    if (servletContext == null) {\r\n        return null;\r\n    }\r\n    if (path == null) {\r\n        return null;\r\n    } else if (path.startsWith(\"/\")) {\r\n        return servletContext.getRequestDispatcher(path);\r\n    }\r\n    String servPath = (String) getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);\r\n    if (servPath == null) {\r\n        servPath = getServletPath();\r\n    }\r\n    String pInfo = getPathInfo();\r\n    String requestPath = null;\r\n    if (pInfo == null) {\r\n        requestPath = servPath;\r\n    } else {\r\n        requestPath = servPath + pInfo;\r\n    }\r\n    int pos = requestPath.lastIndexOf('/');\r\n    String relative = null;\r\n    if (pos >= 0) {\r\n        relative = requestPath.substring(0, pos + 1) + path;\r\n    } else {\r\n        relative = requestPath + path;\r\n    }\r\n    return servletContext.getRequestDispatcher(relative);\r\n}"
}, {
	"Path": "org.apache.naming.resources.RecyclableNamingEnumeration.hasMore",
	"Comment": "determines whether there are any more elements in the enumeration.",
	"Method": "boolean hasMore(){\r\n    return enumeration.hasMoreElements();\r\n}"
}, {
	"Path": "org.apache.catalina.util.ProcessEnvironment.deriveProcessEnvironment",
	"Comment": "constructs the process environment to be supplied to the invokedprocess.defines an environment no environment variables.should be overriden by subclasses to perform useful setup.",
	"Method": "boolean deriveProcessEnvironment(HttpServletRequest req){\r\n    Hashtable<String, String> envp = new Hashtable<String, String>();\r\n    command = getCommand();\r\n    if (command != null) {\r\n        workingDirectory = new File(command.substring(0, command.lastIndexOf(File.separator)));\r\n        envp.put(\"X_TOMCAT_COMMAND_PATH\", command);\r\n    }\r\n    this.env = envp;\r\n    return true;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.node.runtime.gf.WebBundleRuntimeNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object newDescriptor){\r\n    SunWebAppImpl sunWebApp = (SunWebAppImpl) descriptor.getSunDescriptor();\r\n    if (newDescriptor instanceof WebComponentDescriptor) {\r\n        WebComponentDescriptor servlet = (WebComponentDescriptor) newDescriptor;\r\n        Servlet s1descriptor = new Servlet();\r\n        s1descriptor.setServletName(servlet.getCanonicalName());\r\n        if (servlet.getRunAsIdentity() != null) {\r\n            s1descriptor.setPrincipalName(servlet.getRunAsIdentity().getPrincipal());\r\n        }\r\n        sunWebApp.addServlet(s1descriptor);\r\n    } else if (newDescriptor instanceof ServiceReferenceDescriptor) {\r\n        descriptor.addServiceReferenceDescriptor((ServiceReferenceDescriptor) newDescriptor);\r\n    } else if (newDescriptor instanceof SecurityRoleMapping) {\r\n        SecurityRoleMapping srm = (SecurityRoleMapping) newDescriptor;\r\n        sunWebApp.addSecurityRoleMapping(srm);\r\n        Application app = descriptor.getApplication();\r\n        if (app != null) {\r\n            Role role = new Role(srm.getRoleName());\r\n            SecurityRoleMapper rm = app.getRoleMapper();\r\n            if (rm != null) {\r\n                List<PrincipalNameDescriptor> principals = srm.getPrincipalNames();\r\n                for (int i = 0; i < principals.size(); i++) {\r\n                    rm.assignRole(principals.get(i).getPrincipal(), role, descriptor);\r\n                }\r\n                List<String> groups = srm.getGroupNames();\r\n                for (int i = 0; i < groups.size(); i++) {\r\n                    rm.assignRole(new Group(groups.get(i)), role, descriptor);\r\n                }\r\n            }\r\n        }\r\n    } else if (newDescriptor instanceof IdempotentUrlPattern) {\r\n        sunWebApp.addIdempotentUrlPattern((IdempotentUrlPattern) newDescriptor);\r\n    } else if (newDescriptor instanceof SessionConfig) {\r\n        sunWebApp.setSessionConfig((SessionConfig) newDescriptor);\r\n    } else if (newDescriptor instanceof Cache) {\r\n        sunWebApp.setCache((Cache) newDescriptor);\r\n    } else if (newDescriptor instanceof ClassLoader) {\r\n        sunWebApp.setClassLoader((ClassLoader) newDescriptor);\r\n    } else if (newDescriptor instanceof JspConfig) {\r\n        sunWebApp.setJspConfig((JspConfig) newDescriptor);\r\n    } else if (newDescriptor instanceof LocaleCharsetInfo) {\r\n        sunWebApp.setLocaleCharsetInfo((LocaleCharsetInfo) newDescriptor);\r\n    } else if (newDescriptor instanceof WebProperty) {\r\n        sunWebApp.addWebProperty((WebProperty) newDescriptor);\r\n    } else if (newDescriptor instanceof Valve) {\r\n        sunWebApp.addValve((Valve) newDescriptor);\r\n    } else\r\n        super.addDescriptor(descriptor);\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardManager.propertyChange",
	"Comment": "process property change events from our associated context.",
	"Method": "void propertyChange(PropertyChangeEvent event){\r\n    if (!(event.getSource() instanceof Context))\r\n        return;\r\n    if (\"sessionTimeout\".equals(event.getPropertyName())) {\r\n        try {\r\n            setMaxInactiveIntervalSeconds((Integer) event.getNewValue() * 60);\r\n        } catch (NumberFormatException e) {\r\n            log.log(Level.SEVERE, LogFacade.INVALID_SESSION_TIMEOUT_SETTING_EXCEPTION, event.getNewValue().toString());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.WebArchiveClassesLoadable.getClassNames",
	"Comment": "looks for servlet classes, servletfilter classes, listener classes and exception classes in the webbundledescriptor. the closure is computedstarting from these classes.",
	"Method": "List getClassNames(WebBundleDescriptor descriptor){\r\n    final List<String> results = new LinkedList<String>();\r\n    for (Object obj : descriptor.getServletDescriptors()) {\r\n        String servletClassName = (WebComponentDescriptor.class.cast(obj)).getWebComponentImplementation();\r\n        results.add(servletClassName);\r\n    }\r\n    for (Object obj : descriptor.getServletFilterDescriptors()) {\r\n        String filterClassName = (ServletFilter.class.cast(obj)).getClassName();\r\n        results.add(filterClassName);\r\n    }\r\n    for (Object obj : descriptor.getAppListenerDescriptors()) {\r\n        String listenerClassName = (AppListenerDescriptor.class.cast(obj)).getListener();\r\n        results.add(listenerClassName);\r\n    }\r\n    results.addAll(getVerifierContext().getFacesConfigDescriptor().getManagedBeanClasses());\r\n    Enumeration en = ((WebBundleDescriptorImpl) descriptor).getErrorPageDescriptors();\r\n    while (en.hasMoreElements()) {\r\n        ErrorPageDescriptor errorPageDescriptor = (ErrorPageDescriptor) en.nextElement();\r\n        String exceptionType = errorPageDescriptor.getExceptionType();\r\n        if (exceptionType != null && !exceptionType.equals(\"\"))\r\n            results.add(exceptionType);\r\n    }\r\n    File file = getVerifierContext().getOutDir();\r\n    if (!file.exists())\r\n        return results;\r\n    FileArchive arch = new FileArchive();\r\n    arch.open(file.toURI());\r\n    Enumeration entries = arch.entries();\r\n    while (entries.hasMoreElements()) {\r\n        String name = (String) entries.nextElement();\r\n        if (name.startsWith(\"org/apache/jsp\") && name.endsWith(\".class\"))\r\n            results.add(name.substring(0, name.lastIndexOf(\".\")).replace('/', '.'));\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.stop",
	"Comment": "gracefully terminate the active use of the public methods of thiscomponent.this method should be the last one called on a giveninstance of this component.",
	"Method": "void stop(){\r\n    if (!_started) {\r\n        String msg = rb.getString(LogFacade.WEB_CONTAINER_NOT_STARTED);\r\n        throw new LifecycleException(msg);\r\n    }\r\n    _started = false;\r\n    try {\r\n        _embedded.stop();\r\n    } catch (LifecycleException ex) {\r\n        if (!ex.getMessage().contains(\"has not been started\")) {\r\n            throw ex;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getClassLoader",
	"Comment": "gets the class loader of the web application represented by thisservletcontext.",
	"Method": "ClassLoader getClassLoader(){\r\n    ClassLoader webappLoader = (getLoader() != null) ? getLoader().getClassLoader() : null;\r\n    if (webappLoader == null) {\r\n        return null;\r\n    }\r\n    if (mySecurityManager != null) {\r\n        mySecurityManager.checkGetClassLoaderPermission(webappLoader);\r\n    }\r\n    return webappLoader;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.ServerSynchronizer.removeFile",
	"Comment": "send a request to the client to remove the specified file.the file is named by mt.name, relative to base.the nameused in the response will be relative to root.",
	"Method": "void removeFile(URI root,File base,ModTime mt,Payload.Outbound payload){\r\n    File f = fileOf(base, mt.name);\r\n    if (logger.isLoggable(Level.FINEST))\r\n        logger.finest(\"ServerSynchronizer: file \" + mt.name + \" removed from client\");\r\n    try {\r\n        if (logger.isLoggable(Level.FINE))\r\n            logger.fine(\"ServerSynchronizer: removing file \" + f + \" because it does not exist on the DAS\");\r\n        payload.requestFileRemoval(root.relativize(f.toURI()), \"configChange\", null);\r\n    } catch (IOException ioex) {\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.fine(\"ServerSynchronizer: IOException removing file: \" + f);\r\n            logger.fine(ioex.toString());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.services.SMFService.isConfigValid",
	"Comment": "determines if the configuration of the method is valid. when this classis constructed, appropriate defaults are used. but before attempting to createthe service in the solaris platform, it is important that the necessaryconfiguration is done by the users via various mutator methods of this class.this method must be called to guard against some abnormal failures beforecreating the service. it makes sure that the caller has set all the necessaryparameters reasonably. note that it does not validate the actual values.",
	"Method": "boolean isConfigValid(){\r\n    final Set<String> keys = getTokenMap().keySet();\r\n    for (final String k : keys) {\r\n        final boolean aNullValue = NULL_VALUE.equals(getTokenMap().get(k));\r\n        if (aNullValue) {\r\n            final String msg = sm.getString(\"smfTokenNeeded\", k, getTokenMap().get(k));\r\n            throw new RuntimeException(msg);\r\n        }\r\n    }\r\n    final File mf = new File(getManifestFileTemplatePath());\r\n    if (!mf.exists()) {\r\n        final String msg = sm.getString(\"serviceTemplateNotFound\", getManifestFileTemplatePath());\r\n        throw new RuntimeException(msg);\r\n    }\r\n    return (true);\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.WithDefaultsRulesWrapper.addDefault",
	"Comment": "adds a rule to be fired when wrapped implementation returns no matches",
	"Method": "void addDefault(Rule rule){\r\n    if (wrappedRules.getDigester() != null) {\r\n        rule.setDigester(wrappedRules.getDigester());\r\n    }\r\n    if (wrappedRules.getNamespaceURI() != null) {\r\n        rule.setNamespaceURI(wrappedRules.getNamespaceURI());\r\n    }\r\n    defaultRules.add(rule);\r\n    allRules.add(rule);\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.NamingResources.addMessageDestinationRef",
	"Comment": "add a message destination reference for this web application.",
	"Method": "void addMessageDestinationRef(MessageDestinationRef mdr){\r\n    if (entries.containsKey(mdr.getName())) {\r\n        return;\r\n    } else {\r\n        entries.put(mdr.getName(), mdr.getType());\r\n    }\r\n    synchronized (mdrs) {\r\n        mdr.setNamingResources(this);\r\n        mdrs.put(mdr.getName(), mdr);\r\n    }\r\n    support.firePropertyChange(\"messageDestinationRef\", null, mdr);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorSynchronizationImpl.servant",
	"Comment": "returns the coordinatorsynchronizationimpl which serves the given object.",
	"Method": "CoordinatorSynchronizationImpl servant(Synchronization sync){\r\n    CoordinatorSynchronizationImpl result = null;\r\n    if (sync != null && Configuration.getProxyChecker().isProxy(sync)) {\r\n        return result;\r\n    }\r\n    if (sync instanceof CoordinatorSynchronizationImpl) {\r\n        result = (CoordinatorSynchronizationImpl) sync;\r\n    } else if (poa != null) {\r\n        try {\r\n            result = (CoordinatorSynchronizationImpl) poa.reference_to_servant(sync);\r\n            if (result.thisRef == null)\r\n                result.thisRef = sync;\r\n        } catch (Exception exc) {\r\n            _logger.log(Level.WARNING, \"jts.cannot_locate_servant\", \"CoordinatorSynchronization\");\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.getWebContainerFeatureFactory",
	"Comment": "return the webcontainerfeaturefactory according to the configuration.",
	"Method": "WebContainerFeatureFactory getWebContainerFeatureFactory(){\r\n    String featureFactoryName = (serverConfigLookup.calculateWebAvailabilityEnabledFromConfig() ? \"ha\" : \"pe\");\r\n    return webContainerFeatureFactory = habitat.getService(WebContainerFeatureFactory.class, featureFactoryName);\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.ThresholdingOutputStream.checkThreshold",
	"Comment": "checks to see if writing the specified number of bytes would cause theconfigured threshold to be exceeded. if so, triggers an event to allowa concrete implementation to take action on this.",
	"Method": "void checkThreshold(int count){\r\n    if (!thresholdExceeded && (written + count > threshold)) {\r\n        thresholdExceeded = true;\r\n        thresholdReached();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.removeNote",
	"Comment": "remove any object bound to the specified name in the internal notesfor this request.",
	"Method": "void removeNote(String name){\r\n    notes.remove(name);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.logger.IASLogger.write",
	"Comment": "logs the message to the jdk 1.4 logger that handles all logmessages for the iplanet application server.",
	"Method": "void write(String msg,int verbosity){\r\n    if (_logger == null)\r\n        return;\r\n    Level level = Level.INFO;\r\n    if (verbosity == FATAL)\r\n        level = (Level) IASLevel.FATAL;\r\n    else if (verbosity == ERROR)\r\n        level = Level.SEVERE;\r\n    else if (verbosity == WARNING)\r\n        level = Level.WARNING;\r\n    else if (verbosity == INFORMATION)\r\n        level = Level.INFO;\r\n    else if (verbosity == DEBUG)\r\n        level = Level.FINER;\r\n    inferCaller();\r\n    _logger.logp(level, _classname, _methodname, msg);\r\n}"
}, {
	"Path": "com.sun.jts.trace.TraceRecordFormatter.convertXidArrayToString",
	"Comment": "converts an array of xids to string that can be printed. its a helper method.",
	"Method": "String convertXidArrayToString(Xid[] xidArray){\r\n    if (xidArray.length != 0) {\r\n        int i;\r\n        StringBuffer strBuf = new StringBuffer(\"[ \");\r\n        for (i = 0; i < xidArray.length - 1; i++) {\r\n            strBuf.append(convertToString(xidArray[i].getGlobalTransactionId())).append(\", \");\r\n        }\r\n        strBuf.append(xidArray[xidArray.length - 1]).append(\" ]\");\r\n        return strBuf.toString();\r\n    } else\r\n        return \" null \";\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.getServletMethods",
	"Comment": "gets the names of the methods supported by the underlying servlet.this is the same set of methods included in the allow response headerin response to an options request method processed by the underlyingservlet.",
	"Method": "String[] getServletMethods(){\r\n    loadServletClass();\r\n    if (!javax.servlet.http.HttpServlet.class.isAssignableFrom(servletClass)) {\r\n        return DEFAULT_SERVLET_METHODS;\r\n    }\r\n    HashSet<String> allow = new HashSet<String>();\r\n    allow.add(\"TRACE\");\r\n    allow.add(\"OPTIONS\");\r\n    Method[] methods = getAllDeclaredMethods(servletClass);\r\n    for (int i = 0; methods != null && i < methods.length; i++) {\r\n        Method m = methods[i];\r\n        Class<?>[] params = m.getParameterTypes();\r\n        if (!(params.length == 2 && params[0] == HttpServletRequest.class && params[1] == HttpServletResponse.class)) {\r\n            continue;\r\n        }\r\n        if (m.getName().equals(\"doGet\")) {\r\n            allow.add(\"GET\");\r\n            allow.add(\"HEAD\");\r\n        } else if (m.getName().equals(\"doPost\")) {\r\n            allow.add(\"POST\");\r\n        } else if (m.getName().equals(\"doPut\")) {\r\n            allow.add(\"PUT\");\r\n        } else if (m.getName().equals(\"doDelete\")) {\r\n            allow.add(\"DELETE\");\r\n        }\r\n    }\r\n    String[] methodNames = new String[allow.size()];\r\n    return allow.toArray(methodNames);\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.AuthenticatorBase.invoke",
	"Comment": "enforce the security restrictions in the web application deploymentdescriptor of our associated context.",
	"Method": "int invoke(Request request,Response response){\r\n    if (!context.getAvailable()) {\r\n        try {\r\n            ((HttpServletResponse) response.getResponse()).sendError(HttpServletResponse.SC_SERVICE_UNAVAILABLE);\r\n        } catch (IllegalStateException e) {\r\n            ;\r\n        } catch (IOException e) {\r\n            ;\r\n        }\r\n        return END_PIPELINE;\r\n    }\r\n    HttpRequest hrequest = (HttpRequest) request;\r\n    HttpResponse hresponse = (HttpResponse) response;\r\n    if (log.isLoggable(Level.FINE)) {\r\n        String msg = \"Security checking request \" + ((HttpServletRequest) request.getRequest()).getMethod() + \" \" + ((HttpServletRequest) request.getRequest()).getRequestURI();\r\n        log.log(Level.FINE, neutralizeForLog(msg));\r\n    }\r\n    LoginConfig config = this.context.getLoginConfig();\r\n    if (cache) {\r\n        Principal principal = ((HttpServletRequest) request.getRequest()).getUserPrincipal();\r\n        if (principal == null) {\r\n            Session session = getSession(hrequest);\r\n            if (session != null) {\r\n                principal = session.getPrincipal();\r\n                if (principal != null) {\r\n                    if (log.isLoggable(Level.FINE)) {\r\n                        String msg = \"We have cached auth type \" + session.getAuthType() + \" for principal \" + session.getPrincipal();\r\n                        log.log(Level.FINE, neutralizeForLog(msg));\r\n                    }\r\n                    hrequest.setAuthType(session.getAuthType());\r\n                    hrequest.setUserPrincipal(principal);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    Realm realm = this.context.getRealm();\r\n    SecurityConstraint[] constraints = realm.findSecurityConstraints(hrequest, this.context);\r\n    if ((constraints == null)) {\r\n        if (log.isLoggable(Level.FINE))\r\n            log.log(Level.FINE, \" Not subject to any constraint\");\r\n        return processSecurityCheck(hrequest, hresponse, config);\r\n    }\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \" Calling hasUserDataPermission()\");\r\n    if (!realm.hasUserDataPermission(hrequest, hresponse, constraints)) {\r\n        if (log.isLoggable(Level.FINE))\r\n            log.log(Level.FINE, \" Failed hasUserDataPermission() test\");\r\n        return END_PIPELINE;\r\n    }\r\n    int preAuthenticateCheckResult = realm.preAuthenticateCheck(hrequest, hresponse, constraints, disableProxyCaching, securePagesWithPragma, (sso != null));\r\n    if (preAuthenticateCheckResult == Realm.AUTHENTICATE_NOT_NEEDED) {\r\n        return processSecurityCheck(hrequest, hresponse, config);\r\n    } else if (preAuthenticateCheckResult == Realm.AUTHENTICATE_NEEDED) {\r\n        if (log.isLoggable(Level.FINE)) {\r\n            log.log(Level.FINE, \" Calling authenticate()\");\r\n        }\r\n        boolean authenticateResult = realm.invokeAuthenticateDelegate(hrequest, hresponse, context, this, false);\r\n        if (!authenticateResult) {\r\n            if (log.isLoggable(Level.FINE)) {\r\n                log.log(Level.FINE, \" Failed authenticate() test\");\r\n            }\r\n            return END_PIPELINE;\r\n        }\r\n    } else if (preAuthenticateCheckResult == Realm.AUTHENTICATED_NOT_AUTHORIZED) {\r\n        return END_PIPELINE;\r\n    }\r\n    if (log.isLoggable(Level.FINE)) {\r\n        log.log(Level.FINE, \" Calling accessControl()\");\r\n    }\r\n    if (!realm.hasResourcePermission(hrequest, hresponse, constraints, this.context)) {\r\n        if (log.isLoggable(Level.FINE)) {\r\n            log.log(Level.FINE, \" Failed accessControl() test\");\r\n        }\r\n        Auditor[] auditors = this.context.getAuditors();\r\n        if (auditors != null) {\r\n            for (int j = 0; j < auditors.length; j++) {\r\n                auditors[j].webInvocation(hrequest, false);\r\n            }\r\n        }\r\n        return END_PIPELINE;\r\n    }\r\n    Auditor[] auditors = this.context.getAuditors();\r\n    if (auditors != null) {\r\n        boolean success = true;\r\n        for (int j = 0; j < auditors.length; j++) {\r\n            try {\r\n                auditors[j].webInvocation(hrequest, true);\r\n            } catch (Exception e) {\r\n                success = false;\r\n            }\r\n        }\r\n        if (!success) {\r\n            return END_PIPELINE;\r\n        }\r\n    }\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \"Successfully passed all security constraints\");\r\n    return INVOKE_NEXT;\r\n}"
}, {
	"Path": "org.glassfish.web.embed.impl.WebContainerImpl.createWebListener",
	"Comment": "creates a weblistener from the given class type andassigns the given id to it.",
	"Method": "T createWebListener(String id,Class<T> c){\r\n    T webListener = null;\r\n    if (log.isLoggable(Level.INFO)) {\r\n        log.info(\"Creating connector \" + id);\r\n    }\r\n    try {\r\n        webListener = c.newInstance();\r\n        webListener.setId(id);\r\n    } catch (Exception e) {\r\n        log.severe(\"Couldn't create connector \" + e.getMessage());\r\n    }\r\n    return webListener;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.cli.LocalServerCommand.getMasterPassword",
	"Comment": "get the master password, either from a password file orby asking the user.",
	"Method": "String getMasterPassword(){\r\n    final int RETRIES = 3;\r\n    long t0 = now();\r\n    String mpv = passwords.get(CLIConstants.MASTER_PASSWORD);\r\n    if (mpv == null) {\r\n        mpv = \"changeit\";\r\n        if (!verifyMasterPassword(mpv)) {\r\n            mpv = readFromMasterPasswordFile();\r\n            if (!verifyMasterPassword(mpv)) {\r\n                mpv = retry(RETRIES);\r\n            }\r\n        }\r\n    } else {\r\n        if (!verifyMasterPassword(mpv))\r\n            mpv = retry(RETRIES);\r\n    }\r\n    long t1 = now();\r\n    logger.log(Level.FINER, \"Time spent in master password extraction: {0} msec\", (t1 - t0));\r\n    return mpv;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.setMaxProcessors",
	"Comment": "set the maximum number of processors allowed, or 0 for unlimited.",
	"Method": "void setMaxProcessors(int maxProcessors){\r\n    this.maxProcessors = maxProcessors;\r\n    setProperty(\"maxThreads\", String.valueOf(maxProcessors));\r\n}"
}, {
	"Path": "com.sun.enterprise.web.logger.IASLogger.inferCaller",
	"Comment": "examine the call stack and determine the name of the method and thename of the class logging the message.",
	"Method": "void inferCaller(){\r\n    StackTraceElement[] stack = (new Throwable()).getStackTrace();\r\n    _classname = \"\";\r\n    _methodname = \"\";\r\n    for (int ix = 0; ix < stack.length; ix++) {\r\n        StackTraceElement frame = stack[ix];\r\n        _classname = frame.getClassName();\r\n        if (!_classname.startsWith(\"com.sun.enterprise.web.logger\")) {\r\n            _methodname = frame.getMethodName();\r\n            return;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.util.shared.ArchivistUtils.copy",
	"Comment": "utility method that eads the input stream fully and writes the bytes to the current entry in the output stream.",
	"Method": "void copy(InputStream is,OutputStream os){\r\n    copyWithoutClose(is, os);\r\n    is.close();\r\n    os.close();\r\n}"
}, {
	"Path": "org.glassfish.web.embed.impl.WebContainerImpl.addVirtualServer",
	"Comment": "adds the given virtualserver to thiswebcontainer.if this webcontainer has already been started,the given virtualserver will be started as well.",
	"Method": "void addVirtualServer(VirtualServer virtualServer){\r\n    if (!initialized) {\r\n        init();\r\n    }\r\n    if (log.isLoggable(Level.INFO)) {\r\n        log.info(\"Adding virtual server \" + virtualServer.getID());\r\n    }\r\n    com.sun.enterprise.web.VirtualServer vs = (com.sun.enterprise.web.VirtualServer) engine.findChild(virtualServer.getID());\r\n    if (vs != null) {\r\n        throw new ConfigException(\"VirtualServer with id \" + virtualServer.getID() + \" is already registered\");\r\n    }\r\n    Collection<WebListener> webListeners = virtualServer.getWebListeners();\r\n    List<String> names = new ArrayList<String>();\r\n    if ((webListeners != null) && (!webListeners.isEmpty())) {\r\n        for (WebListener listener : webListeners) {\r\n            names.add(listener.getId());\r\n        }\r\n    } else {\r\n        for (NetworkListener networkListener : networkConfig.getNetworkListeners().getNetworkListener()) {\r\n            names.add(networkListener.getName());\r\n        }\r\n        webListeners = listeners;\r\n    }\r\n    StringBuffer networkListeners = new StringBuffer(\"\");\r\n    if (names.size() > 0) {\r\n        networkListeners.append(names.get(0));\r\n    }\r\n    for (int i = 1; i < names.size(); i++) {\r\n        networkListeners.append(\",\");\r\n        networkListeners.append(names.get(i));\r\n    }\r\n    String docRoot = null;\r\n    if (virtualServer.getDocRoot() != null) {\r\n        docRoot = virtualServer.getDocRoot().getAbsolutePath();\r\n    }\r\n    String hostName = null;\r\n    if (virtualServer.getConfig() != null) {\r\n        hostName = virtualServer.getConfig().getHostNames();\r\n    }\r\n    final String root = docRoot;\r\n    final String nl = networkListeners.toString();\r\n    final String id = virtualServer.getID();\r\n    final String hosts = hostName;\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<HttpService>() {\r\n            public Object run(HttpService param) throws PropertyVetoException, TransactionFailure {\r\n                com.sun.enterprise.config.serverbeans.VirtualServer newVirtualServer = param.createChild(com.sun.enterprise.config.serverbeans.VirtualServer.class);\r\n                newVirtualServer.setId(id);\r\n                newVirtualServer.setNetworkListeners(nl);\r\n                if (hosts != null) {\r\n                    newVirtualServer.setHosts(hosts);\r\n                }\r\n                Property property = newVirtualServer.createChild(Property.class);\r\n                property.setName(\"docroot\");\r\n                property.setValue(root);\r\n                newVirtualServer.getProperty().add(property);\r\n                param.getVirtualServer().add(newVirtualServer);\r\n                return newVirtualServer;\r\n            }\r\n        }, httpService);\r\n    } catch (Exception ex) {\r\n        throw new GlassFishException(ex);\r\n    }\r\n    if ((webListeners != null) && (!webListeners.isEmpty())) {\r\n        for (WebListener listener : webListeners) {\r\n            if (getWebListener(listener.getId()) == null) {\r\n                addWebListener(listener, virtualServer.getID());\r\n            }\r\n        }\r\n    }\r\n    vs = (com.sun.enterprise.web.VirtualServer) engine.findChild(id);\r\n    if (vs != null) {\r\n        if (log.isLoggable(Level.INFO)) {\r\n            log.info(\"Added virtual server \" + id + \" docroot \" + docRoot + \" networklisteners \" + nl);\r\n        }\r\n        if (virtualServer instanceof VirtualServerFacade) {\r\n            ((VirtualServerFacade) virtualServer).setVirtualServer(vs);\r\n        }\r\n        vs.setNetworkListenerNames(names.toArray(new String[names.size()]));\r\n    } else {\r\n        log.severe(\"Could not add virtual server \" + id);\r\n        throw new GlassFishException(new Exception(\"Cannot add virtual server \" + id));\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.embed.impl.WebContainerImpl.addVirtualServer",
	"Comment": "adds the given virtualserver to thiswebcontainer.if this webcontainer has already been started,the given virtualserver will be started as well.",
	"Method": "void addVirtualServer(VirtualServer virtualServer){\r\n    com.sun.enterprise.config.serverbeans.VirtualServer newVirtualServer = param.createChild(com.sun.enterprise.config.serverbeans.VirtualServer.class);\r\n    newVirtualServer.setId(id);\r\n    newVirtualServer.setNetworkListeners(nl);\r\n    if (hosts != null) {\r\n        newVirtualServer.setHosts(hosts);\r\n    }\r\n    Property property = newVirtualServer.createChild(Property.class);\r\n    property.setName(\"docroot\");\r\n    property.setValue(root);\r\n    newVirtualServer.getProperty().add(property);\r\n    param.getVirtualServer().add(newVirtualServer);\r\n    return newVirtualServer;\r\n}"
}, {
	"Path": "org.apache.catalina.filters.CsrfPreventionFilter.setEntryPoints",
	"Comment": "entry points are urls that will not be tested for the presence of a validnonce. they are used to provide a way to navigate back to a protectedapplication after navigating away from it. entry points will be limitedto http get requests and should not trigger any security sensitiveactions.",
	"Method": "void setEntryPoints(String entryPoints){\r\n    String[] values = entryPoints.split(\",\");\r\n    for (String value : values) {\r\n        this.entryPoints.add(value.trim());\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.internal.deployment.GenericSniffer.getAnnotationTypes",
	"Comment": "returns the list of annotations types that this sniffer is interested in.if an application bundle contains at least one class annotated withone of the returned annotations, the deployment process will notcall the handles method but will invoke the containers deployers as ifthe handles method had been called and returned true.",
	"Method": "Class<? extends Annotation>[] getAnnotationTypes(){\r\n    return new Class[0];\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.getRoot",
	"Comment": "when the digester is being used as a saxcontenthandler, this method allows you to access the root object that has beencreated after parsing.",
	"Method": "Object getRoot(){\r\n    return root;\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutoDeployService.rescheduleAutoDeployer",
	"Comment": "reschedules the autodeployer because a configuration change has alteredthe frequency.",
	"Method": "void rescheduleAutoDeployer(int pollingIntervalInSeconds){\r\n    deplLogger.fine(\"[AutoDeploy] Restarting...\");\r\n    stopAutoDeployer();\r\n    try {\r\n        autoDeployer.waitUntilIdle();\r\n    } catch (InterruptedException e) {\r\n    }\r\n    startAutoDeployer(pollingIntervalInSeconds);\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ExtendedAccessLogValve.setPattern",
	"Comment": "set the format pattern, first translating any recognized alias.",
	"Method": "void setPattern(String pattern){\r\n    FieldInfo[] f = decodePattern(pattern);\r\n    if (f != null) {\r\n        this.pattern = pattern;\r\n        this.fieldInfos = f;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.jmx.MBeanProxyHandler.getAttributes",
	"Comment": "same as xattributesaccess.getattributes, but with exceptions",
	"Method": "AttributeList getAttributes(String[] attrNames){\r\n    final AttributeList results = getMBeanServerConnection().getAttributes(getObjectName(), attrNames);\r\n    postGetAttributesHook(attrNames, results);\r\n    return (results);\r\n}"
}, {
	"Path": "org.glassfish.api.jdbc.SQLTraceRecord.setThreadName",
	"Comment": "sets the thread name from which the sql statement originated.",
	"Method": "void setThreadName(String threadName){\r\n    this.threadName = threadName;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.Initializer.setFormatter",
	"Comment": "this method is only used in standalone invocation. for backend invocations this method should not be called. the logger should continueto use the default formatter when verifier is invoked from backend.",
	"Method": "void setFormatter(){\r\n    Handler[] handlers = logger.getParent().getHandlers();\r\n    for (int i = 0; i < handlers.length; i++) if (handlers[i] instanceof ConsoleHandler)\r\n        handlers[i].setFormatter(new VerifierFormatter());\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.provider.BaseProvider.isGivenTypeWritable",
	"Comment": "overwrite this if you need different test of type compatibility.used from iswritable method.",
	"Method": "boolean isGivenTypeWritable(Class<?> type,Type genericType){\r\n    return desiredType.isAssignableFrom(type);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getDocBase",
	"Comment": "return the document root for this context.this can be an absolutepathname, a relative pathname, or a url.",
	"Method": "String getDocBase(){\r\n    return docBase;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setAttribute",
	"Comment": "bind the specified value with the specified context attribute name,replacing any existing value for that name.",
	"Method": "void setAttribute(String name,Object value){\r\n    context.setAttribute(name, value);\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.NamingResources.getContainer",
	"Comment": "get the container with which the naming resources are associated.",
	"Method": "Object getContainer(){\r\n    return container;\r\n}"
}, {
	"Path": "org.apache.catalina.realm.GenericPrincipal.toString",
	"Comment": "return a string representation of this object, which exposes onlyinformation that should be public.",
	"Method": "String toString(){\r\n    StringBuilder sb = new StringBuilder(\"GenericPrincipal[\");\r\n    sb.append(this.name);\r\n    sb.append(\"(\");\r\n    for (int i = 0; i < roles.length; i++) {\r\n        sb.append(roles[i]).append(\",\");\r\n    }\r\n    sb.append(\")]\");\r\n    return (sb.toString());\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getLoginConfig",
	"Comment": "return the login configuration descriptor for this web application.",
	"Method": "LoginConfig getLoginConfig(){\r\n    return (this.loginConfig);\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.setClassLoader",
	"Comment": "set the class loader to be used for instantiating application objectswhen required.",
	"Method": "void setClassLoader(ClassLoader classLoader){\r\n    this.classLoader = classLoader;\r\n}"
}, {
	"Path": "com.sun.appserv.web.cache.filter.CachingResponseWrapper.getOutputStream",
	"Comment": "return the servlet output stream associated with this response.",
	"Method": "ServletOutputStream getOutputStream(){\r\n    if (writer != null)\r\n        throw new IllegalStateException(\"getOutputStream<>getWriter\");\r\n    if (cosw == null) {\r\n        cosw = createCachingOutputStreamWrapper();\r\n    }\r\n    return (ServletOutputStream) cosw;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.ServletInterface.check",
	"Comment": "servlet interface test.servlets must implement the javax.servlet.servlet interface either directly or indirectly through genericservlet or httpservlet",
	"Method": "Result check(WebBundleDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!descriptor.getServletDescriptors().isEmpty()) {\r\n        boolean oneFailed = false;\r\n        boolean notPassOrFail = true;\r\n        Set servlets = descriptor.getServletDescriptors();\r\n        Iterator itr = servlets.iterator();\r\n        result = loadWarFile(descriptor);\r\n        while (itr.hasNext()) {\r\n            WebComponentDescriptor servlet = (WebComponentDescriptor) itr.next();\r\n            String servletClassName = servlet.getWebComponentImplementation();\r\n            Class c = loadClass(result, servletClassName);\r\n            if (c == null) {\r\n                continue;\r\n            }\r\n            if (isJAXRPCEndpoint(servlet)) {\r\n                result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.addGoodDetails(smh.getLocalString(getClass().getName() + \".notApplicable1\", \"Not Applicable since, Servlet [ {0} ] is a JAXRPC Endpoint.\", new Object[] { servletClassName }));\r\n                notPassOrFail = false;\r\n            } else if (isImplementorOf(c, \"javax.servlet.Servlet\")) {\r\n                result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"Servlet class [ {0} ] directly or indirectly implements javax.servlet.Servlet\", new Object[] { servletClassName }));\r\n                notPassOrFail = false;\r\n            } else {\r\n                oneFailed = true;\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Servlet class [ {0} ] does not directly or indirectly implement javax.servlet.Servlet\", new Object[] { servletClassName }));\r\n                notPassOrFail = false;\r\n            }\r\n        }\r\n        if (notPassOrFail) {\r\n            result.addWarningDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.warning(smh.getLocalString(getClass().getName() + \".warning\", \"Some servlet classes could not be loaded.\"));\r\n        } else if (oneFailed) {\r\n            result.setStatus(Result.FAILED);\r\n        } else {\r\n            result.setStatus(Result.PASSED);\r\n        }\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"There are no servlet components within the web archive [ {0} ]\", new Object[] { descriptor.getName() }));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationFilterChain.setServlet",
	"Comment": "sets the servlet instance that will be executed at the end of thisfilter chain.",
	"Method": "void setServlet(Servlet servlet){\r\n    this.servlet = servlet;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.AsadminTrustManager.isItOKToAddCertToTrustStore",
	"Comment": "displays the certificate and prompts the user whether or not it is trusted.",
	"Method": "boolean isItOKToAddCertToTrustStore(X509Certificate c){\r\n    Console cons = System.console();\r\n    if (!interactive || cons == null) {\r\n        return true;\r\n    }\r\n    cons.printf(\"%s%n\", c.toString());\r\n    String result = cons.readLine(\"%s\", strmgr.get(\"certificateTrustPrompt\"));\r\n    return result != null && result.equalsIgnoreCase(\"y\");\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setUnloadDelay",
	"Comment": "set the value of the unloaddelay flag, which represents the amountof ms that the container will wait when unloading servlets.setting this to a small value may cause more requests to failto complete when stopping a web application.",
	"Method": "void setUnloadDelay(long unloadDelay){\r\n    long oldUnloadDelay = this.unloadDelay;\r\n    this.unloadDelay = unloadDelay;\r\n    support.firePropertyChange(\"unloadDelay\", Long.valueOf(oldUnloadDelay), Long.valueOf(this.unloadDelay));\r\n}"
}, {
	"Path": "org.glassfish.config.support.GenericCrudCommand.elementName",
	"Comment": "returns the element name used by the parent to store instances of the child",
	"Method": "String elementName(DomDocument document,Class<?> parent,Class<?> child){\r\n    ConfigModel cm = document.buildModel(parent);\r\n    for (String elementName : cm.getElementNames()) {\r\n        ConfigModel.Property prop = cm.getElement(elementName);\r\n        if (prop instanceof ConfigModel.Node) {\r\n            ConfigModel childCM = ((ConfigModel.Node) prop).getModel();\r\n            String childTypeName = childCM.targetTypeName;\r\n            if (childTypeName.equals(child.getName())) {\r\n                return childCM.getTagName();\r\n            }\r\n            List<ConfigModel> subChildrenModels = document.getAllModelsImplementing(childCM.classLoaderHolder.loadClass(childTypeName));\r\n            if (subChildrenModels != null) {\r\n                for (ConfigModel subChildModel : subChildrenModels) {\r\n                    if (subChildModel.targetTypeName.equals(child.getName())) {\r\n                        return subChildModel.getTagName();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteRestAdminCommand.reportAuthenticationException",
	"Comment": "return the error message to be used in the authenticationexception.subclasses can override to provide a more detailed message, forexample, indicating the source of the password that failed.the implementation in this class returns a default error message.",
	"Method": "String reportAuthenticationException(){\r\n    return strings.get(\"InvalidCredentials\", user);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CascadeDeleteNotSupportedForManyMany.runIndividualCmrTest",
	"Comment": "run an individual verifier test of a declated cmr field of the class",
	"Method": "boolean runIndividualCmrTest(Descriptor descriptor,RelationRoleDescriptor role,Class c,Result result){\r\n    boolean isMany = false;\r\n    boolean isPartnerMany = false;\r\n    boolean cascadeDelete = false;\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    isMany = role.getIsMany();\r\n    isPartnerMany = (role.getPartner()).getIsMany();\r\n    cascadeDelete = role.getCascadeDelete();\r\n    if (isMany && isPartnerMany && cascadeDelete) {\r\n        addErrorDetails(result, compName);\r\n        result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: cascade-delete should not be supported for many-many relationships. Please check Relationship Role [{0}]\", new Object[] { role.getName() }));\r\n        return false;\r\n    } else {\r\n        result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"cascade-delete is not supported for many-many relationships. Test passed.\", new Object[] {}));\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ModifiedAttributeHASession.removeAttribute",
	"Comment": "remove the attribute nameand update the attribute state accordingly",
	"Method": "void removeAttribute(String name){\r\n    super.removeAttribute(name);\r\n    SessionAttributeState attributeState = getAttributeState(name);\r\n    if (attributeState != null) {\r\n        if (attributeState.isPersistent()) {\r\n            attributeState.setDeleted(true);\r\n        } else {\r\n            removeAttributeState(name);\r\n        }\r\n    }\r\n    setDirty(true);\r\n}"
}, {
	"Path": "com.sun.jts.trace.TraceUtil.getCurrentTraceLevel",
	"Comment": "gets the current trace level. returns an integer as per the tracelevel constants.",
	"Method": "int getCurrentTraceLevel(){\r\n    return m_currentTraceLevel;\r\n}"
}, {
	"Path": "org.apache.catalina.util.RequestUtil.createSessionVersionString",
	"Comment": "creates the string representation for the given context path tosession version mappings.the returned string will be used as the value of ajsessionidversion cookie or jsessionidversion uri parameter, dependingon the configured session tracking mode.",
	"Method": "String createSessionVersionString(Map<String, String> sessionVersions){\r\n    if (sessionVersions == null) {\r\n        return null;\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    boolean first = true;\r\n    for (Map.Entry<String, String> e : sessionVersions.entrySet()) {\r\n        if (first) {\r\n            first = false;\r\n        } else {\r\n            sb.append(':');\r\n        }\r\n        String contextPath = e.getKey();\r\n        try {\r\n            sb.append(new String(HexUtils.convert(contextPath.getBytes(Charsets.UTF8_CHARSET))));\r\n        } catch (UnsupportedCharsetException ex) {\r\n            throw new IllegalArgumentException(ex);\r\n        }\r\n        sb.append(SESSION_VERSION_SEPARATOR);\r\n        sb.append(e.getValue());\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.CompositeResource.executeWriteCommandManaged",
	"Comment": "execute a writing admincommand with the specified parameters.",
	"Method": "ActionReporter executeWriteCommandManaged(String command,ParameterMap parameters){\r\n    return getCompositeUtil().executeWriteCommandManaged(getSubject(), command, parameters);\r\n}"
}, {
	"Path": "org.apache.catalina.startup.PasswdUserDatabase.getHome",
	"Comment": "return an absolute pathname to the home directory for the specified user.",
	"Method": "String getHome(String user){\r\n    return homes.get(user);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.setWrapper",
	"Comment": "set the wrapper within which this request is being processed.thismust be called as soon as the appropriate wrapper is identified, andbefore the request is ultimately passed to an application servlet.",
	"Method": "void setWrapper(Wrapper wrapper){\r\n    this.wrapper = wrapper;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.matchAlias",
	"Comment": "find all matched aliases.this is more expensive than verifyalias.",
	"Method": "Set<String> matchAlias(List<String> vsList,VirtualServer vs){\r\n    Set<String> matched = new HashSet<String>();\r\n    for (String alias : vs.getAliases()) {\r\n        if (vsList.contains(alias)) {\r\n            matched.add(alias);\r\n        }\r\n    }\r\n    return matched;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.FilterDef.setIsAsyncSupported",
	"Comment": "configures this filter as either supporting or not supportingasynchronous operations.",
	"Method": "void setIsAsyncSupported(boolean isAsyncSupported){\r\n    this.isAsyncSupported = isAsyncSupported;\r\n}"
}, {
	"Path": "com.sun.jts.jta.UserTransactionImpl.begin",
	"Comment": "create a new transaction and associate it with the current thread.",
	"Method": "void begin(){\r\n    if (transactionManager == null)\r\n        init();\r\n    this.transactionManager.begin();\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.jts.ResourceRecoveryManagerImpl.resourceRecoveryCompleted",
	"Comment": "notifies the resource listeners that recovery has completed",
	"Method": "void resourceRecoveryCompleted(){\r\n    Set<RecoveryResourceListener> listeners = recoveryListenersRegistry.getListeners();\r\n    for (RecoveryResourceListener rrl : listeners) {\r\n        rrl.recoveryCompleted();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.ClientArtifactsManager.addAll",
	"Comment": "adds all artifacts in collection to those to be added to the clientfacade jar.",
	"Method": "void addAll(File baseFile,Collection<File> artifactFiles){\r\n    for (File f : artifactFiles) {\r\n        add(baseFile, f);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Response.getContentType",
	"Comment": "return the content type that was set or calculated for this response,or null if no content type was set.",
	"Method": "String getContentType(){\r\n    return coyoteResponse.getContentType();\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.AuthorizationConstraintImpl.getSecurityRoles",
	"Comment": "return the security roles involved in this constraint. the enumeration is empty if there are none.",
	"Method": "Enumeration getSecurityRoles(){\r\n    if (this.securityRoles == null) {\r\n        this.securityRoles = new HashSet<SecurityRole>();\r\n    }\r\n    return (new Vector<SecurityRole>(this.getSecurityRoleSet())).elements();\r\n}"
}, {
	"Path": "org.apache.catalina.logger.LoggerBase.getContainer",
	"Comment": "return the container with which this logger has been associated.",
	"Method": "Container getContainer(){\r\n    return (container);\r\n}"
}, {
	"Path": "org.glassfish.internal.data.ApplicationInfo.getLibraries",
	"Comment": "returns the deployment time libraries for this application",
	"Method": "String getLibraries(){\r\n    return libraries;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.deploy.shared.DeploymentPlanArchive.exists",
	"Comment": "returns the existence of the given entry namethe file name must be relative to the root of the module.",
	"Method": "boolean exists(boolean exists,String name){\r\n    return (getEntry(name) != null);\r\n}"
}, {
	"Path": "org.apache.naming.resources.DirContextURLStreamHandler.isBound",
	"Comment": "returns true if the thread or the context class loader of the current thread is bound.",
	"Method": "boolean isBound(){\r\n    return (clBindings.containsKey(Thread.currentThread().getContextClassLoader())) || (threadBindings.containsKey(Thread.currentThread()));\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.setRules",
	"Comment": "set the rules implementation object containing ourrules collection and associated matching policy.",
	"Method": "void setRules(Rules rules){\r\n    this.rules = rules;\r\n    this.rules.setDigester(this);\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ModifiedAttributeHASession.getAddedAttributesPrevious",
	"Comment": "return an arraylist of stringswhose elements are the names of the added attributes",
	"Method": "List<String> getAddedAttributesPrevious(){\r\n    List<String> resultList = new ArrayList<String>();\r\n    for (Map.Entry<String, SessionAttributeState> entry : _attributeStates.entrySet()) {\r\n        SessionAttributeState nextAttrState = entry.getValue();\r\n        String nextAttrName = entry.getKey();\r\n        if (!nextAttrState.isPersistent()) {\r\n            resultList.add(nextAttrName);\r\n        }\r\n    }\r\n    return resultList;\r\n}"
}, {
	"Path": "com.sun.enterprise.util.AnnotationUtil.presentTransitive",
	"Comment": "if annotation is present on given type or on annotation which ison given type.",
	"Method": "boolean presentTransitive(Class<? extends Annotation> annotationClass,Class type){\r\n    if (type == null) {\r\n        return false;\r\n    }\r\n    if (type.isAnnotationPresent(annotationClass)) {\r\n        return true;\r\n    }\r\n    for (Annotation anno : type.getAnnotations()) {\r\n        if (anno.annotationType().isAnnotationPresent(ManagedJob.class)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.catalina.util.StringParser.reset",
	"Comment": "reset the current state of the parser to the beginning of thecurrent string being parsed.",
	"Method": "void reset(){\r\n    index = 0;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.removeChild",
	"Comment": "removes the given coordinator from the set of children of thetarget topcoordinator.if the topcoordinator is a temporary ancestor, and has norecoverable state after the child is removed, it destroys itself.",
	"Method": "boolean removeChild(CoordinatorImpl child){\r\n    boolean result = false;\r\n    if (nestingInfo != null) {\r\n        result = nestingInfo.removeChild(child);\r\n    }\r\n    if (temporary && !registered && !(participants != null && participants.involved()) && !(synchronizations != null && synchronizations.involved()) && !(nestingInfo != null && nestingInfo.numChildren() > 0)) {\r\n        cleanUpEmpty(null);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.diagnostics.context.impl.ContextImplContextPropagationIntegrationTest.testThreadLocalBehaviour",
	"Comment": "verify that multiple calls to get the current diagnostics context return the same instance.",
	"Method": "void testThreadLocalBehaviour(){\r\n    Context diagnosticsContextStart = mContextManager.getContext();\r\n    Assert.assertEquals(\"The implementation class of diagnosticsContext1 is not as expected.\", diagnosticsContextStart.getClass().getName(), ContextImpl.class.getName());\r\n    for (int i = 0; i < 13; i++) {\r\n        Context diagnosticsContext = mContextManager.getContext();\r\n        Assert.assertSame(\"The diagnostics context instance returned in iteration \" + i + \" is not the same instance as fetched at the start of the test.\", diagnosticsContextStart, diagnosticsContext);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.elements.MethodsExist.getAllMethods",
	"Comment": "it returns a list of all the methods in the given interface intf",
	"Method": "List<Method> getAllMethods(EjbDescriptor descriptor,List<Method> getAllMethods,String intf,List<Method> getAllMethods,Set<String> interfaces){\r\n    List<Method> methods = new ArrayList<Method>();\r\n    for (String intf : interfaces) {\r\n        Class intfClass = loadClass(intf);\r\n        if (intfClass == null)\r\n            continue;\r\n        methods.addAll(Arrays.asList(intfClass.getMethods()));\r\n    }\r\n    return methods;\r\n}"
}, {
	"Path": "org.glassfish.weld.connector.WeldUtils.hasCDIEnablingAnnotations",
	"Comment": "determine whether there are any beans annotated with annotations that should enable cdiprocessing even in the absence of a beans.xml descriptor.",
	"Method": "boolean hasCDIEnablingAnnotations(DeploymentContext context,URI path,boolean hasCDIEnablingAnnotations,DeploymentContext context,Collection<URI> paths){\r\n    List<String> result = new ArrayList<String>();\r\n    Types types = getTypes(context);\r\n    if (types != null) {\r\n        Iterator<Type> typesIter = types.getAllTypes().iterator();\r\n        while (typesIter.hasNext()) {\r\n            Type type = typesIter.next();\r\n            if (!(type instanceof AnnotationType)) {\r\n                Iterator<AnnotationModel> annotations = type.getAnnotations().iterator();\r\n                while (annotations.hasNext()) {\r\n                    AnnotationModel am = annotations.next();\r\n                    AnnotationType at = am.getType();\r\n                    if (isCDIEnablingAnnotation(at) && type.wasDefinedIn(paths)) {\r\n                        if (!result.contains(at.getName())) {\r\n                            result.add(at.getName());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return !(result.isEmpty());\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.ListenerClassExists.runIndividualListenerTest",
	"Comment": "run the verifier test against a declared individual listener class",
	"Method": "boolean runIndividualListenerTest(Result result,Class listenerClass){\r\n    if (listenerClass != null) {\r\n        result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"Listener class [ {0} ] resides in the WEB-INF/classes directory.\", new Object[] { listenerClass.getName() }));\r\n        return true;\r\n    } else\r\n        return false;\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionManagerImpl.commit",
	"Comment": "complete the transaction associated with the current thread. when thismethod completes, the thread becomes associated with no transaction.",
	"Method": "void commit(){\r\n    try {\r\n        current.commit(true);\r\n    } catch (TRANSACTION_ROLLEDBACK ex) {\r\n        RollbackException rbe = new RollbackException();\r\n        Throwable cause = ex.getCause();\r\n        if (cause != null) {\r\n            rbe.initCause(cause);\r\n        }\r\n        throw rbe;\r\n    } catch (NoTransaction ex) {\r\n        throw new IllegalStateException();\r\n    } catch (NO_PERMISSION ex) {\r\n        throw new SecurityException();\r\n    } catch (HeuristicMixed ex) {\r\n        throw new HeuristicMixedException();\r\n    } catch (HeuristicHazard ex) {\r\n        throw new HeuristicRollbackException();\r\n    } catch (Exception ex) {\r\n        throw new SystemException(ex.toString());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.cli.DeleteDomainCommand.checkRename",
	"Comment": "check that the domain directory can be renamed, to increase the likelyhoodthat it can be deleted.",
	"Method": "void checkRename(){\r\n    boolean ok = true;\r\n    try {\r\n        File root = getDomainsDir();\r\n        File domdir = new File(root, getDomainName());\r\n        File tmpdir = File.createTempFile(\"del-\", \"\", root);\r\n        ok = tmpdir.delete() && domdir.renameTo(tmpdir) && tmpdir.renameTo(domdir);\r\n    } catch (IOException ioe) {\r\n        ok = false;\r\n    }\r\n    if (!ok) {\r\n        String msg = strings.get(\"domain.fileinuse\", getDomainName(), getDomainRootDir());\r\n        throw new IllegalStateException(msg);\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.resources.WARDirContext.list",
	"Comment": "enumerates the names bound in the named context, along with the class names of objects bound to them. the contents of any subcontexts are not included.if a binding is added to or removed from this context, its effect on an enumeration previously returned is undefined.",
	"Method": "NamingEnumeration<NameClassPair> list(String name,NamingEnumeration<NameClassPair> list,Name name,ArrayList<NamingEntry> list,Entry entry){\r\n    ArrayList<NamingEntry> entries = new ArrayList<NamingEntry>();\r\n    Entry[] children = entry.getChildren();\r\n    Arrays.sort(children);\r\n    NamingEntry namingEntry = null;\r\n    for (int i = 0; i < children.length; i++) {\r\n        ZipEntry current = children[i].getEntry();\r\n        Object object = null;\r\n        if (current.isDirectory()) {\r\n            object = new WARDirContext(base, children[i]);\r\n        } else {\r\n            object = new WARResource(current);\r\n        }\r\n        namingEntry = new NamingEntry(children[i].getName(), object, NamingEntry.ENTRY);\r\n        entries.add(namingEntry);\r\n    }\r\n    return entries;\r\n}"
}, {
	"Path": "com.sun.enterprise.util.zip.ZipItem.toString",
	"Comment": "returns a string represenation of the real filename and the zip entryname.",
	"Method": "String toString(){\r\n    return \"File: \" + file.getPath() + \", name: \" + name;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationHttpRequest.isSpecial",
	"Comment": "is this attribute name one of the special ones that is added only forincluded servlets?",
	"Method": "boolean isSpecial(String name){\r\n    return specials.contains(name);\r\n}"
}, {
	"Path": "org.glassfish.internal.deployment.GenericSniffer.getAnnotationNames",
	"Comment": "returns the list of annotation names that this sniffer is interested in.if an application bundle contains at least one class annotated withone of the returned annotations, the deployment process will notcall the handles method but will invoke the containers deployers as ifthe handles method had been called and returned true.",
	"Method": "String[] getAnnotationNames(DeploymentContext context){\r\n    List<String> annotationNames = new ArrayList<String>();\r\n    for (Class<? extends Annotation> annotationType : getAnnotationTypes()) {\r\n        annotationNames.add(annotationType.getName());\r\n    }\r\n    return annotationNames.toArray(new String[annotationNames.size()]);\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.isPackageSealed",
	"Comment": "returns true if the specified package name is sealed according to thegiven manifest.",
	"Method": "boolean isPackageSealed(String name,Manifest man){\r\n    String path = name.replace('.', '/') + '/';\r\n    Attributes attr = man.getAttributes(path);\r\n    String sealed = null;\r\n    if (attr != null) {\r\n        sealed = attr.getValue(Name.SEALED);\r\n    }\r\n    if (sealed == null) {\r\n        if ((attr = man.getMainAttributes()) != null) {\r\n            sealed = attr.getValue(Name.SEALED);\r\n        }\r\n    }\r\n    return \"true\".equalsIgnoreCase(sealed);\r\n}"
}, {
	"Path": "org.glassfish.flashlight.impl.client.FlashlightProbeClientMediator.handleListenerAnnotations",
	"Comment": "pick out all methods in the listener with the correct annotation, look upthe referenced probe and return a list of all such pairs. validate thatthe methods really do matchup properly.",
	"Method": "List<MethodProbe> handleListenerAnnotations(Class listenerClass,String invokerId){\r\n    List<MethodProbe> mp = new LinkedList<MethodProbe>();\r\n    for (Method method : listenerClass.getMethods()) {\r\n        ProbeListener probeAnn = method.getAnnotation(ProbeListener.class);\r\n        if (probeAnn == null)\r\n            continue;\r\n        String probeString = probeAnn.value();\r\n        if (probeString == null)\r\n            continue;\r\n        if (invokerId != null) {\r\n            String[] strArr = probeString.split(\":\");\r\n            probeString = strArr[0] + \":\" + strArr[1] + \":\" + strArr[2] + invokerId + \":\" + strArr[3];\r\n        }\r\n        FlashlightProbe probe = probeRegistry.getProbe(probeString);\r\n        if (probe == null) {\r\n            String errStr = localStrings.getLocalString(\"probeNotRegistered\", \"Probe is not registered: {0}\", probeString);\r\n            throw new RuntimeException(errStr);\r\n        }\r\n        mp.add(new MethodProbe(method, probe));\r\n    }\r\n    return mp;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RecoveryCoordinatorImpl.rollbackOrphan",
	"Comment": "this method invoked rollback on the resource that is passed as aparameter.this procedure may be called as the main procedure of a new thread,which must be done for remote resource objectsduring resync to avoid the possibility of deadlock during resync.it is called directly when the resource is not a proxy.",
	"Method": "void rollbackOrphan(Resource res){\r\n    try {\r\n        res.rollback();\r\n    } catch (Throwable exc) {\r\n        if (exc instanceof HeuristicCommit || exc instanceof HeuristicMixed || exc instanceof HeuristicHazard) {\r\n            _logger.log(Level.WARNING, \"jts.heuristic_exception\", exc.toString());\r\n        } else {\r\n        }\r\n    }\r\n    res._release();\r\n}"
}, {
	"Path": "com.sun.enterprise.universal.process.ProcessStreamDrainer.getOutErrString",
	"Comment": "concatenates the stdout and stderr output and returns it as a string",
	"Method": "String getOutErrString(){\r\n    return outWorker.getString() + errWorker.getString();\r\n}"
}, {
	"Path": "org.apache.catalina.util.ManifestResource.getAvailableExtensions",
	"Comment": "return the set of extension objects representing optionalpackages that are bundled with the application associated with thespecified manifest.",
	"Method": "HashMap<String, Extension> getAvailableExtensions(HashMap<String, Extension> getAvailableExtensions,Manifest manifest){\r\n    Attributes attributes = manifest.getMainAttributes();\r\n    String name = attributes.getValue(\"Extension-Name\");\r\n    if (name == null)\r\n        return null;\r\n    HashMap<String, Extension> extensionMap = new HashMap<String, Extension>();\r\n    Extension extension = new Extension();\r\n    extension.setExtensionName(name);\r\n    extension.setImplementationURL(attributes.getValue(\"Implementation-URL\"));\r\n    extension.setImplementationVendor(attributes.getValue(\"Implementation-Vendor\"));\r\n    extension.setImplementationVendorId(attributes.getValue(\"Implementation-Vendor-Id\"));\r\n    extension.setImplementationVersion(attributes.getValue(\"Implementation-Version\"));\r\n    extension.setSpecificationVersion(attributes.getValue(\"Specification-Version\"));\r\n    if (!extensionMap.containsKey(extension.getUniqueId())) {\r\n        extensionMap.put(extension.getUniqueId(), extension);\r\n    }\r\n    return extensionMap;\r\n}"
}, {
	"Path": "org.apache.naming.resources.WebDirContext.release",
	"Comment": "release any resources allocated for this directory context.",
	"Method": "void release(){\r\n    jarFileResourcesProvider = null;\r\n    jarResourceBase = null;\r\n    super.release();\r\n}"
}, {
	"Path": "org.apache.naming.resources.ResourceCache.getMaxAllocateIterations",
	"Comment": "return the maximum amount of iterations during a space allocation.",
	"Method": "int getMaxAllocateIterations(){\r\n    return maxAllocateIterations;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.setMaxSavePostSize",
	"Comment": "set the maximum size of a post which will be saved by the containerduring authentication.",
	"Method": "void setMaxSavePostSize(int maxSavePostSize){\r\n    this.maxSavePostSize = maxSavePostSize;\r\n    setProperty(\"maxSavePostSize\", String.valueOf(maxSavePostSize));\r\n}"
}, {
	"Path": "com.sun.enterprise.web.ServerConfigLookup.getInstanceSessionManagerManagerProperties",
	"Comment": "get the manager properties bean from domain.xmlreturn null if not defined or other problem",
	"Method": "ManagerProperties getInstanceSessionManagerManagerProperties(){\r\n    SessionManager smBean = getInstanceSessionManager();\r\n    if (smBean == null) {\r\n        return null;\r\n    }\r\n    return smBean.getManagerProperties();\r\n}"
}, {
	"Path": "org.apache.naming.resources.BaseDirContext.composeName",
	"Comment": "composes the name of this context with a name relative to this context.",
	"Method": "Name composeName(Name name,Name prefix,String composeName,String name,String prefix){\r\n    return prefix + \"/\" + name;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.SetUtil.newSingletonSet",
	"Comment": "create a new set with one member.additional itemsmay be added.",
	"Method": "Set<T> newSingletonSet(T m1){\r\n    final Set<T> set = new HashSet<T>();\r\n    set.add(m1);\r\n    return (set);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.setXmlValidation",
	"Comment": "set the validation feature of the xml parser used whenparsing xml instances.",
	"Method": "void setXmlValidation(boolean xmlValidation){\r\n    this.xmlValidation = xmlValidation;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.core.proxy.ProxyFactory.getDomainRootProxy",
	"Comment": "return the domainroot. amx is guaranteed to be ready after this callreturns.",
	"Method": "DomainRoot getDomainRootProxy(DomainRoot getDomainRootProxy,boolean waitReady){\r\n    if (waitReady) {\r\n        mDomainRoot.waitAMXReady();\r\n    }\r\n    return (mDomainRoot);\r\n}"
}, {
	"Path": "com.sun.enterprise.universal.xml.MiniXmlParser.parseClusters",
	"Comment": "the logic of finding our server in it and picking out sysprops...",
	"Method": "void parseClusters(){\r\n    clusters = new ArrayList<ParsedCluster>();\r\n    while (skipToButNotPast(\"clusters\", \"cluster\")) {\r\n        ParsedCluster pc = new ParsedCluster(parseAttributes().get(\"name\"));\r\n        clusters.add(pc);\r\n        parseCluster(pc);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.jmx.NotificationBuilder.buildNew",
	"Comment": "build a new notification without any values in its mapand no message.",
	"Method": "Notification buildNew(Notification buildNew,String message){\r\n    return buildNewWithMap(message, null);\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ModifiedAttributeHASession.getAddedAttributes",
	"Comment": "return an arraylist of stringswhose elements are the names of the added attributes",
	"Method": "List<String> getAddedAttributes(){\r\n    List<String> resultList = new ArrayList<String>();\r\n    for (Map.Entry<String, SessionAttributeState> entry : _attributeStates.entrySet()) {\r\n        SessionAttributeState nextAttrState = entry.getValue();\r\n        String nextAttrName = entry.getKey();\r\n        if (!nextAttrState.isPersistent() && !nextAttrState.isDirty()) {\r\n            resultList.add(nextAttrName);\r\n        }\r\n    }\r\n    return resultList;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.elements.EjbLinkElement.check",
	"Comment": "the referenced bean must be an enterprise bean in the same ear file.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    boolean resolved = false;\r\n    boolean oneFailed = false;\r\n    int na = 0;\r\n    if (!descriptor.getEjbReferenceDescriptors().isEmpty()) {\r\n        for (Iterator itr = descriptor.getEjbReferenceDescriptors().iterator(); itr.hasNext(); ) {\r\n            EjbReferenceDescriptor nextEjbReference = (EjbReferenceDescriptor) itr.next();\r\n            if (nextEjbReference.isLinked()) {\r\n                String ejb_link = nextEjbReference.getLinkName();\r\n                ejb_link = ejb_link.substring(ejb_link.indexOf(\"#\") + 1);\r\n                try {\r\n                    Set ejbBundles = descriptor.getApplication().getBundleDescriptors(EjbBundleDescriptorImpl.class);\r\n                    Iterator ejbBundlesIterator = ejbBundles.iterator();\r\n                    EjbBundleDescriptorImpl ejbBundle = null;\r\n                    while (ejbBundlesIterator.hasNext()) {\r\n                        ejbBundle = (EjbBundleDescriptorImpl) ejbBundlesIterator.next();\r\n                        for (Iterator itr2 = ejbBundle.getEjbs().iterator(); itr2.hasNext(); ) {\r\n                            EjbDescriptor ejbDescriptor = (EjbDescriptor) itr2.next();\r\n                            if (ejbDescriptor.getName().equals(ejb_link)) {\r\n                                resolved = true;\r\n                                logger.log(Level.FINE, getClass().getName() + \".passed\", new Object[] { ejb_link, ejbDescriptor.getName() });\r\n                                addGoodDetails(result, compName);\r\n                                result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"Valid referenced bean [ {0} ].\", new Object[] { ejb_link }));\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                } catch (Exception e) {\r\n                    addErrorDetails(result, compName);\r\n                    result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failedException1\", \"Exception occured while opening or saving the J2EE archive.\", new Object[] {}));\r\n                    logger.log(Level.FINE, \"com.sun.enterprise.tools.verifier.testsprint\", new Object[] { \"[\" + getClass() + \"] Error: \" + e.getMessage() });\r\n                    if (!oneFailed) {\r\n                        oneFailed = true;\r\n                    }\r\n                }\r\n                if (!resolved) {\r\n                    if (!oneFailed) {\r\n                        oneFailed = true;\r\n                    }\r\n                    addErrorDetails(result, compName);\r\n                    result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: No EJB matching [ {0} ] found within [ {1} ] jar file.\", new Object[] { ejb_link, descriptor.getName() }));\r\n                } else {\r\n                    resolved = false;\r\n                }\r\n            } else {\r\n                addNaDetails(result, compName);\r\n                result.addNaDetails(smh.getLocalString(getClass().getName() + \".notApplicable1\", \"Warning:  Cannot verify the existence of an ejb reference [ {0} ] to external bean within different .ear file.\", new Object[] { nextEjbReference.getName() }));\r\n                na++;\r\n            }\r\n        }\r\n        if (oneFailed) {\r\n            result.setStatus(Result.FAILED);\r\n        } else if (na == descriptor.getEjbReferenceDescriptors().size()) {\r\n            result.setStatus(Result.NOT_APPLICABLE);\r\n        } else {\r\n            result.setStatus(Result.PASSED);\r\n        }\r\n        return result;\r\n    } else {\r\n        addNaDetails(result, compName);\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"There are no ejb references to other beans within this bean [ {0} ]\", new Object[] { descriptor.getName() }));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.stringsubs.impl.algorithm.AbstractSubstitutionAlgo.init",
	"Comment": "create test file used as a input file for string substitution.",
	"Method": "void init(){\r\n    Map<String, String> substitutionMap = new HashMap<String, String>();\r\n    substitutionMap.put(\"line\", \"replacedLine\");\r\n    substitutionMap.put(\"file\", \"testFile\");\r\n    substitutionMap.put(\"HTTP_PORT\", \"8080\");\r\n    substitutionMap.put(\"HTTPS_PORT\", \"8443\");\r\n    _algorithm = getAlgorithm(substitutionMap);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.ControlImpl.get_coordinator",
	"Comment": "returns the coordinator for the transaction.if the transaction has been completed, an appropriate exception is raised.this operation is part of the omg interface and must not returnany exceptions other than those defined in the omg interface.",
	"Method": "Coordinator get_coordinator(){\r\n    Coordinator result = coordRef;\r\n    if (tranState == Status.StatusCommitted) {\r\n        INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.Completed, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    if (tranState == Status.StatusRolledBack) {\r\n        TRANSACTION_ROLLEDBACK exc = new TRANSACTION_ROLLEDBACK(0, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    if (coordRef == null && coord != null) {\r\n        coordRef = coord.object();\r\n        result = coordRef;\r\n    }\r\n    if (result == null) {\r\n        Unavailable exc = new Unavailable();\r\n        throw exc;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RegisteredResources.distributePrepare",
	"Comment": "distributes prepare messages to all resources in the registered state.resource objects that vote to commit the transaction are added to theregisteredresources section in the coordinatorlog.all resources that return votereadonly have their state set tocompleted. the consolidated result is returned.",
	"Method": "Vote distributePrepare(){\r\n    Vote result = Vote.VoteReadOnly;\r\n    int laoIndex = -1;\r\n    boolean rmErr = false;\r\n    for (int i = 0; i < nRes && result != Vote.VoteRollback; i++) {\r\n        boolean isProxy = false;\r\n        Resource currResource = (Resource) resourceObjects.get(i);\r\n        if ((i == nRes - 1) && lastXAResCommit && (laoResource == null) && result == Vote.VoteCommit) {\r\n            try {\r\n                if (_logger.isLoggable(Level.FINER)) {\r\n                    _logger.logp(Level.FINER, \"RegisteredResources\", \"distributePrepare()\", \"Before invoking commit on LA resource = \" + currResource);\r\n                }\r\n                currResource.commit_one_phase();\r\n                resourceStates.set(i, ResourceStatus.Completed);\r\n                if (_logger.isLoggable(Level.FINER)) {\r\n                    _logger.logp(Level.FINER, \"RegisteredResources\", \"distributePrepare()\", \"After invoking commit on LA resource = \" + currResource);\r\n                }\r\n            } catch (Throwable exc) {\r\n                result = Vote.VoteRollback;\r\n                resourceStates.set(i, ResourceStatus.Completed);\r\n            }\r\n            return result;\r\n        }\r\n        if (!(currResource instanceof OTSResourceImpl)) {\r\n            ProxyChecker checkProxy = Configuration.getProxyChecker();\r\n            isProxy = checkProxy.isProxy(currResource);\r\n        }\r\n        Vote currResult = Vote.VoteRollback;\r\n        try {\r\n            if (_logger.isLoggable(Level.FINER)) {\r\n                _logger.logp(Level.FINER, \"RegisteredResources\", \"prepare()\", \"Before invoking prepare() on resource:\" + currResource);\r\n            }\r\n            currResult = currResource.prepare();\r\n            if (currResult == null) {\r\n                if (_logger.isLoggable(Level.FINER)) {\r\n                    _logger.logp(Level.FINER, \"RegisteredResources\", \"prepare()\", \"Marking the current resource as LAO:\" + currResource);\r\n                }\r\n                laoResource = currResource;\r\n                laoIndex = i;\r\n                continue;\r\n            }\r\n            if (_logger.isLoggable(Level.FINER)) {\r\n                _logger.logp(Level.FINER, \"RegisteredResources\", \"prepare()\", \"After invoking prepare() on resource:\" + currResource + \";This resource voted : \" + currResult);\r\n            }\r\n        } catch (Throwable exc) {\r\n            boolean hazard = exc instanceof HeuristicHazard;\r\n            boolean internal = exc instanceof INTERNAL;\r\n            if (exc instanceof HeuristicMixed || hazard || internal) {\r\n                if (!internal) {\r\n                    resourceStates.set(i, ResourceStatus.Heuristic);\r\n                }\r\n                try {\r\n                    distributeRollback(true);\r\n                } catch (Throwable ex2) {\r\n                    if (ex2 instanceof HeuristicMixed && hazard) {\r\n                        hazard = false;\r\n                    }\r\n                }\r\n                if (hazard) {\r\n                    throw (HeuristicHazard) exc;\r\n                } else if (internal) {\r\n                    throw (INTERNAL) exc;\r\n                } else if (exc instanceof HeuristicMixed) {\r\n                    throw (HeuristicMixed) exc;\r\n                } else {\r\n                    throw new HeuristicMixed();\r\n                }\r\n            } else if (exc instanceof RuntimeException) {\r\n                rmErr = true;\r\n            }\r\n            _logger.log(Level.WARNING, \"jts.exception_on_resource_operation\", new java.lang.Object[] { exc.toString(), \"prepare\" });\r\n        }\r\n        if (currResult == Vote.VoteCommit) {\r\n            if (logRecord != null) {\r\n                if (!(currResource instanceof OTSResourceImpl)) {\r\n                    if (logSection == null)\r\n                        logSection = logRecord.createSection(LOG_SECTION_NAME);\r\n                    logRecord.addObject(logSection, currResource);\r\n                }\r\n            }\r\n            if (result == Vote.VoteReadOnly) {\r\n                result = Vote.VoteCommit;\r\n            }\r\n        } else {\r\n            if (!rmErr)\r\n                resourceStates.set(i, ResourceStatus.Completed);\r\n            if (isProxy) {\r\n                currResource._release();\r\n            }\r\n            if (currResult == Vote.VoteRollback) {\r\n                result = currResult;\r\n            }\r\n        }\r\n    }\r\n    if (result == Vote.VoteCommit && laoResource != null) {\r\n        try {\r\n            if (_logger.isLoggable(Level.FINER)) {\r\n                _logger.logp(Level.FINER, \"RegisteredResources\", \"distributePrepare()\", \"Before invoking commit on LA resource = \" + laoResource);\r\n            }\r\n            resourceStates.set(laoIndex, ResourceStatus.Completed);\r\n            if (_logger.isLoggable(Level.FINER)) {\r\n                _logger.logp(Level.FINER, \"RegisteredResources\", \"distributePrepare()\", \"After invoking commit on LA resource = \" + laoResource);\r\n            }\r\n        } catch (Throwable exc) {\r\n            result = Vote.VoteRollback;\r\n            resourceStates.set(laoIndex, ResourceStatus.Completed);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.DummyApplication.getDescriptor",
	"Comment": "returns the deployment descriptor associated with this application",
	"Method": "Object getDescriptor(){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setXmlNamespaceAware",
	"Comment": "set the namespace aware feature of the xml parser used whenparsing xml instances.",
	"Method": "void setXmlNamespaceAware(boolean webXmlNamespaceAware){\r\n    this.webXmlNamespaceAware = webXmlNamespaceAware;\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.SecurityConstraint.getDataConstraint",
	"Comment": "gets the transport guarantee requirements for this securityconstraint",
	"Method": "TransportGuarantee getDataConstraint(){\r\n    return this.tg;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.pwc.PwcWebModule.getSessionCookieConfig",
	"Comment": "gets the session tracking cookie configuration of thisservletcontext.",
	"Method": "javax.servlet.SessionCookieConfig getSessionCookieConfig(){\r\n    if (webSessionCookieConfig == null) {\r\n        webSessionCookieConfig = new WebSessionCookieConfig(this);\r\n    }\r\n    return webSessionCookieConfig;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.jmx.OpenMBeanUtil.getOpenType",
	"Comment": "get the opentype of an object, which must conform to opentype requirements.",
	"Method": "OpenType getOpenType(Object o){\r\n    if (o == null) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    OpenType type = getSimpleType(o.getClass());\r\n    if (type == null) {\r\n        final Class<?> theClass = o.getClass();\r\n        if (theClass.isArray()) {\r\n            final int dimensions = getArrayDimensions(theClass);\r\n            final Class<?> elementClass = theClass.getComponentType();\r\n            final SimpleType simpleType = getSimpleType(elementClass);\r\n            if (simpleType != null) {\r\n                type = newArrayType(dimensions, simpleType);\r\n            } else {\r\n                final Object element = getAnyArrayElement(o);\r\n                if (CompositeData.class.isAssignableFrom(elementClass)) {\r\n                    if (element == null) {\r\n                        type = SimpleType.VOID;\r\n                    } else {\r\n                        type = newArrayType(dimensions, ((CompositeData) element).getCompositeType());\r\n                    }\r\n                } else if (TabularData.class.isAssignableFrom(elementClass)) {\r\n                    if (element == null) {\r\n                        type = SimpleType.VOID;\r\n                    } else {\r\n                        type = newArrayType(dimensions, TabularData.class.cast(element).getTabularType());\r\n                    }\r\n                }\r\n            }\r\n        } else if (o instanceof CompositeData) {\r\n            type = ((CompositeData) o).getCompositeType();\r\n        } else if (o instanceof TabularData) {\r\n            type = ((TabularData) o).getTabularType();\r\n        }\r\n    }\r\n    if (type == null) {\r\n        throw new IllegalArgumentException(o.getClass().getName());\r\n    }\r\n    return (type);\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.ThresholdingOutputStream.flush",
	"Comment": "flushes this output stream and forces any buffered output bytes to bewritten out.",
	"Method": "void flush(){\r\n    getStream().flush();\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.JspGroupDescriptor.getIncludePreludes",
	"Comment": "return an iterable over the include prelude elements for this group.",
	"Method": "Set<String> getIncludePreludes(){\r\n    if (this.includePreludes == null) {\r\n        this.includePreludes = new OrderedSet<String>();\r\n    }\r\n    return this.includePreludes;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmrFieldsAbstract.runIndividualCmrTest",
	"Comment": "run an individual verifier test of a declated cmr field of the class",
	"Method": "boolean runIndividualCmrTest(Descriptor entity,RelationRoleDescriptor rrd,Class c,Result result){\r\n    return isFieldAbstract(rrd.getCMRField(), c, result);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogRecordEnding.toString",
	"Comment": "this method is called to direct the object to format its state to a string.",
	"Method": "String toString(){\r\n    return \"LRE(curr=\" + currentLSN + \")\";\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.config.ConfigBeanJMXSupport.duckTypedToMBeanOperationInfo",
	"Comment": "ducktyped methods are always exposed as operations, never as attributes.",
	"Method": "MBeanOperationInfo duckTypedToMBeanOperationInfo(DuckTypedInfo info){\r\n    final Descriptor descriptor = descriptor(info.duckTyped());\r\n    final String name = info.name();\r\n    final Class<?> type = remoteType(info.returnType());\r\n    final String description = \"@DuckTyped \" + name + \" of \" + mIntf.getName();\r\n    final int impact = MBeanOperationInfo.UNKNOWN;\r\n    final List<MBeanParameterInfo> paramInfos = new ArrayList<MBeanParameterInfo>();\r\n    int i = 0;\r\n    for (final Class<?> paramClass : info.signature()) {\r\n        final String paramName = \"p\" + i;\r\n        final String paramType = remoteType(paramClass).getName();\r\n        final String paramDescription = \"parameter \" + i;\r\n        final MBeanParameterInfo paramInfo = new MBeanParameterInfo(paramName, paramType, paramDescription, null);\r\n        paramInfos.add(paramInfo);\r\n        ++i;\r\n    }\r\n    final MBeanParameterInfo[] paramInfosArray = CollectionUtil.toArray(paramInfos, MBeanParameterInfo.class);\r\n    final MBeanOperationInfo opInfo = new MBeanOperationInfo(name, description, paramInfosArray, type.getName(), impact, descriptor);\r\n    return opInfo;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.InstanceStateServiceImpl.submitJob",
	"Comment": "for now, this just submits the job directly to the pool.in the futureit might be possible to avoid submitting the job",
	"Method": "Future<InstanceCommandResult> submitJob(Server server,InstanceCommand ice,InstanceCommandResult r){\r\n    return cmdPool.submitJob(ice, r);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationHttpRequest.getRequestDispatcher",
	"Comment": "return a requestdispatcher that wraps the resource at the specifiedpath, which may be interpreted as relative to the current request path.",
	"Method": "RequestDispatcher getRequestDispatcher(String path){\r\n    if (context == null)\r\n        return (null);\r\n    if (path == null)\r\n        return (null);\r\n    else if (path.startsWith(\"/\"))\r\n        return (context.getServletContext().getRequestDispatcher(path));\r\n    String servletPath = (String) getAttribute(RequestDispatcher.INCLUDE_SERVLET_PATH);\r\n    if (servletPath == null)\r\n        servletPath = getServletPath();\r\n    String pathInfo = getPathInfo();\r\n    String requestPath = null;\r\n    if (pathInfo == null) {\r\n        requestPath = servletPath;\r\n    } else {\r\n        requestPath = servletPath + pathInfo;\r\n    }\r\n    int pos = requestPath.lastIndexOf('/');\r\n    String relative = null;\r\n    if (pos >= 0) {\r\n        relative = requestPath.substring(0, pos + 1) + path;\r\n    } else {\r\n        relative = requestPath + path;\r\n    }\r\n    return (context.getServletContext().getRequestDispatcher(relative));\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.addChild",
	"Comment": "adds the given coordinator reference to the set of children of thetarget topcoordinator.",
	"Method": "boolean addChild(CoordinatorImpl child){\r\n    boolean result;\r\n    if (nestingInfo == null) {\r\n        nestingInfo = new NestingInfo();\r\n    }\r\n    result = nestingInfo.addChild(child);\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.RequestFacade.isAsyncStarted",
	"Comment": "checks whether async processing has started on this request.",
	"Method": "boolean isAsyncStarted(){\r\n    if (request == null) {\r\n        throw new IllegalStateException(rb.getString(LogFacade.CANNOT_USE_REQUEST_OBJECT_OUTSIDE_SCOPE_EXCEPTION));\r\n    }\r\n    return request.isAsyncStarted();\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebResourceCollectionImpl.getHttpMethodOmissions",
	"Comment": "return the set of http method omissions this collection has.",
	"Method": "Set<String> getHttpMethodOmissions(){\r\n    if (this.httpMethodOmissions == null) {\r\n        this.httpMethodOmissions = new HashSet<String>();\r\n    }\r\n    return this.httpMethodOmissions;\r\n}"
}, {
	"Path": "org.apache.naming.SelectorContext.lookupLink",
	"Comment": "retrieves the named object, following links except for the terminal atomic component of the name.",
	"Method": "Object lookupLink(Name name,Object lookupLink,String name){\r\n    return getBoundContext().lookupLink(parseName(name));\r\n}"
}, {
	"Path": "com.sun.enterprise.util.i18n.StringManagerBase.getStringWithDefault",
	"Comment": "returns a local string for the caller and format the arguments accordingly. if the key is not found, it will use the given default format.",
	"Method": "String getStringWithDefault(String key,String defaultValue,String getStringWithDefault,String key,String defaultFormat,Object arguments){\r\n    MessageFormat f = new MessageFormat(getStringWithDefault(key, defaultFormat));\r\n    for (int i = 0; i < arguments.length; i++) {\r\n        if (arguments[i] == null) {\r\n            arguments[i] = \"null\";\r\n        } else if (!(arguments[i] instanceof String) && !(arguments[i] instanceof Number) && !(arguments[i] instanceof java.util.Date)) {\r\n            arguments[i] = arguments[i].toString();\r\n        }\r\n    }\r\n    String fmtStr;\r\n    try {\r\n        fmtStr = f.format(arguments);\r\n    } catch (Exception e) {\r\n        _logger.log(Level.WARNING, CULoggerInfo.exceptionWhileFormating, e);\r\n        fmtStr = defaultFormat;\r\n    }\r\n    return fmtStr;\r\n}"
}, {
	"Path": "org.glassfish.admin.payload.PayloadFilesManagerTest.testGetOutputFileURI",
	"Comment": "test of getoutputfileuri method, of class payloadfilesmanager.",
	"Method": "void testGetOutputFileURI(){\r\n    PayloadFilesManager.Temp instance = new PayloadFilesManager.Temp(Logger.getAnonymousLogger());\r\n    try {\r\n        String originalPath = \"way/over/there/myApp.ear\";\r\n        Part testPart = PayloadImpl.Part.newInstance(\"text/plain\", originalPath, null, \"random content\");\r\n        URI result = instance.getOutputFileURI(testPart, testPart.getName());\r\n        assertTrue(result.toASCIIString().endsWith(\"/myApp.ear\"));\r\n    } finally {\r\n        instance.cleanup();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.FileStore.file",
	"Comment": "return a file object representing the pathname to oursession persistence file, if any.",
	"Method": "File file(String id){\r\n    if (this.directory == null) {\r\n        return (null);\r\n    }\r\n    String filename = id + FILE_EXT;\r\n    File file = new File(directory(), filename);\r\n    return (file);\r\n}"
}, {
	"Path": "org.glassfish.common.util.admin.AuthTokenManager.createToken",
	"Comment": "creates a new limited use authentication token with the specifiedlifetime but no subject.",
	"Method": "String createToken(Subject subject,long lifetime,String createToken,String createToken,Subject subject,String createToken,long lifetime){\r\n    return createToken(new Subject(), lifetime);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RegisteredStatics.distributeStart",
	"Comment": "informs all registered objects an association has started.the control object which represents the transaction is given.a flag is passed indicating whether this associationis as a result of a current.begin operation.",
	"Method": "void distributeStart(ControlImpl control,boolean begin){\r\n    org.omg.CosTransactions.Coordinator coord = null;\r\n    try {\r\n        coord = control.get_coordinator();\r\n    } catch (Unavailable exc) {\r\n    }\r\n    if (coord != null) {\r\n        for (int i = 0; i < registered.size(); i++) {\r\n            StaticResource resource = (StaticResource) registered.elementAt(i);\r\n            try {\r\n                resource.startAssociation(coord, begin);\r\n            } catch (INVALID_TRANSACTION exc) {\r\n                for (int j = i - 1; j >= 0; j--) {\r\n                    ((StaticResource) registered.elementAt(j)).endAssociation(coord, begin);\r\n                }\r\n                throw (INVALID_TRANSACTION) exc.fillInStackTrace();\r\n            } catch (Throwable exc) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getServletRegistration",
	"Comment": "gets the servletregistration corresponding to the servlet with thegiven servletname.",
	"Method": "ServletRegistration getServletRegistration(String servletName){\r\n    return servletRegisMap.get(servletName);\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.getNoteNames",
	"Comment": "return an iterator containing the string names of all notes bindingsthat exist for this session.",
	"Method": "Iterator<String> getNoteNames(){\r\n    return (notes.keySet().iterator());\r\n}"
}, {
	"Path": "org.glassfish.api.logging.LogHelper.getFormattedMessage",
	"Comment": "gets the formatted message given the message key and parameters.the resourcebundle associated with the logger is searched for the specified key.",
	"Method": "String getFormattedMessage(Logger logger,String msgKey,Object params){\r\n    ResourceBundle rb = logger.getResourceBundle();\r\n    if (rb != null) {\r\n        try {\r\n            return MessageFormat.format(rb.getString(msgKey), params);\r\n        } catch (java.util.MissingResourceException e) {\r\n            return msgKey;\r\n        }\r\n    }\r\n    return msgKey;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.ServerDirsSelector.getInstance",
	"Comment": "creates a selector for choosing the correct set of directories.",
	"Method": "ServerDirsSelector getInstance(File domainDirParent,String serverName,String nodeDir,String node){\r\n    final ServerDirsSelector helper = new ServerDirsSelector(domainDirParent, serverName, nodeDir, node);\r\n    helper.validateDomainOrInstance();\r\n    return helper;\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.DeploymentUtils.checksum",
	"Comment": "computes the checksum of the uris of files contained in a directory.",
	"Method": "long checksum(File directory){\r\n    if (!directory.isDirectory()) {\r\n        final String msg = localStrings.getLocalString(\"enterprise.deployment.remoteDirPathUnusable\", \"The directory deployment path {0} is not a directory or is inaccessible\", directory.getAbsolutePath());\r\n        throw new IllegalArgumentException(msg);\r\n    }\r\n    final List<URI> uris = new ArrayList<URI>();\r\n    scanDirectory(directory.toURI(), directory, uris);\r\n    Collections.sort(uris);\r\n    final Adler32 checksum = new Adler32();\r\n    for (URI uri : uris) {\r\n        checksum.update(uri.toASCIIString().getBytes());\r\n    }\r\n    return checksum.getValue();\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.getParser",
	"Comment": "return the saxparser we will use to parse the input stream.if thereis a problem creating the parser, return null.",
	"Method": "SAXParser getParser(){\r\n    if (parser != null) {\r\n        return (parser);\r\n    }\r\n    try {\r\n        if (validating) {\r\n            Properties properties = new Properties();\r\n            properties.put(\"SAXParserFactory\", getFactory());\r\n            if (schemaLocation != null) {\r\n                properties.put(\"schemaLocation\", schemaLocation);\r\n                properties.put(\"schemaLanguage\", schemaLanguage);\r\n            }\r\n            parser = ParserFeatureSetterFactory.newSAXParser(properties);\r\n        } else {\r\n            parser = getFactory().newSAXParser();\r\n        }\r\n    } catch (Exception e) {\r\n        log.log(Level.SEVERE, LogFacade.GET_PARRSER_EXCEPTION, e);\r\n        return (null);\r\n    }\r\n    return (parser);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.deploy.shared.MemoryMappedArchive.exists",
	"Comment": "returns the existence of the given entry namethe file name must be relative to the root of the module.",
	"Method": "boolean exists(boolean exists,String name){\r\n    return (getEntry(name) != null);\r\n}"
}, {
	"Path": "org.apache.naming.resources.FileDirContext.getAttributes",
	"Comment": "retrieves selected attributes associated with a named object. see the class description regarding attribute models, attribute type names, and operational attributes.",
	"Method": "Attributes getAttributes(String name,String[] attrIds){\r\n    File file = file(name);\r\n    if (file == null)\r\n        throw new NamingException(MessageFormat.format(rb.getString(LogFacade.RESOURCES_NOT_FOUND), name));\r\n    return new FileResourceAttributes(file);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.generateSessionId",
	"Comment": "this object does not implement a session id generator. providea dummy implementation so that the default one will be used.",
	"Method": "String generateSessionId(){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.addFilter",
	"Comment": "adds the filter with the given name and class type to this servletcontext.",
	"Method": "FilterRegistration.Dynamic addFilter(String filterName,String className,FilterRegistration.Dynamic addFilter,String filterName,Filter filter,FilterRegistration.Dynamic addFilter,String filterName,Class<? extends Filter> filterClass){\r\n    if (SecurityUtil.isPackageProtectionEnabled()) {\r\n        return (FilterRegistration.Dynamic) doPrivileged(\"addFilter\", new Class[] { String.class, Class.class }, new Object[] { filterName, filterClass });\r\n    } else {\r\n        return context.addFilter(filterName, filterClass);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.util.HexUtils.convert2Int",
	"Comment": "convert 4 hex digits to an int, and return the number of convertedbytes.",
	"Method": "int convert2Int(byte[] hex){\r\n    int len;\r\n    if (hex.length < 4)\r\n        return 0;\r\n    if (DEC[hex[0]] < 0)\r\n        throw new IllegalArgumentException(rb.getString(LogFacade.BAD_HEX_DIGIT_EXCEPTION));\r\n    len = DEC[hex[0]];\r\n    len = len << 4;\r\n    if (DEC[hex[1]] < 0)\r\n        throw new IllegalArgumentException(rb.getString(LogFacade.BAD_HEX_DIGIT_EXCEPTION));\r\n    len += DEC[hex[1]];\r\n    len = len << 4;\r\n    if (DEC[hex[2]] < 0)\r\n        throw new IllegalArgumentException(rb.getString(LogFacade.BAD_HEX_DIGIT_EXCEPTION));\r\n    len += DEC[hex[2]];\r\n    len = len << 4;\r\n    if (DEC[hex[3]] < 0)\r\n        throw new IllegalArgumentException(rb.getString(LogFacade.BAD_HEX_DIGIT_EXCEPTION));\r\n    len += DEC[hex[3]];\r\n    return len;\r\n}"
}, {
	"Path": "org.glassfish.contextpropagation.bootstrap.ContextAccessController.checkAccessAllowed",
	"Comment": "checks if access is allowed and throws an insufficientcredentialexceptionif access is not allowed.",
	"Method": "void checkAccessAllowed(String key,AccessControlledMap.ContextAccessLevel type){\r\n    if (!isAccessAllowed(key, type)) {\r\n        throw new InsufficientCredentialException();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.moveVectorItem",
	"Comment": "moves the given object to a new relative location in the specified list",
	"Method": "void moveVectorItem(Vector list,Object ref,int rpos){\r\n    int size = list.size(), old_pos = size - 1;\r\n    for (; old_pos >= 0; old_pos--) {\r\n        if (ref == list.elementAt(old_pos)) {\r\n            break;\r\n        }\r\n    }\r\n    if (old_pos < 0) {\r\n        return;\r\n    }\r\n    int new_pos = old_pos + rpos;\r\n    if (new_pos < 0) {\r\n        new_pos = 0;\r\n    } else if (new_pos >= size) {\r\n        new_pos = size - 1;\r\n    }\r\n    if (new_pos == old_pos) {\r\n        return;\r\n    }\r\n    list.removeElementAt(old_pos);\r\n    list.insertElementAt(ref, new_pos);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.homeintf.remotehomeintf.RemoteHomeInterfaceRmiIIOPArgs.runIndividualHomeMethodTest",
	"Comment": "run an individual verifier test against a declared method of the local interface.",
	"Method": "void runIndividualHomeMethodTest(Method method,EjbDescriptor descriptor,Result result){\r\n    Class[] methodParameterTypes = method.getParameterTypes();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (RmiIIOPUtils.isValidRmiIIOPParameters(methodParameterTypes)) {\r\n        addGoodDetails(result, compName);\r\n        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"[ {0} ] properly declares method with valid RMI-IIOP parameter.\", new Object[] { method.getDeclaringClass().getName() }));\r\n    } else {\r\n        addErrorDetails(result, compName);\r\n        result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: [ {0} ] method was found, but does not have valid RMI-IIOP \" + \"method parameters.\", new Object[] { method.getName() }));\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.hash_transaction",
	"Comment": "removed synchronization at method level since only transtate requires\tlocking",
	"Method": "int hash_transaction(){\r\n    int result = hash;\r\n    if (tranState == null) {\r\n        INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.Completed, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.XercesParser.configureXerces",
	"Comment": "configure schema validation as recommended by the xerces spec. both dtd and schema validation will be enabled simultaneously.",
	"Method": "void configureXerces(SAXParserFactory factory){\r\n    factory.setFeature(XERCES_DYNAMIC, true);\r\n    factory.setFeature(XERCES_SCHEMA, true);\r\n}"
}, {
	"Path": "testmbeans.ImplementsMBeanRegistrationDynamicSupport.setAttributes",
	"Comment": "sets the values of several attributes of the dynamic mbeanand returns the list of attributes that have been set.",
	"Method": "AttributeList setAttributes(AttributeList attributes){\r\n    AttributeList resultList = new AttributeList();\r\n    for (Iterator i = attributes.iterator(); i.hasNext(); ) {\r\n        Attribute attr = (Attribute) i.next();\r\n        try {\r\n            setAttribute(attr);\r\n            String name = attr.getName();\r\n            Object value = getAttribute(name);\r\n            resultList.add(new Attribute(name, value));\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return resultList;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.Initializer.setReportingLevel",
	"Comment": "set the reporting level of verifier based on the option used whileinvoking verifier.",
	"Method": "void setReportingLevel(char c){\r\n    boolean setWarningLevelOnce = false;\r\n    switch(c) {\r\n        case 'w':\r\n            if (!setWarningLevelOnce) {\r\n                logger.log(Level.FINE, getClass().getName() + \".debug.displayWarningFailures\");\r\n                verifierFrameworkContext.setReportLevel(VerifierConstants.WARN);\r\n                setWarningLevelOnce = true;\r\n            } else {\r\n                // NOI18N\r\n                logger.log(Level.FINE, getClass().getName() + \".debug.reportLevel\", new Object[] { getReportLevelString(verifierFrameworkContext.getReportLevel()) });\r\n            }\r\n            break;\r\n        case 'f':\r\n            if (!setWarningLevelOnce) {\r\n                // NOI18N\r\n                logger.log(Level.FINE, getClass().getName() + \".debug.displayFailures\");\r\n                verifierFrameworkContext.setReportLevel(VerifierConstants.FAIL);\r\n                setWarningLevelOnce = true;\r\n            } else {\r\n                // NOI18N\r\n                logger.log(Level.FINE, getClass().getName() + \".debug.reportLevel\", new Object[] { getReportLevelString(verifierFrameworkContext.getReportLevel()) });\r\n            }\r\n            break;\r\n        case 'a':\r\n            if (!setWarningLevelOnce) {\r\n                // NOI18N\r\n                logger.log(Level.FINE, getClass().getName() + \".debug.displayAll\");\r\n                verifierFrameworkContext.setReportLevel(VerifierConstants.ALL);\r\n                setWarningLevelOnce = true;\r\n            } else {\r\n                // NOI18N\r\n                logger.log(Level.FINE, getClass().getName() + \".debug.reportLevel\", new Object[] { getReportLevelString(verifierFrameworkContext.getReportLevel()) });\r\n            }\r\n            break;\r\n        default:\r\n            // NOI18N\r\n            logger.log(Level.SEVERE, getClass().getName() + \".invalidreplevel\", new Object[] { \"verifier\", new Character(c).toString() });\r\n            usage();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.addServlet",
	"Comment": "adds the servlet with the given name and class type to thisservlet context.",
	"Method": "ServletRegistration.Dynamic addServlet(String servletName,String className,ServletRegistration.Dynamic addServlet,String servletName,Servlet servlet,ServletRegistration.Dynamic addServlet,String servletName,Class<? extends Servlet> servletClass){\r\n    if (isRestricted) {\r\n        throw new UnsupportedOperationException(rb.getString(LogFacade.UNSUPPORTED_OPERATION_EXCEPTION));\r\n    }\r\n    return context.addServlet(servletName, servletClass);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.StartLocalInstanceCommand.createLauncher",
	"Comment": "create a launcher for the instance specified by arguments tothis command.the launcher is for a server of the specified type.sets the launcher and info fields.",
	"Method": "void createLauncher(){\r\n    setLauncher(GFLauncherFactory.getInstance(getType()));\r\n    setInfo(getLauncher().getInfo());\r\n    getInfo().setInstanceName(instanceName);\r\n    getInfo().setInstanceRootDir(instanceDir);\r\n    getInfo().setVerbose(verbose);\r\n    getInfo().setWatchdog(watchdog);\r\n    getInfo().setDebug(debug);\r\n    getInfo().setRespawnInfo(programOpts.getClassName(), programOpts.getClassPath(), respawnArgs());\r\n    getLauncher().setup();\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.setIsAsyncSupported",
	"Comment": "marks the wrapped servlet as supporting async operations or not.",
	"Method": "void setIsAsyncSupported(boolean isAsyncSupported){\r\n    this.isAsyncSupported = isAsyncSupported;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.ServerRemoteAdminCommand.addAdditionalHeaders",
	"Comment": "adds the admin indicator header to the request so. do this whether secure admin is enabled or not, because the indicator is unique amongdomains to help make sure only processes in the same domain talk to each other.",
	"Method": "void addAdditionalHeaders(URLConnection urlConnection){\r\n    final String indicatorValue = SecureAdmin.Util.configuredAdminIndicator(secureAdmin);\r\n    if (indicatorValue != null) {\r\n        urlConnection.setRequestProperty(SecureAdmin.Util.ADMIN_INDICATOR_HEADER_NAME, indicatorValue);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.contextpropagation.bootstrap.ContextBootstrap.configure",
	"Comment": "this function must be called by the server prior to using context propagation.",
	"Method": "void configure(LoggerAdapter aLoggerAdapter,WireAdapter aWireAdapter,ThreadLocalAccessor aThreadLocalAccessor,ContextAccessController aContextAccessController,String aGuid){\r\n    if (isConfigured) {\r\n        throw new IllegalStateException(\"WorkArea is already configured\");\r\n    }\r\n    if (aLoggerAdapter == null || aWireAdapter == null || aThreadLocalAccessor == null || aContextAccessController == null) {\r\n        throw new IllegalArgumentException(\"logger and wire adapters, threadLocalAccessor and \" + \"contextAccessController must be specified.\");\r\n    }\r\n    loggerAdapter = aLoggerAdapter;\r\n    wireAdapter = aWireAdapter;\r\n    threadLocalAccessor = aThreadLocalAccessor;\r\n    contextAccessController = aContextAccessController;\r\n    guid = aGuid;\r\n    IS_DEBUG = loggerAdapter.isLoggable(Level.DEBUG);\r\n    isConfigured = true;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.session.stateless.StatelessEjbCreateHome.check",
	"Comment": "stateless session enterprise beans class single create method test.the session enterprise bean class must define a single ejbcreate method that takes no arguments.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (descriptor instanceof EjbSessionDescriptor) {\r\n        String stateType = ((EjbSessionDescriptor) descriptor).getSessionType();\r\n        if (EjbSessionDescriptor.STATELESS.equals(stateType)) {\r\n            try {\r\n                VerifierTestContext context = getVerifierContext();\r\n                ClassLoader jcl = context.getClassLoader();\r\n                Class c = Class.forName(descriptor.getEjbClassName(), false, getVerifierContext().getClassLoader());\r\n                Method m = null;\r\n                int foundThisManyTimes = 0;\r\n                do {\r\n                    Method[] methods = c.getDeclaredMethods();\r\n                    for (int i = 0; i < methods.length; i++) {\r\n                        if (!methods[i].getName().equals(\"ejbCreate\")) {\r\n                            continue;\r\n                        }\r\n                        if (foundThisManyTimes == 0) {\r\n                            m = methods[i];\r\n                            foundThisManyTimes++;\r\n                        } else {\r\n                            foundThisManyTimes++;\r\n                        }\r\n                    }\r\n                } while (((c = c.getSuperclass()) != null) && (m == null));\r\n                if ((m != null) && (foundThisManyTimes == 1)) {\r\n                    Class[] cc = m.getParameterTypes();\r\n                    if (cc.length > 0) {\r\n                        result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: The ejbCreate method has one or more parameters \\n\" + \"within bean [ {0} ].  Stateless session are only allowed \\n\" + \"to have ejbCreate methods with no arguments.\", new Object[] { descriptor.getEjbClassName() }));\r\n                    } else {\r\n                        result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"Valid: This bean's [ {0} ] ejbCreate method has no parameters.\" + \"\\n Stateless session beans can only have a ejbCreate method\" + \"\\n with no parameters.\", new Object[] { descriptor.getEjbClassName() }));\r\n                    }\r\n                } else if ((m != null) && (foundThisManyTimes > 1)) {\r\n                    result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                    result.failed(smh.getLocalString(getClass().getName() + \".failed2\", \"Error: [ {0} ] ejbCreate methods exists within bean [ {1} ].  The EJB class must have only one ejbCreate method for stateless session bean. \", new Object[] { new Integer(foundThisManyTimes), descriptor.getEjbClassName() }));\r\n                } else {\r\n                    result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                    result.failed(smh.getLocalString(getClass().getName() + \".failed3\", \"Error: No ejbCreate method exists within bean [ {0} ]\", new Object[] { descriptor.getEjbClassName() }));\r\n                }\r\n            } catch (ClassNotFoundException e) {\r\n                Verifier.debug(e);\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.failed(smh.getLocalString(getClass().getName() + \".failedException\", \"Error: Class [ {0} ] not found within bean [ {1} ]\", new Object[] { descriptor.getEjbClassName(), descriptor.getName() }));\r\n            }\r\n            return result;\r\n        } else if (EjbSessionDescriptor.STATEFUL.equals(stateType)) {\r\n            result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable1\", \"{0} expected {1} Session bean, but called with {2} Session bean.\", new Object[] { getClass(), EjbSessionDescriptor.STATELESS, stateType }));\r\n            return result;\r\n        } else {\r\n            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.failed(smh.getLocalString(getClass().getName() + \".failed4\", \"Error: [ {0} ] is not valid stateType within bean [ {1} ].\", new Object[] { stateType, descriptor.getName() }));\r\n            return result;\r\n        }\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"[ {0} ] expected {1} bean, but called with {2} bean.\", new Object[] { getClass(), \"Session\", \"Entity\" }));\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.startup.HostConfig.setXmlNamespaceAware",
	"Comment": "set the namespace aware feature of the xml parser used whenparsing xml instances.",
	"Method": "void setXmlNamespaceAware(boolean xmlNamespaceAware){\r\n    this.xmlNamespaceAware = xmlNamespaceAware;\r\n}"
}, {
	"Path": "components.renderkit.MenuBarRenderer.getSubmitScript",
	"Comment": "returns a string that is rendered as the value ofonmousedown attribute. onmousedown event handler is used the track the node that was clicked using a hidden field, then submits the form so that we have the state information to reconstitute the tree.",
	"Method": "String getSubmitScript(String path,FacesContext context){\r\n    UIForm uiform = getMyForm();\r\n    String formClientId = uiform.getClientId(context);\r\n    StringBuffer sb = new StringBuffer();\r\n    sb.append(\"#\\\" onclick=\\\"document.forms['\" + formClientId + \"']['\" + clientId + \"'].value='\" + path + \"';document.forms['\" + formClientId + \"'].submit()\\\"\");\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.apache.catalina.security.SecurityUtil.executeUnderSubjectDoAs",
	"Comment": "return true if a securitymanager is used and is isdoasrequired is required.",
	"Method": "boolean executeUnderSubjectDoAs(){\r\n    if (executeUnderSubjectDoAs && Globals.IS_SECURITY_ENABLED) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.naming.resources.ProxyDirContext.removeFromEnvironment",
	"Comment": "removes an environment property from the environment of this context.",
	"Method": "Object removeFromEnvironment(String propName){\r\n    return dirContext.removeFromEnvironment(propName);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardPipeline.start",
	"Comment": "prepare for active use of the public methods of this component.",
	"Method": "void start(){\r\n    if (started)\r\n        throw new LifecycleException(rb.getString(LogFacade.PIPLINE_STARTED));\r\n    lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null);\r\n    started = true;\r\n    for (int i = 0; i < valves.length; i++) {\r\n        if (valves[i] instanceof Lifecycle)\r\n            ((Lifecycle) valves[i]).start();\r\n    }\r\n    if ((basic != null) && (basic instanceof Lifecycle))\r\n        ((Lifecycle) basic).start();\r\n    lifecycle.fireLifecycleEvent(START_EVENT, null);\r\n    lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.ProgramOptions.toEnvironment",
	"Comment": "copy the program options that were specified on thecommand line into the corresponding environment variables.",
	"Method": "void toEnvironment(Environment env){\r\n    putEnv(env, ECHO);\r\n    putEnv(env, TERSE);\r\n    putEnv(env, INTERACTIVE);\r\n    putEnv(env, HOST);\r\n    putEnv(env, PORT);\r\n    putEnv(env, SECURE);\r\n    putEnv(env, USER);\r\n    putEnv(env, PASSWORDFILE);\r\n    putEnv(env, AUTHTOKEN);\r\n    putEnv(env, AUXINPUT);\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.HAStoreBase.getClusterIdFromConfig",
	"Comment": "return the cluster id for this store as defined in server.xml.",
	"Method": "String getClusterIdFromConfig(){\r\n    return null;\r\n}"
}, {
	"Path": "components.taglib.GraphMenuBarTag.setSelectedClass",
	"Comment": "the css style class to be applied to the textof selected nodes. this can be value or a value binding referenceexpression.",
	"Method": "void setSelectedClass(String styleSelected){\r\n    this.selectedClass = styleSelected;\r\n}"
}, {
	"Path": "org.glassfish.common.util.timer.TimerSchedule.parseNumbersOrNames",
	"Comment": "populate the bitset where true bits represent set values.input data can be either a number or a case insensitive abbreviated name.",
	"Method": "void parseNumbersOrNames(String s,BitSet bits,int start,int size,boolean incrementAllowed,String field){\r\n    if (s.equals(\"*\")) {\r\n        if (!isDayOfWeek(field)) {\r\n            bits.set(0, size);\r\n        } else {\r\n            for (int i = start; i <= size; i++) {\r\n                bits.set(conversionTable.get(i));\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    if (s.indexOf(',') > 0) {\r\n        String[] arr = splitList(s);\r\n        for (String s0 : arr) {\r\n            if (s0.indexOf(rangeChar, 1) > 0) {\r\n                processRange(s0, bits, start, size, field);\r\n            } else {\r\n                bits.set(getNumericValue(s0, start, size, field));\r\n            }\r\n        }\r\n        return;\r\n    }\r\n    if (s.indexOf(rangeChar) > 0) {\r\n        processRange(s, bits, start, size, field);\r\n        return;\r\n    }\r\n    if (incrementAllowed && s.indexOf(incrementChar) > 0) {\r\n        String[] arr = splitBy(s, incrementChar);\r\n        int begin = 0;\r\n        if (!arr[0].equals(\"*\")) {\r\n            begin = getNumericValue(arr[0], start, size, field);\r\n        }\r\n        int incr = getNumericValue(arr[1], start, size, field);\r\n        for (int i = begin; i < size; ) {\r\n            bits.set(i);\r\n            i = i + incr;\r\n        }\r\n        return;\r\n    }\r\n    bits.set(getNumericValue(s, start, size, field));\r\n}"
}, {
	"Path": "org.apache.catalina.util.RequestUtil.putMapEntry",
	"Comment": "put name value pair in map.put name and value pair in map.when name already exist, add valueto array of values.",
	"Method": "void putMapEntry(Map<String, String[]> map,String name,String value){\r\n    String[] newValues = null;\r\n    String[] oldValues = map.get(name);\r\n    if (oldValues == null) {\r\n        newValues = new String[1];\r\n        newValues[0] = value;\r\n    } else {\r\n        newValues = new String[oldValues.length + 1];\r\n        System.arraycopy(oldValues, 0, newValues, 0, oldValues.length);\r\n        newValues[oldValues.length] = value;\r\n    }\r\n    map.put(name, newValues);\r\n}"
}, {
	"Path": "org.glassfish.admin.mbeanserver.RMIConnectorStarter.startRegistry",
	"Comment": "starts the rmi registry , where the rmiserver would be exported. if thisis a multihomed machine then the registry is bound to a specific ip addresselse its bound to a port alone.",
	"Method": "Registry startRegistry(String addr,int port){\r\n    Registry registry = null;\r\n    if (mBindToSingleIP) {\r\n        final String saved = setupRMIHostname(addr);\r\n        try {\r\n            JMX_LOGGER.log(Level.INFO, BINDING_TO_SINGLE_ADDR, new Object[] { System.getProperty(RMI_HOSTNAME_PROP), port });\r\n            registry = _startRegistry(port);\r\n        } finally {\r\n            restoreRMIHostname(saved, addr);\r\n        }\r\n    } else {\r\n        Util.getLogger().log(Level.FINE, \"Binding RMI port to *:{0}\", port);\r\n        registry = _startRegistry(port);\r\n    }\r\n    return registry;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.setErrorReportValveClass",
	"Comment": "set the java class name of the error report valve classfor new web applications.",
	"Method": "void setErrorReportValveClass(String errorReportValveClass){\r\n    String oldErrorReportValveClassClass = this.errorReportValveClass;\r\n    this.errorReportValveClass = errorReportValveClass;\r\n    support.firePropertyChange(\"errorReportValveClass\", oldErrorReportValveClassClass, this.errorReportValveClass);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.remote.RemoteCLICommand.executeAndReturnActionReport",
	"Comment": "execute the command and return the main attributes from the manifestinstead of writing out the output.",
	"Method": "ActionReport executeAndReturnActionReport(String args){\r\n    returnActionReport = true;\r\n    execute(args);\r\n    returnActionReport = false;\r\n    return ar;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.CommandThreadPool.postConstruct",
	"Comment": "process the instance file if this is das and there are instances configured already in this domain",
	"Method": "void postConstruct(){\r\n    if (serverEnv.isInstance()) {\r\n        return;\r\n    }\r\n    int poolSize = 5;\r\n    Config svrConfig = domain.getConfigNamed(\"server-config\");\r\n    if (svrConfig != null) {\r\n        NetworkConfig nwc = svrConfig.getNetworkConfig();\r\n        if (nwc != null) {\r\n            List<NetworkListener> lss = nwc.getNetworkListeners().getNetworkListener();\r\n            if ((lss != null) && (!lss.isEmpty())) {\r\n                for (NetworkListener ls : lss) {\r\n                    if (ServerTags.ADMIN_LISTENER_ID.equals(ls.getName())) {\r\n                        if (ls.findThreadPool() != null) {\r\n                            poolSize = Integer.parseInt(ls.findThreadPool().getMaxThreadPoolSize());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    svc = Executors.newFixedThreadPool(poolSize, new InstanceStateThreadFactory());\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.node.WebCommonNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object newDescriptor){\r\n    Logger logger = DOLUtils.getDefaultLogger();\r\n    if (newDescriptor instanceof EjbReference) {\r\n        descriptor.addEjbReferenceDescriptor((EjbReference) newDescriptor);\r\n    } else if (newDescriptor instanceof EnvironmentProperty) {\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.fine(\"Adding env entry\" + newDescriptor);\r\n        }\r\n        descriptor.addEnvironmentProperty((EnvironmentProperty) newDescriptor);\r\n    } else if (newDescriptor instanceof WebComponentDescriptor) {\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.fine(\"Adding web component\" + newDescriptor);\r\n        }\r\n        descriptor.addWebComponentDescriptor((WebComponentDescriptor) newDescriptor);\r\n    } else if (newDescriptor instanceof TagLibConfigurationDescriptor) {\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.fine(\"Adding taglib component \" + newDescriptor);\r\n        }\r\n        if (descriptor.getJspConfigDescriptor() == null) {\r\n            descriptor.setJspConfigDescriptor(new JspConfigDescriptorImpl());\r\n        }\r\n        descriptor.getJspConfigDescriptor().addTagLib((TagLibConfigurationDescriptor) newDescriptor);\r\n    } else if (newDescriptor instanceof JspConfigDescriptorImpl) {\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.fine(\"Adding JSP Config Descriptor\" + newDescriptor);\r\n        }\r\n        if (descriptor.getJspConfigDescriptor() != null) {\r\n            throw new RuntimeException(\"Has more than one jsp-config element!\");\r\n        }\r\n        descriptor.setJspConfigDescriptor((JspConfigDescriptorImpl) newDescriptor);\r\n    } else if (newDescriptor instanceof LoginConfiguration) {\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.fine(\"Adding Login Config Descriptor\" + newDescriptor);\r\n        }\r\n        if (descriptor.getLoginConfiguration() != null) {\r\n            throw new RuntimeException(\"Has more than one login-config element!\");\r\n        }\r\n        descriptor.setLoginConfiguration((LoginConfiguration) newDescriptor);\r\n    } else if (newDescriptor instanceof SessionConfig) {\r\n        if (descriptor.getSessionConfig() != null) {\r\n            throw new RuntimeException(\"Has more than one session-config element!\");\r\n        }\r\n        descriptor.setSessionConfig((SessionConfig) newDescriptor);\r\n    } else {\r\n        super.addDescriptor(newDescriptor);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RecoveryManager.shutdown",
	"Comment": "informs the recoverymanager that the transaction service is being shutdown.for immediate shutdown,for quiesce,",
	"Method": "void shutdown(boolean immediate){\r\n    if (resyncInProgress != null) {\r\n        try {\r\n            resyncInProgress.waitEvent();\r\n            if (resyncThread != null) {\r\n                resyncThread.join();\r\n            }\r\n        } catch (InterruptedException exc) {\r\n        }\r\n    }\r\n    if (!immediate && Configuration.isRecoverable()) {\r\n        CoordinatorLog.keypoint();\r\n        CoordinatorLog.finalizeAll();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.apiscan.packaging.Archive.getAllOptPkgsInstalledInJRE",
	"Comment": "even if new pkg is installed in jvm lib ext dir. this is in line with jvm operations.",
	"Method": "Archive[] getAllOptPkgsInstalledInJRE(){\r\n    if (allOptPkgsInstalledInJRE != null)\r\n        return allOptPkgsInstalledInJRE;\r\n    synchronized (Archive.class) {\r\n        if (allOptPkgsInstalledInJRE == null) {\r\n            final ArrayList<Archive> allPkgs = new ArrayList<Archive>();\r\n            List ext_dirs = listAllExtDirs();\r\n            for (Iterator iter = ext_dirs.iterator(); iter.hasNext(); ) {\r\n                File ext_dir = new File((String) iter.next());\r\n                ext_dir.listFiles(new FileFilter() {\r\n                    public boolean accept(File f) {\r\n                        if (!f.isDirectory()) {\r\n                            try (JarFile jf = new JarFile(f)) {\r\n                                allPkgs.add(new Archive(jf));\r\n                                // NOI18N\r\n                                logger.logp(// NOI18N\r\n                                Level.FINE, myClassName, \"getAllOptPkgsInstalledInJRE\", \"Found an installed opt pkg \" + f.getAbsolutePath());\r\n                                return true;\r\n                            } catch (Exception e) {\r\n                                logger.logp(Level.INFO, myClassName, \"getAllOptPkgsInstalledInJRE\", thisClassName + \".exception1\", new Object[] { f.toString() });\r\n                                logger.log(Level.INFO, \"\", e);\r\n                            }\r\n                        }\r\n                        return false;\r\n                    }\r\n                });\r\n            }\r\n            final Archive[] tmp = new Archive[allPkgs.size()];\r\n            allPkgs.toArray(tmp);\r\n            allOptPkgsInstalledInJRE = tmp;\r\n        }\r\n    }\r\n    return allOptPkgsInstalledInJRE;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.apiscan.packaging.Archive.getAllOptPkgsInstalledInJRE",
	"Comment": "even if new pkg is installed in jvm lib ext dir. this is in line with jvm operations.",
	"Method": "Archive[] getAllOptPkgsInstalledInJRE(){\r\n    if (!f.isDirectory()) {\r\n        try (JarFile jf = new JarFile(f)) {\r\n            allPkgs.add(new Archive(jf));\r\n            // NOI18N\r\n            logger.logp(// NOI18N\r\n            Level.FINE, myClassName, \"getAllOptPkgsInstalledInJRE\", \"Found an installed opt pkg \" + f.getAbsolutePath());\r\n            return true;\r\n        } catch (Exception e) {\r\n            logger.logp(Level.INFO, myClassName, \"getAllOptPkgsInstalledInJRE\", thisClassName + \".exception1\", new Object[] { f.toString() });\r\n            logger.log(Level.INFO, \"\", e);\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionImpl.enlistResource",
	"Comment": "enlist a resource with the current transactionif a transaction is marked as rollback, enlistment willsucceed if the resource has been enlisted before. otherwise,enlistment will fail. in both cases, a rollbackexception willbe thrown.",
	"Method": "boolean enlistResource(XAResource res){\r\n    int status = getStatus();\r\n    if (status != javax.transaction.Status.STATUS_ACTIVE && status != javax.transaction.Status.STATUS_MARKED_ROLLBACK) {\r\n        throw new IllegalStateException();\r\n    }\r\n    try {\r\n        if (tm.getXAResourceTimeOut() > 0)\r\n            res.setTransactionTimeout(tm.getXAResourceTimeOut());\r\n    } catch (Exception ex) {\r\n        _logger.log(Level.WARNING, \"jts.error_while_setting_xares_txn_timeout\", ex);\r\n    }\r\n    try {\r\n        if (tranState == null) {\r\n            tranState = new TransactionState(gtid, this);\r\n        }\r\n        tranState.startAssociation(res, control, status);\r\n        if (status == javax.transaction.Status.STATUS_MARKED_ROLLBACK) {\r\n            throw new RollbackException();\r\n        }\r\n        return true;\r\n    } catch (XAException ex) {\r\n        _logger.log(Level.WARNING, \"jts.resource_outside_transaction\", ex);\r\n        if (ex.errorCode == XAException.XAER_OUTSIDE) {\r\n            throw new IllegalStateException();\r\n        }\r\n        throw new SystemException();\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.addRule",
	"Comment": "register a new rule matching the specified pattern.this method sets the digester property on the rule.",
	"Method": "void addRule(String pattern,Rule rule){\r\n    rule.setDigester(this);\r\n    getRules().add(pattern, rule);\r\n}"
}, {
	"Path": "org.apache.catalina.startup.HomesUserDatabase.getUsers",
	"Comment": "return an enumeration of the usernames defined on this server.",
	"Method": "Enumeration<String> getUsers(){\r\n    return (homes.keys());\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentTransaction.receivedReply",
	"Comment": "informs the currenttransaction that a reply has been received.",
	"Method": "void receivedReply(int id,PropagationContext context,org.omg.CORBA.Environment ex){\r\n    ControlImpl current = (ControlImpl) m_tid.get();\r\n    if (current == null) {\r\n        return;\r\n    }\r\n    java.lang.Exception ctxExc = ex.exception();\r\n    if (ctxExc instanceof SystemException) {\r\n        Coordinator currentCoord = null;\r\n        try {\r\n            if (Configuration.isLocalFactory()) {\r\n                currentCoord = current.get_localCoordinator();\r\n            } else {\r\n                currentCoord = current.get_coordinator();\r\n            }\r\n        } catch (Unavailable exc) {\r\n            _logger.log(Level.FINE, \"\", exc);\r\n        }\r\n        if (currentCoord == null) {\r\n            return;\r\n        }\r\n        try {\r\n            currentCoord.rollback_only();\r\n        } catch (Inactive exc) {\r\n            _logger.log(Level.FINE, \"\", exc);\r\n        }\r\n    }\r\n    if (context == null || context.current == null || context.current.coord == null || context.current.otid.formatID == -1) {\r\n        return;\r\n    }\r\n    StatusHolder outStatus = new StatusHolder();\r\n    outStatus.value = Status.StatusRolledBack;\r\n    GlobalTID globalTID = null;\r\n    try {\r\n        globalTID = new GlobalTID(current.getGlobalTID(outStatus));\r\n    } catch (Throwable exc) {\r\n        _logger.log(Level.FINE, \"\", exc);\r\n    }\r\n    if (globalTID != null) {\r\n        if (outStatus.value != Status.StatusActive) {\r\n            endCurrent(true);\r\n            current.destroy();\r\n            org.omg.CORBA.WrongTransaction exc = new org.omg.CORBA.WrongTransaction();\r\n            throw exc;\r\n        }\r\n        if (!globalTID.isSameTID(context.current.otid)) {\r\n            org.omg.CORBA.WrongTransaction exc = new org.omg.CORBA.WrongTransaction();\r\n            throw exc;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModule.configureMiscSettings",
	"Comment": "configure miscellaneous settings such as the pool size forsingle threaded servlets, specifying a temporary directory otherthan the default etc.since the work directory is used when configuring the session managerpersistence settings, this method must be invoked prior toconfiguresessionsettings.",
	"Method": "void configureMiscSettings(SunWebAppImpl bean,VirtualServer vs,String contextPath){\r\n    boolean allowLinking = vs.getAllowLinking();\r\n    if ((bean != null) && (bean.sizeWebProperty() > 0)) {\r\n        WebProperty[] props = bean.getWebProperty();\r\n        for (WebProperty prop : props) {\r\n            String name = prop.getAttributeValue(\"name\");\r\n            String value = prop.getAttributeValue(\"value\");\r\n            if (name == null || value == null) {\r\n                throw new IllegalArgumentException(rb.getString(LogFacade.NULL_WEB_MODULE_PROPERTY));\r\n            }\r\n            if (\"singleThreadedServletPoolSize\".equalsIgnoreCase(name)) {\r\n                int poolSize = getSTMPoolSize();\r\n                try {\r\n                    poolSize = Integer.parseInt(value);\r\n                } catch (NumberFormatException e) {\r\n                    String msg = rb.getString(LogFacade.INVALID_SERVLET_POOL_SIZE);\r\n                    msg = MessageFormat.format(msg, value, contextPath, Integer.toString(poolSize));\r\n                    logger.log(Level.WARNING, msg, e);\r\n                }\r\n                if (poolSize > 0) {\r\n                    setSTMPoolSize(poolSize);\r\n                }\r\n            } else if (\"tempdir\".equalsIgnoreCase(name)) {\r\n                setWorkDir(value);\r\n            } else if (\"crossContextAllowed\".equalsIgnoreCase(name)) {\r\n                boolean crossContext = Boolean.parseBoolean(value);\r\n                setCrossContext(crossContext);\r\n            } else if (\"allowLinking\".equalsIgnoreCase(name)) {\r\n                allowLinking = ConfigBeansUtilities.toBoolean(value);\r\n            } else if (\"reuseSessionID\".equalsIgnoreCase(name)) {\r\n                boolean reuse = ConfigBeansUtilities.toBoolean(value);\r\n                setReuseSessionID(reuse);\r\n                if (reuse) {\r\n                    String msg = rb.getString(LogFacade.SESSION_IDS_REUSED);\r\n                    msg = MessageFormat.format(msg, contextPath, vs.getID());\r\n                    logger.log(Level.WARNING, msg);\r\n                }\r\n            } else if (\"useResponseCTForHeaders\".equalsIgnoreCase(name)) {\r\n                if (\"true\".equalsIgnoreCase(value)) {\r\n                    setResponseCTForHeaders();\r\n                }\r\n            } else if (\"encodeCookies\".equalsIgnoreCase(name)) {\r\n                boolean flag = ConfigBeansUtilities.toBoolean(value);\r\n                setEncodeCookies(flag);\r\n            } else if (\"relativeRedirectAllowed\".equalsIgnoreCase(name)) {\r\n                boolean relativeRedirect = ConfigBeansUtilities.toBoolean(value);\r\n                setAllowRelativeRedirect(relativeRedirect);\r\n            } else if (\"fileEncoding\".equalsIgnoreCase(name)) {\r\n                setFileEncoding(value);\r\n            } else if (\"enableTldValidation\".equalsIgnoreCase(name) && ConfigBeansUtilities.toBoolean(value)) {\r\n                setTldValidation(true);\r\n            } else if (\"enableTldNamespaceAware\".equalsIgnoreCase(name) && ConfigBeansUtilities.toBoolean(value)) {\r\n                setTldNamespaceAware(true);\r\n            } else if (\"securePagesWithPragma\".equalsIgnoreCase(name)) {\r\n                boolean securePagesWithPragma = ConfigBeansUtilities.toBoolean(value);\r\n                setSecurePagesWithPragma(securePagesWithPragma);\r\n            } else if (\"useMyFaces\".equalsIgnoreCase(name)) {\r\n                setUseMyFaces(ConfigBeansUtilities.toBoolean(value));\r\n            } else if (\"useBundledJsf\".equalsIgnoreCase(name)) {\r\n                setUseMyFaces(ConfigBeansUtilities.toBoolean(value));\r\n            } else if (name.startsWith(\"alternatedocroot_\")) {\r\n                parseAlternateDocBase(name, value);\r\n            } else if (name.startsWith(\"valve_\") || name.startsWith(\"listener_\")) {\r\n            } else {\r\n                Object[] params = { name, value };\r\n                logger.log(Level.WARNING, LogFacade.INVALID_PROPERTY, params);\r\n            }\r\n        }\r\n    }\r\n    setAllowLinking(allowLinking);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.ServerSynchronizer.getFileNames",
	"Comment": "get the mod times for the entries in dir and add them to thesyncrequest, using names relative to basedir.if level isrecursive, check subdirectories and only include times for files,and empty directories.",
	"Method": "List<String> getFileNames(File dir,List<String> skip,SyncLevel level,int getFileNames,File dir,File baseDir,List<String> skip,List<String> names,SyncLevel level){\r\n    if (level == SyncLevel.TOP) {\r\n        String name = baseDir.toURI().relativize(dir.toURI()).getPath();\r\n        if (name.endsWith(\"/\"))\r\n            name = name.substring(0, name.length() - 1);\r\n        names.add(name);\r\n        return 1;\r\n    }\r\n    int cnt = 0;\r\n    for (String file : dir.list()) {\r\n        File f = new File(dir, file);\r\n        String name = baseDir.toURI().relativize(f.toURI()).getPath();\r\n        if (name.endsWith(\"/\"))\r\n            name = name.substring(0, name.length() - 1);\r\n        if (skip != null && skip.contains(name))\r\n            continue;\r\n        if (f.isDirectory() && level == SyncLevel.RECURSIVE) {\r\n            int subFileCnt = getFileNames(f, baseDir, skip, names, level);\r\n            if (subFileCnt == 0) {\r\n                names.add(name);\r\n                cnt++;\r\n            } else {\r\n                cnt += subFileCnt;\r\n            }\r\n        } else {\r\n            names.add(name);\r\n            cnt++;\r\n        }\r\n    }\r\n    return cnt;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.unparsedEntityDecl",
	"Comment": "receive notification of an unparsed entity declaration event.",
	"Method": "void unparsedEntityDecl(String name,String publicId,String systemId,String notation){\r\n    if (saxLog.isLoggable(Level.FINE)) {\r\n        saxLog.log(Level.FINE, \"unparsedEntityDecl(\" + name + \",\" + publicId + \",\" + systemId + \",\" + notation + \")\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.server.GFDomainXml.getDomDocument",
	"Comment": "returns the domdocument implementation used to create config beans and persistthe dom tree.",
	"Method": "DomDocument getDomDocument(){\r\n    return new GlassFishDocument(habitat, Executors.newCachedThreadPool(new ThreadFactory() {\r\n        public Thread newThread(Runnable r) {\r\n            Thread t = Executors.defaultThreadFactory().newThread(r);\r\n            t.setDaemon(true);\r\n            t.setContextClassLoader(habitat.<ServerContext>getService(ServerContext.class).getCommonClassLoader());\r\n            return t;\r\n        }\r\n    }));\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.server.GFDomainXml.getDomDocument",
	"Comment": "returns the domdocument implementation used to create config beans and persistthe dom tree.",
	"Method": "DomDocument getDomDocument(){\r\n    Thread t = Executors.defaultThreadFactory().newThread(r);\r\n    t.setDaemon(true);\r\n    t.setContextClassLoader(habitat.<ServerContext>getService(ServerContext.class).getCommonClassLoader());\r\n    return t;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.CommandSecurityChecker.getAccessChecks",
	"Comment": "returns all accesscheck objects which apply to the specified command.",
	"Method": "Collection<? extends AccessCheck> getAccessChecks(AdminCommand command,Subject subject){\r\n    final List<AccessCheckWork> work = assembleAccessCheckWork(command, subject);\r\n    final Collection<AccessCheck> accessChecks = new ArrayList<AccessCheck>();\r\n    for (AccessCheckWork w : work) {\r\n        accessChecks.add(w.accessCheck());\r\n    }\r\n    return accessChecks;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.AdminAdapter.setRegistered",
	"Comment": "marks this adapter as having been registered or unregistered as anetwork endpoint",
	"Method": "void setRegistered(boolean isRegistered){\r\n    this.isRegistered = isRegistered;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.create_subtransaction",
	"Comment": "creates a subtransaction and returns a control object that representsthe child transaction.",
	"Method": "Control create_subtransaction(){\r\n    Control result = null;\r\n    if (tranState == null || tranState.state != TransactionState.STATE_ACTIVE) {\r\n        Inactive exc = new Inactive();\r\n        throw exc;\r\n    }\r\n    CoordinatorImpl[] ancestors = new CoordinatorImpl[1];\r\n    ancestors[0] = this;\r\n    SubCoordinator child = null;\r\n    TerminatorImpl terminator = null;\r\n    try {\r\n        child = new SubCoordinator(superInfo.globalTID, superInfo.localTID, ancestors);\r\n        terminator = new TerminatorImpl(child, true);\r\n        result = new ControlImpl(terminator, child, new GlobalTID(child.getGlobalTID()), child.getLocalTID()).object();\r\n    } catch (Throwable exc) {\r\n        Inactive ex2 = new Inactive();\r\n        ex2.initCause(exc);\r\n        throw ex2;\r\n    }\r\n    if (nestingInfo == null) {\r\n        nestingInfo = new NestingInfo();\r\n    }\r\n    nestingInfo.addChild(child);\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.CompositeResource.getChildItemUri",
	"Comment": "every resource that returns a collection will need to return the uri for each item in the colleciton. this methodhandles the creation of that uri, ensuring a correct and consistent uri pattern.",
	"Method": "URI getChildItemUri(String name){\r\n    return getSubUri(\"id/\" + name);\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.SetUtil.copySet",
	"Comment": "create a new set containing all members of another.the returned set is always a hashset.",
	"Method": "HashSet<T> copySet(Set<? extends T> s1){\r\n    final HashSet<T> set = new HashSet<T>();\r\n    set.addAll(s1);\r\n    return (set);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.addMessageDestinationRef",
	"Comment": "add a message destination reference for this web application.",
	"Method": "void addMessageDestinationRef(MessageDestinationRef mdr){\r\n    namingResources.addMessageDestinationRef(mdr);\r\n    if (notifyContainerListeners) {\r\n        fireContainerEvent(\"addMessageDestinationRef\", mdr.getName());\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.loader.WebappLoader.addOverridablePackage",
	"Comment": "adds the given package name to the list of packages that may always beoverriden, regardless of whether they belong to a protected namespace",
	"Method": "void addOverridablePackage(String packageName){\r\n    if (overridablePackages == null) {\r\n        overridablePackages = new ArrayList<String>();\r\n    }\r\n    overridablePackages.add(packageName);\r\n}"
}, {
	"Path": "com.sun.enterprise.config.util.PortUtils.checkInternalConsistency",
	"Comment": "make sure all ports that are specified by the user make sense.",
	"Method": "void checkInternalConsistency(Server server){\r\n    List<SystemProperty> sysProps = server.getSystemProperty();\r\n    Set<Integer> ports = new TreeSet<Integer>();\r\n    for (SystemProperty sp : sysProps) {\r\n        String name = sp.getName();\r\n        if (PORTSLIST.contains(name)) {\r\n            String val = sp.getValue();\r\n            try {\r\n                boolean wasAdded = ports.add(Integer.parseInt(val));\r\n                if (!wasAdded)\r\n                    throw new TransactionFailure(Strings.get(\"PortUtils.duplicate_port\", val, server.getName()));\r\n            } catch (TransactionFailure tf) {\r\n                throw tf;\r\n            } catch (Exception e) {\r\n                throw new TransactionFailure(Strings.get(\"PortUtils.non_int_port\", val, server.getName()));\r\n            }\r\n        }\r\n    }\r\n    checkForLegalPorts(ports, server.getName());\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RegisteredSyncs.addSync",
	"Comment": "adds a reference to a synchronization object to the set.if there is no such set then a new one is created with the singlesynchronization reference.",
	"Method": "void addSync(Synchronization obj){\r\n    registered.addElement(obj);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.removeAlias",
	"Comment": "remove the specified alias name from the aliases for this host.",
	"Method": "void removeAlias(String alias){\r\n    int n = -1;\r\n    for (int i = 0; i < aliases.length; i++) {\r\n        if (aliases[i].equals(alias)) {\r\n            n = i;\r\n            break;\r\n        }\r\n    }\r\n    if (n < 0) {\r\n        return;\r\n    }\r\n    int j = 0;\r\n    String[] results = new String[aliases.length - 1];\r\n    for (int i = 0; i < aliases.length; i++) {\r\n        if (i != n) {\r\n            results[j++] = aliases[i];\r\n        }\r\n    }\r\n    aliases = results;\r\n    fireContainerEvent(REMOVE_ALIAS_EVENT, alias);\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.config.AMXConfigImpl.getAttributeFromConfigBean",
	"Comment": "get an attribute.this is a bit tricky, because the target can be an xml attribute,an xml string element, or an xml list of elements.",
	"Method": "Object getAttributeFromConfigBean(String amxName){\r\n    Object result = null;\r\n    final MBeanAttributeInfo attrInfo = getAttributeInfo(amxName);\r\n    if (attrInfo == null) {\r\n        ConfigBeanJMXSupport.DuckTypedInfo info = getConfigBeanJMXSupport().findDuckTyped(\"get\" + amxName, null);\r\n        if (info == null) {\r\n            info = getConfigBeanJMXSupport().findDuckTyped(\"is\" + amxName, null);\r\n        }\r\n        if (info != null) {\r\n            try {\r\n                result = invokeDuckMethod(info, null);\r\n                return result;\r\n            } catch (final Exception e) {\r\n                throw new RuntimeException(new MBeanException(e, amxName));\r\n            }\r\n        } else {\r\n        }\r\n        throw new RuntimeException(new AttributeNotFoundException(amxName));\r\n    }\r\n    final String xmlName = ConfigBeanJMXSupport.xmlName(attrInfo, amxName);\r\n    final boolean isAttribute = ConfigBeanJMXSupport.isAttribute(attrInfo);\r\n    if (isAttribute) {\r\n        result = mConfigBean.rawAttribute(xmlName);\r\n    } else if (ConfigBeanJMXSupport.isElement(attrInfo)) {\r\n        if (String.class.getName().equals(attrInfo.getType())) {\r\n            final List<?> leaf = mConfigBean.leafElements(xmlName);\r\n            if (leaf != null) {\r\n                try {\r\n                    result = (String) leaf.get(0);\r\n                } catch (final Exception e) {\r\n                }\r\n            }\r\n        } else if (attrInfo.getType().equals(String[].class.getName())) {\r\n            final List<?> leaf = mConfigBean.leafElements(xmlName);\r\n            if (leaf != null) {\r\n                final List<String> elems = TypeCast.checkList(leaf, String.class);\r\n                result = CollectionUtil.toArray(elems, String.class);\r\n            }\r\n        } else {\r\n            throw new IllegalArgumentException(\"getAttributeFromConfigBean: unsupported return type: \" + attrInfo.getType());\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.generator.ResourcesGeneratorBase.generateCommandResources",
	"Comment": "generate resources for commands mapped under given parentbeanname",
	"Method": "void generateCommandResources(String parentBeanName,ClassWriter parentWriter){\r\n    List<CommandResourceMetaData> commandMetaData = CommandResourceMetaData.getMetaData(parentBeanName);\r\n    if (commandMetaData.size() > 0) {\r\n        for (CommandResourceMetaData metaData : commandMetaData) {\r\n            if (ResourceUtil.commandIsPresent(habitat, metaData.command)) {\r\n                String commandResourceName = parentBeanName + getBeanName(metaData.resourcePath);\r\n                String commandResourceClassName = getClassName(commandResourceName);\r\n                generateCommandResourceClass(parentBeanName, metaData);\r\n                parentWriter.createGetCommandResource(commandResourceClassName, metaData.resourcePath);\r\n            }\r\n        }\r\n        parentWriter.createGetCommandResourcePaths(commandMetaData);\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.ResourceLinkRef.getFactoryClassName",
	"Comment": "retrieves the class name of the factory of the object to which this reference refers.",
	"Method": "String getFactoryClassName(){\r\n    String factory = super.getFactoryClassName();\r\n    if (factory != null) {\r\n        return factory;\r\n    } else {\r\n        factory = System.getProperty(Context.OBJECT_FACTORIES);\r\n        if (factory != null) {\r\n            return null;\r\n        } else {\r\n            return DEFAULT_FACTORY;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ReplicationStore.doRemove",
	"Comment": "remove the session with the specified session identifier from this store, if present.if no such session is present, this method takes no action.",
	"Method": "void doRemove(String id){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"ReplicationStore>>doRemove\");\r\n    }\r\n    BackingStore<String, ? extends Storeable> replicator = getStoreableBackingStore();\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"ReplicationStore>>doRemove: replicator: \" + replicator);\r\n    }\r\n    try {\r\n        replicator.remove(id);\r\n    } catch (BackingStoreException ex) {\r\n        _logger.log(Level.WARNING, LogFacade.EXCEPTION_REMOVING_SYNCHRONIZED, ex);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.setRequestedSessionURL",
	"Comment": "set a flag indicating whether or not the requested session id for thisrequest came in through a url.this is normally called by thehttp connector, when it parses the request headers.",
	"Method": "void setRequestedSessionURL(boolean flag){\r\n    this.requestedSessionURL = flag;\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutoDeployer.setJspPrecompilationEnabled",
	"Comment": "sets whether or not the precompilejsp option should be requestedduring autodeployments.",
	"Method": "void setJspPrecompilationEnabled(boolean setting){\r\n    jspPreCompilation = setting;\r\n}"
}, {
	"Path": "org.apache.catalina.valves.AccessLogValve.stop",
	"Comment": "gracefully terminate the active use of the public methods of thiscomponent.this method should be the last one called on a giveninstance of this component.",
	"Method": "void stop(){\r\n    if (!started)\r\n        return;\r\n    close();\r\n    super.stop();\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.addInitParameter",
	"Comment": "adds the initialization parameter with the given name and valueto this servlet.",
	"Method": "void addInitParameter(String name,String value){\r\n    setInitParameter(name, value, true);\r\n    if (notifyContainerListeners) {\r\n        fireContainerEvent(\"addInitParameter\", name);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getContext",
	"Comment": "return a servletcontext object that corresponds to aspecified uri on the server.",
	"Method": "ServletContext getContext(String uri){\r\n    if ((uri == null) || (!uri.startsWith(\"/\"))) {\r\n        return (null);\r\n    }\r\n    Context child = null;\r\n    try {\r\n        Host host = (Host) getParent();\r\n        String mapuri = uri;\r\n        while (true) {\r\n            child = (Context) host.findChild(mapuri);\r\n            if (child != null)\r\n                break;\r\n            int slash = mapuri.lastIndexOf('/');\r\n            if (slash < 0)\r\n                break;\r\n            mapuri = mapuri.substring(0, slash);\r\n        }\r\n    } catch (Throwable t) {\r\n        return (null);\r\n    }\r\n    if (child == null) {\r\n        return (null);\r\n    }\r\n    if (getCrossContext()) {\r\n        return child.getServletContext();\r\n    } else if (child == this) {\r\n        return getServletContext();\r\n    } else {\r\n        return (null);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.common.util.admin.MapInjectionResolver.getUploadedFileParamValue",
	"Comment": "returns the path to the uploaded file if the specified field is of typefile and if the field name is the same as one of the option names thatwas associated with an uploaded file in the incoming command request.",
	"Method": "String getUploadedFileParamValue(String fieldName,Class fieldType,MultiMap<String, File> optionNameToFileMap){\r\n    if (optionNameToFileMap == null) {\r\n        return null;\r\n    }\r\n    final File uploadedFile = optionNameToFileMap.getOne(fieldName);\r\n    if (uploadedFile != null && fieldType.isAssignableFrom(File.class)) {\r\n        return uploadedFile.getAbsolutePath();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityCollection.findPattern",
	"Comment": "is the specified pattern part of this web resource collection?",
	"Method": "boolean findPattern(String pattern){\r\n    for (int i = 0; i < patterns.length; i++) {\r\n        if (patterns[i].equals(pattern))\r\n            return (true);\r\n    }\r\n    return (false);\r\n}"
}, {
	"Path": "org.apache.naming.resources.FileDirContext.listBindings",
	"Comment": "enumerates the names bound in the named context, along with the objects bound to them. the contents of any subcontexts are not included.if a binding is added to or removed from this context, its effect on an enumeration previously returned is undefined.",
	"Method": "NamingEnumeration<Binding> listBindings(String name){\r\n    File file = file(name);\r\n    if (file == null)\r\n        throw new NamingException(MessageFormat.format(rb.getString(LogFacade.RESOURCES_NOT_FOUND), name));\r\n    return new NamingContextBindingsEnumeration(list(file).iterator(), this);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.deploy.shared.JarArchive.entries",
	"Comment": "returns an enumeration of the module file entries with thespecified prefix.all elements in the enumeration are oftype string.each string represents a file name relativeto the root of the module.",
	"Method": "Enumeration<String> entries(String prefix){\r\n    Enumeration<String> allEntries = entries();\r\n    Vector<String> entries = new Vector<String>();\r\n    while (allEntries.hasMoreElements()) {\r\n        String name = allEntries.nextElement();\r\n        if (name != null && name.startsWith(prefix)) {\r\n            entries.add(name);\r\n        }\r\n    }\r\n    return entries.elements();\r\n}"
}, {
	"Path": "org.apache.naming.resources.ProxyDirContext.lookupCache",
	"Comment": "retrieves the named object as a cache entry, without any exception.",
	"Method": "CacheEntry lookupCache(String name){\r\n    CacheEntry entry = cacheLookup(name);\r\n    if (entry == null) {\r\n        entry = new CacheEntry();\r\n        entry.name = name;\r\n        try {\r\n            Object object = dirContext.lookup(parseName(name));\r\n            if (object instanceof InputStream) {\r\n                entry.resource = new Resource((InputStream) object);\r\n            } else if (object instanceof DirContext) {\r\n                entry.context = (DirContext) object;\r\n            } else if (object instanceof Resource) {\r\n                entry.resource = (Resource) object;\r\n            } else {\r\n                entry.resource = new Resource(new ByteArrayInputStream(object.toString().getBytes(Charset.defaultCharset())));\r\n            }\r\n            Attributes attributes = dirContext.getAttributes(parseName(name));\r\n            if (!(attributes instanceof ResourceAttributes)) {\r\n                attributes = new ResourceAttributes(attributes);\r\n            }\r\n            entry.attributes = (ResourceAttributes) attributes;\r\n        } catch (NamingException e) {\r\n            entry.exists = false;\r\n        }\r\n    }\r\n    return entry;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.config.ConfigBeanJMXSupport.findNameHint",
	"Comment": "return the name of the xml attribute which contains the value to be used as its name.first element is the name hint, 2nd indicates its type",
	"Method": "NameHint findNameHint(){\r\n    if (isSingleton()) {\r\n        return NameHint.NONE;\r\n    }\r\n    if (mKey != null) {\r\n        return new NameHint(mKey);\r\n    }\r\n    for (final AttributeMethodInfo info : mAttrInfos) {\r\n        if (info.key()) {\r\n            return new NameHint(info.xmlName());\r\n        }\r\n    }\r\n    return NameHint.NAME;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.mbean.AMXImplBase.getObjectNamesForAttribute",
	"Comment": "get child objectnamebuilder corresponding to the attributename",
	"Method": "ObjectName[] getObjectNamesForAttribute(String attributeName){\r\n    final String[] types = attributeNameToType(attributeName);\r\n    ObjectName[] result = null;\r\n    Map<String, ObjectName> children = null;\r\n    for (final String type : types) {\r\n        children = getChildrenMap(type);\r\n        if (children.keySet().size() != 0) {\r\n            break;\r\n        }\r\n    }\r\n    if (children == null || children.keySet().size() == 0) {\r\n        result = EMPTY_OBJECT_NAMES;\r\n    } else {\r\n        result = new ObjectName[children.keySet().size()];\r\n        children.values().toArray(result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.isContainerProvidedServlet",
	"Comment": "return true if the specified class name represents acontainer provided servlet class that should be loaded by theserver class loader.",
	"Method": "boolean isContainerProvidedServlet(String classname){\r\n    if (classname.startsWith(\"org.apache.catalina.\")) {\r\n        return (true);\r\n    }\r\n    try {\r\n        Class<?> clazz = this.getClass().getClassLoader().loadClass(classname);\r\n        return (ContainerServlet.class.isAssignableFrom(clazz));\r\n    } catch (Throwable t) {\r\n        return (false);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.mbeanserver.ssl.SSLClientConfigurator.configure",
	"Comment": "this method creates an sslcontext based on the default provider and thencreated trustmanagers, keymanagers and initializes the sslcontext withthe trustmanager, keymanager",
	"Method": "SSLContext configure(SSLParams sslParams){\r\n    this.sslParams = sslParams;\r\n    String protocol = sslParams.getProtocol();\r\n    try {\r\n        sslContext = SSLContext.getInstance(protocol);\r\n    } catch (NoSuchAlgorithmException ex) {\r\n        _logger.log(Level.SEVERE, errorPreparingSSL, ex);\r\n    }\r\n    configureCiphersAndProtocols();\r\n    String trustAlgorithm = sslParams.getTrustAlgorithm();\r\n    if (trustAlgorithm == null) {\r\n        trustAlgorithm = TrustManagerFactory.getDefaultAlgorithm();\r\n    }\r\n    String algorithm = sslParams.getKeyAlgorithm();\r\n    if (algorithm == null) {\r\n        algorithm = \"SunX509\";\r\n    }\r\n    String keyAlias = sslParams.getCertNickname();\r\n    if (keyAlias == null) {\r\n        keyAlias = \"s1as\";\r\n    }\r\n    try {\r\n        sslContext.init(getKeyManagers(algorithm, keyAlias), getTrustManagers(trustAlgorithm), new SecureRandom());\r\n    } catch (Exception ex) {\r\n        _logger.log(Level.SEVERE, errorPreparingSSL, ex);\r\n    }\r\n    return sslContext;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.AdminUtil.incrementRecoveryAbortedTransactionCount",
	"Comment": "increments the number of transactions that were rolled back as partof the recovery process.",
	"Method": "void incrementRecoveryAbortedTransactionCount(){\r\n    try {\r\n        statisticsLock.acquireReadLock();\r\n        synchronized (lkRecAborts) {\r\n            iRecAborts++;\r\n        }\r\n    } finally {\r\n        statisticsLock.releaseReadLock();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ValveBase.event",
	"Comment": "process a comet event. this method will rarely need to be provided bya subclass, unless it needs to reassociate a particular object withthe thread that is processing the request.",
	"Method": "void event(org.apache.catalina.connector.Request request,org.apache.catalina.connector.Response response,CometEvent event){\r\n    if (getNext() != null) {\r\n        getNext().event(request, response, event);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RecoveryManager.getCoordinator",
	"Comment": "returns a reference to the coordinator object that corresponds to theglobal identifier passed as a parameter.",
	"Method": "CoordinatorImpl getCoordinator(GlobalTID globalTID){\r\n    CoordinatorImpl result = (CoordinatorImpl) coordsByGlobalTID.get(globalTID);\r\n    return result;\r\n}"
}, {
	"Path": "components.renderkit.ChartServlet.doGet",
	"Comment": "process an incoming request, and create the correspondingresponse.",
	"Method": "void doGet(HttpServletRequest request,HttpServletResponse response){\r\n    String type = request.getParameter(\"type\");\r\n    if ((type == null) || (!type.equals(\"bar\")) && (!type.equals(\"pie\"))) {\r\n        type = \"bar\";\r\n    }\r\n    if (type.equals(\"bar\")) {\r\n        generateBarChart(request, response);\r\n    } else {\r\n        generatePieChart(request, response);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.AdminUtil.getSamplingDuration",
	"Comment": "returns the duration for which the last sampling window was open, in milliseconds.if the sampling window is still open, then the running duration is returned.",
	"Method": "long getSamplingDuration(){\r\n    return (lSampleEndTime == 0 && lSampleStartTime != 0) ? System.currentTimeMillis() - lSampleStartTime : lSampleEndTime - lSampleStartTime;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.DefaultAccessLogFormatterImpl.appendHTTPVersion",
	"Comment": "appends the http protocol version of the given request to the givenchar buffer.",
	"Method": "void appendHTTPVersion(CharBuffer cb,HttpServletRequest hreq){\r\n    cb.put(QUOTE);\r\n    String protocol = hreq.getProtocol();\r\n    if (protocol == null) {\r\n        protocol = \"NULL-HTTP-PROTOCOL\";\r\n    }\r\n    cb.put(protocol);\r\n    cb.put(QUOTE);\r\n}"
}, {
	"Path": "com.sun.enterprise.glassfish.bootstrap.osgi.OSGiGlassFishRuntimeBuilder.reconfigure",
	"Comment": "this method helps in situations where glassfish installation directory has been moved orcertain initial provisoning options have changed, etc. if such thing has happened, it uninstallsall the bundles that were installed from glassfish installation location.",
	"Method": "void reconfigure(Properties properties){\r\n    if (hasBeenReconfigured(properties)) {\r\n        logger.log(Level.INFO, LogFacade.PROVISIONING_OPTIONS_CHANGED);\r\n        framework.stop();\r\n        framework.waitForStop(0);\r\n        properties.setProperty(FRAMEWORK_STORAGE_CLEAN, FRAMEWORK_STORAGE_CLEAN_ONFIRSTINIT);\r\n        fwLauncher = new OSGiFrameworkLauncher(properties);\r\n        framework = fwLauncher.launchOSGiFrameWork();\r\n        logger.logp(Level.FINE, \"OSGiGlassFishRuntimeBuilder\", \"reconfigure\", \"Launched {0}\", new Object[] { framework });\r\n        storeProvisioningOptions(properties);\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.ContextAccessController.checkSecurityToken",
	"Comment": "check a submitted security token. the submitted token must be equal tothe token present in the repository. if no token is present for the context, then returns true.",
	"Method": "boolean checkSecurityToken(Object name,Object token){\r\n    Object refToken = securityTokens.get(name);\r\n    return (refToken == null || refToken.equals(token));\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionImpl.commit",
	"Comment": "complete the transaction represented by this transaction object",
	"Method": "void commit(){\r\n    try {\r\n        if (Configuration.isLocalFactory()) {\r\n            ((ControlImpl) control).get_localTerminator().commit(true);\r\n        } else {\r\n            control.get_terminator().commit(true);\r\n        }\r\n    } catch (TRANSACTION_ROLLEDBACK ex) {\r\n        RollbackException rbe = new RollbackException();\r\n        Throwable cause = ex.getCause();\r\n        if (cause != null) {\r\n            rbe.initCause(cause);\r\n        }\r\n        throw rbe;\r\n    } catch (INVALID_TRANSACTION ex) {\r\n        throw new IllegalStateException();\r\n    } catch (HeuristicMixed ex) {\r\n        throw new HeuristicMixedException();\r\n    } catch (HeuristicHazard ex) {\r\n        throw new HeuristicMixedException();\r\n    } catch (NO_PERMISSION ex) {\r\n        throw new SecurityException();\r\n    } catch (Unavailable ex) {\r\n        SystemException sException = new SystemException();\r\n        sException.initCause(ex);\r\n        throw sException;\r\n    } catch (Exception ex) {\r\n        SystemException sException = new SystemException();\r\n        sException.initCause(ex);\r\n        throw sException;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogControlDescriptor.toString",
	"Comment": "this method is called to direct the object to format its state into a string.",
	"Method": "String toString(){\r\n    return \"LCD(head=\" + headLSN + \",tail=\" + tailLSN + \",next=\" + nextLSN + \")\";\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionState.listXAResources",
	"Comment": "list all the xaresources that have been enlisted in thistransaction.",
	"Method": "Enumeration listXAResources(){\r\n    return Collections.enumeration(resourceList.keySet());\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.addWrapperListener",
	"Comment": "add the classname of a containerlistener to be added to eachwrapper appended to this context.",
	"Method": "void addWrapperListener(String listener){\r\n    wrapperListeners.add(listener);\r\n    if (notifyContainerListeners) {\r\n        fireContainerEvent(\"addWrapperListener\", listener);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.getEffectiveMinorVersion",
	"Comment": "gets the minor version of the servlet specification that theapplication represented by this servletcontext is based on.",
	"Method": "int getEffectiveMinorVersion(){\r\n    return context.getEffectiveMinorVersion();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.commitOnePhase",
	"Comment": "directs the subcoordinator to commit the transaction in one phasethe subcoordinator directs all registered resources to commit.",
	"Method": "boolean commitOnePhase(){\r\n    Vote v = this.prepare();\r\n    if (v == Vote.VoteCommit) {\r\n        this.commit();\r\n    } else if (v == Vote.VoteReadOnly) {\r\n    } else {\r\n        this.rollback(true);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.findbyprimarykey.HomeInterfaceFindByPrimaryKeyArg.check",
	"Comment": "define findbyprimarykey method parameter test.every entity enterprise home interface must define the findbyprimarykey method. the method must declare the primary key class as the method argument.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    result = getInitializedResult();\r\n    compName = getVerifierContext().getComponentNameConstructor();\r\n    boolean oneFailed = false;\r\n    if (descriptor instanceof EjbEntityDescriptor) {\r\n        if (descriptor.getHomeClassName() != null && !\"\".equals(descriptor.getHomeClassName()))\r\n            oneFailed = commonToBothInterfaces(descriptor.getHomeClassName(), descriptor);\r\n        if (oneFailed == false) {\r\n            if (descriptor.getLocalHomeClassName() != null && !\"\".equals(descriptor.getLocalHomeClassName()))\r\n                oneFailed = commonToBothInterfaces(descriptor.getLocalHomeClassName(), descriptor);\r\n        }\r\n        if (oneFailed) {\r\n            result.setStatus(result.FAILED);\r\n        } else {\r\n            result.setStatus(result.PASSED);\r\n        }\r\n        return result;\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"[ {0} ] expected {1} bean, but called with {2} bean.\", new Object[] { getClass(), \"Entity\", \"Session\" }));\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.Environment.getBooleanOption",
	"Comment": "return the value of the environment entry correspondingto the named option.",
	"Method": "boolean getBooleanOption(String name){\r\n    return Boolean.parseBoolean(env.get(optionToEnv(name)));\r\n}"
}, {
	"Path": "com.sun.corba.ee.impl.orbutil.newtimer.TimerPointSourceGenerator.generateSourceFile",
	"Comment": "generate the source file for the timers in the timerfactory from the description.the file is generated in the directory given by the package from the description starting at the dirname.the name of the file is name.java, where nameis the timerfactory name from the description.",
	"Method": "void generateSourceFile(String dirName,Pair<String, TimerFactory> description){\r\n    _clear();\r\n    _package(description.first());\r\n    _import(\"java.lang.Object\");\r\n    _import(\"java.lang.String\");\r\n    _import(\"com.sun.corba.ee.spi.orb.ORB\");\r\n    _import(\"com.sun.corba.ee.spi.orbutil.newtimer.Controllable\");\r\n    _import(\"com.sun.corba.ee.spi.orbutil.newtimer.TimerManager\");\r\n    _import(\"com.sun.corba.ee.spi.orbutil.newtimer.TimerFactory\");\r\n    _import(\"com.sun.corba.ee.spi.orbutil.newtimer.Timer\");\r\n    _import(\"com.sun.corba.ee.spi.orbutil.newtimer.TimerEventController\");\r\n    _import(\"com.sun.corba.ee.spi.orbutil.newtimer.TimerGroup\");\r\n    TimerFactory tf = description.second();\r\n    _class(PUBLIC, tf.name(), _t(\"Object\"));\r\n    generateFields(tf);\r\n    generateConstructor(tf);\r\n    generateEnterExitMethods(tf);\r\n    _end();\r\n    File dir = new File(dirName);\r\n    String pkg = description.first();\r\n    String fileDir = pkg.replace('.', File.separatorChar);\r\n    File fdir = new File(dir, fileDir);\r\n    fdir.mkdirs();\r\n    File file = new File(fdir, tf.name() + \".java\");\r\n    PrintStream ps = new PrintStream(file);\r\n    _sourceCode(ps, new Properties());\r\n}"
}, {
	"Path": "org.glassfish.webservices.transport.tcp.AppServRegistry.populateEndpoints",
	"Comment": "populate currently registered ws endpoints and register them",
	"Method": "void populateEndpoints(WebServiceEngine engine){\r\n    final Iterator<Endpoint> endpoints = engine.getEndpoints();\r\n    while (endpoints.hasNext()) {\r\n        registerEndpoint(endpoints.next());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.store.AsadminSecurityUtil.chooseMasterPassword",
	"Comment": "returns the master password passed on the command line or, if none,the default master password.",
	"Method": "char[] chooseMasterPassword(char[] commandMasterPassword){\r\n    return (commandMasterPassword == null ? defaultMasterPassword() : commandMasterPassword);\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.TransactionManagerHelper.getTransactionRemainingTimeout",
	"Comment": "return duration before current transaction would timeout.",
	"Method": "int getTransactionRemainingTimeout(){\r\n    int timeout = 0;\r\n    Transaction txn = getTransaction();\r\n    if (txn == null) {\r\n        throw new IllegalStateException(\"no current transaction\");\r\n    } else if (txn instanceof JavaEETransactionImpl) {\r\n        timeout = ((JavaEETransactionImpl) txn).getRemainingTimeout();\r\n    }\r\n    return timeout;\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ExtendedAccessLogValve.invoke",
	"Comment": "log a message summarizing the specified request and response, accordingto the format specified by the pattern property.",
	"Method": "int invoke(Request request,Response response){\r\n    request.setNote(REQUEST_START_TIME_NOTE, Long.valueOf(System.currentTimeMillis()));\r\n    return INVOKE_NEXT;\r\n}"
}, {
	"Path": "com.sun.enterprise.server.logging.logviewer.backend.LogFilter.allChecks",
	"Comment": "this method accepts the first line of the log record and checksto see if it matches the query.",
	"Method": "boolean allChecks(LogFile.LogEntry entry,Date fromDate,Date toDate,String queryLevel,boolean onlyLevel,List listOfModules,Properties nameValueMap,String anySearch){\r\n    if (DEBUG) {\r\n        StringBuffer buf = new StringBuffer();\r\n        buf.append(dateTimeCheck(entry.getLoggedDateTime(), fromDate, toDate));\r\n        buf.append(\",\");\r\n        buf.append(levelCheck(entry.getLoggedLevel(), queryLevel, onlyLevel));\r\n        buf.append(\",\");\r\n        buf.append(moduleCheck(entry.getLoggedLoggerName(), listOfModules));\r\n        buf.append(\",\");\r\n        buf.append(nameValueCheck(entry.getLoggedNameValuePairs(), nameValueMap));\r\n        buf.append(\",\");\r\n        buf.append(messageDataCheck(entry.getLoggedMessage(), entry.getLoggedNameValuePairs(), anySearch));\r\n        System.out.println(\"allChecks=\" + buf.toString());\r\n    }\r\n    if ((dateTimeCheck(entry.getLoggedDateTime(), fromDate, toDate)) && (levelCheck(entry.getLoggedLevel(), queryLevel, onlyLevel)) && (moduleCheck(entry.getLoggedLoggerName(), listOfModules)) && (nameValueCheck(entry.getLoggedNameValuePairs(), nameValueMap)) && (messageDataCheck(entry.getLoggedMessage(), entry.getLoggedNameValuePairs(), anySearch))) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ContainerBase.logName",
	"Comment": "return the abbreviated name of this container for logging messages",
	"Method": "String logName(){\r\n    String className = this.getClass().getName();\r\n    int period = className.lastIndexOf(\".\");\r\n    if (period >= 0)\r\n        className = className.substring(period + 1);\r\n    return (className + \"[\" + getName() + \"]\");\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.setExtensionProperty",
	"Comment": "this property can be used to indicate special processing.for example, a deployer may set this property.",
	"Method": "void setExtensionProperty(String key,String value){\r\n    if (null == extensionProperty) {\r\n        extensionProperty = new HashMap<String, String>();\r\n    }\r\n    extensionProperty.put(key, value);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteRestAdminCommand.setUserOut",
	"Comment": "if set, the raw response from the command is written to thespecified stream.",
	"Method": "void setUserOut(OutputStream userOut){\r\n    this.userOut = userOut;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.setProtocolHandlerClassName",
	"Comment": "set the class name of the coyote protocol handler which will be usedby the connector.",
	"Method": "void setProtocolHandlerClassName(String protocolHandlerClassName){\r\n    this.protocolHandlerClassName = protocolHandlerClassName;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.ObjectInputStreamWithServiceLocator.resolveClass",
	"Comment": "use the given classloader rather than using the system class",
	"Method": "Class<?> resolveClass(ObjectStreamClass classDesc){\r\n    try {\r\n        return super.resolveClass(classDesc);\r\n    } catch (ClassNotFoundException e) {\r\n        String cname = classDesc.getName();\r\n        if (cname.startsWith(\"[\")) {\r\n            Class<?> component;\r\n            int dcount;\r\n            for (dcount = 1; cname.charAt(dcount) == '['; dcount++) ;\r\n            if (cname.charAt(dcount) == 'L') {\r\n                component = loadClass(cname.substring(dcount + 1, cname.length() - 1));\r\n            } else {\r\n                throw new ClassNotFoundException(cname);\r\n            }\r\n            int[] dim = new int[dcount];\r\n            for (int i = 0; i < dcount; i++) {\r\n                dim[i] = 0;\r\n            }\r\n            return Array.newInstance(component, dim).getClass();\r\n        } else {\r\n            return loadClass(cname);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.web.GlassFishSingleSignOn.deregister",
	"Comment": "deregister the specified single sign on identifier, and invalidateany associated sessions.",
	"Method": "void deregister(String ssoId){\r\n    if (logger.isLoggable(Level.FINE)) {\r\n        logger.log(Level.FINE, LogFacade.DEREGISTER_SSO);\r\n    }\r\n    SingleSignOnEntry sso = null;\r\n    synchronized (cache) {\r\n        sso = (SingleSignOnEntry) cache.remove(ssoId);\r\n    }\r\n    if (sso == null)\r\n        return;\r\n    sso.expireSessions();\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.ReportHandler.addToDocument",
	"Comment": "this method adds the result value to the appropriate location in the domtree.",
	"Method": "void addToDocument(String moduleName,String status,Result r,Enumeration en){\r\n    if (r == null)\r\n        return;\r\n    NodeList nodeList;\r\n    nodeList = document.getElementsByTagName(moduleName).item(0).getChildNodes();\r\n    Element statusNode = null;\r\n    for (int j = 0; j < nodeList.getLength(); j++) {\r\n        if (((Element) nodeList.item(j)).getTagName().equals(status)) {\r\n            statusNode = (Element) nodeList.item(j);\r\n            break;\r\n        }\r\n    }\r\n    Element test = document.createElement(TEST);\r\n    Element testName = getTextNode(TEST_NAME, r.getTestName());\r\n    Element testAssertion = getTextNode(TEST_ASSERTION, r.getAssertion());\r\n    String string = \"\";\r\n    while (en.hasMoreElements()) {\r\n        string = string + (String) en.nextElement() + \"\\n\";\r\n    }\r\n    Element testDescr = getTextNode(TEST_DESC, string);\r\n    test.appendChild(testName);\r\n    test.appendChild(testAssertion);\r\n    test.appendChild(testDescr);\r\n    statusNode.appendChild(test);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.session.SessionBeanInterface.check",
	"Comment": "implements the sessionbean interface test.all session beans must implement, directly or indirectly, the sessionbean interface.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (descriptor instanceof EjbSessionDescriptor) {\r\n        try {\r\n            VerifierTestContext context = getVerifierContext();\r\n            ClassLoader jcl = context.getClassLoader();\r\n            Class c = Class.forName(descriptor.getEjbClassName(), false, getVerifierContext().getClassLoader());\r\n            boolean validBean = false;\r\n            do {\r\n                Class[] interfaces = c.getInterfaces();\r\n                for (int i = 0; i < interfaces.length; i++) {\r\n                    logger.log(Level.FINE, getClass().getName() + \".debug1\", new Object[] { interfaces[i].getName() });\r\n                    if (interfaces[i].getName().equals(\"javax.ejb.SessionBean\") && descriptor instanceof EjbSessionDescriptor) {\r\n                        validBean = true;\r\n                        result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"[ {0} ] properly implements the SessionBean interface.\", new Object[] { descriptor.getEjbClassName() }));\r\n                        break;\r\n                    }\r\n                }\r\n            } while ((((c = c.getSuperclass()) != null) && (!validBean)));\r\n            if (!validBean) {\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: [ {0} ] does not properly implement the SessionBean interface.  All session Beans must implement the SessionBean interface.  [ {1} ] is not a valid bean.\", new Object[] { descriptor.getEjbClassName(), descriptor.getEjbClassName() }));\r\n            }\r\n        } catch (ClassNotFoundException e) {\r\n            Verifier.debug(e);\r\n            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.failed(smh.getLocalString(getClass().getName() + \".failedException\", \"Error: [ {0} ] class not found.\", new Object[] { descriptor.getEjbClassName() }));\r\n        }\r\n        return result;\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"[ {0} ] expected {1} bean, but called with {2} bean.\", new Object[] { getClass(), \"Session\", \"Entity\" }));\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.SecurityConstraint.setAuthConstraint",
	"Comment": "sets the roles authorized to access the url patterns and http methods",
	"Method": "void setAuthConstraint(String roleNames){\r\n    this.roleNames = roleNames;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentImpl.rollback_only",
	"Comment": "marks the current transaction such that is cannot be committed and onlyrolled back.",
	"Method": "void rollback_only(){\r\n    try {\r\n        Coordinator coord = CurrentTransaction.getCurrentCoordinator();\r\n        coord.rollback_only();\r\n    } catch (Throwable exc) {\r\n        throw new NoTransaction();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.security.common.PrincipalImpl.equals",
	"Comment": "this function returns true if the object passed matches the principal represented in this implementation",
	"Method": "boolean equals(Object another){\r\n    if (another instanceof Group) {\r\n        return false;\r\n    } else if (another instanceof PrincipalImpl) {\r\n        Principal p = (Principal) another;\r\n        return getName().equals(p.getName());\r\n    } else\r\n        return false;\r\n}"
}, {
	"Path": "org.apache.catalina.valves.JDBCAccessLogValve.start",
	"Comment": "invoked by tomcat on startup. the database connection is set here.",
	"Method": "void start(){\r\n    if (started)\r\n        return;\r\n    super.start();\r\n    try {\r\n        Class.forName(driverName).newInstance();\r\n    } catch (ClassNotFoundException e) {\r\n        throw new LifecycleException(e);\r\n    } catch (InstantiationException e) {\r\n        throw new LifecycleException(e);\r\n    } catch (IllegalAccessException e) {\r\n        throw new LifecycleException(e);\r\n    }\r\n    Properties info = new Properties();\r\n    info.setProperty(\"autoReconnect\", \"true\");\r\n    try {\r\n        conn = DriverManager.getConnection(connectionURL, info);\r\n        if (pattern.equals(\"common\")) {\r\n            ps = conn.prepareStatement(\"INSERT INTO \" + tableName + \" (\" + remoteHostField + \", \" + userField + \", \" + timestampField + \", \" + queryField + \", \" + statusField + \", \" + bytesField + \") VALUES(?, ?, ?, ?, ?, ?)\");\r\n        } else if (pattern.equals(\"combined\")) {\r\n            ps = conn.prepareStatement(\"INSERT INTO \" + tableName + \" (\" + remoteHostField + \", \" + userField + \", \" + timestampField + \", \" + queryField + \", \" + statusField + \", \" + bytesField + \", \" + virtualHostField + \", \" + methodField + \", \" + refererField + \", \" + userAgentField + \") VALUES(?, ?, ?, ?, ?, ?, ?, ?, ?, ?)\");\r\n        }\r\n    } catch (SQLException e) {\r\n        throw new LifecycleException(e);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.activate",
	"Comment": "perform internal processing required to activate thissession.",
	"Method": "void activate(){\r\n    context.sessionActivatedStartEvent(this);\r\n    try {\r\n        HttpSessionEvent event = null;\r\n        String[] keys = keys();\r\n        for (int i = 0; i < keys.length; i++) {\r\n            Object attribute = getAttributeInternal(keys[i]);\r\n            if (attribute instanceof HttpSessionActivationListener) {\r\n                if (event == null)\r\n                    event = new HttpSessionEvent(getSession());\r\n                ((HttpSessionActivationListener) attribute).sessionDidActivate(event);\r\n            }\r\n        }\r\n    } finally {\r\n        context.sessionActivatedEndEvent(this);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.DefaultAccessLogFormatterImpl.appendHTTPMethod",
	"Comment": "appends the http method of the given request to the given char buffer.",
	"Method": "void appendHTTPMethod(CharBuffer cb,HttpServletRequest hreq){\r\n    cb.put(QUOTE);\r\n    String method = hreq.getMethod();\r\n    if (method == null) {\r\n        method = \"NULL-HTTP-METHOD\";\r\n    }\r\n    cb.put(method);\r\n    cb.put(QUOTE);\r\n}"
}, {
	"Path": "org.apache.catalina.loader.WebappLoader.closeJARs",
	"Comment": "used to periodically signal to the classloader to release jar resources.",
	"Method": "void closeJARs(boolean force){\r\n    if (classLoader != null) {\r\n        classLoader.closeJARs(force);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.SecureAdminBootstrapHelper.getRemoteHelper",
	"Comment": "creates a new helper for delivering files needed for secure admin tothe remote instance.",
	"Method": "SecureAdminBootstrapHelper getRemoteHelper(ServiceLocator habitat,File DASInstanceDir,String remoteNodeDir,String instance,Node node,Logger logger){\r\n    RemoteType type = null;\r\n    try {\r\n        type = RemoteType.valueOf(node.getType());\r\n    } catch (Exception e) {\r\n        throw new IllegalArgumentException(Strings.get(\"internal.error\", \"unknown type\"));\r\n    }\r\n    switch(type) {\r\n        case SSH:\r\n            return new SSHHelper(habitat, DASInstanceDir, remoteNodeDir, instance, node, logger);\r\n        default:\r\n            throw new IllegalArgumentException(Strings.get(\"internal.error\", \"A new type must have \" + \"been added --> unknown type: \" + type.toString()));\r\n    }\r\n}"
}, {
	"Path": "demo.model.RepeaterBean.append",
	"Comment": "append an informational message to the set of messages that willbe rendered when this view is redisplayed.",
	"Method": "void append(String message){\r\n    FacesContext context = FacesContext.getCurrentInstance();\r\n    context.addMessage(null, new FacesMessage(FacesMessage.SEVERITY_INFO, message, null));\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityConstraint.setAuthConstraint",
	"Comment": "set the authorization constraint present flag for this securityconstraint.",
	"Method": "void setAuthConstraint(boolean authConstraint){\r\n    this.authConstraint = authConstraint;\r\n}"
}, {
	"Path": "com.sun.jts.jta.UserTransactionImpl.rollback",
	"Comment": "roll back the transaction associated with the current thread. when thismethod completes, the thread becomes associated with no transaction.",
	"Method": "void rollback(){\r\n    if (transactionManager == null)\r\n        init();\r\n    this.transactionManager.rollback();\r\n}"
}, {
	"Path": "org.glassfish.grizzly.config.ssl.JSSE14SocketFactory.getParameters",
	"Comment": "return the initialization parameters for the trustmanager. currently, only the default pkix issupported.",
	"Method": "CertPathParameters getParameters(String algorithm,String crlf,KeyStore trustStore){\r\n    CertPathParameters params;\r\n    if (\"PKIX\".equalsIgnoreCase(algorithm)) {\r\n        PKIXBuilderParameters xparams = new PKIXBuilderParameters(trustStore, new X509CertSelector());\r\n        Collection crls = getCRLs(crlf);\r\n        CertStoreParameters csp = new CollectionCertStoreParameters(crls);\r\n        CertStore store = CertStore.getInstance(\"Collection\", csp);\r\n        xparams.addCertStore(store);\r\n        xparams.setRevocationEnabled(true);\r\n        String trustLength = (String) attributes.get(\"trustMaxCertLength\");\r\n        if (trustLength != null) {\r\n            try {\r\n                xparams.setMaxPathLength(Integer.parseInt(trustLength));\r\n            } catch (Exception ex) {\r\n                logger.warning(\"Bad maxCertLength: \" + trustLength);\r\n            }\r\n        }\r\n        params = xparams;\r\n    } else {\r\n        throw new CRLException(\"CRLs not supported for type: \" + algorithm);\r\n    }\r\n    return params;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContextValve.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (info);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.Configuration.getLogFile",
	"Comment": "returns the logfile for the given log path. for delegated recovery support.",
	"Method": "LogFile getLogFile(LogFile getLogFile,String logPath){\r\n    if (logPath == null)\r\n        return null;\r\n    return (LogFile) logPathToFiletable.get(logPath);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.removeConstraints",
	"Comment": "removes any security constraints from this web application.",
	"Method": "void removeConstraints(){\r\n    if (notifyContainerListeners) {\r\n        Iterator<SecurityConstraint> i = constraints.iterator();\r\n        while (i.hasNext()) {\r\n            fireContainerEvent(\"removeConstraint\", i.next());\r\n        }\r\n    }\r\n    constraints.clear();\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.util.ArchiveClassesLoadableHelper.getFailedResult",
	"Comment": "this method is used to print the result in various archiveclassesloadable tests.",
	"Method": "String getFailedResult(ClosureCompiler cc){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(\"\\n\");\r\n    for (Object o : cc.getFailed().entrySet()) {\r\n        Map.Entry<String, List<String>> referencingPathToFailedList = (Map.Entry<String, List<String>>) o;\r\n        LocalStringManagerImpl smh = StringManagerHelper.getLocalStringsManager();\r\n        String classes = \"Failed to find following classes:\";\r\n        if (smh != null) {\r\n            classes = smh.getLocalString(ArchiveClassesLoadableHelper.class.getName() + \".classes\", classes);\r\n        }\r\n        sb.append(classes).append(\"\\n[\");\r\n        for (Iterator<String> iii = referencingPathToFailedList.getValue().iterator(); iii.hasNext(); ) {\r\n            sb.append(\"\\n\\t\").append(iii.next());\r\n            if (iii.hasNext())\r\n                sb.append(\",\");\r\n        }\r\n        sb.append(\"\\n]\");\r\n        String referencingPath = referencingPathToFailedList.getKey();\r\n        if (referencingPath.length() == 0)\r\n            continue;\r\n        String ref = \"referenced in the following call stack :\\n\";\r\n        String reference = \"at\";\r\n        if (smh != null) {\r\n            ref = smh.getLocalString(ArchiveClassesLoadableHelper.class.getName() + \".ref\", ref);\r\n            reference = smh.getLocalString(ArchiveClassesLoadableHelper.class.getName() + \".reference\", reference);\r\n        }\r\n        StringTokenizer st = new StringTokenizer(referencingPath, File.separator);\r\n        Stack<String> referencingClassStack = new Stack<String>();\r\n        while (st.hasMoreTokens()) {\r\n            referencingClassStack.push(st.nextToken());\r\n        }\r\n        if (!referencingClassStack.isEmpty())\r\n            sb.append(\"\\n\\n\" + ref);\r\n        while (!referencingClassStack.isEmpty()) {\r\n            sb.append(\"\\n\\t\").append(reference).append(\" \");\r\n            sb.append(referencingClassStack.pop());\r\n        }\r\n        sb.append(\"\\n\\n\");\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setSessionTrackingModes",
	"Comment": "sets the session tracking modes that are to become effective for thisservletcontext.",
	"Method": "void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes){\r\n    if (sessionTrackingModes.contains(SessionTrackingMode.SSL)) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.UNSUPPORTED_TRACKING_MODE_EXCEPTION), new Object[] { SessionTrackingMode.SSL, getName() });\r\n        throw new IllegalArgumentException(msg);\r\n    }\r\n    if (isContextInitializedCalled) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.SERVLET_CONTEXT_ALREADY_INIT_EXCEPTION), new Object[] { \"setSessionTrackingModes\", getName() });\r\n        throw new IllegalStateException(msg);\r\n    }\r\n    this.sessionTrackingModes = Collections.unmodifiableSet(sessionTrackingModes);\r\n    if (sessionTrackingModes.contains(SessionTrackingMode.COOKIE)) {\r\n        setCookies(true);\r\n    } else {\r\n        setCookies(false);\r\n    }\r\n    if (sessionTrackingModes.contains(SessionTrackingMode.URL)) {\r\n        setEnableURLRewriting(true);\r\n    } else {\r\n        setEnableURLRewriting(false);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.managed.ManagedConnectionFactoryImplEquals.check",
	"Comment": "test if the managedconnectionfactory implementation override the equals method",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!descriptor.getOutBoundDefined()) {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.managed.notApplicableForInboundRA\", \"Resource Adapter does not provide outbound communication\"));\r\n        return result;\r\n    }\r\n    Class mcf = testManagedConnectionFactoryImpl(descriptor, result);\r\n    if (mcf != null) {\r\n        checkMethodImpl(mcf, \"equals\", new Class[] { Object.class }, \"public boolean equals(Object)\", result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.VerifierTest.getInitializedResult",
	"Comment": "common traces and initialization of the result object that willhold the result of the assertion tested by this verifier test",
	"Method": "Result getInitializedResult(){\r\n    logger.log(Level.FINE, \"which.class.called.string\", new Object[] { getClass() });\r\n    Result result = new Result();\r\n    String version = \"\";\r\n    String compName = \"\";\r\n    if (context != null) {\r\n        version = context.getSchemaVersion();\r\n        compName = context.getComponentNameConstructor().toString();\r\n    } else {\r\n        logger.fine(getClass().getName() + \" context is null.\");\r\n    }\r\n    result.init(getClass(), version, compName);\r\n    logger.log(Level.FINE, \"test.string.assertion\", new Object[] { result.getAssertion() });\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.hasRegistered",
	"Comment": "checks whether the topcoordinator has registered with its superior.",
	"Method": "boolean hasRegistered(){\r\n    boolean result = registered || registeredSync;\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.getAuthRealmName",
	"Comment": "gets the value of the authrealm property of this virtual server.",
	"Method": "String getAuthRealmName(){\r\n    return authRealmName;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModule.loadListener",
	"Comment": "loads and instantiates the listener with the specified classname.",
	"Method": "EventListener loadListener(ClassLoader loader,String listenerClassName){\r\n    try {\r\n        return super.loadListener(loader, listenerClassName);\r\n    } catch (Exception e) {\r\n        if (WS_SERVLET_CONTEXT_LISTENER.equals(listenerClassName)) {\r\n            logger.log(Level.WARNING, LogFacade.MISSING_METRO, e);\r\n        }\r\n        throw e;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.config.support.GenericListCommand.filterColumns",
	"Comment": "modify the cols list to include only those columns specified in the outputopts",
	"Method": "List<ColumnInfo> filterColumns(List<ColumnInfo> cols,String[] outputOpts){\r\n    List<ColumnInfo> newcols = new ArrayList<ColumnInfo>(cols.size());\r\n    for (ColumnInfo ci : cols) {\r\n        if (ci.isIncluded(outputOpts)) {\r\n            newcols.add(ci);\r\n        }\r\n    }\r\n    return newcols;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.register_subtran_aware",
	"Comment": "enables a subtransactionawareresource to be registered as a participantin the completion of a subtransaction.if the subcoordinator has not registered with is superior, it creates acoordinatorresource and registers it with the superior.",
	"Method": "void register_subtran_aware(SubtransactionAwareResource sares){\r\n    if (tranState == null || tranState.state != TransactionState.STATE_ACTIVE) {\r\n        Inactive exc = new Inactive();\r\n        throw exc;\r\n    }\r\n    if (rollbackOnly) {\r\n        TRANSACTION_ROLLEDBACK exc = new TRANSACTION_ROLLEDBACK(0, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    if (!registered) {\r\n        CoordinatorResourceImpl cImpl = new CoordinatorResourceImpl(superInfo.globalTID, this, true);\r\n        try {\r\n            CoordinatorResource cRes = cImpl.object();\r\n            superInfo.superior.register_subtran_aware(cRes);\r\n            superInfo.setResource(cRes);\r\n            registered = true;\r\n        } catch (Throwable exc) {\r\n            cImpl.destroy();\r\n            if (exc instanceof OBJECT_NOT_EXIST) {\r\n                TRANSACTION_ROLLEDBACK ex2 = new TRANSACTION_ROLLEDBACK(0, CompletionStatus.COMPLETED_NO);\r\n                throw ex2;\r\n            }\r\n            if (exc instanceof Inactive) {\r\n                throw (Inactive) exc;\r\n            }\r\n            if (exc instanceof SystemException) {\r\n                throw (SystemException) exc;\r\n            }\r\n            INTERNAL ex2 = new INTERNAL(MinorCode.NotRegistered, CompletionStatus.COMPLETED_NO);\r\n            throw ex2;\r\n        }\r\n    }\r\n    if (participants == null) {\r\n        participants = new RegisteredResources(null, this);\r\n    }\r\n    participants.addRes((Resource) sares._duplicate());\r\n    temporary = false;\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.AuthenticatorBase.getRealmName",
	"Comment": "returns the name of the associated realm. always returns null unlesssubclass overrides behavior.",
	"Method": "String getRealmName(){\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.internal.data.ModuleInfo.save",
	"Comment": "saves its state to the configuration. this method must be called within a transactionto the configured module instance.",
	"Method": "void save(Module module){\r\n    if (Boolean.valueOf(moduleProps.getProperty(ServerTags.IS_COMPOSITE))) {\r\n        moduleProps.remove(ServerTags.IS_COMPOSITE);\r\n        for (Iterator itr = moduleProps.keySet().iterator(); itr.hasNext(); ) {\r\n            String propName = (String) itr.next();\r\n            Property prop = module.createChild(Property.class);\r\n            module.getProperty().add(prop);\r\n            prop.setName(propName);\r\n            prop.setValue(moduleProps.getProperty(propName));\r\n        }\r\n    }\r\n    for (EngineRef ref : _getEngineRefs()) {\r\n        Engine engine = module.createChild(Engine.class);\r\n        module.getEngines().add(engine);\r\n        ref.save(engine);\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.NodeCreateRule.begin",
	"Comment": "implemented to replace the content handler currently in use by a nodebuilder.",
	"Method": "void begin(String namespaceURI,String name,Attributes attributes){\r\n    XMLReader xmlReader = getDigester().getXMLReader();\r\n    Document doc = documentBuilder.newDocument();\r\n    NodeBuilder builder = null;\r\n    if (nodeType == Node.ELEMENT_NODE) {\r\n        Element element = null;\r\n        if (getDigester().getNamespaceAware()) {\r\n            element = doc.createElementNS(namespaceURI, name);\r\n            for (int i = 0; i < attributes.getLength(); i++) {\r\n                element.setAttributeNS(attributes.getURI(i), attributes.getLocalName(i), attributes.getValue(i));\r\n            }\r\n        } else {\r\n            element = doc.createElement(name);\r\n            for (int i = 0; i < attributes.getLength(); i++) {\r\n                element.setAttribute(attributes.getQName(i), attributes.getValue(i));\r\n            }\r\n        }\r\n        builder = new NodeBuilder(doc, element);\r\n    } else {\r\n        builder = new NodeBuilder(doc, doc.createDocumentFragment());\r\n    }\r\n    xmlReader.setContentHandler(builder);\r\n}"
}, {
	"Path": "org.glassfish.webservices.WebServiceReferenceManagerImpl.getServletAdapterBasedOnWsdlUrl",
	"Comment": "this method basically is a fall back mechanism to fetch requiredparameters from wsdl url stored in servicereferencedescriptor. the flow reacheshere only in case where required parameters could not be fetchedfrom webbundledescriptor.",
	"Method": "ServletAdapter getServletAdapterBasedOnWsdlUrl(ServiceReferenceDescriptor desc){\r\n    if (logger.isLoggable(Level.INFO)) {\r\n        logger.log(Level.INFO, LogUtils.SERVLET_ADAPTER_BASED_ON_WSDL_URL, new Object[] { desc.getServiceLocalPart(), desc.getWsdlFileUrl() });\r\n    }\r\n    URL wsdl = desc.getWsdlFileUrl();\r\n    String wsdlPath = wsdl.getPath().trim();\r\n    if (!wsdlPath.contains(WebServiceEndpoint.PUBLISHING_SUBCONTEXT))\r\n        return null;\r\n    String contextRootAndPath = // test/Translator\r\n    wsdlPath.substring(1, wsdlPath.indexOf(WebServiceEndpoint.PUBLISHING_SUBCONTEXT) - 1);\r\n    if (!(contextRootAndPath.length() > 0))\r\n        return null;\r\n    String[] contextRootAndPathArray = contextRootAndPath.split(\"/\");\r\n    if (contextRootAndPathArray.length != 2)\r\n        return null;\r\n    if (contextRootAndPathArray[0] == null)\r\n        return null;\r\n    String contextRoot = \"/\" + contextRootAndPathArray[0];\r\n    if (contextRootAndPathArray[1] == null)\r\n        return null;\r\n    String webSevicePath = \"/\" + contextRootAndPathArray[1];\r\n    String urlPattern = wsdlPath.substring(contextRoot.length());\r\n    Adapter adapter = JAXWSAdapterRegistry.getInstance().getAdapter(contextRoot, webSevicePath, urlPattern);\r\n    return adapter instanceof ServletAdapter ? (ServletAdapter) adapter : null;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.CreateSystemProperties.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    String sysPropName = \"\";\r\n    try {\r\n        for (final Object key : properties.keySet()) {\r\n            final String propName = (String) key;\r\n            sysPropName = propName;\r\n            if (spb.containsProperty(sysPropName) && spb.getSystemProperty(sysPropName).getValue().equals(properties.getProperty(propName))) {\r\n                continue;\r\n            }\r\n            ConfigSupport.apply(new SingleConfigCode<SystemPropertyBag>() {\r\n                @Override\r\n                public Object run(SystemPropertyBag param) throws PropertyVetoException, TransactionFailure {\r\n                    for (SystemProperty sysProperty : param.getSystemProperty()) {\r\n                        if (sysProperty.getName().equals(propName)) {\r\n                            Transaction t = Transaction.getTransaction(param);\r\n                            sysProperty = t.enroll(sysProperty);\r\n                            sysProperty.setValue(properties.getProperty(propName));\r\n                            return sysProperty;\r\n                        }\r\n                    }\r\n                    SystemProperty newSysProp = param.createChild(SystemProperty.class);\r\n                    newSysProp.setName(propName);\r\n                    newSysProp.setValue(properties.getProperty(propName));\r\n                    param.getSystemProperty().add(newSysProp);\r\n                    return newSysProp;\r\n                }\r\n            }, spb);\r\n            report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n        }\r\n    } catch (TransactionFailure tfe) {\r\n        report.setMessage(localStrings.getLocalString(\"create.system.properties.failed\", \"System property {0} creation failed\", sysPropName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"create.system.properties.failed\", \"System property {0} creation failed\", sysPropName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.CreateSystemProperties.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    for (SystemProperty sysProperty : param.getSystemProperty()) {\r\n        if (sysProperty.getName().equals(propName)) {\r\n            Transaction t = Transaction.getTransaction(param);\r\n            sysProperty = t.enroll(sysProperty);\r\n            sysProperty.setValue(properties.getProperty(propName));\r\n            return sysProperty;\r\n        }\r\n    }\r\n    SystemProperty newSysProp = param.createChild(SystemProperty.class);\r\n    newSysProp.setName(propName);\r\n    newSysProp.setValue(properties.getProperty(propName));\r\n    param.getSystemProperty().add(newSysProp);\r\n    return newSysProp;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.isAsyncSupported",
	"Comment": "checks if the wrapped servlet has been annotated or flagged in thedeployment descriptor as being able to support asynchronous operations.",
	"Method": "boolean isAsyncSupported(){\r\n    return isAsyncSupported;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.setInitParameters",
	"Comment": "sets the initialization parameters contained in the given mapon this servlet.",
	"Method": "Set<String> setInitParameters(Map<String, String> initParameters){\r\n    if (null == initParameters) {\r\n        throw new IllegalArgumentException(\"Null init parameters\");\r\n    }\r\n    synchronized (parameters) {\r\n        Set<String> conflicts = null;\r\n        for (Map.Entry<String, String> e : initParameters.entrySet()) {\r\n            if (e.getKey() == null || e.getValue() == null) {\r\n                throw new IllegalArgumentException(\"Null parameter name or value\");\r\n            }\r\n            if (parameters.containsKey(e.getKey())) {\r\n                if (conflicts == null) {\r\n                    conflicts = new HashSet<String>();\r\n                }\r\n                conflicts.add(e.getKey());\r\n            }\r\n        }\r\n        if (conflicts != null) {\r\n            return conflicts;\r\n        }\r\n        for (Map.Entry<String, String> e : initParameters.entrySet()) {\r\n            setInitParameter(e.getKey(), e.getValue(), true);\r\n        }\r\n        return Collections.emptySet();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.PEWebContainerFeatureFactoryImpl.getDefaultAccessLogDateStampPattern",
	"Comment": "gets the default datestamp pattern to be applied to access log files.",
	"Method": "String getDefaultAccessLogDateStampPattern(){\r\n    return \"yyyy-MM-dd\";\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModule.getFileEncoding",
	"Comment": "gets the file encoding of all static resources of this web module.",
	"Method": "String getFileEncoding(){\r\n    return fileEncoding;\r\n}"
}, {
	"Path": "org.apache.catalina.loader.StandardClassLoader.findLoadedResource",
	"Comment": "finds the resource with the given name if it has previously beenloaded and cached by this class loader, and return an input streamto the resource data.if this resource has not been cached, returnnull.",
	"Method": "InputStream findLoadedResource(String name){\r\n    return (null);\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Rule.setNamespaceURI",
	"Comment": "set the namespace uri for which this rule is relevant, if any.",
	"Method": "void setNamespaceURI(String namespaceURI){\r\n    this.namespaceURI = namespaceURI;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.getModulesRoot",
	"Comment": "return the absolute path for location where all the deployedstandalone modules are stored for this server instance.",
	"Method": "File getModulesRoot(){\r\n    return _modulesRoot;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Response.getContentCount",
	"Comment": "return the number of bytes actually written to the output stream.",
	"Method": "int getContentCount(){\r\n    return outputBuffer.getContentWritten();\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.CredentialInterface.check",
	"Comment": "all credential interface declared in the dd should be one of the allowed interface",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    boolean oneFailed = false;\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!descriptor.getOutBoundDefined()) {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.managed.notApplicableForInboundRA\", \"Resource Adapter does not provide outbound communication\"));\r\n        return result;\r\n    }\r\n    Set mechanisms = descriptor.getOutboundResourceAdapter().getAuthMechanisms();\r\n    if (mechanisms.isEmpty()) {\r\n        result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.passed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.AuthMechType.nonexist\", \"No authentication mechanism defined for this resource adapater\"));\r\n        return result;\r\n    }\r\n    Iterator mechIterator = mechanisms.iterator();\r\n    while (mechIterator.hasNext()) {\r\n        AuthMechanism am = (AuthMechanism) mechIterator.next();\r\n        String credInterface = am.getCredentialInterface();\r\n        boolean allowedInterface = false;\r\n        if (credInterface != null) {\r\n            for (int i = 0; i < allowedInterfaces.length; i++) {\r\n                if (credInterface.equals(allowedInterfaces[i])) {\r\n                    allowedInterface = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (!allowedInterface || credInterface == null) {\r\n            oneFailed = true;\r\n            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.failed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.CredentialInterface.failed\", \"Authentication mechanism credential interface [ {0} ] defined in the credential-interface tag is not allowed\", new Object[] { credInterface }));\r\n        }\r\n    }\r\n    if (!oneFailed) {\r\n        result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.passed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.CredentialInterface.passed\", \"All defined authorization mechanism credential interfaces are allowed\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.CheckMgr.loadTestInformationFromPropsFile",
	"Comment": "load all the test names from the property file. each manager has itslist of test to be performed for each archive in a property file.the tests list of a list of class name implementing a particular test",
	"Method": "void loadTestInformationFromPropsFile(){\r\n    if (!test.isEmpty())\r\n        return;\r\n    // NOI18N\r\n    logger.log(Level.FINE, \"com.sun.enterprise.tools.verifier.CheckMgr.TestnamesPropsFile\");\r\n    InputStream is = getTestsFileInputStreamFor(getTestsListFileName());\r\n    try {\r\n        DocumentBuilder db = DocumentBuilderFactory.newInstance().newDocumentBuilder();\r\n        Document doc = db.parse(is);\r\n        NodeList list = doc.getElementsByTagName(\"test\");\r\n        for (int i = 0; i < list.getLength(); i++) {\r\n            Element e = (Element) list.item(i);\r\n            NodeList nl = e.getChildNodes();\r\n            TestInformation ti = new TestInformation();\r\n            for (int j = 0; j < nl.getLength(); j++) {\r\n                String nodeName = nl.item(j).getNodeName();\r\n                if (\"test-class\".equals(nodeName.trim())) {\r\n                    Node el = nl.item(j);\r\n                    ti.setClassName(el.getFirstChild().getNodeValue().trim());\r\n                }\r\n                if (\"minimum-version\".equals(nodeName.trim())) {\r\n                    Node el = nl.item(j);\r\n                    ti.setMinimumVersion(el.getFirstChild().getNodeValue().trim());\r\n                }\r\n                if (\"maximum-version\".equals(nodeName.trim())) {\r\n                    Node el = nl.item(j);\r\n                    ti.setMaximumVersion(el.getFirstChild().getNodeValue().trim());\r\n                }\r\n            }\r\n            test.addElement(ti);\r\n        }\r\n        if ((!verifierFrameworkContext.isPortabilityMode() && getRuntimeDDPresent()))\r\n            readSunONETests(test);\r\n        Vector<TestInformation> testExcluded = getTestFromExcludeList();\r\n        test = getFinalTestList(test, testExcluded);\r\n    } finally {\r\n        is.close();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorSynchronizationImpl.before_completion",
	"Comment": "passes on the before completion operation to the coordinator.",
	"Method": "void before_completion(){\r\n    if (coordinator == null) {\r\n        INTERNAL exc = new INTERNAL(MinorCode.NoCoordinator, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    coordinator.beforeCompletion();\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.GenericParser.newSAXParser",
	"Comment": "create a saxparser configured to support xml scheman and dtd",
	"Method": "SAXParser newSAXParser(Properties properties){\r\n    SAXParserFactory factory = (SAXParserFactory) properties.get(\"SAXParserFactory\");\r\n    SAXParser parser = factory.newSAXParser();\r\n    String schemaLocation = (String) properties.get(\"schemaLocation\");\r\n    String schemaLanguage = (String) properties.get(\"schemaLanguage\");\r\n    try {\r\n        if (schemaLocation != null) {\r\n            parser.setProperty(JAXP_SCHEMA_LANGUAGE, schemaLanguage);\r\n            parser.setProperty(JAXP_SCHEMA_SOURCE, schemaLocation);\r\n        }\r\n    } catch (SAXNotRecognizedException e) {\r\n        if (log.isLoggable(Level.INFO)) {\r\n            log.log(Level.INFO, parser.getClass().getName() + \": \" + e.getMessage() + \" not supported.\");\r\n        }\r\n    }\r\n    return parser;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.services.impl.monitor.GrizzlyMonitoring.registerConnectionQueueStatsProviderGlobal",
	"Comment": "register server wide connection queue statistics provider for a network listener",
	"Method": "void registerConnectionQueueStatsProviderGlobal(String name){\r\n    ConnectionQueueStatsProvider connectionQueueStatsProvider = new ConnectionQueueStatsProviderGlobal(name);\r\n    ConnectionQueueStatsProvider oldConnectionQueueStatsProvider = connectionQueueStatsProvidersMap.put(name, connectionQueueStatsProvider);\r\n    if (oldConnectionQueueStatsProvider != null) {\r\n        StatsProviderManager.unregister(oldConnectionQueueStatsProvider);\r\n    }\r\n    StatsProviderManager.register(CONFIG_ELEMENT, PluginPoint.SERVER, subtreePrefix(name) + \"/connection-queue\", connectionQueueStatsProvider);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.beanclass.EjbClassModifiersFinal.check",
	"Comment": "enterprise java bean class modifiers test.the class must not be final.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    Class c = loadEjbClass(descriptor, result);\r\n    if (c != null) {\r\n        boolean isFinal = false;\r\n        int modifiers = c.getModifiers();\r\n        if (Modifier.isFinal(modifiers)) {\r\n            isFinal = true;\r\n        }\r\n        if (!isFinal) {\r\n            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"[ {0} ] properly declares non-final class modifier.\", new Object[] { descriptor.getEjbClassName() }));\r\n        } else if (isFinal) {\r\n            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Ejb Class [ {0} ] was found, but was declared as final.  The class  [ {1} ] must not be defined as final.\", new Object[] { descriptor.getEjbClassName(), descriptor.getEjbClassName() }));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebComponentDescriptorImpl.getUserDefinedHttpMethods",
	"Comment": "this method return an array of user defined http dodelete, doget,dohead, dooptions, dopost, doput, dotrace methods.it is used for processing web security annotations.",
	"Method": "Method[] getUserDefinedHttpMethods(){\r\n    if (httpMethods == null) {\r\n        httpMethods = new ArrayList<Method>();\r\n        if (isServlet) {\r\n            List<String> searchingMethods = new ArrayList<String>();\r\n            String[] httpMString = new String[] { \"doDelete\", \"doGet\", \"doHead\", \"doOptions\", \"doPost\", \"doPut\", \"doTrace\" };\r\n            for (String s : httpMString) {\r\n                searchingMethods.add(s);\r\n            }\r\n            try {\r\n                Class implClass = Class.forName(implFile, true, Thread.currentThread().getContextClassLoader());\r\n                Class clazz = implClass;\r\n                String packageName = null;\r\n                Package clazzPackage = implClass.getPackage();\r\n                if (clazzPackage != null) {\r\n                    packageName = clazzPackage.getName();\r\n                }\r\n                while (clazz != null && (!clazz.getName().startsWith(\"javax.servlet.\")) && searchingMethods.size() > 0) {\r\n                    Package p = clazz.getPackage();\r\n                    Method[] methods = clazz.getDeclaredMethods();\r\n                    for (Method m : methods) {\r\n                        String methodName = m.getName();\r\n                        if (searchingMethods.contains(methodName)) {\r\n                            Class<?> returnType = m.getReturnType();\r\n                            Class<?>[] parameterTypes = m.getParameterTypes();\r\n                            int modifiers = m.getModifiers();\r\n                            boolean isSamePackage = (p == null && clazzPackage == null) || (p != null && clazzPackage != null && packageName.equals(p.getName()));\r\n                            boolean valid = (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers) || ((!Modifier.isPrivate(modifiers)) && isSamePackage));\r\n                            valid = valid && (void.class.equals(returnType)) && (parameterTypes.length == 2) && (parameterTypes[0].equals(HttpServletRequest.class) && parameterTypes[1].equals(HttpServletResponse.class));\r\n                            if (valid) {\r\n                                httpMethods.add(m);\r\n                                searchingMethods.remove(methodName);\r\n                            }\r\n                            if (searchingMethods.size() == 0) {\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    clazz = clazz.getSuperclass();\r\n                }\r\n            } catch (Throwable t) {\r\n                throw new IllegalStateException(t);\r\n            }\r\n        }\r\n    }\r\n    return httpMethods.toArray(new Method[httpMethods.size()]);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.removeInitParameter",
	"Comment": "remove the specified initialization parameter from this servlet.",
	"Method": "void removeInitParameter(String name){\r\n    synchronized (parameters) {\r\n        parameters.remove(name);\r\n    }\r\n    if (notifyContainerListeners) {\r\n        fireContainerEvent(\"removeInitParameter\", name);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.AdminUtil.startSampling",
	"Comment": "startsamplingstart the sampling window. the sample window determines the durationin which the data is collected. start and stop calls demarcate the the window. the sampling data could be number of transactions committed,rolledback etc and transient data like pending etc. it also resets various counters.",
	"Method": "void startSampling(){\r\n    if (!bSampling) {\r\n        try {\r\n            statisticsLock.acquireWriteLock();\r\n            lSampleEndTime = 0;\r\n            lSampleStartTime = System.currentTimeMillis();\r\n            iCommits = 0;\r\n            iAborts = 0;\r\n            iPending = 0;\r\n            iRecCommits = 0;\r\n            iRecAborts = 0;\r\n            Iterator iter = getAllTransactions().iterator();\r\n            while (iter.hasNext()) {\r\n                CoordinatorImpl coord = (CoordinatorImpl) iter.next();\r\n                if (coord.get_status() == org.omg.CosTransactions.Status.StatusPrepared)\r\n                    iPending++;\r\n            }\r\n            bSampling = true;\r\n        } finally {\r\n            statisticsLock.releaseWriteLock();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.SelectorContext.composeName",
	"Comment": "composes the name of this context with a name relative to this context.",
	"Method": "Name composeName(Name name,Name prefix,String composeName,String name,String prefix){\r\n    return prefix + \"/\" + name;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.DefaultAccessLogFormatterImpl.appendHeaderAuth",
	"Comment": "appends the authorization header of the given request to the given charbuffer.",
	"Method": "void appendHeaderAuth(CharBuffer cb,HttpServletRequest hreq){\r\n    cb.put(QUOTE);\r\n    String auth = hreq.getHeader(HTTP_HEADER_AUTHORIZATION);\r\n    if (auth == null) {\r\n        auth = \"NULL-HEADER-AUTHORIZATION\";\r\n    }\r\n    cb.put(auth);\r\n    cb.put(QUOTE);\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.getEnvironmentPropertyByName",
	"Comment": "returns the environment property object searching on the supplied key.throws an illegal argument exception if no such environment property exists.",
	"Method": "EnvironmentProperty getEnvironmentPropertyByName(String name){\r\n    EnvironmentProperty envProp = _getEnvironmentPropertyByName(name);\r\n    if (envProp != null) {\r\n        return envProp;\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"web.deployment.exceptionwebapphasnoenvpropertybyname\", \"This web app [{0}] has no environment property by the name of [{1}]\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ValveBase.getContainer",
	"Comment": "return the container with which this valve is associated, if any.",
	"Method": "Container getContainer(){\r\n    return (container);\r\n}"
}, {
	"Path": "org.glassfish.admin.mbeanserver.ssl.SSLParams.getSsl3Enabled",
	"Comment": "determines whether ssl3 is enabled. if both ssl2 and ssl3 are enabled for a virtual server, the server tries ssl3encryption first. if that fails, the server tries ssl2 encryption.",
	"Method": "Boolean getSsl3Enabled(){\r\n    return ssl3Enabled;\r\n}"
}, {
	"Path": "org.glassfish.internal.embedded.ScatteredArchive.entries",
	"Comment": "returns an enumeration of the module file entries.all elementsin the enumeration are of type string.each string represents afile name relative to the root of the module.currently under construction",
	"Method": "Enumeration<String> entries(Enumeration<String> entries,String s){\r\n    Enumeration<String> entries = entries();\r\n    Vector<String> prefixedEntries = new Vector();\r\n    while (entries.hasMoreElements()) {\r\n        String entry = (String) entries.nextElement();\r\n        if (entry.startsWith(s))\r\n            prefixedEntries.add(entry);\r\n    }\r\n    return prefixedEntries.elements();\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.mbeanapi.config.StandaloneInstanceTest.getOptionalParameters",
	"Comment": "that number here for each value provided through properties system prop",
	"Method": "Map getOptionalParameters(int instanceNum){\r\n    final Map properties = new HashMap();\r\n    final String props = System.getProperty(\"PROPERTIES\");\r\n    if (props == null)\r\n        return null;\r\n    final String[] specs = props.split(\":\");\r\n    String key, value;\r\n    for (int i = 0; i < specs.length; i++) {\r\n        key = specs[i].substring(0, specs[i].indexOf(\"=\", 0));\r\n        value = specs[i].substring(specs[i].indexOf(\"=\") + 1, specs[i].length());\r\n        key = getLegalKey(key);\r\n        if (key != null) {\r\n            properties.put(key, \"\" + (Integer.parseInt(value) + instanceNum));\r\n        } else {\r\n            throw new Exception(\"PROPERTIES:property key did not match legal key\");\r\n        }\r\n    }\r\n    System.out.println(properties.toString());\r\n    return properties;\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.getLastAccessedTime",
	"Comment": "return the last time the client sent a request associated with thissession, as the number of milliseconds since midnight, january 1, 1970gmt.actions that your application takes, such as getting or settinga value associated with the session, do not affect the access time.",
	"Method": "long getLastAccessedTime(){\r\n    if (!isValid()) {\r\n        throw new IllegalStateException(\"getLastAccessedTime: \" + rb.getString(LogFacade.SESSION_INVALIDATED_EXCEPTION));\r\n    }\r\n    return (this.lastAccessedTime);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.connector.coyote.PECoyoteConnector.requestEndEvent",
	"Comment": "fires probe event related to the fact that the given request is aboutto exit from the web container.",
	"Method": "void requestEndEvent(HttpServletRequest request,Host host,Context context,int statusCode){\r\n    if (requestProbeProvider != null) {\r\n        String appName = null;\r\n        if (context instanceof WebModule) {\r\n            appName = ((WebModule) context).getMonitoringNodeName();\r\n        }\r\n        String hostName = null;\r\n        if (host != null) {\r\n            hostName = host.getName();\r\n        }\r\n        requestProbeProvider.requestEndEvent(appName, hostName, request.getServerName(), request.getServerPort(), request.getContextPath(), request.getServletPath(), statusCode, request.getMethod(), request.getRequestURI());\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHostDeployer.start",
	"Comment": "start an existing web application, attached to the specified contextpath.only starts a web application if it is not running.",
	"Method": "void start(String contextPath){\r\n    if (contextPath == null)\r\n        throw new IllegalArgumentException(rb.getString(LogFacade.CONTEXT_PATH_REQUIRED_EXCEPTION));\r\n    if (!contextPath.equals(\"\") && !contextPath.startsWith(\"/\")) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.INVALID_CONTEXT_PATH_EXCEPTION), contextPath);\r\n        throw new IllegalArgumentException(msg);\r\n    }\r\n    Context context = findDeployedApp(contextPath);\r\n    if (context == null) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.CONTEXT_PATH_NOT_IN_USE), contextPath);\r\n        throw new IllegalArgumentException(msg);\r\n    }\r\n    if (log.isLoggable(Level.INFO)) {\r\n        log.log(Level.INFO, LogFacade.STARTING_WEB_APP_INFO, contextPath);\r\n    }\r\n    try {\r\n        ((Lifecycle) context).start();\r\n    } catch (LifecycleException e) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.STARTING_WEB_APP_FAILED_EXCEPTION), contextPath);\r\n        log.log(Level.SEVERE, msg, e);\r\n        throw new IllegalStateException(msg, e);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutoDeployer.undeployAll",
	"Comment": "do undeployment for all deleted applications in autodeploydir dir.",
	"Method": "void undeployAll(File autoDeployDir,boolean includeSubdir){\r\n    if (directoryScanner == null) {\r\n        directoryScanner = new AutoDeployDirectoryScanner();\r\n    }\r\n    File[] apps = null;\r\n    apps = directoryScanner.getAllFilesForUndeployment(autoDeployDir, includeSubdir);\r\n    if (apps != null) {\r\n        for (int i = 0; i < apps.length && !cancelDeployment; i++) {\r\n            try {\r\n                this.undeploy(apps[i], autoDeployDir, getNameFromFilePath(autoDeployDir, apps[i]));\r\n            } catch (AutoDeploymentException ae) {\r\n            } finally {\r\n                directoryScanner.undeployedEntity(autoDeployDir, apps[i]);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.connector.ConnectorCheckMgrImpl.getTestsListFileName",
	"Comment": "return the configuration file name for the list of tests pertinent to theconnector architecture",
	"Method": "String getTestsListFileName(){\r\n    return testsListFileName;\r\n}"
}, {
	"Path": "org.apache.catalina.util.CustomObjectInputStream.resolveClass",
	"Comment": "load the local class equivalent of the specified stream classdescription, by using the class loader assigned to this context.",
	"Method": "Class resolveClass(ObjectStreamClass classDesc){\r\n    try {\r\n        return Class.forName(classDesc.getName(), false, classLoader);\r\n    } catch (ClassNotFoundException e) {\r\n        try {\r\n            return super.resolveClass(classDesc);\r\n        } catch (ClassNotFoundException e2) {\r\n            throw e;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.Initializer.verifyAndSetResultDir",
	"Comment": "verifies and sets the output directory for keeping the result files.",
	"Method": "boolean verifyAndSetResultDir(String name){\r\n    File outputDir = new File(name);\r\n    if (outputDir.exists()) {\r\n        if (outputDir.isDirectory()) {\r\n            if (outputDir.canWrite()) {\r\n                verifierFrameworkContext.setOutputDirName(name);\r\n                return true;\r\n            } else {\r\n                // NOI18N\r\n                logger.log(// NOI18N\r\n                Level.SEVERE, getClass().getName() + \".log.noPermissions\", new Object[] { name });\r\n                return false;\r\n            }\r\n        } else {\r\n            // NOI18N\r\n            logger.log(// NOI18N\r\n            Level.SEVERE, getClass().getName() + \".log.notADir\", new Object[] { name });\r\n            return false;\r\n        }\r\n    } else {\r\n        // NOI18N\r\n        logger.log(// NOI18N\r\n        Level.SEVERE, getClass().getName() + \".log.noDirExists\", new Object[] { name });\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.reconstruct",
	"Comment": "directs the topcoordinator to recover its state after a failure,based on the given coordinatorlog object.if the topcoordinator has already been defined or recovered, the operation returns immediately. otherwise thetopcoordinator restores the state of its internal objects using theirrecovery operations, which in turn recover their state from thecoordinatorlog object.",
	"Method": "void reconstruct(CoordinatorLog log){\r\n    rollbackOnly = false;\r\n    registered = false;\r\n    registeredSync = false;\r\n    root = false;\r\n    dying = false;\r\n    temporary = false;\r\n    terminator = null;\r\n    logRecord = log;\r\n    name = null;\r\n    nestingInfo = null;\r\n    synchronizations = null;\r\n    tranState = new TransactionState();\r\n    int state = tranState.reconstruct(log);\r\n    if (state == TransactionState.STATE_NONE || state == TransactionState.STATE_COMMITTED || state == TransactionState.STATE_ROLLED_BACK) {\r\n        CoordinatorLog.removeLog(log.localTID);\r\n        destroy();\r\n    } else {\r\n        participants = new RegisteredResources(this);\r\n        participants.reconstruct(log);\r\n        superInfo = new SuperiorInfo();\r\n        superInfo.reconstruct(log, this);\r\n        name = superInfo.globalTID.toString();\r\n        hash = superInfo.globalTID.hashCode();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.ListSystemProperties.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        List<SystemProperty> sysProps = spb.getSystemProperty();\r\n        int length = 0;\r\n        if (sysProps.isEmpty()) {\r\n            final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n            part.setMessage(localStrings.getLocalString(\"NothingToList\", \"Nothing to List.\"));\r\n        } else {\r\n            for (SystemProperty prop : sysProps) {\r\n                final ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n                part.setMessage(prop.getName() + \"=\" + prop.getValue());\r\n                length++;\r\n            }\r\n            report.setMessage(localStrings.getLocalString(\"list.ok\", \"The target {0} contains following {1} system properties\", target, length));\r\n        }\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.system.properties.failed\", \"list-system-properties failed\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.resourcesStart",
	"Comment": "allocate resources, including proxy.return true if initialization was successfull,or false otherwise.",
	"Method": "boolean resourcesStart(){\r\n    boolean ok = true;\r\n    Hashtable<String, String> env = new Hashtable<String, String>();\r\n    if (getParent() != null) {\r\n        env.put(ProxyDirContext.HOST, getParent().getName());\r\n    }\r\n    env.put(ProxyDirContext.CONTEXT, getName());\r\n    try {\r\n        ProxyDirContext proxyDirContext = new ProxyDirContext(env, webappResources);\r\n        if (webappResources instanceof BaseDirContext) {\r\n            ((BaseDirContext) webappResources).setDocBase(getBasePath(getDocBase()));\r\n            ((BaseDirContext) webappResources).allocate();\r\n        }\r\n        this.resources = proxyDirContext;\r\n    } catch (Throwable t) {\r\n        if (log.isLoggable(Level.FINE)) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.STARTING_RESOURCES_EXCEPTION), neutralizeForLog(getName()));\r\n            log.log(Level.SEVERE, msg, t);\r\n        } else {\r\n            log.log(Level.SEVERE, LogFacade.STARTING_RESOURCE_EXCEPTION_MESSAGE, new Object[] { neutralizeForLog(getName()), t.getMessage() });\r\n        }\r\n        ok = false;\r\n    }\r\n    return ok;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setXmlValidation",
	"Comment": "set the validation feature of the xml parser used whenparsing xml instances.",
	"Method": "void setXmlValidation(boolean webXmlValidation){\r\n    this.webXmlValidation = webXmlValidation;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.WebTestsUtil.allTestsFinished",
	"Comment": "notification that all tests pertinent to a verifier check manager have been completed",
	"Method": "void allTestsFinished(EventObject e){\r\n    if ((warFile != null) && (warFile.exists())) {\r\n        deleteDirectory(warFile.getAbsolutePath());\r\n    }\r\n    warFile = null;\r\n    util = null;\r\n    cl = null;\r\n    WebCheckMgrImpl.removeVerifierEventsListener(this);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Response.getContext",
	"Comment": "return the context within which this request is being processed.",
	"Method": "Context getContext(){\r\n    return request.getContext();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.ControlImpl.setTranState",
	"Comment": "sets the state of the transaction as the control object knows it.no checking is done to verify the state change is valid.",
	"Method": "void setTranState(Status newState){\r\n    tranState = newState;\r\n}"
}, {
	"Path": "org.glassfish.admin.mbeanserver.ssl.SSLClientConfigurator.getJSSECipher",
	"Comment": "converts the given cipher suite name to the corresponding jsse cipher.",
	"Method": "String getJSSECipher(String cipher){\r\n    final CipherInfo ci = CipherInfo.getCipherInfo(cipher);\r\n    return ((ci != null) ? ci.getCipherName() : null);\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.PartItem.isInMemory",
	"Comment": "provides a hint as to whether or not the file contents will be readfrom memory.",
	"Method": "boolean isInMemory(){\r\n    if (cachedContent != null) {\r\n        return true;\r\n    }\r\n    return dfos.isInMemory();\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.JavaEETransactionManagerSimplified.setPurgeCancelledTtransactionsAfter",
	"Comment": "modify the value to be used to purge transaction tasks after the specified number of cancelled tasks.",
	"Method": "void setPurgeCancelledTtransactionsAfter(int num){\r\n    purgeCancelledTtransactions = num;\r\n}"
}, {
	"Path": "org.glassfish.internal.data.ApplicationInfo.getSniffers",
	"Comment": "returns the list of sniffers that participated in loaded thisapplication",
	"Method": "Collection<Sniffer> getSniffers(){\r\n    List<Sniffer> sniffers = new ArrayList<Sniffer>();\r\n    for (EngineRef ref : engines) {\r\n        sniffers.add(ref.getContainerInfo().getSniffer());\r\n    }\r\n    for (ModuleInfo module : modules) {\r\n        sniffers.addAll(module.getSniffers());\r\n    }\r\n    return sniffers;\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.Descriptor.addDescriptorExtension",
	"Comment": "add a child descriptor to the parent descriptor as an extension.",
	"Method": "void addDescriptorExtension(T dde){\r\n    List<T> descriptorList = (List<T>) descriptorExtensions.get(dde.getClass());\r\n    if (descriptorList == null) {\r\n        descriptorList = new ArrayList<T>();\r\n        descriptorExtensions.put(dde.getClass(), descriptorList);\r\n    }\r\n    descriptorList.add(dde);\r\n}"
}, {
	"Path": "testmbeans.OneClassDynamicMBean.setAttribute",
	"Comment": "sets the value of the specified attribute of the dynamicmbean.",
	"Method": "void setAttribute(Attribute attribute){\r\n    if (attribute.getName().equals(\"A1\")) {\r\n    } else if (attribute.getName().equals(\"A2\")) {\r\n    } else if (attribute.getName().equals(\"A3\")) {\r\n    } else\r\n        throw new AttributeNotFoundException(\"Unknown Attribute \" + attribute.getName());\r\n}"
}, {
	"Path": "org.apache.catalina.core.ContainerBase.stop",
	"Comment": "gracefully shut down active use of the public methods of this component.",
	"Method": "void stop(){\r\n    if (!started) {\r\n        if (log.isLoggable(Level.INFO)) {\r\n            log.log(Level.INFO, LogFacade.CONTAINER_NOT_STARTED_EXCEPTION, logName());\r\n        }\r\n        return;\r\n    }\r\n    lifecycle.fireLifecycleEvent(BEFORE_STOP_EVENT, null);\r\n    threadStop();\r\n    lifecycle.fireLifecycleEvent(STOP_EVENT, null);\r\n    started = false;\r\n    if (pipeline instanceof Lifecycle) {\r\n        ((Lifecycle) pipeline).stop();\r\n    }\r\n    Container[] children = findChildren();\r\n    for (int i = 0; i < children.length; i++) {\r\n        if (children[i] instanceof Lifecycle) {\r\n            try {\r\n                ((Lifecycle) children[i]).stop();\r\n            } catch (Throwable t) {\r\n                String msg = MessageFormat.format(rb.getString(LogFacade.ERROR_STOPPING_CONTAINER), children[i]);\r\n                log.log(Level.SEVERE, msg, t);\r\n            }\r\n        }\r\n    }\r\n    children = findChildren();\r\n    for (int i = 0; i < children.length; i++) {\r\n        removeChild(children[i]);\r\n    }\r\n    if ((resources != null) && (resources instanceof Lifecycle)) {\r\n        ((Lifecycle) resources).stop();\r\n    }\r\n    if ((realm != null) && (realm instanceof Lifecycle)) {\r\n        ((Lifecycle) realm).stop();\r\n    }\r\n    if ((manager != null) && (manager instanceof Lifecycle)) {\r\n        ((Lifecycle) manager).stop();\r\n    }\r\n    if ((logger != null) && (logger instanceof Lifecycle)) {\r\n        ((Lifecycle) logger).stop();\r\n    }\r\n    if ((loader != null) && (loader instanceof Lifecycle)) {\r\n        ((Lifecycle) loader).stop();\r\n    }\r\n    lifecycle.fireLifecycleEvent(AFTER_STOP_EVENT, null);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.getSessionCookieConfig",
	"Comment": "gets the sessioncookieconfig object through which variousproperties of the session tracking cookies created on behalf of thisservletcontext may be configured.",
	"Method": "SessionCookieConfig getSessionCookieConfig(){\r\n    if (SecurityUtil.isPackageProtectionEnabled()) {\r\n        return (SessionCookieConfig) doPrivileged(\"getSessionCookieConfig\", null);\r\n    } else {\r\n        return context.getSessionCookieConfig();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmpFieldAccessor.runIndividualCmpFieldTest",
	"Comment": "run an individual verifier test of a declated cmp field of the class",
	"Method": "boolean runIndividualCmpFieldTest(Descriptor entity,Descriptor persistentField,Class c,Result result){\r\n    return isAccessorDeclared(persistentField.getName(), null, c, result);\r\n}"
}, {
	"Path": "com.sun.enterprise.util.StringUtils.cat",
	"Comment": "concatenate a list of strings, putting a separator in between each one.if the list is one string, then the separator is not used.the separator will never be added to the start or end of the returnedstring.when empty or null strings are encountered in the list of stringsthey are ignore.",
	"Method": "String cat(String separator,String list){\r\n    StringBuilder sb = new StringBuilder();\r\n    boolean first = true;\r\n    for (String s : list) {\r\n        if (!StringUtils.ok(s)) {\r\n            continue;\r\n        }\r\n        if (!first) {\r\n            sb.append(separator);\r\n        } else {\r\n            first = false;\r\n        }\r\n        sb.append(s);\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.DefaultTransactionService.shutdown",
	"Comment": "request the transaction service to stop any further transactional activity.",
	"Method": "void shutdown(boolean immediate){\r\n    if (namingContext != null)\r\n        try {\r\n            NameComponent nc = new NameComponent(TransactionFactoryHelper.id(), \"\");\r\n            NameComponent[] path = { nc };\r\n            namingContext.unbind(path);\r\n            namingContext = null;\r\n        } catch (Exception exc) {\r\n        }\r\n    TransactionFactoryImpl.deactivate();\r\n    CurrentImpl.deactivate();\r\n    currentInstance.shutdown(immediate);\r\n    currentInstance = null;\r\n    factoryInstance = null;\r\n    active = false;\r\n}"
}, {
	"Path": "org.apache.catalina.servlets.CGIServlet.printServletEnvironment",
	"Comment": "prints out important servlet api and container informationcopied from snoopallservlet by craig r. mcclanahan",
	"Method": "void printServletEnvironment(ServletOutputStream out,HttpServletRequest req,HttpServletResponse res){\r\n    out.println(\"<h1>ServletRequest Properties<\/h1>\");\r\n    out.println(\"<ul>\");\r\n    Enumeration<String> attrs = req.getAttributeNames();\r\n    while (attrs.hasMoreElements()) {\r\n        String attr = attrs.nextElement();\r\n        out.println(\"<li><b>attribute<\/b> \" + HtmlEntityEncoder.encodeXSS(attr) + \" = \" + HtmlEntityEncoder.encodeXSS(req.getAttribute(attr)));\r\n    }\r\n    out.println(\"<li><b>characterEncoding<\/b> = \" + HtmlEntityEncoder.encodeXSS(req.getCharacterEncoding()));\r\n    out.println(\"<li><b>contentLength<\/b> = \" + req.getContentLength());\r\n    out.println(\"<li><b>contentType<\/b> = \" + HtmlEntityEncoder.encodeXSS(req.getContentType()));\r\n    Enumeration<Locale> locales = req.getLocales();\r\n    while (locales.hasMoreElements()) {\r\n        Locale locale = locales.nextElement();\r\n        out.println(\"<li><b>locale<\/b> = \" + HtmlEntityEncoder.encodeXSS(locale));\r\n    }\r\n    Enumeration<String> params = req.getParameterNames();\r\n    while (params.hasMoreElements()) {\r\n        String param = params.nextElement();\r\n        String[] values = req.getParameterValues(param);\r\n        for (int i = 0; i < values.length; i++) out.println(\"<li><b>parameter<\/b> \" + HtmlEntityEncoder.encodeXSS(param) + \" = \" + HtmlEntityEncoder.encodeXSS(values[i]));\r\n    }\r\n    out.println(\"<li><b>protocol<\/b> = \" + req.getProtocol());\r\n    out.println(\"<li><b>remoteAddr<\/b> = \" + req.getRemoteAddr());\r\n    out.println(\"<li><b>remoteHost<\/b> = \" + req.getRemoteHost());\r\n    out.println(\"<li><b>scheme<\/b> = \" + req.getScheme());\r\n    out.println(\"<li><b>secure<\/b> = \" + req.isSecure());\r\n    out.println(\"<li><b>serverName<\/b> = \" + HtmlEntityEncoder.encodeXSS(req.getServerName()));\r\n    out.println(\"<li><b>serverPort<\/b> = \" + req.getServerPort());\r\n    out.println(\"<\/ul>\");\r\n    out.println(\"<hr>\");\r\n    out.println(\"<h1>HttpServletRequest Properties<\/h1>\");\r\n    out.println(\"<ul>\");\r\n    out.println(\"<li><b>authType<\/b> = \" + req.getAuthType());\r\n    out.println(\"<li><b>contextPath<\/b> = \" + req.getContextPath());\r\n    Cookie[] cookies = req.getCookies();\r\n    if (cookies != null) {\r\n        for (int i = 0; i < cookies.length; i++) out.println(\"<li><b>cookie<\/b> \" + HtmlEntityEncoder.encodeXSS(cookies[i].getName()) + \" = \" + HtmlEntityEncoder.encodeXSS(cookies[i].getValue()));\r\n    }\r\n    Enumeration<String> headers = req.getHeaderNames();\r\n    while (headers.hasMoreElements()) {\r\n        String header = headers.nextElement();\r\n        out.println(\"<li><b>header<\/b> \" + HtmlEntityEncoder.encodeXSS(header) + \" = \" + HtmlEntityEncoder.encodeXSS(req.getHeader(header)));\r\n    }\r\n    out.println(\"<li><b>method<\/b> = \" + HtmlEntityEncoder.encodeXSS(req.getMethod()));\r\n    out.println(\"<li><a name=\\\"pathInfo\\\"><b>pathInfo<\/b><\/a> = \" + HtmlEntityEncoder.encodeXSS(req.getPathInfo()));\r\n    out.println(\"<li><b>pathTranslated<\/b> = \" + HtmlEntityEncoder.encodeXSS(req.getPathTranslated()));\r\n    out.println(\"<li><b>queryString<\/b> = \" + HtmlEntityEncoder.encodeXSS(req.getQueryString()));\r\n    out.println(\"<li><b>remoteUser<\/b> = \" + HtmlEntityEncoder.encodeXSS(req.getRemoteUser()));\r\n    out.println(\"<li><b>requestedSessionId<\/b> = \" + HtmlEntityEncoder.encodeXSS(req.getRequestedSessionId()));\r\n    out.println(\"<li><b>requestedSessionIdFromCookie<\/b> = \" + req.isRequestedSessionIdFromCookie());\r\n    out.println(\"<li><b>requestedSessionIdFromURL<\/b> = \" + req.isRequestedSessionIdFromURL());\r\n    out.println(\"<li><b>requestedSessionIdValid<\/b> = \" + req.isRequestedSessionIdValid());\r\n    out.println(\"<li><b>requestURI<\/b> = \" + HtmlEntityEncoder.encodeXSS(req.getRequestURI()));\r\n    out.println(\"<li><b>servletPath<\/b> = \" + req.getServletPath());\r\n    out.println(\"<li><b>userPrincipal<\/b> = \" + HtmlEntityEncoder.encodeXSS(req.getUserPrincipal()));\r\n    out.println(\"<\/ul>\");\r\n    out.println(\"<hr>\");\r\n    out.println(\"<h1>ServletRequest Attributes<\/h1>\");\r\n    out.println(\"<ul>\");\r\n    attrs = req.getAttributeNames();\r\n    while (attrs.hasMoreElements()) {\r\n        String attr = attrs.nextElement();\r\n        out.println(\"<li><b>\" + HtmlEntityEncoder.encodeXSS(attr) + \"<\/b> = \" + HtmlEntityEncoder.encodeXSS(req.getAttribute(attr)));\r\n    }\r\n    out.println(\"<\/ul>\");\r\n    out.println(\"<hr>\");\r\n    HttpSession session = req.getSession(false);\r\n    if (session != null) {\r\n        out.println(\"<h1>HttpSession Properties<\/h1>\");\r\n        out.println(\"<ul>\");\r\n        out.println(\"<li><b>id<\/b> = \" + HtmlEntityEncoder.encodeXSS(session.getId()));\r\n        out.println(\"<li><b>creationTime<\/b> = \" + new Date(session.getCreationTime()));\r\n        out.println(\"<li><b>lastAccessedTime<\/b> = \" + new Date(session.getLastAccessedTime()));\r\n        out.println(\"<li><b>maxInactiveInterval<\/b> = \" + session.getMaxInactiveInterval());\r\n        out.println(\"<\/ul>\");\r\n        out.println(\"<hr>\");\r\n        out.println(\"<h1>HttpSession Attributes<\/h1>\");\r\n        out.println(\"<ul>\");\r\n        attrs = session.getAttributeNames();\r\n        while (attrs.hasMoreElements()) {\r\n            String attr = attrs.nextElement();\r\n            out.println(\"<li><b>\" + HtmlEntityEncoder.encodeXSS(attr) + \"<\/b> = \" + HtmlEntityEncoder.encodeXSS(session.getAttribute(attr)));\r\n        }\r\n        out.println(\"<\/ul>\");\r\n        out.println(\"<hr>\");\r\n    }\r\n    out.println(\"<h1>ServletConfig Properties<\/h1>\");\r\n    out.println(\"<ul>\");\r\n    out.println(\"<li><b>servletName<\/b> = \" + getServletConfig().getServletName());\r\n    out.println(\"<\/ul>\");\r\n    out.println(\"<hr>\");\r\n    out.println(\"<h1>ServletConfig Initialization Parameters<\/h1>\");\r\n    out.println(\"<ul>\");\r\n    params = getServletConfig().getInitParameterNames();\r\n    while (params.hasMoreElements()) {\r\n        String param = params.nextElement();\r\n        String value = getServletConfig().getInitParameter(param);\r\n        out.println(\"<li><b>\" + param + \"<\/b> = \" + value);\r\n    }\r\n    out.println(\"<\/ul>\");\r\n    out.println(\"<hr>\");\r\n    out.println(\"<h1>ServletContext Properties<\/h1>\");\r\n    out.println(\"<ul>\");\r\n    out.println(\"<li><b>majorVersion<\/b> = \" + getServletContext().getMajorVersion());\r\n    out.println(\"<li><b>minorVersion<\/b> = \" + getServletContext().getMinorVersion());\r\n    out.println(\"<li><b>realPath('/')<\/b> = \" + getServletContext().getRealPath(\"/\"));\r\n    out.println(\"<li><b>serverInfo<\/b> = \" + getServletContext().getServerInfo());\r\n    out.println(\"<\/ul>\");\r\n    out.println(\"<hr>\");\r\n    out.println(\"<h1>ServletContext Initialization Parameters<\/h1>\");\r\n    out.println(\"<ul>\");\r\n    params = getServletContext().getInitParameterNames();\r\n    while (params.hasMoreElements()) {\r\n        String param = params.nextElement();\r\n        String value = getServletContext().getInitParameter(param);\r\n        out.println(\"<li><b>\" + param + \"<\/b> = \" + value);\r\n    }\r\n    out.println(\"<\/ul>\");\r\n    out.println(\"<hr>\");\r\n    out.println(\"<h1>ServletContext Attributes<\/h1>\");\r\n    out.println(\"<ul>\");\r\n    attrs = getServletContext().getAttributeNames();\r\n    while (attrs.hasMoreElements()) {\r\n        String attr = attrs.nextElement();\r\n        out.println(\"<li><b>\" + attr + \"<\/b> = \" + getServletContext().getAttribute(attr));\r\n    }\r\n    out.println(\"<\/ul>\");\r\n    out.println(\"<hr>\");\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.get_txcontext",
	"Comment": "creates a propagationcontext which contains the information which wouldnormally be passed implicitly via the costspropagation interfaces.",
	"Method": "PropagationContext get_txcontext(){\r\n    if (tranState == null || tranState.state != TransactionState.STATE_ACTIVE || rollbackOnly) {\r\n        Unavailable exc = new Unavailable();\r\n        throw exc;\r\n    }\r\n    long timeLeft = TimeoutManager.timeLeft(superInfo.localTID);\r\n    int timeout = 0;\r\n    if (timeLeft > 0) {\r\n        timeout = (int) timeLeft / 1000;\r\n    } else if (timeLeft == 0) {\r\n        TimeoutManager.timeoutCoordinator(superInfo.localTID, TimeoutManager.ACTIVE_TIMEOUT);\r\n        TRANSACTION_ROLLEDBACK exc = new TRANSACTION_ROLLEDBACK(0, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    TransIdentity current = new TransIdentity(this.object(), null, superInfo.globalTID.realTID);\r\n    TransIdentity[] parents = getAncestors();\r\n    if (emptyData == null) {\r\n        emptyData = Configuration.getORB().create_any();\r\n        emptyData.insert_boolean(false);\r\n    }\r\n    PropagationContext result = new PropagationContext(timeout, current, parents, emptyData);\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.session.SessionCookieConfig.getPath",
	"Comment": "return the path that is set when the session tracking cookie iscreated.",
	"Method": "String getPath(){\r\n    return _path;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.common.JsonActionReporter.quote",
	"Comment": "produce a string in double quotes with backslash sequences in all theright places.",
	"Method": "String quote(String string){\r\n    if (string == null || string.length() == 0) {\r\n        return \"\\\"\\\"\";\r\n    }\r\n    char b;\r\n    char c = 0;\r\n    int i;\r\n    int len = string.length();\r\n    StringBuilder sb = new StringBuilder(len + 4);\r\n    String t;\r\n    sb.append('\"');\r\n    for (i = 0; i < len; i += 1) {\r\n        b = c;\r\n        c = string.charAt(i);\r\n        switch(c) {\r\n            case '\\\\':\r\n            case '\"':\r\n                sb.append('\\\\');\r\n                sb.append(c);\r\n                break;\r\n            case '/':\r\n                if (b == '<') {\r\n                    sb.append('\\\\');\r\n                }\r\n                sb.append(c);\r\n                break;\r\n            case '\\b':\r\n                sb.append(\"\\\\b\");\r\n                break;\r\n            case '\\t':\r\n                sb.append(\"\\\\t\");\r\n                break;\r\n            case '\\n':\r\n                sb.append(\"\\\\n\");\r\n                break;\r\n            case '\\f':\r\n                sb.append(\"\\\\f\");\r\n                break;\r\n            case '\\r':\r\n                sb.append(\"\\\\r\");\r\n                break;\r\n            default:\r\n                if (c < ' ') {\r\n                    t = \"000\" + Integer.toHexString(c);\r\n                    sb.append(\"\\\%u\" + t.substring(t.length() - 4));\r\n                } else {\r\n                    sb.append(c);\r\n                }\r\n        }\r\n    }\r\n    sb.append('\"');\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.ReportHandler.addResultsToDocument",
	"Comment": "this api adds each result to the document tree based on the status.",
	"Method": "void addResultsToDocument(String status,Vector resultVector){\r\n    for (int i = 0; i < resultVector.size(); i++) {\r\n        Enumeration en;\r\n        Result r = (Result) resultVector.get(i);\r\n        String moduleName = r.getModuleName();\r\n        if (status == FAILED) {\r\n            en = r.getErrorDetails().elements();\r\n        } else if (status == WARNING) {\r\n            en = r.getWarningDetails().elements();\r\n        } else if (status == PASSED)\r\n            en = r.getGoodDetails().elements();\r\n        else\r\n            en = r.getNaDetails().elements();\r\n        createNode(moduleName, status);\r\n        addToDocument(moduleName, status, r, en);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.weld.connector.WeldUtils.isImplicitBeanArchive",
	"Comment": "determine whether the specified archive is an implicit bean deployment archive.",
	"Method": "boolean isImplicitBeanArchive(DeploymentContext context,ReadableArchive archive,boolean isImplicitBeanArchive,DeploymentContext context,URI archivePath){\r\n    return (isImplicitBeanDiscoveryEnabled(context) && hasCDIEnablingAnnotations(context, archivePath));\r\n}"
}, {
	"Path": "com.sun.appserv.web.taglibs.cache.CacheTag.doAfterBody",
	"Comment": "doafterbody is called only if the body was evaluated. this would happenif nocache is specified in which case this should do nothingif there was no cached response in which case the response datais obtained from the bodycontent and cachedif the response has expired in which case the cache is refreshed",
	"Method": "int doAfterBody(){\r\n    if (_useCachedResponse) {\r\n        if (bodyContent != null) {\r\n            String content = bodyContent.getString().trim();\r\n            CacheEntry entry = new CacheEntry(content, _timeout);\r\n            _cache.put(_key, entry);\r\n            try {\r\n                bodyContent.writeOut(bodyContent.getEnclosingWriter());\r\n            } catch (java.io.IOException ex) {\r\n                throw new JspException(ex);\r\n            }\r\n        }\r\n    }\r\n    return SKIP_BODY;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.CompositeResource.executeDeleteCommand",
	"Comment": "execute a delete admincommand with the specified parameters.",
	"Method": "ActionReporter executeDeleteCommand(String command,ActionReporter executeDeleteCommand,String command,ParameterMap parameters){\r\n    return getCompositeUtil().executeDeleteCommand(getSubject(), command, parameters);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.cci.CCITest.isCCIImplemented",
	"Comment": "checks whether the resource adapater is implementing the cci interfaces",
	"Method": "boolean isCCIImplemented(ConnectorDescriptor descriptor,Result result){\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    OutboundResourceAdapter outboundRA = descriptor.getOutboundResourceAdapter();\r\n    if (outboundRA == null) {\r\n        return false;\r\n    }\r\n    Set connDefs = outboundRA.getConnectionDefs();\r\n    Iterator iter = connDefs.iterator();\r\n    while (iter.hasNext()) {\r\n        ConnectionDefDescriptor connDefDesc = (ConnectionDefDescriptor) iter.next();\r\n        String intf = connDefDesc.getConnectionFactoryIntf();\r\n        Class implClass = null;\r\n        try {\r\n            implClass = Class.forName(intf, false, getVerifierContext().getClassLoader());\r\n        } catch (ClassNotFoundException e) {\r\n            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.failed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.ConnectorTest.isClassLoadable.failed\", \"The class [ {0} ] is not contained in the archive file\", new Object[] { intf }));\r\n            continue;\r\n        }\r\n        if (isImplementorOf(implClass, \"javax.resource.cci.ConnectionFactory\")) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.SingleSignOn.associate",
	"Comment": "associate the specified single sign on identifier with thespecified session.",
	"Method": "void associate(String ssoId,long ssoVersion,Session session){\r\n    if (!started) {\r\n        return;\r\n    }\r\n    if (debug >= 1)\r\n        log(rb.getString(LogFacade.ASSOCIATE_SSO_WITH_SESSION_INFO));\r\n    SingleSignOnEntry sso = lookup(ssoId, ssoVersion);\r\n    if (sso != null) {\r\n        session.setSsoId(ssoId);\r\n        session.setSsoVersion(ssoVersion);\r\n        sso.addSession(this, session);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionManagerImpl.getStatus",
	"Comment": "obtain the status of the transaction associated with the current thread.",
	"Method": "int getStatus(){\r\n    try {\r\n        Status status = current.get_status();\r\n        return mapStatus(status);\r\n    } catch (Exception ex) {\r\n        throw new SystemException(ex.toString());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.ContextFacade.getUnwrappedContext",
	"Comment": "gets the underlying standardcontext to which thiscontextfacade is ultimately delegating.",
	"Method": "WebModule getUnwrappedContext(){\r\n    return context;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityConstraint.addAuthRole",
	"Comment": "add an authorization role, which is a role name that will bepermitted access to the resources protected by this security constraint.",
	"Method": "void addAuthRole(String authRole){\r\n    if (authRole == null)\r\n        return;\r\n    if (\"*\".equals(authRole)) {\r\n        allRoles = true;\r\n        return;\r\n    }\r\n    String[] results = new String[authRoles.length + 1];\r\n    for (int i = 0; i < authRoles.length; i++) results[i] = authRoles[i];\r\n    results[authRoles.length] = authRole;\r\n    authRoles = results;\r\n    authConstraint = true;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.stringsubs.TestStringSubstitutionFactory.validateTestFile",
	"Comment": "validate if the substitution occurred properly in the test file.",
	"Method": "boolean validateTestFile(File testFile){\r\n    BufferedReader reader = null;\r\n    try {\r\n        reader = new BufferedReader(new InputStreamReader(new FileInputStream(testFile)));\r\n        String afterSubstitutionLine = null;\r\n        int i = 0;\r\n        while ((afterSubstitutionLine = reader.readLine()) != null) {\r\n            switch(i++) {\r\n                case 0:\r\n                    if (!afterSubstitutionLine.equals(\"Substitute REPLACED_JAVA_HOME REPLACED_JAVA @MW_\")) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                case 1:\r\n                    if (!afterSubstitutionLine.equals(\"HOME@\")) {\r\n                        return false;\r\n                    }\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        return false;\r\n    } finally {\r\n        if (reader != null) {\r\n            try {\r\n                reader.close();\r\n            } catch (IOException e) {\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RWLock.releaseReadLock",
	"Comment": "this method is used to release a read lock. it also notifies any waiting writer threadthat it could now acquire a write lock.",
	"Method": "void releaseReadLock(){\r\n    if (--currentReaders == 0)\r\n        notifyWriters();\r\n}"
}, {
	"Path": "org.apache.naming.resources.BaseDirContext.lookupLink",
	"Comment": "retrieves the named object, following links except for the terminal atomic component of the name.",
	"Method": "Object lookupLink(Name name,Object lookupLink,String name){\r\n    return lookupLink(name.toString());\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogRestartDescriptor.equals",
	"Comment": "determines whether the target object is equal to the parameter.",
	"Method": "boolean equals(LogRestartDescriptor other){\r\n    return (restartValid == other.restartValid && restartDataLength == other.restartDataLength && timeStamp == other.timeStamp);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.CreateRemoteNodeCommand.checkDefaults",
	"Comment": "sometimes the console passes an empty string for a parameter. thismakes sure those are defaulted correctly.",
	"Method": "void checkDefaults(){\r\n    if (!StringUtils.ok(installdir)) {\r\n        installdir = NodeUtils.NODE_DEFAULT_INSTALLDIR;\r\n    }\r\n    if (!StringUtils.ok(remoteUser)) {\r\n        remoteUser = NodeUtils.NODE_DEFAULT_REMOTE_USER;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.InstanceEvent.getWrapper",
	"Comment": "return the wrapper managing the servlet instance for which thisevent occurred.",
	"Method": "Wrapper getWrapper(){\r\n    return (Wrapper) getSource();\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardManager.setPathname",
	"Comment": "set the session persistence pathname to the specified value.if nopersistence support is desired, set the pathname to null.",
	"Method": "void setPathname(String pathname){\r\n    String oldPathname = this.pathname;\r\n    this.pathname = pathname;\r\n    support.firePropertyChange(\"pathname\", oldPathname, this.pathname);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Response.toEncoded",
	"Comment": "return the specified url with the specified session identifiersuitably encoded.",
	"Method": "String toEncoded(String url,String sessionId,String toEncoded,String url,String sessionId,String sessionVersion){\r\n    if (url == null || sessionId == null)\r\n        return url;\r\n    String path = url;\r\n    String query = \"\";\r\n    String anchor = \"\";\r\n    int question = url.indexOf('?');\r\n    if (question >= 0) {\r\n        path = url.substring(0, question);\r\n        query = url.substring(question);\r\n    }\r\n    int pound = path.indexOf('#');\r\n    if (pound >= 0) {\r\n        anchor = path.substring(pound);\r\n        path = path.substring(0, pound);\r\n    }\r\n    StringBuilder sb = new StringBuilder(path);\r\n    if (sb.length() > 0) {\r\n        StandardContext ctx = (StandardContext) getContext();\r\n        String sessionParamName = ctx != null ? ctx.getSessionParameterName() : Globals.SESSION_PARAMETER_NAME;\r\n        sb.append(\";\" + sessionParamName + \"=\");\r\n        sb.append(sessionId);\r\n        if (ctx != null && ctx.getJvmRoute() != null) {\r\n            sb.append('.').append(ctx.getJvmRoute());\r\n        }\r\n        String jrouteId = request.getHeader(Constants.PROXY_JROUTE);\r\n        if (jrouteId != null) {\r\n            sb.append(\":\");\r\n            sb.append(jrouteId);\r\n        }\r\n        final Session session = request.getSessionInternal(false);\r\n        if (session != null) {\r\n            String replicaLocation = (String) session.getNote(Globals.JREPLICA_SESSION_NOTE);\r\n            if (replicaLocation != null) {\r\n                sb.append(Globals.JREPLICA_PARAMETER);\r\n                sb.append(replicaLocation);\r\n            }\r\n        }\r\n        if (sessionVersion != null) {\r\n            sb.append(Globals.SESSION_VERSION_PARAMETER);\r\n            sb.append(sessionVersion);\r\n        }\r\n    }\r\n    sb.append(anchor);\r\n    sb.append(query);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.setLogFile",
	"Comment": "configures this virtual server with the specified log file.",
	"Method": "void setLogFile(String logFile,String logLevel,String logServiceFile){\r\n    boolean noCustomLog = (logFile == null || (logServiceFile != null && new File(logFile).equals(new File(logServiceFile))));\r\n    if ((fileLoggerHandler == null && noCustomLog) || (fileLoggerHandler != null && logFile != null && logFile.equals(fileLoggerHandler.getLogFile()))) {\r\n        return;\r\n    }\r\n    Logger newLogger = null;\r\n    FileLoggerHandler oldHandler = fileLoggerHandler;\r\n    if (oldHandler != null) {\r\n        _logger.removeHandler(oldHandler);\r\n    }\r\n    if (noCustomLog) {\r\n        fileLoggerHandler = null;\r\n        newLogger = _logger;\r\n    } else {\r\n        String lname = _logger.getName() + \"._vs.\" + getID();\r\n        newLogger = LogManager.getLogManager().getLogger(lname);\r\n        if (newLogger == null) {\r\n            newLogger = new Logger(lname, null) {\r\n                @Override\r\n                public void log(LogRecord record) {\r\n                    if (record.getResourceBundle() == null) {\r\n                        ResourceBundle bundle = getResourceBundle();\r\n                        if (bundle != null) {\r\n                            record.setResourceBundle(bundle);\r\n                        }\r\n                    }\r\n                    record.setThreadID((int) Thread.currentThread().getId());\r\n                    super.log(record);\r\n                }\r\n                @Override\r\n                public ResourceBundle getResourceBundle() {\r\n                    return rb;\r\n                }\r\n                @Override\r\n                public synchronized void addHandler(Handler handler) {\r\n                    super.addHandler(handler);\r\n                    if (handler instanceof FileLoggerHandler) {\r\n                        ((FileLoggerHandler) handler).associate();\r\n                    }\r\n                }\r\n                @Override\r\n                public synchronized void removeHandler(Handler handler) {\r\n                    if (!(handler instanceof FileLoggerHandler)) {\r\n                        super.removeHandler(handler);\r\n                    } else {\r\n                        boolean hasHandler = false;\r\n                        Handler[] hs = getHandlers();\r\n                        if (hs != null) {\r\n                            for (Handler h : hs) {\r\n                                if (h == handler) {\r\n                                    hasHandler = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (hasHandler) {\r\n                            super.removeHandler(handler);\r\n                            ((FileLoggerHandler) handler).disassociate();\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n            synchronized (Logger.class) {\r\n                LogManager.getLogManager().addLogger(newLogger);\r\n            }\r\n        }\r\n        Handler[] handlers = newLogger.getHandlers();\r\n        if (handlers != null) {\r\n            for (Handler h : handlers) {\r\n                newLogger.removeHandler(h);\r\n            }\r\n        }\r\n        Logger rootLogger = Logger.global.getParent();\r\n        if (rootLogger != null) {\r\n            Handler[] rootHandlers = rootLogger.getHandlers();\r\n            if (rootHandlers != null) {\r\n                for (Handler h : rootHandlers) {\r\n                    if (!(h instanceof GFFileHandler)) {\r\n                        newLogger.addHandler(h);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        fileLoggerHandler = fileLoggerHandlerFactory.getHandler(logFile);\r\n        newLogger.addHandler(fileLoggerHandler);\r\n        newLogger.setUseParentHandlers(false);\r\n    }\r\n    setLogger(newLogger, logLevel);\r\n    close(oldHandler);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.setLogFile",
	"Comment": "configures this virtual server with the specified log file.",
	"Method": "void setLogFile(String logFile,String logLevel,String logServiceFile){\r\n    if (record.getResourceBundle() == null) {\r\n        ResourceBundle bundle = getResourceBundle();\r\n        if (bundle != null) {\r\n            record.setResourceBundle(bundle);\r\n        }\r\n    }\r\n    record.setThreadID((int) Thread.currentThread().getId());\r\n    super.log(record);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.setLogFile",
	"Comment": "configures this virtual server with the specified log file.",
	"Method": "void setLogFile(String logFile,String logLevel,String logServiceFile){\r\n    return rb;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.setLogFile",
	"Comment": "configures this virtual server with the specified log file.",
	"Method": "void setLogFile(String logFile,String logLevel,String logServiceFile){\r\n    super.addHandler(handler);\r\n    if (handler instanceof FileLoggerHandler) {\r\n        ((FileLoggerHandler) handler).associate();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.setLogFile",
	"Comment": "configures this virtual server with the specified log file.",
	"Method": "void setLogFile(String logFile,String logLevel,String logServiceFile){\r\n    if (!(handler instanceof FileLoggerHandler)) {\r\n        super.removeHandler(handler);\r\n    } else {\r\n        boolean hasHandler = false;\r\n        Handler[] hs = getHandlers();\r\n        if (hs != null) {\r\n            for (Handler h : hs) {\r\n                if (h == handler) {\r\n                    hasHandler = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (hasHandler) {\r\n            super.removeHandler(handler);\r\n            ((FileLoggerHandler) handler).disassociate();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorSynchronizationImpl.after_completion",
	"Comment": "passes on the after completion operation to the coordinator.",
	"Method": "void after_completion(Status status){\r\n    if (coordinator == null) {\r\n        INTERNAL exc = new INTERNAL(MinorCode.NoCoordinator, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    coordinator.afterCompletion(status);\r\n    destroy();\r\n}"
}, {
	"Path": "org.apache.catalina.logger.LoggerBase.setContainer",
	"Comment": "set the container with which this logger has been associated.",
	"Method": "void setContainer(Container container){\r\n    Container oldContainer = this.container;\r\n    this.container = container;\r\n    support.firePropertyChange(\"container\", oldContainer, this.container);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getEffectiveMajorVersion",
	"Comment": "gets the major version of the servlet specification that theapplication represented by this servletcontext is based on.",
	"Method": "int getEffectiveMajorVersion(){\r\n    if (isRestricted) {\r\n        throw new UnsupportedOperationException(rb.getString(LogFacade.UNSUPPORTED_OPERATION_EXCEPTION));\r\n    }\r\n    return context.getEffectiveMajorVersion();\r\n}"
}, {
	"Path": "org.glassfish.api.admin.AdminCommandLock.getLockOwner",
	"Comment": "get the admin user id for the user who acquired the exclusive lock.this does not imply the lock is still held.",
	"Method": "String getLockOwner(){\r\n    return lockOwner;\r\n}"
}, {
	"Path": "com.sun.appserv.util.cache.BaseCache.put",
	"Comment": "cache the given value at the specified key and return previous value",
	"Method": "Object put(Object key,Object value,Object put,Object key,Object value,int size){\r\n    int hashCode = hash(key);\r\n    return _put(hashCode, key, value, size, false);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.setNetworkListenerNames",
	"Comment": "associates this standardhost with the given network listener names.",
	"Method": "void setNetworkListenerNames(String[] networkListenerNames){\r\n    String[] oldListenerNames = this.networkListenerNames;\r\n    this.networkListenerNames = networkListenerNames.clone();\r\n    support.firePropertyChange(\"ports\", oldListenerNames, this.networkListenerNames);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getRealPath",
	"Comment": "return the real path corresponding to the given virtual path, ornull if the container was unable to perform thetranslation",
	"Method": "String getRealPath(String path){\r\n    if (!(showArchivedRealPathEnabled || directoryDeployed)) {\r\n        return null;\r\n    }\r\n    if (!isFilesystemBased())\r\n        return null;\r\n    if (path == null) {\r\n        return null;\r\n    }\r\n    File file = null;\r\n    if (alternateDocBases == null || alternateDocBases.size() == 0) {\r\n        file = new File(getBasePath(getDocBase()), path);\r\n    } else {\r\n        AlternateDocBase match = AlternateDocBase.findMatch(path, alternateDocBases);\r\n        if (match != null) {\r\n            file = new File(match.getBasePath(), path);\r\n        } else {\r\n            file = new File(getBasePath(getDocBase()), path);\r\n        }\r\n    }\r\n    if (!file.exists()) {\r\n        try {\r\n            File f = getExtractedMetaInfResourcePath(path);\r\n            if (f != null && f.exists()) {\r\n                file = f;\r\n            }\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    if (!file.exists()) {\r\n        return null;\r\n    } else {\r\n        return file.getAbsolutePath();\r\n    }\r\n}"
}, {
	"Path": "components.model.Graph.addNode",
	"Comment": "register the specified node in our registry of the complete tree.",
	"Method": "void addNode(Node node){\r\n    synchronized (registry) {\r\n        String name = node.getName();\r\n        if (registry.containsKey(name)) {\r\n            throw new IllegalArgumentException(\"Name '\" + name + \"' is not unique\");\r\n        }\r\n        node.setGraph(this);\r\n        registry.put(name, node);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.ThresholdingOutputStream.close",
	"Comment": "closes this output stream and releases any system resources associatedwith this stream.",
	"Method": "void close(){\r\n    try {\r\n        flush();\r\n    } catch (IOException ignored) {\r\n    }\r\n    getStream().close();\r\n}"
}, {
	"Path": "org.glassfish.deployment.admin.ListComponentsCommand.isApplicationOfThisType",
	"Comment": "check the type of application by comparing the sniffer engine.",
	"Method": "boolean isApplicationOfThisType(Application app,String type){\r\n    if (type.equals(\"application\")) {\r\n        type = \"ear\";\r\n    } else if (type.equals(\"webservice\")) {\r\n        type = \"webservices\";\r\n    }\r\n    List<Engine> engineList = getAppEngines(app);\r\n    for (Engine engine : engineList) {\r\n        if (engine.getSniffer().equals(type)) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHostValve.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (info);\r\n}"
}, {
	"Path": "org.glassfish.api.jdbc.SQLTraceRecord.getThreadName",
	"Comment": "gets the thread name from which the sql statement originated.",
	"Method": "String getThreadName(){\r\n    return threadName;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.getFilterRegistration",
	"Comment": "gets the filterregistration corresponding to the filter with thegiven filtername.",
	"Method": "FilterRegistration getFilterRegistration(String filterName){\r\n    if (SecurityUtil.isPackageProtectionEnabled()) {\r\n        return (FilterRegistration) doPrivileged(\"getFilterRegistration\", new Object[] { filterName });\r\n    } else {\r\n        return context.getFilterRegistration(filterName);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.findApplicationParameters",
	"Comment": "return the set of application parameters for this application.",
	"Method": "List<ApplicationParameter> findApplicationParameters(){\r\n    return applicationParameters;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.Validator.validate",
	"Comment": "checks the validity of the given value for the entry. this method doesbasic checks such as null ness & type.",
	"Method": "void validate(Object obj){\r\n    if (obj == null) {\r\n        throw new InvalidConfigException(strMgr.getString(\"validator.invalid_value\", getName(), null));\r\n    }\r\n    Class c = obj.getClass();\r\n    if (!type.isAssignableFrom(c)) {\r\n        throw new InvalidConfigException(strMgr.getString(\"validator.invalid_type\", getName(), type.getName(), c.getName()));\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.logger.FileLogger.log",
	"Comment": "writes the specified message to a servlet log file, usually an eventlog.the name and type of the servlet log is specific to theservlet container.",
	"Method": "void log(String msg){\r\n    Timestamp ts = new Timestamp(System.currentTimeMillis());\r\n    String tsString = ts.toString().substring(0, 19);\r\n    String tsDate = tsString.substring(0, 10);\r\n    if (!date.equals(tsDate)) {\r\n        synchronized (this) {\r\n            if (!date.equals(tsDate)) {\r\n                close();\r\n                date = tsDate;\r\n                open();\r\n            }\r\n        }\r\n    }\r\n    if (writer != null) {\r\n        if (timestamp) {\r\n            writer.println(tsString + \" \" + msg);\r\n        } else {\r\n            writer.println(msg);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.jstl.integration.GlassFishTldProvider.getTldListenerMap",
	"Comment": "gets a mapping from jar files to their tld resourcesthat are known to contain listener declarations.",
	"Method": "Map<URI, List<String>> getTldListenerMap(){\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.contextpropagation.internal.Utils.registerContextFactoryForPrefixNamed",
	"Comment": "viewcapable objects are created by the context propagation framework when needed using the contextviewfactory registered against thespecified context name",
	"Method": "void registerContextFactoryForPrefixNamed(String prefixName,ContextViewFactory factory){\r\n    Utils.validateFactoryRegistrationArgs(\"prefixName\", MessageID.WARN_FACTORY_ALREADY_REGISTERED_FOR_PREFIX, prefixName, factory, viewFactoriesByPrefix);\r\n    viewFactoriesByPrefix.put(prefixName, factory);\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.AuthenticatorBase.associate",
	"Comment": "associate the specified single sign on identifier with thespecified session.",
	"Method": "void associate(String ssoId,long ssoVersion,Session session){\r\n    if (sso == null)\r\n        return;\r\n    sso.associate(ssoId, ssoVersion, session);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.ServerConfigLookup.getPersistenceScopeFromConfig",
	"Comment": "get the persistencescope from domain.xml.return null if not found",
	"Method": "String getPersistenceScopeFromConfig(){\r\n    WebContainerAvailability webContainerAvailabilityBean = getWebContainerAvailability();\r\n    if (webContainerAvailabilityBean == null) {\r\n        return null;\r\n    }\r\n    return webContainerAvailabilityBean.getPersistenceScope();\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.launcher.GFLauncher.getAdminRealmKeyFile",
	"Comment": "returns the admin realm key file for the server, if the admin realm is afilerealm. otherwise return null. this value can be used to create afilerealm for the server.",
	"Method": "String getAdminRealmKeyFile(){\r\n    return adminFileRealmKeyFile;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.ServerConfigLookup.toBoolean",
	"Comment": "convert the input value to the appropriate boolean valueif input value is null, return null",
	"Method": "Boolean toBoolean(String value){\r\n    if (value.equalsIgnoreCase(\"true\") || value.equalsIgnoreCase(\"yes\") || value.equalsIgnoreCase(\"on\") || value.equalsIgnoreCase(\"1\")) {\r\n        return Boolean.TRUE;\r\n    }\r\n    return Boolean.FALSE;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.launcher.GFLauncher.useLaunchCtl",
	"Comment": "checks whether to use launchctl for start up by checking if mac os version10.10",
	"Method": "boolean useLaunchCtl(String osversion){\r\n    int major = 0;\r\n    int minor = 0;\r\n    if (osversion == null || osversion.isEmpty())\r\n        return false;\r\n    String[] split = osversion.split(\"[\\\\._\\\\-]+\");\r\n    try {\r\n        if (split.length > 0 && split[0].length() > 0) {\r\n            major = Integer.parseInt(split[0]);\r\n        }\r\n        if (split.length > 1 && split[1].length() > 0) {\r\n            minor = Integer.parseInt(split[1]);\r\n        }\r\n        return ((major <= 9) || (major <= 10 && minor < 10));\r\n    } catch (NumberFormatException e) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RecoveryCoordinatorImpl.replay_completion",
	"Comment": "informs the transaction service that the given resource object has beenprepared but has not received a commit or rollback operation.if the transaction outcome is unknown, the resource object passedon this operation will be called at some later time forcommit or rollback.",
	"Method": "Status replay_completion(Resource res,Status replay_completion,Resource res,String logPath){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.logp(Level.FINE, \"RecoveryCoordinatorImpl\", \"replay_completion()\", \"replay_completion on Resource:\" + res);\r\n    }\r\n    Status result = Status.StatusRolledBack;\r\n    CoordinatorImpl coord = DelegatedRecoveryManager.getCoordinator(globalTID, logPath);\r\n    if (coord != null) {\r\n        try {\r\n            result = coord.get_status();\r\n        } catch (SystemException exc) {\r\n        }\r\n    }\r\n    switch(result.value()) {\r\n        case Status._StatusActive:\r\n        case Status._StatusMarkedRollback:\r\n            try {\r\n                coord.rollback_only();\r\n            } catch (Throwable exc) {\r\n            }\r\n            throw new NotPrepared();\r\n        case Status._StatusPrepared:\r\n            result = Status.StatusUnknown;\r\n            break;\r\n        case Status._StatusCommitting:\r\n            break;\r\n        case Status._StatusCommitted:\r\n            break;\r\n        case Status._StatusRolledBack:\r\n            if (coord == null) {\r\n                if (!Configuration.getProxyChecker().isProxy(res)) {\r\n                    rollbackOrphan(res);\r\n                } else {\r\n                    try {\r\n                        OrphanRollbackThread rollbackThread = new OrphanRollbackThread(this, (Resource) res._duplicate());\r\n                        rollbackThread.start();\r\n                    } catch (SystemException exc) {\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        default:\r\n            result = Status.StatusRolledBack;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.DefaultConnectionManagerSerializable.check",
	"Comment": "test if the default implementation of the javax.resource.spi.connectionmanagerprovided implements the java.io.serializable interface",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!descriptor.getOutBoundDefined()) {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.managed.notApplicableForInboundRA\", \"Resource Adapter does not provide outbound communication\"));\r\n        return result;\r\n    }\r\n    Class c = findImplementorOf(descriptor, \"javax.resource.spi.ConnectionManager\");\r\n    if (c != null) {\r\n        testImplementationOf(c, \"java.io.Serializable\", result);\r\n        return result;\r\n    }\r\n    result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n    result.failed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.DefaultConnectionManagerExistence.failed\", \"Error: There is no default implementation of the [ {0} ] provided\", new Object[] { \"javax.resource.spi.ConnectionManager\" }));\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.startup.Embedded.createEngine",
	"Comment": "create, configure, and return an engine that will process allhttp requests received from one of the associated connectors,based on the specified properties.",
	"Method": "Engine createEngine(){\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \"Creating engine\");\r\n    StandardEngine engine = new StandardEngine();\r\n    engine.setDebug(debug);\r\n    engine.setLogger(logger);\r\n    engine.setRealm(realm);\r\n    return (engine);\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.clearReferencesRmiTargets",
	"Comment": "this depends on the internals of the sun jvm so it does everything byreflection.",
	"Method": "void clearReferencesRmiTargets(){\r\n    try {\r\n        Class<?> objectTargetClass = Class.forName(\"sun.rmi.transport.Target\");\r\n        Field cclField = objectTargetClass.getDeclaredField(\"ccl\");\r\n        cclField.setAccessible(true);\r\n        Class<?> objectTableClass = Class.forName(\"sun.rmi.transport.ObjectTable\");\r\n        Field objTableField = objectTableClass.getDeclaredField(\"objTable\");\r\n        objTableField.setAccessible(true);\r\n        Object objTable = objTableField.get(null);\r\n        if (objTable == null) {\r\n            return;\r\n        }\r\n        if (objTable instanceof Map<?, ?>) {\r\n            Iterator<?> iter = ((Map<?, ?>) objTable).values().iterator();\r\n            while (iter.hasNext()) {\r\n                Object obj = iter.next();\r\n                Object cclObject = cclField.get(obj);\r\n                if (this == cclObject) {\r\n                    iter.remove();\r\n                }\r\n            }\r\n        }\r\n        Field implTableField = objectTableClass.getDeclaredField(\"implTable\");\r\n        implTableField.setAccessible(true);\r\n        Object implTable = implTableField.get(null);\r\n        if (implTable == null) {\r\n            return;\r\n        }\r\n        if (implTable instanceof Map<?, ?>) {\r\n            Iterator<?> iter = ((Map<?, ?>) implTable).values().iterator();\r\n            while (iter.hasNext()) {\r\n                Object obj = iter.next();\r\n                Object cclObject = cclField.get(obj);\r\n                if (this == cclObject) {\r\n                    iter.remove();\r\n                }\r\n            }\r\n        }\r\n    } catch (ClassNotFoundException e) {\r\n        if (logger.isLoggable(Level.INFO)) {\r\n            logger.log(Level.INFO, getString(LogFacade.CLEAR_RMI_INFO, contextName), e);\r\n        }\r\n    } catch (SecurityException e) {\r\n        if (logger.isLoggable(Level.WARNING)) {\r\n            logger.log(Level.WARNING, getString(LogFacade.CLEAR_RMI_FAIL, contextName), e);\r\n        }\r\n    } catch (NoSuchFieldException e) {\r\n        if (logger.isLoggable(Level.WARNING)) {\r\n            logger.log(Level.WARNING, getString(LogFacade.CLEAR_RMI_FAIL, contextName), e);\r\n        }\r\n    } catch (IllegalArgumentException e) {\r\n        if (logger.isLoggable(Level.WARNING)) {\r\n            logger.log(Level.WARNING, getString(LogFacade.CLEAR_RMI_FAIL, contextName), e);\r\n        }\r\n    } catch (IllegalAccessException e) {\r\n        if (logger.isLoggable(Level.WARNING)) {\r\n            logger.log(Level.WARNING, getString(LogFacade.CLEAR_RMI_FAIL, contextName), e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.web.GlassFishSingleSignOn.threadStart",
	"Comment": "start the background thread that will periodically check forsso timeouts.",
	"Method": "void threadStart(){\r\n    if (thread != null)\r\n        return;\r\n    threadDone = false;\r\n    String threadName = \"SingleSignOnExpiration\";\r\n    thread = new Thread(this, threadName);\r\n    thread.setDaemon(true);\r\n    thread.start();\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setTldValidation",
	"Comment": "set the validation feature of the xml parser used whenparsing tlds files.",
	"Method": "void setTldValidation(boolean tldValidation){\r\n    this.tldValidation = tldValidation;\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.JavaEETransactionManagerSimplified.release",
	"Comment": "release a transaction. this call causes the calling thread to bedissociated from the specified transaction. this is used by importing transactions via the connector contract.",
	"Method": "void release(Xid xid){\r\n    getDelegate().release(xid);\r\n}"
}, {
	"Path": "org.apache.catalina.loader.WebappLoader.getClasspath",
	"Comment": "try to extract the classpath from a loader that is not urlclassloader",
	"Method": "String getClasspath(String getClasspath,ClassLoader loader){\r\n    try {\r\n        Method m = loader.getClass().getMethod(\"getClasspath\", new Class[] {});\r\n        if (log.isLoggable(Level.FINEST))\r\n            log.log(Level.FINEST, \"getClasspath \" + m);\r\n        Object o = m.invoke(loader, new Object[] {});\r\n        if (log.isLoggable(Level.FINEST))\r\n            log.log(Level.FINEST, \"gotClasspath \" + o);\r\n        if (o instanceof String)\r\n            return (String) o;\r\n        return null;\r\n    } catch (Exception ex) {\r\n        if (log.isLoggable(Level.FINEST))\r\n            log.log(Level.FINEST, \"getClasspath \", ex);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.DelegatedTimeoutManager.checkTimeouts",
	"Comment": "periodically checks the existing timeouts.this is done to discover if any transactions have overrun their allottedtime.those which have are returned as an enumeration.note that this method should not do anything that will cause asynchronized method in the recoverymanager to be called, as this couldcause a deadlock when recoverymanager methods on other threads callsettimeout.",
	"Method": "Enumeration checkTimeouts(){\r\n    if (!isSetTimeout)\r\n        return null;\r\n    Enumeration result = null;\r\n    if (timeoutActive && ((pendingTimeouts.size() != 0) || (indoubtTimeouts.size() != 0))) {\r\n        Vector timedOut = null;\r\n        Enumeration timeouts = null;\r\n        synchronized (pendingTimeouts) {\r\n            timeouts = pendingTimeouts.elements();\r\n            while (timeouts.hasMoreElements()) {\r\n                DelegatedTimeoutInfo timeoutInfo = (DelegatedTimeoutInfo) timeouts.nextElement();\r\n                if (new Date().getTime() > timeoutInfo.expireTime) {\r\n                    if (timedOut == null) {\r\n                        timedOut = new Vector();\r\n                    }\r\n                    timedOut.addElement(timeoutInfo);\r\n                }\r\n            }\r\n        }\r\n        synchronized (indoubtTimeouts) {\r\n            timeouts = indoubtTimeouts.elements();\r\n            while (timeouts.hasMoreElements()) {\r\n                DelegatedTimeoutInfo timeoutInfo = (DelegatedTimeoutInfo) timeouts.nextElement();\r\n                if (new Date().getTime() > timeoutInfo.expireTime) {\r\n                    if (timedOut == null) {\r\n                        timedOut = new Vector();\r\n                    }\r\n                    timedOut.addElement(timeoutInfo);\r\n                }\r\n            }\r\n        }\r\n        if (timedOut != null) {\r\n            result = timedOut.elements();\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.common.util.timer.TimerSchedule.getLastDayForDayOfWeek",
	"Comment": "return day of the month that represents the last occurance of this day of the week",
	"Method": "int getLastDayForDayOfWeek(Calendar testdate,int day,int lastday){\r\n    int result = lastday;\r\n    for (int i = lastday; i >= 1; i--) {\r\n        testdate.set(Calendar.DAY_OF_MONTH, i);\r\n        int testday = testdate.get(Calendar.DAY_OF_WEEK);\r\n        if (testday == day) {\r\n            result = i;\r\n            break;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.web.loader.ServletContainerInitializerUtil.getInterestList",
	"Comment": "builds a mapping of classes to the list of servletcontainerinitializersinterested in them",
	"Method": "Map<Class<?>, List<Class<? extends ServletContainerInitializer>>> getInterestList(Iterable<ServletContainerInitializer> initializers){\r\n    if (null == initializers) {\r\n        return null;\r\n    }\r\n    Map<Class<?>, List<Class<? extends ServletContainerInitializer>>> interestList = null;\r\n    for (ServletContainerInitializer sc : initializers) {\r\n        if (interestList == null) {\r\n            interestList = new HashMap<Class<?>, List<Class<? extends ServletContainerInitializer>>>();\r\n        }\r\n        Class<? extends ServletContainerInitializer> sciClass = sc.getClass();\r\n        HandlesTypes ann = (HandlesTypes) sciClass.getAnnotation(HandlesTypes.class);\r\n        if (ann == null) {\r\n            List<Class<? extends ServletContainerInitializer>> currentInitializerList = interestList.get(ServletContainerInitializerUtil.class);\r\n            if (currentInitializerList == null) {\r\n                List<Class<? extends ServletContainerInitializer>> arr = new ArrayList<Class<? extends ServletContainerInitializer>>();\r\n                arr.add(sciClass);\r\n                interestList.put(ServletContainerInitializerUtil.class, arr);\r\n            } else {\r\n                currentInitializerList.add(sciClass);\r\n            }\r\n        } else {\r\n            Class[] interestedClasses = ann.value();\r\n            if ((interestedClasses != null) && (interestedClasses.length != 0)) {\r\n                for (Class c : interestedClasses) {\r\n                    List<Class<? extends ServletContainerInitializer>> currentInitializerList = interestList.get(c);\r\n                    if (currentInitializerList == null) {\r\n                        List<Class<? extends ServletContainerInitializer>> arr = new ArrayList<Class<? extends ServletContainerInitializer>>();\r\n                        arr.add(sciClass);\r\n                        interestList.put(c, arr);\r\n                    } else {\r\n                        currentInitializerList.add(sciClass);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return interestList;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.PEAccessLogValve.threadStart",
	"Comment": "start the background writerthread that will periodically write access log",
	"Method": "void threadStart(){\r\n    if (writerThread != null || writeInterval == 0)\r\n        return;\r\n    threadDone = false;\r\n    String threadName = \"AccessLogWriter\";\r\n    writerThread = new Thread(this, threadName);\r\n    writerThread.setDaemon(true);\r\n    writerThread.start();\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.WithDefaultsRulesWrapper.match",
	"Comment": "return list of rules matching given pattern.if wrapped implementation returns any matches return those.otherwise, return default matches.",
	"Method": "List<Rule> match(String namespaceURI,String pattern){\r\n    List<Rule> matches = wrappedRules.match(namespaceURI, pattern);\r\n    if (matches == null || matches.isEmpty()) {\r\n        return new ArrayList<Rule>(defaultRules);\r\n    }\r\n    return matches;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.pwc.PwcWebModule.getSessionCookieConfigFromSunWebXml",
	"Comment": "return the session cookie configuration for this web module.",
	"Method": "SessionCookieConfig getSessionCookieConfigFromSunWebXml(){\r\n    return _cookieConfig;\r\n}"
}, {
	"Path": "org.glassfish.webservices.WebServicesDeployer.doWebServiceDeployment",
	"Comment": "prepares the servlet based web services specified in web.xml for deployment.swap the application written servlet implementation class forone provided by the container.the original class is storedas runtime information since it will be used as the servant atdispatch time.",
	"Method": "void doWebServiceDeployment(WebBundleDescriptor webBunDesc){\r\n    Collection<WebServiceEndpoint> endpoints = webBunDesc.getWebServices().getEndpoints();\r\n    ClassLoader cl = webBunDesc.getClassLoader();\r\n    WsUtil wsutil = new WsUtil();\r\n    for (WebServiceEndpoint nextEndpoint : endpoints) {\r\n        WebComponentDescriptor webComp = nextEndpoint.getWebComponentImpl();\r\n        if (!nextEndpoint.hasServletImplClass()) {\r\n            throw new DeploymentException(format(rb.getString(LogUtils.DEPLOYMENT_BACKEND_CANNOT_FIND_SERVLET), nextEndpoint.getEndpointName()));\r\n        }\r\n        if (nextEndpoint.hasEndpointAddressUri()) {\r\n            webComp.getUrlPatternsSet().clear();\r\n            webComp.addUrlPattern(nextEndpoint.getEndpointAddressUri());\r\n        }\r\n        if (!nextEndpoint.getWebService().hasFilePublishing()) {\r\n            String publishingUri = nextEndpoint.getPublishingUri();\r\n            String publishingUrlPattern = (publishingUri.charAt(0) == '/') ? publishingUri : \"/\" + publishingUri + \"/*\";\r\n            webComp.addUrlPattern(publishingUrlPattern);\r\n        }\r\n        String servletImplClass = nextEndpoint.getServletImplClass();\r\n        try {\r\n            Class servletImplClazz = cl.loadClass(servletImplClass);\r\n            String containerServlet;\r\n            if (wsutil.isJAXWSbasedService(nextEndpoint.getWebService())) {\r\n                containerServlet = \"org.glassfish.webservices.JAXWSServlet\";\r\n                addWSServletContextListener(webBunDesc);\r\n            } else {\r\n                containerServlet = SingleThreadModel.class.isAssignableFrom(servletImplClazz) ? \"org.glassfish.webservices.SingleThreadJAXRPCServlet\" : \"org.glassfish.webservices.JAXRPCServlet\";\r\n            }\r\n            webComp.setWebComponentImplementation(containerServlet);\r\n        } catch (ClassNotFoundException cex) {\r\n            throw new DeploymentException(format(rb.getString(LogUtils.DEPLOYMENT_BACKEND_CANNOT_FIND_SERVLET), nextEndpoint.getEndpointName()));\r\n        }\r\n        WebServerInfo wsi = new WsUtil().getWebServerInfoForDAS();\r\n        URL rootURL = wsi.getWebServerRootURL(nextEndpoint.isSecure());\r\n        String contextRoot = webBunDesc.getContextRoot();\r\n        URL actualAddress = nextEndpoint.composeEndpointAddress(rootURL, contextRoot);\r\n        if (wsi.getHttpVS() != null && wsi.getHttpVS().getPort() != 0) {\r\n            logger.log(Level.INFO, LogUtils.ENDPOINT_REGISTRATION, new Object[] { nextEndpoint.getEndpointName(), actualAddress });\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.util.StringParser.skipChar",
	"Comment": "advance the current parsing position while it is pointing at thespecified character, or until it moves past the end of the string.return the final value.",
	"Method": "int skipChar(char ch){\r\n    while ((index < length) && (ch == chars[index])) index++;\r\n    return (index);\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.JspGroupDescriptor.getIncludeCodas",
	"Comment": "return an iterable over include coda elements for this group.",
	"Method": "Set<String> getIncludeCodas(){\r\n    if (this.includeCodas == null) {\r\n        this.includeCodas = new OrderedSet<String>();\r\n    }\r\n    return this.includeCodas;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.server.AppServerStartupTest.testRunAppServerStartup",
	"Comment": "helper method to run the app server after asserting that the results are clean.",
	"Method": "void testRunAppServerStartup(){\r\n    Assert.assertFalse(results.isConstructed(TestInitRunLevelService.class));\r\n    Assert.assertFalse(results.isConstructed(TestStartupService.class));\r\n    Assert.assertFalse(results.isConstructed(TestStartupRunLevelService.class));\r\n    Assert.assertFalse(results.isConstructed(TestPostStartupRunLevelService.class));\r\n    as.run();\r\n}"
}, {
	"Path": "org.apache.catalina.startup.Embedded.addConnector",
	"Comment": "add a new connector to the set of defined connectors.the newlyadded connector will be associated with the most recently added engine.",
	"Method": "void addConnector(Connector connector){\r\n    if (log.isLoggable(Level.FINE)) {\r\n        log.log(Level.FINE, \"Adding connector (\" + connector.getInfo() + \")\");\r\n    }\r\n    if (engines.length < 1)\r\n        throw new IllegalStateException(rb.getString(LogFacade.NO_ENGINES_DEFINED));\r\n    super.addConnector(connector);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.AsadminTrustManager.checkCertificate",
	"Comment": "this function validates the cert and ensures that it is trusted.",
	"Method": "void checkCertificate(X509Certificate[] chain){\r\n    if (chain == null || chain.length == 0) {\r\n        throw new IllegalArgumentException(strmgr.get(\"emptyServerCertificate\"));\r\n    }\r\n    for (int i = 0; i < chain.length; i++) {\r\n        chain[i].checkValidity();\r\n    }\r\n    try {\r\n        AsadminTruststore truststore = AsadminTruststore.newInstance();\r\n        if (!truststore.certificateExists(chain[0])) {\r\n            if (isItOKToAddCertToTrustStore(chain[0])) {\r\n                truststore.addCertificate(getAliasName(), chain[0]);\r\n            } else {\r\n                throw new CertificateException(strmgr.get(\"serverCertificateNotTrusted\"));\r\n            }\r\n        }\r\n    } catch (CertificateException ex) {\r\n        throw ex;\r\n    } catch (Exception e) {\r\n        throw new RuntimeException(e);\r\n    }\r\n}"
}, {
	"Path": "components.taglib.GraphMenuBarTag.setValue",
	"Comment": "value binding reference expression that points to a graph in scopednamespace.",
	"Method": "void setValue(String newValue){\r\n    value = newValue;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.HttpConnectorAddress.getConnectorType",
	"Comment": "get the protocol prefix to be used for a connection for thereceiver",
	"Method": "String getConnectorType(){\r\n    return this.isSecure() ? HTTPS_CONNECTOR : HTTP_CONNECTOR;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ContainerBase.start",
	"Comment": "prepare for active use of the public methods of this component.",
	"Method": "void start(){\r\n    if (started) {\r\n        if (log.isLoggable(Level.INFO)) {\r\n            log.log(Level.INFO, LogFacade.CONTAINER_STARTED, logName());\r\n        }\r\n        return;\r\n    }\r\n    lifecycle.fireLifecycleEvent(BEFORE_START_EVENT, null);\r\n    started = true;\r\n    if ((loader != null) && (loader instanceof Lifecycle))\r\n        ((Lifecycle) loader).start();\r\n    if ((logger != null) && (logger instanceof Lifecycle))\r\n        ((Lifecycle) logger).start();\r\n    if ((manager != null) && (manager instanceof Lifecycle))\r\n        ((Lifecycle) manager).start();\r\n    if ((realm != null) && (realm instanceof Lifecycle))\r\n        ((Lifecycle) realm).start();\r\n    if ((resources != null) && (resources instanceof Lifecycle))\r\n        ((Lifecycle) resources).start();\r\n    startChildren();\r\n    if (pipeline instanceof Lifecycle) {\r\n        ((Lifecycle) pipeline).start();\r\n    }\r\n    lifecycle.fireLifecycleEvent(START_EVENT, null);\r\n    threadStart();\r\n    lifecycle.fireLifecycleEvent(AFTER_START_EVENT, null);\r\n}"
}, {
	"Path": "org.glassfish.embeddable.BootstrapProperties.setInstallRoot",
	"Comment": "optionally set the installation root using which the glassfish should run.",
	"Method": "void setInstallRoot(String installRoot){\r\n    properties.setProperty(INSTALL_ROOT_PROP_NAME, installRoot);\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.getRuleNamespaceURI",
	"Comment": "return the namespace uri that will be applied to all subsequentlyadded rule objects.",
	"Method": "String getRuleNamespaceURI(){\r\n    return (getRules().getNamespaceURI());\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.SingleSignOn.deregister",
	"Comment": "deregister the specified session.if it is the last session,then also get rid of the single sign on identifier",
	"Method": "void deregister(String ssoId,Session session){\r\n    SingleSignOnEntry sso = lookup(ssoId);\r\n    if (sso == null)\r\n        return;\r\n    session.setSsoId(null);\r\n    session.setSsoVersion(0L);\r\n    sso.removeSession(session);\r\n    if (sso.isEmpty()) {\r\n        synchronized (cache) {\r\n            cache.remove(ssoId);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutoDeployDirectoryScanner.getAllFilesForUndeployment",
	"Comment": "this should never be called from system dir autodeploy code...",
	"Method": "File[] getAllFilesForUndeployment(File autodeployDir,boolean includeSubdir){\r\n    try {\r\n        AutoDeployedFilesManager adfm = AutoDeployedFilesManager.loadStatus(autodeployDir);\r\n        return adfm.getFilesForUndeployment(getListOfFiles(autodeployDir, includeSubdir));\r\n    } catch (Exception e) {\r\n        printException(e);\r\n        return new File[0];\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.util.RequestUtil.parseCharacterEncoding",
	"Comment": "parse the character encoding from the specified content type header.if the content type is null, or there is no explicit character encoding,null is returned.",
	"Method": "String parseCharacterEncoding(String contentType){\r\n    if (contentType == null)\r\n        return (null);\r\n    int start = contentType.indexOf(\"charset=\");\r\n    if (start < 0)\r\n        return (null);\r\n    String encoding = contentType.substring(start + 8);\r\n    int end = encoding.indexOf(';');\r\n    if (end >= 0)\r\n        encoding = encoding.substring(0, end);\r\n    encoding = encoding.trim();\r\n    if ((encoding.length() > 2) && (encoding.startsWith(\"\\\"\")) && (encoding.endsWith(\"\\\"\")))\r\n        encoding = encoding.substring(1, encoding.length() - 1);\r\n    return (encoding.trim());\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.ClusterCommandHelper.runCommand",
	"Comment": "loop through all instances in a cluster and execute a command foreach one.",
	"Method": "ActionReport runCommand(String command,ParameterMap map,String clusterName,AdminCommandContext context,boolean verbose){\r\n    final long startTime = System.currentTimeMillis();\r\n    Logger logger = context.getLogger();\r\n    ActionReport report = context.getActionReport();\r\n    Cluster cluster = domain.getClusterNamed(clusterName);\r\n    if (cluster == null) {\r\n        String msg = Strings.get(\"cluster.command.unknownCluster\", clusterName);\r\n        throw new CommandException(msg);\r\n    }\r\n    List<Server> targetServers = domain.getServersInTarget(clusterName);\r\n    if (targetServers == null || targetServers.isEmpty()) {\r\n        report.setActionExitCode(ExitCode.SUCCESS);\r\n        report.setMessage(Strings.get(\"cluster.command.noInstances\", clusterName));\r\n        return report;\r\n    }\r\n    int nInstances = targetServers.size();\r\n    StringBuilder failedServerNames = new StringBuilder();\r\n    StringBuilder succeededServerNames = new StringBuilder();\r\n    List<String> waitingForServerNames = new ArrayList<String>();\r\n    String msg;\r\n    ReportResult reportResult = new ReportResult();\r\n    boolean failureOccurred = false;\r\n    progress = context.getProgressStatus();\r\n    StringBuilder output = new StringBuilder();\r\n    if (logger.isLoggable(Level.FINE))\r\n        logger.fine(String.format(\"Original instance list %s\", serverListToString(targetServers)));\r\n    targetServers = optimizeServerListOrder(targetServers);\r\n    ArrayBlockingQueue<CommandRunnable> responseQueue = new ArrayBlockingQueue<CommandRunnable>(nInstances);\r\n    int adminThreadPoolSize = getAdminThreadPoolSize(logger);\r\n    int threadPoolSize = Math.min(nInstances, adminThreadPoolSize / 2);\r\n    if (threadPoolSize < 1)\r\n        threadPoolSize = 1;\r\n    ExecutorService threadPool = Executors.newFixedThreadPool(threadPoolSize);\r\n    if (map == null) {\r\n        map = new ParameterMap();\r\n    }\r\n    msg = String.format(\"Executing %s on %d instances using a thread pool of size %d: %s\", command, nInstances, threadPoolSize, serverListToString(targetServers));\r\n    logger.info(msg);\r\n    msg = Strings.get(\"cluster.command.executing\", command, Integer.toString(nInstances));\r\n    progress.setTotalStepCount(nInstances);\r\n    progress.progress(msg);\r\n    for (Server server : targetServers) {\r\n        String iname = server.getName();\r\n        waitingForServerNames.add(iname);\r\n        ParameterMap instanceParameterMap = new ParameterMap(map);\r\n        instanceParameterMap.set(\"DEFAULT\", iname);\r\n        ActionReport instanceReport = runner.getActionReport(\"plain\");\r\n        instanceReport.setActionExitCode(ExitCode.SUCCESS);\r\n        CommandInvocation invocation = runner.getCommandInvocation(command, instanceReport, context.getSubject());\r\n        invocation.parameters(instanceParameterMap);\r\n        msg = command + \" \" + iname;\r\n        logger.info(msg);\r\n        if (verbose) {\r\n            output.append(msg).append(NL);\r\n        }\r\n        CommandRunnable cmdRunnable = new CommandRunnable(invocation, instanceReport, responseQueue);\r\n        cmdRunnable.setName(iname);\r\n        threadPool.execute(cmdRunnable);\r\n    }\r\n    if (logger.isLoggable(Level.FINE))\r\n        logger.fine(String.format(\"%s commands queued, waiting for responses\", command));\r\n    long adminTimeout = RemoteRestAdminCommand.getReadTimeout() - 3000;\r\n    if (adminTimeout <= 0) {\r\n        adminTimeout = 57 * 1000;\r\n    }\r\n    if (logger.isLoggable(Level.FINE))\r\n        logger.fine(String.format(\"Initial cluster command timeout: %d ms\", adminTimeout));\r\n    for (int n = 0; n < nInstances; n++) {\r\n        long timeLeft = adminTimeout - (System.currentTimeMillis() - startTime);\r\n        if (timeLeft < 0) {\r\n            timeLeft = 0;\r\n        }\r\n        CommandRunnable cmdRunnable = null;\r\n        try {\r\n            cmdRunnable = responseQueue.poll(timeLeft, TimeUnit.MILLISECONDS);\r\n        } catch (InterruptedException e) {\r\n            threadPool.shutdownNow();\r\n            msg = Strings.get(\"cluster.command.interrupted\", clusterName, Integer.toString(n), Integer.toString(nInstances), command);\r\n            logger.warning(msg);\r\n            output.append(msg).append(NL);\r\n            failureOccurred = true;\r\n            Thread.currentThread().interrupt();\r\n            break;\r\n        }\r\n        if (cmdRunnable == null) {\r\n            break;\r\n        }\r\n        String iname = cmdRunnable.getName();\r\n        waitingForServerNames.remove(iname);\r\n        ActionReport instanceReport = cmdRunnable.getActionReport();\r\n        if (logger.isLoggable(Level.FINE))\r\n            logger.fine(String.format(\"Instance %d of %d (%s) has responded with %s\", n + 1, nInstances, iname, instanceReport.getActionExitCode()));\r\n        if (instanceReport.getActionExitCode() != ExitCode.SUCCESS) {\r\n            failureOccurred = true;\r\n            failedServerNames.append(iname).append(\" \");\r\n            reportResult.failedServerNames.add(iname);\r\n            msg = iname + \": \" + instanceReport.getMessage();\r\n            logger.severe(msg);\r\n            output.append(msg).append(NL);\r\n            msg = Strings.get(\"cluster.command.instancesFailed\", command, iname);\r\n            progress.progress(1, msg);\r\n        } else {\r\n            succeededServerNames.append(iname).append(\" \");\r\n            reportResult.succeededServerNames.add(iname);\r\n            progress.progress(1, iname);\r\n        }\r\n    }\r\n    report.setActionExitCode(ExitCode.SUCCESS);\r\n    if (failureOccurred) {\r\n        report.setResultType(List.class, reportResult.failedServerNames);\r\n    } else {\r\n        report.setResultType(List.class, reportResult.succeededServerNames);\r\n    }\r\n    if (succeededServerNames.length() > 0 && (verbose || failureOccurred)) {\r\n        output.append(NL + Strings.get(\"cluster.command.instancesSucceeded\", command, succeededServerNames));\r\n    }\r\n    if (failureOccurred) {\r\n        output.append(NL + Strings.get(\"cluster.command.instancesFailed\", command, failedServerNames));\r\n        if (succeededServerNames.length() > 0) {\r\n            report.setActionExitCode(ExitCode.WARNING);\r\n        } else {\r\n            report.setActionExitCode(ExitCode.FAILURE);\r\n        }\r\n    }\r\n    if (!waitingForServerNames.isEmpty()) {\r\n        msg = Strings.get(\"cluster.command.instancesTimedOut\", command, listToString(waitingForServerNames));\r\n        logger.warning(msg);\r\n        if (output.length() > 0) {\r\n            output.append(NL);\r\n        }\r\n        output.append(msg);\r\n        report.setActionExitCode(ExitCode.WARNING);\r\n    }\r\n    report.setMessage(output.toString());\r\n    threadPool.shutdown();\r\n    return report;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogFile.checkpoint",
	"Comment": "informs the log that all log records older than the one with the given lsnare no longer required.the checkpoint marks the point where log processing will begin in the eventof recovery processing. this will generally correspond to the last recordbefore a successful keypoint.",
	"Method": "boolean checkpoint(LogLSN firstLSN){\r\n    boolean result = true;\r\n    LogLSN checkLSN;\r\n    if (firstLSN.isNULL())\r\n        checkLSN = new LogLSN(LogLSN.HEAD_LSN);\r\n    else\r\n        checkLSN = new LogLSN(firstLSN);\r\n    try {\r\n        handle.checkLSN(checkLSN);\r\n        handle.truncate(checkLSN, LogHandle.TAIL_NOT_INCLUSIVE);\r\n    } catch (LogException le) {\r\n        result = false;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.session.PersistenceType.getType",
	"Comment": "returns a string describing the persistence mechanism that theobject represents.",
	"Method": "String getType(){\r\n    return _type;\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.BasicAuthenticator.parsePassword",
	"Comment": "parse the password from the specified authorization credentials.if none can be found, return null.",
	"Method": "char[] parsePassword(String authorization){\r\n    if (authorization == null)\r\n        return (null);\r\n    if (!authorization.toLowerCase(Locale.ENGLISH).startsWith(\"basic \"))\r\n        return (null);\r\n    authorization = authorization.substring(6).trim();\r\n    String unencoded = new String(Base64.decode(authorization.getBytes(Charset.defaultCharset())));\r\n    int colon = unencoded.indexOf(':');\r\n    if (colon < 0)\r\n        return (null);\r\n    char[] password = unencoded.substring(colon + 1).toCharArray();\r\n    return (password);\r\n}"
}, {
	"Path": "org.glassfish.api.admin.AdminCommandLock.queuePut",
	"Comment": "convenience method that puts an object on a blockingqueueas well as deals with interruptedexceptions.",
	"Method": "void queuePut(BlockingQueue<SuspendStatus> itmQ,SuspendStatus status){\r\n    boolean itemPut = false;\r\n    while (!itemPut) {\r\n        try {\r\n            itmQ.put(status);\r\n            itemPut = true;\r\n        } catch (java.lang.InterruptedException e) {\r\n            logger.log(Level.FINE, \"Interrupted putting lock status on queue\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteAdminCommand.setUserOut",
	"Comment": "if set, the raw response from the command is written to thespecified stream.",
	"Method": "void setUserOut(OutputStream userOut){\r\n    this.userOut = userOut;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.NestingInfo.removeFromParent",
	"Comment": "removes the given coordinator as a child from the parent coordinator.if the child could not be removed from the parent, the operation returnsfalse.",
	"Method": "boolean removeFromParent(CoordinatorImpl child){\r\n    boolean result = true;\r\n    if (!removed) {\r\n        CoordinatorImpl parent = ancestorSeq[0];\r\n        result = parent.removeChild(child);\r\n        removed = true;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServerFacade.getContexts",
	"Comment": "gets the collection of context instances registered withthis virtualserver.",
	"Method": "Collection<Context> getContexts(){\r\n    if (vs != null) {\r\n        return vs.getContexts();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.loader.WebappLoader.propertyChange",
	"Comment": "process property change events from our associated context.",
	"Method": "void propertyChange(PropertyChangeEvent event){\r\n    if (!(event.getSource() instanceof Context))\r\n        return;\r\n    String propName = event.getPropertyName();\r\n    if (\"reloadable\".equals(propName)) {\r\n        try {\r\n            setReloadable(((Boolean) event.getNewValue()).booleanValue());\r\n        } catch (NumberFormatException e) {\r\n            log.log(Level.SEVERE, LogFacade.SET_RELOADABLE_PROPERTY_EXCEPTION, neutralizeForLog(event.getNewValue().toString()));\r\n        }\r\n    } else if (\"antiJARLocking\".equals(propName)) {\r\n        ClassLoader cloader = Thread.currentThread().getContextClassLoader();\r\n        if (cloader instanceof WebappClassLoader) {\r\n            ((WebappClassLoader) cloader).setAntiJARLocking(((Boolean) event.getNewValue()).booleanValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.AsadminTrustManager.setInteractive",
	"Comment": "set the interactive mode for the trust manager.if false, it willnot prompt for any confirmations and will just trust certificates.by default it is true.",
	"Method": "void setInteractive(boolean mode){\r\n    interactive = mode;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.services.SMFService.getManifestFilePath",
	"Comment": "returns the absolute location of the manifest file as smf understands it.it takes into account the name, type and configuration location of the service. it is expected that these are set before calling this method.if thefully qualified service nameis invalid, a runtimeexception results.",
	"Method": "String getManifestFilePath(){\r\n    final String fn = new StringBuilder().append(MANIFEST_HOME).append(info.fqsn).append(\"/\").append(MANIFEST_FILE_SUFFIX).toString();\r\n    return (fn);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServerFacade.setWebListeners",
	"Comment": "sets the collection of weblistener instances from whichthis virtualserver receives requests.",
	"Method": "void setWebListeners(WebListener webListeners){\r\n    if (webListeners != null) {\r\n        this.webListeners = Arrays.asList(webListeners);\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.resources.ProxyDirContext.lookupLink",
	"Comment": "retrieves the named object, following links except for the terminal atomic component of the name.",
	"Method": "Object lookupLink(Name name,Object lookupLink,String name){\r\n    return dirContext.lookupLink(parseName(name));\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RecoveryManager.registerTransactionRecoveryFence",
	"Comment": "register the implementation of transaction recovery fence.this service is started as soon as all the resources are available.",
	"Method": "void registerTransactionRecoveryFence(TransactionRecoveryFence fence){\r\n    txRecoveryFence = fence;\r\n}"
}, {
	"Path": "com.sun.enterprise.loader.ASURLClassLoader.addURL",
	"Comment": "appends the specified url to the list of urls to search forclasses and resources.",
	"Method": "void addURL(URL url){\r\n    appendURL(url);\r\n}"
}, {
	"Path": "components.taglib.GraphMenuTreeTag.setStyleClass",
	"Comment": "the css style class to be applied to the entire menu.this can be value or a value binding referenceexpression.",
	"Method": "void setStyleClass(String style){\r\n    this.styleClass = style;\r\n}"
}, {
	"Path": "org.glassfish.web.util.IntrospectionUtils.getClassPath",
	"Comment": "construct a url classpath from files in a directory, a cpath property,and tools.jar.",
	"Method": "URL[] getClassPath(Vector<URL> v,URL[] getClassPath,String dir,String cpath,String cpathProp,boolean addTools){\r\n    Vector<URL> jarsV = new Vector<URL>();\r\n    if (dir != null) {\r\n        URL url = getURL(dir, \"classes\");\r\n        if (url != null)\r\n            jarsV.addElement(url);\r\n        addToClassPath(jarsV, dir);\r\n    }\r\n    if (cpath != null)\r\n        addJarsFromClassPath(jarsV, cpath);\r\n    if (cpathProp != null) {\r\n        String cpath1 = System.getProperty(cpathProp);\r\n        addJarsFromClassPath(jarsV, cpath1);\r\n    }\r\n    if (addTools)\r\n        addToolsJar(jarsV);\r\n    return getClassPath(jarsV);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.CheckResourceAdapterClassSerializable.check",
	"Comment": "resourceadapter class must be available if the resource adapter provides inbound communication",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    String resourceAdapterClass = descriptor.getResourceAdapterClass();\r\n    if (resourceAdapterClass.equals(\"\") && descriptor.getInBoundDefined()) {\r\n        addErrorDetails(result, compName);\r\n        result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"ResourceAdapter class not found\"));\r\n    } else {\r\n        addGoodDetails(result, compName);\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.resourceadapter.notApp\", \"Valid ResourceAdapter class.\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.setAppBase",
	"Comment": "set the application root for this host.this can be an absolutepathname, a relative pathname, or a url.",
	"Method": "void setAppBase(String appBase){\r\n    String oldAppBase = this.appBase;\r\n    this.appBase = appBase;\r\n    support.firePropertyChange(\"appBase\", oldAppBase, this.appBase);\r\n}"
}, {
	"Path": "components.taglib.GraphMenuBarTag.setActionListener",
	"Comment": "optional method reference to handle menu expansion and contractionevents.",
	"Method": "void setActionListener(String actionListener){\r\n    this.actionListener = actionListener;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.DefaultAccessLogFormatterImpl.appendClientName",
	"Comment": "appends the client host name of the given request to the given charbuffer.",
	"Method": "void appendClientName(CharBuffer cb,ServletRequest req){\r\n    cb.put(QUOTE);\r\n    String value = req.getRemoteHost();\r\n    if (value == null) {\r\n        value = \"NULL-CLIENT-NAME\";\r\n    }\r\n    cb.put(value);\r\n    cb.put(QUOTE);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.configureRedirect",
	"Comment": "configures this virtualserver with its redirect properties.",
	"Method": "void configureRedirect(){\r\n    vsPipeline.clearRedirects();\r\n    List<Property> props = vsBean.getProperty();\r\n    if (props == null) {\r\n        return;\r\n    }\r\n    for (Property prop : props) {\r\n        String propName = prop.getName();\r\n        String propValue = prop.getValue();\r\n        if (propName == null || propValue == null) {\r\n            _logger.log(Level.WARNING, LogFacade.NULL_VIRTUAL_SERVER_PROPERTY, getID());\r\n            continue;\r\n        }\r\n        if (!propName.startsWith(\"redirect_\")) {\r\n            continue;\r\n        }\r\n        String from = null;\r\n        String url = null;\r\n        String urlPrefix = null;\r\n        String escape = null;\r\n        String[] redirectParams = propValue.split(\" \");\r\n        for (int j = 0; j < redirectParams.length; j++) {\r\n            if (redirectParams[j].startsWith(\"from=\")) {\r\n                if (from != null) {\r\n                    _logger.log(Level.WARNING, LogFacade.REDIRECT_MULTIPLE_ELEMENT, new Object[] { propValue, getID(), \"from\" });\r\n                }\r\n                from = redirectParams[j].substring(\"from=\".length());\r\n            }\r\n            if (redirectParams[j].startsWith(\"url=\")) {\r\n                if (url != null) {\r\n                    _logger.log(Level.WARNING, LogFacade.REDIRECT_MULTIPLE_ELEMENT, new Object[] { propValue, getID(), \"url\" });\r\n                }\r\n                url = redirectParams[j].substring(\"url=\".length());\r\n            }\r\n            if (redirectParams[j].startsWith(\"url-prefix=\")) {\r\n                if (urlPrefix != null) {\r\n                    _logger.log(Level.WARNING, LogFacade.REDIRECT_MULTIPLE_ELEMENT, new Object[] { propValue, getID(), \"url-prefix\" });\r\n                }\r\n                urlPrefix = redirectParams[j].substring(\"url-prefix=\".length());\r\n            }\r\n            if (redirectParams[j].startsWith(\"escape=\")) {\r\n                if (escape != null) {\r\n                    _logger.log(Level.WARNING, LogFacade.REDIRECT_MULTIPLE_ELEMENT, new Object[] { propValue, getID(), \"escape\" });\r\n                }\r\n                escape = redirectParams[j].substring(\"escape=\".length());\r\n            }\r\n        }\r\n        if (from == null || from.length() == 0) {\r\n            _logger.log(Level.WARNING, LogFacade.REDIRECT_MULTIPLE_ELEMENT, new Object[] { propValue, getID() });\r\n        }\r\n        if ((url == null || url.length() == 0) && (urlPrefix == null || urlPrefix.length() == 0)) {\r\n            _logger.log(Level.WARNING, LogFacade.REDIRECT_MISSING_URL_OR_URL_PREFIX, new Object[] { propValue, getID() });\r\n        }\r\n        if (url != null && url.length() > 0 && urlPrefix != null && urlPrefix.length() > 0) {\r\n            _logger.log(Level.WARNING, LogFacade.REDIRECT_BOTH_URL_AND_URL_PREFIX, new Object[] { propValue, getID() });\r\n        }\r\n        boolean escapeURI = true;\r\n        if (escape != null) {\r\n            if (\"yes\".equalsIgnoreCase(escape)) {\r\n                escapeURI = true;\r\n            } else if (\"no\".equalsIgnoreCase(escape)) {\r\n                escapeURI = false;\r\n            } else {\r\n                _logger.log(Level.WARNING, LogFacade.REDIRECT_INVALID_ESCAPE, new Object[] { propValue, getID() });\r\n            }\r\n        }\r\n        vsPipeline.addRedirect(from, url, urlPrefix, escapeURI);\r\n    }\r\n    if (vsPipeline.hasRedirects()) {\r\n        if (pipeline != vsPipeline) {\r\n            setPipeline(vsPipeline);\r\n        }\r\n    } else if (isActive && pipeline != origPipeline) {\r\n        setPipeline(origPipeline);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.jts.recovery.SybaseXAResource.recover",
	"Comment": "returns xids list for recovery depending on flags. sybase xa resource ignores the flagsfor xaresource recover call. this method takes care for the fault. allows the recover callonly for tmstartrscan, for other values of flags just returns null.",
	"Method": "Xid[] recover(int flag){\r\n    try {\r\n        if (flag == XAResource.TMSTARTRSCAN)\r\n            return m_xacon.getXAResource().recover(flag);\r\n    } catch (ResourceException e) {\r\n        throw new XAException(sm.getString(\"transaction.sybase_xa_wrapper_connection_failed\", e));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteRestAdminCommand.getFromEnvironment",
	"Comment": "subclasses can override to supply parameter values from environment.the implementation in this class returns null, indicating that thename is not available in the environment.",
	"Method": "String getFromEnvironment(String name){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getNote",
	"Comment": "return the object bound with the specified name to the internal notesfor this request, or null if no such binding exists.",
	"Method": "Object getNote(String name){\r\n    return notes.get(name);\r\n}"
}, {
	"Path": "com.sun.enterprise.util.Utility.toCharArray",
	"Comment": "returns a character array for the valid characters in a charbuffer.",
	"Method": "char[] toCharArray(CharBuffer cb){\r\n    return cb.toString().toCharArray();\r\n}"
}, {
	"Path": "com.sun.enterprise.security.web.GlassFishSingleSignOn.stop",
	"Comment": "gracefully terminate the active use of the public methods of thiscomponent.this method should be the last one called on a giveninstance of this component.",
	"Method": "void stop(){\r\n    if (!started)\r\n        return;\r\n    threadStop();\r\n    super.stop();\r\n}"
}, {
	"Path": "org.glassfish.weld.connector.WeldUtils.hasScopeAnnotation",
	"Comment": "determine whether the specified class is annotated with a cdi scope annotation.",
	"Method": "boolean hasScopeAnnotation(Class clazz){\r\n    return hasValidAnnotation(clazz, cdiScopeAnnotations, null);\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ExtendedAccessLogValve.stop",
	"Comment": "gracefully terminate the active use of the public methods of thiscomponent.this method should be the last one called on a giveninstance of this component.",
	"Method": "void stop(){\r\n    if (!started)\r\n        return;\r\n    close();\r\n    super.stop();\r\n}"
}, {
	"Path": "com.sun.appserv.web.taglibs.cache.CacheUtil.convertScope",
	"Comment": "converts the string representation of the given scope into an int.",
	"Method": "int convertScope(String scope){\r\n    int ret;\r\n    if (REQUEST_SCOPE.equalsIgnoreCase(scope)) {\r\n        ret = PageContext.REQUEST_SCOPE;\r\n    } else if (SESSION_SCOPE.equalsIgnoreCase(scope)) {\r\n        ret = PageContext.SESSION_SCOPE;\r\n    } else if (APPLICATION_SCOPE.equalsIgnoreCase(scope)) {\r\n        ret = PageContext.APPLICATION_SCOPE;\r\n    } else {\r\n        String msg = _rb.getString(LogFacade.ILLEGAL_SCOPE);\r\n        msg = MessageFormat.format(msg, new Object[] { scope });\r\n        throw new IllegalArgumentException(msg);\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.ServerSynchronizer.synchronize",
	"Comment": "handle a single syncrhonization request for the given serverby adding the needed files to the payload.",
	"Method": "void synchronize(Server server,SyncRequest sr,Payload.Outbound payload,ActionReport report,Logger logger){\r\n    this.logger = logger;\r\n    try {\r\n        if (logger.isLoggable(Level.FINE))\r\n            logger.fine(\"ServerSynchronizer: synchronization request for \" + \"server \" + server.getName() + \", directory \" + sr.dir);\r\n        if (sr.dir.equals(\"config\"))\r\n            synchronizeConfig(payload, server, sr);\r\n        else if (sr.dir.equals(\"applications\"))\r\n            synchronizeApplications(payload, server, sr);\r\n        else if (sr.dir.equals(\"lib\"))\r\n            synchronizeLib(payload, server, sr);\r\n        else if (sr.dir.equals(\"docroot\"))\r\n            synchronizeDocroot(payload, server, sr);\r\n        else if (sr.dir.equals(\"config-specific\"))\r\n            synchronizeConfigSpecificDir(payload, server, sr);\r\n        else {\r\n            report.setActionExitCode(ExitCode.FAILURE);\r\n            report.setMessage(strings.getLocalString(\"serversync.unknown.dir\", \"Unknown directory: {0}\", sr.dir));\r\n            return;\r\n        }\r\n        report.setActionExitCode(ExitCode.SUCCESS);\r\n    } catch (URISyntaxException ex) {\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.fine(\"ServerSynchronizer: Exception processing request\");\r\n            logger.fine(ex.toString());\r\n        }\r\n        report.setActionExitCode(ExitCode.FAILURE);\r\n        report.setMessage(strings.getLocalString(\"serversync.exception.processing\", \"ServerSynchronizer: Exception processing request\"));\r\n        report.setFailureCause(ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.CombinedAccessLogFormatterImpl.appendLogEntry",
	"Comment": "appends an access log entry line, with info obtained from the givenrequest and response objects, to the given charbuffer.",
	"Method": "void appendLogEntry(Request request,Response response,CharBuffer charBuffer){\r\n    super.appendLogEntry(request, response, charBuffer);\r\n    ServletRequest req = request.getRequest();\r\n    HttpServletRequest hreq = (HttpServletRequest) req;\r\n    appendReferer(charBuffer, hreq);\r\n    charBuffer.put(SPACE);\r\n    appendUserAgent(charBuffer, hreq);\r\n}"
}, {
	"Path": "components.taglib.GraphMenuTreeTag.setUnselectedClass",
	"Comment": "the css style class to be applied to the textof unselected nodes. this can be value or a value binding referenceexpression.",
	"Method": "void setUnselectedClass(String styleUnselected){\r\n    this.unselectedClass = styleUnselected;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RegisteredResources.involved",
	"Comment": "checks whether there are any resource objects registered.if there are, the operation returns true, otherwise false.",
	"Method": "boolean involved(){\r\n    boolean result = (nRes != 0);\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentTransaction.getSuspendedTransactions",
	"Comment": "returns all the transactions in the system that are currently suspendedin the form of a sequence of control objects.",
	"Method": "Control[] getSuspendedTransactions(){\r\n    if (!statsOn) {\r\n        throw new NO_IMPLEMENT(\"statistics not on\");\r\n    }\r\n    Control[] result = null;\r\n    int suspNum = suspended != null ? suspended.size() : 0;\r\n    if (suspNum > 0) {\r\n        result = new Control[suspNum];\r\n        Enumeration controls = suspended.elements();\r\n        int pos = 0;\r\n        while (controls.hasMoreElements()) result[pos++] = ((ControlImpl) controls.nextElement()).object();\r\n    } else\r\n        result = new Control[0];\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.listener.CombinedJavaConfigSystemPropertyListener.getSystemProperty",
	"Comment": "return the systemproperty from the list of system properties with thegiven name. if the property is not there, or the list is null, return null.",
	"Method": "SystemProperty getSystemProperty(List<SystemProperty> ssps,String spName){\r\n    if (ssps != null) {\r\n        for (SystemProperty sp : ssps) {\r\n            if (sp.getName().equals(spName)) {\r\n                return sp;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.webservices.monitoring.WebServiceEngineImpl.preProcessRequest",
	"Comment": "callback when a web service request entered the web service containerbefore any processing is done.",
	"Method": "String preProcessRequest(Endpoint endpoint){\r\n    if (globalMessageListener == null)\r\n        return null;\r\n    return globalMessageListener.preProcessRequest(endpoint);\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.CompositeResource.executeDeleteCommandManaged",
	"Comment": "execute a delete admincommand with the specified parameters.",
	"Method": "ActionReporter executeDeleteCommandManaged(String command,ParameterMap parameters){\r\n    return getCompositeUtil().executeDeleteCommandManaged(getSubject(), command, parameters);\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.NonLoginAuthenticator.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (this.info);\r\n}"
}, {
	"Path": "org.glassfish.deployment.versioning.VersioningUtils.isVersionExpressionWithWildCard",
	"Comment": "test if the given application name is a version expression containingany wildcard character. that is to say the version expression is matchingmore than one version.",
	"Method": "Boolean isVersionExpressionWithWildCard(String appName){\r\n    return isVersionExpression(appName) && appName.contains(EXPRESSION_WILDCARD);\r\n}"
}, {
	"Path": "org.apache.naming.ResourceRef.getFactoryClassName",
	"Comment": "retrieves the class name of the factory of the object to which this reference refers.",
	"Method": "String getFactoryClassName(){\r\n    String factory = super.getFactoryClassName();\r\n    if (factory != null) {\r\n        return factory;\r\n    } else {\r\n        factory = System.getProperty(Context.OBJECT_FACTORIES);\r\n        if (factory != null) {\r\n            return null;\r\n        } else {\r\n            return DEFAULT_FACTORY;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.ModuleDescriptor.setArchiveUri",
	"Comment": "sets the archive uri as defined in the application xmlor the full archive path for standalone modules",
	"Method": "void setArchiveUri(String path){\r\n    this.path = path;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RegisteredSyncs.involved",
	"Comment": "checks whether there are any synchronization objects registered.if there are, the operation returns true, otherwise false.",
	"Method": "boolean involved(){\r\n    boolean result = (registered.size() != 0);\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.deploy.shared.AbstractReadableArchive.getExtraData",
	"Comment": "returns any data that could have been calculated as part ofthe descriptor loading.",
	"Method": "U getExtraData(Class<U> dataType){\r\n    return dataType.cast(extraData.get(dataType));\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Response.setLocale",
	"Comment": "set the locale that is appropriate for this response, includingsetting the appropriate character encoding.",
	"Method": "void setLocale(Locale locale){\r\n    if (isCommitted())\r\n        return;\r\n    if (included)\r\n        return;\r\n    coyoteResponse.setLocale(locale);\r\n    if (usingWriter)\r\n        return;\r\n    if (isCharacterEncodingSet) {\r\n        return;\r\n    }\r\n    CharsetMapper cm = getContext().getCharsetMapper();\r\n    String charset = cm.getCharset(locale);\r\n    if (charset != null) {\r\n        coyoteResponse.setCharacterEncoding(charset);\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.resources.ProxyDirContext.list",
	"Comment": "enumerates the names bound in the named context, along with the class names of objects bound to them.",
	"Method": "NamingEnumeration<NameClassPair> list(Name name,NamingEnumeration<NameClassPair> list,String name){\r\n    return dirContext.list(parseName(name));\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setEnableURLRewriting",
	"Comment": "enables or disables the rewriting of urls with the jsessionids ofhttp sessions belonging to this context.",
	"Method": "void setEnableURLRewriting(boolean enableURLRewriting){\r\n    boolean oldEnableURLRewriting = this.enableURLRewriting;\r\n    this.enableURLRewriting = enableURLRewriting;\r\n    support.firePropertyChange(\"enableURLRewriting\", Boolean.valueOf(oldEnableURLRewriting), Boolean.valueOf(this.enableURLRewriting));\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.RulesBase.setNamespaceURI",
	"Comment": "set the namespace uri that will be applied to all subsequentlyadded rule objects.",
	"Method": "void setNamespaceURI(String namespaceURI){\r\n    this.namespaceURI = namespaceURI;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.jmx.NotificationListenerBase.cleanup",
	"Comment": "reset everything so that no listening is occuring andall lists are empty.",
	"Method": "void cleanup(){\r\n    try {\r\n        if (mDelegateListener != null) {\r\n            getConn().removeNotificationListener(JMXUtil.getMBeanServerDelegateObjectName(), mDelegateListener, null, null);\r\n            mDelegateListener = null;\r\n        }\r\n        for (final ObjectName objectName : mListenees) {\r\n            getConn().removeNotificationListener(objectName, this, mFilter, null);\r\n        }\r\n    } catch (JMException e) {\r\n    } catch (IOException e) {\r\n    }\r\n    mListenees.clear();\r\n}"
}, {
	"Path": "com.sun.enterprise.web.ServerConfigLookup.getInstanceSessionManager",
	"Comment": "get the session manager bean from domain.xmlreturn null if not defined or other problem",
	"Method": "SessionManager getInstanceSessionManager(){\r\n    if (configBean == null) {\r\n        return null;\r\n    }\r\n    WebContainer webContainerBean = configBean.getExtensionByType(WebContainer.class);\r\n    if (webContainerBean == null) {\r\n        return null;\r\n    }\r\n    SessionConfig sessionConfigBean = webContainerBean.getSessionConfig();\r\n    if (sessionConfigBean == null) {\r\n        return null;\r\n    }\r\n    return sessionConfigBean.getSessionManager();\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.services.impl.monitor.GrizzlyMonitoring.registerConnectionQueueStatsProvider",
	"Comment": "register connection queue statistics provider for a network listener",
	"Method": "void registerConnectionQueueStatsProvider(String name){\r\n    ConnectionQueueStatsProvider connectionQueueStatsProvider = new ConnectionQueueStatsProvider(name);\r\n    ConnectionQueueStatsProvider oldConnectionQueueStatsProvider = connectionQueueStatsProvidersMap.put(name, connectionQueueStatsProvider);\r\n    if (oldConnectionQueueStatsProvider != null) {\r\n        StatsProviderManager.unregister(oldConnectionQueueStatsProvider);\r\n    }\r\n    StatsProviderManager.register(CONFIG_ELEMENT, PluginPoint.SERVER, subtreePrefix(name) + \"/connection-queue\", connectionQueueStatsProvider);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.beanclass.EjbClassExist.check",
	"Comment": "bean class test.verify that the bean class exist and is loadable.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    try {\r\n        Class.forName(descriptor.getEjbClassName(), false, getVerifierContext().getClassLoader());\r\n        result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"Bean class [ {0} ] exist and is loadable.\", new Object[] { descriptor.getEjbClassName() }));\r\n    } catch (NoClassDefFoundError e) {\r\n        logger.log(Level.FINE, \"Can't find class \" + e.getMessage());\r\n        result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Bean class [ {0} ] does not exist or is not loadable.\", new Object[] { descriptor.getEjbClassName() }));\r\n    } catch (ClassNotFoundException e) {\r\n        Verifier.debug(e);\r\n        result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Bean class [ {0} ] does not exist or is not loadable.\", new Object[] { descriptor.getEjbClassName() }));\r\n    } catch (Exception e) {\r\n        result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Bean class [ {0} ] does not exist or is not loadable.\", new Object[] { descriptor.getEjbClassName() }));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.addContext",
	"Comment": "registers the given context with this virtualserverat the given context root.if this virtualserver has already been started, thegiven context will be started as well.",
	"Method": "void addContext(Context context,String contextRoot){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, LogFacade.VS_ADDED_CONTEXT);\r\n    }\r\n    if (!(context instanceof ContextFacade)) {\r\n        return;\r\n    }\r\n    if (!contextRoot.startsWith(\"/\")) {\r\n        contextRoot = \"/\" + contextRoot;\r\n    }\r\n    ExtendedDeploymentContext deploymentContext = null;\r\n    try {\r\n        if (factory == null)\r\n            factory = services.getService(ArchiveFactory.class);\r\n        ContextFacade facade = (ContextFacade) context;\r\n        File docRoot = facade.getDocRoot();\r\n        ClassLoader classLoader = facade.getClassLoader();\r\n        ReadableArchive archive = factory.openArchive(docRoot);\r\n        if (report == null)\r\n            report = new PlainTextActionReporter();\r\n        ServerEnvironment env = services.getService(ServerEnvironment.class);\r\n        DeployCommandParameters params = new DeployCommandParameters();\r\n        params.contextroot = contextRoot;\r\n        params.enabled = Boolean.FALSE;\r\n        params.origin = OpsParams.Origin.deploy;\r\n        params.virtualservers = getName();\r\n        params.target = \"server\";\r\n        ExtendedDeploymentContext initialContext = new DeploymentContextImpl(report, archive, params, env);\r\n        if (deployment == null)\r\n            deployment = services.getService(Deployment.class);\r\n        ArchiveHandler archiveHandler = deployment.getArchiveHandler(archive);\r\n        if (archiveHandler == null) {\r\n            throw new RuntimeException(\"Cannot find archive handler for source archive\");\r\n        }\r\n        params.name = archiveHandler.getDefaultApplicationName(archive, initialContext);\r\n        Applications apps = domain.getApplications();\r\n        ApplicationInfo appInfo = deployment.get(params.name);\r\n        ApplicationRef appRef = domain.getApplicationRefInServer(params.target, params.name);\r\n        if (appInfo != null && appRef != null) {\r\n            if (appRef.getVirtualServers().contains(getName())) {\r\n                throw new ConfigException(\"Context with name \" + params.name + \" is already registered on virtual server \" + getName());\r\n            } else {\r\n                String virtualServers = appRef.getVirtualServers();\r\n                virtualServers = virtualServers + \",\" + getName();\r\n                params.virtualservers = virtualServers;\r\n                params.force = Boolean.TRUE;\r\n                if (_logger.isLoggable(Level.FINE)) {\r\n                    _logger.log(Level.FINE, \"Virtual server \" + getName() + \" added to context \" + params.name);\r\n                }\r\n                return;\r\n            }\r\n        }\r\n        deploymentContext = deployment.getBuilder(_logger, params, report).source(archive).archiveHandler(archiveHandler).build(initialContext);\r\n        Properties properties = new Properties();\r\n        deploymentContext.getAppProps().putAll(properties);\r\n        if (classLoader != null) {\r\n            ClassLoader parentCL = clh.createApplicationParentCL(classLoader, deploymentContext);\r\n            ClassLoader cl = archiveHandler.getClassLoader(parentCL, deploymentContext);\r\n            deploymentContext.setClassLoader(cl);\r\n        }\r\n        ApplicationConfigInfo savedAppConfig = new ApplicationConfigInfo(apps.getModule(com.sun.enterprise.config.serverbeans.Application.class, params.name));\r\n        Properties appProps = deploymentContext.getAppProps();\r\n        String appLocation = DeploymentUtils.relativizeWithinDomainIfPossible(deploymentContext.getSource().getURI());\r\n        appProps.setProperty(ServerTags.LOCATION, appLocation);\r\n        appProps.setProperty(ServerTags.OBJECT_TYPE, \"user\");\r\n        appProps.setProperty(ServerTags.CONTEXT_ROOT, contextRoot);\r\n        savedAppConfig.store(appProps);\r\n        Transaction t = deployment.prepareAppConfigChanges(deploymentContext);\r\n        appInfo = deployment.deploy(deploymentContext);\r\n        if (appInfo != null) {\r\n            facade.setAppName(appInfo.getName());\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, LogFacade.VS_ADDED_CONTEXT, new Object[] { getName(), appInfo.getName() });\r\n            }\r\n            deployment.registerAppInDomainXML(appInfo, deploymentContext, t);\r\n        } else {\r\n            if (report.getActionExitCode().equals(ActionReport.ExitCode.FAILURE)) {\r\n                throw new ConfigException(report.getMessage());\r\n            }\r\n        }\r\n        File file = null;\r\n        boolean delete = true;\r\n        com.sun.enterprise.config.serverbeans.Application appBean = apps.getApplication(params.name);\r\n        if (appBean != null) {\r\n            file = new File(deploymentContext.getSource().getURI().getPath(), \"/WEB-INF/web.xml\");\r\n            if (file.exists()) {\r\n                delete = false;\r\n            }\r\n            updateWebXml(facade, file);\r\n        } else {\r\n            _logger.log(Level.SEVERE, LogFacade.APP_NOT_FOUND);\r\n        }\r\n        ReadableArchive source = appInfo.getSource();\r\n        UndeployCommandParameters undeployParams = new UndeployCommandParameters(params.name);\r\n        undeployParams.origin = UndeployCommandParameters.Origin.undeploy;\r\n        undeployParams.target = \"server\";\r\n        ExtendedDeploymentContext undeploymentContext = deployment.getBuilder(_logger, undeployParams, report).source(source).build();\r\n        deployment.undeploy(params.name, undeploymentContext);\r\n        params.origin = DeployCommandParameters.Origin.load;\r\n        params.enabled = Boolean.TRUE;\r\n        archive = factory.openArchive(docRoot);\r\n        deploymentContext = deployment.getBuilder(_logger, params, report).source(archive).build();\r\n        if (classLoader != null) {\r\n            ClassLoader parentCL = clh.createApplicationParentCL(classLoader, deploymentContext);\r\n            archiveHandler = deployment.getArchiveHandler(archive);\r\n            ClassLoader cl = archiveHandler.getClassLoader(parentCL, deploymentContext);\r\n            deploymentContext.setClassLoader(cl);\r\n        }\r\n        deployment.deploy(deploymentContext);\r\n        deployment.updateAppEnabledAttributeInDomainXML(params.name, params.target, true);\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, LogFacade.VS_ENABLED_CONTEXT, new Object[] { getName(), params.name() });\r\n        }\r\n        if (delete) {\r\n            if (file != null) {\r\n                if (file.exists() && !file.delete()) {\r\n                    String path = file.toString();\r\n                    _logger.log(Level.WARNING, LogFacade.UNABLE_TO_DELETE, path);\r\n                }\r\n            }\r\n        }\r\n        if (contextRoot.equals(\"/\")) {\r\n            contextRoot = \"\";\r\n        }\r\n        WebModule wm = (WebModule) findChild(contextRoot);\r\n        if (wm != null) {\r\n            facade.setUnwrappedContext(wm);\r\n            wm.setEmbedded(true);\r\n            if (config != null) {\r\n                wm.setDefaultWebXml(config.getDefaultWebXml());\r\n            }\r\n        } else {\r\n            throw new ConfigException(\"Deployed app not found \" + contextRoot);\r\n        }\r\n        if (deploymentContext != null) {\r\n            deploymentContext.postDeployClean(true);\r\n        }\r\n    } catch (Exception ex) {\r\n        if (deployment != null && deploymentContext != null) {\r\n            deploymentContext.clean();\r\n        }\r\n        throw new GlassFishException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutoUndeploymentOperation.newInstance",
	"Comment": "creates a new, injected, and initialized autoundeploymentoperation object.",
	"Method": "AutoUndeploymentOperation newInstance(ServiceLocator habitat,File appFile,String name,String target){\r\n    AutoUndeploymentOperation o = (AutoUndeploymentOperation) habitat.getService(AutoUndeploymentOperation.class);\r\n    o.init(appFile, name, target);\r\n    return o;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.NestingInfo.addChild",
	"Comment": "adds the given subcoordinator as a child.if the reference is already in the set, the operation returns false.",
	"Method": "boolean addChild(CoordinatorImpl child){\r\n    boolean result = !childSet.contains(child);\r\n    if (result)\r\n        childSet.addElement(child);\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.archivist.WebArchivist.setDescriptor",
	"Comment": "archivist read xml deployment descriptors and keep theparsed result in the dol descriptor instances. sets the descriptorfor a particular archivst type",
	"Method": "void setDescriptor(Application descriptor){\r\n    java.util.Set webBundles = descriptor.getBundleDescriptors(WebBundleDescriptorImpl.class);\r\n    if (webBundles.size() > 0) {\r\n        this.descriptor = (WebBundleDescriptorImpl) webBundles.iterator().next();\r\n        if (this.descriptor.getModuleDescriptor().isStandalone())\r\n            return;\r\n        else\r\n            this.descriptor = null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.ProxyHandlerImpl.getSSLKeysize",
	"Comment": "returns the ssl keysize with which the original client request thatwas intercepted by the ssl offloader has been protected, and whichthe ssl offloader has added as a custom request header on thegiven request.",
	"Method": "int getSSLKeysize(HttpServletRequest request){\r\n    int keySize = -1;\r\n    String header = request.getHeader(Constants.PROXY_KEYSIZE);\r\n    if (header != null) {\r\n        keySize = Integer.parseInt(header);\r\n    }\r\n    return keySize;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.ReportHandler.createNode",
	"Comment": "this method is responsible for creating nodes in the dom tree likewhere modulename is ejb and status is failed.",
	"Method": "void createNode(String moduleName,String status){\r\n    NodeList nodeList;\r\n    Element moduleNode;\r\n    nodeList = document.getElementsByTagName(moduleName);\r\n    if (nodeList.getLength() == 0) {\r\n        moduleNode = document.createElement(moduleName);\r\n        rootNode.appendChild(moduleNode);\r\n    } else {\r\n        moduleNode = (Element) nodeList.item(0);\r\n    }\r\n    nodeList = moduleNode.getChildNodes();\r\n    Element statusNode = null;\r\n    if (nodeList.getLength() == 0) {\r\n        statusNode = document.createElement(status);\r\n        moduleNode.appendChild(statusNode);\r\n    } else {\r\n        for (int j = 0; j < nodeList.getLength(); j++) {\r\n            if (((Element) nodeList.item(j)).getTagName().equals(status)) {\r\n                statusNode = (Element) nodeList.item(j);\r\n                break;\r\n            }\r\n        }\r\n        if (statusNode == null) {\r\n            statusNode = document.createElement(status);\r\n            moduleNode.appendChild(statusNode);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.get_transaction_name",
	"Comment": "returns a printable string that represents the subcoordinator.this operation references only the global tid, and so can beimplemented locally in a proxy class.",
	"Method": "String get_transaction_name(){\r\n    String result = null;\r\n    if (tranState != null) {\r\n        result = name;\r\n    } else {\r\n        INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.Completed, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.AbstractRulesImpl.getNamespaceURI",
	"Comment": "return the namespace uri that will be applied to all subsequentlyadded rule objects.",
	"Method": "String getNamespaceURI(){\r\n    return namespaceURI;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.removeMessageDestinationRef",
	"Comment": "remove any message destination ref with the specified name.",
	"Method": "void removeMessageDestinationRef(String name){\r\n    namingResources.removeMessageDestinationRef(name);\r\n    if (notifyContainerListeners) {\r\n        fireContainerEvent(\"removeMessageDestinationRef\", name);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebResourceCollectionImpl.getHttpMethodOmissionsAsArray",
	"Comment": "returns the httpmethodomissions this collection has in an array of stringsthis is added to speed up processing while creating webresource permissions",
	"Method": "String[] getHttpMethodOmissionsAsArray(){\r\n    if (httpMethodOmissions == null) {\r\n        return (String[]) null;\r\n    }\r\n    return httpMethodOmissions.toArray(new String[httpMethodOmissions.size()]);\r\n}"
}, {
	"Path": "com.sun.appserv.web.taglibs.cache.CacheRequestListener.requestInitialized",
	"Comment": "receives notification that the request is about to enter the scopeof the web application, and adds newly created cache for jsp tagbody invocations as a request attribute.",
	"Method": "void requestInitialized(ServletRequestEvent sre){\r\n    ServletContext context = sre.getServletContext();\r\n    CacheManager cm = (CacheManager) context.getAttribute(CacheManager.CACHE_MANAGER_ATTR_NAME);\r\n    if (cm == null) {\r\n        cm = new CacheManager();\r\n    }\r\n    Cache cache = null;\r\n    try {\r\n        cache = cm.createCache();\r\n    } catch (Exception ex) {\r\n    }\r\n    if (cache != null) {\r\n        ServletRequest req = sre.getServletRequest();\r\n        req.setAttribute(Constants.JSPTAG_CACHE_KEY, cache);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.getAttributeNames",
	"Comment": "return an enumeration of string objectscontaining the names of the objects bound to this session.",
	"Method": "Enumeration<String> getAttributeNames(){\r\n    if (!isValid())\r\n        throw new IllegalStateException(\"getAttributeNames: \" + rb.getString(LogFacade.SESSION_INVALIDATED_EXCEPTION));\r\n    return (new Enumerator<String>(attributes.keySet(), true));\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapperValve.exception",
	"Comment": "handle the specified servletexception encountered while processingthe specified request to produce the specified response.anyexceptions that occur during generation of the exception report arelogged and swallowed.",
	"Method": "void exception(Request request,Response response,Throwable exception){\r\n    ServletRequest sreq = request.getRequest();\r\n    sreq.setAttribute(RequestDispatcher.ERROR_EXCEPTION, exception);\r\n    ServletResponse sresponse = response.getResponse();\r\n    ((HttpServletResponse) sresponse).setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.DefaultTransactionService.identify_ORB",
	"Comment": "request the transaction service to identify itself with a communicationmanager.multiple communication managers may request a transactionservice to identify itself.",
	"Method": "void identify_ORB(ORB orb,TSIdentification ident,Properties properties){\r\n    if (this.orb == null) {\r\n        this.orb = orb;\r\n        Configuration.setORB(orb);\r\n        Configuration.setProperties(properties);\r\n        Configuration.setProxyChecker(this);\r\n    }\r\n    if (!poasCreated) {\r\n        setServerName(properties);\r\n        try {\r\n            if (orb != null)\r\n                createPOAs();\r\n        } catch (Exception exc) {\r\n            _logger.log(Level.WARNING, \"jts.unexpected_error_when_creating_poa\", exc);\r\n            throw new INTERNAL(MinorCode.TSCreateFailed, CompletionStatus.COMPLETED_NO);\r\n        }\r\n    }\r\n    if (currentInstance == null)\r\n        try {\r\n            currentInstance = new CurrentImpl();\r\n        } catch (Exception exc) {\r\n            _logger.log(Level.WARNING, \"jts.unexpected_error_when_creating_current\", exc);\r\n            throw new INTERNAL(MinorCode.TSCreateFailed, CompletionStatus.COMPLETED_NO);\r\n        }\r\n    if (ident != null)\r\n        SenderReceiver.identify(ident);\r\n    if (recoverable && namingContext == null)\r\n        try {\r\n            namingContext = NamingContextHelper.narrow(orb.resolve_initial_references(\"NameService\"));\r\n        } catch (InvalidName inexc) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"jts.orb_not_running\");\r\n            }\r\n        } catch (Exception exc) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"jts.orb_not_running\");\r\n            }\r\n        }\r\n    if (factoryInstance == null)\r\n        try {\r\n            boolean localFactory = true;\r\n            TransactionFactory factory = null;\r\n            factoryInstance = new TransactionFactoryImpl();\r\n            if (localFactory) {\r\n                factory = (TransactionFactory) factoryInstance;\r\n            } else {\r\n                factory = factoryInstance.object();\r\n            }\r\n            Configuration.setFactory(factory, localFactory);\r\n            if (Configuration.isLocalFactory() == false && namingContext != null) {\r\n                NameComponent nc = new NameComponent(TransactionFactoryHelper.id(), \"\");\r\n                NameComponent[] path = { nc };\r\n                namingContext.rebind(path, factory);\r\n            }\r\n        } catch (Exception exc) {\r\n            _logger.log(Level.WARNING, \"jts.cannot_register_with_orb\", \"TransactionFactory\");\r\n        }\r\n    active = true;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.remote.RemoteCommand.getManHabitat",
	"Comment": "return a servicelocator used just for reading man pages from themodules in the modules directory.",
	"Method": "ServiceLocator getManHabitat(){\r\n    if (manServiceLocator != null)\r\n        return manServiceLocator;\r\n    ModulesRegistry registry = new StaticModulesRegistry(getModuleClassLoader());\r\n    ServiceLocator serviceLocator = registry.createServiceLocator(\"default\");\r\n    manServiceLocator = serviceLocator;\r\n    return manServiceLocator;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.CLIProcessExecutor.exitValue",
	"Comment": "return the exit value of this process.if process is null, then there is no process runningtherefore the return value is 0.",
	"Method": "int exitValue(){\r\n    if (process == null)\r\n        return -1;\r\n    return process.exitValue();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.DelegatedTimeoutManager.setTimeout",
	"Comment": "sets the timeout for the transaction to the specified type and time inseconds.if the type is none, the timeout for the transaction iscancelled, otherwise the current timeout for the transaction is modifiedto be of the new type and duration.",
	"Method": "boolean setTimeout(Long localTID,int timeoutType,int seconds){\r\n    boolean result = true;\r\n    DelegatedTimeoutInfo timeoutInfo = null;\r\n    switch(timeoutType) {\r\n        case DelegatedTimeoutManager.ACTIVE_TIMEOUT:\r\n            if (!isSetTimeout) {\r\n                initSetTimeout();\r\n            }\r\n            timeoutInfo = new DelegatedTimeoutInfo();\r\n            timeoutInfo.expireTime = new Date().getTime() + seconds * 1000L;\r\n            timeoutInfo.localTID = localTID;\r\n            timeoutInfo.timeoutType = timeoutType;\r\n            pendingTimeouts.put(localTID, timeoutInfo);\r\n            break;\r\n        case TimeoutManager.IN_DOUBT_TIMEOUT:\r\n            if (!isSetTimeout) {\r\n                initSetTimeout();\r\n            }\r\n            timeoutInfo = new DelegatedTimeoutInfo();\r\n            timeoutInfo.expireTime = new Date().getTime() + seconds * 1000L;\r\n            timeoutInfo.localTID = localTID;\r\n            timeoutInfo.timeoutType = timeoutType;\r\n            indoubtTimeouts.put(localTID, timeoutInfo);\r\n            break;\r\n        default:\r\n            if (!isSetTimeout)\r\n                break;\r\n            result = (pendingTimeouts.remove(localTID) != null);\r\n            if (!result)\r\n                result = (indoubtTimeouts.remove(localTID) != null);\r\n            if (quiescing && pendingTimeouts.isEmpty() && indoubtTimeouts.isEmpty()) {\r\n                timeoutThread.stop();\r\n                timeoutActive = false;\r\n            }\r\n            break;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.getInitParameterNames",
	"Comment": "return the set of initialization parameter names defined for thisservlet.if none are defined, an empty enumeration is returned.",
	"Method": "Enumeration<String> getInitParameterNames(){\r\n    synchronized (parameters) {\r\n        return (new Enumerator<String>(parameters.keySet()));\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.FilterDef.setInitParameters",
	"Comment": "sets the initialization parameters contained in the given mapon this filter.",
	"Method": "Set<String> setInitParameters(Map<String, String> initParameters){\r\n    if (null == initParameters) {\r\n        throw new IllegalArgumentException(\"Null init parameters\");\r\n    }\r\n    synchronized (parameters) {\r\n        Set<String> conflicts = null;\r\n        for (Map.Entry<String, String> e : initParameters.entrySet()) {\r\n            if (e.getKey() == null || e.getValue() == null) {\r\n                throw new IllegalArgumentException(\"Null parameter name or value\");\r\n            }\r\n            if (parameters.containsKey(e.getKey())) {\r\n                if (conflicts == null) {\r\n                    conflicts = new HashSet<String>();\r\n                }\r\n                conflicts.add(e.getKey());\r\n            }\r\n        }\r\n        if (conflicts != null) {\r\n            return conflicts;\r\n        }\r\n        for (Map.Entry<String, String> e : initParameters.entrySet()) {\r\n            setInitParameter(e.getKey(), e.getValue(), true);\r\n        }\r\n        return Collections.emptySet();\r\n    }\r\n}"
}, {
	"Path": "demo.model.RepeaterBean.create",
	"Comment": "create a new empty row to be filled in for a new recordin the database.",
	"Method": "String create(){\r\n    append(\"CREATE NEW ROW button pressed\");\r\n    clear();\r\n    List list = getCustomers();\r\n    if (list != null) {\r\n        CustomerBean customer = new CustomerBean();\r\n        list.add(customer);\r\n        int index = data.getRowIndex();\r\n        data.setRowIndex(list.size() - 1);\r\n        created.setSelected(true);\r\n        data.setRowIndex(index);\r\n    }\r\n    scroll(list.size());\r\n    return (null);\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.ParameterParser.parseQuotedToken",
	"Comment": "parses out a token until any of the given terminatorsis encountered outside the quotation marks.",
	"Method": "String parseQuotedToken(char[] terminators){\r\n    char ch;\r\n    i1 = pos;\r\n    i2 = pos;\r\n    boolean quoted = false;\r\n    boolean charEscaped = false;\r\n    while (hasChar()) {\r\n        ch = chars[pos];\r\n        if (!quoted && isOneOf(ch, terminators)) {\r\n            break;\r\n        }\r\n        if (!charEscaped && ch == '\"') {\r\n            quoted = !quoted;\r\n        }\r\n        charEscaped = (!charEscaped && ch == '\\\\');\r\n        i2++;\r\n        pos++;\r\n    }\r\n    return getToken(true);\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.mbean.SystemInfoFactory.createInstance",
	"Comment": "create the singleton instance.intended for exclusive use by the appropriate codeto initialize once at startup.",
	"Method": "SystemInfoImpl createInstance(MBeanServer server){\r\n    if (INSTANCE == null) {\r\n        INSTANCE = new SystemInfoImpl(server);\r\n        new SystemInfoIniter(server, INSTANCE).init();\r\n    } else {\r\n    }\r\n    return INSTANCE;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.createFilter",
	"Comment": "instantiates the given filter class and performs any requiredresource injection into the new filter instance before returningit.",
	"Method": "T createFilter(Class<T> clazz){\r\n    if (SecurityUtil.isPackageProtectionEnabled()) {\r\n        return (T) doPrivileged(\"createFilter\", new Object[] { clazz });\r\n    } else {\r\n        return context.createFilter(clazz);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.server.logging.GFFileHandler.getCurrentLogFile",
	"Comment": "a simple getter to access the current log file written bythis filehandler.",
	"Method": "File getCurrentLogFile(){\r\n    return absoluteFile;\r\n}"
}, {
	"Path": "org.glassfish.weld.connector.WeldCompositeSniffer.supportsArchiveType",
	"Comment": "this api is used to help determine if the sniffer should recognizethe current archive.if the sniffer does not support the archive type associated withthe current deployment, the sniffer should not recognize the archive.",
	"Method": "boolean supportsArchiveType(ArchiveType archiveType){\r\n    if (archiveType.toString().equals(ModuleType.EAR.toString())) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.catalina.session.ManagerBase.getRejectedSessions",
	"Comment": "gets the number of session creations that failed due tomaxactivesessions",
	"Method": "int getRejectedSessions(){\r\n    return rejectedSessions;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationFilterConfig.getInitParameter",
	"Comment": "return a string containing the value of the namedinitialization parameter, or null if the parameterdoes not exist.",
	"Method": "String getInitParameter(String name){\r\n    return filterDef.getInitParameter(name);\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.invalidate",
	"Comment": "invalidates this session and unbinds any objects bound to it.",
	"Method": "void invalidate(){\r\n    if (!isValid)\r\n        throw new IllegalStateException(\"invalidate: \" + rb.getString(LogFacade.SESSION_INVALIDATED_EXCEPTION));\r\n    if (!this.isForegroundLocked()) {\r\n        this.getSessionLockForForeground();\r\n    }\r\n    try {\r\n        expire();\r\n    } finally {\r\n        this.unlockForeground();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.services.SMFService.getTimeoutSeconds",
	"Comment": "returns timeout in seconds before the master boot restarter shouldgive up starting this service.",
	"Method": "int getTimeoutSeconds(){\r\n    final int to = Integer.parseInt(getTokenMap().get(TIMEOUT_SECONDS_TN));\r\n    return (to);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.domain.DomainPortValidator.checkPortPrivilege",
	"Comment": "check if any of the port values are below 1024. if below 1024, thendisplay a warning message.",
	"Method": "void checkPortPrivilege(Integer[] ports){\r\n    for (Integer port : ports) {\r\n        final int p = port.intValue();\r\n        if (p < 1024) {\r\n            _logger.warning(_strings.get(\"PortPrivilege\"));\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.embeddable.GlassFishRuntime.bootstrap",
	"Comment": "bootstrap glassfish runtime based on runtime configuration passed in the bootstrapproperties object.calling this method twice will throw a glassfishexception",
	"Method": "GlassFishRuntime bootstrap(GlassFishRuntime bootstrap,BootstrapProperties bootstrapProperties,GlassFishRuntime bootstrap,BootstrapProperties bootstrapProperties,ClassLoader cl){\r\n    return _bootstrap(bootstrapProperties, cl);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.getConfigClass",
	"Comment": "return the java class name of the context configuration classfor new web applications.",
	"Method": "String getConfigClass(){\r\n    return (this.configClass);\r\n}"
}, {
	"Path": "org.glassfish.api.logging.LogHelper.log",
	"Comment": "logs a message with the given level, message, parameters and throwable.",
	"Method": "void log(Logger logger,Level level,String messageId,Throwable thrown,Object params){\r\n    LogRecord rec = new LogRecord(level, messageId);\r\n    rec.setLoggerName(logger.getName());\r\n    rec.setResourceBundleName(logger.getResourceBundleName());\r\n    rec.setResourceBundle(logger.getResourceBundle());\r\n    rec.setParameters(params);\r\n    rec.setThrown(thrown);\r\n    logger.log(rec);\r\n}"
}, {
	"Path": "org.glassfish.internal.embedded.ScatteredArchive.getName",
	"Comment": "returns the name of the archive.implementations should not return null.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityCollection.addMethod",
	"Comment": "add an http request method to be part of this web resource collection.",
	"Method": "void addMethod(String method){\r\n    if (method == null)\r\n        return;\r\n    String[] results = new String[methods.length + 1];\r\n    for (int i = 0; i < methods.length; i++) results[i] = methods[i];\r\n    results[methods.length] = method;\r\n    methods = results;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getEffectiveSessionTrackingModes",
	"Comment": "gets the session tracking modes that are in effect for thisservletcontext.",
	"Method": "Set<SessionTrackingMode> getEffectiveSessionTrackingModes(){\r\n    return (sessionTrackingModes != null ? new HashSet(sessionTrackingModes) : getDefaultSessionTrackingModes());\r\n}"
}, {
	"Path": "com.sun.enterprise.security.web.GlassFishSingleSignOn.run",
	"Comment": "the background thread that checks for sso timeouts and shutdown.",
	"Method": "void run(){\r\n    while (!threadDone) {\r\n        threadSleep();\r\n        processExpires();\r\n    }\r\n}"
}, {
	"Path": "testmbeans.Reg.setAttribute",
	"Comment": "sets the value of the specified attribute of the dynamicmbean.",
	"Method": "void setAttribute(Attribute attribute){\r\n    if (attribute.getName().equals(\"Name\")) {\r\n    } else\r\n        throw new AttributeNotFoundException(\"Unknown Attribute \" + attribute.getName());\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModuleConfig.getBean",
	"Comment": "return the configuration information specified in server.xml.",
	"Method": "Application getBean(){\r\n    return _wmBean;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.base.UnprocessedConfigChange.getSource",
	"Comment": "preferred value is an objectname, otherwise a string suitable for a user to understandwhat might have been affected.can be null.",
	"Method": "Object getSource(){\r\n    return mSource;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationDispatcher.dispatch",
	"Comment": "dispatches the given request and response to the resourcefor which this dispatcher was acquired.any runtime exceptions, ioexception, or servletexception thrownby the target will be propagated to the caller.",
	"Method": "void dispatch(ServletRequest request,ServletResponse response,DispatcherType dispatcherType){\r\n    if (DispatcherType.FORWARD != dispatcherType && DispatcherType.ERROR != dispatcherType && DispatcherType.ASYNC != dispatcherType) {\r\n        throw new IllegalArgumentException(\"Illegal dispatcher type\");\r\n    }\r\n    boolean isCommit = (DispatcherType.FORWARD == dispatcherType || DispatcherType.ERROR == dispatcherType);\r\n    if (Globals.IS_SECURITY_ENABLED) {\r\n        try {\r\n            PrivilegedDispatch dp = new PrivilegedDispatch(request, response, dispatcherType);\r\n            AccessController.doPrivileged(dp);\r\n            if (isCommit && !request.isAsyncStarted()) {\r\n                ApplicationDispatcherForward.commit(request, response, context, wrapper);\r\n            }\r\n        } catch (PrivilegedActionException pe) {\r\n            Exception e = pe.getException();\r\n            if (e instanceof ServletException)\r\n                throw (ServletException) e;\r\n            throw (IOException) e;\r\n        }\r\n    } else {\r\n        doDispatch(request, response, dispatcherType);\r\n        if (isCommit && !request.isAsyncStarted()) {\r\n            ApplicationDispatcherForward.commit(request, response, context, wrapper);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.AdminUtil.getSamplingStartTime",
	"Comment": "returns the time in milliseconds, since the begining of time, when thesampling window was started.",
	"Method": "long getSamplingStartTime(){\r\n    return lSampleStartTime;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.TagLibTest.getRetType",
	"Comment": "this method returns the first token of this string, which must be the returntype of the method.",
	"Method": "String getRetType(String signature){\r\n    String[] tokens = (signature.split(\"\\\\s\"));\r\n    return tokens[0];\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteRestAdminCommand.checkConnect",
	"Comment": "check that the connection was successful and handle any error responses,turning them into exceptions.",
	"Method": "String checkConnect(HttpURLConnection urlConnection){\r\n    int code = urlConnection.getResponseCode();\r\n    if (logger.isLoggable(Level.FINER)) {\r\n        logger.log(Level.FINER, \"Response code: \" + code);\r\n    }\r\n    if (code == -1) {\r\n        URL url = urlConnection.getURL();\r\n        throw new CommandException(strings.get(\"NotHttpResponse\", url.getHost(), url.getPort()));\r\n    }\r\n    if (code == HttpURLConnection.HTTP_UNAUTHORIZED) {\r\n        throw new AuthenticationException(reportAuthenticationException());\r\n    }\r\n    if (code == HttpURLConnection.HTTP_PRECON_FAILED) {\r\n        throw new CommandValidationException(\"Code: \" + HttpURLConnection.HTTP_PRECON_FAILED + \": Cached CommandModel is invalid.\");\r\n    }\r\n    if (code == HttpURLConnection.HTTP_NOT_FOUND) {\r\n        try {\r\n            throw new InvalidCommandException(ProprietaryReaderFactory.<String>getReader(String.class, urlConnection.getContentType()).readFrom(urlConnection.getErrorStream(), urlConnection.getContentType()));\r\n        } catch (IOException ioex) {\r\n            throw new InvalidCommandException(urlConnection.getResponseMessage());\r\n        }\r\n    }\r\n    if (isStatusRedirection(code)) {\r\n        return urlConnection.getHeaderField(\"Location\");\r\n    }\r\n    if (code != HttpURLConnection.HTTP_OK && code != HttpURLConnection.HTTP_INTERNAL_ERROR) {\r\n        throw new CommandException(strings.get(\"BadResponse\", String.valueOf(code), urlConnection.getResponseMessage()));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.NamingResources.addResourceEnvRef",
	"Comment": "add a resource environment reference for this web application.",
	"Method": "void addResourceEnvRef(String name,String type){\r\n    if (entries.containsKey(name)) {\r\n        return;\r\n    } else {\r\n        entries.put(name, type);\r\n    }\r\n    synchronized (resourceEnvRefs) {\r\n        resourceEnvRefs.put(name, type);\r\n    }\r\n    support.firePropertyChange(\"resourceEnvRef\", null, name + \":\" + type);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.createListener",
	"Comment": "instantiates the given eventlistener class and performs anyrequired resource injection into the new eventlistener instancebefore returning it.",
	"Method": "T createListener(Class<T> clazz){\r\n    if (!ServletContextListener.class.isAssignableFrom(clazz) && !ServletContextAttributeListener.class.isAssignableFrom(clazz) && !ServletRequestListener.class.isAssignableFrom(clazz) && !ServletRequestAttributeListener.class.isAssignableFrom(clazz) && !HttpSessionAttributeListener.class.isAssignableFrom(clazz) && !HttpSessionIdListener.class.isAssignableFrom(clazz) && !HttpSessionListener.class.isAssignableFrom(clazz)) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.UNABLE_ADD_LISTENER_EXCEPTION), new Object[] { clazz.getName() });\r\n        throw new IllegalArgumentException(msg);\r\n    }\r\n    try {\r\n        return createListenerInstance(clazz);\r\n    } catch (Throwable t) {\r\n        throw new ServletException(t);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.readers.InputObject.isNull",
	"Comment": "determine if the value associated with the key is null or if there is no value.",
	"Method": "boolean isNull(String key){\r\n    Object value = getValue(key);\r\n    if (value == null)\r\n        return true;\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.SecurityConstraint.getWebResourceCollection",
	"Comment": "gets the web resource collection for this security constraint",
	"Method": "Set<WebResourceCollection> getWebResourceCollection(){\r\n    return this.webResourceCollection;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.getAppBase",
	"Comment": "return the application root for this host.this can be an absolutepathname, a relative pathname, or a url.",
	"Method": "String getAppBase(){\r\n    return (this.appBase);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteRestAdminCommand.preinit",
	"Comment": "can be called to start async preinitialisation. it can help a littlebit in usage performance.",
	"Method": "void preinit(){\r\n    Thread thread = new Thread(new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            ProprietaryReaderFactory.getReader(Class.class, \"not/defined\");\r\n            ProprietaryWriterFactory.getWriter(Class.class);\r\n        }\r\n    });\r\n    thread.setDaemon(true);\r\n    thread.start();\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteRestAdminCommand.preinit",
	"Comment": "can be called to start async preinitialisation. it can help a littlebit in usage performance.",
	"Method": "void preinit(){\r\n    ProprietaryReaderFactory.getReader(Class.class, \"not/defined\");\r\n    ProprietaryWriterFactory.getWriter(Class.class);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Response.getContentLength",
	"Comment": "return the content length that was set or calculated for this response.",
	"Method": "int getContentLength(){\r\n    return coyoteResponse.getContentLength();\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.DeleteProfiler.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<JavaConfig>() {\r\n            public Object run(JavaConfig param) throws PropertyVetoException, TransactionFailure {\r\n                if (param.getProfiler() != null) {\r\n                    param.setProfiler(null);\r\n                    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n                    return param;\r\n                }\r\n                report.setMessage(localStrings.getLocalString(\"delete.profiler.notfound\", \"delete failed, profiler not found\"));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return null;\r\n            }\r\n        }, javaConfig);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(localStrings.getLocalString(\"delete.profiler.fail\", \"delete failed \"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.DeleteProfiler.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    if (param.getProfiler() != null) {\r\n        param.setProfiler(null);\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n        return param;\r\n    }\r\n    report.setMessage(localStrings.getLocalString(\"delete.profiler.notfound\", \"delete failed, profiler not found\"));\r\n    report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.NodeUtils.getGlassFishVersionOnNode",
	"Comment": "get the version string from a glassfish installation on the node.",
	"Method": "String getGlassFishVersionOnNode(Node node,AdminCommandContext context){\r\n    if (node == null)\r\n        return \"\";\r\n    List<String> command = new ArrayList<String>();\r\n    command.add(\"version\");\r\n    command.add(\"--local\");\r\n    command.add(\"--terse\");\r\n    NodeRunner nr = new NodeRunner(habitat, logger);\r\n    StringBuilder output = new StringBuilder();\r\n    try {\r\n        int commandStatus = nr.runAdminCommandOnNode(node, output, command, context);\r\n        if (commandStatus != 0) {\r\n            return \"unknown version: \" + output.toString();\r\n        }\r\n    } catch (Exception e) {\r\n        throw new CommandValidationException(Strings.get(\"failed.to.run\", command.toString(), node.getNodeHost()), e);\r\n    }\r\n    return output.toString().trim();\r\n}"
}, {
	"Path": "org.apache.naming.NamingContext.addToEnvironment",
	"Comment": "adds a new environment property to the environment of this context. if the property already exists, its value is overwritten.",
	"Method": "Object addToEnvironment(String propName,Object propVal){\r\n    return env.put(propName, propVal);\r\n}"
}, {
	"Path": "org.apache.catalina.ssi.ExpressionParseTree.evaluateTree",
	"Comment": "evaluates the tree and returns true or false. the specified ssimediatoris used to resolve variable references.",
	"Method": "boolean evaluateTree(){\r\n    return root.evaluate();\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.node.WebCommonNode.endElement",
	"Comment": "receives notification of the end of an xml element by the parser",
	"Method": "boolean endElement(XMLElement element){\r\n    if (WebTagNames.DISTRIBUTABLE.equals(element.getQName())) {\r\n        descriptor.setDistributable(true);\r\n        return false;\r\n    } else {\r\n        boolean allDone = super.endElement(element);\r\n        if (allDone && servletMappings != null) {\r\n            for (Iterator<String> keys = servletMappings.keySet().iterator(); keys.hasNext(); ) {\r\n                String servletName = keys.next();\r\n                Vector<String> mappings = servletMappings.get(servletName);\r\n                WebComponentDescriptor servlet = descriptor.getWebComponentByCanonicalName(servletName);\r\n                if (servlet != null) {\r\n                    for (Iterator<String> mapping = mappings.iterator(); mapping.hasNext(); ) {\r\n                        servlet.addUrlPattern(mapping.next());\r\n                    }\r\n                } else {\r\n                    throw new RuntimeException(\"There is no web component by the name of \" + servletName + \" here.\");\r\n                }\r\n            }\r\n        }\r\n        return allDone;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.DigestAuthenticator.parseUsername",
	"Comment": "parse the username from the specified authorization string.if nonecan be identified, return null",
	"Method": "String parseUsername(String authorization){\r\n    if (authorization == null)\r\n        return (null);\r\n    if (!authorization.startsWith(\"Digest \"))\r\n        return (null);\r\n    authorization = authorization.substring(7).trim();\r\n    StringTokenizer commaTokenizer = new StringTokenizer(authorization, \",\");\r\n    while (commaTokenizer.hasMoreTokens()) {\r\n        String currentToken = commaTokenizer.nextToken();\r\n        int equalSign = currentToken.indexOf('=');\r\n        if (equalSign < 0)\r\n            return null;\r\n        String currentTokenName = currentToken.substring(0, equalSign).trim();\r\n        String currentTokenValue = currentToken.substring(equalSign + 1).trim();\r\n        if (\"username\".equals(currentTokenName))\r\n            return (removeQuotes(currentTokenValue));\r\n    }\r\n    return (null);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.CommonAccessLogFormatterImpl.appendResponseLength",
	"Comment": "appends the content length of the given response to the given charbuffer.",
	"Method": "void appendResponseLength(CharBuffer cb,Response response){\r\n    cb.put(\"\" + response.getContentCount());\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorLog.getLogged",
	"Comment": "process the log to build a sequence of coordinatorlog objects whichrepresent all logged transactions.",
	"Method": "Enumeration getLogged(Enumeration getLogged,String logPath){\r\n    Vector logRecords = null;\r\n    Enumeration coordLogs = null;\r\n    if (openLog(logPath)) {\r\n        CoordinatorLogStateHolder logStateHolder = getStateHolder(logPath);\r\n        logRecords = logStateHolder.logFile.getLogRecords();\r\n        for (int i = 0; i < logRecords.size(); i++) {\r\n            byte[] buffer = (byte[]) logRecords.elementAt(i);\r\n            ByteArrayInputStream byteInput = new ByteArrayInputStream(buffer);\r\n            DataInputStream dataInput = new DataInputStream(byteInput);\r\n            try {\r\n                Long localTID = dataInput.readLong();\r\n                CoordinatorLog coordLog = (CoordinatorLog) logStateHolder.activeLogs.get(localTID);\r\n                if (coordLog == null) {\r\n                    coordLog = CoordinatorLogPool.getCoordinatorLog(logPath);\r\n                    coordLog.setLocalTID(localTID, logPath);\r\n                }\r\n                coordLog.reconstruct(dataInput);\r\n            } catch (IOException exc) {\r\n            }\r\n        }\r\n        coordLogs = logStateHolder.activeLogs.elements();\r\n    } else\r\n        coordLogs = new Hashtable().elements();\r\n    return coordLogs;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.remote.ExceptionAnalyzer.getFirstInstanceOf",
	"Comment": "returns the first instance of the given exception class in the chain of causes. the counting starts from the instance of the exception that created the exceptionanalyzer class itself.",
	"Method": "Throwable getFirstInstanceOf(Class<? extends Exception> ac){\r\n    for (Throwable t : chain) {\r\n        try {\r\n            ac.cast(t);\r\n            return t;\r\n        } catch (ClassCastException cce) {\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.node.ServletNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object newDescriptor){\r\n    if (newDescriptor instanceof RoleReference) {\r\n        if (DOLUtils.getDefaultLogger().isLoggable(Level.FINE)) {\r\n            DOLUtils.getDefaultLogger().fine(\"Adding security role ref \" + newDescriptor);\r\n        }\r\n        descriptor.addSecurityRoleReference((RoleReference) newDescriptor);\r\n    } else if (newDescriptor instanceof EnvironmentEntry) {\r\n        if (DOLUtils.getDefaultLogger().isLoggable(Level.FINE)) {\r\n            DOLUtils.getDefaultLogger().fine(\"Adding init-param \" + newDescriptor);\r\n        }\r\n        descriptor.addInitializationParameter((InitializationParameter) newDescriptor);\r\n    } else if (newDescriptor instanceof MultipartConfig) {\r\n        descriptor.setMultipartConfig((MultipartConfig) newDescriptor);\r\n    } else\r\n        super.addDescriptor(newDescriptor);\r\n}"
}, {
	"Path": "org.apache.naming.resources.FileDirContext.rename",
	"Comment": "binds a new name to the object bound to an old name, and unbinds the old name. both names are relative to this context. any attributes associated with the old name become associated with the new name. intermediate contexts of the old name are not changed.",
	"Method": "void rename(String oldName,String newName){\r\n    File file = file(oldName);\r\n    if (file == null)\r\n        throw new NamingException(MessageFormat.format(rb.getString(LogFacade.RESOURCES_NOT_FOUND), oldName));\r\n    File newFile = fileCache.get(newName);\r\n    if (newFile == null) {\r\n        newFile = new File(base, newName);\r\n    }\r\n    if (!file.renameTo(newFile)) {\r\n        throw new NamingException(MessageFormat.format(rb.getString(LogFacade.RESOURCES_RENAME_FAIL), oldName, newName));\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.services.SMFService.tokensAndValues",
	"Comment": "returns the tokens and values of the service as a map.note that a copy is returned.",
	"Method": "Map<String, String> tokensAndValues(){\r\n    return (new HashMap<String, String>(getTokenMap()));\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.messagebean.ImplementsMessageListener.check",
	"Comment": "run a verifier test against an individual declared messagedrive bean component",
	"Method": "Result check(EjbMessageBeanDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    Class mbc = loadMessageBeanClass(descriptor, result);\r\n    if (descriptor.getEjbBundleDescriptor().getSpecVersion().equals(\"2.0\"))\r\n        testImplementationOf(mbc, javax.jms.MessageListener.class.getName(), result);\r\n    else\r\n        testImplementationOf(mbc, descriptor.getMessageListenerType(), result);\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationFilterConfig.getServletContext",
	"Comment": "return the servletcontext of our associated web application.",
	"Method": "ServletContext getServletContext(){\r\n    return (this.context.getServletContext());\r\n}"
}, {
	"Path": "com.sun.enterprise.web.PEAccessLogValve.setAddDateStampToFirstAccessLogFile",
	"Comment": "are we supposed to add datestamp to first access log file we create,or only starting with first rotation?",
	"Method": "void setAddDateStampToFirstAccessLogFile(boolean add){\r\n    addDateStampToFirstAccessLogFile = add;\r\n}"
}, {
	"Path": "org.apache.catalina.session.ManagerBase.getDuplicates",
	"Comment": "number of duplicated session ids generated by the random source.anything bigger than 0 means problems.",
	"Method": "int getDuplicates(){\r\n    return duplicates;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.FileValidator.setConstraints",
	"Comment": "sets the current constraint set to the given set if it is a valid constriant set.",
	"Method": "String setConstraints(String constraints){\r\n    if (isValidConstraints(constraints)) {\r\n        this.constraints = constraints;\r\n    }\r\n    return this.constraints;\r\n}"
}, {
	"Path": "com.sun.jts.pi.ArrayListStack.push",
	"Comment": "pushes an item onto the top of this stack. this method will internallyadd elements to the arraylist if the stack is full.",
	"Method": "void push(Object obj){\r\n    list.add(curIndex, obj);\r\n    curIndex += 1;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.deallocate",
	"Comment": "return this previously allocated servlet to the pool of availableinstances.if this servlet class does not implement singlethreadmodel,no action is actually required.",
	"Method": "void deallocate(Servlet servlet){\r\n    if (!singleThreadModel) {\r\n        countAllocated.decrementAndGet();\r\n        return;\r\n    }\r\n    synchronized (instancePool) {\r\n        countAllocated.decrementAndGet();\r\n        instancePool.push(servlet);\r\n        instancePool.notify();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.results.GetResultList.getCommandResourcesPaths",
	"Comment": "returns an array of command resources paths and the operation type.",
	"Method": "String[][] getCommandResourcesPaths(){\r\n    return __commandResourcesPaths;\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.ByteArrayOutputStream.writeTo",
	"Comment": "writes the entire contents of this byte stream to thespecified output stream.",
	"Method": "void writeTo(OutputStream out){\r\n    int remaining = count;\r\n    for (int i = 0; i < buffers.size(); i++) {\r\n        byte[] buf = getBuffer(i);\r\n        int c = Math.min(buf.length, remaining);\r\n        out.write(buf, 0, c);\r\n        remaining -= c;\r\n        if (remaining == 0) {\r\n            break;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.api.admin.AdminCommandLock.setLockMessage",
	"Comment": "sets a message to be returned if the lock could not be acquired.this message can be displayed to the user to indicate why thedomain is locked.",
	"Method": "void setLockMessage(String message){\r\n    lockMessage = message;\r\n}"
}, {
	"Path": "org.apache.naming.resources.BaseDirContext.list",
	"Comment": "enumerates the names bound in the named context, along with the class names of objects bound to them.",
	"Method": "NamingEnumeration<NameClassPair> list(Name name,NamingEnumeration<NameClassPair> list,String name){\r\n    return list(name.toString());\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.addConstraint",
	"Comment": "add a security constraint to the set for this web application.",
	"Method": "void addConstraint(SecurityConstraint constraint){\r\n    SecurityCollection[] collections = constraint.findCollections();\r\n    for (SecurityCollection collection : collections) {\r\n        String[] patterns = collection.findPatterns();\r\n        for (int j = 0; j < patterns.length; j++) {\r\n            patterns[j] = adjustURLPattern(patterns[j]);\r\n            if (!validateURLPattern(patterns[j])) {\r\n                String msg = MessageFormat.format(rb.getString(LogFacade.SECURITY_CONSTRAINT_PATTERN_EXCEPTION), patterns[j]);\r\n                throw new IllegalArgumentException(msg);\r\n            }\r\n        }\r\n    }\r\n    constraints.add(constraint);\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ReplicationAttributeStore.doValveSave",
	"Comment": "save the specified session into this store.any previously savedinformation for the associated session identifier is replaced.",
	"Method": "void doValveSave(Session session){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"ReplicationAttributeStore>>doValveSave:valid =\" + ((StandardSession) session).getIsValid());\r\n        if (session instanceof HASession) {\r\n            _logger.fine(\"ReplicationAttributeStore>>valveSave:ssoId=\" + ((HASession) session).getSsoId());\r\n        }\r\n    }\r\n    if (!((StandardSession) session).getIsValid()) {\r\n        return;\r\n    }\r\n    if (!(session instanceof ModifiedAttributeHASession) || !(session instanceof BaseHASession)) {\r\n        return;\r\n    }\r\n    ModifiedAttributeHASession modAttrSession = (ModifiedAttributeHASession) session;\r\n    String userName = \"\";\r\n    if (session.getPrincipal() != null) {\r\n        userName = session.getPrincipal().getName();\r\n        ((BaseHASession) session).setUserName(userName);\r\n    }\r\n    BackingStore<String, CompositeMetadata> replicator = getCompositeMetadataBackingStore();\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"ReplicationAttributeStore>>save: replicator: \" + replicator);\r\n    }\r\n    CompositeMetadata compositeMetadata = createCompositeMetadata(modAttrSession);\r\n    try {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.fine(\"CompositeMetadata is \" + compositeMetadata + \" id is \" + session.getIdInternal());\r\n        }\r\n        // id\r\n        replicator.save(session.getIdInternal(), compositeMetadata, !((HASession) session).isPersistent());\r\n        modAttrSession.resetAttributeState();\r\n        postSaveUpdate(modAttrSession);\r\n    } catch (BackingStoreException ex) {\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.versioning.VersioningService.getMatchedVersions",
	"Comment": "process the expression matching operation of the given application name.",
	"Method": "List<String> getMatchedVersions(String name,String target){\r\n    String untagged = VersioningUtils.getUntaggedName(name);\r\n    List<String> allVersions = getAllversions(untagged, target);\r\n    if (allVersions.size() == 0) {\r\n        if (!name.equals(untagged)) {\r\n            throw new VersioningException(VersioningUtils.LOCALSTRINGS.getLocalString(\"versioning.deployment.application.noversion\", \"Application {0} has no version registered\", untagged));\r\n        }\r\n        return Collections.EMPTY_LIST;\r\n    }\r\n    return VersioningUtils.matchExpression(allVersions, name);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.TagLibDescriptor.getTagDescriptors",
	"Comment": "for each tag in the tag lib descriptor create a tagdescriptor and returnthe array of tagdescriptors present in the tag lib.",
	"Method": "TagDescriptor[] getTagDescriptors(){\r\n    NodeList nl = doc.getElementsByTagName(TAG);\r\n    TagDescriptor[] tagdescriptor = null;\r\n    if (nl != null) {\r\n        int size = nl.getLength();\r\n        tagdescriptor = new TagDescriptor[size];\r\n        for (int i = 0; i < size; i++) {\r\n            tagdescriptor[i] = new TagDescriptor(nl.item(i));\r\n        }\r\n    }\r\n    return tagdescriptor;\r\n}"
}, {
	"Path": "com.sun.enterprise.config.modularity.ConfigModularityUtils.getDefaultConfigurations",
	"Comment": "if exists, locate and return a url to the configuration snippet for the given config bean class.",
	"Method": "List<ConfigBeanDefaultValue> getDefaultConfigurations(Class configBeanClass,String runtimeType){\r\n    CustomConfiguration c = (CustomConfiguration) configBeanClass.getAnnotation(CustomConfiguration.class);\r\n    List<ConfigBeanDefaultValue> defaults = Collections.emptyList();\r\n    if (c.usesOnTheFlyConfigGeneration()) {\r\n        Method m = getGetDefaultValuesMethod(configBeanClass);\r\n        if (m != null) {\r\n            try {\r\n                defaults = (List<ConfigBeanDefaultValue>) m.invoke(null, runtimeType);\r\n            } catch (Exception e) {\r\n                LogHelper.log(LOG, Level.INFO, cannotGetDefaultConfig, e, configBeanClass.getName());\r\n            }\r\n        }\r\n    } else {\r\n        LocalStringManager localStrings = new LocalStringManagerImpl(configBeanClass);\r\n        ModuleXMLConfigurationFileParser parser = new ModuleXMLConfigurationFileParser(localStrings);\r\n        try {\r\n            defaults = parser.parseServiceConfiguration(getConfigurationFileUrl(configBeanClass, c.baseConfigurationFileName(), runtimeType).openStream());\r\n        } catch (XMLStreamException e) {\r\n            LOG.log(Level.SEVERE, cannotParseDefaultDefaultConfig, e);\r\n        } catch (IOException e) {\r\n            LOG.log(Level.SEVERE, cannotParseDefaultDefaultConfig, e);\r\n        }\r\n    }\r\n    return defaults;\r\n}"
}, {
	"Path": "org.glassfish.admin.monitor.StatsProviderManagerDelegateImpl.enableStatsProviders",
	"Comment": "called from smpd, when monitoring level for a module is turned on",
	"Method": "void enableStatsProviders(String configElement){\r\n    if (!getMonitoringEnabled())\r\n        return;\r\n    String configLevel = getMonitoringLevel(configElement);\r\n    if (logger.isLoggable(Level.FINE))\r\n        logger.fine(\"Enabling all the statsProviders for - \" + configElement);\r\n    List<StatsProviderRegistryElement> spreList = statsProviderRegistry.getStatsProviderRegistryElement(configElement);\r\n    if (spreList == null)\r\n        return;\r\n    for (StatsProviderRegistryElement spre : spreList) {\r\n        boolean isEnableAllowed = spre.isEnableAllowed(configLevel);\r\n        if (!spre.isEnabled()) {\r\n            if (isEnableAllowed) {\r\n                enableStatsProvider(spre);\r\n            }\r\n        } else {\r\n            if (!isEnableAllowed) {\r\n                disableStatsProvider(spre);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.managed.ManagedConnectionMetaDataExistence.check",
	"Comment": "test the implementation of the javax.resource.spi.managedconnection interface in the rar file",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!descriptor.getOutBoundDefined()) {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.managed.notApplicableForInboundRA\", \"Resource Adapter does not provide outbound communication\"));\r\n        return result;\r\n    }\r\n    findImplementorOf(descriptor, \"javax.resource.spi.ManagedConnectionMetaData\", result);\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardManager.getName",
	"Comment": "return the descriptive short name of this manager implementation.",
	"Method": "String getName(){\r\n    return name;\r\n}"
}, {
	"Path": "org.glassfish.api.admin.AdminCommandLock.setLockOwner",
	"Comment": "sets the admin user id for the user who acquired the exclusive lock.",
	"Method": "void setLockOwner(String owner){\r\n    lockOwner = owner;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.RulesBase.getDigester",
	"Comment": "return the digester instance with which this rules instance isassociated.",
	"Method": "Digester getDigester(){\r\n    return (this.digester);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SenderReceiver.received_request",
	"Comment": "pass the operation through to the currenttransaction class.",
	"Method": "void received_request(int id,PropagationContext context){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        if (context != null) {\r\n            _logger.log(Level.FINE, \"In received_request\" + \":\" + id + \",\" + context.current.otid.formatID);\r\n        } else {\r\n            _logger.log(Level.FINE, \"In received_request\" + \":\" + id + \", null context\");\r\n        }\r\n    }\r\n    CurrentTransaction.receivedRequest(id, context);\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        if (context != null) {\r\n            _logger.log(Level.FINE, \"Out received_request\" + \":\" + id + \",\" + context.current.otid.formatID);\r\n        } else {\r\n            _logger.log(Level.FINE, \"Out received_request\" + \":\" + id + \", null context\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.createWrapper",
	"Comment": "factory method to create and return a new wrapper instance, ofthe java implementation class appropriate for this contextimplementation.the constructor of the instantiated wrapperwill have been called, but no properties will have been set.",
	"Method": "Wrapper createWrapper(){\r\n    Wrapper wrapper = new StandardWrapper();\r\n    synchronized (instanceListeners) {\r\n        for (String instanceListener : instanceListeners) {\r\n            try {\r\n                Class clazz = Class.forName(instanceListener);\r\n                wrapper.addInstanceListener((InstanceListener) clazz.newInstance());\r\n            } catch (Throwable t) {\r\n                String msg = MessageFormat.format(rb.getString(LogFacade.CREATING_INSTANCE_LISTENER_EXCEPTION), instanceListener);\r\n                log.log(Level.SEVERE, msg, t);\r\n                return (null);\r\n            }\r\n        }\r\n    }\r\n    synchronized (instanceListenerInstances) {\r\n        for (InstanceListener instanceListenerInstance : instanceListenerInstances) {\r\n            wrapper.addInstanceListener(instanceListenerInstance);\r\n        }\r\n    }\r\n    Iterator<String> i = wrapperLifecycles.iterator();\r\n    while (i.hasNext()) {\r\n        String wrapperLifecycle = i.next();\r\n        try {\r\n            Class clazz = Class.forName(wrapperLifecycle);\r\n            if (wrapper instanceof Lifecycle) {\r\n                ((Lifecycle) wrapper).addLifecycleListener((LifecycleListener) clazz.newInstance());\r\n            }\r\n        } catch (Throwable t) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.CREATING_LIFECYCLE_LISTENER_EXCEPTION), wrapperLifecycle);\r\n            log.log(Level.SEVERE, msg, t);\r\n            return (null);\r\n        }\r\n    }\r\n    i = wrapperListeners.iterator();\r\n    while (i.hasNext()) {\r\n        String wrapperListener = i.next();\r\n        try {\r\n            Class clazz = Class.forName(wrapperListener);\r\n            wrapper.addContainerListener((ContainerListener) clazz.newInstance());\r\n        } catch (Throwable t) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.CREATING_CONTAINER_LISTENER_EXCEPTION), wrapperListener);\r\n            log.log(Level.SEVERE, msg, t);\r\n            return (null);\r\n        }\r\n    }\r\n    return (wrapper);\r\n}"
}, {
	"Path": "org.apache.catalina.realm.JAASCallbackHandler.handle",
	"Comment": "retrieve the information requested in the provided callbacks.thisimplementation only recognizes namecallback andpasswordcallback instances.",
	"Method": "void handle(Callback callbacks){\r\n    for (int i = 0; i < callbacks.length; i++) {\r\n        if (callbacks[i] instanceof NameCallback) {\r\n            if (realm.getDebug() >= 3)\r\n                realm.log(\"Returning username \" + username);\r\n            ((NameCallback) callbacks[i]).setName(username);\r\n        } else if (callbacks[i] instanceof PasswordCallback) {\r\n            final char[] passwordcontents;\r\n            if (password != null) {\r\n                passwordcontents = (char[]) password.clone();\r\n            } else {\r\n                passwordcontents = new char[0];\r\n            }\r\n            ((PasswordCallback) callbacks[i]).setPassword(passwordcontents);\r\n        } else {\r\n            throw new UnsupportedCallbackException(callbacks[i]);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getContext",
	"Comment": "return the context within which this request is being processed.",
	"Method": "Context getContext(){\r\n    return context;\r\n}"
}, {
	"Path": "org.glassfish.webservices.monitoring.LogAuthenticationListener.authSucess",
	"Comment": "notification that a user properly authenticated while making a web service invocation.",
	"Method": "void authSucess(BundleDescriptor bundleDesc,Endpoint endpoint,Principal principal){\r\n    if (DOLUtils.ejbType().equals(bundleDesc.getModuleType())) {\r\n        if (logger.isLoggable(Level.FINER)) {\r\n            logger.log(Level.FINER, LogUtils.AUTHENTICATION_SUCCESS, new Object[] { endpoint.getEndpointSelector(), bundleDesc.getModuleID(), \"ejb module\" });\r\n        }\r\n    } else {\r\n        if (logger.isLoggable(Level.FINER)) {\r\n            logger.log(Level.FINER, LogUtils.AUTHENTICATION_SUCCESS, new Object[] { endpoint.getEndpointSelector(), bundleDesc.getModuleID(), \"web app\" });\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.RequestFacadeHelper.isMaxDispatchDepthReached",
	"Comment": "check if the application dispatching has reached the maximum",
	"Method": "boolean isMaxDispatchDepthReached(){\r\n    validateRequest();\r\n    return request.isMaxDispatchDepthReached();\r\n}"
}, {
	"Path": "org.apache.catalina.valves.AccessLogValve.getCondition",
	"Comment": "return whether the attribute name to look for whenperforming conditional logging. if null, everyrequest is logged.",
	"Method": "String getCondition(){\r\n    return condition;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogRestartDescriptor.toString",
	"Comment": "this method is called to direct the object to format its stateto a string.",
	"Method": "String toString(){\r\n    return \"LRD(valid=\" + restartValid + \",len=\" + restartDataLength + \",time=\" + timeStamp + \")\";\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.XATerminatorImpl.prepare",
	"Comment": "ask the resource manager to prepare for a transaction commitof the transaction specified in xid.",
	"Method": "int prepare(Xid xid){\r\n    check(xid);\r\n    GlobalTID tid = new GlobalTID(xid);\r\n    try {\r\n        recreate(xid, 0);\r\n    } catch (Throwable e) {\r\n        XAException xaExc = new XAException(XAException.XAER_PROTO);\r\n        xaExc.initCause(e);\r\n        throw xaExc;\r\n    }\r\n    boolean exceptionFlag = false;\r\n    int errorCode = XAException.XAER_PROTO;\r\n    try {\r\n        RecoveryManager.waitForRecovery();\r\n        TopCoordinator coord = (TopCoordinator) RecoveryManager.getCoordinator(tid);\r\n        if (coord == null) {\r\n            errorCode = XAException.XAER_PROTO;\r\n            throw new XAException(errorCode);\r\n        }\r\n        synchronized (coord) {\r\n            coord.beforeCompletion();\r\n            Vote vote = coord.prepare();\r\n            if (vote == Vote.VoteRollback) {\r\n                errorCode = XAException.XA_RBROLLBACK;\r\n            } else if (vote == Vote.VoteCommit) {\r\n                return XAResource.XA_OK;\r\n            } else if (vote == Vote.VoteReadOnly) {\r\n                return XAResource.XA_RDONLY;\r\n            }\r\n            throw new XAException(errorCode);\r\n        }\r\n    } catch (Throwable exc) {\r\n        exceptionFlag = true;\r\n        XAException xaExc = new XAException(errorCode);\r\n        xaExc.initCause(exc);\r\n        throw xaExc;\r\n    } finally {\r\n        try {\r\n            release(xid);\r\n        } catch (Throwable t) {\r\n            if (!exceptionFlag) {\r\n                errorCode = XAException.XAER_PROTO;\r\n                XAException xaExc = new XAException(errorCode);\r\n                xaExc.initCause(t);\r\n                throw xaExc;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.getServletContext",
	"Comment": "return the servlet context with which this servlet is associated.",
	"Method": "ServletContext getServletContext(){\r\n    if (parent == null)\r\n        return (null);\r\n    else if (!(parent instanceof Context))\r\n        return (null);\r\n    else\r\n        return (((Context) parent).getServletContext());\r\n}"
}, {
	"Path": "org.apache.catalina.core.NamingContextListener.processGlobalResourcesChange",
	"Comment": "process a property change on the naming resources, by making thecorresponding addition or removal to the associated jndi context.",
	"Method": "void processGlobalResourcesChange(String name,Object oldValue,Object newValue){\r\n    if (name.equals(\"ejb\")) {\r\n        if (oldValue != null) {\r\n            ContextEjb ejb = (ContextEjb) oldValue;\r\n            if (ejb.getName() != null) {\r\n                removeEjb(ejb.getName());\r\n            }\r\n        }\r\n        if (newValue != null) {\r\n            ContextEjb ejb = (ContextEjb) newValue;\r\n            if (ejb.getName() != null) {\r\n                addEjb(ejb);\r\n            }\r\n        }\r\n    } else if (name.equals(\"environment\")) {\r\n        if (oldValue != null) {\r\n            ContextEnvironment env = (ContextEnvironment) oldValue;\r\n            if (env.getName() != null) {\r\n                removeEnvironment(env.getName());\r\n            }\r\n        }\r\n        if (newValue != null) {\r\n            ContextEnvironment env = (ContextEnvironment) newValue;\r\n            if (env.getName() != null) {\r\n                addEnvironment(env);\r\n            }\r\n        }\r\n    } else if (name.equals(\"localEjb\")) {\r\n        if (oldValue != null) {\r\n            ContextLocalEjb ejb = (ContextLocalEjb) oldValue;\r\n            if (ejb.getName() != null) {\r\n                removeLocalEjb(ejb.getName());\r\n            }\r\n        }\r\n        if (newValue != null) {\r\n            ContextLocalEjb ejb = (ContextLocalEjb) newValue;\r\n            if (ejb.getName() != null) {\r\n                addLocalEjb(ejb);\r\n            }\r\n        }\r\n    } else if (name.equals(\"resource\")) {\r\n        if (oldValue != null) {\r\n            ContextResource resource = (ContextResource) oldValue;\r\n            if (resource.getName() != null) {\r\n                removeResource(resource.getName());\r\n            }\r\n        }\r\n        if (newValue != null) {\r\n            ContextResource resource = (ContextResource) newValue;\r\n            if (resource.getName() != null) {\r\n                addResource(resource);\r\n            }\r\n        }\r\n    } else if (name.equals(\"resourceEnvRef\")) {\r\n        if (oldValue != null) {\r\n            String update = (String) oldValue;\r\n            int colon = update.indexOf(':');\r\n            removeResourceEnvRef(update.substring(0, colon));\r\n        }\r\n        if (newValue != null) {\r\n            String update = (String) newValue;\r\n            int colon = update.indexOf(':');\r\n            addResourceEnvRef(update.substring(0, colon), update.substring(colon + 1));\r\n        }\r\n    } else if (name.equals(\"resourceLink\")) {\r\n        if (oldValue != null) {\r\n            ContextResourceLink rl = (ContextResourceLink) oldValue;\r\n            if (rl.getName() != null) {\r\n                removeResourceLink(rl.getName());\r\n            }\r\n        }\r\n        if (newValue != null) {\r\n            ContextResourceLink rl = (ContextResourceLink) newValue;\r\n            if (rl.getName() != null) {\r\n                addResourceLink(rl);\r\n            }\r\n        }\r\n    } else if (name.equals(\"resourceParams\")) {\r\n        String resourceParamsName = null;\r\n        ResourceParams rp = null;\r\n        if (oldValue != null) {\r\n            rp = (ResourceParams) oldValue;\r\n        }\r\n        if (newValue != null) {\r\n            rp = (ResourceParams) newValue;\r\n        }\r\n        if (rp != null) {\r\n            resourceParamsName = rp.getName();\r\n        }\r\n        if (resourceParamsName != null) {\r\n            ContextEjb ejb = namingResources.findEjb(resourceParamsName);\r\n            if (ejb != null) {\r\n                removeEjb(resourceParamsName);\r\n                addEjb(ejb);\r\n            }\r\n            ContextResource resource = namingResources.findResource(resourceParamsName);\r\n            if (resource != null) {\r\n                removeResource(resourceParamsName);\r\n                addResource(resource);\r\n            }\r\n            String resourceEnvRefValue = namingResources.findResourceEnvRef(resourceParamsName);\r\n            if (resourceEnvRefValue != null) {\r\n                removeResourceEnvRef(resourceParamsName);\r\n                addResourceEnvRef(resourceParamsName, resourceEnvRefValue);\r\n            }\r\n            ContextResourceLink resourceLink = namingResources.findResourceLink(resourceParamsName);\r\n            if (resourceLink != null) {\r\n                removeResourceLink(resourceParamsName);\r\n                addResourceLink(resourceLink);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.web.GlassFishSingleSignOn.threadStop",
	"Comment": "stop the background thread that is periodically checking forsso timeouts.",
	"Method": "void threadStop(){\r\n    if (thread == null)\r\n        return;\r\n    threadDone = true;\r\n    thread.interrupt();\r\n    try {\r\n        thread.join();\r\n    } catch (InterruptedException e) {\r\n        ;\r\n    }\r\n    thread = null;\r\n}"
}, {
	"Path": "org.apache.catalina.session.PersistentManagerBase.getName",
	"Comment": "return the descriptive short name of this manager implementation.",
	"Method": "String getName(){\r\n    return (name);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.hasServlet",
	"Comment": "checks whether this context contains the given servlet instance",
	"Method": "boolean hasServlet(Servlet servlet){\r\n    for (Map.Entry<String, Container> e : children.entrySet()) {\r\n        if (servlet == ((StandardWrapper) e.getValue()).getServlet()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationFilterChain.setWrapper",
	"Comment": "sets the wrapper of the servlet that will be executed at the end ofthis filter chain.",
	"Method": "void setWrapper(StandardWrapper wrapper){\r\n    this.wrapper = wrapper;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.CompositeUtil.executeWriteCommand",
	"Comment": "execute a writing admincommand with the specified parameters.",
	"Method": "ActionReporter executeWriteCommand(Subject subject,String command,ActionReporter executeWriteCommand,Subject subject,String command,ParameterMap parameters){\r\n    return executeCommand(subject, command, parameters, Status.BAD_REQUEST, true, true, false);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentTransaction.addSuspended",
	"Comment": "adds the given control object to the set of control objects suspended inthe process.",
	"Method": "void addSuspended(ControlImpl control){\r\n    if (statsOn)\r\n        suspended.addElement(control);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.ContainerTransactionStyle3.getAllInterfaceMethods",
	"Comment": "collect all the methods the bean interfaces specified in methoddescriptor",
	"Method": "Set<Method> getAllInterfaceMethods(MethodDescriptor methodDescriptor){\r\n    Set<Method> methods = new HashSet<Method>();\r\n    String methodIntf = methodDescriptor.getEjbClassSymbol();\r\n    if ((methodIntf == null)) {\r\n        methods.addAll(Arrays.asList(homeMethods));\r\n        methods.addAll(Arrays.asList(localHomeMethods));\r\n        methods.addAll(Arrays.asList(remoteMethods));\r\n        methods.addAll(Arrays.asList(localMethods));\r\n        methods.addAll(Arrays.asList(serviceMethods));\r\n    } else if (methodIntf.equals(MethodDescriptor.EJB_HOME)) {\r\n        methods.addAll(Arrays.asList(homeMethods));\r\n    } else if (methodIntf.equals(MethodDescriptor.EJB_LOCALHOME)) {\r\n        methods.addAll(Arrays.asList(localHomeMethods));\r\n    } else if (methodIntf.equals(MethodDescriptor.EJB_REMOTE)) {\r\n        methods.addAll(Arrays.asList(remoteMethods));\r\n    } else if (methodIntf.equals(MethodDescriptor.EJB_LOCAL)) {\r\n        methods.addAll(Arrays.asList(localMethods));\r\n    } else if (methodIntf.equals(MethodDescriptor.EJB_WEB_SERVICE)) {\r\n        methods.addAll(Arrays.asList(serviceMethods));\r\n    }\r\n    return methods;\r\n}"
}, {
	"Path": "org.apache.catalina.session.ManagerBase.setRejectedSessions",
	"Comment": "sets the number of sessions that were not created because the maximumnumber of active sessions was reached.",
	"Method": "void setRejectedSessions(int rejectedSessions){\r\n    this.rejectedSessions = rejectedSessions;\r\n}"
}, {
	"Path": "org.apache.catalina.session.PersistentManagerBase.isLoaded",
	"Comment": "return true, if the session id is loaded in memoryotherwise false is returned",
	"Method": "boolean isLoaded(String id){\r\n    try {\r\n        if (super.findSession(id) != null)\r\n            return true;\r\n    } catch (IOException e) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.CHECKING_IS_LOADED_EXCEPTION), new Object[] { id, e.getMessage() });\r\n        log.log(Level.SEVERE, msg, e);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.closeJARs",
	"Comment": "used to periodically signal to the classloader to releasejar resources.",
	"Method": "void closeJARs(boolean force){\r\n    if (jarFiles.length > 0) {\r\n        synchronized (jarFilesLock) {\r\n            if (force || (System.currentTimeMillis() > (lastJarAccessed + 90000))) {\r\n                for (int i = 0; i < jarFiles.length; i++) {\r\n                    try {\r\n                        if (jarFiles[i] != null) {\r\n                            jarFiles[i].close();\r\n                            jarFiles[i] = null;\r\n                        }\r\n                    } catch (IOException e) {\r\n                        if (logger.isLoggable(Level.FINE)) {\r\n                            logger.log(Level.FINE, \"Failed to close JAR\", e);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.ManagerBase.getRandom",
	"Comment": "return the random number generator instance we should use forgenerating session identifiers.if there is no such generatorcurrently defined, construct and seed a new one.",
	"Method": "Random getRandom(){\r\n    if (this.random == null) {\r\n        long seed = System.currentTimeMillis();\r\n        long t1 = seed;\r\n        char[] entropy = getEntropy().toCharArray();\r\n        for (int i = 0; i < entropy.length; i++) {\r\n            long update = ((byte) entropy[i]) << ((i % 8) * 8);\r\n            seed ^= update;\r\n        }\r\n        try {\r\n            Class<?> clazz = Class.forName(randomClass);\r\n            this.random = (Random) clazz.newInstance();\r\n            this.random.setSeed(seed);\r\n        } catch (Exception e) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.INIT_RANDOM_NUMBER_GENERATOR_EXCEPTION), randomClass);\r\n            log.log(Level.SEVERE, msg, e);\r\n            this.random = new java.util.Random();\r\n            this.random.setSeed(seed);\r\n        }\r\n        long t2 = System.currentTimeMillis();\r\n        if ((t2 - t1) > 100)\r\n            if (log.isLoggable(Level.FINE)) {\r\n                String msg = MessageFormat.format(rb.getString(LogFacade.SEEDING_RANDOM_NUMBER_GENERATOR_CLASS), randomClass);\r\n                log.log(Level.FINE, msg + \" \" + (t2 - t1));\r\n            }\r\n    }\r\n    return (this.random);\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.DeferredFileOutputStream.getData",
	"Comment": "returns the data for this output stream as an array of bytes, assumingthat the data has been retained in memory. if the data was written todisk, this method returns null.",
	"Method": "byte[] getData(){\r\n    if (memoryOutputStream != null) {\r\n        return memoryOutputStream.toByteArray();\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.Initializer.parseArgs",
	"Comment": "parses the arguments passed to verifier and sets the framework contextobject.",
	"Method": "void parseArgs(String[] argv){\r\n    int c;\r\n    String arg;\r\n    boolean isVerboseSet = false;\r\n    LongOption[] longopts = new LongOption[20];\r\n    StringBuffer sb = new StringBuffer();\r\n    longopts[0] = new LongOption(\"help\", false, null, 'h');\r\n    longopts[1] = new LongOption(\"timestamp\", false, null, 't');\r\n    longopts[2] = new LongOption(\"verbose\", false, null, 'v');\r\n    longopts[3] = new LongOption(\"version\", false, null, 'V');\r\n    longopts[4] = new LongOption(\"destdir\", true, sb, 'd');\r\n    longopts[5] = new LongOption(\"reportlevel\", true, sb, 'r');\r\n    longopts[6] = new LongOption(\"gui\", false, null, 'u');\r\n    longopts[7] = new LongOption(\"app\", false, null, 'a');\r\n    longopts[8] = new LongOption(\"appclient\", false, null, 'A');\r\n    longopts[9] = new LongOption(\"connector\", false, null, 'c');\r\n    longopts[10] = new LongOption(\"ejb\", false, null, 'e');\r\n    longopts[11] = new LongOption(\"web\", false, null, 'w');\r\n    longopts[12] = new LongOption(\"webservices\", false, null, 's');\r\n    longopts[13] = new LongOption(\"webservicesclient\", false, null, 'l');\r\n    longopts[14] = new LongOption(\"persistence\", false, null, 'P');\r\n    longopts[15] = new LongOption(\"configdir\", true, null, 'C');\r\n    longopts[16] = new LongOption(\"portability\", false, null, 'p');\r\n    longopts[17] = new LongOption(\"domain\", true, null, 'D');\r\n    longopts[18] = new LongOption(\"extDir\", true, null, 'E');\r\n    longopts[19] = new LongOption(\"mode\", true, null, 'm');\r\n    String[] levels = new String[6];\r\n    levels[0] = \"a\";\r\n    levels[1] = \"w\";\r\n    levels[2] = \"f\";\r\n    levels[3] = \"all\";\r\n    levels[4] = \"warnings\";\r\n    levels[5] = \"failures\";\r\n    CLIPParser parser = null;\r\n    parser = new CLIPParser(\"verifier\", argv, \"-:vtVhud:r:aAcewslC:pPm:D:E:\", longopts);\r\n    while ((c = parser.getopt()) != -1) switch(c) {\r\n        case 0:\r\n            arg = parser.getOptarg();\r\n            processValidLongOpt((char) Integer.parseInt(sb.toString()), arg, levels);\r\n            break;\r\n        case 'v':\r\n            logger.setLevel(Level.FINEST);\r\n            isVerboseSet = true;\r\n            Handler[] handler = Logger.getLogger(\"\").getHandlers();\r\n            for (int i = 0; i < handler.length; i++) {\r\n                handler[i].setLevel(Level.FINEST);\r\n            }\r\n            // NOI18N\r\n            logger.log(Level.FINE, getClass().getName() + \".debug.verboseFlag\");\r\n            break;\r\n        case 't':\r\n            verifierFrameworkContext.setUseTimeStamp(true);\r\n            break;\r\n        case 'h':\r\n            // NOI18N\r\n            logger.log(Level.FINE, getClass().getName() + \".debug.helpMessage\");\r\n            usage();\r\n            break;\r\n        case 'V':\r\n            logger.log(Level.INFO, getClass().getName() + \".Version\");\r\n            System.exit(0);\r\n            break;\r\n        case 'u':\r\n            // NOI18N\r\n            logger.log(Level.FINE, getClass().getName() + \".debug.startGUI\");\r\n            verifierFrameworkContext.setUsingGui(true);\r\n            break;\r\n        case 'r':\r\n            arg = parser.getOptarg();\r\n            if (arg == null) {\r\n                // NOI18N\r\n                logger.log(Level.SEVERE, getClass().getName() + \".reqargs\", new Object[] { \"verifier\", \"-r\" });\r\n                usage();\r\n            } else {\r\n                boolean validLevel = false;\r\n                for (int i = 0; i < levels.length; i++) {\r\n                    if (arg.equals(levels[i])) {\r\n                        validLevel = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if (!validLevel) {\r\n                    logger.log(Level.SEVERE, getClass().getName() + \".invalidreplevel\", new Object[] { \"verifier\", arg });\r\n                    usage();\r\n                } else {\r\n                    setReportingLevel(arg.charAt(0));\r\n                }\r\n            }\r\n            break;\r\n        case 'd':\r\n            arg = parser.getOptarg();\r\n            if (arg == null) {\r\n                logger.log(Level.SEVERE, getClass().getName() + \".reqargs\", new Object[] { \"verifier\", \"-d\" });\r\n                usage();\r\n            } else if (!verifyAndSetResultDir(arg)) {\r\n                usage();\r\n            }\r\n            break;\r\n        case ':':\r\n            logger.log(Level.SEVERE, getClass().getName() + \".reqsarg\", new Object[] { \"verifier\", new Character((char) parser.getOptopt()).toString() });\r\n            usage();\r\n            break;\r\n        case 'a':\r\n            logger.log(Level.FINE, getClass().getName() + \".debug.app\");\r\n            verifierFrameworkContext.setApp(true);\r\n            verifierFrameworkContext.setPartition(true);\r\n            break;\r\n        case 'A':\r\n            // NOI18N\r\n            logger.log(Level.FINE, getClass().getName() + \".debug.appclient\");\r\n            verifierFrameworkContext.setAppClient(true);\r\n            verifierFrameworkContext.setPartition(true);\r\n            break;\r\n        case 'c':\r\n            // NOI18N\r\n            logger.log(Level.FINE, getClass().getName() + \".debug.connector\");\r\n            verifierFrameworkContext.setConnector(true);\r\n            verifierFrameworkContext.setPartition(true);\r\n            break;\r\n        case 'e':\r\n            logger.log(Level.FINE, getClass().getName() + \".debug.ejb\");\r\n            verifierFrameworkContext.setEjb(true);\r\n            verifierFrameworkContext.setPartition(true);\r\n            break;\r\n        case 'w':\r\n            logger.log(Level.FINE, getClass().getName() + \".debug.web\");\r\n            verifierFrameworkContext.setWeb(true);\r\n            verifierFrameworkContext.setPartition(true);\r\n            break;\r\n        case 's':\r\n            // NOI18N\r\n            logger.log(Level.FINE, getClass().getName() + \".debug.webservices\");\r\n            verifierFrameworkContext.setWebServices(true);\r\n            verifierFrameworkContext.setPartition(true);\r\n            break;\r\n        case 'l':\r\n            // NOI18N\r\n            logger.log(Level.FINE, getClass().getName() + \".debug.webservicesclient\");\r\n            verifierFrameworkContext.setWebServicesClient(true);\r\n            verifierFrameworkContext.setPartition(true);\r\n            break;\r\n        case 'P':\r\n            verifierFrameworkContext.setPersistenceUnits(true);\r\n            verifierFrameworkContext.setPartition(true);\r\n            break;\r\n        case '?':\r\n            char x = (char) parser.getOptopt();\r\n            if (x == '?') {\r\n                usage();\r\n            }\r\n            // NOI18N\r\n            logger.log(Level.SEVERE, getClass().getName() + \".invalidarg\", new Object[] { \"verifier\", new Character(x).toString() });\r\n            usage();\r\n            break;\r\n        case 'C':\r\n            arg = parser.getOptarg();\r\n            if (arg == null || !(new File(arg).exists())) {\r\n                logger.log(Level.SEVERE, getClass().getName() + \".reqargs\", new Object[] { \"verifier\", \"-C\" });\r\n                usage();\r\n            }\r\n            verifierFrameworkContext.setConfigDirStr(arg);\r\n            break;\r\n        case 'p':\r\n            verifierFrameworkContext.setPortabilityMode(true);\r\n            break;\r\n        case 'm':\r\n            arg = parser.getOptarg();\r\n            if (arg != null && (arg.equals(SpecVersionMapper.JavaEEVersion_1_2) || arg.equals(SpecVersionMapper.JavaEEVersion_1_3) || arg.equals(SpecVersionMapper.JavaEEVersion_1_4) || arg.equals(SpecVersionMapper.JavaEEVersion_5))) {\r\n                verifierFrameworkContext.setJavaEEVersion(arg);\r\n            } else {\r\n                // NOI18N\r\n                logger.log(Level.SEVERE, getClass().getName() + \".invalidjavaeeversion\", new Object[] { \"verifier\", arg });\r\n                usage();\r\n            }\r\n            logger.log(Level.INFO, getClass().getName() + \".specversion\", new Object[] { verifierFrameworkContext.getJavaEEVersion() });\r\n            break;\r\n        case 'D':\r\n            arg = parser.getOptarg();\r\n            if (arg == null) {\r\n                logger.log(Level.SEVERE, getClass().getName() + \".reqargs\", new Object[] { \"verifier\", \"-D\" });\r\n                usage();\r\n            }\r\n            if (!new File(arg).exists()) {\r\n                logger.log(Level.SEVERE, getClass().getName() + \".log.noDirExists\", new Object[] { arg });\r\n                usage();\r\n            }\r\n            verifierFrameworkContext.setDomainDir(arg);\r\n            break;\r\n        case 'E':\r\n            arg = parser.getOptarg();\r\n            if (arg == null) {\r\n                logger.log(Level.SEVERE, getClass().getName() + \".reqargs\", new Object[] { \"verifier\", \"-E\" });\r\n                usage();\r\n            }\r\n            verifierFrameworkContext.setExtDir(arg);\r\n            break;\r\n        default:\r\n            // NOI18N\r\n            logger.log(Level.SEVERE, getClass().getName() + \".invalidarg\", new Object[] { \"verifier\", new Character((char) c).toString() });\r\n            usage();\r\n            break;\r\n    }\r\n    int i = parser.getOptind();\r\n    if (i < argv.length) {\r\n        File jarFile = new File(argv[i]);\r\n        if (!jarFile.exists()) {\r\n            // NOI18N\r\n            logger.log(Level.SEVERE, getClass().getName() + \".invalidArchive\", new Object[] { argv[i] });\r\n            usage();\r\n        }\r\n        verifierFrameworkContext.setJarFileName(jarFile.getPath());\r\n        logger.log(Level.FINE, getClass().getName() + \".debug.jarFileName\", new Object[] { verifierFrameworkContext.getJarFileName() });\r\n        i++;\r\n        for (; i < argv.length; i++) // NOI18N\r\n        logger.log(// NOI18N\r\n        Level.INFO, getClass().getName() + \".extraargs\", new Object[] { \"verifier\", argv[i] });\r\n    } else {\r\n        if (!verifierFrameworkContext.isUsingGui()) {\r\n            // NOI18N\r\n            logger.log(// NOI18N\r\n            Level.SEVERE, getClass().getName() + \".jarmissing\", new Object[] { \"verifier\" });\r\n            usage();\r\n        }\r\n    }\r\n    if (!isVerboseSet)\r\n        setFormatter();\r\n    logger.log(Level.FINE, getClass().getName() + \".debug.endParseArgs\");\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.MultipartStream.readBoundary",
	"Comment": "skips a boundary token, and checks whether moreencapsulations are contained in the stream.",
	"Method": "boolean readBoundary(){\r\n    byte[] marker = new byte[2];\r\n    boolean nextChunk = false;\r\n    head += boundaryLength;\r\n    try {\r\n        marker[0] = readByte();\r\n        if (marker[0] == LF) {\r\n            return true;\r\n        }\r\n        marker[1] = readByte();\r\n        if (arrayequals(marker, STREAM_TERMINATOR, 2)) {\r\n            nextChunk = false;\r\n        } else if (arrayequals(marker, FIELD_SEPARATOR, 2)) {\r\n            nextChunk = true;\r\n        } else {\r\n            throw new MalformedStreamException(\"Unexpected characters follow a boundary\");\r\n        }\r\n    } catch (IOException e) {\r\n        throw new MalformedStreamException(\"Stream ended unexpectedly\");\r\n    }\r\n    return nextChunk;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorResourceImpl.forget",
	"Comment": "informs the object that the transaction is to be forgotten.informs the coordinatorresourceimpl that it does not need to retain heuristicinformation any longer.",
	"Method": "void forget(){\r\n    if (subtransaction) {\r\n        INTERNAL exc = new INTERNAL(MinorCode.TopForSub, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    destroy();\r\n}"
}, {
	"Path": "org.apache.catalina.loader.WebappLoader.addRepository",
	"Comment": "add a new repository to the set of repositories for this class loader.",
	"Method": "void addRepository(String repository){\r\n    if (log.isLoggable(Level.FINEST))\r\n        log.log(Level.FINEST, \"Adding repository \" + repository);\r\n    for (int i = 0; i < repositories.length; i++) {\r\n        if (repository.equals(repositories[i]))\r\n            return;\r\n    }\r\n    String[] results = new String[repositories.length + 1];\r\n    for (int i = 0; i < repositories.length; i++) results[i] = repositories[i];\r\n    results[repositories.length] = repository;\r\n    repositories = results;\r\n    if (started && (classLoader != null)) {\r\n        classLoader.addRepository(repository);\r\n        setClassPath();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.setSessionTrackingModes",
	"Comment": "sets the session tracking modes that are to become effective for thisservletcontext.",
	"Method": "void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes){\r\n    if (isRestricted) {\r\n        throw new UnsupportedOperationException(rb.getString(LogFacade.UNSUPPORTED_OPERATION_EXCEPTION));\r\n    }\r\n    context.setSessionTrackingModes(sessionTrackingModes);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.TagLibTest.getParamTypeClass",
	"Comment": "given a parameter array contained in a method, this method returns theclass array representation of the parameters",
	"Method": "Class[] getParamTypeClass(String[] par,ClassLoader cl){\r\n    List<Class> list = new ArrayList<Class>();\r\n    for (String s : par) {\r\n        Class c = checkIfPrimitive(s);\r\n        if (c != null)\r\n            list.add(c);\r\n        else {\r\n            try {\r\n                c = Class.forName(s, false, cl);\r\n                list.add(c);\r\n            } catch (ClassNotFoundException e) {\r\n            }\r\n        }\r\n    }\r\n    return list.toArray(new Class[0]);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.addChild",
	"Comment": "adds the given coordinator reference to the set of childrenof the target subcoordinator.",
	"Method": "boolean addChild(CoordinatorImpl child){\r\n    boolean result = nestingInfo.addChild(child);\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.LimitedInputStream.checkLimit",
	"Comment": "called to check, whether the input streamslimit is reached.",
	"Method": "void checkLimit(){\r\n    if (count > sizeMax) {\r\n        raiseError(sizeMax, count);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.ListenerClassImplementsValidInterface.runIndividualListenerTest",
	"Comment": "run the verifier test against a declared individual listener class",
	"Method": "boolean runIndividualListenerTest(Result result,Class listenerClass){\r\n    boolean validInterface = false;\r\n    Class clazz = listenerClass;\r\n    if (listenerClass == null) {\r\n        return false;\r\n    }\r\n    validInterface = isImplementorOf(clazz, \"javax.servlet.ServletContextAttributeListener\");\r\n    if (validInterface != true) {\r\n        validInterface = isImplementorOf(clazz, \"javax.servlet.ServletContextListener\");\r\n    }\r\n    if (validInterface != true) {\r\n        validInterface = isImplementorOf(clazz, \"javax.servlet.http.HttpSessionAttributeListener\");\r\n    }\r\n    if (validInterface != true) {\r\n        validInterface = isImplementorOf(clazz, \"javax.servlet.http.HttpSessionListener\");\r\n    }\r\n    if (validInterface != true) {\r\n        validInterface = isImplementorOf(clazz, \"javax.servlet.ServletRequestAttributeListener\");\r\n    }\r\n    if (validInterface != true) {\r\n        validInterface = isImplementorOf(clazz, \"javax.servlet.ServletRequestListener\");\r\n    }\r\n    if (validInterface != true) {\r\n        validInterface = isImplementorOf(clazz, \"javax.servlet.http.HttpSessionBindingListener\");\r\n    }\r\n    if (validInterface) {\r\n        result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"Listener class [ {0} ] implements a valid interface.\", new Object[] { listenerClass.getName() }));\r\n    } else if (!validInterface) {\r\n        result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Listener class [ {0} ] does not implement one or more of the following valid interface.\\n javax.servlet.ServletContextAttributeListener, javax.servlet.ServletContextListener, javax.servlet.http.HttpSessionAttributeListener, javax.servlet.http.HttpSessionListener\", new Object[] { clazz.getName() }));\r\n    }\r\n    return validInterface;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.VerifierTest.testImplementationOf",
	"Comment": "verify that a class or one of its superclass is implementing an interface",
	"Method": "boolean testImplementationOf(Class clazz,String interfaceName,Result result){\r\n    if (isImplementorOf(clazz, interfaceName)) {\r\n        result.passed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.VerifierTest.interfaceimplementation.passed\", \"The class [ {0} ] implements the [ {1} ] interface\", new Object[] { clazz.getName(), interfaceName }));\r\n        return true;\r\n    } else {\r\n        result.failed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.VerifierTest.interfaceimplementation.failed\", \"Error: The class [ {0} ] does not implement the [ {1} ] interface\", new Object[] { clazz.getName(), interfaceName }));\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.cci.InteractionSpecSerializable.check",
	"Comment": "test if the javax.resource.cci.interfactionspec implementation providedin the rar file also implements the java.io.serializable interface",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (isCCIImplemented(descriptor, result)) {\r\n        Class is = findImplementorOf(descriptor, \"javax.resource.cci.InteractionSpec\");\r\n        if (is != null) {\r\n            testImplementationOf(is, \"java.io.Serializable\", result);\r\n            return result;\r\n        } else {\r\n            result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.cci.InteractionSpecJavaBeansCompliance.nonexist\", \"Error: While the CCI interfaces are implemented, the javax.resource.cci.InteractionSpec is not\"));\r\n            return result;\r\n        }\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.cci.InteractionExistence.notapp\", \"NotApplicable : The CCI interfaces do not seem to be implemented by this resource adapter\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.TransactionSynchronizationRegistryImpl.getTransactionKey",
	"Comment": "return an opaque object to represent the transaction bound to thecurrent thread at the time this method is called. the returned objectoverrides hashcode and equals methods to allowits use as the key in a java.util.hashmap for use by thecaller. if there is no transaction currently active, null is returned.the returned object will return the same hashcode andcompare equal to all other objects returned by calling this methodfrom any component executing in the same transaction context in thesame application server.the tostring method returns a stringthat might be usable by a human reader to usefully understand thetransaction context. the result of the tostring methodis otherwise not defined. specifically, there is no forward or backwardcompatibility guarantee for the result returned by thetostring method.the object is not necessarily serializable, and is not usefuloutside the virtual machine from which it was obtained.",
	"Method": "Object getTransactionKey(){\r\n    try {\r\n        return transactionManager.getTransaction();\r\n    } catch (SystemException ex) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.jtsxa.XID.isEqualBranchQualifier",
	"Comment": "compares the input parameter with the branch qualifier for equality.",
	"Method": "boolean isEqualBranchQualifier(byte[] data){\r\n    int L = data.length > MAXBQUALSIZE ? MAXBQUALSIZE : data.length;\r\n    int i;\r\n    if (L != bqual_length) {\r\n        return false;\r\n    }\r\n    for (i = 0; i < L; i++) {\r\n        if (data[i] != this.data[gtrid_length + i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.setDebug",
	"Comment": "set the debugging detail level of our currently enabled logger.",
	"Method": "void setDebug(int debug){\r\n    ;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RWLock.acquireWriteLock",
	"Comment": "this method is used to acquire a write lock. if there are already reader threadsaccessing the object using the rwlock, then the writer thread will wait till allthe reader threads are finished with their operations.",
	"Method": "void acquireWriteLock(){\r\n    Object lock = new Object();\r\n    synchronized (lock) {\r\n        synchronized (this) {\r\n            if (writerQueue.size() == 0 && currentReaders == 0 && currentWriters == 0) {\r\n                ++currentWriters;\r\n                return;\r\n            }\r\n            writerQueue.enQueue(lock);\r\n        }\r\n        try {\r\n            lock.wait();\r\n        } catch (InterruptedException ie) {\r\n            _logger.log(Level.FINE, \"Error in acquireWriteLock\", ie);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.logger.LoggerBase.getVerbosity",
	"Comment": "return the verbosity level of this logger.messages logged with ahigher verbosity than this level will be silently ignored.",
	"Method": "int getVerbosity(){\r\n    return (this.verbosity);\r\n}"
}, {
	"Path": "com.sun.enterprise.config.serverbeans.ConfigBeansUtilities.getDefaultRotationIntervalInMinutes",
	"Comment": "get the default value of rotationintervalinminutes from dtd",
	"Method": "String getDefaultRotationIntervalInMinutes(){\r\n    return \"1440\";\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionManagerImpl.setRollbackOnly",
	"Comment": "modify the transaction associated with the current thread such thatthe only possible outcome of the transaction is to roll back thetransaction.",
	"Method": "void setRollbackOnly(){\r\n    try {\r\n        current.rollback_only();\r\n    } catch (NoTransaction ex) {\r\n        throw new IllegalStateException();\r\n    } catch (Exception ex) {\r\n        throw new SystemException(ex.toString());\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RegisteredResources.distributeSubrollback",
	"Comment": "distributes rollbacksubtransaction messages to all registeredsubtransactionawareresources.",
	"Method": "void distributeSubrollback(){\r\n    for (int i = 0; i < nRes; i++) {\r\n        boolean isProxy = false;\r\n        SubtransactionAwareResource currResource = (SubtransactionAwareResource) resourceObjects.get(i);\r\n        if (!(currResource instanceof com.sun.jts.jtsxa.OTSResourceImpl)) {\r\n            ProxyChecker checkProxy = Configuration.getProxyChecker();\r\n            isProxy = checkProxy.isProxy(currResource);\r\n        }\r\n        try {\r\n            currResource.rollback_subtransaction();\r\n        } catch (Throwable exc) {\r\n        }\r\n        resourceStates.set(i, ResourceStatus.Completed);\r\n        if (isProxy) {\r\n            currResource._release();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.internal.embedded.admin.CommandParameters.addOption",
	"Comment": "adds a command option as the user would specify it using thecli command for instance",
	"Method": "void addOption(String optionName,String optionValue){\r\n    params.add(optionName, optionValue);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.server.ClassLoaderHierarchyImpl.addRepository",
	"Comment": "this method installs the admin console osgi bundle respository so \tour plugins can be found.",
	"Method": "void addRepository(String name,String path){\r\n    File pathFile = new File(path);\r\n    Repository repo = new DirectoryBasedRepository(name, pathFile);\r\n    modulesRegistry.addRepository(repo);\r\n    try {\r\n        repo.initialize();\r\n    } catch (IOException ex) {\r\n        logger.log(Level.SEVERE, \"Problem initializing additional repository!\", ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.ListCommandsCommand.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    context.getActionReport().setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    ActionReport report = context.getActionReport();\r\n    report.getTopMessagePart().setChildrenType(\"Command\");\r\n    for (String name : sortedAdminCommands()) {\r\n        ActionReport.MessagePart part = report.getTopMessagePart().addChild();\r\n        part.setMessage(name);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.pi.ArrayListStack.pop",
	"Comment": "removes the object at the top of this stack and returns thatobject as the value of this function.",
	"Method": "Object pop(){\r\n    if (curIndex > 0) {\r\n        curIndex -= 1;\r\n        return list.remove(curIndex);\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.naming.resources.DirContextURLStreamHandlerFactory.createURLStreamHandler",
	"Comment": "creates a new urlstreamhandler instance with the specified protocol.will return null if the protocol is not jndi.",
	"Method": "URLStreamHandler createURLStreamHandler(String protocol){\r\n    if (protocol.equals(\"jndi\")) {\r\n        return new DirContextURLStreamHandler();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.SingleSignOnEntry.isEmpty",
	"Comment": "returns true if this singlesignonentry does not have any sessionsassociated with it, and false otherwise.",
	"Method": "boolean isEmpty(){\r\n    return (sessions.size() == 0);\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.pop",
	"Comment": "pop the top object off of the stack, and return it.if there areno objects on the stack, return null.",
	"Method": "Object pop(Object pop,String stackName){\r\n    Object result = null;\r\n    ArrayStack<Object> namedStack = stacksByName.get(stackName);\r\n    if (namedStack == null) {\r\n        if (log.isLoggable(Level.FINE)) {\r\n            log.log(Level.FINE, \"Stack '\" + stackName + \"' is empty\");\r\n        }\r\n        throw new EmptyStackException();\r\n    } else {\r\n        result = namedStack.pop();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.CommandRunnerImpl.getActionReport",
	"Comment": "returns an initialized actionreport instance for the passed type ornull if it cannot be found.",
	"Method": "ActionReport getActionReport(String name){\r\n    return habitat.getService(ActionReport.class, name);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModule.configureAlternateDD",
	"Comment": "determines and sets the alternate deployment descriptor forthis web module.",
	"Method": "void configureAlternateDD(WebBundleDescriptor wbd){\r\n    String altDDName = wbd.getModuleDescriptor().getAlternateDescriptor();\r\n    if (altDDName == null) {\r\n        return;\r\n    }\r\n    com.sun.enterprise.deployment.Application app = wbd.getApplication();\r\n    if (app == null || app.isVirtual()) {\r\n        return;\r\n    }\r\n    DeploymentContext dc = getWebModuleConfig().getDeploymentContext();\r\n    if (dc == null) {\r\n        return;\r\n    }\r\n    altDDName = altDDName.trim();\r\n    if (altDDName.startsWith(\"/\")) {\r\n        altDDName = altDDName.substring(1);\r\n    }\r\n    String appLoc = dc.getSource().getParentArchive().getURI().getPath();\r\n    altDDName = appLoc + altDDName;\r\n    if (logger.isLoggable(Level.FINE)) {\r\n        Object[] objs = { altDDName, wmInfo.getName() };\r\n        logger.log(Level.FINE, LogFacade.ALT_DD_NAME, objs);\r\n    }\r\n    setAltDDName(altDDName);\r\n}"
}, {
	"Path": "com.sun.jts.codegen.otsidl._JControlStub.setTranState",
	"Comment": "returns the state of the transaction as the control object knows it.",
	"Method": "void setTranState(org.omg.CosTransactions.Status state){\r\n    org.omg.CORBA.portable.InputStream $in = null;\r\n    try {\r\n        org.omg.CORBA.portable.OutputStream $out = _request(\"setTranState\", true);\r\n        org.omg.CosTransactions.StatusHelper.write($out, state);\r\n        $in = _invoke($out);\r\n    } catch (org.omg.CORBA.portable.ApplicationException $ex) {\r\n        $in = $ex.getInputStream();\r\n        String _id = $ex.getId();\r\n        throw new org.omg.CORBA.MARSHAL(_id);\r\n    } catch (org.omg.CORBA.portable.RemarshalException $rm) {\r\n        setTranState(state);\r\n    } finally {\r\n        _releaseReply($in);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.embed.impl.WebContainerImpl.removeContext",
	"Comment": "stops the given context and removes it from allvirtualserver.",
	"Method": "void removeContext(Context context){\r\n    String contextRoot = context.getPath();\r\n    for (VirtualServer vs : getVirtualServers()) {\r\n        if (!org.glassfish.api.web.Constants.ADMIN_VS.equals(vs.getID())) {\r\n            if (vs.getContext(contextRoot) != null) {\r\n                vs.removeContext(context);\r\n                if (log.isLoggable(Level.INFO)) {\r\n                    log.info(\"Removed context with path \" + contextRoot + \" from virtual server \" + vs.getID());\r\n                }\r\n            } else {\r\n                throw new GlassFishException(\"Context with context path \" + context.getPath() + \" does not exist on virtual server \" + vs.getID());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.filterStart",
	"Comment": "configure and initialize the set of filters for this context.return true if all filter initialization completedsuccessfully, or false otherwise.",
	"Method": "boolean filterStart(){\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \"Starting filters\");\r\n    boolean ok = true;\r\n    synchronized (filterConfigs) {\r\n        filterConfigs.clear();\r\n        for (String name : filterDefs.keySet()) {\r\n            String safeName = neutralizeForLog(name);\r\n            if (log.isLoggable(Level.FINE)) {\r\n                log.log(Level.FINE, \" Starting filter '\" + safeName + \"'\");\r\n            }\r\n            try {\r\n                filterConfigs.put(name, new ApplicationFilterConfig(this, filterDefs.get(name)));\r\n            } catch (Throwable t) {\r\n                String msg = MessageFormat.format(rb.getString(LogFacade.STARTING_FILTER_EXCEPTION), safeName);\r\n                getServletContext().log(msg, t);\r\n                ok = false;\r\n            }\r\n        }\r\n    }\r\n    return (ok);\r\n}"
}, {
	"Path": "org.glassfish.api.admin.CommandSupport.init",
	"Comment": "execute aspects when command is just completely initialized, i..einjected with parameters.",
	"Method": "void init(ServiceLocator serviceLocator,AdminCommand command,AdminCommandContext context,Job instance){\r\n    processAspects(serviceLocator, command, new Function() {\r\n        @Override\r\n        public AdminCommand apply(Annotation a, CommandAspectImpl<Annotation> aspect, AdminCommand command) {\r\n            aspect.init(a, command, context, instance);\r\n            return command;\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.glassfish.api.admin.CommandSupport.init",
	"Comment": "execute aspects when command is just completely initialized, i..einjected with parameters.",
	"Method": "void init(ServiceLocator serviceLocator,AdminCommand command,AdminCommandContext context,Job instance){\r\n    aspect.init(a, command, context, instance);\r\n    return command;\r\n}"
}, {
	"Path": "org.apache.catalina.util.RequestUtil.parseCookieHeader",
	"Comment": "parse a cookie header into an array of cookies according to rfc 2109.",
	"Method": "Cookie[] parseCookieHeader(String header){\r\n    if ((header == null) || (header.length() < 1))\r\n        return (new Cookie[0]);\r\n    ArrayList<Cookie> cookies = new ArrayList<Cookie>();\r\n    while (header.length() > 0) {\r\n        int semicolon = header.indexOf(';');\r\n        if (semicolon < 0)\r\n            semicolon = header.length();\r\n        if (semicolon == 0)\r\n            break;\r\n        String token = header.substring(0, semicolon);\r\n        if (semicolon < header.length())\r\n            header = header.substring(semicolon + 1);\r\n        else\r\n            header = \"\";\r\n        try {\r\n            int equals = token.indexOf('=');\r\n            if (equals > 0) {\r\n                String name = token.substring(0, equals).trim();\r\n                String value = token.substring(equals + 1).trim();\r\n                cookies.add(new Cookie(name, value));\r\n            }\r\n        } catch (Throwable e) {\r\n        }\r\n    }\r\n    return cookies.toArray(new Cookie[cookies.size()]);\r\n}"
}, {
	"Path": "org.glassfish.webservices.monitoring.EndpointImpl.getDescriptor",
	"Comment": "return the deployment descriptors associated with this endpoint.",
	"Method": "WebServiceEndpoint getDescriptor(){\r\n    return endpointDesc;\r\n}"
}, {
	"Path": "org.apache.catalina.session.PersistentManagerBase.writeSession",
	"Comment": "write the provided session to the store without modifyingthe copy in memory or triggering passivation events. doesnothing if the session is invalid or past its expiration.",
	"Method": "void writeSession(Session session){\r\n    if (store == null || !session.isValid()) {\r\n        return;\r\n    }\r\n    ((StandardContext) getContainer()).sessionPersistedStartEvent((StandardSession) session);\r\n    if (isSessionVersioningSupported() && ((StandardSession) session).hasNonHttpLockOccurred()) {\r\n        ((StandardSession) session).incrementVersion();\r\n    }\r\n    try {\r\n        if (SecurityUtil.isPackageProtectionEnabled()) {\r\n            try {\r\n                AccessController.doPrivileged(new PrivilegedStoreSave(session));\r\n            } catch (PrivilegedActionException ex) {\r\n                Exception exception = ex.getException();\r\n                log.log(Level.SEVERE, LogFacade.STORE_WRITE_SESSION_EXCEPTION, exception);\r\n            }\r\n        } else {\r\n            store.save(session);\r\n        }\r\n    } catch (IOException e) {\r\n        log.log(Level.SEVERE, LogFacade.SERIALIZING_SESSION_EXCEPTION, new Object[] { session.getIdInternal(), e });\r\n        throw e;\r\n    } finally {\r\n        ((StandardContext) getContainer()).sessionPersistedEndEvent((StandardSession) session);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.removeInstanceListener",
	"Comment": "remove a class name from the list of instancelistener classes thatwill be added to newly created wrappers.",
	"Method": "void removeInstanceListener(String listener){\r\n    instanceListeners.remove(listener);\r\n    if (notifyContainerListeners) {\r\n        fireContainerEvent(\"removeInstanceListener\", listener);\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.ArrayStack.push",
	"Comment": "pushes a new item onto the top of this stack. the pushed item is alsoreturned. this is equivalent to calling add.",
	"Method": "E push(E item){\r\n    add(item);\r\n    return item;\r\n}"
}, {
	"Path": "org.glassfish.web.embed.impl.WebContainerImpl.createContext",
	"Comment": "creates a context and configures it with the givendocroot and classloader.the classloader of the class on which this method is calledwill be used.in order to access the new context or any of itsresources, the context must be registered with avirtualserver that has been started.",
	"Method": "Context createContext(File docRoot,Context createContext,File docRoot,ClassLoader classLoader,Context createContext,File docRoot,String contextRoot,ClassLoader classLoader){\r\n    Context context = createContext(docRoot, classLoader);\r\n    try {\r\n        addContext(context, contextRoot);\r\n    } catch (Exception ex) {\r\n        log.severe(\"Couldn't add context \" + context + \" using \" + contextRoot);\r\n        ex.printStackTrace();\r\n    }\r\n    return context;\r\n}"
}, {
	"Path": "org.glassfish.weld.connector.WeldSniffer.supportsArchiveType",
	"Comment": "this api is used to help determine if the sniffer should recognizethe current archive.if the sniffer does not support the archive type associated withthe current deployment, the sniffer should not recognize the archive.",
	"Method": "boolean supportsArchiveType(ArchiveType archiveType){\r\n    if (archiveType.toString().equals(ModuleType.WAR.toString()) || archiveType.toString().equals(ModuleType.EJB.toString()) || archiveType.toString().equals(ModuleType.RAR.toString())) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.getContexts",
	"Comment": "gets the collection of context instances registered withthis virtualserver.",
	"Method": "Collection<Context> getContexts(){\r\n    Collection<Context> ctxs = new ArrayList<Context>();\r\n    for (Container container : findChildren()) {\r\n        if (container instanceof Context) {\r\n            ctxs.add((Context) container);\r\n        }\r\n    }\r\n    return ctxs;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.messagebean.EjbCreateModifiers.check",
	"Comment": "run a verifier test against an individual declared messagedrive bean component",
	"Method": "Result check(EjbMessageBeanDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    Class mbc = loadMessageBeanClass(descriptor, result);\r\n    if (mbc != null) {\r\n        Method m = getMethod(mbc, getMethodName(), null);\r\n        if (m != null) {\r\n            int modifiers = m.getModifiers();\r\n            if (Modifier.isPublic(modifiers) && !Modifier.isStatic(modifiers) && !Modifier.isFinal(modifiers)) {\r\n                result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.passed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.messagebean.EjbCreateModifiers.passed\", \"Message-Drive bean [ {0} ] provide an {1} implementation declared public and not static or final\", new Object[] { (descriptor).getEjbClassName(), getMethodName() }));\r\n            } else {\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.failed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.messagebean.EjbCreateModifiers.failed\", \"Error: Message-Drive bean [ {0} ] {1} implementation is either not public or is static or final\", new Object[] { (descriptor).getEjbClassName(), getMethodName() }));\r\n            }\r\n        } else {\r\n            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.failed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.messagebean.EjbCreateExists.failed\", \"Error: Message-Drive bean [ {0} ] does not implement an {1} with no arguments\", new Object[] { (descriptor).getEjbClassName(), getMethodName() }));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "testmbeans.ImplementsMBeanRegistration.preRegister",
	"Comment": "allows the mbean to perform any operations it needs before beingregistered in the mbean server. if the name of the mbean is notspecified, the mbean can provide a name for its registration. ifany exception is raised, the mbean will not be registered in thembean server.",
	"Method": "ObjectName preRegister(MBeanServer server,ObjectName name){\r\n    myName = name;\r\n    return name;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.pwc.PwcWebModule.setSTMPoolSize",
	"Comment": "set the maximum number of instances that will be allocated when a singlethread model servlet is used in this web module.",
	"Method": "void setSTMPoolSize(int newPoolSize){\r\n    int oldPoolSize = this.stmPoolSize;\r\n    this.stmPoolSize = newPoolSize;\r\n    support.firePropertyChange(\"stmPoolSize\", Integer.valueOf(oldPoolSize), Integer.valueOf(this.stmPoolSize));\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.CommandRunnerImpl.getCommandInvocation",
	"Comment": "obtain a new command invocation object.command invocations can be configured and usedto trigger a command execution.",
	"Method": "CommandInvocation getCommandInvocation(String name,ActionReport report,Subject subject,CommandInvocation getCommandInvocation,String scope,String name,ActionReport report,Subject subject,CommandInvocation getCommandInvocation,String name,ActionReport report,Subject subject,boolean isNotify,CommandInvocation getCommandInvocation,String scope,String name,ActionReport report,Subject subject,boolean isNotify){\r\n    return new ExecutionContext(scope, name, report, subject, isNotify);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.DeleteSystemProperty.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    Property domainProp = domain.getProperty(\"administrative.domain.name\");\r\n    String domainName = domainProp.getValue();\r\n    if (!spb.containsProperty(propName)) {\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        String msg = localStrings.getLocalString(\"no.such.property\", \"System Property named {0} does not exist at the given target {1}\", propName, target);\r\n        report.setMessage(msg);\r\n        return;\r\n    }\r\n    if (definitions(propName) == 1) {\r\n        List<String> refs = new ArrayList<String>();\r\n        List<Dom> doms = new ArrayList<Dom>();\r\n        if (\"domain\".equals(target) || target.equals(domainName)) {\r\n            for (Server s : domain.getServers().getServer()) {\r\n                Config config = s.getConfig();\r\n                Cluster cluster = s.getCluster();\r\n                if (!s.containsProperty(propName) && !config.containsProperty(propName)) {\r\n                    if (cluster != null) {\r\n                        if (!cluster.containsProperty(propName)) {\r\n                            doms.add(Dom.unwrap(s));\r\n                        }\r\n                    } else {\r\n                        doms.add(Dom.unwrap(s));\r\n                    }\r\n                }\r\n            }\r\n        } else {\r\n            Config config = domain.getConfigNamed(target);\r\n            if (config != null) {\r\n                doms.add(Dom.unwrap(config));\r\n                String configName = config.getName();\r\n                for (Server s : domain.getServers().getServer()) {\r\n                    String configRef = s.getConfigRef();\r\n                    if (configRef.equals(configName)) {\r\n                        if (!s.containsProperty(propName)) {\r\n                            doms.add(Dom.unwrap(s));\r\n                        }\r\n                    }\r\n                }\r\n                for (Cluster c : domain.getClusters().getCluster()) {\r\n                    String configRef = c.getConfigRef();\r\n                    if (configRef.equals(configName)) {\r\n                        if (!c.containsProperty(propName)) {\r\n                            doms.add(Dom.unwrap(c));\r\n                        }\r\n                    }\r\n                }\r\n            } else {\r\n                Cluster cluster = domain.getClusterNamed(target);\r\n                if (cluster != null) {\r\n                    doms.add(Dom.unwrap(cluster));\r\n                    Config clusterConfig = domain.getConfigNamed(cluster.getConfigRef());\r\n                    doms.add(Dom.unwrap(clusterConfig));\r\n                    for (Server s : cluster.getInstances()) {\r\n                        if (!s.containsProperty(propName)) {\r\n                            doms.add(Dom.unwrap(s));\r\n                        }\r\n                    }\r\n                } else {\r\n                    Server server = domain.getServerNamed(target);\r\n                    doms.add(Dom.unwrap(server));\r\n                    doms.add(Dom.unwrap(domain.getConfigNamed(server.getConfigRef())));\r\n                }\r\n            }\r\n        }\r\n        String sysPropName = SystemPropertyConstants.getPropertyAsValue(propName);\r\n        for (Dom d : doms) {\r\n            listRefs(d, sysPropName, refs);\r\n        }\r\n        if (!refs.isEmpty()) {\r\n            String msg = localStrings.getLocalString(\"cant.delete.referenced.property\", \"System Property {0} is referenced by {1} in the configuration. Please remove the references first.\", propName, Arrays.toString(refs.toArray()));\r\n            report.setMessage(msg);\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<SystemPropertyBag>() {\r\n            public Object run(SystemPropertyBag param) throws PropertyVetoException, TransactionFailure {\r\n                param.getSystemProperty().remove(param.getSystemProperty(propName));\r\n                return param;\r\n            }\r\n        }, spb);\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n        String msg = localStrings.getLocalString(\"delete.sysprops.ok\", \"System Property named {0} deleted from given target {1}. Make sure you check its references.\", propName, target);\r\n        report.setMessage(msg);\r\n    } catch (TransactionFailure tf) {\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tf);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.DeleteSystemProperty.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    param.getSystemProperty().remove(param.getSystemProperty(propName));\r\n    return param;\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.DeleteNetworkListener.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    ActionReport report = context.getActionReport();\r\n    NetworkListeners networkListeners = config.getNetworkConfig().getNetworkListeners();\r\n    try {\r\n        if (findListener(networkListeners, report)) {\r\n            final Protocol httpProtocol = listenerToBeRemoved.findHttpProtocol();\r\n            final VirtualServer virtualServer = config.getHttpService().getVirtualServerByName(httpProtocol.getHttp().getDefaultVirtualServer());\r\n            ConfigSupport.apply(new ConfigCode() {\r\n                public Object run(ConfigBeanProxy... params) throws PropertyVetoException {\r\n                    final NetworkListeners listeners = (NetworkListeners) params[0];\r\n                    final VirtualServer server = (VirtualServer) params[1];\r\n                    listeners.getNetworkListener().remove(listenerToBeRemoved);\r\n                    server.removeNetworkListener(listenerToBeRemoved.getName());\r\n                    return listenerToBeRemoved;\r\n                }\r\n            }, networkListeners, virtualServer);\r\n        }\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.DELETE_NETWORK_LISTENER_FAIL), networkListenerName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.DeleteNetworkListener.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final NetworkListeners listeners = (NetworkListeners) params[0];\r\n    final VirtualServer server = (VirtualServer) params[1];\r\n    listeners.getNetworkListener().remove(listenerToBeRemoved);\r\n    server.removeNetworkListener(listenerToBeRemoved.getName());\r\n    return listenerToBeRemoved;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationHttpResponse.getInfo",
	"Comment": "return descriptive information about this implementation.",
	"Method": "String getInfo(){\r\n    return (this.info);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.getAllowLinking",
	"Comment": "gets the value of the allowlinking property of this virtual server.",
	"Method": "boolean getAllowLinking(){\r\n    return allowLinking;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.DomainConfigValidator.validate",
	"Comment": "validates the domainconfig. for each required domain config entry in theentries, gets the value from the domainconfig object and invokes the validator of that entry. skips the validation of an entry if no validatoris specified for that entry.",
	"Method": "void validate(Object domainConfig){\r\n    super.validate(domainConfig);\r\n    for (int i = 0; i < entries.length; i++) {\r\n        if (isValidate(entries[i].key, domainConfig)) {\r\n            final Object value = ((HashMap) domainConfig).get(entries[i].key);\r\n            if (entries[i].hasValidator()) {\r\n                entries[i].validator.validate(value);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.util.Utility.convertCharArrayToByteArray",
	"Comment": "convert the char array to byte array with respect to given charset.",
	"Method": "byte[] convertCharArrayToByteArray(char[] charArray,String strCharset){\r\n    if (charArray == null) {\r\n        return null;\r\n    }\r\n    char[] cArray = (char[]) charArray.clone();\r\n    CharBuffer charBuffer = CharBuffer.wrap(cArray);\r\n    Charset charSet;\r\n    if (strCharset == null || \"\".equals(strCharset)) {\r\n        charSet = Charset.defaultCharset();\r\n    } else if (Charset.isSupported(strCharset)) {\r\n        charSet = Charset.forName(strCharset);\r\n    } else {\r\n        CharacterCodingException e = new CharacterCodingException();\r\n        e.initCause(new UnsupportedCharsetException(strCharset));\r\n        throw e;\r\n    }\r\n    CharsetEncoder encoder = charSet.newEncoder();\r\n    ByteBuffer byteBuffer = null;\r\n    try {\r\n        byteBuffer = encoder.encode(charBuffer);\r\n    } catch (CharacterCodingException cce) {\r\n        throw cce;\r\n    } catch (Throwable t) {\r\n        CharacterCodingException e = new CharacterCodingException();\r\n        e.initCause(t);\r\n        throw e;\r\n    }\r\n    byte[] result = new byte[byteBuffer.remaining()];\r\n    byteBuffer.get(result);\r\n    clear(byteBuffer);\r\n    clear(charBuffer);\r\n    return result.clone();\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.archivist.WebFragmentArchivist.setDescriptor",
	"Comment": "archivist read xml deployment descriptors and keep theparsed result in the dol descriptor instances. sets the descriptorfor a particular archivst type",
	"Method": "void setDescriptor(Application descriptor){\r\n    this.descriptor = null;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.provider.OptionsResultJsonProvider.getContent",
	"Comment": "get json representation for the given optionsresult object",
	"Method": "String getContent(OptionsResult proxy){\r\n    JSONObject obj = new JSONObject();\r\n    try {\r\n        obj.put(proxy.getName(), getRespresenationForMethodMetaData(proxy));\r\n    } catch (JSONException ex) {\r\n        RestLogging.restLogger.log(Level.SEVERE, null, ex);\r\n    }\r\n    return obj.toString();\r\n}"
}, {
	"Path": "org.glassfish.cdi.hk2.HK2IntegrationUtilities.getApplicationServiceLocator",
	"Comment": "this method returns the proper applicationservicelocatorto use for cdi integration",
	"Method": "ServiceLocator getApplicationServiceLocator(){\r\n    try {\r\n        Context ic = new InitialContext();\r\n        return (ServiceLocator) ic.lookup(APP_SL_NAME);\r\n    } catch (NamingException ne) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.valves.RemoteAddrValve.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (info);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.isUserInRole",
	"Comment": "return true if the authenticated user principalpossesses the specified role name.",
	"Method": "boolean isUserInRole(String role){\r\n    Principal userPrincipal = this.getUserPrincipal();\r\n    if (userPrincipal == null) {\r\n        return false;\r\n    }\r\n    if (context == null) {\r\n        return false;\r\n    }\r\n    Realm realm = context.getRealm();\r\n    if (realm == null) {\r\n        return false;\r\n    }\r\n    if (wrapper != null) {\r\n        String realRole = wrapper.findSecurityReference(role);\r\n        if (realRole != null && realm.hasRole(this, (HttpResponse) response, userPrincipal, realRole)) {\r\n            return true;\r\n        }\r\n    }\r\n    return realm.hasRole(this, (HttpResponse) response, userPrincipal, role);\r\n}"
}, {
	"Path": "org.glassfish.webservices.WsUtil.createTemplatesFor",
	"Comment": "create an xslt template for transforming the packaged webservicewsdl to a final wsdl.",
	"Method": "Templates createTemplatesFor(Collection endpoints,Collection wsdlRelativeImports,Collection wsdlIncludes,Collection schemaRelativeImports,Collection schemaIncludes){\r\n    ByteArrayOutputStream bos = new ByteArrayOutputStream();\r\n    OutputStreamWriter writer = new OutputStreamWriter(bos, \"UTF-8\");\r\n    writer.write(\"<xsl:transform version=\\\"1.0\\\" xmlns:xsl=\\\"http://www.w3.org/1999/XSL/Transform\\\" xmlns:xsd=\\\"http://www.w3.org/2001/XMLSchema\\\" xmlns:wsdl=\\\"http://schemas.xmlsoap.org/wsdl/\\\" xmlns:soap=\\\"http://schemas.xmlsoap.org/wsdl/soap/\\\" xmlns:soap12=\\\"http://schemas.xmlsoap.org/wsdl/soap12/\\\">\\n\");\r\n    int wsdlImportNum = 0;\r\n    for (Iterator iter = wsdlRelativeImports.iterator(); iter.hasNext(); ) {\r\n        Import next = (Import) iter.next();\r\n        String importNamespaceParam = WSDL_IMPORT_NAMESPACE_PARAM_NAME + wsdlImportNum;\r\n        String importLocationParam = WSDL_IMPORT_LOCATION_PARAM_NAME + wsdlImportNum;\r\n        writer.write(\"<xsl:param name=\\\"\" + importNamespaceParam + \"\\\"/>\\n\");\r\n        writer.write(\"<xsl:param name=\\\"\" + importLocationParam + \"\\\"/>\\n\");\r\n        writer.write(\"<xsl:template match=\\\"/\\\"><xsl:apply-templates mode=\\\"copy\\\"/><\/xsl:template>\\n\");\r\n        writer.write(\"<xsl:template match=\\\"wsdl:definitions/wsdl:import[@location='\");\r\n        writer.write(next.getLocation());\r\n        writer.write(\"']\\\" mode=\\\"copy\\\">\");\r\n        writer.write(\"<wsdl:import>\");\r\n        writer.write(\"<xsl:attribute name=\\\"namespace\\\"><xsl:value-of select=\\\"$\" + importNamespaceParam + \"\\\"/>\");\r\n        writer.write(\"<\/xsl:attribute>\");\r\n        writer.write(\"<xsl:attribute name=\\\"location\\\"><xsl:value-of select=\\\"$\" + importLocationParam + \"\\\"/>\");\r\n        writer.write(\"<\/xsl:attribute>\");\r\n        writer.write(\"<\/wsdl:import><\/xsl:template>\");\r\n        wsdlImportNum++;\r\n    }\r\n    int wsdlIncludeNum = 0;\r\n    for (Iterator iter = wsdlIncludes.iterator(); iter.hasNext(); ) {\r\n        Import next = (Import) iter.next();\r\n        String importLocationParam = WSDL_INCLUDE_LOCATION_PARAM_NAME + wsdlIncludeNum;\r\n        writer.write(\"<xsl:param name=\\\"\" + importLocationParam + \"\\\"/>\\n\");\r\n        writer.write(\"<xsl:template match=\\\"/\\\"><xsl:apply-templates mode=\\\"copy\\\"/><\/xsl:template>\\n\");\r\n        writer.write(\"<xsl:template match=\\\"wsdl:definitions/wsdl:include[@location='\");\r\n        writer.write(next.getLocation());\r\n        writer.write(\"']\\\" mode=\\\"copy\\\">\");\r\n        writer.write(\"<wsdl:include>\");\r\n        writer.write(\"<xsl:attribute name=\\\"location\\\"><xsl:value-of select=\\\"$\" + importLocationParam + \"\\\"/>\");\r\n        writer.write(\"<\/xsl:attribute>\");\r\n        writer.write(\"<\/wsdl:include><\/xsl:template>\");\r\n        wsdlIncludeNum++;\r\n    }\r\n    int schemaImportNum = 0;\r\n    for (Iterator iter = schemaRelativeImports.iterator(); iter.hasNext(); ) {\r\n        Import next = (Import) iter.next();\r\n        String importNamespaceParam = SCHEMA_IMPORT_NAMESPACE_PARAM_NAME + schemaImportNum;\r\n        String importLocationParam = SCHEMA_IMPORT_LOCATION_PARAM_NAME + schemaImportNum;\r\n        writer.write(\"<xsl:param name=\\\"\" + importNamespaceParam + \"\\\"/>\\n\");\r\n        writer.write(\"<xsl:param name=\\\"\" + importLocationParam + \"\\\"/>\\n\");\r\n        writer.write(\"<xsl:template match=\\\"/\\\"><xsl:apply-templates mode=\\\"copy\\\"/><\/xsl:template>\\n\");\r\n        writer.write(\"<xsl:template match=\\\"wsdl:definitions/wsdl:types/xsd:schema/xsd:import[@schemaLocation='\");\r\n        writer.write(next.getLocation());\r\n        writer.write(\"']\\\" mode=\\\"copy\\\">\");\r\n        writer.write(\"<xsd:import>\");\r\n        writer.write(\"<xsl:attribute name=\\\"namespace\\\"><xsl:value-of select=\\\"$\" + importNamespaceParam + \"\\\"/>\");\r\n        writer.write(\"<\/xsl:attribute>\");\r\n        writer.write(\"<xsl:attribute name=\\\"schemaLocation\\\"><xsl:value-of select=\\\"$\" + importLocationParam + \"\\\"/>\");\r\n        writer.write(\"<\/xsl:attribute>\");\r\n        writer.write(\"<\/xsd:import><\/xsl:template>\");\r\n        schemaImportNum++;\r\n    }\r\n    int schemaIncludeNum = 0;\r\n    for (Iterator iter = schemaIncludes.iterator(); iter.hasNext(); ) {\r\n        Import next = (Import) iter.next();\r\n        String importLocationParam = SCHEMA_INCLUDE_LOCATION_PARAM_NAME + schemaIncludeNum;\r\n        writer.write(\"<xsl:param name=\\\"\" + importLocationParam + \"\\\"/>\\n\");\r\n        writer.write(\"<xsl:template match=\\\"/\\\"><xsl:apply-templates mode=\\\"copy\\\"/><\/xsl:template>\\n\");\r\n        writer.write(\"<xsl:template match=\\\"wsdl:definitions/wsdl:types/xsd:schema/xsd:include[@schemaLocation='\");\r\n        writer.write(next.getLocation());\r\n        writer.write(\"']\\\" mode=\\\"copy\\\">\");\r\n        writer.write(\"<xsd:include>\");\r\n        writer.write(\"<xsl:attribute name=\\\"schemaLocation\\\"><xsl:value-of select=\\\"$\" + importLocationParam + \"\\\"/>\");\r\n        writer.write(\"<\/xsl:attribute>\");\r\n        writer.write(\"<\/xsd:include><\/xsl:template>\");\r\n        schemaIncludeNum++;\r\n    }\r\n    int endpointNum = 0;\r\n    for (Iterator iter = endpoints.iterator(); iter.hasNext(); ) {\r\n        WebServiceEndpoint endpoint = (WebServiceEndpoint) iter.next();\r\n        if (!endpoint.hasWsdlPort()) {\r\n            throw new Exception(\"No WSDL port specified for endpoint \" + endpoint.getEndpointName());\r\n        }\r\n        if (!endpoint.hasServiceName()) {\r\n            throw new Exception(\"Runtime settings error.  Cannot find \" + \"service name for endpoint \" + endpoint.getEndpointName());\r\n        }\r\n        String actualAddressParam = ENDPOINT_ADDRESS_PARAM_NAME + endpointNum;\r\n        writer.write(\"<xsl:param name=\\\"\" + actualAddressParam + \"\\\"/>\\n\");\r\n        writer.write(\"<xsl:template match=\\\"/\\\"><xsl:apply-templates mode=\\\"copy\\\"/><\/xsl:template>\\n\");\r\n        writer.write(\"<xsl:template match=\\\"wsdl:definitions[@targetNamespace='\");\r\n        writer.write(endpoint.getServiceName().getNamespaceURI());\r\n        writer.write(\"']/wsdl:service[@name='\");\r\n        writer.write(endpoint.getServiceName().getLocalPart());\r\n        writer.write(\"']/wsdl:port[@name='\");\r\n        writer.write(endpoint.getWsdlPort().getLocalPart());\r\n        writer.write(\"']/\" + endpoint.getSoapAddressPrefix() + \":address\\\" mode=\\\"copy\\\">\");\r\n        writer.write(\"<\" + endpoint.getSoapAddressPrefix() + \":address><xsl:attribute name=\\\"location\\\"><xsl:value-of select=\\\"$\" + actualAddressParam + \"\\\"/>\");\r\n        writer.write(\"<\/xsl:attribute><\/\" + endpoint.getSoapAddressPrefix() + \":address><\/xsl:template>\");\r\n        endpointNum++;\r\n    }\r\n    writer.write(\"<xsl:template match=\\\"@*|node()\\\" mode=\\\"copy\\\"><xsl:copy><xsl:apply-templates select=\\\"@*\\\" mode=\\\"copy\\\"/><xsl:apply-templates mode=\\\"copy\\\"/><\/xsl:copy><\/xsl:template>\\n\");\r\n    writer.write(\"<\/xsl:transform>\\n\");\r\n    writer.close();\r\n    byte[] stylesheet = bos.toByteArray();\r\n    if (logger.isLoggable(Level.FINE)) {\r\n        logger.fine(new String(stylesheet));\r\n    }\r\n    Source stylesheetSource = new StreamSource(new ByteArrayInputStream(stylesheet));\r\n    TransformerFactory transformerFactory = TransformerFactory.newInstance();\r\n    Templates templates = transformerFactory.newTemplates(stylesheetSource);\r\n    return templates;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RegisteredStatics.distributeEnd",
	"Comment": "informs all registered staticresource objects that a thread associationhas ended.the control object representing the transaction is given.a flag is passed indicating whether this associationis as a result of the transaction completing.",
	"Method": "void distributeEnd(ControlImpl control,boolean complete){\r\n    org.omg.CosTransactions.Coordinator coord = null;\r\n    try {\r\n        coord = control.get_coordinator();\r\n    } catch (Unavailable exc) {\r\n    }\r\n    if (coord != null) {\r\n        for (int i = 0; i < registered.size(); i++) {\r\n            StaticResource resource = (StaticResource) registered.elementAt(i);\r\n            try {\r\n                resource.endAssociation(coord, complete);\r\n            } catch (Throwable e) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteRestAdminCommand.executeCommand",
	"Comment": "run the command using the specified arguments.return the output of the command.",
	"Method": "String executeCommand(ParameterMap opts){\r\n    if (logger.isLoggable(Level.FINER)) {\r\n        logger.log(Level.FINER, \"RemoteRestAdminCommand.executeCommand() - name: {0}\", this.name);\r\n    }\r\n    if (opts != null && opts.size() == 1 && opts.containsKey(\"help\")) {\r\n        return getManPage();\r\n    }\r\n    ParameterMap params = processParams(opts);\r\n    boolean retry;\r\n    do {\r\n        retry = false;\r\n        try {\r\n            executeRemoteCommand(params);\r\n        } catch (CommandValidationException mve) {\r\n            if (refetchInvalidModel() && isCommandModelFromCache()) {\r\n                fetchCommandModel();\r\n                retry = true;\r\n            } else {\r\n                throw mve;\r\n            }\r\n        }\r\n        return output;\r\n    } while (retry);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.pe.PEDomainConfigValidator.printDuplicatesFromMap",
	"Comment": "return a string representation of the given map, but only forthose entries where the value has a size greater than 1",
	"Method": "String printDuplicatesFromMap(Map map){\r\n    final StringBuffer sb = new StringBuffer();\r\n    final Iterator it = map.entrySet().iterator();\r\n    Map.Entry entry = getNextDuplicate(it);\r\n    if (entry != null) {\r\n        printEntry(sb, entry);\r\n        while ((entry = getNextDuplicate(it)) != null) {\r\n            sb.append(\", \");\r\n            printEntry(sb, entry);\r\n        }\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.glassfish.weld.WeldDeployer.event",
	"Comment": "specific stages of the weld bootstrapping process will execute across different stagesof the deployment process.weld deployment will happen when the load phase of thedeployment process is complete.when all modules have been loaded, a deploymentgraph is produced defining the accessibility relationships betweenbeandeploymentarchives.",
	"Method": "void event(Event event){\r\n    if (event.is(org.glassfish.internal.deployment.Deployment.APPLICATION_LOADED)) {\r\n        ApplicationInfo appInfo = (ApplicationInfo) event.hook();\r\n        WeldBootstrap bootstrap = appInfo.getTransientAppMetaData(WELD_BOOTSTRAP, WeldBootstrap.class);\r\n        if (bootstrap != null) {\r\n            DeploymentImpl deploymentImpl = appInfo.getTransientAppMetaData(WELD_DEPLOYMENT, DeploymentImpl.class);\r\n            deploymentImpl.buildDeploymentGraph();\r\n            List<BeanDeploymentArchive> archives = deploymentImpl.getBeanDeploymentArchives();\r\n            for (BeanDeploymentArchive archive : archives) {\r\n                ResourceLoaderImpl loader = new ResourceLoaderImpl(((BeanDeploymentArchiveImpl) archive).getModuleClassLoaderForBDA());\r\n                archive.getServices().add(ResourceLoader.class, loader);\r\n            }\r\n            addCdiServicesToNonModuleBdas(deploymentImpl.getLibJarRootBdas(), services.getService(InjectionManager.class));\r\n            addCdiServicesToNonModuleBdas(deploymentImpl.getRarRootBdas(), services.getService(InjectionManager.class));\r\n            ClassLoader oldTCL = Thread.currentThread().getContextClassLoader();\r\n            final String fAppName = appInfo.getName();\r\n            invocationManager.pushAppEnvironment(new ApplicationEnvironment() {\r\n                @Override\r\n                public String getName() {\r\n                    return fAppName;\r\n                }\r\n            });\r\n            try {\r\n                bootstrap.startExtensions(deploymentImpl.getExtensions());\r\n                bootstrap.startContainer(fAppName, Environments.SERVLET, deploymentImpl);\r\n                bootstrap.startInitialization();\r\n                fireProcessInjectionTargetEvents(bootstrap, deploymentImpl);\r\n                bootstrap.deployBeans();\r\n                bootstrap.validateBeans();\r\n                bootstrap.endInitialization();\r\n            } catch (Throwable t) {\r\n                try {\r\n                    doBootstrapShutdown(appInfo);\r\n                } finally {\r\n                }\r\n                String msgPrefix = getDeploymentErrorMsgPrefix(t);\r\n                DeploymentException de = new DeploymentException(msgPrefix + t.getMessage());\r\n                de.initCause(t);\r\n                throw (de);\r\n            } finally {\r\n                invocationManager.popAppEnvironment();\r\n                Thread.currentThread().setContextClassLoader(oldTCL);\r\n                deploymentComplete(deploymentImpl);\r\n            }\r\n        }\r\n    } else if (event.is(org.glassfish.internal.deployment.Deployment.APPLICATION_STOPPED) || event.is(org.glassfish.internal.deployment.Deployment.APPLICATION_UNLOADED) || event.is(org.glassfish.internal.deployment.Deployment.APPLICATION_DISABLED)) {\r\n        ApplicationInfo appInfo = (ApplicationInfo) event.hook();\r\n        Application app = appInfo.getMetaData(Application.class);\r\n        if (app != null) {\r\n            for (BundleDescriptor next : app.getBundleDescriptors()) {\r\n                if (next instanceof EjbBundleDescriptor || next instanceof WebBundleDescriptor) {\r\n                    bundleToBeanDeploymentArchive.remove(next);\r\n                }\r\n            }\r\n            appToBootstrap.remove(app);\r\n        }\r\n        String shutdown = appInfo.getTransientAppMetaData(WELD_SHUTDOWN, String.class);\r\n        if (Boolean.valueOf(shutdown).equals(Boolean.TRUE)) {\r\n            return;\r\n        }\r\n        ClassLoader currentContextClassLoader = Thread.currentThread().getContextClassLoader();\r\n        Thread.currentThread().setContextClassLoader(appInfo.getAppClassLoader());\r\n        try {\r\n            WeldBootstrap bootstrap = appInfo.getTransientAppMetaData(WELD_BOOTSTRAP, WeldBootstrap.class);\r\n            if (bootstrap != null) {\r\n                final String fAppName = appInfo.getName();\r\n                invocationManager.pushAppEnvironment(new ApplicationEnvironment() {\r\n                    @Override\r\n                    public String getName() {\r\n                        return fAppName;\r\n                    }\r\n                });\r\n                try {\r\n                    doBootstrapShutdown(appInfo);\r\n                } catch (Exception e) {\r\n                    logger.log(Level.WARNING, CDILoggerInfo.WELD_BOOTSTRAP_SHUTDOWN_EXCEPTION, new Object[] { e });\r\n                } finally {\r\n                    invocationManager.popAppEnvironment();\r\n                }\r\n                appInfo.addTransientAppMetaData(WELD_SHUTDOWN, \"true\");\r\n            }\r\n        } finally {\r\n            Thread.currentThread().setContextClassLoader(currentContextClassLoader);\r\n        }\r\n        DeploymentImpl deploymentImpl = appInfo.getTransientAppMetaData(WELD_DEPLOYMENT, DeploymentImpl.class);\r\n        if (deploymentImpl != null) {\r\n            deploymentImpl.cleanup();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.weld.WeldDeployer.event",
	"Comment": "specific stages of the weld bootstrapping process will execute across different stagesof the deployment process.weld deployment will happen when the load phase of thedeployment process is complete.when all modules have been loaded, a deploymentgraph is produced defining the accessibility relationships betweenbeandeploymentarchives.",
	"Method": "void event(Event event){\r\n    return fAppName;\r\n}"
}, {
	"Path": "org.glassfish.weld.WeldDeployer.event",
	"Comment": "specific stages of the weld bootstrapping process will execute across different stagesof the deployment process.weld deployment will happen when the load phase of thedeployment process is complete.when all modules have been loaded, a deploymentgraph is produced defining the accessibility relationships betweenbeandeploymentarchives.",
	"Method": "void event(Event event){\r\n    return fAppName;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.cci.InteractionExistence.check",
	"Comment": "test if a javax.resource.cci.interfaction implementation has been provided in the rar file",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (isCCIImplemented(descriptor, result)) {\r\n        findImplementorOf(descriptor, \"javax.resource.cci.Interaction\", result);\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notapp\", \"NotApplicable : The CCI interfaces do not seem to be implemented by this resource adapter\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.characters",
	"Comment": "process notification of character data received from the body ofan xml element.",
	"Method": "void characters(char buffer,int start,int length){\r\n    if (saxLog.isLoggable(Level.FINE)) {\r\n        saxLog.log(Level.FINE, \"characters(\" + new String(buffer, start, length) + \")\");\r\n    }\r\n    bodyText.append(buffer, start, length);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RecoveryManager.removeCoordinator",
	"Comment": "removes the coordinator associations for the given identifiers.if there was no association the operation returns false.any timeout that was established for the coordinator is cancelled,and any active thread associations for the transaction are removedand the corresponding control objects destroyed.",
	"Method": "boolean removeCoordinator(GlobalTID globalTID,Long localTID,boolean aborted){\r\n    boolean result = false;\r\n    CoordinatorImpl coord = null;\r\n    result = (coordsByGlobalTID.remove(globalTID) != null);\r\n    if (result) {\r\n        coord = (CoordinatorImpl) coordsByLocalTID.remove(localTID);\r\n        result = (coord != null);\r\n    }\r\n    if (coord != null) {\r\n        try {\r\n            if (coord.is_top_level_transaction()) {\r\n                if (inCompleteTxMap.get(coord) == null) {\r\n                    if (Configuration.isDBLoggingEnabled())\r\n                        LogDBHelper.getInstance().deleteRecord(localTID.longValue());\r\n                    else\r\n                        CoordinatorLog.removeLog(localTID);\r\n                } else {\r\n                    if (_logger.isLoggable(Level.FINE)) {\r\n                        _logger.logp(Level.FINE, \"RecoveryManager\", \"removeCoordinator()\", \"Transaction hasn't completed, let it stay in active logs\");\r\n                    }\r\n                }\r\n            }\r\n        } catch (SystemException exc) {\r\n            result = false;\r\n        }\r\n    }\r\n    TimeoutManager.setTimeout(localTID, TimeoutManager.CANCEL_TIMEOUT, 0);\r\n    if (resyncCoords > 0) {\r\n        resyncCoords--;\r\n        if (resyncCoords == 0) {\r\n            try {\r\n                resyncComplete(true, true);\r\n            } catch (Throwable exc) {\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.BaseVerifier.getClassPath",
	"Comment": "converts list of paths to a string of paths separated by pathseparator",
	"Method": "String getClassPath(String getClassPath,List<String> classPath){\r\n    if (classPath == null)\r\n        return \"\";\r\n    StringBuilder cp = new StringBuilder(\"\");\r\n    for (int i = 0; i < classPath.size(); i++) {\r\n        cp.append(classPath.get(i));\r\n        cp.append(File.pathSeparator);\r\n    }\r\n    return cp.toString();\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.PartItem.isFormField",
	"Comment": "determines whether or not a fileitem instance representsa simple form field.",
	"Method": "boolean isFormField(){\r\n    return isFormField;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.setCiphers",
	"Comment": "sets the ssl cipher suites that are to be enabled.only those ssl cipher suites that are actually supported bythe underlying ssl implementation will be enabled.",
	"Method": "void setCiphers(String ciphers){\r\n    setProperty(\"ciphers\", ciphers);\r\n    ServerSocketFactory factory = getFactory();\r\n    if (factory instanceof CoyoteServerSocketFactory) {\r\n        ((CoyoteServerSocketFactory) factory).setCiphers(ciphers);\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.resources.WARDirContext.rename",
	"Comment": "binds a new name to the object bound to an old name, and unbinds the old name. both names are relative to this context. any attributes associated with the old name become associated with the new name. intermediate contexts of the old name are not changed.",
	"Method": "void rename(String oldName,String newName){\r\n    throw new OperationNotSupportedException();\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.EjbTest.check",
	"Comment": "all connector tests should implement this method. it run an individualtest against the resource adapter deployment descriptor.",
	"Method": "Result check(Descriptor descriptor,Result check,EjbDescriptor descriptor){\r\n    try {\r\n        return check((EjbDescriptor) descriptor);\r\n    } catch (Throwable t) {\r\n        ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n        Result r = getInitializedResult();\r\n        if (t instanceof java.lang.NoClassDefFoundError) {\r\n            String s = t.toString();\r\n            String className = s.substring(s.indexOf(\":\"));\r\n            addWarningDetails(r, compName);\r\n            r.warning(smh.getLocalString(\"com.sun.enterprise.tools.verifier.checkinclasspath\", \"The class [ {0} ] was not found, check manifest classpath, or make sure it is available in classpath at runtime.\", new Object[] { className }));\r\n            return r;\r\n        } else\r\n            throw new RuntimeException(t);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.asyncComplete",
	"Comment": "invokes any registered asynclistener instances at theironcomplete method",
	"Method": "void asyncComplete(){\r\n    asyncStarted.set(false);\r\n    if (asyncStartedThread != Thread.currentThread() || !asyncContext.isOkToConfigure()) {\r\n        coyoteRequest.getResponse().resume();\r\n    } else {\r\n        final SuspendedContextImpl suspendContext = (SuspendedContextImpl) coyoteRequest.getResponse().getSuspendContext();\r\n        suspendContext.markResumed();\r\n        suspendContext.getSuspendStatus().reset();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.startup.Embedded.removeHost",
	"Comment": "remove the specified host, along with all of its related contexts,from the set of defined hosts for its associated engine.if this isthe last host for this engine, the engine will also be removed.",
	"Method": "void removeHost(Host host){\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \"Removing host[\" + host.getName() + \"]\");\r\n    boolean found = false;\r\n    for (int i = 0; i < engines.length; i++) {\r\n        Container[] hosts = engines[i].findChildren();\r\n        for (int j = 0; j < hosts.length; j++) {\r\n            if (host == (Host) hosts[j]) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (found)\r\n            break;\r\n    }\r\n    if (!found)\r\n        return;\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \" Removing this Host\");\r\n    host.getParent().removeChild(host);\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.jmx.JMXUtil.getUserDataMapString_Serializable",
	"Comment": "get a map from the user data field of a notification.this variant requires map.",
	"Method": "Map<String, T> getUserDataMapString_Serializable(Notification notif){\r\n    final Object userData = notif.getUserData();\r\n    if (!(userData instanceof Map)) {\r\n        throw new IllegalArgumentException();\r\n    }\r\n    final Map<String, T> result = TypeCast.asMap((Map) userData);\r\n    if (result != null) {\r\n        for (final Map.Entry<String, T> me : result.entrySet()) {\r\n            result.put(me.getKey(), me.getValue());\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.AuthenticatorBase.setDisableProxyCaching",
	"Comment": "set the value of the flag that states if we add headers to disablecaching by proxies.",
	"Method": "void setDisableProxyCaching(boolean nocache){\r\n    disableProxyCaching = nocache;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.upgrade",
	"Comment": "create an instance of httpupgradehandler for an givenclass and uses it for the http protocol upgrade processing.",
	"Method": "T upgrade(Class<T> handlerClass){\r\n    upgrade = true;\r\n    T handler = null;\r\n    try {\r\n        handler = ((StandardContext) getContext()).createHttpUpgradeHandlerInstance(handlerClass);\r\n    } catch (IOException | ServletException ise) {\r\n        throw ise;\r\n    } catch (Throwable t) {\r\n        throw new ServletException(t);\r\n    }\r\n    httpUpgradeHandler = handler;\r\n    coyoteRequest.getResponse().suspend();\r\n    return handler;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.CheckMgr.addVerifierEventsListener",
	"Comment": "support notification of test completion with a changeeventthe changeevent source is the corresponding result object",
	"Method": "void addVerifierEventsListener(VerifierEventsListener l){\r\n    listenerList.add(l);\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.VirtualServerConfig.setContextXmlDefault",
	"Comment": "sets the location of the default context.xml configuration file.",
	"Method": "void setContextXmlDefault(String contextXmlDefault){\r\n    this.contextXmlDefault = contextXmlDefault;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.pe.PEDomainConfigValidator.reverseMap",
	"Comment": "reverse the given map. i.e. a keys in the input map arevalues in the output map, and values in the input map arekays in the output map. note that the values in the outputmap must be sets, to allow for many to 1 relations in the inputmap.",
	"Method": "Map reverseMap(Map inputMap){\r\n    final Map outputMap = new TreeMap();\r\n    for (Iterator entries = inputMap.entrySet().iterator(); entries.hasNext(); ) {\r\n        Map.Entry entry = (Map.Entry) entries.next();\r\n        addEntryToMap(entry.getKey(), entry.getValue(), outputMap);\r\n    }\r\n    return outputMap;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.adapter.Utils.packageResource2String",
	"Comment": "reads the given file in this package and returns it as a string. if there is any problem in reading an ioexception is thrown.",
	"Method": "String packageResource2String(String name){\r\n    String file = Utils.class.getPackage().getName().replace('.', '/') + \"/\" + name;\r\n    InputStream is = null;\r\n    try {\r\n        is = new BufferedInputStream(Utils.class.getClassLoader().getResourceAsStream(file));\r\n        byte[] bytes = new byte[1024];\r\n        int read;\r\n        StringBuilder sb = new StringBuilder();\r\n        while ((read = is.read(bytes)) != -1) {\r\n            sb.append(new String(bytes, 0, read, \"UTF-8\"));\r\n        }\r\n        return (sb.toString());\r\n    } finally {\r\n        if (is != null) {\r\n            try {\r\n                is.close();\r\n            } catch (IOException ioe) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.removeResourceEnvReferenceDescriptor",
	"Comment": "removes a existing resource environment reference from the bundle",
	"Method": "void removeResourceEnvReferenceDescriptor(ResourceEnvReferenceDescriptor resourceEnvRefReference){\r\n    getResourceEnvReferenceDescriptors().remove(resourceEnvRefReference);\r\n}"
}, {
	"Path": "org.glassfish.webservices.WebServiceEjbEndpointRegistry.createEjbEndpointInfo",
	"Comment": "creates a new ejbruntimeendpointinfo instance depending on the typeand version of the web service implementation.",
	"Method": "EjbRuntimeEndpointInfo createEjbEndpointInfo(WebServiceEndpoint webServiceEndpoint,EjbEndpointFacade ejbContainer,Object servant,Class tieClass){\r\n    EjbRuntimeEndpointInfo info = null;\r\n    if (webServiceEndpoint.getWebService().hasMappingFile()) {\r\n        info = new Ejb2RuntimeEndpointInfo(webServiceEndpoint, ejbContainer, servant, tieClass);\r\n    } else {\r\n        info = new EjbRuntimeEndpointInfo(webServiceEndpoint, ejbContainer, servant);\r\n    }\r\n    return info;\r\n}"
}, {
	"Path": "com.sun.jts.jta.UserTransactionImpl.setTransactionTimeout",
	"Comment": "modify the timeout value that is associated with transactions startedby subsequent invocations of the begin method. if an application has not called this method, the transactionservice uses some default value for the transaction timeout.",
	"Method": "void setTransactionTimeout(int seconds){\r\n    if (transactionManager == null)\r\n        init();\r\n    this.transactionManager.setTransactionTimeout(seconds);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.PEAccessLogValve.updateVirtualServerProperties",
	"Comment": "configures this accesslog valve with the accesslog related propertiesof the givenbean.",
	"Method": "boolean updateVirtualServerProperties(String vsId,VirtualServer vsBean,Domain domain,ServiceLocator services,String accessLogBufferSize,String accessLogWriteInterval){\r\n    String accessLog = vsBean.getAccessLog();\r\n    if (accessLog == null && vsBean.getHttpAccessLog() != null) {\r\n        accessLog = vsBean.getHttpAccessLog().getLogDirectory();\r\n    }\r\n    if (accessLog == null) {\r\n        return false;\r\n    }\r\n    File dir = new File(accessLog);\r\n    if (!dir.isAbsolute()) {\r\n        String logRoot = domain.getLogRoot();\r\n        if (logRoot != null) {\r\n            dir = new File(logRoot, accessLog);\r\n        } else {\r\n            ServerEnvironment env = services.getService(ServerEnvironment.class);\r\n            dir = new File(env.getDomainRoot(), accessLog);\r\n        }\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, LogFacade.ACCESS_LOG_DIRECTORY_SET, new Object[] { vsId, dir.getAbsolutePath() });\r\n    }\r\n    setDirectory(dir.getAbsolutePath());\r\n    String acWriteInterval = vsBean.getPropertyValue(Constants.ACCESS_LOG_WRITE_INTERVAL_PROPERTY, accessLogWriteInterval);\r\n    if (acWriteInterval != null) {\r\n        try {\r\n            setWriterInterval(Integer.parseInt(acWriteInterval));\r\n        } catch (NumberFormatException ex) {\r\n            _logger.log(Level.WARNING, LogFacade.INVALID_ACCESS_LOG_WRITER_INTERVAL, acWriteInterval);\r\n        }\r\n    }\r\n    String acBufferSize = vsBean.getPropertyValue(Constants.ACCESS_LOG_BUFFER_SIZE_PROPERTY, accessLogBufferSize);\r\n    if (acBufferSize != null) {\r\n        try {\r\n            setBufferSize(Integer.parseInt(acBufferSize));\r\n        } catch (NumberFormatException ex) {\r\n            _logger.log(Level.WARNING, LogFacade.INVALID_ACCESS_LOG_BUFFER_SIZE, acBufferSize);\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.CreateInstanceCommand.getLocalInstanceDir",
	"Comment": "returns the directory for the selected instance that is on the localsystem.",
	"Method": "File getLocalInstanceDir(){\r\n    final File nodeDirFile = (nodeDir != null ? new File(nodeDir) : defaultLocalNodeDirFile());\r\n    InstanceDirs instanceDirs = new InstanceDirs(nodeDirFile.toString(), theNode.getName(), instance);\r\n    return instanceDirs.getInstanceDir();\r\n}"
}, {
	"Path": "org.apache.catalina.core.DummyRequest.getServletContext",
	"Comment": "gets the servlet context to which this servlet request was lastdispatched.",
	"Method": "ServletContext getServletContext(){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jts.pi.ArrayListStack.peek",
	"Comment": "looks at the object at the top of this stack without removing itfrom the stack.",
	"Method": "Object peek(){\r\n    Object top = null;\r\n    if (curIndex > 0) {\r\n        top = list.get(curIndex - 1);\r\n    }\r\n    return top;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.deploy.shared.InputJarArchive.getURI",
	"Comment": "returns the path used to create or open the underlying archive",
	"Method": "URI getURI(){\r\n    return uri;\r\n}"
}, {
	"Path": "org.glassfish.weld.connector.WeldUtils.isValidAnnotation",
	"Comment": "determine whether the specified annotation type is one of the specified valid types and notin the specified exclusion list. positive results include those annotations which are themselvesannotated with types in the valid list.",
	"Method": "boolean isValidAnnotation(Class<? extends Annotation> annotationType,Collection<String> validTypeNames,Collection<String> excludedTypeNames){\r\n    boolean result = false;\r\n    if (validTypeNames != null && !validTypeNames.isEmpty()) {\r\n        HashSet<String> excludedScopes = new HashSet<String>();\r\n        if (excludedTypeNames != null) {\r\n            excludedScopes.addAll(excludedTypeNames);\r\n        }\r\n        String annotationTypeName = annotationType.getName();\r\n        if (validTypeNames.contains(annotationTypeName) && !excludedScopes.contains(annotationTypeName)) {\r\n            result = true;\r\n        } else if (!excludedScopes.contains(annotationTypeName)) {\r\n            excludedScopes.add(annotationTypeName);\r\n            for (Annotation parent : annotationType.getAnnotations()) {\r\n                if (isValidAnnotation(parent.annotationType(), validTypeNames, excludedScopes)) {\r\n                    result = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.ControlImpl.getTranState",
	"Comment": "returns the state of the transaction as the control object knows it.",
	"Method": "Status getTranState(){\r\n    Status result = tranState;\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHostValve.throwable",
	"Comment": "handle the specified throwable encountered while processingthe specified request to produce the specified response.anyexceptions that occur during generation of the exception report arelogged and swallowed.",
	"Method": "void throwable(Request request,Response response,Throwable throwable){\r\n    Context context = request.getContext();\r\n    if (context == null)\r\n        return;\r\n    Throwable realError = throwable;\r\n    if (realError instanceof ServletException) {\r\n        realError = ((ServletException) realError).getRootCause();\r\n        if (realError == null) {\r\n            realError = throwable;\r\n        }\r\n    }\r\n    if (realError instanceof ClientAbortException) {\r\n        if (log.isLoggable(Level.FINE)) {\r\n            log.log(Level.FINE, LogFacade.REMOTE_CLIENT_ABORTED_EXCEPTION, realError.getCause().getMessage());\r\n        }\r\n        return;\r\n    }\r\n    ErrorPage errorPage = findErrorPage(context, throwable);\r\n    if ((errorPage == null) && (realError != throwable)) {\r\n        errorPage = findErrorPage(context, realError);\r\n    }\r\n    if (errorPage != null) {\r\n        dispatchToErrorPage(request, response, errorPage, throwable, realError, 0);\r\n    } else if (context.getDefaultErrorPage() != null) {\r\n        dispatchToErrorPage(request, response, context.getDefaultErrorPage(), throwable, realError, 0);\r\n    } else {\r\n        ServletResponse sresp = (ServletResponse) response;\r\n        ((HttpServletResponse) sresp).setStatus(HttpServletResponse.SC_INTERNAL_SERVER_ERROR);\r\n        response.setError();\r\n        status(request, response);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.PersistentManagerBase.processInvalidatedSessions",
	"Comment": "purges those session ids from the map of invalidated session ids whosetime has come up",
	"Method": "void processInvalidatedSessions(){\r\n    if (!started) {\r\n        return;\r\n    }\r\n    long timeNow = System.currentTimeMillis();\r\n    for (Map.Entry<String, Long> e : invalidatedSessions.entrySet()) {\r\n        String id = e.getKey();\r\n        Long timeAdded = e.getValue();\r\n        if ((timeAdded == null) || (timeNow - timeAdded.longValue() > rememberInvalidatedSessionIdMilliSecs)) {\r\n            removeFromInvalidatedSessions(id);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.logger.FileLoggerHandler.flush",
	"Comment": "called to flush any cached data thatthis log handler may contain.",
	"Method": "void flush(){\r\n    if (printWriter != null) {\r\n        printWriter.flush();\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.XercesParser.configureOldXerces",
	"Comment": "configure schema validation as recommended by the jaxp 1.2 spec.the properties object may contains information aboutthe schema local and language.",
	"Method": "void configureOldXerces(SAXParser parser,Properties properties){\r\n    String schemaLocation = (String) properties.get(\"schemaLocation\");\r\n    String schemaLanguage = (String) properties.get(\"schemaLanguage\");\r\n    try {\r\n        if (schemaLocation != null) {\r\n            parser.setProperty(JAXP_SCHEMA_LANGUAGE, schemaLanguage);\r\n            parser.setProperty(JAXP_SCHEMA_SOURCE, schemaLocation);\r\n        }\r\n    } catch (SAXNotRecognizedException e) {\r\n        if (log.isLoggable(Level.INFO)) {\r\n            log.log(Level.INFO, parser.getClass().getName() + \": \" + e.getMessage() + \" not supported.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.PEAccessLogValve.setPattern",
	"Comment": "set the format pattern, first translating any recognized alias.",
	"Method": "void setPattern(String p){\r\n    if (COMMON_PATTERN.equalsIgnoreCase(p)) {\r\n        formatter = new CommonAccessLogFormatterImpl();\r\n    } else if (COMBINED_PATTERN.equalsIgnoreCase(p)) {\r\n        formatter = new CombinedAccessLogFormatterImpl();\r\n    } else {\r\n        formatter = new DefaultAccessLogFormatterImpl(p, getContainer());\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.loader.WebappLoader.setRepositories",
	"Comment": "configure the repositories for our class loader, based on theassociated context.",
	"Method": "void setRepositories(){\r\n    if (!(container instanceof Context))\r\n        return;\r\n    ServletContext servletContext = ((Context) container).getServletContext();\r\n    if (servletContext == null)\r\n        return;\r\n    File workDir = (File) servletContext.getAttribute(ServletContext.TEMPDIR);\r\n    if (workDir == null) {\r\n        if (log.isLoggable(Level.INFO)) {\r\n            log.log(Level.INFO, LogFacade.NO_WORK_DIR_INFO, servletContext);\r\n        }\r\n    }\r\n    if (log.isLoggable(Level.FINEST) && workDir != null)\r\n        log.log(Level.FINEST, \"Deploying class repositories to work directory\" + workDir.getAbsolutePath());\r\n    DirContext resources = container.getResources();\r\n    String classesPath = \"/WEB-INF/classes\";\r\n    DirContext classes = null;\r\n    try {\r\n        Object object = resources.lookup(classesPath);\r\n        if (object instanceof DirContext) {\r\n            classes = (DirContext) object;\r\n        }\r\n    } catch (NamingException e) {\r\n    }\r\n    if (classes != null) {\r\n        File classRepository = null;\r\n        String absoluteClassesPath = servletContext.getRealPath(classesPath);\r\n        if (absoluteClassesPath != null) {\r\n            classRepository = new File(absoluteClassesPath);\r\n        } else {\r\n            classRepository = new File(workDir, classesPath);\r\n            if (!classRepository.mkdirs() && !classRepository.isDirectory()) {\r\n                throw new IOException(rb.getString(LogFacade.FAILED_CREATE_DEST_DIR));\r\n            }\r\n            if (!copyDir(classes, classRepository)) {\r\n                throw new IOException(rb.getString(LogFacade.FAILED_COPY_RESOURCE));\r\n            }\r\n        }\r\n        if (log.isLoggable(Level.FINEST))\r\n            log.log(Level.FINEST, \"Deploy class files \" + classesPath + \" to \" + classRepository.getAbsolutePath());\r\n    }\r\n    String libPath = \"/WEB-INF/lib\";\r\n    classLoader.setJarPath(libPath);\r\n    DirContext libDir = null;\r\n    try {\r\n        Object object = resources.lookup(libPath);\r\n        if (object instanceof DirContext)\r\n            libDir = (DirContext) object;\r\n    } catch (NamingException e) {\r\n    }\r\n    if (libDir != null) {\r\n        boolean copyJars = false;\r\n        String absoluteLibPath = servletContext.getRealPath(libPath);\r\n        File destDir = null;\r\n        if (absoluteLibPath != null) {\r\n            destDir = new File(absoluteLibPath);\r\n        } else {\r\n            copyJars = true;\r\n            destDir = new File(workDir, libPath);\r\n            if (!destDir.mkdirs() && !destDir.isDirectory()) {\r\n                log.log(Level.SEVERE, LogFacade.FAILED_CREATE_WORK_DIR_EXCEPTION, destDir.getAbsolutePath());\r\n            }\r\n        }\r\n        if (!copyJars) {\r\n            return;\r\n        }\r\n        try {\r\n            NamingEnumeration<Binding> enumeration = resources.listBindings(libPath);\r\n            while (enumeration.hasMoreElements()) {\r\n                Binding binding = enumeration.nextElement();\r\n                String filename = libPath + \"/\" + binding.getName();\r\n                if (!filename.endsWith(\".jar\") && !filename.endsWith(\".zip\"))\r\n                    continue;\r\n                if (binding.getName() != null && binding.getName().startsWith(\".\") && ignoreHiddenJarFiles) {\r\n                    continue;\r\n                }\r\n                File destFile = new File(destDir, binding.getName());\r\n                if (log.isLoggable(Level.FINEST)) {\r\n                    log.log(Level.FINEST, \"Deploy JAR \" + filename + \" to \" + destFile.getAbsolutePath());\r\n                }\r\n                Object obj = binding.getObject();\r\n                if (!(obj instanceof Resource))\r\n                    continue;\r\n                Resource jarResource = (Resource) obj;\r\n                try (FileOutputStream fos = new FileOutputStream(destFile)) {\r\n                    if (!copy(jarResource.streamContent(), fos)) {\r\n                        continue;\r\n                    }\r\n                }\r\n            }\r\n        } catch (NamingException e) {\r\n        } catch (IOException e) {\r\n            log(\"Unable to configure repositories\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteRestAdminCommand.setCommandModel",
	"Comment": "set the commandmodel used by this command.normally thecommandmodel will be fetched from the server using thegetcommandmodel method, which will also save the commandmodelfor further use.if the commandmodel is known in advance, itcan be set with this method and avoid the call to the server.",
	"Method": "void setCommandModel(CommandModel commandModel){\r\n    this.commandModel = commandModel;\r\n    this.commandModelFromCache = false;\r\n}"
}, {
	"Path": "org.apache.catalina.startup.HomesUserDatabase.getUserConfig",
	"Comment": "return the userconfig listener with which we are associated.",
	"Method": "UserConfig getUserConfig(){\r\n    return (this.userConfig);\r\n}"
}, {
	"Path": "org.glassfish.api.jdbc.SQLTraceRecord.setParams",
	"Comment": "sets the parameters of the method that executed the sql query. includes information like sql query, arguments and so on.",
	"Method": "void setParams(Object[] params){\r\n    this.params = params;\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.SessionAttributeState.createPersistentAttribute",
	"Comment": "create an instance of sessionattributestaterepresenting a persistent attribute",
	"Method": "SessionAttributeState createPersistentAttribute(){\r\n    SessionAttributeState result = new SessionAttributeState();\r\n    result.setPersistent(true);\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.JavaEETransactionManagerSimplifiedDelegate.setRollbackOnlyDistributedTransaction",
	"Comment": "throws an exception if called as it means that there is no active local transaction.",
	"Method": "void setRollbackOnlyDistributedTransaction(){\r\n    throw new IllegalStateException(sm.getString(\"enterprise_distributedtx.transaction_notactive\"));\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getParameterNames",
	"Comment": "return the names of all defined request parameters for this request.",
	"Method": "Enumeration<String> getParameterNames(){\r\n    processParameters();\r\n    return new Enumerator<String>(coyoteRequest.getParameterNames());\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.combineInjectionTargets",
	"Comment": "this method will copy the injection targets from env2 to env1.",
	"Method": "void combineInjectionTargets(EnvironmentProperty env1,EnvironmentProperty env2){\r\n    for (InjectionTarget injTarget : env2.getInjectionTargets()) {\r\n        env1.addInjectionTarget(injTarget);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.cli.CreateDomainCommand.usePortBase",
	"Comment": "check if portbase option is specified. portbase is mutually exclusive toadminport and domainproperties options. if portbase options is specfiedand also adminport or domainproperties is specified as well, then throwan exception.",
	"Method": "boolean usePortBase(){\r\n    if (portBase != null) {\r\n        if (adminPort != null) {\r\n            throw new CommandValidationException(strings.get(\"MutuallyExclusiveOption\", ADMIN_PORT, PORTBASE_OPTION));\r\n        } else if (instancePort != null) {\r\n            throw new CommandValidationException(strings.get(\"MutuallyExclusiveOption\", INSTANCE_PORT, PORTBASE_OPTION));\r\n        } else if (domainProperties != null) {\r\n            throw new CommandValidationException(strings.get(\"MutuallyExclusiveOption\", DOMAIN_PROPERTIES, PORTBASE_OPTION));\r\n        } else {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ContainerBase.removeLifecycleListener",
	"Comment": "removes the given lifecycle event listener from this container.",
	"Method": "void removeLifecycleListener(LifecycleListener listener){\r\n    lifecycle.removeLifecycleListener(listener);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.addJspFile",
	"Comment": "adds the servlet with the given name and jsp file to this servletcontext.",
	"Method": "ServletRegistration.Dynamic addJspFile(String servletName,String jspFile){\r\n    if (isContextInitializedCalled) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.SERVLET_CONTEXT_ALREADY_INIT_EXCEPTION), new Object[] { \"addJspFile\", getName() });\r\n        throw new IllegalStateException(msg);\r\n    }\r\n    if (servletName == null || servletName.length() == 0) {\r\n        throw new IllegalArgumentException(rb.getString(LogFacade.NULL_EMPTY_SERVLET_NAME_EXCEPTION));\r\n    }\r\n    synchronized (children) {\r\n        if (findChild(servletName) == null) {\r\n            DynamicServletRegistrationImpl regis = (DynamicServletRegistrationImpl) servletRegisMap.get(servletName);\r\n            Wrapper wrapper = null;\r\n            if (regis == null) {\r\n                wrapper = createWrapper();\r\n            } else {\r\n                wrapper = regis.getWrapper();\r\n            }\r\n            wrapper.setJspFile(jspFile);\r\n            wrapper.setName(servletName);\r\n            addChild(wrapper, true, (null == regis));\r\n            if (null == regis) {\r\n                regis = (DynamicServletRegistrationImpl) servletRegisMap.get(servletName);\r\n            }\r\n            return regis;\r\n        } else {\r\n            return null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.suspendWebModule",
	"Comment": "suspends the web application with the given appname that has beendeployed at the given contextroot on the given virtual servers.",
	"Method": "boolean suspendWebModule(String contextRoot,String appName,String hosts){\r\n    boolean hasBeenSuspended = false;\r\n    List<String> hostList = StringUtils.parseStringList(hosts, \" ,\");\r\n    if (hostList == null || hostList.isEmpty()) {\r\n        return hasBeenSuspended;\r\n    }\r\n    if (contextRoot.length() != 0 && !contextRoot.startsWith(\"/\")) {\r\n        contextRoot = \"/\" + contextRoot;\r\n    }\r\n    VirtualServer host = null;\r\n    Context context = null;\r\n    for (Container aHostArray : getEngine().findChildren()) {\r\n        host = (VirtualServer) aHostArray;\r\n        if (hostList.contains(host.getName()) || verifyAlias(hostList, host)) {\r\n            context = (Context) host.findChild(contextRoot);\r\n            if (context != null) {\r\n                context.setAvailable(false);\r\n                if (logger.isLoggable(Level.FINEST)) {\r\n                    logger.log(Level.FINEST, LogFacade.CONTEXT_DISABLED, new Object[] { contextRoot, host });\r\n                }\r\n                hasBeenSuspended = true;\r\n            }\r\n        }\r\n    }\r\n    if (!hasBeenSuspended) {\r\n        logger.log(Level.WARNING, LogFacade.DISABLE_WEB_MODULE_ERROR, contextRoot);\r\n    }\r\n    return hasBeenSuspended;\r\n}"
}, {
	"Path": "org.glassfish.security.common.FileRealmHelper.getUser",
	"Comment": "returns the information recorded about a particular named user.",
	"Method": "FileRealmHelper.User getUser(String name){\r\n    return userTable.get(name);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.Environment.hasOption",
	"Comment": "is there an environment entry corresponding to the named option?",
	"Method": "boolean hasOption(String name){\r\n    return env.containsKey(optionToEnv(name));\r\n}"
}, {
	"Path": "org.glassfish.admin.mbeanserver.ssl.SSLClientConfigurator.getEnabledProtocolsAsString",
	"Comment": "returns the list of enabled protocols as a comma separated string",
	"Method": "String getEnabledProtocolsAsString(){\r\n    if (getEnabledProtocols() != null && getEnabledProtocols().length > 0) {\r\n        return toCommaSeparatedString(getEnabledProtocols());\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.getMaxInstances",
	"Comment": "return maximum number of instances that will be allocated when a singlethread model servlet is used.",
	"Method": "int getMaxInstances(){\r\n    return (this.maxInstances);\r\n}"
}, {
	"Path": "com.sun.enterprise.config.util.PortBaseHelper.verifyPortBasePortIsValid",
	"Comment": "verify that the portbase port is validport must be greater than 0 and less than 65535.this method will also check if the port is in used.",
	"Method": "void verifyPortBasePortIsValid(String portName,int portNum){\r\n    if (portNum <= 0 || portNum > PORT_MAX_VAL) {\r\n        throw new TransactionFailure(strings.get(\"InvalidPortBaseRange\", portNum, portName));\r\n    }\r\n    if (checkPorts && !NetUtils.isPortFree(portNum)) {\r\n        throw new TransactionFailure(strings.get(\"PortBasePortInUse\", portNum, portName));\r\n    }\r\n    _logger.log(Level.FINER, ConfigApiLoggerInfo.portBaseHelperPort, portNum);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.deploy.shared.MemoryMappedArchive.getName",
	"Comment": "returns the name for the archive.for a memorymappedarhive there is no name, so an empty string is returned.",
	"Method": "String getName(){\r\n    return \"\";\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.XATerminatorImpl.rollback",
	"Comment": "informs the resource manager to roll back work done on behalfof a transaction branch.",
	"Method": "void rollback(Xid xid){\r\n    check(xid);\r\n    GlobalTID tid = new GlobalTID(xid);\r\n    if (RecoveryManager.readAndUpdateTxMap(tid) == false) {\r\n        throw new XAException(XAException.XAER_PROTO);\r\n    }\r\n    boolean exceptionFlag = false;\r\n    int errorCode = XAException.XAER_PROTO;\r\n    try {\r\n        RecoveryManager.waitForRecovery();\r\n        TopCoordinator coord = (TopCoordinator) RecoveryManager.getCoordinator(tid);\r\n        if (coord == null) {\r\n            errorCode = XAException.XAER_PROTO;\r\n            throw new XAException(errorCode);\r\n        }\r\n        synchronized (coord) {\r\n            coord.rollback(true);\r\n        }\r\n    } catch (Throwable exc) {\r\n        exceptionFlag = true;\r\n        XAException xaExc = new XAException(errorCode);\r\n        xaExc.initCause(exc);\r\n        throw xaExc;\r\n    } finally {\r\n        Thread thread = RecoveryManager.removeFromTxMap(tid);\r\n        if (thread == null || (thread != Thread.currentThread())) {\r\n            if (!exceptionFlag) {\r\n                throw new XAException(XAException.XAER_RMERR);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.mbeanserver.RMIConnectorStarter.stopAndUnexport",
	"Comment": "stops the connector and unexports the rmiserver from the registry.",
	"Method": "void stopAndUnexport(){\r\n    super.stop();\r\n    try {\r\n        if (this.mBindToSingleIP) {\r\n            mRegistry.unbind(mHostName);\r\n        }\r\n        UnicastRemoteObject.unexportObject(mRegistry, true);\r\n    } catch (RemoteException ex) {\r\n        Util.getLogger().log(Level.SEVERE, ERROR_STOPPING, ex);\r\n    } catch (NotBoundException ex) {\r\n        Util.getLogger().log(Level.SEVERE, ERROR_STOPPING, ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.configureHostPortNumbers",
	"Comment": "configures the given virtual server with the port numbers of itsassociated http listeners.",
	"Method": "void configureHostPortNumbers(VirtualServer vs,HashSet<NetworkListener> listeners){\r\n    boolean addJkListenerName = jkConnector != null && !vs.getName().equalsIgnoreCase(org.glassfish.api.web.Constants.ADMIN_VS);\r\n    List<String> listenerNames = new ArrayList<String>();\r\n    for (NetworkListener listener : listeners) {\r\n        if (Boolean.valueOf(listener.getEnabled())) {\r\n            listenerNames.add(listener.getName());\r\n            if (logger.isLoggable(Level.FINE)) {\r\n                logger.log(Level.FINE, LogFacade.VIRTUAL_SERVER_SET_LISTENER_NAME);\r\n            }\r\n        } else {\r\n            if (vs.getName().equalsIgnoreCase(org.glassfish.api.web.Constants.ADMIN_VS)) {\r\n                String msg = rb.getString(LogFacade.MUST_NOT_DISABLE);\r\n                msg = MessageFormat.format(msg, listener.getName(), vs.getName());\r\n                throw new IllegalArgumentException(msg);\r\n            }\r\n        }\r\n    }\r\n    if (addJkListenerName && (!listenerNames.contains(jkConnector.getName()))) {\r\n        listenerNames.add(jkConnector.getName());\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.log(Level.FINE, LogFacade.VIRTUAL_SERVER_SET_JK_LISTENER_NAME, new Object[] { vs.getID(), jkConnector.getName() });\r\n        }\r\n    }\r\n    vs.setNetworkListenerNames(listenerNames.toArray(new String[listenerNames.size()]));\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.common.XMLContentActionReporter.writeActionReport",
	"Comment": "creates a new element representing the xml content describing anaction report.invokes itself recursively to capture informationabout any subactions.",
	"Method": "Element writeActionReport(Document owningDocument,ActionReporter report){\r\n    Element result = owningDocument.createElement(\"action-report\");\r\n    result.setAttribute(\"description\", report.actionDescription);\r\n    result.setAttribute(\"exit-code\", report.getActionExitCode().name());\r\n    if (exception != null) {\r\n        result.setAttribute(\"failure-cause\", exception.getLocalizedMessage());\r\n    }\r\n    writePart(result, report.getTopMessagePart(), null);\r\n    for (ActionReporter subReport : report.subActions) {\r\n        result.appendChild(writeActionReport(owningDocument, subReport));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.configapi.tests.UnprocessedEventsTest.getFileName",
	"Comment": "returns the domaintest file name without the .xml extension to load the test configurationfrom.",
	"Method": "String getFileName(){\r\n    return \"DomainTest\";\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.getMaxInactiveInterval",
	"Comment": "return the maximum time interval, in seconds, between client requestsbefore the servlet container will invalidate the session.a negativetime indicates that the session should never time out.",
	"Method": "int getMaxInactiveInterval(){\r\n    return (this.maxInactiveInterval);\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.endPrefixMapping",
	"Comment": "process notification that a namespace prefix is going out of scope.",
	"Method": "void endPrefixMapping(String prefix){\r\n    if (saxLog.isLoggable(Level.FINE)) {\r\n        saxLog.log(Level.FINE, \"endPrefixMapping(\" + prefix + \")\");\r\n    }\r\n    ArrayStack<String> stack = namespaces.get(prefix);\r\n    if (stack == null) {\r\n        return;\r\n    }\r\n    try {\r\n        stack.pop();\r\n        if (stack.empty())\r\n            namespaces.remove(prefix);\r\n    } catch (EmptyStackException e) {\r\n        throw createSAXException(\"endPrefixMapping popped too many times\");\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.PartItem.getName",
	"Comment": "returns the name of the field in the multipart form corresponding tothis file item.",
	"Method": "String getName(){\r\n    return fieldName;\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.DeploymentContextImpl.getAppProps",
	"Comment": "returns the application level properties that will be persisted as akey value pair at then end of deployment. that allows individualdeployers implementation to store some information at theapplication level that should be available upon server restart.application level propertries are shared by all the modules.",
	"Method": "Properties getAppProps(){\r\n    if (props == null) {\r\n        props = new Properties();\r\n    }\r\n    return props;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.SecurityRolesBind.check",
	"Comment": "if the application assembler defines security roles in the deploymentdescriptor, the application assembler must bind security role referencesdeclared by the bean provider to the security roles.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    EjbBundleDescriptorImpl bundleDescriptor = descriptor.getEjbBundleDescriptor();\r\n    Set ejbs = bundleDescriptor.getEjbs();\r\n    Iterator ejbIterator = ejbs.iterator();\r\n    EjbDescriptor ejb = null;\r\n    Set roleReferences = null;\r\n    Iterator roleRefsIterator = null;\r\n    Set roles = bundleDescriptor.getRoles();\r\n    Iterator rolesIterator = roles.iterator();\r\n    RoleReference roleReference = null;\r\n    Role role = null;\r\n    boolean oneFailed = false;\r\n    while (ejbIterator.hasNext()) {\r\n        ejb = (EjbDescriptor) ejbIterator.next();\r\n        roleReferences = ejb.getRoleReferences();\r\n        roleRefsIterator = roleReferences.iterator();\r\n        if (roleRefsIterator.hasNext()) {\r\n            while (roleRefsIterator.hasNext()) {\r\n                roleReference = (RoleReference) roleRefsIterator.next();\r\n                role = roleReference.getRole();\r\n                if (!role.getName().equals(\"\") && !bundleDescriptor.getRoles().contains(role)) {\r\n                    result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                    result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: The role [ {0} ] for bean [ {1} ] is undefined.\", new Object[] { role.getName(), ejb.getName() }));\r\n                    if (!oneFailed) {\r\n                        oneFailed = true;\r\n                    }\r\n                } else {\r\n                    result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                    result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"The role [ {0} ] for bean [ {1} ] is defined.\", new Object[] { role.getName(), ejb.getName() }));\r\n                }\r\n            }\r\n        } else {\r\n            result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"There are no role references which need to be bound to other security roles within this bean [ {0} ]\", new Object[] { ejb.getName() }));\r\n        }\r\n    }\r\n    if (oneFailed) {\r\n        result.setStatus(Result.FAILED);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.SetNextRule.isExactMatch",
	"Comment": "is exact matching being used.this rule uses org.apache.commons.beanutils.methodutils to introspect the relevent objects so that the right method can be called.originally, methodutils.invokeexactmethod was used.this matches methods very strictly and so may not find a matching method when one exists.this is still the behaviour when exact matching is enabled.when exact matching is disabled, methodutils.invokemethod is used.this method finds more methods but is less precise when there are several methods with correct signatures.so, if you want to choose an exact signature you might need to enable this property.the default setting is to disable exact matches.",
	"Method": "boolean isExactMatch(){\r\n    return useExactMatch;\r\n}"
}, {
	"Path": "org.glassfish.internal.embedded.Server.addContainer",
	"Comment": "adds a container to this server.using the configuration instance for the container of type ,creating the container from that configuration and finally adding thecontainer instance to the list of managed containers",
	"Method": "void addContainer(ContainerBuilder.Type type,T addContainer,ContainerBuilder<T> info){\r\n    T container = info.create(this);\r\n    if (container != null && containers.add(new Container(container))) {\r\n        return container;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteAdminCommand.getAttributes",
	"Comment": "after a successful command execution, the attributes returnedby the command are saved.this method returns those savedattributes.",
	"Method": "Map<String, String> getAttributes(){\r\n    return attrs;\r\n}"
}, {
	"Path": "org.glassfish.common.util.timer.TimerSchedule.processRangeDaysOfMonth",
	"Comment": "process a range of values for that represents days of the month.",
	"Method": "void processRangeDaysOfMonth(String s){\r\n    if (simpleRangePattern.matcher(s).matches()) {\r\n        String[] arr = splitBy(s, rangeChar);\r\n        int begin = parseInt(arr[0], DAY_OF_MONTH);\r\n        int end = 31;\r\n        if (positivePattern.matcher(arr[1]).matches()) {\r\n            end = parseInt(arr[1], DAY_OF_MONTH);\r\n        }\r\n        if (begin < 1 || end > 31) {\r\n            throw new IllegalArgumentException(\"Invalid dayOfMonth range: \" + s);\r\n        }\r\n        setBitsRange(daysOfMonth, begin, end, 1, 32);\r\n    } else {\r\n        daysOfWeekOrRangesOfDaysInMonth.add(s.toLowerCase(Locale.ENGLISH));\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.CheckMgr.isApplicable",
	"Comment": "this method is overridden in ejbcheckmgrimpl. this method is used toensure that entity and mdb tests are not run for session descriptors and similarly the other way round.",
	"Method": "boolean isApplicable(TestInformation test,Descriptor descriptor){\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorLog.removeLog",
	"Comment": "removes the coordinatorlog object from the map, and destroys it.",
	"Method": "boolean removeLog(Long localTID,boolean removeLog,Long localTID,String logPath){\r\n    boolean result = true;\r\n    CoordinatorLogStateHolder logStateHolder = getStateHolder(logPath);\r\n    CoordinatorLog clog = (CoordinatorLog) logStateHolder.activeLogs.remove(localTID);\r\n    if (clog != null) {\r\n        synchronized (logStateHolder.keypointStateLock) {\r\n            if (logStateHolder.keypointInProgress && logStateHolder.keypointLogs != null)\r\n                logStateHolder.keypointLogs.put(localTID, NULL_ENTRY);\r\n        }\r\n        if (clog.writeDone)\r\n            logStateHolder.tranCount++;\r\n        clog.reUse(logPath);\r\n        if (logStateHolder.tranCount >= keypointTrigger) {\r\n            logStateHolder.tranCount = 0;\r\n            keypoint(logPath);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "testmbeans.Reg.preRegister",
	"Comment": "allows the mbean to perform any operations it needs before beingregistered in the mbean server. if the name of the mbean is notspecified, the mbean can provide a name for its registration. ifany exception is raised, the mbean will not be registered in thembean server.",
	"Method": "ObjectName preRegister(MBeanServer server,ObjectName name){\r\n    return new ObjectName(\"user\", \"foo\", \"xyz\");\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.mbean.AMXImplBase.getName",
	"Comment": "a subclass might need to override this method if its name contains charactersthat are illegal for the objectname.",
	"Method": "String getName(){\r\n    String name = Util.getNameProp(getObjectName());\r\n    return name == null ? AMX.NO_NAME : name;\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutoDeployedFilesManager.appToUndeployRequestFile",
	"Comment": "returns the file object for the undeployment request for the specified appfile or directory.",
	"Method": "File appToUndeployRequestFile(File autodeployDir,File f,File appToUndeployRequestFile,File f){\r\n    return appToUndeployRequestFile(f.getParentFile(), f);\r\n}"
}, {
	"Path": "org.apache.catalina.startup.DigesterFactory.newDigester",
	"Comment": "create a digester parser with no ruleassociated and xml validation turned off.",
	"Method": "Digester newDigester(Digester newDigester,RuleSet rule,Digester newDigester,boolean xmlValidation,boolean xmlNamespaceAware,RuleSet rule){\r\n    Digester digester = new Digester();\r\n    digester.setNamespaceAware(xmlNamespaceAware);\r\n    digester.setValidating(xmlValidation);\r\n    digester.setUseContextClassLoader(true);\r\n    String parserName = digester.getFactory().getClass().getName();\r\n    if (parserName.indexOf(\"xerces\") != -1) {\r\n        digester = patchXerces(digester);\r\n    }\r\n    if (xmlValidation) {\r\n        if (parserName.indexOf(\"xerces\") != -1) {\r\n            turnOnXercesValidation(digester);\r\n        } else {\r\n            turnOnValidation(digester);\r\n        }\r\n    }\r\n    digester.setEntityResolver(entityResolver);\r\n    if (rule != null)\r\n        digester.addRuleSet(rule);\r\n    return (digester);\r\n}"
}, {
	"Path": "com.sun.jts.trace.TraceRecordFormatter.convertToString",
	"Comment": "helper method to convert a byte arror to string. this is typically used for printing xids.",
	"Method": "String convertToString(byte[] byteArray){\r\n    int i;\r\n    StringBuffer strBuf = new StringBuffer();\r\n    for (i = 0; i < byteArray.length; i++) {\r\n        strBuf.append(byteArray[i]);\r\n    }\r\n    return strBuf.toString();\r\n}"
}, {
	"Path": "org.glassfish.api.deployment.MetaData.requires",
	"Comment": "returns the list of types of metadata this deployer will require to run successfullythe prepare method.",
	"Method": "Class[] requires(){\r\n    if (requires == null) {\r\n        return empty;\r\n    }\r\n    return requires;\r\n}"
}, {
	"Path": "org.glassfish.webservices.node.WebServicesDescriptorNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object descriptor){\r\n    WebServicesDescriptor webServicesDesc = bundleDescriptor.getWebServices();\r\n    WebService webService = (WebService) descriptor;\r\n    webServicesDesc.addWebService(webService);\r\n    for (Iterator iter = webService.getEndpoints().iterator(); iter.hasNext(); ) {\r\n        WebServiceEndpoint next = (WebServiceEndpoint) iter.next();\r\n        if (!next.resolveComponentLink()) {\r\n            logger.log(Level.INFO, LogUtils.WS_COMP_LINK_NOT_VALID, new Object[] { next.getEndpointName(), next.getLinkName() });\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.ProgramOptions.getProgramArguments",
	"Comment": "return an array of asadmin command line options that specifyall the options of this programoptions instance.",
	"Method": "String[] getProgramArguments(){\r\n    List<String> args = new ArrayList<String>(15);\r\n    if (ok(getHost())) {\r\n        args.add(\"--host\");\r\n        args.add(getHost());\r\n    }\r\n    if (getPort() > 0) {\r\n        args.add(\"--port\");\r\n        args.add(String.valueOf(getPort()));\r\n    }\r\n    if (ok(getUser())) {\r\n        args.add(\"--user\");\r\n        args.add(getUser());\r\n    }\r\n    if (ok(getPasswordFile())) {\r\n        args.add(\"--passwordfile\");\r\n        args.add(getPasswordFile());\r\n    }\r\n    if (ok(getAuxInput())) {\r\n        args.add(\"--\" + AUXINPUT);\r\n        args.add(getAuxInput());\r\n    }\r\n    args.add(\"--secure=\" + String.valueOf(isSecure()));\r\n    args.add(\"--terse=\" + String.valueOf(isTerse()));\r\n    args.add(\"--echo=\" + String.valueOf(isEcho()));\r\n    args.add(\"--interactive=\" + String.valueOf(isInteractive()));\r\n    String[] a = new String[args.size()];\r\n    args.toArray(a);\r\n    return a;\r\n}"
}, {
	"Path": "org.glassfish.weld.DeploymentImpl.buildDeploymentGraph",
	"Comment": "build the accessibility relationship between beandeploymentarchivesfor this deployment.this method must be called after all weldbeandeploymentarchives have been produced for thedeployment.",
	"Method": "void buildDeploymentGraph(){\r\n    if (ejbRootBdas != null) {\r\n        for (RootBeanDeploymentArchive ejbRootBda : ejbRootBdas) {\r\n            BeanDeploymentArchive ejbModuleBda = ejbRootBda.getModuleBda();\r\n            boolean modifiedArchive = false;\r\n            for (RootBeanDeploymentArchive otherEjbRootBda : ejbRootBdas) {\r\n                BeanDeploymentArchive otherEjbModuleBda = otherEjbRootBda.getModuleBda();\r\n                if (otherEjbModuleBda.getId().equals(ejbModuleBda.getId())) {\r\n                    continue;\r\n                }\r\n                ejbRootBda.getBeanDeploymentArchives().add(otherEjbRootBda);\r\n                ejbRootBda.getBeanDeploymentArchives().add(otherEjbModuleBda);\r\n                ejbModuleBda.getBeanDeploymentArchives().add(otherEjbModuleBda);\r\n                modifiedArchive = true;\r\n            }\r\n            if (libJarRootBdas != null) {\r\n                for (RootBeanDeploymentArchive libJarRootBda : libJarRootBdas) {\r\n                    BeanDeploymentArchive libJarModuleBda = libJarRootBda.getModuleBda();\r\n                    ejbRootBda.getBeanDeploymentArchives().add(libJarRootBda);\r\n                    ejbRootBda.getBeanDeploymentArchives().add(libJarModuleBda);\r\n                    ejbModuleBda.getBeanDeploymentArchives().add(libJarRootBda);\r\n                    ejbModuleBda.getBeanDeploymentArchives().add(libJarModuleBda);\r\n                    modifiedArchive = true;\r\n                }\r\n            }\r\n            if (rarRootBdas != null) {\r\n                for (RootBeanDeploymentArchive rarRootBda : rarRootBdas) {\r\n                    BeanDeploymentArchive rarModuleBda = rarRootBda.getModuleBda();\r\n                    ejbRootBda.getBeanDeploymentArchives().add(rarRootBda);\r\n                    ejbRootBda.getBeanDeploymentArchives().add(rarModuleBda);\r\n                    ejbModuleBda.getBeanDeploymentArchives().add(rarRootBda);\r\n                    ejbModuleBda.getBeanDeploymentArchives().add(rarModuleBda);\r\n                    modifiedArchive = true;\r\n                }\r\n            }\r\n            if (modifiedArchive) {\r\n                int idx = getBeanDeploymentArchives().indexOf(ejbModuleBda);\r\n                if (idx >= 0) {\r\n                    getBeanDeploymentArchives().remove(idx);\r\n                    getBeanDeploymentArchives().add(ejbModuleBda);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (warRootBdas != null) {\r\n        ListIterator<RootBeanDeploymentArchive> warIter = warRootBdas.listIterator();\r\n        boolean modifiedArchive = false;\r\n        while (warIter.hasNext()) {\r\n            RootBeanDeploymentArchive warRootBda = warIter.next();\r\n            BeanDeploymentArchive warModuleBda = warRootBda.getModuleBda();\r\n            if (ejbRootBdas != null) {\r\n                for (RootBeanDeploymentArchive ejbRootBda : ejbRootBdas) {\r\n                    BeanDeploymentArchive ejbModuleBda = ejbRootBda.getModuleBda();\r\n                    warRootBda.getBeanDeploymentArchives().add(ejbRootBda);\r\n                    warRootBda.getBeanDeploymentArchives().add(ejbModuleBda);\r\n                    warModuleBda.getBeanDeploymentArchives().add(ejbRootBda);\r\n                    warModuleBda.getBeanDeploymentArchives().add(ejbModuleBda);\r\n                    for (BeanDeploymentArchive oneBda : warModuleBda.getBeanDeploymentArchives()) {\r\n                        oneBda.getBeanDeploymentArchives().add(ejbRootBda);\r\n                        oneBda.getBeanDeploymentArchives().add(ejbModuleBda);\r\n                    }\r\n                    modifiedArchive = true;\r\n                }\r\n            }\r\n            if (libJarRootBdas != null) {\r\n                for (RootBeanDeploymentArchive libJarRootBda : libJarRootBdas) {\r\n                    BeanDeploymentArchive libJarModuleBda = libJarRootBda.getModuleBda();\r\n                    warRootBda.getBeanDeploymentArchives().add(libJarRootBda);\r\n                    warRootBda.getBeanDeploymentArchives().add(libJarModuleBda);\r\n                    warModuleBda.getBeanDeploymentArchives().add(libJarRootBda);\r\n                    warModuleBda.getBeanDeploymentArchives().add(libJarModuleBda);\r\n                    for (BeanDeploymentArchive oneBda : warModuleBda.getBeanDeploymentArchives()) {\r\n                        oneBda.getBeanDeploymentArchives().add(libJarRootBda);\r\n                        oneBda.getBeanDeploymentArchives().add(libJarModuleBda);\r\n                    }\r\n                    modifiedArchive = true;\r\n                }\r\n            }\r\n            if (rarRootBdas != null) {\r\n                for (RootBeanDeploymentArchive rarRootBda : rarRootBdas) {\r\n                    BeanDeploymentArchive rarModuleBda = rarRootBda.getModuleBda();\r\n                    warRootBda.getBeanDeploymentArchives().add(rarRootBda);\r\n                    warRootBda.getBeanDeploymentArchives().add(rarModuleBda);\r\n                    warModuleBda.getBeanDeploymentArchives().add(rarRootBda);\r\n                    warModuleBda.getBeanDeploymentArchives().add(rarModuleBda);\r\n                    for (BeanDeploymentArchive oneBda : warModuleBda.getBeanDeploymentArchives()) {\r\n                        oneBda.getBeanDeploymentArchives().add(rarRootBda);\r\n                        oneBda.getBeanDeploymentArchives().add(rarModuleBda);\r\n                    }\r\n                    modifiedArchive = true;\r\n                }\r\n            }\r\n            if (modifiedArchive) {\r\n                int idx = getBeanDeploymentArchives().indexOf(warModuleBda);\r\n                if (idx >= 0) {\r\n                    getBeanDeploymentArchives().remove(idx);\r\n                    getBeanDeploymentArchives().add(warModuleBda);\r\n                }\r\n                modifiedArchive = false;\r\n            }\r\n        }\r\n    }\r\n    addDependentBdas();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.is_same_transaction",
	"Comment": "removed synchronization at method level since only transtate requires\tlocking",
	"Method": "boolean is_same_transaction(Coordinator other){\r\n    boolean result = false;\r\n    if (tranState != null) {\r\n        if (name == null)\r\n            name = superInfo.globalTID.toString();\r\n        result = name.equals(other.get_transaction_name());\r\n    } else {\r\n        INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.Completed, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setOriginalDocBase",
	"Comment": "set the original document root for this context, which can be anabsolute pathname, a relative pathname, or a url.",
	"Method": "void setOriginalDocBase(String docBase){\r\n    this.originalDocBase = docBase;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.getJarNameToWebFragmentNameMap",
	"Comment": "this method return an unmodifiable version of jarname2webfragnamemap.",
	"Method": "Map<String, String> getJarNameToWebFragmentNameMap(){\r\n    if (jarName2WebFragNameMap == null) {\r\n        jarName2WebFragNameMap = new HashMap<String, String>();\r\n    }\r\n    return Collections.unmodifiableMap(jarName2WebFragNameMap);\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.utils.ResourceUtil.isAuthorized",
	"Comment": "indicates whether the subject can perform the action on the resource.",
	"Method": "boolean isAuthorized(ServiceLocator habitat,Subject subject,String resource,String action){\r\n    final AuthorizationService authorizationSvc = AccessController.doPrivileged(new PrivilegedLookup<AuthorizationService>(habitat, AuthorizationService.class));\r\n    return authorizationSvc.isAuthorized(subject, new URI(\"admin\", resource, null), action);\r\n}"
}, {
	"Path": "com.sun.enterprise.universal.xml.SysPropsHandlerTest.exercise",
	"Comment": "test of getcombinedsysprops method, of class syspropshandler.",
	"Method": "void exercise(){\r\n    System.out.println(\"exercise SysPropsHndler\");\r\n    SysPropsHandler instance = new SysPropsHandler();\r\n    instance.add(Type.SERVER, \"test\", \"from-server\");\r\n    instance.add(Type.CLUSTER, \"test\", \"from-cluster\");\r\n    instance.add(Type.CONFIG, \"test\", \"from-config\");\r\n    instance.add(Type.DOMAIN, \"test\", \"from-domain\");\r\n    Map<String, String> map = instance.getCombinedSysProps();\r\n    assertTrue(map.size() == 1);\r\n    assertTrue(map.get(\"test\").equals(\"from-server\"));\r\n    instance.add(Type.CLUSTER, \"test2\", \"from-cluster\");\r\n    instance.add(Type.CONFIG, \"test2\", \"from-config\");\r\n    instance.add(Type.DOMAIN, \"test2\", \"from-domain\");\r\n    instance.add(Type.CONFIG, \"test3\", \"from-config\");\r\n    instance.add(Type.DOMAIN, \"test3\", \"from-domain\");\r\n    instance.add(Type.DOMAIN, \"test4\", \"from-domain\");\r\n    map = instance.getCombinedSysProps();\r\n    assertTrue(map.size() == 4);\r\n    assertTrue(map.get(\"test\").equals(\"from-server\"));\r\n    assertTrue(map.get(\"test2\").equals(\"from-cluster\"));\r\n    assertTrue(map.get(\"test3\").equals(\"from-config\"));\r\n    assertTrue(map.get(\"test4\").equals(\"from-domain\"));\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TimeoutManager.timeLeft",
	"Comment": "returns the amount of time left before the given transaction times out.",
	"Method": "long timeLeft(Long localTID){\r\n    TimeoutInfo timeoutInfo = (TimeoutInfo) pendingTimeouts.get(localTID);\r\n    if (timeoutInfo == null)\r\n        timeoutInfo = (TimeoutInfo) indoubtTimeouts.get(localTID);\r\n    long result = -1;\r\n    if (timeoutInfo != null) {\r\n        result = timeoutInfo.expireTime - new Date().getTime();\r\n        if (result < 0) {\r\n            result = 0;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.diagnostics.context.impl.ContextImplContextPropagationIntegrationTest.testValuePersistence",
	"Comment": "verify that values set on the incumbent diagnostics context remain accessible on subsequent fetches of the diagnostics context.",
	"Method": "void testValuePersistence(){\r\n    final String propagatingKey = \"propagatingKey\";\r\n    final String propagatingValue = \"propagatingValue\";\r\n    final String nonPropagatingKey = \"nonPropagatingKey\";\r\n    final String nonPropagatingValue = \"nonPropagatingValue\";\r\n    {\r\n        Context diagnosticsContextStart = mContextManager.getContext();\r\n        diagnosticsContextStart.put(propagatingKey, propagatingValue, true);\r\n        diagnosticsContextStart.put(nonPropagatingKey, nonPropagatingValue, false);\r\n    }\r\n    for (int i = 0; i < 17; i++) {\r\n        Context diagnosticsContext = mContextManager.getContext();\r\n        Assert.assertEquals(\"The value associated with key \" + propagatingKey + \" is not as expected.\", propagatingValue, diagnosticsContext.get(propagatingKey));\r\n        Assert.assertEquals(\"The value associated with key \" + nonPropagatingKey + \" is not as expected.\", nonPropagatingValue, diagnosticsContext.get(nonPropagatingKey));\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.logger.FileLogger.stop",
	"Comment": "gracefully terminate the active use of the public methods of thiscomponent.this method should be the last one called on a giveninstance of this component.",
	"Method": "void stop(){\r\n    if (!started)\r\n        throw new LifecycleException(rb.getString(LogFacade.FILE_LOGGER_NOT_STARTED));\r\n    lifecycle.fireLifecycleEvent(STOP_EVENT, null);\r\n    started = false;\r\n    close();\r\n    super.stop();\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.ListInstancesCommand.createServerList",
	"Comment": "return null means the whichtarget is garbagereturn empty list means the whichtarget was an empty cluster",
	"Method": "List<Server> createServerList(){\r\n    if (!StringUtils.ok(whichTarget))\r\n        return allServers.getServer();\r\n    ReferenceContainer rc = domain.getReferenceContainerNamed(whichTarget);\r\n    if (rc == null) {\r\n        return getServersForNodeOrConfig();\r\n    } else if (rc.isServer()) {\r\n        List<Server> l = new LinkedList<Server>();\r\n        l.add((Server) rc);\r\n        return l;\r\n    } else if (rc.isCluster()) {\r\n        Cluster cluster = (Cluster) rc;\r\n        return cluster.getInstances();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.ConnectorTest.checkMethodImpl",
	"Comment": "check that a class overrides some methods defined in the java.lang.object class",
	"Method": "boolean checkMethodImpl(Class clazz,String methodName,Class[] parmTypes,String methodSignature,Result result){\r\n    Method m = null;\r\n    Class c = clazz;\r\n    do {\r\n        try {\r\n            m = c.getDeclaredMethod(methodName, parmTypes);\r\n        } catch (NoSuchMethodException nsme) {\r\n        } catch (SecurityException se) {\r\n        }\r\n        c = c.getSuperclass();\r\n    } while (m != null && c != null && c != Object.class);\r\n    if (m == null) {\r\n        result.failed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.ConnectorTest.MethodOverride.failed\", \"Warning: The class [ {0} ] does not override the method [ {1} ]\", new Object[] { clazz.getName(), methodSignature }));\r\n        return false;\r\n    } else {\r\n        result.passed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.ConnectorTest.MethodOverride.passed\", \"The class [ {0} ] overrides the method [ {1} ]\", new Object[] { clazz.getName(), methodSignature }));\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CMPTest.isAccessorDeclared",
	"Comment": "check if fields accessor methods conformant to spec 2.0 paragraph 9.4.1 havebeen declared in a class.",
	"Method": "boolean isAccessorDeclared(String fieldName,Class fieldType,Class c,Result result){\r\n    String getMethodName = \"get\" + Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);\r\n    String setMethodName = \"set\" + Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);\r\n    Method getMethod = getMethod(c, getMethodName, null);\r\n    if (getMethod != null) {\r\n        if (fieldType != null) {\r\n            if (!fieldType.getName().equals(getMethod.getReturnType().getName())) {\r\n                result.addErrorDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CMPTest.isAccessorDeclared.failed1\", \"Error : [ {0} ] field accessor method has the wrong return type [ {1} ] \", new Object[] { fieldName, getMethod.getReturnType().getName() }));\r\n                return false;\r\n            }\r\n        }\r\n        Class[] parms = { getMethod.getReturnType() };\r\n        Method setMethod = getMethod(c, setMethodName, parms);\r\n        if (setMethod != null) {\r\n            if (setMethod.getReturnType().getName().equals(\"void\")) {\r\n                result.addGoodDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CMPTest.isAccessorDeclared.success\", \"[ {0} ] field accessor methods exist and have the correct signaures\", new Object[] { fieldName }));\r\n                return true;\r\n            } else {\r\n                result.addErrorDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CMPTest.isAccessorDeclared.failed1\", \"Error : [ {0} ] field accessor method has the wrong return type [ {1} ] \", new Object[] { fieldName, setMethod.getReturnType().getName() }));\r\n            }\r\n        } else {\r\n            result.addErrorDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CMPTest.isAccessorDeclared.failed2\", \"Error : Cannot find accessor [ {0 } ] method for [ {1} ] field \", new Object[] { setMethodName, fieldName }));\r\n        }\r\n    } else {\r\n        result.addErrorDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CMPTest.isAccessorDeclared.failed2\", \"Error : Cannot find accessor [ {0} ] method for [ {1} ] field \", new Object[] { getMethodName, fieldName }));\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.webservices.monitoring.MessageTraceImpl.getMessage",
	"Comment": "return the soapmessage as a string including the soapheaders or not",
	"Method": "String getMessage(boolean includeHeaders){\r\n    if (soapMessage != null) {\r\n        if (includeHeaders) {\r\n            return soapMessage;\r\n        }\r\n        Pattern p = Pattern.compile(\"<env:Body>.*<\/env:Body>\");\r\n        Matcher m = p.matcher(soapMessage);\r\n        if (m.find()) {\r\n            return soapMessage.substring(m.start(), m.end());\r\n        } else {\r\n            return soapMessage;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.util.Utility.getEnvOrProp",
	"Comment": "return the value for a given name from the system properties or theenvironmental variables.the former overrides the latter.",
	"Method": "String getEnvOrProp(String name){\r\n    String envVal = System.getenv(name);\r\n    String sysPropVal = System.getProperty(name);\r\n    if (sysPropVal != null)\r\n        return sysPropVal;\r\n    return envVal;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.DelegatedRecoveryManager.shutdown",
	"Comment": "informs the delegatedrecoverymanager that the transaction service is being shutdown.for immediate shutdown,for quiesce,",
	"Method": "void shutdown(boolean immediate){\r\n    Enumeration keys = recoveryStatetable.keys();\r\n    if (keys.hasMoreElements()) {\r\n        String logPath = (String) keys.nextElement();\r\n        RecoveryStateHolder state = (RecoveryStateHolder) recoveryStatetable.get(logPath);\r\n        if (immediate) {\r\n        } else {\r\n            if (state.resyncInProgress != null) {\r\n                try {\r\n                    state.resyncInProgress.waitEvent();\r\n                } catch (InterruptedException exc) {\r\n                }\r\n            }\r\n        }\r\n        if (!immediate) {\r\n            CoordinatorLog.keypoint(logPath);\r\n            CoordinatorLog.finalizeAll(logPath);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.trace.TraceUtil.setCurrentTraceLevel",
	"Comment": "sets the current trace level. the argument is tested for its validity and trace level is set.else an exception is raised.",
	"Method": "void setCurrentTraceLevel(int traceLevel){\r\n    if (Configuration.isTraceEnabled()) {\r\n        int i;\r\n        boolean traceLevelSet = false;\r\n        for (i = 0; i <= TraceLevel.IAS_JTS_MAX_TRACE_LEVEL; i++) {\r\n            if (traceLevel == i) {\r\n                m_currentTraceLevel = traceLevel;\r\n                traceLevelSet = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!traceLevelSet)\r\n            throw new InvalidTraceLevelException();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.AuthenticatorBase.isChangeSessionIdOnAuthentication",
	"Comment": "return the flag that states if we should change the session id of anexisting session upon successful authentication.",
	"Method": "boolean isChangeSessionIdOnAuthentication(){\r\n    return changeSessionIdOnAuthentication;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.postWorkDirectory",
	"Comment": "set the appropriate context attribute for our work directory.",
	"Method": "void postWorkDirectory(){\r\n    String workDir = getWorkDir();\r\n    if (workDir == null || workDir.length() == 0) {\r\n        String hostName = null;\r\n        String engineName = null;\r\n        String hostWorkDir = null;\r\n        Container parentHost = getParent();\r\n        if (parentHost != null) {\r\n            hostName = parentHost.getName();\r\n            if (parentHost instanceof StandardHost) {\r\n                hostWorkDir = ((StandardHost) parentHost).getWorkDir();\r\n            }\r\n            Container parentEngine = parentHost.getParent();\r\n            if (parentEngine != null) {\r\n                engineName = parentEngine.getName();\r\n            }\r\n        }\r\n        if ((hostName == null) || (hostName.length() < 1))\r\n            hostName = \"_\";\r\n        if ((engineName == null) || (engineName.length() < 1))\r\n            engineName = \"_\";\r\n        String temp = getPath();\r\n        if (temp.startsWith(\"/\"))\r\n            temp = temp.substring(1);\r\n        temp = temp.replace('/', '_');\r\n        temp = temp.replace('\\\\', '_');\r\n        if (temp.length() < 1)\r\n            temp = \"_\";\r\n        if (hostWorkDir != null) {\r\n            workDir = hostWorkDir + File.separator + temp;\r\n        } else {\r\n            workDir = \"work\" + File.separator + engineName + File.separator + hostName + File.separator + temp;\r\n        }\r\n        setWorkDir(workDir);\r\n    }\r\n    File dir = new File(workDir);\r\n    if (!dir.isAbsolute()) {\r\n        File catalinaHome = engineBase();\r\n        String catalinaHomePath = null;\r\n        try {\r\n            catalinaHomePath = catalinaHome.getCanonicalPath();\r\n            dir = new File(catalinaHomePath, workDir);\r\n        } catch (IOException e) {\r\n        }\r\n    }\r\n    if (!dir.mkdirs() && !dir.isDirectory()) {\r\n        log.log(Level.SEVERE, LogFacade.CREATE_WORK_DIR_EXCEPTION, dir.getAbsolutePath());\r\n    }\r\n    getServletContext().setAttribute(ServletContext.TEMPDIR, dir);\r\n    context.setAttributeReadOnly(ServletContext.TEMPDIR);\r\n}"
}, {
	"Path": "org.glassfish.webservices.WebServiceReferenceManagerImpl.getServletAdapter",
	"Comment": "returns servletadapter instance holding wsdl for the webservice being referredin webserviceref annotation.",
	"Method": "ServletAdapter getServletAdapter(ServiceReferenceDescriptor desc){\r\n    WebBundleDescriptor webBundle = null;\r\n    WebServicesDescriptor webServicesDescriptor = null;\r\n    if (desc.getBundleDescriptor() instanceof WebBundleDescriptor) {\r\n        webBundle = ((WebBundleDescriptor) desc.getBundleDescriptor());\r\n    } else {\r\n        return getServletAdapterBasedOnWsdlUrl(desc);\r\n    }\r\n    WebServicesDescriptor wsDesc = webBundle.getWebServices();\r\n    assert wsDesc != null;\r\n    assert desc.getServiceLocalPart() != null;\r\n    WebService webService = wsDesc.getWebServiceByName(desc.getServiceLocalPart());\r\n    if (webService == null)\r\n        return getServletAdapterBasedOnWsdlUrl(desc);\r\n    String contextRoot = webBundle.getContextRoot();\r\n    String webSevicePath = null;\r\n    String publishingContext = null;\r\n    for (WebServiceEndpoint endpoint : webService.getEndpoints()) {\r\n        if (desc.getServiceName().equals(endpoint.getServiceName()) && desc.getServiceNamespaceUri().equals(endpoint.getWsdlService().getNamespaceURI())) {\r\n            String endPointAddressURI = endpoint.getEndpointAddressUri();\r\n            if (endPointAddressURI == null || endPointAddressURI.length() == 0)\r\n                return null;\r\n            webSevicePath = endPointAddressURI.startsWith(\"/\") ? endPointAddressURI : (\"/\" + endPointAddressURI);\r\n            publishingContext = \"/\" + endpoint.getPublishingUri() + \"/\" + webService.getWsdlFileUri();\r\n            Adapter adapter = JAXWSAdapterRegistry.getInstance().getAdapter(contextRoot, webSevicePath, publishingContext);\r\n            return adapter instanceof ServletAdapter ? (ServletAdapter) adapter : null;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.server.SnifferManagerImpl.getSniffers",
	"Comment": "returns a collection of sniffers that recognized some parts of thepassed archive as components their container handle.if no sniffer recognize the passed archive, an empty collection isreturned.",
	"Method": "Collection<Sniffer> getSniffers(Collection<Sniffer> getSniffers,DeploymentContext context,Collection<Sniffer> getSniffers,DeploymentContext context,List<URI> uris,Types types){\r\n    Collection<Sniffer> regularSniffers = getSniffers();\r\n    List<Sniffer> appSniffers = this.getApplicableSniffers(context, uris, types, regularSniffers, true);\r\n    for (Sniffer sniffer : regularSniffers) {\r\n        if (!appSniffers.contains(sniffer) && sniffer.handles(context)) {\r\n            appSniffers.add(sniffer);\r\n        }\r\n    }\r\n    return appSniffers;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.deploy.shared.JarArchive.getExtraData",
	"Comment": "returns any data that could have been calculated as part ofthe descriptor loading.",
	"Method": "U getExtraData(Class<U> dataType){\r\n    return dataType.cast(extraData.get(dataType));\r\n}"
}, {
	"Path": "org.apache.catalina.startup.PasswdUserDatabase.getUsers",
	"Comment": "return an enumeration of the usernames defined on this server.",
	"Method": "Enumeration<String> getUsers(){\r\n    return (homes.keys());\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.fireContainerEvent",
	"Comment": "fire container events if the context implementation is theorg.apache.catalina.core.standardcontext.",
	"Method": "void fireContainerEvent(Context context,String type,Object data){\r\n    if (!(context instanceof StandardContext)) {\r\n        return;\r\n    }\r\n    if (containerEventMethod == null) {\r\n        containerEventMethod = context.getClass().getMethod(\"fireContainerEvent\", containerEventTypes);\r\n    }\r\n    Object[] containerEventParams = new Object[2];\r\n    containerEventParams[0] = type;\r\n    containerEventParams[1] = data;\r\n    containerEventMethod.invoke(context, containerEventParams);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.isRequestedSessionIdFromCookie",
	"Comment": "return true if the session identifier included in thisrequest came from a cookie.",
	"Method": "boolean isRequestedSessionIdFromCookie(){\r\n    if (requestedSessionId != null) {\r\n        return requestedSessionCookie;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.managed.ManagedConnectionFactorySerializable.check",
	"Comment": "all connector tests should implement this method. it run an individualtest against the resource adapter deployment descriptor.",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!descriptor.getOutBoundDefined()) {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.managed.notApplicableForInboundRA\", \"Resource Adapter does not provide outbound communication\"));\r\n        return result;\r\n    }\r\n    testImplementationOf(descriptor, \"java.io.Serializable\", result);\r\n    return result;\r\n}"
}, {
	"Path": "testmbeans.Reg.getAttribute",
	"Comment": "gets the value of the specified attribute of the dynamicmbean.",
	"Method": "Object getAttribute(String attributeName){\r\n    if (attributeName.equals(\"Name\")) {\r\n        return null;\r\n    }\r\n    throw new AttributeNotFoundException(\"Unknown Attribute \" + attributeName);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.isEnableURLRewriting",
	"Comment": "checks whether the rewriting of urls with the jsessionids ofhttp sessions belonging to this context is enabled or not.",
	"Method": "boolean isEnableURLRewriting(){\r\n    return enableURLRewriting;\r\n}"
}, {
	"Path": "org.apache.catalina.loader.StandardClassLoader.addRepository",
	"Comment": "add a new repository to the set of places this classloader can look forclasses to be loaded.",
	"Method": "void addRepository(String repository){\r\n    if (debug >= 1)\r\n        log(\"addRepository(\" + repository + \")\");\r\n    try {\r\n        URLStreamHandler streamHandler = null;\r\n        String protocol = parseProtocol(repository);\r\n        if (factory != null)\r\n            streamHandler = factory.createURLStreamHandler(protocol);\r\n        URL url = new URL(null, repository, streamHandler);\r\n        super.addURL(url);\r\n    } catch (MalformedURLException e) {\r\n        IllegalArgumentException iae = new IllegalArgumentException(\"Invalid repository: \" + repository);\r\n        iae.initCause(e);\r\n        throw iae;\r\n    }\r\n    addRepositoryInternal(repository);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getResourceAsStream",
	"Comment": "return the requested resource as an inputstream.thepath must be specified according to the rules described undergetresource.if no such resource can be identified,return null.",
	"Method": "InputStream getResourceAsStream(String path){\r\n    if (path == null || !path.startsWith(\"/\"))\r\n        return (null);\r\n    path = RequestUtil.normalize(path);\r\n    if (path == null)\r\n        return (null);\r\n    DirContext resources = null;\r\n    if (alternateDocBases == null || alternateDocBases.size() == 0) {\r\n        resources = getResources();\r\n    } else {\r\n        AlternateDocBase match = AlternateDocBase.findMatch(path, alternateDocBases);\r\n        if (match != null) {\r\n            resources = ContextsAdapterUtility.unwrap(match.getResources());\r\n        } else {\r\n            resources = getResources();\r\n        }\r\n    }\r\n    if (resources != null) {\r\n        try {\r\n            Object resource = resources.lookup(path);\r\n            if (resource instanceof Resource)\r\n                return (((Resource) resource).streamContent());\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return (null);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.StartInstanceCommandTest.testExecuteCommand",
	"Comment": "test of executecommand method, of class startinstancecommand.",
	"Method": "void testExecuteCommand(){\r\n    System.out.println(\"executeCommand\");\r\n}"
}, {
	"Path": "org.apache.naming.resources.FileDirContext.release",
	"Comment": "release any resources allocated for this directory context.",
	"Method": "void release(){\r\n    caseSensitive = true;\r\n    allowLinking = false;\r\n    absoluteBase = null;\r\n    base = null;\r\n    super.release();\r\n}"
}, {
	"Path": "org.glassfish.api.admin.ProcessEnvironment.getProcessType",
	"Comment": "determine and return the modes in which the code is behaving, like application server or application client modes.",
	"Method": "ProcessType getProcessType(){\r\n    return type;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.WebTest.check",
	"Comment": "all connector tests should implement this method. it run an individualtest against the resource adapter deployment descriptor.",
	"Method": "Result check(Descriptor descriptor,Result check,WebBundleDescriptor descriptor){\r\n    return check((WebBundleDescriptor) descriptor);\r\n}"
}, {
	"Path": "org.apache.catalina.util.Extension.getUniqueId",
	"Comment": "uniqueid created by combining the extension name and implementationversion.",
	"Method": "String getUniqueId(){\r\n    return this.extensionName + this.implementationVersion;\r\n}"
}, {
	"Path": "com.sun.jts.trace.TraceUtil.getXAExceptionInfo",
	"Comment": "returns details about oracle xaexception if available. returns an default message if it is not oracle xaexception",
	"Method": "String getXAExceptionInfo(XAException exception,Logger logger){\r\n    Class<? extends XAException> aClass = exception.getClass();\r\n    if (aClass.getName().indexOf(\"OracleXAException\") < 0) {\r\n        return exception.getMessage();\r\n    }\r\n    StringBuffer msg = new StringBuffer();\r\n    try {\r\n        String oracleError = \"\" + invokeMethod(exception, aClass, \"getOracleError\", logger);\r\n        String oracleSQLError = \"\" + invokeMethod(exception, aClass, \"getOracleSQLError\", logger);\r\n        String xaError = \"\" + invokeMethod(exception, aClass, \"getXAError\", logger);\r\n        msg.append(\"\\n XAException = \").append(exception.getMessage()).append(\"\\n OracleError = \").append(oracleError).append(\"\\n OracleSQLError = \").append(oracleSQLError).append(\"\\n XAError = \").append(xaError);\r\n    } catch (Exception e) {\r\n        logger.log(Level.WARNING, \"getXAExceptionInfo failed with exception:\", e);\r\n    }\r\n    return msg.toString();\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.web.WebVerifier.getClassPath",
	"Comment": "creates and returns the class path associated with the web archive.uses the exploded location of the archive for generating the classpath.",
	"Method": "String getClassPath(){\r\n    if (classPath != null)\r\n        return classPath;\r\n    if (isASMode)\r\n        return (classPath = getClassPath(verifierFrameworkContext.getClassPath()) + File.pathSeparator + jspOutDir.getAbsolutePath());\r\n    String cp;\r\n    if (!webd.getModuleDescriptor().isStandalone()) {\r\n        String ear_uri = verifierFrameworkContext.getExplodedArchivePath();\r\n        File ear = new File(ear_uri);\r\n        assert (ear.isDirectory());\r\n        String earCP = ClassPathBuilder.buildClassPathForEar(ear);\r\n        String libdir = webd.getApplication().getLibraryDirectory();\r\n        if (libdir != null) {\r\n            earCP = getLibdirClasspath(ear_uri, libdir) + earCP;\r\n        }\r\n        String module_uri = webd.getModuleDescriptor().getArchiveUri();\r\n        File module = new File(module_uri);\r\n        assert (module.isFile() && !module.isAbsolute());\r\n        File explodedModuleDir = new File(ear_uri, FileUtils.makeFriendlyFilename(module_uri));\r\n        String moduleCP = ClassPathBuilder.buildClassPathForWar(explodedModuleDir);\r\n        cp = moduleCP + File.pathSeparator + earCP;\r\n    } else {\r\n        String module_uri = verifierFrameworkContext.getExplodedArchivePath();\r\n        File module = new File(module_uri);\r\n        assert (module.isDirectory() && module.isAbsolute());\r\n        cp = ClassPathBuilder.buildClassPathForWar(module);\r\n    }\r\n    String as_lib_root = System.getProperty(\"com.sun.aas.installRoot\") + File.separator + \"lib\" + File.separator;\r\n    if (verifierFrameworkContext.getJavaEEVersion().compareTo(\"5\") >= 0) {\r\n        cp += File.pathSeparator + as_lib_root + \"javax.faces.jar\" + File.pathSeparator + as_lib_root + \"appserv-jstl.jar\" + File.pathSeparator;\r\n    }\r\n    cp = cp + File.pathSeparator + jspOutDir.getAbsolutePath();\r\n    return (classPath = cp);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TimeoutManager.shutdown",
	"Comment": "informs the timeoutmanager that the transaction serviceis being shut down. for immediate shutdown, the timeout thread isstopped and all timeout information discarded.for quiesce, the timeout thread is stopped when there are no runningtransactions left.",
	"Method": "void shutdown(boolean immediate){\r\n    if (immediate || pendingTimeouts == null || pendingTimeouts.isEmpty()) {\r\n        if (timeoutThread != null) {\r\n            timeoutThread.stop();\r\n        }\r\n        if (pendingTimeouts != null) {\r\n            pendingTimeouts.clear();\r\n        }\r\n        pendingTimeouts = null;\r\n        timeoutThread = null;\r\n        timeoutActive = false;\r\n    } else {\r\n        quiescing = true;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModuleConfig.setWorkDirBase",
	"Comment": "sets the parent of the work directory for this web application.the actual work directory is a subdirectory named afterthe web application.",
	"Method": "void setWorkDirBase(String baseDir){\r\n    synchronized (this) {\r\n        _baseDir = baseDir;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.security.store.PasswordAdapter.getPasswordForAlias",
	"Comment": "this methods returns password string for a given alias and smp.",
	"Method": "String getPasswordForAlias(String alias){\r\n    String passwordString = null;\r\n    final Key key = _pwdStore.getKey(alias, getMasterPassword());\r\n    if (key != null) {\r\n        passwordString = new String(key.getEncoded());\r\n    }\r\n    return passwordString;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.getCertificates",
	"Comment": "get the underlying webcontainer certificate for the request",
	"Method": "X509Certificate[] getCertificates(org.apache.catalina.Request request){\r\n    Request cRequest = null;\r\n    if (request instanceof Request) {\r\n        cRequest = (Request) request;\r\n    } else {\r\n        return null;\r\n    }\r\n    X509Certificate[] certs = (X509Certificate[]) cRequest.getAttribute(Globals.CERTIFICATES_ATTR);\r\n    if ((certs == null) || (certs.length < 1)) {\r\n        certs = (X509Certificate[]) cRequest.getAttribute(Globals.SSL_CERTIFICATE_ATTR);\r\n    }\r\n    return certs;\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutoDeployedFilesManager.getFilesForUndeployment",
	"Comment": "compare the list of files with the current status infoand determine the apps that need to be undeployed.",
	"Method": "File[] getFilesForUndeployment(File[] latestFiles){\r\n    File statusDir = new File(statDir);\r\n    Set<File> statusFiles = AutoDeployDirectoryScanner.getListOfFilesAsSet(statusDir, true);\r\n    if (statusFiles == null || statusFiles.isEmpty()) {\r\n        return null;\r\n    }\r\n    for (File deployDirFile : latestFiles) {\r\n        statusFiles.remove(getStatusFile(deployDirFile));\r\n    }\r\n    ArrayList<File> appNames = new ArrayList<File>();\r\n    File autodeployDir = statusDir.getParentFile();\r\n    for (File statusDirFile : statusFiles) {\r\n        File filePath = autodeployDir;\r\n        File f = statusDirFile.getParentFile();\r\n        while (!f.equals(statusDir)) {\r\n            filePath = new File(filePath, f.getName());\r\n            f = f.getParentFile();\r\n        }\r\n        filePath = new File(filePath, statusDirFile.getName());\r\n        File _deployedMarkerFile = new File(filePath + AutoDeployConstants.DEPLOYED);\r\n        if (_deployedMarkerFile.exists()) {\r\n            appNames.add(filePath);\r\n        }\r\n    }\r\n    appNames.addAll(getFilesToUndeployByRequest(autodeployDir, statusDir));\r\n    return appNames.toArray(new File[appNames.size()]);\r\n}"
}, {
	"Path": "org.apache.catalina.valves.JDBCAccessLogValve.setQueryField",
	"Comment": "sets the name of the field containing the url part of the http query.",
	"Method": "void setQueryField(String queryField){\r\n    this.queryField = queryField;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.reconfig.WebConfigListener.setContainer",
	"Comment": "set the web container for this configlistener.must be set in order to perform dynamic configuration",
	"Method": "void setContainer(WebContainer container){\r\n    this.container = container;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardServer.removeService",
	"Comment": "remove the specified service from the set associated from thisserver.",
	"Method": "void removeService(Service service){\r\n    synchronized (servicesMonitor) {\r\n        int j = -1;\r\n        for (int i = 0; i < services.length; i++) {\r\n            if (service == services[i]) {\r\n                j = i;\r\n                break;\r\n            }\r\n        }\r\n        if (j < 0)\r\n            return;\r\n        if (services[j] instanceof Lifecycle) {\r\n            try {\r\n                ((Lifecycle) services[j]).stop();\r\n            } catch (LifecycleException e) {\r\n            }\r\n        }\r\n        int k = 0;\r\n        Service[] results = new Service[services.length - 1];\r\n        for (int i = 0; i < services.length; i++) {\r\n            if (i != j)\r\n                results[k++] = services[i];\r\n        }\r\n        services = results;\r\n        support.firePropertyChange(\"service\", service, null);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.VerifierTestContext.setEjbDescriptorForServiceRef",
	"Comment": "added for webservices client verificationset the ejbdescriptor for the current servicereferencedescriptorbeing validated by tests",
	"Method": "void setEjbDescriptorForServiceRef(EjbDescriptor desc){\r\n    ejbdesc = desc;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.provider.ProviderUtil.getHint",
	"Comment": "method to get the hint to display in case module monitoring levels are off",
	"Method": "String getHint(UriInfo uriInfo,String mediaType){\r\n    String result = \"\";\r\n    java.net.URI baseUri = uriInfo.getBaseUri();\r\n    String monitoringLevelsConfigUrl = baseUri.getScheme() + \"://\" + baseUri.getHost() + \":\" + baseUri.getPort() + \"/management/domain/configs/config/server-config/monitoring-service/module-monitoring-levels\";\r\n    String name = Util.localStrings.getLocalString(\"rest.monitoring.levels.hint.heading\", \"Hint\");\r\n    String value = Util.localStrings.getLocalString(\"rest.monitoring.levels.hint.message\", \"Module monitoring levels may be OFF. To set module monitoring levels please visit following url: {0}\", new Object[] { monitoringLevelsConfigUrl });\r\n    if (mediaType.equals(MediaType.TEXT_HTML)) {\r\n        monitoringLevelsConfigUrl = \"<br><a href=\\\"\" + monitoringLevelsConfigUrl + \"\\\">\" + monitoringLevelsConfigUrl + \"<\/a>\";\r\n        value = Util.localStrings.getLocalString(\"rest.monitoring.levels.hint.message\", \"Module monitoring levels may be OFF. To set module monitoring levels please visit following url: {0}\", new Object[] { monitoringLevelsConfigUrl });\r\n        result = result + \"<h2>\" + name + \"<\/h2>\";\r\n        result = result + value + \"<br>\";\r\n        result = \"<div>\" + result + \"<\/div>\" + \"<br>\";\r\n        return result;\r\n    }\r\n    if (mediaType.equals(MediaType.APPLICATION_JSON)) {\r\n        result = \" \" + quote(name) + \":\" + jsonValue(value);\r\n        return result;\r\n    }\r\n    if (mediaType.equals(MediaType.APPLICATION_XML)) {\r\n        result = result + \" \" + name + \"=\" + quote(value);\r\n        return result;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.managed.ManagedConnectionFactoryImplHashcode.check",
	"Comment": "test if the managedconnectionfactory implementation override the hashcode method",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!descriptor.getOutBoundDefined()) {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.managed.notApplicableForInboundRA\", \"Resource Adapter does not provide outbound communication\"));\r\n        return result;\r\n    }\r\n    Class mcf = testManagedConnectionFactoryImpl(descriptor, result);\r\n    if (mcf != null) {\r\n        checkMethodImpl(mcf, \"hashCode\", null, \"public int hashCode()\", result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.servlets.DefaultServlet.checkIfHeaders",
	"Comment": "check if the conditions specified in the optional if headers aresatisfied.",
	"Method": "boolean checkIfHeaders(HttpServletRequest request,HttpServletResponse response,ResourceAttributes resourceAttributes){\r\n    return checkIfMatch(request, response, resourceAttributes) && checkIfModifiedSince(request, response, resourceAttributes) && checkIfNoneMatch(request, response, resourceAttributes) && checkIfUnmodifiedSince(request, response, resourceAttributes);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.ControlImpl.get_localCoordinator",
	"Comment": "returns the coordinator for the transaction.if the transaction has been completed, an appropriate exception is raised.this operation is part of the omg interface and must not returnany exceptions other than those defined in the omg interface.",
	"Method": "Coordinator get_localCoordinator(){\r\n    Coordinator result = (Coordinator) coord;\r\n    if (tranState == Status.StatusCommitted) {\r\n        INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.Completed, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    if (tranState == Status.StatusRolledBack) {\r\n        TRANSACTION_ROLLEDBACK exc = new TRANSACTION_ROLLEDBACK(0, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    if (result == null) {\r\n        Unavailable exc = new Unavailable();\r\n        throw exc;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.web.util.IntrospectionUtils.addToClassPath",
	"Comment": "add all the jar files in a dir to the classpath, represented as a vectorof urls.",
	"Method": "void addToClassPath(Vector<URL> cpV,String dir){\r\n    try {\r\n        String[] cpComp = getFilesByExt(dir, \".jar\");\r\n        if (cpComp != null) {\r\n            int jarCount = cpComp.length;\r\n            for (int i = 0; i < jarCount; i++) {\r\n                URL url = getURL(dir, cpComp[i]);\r\n                if (url != null)\r\n                    cpV.addElement(url);\r\n            }\r\n        }\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.setCreationTime",
	"Comment": "set the creation time for this session.this method is called by themanager when an existing session instance is reused.",
	"Method": "void setCreationTime(long time){\r\n    this.creationTime = time;\r\n    this.lastAccessedTime = time;\r\n    this.thisAccessedTime = time;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.cli.LocalServerCommand.isThisServer",
	"Comment": "see if the server is alive and is the one at the specified directory.",
	"Method": "boolean isThisServer(File ourDir,String directoryKey){\r\n    if (!ok(directoryKey))\r\n        throw new NullPointerException();\r\n    ourDir = getUniquePath(ourDir);\r\n    logger.log(Level.FINER, \"Check if server is at location {0}\", ourDir);\r\n    try {\r\n        RemoteCLICommand cmd = new RemoteCLICommand(\"__locations\", programOpts, env);\r\n        ActionReport report = cmd.executeAndReturnActionReport(new String[] { \"__locations\" });\r\n        String theirDirPath = report.findProperty(directoryKey);\r\n        logger.log(Level.FINER, \"Remote server has root directory {0}\", theirDirPath);\r\n        if (ok(theirDirPath)) {\r\n            File theirDir = getUniquePath(new File(theirDirPath));\r\n            return theirDir.equals(ourDir);\r\n        }\r\n        return false;\r\n    } catch (Exception ex) {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.PEAccessLogValve.getCondition",
	"Comment": "return whether the attribute name to look for whenperforming conditional loggging. if null, everyrequest is logged.",
	"Method": "String getCondition(){\r\n    return condition;\r\n}"
}, {
	"Path": "org.apache.naming.resources.BaseDirContext.search",
	"Comment": "searches in the named context or object for entries that satisfy the given search filter. performs the search as specified by the search controls.",
	"Method": "NamingEnumeration<SearchResult> search(Name name,Attributes matchingAttributes,String[] attributesToReturn,NamingEnumeration<SearchResult> search,String name,Attributes matchingAttributes,String[] attributesToReturn,NamingEnumeration<SearchResult> search,Name name,Attributes matchingAttributes,NamingEnumeration<SearchResult> search,String name,Attributes matchingAttributes,NamingEnumeration<SearchResult> search,Name name,String filter,SearchControls cons,NamingEnumeration<SearchResult> search,String name,String filter,SearchControls cons,NamingEnumeration<SearchResult> search,Name name,String filterExpr,Object[] filterArgs,SearchControls cons,NamingEnumeration<SearchResult> search,String name,String filterExpr,Object[] filterArgs,SearchControls cons){\r\n    return search(name.toString(), filterExpr, filterArgs, cons);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.getLocalTID",
	"Comment": "returns the internal identifier for the transaction.this method is currently not synchronized because that causes a deadlockin resync.",
	"Method": "long getLocalTID(){\r\n    long result = superInfo.localTID.longValue();\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.provider.ProviderUtil.stringToArray",
	"Comment": "this method converts a string into string array, uses the delimeter as the separator character. if the delimiter is null, uses space as default.",
	"Method": "String[] stringToArray(String str,String delimiter){\r\n    String[] retString = new String[0];\r\n    if (str != null) {\r\n        if (delimiter == null) {\r\n            delimiter = \" \";\r\n        }\r\n        StringTokenizer tokens = new StringTokenizer(str, delimiter);\r\n        retString = new String[tokens.countTokens()];\r\n        int i = 0;\r\n        while (tokens.hasMoreTokens()) {\r\n            retString[i++] = tokens.nextToken();\r\n        }\r\n    }\r\n    return retString;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.stringsubs.impl.StringSubstitutionProperties.getProperty",
	"Comment": "searches for the property with the specified key in this property list.the method returns null if the property is not found.",
	"Method": "String getProperty(String key){\r\n    if (_properties == null) {\r\n        load();\r\n    }\r\n    return _properties.getProperty(key);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.ListenerClassHasValidConstructor.runIndividualListenerTest",
	"Comment": "run the verifier test against a declared individual listener class",
	"Method": "boolean runIndividualListenerTest(Result result,Class listenerClass){\r\n    boolean validConstructor = false;\r\n    boolean foundIt = false;\r\n    if (listenerClass == null)\r\n        return false;\r\n    do {\r\n        Constructor[] constructors = listenerClass.getDeclaredConstructors();\r\n        for (int i = 0; i < constructors.length; i++) {\r\n            logger.log(Level.FINE, getClass().getName() + \".debug\", new Object[] { constructors[i].toString() });\r\n            Class[] parameters = constructors[i].getParameterTypes();\r\n            if (parameters.length == 0) {\r\n                if (Modifier.isPublic(constructors[i].getModifiers())) {\r\n                    validConstructor = true;\r\n                } else {\r\n                    validConstructor = false;\r\n                }\r\n                foundIt = true;\r\n                break;\r\n            }\r\n        }\r\n    } while ((!foundIt) && ((listenerClass = listenerClass.getSuperclass()) != null));\r\n    if (validConstructor) {\r\n        result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"Listener class [ {0} ] implements a valid constructor.\", new Object[] { listenerClass.getName() }));\r\n    } else {\r\n        result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Listener class [ {0} ] does not implement a valid constructor.\", new Object[] { listenerClass.getName() }));\r\n    }\r\n    return validConstructor;\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.getAttributeInternal",
	"Comment": "return the value of an attribute without a check for validity.",
	"Method": "Object getAttributeInternal(String name){\r\n    return (attributes.get(name));\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogFile.getLogRecords",
	"Comment": "returns all of the log records written to the log since the last checkpoint.the caller is responsible for freeing the sequence storage.if the log is empty, an empty sequence is returned.the result is returned in a vector as we do not know ahead of time howmany log records there are.",
	"Method": "Vector getLogRecords(){\r\n    Vector logRecords = new Vector();\r\n    boolean keypointEndFound = false;\r\n    LogCursor logCursor;\r\n    try {\r\n        logCursor = handle.openCursor(LogLSN.HEAD_LSN, LogLSN.TAIL_LSN);\r\n    } catch (LogException le) {\r\n        return new Vector();\r\n    }\r\n    try {\r\n        LogLSN lsn = new LogLSN();\r\n        int[] recordType = new int[1];\r\n        for (; ; ) {\r\n            byte[] logRecord = logCursor.readCursor(recordType, lsn);\r\n            switch(recordType[0]) {\r\n                case LogFile.KEYPOINT_START:\r\n                    if (keypointEndFound)\r\n                        throw new LogException(null, LogException.LOG_END_OF_CURSOR, 2);\r\n                    break;\r\n                case LogFile.KEYPOINT_END:\r\n                    keypointEndFound = true;\r\n                    break;\r\n                case LogFile.NORMAL:\r\n                case LogFile.REWRITE:\r\n                    if ((recordType[0] == LogFile.NORMAL) || keypointEndFound)\r\n                        logRecords.addElement(logRecord);\r\n                    break;\r\n                default:\r\n                    break;\r\n            }\r\n        }\r\n    } catch (LogException le) {\r\n        if (le.errorCode != LogException.LOG_END_OF_CURSOR) {\r\n            return new Vector();\r\n        }\r\n    }\r\n    try {\r\n        handle.closeCursor(logCursor);\r\n    } catch (LogException le) {\r\n    }\r\n    return logRecords;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.CompositeUtil.executeWriteCommandManaged",
	"Comment": "execute a writing admincommand with the specified parameters as managed job.",
	"Method": "ActionReporter executeWriteCommandManaged(Subject subject,String command,ParameterMap parameters){\r\n    return executeCommand(subject, command, parameters, Status.BAD_REQUEST, true, true, true);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.appclient.AppClientCheckMgrImpl.getTestsListFileName",
	"Comment": "return the configuration file name for the list of tests pertinent to theconnector architecture",
	"Method": "String getTestsListFileName(){\r\n    return testsListFileName;\r\n}"
}, {
	"Path": "com.sun.jts.jta.UserTransactionImpl.setRollbackOnly",
	"Comment": "modify the transaction associated with the current thread such thatthe only possible outcome of the transaction is to roll back thetransaction.",
	"Method": "void setRollbackOnly(){\r\n    if (transactionManager == null)\r\n        init();\r\n    this.transactionManager.setRollbackOnly();\r\n}"
}, {
	"Path": "org.glassfish.internal.embedded.Server.start",
	"Comment": "starts the embedded server, opening ports, and running the startupservices.",
	"Method": "void start(){\r\n    if (glassfish != null) {\r\n        try {\r\n            if (glassfish.getStatus() != GlassFish.Status.STARTED) {\r\n                glassfish.start();\r\n            }\r\n        } catch (GlassFishException e) {\r\n            throw new LifecycleException(e);\r\n        }\r\n        logger.finer(\"GlassFish has been started\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionManagerImpl.resume",
	"Comment": "resume the transaction context association of the calling threadwith the transaction represented by the supplied transaction object.when this method returns, the calling thread is associated with thetransaction context specified.",
	"Method": "void resume(Transaction suspended){\r\n    if (getTransaction() != null)\r\n        throw new IllegalStateException();\r\n    if (suspended == null)\r\n        throw new InvalidTransactionException();\r\n    if ((suspended instanceof TransactionImpl) == false) {\r\n        throw new InvalidTransactionException();\r\n    }\r\n    Control control = ((TransactionImpl) suspended).getControl();\r\n    try {\r\n        current.resume(control);\r\n    } catch (InvalidControl ex) {\r\n        throw new InvalidTransactionException();\r\n    } catch (Exception ex) {\r\n        throw new SystemException(ex.toString());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.universal.process.ProcessUtils.getExe",
	"Comment": "look for name in the path. if it is found and if it isexecutable then return a file object pointing to it. otherwise return nu",
	"Method": "File getExe(String name){\r\n    for (String path : paths) {\r\n        File f = new File(path + \"/\" + name);\r\n        if (f.canExecute()) {\r\n            return SmartFile.sanitize(f);\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ModifiedAttributeHASession.getDeletedAttributes",
	"Comment": "return an arraylist of stringswhose elements are the names of the deleted attributes",
	"Method": "List<String> getDeletedAttributes(){\r\n    List<String> resultList = new ArrayList<String>();\r\n    for (Map.Entry<String, SessionAttributeState> entry : _attributeStates.entrySet()) {\r\n        SessionAttributeState nextAttrState = entry.getValue();\r\n        String nextAttrName = entry.getKey();\r\n        if (nextAttrState.isDeleted() && nextAttrState.isPersistent()) {\r\n            resultList.add(nextAttrName);\r\n        }\r\n    }\r\n    return resultList;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getFilterRegistrations",
	"Comment": "gets a map of the filterregistration objects corresponding to allcurrently registered filters.",
	"Method": "Map<String, ? extends FilterRegistration> getFilterRegistrations(){\r\n    return Collections.unmodifiableMap(filterRegisMap);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.LocalInstanceCommand.mkdirs",
	"Comment": "override this method if your class does not want to create directories",
	"Method": "boolean mkdirs(File f){\r\n    return f.mkdirs();\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.app.AppClientURI.check",
	"Comment": "the java element specifies the uri of a java applicationclient module, relative to the top level of the application package.",
	"Method": "Result check(Application descriptor){\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    Result result = getInitializedResult();\r\n    for (Iterator itr = descriptor.getBundleDescriptors(ApplicationClientDescriptor.class).iterator(); itr.hasNext(); ) {\r\n        ApplicationClientDescriptor acd = (ApplicationClientDescriptor) itr.next();\r\n        if (!acd.getModuleDescriptor().getArchiveUri().endsWith(\".jar\")) {\r\n            addErrorDetails(result, compName);\r\n            result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: [ {0} ] does not specify the URI [ {1} ] of an ejb-jar, relative to the top level of the application package [ {2} ], or does not end with \\\".jar\\\"\", new Object[] { acd.getName(), acd.getModuleDescriptor().getArchiveUri(), descriptor.getName() }));\r\n        }\r\n    }\r\n    if (result.getStatus() != Result.FAILED) {\r\n        addGoodDetails(result, compName);\r\n        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"All the Application URIs are valid.\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.AdminUtil.getSamplingEndTime",
	"Comment": "returns the time in millisecond , since the begining of time, when thesampling window was closed.",
	"Method": "long getSamplingEndTime(){\r\n    return lSampleEndTime;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.hasFilter",
	"Comment": "checks whether this context contains the given filter instance",
	"Method": "boolean hasFilter(Filter filter){\r\n    for (Map.Entry<String, FilterDef> e : filterDefs.entrySet()) {\r\n        if (filter == e.getValue().getFilter()) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.catalina.InstanceEvent.getException",
	"Comment": "return the exception that occurred during the processingthat was reported by this event.",
	"Method": "Throwable getException(){\r\n    return (this.exception);\r\n}"
}, {
	"Path": "org.glassfish.weld.ValidationNamingProxy.obtainBeanManager",
	"Comment": "obtain the beanmanagernamingproxy from hk2, so the beanmanager can be looked up",
	"Method": "BeanManager obtainBeanManager(){\r\n    BeanManager beanManager = null;\r\n    ComponentInvocation inv = invocationManager.getCurrentInvocation();\r\n    if (inv != null) {\r\n        JndiNameEnvironment componentEnv = compEnvManager.getJndiNameEnvironment(inv.getComponentId());\r\n        if (componentEnv != null) {\r\n            BundleDescriptor bundle = null;\r\n            if (componentEnv instanceof EjbDescriptor) {\r\n                bundle = (BundleDescriptor) ((EjbDescriptor) componentEnv).getEjbBundleDescriptor().getModuleDescriptor().getDescriptor();\r\n            } else if (componentEnv instanceof WebBundleDescriptor) {\r\n                bundle = (BundleDescriptor) componentEnv;\r\n            }\r\n            if (bundle != null) {\r\n                BeanDeploymentArchive bda = weldDeployer.getBeanDeploymentArchiveForBundle(bundle);\r\n                if (bda != null) {\r\n                    WeldBootstrap bootstrap = weldDeployer.getBootstrapForApp(bundle.getApplication());\r\n                    beanManager = bootstrap.getManager(bda);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return beanManager;\r\n}"
}, {
	"Path": "org.glassfish.faces.integration.GlassFishTldProvider.getTldListenerMap",
	"Comment": "gets a mapping from jar files to their tld resourcesthat are known to contain listener declarations.",
	"Method": "Map<URI, List<String>> getTldListenerMap(){\r\n    if (tldListenerMap == null) {\r\n        tldListenerMap = new HashMap<URI, List<String>>();\r\n        Set<Map.Entry<URI, List<String>>> entrySet = tldMap.entrySet();\r\n        for (Map.Entry<URI, List<String>> entry : entrySet) {\r\n            if (entry.getValue().contains(\"META-INF/jsf_core.tld\")) {\r\n                tldListenerMap.put(entry.getKey(), entry.getValue());\r\n                break;\r\n            }\r\n        }\r\n        tldListenerMap = Collections.unmodifiableMap(tldListenerMap);\r\n    }\r\n    return tldListenerMap;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.Configuration.setPOA",
	"Comment": "sets the identity of the poa to be used for the given types of object.",
	"Method": "void setPOA(String type,POA poa){\r\n    poas.put(type, poa);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.web.TagLibFactory.getTagLibDescriptors",
	"Comment": "this method is responsible for creating a document object from the tldfiles and then returning the array taglibdescriptor objects based on tldversion.",
	"Method": "TagLibDescriptor[] getTagLibDescriptors(WebBundleDescriptor descriptor){\r\n    ArrayList<TagLibDescriptor> tmp = new ArrayList<TagLibDescriptor>();\r\n    Iterable<TaglibDescriptor> taglibConfig = null;\r\n    if (((WebBundleDescriptorImpl) descriptor).getJspConfigDescriptor() != null) {\r\n        taglibConfig = ((WebBundleDescriptorImpl) descriptor).getJspConfigDescriptor().getTaglibs();\r\n    } else {\r\n        return null;\r\n    }\r\n    init();\r\n    for (TaglibDescriptor taglibDescriptor : taglibConfig) {\r\n        String taglibLocation = taglibDescriptor.getTaglibLocation();\r\n        Document d = null;\r\n        try {\r\n            d = createDocument(taglibLocation, descriptor);\r\n        } catch (Exception e) {\r\n            logger.log(Level.WARNING, smh.getLocalString(getClass().getName() + \".exception\", \"Continuing, though problem in creating taglib document. Cause: {0}\", new Object[] { e.getMessage() }));\r\n            if (e instanceof SAXParseException) {\r\n                LogRecord logRecord = new LogRecord(Level.SEVERE, smh.getLocalString(getClass().getName() + \".exception2\", \"XML Error line : {0} in [ {1} ]. {2}\", new Object[] { ((SAXParseException) e).getLineNumber(), taglibLocation, e.getLocalizedMessage() }));\r\n                logRecord.setThrown(e);\r\n                verifierFrameworkContext.getResultManager().log(logRecord);\r\n            }\r\n            continue;\r\n        }\r\n        String version = getTLDSpecVersion(d);\r\n        TagLibDescriptor taglib = null;\r\n        taglib = new TagLibDescriptor(d, version, taglibLocation);\r\n        tmp.add(taglib);\r\n    }\r\n    int count = tmp.size();\r\n    TagLibDescriptor[] arr = new TagLibDescriptor[count];\r\n    int i = 0;\r\n    for (Iterator e = tmp.iterator(); e.hasNext(); i++) {\r\n        arr[i] = (TagLibDescriptor) e.next();\r\n    }\r\n    return arr;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.ServerConfigLookup.getInstanceSessionManagerStoreProperties",
	"Comment": "get the store properties bean from domain.xmlreturn null if not defined or other problem",
	"Method": "StoreProperties getInstanceSessionManagerStoreProperties(){\r\n    SessionManager smBean = getInstanceSessionManager();\r\n    if (smBean == null) {\r\n        return null;\r\n    }\r\n    return smBean.getStoreProperties();\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.ServerSynchronizer.getConfigFileNames",
	"Comment": "return the names of the config files we need to consider.names are all relative to the config directory.",
	"Method": "Set<String> getConfigFileNames(){\r\n    Set<String> files = new LinkedHashSet<String>();\r\n    BufferedReader in = null;\r\n    try {\r\n        File configDir = env.getConfigDirPath();\r\n        File f = new File(configDir, \"config-files\");\r\n        if (f.exists())\r\n            in = new BufferedReader(new InputStreamReader(new FileInputStream(f)));\r\n        else {\r\n            InputStream res = getClass().getResourceAsStream(\"/META-INF/config-files\");\r\n            if (res != null)\r\n                in = new BufferedReader(new InputStreamReader(res));\r\n            else\r\n                logger.severe(\"ServerSynchronizer: can't find list of \" + \"config files to synchronize!\");\r\n        }\r\n        String line;\r\n        if (in != null) {\r\n            while ((line = in.readLine()) != null) {\r\n                if (line.startsWith(\"#\"))\r\n                    continue;\r\n                line = line.trim();\r\n                if (line.length() == 0)\r\n                    continue;\r\n                files.add(line);\r\n            }\r\n        }\r\n    } catch (IOException ex) {\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.fine(\"ServerSynchronizer: IOException in getConfigFileNames\");\r\n            logger.fine(ex.toString());\r\n        }\r\n    } finally {\r\n        try {\r\n            if (in != null)\r\n                in.close();\r\n        } catch (IOException cex) {\r\n        }\r\n    }\r\n    return files;\r\n}"
}, {
	"Path": "org.glassfish.server.ServerEnvironmentImpl.getApplicationCompileJspPath",
	"Comment": "returns the path for compiled jsp pages from an applicationthat is deployed on this instance. by default all such compiled jspsshould lie in the same folder.",
	"Method": "File getApplicationCompileJspPath(){\r\n    return new File(getApplicationStubPath(), kCompileJspDirName);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RegisteredStatics.removeStatic",
	"Comment": "removes the given staticresource object from the set of thoseinformed of thread association changes.",
	"Method": "boolean removeStatic(StaticResource obj){\r\n    boolean result = registered.removeElement(obj);\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationDispatcherForward.custom",
	"Comment": "handles an http status code or exception by forwarding controlto the location included in the specified errorpage object.",
	"Method": "void custom(HttpServletRequest request,HttpServletResponse response,ErrorPage errorPage,Context context){\r\n    try {\r\n        if (response.isCommitted()) {\r\n            RequestFacadeHelper reqFacHelper = RequestFacadeHelper.getInstance(request);\r\n            if (reqFacHelper != null) {\r\n                reqFacHelper.resetResponse();\r\n            }\r\n        }\r\n        ServletContext servletContext = context.getServletContext();\r\n        ApplicationDispatcher dispatcher = (ApplicationDispatcher) servletContext.getRequestDispatcher(errorPage.getLocation());\r\n        dispatcher.dispatch(request, response, DispatcherType.ERROR);\r\n    } catch (IllegalStateException ise) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.EXCEPTION_PROCESSING), errorPage);\r\n        log.log(Level.WARNING, msg, ise);\r\n    } catch (Throwable t) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.EXCEPTION_PROCESSING), errorPage);\r\n        log.log(Level.WARNING, msg, t);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deploy.shared.FileArchive.getURI",
	"Comment": "returns the uri used to create or open the underlyong archive",
	"Method": "URI getURI(){\r\n    return uri;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.ControlImpl.getLocalTID",
	"Comment": "returns the identifier that locally represents the transaction, and a valuethat indicates the state of the transaction.if the transaction represented by the control object has been completed,the identifier is still returned if possible.",
	"Method": "long getLocalTID(StatusHolder status){\r\n    long result = 0;\r\n    if (status != null)\r\n        status.value = tranState;\r\n    if (localTID == null) {\r\n        INTERNAL exc = new INTERNAL(MinorCode.NoGlobalTID, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    } else {\r\n        result = localTID.longValue();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.util.StringUtils.quotePathIfNecessary",
	"Comment": "nightmares can result from using a path with a space in it!this method will enclose in the specified quote characters if needed.",
	"Method": "String quotePathIfNecessary(String path,String quotePathIfNecessary,String path,char quoteChar){\r\n    if (!ok(path) || !needsQuoting(path) || isDoubleQuoted(path) || isSingleQuoted(path))\r\n        return path;\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(quoteChar);\r\n    sb.append(path);\r\n    sb.append(quoteChar);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ValveBase.setContainer",
	"Comment": "set the container with which this valve is associated, if any.",
	"Method": "void setContainer(Container container){\r\n    this.container = container;\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.JavaEETransactionImpl.getTransactionId",
	"Comment": "this method is used for the admin framework displayingof transactions ids",
	"Method": "String getTransactionId(){\r\n    return xid.toString();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorLog.createSection",
	"Comment": "creates a subsection in the coordinatorlog in which to store relatedobjects and data.the object that is returned is used to identify the section on subsequentcalls.if the section has already been created, the object for the existingsection is returned.",
	"Method": "java.lang.Object createSection(String sectionName){\r\n    CoordinatorLogSection result = null;\r\n    result = (CoordinatorLogSection) sectionMapping.get(sectionName);\r\n    if (result == null) {\r\n        result = SectionPool.getCoordinatorLogSection(sectionName);\r\n        sectionMapping.put(sectionName, result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.getCurrentElementName",
	"Comment": "return the name of the xml element that is currently being processed.",
	"Method": "String getCurrentElementName(){\r\n    String elementName = match;\r\n    int lastSlash = elementName.lastIndexOf('/');\r\n    if (lastSlash >= 0) {\r\n        elementName = elementName.substring(lastSlash + 1);\r\n    }\r\n    return (elementName);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteRestAdminCommand.headers",
	"Comment": "return a modifiable list of headers to be added to the request.",
	"Method": "List<Header> headers(){\r\n    return requestHeaders;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.UserDataConstraintImpl.setTransportGuarantee",
	"Comment": "sets my transport type to the given value. throws an illegal argument exception if the value is not allowed.",
	"Method": "void setTransportGuarantee(String transportGuarantee){\r\n    if (this.isBoundsChecking()) {\r\n        if (!UserDataConstraint.NONE_TRANSPORT.equals(transportGuarantee) && !UserDataConstraint.INTEGRAL_TRANSPORT.equals(transportGuarantee) && !UserDataConstraint.CONFIDENTIAL_TRANSPORT.equals(transportGuarantee)) {\r\n            throw new IllegalArgumentException(localStrings.getLocalString(\"web.deployment.exceptiontransportguarentee\", \"{0} is not a valid transport guarantee\", new Object[] { transportGuarantee }));\r\n        }\r\n    }\r\n    this.transportGuarantee = transportGuarantee;\r\n}"
}, {
	"Path": "org.apache.catalina.util.LifecycleSupport.removeLifecycleListeners",
	"Comment": "removes any lifecycle event listeners from this lifecyclesupportinstance.",
	"Method": "void removeLifecycleListeners(){\r\n    listeners.clear();\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.createSAXException",
	"Comment": "create a sax exception which also understands about the location inthe digester file where the exception occurs",
	"Method": "SAXException createSAXException(String message,Exception e,SAXException createSAXException,Exception e,SAXException createSAXException,String message){\r\n    return createSAXException(message, null);\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.core.proxy.AMXProxyHandler.childrenSet",
	"Comment": "returns an array of children, including an empty array if there are none, but childrenare possible.returns null if children are not possible.",
	"Method": "Set<AMXProxy> childrenSet(Set<AMXProxy> childrenSet,ObjectName[] objectNames,Set<T> childrenSet,String type,Class<T> intf){\r\n    final Map<String, T> m = childrenMap(type, intf);\r\n    return new HashSet<T>(m.values());\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.setConfig",
	"Comment": "reconfigures this virtualserver with the givenconfiguration.in order for the given configuration to take effect, thisvirtualserver may be stopped and restarted.",
	"Method": "void setConfig(VirtualServerConfig config){\r\n    this.config = config;\r\n    configureSingleSignOn(config.isSsoEnabled(), Globals.getDefaultHabitat().<PEWebContainerFeatureFactoryImpl>getService(PEWebContainerFeatureFactoryImpl.class), false);\r\n    if (config.isAccessLoggingEnabled()) {\r\n        enableAccessLogging();\r\n    } else {\r\n        disableAccessLogging();\r\n    }\r\n    setDefaultWebXmlLocation(config.getDefaultWebXml());\r\n    setDefaultContextXmlLocation(config.getContextXmlDefault());\r\n    setAllowLinking(config.isAllowLinking());\r\n    configureRemoteAddressFilterValve(config.getAllowRemoteAddress(), config.getDenyRemoteAddress());\r\n    configureRemoteHostFilterValve(config.getAllowRemoteHost(), config.getAllowRemoteHost());\r\n    configureAliases(config.getHostNames());\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.JavaEETransactionManagerSimplified.forceRollback",
	"Comment": "called by admin framework when transaction monitoring is enabled",
	"Method": "void forceRollback(String txnId){\r\n    if (txnTable == null || txnTable.size() == 0)\r\n        getActiveTransactions();\r\n    if (txnTable == null || txnTable.get(txnId) == null) {\r\n        String result = sm.getString(\"transaction.monitor.rollback_invalid_id\");\r\n        throw new IllegalStateException(result);\r\n    } else {\r\n        if (_logger.isLoggable(Level.FINE))\r\n            _logger.log(Level.FINE, \"TM: Marking txnId \" + txnId + \" for rollback\");\r\n        ((Transaction) txnTable.get(txnId)).setRollbackOnly();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.webservices.WebServicesDeployer.prepare",
	"Comment": "prepares the application bits for running in the application server.for certain cases, this is exploding the jar file to a format thecontractprovider instance is expecting, generating non portableartifacts and other application specific tasks.failure to prepare should throw an exception which will cause the overalldeployment to fail.",
	"Method": "boolean prepare(DeploymentContext dc){\r\n    try {\r\n        Application app = dc.getModuleMetaData(Application.class);\r\n        if (app == null) {\r\n            logger.log(Level.SEVERE, LogUtils.FAILED_LOADING_DD);\r\n            return false;\r\n        }\r\n        BundleDescriptor bundle = DOLUtils.getCurrentBundleForContext(dc);\r\n        String moduleCP = getModuleClassPath(dc);\r\n        final List<URL> moduleCPUrls = ASClassLoaderUtil.getURLsFromClasspath(moduleCP, File.pathSeparator, null);\r\n        final ClassLoader oldCl = Thread.currentThread().getContextClassLoader();\r\n        URLClassLoader newCl = AccessController.doPrivileged(new PrivilegedAction<URLClassLoader>() {\r\n            @Override\r\n            public URLClassLoader run() {\r\n                return new URLClassLoader(ASClassLoaderUtil.convertURLListToArray(moduleCPUrls), oldCl);\r\n            }\r\n        });\r\n        Thread.currentThread().setContextClassLoader(newCl);\r\n        WebServicesDescriptor wsDesc = bundle.getWebServices();\r\n        for (WebService ws : wsDesc.getWebServices()) {\r\n            if ((new WsUtil()).isJAXWSbasedService(ws)) {\r\n                setupJaxWSServiceForDeployment(dc, ws);\r\n            } else {\r\n                JAXRPCCodeGenFacade facade = habitat.getService(JAXRPCCodeGenFacade.class);\r\n                if (facade != null) {\r\n                    facade.run(habitat, dc, moduleCP, false);\r\n                } else {\r\n                    throw new DeploymentException(rb.getString(LogUtils.JAXRPC_CODEGEN_FAIL));\r\n                }\r\n            }\r\n        }\r\n        doWebServicesDeployment(app, dc);\r\n        Thread.currentThread().setContextClassLoader(oldCl);\r\n        WebServicesContainer container = habitat.getService(WebServicesContainer.class);\r\n        WebServicesDeploymentMBean bean = container.getDeploymentBean();\r\n        WebServiceDeploymentNotifier notifier = getDeploymentNotifier();\r\n        bean.deploy(wsDesc, notifier);\r\n        return true;\r\n    } catch (Exception ex) {\r\n        RuntimeException re = new RuntimeException(ex.getMessage());\r\n        re.initCause(ex);\r\n        throw re;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.webservices.WebServicesDeployer.prepare",
	"Comment": "prepares the application bits for running in the application server.for certain cases, this is exploding the jar file to a format thecontractprovider instance is expecting, generating non portableartifacts and other application specific tasks.failure to prepare should throw an exception which will cause the overalldeployment to fail.",
	"Method": "boolean prepare(DeploymentContext dc){\r\n    return new URLClassLoader(ASClassLoaderUtil.convertURLListToArray(moduleCPUrls), oldCl);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TransactionFactoryImpl.recreate",
	"Comment": "creates the coordinator, control and terminator objectsfor a transaction based on the xid object passed in.",
	"Method": "Control recreate(PropagationContext context,Control recreate,GlobalTID tid,int timeout){\r\n    if (!active) {\r\n        NO_PERMISSION exc = new NO_PERMISSION(0, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    CoordinatorImpl subordinate = RecoveryManager.getCoordinator(tid);\r\n    Control result = null;\r\n    if (subordinate == null) {\r\n        RecoveryManager.waitForResync();\r\n        subordinate = RecoveryManager.getCoordinator(tid);\r\n    }\r\n    try {\r\n        if (subordinate == null) {\r\n            subordinate = new TopCoordinator(timeout, tid, new TxInflowCoordinator(), true);\r\n        } else {\r\n            Status status = subordinate.get_status();\r\n            if ((status != Status.StatusMarkedRollback) && (status != Status.StatusActive)) {\r\n                throw new INVALID_TRANSACTION(\"tx completion in-progress\");\r\n            }\r\n            subordinate.setPermanent();\r\n        }\r\n        if (Configuration.isLocalFactory()) {\r\n            result = (Control) new ControlImpl(null, subordinate, tid, subordinate.getLocalTID());\r\n        } else {\r\n            result = new ControlImpl(null, subordinate, tid, subordinate.getLocalTID()).object();\r\n        }\r\n    } catch (Throwable exc) {\r\n        _logger.log(Level.WARNING, \"jts.unable_to_create_subordinate_coordinator\");\r\n        String msg = LogFormatter.getLocalizedMessage(_logger, \"jts.unable_to_create_subordinate_coordinator\");\r\n        INTERNAL intExc = new INTERNAL(msg);\r\n        intExc.initCause(exc);\r\n        throw intExc;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.server.DynamicReloadService.reschedule",
	"Comment": "reschedules the autodeployer because a configuration change has alteredthe frequency.",
	"Method": "void reschedule(int pollIntervalInSeconds){\r\n    logger.fine(\"[Reloader] Restarting...\");\r\n    stop();\r\n    try {\r\n        reloader.waitUntilIdle();\r\n    } catch (InterruptedException e) {\r\n    }\r\n    start(pollIntervalInSeconds);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getRequestURL",
	"Comment": "reconstructs the url the client used to make the request.the returned url contains a protocol, server name, portnumber, and server path, but it does not include querystring parameters.because this method returns a stringbuffer,not a string, you can modify the url easily,for example, to append query parameters.this method is useful for creating redirect messages andfor reporting errors.",
	"Method": "StringBuffer getRequestURL(StringBuffer getRequestURL,boolean maskDefaultContextMapping){\r\n    StringBuffer url = new StringBuffer();\r\n    String scheme = getScheme();\r\n    int port = getServerPort();\r\n    if (port < 0) {\r\n        port = 80;\r\n    }\r\n    url.append(scheme);\r\n    url.append(\"://\");\r\n    url.append(getServerName());\r\n    if (scheme.equals(\"http\") && port != 80 || scheme.equals(\"https\") && port != 443) {\r\n        url.append(':');\r\n        url.append(port);\r\n    }\r\n    url.append(getRequestURI(maskDefaultContextMapping));\r\n    return url;\r\n}"
}, {
	"Path": "org.apache.catalina.util.Enumerator.nextElement",
	"Comment": "returns the next element of this enumeration if this enumerationhas at least one more element to provide.",
	"Method": "T nextElement(){\r\n    return iterator.next();\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.config.ConfigBeanJMXSupportRegistry.getAllConfigBeanProxyInterfaces",
	"Comment": "find allconfigbeanproxy interfacesreachable from specified item, including the item itself",
	"Method": "Set<Class<? extends ConfigBeanProxy>> getAllConfigBeanProxyInterfaces(ConfigBeanJMXSupport top){\r\n    final Set<Class<? extends ConfigBeanProxy>> all = new HashSet<Class<? extends ConfigBeanProxy>>();\r\n    all.add(top.getIntf());\r\n    for (final Class<? extends ConfigBeanProxy> intf : top.childTypes().values()) {\r\n        all.addAll(getAllConfigBeanProxyInterfaces(getInstance(intf)));\r\n    }\r\n    return all;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.setServletClassName",
	"Comment": "set the fully qualified servlet class name for this servlet.",
	"Method": "void setServletClassName(String className){\r\n    if (className == null) {\r\n        throw new NullPointerException(\"Null servlet class name\");\r\n    }\r\n    if (servletClassName != null) {\r\n        throw new IllegalStateException(\"Wrapper already initialized with servlet instance, \" + \"class, or name\");\r\n    }\r\n    servletClassName = className;\r\n    support.firePropertyChange(\"servletClassName\", null, servletClassName);\r\n    if (Constants.JSP_SERVLET_CLASS.equals(servletClassName)) {\r\n        isJspServlet = true;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.ConnectionRequestInfoImplHashcode.check",
	"Comment": "test wether the implementatin of the connectionrequestinfo interfaceproperly overrides the hashcode method.",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    Class c = findImplementorOf(descriptor, \"javax.resource.spi.ConnectionRequestInfo\");\r\n    if (c == null) {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.ConnectorTest.optionalInterfaceMissing\", \"Warning: There is no implementation of the optional [ {0} ] interface\", new Object[] { \"javax.resource.spi.ConnectionRequestInfo\" }));\r\n    } else {\r\n        checkMethodImpl(c, \"hashCode\", null, \"public int hashCode()\", result);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationDispatcherForward.status",
	"Comment": "searches and processes a custom error page for the given status code.this method attempts to map the given status code to an error page,using the mappings of the given context or those of the host on whichthe given context has been deployed.if a match is found using the context mappings, the request is forwardedto the error page. otherwise, if a match is found using the host mappings, the contents of the error page are returned. if no match isfound, no action is taken.",
	"Method": "boolean status(HttpServletRequest request,HttpServletResponse response,Context context,Wrapper wrapper,int statusCode){\r\n    RequestFacadeHelper reqFacHelper = RequestFacadeHelper.getInstance(request);\r\n    if (reqFacHelper == null || !reqFacHelper.isResponseError()) {\r\n        return false;\r\n    }\r\n    boolean matchFound = false;\r\n    ErrorPage errorPage = context.findErrorPage(statusCode);\r\n    if (errorPage != null) {\r\n        matchFound = true;\r\n        String requestPath = (String) request.getAttribute(Globals.DISPATCHER_REQUEST_PATH_ATTR);\r\n        if (requestPath == null || !requestPath.equals(errorPage.getLocation())) {\r\n            String message = reqFacHelper.getResponseMessage();\r\n            if (message == null) {\r\n                message = \"\";\r\n            } else {\r\n                message = HtmlEntityEncoder.encodeXSS(message);\r\n            }\r\n            prepareRequestForDispatch(request, wrapper, errorPage.getLocation(), statusCode, message);\r\n            custom(request, response, errorPage, context);\r\n        }\r\n    } else {\r\n        errorPage = ((StandardHost) context.getParent()).findErrorPage(statusCode);\r\n        if (errorPage != null) {\r\n            matchFound = true;\r\n            try {\r\n                serveErrorPage(response, errorPage, statusCode);\r\n            } catch (Exception e) {\r\n                String msg = MessageFormat.format(rb.getString(LogFacade.EXCEPTION_PROCESSING), errorPage);\r\n                log.log(Level.WARNING, msg, e);\r\n            }\r\n        }\r\n    }\r\n    return matchFound;\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.MultipartStream.getHeaderEncoding",
	"Comment": "retrieves the character encoding used when reading the headers of anindividual part. when not specified, or null, the platformdefault encoding is used.",
	"Method": "String getHeaderEncoding(){\r\n    return headerEncoding;\r\n}"
}, {
	"Path": "org.apache.catalina.session.PersistentManagerBase.setMaxIdleSwap",
	"Comment": "sets the time in seconds after which a session should be swapped out ofmemory to disk.",
	"Method": "void setMaxIdleSwap(int max){\r\n    if (max == this.maxIdleSwap)\r\n        return;\r\n    int oldMaxIdleSwap = this.maxIdleSwap;\r\n    this.maxIdleSwap = max;\r\n    support.firePropertyChange(\"maxIdleSwap\", Integer.valueOf(oldMaxIdleSwap), Integer.valueOf(this.maxIdleSwap));\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.setWebListeners",
	"Comment": "sets the collection of weblistener instances from whichthis virtualserver receives requests.",
	"Method": "void setWebListeners(WebListener webListeners){\r\n    if (webListeners != null) {\r\n        listeners = Arrays.asList(webListeners);\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.ArrayStack.empty",
	"Comment": "return true if this stack is currently empty.this method exists for compatibility with java.util.stack.new users of this class should use isempty instead.",
	"Method": "boolean empty(){\r\n    return isEmpty();\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.wsclient.WebServiceClientCheckMgrImpl.getTestsListFileName",
	"Comment": "return the configuration file name for the list of tests pertinent to theconnector architecture",
	"Method": "String getTestsListFileName(){\r\n    return testsListFileName;\r\n}"
}, {
	"Path": "testmbeans.ImplementsMBeanRegistration.setAttribute",
	"Comment": "sets the value of the specified attribute of the dynamicmbean.",
	"Method": "void setAttribute(Attribute attribute){\r\n    if (attribute.getName().equals(\"Name\")) {\r\n    } else\r\n        throw new AttributeNotFoundException(\"Unknown Attribute \" + attribute.getName());\r\n}"
}, {
	"Path": "org.apache.catalina.util.HexUtils.convert",
	"Comment": "convert a string of hexadecimal digits into the correspondingbyte array by encoding each two hexadecimal digits as a byte.",
	"Method": "byte[] convert(String digits,char[] convert,byte bytes){\r\n    char[] arr = new char[bytes.length * 2];\r\n    for (int i = 0; i < bytes.length; i++) {\r\n        arr[2 * i] = convertDigit((int) (bytes[i] >> 4));\r\n        arr[2 * i + 1] = convertDigit((int) (bytes[i] & 0x0f));\r\n    }\r\n    return arr;\r\n}"
}, {
	"Path": "org.apache.catalina.util.StringParser.findChar",
	"Comment": "return the index of the next occurrence of the specified character,or the index of the character after the last position of the stringif no more occurrences of this character are found.the currentparsing position is updated to the returned value.",
	"Method": "int findChar(char ch){\r\n    while ((index < length) && (ch != chars[index])) index++;\r\n    return (index);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.messagebean.MessageBeanTest.check",
	"Comment": "run a verifier test against an individual declared messagedrive bean component",
	"Method": "Result check(EjbMessageBeanDescriptor descriptor,Result check,EjbDescriptor descriptor){\r\n    if (descriptor instanceof EjbMessageBeanDescriptor) {\r\n        return check((EjbMessageBeanDescriptor) descriptor);\r\n    } else {\r\n        Result result = getInitializedResult();\r\n        compName = getVerifierContext().getComponentNameConstructor();\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.messagebean.MessageBeanTest.notApplicable\", \"Test apply only to message-driven Bean components\"));\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.removeAttribute",
	"Comment": "remove the context attribute with the specified name, if any.",
	"Method": "void removeAttribute(String name){\r\n    Object value = null;\r\n    boolean found = false;\r\n    synchronized (attributesLock) {\r\n        if (readOnlyAttributes.containsKey(name))\r\n            return;\r\n        value = attributes.remove(name);\r\n        if (value == null)\r\n            return;\r\n    }\r\n    List<EventListener> listeners = context.getApplicationEventListeners();\r\n    if (listeners.isEmpty()) {\r\n        return;\r\n    }\r\n    ServletContextAttributeEvent event = new ServletContextAttributeEvent(context.getServletContext(), name, value);\r\n    Iterator<EventListener> iter = listeners.iterator();\r\n    while (iter.hasNext()) {\r\n        EventListener eventListener = iter.next();\r\n        if (!(eventListener instanceof ServletContextAttributeListener)) {\r\n            continue;\r\n        }\r\n        ServletContextAttributeListener listener = (ServletContextAttributeListener) eventListener;\r\n        try {\r\n            context.fireContainerEvent(ContainerEvent.BEFORE_CONTEXT_ATTRIBUTE_REMOVED, listener);\r\n            listener.attributeRemoved(event);\r\n            context.fireContainerEvent(ContainerEvent.AFTER_CONTEXT_ATTRIBUTE_REMOVED, listener);\r\n        } catch (Throwable t) {\r\n            context.fireContainerEvent(ContainerEvent.AFTER_CONTEXT_ATTRIBUTE_REMOVED, listener);\r\n            log.log(Level.WARNING, LogFacade.ATTRIBUTES_EVENT_LISTENER_EXCEPTION, t);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.appserv.web.taglibs.cache.CacheTag.doEndTag",
	"Comment": "doendtag just resets all the valiables in case the tag is reused",
	"Method": "int doEndTag(){\r\n    _key = null;\r\n    _keyExpr = null;\r\n    _timeout = Constants.DEFAULT_JSP_CACHE_TIMEOUT;\r\n    _refreshCache = false;\r\n    _useCachedResponse = true;\r\n    _scope = PageContext.APPLICATION_SCOPE;\r\n    _cache = null;\r\n    return EVAL_PAGE;\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardManager.readSessions",
	"Comment": "reads any sessions from the given input stream, and initializes thecache of active sessions with them.",
	"Method": "void readSessions(InputStream is){\r\n    sessions.clear();\r\n    ObjectInputStream ois = null;\r\n    try {\r\n        BufferedInputStream bis = new BufferedInputStream(is);\r\n        if (container != null) {\r\n            ois = ((StandardContext) container).createObjectInputStream(bis);\r\n        } else {\r\n            ois = new ObjectInputStream(bis);\r\n        }\r\n    } catch (IOException ioe) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.LOADING_PERSISTED_SESSION_IO_EXCEPTION), ioe);\r\n        log.log(Level.SEVERE, msg, ioe);\r\n        if (ois != null) {\r\n            try {\r\n                ois.close();\r\n            } catch (IOException f) {\r\n            }\r\n            ois = null;\r\n        }\r\n        throw ioe;\r\n    }\r\n    synchronized (sessions) {\r\n        try {\r\n            Integer count = (Integer) ois.readObject();\r\n            int n = count.intValue();\r\n            if (log.isLoggable(Level.FINE))\r\n                log.log(Level.FINE, \"Loading \" + n + \" persisted sessions\");\r\n            for (int i = 0; i < n; i++) {\r\n                StandardSession session = StandardSession.deserialize(ois, this);\r\n                session.setManager(this);\r\n                sessions.put(session.getIdInternal(), session);\r\n                session.activate();\r\n            }\r\n        } catch (ClassNotFoundException e) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.CLASS_NOT_FOUND_EXCEPTION), e);\r\n            log.log(Level.SEVERE, msg, e);\r\n            if (ois != null) {\r\n                try {\r\n                    ois.close();\r\n                } catch (IOException f) {\r\n                }\r\n                ois = null;\r\n            }\r\n            throw e;\r\n        } catch (IOException e) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.LOADING_PERSISTED_SESSION_IO_EXCEPTION), e);\r\n            log.log(Level.SEVERE, msg, e);\r\n            if (ois != null) {\r\n                try {\r\n                    ois.close();\r\n                } catch (IOException f) {\r\n                }\r\n                ois = null;\r\n            }\r\n            throw e;\r\n        } finally {\r\n            try {\r\n                if (ois != null) {\r\n                    ois.close();\r\n                }\r\n            } catch (IOException f) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.homeintf.remotehomeintf.RemoteHomeInterfaceRmiIIOPException.runIndividualHomeMethodTest",
	"Comment": "run an individual verifier test against a declared method of the remote interface.",
	"Method": "void runIndividualHomeMethodTest(Method method,EjbDescriptor descriptor,Result result){\r\n    Class[] methodExceptionTypes = method.getExceptionTypes();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (RmiIIOPUtils.isValidRmiIIOPException(methodExceptionTypes)) {\r\n        addGoodDetails(result, compName);\r\n        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"[ {0} ] method properly throws java.rmi.RemoteException.\", new Object[] { method.getName() }));\r\n    } else {\r\n        addErrorDetails(result, compName);\r\n        result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: [ {0} ] method was found, but does not properly throw \" + \"java.rmi.RemoteException.\", new Object[] { method.getName() }));\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.RepositoryManager.changePasswordAliasKeystorePassword",
	"Comment": "change the password protecting the password alias keystore",
	"Method": "void changePasswordAliasKeystorePassword(RepositoryConfig config,String oldPassword,String newPassword){\r\n    final PEFileLayout layout = getFileLayout(config);\r\n    final File passwordAliases = layout.getPasswordAliasKeystore();\r\n    if (passwordAliases.exists()) {\r\n        try {\r\n            PasswordAdapter p = new PasswordAdapter(passwordAliases.getAbsolutePath(), oldPassword.toCharArray());\r\n            p.changePassword(newPassword.toCharArray());\r\n        } catch (Exception ex) {\r\n            throw new RepositoryException(_strMgr.getString(\"passwordAliasPasswordNotChanged\", passwordAliases), ex);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.api.admin.AdminCommandLock.getLock",
	"Comment": "return the appropriate lock object for the specified command.the returned lock has been locked.if this command needsno lock, null is returned.",
	"Method": "Lock getLock(CommandLock.LockType type,Lock getLock,AdminCommand command,Lock getLock,AdminCommand command,String owner){\r\n    Lock lock = null;\r\n    boolean exclusive = false;\r\n    int timeout = 30;\r\n    CommandLock alock = command.getClass().getAnnotation(CommandLock.class);\r\n    if (alock == null || alock.value() == CommandLock.LockType.SHARED)\r\n        lock = rwlock.readLock();\r\n    else if (alock.value() == CommandLock.LockType.EXCLUSIVE) {\r\n        lock = rwlock.writeLock();\r\n        exclusive = true;\r\n    }\r\n    if (lock == null)\r\n        return null;\r\n    if (suspendCommandsLockThread != null && suspendCommandsLockThread.isAlive()) {\r\n        timeout = -1;\r\n    } else {\r\n        boolean badTimeOutValue = false;\r\n        String timeout_s = System.getProperty(\"com.sun.aas.commandLockTimeOut\", \"30\");\r\n        try {\r\n            timeout = Integer.parseInt(timeout_s);\r\n            if (timeout < 0)\r\n                badTimeOutValue = true;\r\n        } catch (NumberFormatException e) {\r\n            badTimeOutValue = true;\r\n        }\r\n        if (badTimeOutValue) {\r\n            logger.log(Level.INFO, \"Bad value com.sun.aas.commandLockTimeOut: \" + timeout_s + \". Using 30 seconds.\");\r\n            timeout = 30;\r\n        }\r\n    }\r\n    boolean lockAcquired = false;\r\n    while (!lockAcquired) {\r\n        try {\r\n            if (lock.tryLock(timeout, TimeUnit.SECONDS)) {\r\n                lockAcquired = true;\r\n            } else {\r\n                if (timeout >= 0)\r\n                    throw new AdminCommandLockTimeoutException(\"timeout acquiring lock\", getLockTimeOfAcquisition(), getLockOwner());\r\n                else\r\n                    throw new AdminCommandLockException(getLockMessage(), getLockTimeOfAcquisition(), getLockOwner());\r\n            }\r\n        } catch (java.lang.InterruptedException e) {\r\n            logger.log(Level.FINE, \"Interrupted acquiring command lock. \", e);\r\n        }\r\n    }\r\n    if (lockAcquired && exclusive) {\r\n        setLockOwner(owner);\r\n        setLockTimeOfAcquisition(new Date());\r\n    }\r\n    return lock;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Response.recycle",
	"Comment": "release all object references, and initialize instance variables, inpreparation for reuse of this object.",
	"Method": "void recycle(){\r\n    if (request != null && request.isAsyncStarted()) {\r\n        return;\r\n    }\r\n    context = null;\r\n    outputBuffer.recycle();\r\n    usingOutputStream = false;\r\n    usingWriter = false;\r\n    appCommitted = false;\r\n    included = false;\r\n    error = false;\r\n    isContentTypeSet = false;\r\n    isCharacterEncodingSet = false;\r\n    detailErrorMsg = null;\r\n    if (enforceScope) {\r\n        if (facade != null) {\r\n            facade.clear();\r\n            facade = null;\r\n        }\r\n        if (outputStream != null) {\r\n            outputStream.clear();\r\n            outputStream = null;\r\n        }\r\n        if (writer != null) {\r\n            writer.clear();\r\n            writer = null;\r\n        }\r\n    } else {\r\n        writer.recycle();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ReplicationStore.removeSynchronized",
	"Comment": "remove the session with the specified session identifier from this store, if present.if no such session is present, this method takes no action.",
	"Method": "void removeSynchronized(String id){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"ReplicationStore>>removeSynchronized\");\r\n    }\r\n    BackingStore<String, ? extends Storeable> replicator = getStoreableBackingStore();\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"ReplicationStore>>removeSynchronized: replicator: \" + replicator);\r\n    }\r\n    try {\r\n        replicator.remove(id);\r\n    } catch (BackingStoreException ex) {\r\n        _logger.log(Level.WARNING, LogFacade.EXCEPTION_REMOVING_SYNCHRONIZED, ex);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getDefaultSessionTrackingModes",
	"Comment": "gets the session tracking modes that are supported by default for thisservletcontext.",
	"Method": "Set<SessionTrackingMode> getDefaultSessionTrackingModes(){\r\n    return EnumSet.copyOf(DEFAULT_SESSION_TRACKING_MODES);\r\n}"
}, {
	"Path": "org.apache.catalina.logger.LoggerBase.setVerbosity",
	"Comment": "set the verbosity level of this logger.messages logged with ahigher verbosity than this level will be silently ignored.",
	"Method": "void setVerbosity(int verbosity){\r\n    this.verbosity = verbosity;\r\n}"
}, {
	"Path": "samples.amx.SampleListener.getNotifsReceived",
	"Comment": "return a map, keyed by notification type, of all notifications received so far.",
	"Method": "Map getNotifsReceived(List getNotifsReceived,String type){\r\n    return ((List) mNotifs.get(type));\r\n}"
}, {
	"Path": "com.sun.jts.utils.RecoveryHooks.FailureInducer.activateFailureInducer",
	"Comment": "this activates the failureinducer. an application needs to activatethe failure inducer first, before setting the fail or wait points.",
	"Method": "void activateFailureInducer(){\r\n    failureInducerIsActive = true;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.RuleSetBase.getNamespaceURI",
	"Comment": "return the namespace uri that will be applied to all rule instancescreated from this ruleset.",
	"Method": "String getNamespaceURI(){\r\n    return (this.namespaceURI);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.ServerConfigLookup.getPersistenceTypeFromConfig",
	"Comment": "get the persistencetype from domain.xml.return null if not found",
	"Method": "PersistenceType getPersistenceTypeFromConfig(){\r\n    String persistenceTypeString = null;\r\n    PersistenceType persistenceType = null;\r\n    WebContainerAvailability webContainerAvailabilityBean = getWebContainerAvailability();\r\n    if (webContainerAvailabilityBean == null) {\r\n        return null;\r\n    }\r\n    persistenceTypeString = webContainerAvailabilityBean.getPersistenceType();\r\n    if (persistenceTypeString != null) {\r\n        persistenceType = PersistenceType.parseType(persistenceTypeString);\r\n    }\r\n    if (persistenceType != null) {\r\n        if (_logger.isLoggable(Level.FINEST)) {\r\n            _logger.log(Level.FINEST, LogFacade.PERSISTENCE_TYPE, persistenceType.getType());\r\n        }\r\n    } else {\r\n        if (_logger.isLoggable(Level.FINEST)) {\r\n            _logger.log(Level.FINEST, LogFacade.PERSISTENCE_TYPE_MISSING);\r\n        }\r\n    }\r\n    return persistenceType;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.DependentValueClassModifiers.runIndividualCmpFieldTest",
	"Comment": "run an individual verifier test of a declated cmp field of the class",
	"Method": "boolean runIndividualCmpFieldTest(Descriptor entity,Descriptor persistentField,Class c,Result result){\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    String fieldName = persistentField.getName();\r\n    String getMethodName = \"get\" + Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);\r\n    Method getMethod = getMethod(c, getMethodName, null);\r\n    if (getMethod != null) {\r\n        Class returnType = getMethod.getReturnType();\r\n        if (returnType.isArray()) {\r\n            returnType = returnType.getComponentType();\r\n        }\r\n        if (returnType.isPrimitive()) {\r\n            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.addGoodDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CMPTest.DependentValueClassModifiers.notApplicable\", \"Field [ {0} ] is not a dependent value class reference\", new Object[] { fieldName }));\r\n            return true;\r\n        }\r\n        if (returnType.isInterface()) {\r\n            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.addGoodDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CMPTest.DependentValueClassModifiers.notApplicable\", \"Field [ {0} ] is not a dependent value class reference\", new Object[] { fieldName }));\r\n            return true;\r\n        }\r\n        if (returnType.toString().startsWith(\"class java.\")) {\r\n            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.addGoodDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CMPTest.DependentValueClassModifiers.notApplicable\", \"Field [ {0} ] is not a dependent value class reference\", new Object[] { fieldName }));\r\n            return true;\r\n        }\r\n        EjbBundleDescriptorImpl bundle = ((EjbDescriptor) entity).getEjbBundleDescriptor();\r\n        if ((isValidInterface(returnType, bundle.getEjbs(), MethodDescriptor.EJB_REMOTE)) || (isValidInterface(returnType, bundle.getEjbs(), MethodDescriptor.EJB_LOCAL))) {\r\n            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.addGoodDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CMPTest.DependentValueClassModifiers.notApplicable\", \"Field [ {0} ] is not a dependent value class reference\", new Object[] { fieldName }));\r\n            return true;\r\n        }\r\n        int modifiers = returnType.getModifiers();\r\n        if (Modifier.isPublic(modifiers) && Modifier.isAbstract(modifiers) == false && EjbUtils.isValidSerializableType(returnType)) {\r\n            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.addGoodDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CMPTest.DependentValueClassModifiers.passed\", \"Dependent value class [ {0} ] reference by cmp field [ {1} ] is public, not abstract and serializable\", new Object[] { returnType.getName(), fieldName }));\r\n            return true;\r\n        } else {\r\n            result.addWarningDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.addWarningDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CMPTest.DependentValueClassModifiers.failed\", \"Verifier cannot find out if [ {0} ] is a Dependent value class (reference by cmp field [ {1} ]) \", new Object[] { returnType.getName(), fieldName }));\r\n            return false;\r\n        }\r\n    } else {\r\n        result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.addErrorDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CMPTest.isAccessorDeclared.failed2\", \"Error : Cannot find accessor [ {0} ] method for [ {1} ] field \", new Object[] { getMethodName, fieldName }));\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.CreateProfilerTest.getFileName",
	"Comment": "returns the domaintest file name without the .xml extension to load the test configurationfrom.",
	"Method": "String getFileName(){\r\n    return \"DomainTest\";\r\n}"
}, {
	"Path": "com.sun.enterprise.glassfish.bootstrap.osgi.BundleProvisioner.initCurrentManagedBundles",
	"Comment": "this method goes through all the currently installed bundlesand returns information about those bundles whose locationrefers to locations as we have been configured to manage.",
	"Method": "void initCurrentManagedBundles(){\r\n    Bundle[] bundles = getBundleContext().getBundles();\r\n    for (Bundle bundle : bundles) {\r\n        try {\r\n            final long id = bundle.getBundleId();\r\n            if (id == 0) {\r\n                continue;\r\n            }\r\n            Jar jar = new Jar(bundle);\r\n            if (customizer.isManaged(jar)) {\r\n                addBundle(jar);\r\n            }\r\n        } catch (URISyntaxException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModuleConfig.setDescriptor",
	"Comment": "set the deployment descriptor object describing the contents of theweb application.",
	"Method": "void setDescriptor(WebBundleDescriptorImpl wbd){\r\n    _wbd = wbd;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.addApplicationListener",
	"Comment": "adds the listener with the given class name that is declared in thedeployment descriptor to the set of listeners configured for thisapplication.",
	"Method": "void addApplicationListener(String listener){\r\n    addListener(listener, false);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteAdminCommand.followRedirection",
	"Comment": "creates a new httpconnectoraddress corresponding to the location to whichan earlier request was redirected.if the new protocol is https then the httpconnectoraddress secure settingis turned on.",
	"Method": "HttpConnectorAddress followRedirection(HttpConnectorAddress originalAddr,String redirection){\r\n    final URL url = new URL(redirection);\r\n    final boolean useSecure = (url.getProtocol().equalsIgnoreCase(\"https\"));\r\n    HttpConnectorAddress hca = new HttpConnectorAddress(url.getHost(), url.getPort(), useSecure, originalAddr.getPath(), originalAddr.getSSLSocketFactory());\r\n    hca.setInteractive(interactive);\r\n    return hca;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.app.ConnectorURI.check",
	"Comment": "the connector element specifies the uri of a connectormodule, relative to the top level of the application package.",
	"Method": "Result check(Application descriptor){\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    Result result = getInitializedResult();\r\n    for (Iterator itr = descriptor.getBundleDescriptors(ConnectorDescriptor.class).iterator(); itr.hasNext(); ) {\r\n        ConnectorDescriptor cond = (ConnectorDescriptor) itr.next();\r\n        if (!cond.getModuleDescriptor().getArchiveUri().endsWith(\".rar\")) {\r\n            addErrorDetails(result, compName);\r\n            result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: [ {0} ] does not specify the URI [ {1} ] of a Connector module, relative to the top level of the application package [ {2} ], or does not end with \\\".rar\\\"\", new Object[] { cond.getName(), cond.getModuleDescriptor().getArchiveUri(), descriptor.getName() }));\r\n        }\r\n    }\r\n    if (result.getStatus() != Result.FAILED) {\r\n        addGoodDetails(result, compName);\r\n        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"All the Connector URIs are valid.\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModuleConfig.getDescriptor",
	"Comment": "return the object representation of the deployment descriptor specifiedfor the web application.",
	"Method": "WebBundleDescriptorImpl getDescriptor(){\r\n    return _wbd;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getRequest",
	"Comment": "gets the servletrequest for which this objectis the facade. this method must be implemented by a subclass.",
	"Method": "HttpServletRequest getRequest(HttpServletRequest getRequest,boolean maskDefaultContextMapping){\r\n    if (!maskDefaultContextMapping || !isDefaultContext) {\r\n        if (facade == null) {\r\n            facade = new RequestFacade(this);\r\n        }\r\n        if (!initRequestFacadeHelper) {\r\n            attributes.put(Globals.REQUEST_FACADE_HELPER, facade.getRequestFacadeHelper());\r\n            initRequestFacadeHelper = true;\r\n        }\r\n        return facade;\r\n    } else {\r\n        if (defaultContextMaskingFacade == null) {\r\n            defaultContextMaskingFacade = new RequestFacade(this, true);\r\n        }\r\n        if (!initRequestFacadeHelper) {\r\n            attributes.put(Globals.REQUEST_FACADE_HELPER, defaultContextMaskingFacade.getRequestFacadeHelper());\r\n            initRequestFacadeHelper = true;\r\n        }\r\n        return defaultContextMaskingFacade;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.CoyoteServerSocketFactory.setCiphers",
	"Comment": "sets the ssl cipher suites that are to be enabled.only those ssl cipher suites that are actually supported bythe underlying ssl implementation will be enabled.",
	"Method": "void setCiphers(String ciphers){\r\n    this.cipherSuites = ciphers;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.findWrapperLifecycles",
	"Comment": "return the list of lifecyclelistener classes that will be added tonewly created wrappers automatically.",
	"Method": "List<String> findWrapperLifecycles(){\r\n    return wrapperLifecycles;\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.AuthenticatorBase.getRandom",
	"Comment": "return the random number generator instance we should use forgenerating session identifiers.if there is no such generatorcurrently defined, construct and seed a new one.",
	"Method": "SecureRandom getRandom(){\r\n    if (this.random == null) {\r\n        try {\r\n            Class clazz = Class.forName(randomClass);\r\n            this.random = (SecureRandom) clazz.newInstance();\r\n            long seed = System.currentTimeMillis();\r\n            char[] entropy = getEntropy().toCharArray();\r\n            for (int i = 0; i < entropy.length; i++) {\r\n                long update = ((byte) entropy[i]) << ((i % 8) * 8);\r\n                seed ^= update;\r\n            }\r\n            this.random.setSeed(seed);\r\n        } catch (Exception e) {\r\n            this.random = new SecureRandom();\r\n        }\r\n    }\r\n    return (this.random);\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutodeployRetryManager.createInfo",
	"Comment": "factory method that creates a new info object for a given file.",
	"Method": "Info createInfo(File f){\r\n    if (f.isDirectory()) {\r\n        return new DirectoryInfo(f);\r\n    } else {\r\n        return new JarInfo(f);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.TransactionSynchronizationRegistryImpl.getTransactionStatus",
	"Comment": "returns the status of the transaction bound to the current thread.this is the result of executing getstatus method on thetransactionmanager, in the current transaction context.",
	"Method": "int getTransactionStatus(){\r\n    try {\r\n        return transactionManager.getStatus();\r\n    } catch (SystemException ex) {\r\n        return Status.STATUS_NO_TRANSACTION;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentTransaction.sendingRequest",
	"Comment": "informs the currenttransaction that a request is being sent.returns the transaction context that should be established for the object inthe remote process.",
	"Method": "void sendingRequest(int id,PropagationContextHolder holder){\r\n    boolean[] outBoolean = new boolean[1];\r\n    ControlImpl current = endAborted(outBoolean, false);\r\n    if (outBoolean[0]) {\r\n        TRANSACTION_ROLLEDBACK exc = new TRANSACTION_ROLLEDBACK(0, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    if (current == null) {\r\n        return;\r\n    }\r\n    try {\r\n        holder.value = current.getTXContext();\r\n    } catch (Unavailable exc) {\r\n        INVALID_TRANSACTION ex2 = new INVALID_TRANSACTION(0, CompletionStatus.COMPLETED_NO);\r\n        ex2.initCause(exc);\r\n        throw ex2;\r\n    } catch (TRANSACTION_ROLLEDBACK exc) {\r\n        endCurrent(true);\r\n        current.destroy();\r\n        throw (TRANSACTION_ROLLEDBACK) exc.fillInStackTrace();\r\n    } catch (Throwable exc) {\r\n        _logger.log(Level.FINE, \"\", exc);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.valves.AccessLogValve.getInfo",
	"Comment": "return descriptive information about this implementation.",
	"Method": "String getInfo(){\r\n    return (this.info);\r\n}"
}, {
	"Path": "org.glassfish.deployment.versioning.VersioningUtilsTest.testGetRepositoryName",
	"Comment": "test of getrepositoryname method, of class versioningutils.",
	"Method": "void testGetRepositoryName(){\r\n    String versionIdentifier = \"RC-1.0.0\";\r\n    String appName = APPLICATION_NAME + VersioningUtils.EXPRESSION_SEPARATOR + versionIdentifier;\r\n    String expectedResult = APPLICATION_NAME + VersioningUtils.REPOSITORY_DASH + versionIdentifier;\r\n    String result = \"\";\r\n    result = VersioningUtils.getRepositoryName(appName);\r\n    assertEquals(expectedResult, result);\r\n    versionIdentifier = \"RC:1.0.0\";\r\n    appName = APPLICATION_NAME + VersioningUtils.EXPRESSION_SEPARATOR + versionIdentifier;\r\n    expectedResult = APPLICATION_NAME + VersioningUtils.REPOSITORY_DASH + versionIdentifier.replace(\":\", VersioningUtils.REPOSITORY_DASH);\r\n    result = VersioningUtils.getRepositoryName(appName);\r\n    assertEquals(expectedResult, result);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.ControlImpl.getGlobalTID",
	"Comment": "returns the identifier that globally represents the transaction, and avalue that indicates the state of the transaction.",
	"Method": "GlobalTID getGlobalTID(otid_t getGlobalTID,StatusHolder status){\r\n    otid_t result = null;\r\n    if (status != null)\r\n        status.value = tranState;\r\n    if (globalTID == null) {\r\n        INTERNAL exc = new INTERNAL(MinorCode.NoGlobalTID, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    } else\r\n        result = globalTID.realTID;\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModule.loadSessions",
	"Comment": "loads any sessions that were stored in the given deployment contextprior to a redeployment of this web module.",
	"Method": "void loadSessions(Properties deploymentProperties){\r\n    if (deploymentProperties == null) {\r\n        return;\r\n    }\r\n    StandardManager manager = (StandardManager) getManager();\r\n    if (manager == null) {\r\n        return;\r\n    }\r\n    String sessions = deploymentProperties.getProperty(getObjectName());\r\n    if (sessions != null) {\r\n        try {\r\n            ByteArrayInputStream bais = new ByteArrayInputStream(gfDecoder.decodeBuffer(sessions));\r\n            manager.readSessions(bais);\r\n        } catch (Exception ex) {\r\n            String msg = rb.getString(LogFacade.UNABLE_TO_RESTORE_SESSIONS_DURING_REDEPLOY);\r\n            msg = MessageFormat.format(msg, getName());\r\n            logger.log(Level.WARNING, msg, ex);\r\n        }\r\n        deploymentProperties.remove(getObjectName());\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.JDBCStore.getSize",
	"Comment": "return an integer containing a count of all sessionscurrently saved in this store.if there are no sessions,0 is returned.",
	"Method": "int getSize(){\r\n    int size = 0;\r\n    String sizeSql = \"SELECT COUNT(\" + sessionIdCol + \") FROM \" + sessionTable + \" WHERE \" + sessionAppCol + \" = ?\";\r\n    ResultSet rst = null;\r\n    synchronized (this) {\r\n        Connection _conn = getConnection();\r\n        if (_conn == null) {\r\n            return (size);\r\n        }\r\n        try {\r\n            if (preparedSizeSql == null) {\r\n                preparedSizeSql = _conn.prepareStatement(sizeSql);\r\n            }\r\n            preparedSizeSql.setString(1, getName());\r\n            rst = preparedSizeSql.executeQuery();\r\n            if (rst.next()) {\r\n                size = rst.getInt(1);\r\n            }\r\n        } catch (SQLException e) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.SQL_ERROR), e);\r\n            log(msg);\r\n        } finally {\r\n            try {\r\n                if (rst != null)\r\n                    rst.close();\r\n            } catch (SQLException e) {\r\n            }\r\n            release(_conn);\r\n        }\r\n    }\r\n    return (size);\r\n}"
}, {
	"Path": "org.apache.catalina.realm.RealmBase.getAlternatePrincipal",
	"Comment": "return an alternate principal from the request if available.tomcat realms do not implement this so always return null as default.",
	"Method": "Principal getAlternatePrincipal(HttpRequest req){\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.admin.cli.resources.ListResourceRefs.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        if (resourceRefs != null) {\r\n            processResourceRefs(report, resourceRefs);\r\n            report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n        }\r\n    } catch (Exception e) {\r\n        report.setMessage(localStrings.getLocalString(\"list.resource.refs.failed\", \"list-resource-refs failed\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.addWrapperLifecycle",
	"Comment": "add the classname of a lifecyclelistener to be added to eachwrapper appended to this context.",
	"Method": "void addWrapperLifecycle(String listener){\r\n    wrapperLifecycles.add(listener);\r\n    if (notifyContainerListeners) {\r\n        fireContainerEvent(\"addWrapperLifecycle\", listener);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.MultipartStream.findByte",
	"Comment": "searches for a byte of specified value in the buffer,starting at the specified position.",
	"Method": "int findByte(byte value,int pos){\r\n    for (int i = pos; i < tail; i++) {\r\n        if (buffer[i] == value) {\r\n            return i;\r\n        }\r\n    }\r\n    return -1;\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ModifiedAttributeHASession.setAttribute",
	"Comment": "set the attribute name to the value valueand update the attribute state accordingly",
	"Method": "void setAttribute(String name,Object value){\r\n    super.setAttribute(name, value);\r\n    SessionAttributeState attributeState = getAttributeState(name);\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"ModifiedAttributeHASession>>setAttribute name=\" + name + \" attributeState=\" + attributeState);\r\n    }\r\n    if (value == null) {\r\n        if (attributeState != null) {\r\n            if (attributeState.isPersistent()) {\r\n                attributeState.setDeleted(true);\r\n            } else {\r\n                removeAttributeState(name);\r\n            }\r\n        }\r\n    } else {\r\n        if (attributeState == null) {\r\n            SessionAttributeState newAttrState = new SessionAttributeState();\r\n            _attributeStates.put(name, newAttrState);\r\n        } else {\r\n            if (attributeState.isDeleted()) {\r\n                attributeState.setDeleted(false);\r\n            } else {\r\n                if (attributeState.isPersistent()) {\r\n                    attributeState.setDirty(true);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    setDirty(true);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.ControlImpl.pushControl",
	"Comment": "stacks the given controlimpl on the target of the operation, so that it canlater be restored, and returns a value that indicates the state of thetransaction.if there is already a stacked controlimpl object, the operation throws anexception.if the transaction has already completed, no stacking is done.",
	"Method": "void pushControl(ControlImpl control,StatusHolder status){\r\n    if (tranState == Status.StatusActive) {\r\n        if (stacked != null) {\r\n            INTERNAL exc = new INTERNAL(MinorCode.AlreadyStacked, CompletionStatus.COMPLETED_NO);\r\n            throw exc;\r\n        } else\r\n            stacked = control;\r\n    }\r\n    if (status != null)\r\n        status.value = tranState;\r\n}"
}, {
	"Path": "com.sun.enterprise.util.io.ServerDirs.deletePidFile",
	"Comment": "return a message suitable for printing, not just for errors.",
	"Method": "String deletePidFile(){\r\n    if (!valid)\r\n        return \"Internal Error: ServerDirs is in an invalid state\";\r\n    if (!pidFile.isFile())\r\n        return null;\r\n    String message = \"pid file \" + pidFile + \" exists, removing it.\";\r\n    if (!pidFile.delete()) {\r\n        return message + \"  Couldn't remove pid file\";\r\n    }\r\n    return message;\r\n}"
}, {
	"Path": "org.apache.catalina.startup.Catalina.createStopDigester",
	"Comment": "create and configure the digester we will be using for shutdown.",
	"Method": "Digester createStopDigester(){\r\n    Digester digester = new Digester();\r\n    if (debug > 0)\r\n        digester.setDebug(debug);\r\n    digester.addObjectCreate(\"Server\", \"org.apache.catalina.core.StandardServer\", \"className\");\r\n    digester.addSetProperties(\"Server\");\r\n    digester.addSetNext(\"Server\", \"setServer\", \"org.apache.catalina.Server\");\r\n    return (digester);\r\n}"
}, {
	"Path": "examples.sfsb.TraderBean.ejbActivate",
	"Comment": "this method is required by the ejb specification,but is not used by this example.",
	"Method": "void ejbActivate(){\r\n    log(\"ejbActivate called\");\r\n}"
}, {
	"Path": "com.sun.enterprise.glassfish.bootstrap.StaticGlassFishRuntime.newGlassFish",
	"Comment": "creates a new glassfish instance and add it to a map of instancescreated by this runtime.",
	"Method": "GlassFish newGlassFish(GlassFishProperties glassFishProperties){\r\n    try {\r\n        Properties cloned = new Properties();\r\n        cloned.putAll(glassFishProperties.getProperties());\r\n        final GlassFishProperties gfProps = new GlassFishProperties(cloned);\r\n        setEnv(gfProps);\r\n        final StartupContext startupContext = new StartupContext(gfProps.getProperties());\r\n        ModulesRegistry modulesRegistry = SingleHK2Factory.getInstance().createModulesRegistry();\r\n        ServiceLocator serviceLocator = main.createServiceLocator(modulesRegistry, startupContext, Arrays.asList((PopulatorPostProcessor) new EmbeddedInhabitantsParser(), new ContextDuplicatePostProcessor()), null);\r\n        final ModuleStartup gfKernel = main.findStartupService(modulesRegistry, serviceLocator, null, startupContext);\r\n        GlassFishImpl gfImpl = new GlassFishImpl(gfKernel, serviceLocator, gfProps.getProperties()) {\r\n            @Override\r\n            public void dispose() throws GlassFishException {\r\n                try {\r\n                    super.dispose();\r\n                } finally {\r\n                    gfMap.remove(gfProps.getInstanceRoot());\r\n                    if (\"true\".equalsIgnoreCase(gfProps.getProperties().getProperty(autoDelete)) && gfProps.getInstanceRoot() != null) {\r\n                        File instanceRoot = new File(gfProps.getInstanceRoot());\r\n                        if (instanceRoot.exists()) {\r\n                            Util.deleteRecursive(instanceRoot);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        };\r\n        gfMap.put(gfProps.getInstanceRoot(), gfImpl);\r\n        return gfImpl;\r\n    } catch (GlassFishException e) {\r\n        throw e;\r\n    } catch (Exception e) {\r\n        throw new GlassFishException(e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.glassfish.bootstrap.StaticGlassFishRuntime.newGlassFish",
	"Comment": "creates a new glassfish instance and add it to a map of instancescreated by this runtime.",
	"Method": "GlassFish newGlassFish(GlassFishProperties glassFishProperties){\r\n    try {\r\n        super.dispose();\r\n    } finally {\r\n        gfMap.remove(gfProps.getInstanceRoot());\r\n        if (\"true\".equalsIgnoreCase(gfProps.getProperties().getProperty(autoDelete)) && gfProps.getInstanceRoot() != null) {\r\n            File instanceRoot = new File(gfProps.getInstanceRoot());\r\n            if (instanceRoot.exists()) {\r\n                Util.deleteRecursive(instanceRoot);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SenderReceiver.received_reply",
	"Comment": "pass the operation through to the currenttransaction class.",
	"Method": "void received_reply(int id,PropagationContext context,org.omg.CORBA.Environment ex){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        if (context != null) {\r\n            _logger.log(Level.FINE, \"In received_reply\" + \":\" + id + \",\" + context.current.otid.formatID);\r\n        } else {\r\n            _logger.log(Level.FINE, \"In received_reply\" + \":\" + id + \", null context\");\r\n        }\r\n    }\r\n    CurrentTransaction.receivedReply(id, context, ex);\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        if (context != null) {\r\n            _logger.log(Level.FINE, \"Out received_reply\" + \":\" + id + \",\" + context.current.otid.formatID);\r\n        } else {\r\n            _logger.log(Level.FINE, \"Out received_reply\" + \":\" + id + \", null context\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.jmx.MBeanProxyHandler.getAttribute",
	"Comment": "same as xattributesaccess.getattribute, but with exceptions",
	"Method": "Object getAttribute(String attributeName){\r\n    final Object result = getMBeanServerConnection().getAttribute(getObjectName(), attributeName);\r\n    postGetAttributeHook(attributeName, result);\r\n    return (result);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.AdminAdapter.hasCookieHeader",
	"Comment": "this method checks if the request has a cookie header andif the instance name serving the request is the same as thejvmroute information",
	"Method": "boolean hasCookieHeader(Request req){\r\n    String[] nameValuePair = getJSESSIONIDHeaders(req);\r\n    if (nameValuePair != null) {\r\n        String headerValue = nameValuePair[1];\r\n        int index = headerValue.lastIndexOf('.');\r\n        return headerValue.substring(index + 1).equals(server.getName()) ? true : false;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ErrorReportValve.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (info);\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.readers.InputObject.getInt",
	"Comment": "get the int value associated with a key. if the number value is toolarge for an int, it will be clipped.",
	"Method": "int getInt(String key){\r\n    Object o = getValue(key);\r\n    return o instanceof Number ? ((Number) o).intValue() : (int) getDouble(key);\r\n}"
}, {
	"Path": "org.apache.catalina.valves.AccessLogValve.replace",
	"Comment": "return the replacement text for the specified pattern character.",
	"Method": "String replace(char pattern,Date date,Request request,Response response,long time,String replace,String header,char type,Request request,Response response){\r\n    Object value = null;\r\n    ServletRequest req = request.getRequest();\r\n    HttpServletRequest hreq = (HttpServletRequest) req;\r\n    switch(type) {\r\n        case 'i':\r\n            if (null != hreq)\r\n                value = hreq.getHeader(header);\r\n            else\r\n                value = \"??\";\r\n            break;\r\n        case 'c':\r\n            Cookie[] c = hreq.getCookies();\r\n            for (int i = 0; c != null && i < c.length; i++) {\r\n                if (header.equals(c[i].getName())) {\r\n                    value = c[i].getValue();\r\n                    break;\r\n                }\r\n            }\r\n            break;\r\n        case 'r':\r\n            if (null != hreq)\r\n                value = hreq.getAttribute(header);\r\n            else\r\n                value = \"??\";\r\n            break;\r\n        case 's':\r\n            if (null != hreq) {\r\n                HttpSession sess = hreq.getSession(false);\r\n                if (null != sess)\r\n                    value = sess.getAttribute(header);\r\n            }\r\n            break;\r\n        default:\r\n            value = \"???\";\r\n    }\r\n    try {\r\n        if (value != null)\r\n            if (value instanceof String)\r\n                return (String) value;\r\n            else\r\n                return value.toString();\r\n        else\r\n            return \"-\";\r\n    } catch (Throwable e) {\r\n        return \"-\";\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SenderReceiver.identify",
	"Comment": "identifies an instance of this class to the tsidentification object.",
	"Method": "void identify(TSIdentification ident){\r\n    try {\r\n        ident.identify_sender(sendRec);\r\n        ident.identify_receiver(sendRec);\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.log(Level.FINE, \"Sender/Receiver \" + sendRec + \" successfully identified\");\r\n        }\r\n    } catch (AlreadyIdentified exc) {\r\n        _logger.log(Level.FINE, \"jts.already_indetified_communication_manager\");\r\n    } catch (NotAvailable exc) {\r\n        _logger.log(Level.WARNING, \"jts.unable_to_indetify_communication_manager\");\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.getInstanceSupport",
	"Comment": "return the instancesupport object for this wrapper instance.",
	"Method": "InstanceSupport getInstanceSupport(){\r\n    return (this.instanceSupport);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.AdminUtil.getActiveTransactionCount",
	"Comment": "return the number of transactions that are active currently.",
	"Method": "long getActiveTransactionCount(){\r\n    return RecoveryManager.getCoordsByGlobalTID().size() - getPendingTransactionCount();\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebComponentDescriptorImpl.removeInitializationParameter",
	"Comment": "removes the given servlet initialization parameter from this component.",
	"Method": "void removeInitializationParameter(InitializationParameter initializationParameter){\r\n    getInitializationParameterSet().remove(initializationParameter);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.connector.ConnectorVerifier.getClassPath",
	"Comment": "creates and returns the class path associated with the rar.uses the exploded location of the archive for generating the classpath.",
	"Method": "String getClassPath(){\r\n    if (classPath != null)\r\n        return classPath;\r\n    if (isASMode)\r\n        return (classPath = getClassPath(verifierFrameworkContext.getClassPath()));\r\n    String cp;\r\n    if (!cond.getModuleDescriptor().isStandalone()) {\r\n        String ear_uri = verifierFrameworkContext.getExplodedArchivePath();\r\n        File ear = new File(ear_uri);\r\n        assert (ear.isDirectory());\r\n        cp = ClassPathBuilder.buildClassPathForEar(ear);\r\n        String libdir = cond.getApplication().getLibraryDirectory();\r\n        if (libdir != null) {\r\n            cp = getLibdirClasspath(ear_uri, libdir) + cp;\r\n        }\r\n    } else {\r\n        String module_uri = verifierFrameworkContext.getExplodedArchivePath();\r\n        File module = new File(module_uri);\r\n        assert (module.isDirectory() && module.isAbsolute());\r\n        cp = ClassPathBuilder.buildClassPathForRar(module);\r\n    }\r\n    return (classPath = cp);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.DefaultAccessLogFormatterImpl.appendResponseLength",
	"Comment": "appends the content length of the given response to the given charbuffer.",
	"Method": "void appendResponseLength(CharBuffer cb,Response response){\r\n    cb.put(\"\" + response.getContentCount());\r\n}"
}, {
	"Path": "org.glassfish.common.util.admin.RestSessionManager.createSession",
	"Comment": "todo createsession is public. this package should not be exported",
	"Method": "String createSession(String remoteAddr,Subject subject,int sessionTimeoutInMins){\r\n    String sessionId;\r\n    do {\r\n        sessionId = new BigInteger(130, randomGenerator).toString(16);\r\n    } while (isSessionExist(sessionId));\r\n    saveSession(sessionId, remoteAddr, subject, sessionTimeoutInMins);\r\n    return sessionId;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.VerifierTest.getMethod",
	"Comment": "utility method to return a method if ig is implemented by a class or oneof its superclass and it is defined as public",
	"Method": "Method getMethod(Class clazz,String methodName,Class[] parmTypes){\r\n    Method m = null;\r\n    Class c = clazz;\r\n    do {\r\n        try {\r\n            m = clazz.getMethod(methodName, parmTypes);\r\n        } catch (NoSuchMethodException nsme) {\r\n        } catch (SecurityException se) {\r\n        }\r\n        c = c.getSuperclass();\r\n    } while (m != null && c != null);\r\n    return m;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getResourceAsStream",
	"Comment": "return the requested resource as an inputstream.thepath must be specified according to the rules described undergetresource.if no such resource can be identified,return null.",
	"Method": "InputStream getResourceAsStream(String path){\r\n    return context.getResourceAsStream(path);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.getServletClassName",
	"Comment": "return the fully qualified servlet class name for this servlet.",
	"Method": "String getServletClassName(){\r\n    return this.servletClassName;\r\n}"
}, {
	"Path": "org.glassfish.internal.embedded.Server.createPort",
	"Comment": "creates a port to attach to embedded containers. ports can be attached to manyembedded containers and some containers may accept more than one port.",
	"Method": "Port createPort(int portNumber){\r\n    Ports ports = habitat.getService(Ports.class);\r\n    return ports.createPort(portNumber);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.ConnectorTest.check",
	"Comment": "all connector tests should implement this method. it run an individualtest against the resource adapter deployment descriptor.",
	"Method": "Result check(Descriptor descriptor,Result check,ConnectorDescriptor descriptor){\r\n    return check((ConnectorDescriptor) descriptor);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModuleConfig.getLocation",
	"Comment": "return the directory in which the web application is deployed.",
	"Method": "File getLocation(){\r\n    return _dir;\r\n}"
}, {
	"Path": "samples.amx.SampleListener.addNotif",
	"Comment": "keep a map, keyed by notification type, of all notifications received.",
	"Method": "void addNotif(Notification notif){\r\n    final String type = notif.getType();\r\n    List list = null;\r\n    if (!mNotifs.keySet().contains(type)) {\r\n        clearNotifs(type);\r\n    }\r\n    list = (List) mNotifs.get(type);\r\n    list.add(notif);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.removeLocalEjb",
	"Comment": "remove any local ejb resource reference with the specified name.",
	"Method": "void removeLocalEjb(String name){\r\n    namingResources.removeLocalEjb(name);\r\n    if (notifyContainerListeners) {\r\n        fireContainerEvent(\"removeLocalEjb\", name);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.stringsubs.impl.TestStringSubstitutionEngine.testSubstitutionForGroupInvalidFilePath",
	"Comment": "test substitution for group pointing to invalid file paths.",
	"Method": "void testSubstitutionForGroupInvalidFilePath(){\r\n    List<String> groupIDs = new ArrayList<String>(1);\r\n    groupIDs.add(GROUP_WITH_INVALID_FILE_PATHS);\r\n    try {\r\n        _engine.substituteGroups(groupIDs);\r\n    } catch (StringSubstitutionException e) {\r\n        Assert.fail(\"Throwing exception if Group having invalid file paths undergo substitution.\");\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.CreateLocalInstanceCommand.createMasterPasswordFile",
	"Comment": "create the master password keystore. this routine can also modify the master passwordif the keystore already exists",
	"Method": "void createMasterPasswordFile(String masterPassword){\r\n    final File pwdFile = new File(this.getServerDirs().getAgentDir(), MASTER_PASSWORD_ALIAS);\r\n    try {\r\n        PasswordAdapter p = new PasswordAdapter(pwdFile.getAbsolutePath(), MASTER_PASSWORD_ALIAS.toCharArray());\r\n        p.setPasswordForAlias(MASTER_PASSWORD_ALIAS, masterPassword.getBytes());\r\n        chmod(\"600\", pwdFile);\r\n    } catch (Exception ex) {\r\n        throw new CommandException(Strings.get(\"masterPasswordFileNotCreated\", pwdFile), ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RegisteredSyncs.distributeAfter",
	"Comment": "distributes after completion operations to all registeredsynchronization objects.",
	"Method": "void distributeAfter(Status status){\r\n    for (int i = 0; i < registered.size(); i++) {\r\n        boolean isProxy = false;\r\n        Synchronization sync = (Synchronization) registered.elementAt(i);\r\n        if (!(sync instanceof com.sun.jts.jta.SynchronizationImpl)) {\r\n            isProxy = Configuration.getProxyChecker().isProxy(sync);\r\n        }\r\n        try {\r\n            if (_logger.isLoggable(Level.FINEST)) {\r\n                _logger.logp(Level.FINEST, \"RegisterdSyncs\", \"distributeAfter()\", \"Before invoking after_completion() on synchronization object \" + sync);\r\n            }\r\n            sync.after_completion(status);\r\n            if (_logger.isLoggable(Level.FINEST)) {\r\n                _logger.logp(Level.FINEST, \"RegisterdSyncs\", \"distributeAfter()\", \"After invoking after_completion() on\" + \"synchronization object\" + sync);\r\n            }\r\n        } catch (Throwable exc) {\r\n            if (exc instanceof OBJECT_NOT_EXIST || exc instanceof COMM_FAILURE) {\r\n            } else {\r\n                _logger.log(Level.WARNING, \"jts.exception_in_synchronization_operation\", new java.lang.Object[] { exc.toString(), \"after_completion\" });\r\n            }\r\n        }\r\n        if (isProxy) {\r\n            sync._release();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.changeSessionId",
	"Comment": "change the session id of the current session associated with thisrequest and return the new session id.",
	"Method": "String changeSessionId(){\r\n    Manager manager = context.getManager();\r\n    if (manager == null) {\r\n        throw new IllegalStateException(rb.getString(LogFacade.CHANGE_SESSION_ID_BEEN_CALLED_EXCEPTION));\r\n    }\r\n    Session session = getSessionInternal(false);\r\n    if (session == null) {\r\n        throw new IllegalStateException(rb.getString(LogFacade.CHANGE_SESSION_ID_BEEN_CALLED_EXCEPTION));\r\n    }\r\n    manager.changeSessionId(session);\r\n    String newSessionId = session.getId();\r\n    if (requestedSessionId != null && requestedSessionId.length() > 0) {\r\n        requestedSessionId = newSessionId;\r\n    }\r\n    addSessionCookie();\r\n    return newSessionId;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Response.getReporter",
	"Comment": "return a printwriter that can be used to render error messages,regardless of whether a stream or writer has already been acquired.",
	"Method": "PrintWriter getReporter(){\r\n    if (outputBuffer.isNew()) {\r\n        outputBuffer.checkConverter();\r\n        if (writer == null) {\r\n            writer = createWriter(outputBuffer);\r\n        }\r\n        return writer;\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.NamingResources.addLocalEjb",
	"Comment": "add a local ejb resource reference for this web application.",
	"Method": "void addLocalEjb(ContextLocalEjb ejb){\r\n    if (entries.containsKey(ejb.getName())) {\r\n        return;\r\n    } else {\r\n        entries.put(ejb.getName(), ejb.getType());\r\n    }\r\n    synchronized (localEjbs) {\r\n        ejb.setNamingResources(this);\r\n        localEjbs.put(ejb.getName(), ejb);\r\n    }\r\n    support.firePropertyChange(\"localEjb\", null, ejb);\r\n}"
}, {
	"Path": "org.glassfish.deployment.admin.ListComponentsCommand.getAppSnifferEngines",
	"Comment": "return all user visible sniffer engines in an application.the return format is",
	"Method": "String getAppSnifferEngines(Application app,boolean format){\r\n    return getSniffers(getAppEngines(app), format);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.createInputStream",
	"Comment": "create and return a servletinputstream to read the contentassociated with this request.",
	"Method": "ServletInputStream createInputStream(){\r\n    if (inputStream == null) {\r\n        inputStream = new CoyoteInputStream(inputBuffer);\r\n    }\r\n    return inputStream;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.MasterPasswordFileManager.createMasterPasswordFile",
	"Comment": "create the master password keystore. this routine can also modify the master passwordif the keystore already exists",
	"Method": "void createMasterPasswordFile(RepositoryConfig config,String masterPassword){\r\n    final PEFileLayout layout = getFileLayout(config);\r\n    final File pwdFile = layout.getMasterPasswordFile();\r\n    try {\r\n        PasswordAdapter p = new PasswordAdapter(pwdFile.getAbsolutePath(), getMasterPasswordPassword());\r\n        p.setPasswordForAlias(MASTER_PASSWORD_ALIAS, masterPassword.getBytes());\r\n        chmod(\"600\", pwdFile);\r\n    } catch (Exception ex) {\r\n        throw new RepositoryException(_strMgr.getString(\"masterPasswordFileNotCreated\", pwdFile), ex);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.DeploymentContextImpl.prepareScratchDirs",
	"Comment": "prepare the scratch directories, creating the directoriesif they do not exist",
	"Method": "void prepareScratchDirs(){\r\n    prepareScratchDir(getScratchDir(\"ejb\"));\r\n    prepareScratchDir(getScratchDir(\"xml\"));\r\n    prepareScratchDir(getScratchDir(\"jsp\"));\r\n}"
}, {
	"Path": "org.apache.catalina.core.ContainerBase.getParent",
	"Comment": "return the container for which this container is a child, if there isone.if there is no defined parent, return null.",
	"Method": "Container getParent(){\r\n    return (parent);\r\n}"
}, {
	"Path": "testmbeans.ImplementsMBeanRegistration.getAttribute",
	"Comment": "gets the value of the specified attribute of the dynamicmbean.",
	"Method": "Object getAttribute(String attributeName){\r\n    if (attributeName.equals(\"Name\")) {\r\n        return null;\r\n    }\r\n    throw new AttributeNotFoundException(\"Unknown Attribute \" + attributeName);\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.Artifacts.get",
	"Comment": "gets the artifacts matching the key prefix from the application propertiesof the specified application.",
	"Method": "Artifacts get(DeploymentContext dc,String keyPrefix,Artifacts get,Properties props,String keyPrefix){\r\n    final Artifacts result = new Artifacts(keyPrefix);\r\n    for (String propName : props.stringPropertyNames()) {\r\n        final String propNamePrefix = propNamePrefix(keyPrefix);\r\n        if (propName.startsWith(propNamePrefix)) {\r\n            final URI fullURI = URI.create(props.getProperty(propName));\r\n            result.addArtifact(fullURI, propName.substring(propNamePrefix.length()));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getMinorVersion",
	"Comment": "return the minor version of the java servlet api that we implement.",
	"Method": "int getMinorVersion(){\r\n    return context.getMinorVersion();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorLog.getStateHolder",
	"Comment": "get the state for the given log location.if the state does not exists, creates the state and retuns, otherwise existingstate is returned.",
	"Method": "CoordinatorLogStateHolder getStateHolder(String str){\r\n    synchronized (logStateHoldertable) {\r\n        CoordinatorLogStateHolder logStateHolder = (CoordinatorLogStateHolder) logStateHoldertable.get(str);\r\n        if (logStateHolder == null) {\r\n            logStateHolder = new CoordinatorLogStateHolder();\r\n            logStateHolder.logFile = null;\r\n            logStateHolder.log = null;\r\n            logStateHolder.activeLogs = new Hashtable();\r\n            logStateHolder.keypointLogs = new Hashtable();\r\n            logStateHolder.tranCount = 0;\r\n            logStateHolder.keypointInProgress = false;\r\n            logStateHolder.keypointLock = new RWLock();\r\n            logStateHolder.keypointStateLock = new java.lang.Object();\r\n            logStateHoldertable.put(str, logStateHolder);\r\n        }\r\n        return logStateHolder;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getHost",
	"Comment": "return the host within which this request is being processed.",
	"Method": "Host getHost(){\r\n    return (Host) mappingData.host;\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionImpl.getTransactionId",
	"Comment": "this method is used for the admin framework displayingof transactions ids",
	"Method": "String getTransactionId(){\r\n    return gtid.toString();\r\n}"
}, {
	"Path": "components.components.ScrollerComponent.getRowsPerPage",
	"Comment": "returns the number of rows to display by looking up theuidata component that this scroller is associated with.for the purposes of this demo, we are assuming the uidata tobe child of uiform component and not nested inside a customnamingcontainer.",
	"Method": "int getRowsPerPage(FacesContext context){\r\n    String forValue = (String) getAttributes().get(\"for\");\r\n    UIData uiData = (UIData) getForm(context).findComponent(forValue);\r\n    if (uiData == null) {\r\n        return 0;\r\n    }\r\n    return uiData.getRows();\r\n}"
}, {
	"Path": "com.sun.enterprise.config.modularity.ConfigModularityUtils.findSuitableCollectionGetter",
	"Comment": "find a getter method that returns a collection of the type we want to put set.",
	"Method": "Method findSuitableCollectionGetter(Class owner,Class typeToSet){\r\n    Method[] methods = owner.getMethods();\r\n    Method tm = returnException(owner, typeToSet);\r\n    if (tm != null)\r\n        return tm;\r\n    for (Method m : methods) {\r\n        if (m.getName().startsWith(\"get\")) {\r\n            Type t = m.getGenericReturnType();\r\n            if (t instanceof ParameterizedType) {\r\n                ParameterizedType pt = (ParameterizedType) t;\r\n                Type actualGenericParameter = pt.getActualTypeArguments()[0];\r\n                if (pt.getActualTypeArguments().length == 1) {\r\n                    if (Collection.class.isAssignableFrom(m.getReturnType())) {\r\n                        if (actualGenericParameter instanceof Class) {\r\n                            if (typeToSet.isAssignableFrom((Class) actualGenericParameter)) {\r\n                                if ((m.getAnnotation(DuckTyped.class) != null)) {\r\n                                    return m;\r\n                                } else {\r\n                                    Method deepM = findDeeperSuitableCollectionGetter(owner, typeToSet);\r\n                                    return deepM != null ? deepM : m;\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return findDeeperSuitableCollectionGetter(owner, typeToSet);\r\n}"
}, {
	"Path": "components.renderkit.ChartServlet.doPost",
	"Comment": "process an incoming request, and create the correspondingresponse.",
	"Method": "void doPost(HttpServletRequest request,HttpServletResponse response){\r\n    doGet(request, response);\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.processingInstruction",
	"Comment": "process notification of a processing instruction that was encountered.",
	"Method": "void processingInstruction(String target,String data){\r\n    if (saxLog.isLoggable(Level.FINE)) {\r\n        saxLog.log(Level.FINE, \"processingInstruction('\" + target + \"','\" + data + \"')\");\r\n    }\r\n    ;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.getServiceReferenceByName",
	"Comment": "looks up an service reference with the given name.throws an illegalargumentexception if it is not found.",
	"Method": "ServiceReferenceDescriptor getServiceReferenceByName(String name){\r\n    ServiceReferenceDescriptor sr = _getServiceReferenceByName(name);\r\n    if (sr != null) {\r\n        return sr;\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"web.deployment.exceptionwebapphasnoservicerefbyname\", \"This web app [{0}] has no service reference by the name of [{1}]\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "org.apache.catalina.realm.RealmBase.getAlternateAuthType",
	"Comment": "return an alternate auth type from the request if available.tomcat realms do not implement this so always return null as default.",
	"Method": "String getAlternateAuthType(HttpRequest req){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.util.ProcessExecutor.getFileBuffer",
	"Comment": "returns the contents of a file as a string. it never returns a null. ifthe file is empty, an empty string is returned.",
	"Method": "String getFileBuffer(File file){\r\n    final StringBuffer sb = new StringBuffer();\r\n    BufferedReader reader = null;\r\n    try {\r\n        reader = new BufferedReader(new FileReader(file));\r\n        String line = null;\r\n        while ((line = reader.readLine()) != null) {\r\n            sb.append(line);\r\n            sb.append(NEWLINE);\r\n        }\r\n    } catch (Exception e) {\r\n    } finally {\r\n        try {\r\n            reader.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return (sb.toString());\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.NodeUtils.pingSSHConnection",
	"Comment": "make sure we can make an ssh connection using an existing node.",
	"Method": "void pingSSHConnection(Node node){\r\n    try {\r\n        sshL.init(node, logger);\r\n        sshL.pingConnection();\r\n    } catch (Exception e) {\r\n        String m1 = e.getMessage();\r\n        String m2 = \"\";\r\n        Throwable e2 = e.getCause();\r\n        if (e2 != null) {\r\n            m2 = e2.getMessage();\r\n        }\r\n        String msg = Strings.get(\"ssh.bad.connect\", node.getNodeHost(), \"SSH\");\r\n        logger.warning(StringUtils.cat(\": \", msg, m1, m2, sshL.toString()));\r\n        throw new CommandValidationException(StringUtils.cat(NL, msg, m1, m2));\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ContainerBase.setParent",
	"Comment": "set the parent container to which this container is being added as achild.this container may refuse to become attached to the specifiedcontainer by throwing an exception.",
	"Method": "void setParent(Container container){\r\n    Container oldParent = this.parent;\r\n    this.parent = container;\r\n    support.firePropertyChange(\"parent\", oldParent, this.parent);\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ErrorReportValve.invoke",
	"Comment": "invoke the next valve in the sequence. when the invoke returns, checkthe response state, and output an error report is necessary.",
	"Method": "int invoke(Request request,Response response){\r\n    return INVOKE_NEXT;\r\n}"
}, {
	"Path": "org.glassfish.admin.payload.PayloadFilesManager.processParts",
	"Comment": "returns all files extracted from the payload, treating each part as aseparate file.",
	"Method": "List<File> processParts(Payload.Inbound inboundPayload){\r\n    return new ArrayList<File>(processPartsExtended(inboundPayload).keySet());\r\n}"
}, {
	"Path": "com.sun.enterprise.glassfish.bootstrap.MainHelper.getInstanceRoot",
	"Comment": "cli or any other client needs to always pass in the instancedir forinstances.",
	"Method": "File getInstanceRoot(Properties args,Properties asEnv){\r\n    String instanceDir = getParam(args, \"instancedir\");\r\n    if (ok(instanceDir))\r\n        return new File(instanceDir);\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.catalina.core.DummyRequest.generateSessionId",
	"Comment": "this object does not implement a session id generator. providea dummy implementation so that the default one will be used.",
	"Method": "String generateSessionId(){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.GetHealthCommand.getHealthWithGMS",
	"Comment": "simply get the healthhistory object from gmsadapter and outputthe information.",
	"Method": "void getHealthWithGMS(Logger logger,ActionReport report,GMSAdapter gmsAdapter){\r\n    StringBuilder result = new StringBuilder();\r\n    HealthHistory history = gmsAdapter.getHealthHistory();\r\n    if (history == null) {\r\n        setFail(logger, report, Strings.get(\"get.health.noHistoryError\"));\r\n        return;\r\n    }\r\n    if (history.getInstances().isEmpty()) {\r\n        report.setMessage(Strings.get(\"get.health.no.instances\", clusterName));\r\n        return;\r\n    }\r\n    SortedSet<String> names = new TreeSet<String>(history.getInstances());\r\n    List<Properties> statesAndTimes = new ArrayList<Properties>(names.size());\r\n    for (String name : names) {\r\n        Properties instanceStateAndTime = new Properties();\r\n        HealthHistory.InstanceHealth ih = history.getHealthByInstance(name);\r\n        instanceStateAndTime.put(\"name\", name);\r\n        instanceStateAndTime.put(\"status\", ih.state.name());\r\n        if (HealthHistory.NOTIME == ih.time) {\r\n            result.append(name + \" \" + ih.state);\r\n            instanceStateAndTime.put(\"time\", \"\");\r\n        } else {\r\n            result.append(Strings.get(\"get.health.instance.state.since\", name, ih.state, new Date(ih.time).toString()));\r\n            instanceStateAndTime.put(\"time\", String.valueOf(ih.time));\r\n        }\r\n        result.append(\"\\n\");\r\n        statesAndTimes.add(instanceStateAndTime);\r\n    }\r\n    Properties instanceStateTimes = new Properties();\r\n    instanceStateTimes.put(\"instances\", statesAndTimes);\r\n    report.setExtraProperties(instanceStateTimes);\r\n    String rawResult = result.toString();\r\n    report.setMessage(rawResult.substring(0, rawResult.lastIndexOf(\"\\n\")));\r\n}"
}, {
	"Path": "org.apache.catalina.ssi.SSIServletRequestUtil.getRelativePath",
	"Comment": "return the relative path associated with this servlet. taken fromdefaultservlet.java. perhaps this should be put inorg.apache.catalina.util somewhere? seems like it would be widely used.",
	"Method": "String getRelativePath(HttpServletRequest request){\r\n    if (request.getAttribute(\"javax.servlet.include.request_uri\") != null) {\r\n        String result = (String) request.getAttribute(\"javax.servlet.include.path_info\");\r\n        if (result == null)\r\n            result = (String) request.getAttribute(\"javax.servlet.include.servlet_path\");\r\n        if ((result == null) || (result.equals(\"\")))\r\n            result = \"/\";\r\n        return (result);\r\n    }\r\n    String result = request.getPathInfo();\r\n    if (result == null) {\r\n        result = request.getServletPath();\r\n    }\r\n    if ((result == null) || (result.equals(\"\"))) {\r\n        result = \"/\";\r\n    }\r\n    return RequestUtil.normalize(result);\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.DeferredFileOutputStream.getStream",
	"Comment": "returns the current output stream. this may be memory based or diskbased, depending on the current state with respect to the threshold.",
	"Method": "OutputStream getStream(){\r\n    return currentOutputStream;\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.passivate",
	"Comment": "perform the internal processing required to passivatethis session.",
	"Method": "void passivate(){\r\n    context.sessionPassivatedStartEvent(this);\r\n    try {\r\n        HttpSessionEvent event = null;\r\n        String[] keys = keys();\r\n        for (int i = 0; i < keys.length; i++) {\r\n            Object attribute = getAttributeInternal(keys[i]);\r\n            if (attribute instanceof HttpSessionActivationListener) {\r\n                if (event == null)\r\n                    event = new HttpSessionEvent(getSession());\r\n                ((HttpSessionActivationListener) attribute).sessionWillPassivate(event);\r\n            }\r\n        }\r\n    } finally {\r\n        context.sessionPassivatedEndEvent(this);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.DeploymentContextImpl.getFinalClassLoader",
	"Comment": "returns the class loader associated to this deployment request.classloader instances are usually obtained by the getclassloader api onthe associated archivehandler for the archive type being deployed.this can return null and the container should allocate a classloaderwhile loading the application.",
	"Method": "ClassLoader getFinalClassLoader(){\r\n    return cloader;\r\n}"
}, {
	"Path": "org.apache.naming.resources.ProxyDirContext.composeName",
	"Comment": "composes the name of this context with a name relative to this context.",
	"Method": "Name composeName(Name name,Name prefix,String composeName,String name,String prefix){\r\n    return prefix + \"/\" + name;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.CompositeResource.executeSseCommand",
	"Comment": "execute an admincommand with the specified parameters andreturn eventoutput suitable for sse.",
	"Method": "EventOutput executeSseCommand(Subject subject,String command,ParameterMap parameters,ResponseBodyBuilder builder,EventOutput executeSseCommand,Subject subject,String command,ParameterMap parameters,SseCommandHelper.ActionReportProcessor processor,EventOutput executeSseCommand,Subject subject,String command,ParameterMap parameters){\r\n    return getCompositeUtil().executeSseCommand(subject, command, parameters);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.cli.CreateDomainCommand.verifyPortIsValid",
	"Comment": "verify that the port is valid. port must be greater than 0 and less than65535. this method will also check if the port is in use. if checkportsis false it does not throw an exception if it is in use.",
	"Method": "void verifyPortIsValid(String portNum){\r\n    final int portToVerify = convertPortStr(portNum);\r\n    if (!NetUtils.isPortValid(portToVerify)) {\r\n        throw new CommandException(strings.get(\"InvalidPortRange\", portNum));\r\n    }\r\n    if (checkPorts == false) {\r\n        logger.log(Level.FINER, \"Port ={0}\", portToVerify);\r\n        return;\r\n    }\r\n    NetUtils.PortAvailability avail = NetUtils.checkPort(portToVerify);\r\n    switch(avail) {\r\n        case illegalNumber:\r\n            throw new CommandException(strings.get(\"InvalidPortRange\", portNum));\r\n        case inUse:\r\n            throw new CommandException(strings.get(\"PortInUseError\", domainName, portNum));\r\n        case noPermission:\r\n            throw new CommandException(strings.get(\"NoPermissionForPortError\", portNum, domainName));\r\n        case unknown:\r\n            throw new CommandException(strings.get(\"UnknownPortMsg\", portNum));\r\n        case OK:\r\n            logger.log(Level.FINER, \"Port ={0}\", portToVerify);\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.mbean.MBeanImplBase.getNotificationBuilder",
	"Comment": "get a notificationbuilder for the specified type of notificationwhose source is this object.",
	"Method": "NotificationBuilder getNotificationBuilder(String notificationType){\r\n    if (mNotificationBuilders == null) {\r\n        mNotificationBuilders = new HashMap<String, NotificationBuilder>();\r\n    }\r\n    NotificationBuilder builder = mNotificationBuilders.get(notificationType);\r\n    if (builder == null) {\r\n        builder = createNotificationBuilder(notificationType);\r\n        mNotificationBuilders.put(notificationType, builder);\r\n    }\r\n    return (builder);\r\n}"
}, {
	"Path": "org.apache.naming.resources.WARDirContext.getAttributes",
	"Comment": "retrieves all of the attributes associated with a named object.",
	"Method": "Attributes getAttributes(String name,String[] attrIds,Attributes getAttributes,Name name,String[] attrIds){\r\n    Entry entry = null;\r\n    if (name.isEmpty())\r\n        entry = entries;\r\n    else\r\n        entry = treeLookup(name);\r\n    if (entry == null)\r\n        throw new NamingException(MessageFormat.format(rb.getString(LogFacade.RESOURCES_NOT_FOUND), name));\r\n    ZipEntry zipEntry = entry.getEntry();\r\n    ResourceAttributes attrs = new ResourceAttributes();\r\n    attrs.setCreationDate(new Date(zipEntry.getTime()));\r\n    attrs.setName(entry.getName());\r\n    if (!zipEntry.isDirectory())\r\n        attrs.setResourceType(\"\");\r\n    attrs.setContentLength(zipEntry.getSize());\r\n    attrs.setLastModified(new Date(zipEntry.getTime()));\r\n    return attrs;\r\n}"
}, {
	"Path": "com.sun.enterprise.universal.io.SmartFile.convertWindows",
	"Comment": "there is no symlink issue with getcanonical vs getabsoluteso we do it the easy way here...",
	"Method": "void convertWindows(String oldPath){\r\n    try {\r\n        path = new File(oldPath).getCanonicalPath();\r\n        if (!path.startsWith(\"\\\\\"))\r\n            path = path.replace('\\\\', '/');\r\n    } catch (IOException ex) {\r\n        path = oldPath.replace('\\\\', '/');\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.hasSecurityRole",
	"Comment": "checks if the given security role is defined for this application.",
	"Method": "boolean hasSecurityRole(String role){\r\n    return securityRoles.contains(role);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.create_subtransaction",
	"Comment": "creates a subtransaction and returns a control object thatrepresents the child transaction.",
	"Method": "Control create_subtransaction(){\r\n    Control result = null;\r\n    if (tranState == null || tranState.state != TransactionState.STATE_ACTIVE) {\r\n        Inactive exc = new Inactive();\r\n        throw exc;\r\n    }\r\n    CoordinatorImpl[] thisAncestors = nestingInfo.getAncestors();\r\n    CoordinatorImpl[] ancestors = new CoordinatorImpl[thisAncestors.length + 1];\r\n    System.arraycopy(thisAncestors, 0, ancestors, 1, thisAncestors.length);\r\n    ancestors[0] = this;\r\n    SubCoordinator child = null;\r\n    TerminatorImpl terminator = null;\r\n    try {\r\n        child = new SubCoordinator(superInfo.globalTID, superInfo.localTID, ancestors);\r\n        terminator = new TerminatorImpl(child, true);\r\n        result = new ControlImpl(terminator, child, new GlobalTID(child.getGlobalTID()), child.getLocalTID()).object();\r\n    } catch (Throwable exc) {\r\n        Inactive ex2 = new Inactive();\r\n        throw ex2;\r\n    }\r\n    nestingInfo.addChild(child);\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.servlets.DefaultServlet.serveResource",
	"Comment": "serve the specified resource, optionally including the data content.",
	"Method": "void serveResource(HttpServletRequest request,HttpServletResponse response,boolean content){\r\n    String path = getRelativePath(request);\r\n    if (debug > 0) {\r\n        if (content)\r\n            log(\"DefaultServlet.serveResource:  Serving resource '\" + path + \"' headers and data\");\r\n        else\r\n            log(\"DefaultServlet.serveResource:  Serving resource '\" + path + \"' headers only\");\r\n    }\r\n    CacheEntry cacheEntry = null;\r\n    ProxyDirContext proxyDirContext = resources;\r\n    if (alternateDocBases == null || alternateDocBases.size() == 0) {\r\n        cacheEntry = proxyDirContext.lookupCache(path);\r\n    } else {\r\n        AlternateDocBase match = AlternateDocBase.findMatch(path, alternateDocBases);\r\n        if (match != null) {\r\n            cacheEntry = ((ProxyDirContext) ContextsAdapterUtility.unwrap(match.getResources())).lookupCache(path);\r\n        } else {\r\n            cacheEntry = proxyDirContext.lookupCache(path);\r\n        }\r\n    }\r\n    if (!cacheEntry.exists) {\r\n        String requestUri = (String) request.getAttribute(RequestDispatcher.INCLUDE_REQUEST_URI);\r\n        if (requestUri != null) {\r\n            throw new FileNotFoundException(requestUri);\r\n        }\r\n        response.sendError(HttpServletResponse.SC_NOT_FOUND);\r\n        return;\r\n    }\r\n    if (cacheEntry.context == null) {\r\n        if (path.endsWith(\"/\") || (path.endsWith(\"\\\\\"))) {\r\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\r\n            return;\r\n        }\r\n    }\r\n    if (cacheEntry.context == null) {\r\n        boolean included = (request.getAttribute(RequestDispatcher.INCLUDE_CONTEXT_PATH) != null);\r\n        if (!included && !checkIfHeaders(request, response, cacheEntry.attributes)) {\r\n            return;\r\n        }\r\n    }\r\n    String contentType = cacheEntry.attributes.getMimeType();\r\n    if (contentType == null && !cacheEntry.attributes.isMimeTypeInitialized()) {\r\n        contentType = getServletContext().getMimeType(cacheEntry.name);\r\n        cacheEntry.attributes.setMimeType(contentType);\r\n    }\r\n    ArrayList<Range> ranges = null;\r\n    long contentLength = -1L;\r\n    if (cacheEntry.context != null) {\r\n        if (!listings) {\r\n            response.sendError(HttpServletResponse.SC_NOT_FOUND);\r\n            return;\r\n        }\r\n        contentType = \"text/html;charset=UTF-8\";\r\n    } else {\r\n        if (useAcceptRanges) {\r\n            response.setHeader(\"Accept-Ranges\", \"bytes\");\r\n        }\r\n        ranges = parseRange(request, response, cacheEntry.attributes);\r\n        response.setHeader(\"ETag\", cacheEntry.attributes.getETag());\r\n        response.setHeader(\"Last-Modified\", cacheEntry.attributes.getLastModifiedHttp());\r\n        contentLength = cacheEntry.attributes.getContentLength();\r\n        if (contentLength == 0L) {\r\n            content = false;\r\n        }\r\n    }\r\n    ServletOutputStream ostream = null;\r\n    PrintWriter writer = null;\r\n    if (content) {\r\n        try {\r\n            ostream = response.getOutputStream();\r\n        } catch (IllegalStateException e) {\r\n            if ((contentType == null) || (contentType.startsWith(\"text\")) || (contentType.startsWith(\"xml\"))) {\r\n                writer = response.getWriter();\r\n            } else {\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    if ((cacheEntry.context != null) || (((ranges == null) || (ranges.isEmpty())) && (request.getHeader(\"Range\") == null)) || (ranges == FULL)) {\r\n        if (contentType != null) {\r\n            if (debug > 0)\r\n                log(\"DefaultServlet.serveFile:  contentType='\" + contentType + \"'\");\r\n            response.setContentType(contentType);\r\n        }\r\n        if ((cacheEntry.resource != null) && (contentLength >= 0)) {\r\n            if (debug > 0)\r\n                log(\"DefaultServlet.serveFile:  contentLength=\" + contentLength);\r\n            if (contentLength < Integer.MAX_VALUE) {\r\n                response.setContentLength((int) contentLength);\r\n            } else {\r\n                response.setHeader(\"content-length\", \"\" + contentLength);\r\n            }\r\n        }\r\n        InputStream renderResult = null;\r\n        if (cacheEntry.context != null) {\r\n            if (content) {\r\n                renderResult = render(request.getContextPath(), cacheEntry, proxyDirContext);\r\n            }\r\n        }\r\n        if (content) {\r\n            try {\r\n                response.setBufferSize(output);\r\n            } catch (IllegalStateException e) {\r\n            }\r\n            if (ostream != null) {\r\n                if (!checkSendfile(request, response, cacheEntry, contentLength, null))\r\n                    copy(cacheEntry, renderResult, ostream);\r\n            } else {\r\n                copy(cacheEntry, renderResult, writer);\r\n            }\r\n        }\r\n    } else {\r\n        if ((ranges == null) || (ranges.isEmpty()))\r\n            return;\r\n        if (maxHeaderRangeItems >= 0 && ranges.size() > maxHeaderRangeItems) {\r\n            response.sendError(HttpServletResponse.SC_FORBIDDEN);\r\n            return;\r\n        }\r\n        response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);\r\n        if (ranges.size() == 1) {\r\n            Range range = ranges.get(0);\r\n            response.addHeader(\"Content-Range\", \"bytes \" + range.start + \"-\" + range.end + \"/\" + range.length);\r\n            long length = range.end - range.start + 1;\r\n            if (length < Integer.MAX_VALUE) {\r\n                response.setContentLength((int) length);\r\n            } else {\r\n                response.setHeader(\"content-length\", \"\" + length);\r\n            }\r\n            if (contentType != null) {\r\n                if (debug > 0)\r\n                    log(\"DefaultServlet.serveFile:  contentType='\" + contentType + \"'\");\r\n                response.setContentType(contentType);\r\n            }\r\n            if (content) {\r\n                try {\r\n                    response.setBufferSize(output);\r\n                } catch (IllegalStateException e) {\r\n                }\r\n                if (ostream != null) {\r\n                    if (!checkSendfile(request, response, cacheEntry, range.end - range.start + 1, range))\r\n                        copy(cacheEntry, ostream, range);\r\n                } else {\r\n                    copy(cacheEntry, writer, range);\r\n                }\r\n            }\r\n        } else {\r\n            response.setContentType(\"multipart/byteranges; boundary=\" + mimeSeparation);\r\n            if (content) {\r\n                try {\r\n                    response.setBufferSize(output);\r\n                } catch (IllegalStateException e) {\r\n                }\r\n                if (ostream != null) {\r\n                    copy(cacheEntry, ostream, ranges.iterator(), contentType);\r\n                } else {\r\n                    copy(cacheEntry, writer, ranges.iterator(), contentType);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.appserv.server.util.PreprocessorUtil.init",
	"Comment": "initializes the preprocessor utility with the associated class namesarray arugment.",
	"Method": "boolean init(String[] ppClassNames){\r\n    if (ppClassNames != null) {\r\n        setupPreprocessor(ppClassNames);\r\n    }\r\n    return _preprocessorEnabled;\r\n}"
}, {
	"Path": "org.apache.catalina.security.SecurityUtil.isPackageProtectionEnabled",
	"Comment": "return the securitymanager only if security is enabled andpackage protection mechanism is enabled.",
	"Method": "boolean isPackageProtectionEnabled(){\r\n    if (packageDefinitionEnabled && Globals.IS_SECURITY_ENABLED) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.ByteArrayOutputStream.toByteArray",
	"Comment": "gets the curent contents of this byte stream as a byte array.the result is independent of this stream.",
	"Method": "byte[] toByteArray(){\r\n    int remaining = count;\r\n    if (remaining == 0) {\r\n        return EMPTY_BYTE_ARRAY;\r\n    }\r\n    byte[] newbuf = new byte[remaining];\r\n    int pos = 0;\r\n    for (int i = 0; i < buffers.size(); i++) {\r\n        byte[] buf = getBuffer(i);\r\n        int c = Math.min(buf.length, remaining);\r\n        System.arraycopy(buf, 0, newbuf, pos, c);\r\n        pos += c;\r\n        remaining -= c;\r\n        if (remaining == 0) {\r\n            break;\r\n        }\r\n    }\r\n    return newbuf;\r\n}"
}, {
	"Path": "org.glassfish.web.util.IntrospectionUtils.getURLClassLoader",
	"Comment": "construct a urlclassloader. will compile and work in jdk1.1 too.",
	"Method": "ClassLoader getURLClassLoader(URL urls,ClassLoader parent){\r\n    try {\r\n        Class<?> urlCL = Class.forName(\"java.net.URLClassLoader\");\r\n        Class<?>[] paramT = new Class[2];\r\n        paramT[0] = urls.getClass();\r\n        paramT[1] = ClassLoader.class;\r\n        Method m = findMethod(urlCL, \"newInstance\", paramT);\r\n        if (m == null)\r\n            return null;\r\n        ClassLoader cl = (ClassLoader) m.invoke(urlCL, new Object[] { urls, parent });\r\n        return cl;\r\n    } catch (ClassNotFoundException ex) {\r\n        return null;\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "test.TestBean.testA1",
	"Comment": "run test for cmp1.1 bean without flush after businessmethod. this method will fail at commit and the clientwill get a runtimeexception.",
	"Method": "void testA1(){\r\n    a1bean = a1Home.create(\"A1\");\r\n    a1bean.setName(\"A12345678901234567890\");\r\n}"
}, {
	"Path": "test.TestBean.testA2",
	"Comment": "run test for cmp2.x bean without flush after businessmethod. this method will fail at commit and the clientwill get a runtimeexception.",
	"Method": "void testA2(){\r\n    a2bean = a2Home.create(\"A2\");\r\n    a2bean.setName(\"A12345678901234567890\");\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.deploy.shared.InputJarArchive.exists",
	"Comment": "returns the existence of the given entry namethe file name must be relative to the root of the module.",
	"Method": "boolean exists(String name,boolean exists){\r\n    return jarFile != null;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.setMethod",
	"Comment": "set the http request method used for this request.used by fbl when the original request is restored aftersuccessful authentication.",
	"Method": "void setMethod(String method){\r\n    coyoteRequest.setMethod(method);\r\n}"
}, {
	"Path": "org.apache.naming.resources.BaseDirContext.removeFromEnvironment",
	"Comment": "removes an environment property from the environment of this context.",
	"Method": "Object removeFromEnvironment(String propName){\r\n    return env.remove(propName);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.adapter.AdminConsoleAdapter.getResourceBundle",
	"Comment": "this method returns the resource bundle for localized strings usedby the adminconsoleadapter.",
	"Method": "ResourceBundle getResourceBundle(Locale locale){\r\n    return ResourceBundle.getBundle(\"com.sun.enterprise.v3.admin.adapter.LocalStrings\", locale);\r\n}"
}, {
	"Path": "com.sun.appserv.web.cache.filter.CachingResponseWrapper.cacheResponse",
	"Comment": "called by dofilter to cache the response that was just sent out",
	"Method": "HttpCacheEntry cacheResponse(){\r\n    HttpCacheEntry entry = new HttpCacheEntry();\r\n    entry.responseHeaders = headers;\r\n    entry.dateHeaders = dateHeaders;\r\n    entry.cookies = cookies;\r\n    entry.contentLength = contentLength;\r\n    entry.contentType = contentType;\r\n    entry.locale = locale;\r\n    entry.statusCode = statusCode;\r\n    if (writer != null) {\r\n        writer.flush();\r\n    }\r\n    entry.bytes = ((cosw != null) ? cosw.getBytes() : EMPTY_BYTE_ARRAY);\r\n    return entry;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.configureAuthRealm",
	"Comment": "configures this virtual server with its authentication realm.checks if this virtual server specifies any authrealm property, andif so, ensures that its value identifies a valid realm.",
	"Method": "void configureAuthRealm(SecurityService securityService){\r\n    List<Property> properties = vsBean.getProperty();\r\n    if (properties != null && properties.size() > 0) {\r\n        for (Property p : properties) {\r\n            if (p != null && \"authRealm\".equals(p.getName())) {\r\n                authRealmName = p.getValue();\r\n                if (authRealmName != null) {\r\n                    AuthRealm realm = null;\r\n                    List<AuthRealm> rs = securityService.getAuthRealm();\r\n                    if (rs != null && rs.size() > 0) {\r\n                        for (AuthRealm r : rs) {\r\n                            if (r != null && r.getName().equals(authRealmName)) {\r\n                                realm = r;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (realm == null) {\r\n                        _logger.log(Level.SEVERE, LogFacade.INVALID_AUTH_REALM, new Object[] { getID(), authRealmName });\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.embed.impl.WebContainerImpl.getSniffers",
	"Comment": "returns the list of sniffers associated with this embedded container",
	"Method": "List<Sniffer> getSniffers(){\r\n    List<Sniffer> sniffers = new ArrayList<Sniffer>();\r\n    sniffers.add(habitat.<Sniffer>getService(Sniffer.class, \"web\"));\r\n    sniffers.add(habitat.<Sniffer>getService(Sniffer.class, \"weld\"));\r\n    Sniffer security = habitat.getService(Sniffer.class, \"Security\");\r\n    if (security != null) {\r\n        sniffers.add(security);\r\n    }\r\n    return sniffers;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmrFieldNameStartLowercase.runIndividualCmrTest",
	"Comment": "run an individual verifier test of a declated cmr field of the class",
	"Method": "boolean runIndividualCmrTest(Descriptor descriptor,RelationRoleDescriptor rrd,Class c,Result result){\r\n    return startWithLowercasedLetter(rrd.getCMRField(), result);\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutoDeployedFilesManager.getFilesForDeployment",
	"Comment": "compare the list of files with the current status infoand determine the files that need to be deployed",
	"Method": "File[] getFilesForDeployment(File[] latestFiles){\r\n    if (latestFiles == null)\r\n        return new File[0];\r\n    ArrayList<File> arrList = new ArrayList<File>();\r\n    for (File deployDirFile : latestFiles) {\r\n        if (FILE_NAMES_TO_IGNORE_FOR_AUTODEPLOY.contains(deployDirFile.getName())) {\r\n            if (deplLogger.isLoggable(Level.FINE)) {\r\n                deplLogger.fine(\"Skipping \" + deployDirFile.getAbsolutePath() + \" because its name is in the list of files to ignore\");\r\n            }\r\n            continue;\r\n        }\r\n        File statusFile = getStatusFile(deployDirFile);\r\n        if (!statusFile.exists() || deployDirFile.lastModified() != statusFile.lastModified()) {\r\n            if (deplLogger.isLoggable(Level.FINE)) {\r\n                deplLogger.fine(\"Including \" + deployDirFile.getAbsolutePath() + \" in candidate files for deployment\");\r\n            }\r\n            arrList.add(deployDirFile);\r\n        } else {\r\n            if (deplLogger.isLoggable(Level.FINE)) {\r\n                deplLogger.fine(\"Skipping \" + deployDirFile.getAbsolutePath() + \" its status file exists and the timestamps on the status file and the autodeployed file match\");\r\n            }\r\n        }\r\n    }\r\n    return arrList.toArray(new File[arrList.size()]);\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ValveBase.setNext",
	"Comment": "set the valve that follows this one in the pipeline it is part of.",
	"Method": "void setNext(Valve valve){\r\n    this.next = valve;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SenderReceiver.sending_request",
	"Comment": "pass the operation through to the currenttransaction class.",
	"Method": "void sending_request(int id,PropagationContextHolder holder){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        if (holder.value != null) {\r\n            _logger.log(Level.FINE, \"In sending_request\" + \":\" + id + \",\" + holder.value.current.otid.formatID);\r\n        } else {\r\n            _logger.log(Level.FINE, \"In sending_request\" + \":\" + id + \",\" + holder);\r\n        }\r\n    }\r\n    CurrentTransaction.sendingRequest(id, holder);\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        if (holder.value != null) {\r\n            _logger.log(Level.FINE, \"Out sending_request\" + \":\" + id + \",\" + holder.value.current.otid.formatID);\r\n        } else {\r\n            _logger.log(Level.FINE, \"Out sending_request\" + \":\" + id + \",\" + holder);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.addServlet",
	"Comment": "adds the given servlet instance with the given name and url patternsto this servlet context, and initializes it.",
	"Method": "ServletRegistration.Dynamic addServlet(String servletName,String className,ServletRegistration.Dynamic addServlet,String servletName,Servlet servlet,ServletRegistration.Dynamic addServlet,String servletName,Class<? extends Servlet> servletClass,ServletRegistration.Dynamic addServlet,String servletName,Servlet instance,Map<String, String> initParams,ServletRegistration.Dynamic addServlet,String servletName,Servlet servlet,Map<String, String> initParams,String urlPatterns){\r\n    if (isContextInitializedCalled) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.SERVLET_CONTEXT_ALREADY_INIT_EXCEPTION), new Object[] { \"addServlet\", getName() });\r\n        throw new IllegalStateException(msg);\r\n    }\r\n    if (servletName == null || servletName.length() == 0) {\r\n        throw new IllegalArgumentException(rb.getString(LogFacade.NULL_EMPTY_SERVLET_NAME_EXCEPTION));\r\n    }\r\n    if (servlet == null) {\r\n        throw new NullPointerException(rb.getString(LogFacade.NULL_SERVLET_INSTANCE_EXCEPTION));\r\n    }\r\n    if (servlet instanceof SingleThreadModel) {\r\n        throw new IllegalArgumentException(\"Servlet implements \" + SingleThreadModel.class.getName());\r\n    }\r\n    Container host = getParent();\r\n    if (host != null) {\r\n        for (Container child : host.findChildren()) {\r\n            if (child == this) {\r\n                continue;\r\n            }\r\n            if (((StandardContext) child).hasServlet(servlet)) {\r\n                return null;\r\n            }\r\n        }\r\n    }\r\n    synchronized (children) {\r\n        for (Map.Entry<String, Container> e : children.entrySet()) {\r\n            if (servletName.equals(e.getKey()) || servlet == ((StandardWrapper) e.getValue()).getServlet()) {\r\n                return null;\r\n            }\r\n        }\r\n        DynamicServletRegistrationImpl regis = (DynamicServletRegistrationImpl) servletRegisMap.get(servletName);\r\n        StandardWrapper wrapper = null;\r\n        if (regis == null) {\r\n            wrapper = (StandardWrapper) createWrapper();\r\n        } else {\r\n            wrapper = regis.getWrapper();\r\n        }\r\n        wrapper.setName(servletName);\r\n        wrapper.setServlet(servlet);\r\n        if (initParams != null) {\r\n            for (Map.Entry<String, String> e : initParams.entrySet()) {\r\n                wrapper.addInitParameter(e.getKey(), e.getValue());\r\n            }\r\n        }\r\n        addChild(wrapper, true, (null == regis));\r\n        if (null == regis) {\r\n            regis = (DynamicServletRegistrationImpl) servletRegisMap.get(servletName);\r\n        }\r\n        if (urlPatterns != null) {\r\n            for (String urlPattern : urlPatterns) {\r\n                addServletMapping(urlPattern, servletName, false);\r\n            }\r\n        }\r\n        return regis;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutoDeployer.setVerifierEnabled",
	"Comment": "sets whether descriptor verification should be requested duringautodeployments.",
	"Method": "void setVerifierEnabled(boolean verify){\r\n    this.verify = verify;\r\n}"
}, {
	"Path": "org.apache.catalina.session.PersistentManagerBase.setStore",
	"Comment": "set the store object which will manage persistent sessionstorage for this manager.",
	"Method": "void setStore(Store store){\r\n    this.store = store;\r\n    store.setManager(this);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getOverride",
	"Comment": "return the defaultcontext override flag for this web application.",
	"Method": "boolean getOverride(){\r\n    return override;\r\n}"
}, {
	"Path": "org.apache.catalina.session.ManagerBase.add",
	"Comment": "add this session to the set of active sessions for this manager.",
	"Method": "void add(Session session){\r\n    sessions.put(session.getIdInternal(), session);\r\n    int size = sessions.size();\r\n    if (size > maxActive) {\r\n        synchronized (maxActiveUpdateLock) {\r\n            if (size > maxActive) {\r\n                maxActive = size;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.cci.RecordExistence.check",
	"Comment": "test if a javax.resource.cci.record implementation has been provided in the rar file",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (isCCIImplemented(descriptor, result)) {\r\n        findImplementorOf(descriptor, \"javax.resource.cci.Record\", result);\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.cci.InteractionExistence.notapp\", \"NotApplicable : The CCI interfaces do not seem to be implemented by this resource adapter\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.getDebug",
	"Comment": "return the debugging detail level of our currently enabled logger.",
	"Method": "int getDebug(){\r\n    return (0);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getFacade",
	"Comment": "return the facade associated with this applicationcontext.",
	"Method": "ServletContext getFacade(){\r\n    return this.facade;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setSessionCookieName",
	"Comment": "sets the name that will be assigned to any session trackingcookies created on behalf of this context",
	"Method": "void setSessionCookieName(String sessionCookieName){\r\n    this.sessionCookieName = sessionCookieName;\r\n    sessionCookieNameInitialized = true;\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.DeploymentContextImpl.getTransformers",
	"Comment": "returns the list of transformers registered to this context.",
	"Method": "List<ClassFileTransformer> getTransformers(){\r\n    return transformers;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.resources.AbstractResource.getAuthenticatedUser",
	"Comment": "this method will return the authenticated user associated with the current request.",
	"Method": "String getAuthenticatedUser(){\r\n    if (authenticatedUser == null) {\r\n        Subject s = getSubject();\r\n        if (s != null) {\r\n            List<String> list = SubjectUtil.getUsernamesFromSubject(s);\r\n            if (list != null) {\r\n                authenticatedUser = list.get(0);\r\n            }\r\n        }\r\n    }\r\n    return authenticatedUser;\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutoDeployer.deployAll",
	"Comment": "do deployment for all the deployable components in autodeploydir dir.",
	"Method": "void deployAll(File autoDeployDir,boolean includeSubDir){\r\n    if (directoryScanner == null) {\r\n        directoryScanner = new AutoDeployDirectoryScanner();\r\n    }\r\n    File[] files = null;\r\n    files = directoryScanner.getAllDeployableModules(autoDeployDir, includeSubDir);\r\n    if (files != null && files.length > 0) {\r\n        deplLogger.fine(\"Deployable files: \" + Arrays.toString(files));\r\n        for (int i = 0; ((i < files.length) && !cancelDeployment); i++) {\r\n            boolean okToRecordResult = true;\r\n            try {\r\n                okToRecordResult = (deploy(files[i], autoDeployDir) != AutodeploymentStatus.PENDING);\r\n            } catch (AutoDeploymentException ae) {\r\n            } finally {\r\n                if (renameOnSuccess && okToRecordResult) {\r\n                    deplLogger.fine(\"Reporting deployed entity \" + files[i].getAbsolutePath());\r\n                    directoryScanner.deployedEntity(autoDeployDir, files[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "demo.model.GraphBean.processGraphEvent",
	"Comment": "processes the event queued on the graph component when a particularnode in the tree control is to be expanded or collapsed.",
	"Method": "void processGraphEvent(ActionEvent event){\r\n    if (log.isTraceEnabled()) {\r\n        log.trace(\"TRACE: GraphBean.processGraphEvent \");\r\n    }\r\n    Graph graph = null;\r\n    GraphComponent component = (GraphComponent) event.getSource();\r\n    String path = (String) component.getAttributes().get(\"path\");\r\n    graph = (Graph) component.getValue();\r\n    if (graph == null) {\r\n        if (log.isErrorEnabled()) {\r\n            log.error(\"ERROR: Graph could not located in scope \");\r\n        }\r\n    }\r\n    Node node = graph.findNode(path);\r\n    if (node == null) {\r\n        if (log.isErrorEnabled()) {\r\n            log.error(\"ERROR: Node \" + path + \"could not be located. \");\r\n        }\r\n        return;\r\n    }\r\n    boolean current = node.isExpanded();\r\n    node.setExpanded(!current);\r\n    if (!current) {\r\n        Node parent = node.getParent();\r\n        if (parent != null) {\r\n            Iterator kids = parent.getChildren();\r\n            while (kids.hasNext()) {\r\n                Node kid = (Node) kids.next();\r\n                if (kid != node) {\r\n                    kid.setExpanded(false);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "components.renderkit.RepeaterRenderer.getColumnFooterCount",
	"Comment": "return the number of child components of type uicolumnare registered with the specified uidata componentand have a facet named footer.",
	"Method": "int getColumnFooterCount(UIData data){\r\n    int n = 0;\r\n    Iterator kids = data.getChildren().iterator();\r\n    while (kids.hasNext()) {\r\n        UIComponent kid = (UIComponent) kids.next();\r\n        if ((kid instanceof UIColumn) && (kid.getFacet(\"footer\") != null)) {\r\n            n++;\r\n        }\r\n    }\r\n    return (n);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.common.XMLActionReporter.writeActionReport",
	"Comment": "creates a new element representing the xml content describing anaction report.invokes itself recursively to capture informationabout any subactions.",
	"Method": "Element writeActionReport(Document owningDocument,ActionReporter report){\r\n    Element result = owningDocument.createElement(\"action-report\");\r\n    result.setAttribute(\"description\", report.actionDescription);\r\n    result.setAttribute(\"exit-code\", report.getActionExitCode().name());\r\n    if (exception != null) {\r\n        result.setAttribute(\"failure-cause\", exception.getLocalizedMessage());\r\n    }\r\n    writePart(result, report.getTopMessagePart(), null);\r\n    for (ActionReporter subReport : report.subActions) {\r\n        result.appendChild(writeActionReport(owningDocument, subReport));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.logger.LoggerBase.setVerbosityLevel",
	"Comment": "set the verbosity level of this logger.messages logged with ahigher verbosity than this level will be silently ignored.",
	"Method": "void setVerbosityLevel(String verbosity){\r\n    if (\"FATAL\".equalsIgnoreCase(verbosity))\r\n        this.verbosity = FATAL;\r\n    else if (\"ERROR\".equalsIgnoreCase(verbosity))\r\n        this.verbosity = ERROR;\r\n    else if (\"WARNING\".equalsIgnoreCase(verbosity))\r\n        this.verbosity = WARNING;\r\n    else if (\"INFORMATION\".equalsIgnoreCase(verbosity))\r\n        this.verbosity = INFORMATION;\r\n    else if (\"DEBUG\".equalsIgnoreCase(verbosity))\r\n        this.verbosity = DEBUG;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.ProgramOptions.updateOptions",
	"Comment": "update the program options based on the specifiedoptions from the command line.",
	"Method": "void updateOptions(ParameterMap newOptions){\r\n    if (options == null)\r\n        options = newOptions;\r\n    else {\r\n        for (Map.Entry<String, List<String>> e : newOptions.entrySet()) options.set(e.getKey(), e.getValue());\r\n    }\r\n    optionsSet = true;\r\n    String sport = options.getOne(PORT);\r\n    if (ok(sport)) {\r\n        String badPortMsg = strings.get(\"InvalidPortNumber\", sport);\r\n        try {\r\n            int port = Integer.parseInt(sport);\r\n            if (port < 1 || port > 65535)\r\n                throw new CommandException(badPortMsg);\r\n        } catch (NumberFormatException e) {\r\n            throw new CommandException(badPortMsg);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.loader.WebappLoader.setContainer",
	"Comment": "set the container with which this logger has been associated.",
	"Method": "void setContainer(Container container){\r\n    if ((this.container != null) && (this.container instanceof Context))\r\n        ((Context) this.container).removePropertyChangeListener(this);\r\n    Container oldContainer = this.container;\r\n    this.container = container;\r\n    support.firePropertyChange(\"container\", oldContainer, this.container);\r\n    if (this.container instanceof Context) {\r\n        setReloadable(((Context) this.container).getReloadable());\r\n        ((Context) this.container).addPropertyChangeListener(this);\r\n    }\r\n}"
}, {
	"Path": "examples.sfsb.TraderBean.ejbRemove",
	"Comment": "this method is required by the ejb specification,but is not used by this example.",
	"Method": "void ejbRemove(){\r\n    log(\"ejbRemove called\");\r\n}"
}, {
	"Path": "org.glassfish.webservices.WebServicesDeployer.getWebServiceDescriptors",
	"Comment": "return a set of all com.sun.enterprise.deployment.webservicedescriptors in the application.",
	"Method": "Set<WebService> getWebServiceDescriptors(Application app){\r\n    Set<WebService> webServiceDescriptors = new HashSet<WebService>();\r\n    for (BundleDescriptor next : app.getBundleDescriptors()) {\r\n        WebServicesDescriptor webServicesDesc = next.getWebServices();\r\n        webServiceDescriptors.addAll(webServicesDesc.getWebServices());\r\n    }\r\n    return webServiceDescriptors;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.ResourceAuth.check",
	"Comment": "resource authority exists test.must be container or servlet.",
	"Method": "Result check(WebBundleDescriptor descriptor){\r\n    Set resourceRefs;\r\n    ResourceReferenceDescriptor resrefDes;\r\n    Iterator itr;\r\n    String resAuth;\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    boolean oneFailed = false;\r\n    if (!descriptor.getResourceReferenceDescriptors().isEmpty()) {\r\n        resourceRefs = descriptor.getResourceReferenceDescriptors();\r\n        itr = resourceRefs.iterator();\r\n        while (itr.hasNext()) {\r\n            resrefDes = (ResourceReferenceDescriptor) itr.next();\r\n            resAuth = resrefDes.getAuthorization();\r\n            if (resAuth.equals(\"Application\") || resAuth.equals(\"Container\")) {\r\n                result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"Resource reference has valid authorization.\"));\r\n            } else {\r\n                oneFailed = true;\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Resource reference auth has to be either Container or Application.\"));\r\n            }\r\n        }\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"There are no resource references defined within the web archive [ {0} ]\", new Object[] { descriptor.getName() }));\r\n    }\r\n    if (oneFailed) {\r\n        result.setStatus(Result.FAILED);\r\n    } else {\r\n        result.setStatus(Result.PASSED);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.CLICommand.getUsage",
	"Comment": "get the usage text for the subcommand. this method shows the details forthe subcommand options but does not provide details about the command options.",
	"Method": "String getUsage(){\r\n    String usage;\r\n    if (commandModel != null && ok(usage = commandModel.getUsageText())) {\r\n        StringBuffer usageText = new StringBuffer();\r\n        usageText.append(strings.get(\"Usage\", strings.get(\"Usage.brief\", programOpts.getCommandName())));\r\n        usageText.append(\" \");\r\n        usageText.append(usage);\r\n        return usageText.toString();\r\n    } else {\r\n        return generateUsageText();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.incrementSessionVersion",
	"Comment": "increments the version of the given session, and stores it as arequest attribute, so it can later be included in a response cookie.",
	"Method": "void incrementSessionVersion(StandardSession ss,Context context){\r\n    if (ss == null || context == null) {\r\n        return;\r\n    }\r\n    String versionString = Long.toString(ss.incrementVersion());\r\n    Map<String, String> sessionVersions = getSessionVersionsRequestAttribute();\r\n    if (sessionVersions == null) {\r\n        sessionVersions = new HashMap<String, String>();\r\n        setAttribute(Globals.SESSION_VERSIONS_REQUEST_ATTRIBUTE, sessionVersions);\r\n    }\r\n    String path = context.getPath();\r\n    if (\"\".equals(path)) {\r\n        path = \"/\";\r\n    }\r\n    sessionVersions.put(path, versionString);\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.SingleSignOnEntry.getAuthType",
	"Comment": "gets the name of the authentication type originally used to authenticatethe user associated with the sso.",
	"Method": "String getAuthType(){\r\n    return authType;\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.PartItem.getContentType",
	"Comment": "returns the content type passed by the agent or null ifnot defined.",
	"Method": "String getContentType(){\r\n    return contentType;\r\n}"
}, {
	"Path": "org.apache.catalina.servlets.WebdavServlet.checkIfHeaders",
	"Comment": "check if the conditions specified in the optional if headers aresatisfied.",
	"Method": "boolean checkIfHeaders(HttpServletRequest request,HttpServletResponse response,ResourceAttributes resourceAttributes){\r\n    if (!super.checkIfHeaders(request, response, resourceAttributes))\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.beforeCompletion",
	"Comment": "informs the topcoordinator that the transaction is about to complete.the topcoordinator informs all synchronization objects registered withit that the transaction is about to complete and waits for all of thereplies before this operation completes.",
	"Method": "void beforeCompletion(){\r\n    if (root && nestingInfo != null && nestingInfo.numChildren() != 0) {\r\n        INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.UnfinishedSubtransactions, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    if (synchronizations != null) {\r\n        try {\r\n            if (!synchronizations.distributeBefore()) {\r\n                rollbackOnly = true;\r\n            }\r\n        } catch (RuntimeException ex) {\r\n            rollbackOnly = true;\r\n            throw ex;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.startDocument",
	"Comment": "process notification of the beginning of the document being reached.",
	"Method": "void startDocument(){\r\n    if (saxLog.isLoggable(Level.FINE)) {\r\n        saxLog.log(Level.FINE, \"startDocument()\");\r\n    }\r\n    configure();\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.getContextClass",
	"Comment": "return the java class name of the context implementation classfor new web applications.",
	"Method": "String getContextClass(){\r\n    return (this.contextClass);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteRestAdminCommand.followRedirection",
	"Comment": "creates a new httpconnectoraddress corresponding to the location to whichan earlier request was redirected.if the new protocol is https then the httpconnectoraddress secure settingis turned on.",
	"Method": "HttpConnectorAddress followRedirection(HttpConnectorAddress originalAddr,String redirection){\r\n    final URL url = new URL(redirection);\r\n    final boolean useSecure = (url.getProtocol().equalsIgnoreCase(\"https\"));\r\n    HttpConnectorAddress hca = new HttpConnectorAddress(url.getHost(), url.getPort(), useSecure, originalAddr.getPath(), originalAddr.getSSLSocketFactory());\r\n    hca.setInteractive(interactive);\r\n    return hca;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.Verifier.log",
	"Comment": "this method is used to log exception messges in the error vector ofresultmanager object.",
	"Method": "void log(String message,Exception e){\r\n    if (message == null) {\r\n        message = \"\";\r\n    }\r\n    LogRecord logRecord = new LogRecord(Level.SEVERE, message);\r\n    logRecord.setThrown(e);\r\n    verifierFrameworkContext.getResultManager().log(logRecord);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.SessionTracker.sessionEvent",
	"Comment": "processes the given session event, by unregistering this sessiontrackeras a session listener from the session that is the source of the event,and by decrementing the counter of currently tracked sessions.",
	"Method": "void sessionEvent(SessionEvent event){\r\n    if (!Session.SESSION_DESTROYED_EVENT.equals(event.getType())) {\r\n        return;\r\n    }\r\n    Session session = event.getSession();\r\n    synchronized (this) {\r\n        if (session.getIdInternal() != null && session.getIdInternal().equals(trackedSessionId) && session.getManager() != null && session.getManager().getContainer() != null && contextNames.contains(session.getManager().getContainer().getName())) {\r\n            count--;\r\n            if (count == 0) {\r\n                trackedSessionId = null;\r\n                if (response != null) {\r\n                    response.removeSessionCookies();\r\n                }\r\n            }\r\n        }\r\n        session.removeSessionListener(this);\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.endElement",
	"Comment": "process notification of the end of an xml element being reached.",
	"Method": "void endElement(String namespaceURI,String localName,String qName){\r\n    boolean debug = log.isLoggable(Level.FINE);\r\n    if (debug) {\r\n        if (saxLog.isLoggable(Level.FINE)) {\r\n            saxLog.log(Level.FINE, \"endElement(\" + namespaceURI + \",\" + localName + \",\" + qName + \")\");\r\n        }\r\n        log.log(Level.FINE, \"  match='\" + match + \"'\");\r\n        log.log(Level.FINE, \"  bodyText='\" + bodyText + \"'\");\r\n    }\r\n    bodyText = updateBodyText(bodyText);\r\n    String name = localName;\r\n    if ((name == null) || (name.length() < 1)) {\r\n        name = qName;\r\n    }\r\n    List<Rule> rules = matches.pop();\r\n    if ((rules != null) && (rules.size() > 0)) {\r\n        String bodyText = this.bodyText.toString();\r\n        for (int i = 0; i < rules.size(); i++) {\r\n            try {\r\n                Rule rule = rules.get(i);\r\n                if (debug) {\r\n                    log.log(Level.FINE, \"  Fire body() for \" + rule);\r\n                }\r\n                rule.body(namespaceURI, name, bodyText);\r\n            } catch (Exception e) {\r\n                log.log(Level.SEVERE, LogFacade.BODY_EVENT_EXCEPTION, e);\r\n                throw createSAXException(e);\r\n            } catch (Error e) {\r\n                log.log(Level.SEVERE, LogFacade.BODY_EVENT_ERROR, e);\r\n                throw e;\r\n            }\r\n        }\r\n    } else {\r\n        if (debug) {\r\n            log.log(Level.FINE, \"  No rules found matching '\" + match + \"'.\");\r\n        }\r\n        if (rulesValidation) {\r\n            log.log(Level.WARNING, LogFacade.NO_RULES_FOUND_MATCHING_EXCEPTION, match);\r\n        }\r\n    }\r\n    bodyText = bodyTexts.pop();\r\n    if (debug) {\r\n        log.log(Level.FINE, \"  Popping body text '\" + bodyText.toString() + \"'\");\r\n    }\r\n    if (rules != null) {\r\n        for (int i = 0; i < rules.size(); i++) {\r\n            int j = (rules.size() - i) - 1;\r\n            try {\r\n                Rule rule = rules.get(j);\r\n                if (debug) {\r\n                    log.log(Level.FINE, neutralizeForLog(\"  Fire end() for \" + rule));\r\n                }\r\n                rule.end(namespaceURI, name);\r\n            } catch (Exception e) {\r\n                log.log(Level.SEVERE, LogFacade.END_EVENT_EXCEPTION, e);\r\n                throw createSAXException(e);\r\n            } catch (Error e) {\r\n                log.log(Level.SEVERE, LogFacade.END_EVENT_ERROR, e);\r\n                throw e;\r\n            }\r\n        }\r\n    }\r\n    int slash = match.lastIndexOf('/');\r\n    if (slash >= 0) {\r\n        match = match.substring(0, slash);\r\n    } else {\r\n        match = \"\";\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.resources.WARDirContext.release",
	"Comment": "release any resources allocated for this directory context.",
	"Method": "void release(){\r\n    entries = null;\r\n    if (base != null) {\r\n        try {\r\n            base.close();\r\n        } catch (IOException e) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.EXCEPTION_CLOSING_WAR), base.getName());\r\n            log.log(Level.WARNING, msg, e);\r\n        }\r\n    }\r\n    base = null;\r\n    super.release();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentImpl.rollback",
	"Comment": "rolls back the changes performed under the current transaction.this operation can only be called if there is a terminator object available.",
	"Method": "void rollback(){\r\n    ControlImpl controlImpl = CurrentTransaction.getCurrent();\r\n    if (controlImpl == null) {\r\n        NoTransaction exc = new NoTransaction();\r\n        throw exc;\r\n    }\r\n    int active = 1;\r\n    if (!controlImpl.representsRemoteControl()) {\r\n        StatusHolder status = new StatusHolder();\r\n        controlImpl.getLocalTID(status);\r\n        if (status.value != Status.StatusActive) {\r\n            CurrentTransaction.endCurrent(true);\r\n            if (status.value == Status.StatusRolledBack) {\r\n                return;\r\n            }\r\n            INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.Completed, CompletionStatus.COMPLETED_NO);\r\n            throw exc;\r\n        }\r\n        active = controlImpl.numAssociated();\r\n    }\r\n    if ((active != 1) || (controlImpl.isOutgoing())) {\r\n        INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.DeferredActivities, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    } else {\r\n        Terminator term = null;\r\n        if (Configuration.isLocalFactory()) {\r\n            try {\r\n                term = controlImpl.get_localTerminator();\r\n            } catch (Unavailable exc) {\r\n                NO_PERMISSION ex2 = new NO_PERMISSION(0, CompletionStatus.COMPLETED_NO);\r\n                throw ex2;\r\n            }\r\n        } else {\r\n            try {\r\n                term = controlImpl.get_terminator();\r\n            } catch (Unavailable exc) {\r\n                NO_PERMISSION ex2 = new NO_PERMISSION(0, CompletionStatus.COMPLETED_NO);\r\n                throw ex2;\r\n            }\r\n            try {\r\n                if (Configuration.getProxyChecker().isProxy(term))\r\n                    CurrentTransaction.endCurrent(true);\r\n            } catch (Throwable exc) {\r\n            }\r\n        }\r\n        try {\r\n            term.rollback();\r\n        } catch (TRANSACTION_ROLLEDBACK e) {\r\n            CurrentTransaction.endCurrent(true);\r\n        }\r\n        controlImpl.destroy();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.FormAuthenticator.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (this.info);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.DefaultTransactionService.createPOAs",
	"Comment": "creates the poa objects which are used for objects within the jts.",
	"Method": "void createPOAs(){\r\n    POA rootPOA = (POA) orb.resolve_initial_references(\"RootPOA\");\r\n    POA CRpoa = null;\r\n    if (recoverable) {\r\n        Policy[] tpolicy = new Policy[2];\r\n        tpolicy[0] = rootPOA.create_lifespan_policy(LifespanPolicyValue.PERSISTENT);\r\n        tpolicy[1] = rootPOA.create_request_processing_policy(RequestProcessingPolicyValue.USE_SERVANT_MANAGER);\r\n        CRpoa = rootPOA.create_POA(\"com.sun.jts.CosTransactions.CoordinatorResourcePOA\", null, tpolicy);\r\n        CoordinatorResourceServantActivator crsa = new CoordinatorResourceServantActivator(orb);\r\n        CRpoa.set_servant_manager(crsa);\r\n    } else\r\n        CRpoa = rootPOA;\r\n    Configuration.setPOA(\"CoordinatorResource\", CRpoa);\r\n    POA RCpoa = null;\r\n    if (recoverable) {\r\n        Policy[] tpolicy = new Policy[2];\r\n        tpolicy[0] = rootPOA.create_lifespan_policy(LifespanPolicyValue.PERSISTENT);\r\n        tpolicy[1] = rootPOA.create_request_processing_policy(RequestProcessingPolicyValue.USE_SERVANT_MANAGER);\r\n        RCpoa = rootPOA.create_POA(\"com.sun.jts.CosTransactions.RecoveryCoordinatorPOA\", null, tpolicy);\r\n        RecoveryCoordinatorServantActivator rcsa = new RecoveryCoordinatorServantActivator(orb);\r\n        RCpoa.set_servant_manager(rcsa);\r\n    } else\r\n        RCpoa = rootPOA;\r\n    Configuration.setPOA(\"RecoveryCoordinator\", RCpoa);\r\n    POA Cpoa = rootPOA.create_POA(\"CoordinatorPOA\", null, null);\r\n    Configuration.setPOA(\"Coordinator\", Cpoa);\r\n    Configuration.setPOA(\"transient\", rootPOA);\r\n    CRpoa.the_POAManager().activate();\r\n    RCpoa.the_POAManager().activate();\r\n    Cpoa.the_POAManager().activate();\r\n    rootPOA.the_POAManager().activate();\r\n    poasCreated = true;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.combineWebComponentDescriptor",
	"Comment": "this method combines descriptor except urlpattern and addto current bundle descriptor if necessary.it returns the web component descriptor in the current bundle descriptor.",
	"Method": "WebComponentDescriptor combineWebComponentDescriptor(WebComponentDescriptor webComponentDescriptor){\r\n    WebComponentDescriptor resultDesc = null;\r\n    String name = webComponentDescriptor.getCanonicalName();\r\n    WebComponentDescriptor webCompDesc = getWebComponentByCanonicalName(name);\r\n    if (webCompDesc != null) {\r\n        resultDesc = webCompDesc;\r\n        if (!webCompDesc.isConflict(webComponentDescriptor, true)) {\r\n            webCompDesc.add(webComponentDescriptor, false, false);\r\n        }\r\n        String implFile = webCompDesc.getWebComponentImplementation();\r\n        if (resultDesc.isConflict() && (implFile == null || implFile.length() == 0)) {\r\n            throw new IllegalArgumentException(localStrings.getLocalString(\"web.deployment.exceptionconflictwebcompwithoutimpl\", \"Two or more web fragments define the same Servlet with conflicting implementation class names that are not overridden by the web.xml\"));\r\n        }\r\n        if (resultDesc.getConflictedInitParameterNames().size() > 0) {\r\n            throw new IllegalArgumentException(localStrings.getLocalString(\"web.deployment.exceptionconflictwebcompinitparam\", \"Two or more web fragments define the same Servlet with conflicting init param that are not overridden by the web.xml\"));\r\n        }\r\n    } else {\r\n        resultDesc = webComponentDescriptor;\r\n        if (resultDesc.isConflict()) {\r\n            throw new IllegalArgumentException(localStrings.getLocalString(\"web.deployment.exceptionconflictwebcomp\", \"One or more web fragments define the same Servlet in a conflicting way, and the Servlet is not defined in web.xml\"));\r\n        } else {\r\n            this.getWebComponentDescriptors().add(resultDesc);\r\n        }\r\n    }\r\n    return resultDesc;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.setInitParameter",
	"Comment": "sets the init parameter with the given name and valueon this servlet.",
	"Method": "boolean setInitParameter(String name,String value,boolean override){\r\n    if (null == name || null == value) {\r\n        throw new IllegalArgumentException(\"Null servlet init parameter name or value\");\r\n    }\r\n    synchronized (parameters) {\r\n        if (override || !parameters.containsKey(name)) {\r\n            parameters.put(name, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.DigestAuthenticator.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (info);\r\n}"
}, {
	"Path": "org.apache.catalina.session.ManagerBase.setDistributable",
	"Comment": "set the distributable flag for the sessions supported by thismanager.if this flag is set, all user data objects added tosessions associated with this manager must implement serializable.",
	"Method": "void setDistributable(boolean distributable){\r\n    boolean oldDistributable = this.distributable;\r\n    this.distributable = distributable;\r\n    support.firePropertyChange(\"distributable\", Boolean.valueOf(oldDistributable), Boolean.valueOf(this.distributable));\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.mbeanapi.config.ClusterLifecycleTest.getOptionalParameters",
	"Comment": "that number here for each value provided through properties system prop",
	"Method": "Map getOptionalParameters(int instanceNum){\r\n    final Map properties = new HashMap();\r\n    final String props = System.getProperty(\"PROPERTIES\");\r\n    if (props == null)\r\n        return null;\r\n    final String[] specs = props.split(\":\");\r\n    String key, value;\r\n    for (int i = 0; i < specs.length; i++) {\r\n        key = specs[i].substring(0, specs[i].indexOf(\"=\", 0));\r\n        value = specs[i].substring(specs[i].indexOf(\"=\") + 1, specs[i].length());\r\n        key = getLegalKey(key);\r\n        if (key != null) {\r\n            properties.put(key, \"\" + (Integer.parseInt(value) + instanceNum));\r\n        } else {\r\n            throw new Exception(\"PROPERTIES:property key did not match legal key\");\r\n        }\r\n    }\r\n    System.out.println(properties.toString());\r\n    return properties;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Rule.getNamespaceURI",
	"Comment": "return the namespace uri for which this rule is relevant, if any.",
	"Method": "String getNamespaceURI(){\r\n    return (this.namespaceURI);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SenderReceiver.sending_reply",
	"Comment": "pass the operation through to the currenttransaction class.",
	"Method": "void sending_reply(int id,PropagationContextHolder holder){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        if (holder.value != null) {\r\n            _logger.log(Level.FINE, \"In sending_reply\" + \":\" + id + \",\" + holder.value.current.otid.formatID);\r\n        } else {\r\n            _logger.log(Level.FINE, \"In sending_reply\" + \":\" + id + \",\" + holder);\r\n        }\r\n    }\r\n    CurrentTransaction.sendingReply(id, holder);\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        if (holder.value != null) {\r\n            _logger.log(Level.FINE, \"Out sending_reply\" + \":\" + id + \",\" + holder.value.current.otid.formatID);\r\n        } else {\r\n            _logger.log(Level.FINE, \"Out sending_reply\" + \":\" + id + \",\" + holder);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationFilterConfig.setFilterDef",
	"Comment": "set the filter definition we are configured for.this has the sideeffect of instantiating an instance of the corresponding filter class.",
	"Method": "void setFilterDef(FilterDef filterDef){\r\n    this.filterDef = filterDef;\r\n    if (filterDef == null) {\r\n        if (this.filter != null) {\r\n            if (SecurityUtil.executeUnderSubjectDoAs()) {\r\n                try {\r\n                    SecurityUtil.doAsPrivilege(\"destroy\", filter);\r\n                    SecurityUtil.remove(filter);\r\n                } catch (java.lang.Exception ex) {\r\n                    String msg = rb.getString(LogFacade.DO_AS_PRIVILEGE);\r\n                    log.log(Level.SEVERE, msg, ex);\r\n                }\r\n            } else {\r\n                filter.destroy();\r\n            }\r\n        }\r\n        this.filter = null;\r\n    } else {\r\n        filter = filterDef.getFilter();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.versioning.VersioningUtilsTest.testIsVersionIdentifier",
	"Comment": "test of isversionidentifier method, of class versioningutils.",
	"Method": "void testIsVersionIdentifier(){\r\n    assertEquals(false, VersioningUtils.isVersionIdentifier(APPLICATION_NAME + \":*\"));\r\n    assertEquals(false, VersioningUtils.isVersionIdentifier(APPLICATION_NAME + \":BETA*\"));\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.removeValve",
	"Comment": "removes the given valve from the currently active pipeline, keeping thevalve that is not currently active in sync.",
	"Method": "void removeValve(GlassFishValve valve){\r\n    super.removeValve(valve);\r\n    if (pipeline == vsPipeline) {\r\n        origPipeline.removeValve(valve);\r\n    } else {\r\n        vsPipeline.removeValve(valve);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.JobManagerService.reapCompletedJobs",
	"Comment": "this method will look for completed jobs from the jobs.xmlfiles and load the information in a local datastructure forfaster access",
	"Method": "void reapCompletedJobs(File file){\r\n    if (file != null && file.exists()) {\r\n        JobInfos jobInfos = getCompletedJobs(file);\r\n        if (jobInfos != null) {\r\n            for (JobInfo jobInfo : jobInfos.getJobInfoList()) {\r\n                addToCompletedJobs(new CompletedJob(jobInfo.jobId, jobInfo.commandCompletionDate, jobInfo.getJobsFile()));\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.setName",
	"Comment": "set the canonical, fully qualified, name of the virtual hostthis container represents.",
	"Method": "void setName(String name){\r\n    if (name == null)\r\n        throw new IllegalArgumentException(rb.getString(LogFacade.HOST_NAME_REQUIRED_EXCEPTION));\r\n    String oldName = this.name;\r\n    this.name = name;\r\n    support.firePropertyChange(\"name\", oldName, this.name);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.remote.ClientCookieStore.store",
	"Comment": "store the cookies in the cookiestore to the provided location.this method will overwrite the contents of the target file.",
	"Method": "void store(){\r\n    PrintWriter out = null;\r\n    if (!cookieStoreFile.getParentFile().exists() && !cookieStoreFile.getParentFile().mkdirs()) {\r\n        throw new IOException(\"Unable to create directory: \" + cookieStoreFile.toString());\r\n    }\r\n    out = new PrintWriter(new BufferedWriter(new FileWriter(cookieStoreFile)));\r\n    out.println(CACHE_COMMENT);\r\n    for (URI uri : this.getURIs()) {\r\n        for (HttpCookie cookie : this.get(uri)) {\r\n            if (cookie.getMaxAge() < 1 || cookie.getDiscard())\r\n                continue;\r\n            StringBuilder sb = new StringBuilder();\r\n            sb.append(cookie.getName()).append(\"=\").append(cookie.getValue());\r\n            if (cookie.getPath() != null) {\r\n                sb.append(\"; Path=\").append(cookie.getPath());\r\n            }\r\n            if (cookie.getDomain() != null) {\r\n                sb.append(\"; Domain=\").append(cookie.getDomain());\r\n            }\r\n            if (cookie.getComment() != null) {\r\n                sb.append(\"; Comment=\").append(cookie.getComment());\r\n            }\r\n            if (cookie.getCommentURL() != null) {\r\n                sb.append(\"; CommentURL=\\\"\").append(cookie.getCommentURL()).append(\"\\\"\");\r\n            }\r\n            sb.append(\"; Max-Age=\").append(cookie.getMaxAge());\r\n            if (cookie.getPortlist() != null) {\r\n                sb.append(\"; Port=\\\"\").append(cookie.getPortlist()).append(\"\\\"\");\r\n            }\r\n            sb.append(\"; Version=\").append(cookie.getVersion());\r\n            out.println(sb);\r\n        }\r\n    }\r\n    out.close();\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.config.AMXConfigImpl.translateResult",
	"Comment": "convert results that contain local configbeanproxy into objectnames.ignore other items, passing through unchanged.",
	"Method": "Object translateResult(Object result){\r\n    if (result instanceof String)\r\n        return result;\r\n    Object out = result;\r\n    if (result instanceof ConfigBeanProxy) {\r\n        out = getObjectName((ConfigBeanProxy) result);\r\n    } else if (result instanceof Collection) {\r\n        final Collection<Object> c = (Collection) result;\r\n        final Collection<Object> translated = new ArrayList<Object>();\r\n        for (final Object item : c) {\r\n            translated.add(translateResult(item));\r\n        }\r\n        if (result instanceof Set) {\r\n            out = new HashSet<Object>(translated);\r\n        } else if (result instanceof AbstractQueue) {\r\n            out = new LinkedBlockingDeque(translated);\r\n        } else {\r\n            out = translated;\r\n        }\r\n    } else if (result instanceof Map) {\r\n        final Map resultMap = (Map) result;\r\n        Map outMap = new HashMap();\r\n        for (final Object meo : resultMap.entrySet()) {\r\n            Map.Entry me = (Map.Entry) meo;\r\n            outMap.put(translateResult(me.getKey()), translateResult(me.getValue()));\r\n        }\r\n        out = outMap;\r\n    } else if (result.getClass().isArray()) {\r\n        final Class<?> componentType = result.getClass().getComponentType();\r\n        if (ConfigBeanProxy.class.isAssignableFrom(componentType)) {\r\n            final Object[] items = (Object[]) result;\r\n            final ObjectName[] objectNames = new ObjectName[items.length];\r\n            for (int i = 0; i < items.length; ++i) {\r\n                objectNames[i] = getObjectName((ConfigBeanProxy) items[i]);\r\n            }\r\n            out = objectNames;\r\n        }\r\n    }\r\n    return out;\r\n}"
}, {
	"Path": "com.sun.enterprise.util.Utility.lookupObject",
	"Comment": "this is a convenience method to lookup a remote object by name withinthe naming context.",
	"Method": "java.rmi.Remote lookupObject(String publishedName,java.lang.Class anInterface){\r\n    Context ic = new InitialContext();\r\n    java.lang.Object objRef = ic.lookup(publishedName);\r\n    return (java.rmi.Remote) PortableRemoteObject.narrow(objRef, anInterface);\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.CompositeResource.badRequest",
	"Comment": "convenience methods for throwing common webapp exceptions",
	"Method": "Response badRequest(ResponseBody rb,String message,Response badRequest,ResponseBody rb,WebApplicationException badRequest,Throwable cause,WebApplicationException badRequest,String message){\r\n    return new WebApplicationException(Response.status(Status.BAD_REQUEST).entity(message).build());\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteAdminCommand.executeCommand",
	"Comment": "run the command using the specified arguments.return the output of the command.",
	"Method": "String executeCommand(ParameterMap opts){\r\n    getCommandModel();\r\n    options = new ParameterMap();\r\n    for (Map.Entry<String, List<String>> o : opts.entrySet()) {\r\n        String key = o.getKey();\r\n        List<String> value = o.getValue();\r\n        options.set(key.toLowerCase(Locale.ENGLISH), value);\r\n    }\r\n    operands = options.get(\"default\");\r\n    try {\r\n        initializeDoUpload();\r\n        if (doUpload) {\r\n            outboundPayload = PayloadImpl.Outbound.newInstance();\r\n        }\r\n        StringBuilder uriString = getCommandURI();\r\n        ParamModel operandParam = null;\r\n        for (ParamModel opt : commandModel.getParameters()) {\r\n            if (opt.getParam().primary()) {\r\n                operandParam = opt;\r\n                continue;\r\n            }\r\n            String paramName = opt.getName();\r\n            List<String> paramValues = new ArrayList<String>(options.get(paramName.toLowerCase(Locale.ENGLISH)));\r\n            if (!opt.getParam().alias().isEmpty() && !paramName.equalsIgnoreCase(opt.getParam().alias())) {\r\n                paramValues.addAll(options.get(opt.getParam().alias().toLowerCase(Locale.ENGLISH)));\r\n            }\r\n            if (!opt.getParam().multiple() && paramValues.size() > 1) {\r\n                throw new CommandException(strings.get(\"tooManyOptions\", paramName));\r\n            }\r\n            if (paramValues.isEmpty()) {\r\n                String envValue = getFromEnvironment(paramName);\r\n                if (envValue != null) {\r\n                    paramValues.add(envValue);\r\n                }\r\n            }\r\n            if (paramValues.isEmpty()) {\r\n                if (!opt.getParam().optional()) {\r\n                    throw new CommandException(strings.get(\"missingOption\", paramName));\r\n                }\r\n                continue;\r\n            }\r\n            for (String paramValue : paramValues) {\r\n                if (opt.getType() == File.class || opt.getType() == File[].class) {\r\n                    addFileOption(uriString, paramName, paramValue);\r\n                } else if (opt.getParam().password()) {\r\n                    addPasswordOption(uriString, paramName, paramValue);\r\n                } else {\r\n                    addStringOption(uriString, paramName, paramValue);\r\n                }\r\n            }\r\n        }\r\n        for (String operand : operands) {\r\n            if (operandParam.getType() == File.class || operandParam.getType() == File[].class) {\r\n                addFileOption(uriString, \"DEFAULT\", operand);\r\n            } else {\r\n                addStringOption(uriString, \"DEFAULT\", operand);\r\n            }\r\n        }\r\n        uriString.setLength(uriString.length() - 1);\r\n        executeRemoteCommand(uriString.toString());\r\n    } catch (IOException ioex) {\r\n        throw new CommandException(\"I/O Error\", ioex);\r\n    }\r\n    return output;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.messagebean.EjbCreateReturnType.check",
	"Comment": "run a verifier test against an individual declared messagedrive bean component",
	"Method": "Result check(EjbMessageBeanDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    Class mbc = loadMessageBeanClass(descriptor, result);\r\n    if (mbc != null) {\r\n        Method m = getMethod(mbc, getMethodName(), null);\r\n        if (m != null) {\r\n            String returnType = m.getReturnType().getName();\r\n            if (\"void\".equalsIgnoreCase(returnType)) {\r\n                result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.passed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.messagebean.EjbCreateReturnType.passed\", \"Message-Drive bean [ {0} ] {1} implementation has a void return type\", new Object[] { (descriptor).getEjbClassName(), m.getName() }));\r\n            } else {\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.failed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.messagebean.EjbCreateReturnType.failed\", \"Error: Message-Drive bean [ {0} ] {1} return type is [ {1} ]\", new Object[] { (descriptor).getEjbClassName(), returnType }));\r\n            }\r\n        } else {\r\n            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.failed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.messagebean.EjbCreateExists.failed\", \"Error: Message-Drive bean [ {0} ] does not implement an {1} with no arguments\", new Object[] { (descriptor).getEjbClassName(), getMethodName() }));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.cluster.ssh.launcher.SSHLauncher.runCommandAsIs",
	"Comment": "executes a command on the remote system via ssh without normalizing the command line",
	"Method": "int runCommandAsIs(List<String> command,OutputStream os,List<String> stdinLines,int runCommandAsIs,String command,OutputStream os,List<String> stdinLines){\r\n    if (logger.isLoggable(Level.FINER)) {\r\n        logger.finer(\"Running command \" + command + \" on host: \" + this.host);\r\n    }\r\n    boolean createNewSession = false;\r\n    if (session == null)\r\n        createNewSession = true;\r\n    if (createNewSession)\r\n        openConnection();\r\n    int status = exec(command, os, listInputStream(stdinLines));\r\n    if (createNewSession) {\r\n        SSHUtil.unregister(session);\r\n        session = null;\r\n    }\r\n    return status;\r\n}"
}, {
	"Path": "com.sun.appserv.web.taglibs.cache.CacheEntry.computeExpireTime",
	"Comment": "compute when this entry to be expired based on timeout relative to current time.",
	"Method": "void computeExpireTime(int timeout){\r\n    this.expireTime = (timeout == NO_TIMEOUT) ? timeout : System.currentTimeMillis() + (timeout * 1000L);\r\n}"
}, {
	"Path": "org.apache.catalina.session.PersistentManagerBase.getStore",
	"Comment": "return the store object which manages persistent sessionstorage for this manager.",
	"Method": "Store getStore(){\r\n    return (this.store);\r\n}"
}, {
	"Path": "com.sun.enterprise.util.io.FileUtils.deleteFileMaybe",
	"Comment": "wrapper for file.deletethis version will return true if the file does not exist when the method returns.unlike file.delete which returns false if the file does not exist.",
	"Method": "boolean deleteFileMaybe(File f){\r\n    return f != null && (!f.exists() || f.delete());\r\n}"
}, {
	"Path": "org.apache.catalina.core.ContainerBase.removeLifecycleListeners",
	"Comment": "removes any lifecycle event listeners from this container.",
	"Method": "void removeLifecycleListeners(){\r\n    lifecycle.removeLifecycleListeners();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentTransaction.receivedRequest",
	"Comment": "informs the currenttransaction that a request has been received.the request contains the transaction context that should be establishedfor the object.",
	"Method": "void receivedRequest(int id,PropagationContext context){\r\n    if (context == null || context.current == null || context.current.otid.formatID == -1) {\r\n        return;\r\n    }\r\n    JavaEETransactionManagerJTSDelegate.getInstance().initXA();\r\n    Control current = Configuration.getFactory().recreate(context);\r\n    importedTransactions.put(Thread.currentThread(), new GlobalTID(context.current.otid));\r\n    try {\r\n        ControlImpl contImpl = null;\r\n        if (Configuration.isLocalFactory()) {\r\n            contImpl = (ControlImpl) current;\r\n        } else {\r\n            contImpl = ControlImpl.servant(JControlHelper.narrow(current));\r\n        }\r\n        setCurrent(contImpl, false);\r\n    } catch (Throwable exc) {\r\n        _logger.log(Level.WARNING, \"jts.unable_to_create_subordinate_coordinator\", exc);\r\n        String msg = LogFormatter.getLocalizedMessage(_logger, \"jts.unable_to_create_subordinate_coordinator\");\r\n        throw new org.omg.CORBA.INTERNAL(msg);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.removeAttribute",
	"Comment": "remove the context attribute with the specified name, if any.",
	"Method": "void removeAttribute(String name){\r\n    context.removeAttribute(name);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.CommandRunnable.getActionReport",
	"Comment": "returns the actionreport that was passed on the constructor.",
	"Method": "ActionReport getActionReport(){\r\n    return report;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getNamingResources",
	"Comment": "return the naming resources associated with this web application.",
	"Method": "NamingResources getNamingResources(){\r\n    return namingResources;\r\n}"
}, {
	"Path": "org.glassfish.config.support.GenericListCommand.getColumnInfo",
	"Comment": "return the list of columns available from the configbeanproxy clazz",
	"Method": "List<ColumnInfo> getColumnInfo(Class<? extends ConfigBeanProxy> clazz){\r\n    List<ColumnInfo> cols = new ArrayList<ColumnInfo>();\r\n    for (String aname : targetModel.getAttributeNames()) {\r\n        ColumnInfo ci = new ColumnInfo();\r\n        ci.cprop = targetModel.findIgnoreCase(aname);\r\n        ci.order = targetModel.key.equals(\"@\" + aname) ? ColumnInfo.KEY_ORDER : ColumnInfo.NONKEY_ORDER;\r\n        ci.xmlName = aname;\r\n        ci.heading = aname.toUpperCase(Locale.ENGLISH);\r\n        cols.add(ci);\r\n    }\r\n    for (Method m : targetType.getMethods()) {\r\n        ListingColumn lc = m.getAnnotation(ListingColumn.class);\r\n        if (lc != null) {\r\n            String cname = targetModel.camelCaseToXML(targetModel.trimPrefix(m.getName()));\r\n            ColumnInfo mci = null;\r\n            for (ColumnInfo ci : cols) {\r\n                if (cname.equalsIgnoreCase(ci.xmlName)) {\r\n                    mci = ci;\r\n                    break;\r\n                }\r\n            }\r\n            if (mci == null) {\r\n                mci = new ColumnInfo();\r\n                mci.xmlName = cname;\r\n                mci.heading = cname.toUpperCase(Locale.ENGLISH);\r\n                try {\r\n                    mci.duckGetter = targetModel.getDuckMethod(m);\r\n                } catch (ClassNotFoundException ex) {\r\n                    ConfigApiLoggerInfo.getLogger().log(Level.SEVERE, ConfigApiLoggerInfo.CANNOT_IDENTIFY_LIST_COL_GETTER, ex);\r\n                } catch (NoSuchMethodException ex) {\r\n                    ConfigApiLoggerInfo.getLogger().log(Level.SEVERE, ConfigApiLoggerInfo.CANNOT_IDENTIFY_LIST_COL_GETTER, ex);\r\n                }\r\n                cols.add(mci);\r\n            }\r\n            mci.lcAnn = lc;\r\n            mci.order = lc.order();\r\n            if (lc.header() != null && lc.header().length() > 0) {\r\n                mci.heading = lc.header();\r\n            }\r\n        }\r\n    }\r\n    return cols;\r\n}"
}, {
	"Path": "org.apache.catalina.util.StringManager.getResourceBundleLocale",
	"Comment": "returns the locale of the resource bundle for the given request locale.",
	"Method": "Locale getResourceBundleLocale(Locale requestLocale){\r\n    ResourceBundle bundle = bundles.get(requestLocale);\r\n    if (bundle == null) {\r\n        synchronized (bundles) {\r\n            bundle = bundles.get(requestLocale);\r\n            if (bundle == null) {\r\n                bundle = ResourceBundle.getBundle(this.bundleName, requestLocale);\r\n                bundles.put(requestLocale, bundle);\r\n            }\r\n        }\r\n    }\r\n    return bundle.getLocale();\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.LoginConfig.getFormLoginConfig",
	"Comment": "gets the form login config, or null ifthe authentication scheme is not form based login.",
	"Method": "FormLoginConfig getFormLoginConfig(){\r\n    return formLoginConfig;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.Environment.putOption",
	"Comment": "set the environment entry corresponding to the named optionto the specified value.",
	"Method": "String putOption(String name,String value){\r\n    return env.put(optionToEnv(name), value);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.AdminUtil.unfreezeAll",
	"Comment": "unfreezeallunfreeze all transactional activity frozen by a freezeall call.part of freezing functions that will be used to achive a transactional quiet period before taking any action or collectingany statistics. this call returns almost immediately.",
	"Method": "void unfreezeAll(){\r\n    TransactionState.freezeLock.releaseWriteLock();\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmrUseCorrectCollectionInterface.runIndividualCmrTest",
	"Comment": "run an individual verifier test of a declated cmr field of the class",
	"Method": "boolean runIndividualCmrTest(Descriptor descriptor,RelationRoleDescriptor rrd,Class c,Result result){\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (rrd.getPartner().getIsMany()) {\r\n        if (rrd.getCMRFieldType() == null) {\r\n            addErrorDetails(result, compName);\r\n            result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed2\", \"Error : CMR field [ {0} ]  cmr-field-type must be defined for one-to-many or many-to-many relationships and the value of the cmr-field-type element must be either: java.util.Collection or java.util.Set\", new Object[] { rrd.getCMRField() }));\r\n            return false;\r\n        } else {\r\n            CMRFieldInfo info = rrd.getCMRFieldInfo();\r\n            if (rrd.getCMRFieldType().equals(info.type.getName())) {\r\n                result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"CMR field [ {0} ] is the same type as declared in the deployment descriptors [ {1} ]\", new Object[] { info.name, info.role.getCMRFieldType() }));\r\n                return true;\r\n            } else {\r\n                addErrorDetails(result, compName);\r\n                result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error : CMR field [ {0} ] is not the same type as declared in the deployment descriptors [ {1} ]\", new Object[] { info.name, info.role.getCMRFieldType() }));\r\n                return false;\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.DeploymentContextImpl.getScratchDir",
	"Comment": "returns a scratch directory that can be used to store things in.the scratch directory will be persisted accross server restart butnot accross redeployment of the same application",
	"Method": "File getScratchDir(String subDirName){\r\n    File rootScratchDir = env.getApplicationStubPath();\r\n    if (tenant != null && originalAppName != null) {\r\n        rootScratchDir = getRootScratchTenantDirForApp(originalAppName);\r\n        rootScratchDir = new File(rootScratchDir, tenant);\r\n        if (subDirName != null) {\r\n            rootScratchDir = new File(rootScratchDir, subDirName);\r\n        }\r\n        return rootScratchDir;\r\n    } else {\r\n        if (subDirName != null) {\r\n            rootScratchDir = new File(rootScratchDir, subDirName);\r\n        }\r\n        String appDirName = VersioningUtils.getRepositoryName(parameters.name());\r\n        return new File(rootScratchDir, appDirName);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardService.getContainer",
	"Comment": "return the container that handles requests for allconnectors associated with this service.",
	"Method": "Container getContainer(){\r\n    return (this.container);\r\n}"
}, {
	"Path": "org.glassfish.webservices.WsUtil.setContentTypeAndFlush",
	"Comment": "used to send back the message after a 4xx response code has been set",
	"Method": "void setContentTypeAndFlush(HttpServletResponse response){\r\n    response.setContentType(\"text/xml\");\r\n    response.flushBuffer();\r\n    response.getWriter().close();\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.LocalInstanceCommand.setServerDirs",
	"Comment": "override this method if your class does not want to set serverdirs",
	"Method": "boolean setServerDirs(){\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.enterprise.deploy.shared.FileArchive.getFileSubArchivePath",
	"Comment": "create or obtain an embedded archive within this abstraction.",
	"Method": "String getFileSubArchivePath(String name){\r\n    name = name.replace('/', File.separatorChar);\r\n    File file = new File(name);\r\n    File subDir;\r\n    if (file.isAbsolute()) {\r\n        subDir = file;\r\n    } else {\r\n        subDir = new File(archive, FileUtils.makeFriendlyFilenameExtension(name));\r\n        if (!subDir.exists()) {\r\n            subDir = new File(archive, name);\r\n            if (!subDir.exists()) {\r\n                subDir = new File(archive, FileUtils.makeFriendlyFilenameExtension(name));\r\n            }\r\n        }\r\n    }\r\n    return subDir.getPath();\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.results.ActionReportResult.setCommandDisplayName",
	"Comment": "change display name for command associated with the command resource.",
	"Method": "void setCommandDisplayName(String s){\r\n    commandDisplayName = s;\r\n}"
}, {
	"Path": "org.glassfish.gms.GMSAdapterImpl.registerMemberLeavingListener",
	"Comment": "register a listener for all events that represent a member has left the group.",
	"Method": "void registerMemberLeavingListener(CallBack callback){\r\n    if (gms != null && callback != null) {\r\n        registerFailureNotificationListener(callback);\r\n        registerPlannedShutdownListener(callback);\r\n        registerJoinNotificationListener(callback);\r\n    }\r\n}"
}, {
	"Path": "com.sun.appserv.web.cache.filter.CachingFilter.init",
	"Comment": "called by the web container to indicate to a filter that it is being placed into service. the servlet container calls the init method exactlyonce after instantiating the filter. the init method must complete successfully before the filter is asked to do any filtering work.",
	"Method": "void init(FilterConfig filterConfig){\r\n    filterName = filterConfig.getFilterName();\r\n    servletName = filterConfig.getInitParameter(\"servletName\");\r\n    urlPattern = filterConfig.getInitParameter(\"URLPattern\");\r\n    ServletContext context = filterConfig.getServletContext();\r\n    manager = (CacheManager) context.getAttribute(CacheManager.CACHE_MANAGER_ATTR_NAME);\r\n    if (manager != null && manager.isEnabled()) {\r\n        this.cache = manager.getDefaultCache();\r\n        this.helper = manager.getCacheHelperByFilterName(filterName);\r\n        manager.addCacheManagerListener(this);\r\n        isEnabled = true;\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, LogFacade.CACHING_FILTER_READY, new Object[] { filterName, isEnabled, manager });\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.PersistentManagerBase.removeSession",
	"Comment": "remove this session from the active sessions for this manager,and from the store.",
	"Method": "void removeSession(String id){\r\n    try {\r\n        if (SecurityUtil.isPackageProtectionEnabled()) {\r\n            try {\r\n                AccessController.doPrivileged(new PrivilegedStoreRemove(id));\r\n            } catch (PrivilegedActionException ex) {\r\n                Exception exception = ex.getException();\r\n                log.log(Level.SEVERE, LogFacade.STORE_REMOVE_SESSION_EXCEPTION, exception);\r\n            }\r\n        } else {\r\n            store.remove(id);\r\n        }\r\n    } catch (IOException e) {\r\n        log.log(Level.SEVERE, LogFacade.REMOVING_SESSION_EXCEPTION, e);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.setNote",
	"Comment": "bind an object to a specified name in the internal notes associatedwith this session, replacing any existing binding for this name.",
	"Method": "void setNote(String name,Object value){\r\n    notes.put(name, value);\r\n}"
}, {
	"Path": "org.glassfish.cluster.ssh.sftp.SFTPClient.normalizePath",
	"Comment": "commands run in a shell on windows need to have forward slashes.",
	"Method": "String normalizePath(String path){\r\n    return path.replaceAll(\"\\\\\\\\\", \"/\");\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.findbyprimarykey.HomeInterfaceFindByPrimaryKeyName.check",
	"Comment": "define findbyprimarykey method test.every entity enterprise bean class must define the findbyprimarykey method.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    result = getInitializedResult();\r\n    boolean oneFailed = false;\r\n    compName = getVerifierContext().getComponentNameConstructor();\r\n    if (descriptor instanceof EjbEntityDescriptor) {\r\n        if (descriptor.getLocalHomeClassName() != null && !\"\".equals(descriptor.getLocalHomeClassName()))\r\n            oneFailed = commonToBothInterfaces(descriptor.getLocalHomeClassName(), descriptor);\r\n        if (oneFailed == false) {\r\n            if (descriptor.getHomeClassName() != null && !\"\".equals(descriptor.getHomeClassName()))\r\n                oneFailed = commonToBothInterfaces(descriptor.getHomeClassName(), descriptor);\r\n        }\r\n        if (oneFailed) {\r\n            result.setStatus(result.FAILED);\r\n        } else {\r\n            result.setStatus(result.PASSED);\r\n        }\r\n        return result;\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"[ {0} ] expected {1} bean, but called with {2} bean.\", new Object[] { getClass(), \"Entity\", \"Session\" }));\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationFilterConfig.isAsyncSupported",
	"Comment": "checks if this filter has been annotated or flagged in the deploymentdescriptor as being able to support asynchronous operations.",
	"Method": "boolean isAsyncSupported(){\r\n    return filterDef.isAsyncSupported();\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.CLICommand.expandManPage",
	"Comment": "return a man page for this command that has the tokens substituted",
	"Method": "BufferedReader expandManPage(Reader r){\r\n    manpageTokenValues[0] = programOpts.getCommandName();\r\n    manpageTokenValues[1] = Environment.getPrefix();\r\n    manpageTokenValues[2] = Version.getBriefProductName();\r\n    TokenValueSet tvs = new TokenValueSet();\r\n    for (int i = 0; i < manpageTokens.length; i++) {\r\n        tvs.add(new TokenValue(manpageTokens[i], manpageTokenValues[i], \"{\", \"}\"));\r\n    }\r\n    return new BufferedReader(new LineTokenReplacer(tvs).getReader(r));\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ReplicationWebEventPersistentManager.getName",
	"Comment": "return the descriptive short name of this manager implementation.",
	"Method": "String getName(){\r\n    return this.name;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.businessmethod.BusinessMethodPublic.commonToBothInterfaces",
	"Comment": "this method is responsible for the logic of the test. it is called for both local and remote interfaces.",
	"Method": "void commonToBothInterfaces(String intf,EjbDescriptor descriptor){\r\n    try {\r\n        Class intfClass = Class.forName(intf, false, getVerifierContext().getClassLoader());\r\n        for (Method remoteMethod : intfClass.getMethods()) {\r\n            if (remoteMethod.getDeclaringClass().getName().equals(\"javax.ejb.EJBObject\") || remoteMethod.getDeclaringClass().getName().equals(\"javax.ejb.EJBLocalObject\"))\r\n                continue;\r\n            Class beanClass = Class.forName(descriptor.getEjbClassName(), false, getVerifierContext().getClassLoader());\r\n            boolean foundOne = false;\r\n            for (Method method : beanClass.getMethods()) {\r\n                if (MethodUtils.methodEquals(method, remoteMethod)) {\r\n                    foundOne = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (!foundOne) {\r\n                String methodToString = remoteMethod.toString().replace(\"abstract \", \"\");\r\n                addErrorDetails(result, compName);\r\n                result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: public business method [ {0} ] not found in [ {1} ].\", new Object[] { methodToString, beanClass.getName() }));\r\n            }\r\n        }\r\n    } catch (ClassNotFoundException e) {\r\n        Verifier.debug(e);\r\n        addErrorDetails(result, compName);\r\n        result.failed(smh.getLocalString(getClass().getName() + \".failedException\", \"Error: Remote interface [ {0} ] or bean class [ {1} ] \" + \"does not exist or is not loadable within bean [ {2} ].\", new Object[] { intf, descriptor.getEjbClassName(), descriptor.getName() }));\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.contextpropagation.weblogic.workarea.WorkContextHelper.setWorkContextHelper",
	"Comment": "set the workcontexthelper singleton. this should be set at startupand not synchronized.",
	"Method": "void setWorkContextHelper(WorkContextHelper wam){\r\n    throw new IllegalArgumentException(\"WorkContextHelper does not currently support replacement\");\r\n}"
}, {
	"Path": "org.glassfish.config.support.PropertyResolver.getPropertyValue",
	"Comment": "given a propery name, return its corresponding value in the specified systemproperty array. return null if the property is not found.",
	"Method": "String getPropertyValue(String propName,List<SystemProperty> props,String getPropertyValue,String propName){\r\n    if (propName.startsWith(\"${\") && propName.endsWith(\"}\")) {\r\n        propName = propName.substring(2, propName.lastIndexOf(\"}\"));\r\n    }\r\n    String propVal = null;\r\n    if (_server != null) {\r\n        propVal = getPropertyValue(propName, _server.getSystemProperty());\r\n    }\r\n    if (propVal == null) {\r\n        if (_cluster != null) {\r\n            propVal = getPropertyValue(propName, _cluster.getSystemProperty());\r\n        }\r\n        if (propVal == null) {\r\n            if (_config != null) {\r\n                propVal = getPropertyValue(propName, _config.getSystemProperty());\r\n                if (propVal == null) {\r\n                    if (_domain != null) {\r\n                        propVal = getPropertyValue(propName, _domain.getSystemProperty());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return propVal;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.provider.BaseProvider.canShowHiddenCommands",
	"Comment": "returns true if the html viewer displays the hidden cli command links",
	"Method": "boolean canShowHiddenCommands(){\r\n    RestConfig rg = ResourceUtil.getRestConfig(habitat);\r\n    if ((rg != null) && (rg.getShowHiddenCommands().equalsIgnoreCase(\"true\"))) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.catalina.loader.WebappLoader.setClassPath",
	"Comment": "set the appropriate context attribute for our class path.thisis required only because jasper depends on it.",
	"Method": "void setClassPath(){\r\n    if (!(container instanceof Context))\r\n        return;\r\n    ServletContext servletContext = ((Context) container).getServletContext();\r\n    if (servletContext == null)\r\n        return;\r\n    if (container instanceof StandardContext) {\r\n        String baseClasspath = ((StandardContext) container).getCompilerClasspath();\r\n        if (baseClasspath != null) {\r\n            servletContext.setAttribute(Globals.CLASS_PATH_ATTR, baseClasspath);\r\n            return;\r\n        }\r\n    }\r\n    StringBuilder classpath = new StringBuilder();\r\n    ClassLoader loader = getClassLoader();\r\n    boolean first = true;\r\n    while (loader != null) {\r\n        if (!(loader instanceof URLClassLoader)) {\r\n            String cp = getClasspath(loader);\r\n            if (cp != null) {\r\n                if (!first) {\r\n                    classpath.append(File.pathSeparator);\r\n                } else {\r\n                    first = false;\r\n                }\r\n                classpath.append(cp);\r\n            }\r\n        } else {\r\n            URL[] repositories = ((URLClassLoader) loader).getURLs();\r\n            for (int i = 0; i < repositories.length; i++) {\r\n                if (repositories[i] == null) {\r\n                    continue;\r\n                }\r\n                String repository = repositories[i].toString();\r\n                if (repository.startsWith(\"file://\")) {\r\n                    repository = repository.substring(7);\r\n                } else if (repository.startsWith(\"file:\")) {\r\n                    repository = repository.substring(5);\r\n                } else if (repository.startsWith(\"jndi:\")) {\r\n                    repository = servletContext.getRealPath(repository.substring(5));\r\n                } else {\r\n                    continue;\r\n                }\r\n                if (!repository.isEmpty()) {\r\n                    if (!first) {\r\n                        classpath.append(File.pathSeparator);\r\n                    } else {\r\n                        first = false;\r\n                    }\r\n                    classpath.append(repository);\r\n                }\r\n            }\r\n        }\r\n        loader = loader.getParent();\r\n    }\r\n    this.classpath = classpath.toString();\r\n    servletContext.setAttribute(Globals.CLASS_PATH_ATTR, classpath.toString());\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.stringsubs.impl.ArchiveEntryWrapperImpl.appendEntry",
	"Comment": "adds the given entry into the jar and writes the entry data from the inputstream.",
	"Method": "void appendEntry(JarOutputStream jos,JarEntry jarEntry,InputStream is){\r\n    jos.putNextEntry(jarEntry);\r\n    if (!jarEntry.isDirectory()) {\r\n        int i = 0;\r\n        while ((i = is.read(_buffer)) != -1) {\r\n            jos.write(_buffer, 0, i);\r\n        }\r\n        is.close();\r\n        jos.flush();\r\n    }\r\n    jos.closeEntry();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogHandle.checkRestart",
	"Comment": "checks restart record information.this internal method does not need to be synchronized.",
	"Method": "void checkRestart(LogFileHandle fileHandle,int restartNumber,int[] restartInfo){\r\n    restartInfo[0] = 0;\r\n    restartInfo[1] = 0;\r\n    byte[] restartBytes = new byte[LogRestartDescriptor.SIZEOF];\r\n    int offset = restartPosition(restartNumber);\r\n    fileHandle.fileSeek(offset, LogFileHandle.SEEK_ABSOLUTE);\r\n    int bytesRead = fileHandle.fileRead(restartBytes);\r\n    LogRestartDescriptor logRD = new LogRestartDescriptor(restartBytes, 0);\r\n    if (bytesRead > 0) {\r\n        if (logRD.restartValid == restartPosition(restartNumber)) {\r\n            fileHandle.fileSeek(logRD.restartDataLength, LogFileHandle.SEEK_RELATIVE);\r\n            fileHandle.fileRead(restartBytes);\r\n            LogRestartDescriptor logRDEnd = new LogRestartDescriptor(restartBytes, 0);\r\n            if (logRD.equals(logRDEnd)) {\r\n                restartInfo[0] = logRD.restartDataLength;\r\n                restartInfo[1] = logRD.timeStamp;\r\n            } else\r\n                throw new LogException(null, LogException.LOG_CORRUPTED, 1);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getServletContext",
	"Comment": "return the servlet context for which this context is a facade.",
	"Method": "ServletContext getServletContext(){\r\n    if (context == null) {\r\n        context = new ApplicationContext(this);\r\n        if (altDDName != null && context.getAttribute(Globals.ALT_DD_ATTR) == null) {\r\n            context.setAttribute(Globals.ALT_DD_ATTR, altDDName);\r\n            context.setAttributeReadOnly(Globals.ALT_DD_ATTR);\r\n        }\r\n    }\r\n    return context.getFacade();\r\n}"
}, {
	"Path": "org.apache.catalina.valves.RequestFilterValve.process",
	"Comment": "perform the filtering that has been configured for this valve, matchingagainst the specified request property.",
	"Method": "int process(String property,Request request,Response response){\r\n    for (int i = 0; i < denies.length; i++) {\r\n        if (denies[i].matcher(property).matches()) {\r\n            handleError(request, response, HttpServletResponse.SC_FORBIDDEN);\r\n            return END_PIPELINE;\r\n        }\r\n    }\r\n    for (int i = 0; i < allows.length; i++) {\r\n        if (allows[i].matcher(property).matches()) {\r\n            return INVOKE_NEXT;\r\n        }\r\n    }\r\n    if ((denies.length > 0) && (allows.length == 0)) {\r\n        return INVOKE_NEXT;\r\n    }\r\n    handleError(request, response, HttpServletResponse.SC_FORBIDDEN);\r\n    return END_PIPELINE;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorLog.addLog",
	"Comment": "remembers the mapping between the local transaction identifier and thecoordinatorlog object.",
	"Method": "boolean addLog(Long localTID,CoordinatorLog clog,boolean addLog,Long localTID,CoordinatorLog clog,String logPath){\r\n    CoordinatorLogStateHolder logStateHolder = getStateHolder(logPath);\r\n    boolean result = true;\r\n    logStateHolder.activeLogs.put(localTID, clog);\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationFilterChain.release",
	"Comment": "release references to the filters and wrapper executed by this chain.",
	"Method": "void release(){\r\n    n = 0;\r\n    pos = 0;\r\n    servlet = null;\r\n    wrapper = null;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.getEntityManagerFactoryReferenceByName",
	"Comment": "return the entity manager factory reference descriptor corresponding tothe given name.",
	"Method": "EntityManagerFactoryReferenceDescriptor getEntityManagerFactoryReferenceByName(String name){\r\n    EntityManagerFactoryReferenceDescriptor emfr = _getEntityManagerFactoryReferenceByName(name);\r\n    if (emfr != null) {\r\n        return emfr;\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"web.deployment.exceptionwebapphasnoentitymgrfactoryrefbyname\", \"This web app [{0}] has no entity manager factory reference by the name of [{1}]\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.Descriptor.stripIntegerEndingFrom",
	"Comment": "returns the largest substring of the given string thatdoes not have an integer at the end.",
	"Method": "String stripIntegerEndingFrom(String s){\r\n    return recursiveStripIntegerEndingFrom(s);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.EjbBeanType.check",
	"Comment": "bean type test.the bean provider must use the appropriate session or entity element to declare the bean type.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if ((descriptor instanceof EjbSessionDescriptor) || (descriptor instanceof EjbEntityDescriptor)) {\r\n        try {\r\n            Class c = Class.forName(descriptor.getEjbClassName(), false, getVerifierContext().getClassLoader());\r\n            boolean validBean = false;\r\n            do {\r\n                Class[] interfaces = c.getInterfaces();\r\n                for (int i = 0; i < interfaces.length; i++) {\r\n                    logger.log(Level.FINE, getClass().getName() + \".debug1\", new Object[] { interfaces[i].getName() });\r\n                    if (interfaces[i].getName().equals(\"javax.ejb.EntityBean\") && (descriptor instanceof EjbEntityDescriptor)) {\r\n                        validBean = true;\r\n                        result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"[ {0} ] properly implements the {1}Bean interface.\", new Object[] { descriptor.getEjbClassName(), \"Entity\" }));\r\n                        break;\r\n                    } else if (interfaces[i].getName().equals(\"javax.ejb.SessionBean\") && descriptor instanceof EjbSessionDescriptor) {\r\n                        validBean = true;\r\n                        result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"[ {0} ] properly implements the {1}Bean interface.\", new Object[] { descriptor.getEjbClassName(), \"Session\" }));\r\n                        break;\r\n                    }\r\n                }\r\n            } while ((((c = c.getSuperclass()) != null) && (!validBean)));\r\n            if (!validBean) {\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: [ {0} ] is not a valid bean. The bean provider must use the appropriate {1} or {2} element to declare the bean type.\", new Object[] { descriptor.getEjbClassName(), \"session\", \"entity\" }));\r\n            }\r\n        } catch (ClassNotFoundException e) {\r\n            Verifier.debug(e);\r\n            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.failed(smh.getLocalString(getClass().getName() + \".failedException\", \"Error: [ {0} ] class not found.\", new Object[] { descriptor.getEjbClassName() }));\r\n        }\r\n        return result;\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"[ {0} ] not called with a Session or Entity Bean.\", new Object[] { getClass() }));\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.security.SecurityUtil.execute",
	"Comment": "perform work as a particular subject. here the workwill be granted to a null subject.",
	"Method": "void execute(Method method,Object targetObject,Object[] targetArguments,Principal principal){\r\n    try {\r\n        Subject subject = null;\r\n        PrivilegedExceptionAction<Void> pea = new PrivilegedExceptionAction<Void>() {\r\n            public Void run() throws Exception {\r\n                method.invoke(targetObject, targetArguments);\r\n                return null;\r\n            }\r\n        };\r\n        if (targetArguments != null && targetArguments[0] instanceof HttpServletRequest) {\r\n            HttpServletRequest request = (HttpServletRequest) targetArguments[0];\r\n            boolean hasSubject = false;\r\n            HttpSession session = request.getSession(false);\r\n            if (session != null) {\r\n                subject = (Subject) session.getAttribute(Globals.SUBJECT_ATTR);\r\n                hasSubject = (subject != null);\r\n            }\r\n            if (subject == null) {\r\n                subject = new Subject();\r\n                if (principal != null) {\r\n                    subject.getPrincipals().add(principal);\r\n                }\r\n            }\r\n            if (session != null && !hasSubject) {\r\n                session.setAttribute(Globals.SUBJECT_ATTR, subject);\r\n            }\r\n        }\r\n        Subject.doAsPrivileged(subject, pea, null);\r\n    } catch (PrivilegedActionException pe) {\r\n        Throwable e;\r\n        if (pe.getException() instanceof InvocationTargetException) {\r\n            e = ((InvocationTargetException) pe.getException()).getTargetException();\r\n        } else {\r\n            e = pe;\r\n        }\r\n        if (log.isLoggable(Level.FINE)) {\r\n            log.log(Level.FINE, LogFacade.PRIVILEGE_ACTION_EXCEPTION, e);\r\n        }\r\n        if (e instanceof UnavailableException)\r\n            throw (UnavailableException) e;\r\n        else if (e instanceof ServletException)\r\n            throw (ServletException) e;\r\n        else if (e instanceof IOException)\r\n            throw (IOException) e;\r\n        else if (e instanceof RuntimeException)\r\n            throw (RuntimeException) e;\r\n        else\r\n            throw new ServletException(e.getMessage(), e);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.security.SecurityUtil.execute",
	"Comment": "perform work as a particular subject. here the workwill be granted to a null subject.",
	"Method": "void execute(Method method,Object targetObject,Object[] targetArguments,Principal principal){\r\n    method.invoke(targetObject, targetArguments);\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ReplicationAttributeStore.doSave",
	"Comment": "save the specified session into this store.any previously savedinformation for the associated session identifier is replaced.",
	"Method": "void doSave(Session session){\r\n    if (!((StandardSession) session).getIsValid()) {\r\n        return;\r\n    }\r\n    if (!(session instanceof ModifiedAttributeHASession) || !(session instanceof HASession)) {\r\n        return;\r\n    }\r\n    ModifiedAttributeHASession modAttrSession = (ModifiedAttributeHASession) session;\r\n    BackingStore<String, CompositeMetadata> replicator = getCompositeMetadataBackingStore();\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"ReplicationAttributeStore>>doSave: replicator: \" + replicator);\r\n    }\r\n    CompositeMetadata compositeMetadata = createCompositeMetadata(modAttrSession);\r\n    try {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.fine(\"CompositeMetadata is \" + compositeMetadata + \" id is \" + session.getIdInternal());\r\n        }\r\n        // id\r\n        replicator.save(session.getIdInternal(), compositeMetadata, !((HASession) session).isPersistent());\r\n        modAttrSession.resetAttributeState();\r\n        postSaveUpdate(modAttrSession);\r\n    } catch (BackingStoreException ex) {\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.servlets.DefaultServlet.setListings",
	"Comment": "enables or disables directory listings for this defaultservlet.",
	"Method": "void setListings(boolean listings){\r\n    this.listings = listings;\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionManagerImpl.suspend",
	"Comment": "suspend the transaction currently associated with the callingthread and return a transaction object that represents thetransaction context being suspended. if the calling thread isnot associated with a transaction, the method returns a nullobject reference. when this method returns, the calling threadis associated with no transaction.",
	"Method": "Transaction suspend(){\r\n    try {\r\n        Control control = current.suspend();\r\n        if (control == null)\r\n            return null;\r\n        return createTransactionImpl(control);\r\n    } catch (Unavailable uex) {\r\n        throw new SystemException(uex.toString());\r\n    } catch (Exception ex) {\r\n        throw new SystemException(ex.toString());\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.realm.JAASRealm.stop",
	"Comment": "gracefully shut down active use of the public methods of this component.",
	"Method": "void stop(){\r\n    super.stop();\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.getMinProcessors",
	"Comment": "return the minimum number of processors to start at initialization.",
	"Method": "int getMinProcessors(){\r\n    return minProcessors;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getUrlPatternFilterMappings",
	"Comment": "gets the current url pattern mappings of the filter with the givenname.",
	"Method": "Collection<String> getUrlPatternFilterMappings(String filterName){\r\n    HashSet<String> mappings = new HashSet<String>();\r\n    synchronized (filterMaps) {\r\n        for (FilterMap fm : filterMaps) {\r\n            if (filterName.equals(fm.getFilterName()) && fm.getURLPattern() != null) {\r\n                mappings.add(fm.getURLPattern());\r\n            }\r\n        }\r\n    }\r\n    return mappings;\r\n}"
}, {
	"Path": "org.glassfish.deployment.admin.ReDeployCommand.validateParameters",
	"Comment": "validate the parameters, name and path.check if name is registered.for redeployment, theapplication must be previously deployed.verify that path is valid and not null.",
	"Method": "boolean validateParameters(String name,ActionReport report){\r\n    if (!deployment.isRegistered(name)) {\r\n        report.setMessage(localStrings.getLocalString(\"application.notreg\", \"Application {0} not registered\", name));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return false;\r\n    } else if (path == null) {\r\n        if (!Boolean.parseBoolean(configBeansUtilities.getDirectoryDeployed(name))) {\r\n            report.setMessage(localStrings.getLocalString(\"redeploy.command.cannot.redeploy\", \"Cannot redeploy this app {0} without specify the operand.\", name));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return false;\r\n        }\r\n    }\r\n    super.path = (path == null) ? new File(configBeansUtilities.getLocation(name)) : path;\r\n    if (!super.path.exists()) {\r\n        report.setMessage(localStrings.getLocalString(\"redeploy.command.invalid.path\", \"Cannot determine the path of application.\"));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.glassfish.security.common.FileRealmHelper.reduceGroups",
	"Comment": "this method reduces the group size by 1 and remove group name frominternal group list if resulting group size is 0.",
	"Method": "void reduceGroups(String[] groupList){\r\n    if (groupList != null) {\r\n        for (int i = 0; i < groupList.length; i++) {\r\n            Integer groupSize = groupSizeMap.get(groupList[i]);\r\n            if (groupSize != null) {\r\n                int gpSize = groupSize.intValue() - 1;\r\n                if (gpSize > 0) {\r\n                    groupSizeMap.put(groupList[i], Integer.valueOf(gpSize));\r\n                } else {\r\n                    groupSizeMap.remove(groupList[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.util.RequestUtil.parseSessionVersionString",
	"Comment": "parses the given session version string into its components.",
	"Method": "HashMap<String, String> parseSessionVersionString(String sessionVersion){\r\n    if (sessionVersion == null) {\r\n        return null;\r\n    }\r\n    StringTokenizer st = new StringTokenizer(sessionVersion, SESSION_VERSION_SEPARATOR);\r\n    HashMap<String, String> result = new HashMap<String, String>(st.countTokens());\r\n    while (st.hasMoreTokens()) {\r\n        String hexPath = st.nextToken();\r\n        if (st.hasMoreTokens()) {\r\n            try {\r\n                String contextPath = new String(HexUtils.convert(hexPath), Charsets.UTF8_CHARSET);\r\n                result.put(contextPath, st.nextToken());\r\n            } catch (UnsupportedCharsetException ex) {\r\n                throw new IllegalArgumentException(ex);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityConstraint.toString",
	"Comment": "return a string representation of this security constraint.",
	"Method": "String toString(){\r\n    StringBuilder sb = new StringBuilder(\"SecurityConstraint: \");\r\n    for (SecurityCollection collection : collections) {\r\n        sb.append(\" collection: \").append(collection);\r\n    }\r\n    for (String authRole : authRoles) {\r\n        sb.append(\" authRole: \" + authRole);\r\n    }\r\n    sb.append(\" userConstraint: \").append(userConstraint);\r\n    return (sb.toString());\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.translateAttributeName",
	"Comment": "translate the attribute name from the legacy factory names to theirinternal protocol names.",
	"Method": "String translateAttributeName(String name){\r\n    if (\"clientAuth\".equals(name)) {\r\n        return \"clientauth\";\r\n    } else if (\"keystoreFile\".equals(name)) {\r\n        return \"keystore\";\r\n    } else if (\"randomFile\".equals(name)) {\r\n        return \"randomfile\";\r\n    } else if (\"rootFile\".equals(name)) {\r\n        return \"rootfile\";\r\n    } else if (\"keystorePass\".equals(name)) {\r\n        return \"keypass\";\r\n    } else if (\"keystoreType\".equals(name)) {\r\n        return \"keytype\";\r\n    } else if (\"sslProtocol\".equals(name)) {\r\n        return \"protocol\";\r\n    } else if (\"sslProtocols\".equals(name)) {\r\n        return \"protocols\";\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.ListNetworkListeners.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the parameter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    final ActionReport report = context.getActionReport();\r\n    List<NetworkListener> list = config.getNetworkConfig().getNetworkListeners().getNetworkListener();\r\n    for (NetworkListener networkListener : list) {\r\n        report.getTopMessagePart().addChild().setMessage(networkListener.getName());\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteAdminCommand.getOption",
	"Comment": "get an option value, that might come from the command lineor from the environment.return the default value for theoption if not otherwise specified.",
	"Method": "String getOption(String name){\r\n    String val = options.getOne(name);\r\n    if (val == null)\r\n        val = getFromEnvironment(name);\r\n    if (val == null) {\r\n        ParamModel opt = commandModel.getModelFor(name);\r\n        if (opt != null) {\r\n            String def = opt.getParam().defaultValue();\r\n            if (ok(def))\r\n                val = def;\r\n        }\r\n    }\r\n    return val;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.LocalInstanceCommand.updateDasPort",
	"Comment": "update das port from an old v2 das.properties file.if the old port is the standard jrmp port, just use the newstandard http port.otherwise, prompt for the new port numberif possible.in any event, try to rewrite the das.propertiesfile with the new values.",
	"Method": "int updateDasPort(Properties dasprops,int port,File propfile){\r\n    Console cons;\r\n    if (port == 8686) {\r\n        logger.info(Strings.get(\"Instance.oldDasProperties\", propfile.toString(), Integer.toString(port), Integer.toString(programOpts.getPort())));\r\n        port = programOpts.getPort();\r\n    } else if ((cons = System.console()) != null) {\r\n        String line = cons.readLine(\"%s\", Strings.get(\"Instance.oldDasPropertiesPrompt\", propfile.toString(), Integer.toString(port), Integer.toString(programOpts.getPort())));\r\n        while (line != null && line.length() > 0) {\r\n            try {\r\n                port = Integer.parseInt(line);\r\n                if (port > 0 && port <= 65535)\r\n                    break;\r\n            } catch (NumberFormatException nfex) {\r\n            }\r\n            line = cons.readLine(Strings.get(\"Instance.reenterPort\"), Integer.toString(programOpts.getPort()));\r\n        }\r\n    } else {\r\n        logger.info(Strings.get(\"Instance.oldDasPropertiesWrong\", propfile.toString(), Integer.toString(port), Integer.toString(programOpts.getPort())));\r\n        port = programOpts.getPort();\r\n    }\r\n    dasprops.setProperty(\"agent.das.protocol\", \"http\");\r\n    dasprops.setProperty(\"agent.das.port\", Integer.toString(port));\r\n    BufferedOutputStream bos = null;\r\n    try {\r\n        bos = new BufferedOutputStream(new FileOutputStream(propfile));\r\n        dasprops.store(bos, \"Domain Administration Server Connection Properties\");\r\n        bos.close();\r\n        bos = null;\r\n    } catch (IOException ex2) {\r\n        logger.info(Strings.get(\"Instance.dasPropertiesUpdateFailed\"));\r\n    } finally {\r\n        if (bos != null) {\r\n            try {\r\n                bos.close();\r\n            } catch (IOException cex) {\r\n            }\r\n        }\r\n    }\r\n    logger.log(Level.FINER, \"New DAS port number: {0}\", port);\r\n    return port;\r\n}"
}, {
	"Path": "org.apache.naming.resources.WebDirContext.listBindings",
	"Comment": "enumerates the names bound in the named context, along with the objects bound to them. the contents of any subcontexts are not included.if a binding is added to or removed from this context, its effect on an enumeration previously returned is undefined.",
	"Method": "NamingEnumeration<Binding> listBindings(String name){\r\n    List<NamingEntry> namingEntries = null;\r\n    File file = file(name);\r\n    if (file != null) {\r\n        namingEntries = list(file);\r\n    }\r\n    List<JarFileEntry> jfeEntries = lookupAllFromJars(name);\r\n    for (JarFileEntry jfeEntry : jfeEntries) {\r\n        List<NamingEntry> jfeList = list(jfeEntry);\r\n        if (namingEntries != null) {\r\n            namingEntries.addAll(jfeList);\r\n        } else {\r\n            namingEntries = jfeList;\r\n        }\r\n    }\r\n    if (file == null && jfeEntries.size() == 0) {\r\n        throw new NamingException(MessageFormat.format(rb.getString(LogFacade.RESOURCES_NOT_FOUND), name));\r\n    }\r\n    return new NamingContextBindingsEnumeration(namingEntries.iterator(), this);\r\n}"
}, {
	"Path": "com.sun.enterprise.server.logging.SyslogHandler.log",
	"Comment": "retrieves the logrecord from our queue and store them in the file",
	"Method": "void log(){\r\n    LogRecord record;\r\n    try {\r\n        record = pendingRecords.take();\r\n    } catch (InterruptedException e) {\r\n        return;\r\n    }\r\n    Level level = record.getLevel();\r\n    long millisec = record.getMillis();\r\n    int syslogLevel = Syslog.INFO;\r\n    String logLevel = \"INFO\";\r\n    if (level.equals(Level.SEVERE)) {\r\n        syslogLevel = Syslog.CRIT;\r\n        logLevel = \"CRIT\";\r\n    } else if (level.equals(Level.WARNING)) {\r\n        syslogLevel = Syslog.WARNING;\r\n        logLevel = \"WARNING\";\r\n    } else if (level.intValue() <= Level.FINE.intValue()) {\r\n        syslogLevel = Syslog.DEBUG;\r\n        logLevel = \"DEBUG\";\r\n    }\r\n    StringBuilder sb = new StringBuilder();\r\n    SimpleDateFormat formatter = new SimpleDateFormat(\"MMM dd HH:mm:ss\");\r\n    sb.append(formatter.format(millisec));\r\n    sb.append(\" [ \");\r\n    sb.append(logLevel);\r\n    sb.append(\" glassfish ] \");\r\n    String formattedMsg = simpleFormatter.formatMessage(record);\r\n    sb.append(formattedMsg);\r\n    if (sysLogger != null) {\r\n        sysLogger.log(Syslog.DAEMON, syslogLevel, sb.toString());\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ReplicationStore.doValveSave",
	"Comment": "save the specified session into this store.any previously savedinformation for the associated session identifier is replaced.",
	"Method": "void doValveSave(Session session){\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        if (session instanceof HASession) {\r\n            _logger.fine(\"ReplicationStore>>doValveSave:id =\" + ((HASession) session).getIdInternal());\r\n        }\r\n        _logger.fine(\"ReplicationStore>>doValveSave:valid =\" + session.getIsValid());\r\n    }\r\n    if (!session.getIsValid()) {\r\n        return;\r\n    }\r\n    if (!(session instanceof BaseHASession)) {\r\n        return;\r\n    }\r\n    String userName = \"\";\r\n    if (session.getPrincipal() != null) {\r\n        userName = session.getPrincipal().getName();\r\n        ((BaseHASession) session).setUserName(userName);\r\n    }\r\n    byte[] sessionState = this.getByteArray(session, isReplicationCompressionEnabled());\r\n    if (_logger.isLoggable(Level.FINEST)) {\r\n        _logger.finest(\"ReplicationStore->Byte array to save\");\r\n        StringBuilder sb = new StringBuilder(\"Session data{\");\r\n        for (byte b : sessionState) {\r\n            sb.append(b + \"_\");\r\n        }\r\n        sb.append(\"}\");\r\n        _logger.finest(sb.toString());\r\n    }\r\n    BackingStore<String, SimpleMetadata> replicator = getSimpleMetadataBackingStore();\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"ReplicationStore>>doValveSave replicator: \" + replicator);\r\n        _logger.fine(\"ReplicationStore>>doValveSave version:\" + session.getVersion());\r\n    }\r\n    // version\r\n    SimpleMetadata simpleMetadata = // version\r\n    SimpleMetadataFactory.createSimpleMetadata(session.getVersion(), session.getLastAccessedTime(), session.getMaxInactiveInterval() * 1000L, sessionState);\r\n    if (_logger.isLoggable(Level.FINEST)) {\r\n        _logger.finest(\"In doValveSave metadata is \" + simpleMetadata);\r\n    }\r\n    try {\r\n        HASession haSess = (HASession) session;\r\n        // id\r\n        replicator.save(session.getIdInternal(), simpleMetadata, haSess.isPersistent());\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.fine(\"Save succeeded.\");\r\n        }\r\n    } catch (BackingStoreException ex) {\r\n        IOException ex1 = (IOException) new IOException(\"Error during save: \" + ex.getMessage()).initCause(ex);\r\n        throw ex1;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.ContainerTransactionStyle3.getBusinessMethods",
	"Comment": "returns an array of business methods that are collected from set classnames",
	"Method": "Method[] getBusinessMethods(Set<String> classNames,Method[] intfMethods){\r\n    if (!classNames.isEmpty()) {\r\n        List<Method> methods = new ArrayList<Method>();\r\n        for (String clsName : classNames) {\r\n            Method[] methodArray = getMethods(clsName);\r\n            if (methodArray != null)\r\n                methods.addAll(Arrays.asList(methodArray));\r\n        }\r\n        if (intfMethods != null)\r\n            methods.addAll(Arrays.asList(intfMethods));\r\n        return methods.toArray(new Method[] {});\r\n    }\r\n    return intfMethods;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardService.findConnector",
	"Comment": "find and return the connector associated with this service and connector name.",
	"Method": "Connector findConnector(String name){\r\n    for (Connector connector : connectors) {\r\n        if (connector.getName().equals(name)) {\r\n            return connector;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.naming.EjbRef.getFactoryClassName",
	"Comment": "retrieves the class name of the factory of the object to which this reference refers.",
	"Method": "String getFactoryClassName(){\r\n    String factory = super.getFactoryClassName();\r\n    if (factory != null) {\r\n        return factory;\r\n    } else {\r\n        factory = System.getProperty(Context.OBJECT_FACTORIES);\r\n        if (factory != null) {\r\n            return null;\r\n        } else {\r\n            return DEFAULT_FACTORY;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.loader.StandardClassLoader.findResource",
	"Comment": "find the specified resource in our local repository, and return aurl refering to it, or null if this resourcecannot be found.",
	"Method": "URL findResource(String name){\r\n    if (debug >= 3)\r\n        log(\"    findResource(\" + name + \")\");\r\n    URL url = super.findResource(name);\r\n    if (debug >= 3) {\r\n        if (url != null)\r\n            log(\"    --> Returning '\" + url.toString() + \"'\");\r\n        else\r\n            log(\"    --> Resource not found, returning null\");\r\n    }\r\n    return (url);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.VerifierTest.isSubclassOf",
	"Comment": "check if the class is a sublcass or the class itself of the passed class name",
	"Method": "boolean isSubclassOf(Class subClass,String superClassName){\r\n    if (subClass == null || superClassName == null) {\r\n        return false;\r\n    }\r\n    Class c = subClass;\r\n    do {\r\n        if (c.getName().equals(superClassName)) {\r\n            return true;\r\n        }\r\n        Class[] interfaces = c.getInterfaces();\r\n        for (int i = 0; i < interfaces.length; i++) {\r\n            if (interfaces[i].getName().equals(superClassName)) {\r\n                return true;\r\n            } else {\r\n                if (isSubclassOf(interfaces[i], superClassName)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        c = c.getSuperclass();\r\n    } while (c != null);\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardEngine.setParent",
	"Comment": "disallow any attempt to set a parent for this container, since anengine is supposed to be at the top of the container hierarchy.",
	"Method": "void setParent(Container container){\r\n    throw new IllegalArgumentException(rb.getString(LogFacade.CANNOT_HAVE_PARENT_CONTAINER_EXCEPTION));\r\n}"
}, {
	"Path": "demo.model.RepeaterBean.getCustomers",
	"Comment": "return the customer list containing the data backing this demo.",
	"Method": "List getCustomers(){\r\n    List list = (List) FacesContext.getCurrentInstance().getExternalContext().getSessionMap().get(\"list\");\r\n    if (list == null) {\r\n        list = new ArrayList();\r\n        list.add(new CustomerBean(\"123456\", \"Alpha Beta Company\", \"ABC\", 1234.56));\r\n        list.add(new CustomerBean(\"445566\", \"General Services, Ltd.\", \"GS\", 33.33));\r\n        list.add(new CustomerBean(\"654321\", \"Summa Cum Laude, Inc.\", \"SCL\", 76543.21));\r\n        list.add(new CustomerBean(\"333333\", \"Yabba Dabba Doo\", \"YDD\", 333.33));\r\n        for (int i = 10; i < 20; i++) {\r\n            list.add(new CustomerBean(\"8888\" + i, \"Customer \" + i, \"CU\" + i, ((double) i) * 10.0));\r\n        }\r\n        FacesContext.getCurrentInstance().getExternalContext().getSessionMap().put(\"list\", list);\r\n    }\r\n    return (list);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ContainerBase.removeChild",
	"Comment": "remove an existing child container from association with this parentcontainer.",
	"Method": "void removeChild(Container child){\r\n    if (child == null) {\r\n        return;\r\n    }\r\n    synchronized (children) {\r\n        if (children.get(child.getName()) == null)\r\n            return;\r\n        children.remove(child.getName());\r\n    }\r\n    if (started && (child instanceof Lifecycle)) {\r\n        try {\r\n            if (child instanceof ContainerBase) {\r\n                if (((ContainerBase) child).started) {\r\n                    ((Lifecycle) child).stop();\r\n                }\r\n            } else {\r\n                ((Lifecycle) child).stop();\r\n            }\r\n        } catch (LifecycleException e) {\r\n            log.log(Level.SEVERE, LogFacade.CONTAINER_BASE_REMOVE_CHILD_STOP, e);\r\n        }\r\n    }\r\n    if (notifyContainerListeners) {\r\n        fireContainerEvent(REMOVE_CHILD_EVENT, child);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.monitor.jndi.JndiNameLookupHelper.initialize",
	"Comment": "initializes the jndimbeanhelper object upon creation. it specificallycreates an initialcontext instance for querying the naming serviceduring certain method invocations.",
	"Method": "void initialize(){\r\n    try {\r\n        context = new InitialContext();\r\n    } catch (javax.naming.NamingException e) {\r\n        logger.log(Level.WARNING, UNHANDLED_EXCEPTION, e);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.logger.SystemErrLogger.log",
	"Comment": "writes the specified message to a servlet log file, usually an eventlog.the name and type of the servlet log is specific to theservlet container.",
	"Method": "void log(String msg){\r\n    System.err.println(msg);\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ValveBase.stop",
	"Comment": "gracefully terminate the active use of the public methods of thiscomponent.this method should be the last one called on a giveninstance of this component.",
	"Method": "void stop(){\r\n    if (!started)\r\n        return;\r\n    lifecycle.fireLifecycleEvent(STOP_EVENT, null);\r\n    started = false;\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.Descriptor.createUniqueFilenameAmongst",
	"Comment": "returns string based on the trial name that is guaramteed to be differentfrom any of the strings in the vector of string names.",
	"Method": "String createUniqueFilenameAmongst(String trialName,Vector<String> otherNames){\r\n    int p = trialName.lastIndexOf(\".\");\r\n    if (p < 0) {\r\n        return uniquifyString(trialName, otherNames, 0);\r\n    }\r\n    String ext = trialName.substring(p);\r\n    String file = trialName.substring(0, p);\r\n    Vector<String> nameList = new Vector<String>();\r\n    for (Enumeration e = otherNames.elements(); e.hasMoreElements(); ) {\r\n        String name = e.nextElement().toString();\r\n        if (name.endsWith(ext)) {\r\n            nameList.add(name.substring(0, name.length() - ext.length()));\r\n        }\r\n    }\r\n    String unique = uniquifyString(file, nameList, 0);\r\n    return unique + ext;\r\n}"
}, {
	"Path": "org.apache.naming.resources.WARDirContext.lookupLink",
	"Comment": "retrieves the named object, following links except for the terminal atomic component of the name. if the object bound to name is not a link, returns the object itself.",
	"Method": "Object lookupLink(String name){\r\n    return lookup(name);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.Parser.getOptions",
	"Comment": "returns a map with all the options.the map is indexed by the long name of the option.",
	"Method": "ParameterMap getOptions(){\r\n    return optionsMap;\r\n}"
}, {
	"Path": "org.glassfish.cluster.ssh.util.SSHUtil.register",
	"Comment": "registers a connection for cleanup when the plugin is stopped.",
	"Method": "void register(Session session){\r\n    if (!activeConnections.contains(session)) {\r\n        activeConnections.add(session);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deploy.shared.FileArchive.getDirectories",
	"Comment": "returns the enumeration of first level directories in thisarchive",
	"Method": "Collection<String> getDirectories(){\r\n    List<String> results = new ArrayList<String>();\r\n    if (archive != null) {\r\n        for (File f : archive.listFiles()) {\r\n            if (f.isDirectory() && isEntryValid(f)) {\r\n                results.add(f.getName());\r\n            }\r\n        }\r\n    }\r\n    return results;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.ejb.EjbCheckMgrImpl.isApplicable",
	"Comment": "entity and mdb assertions should not be run for session descriptors and similarly the other way round.",
	"Method": "boolean isApplicable(TestInformation test,Descriptor descriptor){\r\n    String testName = test.getClassName();\r\n    if (descriptor instanceof EjbSessionDescriptor && (testName.indexOf(\"tests.ejb.entity\") >= 0 || testName.indexOf(\"tests.ejb.messagebean\") >= 0))\r\n        return false;\r\n    if (descriptor instanceof EjbEntityDescriptor && (testName.indexOf(\"tests.ejb.session\") >= 0 || testName.indexOf(\"tests.ejb.messagebean\") >= 0))\r\n        return false;\r\n    if (descriptor instanceof EjbMessageBeanDescriptor && (testName.indexOf(\"tests.ejb.session\") >= 0 || testName.indexOf(\"tests.ejb.entity\") >= 0))\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.AbstractRulesImpl.getDigester",
	"Comment": "return the digester instance with which this rules instance isassociated.",
	"Method": "Digester getDigester(){\r\n    return digester;\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutoDeployer.setDirectoryScanner",
	"Comment": "setdirectoryscanner which will be used for filtering out deployeble component",
	"Method": "void setDirectoryScanner(DirectoryScanner ds){\r\n    directoryScanner = ds;\r\n}"
}, {
	"Path": "com.sun.enterprise.server.logging.GFFileHandler.log",
	"Comment": "5005retrieves the logrecord from our queue and store them in the file",
	"Method": "void log(){\r\n    LogRecord record;\r\n    try {\r\n        record = pendingRecords.take();\r\n        super.publish(record);\r\n    } catch (InterruptedException e) {\r\n        return;\r\n    }\r\n    Vector<LogRecord> v = new Vector<LogRecord>();\r\n    int msgs = pendingRecords.drainTo(v, flushFrequency);\r\n    for (int j = 0; j < msgs; j++) {\r\n        super.publish(v.get(j));\r\n    }\r\n    flush();\r\n    if ((rotationRequested.get()) || ((limitForFileRotation > 0) && (meter.written >= limitForFileRotation))) {\r\n        synchronized (rotationLock) {\r\n            rotate();\r\n            rotationRequested.set(false);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.getDefaultSessionTrackingModes",
	"Comment": "gets the session tracking modes that are supported by default for thisservletcontext.",
	"Method": "Set<SessionTrackingMode> getDefaultSessionTrackingModes(){\r\n    if (SecurityUtil.isPackageProtectionEnabled()) {\r\n        return (Set<SessionTrackingMode>) doPrivileged(\"getDefaultSessionTrackingModes\", null);\r\n    } else {\r\n        return context.getDefaultSessionTrackingModes();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.VirtualServerConfig.setDefaultWebXml",
	"Comment": "sets the location of the default web.xml configuration file.",
	"Method": "void setDefaultWebXml(String defaultWebXml){\r\n    this.defaultWebXml = defaultWebXml;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getSessionInternal",
	"Comment": "gets the session associated with this request, creating oneif necessary and requested.",
	"Method": "Session getSessionInternal(Session getSessionInternal,boolean create){\r\n    return doGetSession(create);\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.core.proxy.ProxyFactory.connectionBad",
	"Comment": "the connection is bad. tell each proxy its gone and remove it.",
	"Method": "void connectionBad(){\r\n    final Set<AMXProxy> proxies = new HashSet<AMXProxy>();\r\n    for (final AMXProxy amx : proxies) {\r\n        final AMXProxyHandler proxy = AMXProxyHandler.unwrap(amx);\r\n        proxy.connectionBad();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.EmbeddedWebContainer.createEngine",
	"Comment": "create, configure, and return an engine that will process allhttp requests received from one of the associated connectors,based on the specified properties.do not create the jaas default realm since all children willhave their own.",
	"Method": "Engine createEngine(){\r\n    StandardEngine engine = new StandardEngine();\r\n    engine.setDebug(debug);\r\n    engine.setLogger(super.getLogger());\r\n    engine.setRealm(null);\r\n    return (engine);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.services.impl.monitor.GrizzlyMonitoring.unregisterConnectionQueueStatsProviderGlobal",
	"Comment": "unregister server wide connection queue statistics provider for a network listener",
	"Method": "void unregisterConnectionQueueStatsProviderGlobal(String name){\r\n    final ConnectionQueueStatsProvider connectionQueueStatsProvider = connectionQueueStatsProvidersMap.remove(name);\r\n    if (connectionQueueStatsProvider != null) {\r\n        StatsProviderManager.unregister(connectionQueueStatsProvider);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityCollection.addMethodOmission",
	"Comment": "add an http request method omission to be part of this web resource collection.",
	"Method": "void addMethodOmission(String methodOmission){\r\n    if (methodOmission == null)\r\n        return;\r\n    String[] results = new String[methodOmissions.length + 1];\r\n    for (int i = 0; i < methodOmissions.length; i++) results[i] = methodOmissions[i];\r\n    results[methodOmissions.length] = methodOmission;\r\n    methodOmissions = results;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.loadServlet",
	"Comment": "creates an instance of the servlet, if there is not alreadyat least one initialized instance.",
	"Method": "Servlet loadServlet(){\r\n    if (!singleThreadModel && (instance != null)) {\r\n        return instance;\r\n    }\r\n    long t1 = System.currentTimeMillis();\r\n    loadServletClass();\r\n    Servlet servlet = null;\r\n    try {\r\n        servlet = ((StandardContext) getParent()).createServletInstance(servletClass);\r\n    } catch (ClassCastException e) {\r\n        unavailable(null);\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.CLASS_IS_NOT_SERVLET_EXCEPTION), servletClass.getName());\r\n        throw new ServletException(msg, e);\r\n    } catch (Throwable e) {\r\n        unavailable(null);\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.ERROR_INSTANTIATE_SERVLET_CLASS_EXCEPTION), servletClass.getName());\r\n        throw new ServletException(msg, e);\r\n    }\r\n    if (!isServletAllowed(servlet)) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.PRIVILEGED_SERVLET_CANNOT_BE_LOADED_EXCEPTION), servletClass.getName());\r\n        throw new SecurityException(msg);\r\n    }\r\n    if ((servlet instanceof ContainerServlet) && (isContainerProvidedServlet(servletClass.getName()) || ((Context) getParent()).getPrivileged())) {\r\n        ((ContainerServlet) servlet).setWrapper(this);\r\n    }\r\n    classLoadTime = (int) (System.currentTimeMillis() - t1);\r\n    singleThreadModel = servlet instanceof SingleThreadModel;\r\n    if (singleThreadModel) {\r\n        if (instancePool == null)\r\n            instancePool = new Stack<Servlet>();\r\n    }\r\n    if (notifyContainerListeners) {\r\n        fireContainerEvent(\"load\", this);\r\n    }\r\n    loadTime = System.currentTimeMillis() - t1;\r\n    return servlet;\r\n}"
}, {
	"Path": "org.glassfish.web.util.ExceptionUtils.unwrapInvocationTargetException",
	"Comment": "checks whether the supplied throwable is an instance ofinvocationtargetexception and returns the throwable that iswrapped by it, if there is any.",
	"Method": "Throwable unwrapInvocationTargetException(Throwable t){\r\n    if (t instanceof InvocationTargetException && t.getCause() != null) {\r\n        return t.getCause();\r\n    }\r\n    return t;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.NodeUtils.sanitizeReport",
	"Comment": "takes an action report and updates the message in the report withthe message from the root cause of the report.",
	"Method": "void sanitizeReport(ActionReport report){\r\n    if (report != null && report.hasFailures() && report.getFailureCause() != null) {\r\n        Throwable rootCause = ExceptionUtil.getRootCause(report.getFailureCause());\r\n        if (rootCause != null && StringUtils.ok(rootCause.getMessage())) {\r\n            report.setMessage(rootCause.getMessage());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Response.addSessionCookieInternal",
	"Comment": "special method for adding a session cookie as we should be overriding any previous",
	"Method": "void addSessionCookieInternal(Cookie cookie){\r\n    if (isCommitted())\r\n        return;\r\n    String name = cookie.getName();\r\n    final String headername = \"Set-Cookie\";\r\n    final String startsWith = name + \"=\";\r\n    final String cookieString = getCookieString(cookie);\r\n    boolean set = false;\r\n    MimeHeaders headers = coyoteResponse.getResponse().getHeaders();\r\n    int n = headers.size();\r\n    for (int i = 0; i < n; i++) {\r\n        if (headers.getName(i).toString().equals(headername)) {\r\n            if (headers.getValue(i).toString().startsWith(startsWith)) {\r\n                headers.getValue(i).setString(cookieString);\r\n                set = true;\r\n            }\r\n        }\r\n    }\r\n    if (!set) {\r\n        addHeader(headername, cookieString);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.embed.impl.WebContainerImpl.getVirtualServers",
	"Comment": "gets the collection of virtualserver instances registeredwith this webcontainer.",
	"Method": "Collection<VirtualServer> getVirtualServers(){\r\n    if (!initialized) {\r\n        init();\r\n    }\r\n    List<VirtualServer> virtualServers = new ArrayList<VirtualServer>();\r\n    for (Container child : engine.findChildren()) {\r\n        if (child instanceof VirtualServer) {\r\n            virtualServers.add((VirtualServer) child);\r\n        }\r\n    }\r\n    return virtualServers;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.createListenerInstance",
	"Comment": "instantiates and injects the given eventlistener class for thegiven webmodule",
	"Method": "T createListenerInstance(WebModule module,Class<T> clazz){\r\n    validateJSR299Scope(clazz);\r\n    WebComponentInvocation inv = new WebComponentInvocation(module);\r\n    try {\r\n        invocationMgr.preInvoke(inv);\r\n        return injectionMgr.createManagedObject(clazz);\r\n    } finally {\r\n        invocationMgr.postInvoke(inv);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.LibrariesTldProvider.getTldListenerMap",
	"Comment": "gets a mapping from jar files to their tld resourcesthat are known to contain listener declarations.",
	"Method": "Map<URI, List<String>> getTldListenerMap(){\r\n    return cloneTldMap();\r\n}"
}, {
	"Path": "org.apache.catalina.session.ManagerBase.getContainer",
	"Comment": "return the container with which this manager is associated.",
	"Method": "Container getContainer(){\r\n    return container;\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.setSipApplicationSessionId",
	"Comment": "sets the id of the sipapplicationsession that is the parent of thisstandardsession.",
	"Method": "void setSipApplicationSessionId(String id){\r\n    sipAppSessionId = id;\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.setAuthType",
	"Comment": "set the authentication type used to authenticate our cachedprincipal, if any.",
	"Method": "void setAuthType(String authType){\r\n    this.authType = authType;\r\n}"
}, {
	"Path": "org.glassfish.cluster.ssh.launcher.SSHLauncher.commandListToQuotedString",
	"Comment": "take a command in the form of a list and convert it to a command string.if any string in the list has spaces then the string is quoted beforebeing added to the final command string.",
	"Method": "String commandListToQuotedString(List<String> command){\r\n    if (command.size() == 1)\r\n        return command.get(0);\r\n    StringBuilder commandBuilder = new StringBuilder();\r\n    boolean first = true;\r\n    for (String s : command) {\r\n        if (!first) {\r\n            commandBuilder.append(\" \");\r\n        } else {\r\n            first = false;\r\n        }\r\n        if (s.contains(\" \")) {\r\n            commandBuilder.append(FileUtils.quoteString(s));\r\n        } else {\r\n            commandBuilder.append(s);\r\n        }\r\n    }\r\n    return commandBuilder.toString();\r\n}"
}, {
	"Path": "org.glassfish.faces.integration.GlassFishInjectionProvider.enableHighAvailability",
	"Comment": "method to test with ha has been enabled.if so, then set the jsf context paramcom.sun.faces.enableagressivesessiondirtying to true",
	"Method": "void enableHighAvailability(ServletContext ctx){\r\n    WebConfiguration config = WebConfiguration.getInstance(ctx);\r\n    if (!config.isSet(WebConfiguration.BooleanWebContextInitParameter.EnableAgressiveSessionDirtying)) {\r\n        Object isDistributableObj = ctx.getAttribute(Constants.IS_DISTRIBUTABLE_ATTRIBUTE);\r\n        Object enableHAObj = ctx.getAttribute(Constants.ENABLE_HA_ATTRIBUTE);\r\n        if (isDistributableObj instanceof Boolean && enableHAObj instanceof Boolean) {\r\n            boolean isDistributable = ((Boolean) isDistributableObj).booleanValue();\r\n            boolean enableHA = ((Boolean) enableHAObj).booleanValue();\r\n            if (LOGGER.isLoggable(Level.FINE)) {\r\n                LOGGER.log(Level.FINE, \"isDistributable = {0} enableHA = {1}\", new Object[] { isDistributable, enableHA });\r\n            }\r\n            if (isDistributable && enableHA) {\r\n                if (LOGGER.isLoggable(Level.FINE)) {\r\n                    LOGGER.fine(\"setting the EnableAgressiveSessionDirtying to true\");\r\n                }\r\n                config.overrideContextInitParameter(WebConfiguration.BooleanWebContextInitParameter.EnableAgressiveSessionDirtying, Boolean.TRUE);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.CommandModelData.unknownOptionsAreOperands",
	"Comment": "should an unknown option be considered an operand by asadmin?",
	"Method": "boolean unknownOptionsAreOperands(){\r\n    return dashOk;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServerFacade.addContext",
	"Comment": "registers the given context with this virtualserverat the given context root.if this virtualserver has already been started, thegiven context will be started as well.",
	"Method": "void addContext(Context context,String contextRoot){\r\n    if (vs != null) {\r\n        vs.addContext(context, contextRoot);\r\n    } else {\r\n        throw new GlassFishException(\"Virtual server \" + id + \" has not been added\");\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.api.admin.AdminCommandLock.runWithSuspendedLock",
	"Comment": "use this method to temporarily suspend the command lock duringwhich other operations may be performed.when the method returnsthe lock will be reestablished.this method must be invoked from the same thread which acquired the original lock.",
	"Method": "void runWithSuspendedLock(Runnable r){\r\n    Lock lock = null;\r\n    try {\r\n        if (rwlock.isWriteLockedByCurrentThread()) {\r\n            lock = rwlock.writeLock();\r\n        } else if (rwlock.getReadHoldCount() > 0) {\r\n            lock = rwlock.readLock();\r\n        }\r\n        if (lock != null)\r\n            lock.unlock();\r\n        r.run();\r\n    } finally {\r\n        if (lock != null)\r\n            lock.lock();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.createListener",
	"Comment": "instantiates the given eventlistener class and performs anyrequired resource injection into the new eventlistener instancebefore returning it.",
	"Method": "T createListener(Class<T> clazz){\r\n    if (SecurityUtil.isPackageProtectionEnabled()) {\r\n        return (T) doPrivileged(\"createListener\", new Object[] { clazz });\r\n    } else {\r\n        return context.createListener(clazz);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.ssi.ExpressionParseTree.resolveGroup",
	"Comment": "resolves all pending opp nodes on the stack until the next group markeris reached.",
	"Method": "void resolveGroup(){\r\n    OppNode top = null;\r\n    while ((top = oppStack.remove(0)) != null) {\r\n        top.popValues(nodeStack);\r\n        nodeStack.add(0, top);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.JobCleanUpService.scheduleCleanUp",
	"Comment": "this will schedule a cleanup of expired jobs based on configurable values",
	"Method": "void scheduleCleanUp(){\r\n    logger.fine(KernelLoggerInfo.schedulingCleanup);\r\n    long delayBetweenRuns = 1200000;\r\n    long initialDelay = 1200000;\r\n    delayBetweenRuns = jobManagerService.convert(managedJobConfig.getPollInterval());\r\n    initialDelay = jobManagerService.convert(managedJobConfig.getInitialDelay());\r\n    ScheduledFuture<?> cleanupFuture = scheduler.scheduleAtFixedRate(new JobCleanUpTask(), initialDelay, delayBetweenRuns, TimeUnit.MILLISECONDS);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteAdminCommand.setInteractive",
	"Comment": "set the interactive mode for the command.by default, the command isinteractive.",
	"Method": "void setInteractive(boolean state){\r\n    this.interactive = state;\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.DeleteProtocol.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    ActionReport report = context.getActionReport();\r\n    NetworkConfig networkConfig = config.getNetworkConfig();\r\n    Protocols protocols = networkConfig.getProtocols();\r\n    try {\r\n        protocol = protocols.findProtocol(protocolName);\r\n        if (protocol == null) {\r\n            report.setMessage(MessageFormat.format(rb.getString(LogFacade.DELETE_PROTOCOL_NOT_EXISTS), protocolName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n        List<NetworkListener> nwlsnrList = protocol.findNetworkListeners();\r\n        for (NetworkListener nwlsnr : nwlsnrList) {\r\n            if (protocol.getName().equals(nwlsnr.getProtocol())) {\r\n                report.setMessage(MessageFormat.format(rb.getString(LogFacade.DELETE_PROTOCOL_BEING_USED), protocolName, nwlsnr.getName()));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n        ConfigSupport.apply(new SingleConfigCode<Protocols>() {\r\n            public Object run(Protocols param) {\r\n                param.getProtocol().remove(protocol);\r\n                return protocol;\r\n            }\r\n        }, protocols);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.DELETE_PROTOCOL_FAIL), protocolName) + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.DeleteProtocol.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    param.getProtocol().remove(protocol);\r\n    return protocol;\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.ListTransports.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    final ActionReport report = context.getActionReport();\r\n    List<Transport> list = config.getNetworkConfig().getTransports().getTransport();\r\n    for (Transport transport : list) {\r\n        report.getTopMessagePart().addChild().setMessage(transport.getName());\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.util.ObjectNameBuilder.getAncestors",
	"Comment": "return a list of ancestors, with the child itself last in the list.",
	"Method": "List<ObjectName> getAncestors(MBeanServer server,ObjectName start){\r\n    AMXProxy amx = ProxyFactory.getInstance(server).getProxy(start, AMXProxy.class);\r\n    final List<ObjectName> ancestors = new ArrayList<ObjectName>();\r\n    AMXProxy parent = null;\r\n    while ((parent = amx.parent()) != null) {\r\n        ancestors.add(parent.extra().objectName());\r\n        amx = parent;\r\n    }\r\n    Collections.reverse(ancestors);\r\n    ancestors.add(start);\r\n    return ancestors;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.loadListener",
	"Comment": "loads and instantiates the listener with the specified classname.",
	"Method": "EventListener loadListener(ClassLoader loader,String listenerClassName){\r\n    if (log.isLoggable(Level.FINE)) {\r\n        log.log(Level.FINE, \"Configuring event listener class '\" + neutralizeForLog(listenerClassName) + \"'\");\r\n    }\r\n    return createListener((Class<EventListener>) loader.loadClass(listenerClassName));\r\n}"
}, {
	"Path": "samples.amx.Samples.demoJMXMonitor",
	"Comment": "demonstrates the use of a javax.management.monitor mbean\t\tto be notified of changes in the value of an attribute.",
	"Method": "void demoJMXMonitor(){\r\n    final JMXMonitorMgr mgr = getDomainRoot().getJMXMonitorMgr();\r\n    final String attrName = \"SampleString\";\r\n    final String attrValue = \"hello\";\r\n    final SampleListener sampleListener = new SampleListener();\r\n    final MBeanServerConnection conn = Util.getExtra(mgr).getConnectionSource().getExistingMBeanServerConnection();\r\n    conn.addNotificationListener(getMBeanServerDelegateObjectName(), sampleListener, null, null);\r\n    final Sample sample = (Sample) getDomainRoot().getContainee(XTypes.SAMPLE);\r\n    final String monitorName = \"SampleStringMonitor\";\r\n    AMXStringMonitor mon = null;\r\n    try {\r\n        try {\r\n            mgr.remove(monitorName);\r\n        } catch (Exception e) {\r\n        }\r\n        mon = mgr.createStringMonitor(monitorName);\r\n        waitMBeanServerNotification(sampleListener, MBeanServerNotification.REGISTRATION_NOTIFICATION, Util.getObjectName(mon));\r\n        sample.addAttribute(attrName, attrValue);\r\n        mon.addNotificationListener(sampleListener, null, null);\r\n        mon.setObservedAttribute(attrName);\r\n        mon.setStringToCompare(attrValue);\r\n        mon.setNotifyDiffer(true);\r\n        mon.setNotifyMatch(true);\r\n        mon.addObservedObject(Util.getObjectName(sample));\r\n        final StdAttributesAccess attrs = Util.getExtra(sample);\r\n        attrs.setAttribute(new Attribute(attrName, \"goodbye\"));\r\n        attrs.setAttribute(new Attribute(attrName, attrValue));\r\n        sample.removeAttribute(attrName);\r\n        final Map notifs = sampleListener.getNotifsReceived();\r\n        waitNumNotifs(notifs, AttributeChangeNotification.ATTRIBUTE_CHANGE, 4);\r\n    } catch (Throwable t) {\r\n        t.printStackTrace();\r\n    } finally {\r\n        try {\r\n            mon.removeNotificationListener(sampleListener);\r\n            if (mon != null) {\r\n                mgr.remove(mon.getName());\r\n                waitMBeanServerNotification(sampleListener, MBeanServerNotification.UNREGISTRATION_NOTIFICATION, Util.getObjectName(mon));\r\n            }\r\n            conn.removeNotificationListener(getMBeanServerDelegateObjectName(), sampleListener);\r\n        } catch (ListenerNotFoundException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.setProperty",
	"Comment": "set the current value of the specified property for the underlyingxmlreader implementation.see for information about the standard sax2 properties.",
	"Method": "void setProperty(String property,Object value){\r\n    getParser().setProperty(property, value);\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebResourceCollectionImpl.addHttpMethodOmission",
	"Comment": "adds the given http method omission to the collection of http methods thiscollection has.",
	"Method": "void addHttpMethodOmission(String httpMethodOmission){\r\n    this.getHttpMethodOmissions().add(httpMethodOmission);\r\n}"
}, {
	"Path": "org.glassfish.api.deployment.MetaData.provides",
	"Comment": "returns the list of types of metadata this deployer will provide to the deployementcontext upon the successful completion of the prepare method.",
	"Method": "Class[] provides(){\r\n    if (provides == null) {\r\n        return empty;\r\n    }\r\n    return provides;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.cli.StopDomainCommand.dasNotRunning",
	"Comment": "print message and return exit code whenwe detect that the das is not running.",
	"Method": "int dasNotRunning(){\r\n    if (kill) {\r\n        if (isLocal())\r\n            return kill();\r\n        else\r\n            throw new CommandException(Strings.get(\"StopDomain.dasNotRunningRemotely\"));\r\n    }\r\n    if (isLocal())\r\n        logger.warning(Strings.get(\"StopDomain.dasNotRunning\", getDomainRootDir()));\r\n    else\r\n        logger.warning(Strings.get(\"StopDomain.dasNotRunningRemotely\"));\r\n    return 0;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.remote.RemoteCommand.executeAndReturnAttributes",
	"Comment": "execute the command and return the main attributes from the manifestinstead of writing out the output.",
	"Method": "Map<String, String> executeAndReturnAttributes(String args){\r\n    returnAttributes = true;\r\n    execute(args);\r\n    returnAttributes = false;\r\n    return attrs;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.TagLibTest.returnTypeMatch",
	"Comment": "checks if the return type specified in this method m and the return typerequired matches",
	"Method": "boolean returnTypeMatch(Method m,String retType){\r\n    Class ret = m.getReturnType();\r\n    Class retTypeClass = checkIfPrimitive(retType);\r\n    if (retTypeClass == null)\r\n        ;\r\n    try {\r\n        retTypeClass = Class.forName(retType);\r\n    } catch (ClassNotFoundException e) {\r\n    }\r\n    if (retTypeClass != null)\r\n        return retTypeClass.equals(ret);\r\n    else\r\n        return false;\r\n}"
}, {
	"Path": "org.glassfish.internal.embedded.Server.createConfig",
	"Comment": "get the embedded container builder for a container type identified by itsname.",
	"Method": "ContainerBuilder<EmbeddedContainer> createConfig(ContainerBuilder.Type type,ContainerBuilder<EmbeddedContainer> createConfig,String name,T createConfig,Class<T> configType){\r\n    return habitat.getService(configType);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentTransaction.removeSuspended",
	"Comment": "removes the given control object from the set of those suspended in theprocess. the operation returns false if the control object has not beensuspended.",
	"Method": "boolean removeSuspended(ControlImpl control){\r\n    boolean result = true;\r\n    if (statsOn)\r\n        result = suspended.removeElement(control);\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.realm.RealmBase.authenticate",
	"Comment": "return the principal associated with the specified chain of x509client certificates.if there is none, return null.",
	"Method": "Principal authenticate(String username,char[] credentials,Principal authenticate,String username,char[] clientDigest,String nOnce,String nc,String cnonce,String qop,String realm,char[] md5a2,Principal authenticate,X509Certificate certs,Principal authenticate,HttpServletRequest hreq){\r\n    throw new UnsupportedOperationException();\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteAdminCommand.reportAuthenticationException",
	"Comment": "return the error message to be used in the authenticationexception.subclasses can override to provide a more detailed message, forexample, indicating the source of the password that failed.the implementation in this class returns a default error message.",
	"Method": "String reportAuthenticationException(){\r\n    return strings.get(\"InvalidCredentials\", user);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RecoveryManager.recoverXAResources",
	"Comment": "recovers the in doubt transactions from the provided list ofxaresource objects. this method is never called by the recoverythread, and its the application threads which wants to pass inthe xa resources that call this.",
	"Method": "void recoverXAResources(Enumeration xaResources){\r\n    String manualRecovery = Configuration.getPropertyValue(Configuration.MANUAL_RECOVERY);\r\n    if (manualRecovery == null || !(manualRecovery.equalsIgnoreCase(\"true\"))) {\r\n        return;\r\n    }\r\n    synchronized (lockObject) {\r\n        if (uniqueRMSetReady.isPosted() == false) {\r\n            RecoveryManager.uniqueRMSet = getUniqueRMSet(xaResources);\r\n            uniqueRMSetReady.post();\r\n            waitForResync();\r\n            return;\r\n        } else {\r\n            RecoveryManager.waitForResync();\r\n            RecoveryManager.uniqueRMSet = getUniqueRMSet(xaResources);\r\n            proceedWithXARecovery();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.api.ActionReport.findProperty",
	"Comment": "search in message parts properties then in extra properties and thenin sub reports. returns first occurrence of the key.",
	"Method": "String findProperty(String key,String findProperty,String key){\r\n    MessagePart topMessagePart = getTopMessagePart();\r\n    if (topMessagePart != null) {\r\n        String value = topMessagePart.findProperty(key);\r\n        if (value != null) {\r\n            return value;\r\n        }\r\n    }\r\n    if (extraProperties != null) {\r\n        String value = extraProperties.getProperty(key);\r\n        if (value != null) {\r\n            return value;\r\n        }\r\n    }\r\n    if (getSubActionsReport() != null) {\r\n        for (ActionReport subReport : getSubActionsReport()) {\r\n            String value = subReport.findProperty(key);\r\n            if (value != null) {\r\n                return value;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteRestAdminCommand.getAttributes",
	"Comment": "after a successful command execution, the attributes returnedby the command are saved.this method returns those savedattributes.",
	"Method": "Map<String, String> getAttributes(){\r\n    return attrs;\r\n}"
}, {
	"Path": "org.apache.catalina.session.ManagerBase.remove",
	"Comment": "remove this session from the active sessions for this manager.",
	"Method": "void remove(Session session){\r\n    sessions.remove(session.getIdInternal());\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.ejbfindbyprimarykey.EjbFindByPrimaryKeyFinal.check",
	"Comment": "define ejbfindbyprimarykey method final test.every entity enterprise bean class must define the ejbfindbyprimarykey method. the method must not be declared as final.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (descriptor instanceof EjbEntityDescriptor) {\r\n        String persistentType = ((EjbEntityDescriptor) descriptor).getPersistenceType();\r\n        if (EjbEntityDescriptor.BEAN_PERSISTENCE.equals(persistentType)) {\r\n            boolean ejbFindByPrimaryKeyMethodFound = false;\r\n            boolean isFinal = false;\r\n            boolean oneFailed = false;\r\n            int findMethodModifiers = 0;\r\n            try {\r\n                VerifierTestContext context = getVerifierContext();\r\n                ClassLoader jcl = context.getClassLoader();\r\n                Class EJBClass = Class.forName(descriptor.getEjbClassName(), false, getVerifierContext().getClassLoader());\r\n                do {\r\n                    Method[] ejbFinderMethods = EJBClass.getDeclaredMethods();\r\n                    for (int j = 0; j < ejbFinderMethods.length; ++j) {\r\n                        if (ejbFinderMethods[j].getName().equals(\"ejbFindByPrimaryKey\")) {\r\n                            ejbFindByPrimaryKeyMethodFound = true;\r\n                            findMethodModifiers = ejbFinderMethods[j].getModifiers();\r\n                            if (Modifier.isFinal(findMethodModifiers)) {\r\n                                isFinal = true;\r\n                            }\r\n                            if (ejbFindByPrimaryKeyMethodFound && !isFinal) {\r\n                                result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                                result.addGoodDetails(smh.getLocalString(getClass().getName() + \".debug1\", \"For EJB Class [ {0} ] Finder method [ {1} ]\", new Object[] { EJBClass.getName(), ejbFinderMethods[j].getName() }));\r\n                                result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"A non-final [ {0} ] method was found.\", new Object[] { ejbFinderMethods[j].getName() }));\r\n                            } else if (ejbFindByPrimaryKeyMethodFound && isFinal) {\r\n                                oneFailed = true;\r\n                                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                                result.addErrorDetails(smh.getLocalString(getClass().getName() + \".debug1\", \"For EJB Class [ {0} ] Finder method [ {1} ]\", new Object[] { EJBClass.getName(), ejbFinderMethods[j].getName() }));\r\n                                result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: A final [ {0} ] method was found, but [ {1} ] cannot be declared as final.\", new Object[] { ejbFinderMethods[j].getName(), ejbFinderMethods[j].getName() }));\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                } while (((EJBClass = EJBClass.getSuperclass()) != null) && (!ejbFindByPrimaryKeyMethodFound));\r\n                if (!ejbFindByPrimaryKeyMethodFound) {\r\n                    oneFailed = true;\r\n                    result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                    result.addErrorDetails(smh.getLocalString(getClass().getName() + \".debug3\", \"For EJB Class [ {0} ]\", new Object[] { descriptor.getEjbClassName() }));\r\n                    result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed1\", \"Error: No ejbFindByPrimaryKey method was found in bean class.\"));\r\n                }\r\n            } catch (ClassNotFoundException e) {\r\n                Verifier.debug(e);\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.failed(smh.getLocalString(getClass().getName() + \".failedException\", \"Error: EJB Class [ {0} ] does not exist or is not loadable.\", new Object[] { descriptor.getEjbClassName() }));\r\n                oneFailed = true;\r\n            }\r\n            if (oneFailed) {\r\n                result.setStatus(result.FAILED);\r\n            } else {\r\n                result.setStatus(result.PASSED);\r\n            }\r\n        } else {\r\n            result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable2\", \"Expected persistence type [ {0} ], but bean [ {1} ] has persistence type [ {2} ]\", new Object[] { EjbEntityDescriptor.BEAN_PERSISTENCE, descriptor.getName(), persistentType }));\r\n        }\r\n        return result;\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"[ {0} ] expected {1} bean, but called with {2} bean.\", new Object[] { getClass(), \"Entity\", \"Session\" }));\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.internal.data.ApplicationInfo.save",
	"Comment": "saves its state to the configuration. this method must be called within a transactionto the configured application instance.",
	"Method": "void save(Application app){\r\n    for (EngineRef ref : engines) {\r\n        Engine engine = app.createChild(Engine.class);\r\n        app.getEngine().add(engine);\r\n        ref.save(engine);\r\n    }\r\n    for (ModuleInfo module : modules) {\r\n        Module modConfig = app.getModule(module.getName());\r\n        if (modConfig == null) {\r\n            modConfig = app.createChild(Module.class);\r\n            modConfig.setName(module.getName());\r\n            app.getModule().add(modConfig);\r\n        }\r\n        module.save(modConfig);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.common.util.timer.TimerSchedule.isValid",
	"Comment": "returns true if this date can be used for the next timeout ofthe schedule represented by this instance.",
	"Method": "boolean isValid(Calendar date){\r\n    if ((end_ != null && date.getTimeInMillis() > end_.getTime())) {\r\n        return false;\r\n    }\r\n    if (years.size() == 0) {\r\n        return isValid;\r\n    }\r\n    Calendar now = new GregorianCalendar(Locale.ENGLISH);\r\n    if (tz_ != null) {\r\n        now.setTimeZone(tz_);\r\n    }\r\n    int currYear = now.get(Calendar.YEAR);\r\n    for (int year : years) {\r\n        if (year < currYear) {\r\n            continue;\r\n        }\r\n        if (date.get(Calendar.YEAR) == year) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.ConfigAttributeSetTest.getFileName",
	"Comment": "returns the domaintest file name without the .xml extension to load the test configurationfrom.",
	"Method": "String getFileName(){\r\n    return \"DomainTest\";\r\n}"
}, {
	"Path": "testmbeans.ObjectNameSelfProviderDynamicSupport.getAttributes",
	"Comment": "enables the get values of several attributes of the dynamic mbean.",
	"Method": "AttributeList getAttributes(String[] attributeNames){\r\n    AttributeList resultList = new AttributeList();\r\n    for (int i = 0; i < attributeNames.length; i++) {\r\n        try {\r\n            Object value = getAttribute((String) attributeNames[i]);\r\n            resultList.add(new Attribute(attributeNames[i], value));\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return resultList;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.isDirectoryListing",
	"Comment": "checks whether directory listings are enabled or disabled on thiscontext.",
	"Method": "boolean isDirectoryListing(){\r\n    return directoryListing;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModule.setFileEncoding",
	"Comment": "sets the file encoding of all static resources of this web module.",
	"Method": "void setFileEncoding(String enc){\r\n    this.fileEncoding = enc;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RecoveryManager.getLocalCoordinator",
	"Comment": "returns a reference to the coordinator object that corresponds to thelocal identifier passed as a parameter.",
	"Method": "CoordinatorImpl getLocalCoordinator(Long localTID){\r\n    CoordinatorImpl result = (CoordinatorImpl) coordsByLocalTID.get(localTID);\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.hasRegistered",
	"Comment": "checks whether the subcoordinator has registered with its superior.",
	"Method": "boolean hasRegistered(){\r\n    boolean result = registered;\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.server.ServerEnvironmentImpl.getInstanceName",
	"Comment": "every server has a name that can be found in the server element in domain.xml",
	"Method": "String getInstanceName(){\r\n    return instanceName;\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.SecurityConstraint.setUserDataConstraint",
	"Comment": "sets therequirement that the constrained requests be receivedover a protected transport layer connection. this guarantees howthe data will be transported between client and server. the choicesfor type of transport guarantee include none, integral, andconfidential. if no user data constraint applies to a request, thecontainer must accept the request when received over any connection,including an unprotected one.",
	"Method": "void setUserDataConstraint(TransportGuarantee tg){\r\n    this.tg = tg;\r\n}"
}, {
	"Path": "org.glassfish.security.common.FileRealmHelper.validateGroupList",
	"Comment": "validates syntax of a list of group names.this is equivalent to calling validategroupname on every elementof the grouplist.",
	"Method": "void validateGroupList(String[] groupList){\r\n    if (groupList == null || groupList.length == 0) {\r\n        return;\r\n    }\r\n    for (int i = 0; i < groupList.length; i++) {\r\n        validateGroupName(groupList[i]);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.weld.connector.WeldUtils.getCDIEnablingAnnotations",
	"Comment": "get the names of any annotation types that are applied to beans, which should enable cdiprocessing even in the absence of a beans.xml descriptor.",
	"Method": "String[] getCDIEnablingAnnotations(DeploymentContext context){\r\n    List<String> result = new ArrayList<String>();\r\n    Types types = getTypes(context);\r\n    if (types != null) {\r\n        Iterator<Type> typesIter = types.getAllTypes().iterator();\r\n        while (typesIter.hasNext()) {\r\n            Type type = typesIter.next();\r\n            if (!(type instanceof AnnotationType)) {\r\n                Iterator<AnnotationModel> annotations = type.getAnnotations().iterator();\r\n                while (annotations.hasNext()) {\r\n                    AnnotationModel am = annotations.next();\r\n                    AnnotationType at = am.getType();\r\n                    if (isCDIEnablingAnnotation(at)) {\r\n                        if (!result.contains(at.getName())) {\r\n                            result.add(at.getName());\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result.toArray(new String[result.size()]);\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.copy",
	"Comment": "create and return a temporary loader with the same visibility as this loader. the temporary loader may be used to load resources or any other application classes for the purposes of introspecting them for annotations. the persistence provider should not maintain any references to the temporary loader, or any objects loaded by it.",
	"Method": "ClassLoader copy(){\r\n    logger.entering(\"WebModuleListener$InstrumentableWebappClassLoader\", \"copy\");\r\n    return AccessController.doPrivileged(new PrivilegedAction<URLClassLoader>() {\r\n        @Override\r\n        public URLClassLoader run() {\r\n            return new URLClassLoader(getURLs(), getParent());\r\n        }\r\n    });\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.copy",
	"Comment": "create and return a temporary loader with the same visibility as this loader. the temporary loader may be used to load resources or any other application classes for the purposes of introspecting them for annotations. the persistence provider should not maintain any references to the temporary loader, or any objects loaded by it.",
	"Method": "ClassLoader copy(){\r\n    return new URLClassLoader(getURLs(), getParent());\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.utils.ResourceUtil.getCommand",
	"Comment": "returns the name of the command associated with this resource,if any, forthe given operation.",
	"Method": "String getCommand(RestRedirect.OpType type,ConfigModel model){\r\n    Class<? extends ConfigBeanProxy> cbp = null;\r\n    try {\r\n        cbp = (Class<? extends ConfigBeanProxy>) model.classLoaderHolder.loadClass(model.targetTypeName);\r\n    } catch (MultiException e) {\r\n        e.printStackTrace();\r\n    }\r\n    if (cbp != null) {\r\n        RestRedirects restRedirects = cbp.getAnnotation(RestRedirects.class);\r\n        if (restRedirects != null) {\r\n            RestRedirect[] values = restRedirects.value();\r\n            for (RestRedirect r : values) {\r\n                if (r.opType().equals(type)) {\r\n                    return r.commandName();\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.internal.embedded.Server.stop",
	"Comment": "stops the embedded server instance, any deployed application will be stoppedports will be closed and shutdown services will be ran.embeddedfilesystem will be released, meaning that any managed directory willbe deleted rendering the embeddedfilesystem unusable.",
	"Method": "void stop(){\r\n    try {\r\n        if (glassfish != null) {\r\n            glassfish.stop();\r\n            logger.finer(\"GlassFish has been stopped\");\r\n        }\r\n        if (glassfishRuntime != null) {\r\n            glassfishRuntime.shutdown();\r\n            logger.finer(\"GlassFishruntime has been shutdown\");\r\n        }\r\n    } catch (Exception ex) {\r\n        logger.log(Level.WARNING, ex.getMessage(), ex);\r\n    } finally {\r\n        synchronized (servers) {\r\n            servers.remove(serverName);\r\n        }\r\n        fileSystem.getService().preDestroy();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getRemoteUser",
	"Comment": "return the name of the remote user that has been authenticatedfor this request.",
	"Method": "String getRemoteUser(){\r\n    if (userPrincipal != null) {\r\n        return userPrincipal.getName();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.utils.Util.getFormattingIndentLevel",
	"Comment": "get the current configured indenting value for the rest layer",
	"Method": "int getFormattingIndentLevel(){\r\n    RestConfig rg = ResourceUtil.getRestConfig(Globals.getDefaultBaseServiceLocator());\r\n    if (rg == null) {\r\n        return -1;\r\n    } else {\r\n        return Integer.parseInt(rg.getIndentLevel());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.cli.CreateDomainCommand.verifyPortBasePortIsValid",
	"Comment": "verify that the portbase port is valid port must be greater than 0 andless than 65535. this method will also check if the port is in used.",
	"Method": "void verifyPortBasePortIsValid(String portName,int portNum){\r\n    if (portNum <= 0 || portNum > PORT_MAX_VAL) {\r\n        throw new CommandValidationException(strings.get(\"InvalidPortBaseRange\", portNum, portName));\r\n    }\r\n    if (checkPorts && !NetUtils.isPortFree(portNum)) {\r\n        throw new CommandValidationException(strings.get(\"PortBasePortInUse\", portNum, portName));\r\n    }\r\n    logger.log(Level.FINER, \"Port ={0}\", portNum);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmrFieldAccessorModifiers.runIndividualCmrTest",
	"Comment": "run an individual verifier test of a declated cmp field of the class",
	"Method": "boolean runIndividualCmrTest(Descriptor entity,RelationRoleDescriptor rrd,Class c,Result result){\r\n    return accessorMethodModifiers(rrd.getCMRField(), c, result);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.RepositoryNameValidator.checkValidXmlToken",
	"Comment": "implementation copied from com.sun.enterprise.admin.verifier.tests.statictest",
	"Method": "void checkValidXmlToken(String name){\r\n    try {\r\n        String xml = XML_1 + name + XML_2;\r\n        ByteArrayInputStream bais = new ByteArrayInputStream(xml.getBytes());\r\n        InputSource is = new InputSource(bais);\r\n        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\r\n        dbf.setValidating(false);\r\n        DocumentBuilder db = dbf.newDocumentBuilder();\r\n        db.parse(is);\r\n    } catch (Exception e) {\r\n        throw new InvalidConfigException(strMgr.getString(\"validator.invalid_value\", getName(), name));\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ExtendedAccessLogValve.getCondition",
	"Comment": "return whether the attribute name to look for whenperforming conditional loggging. if null, everyrequest is logged.",
	"Method": "String getCondition(){\r\n    return condition;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.CompositeUtil.executeSseCommand",
	"Comment": "execute an admincommand with the specified parameters andreturn eventoutput suitable for sse.",
	"Method": "EventOutput executeSseCommand(Subject subject,String command,ParameterMap parameters,EventOutput executeSseCommand,Subject subject,String command,ParameterMap parameters,SseCommandHelper.ActionReportProcessor processor){\r\n    return ResourceUtil.runCommandWithSse(command, parameters, subject, processor);\r\n}"
}, {
	"Path": "org.apache.naming.resources.WebDirContext.getAttributes",
	"Comment": "retrieves selected attributes associated with a named object. see the class description regarding attribute models, attribute type names, and operational attributes.",
	"Method": "Attributes getAttributes(String name,String[] attrIds){\r\n    File file = file(name);\r\n    if (file == null) {\r\n        JarFileEntry jfEntry = lookupFromJars(name);\r\n        if (jfEntry == null) {\r\n            throw new NamingException(MessageFormat.format(rb.getString(LogFacade.RESOURCES_NOT_FOUND), name));\r\n        } else {\r\n            return new JarResourceAttributes(jfEntry.getJarEntry());\r\n        }\r\n    } else {\r\n        return new FileResourceAttributes(file);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.archivist.WebArchivist.readStandardFragments",
	"Comment": "this method will return the list of web fragment in the desired order.",
	"Method": "List<WebFragmentDescriptor> readStandardFragments(WebBundleDescriptorImpl descriptor,ReadableArchive archive){\r\n    List<WebFragmentDescriptor> wfList = new ArrayList<WebFragmentDescriptor>();\r\n    Vector libs = getLibraries(archive);\r\n    if (libs != null && libs.size() > 0) {\r\n        for (int i = 0; i < libs.size(); i++) {\r\n            String lib = (String) libs.get(i);\r\n            Archivist wfArchivist = new WebFragmentArchivist(this, habitat);\r\n            wfArchivist.setRuntimeXMLValidation(this.getRuntimeXMLValidation());\r\n            wfArchivist.setRuntimeXMLValidationLevel(this.getRuntimeXMLValidationLevel());\r\n            wfArchivist.setAnnotationProcessingRequested(false);\r\n            WebFragmentDescriptor wfDesc = null;\r\n            ReadableArchive embeddedArchive = archive.getSubArchive(lib);\r\n            try {\r\n                if (embeddedArchive != null && wfArchivist.hasStandardDeploymentDescriptor(embeddedArchive)) {\r\n                    try {\r\n                        wfDesc = (WebFragmentDescriptor) wfArchivist.open(embeddedArchive);\r\n                    } catch (SAXException ex) {\r\n                        IOException ioex = new IOException();\r\n                        ioex.initCause(ex);\r\n                        throw ioex;\r\n                    }\r\n                } else {\r\n                    wfDesc = new WebFragmentDescriptor();\r\n                }\r\n            } finally {\r\n                if (embeddedArchive != null) {\r\n                    embeddedArchive.close();\r\n                }\r\n            }\r\n            wfDesc.setJarName(lib.substring(lib.lastIndexOf('/') + 1));\r\n            wfList.add(wfDesc);\r\n            descriptor.putJarNameWebFragmentNamePair(wfDesc.getJarName(), wfDesc.getName());\r\n        }\r\n        if (((WebBundleDescriptorImpl) descriptor).getAbsoluteOrderingDescriptor() != null) {\r\n            wfList = ((WebBundleDescriptorImpl) descriptor).getAbsoluteOrderingDescriptor().order(wfList);\r\n        } else {\r\n            OrderingDescriptor.sort(wfList);\r\n        }\r\n        for (WebFragmentDescriptor wf : wfList) {\r\n            descriptor.addOrderedLib(wf.getJarName());\r\n        }\r\n    }\r\n    return wfList;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setCaseSensitiveMapping",
	"Comment": "set case sensitivity for filter and security constraint mappings.",
	"Method": "void setCaseSensitiveMapping(boolean caseSensitiveMap){\r\n    caseSensitiveMapping = caseSensitiveMap;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentImpl.set_timeout",
	"Comment": "sets the timeout value to be used for all subsequent transactions.",
	"Method": "void set_timeout(int timeout){\r\n    if (timeout >= 0) {\r\n        timeOut = timeout;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.valves.PersistentValve.invoke",
	"Comment": "select the appropriate child context to process this request,based on the specified request uri.if no matching context canbe found, return an appropriate http error.",
	"Method": "int invoke(Request request,Response response){\r\n    Context context = request.getContext();\r\n    if (context == null) {\r\n        ((HttpServletResponse) response.getResponse()).sendError(HttpServletResponse.SC_INTERNAL_SERVER_ERROR, rb.getString(LogFacade.NO_CONTEXT_CONFIGURED));\r\n        return END_PIPELINE;\r\n    }\r\n    Thread.currentThread().setContextClassLoader(context.getLoader().getClassLoader());\r\n    HttpServletRequest hreq = (HttpServletRequest) request.getRequest();\r\n    String sessionId = hreq.getRequestedSessionId();\r\n    Manager manager = context.getManager();\r\n    if (sessionId != null && manager != null) {\r\n        if (manager instanceof PersistentManager) {\r\n            Store store = ((PersistentManager) manager).getStore();\r\n            if (store != null) {\r\n                Session session = null;\r\n                try {\r\n                    session = store.load(sessionId);\r\n                } catch (Exception e) {\r\n                    log(\"deserializeError\");\r\n                }\r\n                if (session != null) {\r\n                    if (!session.isValid() || isSessionStale(session, System.currentTimeMillis())) {\r\n                        log(\"session swapped in is invalid or expired\");\r\n                        session.expire();\r\n                        store.remove(sessionId);\r\n                    } else {\r\n                        session.setManager(manager);\r\n                        manager.add(session);\r\n                        session.access();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    log(\"sessionId: \" + sessionId);\r\n    return INVOKE_NEXT;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.Configuration.getPOA",
	"Comment": "returns the identity of the poa to be used for the given type of objects.",
	"Method": "POA getPOA(String type){\r\n    POA result = (POA) poas.get(type);\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.jmx.MBeanProxyHandler.setAttribute",
	"Comment": "same as xattributesaccess.setattribute, but with exceptions",
	"Method": "void setAttribute(Attribute attr){\r\n    getMBeanServerConnection().setAttribute(getObjectName(), attr);\r\n    postSetAttributeHook(attr);\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.AuthenticatorBase.setSecurePagesWithPragma",
	"Comment": "set the value of the flag that states what headers we add to disableproxy caching.",
	"Method": "void setSecurePagesWithPragma(boolean securePagesWithPragma){\r\n    this.securePagesWithPragma = securePagesWithPragma;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Response.encode",
	"Comment": "apply url encoding to the given url without adding session identifieret al associated to this response.",
	"Method": "String encode(String url){\r\n    return urlEncoder.encodeURL(url);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModule.addFilterMap",
	"Comment": "configures this web module with the filter mappings specified in thedeployment descriptor.",
	"Method": "void addFilterMap(ServletFilterMapping sfm){\r\n    FilterMaps filterMaps = new FilterMaps();\r\n    filterMaps.setFilterName(sfm.getName());\r\n    filterMaps.setDispatcherTypes(sfm.getDispatchers());\r\n    List<String> servletNames = sfm.getServletNames();\r\n    if (servletNames != null) {\r\n        for (String servletName : servletNames) {\r\n            filterMaps.addServletName(servletName);\r\n        }\r\n    }\r\n    List<String> urlPatterns = sfm.getUrlPatterns();\r\n    if (urlPatterns != null) {\r\n        for (String urlPattern : urlPatterns) {\r\n            filterMaps.addURLPattern(urlPattern);\r\n        }\r\n    }\r\n    addFilterMaps(filterMaps);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteAdminCommand.getUsage",
	"Comment": "get the usage text.if we got usage information from the server, use it.",
	"Method": "String getUsage(){\r\n    return usage;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.SetRootRule.isExactMatch",
	"Comment": "is exact matching being used.this rule uses org.apache.commons.beanutils.methodutils to introspect the relevent objects so that the right method can be called.originally, methodutils.invokeexactmethod was used.this matches methods very strictly and so may not find a matching method when one exists.this is still the behaviour when exact matching is enabled.when exact matching is disabled, methodutils.invokemethod is used.this method finds more methods but is less precise when there are several methods with correct signatures.so, if you want to choose an exact signature you might need to enable this property.the default setting is to disable exact matches.",
	"Method": "boolean isExactMatch(){\r\n    return useExactMatch;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getMimeType",
	"Comment": "return the mime type of the specified file, or null ifthe mime type cannot be determined.",
	"Method": "String getMimeType(String file){\r\n    if (file == null)\r\n        return (null);\r\n    int period = file.lastIndexOf(\".\");\r\n    if (period < 0)\r\n        return (null);\r\n    String extension = file.substring(period + 1);\r\n    if (extension.length() < 1)\r\n        return (null);\r\n    return (findMimeMapping(extension));\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.CLICommand.getManPage",
	"Comment": "return a bufferedreader for the man page for this command,or null if not found.",
	"Method": "BufferedReader getManPage(){\r\n    String commandName = getName();\r\n    if (commandName.length() == 0)\r\n        throw new IllegalArgumentException(\"Command name cannot be empty\");\r\n    if (commandName.equals(\"help\"))\r\n        commandName = programOpts.getCommandName();\r\n    return ManPageFinder.getCommandManPage(commandName, getClass().getName(), Locale.getDefault(), getClass().getClassLoader(), logger);\r\n}"
}, {
	"Path": "org.apache.naming.resources.ProxyDirContext.search",
	"Comment": "searches in the named context or object for entries that satisfy the given search filter. performs the search as specified by the search controls.",
	"Method": "NamingEnumeration<SearchResult> search(Name name,Attributes matchingAttributes,String[] attributesToReturn,NamingEnumeration<SearchResult> search,String name,Attributes matchingAttributes,String[] attributesToReturn,NamingEnumeration<SearchResult> search,Name name,Attributes matchingAttributes,NamingEnumeration<SearchResult> search,String name,Attributes matchingAttributes,NamingEnumeration<SearchResult> search,Name name,String filter,SearchControls cons,NamingEnumeration<SearchResult> search,String name,String filter,SearchControls cons,NamingEnumeration<SearchResult> search,Name name,String filterExpr,Object[] filterArgs,SearchControls cons,NamingEnumeration<SearchResult> search,String name,String filterExpr,Object[] filterArgs,SearchControls cons){\r\n    return dirContext.search(parseName(name), filterExpr, filterArgs, cons);\r\n}"
}, {
	"Path": "com.sun.enterprise.security.store.PasswordAdapter.getPasswordSecretKeyForAlias",
	"Comment": "this methods returns password secretkey for a given alias and smp.",
	"Method": "SecretKey getPasswordSecretKeyForAlias(String alias){\r\n    return (SecretKey) _pwdStore.getKey(alias, getMasterPassword());\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getServletNameFilterMappings",
	"Comment": "gets the current servlet name mappings of the filter withthe given name.",
	"Method": "Collection<String> getServletNameFilterMappings(String filterName){\r\n    HashSet<String> mappings = new HashSet<String>();\r\n    synchronized (filterMaps) {\r\n        for (FilterMap fm : filterMaps) {\r\n            if (filterName.equals(fm.getFilterName()) && fm.getServletName() != null) {\r\n                mappings.add(fm.getServletName());\r\n            }\r\n        }\r\n    }\r\n    return mappings;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.annotation.handlers.ServletSecurityHandler.getUrlPatternsWithoutSecurityConstraint",
	"Comment": "given a webcomponentdescriptor, find the set of urlpattern which does not haveany existing url pattern in securityconstraint",
	"Method": "Set<String> getUrlPatternsWithoutSecurityConstraint(WebComponentDescriptor webCompDesc){\r\n    Set<String> urlPatternsWithoutSC = new HashSet<String>(webCompDesc.getUrlPatternsSet());\r\n    WebBundleDescriptor webBundleDesc = webCompDesc.getWebBundleDescriptor();\r\n    Enumeration<SecurityConstraint> eSecConstr = webBundleDesc.getSecurityConstraints();\r\n    while (eSecConstr.hasMoreElements()) {\r\n        SecurityConstraint sc = eSecConstr.nextElement();\r\n        for (WebResourceCollection wrc : sc.getWebResourceCollections()) {\r\n            urlPatternsWithoutSC.removeAll(wrc.getUrlPatterns());\r\n        }\r\n    }\r\n    return urlPatternsWithoutSC;\r\n}"
}, {
	"Path": "org.glassfish.diagnostics.context.impl.ContextManagerImplUnitTest.testViewFactoryRegistration",
	"Comment": "verify that contextmanagerimpl initialization registers a contextviewfactory with the contextmaphelper. this test assumes only that initialization takes place by the time the first new contextmanagerimpl has been created.",
	"Method": "void testViewFactoryRegistration(){\r\n    new MockUp<ContextMapHelper>() {\r\n        @Mock\r\n        public void registerContextFactoryForPrefixNamed(String prefixName, ContextViewFactory factory) {\r\n            Assert.assertEquals(prefixName, ContextManager.WORK_CONTEXT_KEY);\r\n            Assert.assertTrue(\"org.glassfish.diagnostics.context.impl.ContextManagerImpl$DiagnosticContextViewFactory\".equals(factory.getClass().getName()));\r\n        }\r\n    };\r\n    ContextManagerImpl cmi = new ContextManagerImpl();\r\n}"
}, {
	"Path": "org.glassfish.diagnostics.context.impl.ContextManagerImplUnitTest.testViewFactoryRegistration",
	"Comment": "verify that contextmanagerimpl initialization registers a contextviewfactory with the contextmaphelper. this test assumes only that initialization takes place by the time the first new contextmanagerimpl has been created.",
	"Method": "void testViewFactoryRegistration(){\r\n    Assert.assertEquals(prefixName, ContextManager.WORK_CONTEXT_KEY);\r\n    Assert.assertTrue(\"org.glassfish.diagnostics.context.impl.ContextManagerImpl$DiagnosticContextViewFactory\".equals(factory.getClass().getName()));\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.util.ImplUtil.unregisterOneMBean",
	"Comment": "unregister a single mbean, returning true if it was unregistered, false otherwise.",
	"Method": "boolean unregisterOneMBean(MBeanServer mbeanServer,ObjectName objectName){\r\n    boolean success = false;\r\n    try {\r\n        mbeanServer.unregisterMBean(objectName);\r\n    } catch (final Exception e) {\r\n        success = false;\r\n    }\r\n    return success;\r\n}"
}, {
	"Path": "org.apache.catalina.loader.WebappLoader.getContainer",
	"Comment": "return the container with which this logger has been associated.",
	"Method": "Container getContainer(){\r\n    return (container);\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.archivist.WebArchivist.postStandardDDsRead",
	"Comment": "after reading all the standard deployment descriptors, merge anyresource descriptors from ejb descriptors into the webbundledescriptor.",
	"Method": "void postStandardDDsRead(WebBundleDescriptorImpl descriptor,ReadableArchive archive,Map<ExtensionsArchivist, RootDeploymentDescriptor> extensions){\r\n    for (RootDeploymentDescriptor rd : extensions.values()) {\r\n        if (rd instanceof EjbBundleDescriptor) {\r\n            EjbBundleDescriptor eb = (EjbBundleDescriptor) rd;\r\n            descriptor.addJndiNameEnvironment(eb);\r\n            for (EjbDescriptor ejb : eb.getEjbs()) {\r\n                ejb.notifyNewModule(descriptor);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.AdminUtil.isFrozenAll",
	"Comment": "isfrozenallget the current state.part of freezing functions that will be used to achive a transactional quiet period before taking any action or collectingany statistics. this call returns almost immediately.",
	"Method": "boolean isFrozenAll(){\r\n    return TransactionState.freezeLock.isWriteLocked();\r\n}"
}, {
	"Path": "com.sun.enterprise.web.connector.coyote.PECoyoteConnector.requestStartEvent",
	"Comment": "fires probe event related to the fact that the given request hasbeen entered the web container.",
	"Method": "void requestStartEvent(HttpServletRequest request,Host host,Context context){\r\n    if (requestProbeProvider != null) {\r\n        String appName = null;\r\n        if (context instanceof WebModule) {\r\n            appName = ((WebModule) context).getMonitoringNodeName();\r\n        }\r\n        String hostName = null;\r\n        if (host != null) {\r\n            hostName = host.getName();\r\n        }\r\n        requestProbeProvider.requestStartEvent(appName, hostName, request.getServerName(), request.getServerPort(), request.getContextPath(), request.getServletPath());\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationDispatcher.wrapResponse",
	"Comment": "create and return a response wrapper that has been inserted in theappropriate spot in the response chain.",
	"Method": "ServletResponse wrapResponse(State state){\r\n    ServletResponse previous = null;\r\n    ServletResponse current = state.outerResponse;\r\n    while (current != null) {\r\n        if (state.hresponse == null && (current instanceof HttpServletResponse)) {\r\n            state.hresponse = (HttpServletResponse) current;\r\n            if (DispatcherType.INCLUDE != state.dispatcherType)\r\n                return null;\r\n        }\r\n        if (!(current instanceof ServletResponseWrapper))\r\n            break;\r\n        if (current instanceof ApplicationHttpResponse)\r\n            break;\r\n        if (current instanceof ApplicationResponse)\r\n            break;\r\n        previous = current;\r\n        current = ((ServletResponseWrapper) current).getResponse();\r\n    }\r\n    ServletResponse wrapper = null;\r\n    if ((current instanceof ApplicationHttpResponse) || (current instanceof HttpResponse) || (current instanceof HttpServletResponse))\r\n        wrapper = new ApplicationHttpResponse((HttpServletResponse) current, DispatcherType.INCLUDE == state.dispatcherType);\r\n    else\r\n        wrapper = new ApplicationResponse(current, DispatcherType.INCLUDE == state.dispatcherType);\r\n    if (previous == null)\r\n        state.outerResponse = wrapper;\r\n    else\r\n        ((ServletResponseWrapper) previous).setResponse(wrapper);\r\n    state.wrapResponse = wrapper;\r\n    return (wrapper);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.isAccessLoggingEnabled",
	"Comment": "determines whether access logging is enabled for this virtual server.",
	"Method": "boolean isAccessLoggingEnabled(boolean globalAccessLoggingEnabled){\r\n    String enabled = vsBean.getAccessLoggingEnabled();\r\n    return \"inherit\".equals(enabled) && globalAccessLoggingEnabled || ConfigBeansUtilities.toBoolean(enabled);\r\n}"
}, {
	"Path": "org.glassfish.admin.mbeanserver.RMIConnectorStarter.getAddress",
	"Comment": "utility method to get an inetaddress from the address string from the config",
	"Method": "InetAddress getAddress(String addrSpec){\r\n    String actual = addrSpec;\r\n    if (addrSpec.equals(\"localhost\")) {\r\n        actual = \"127.0.0.1\";\r\n    }\r\n    final InetAddress addr = InetAddress.getByName(actual);\r\n    return addr;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.isRequestedSessionIdValid",
	"Comment": "return true if the session identifier included in thisrequest identifies a valid session.",
	"Method": "boolean isRequestedSessionIdValid(){\r\n    if (requestedSessionId == null) {\r\n        return false;\r\n    }\r\n    if (context == null) {\r\n        return false;\r\n    }\r\n    if (session != null && requestedSessionId.equals(session.getIdInternal())) {\r\n        return session.isValid();\r\n    }\r\n    Manager manager = context.getManager();\r\n    if (manager == null) {\r\n        return false;\r\n    }\r\n    Session localSession = null;\r\n    try {\r\n        if (manager.isSessionVersioningSupported()) {\r\n            localSession = manager.findSession(requestedSessionId, requestedSessionVersion);\r\n        } else {\r\n            localSession = manager.findSession(requestedSessionId, this);\r\n        }\r\n    } catch (IOException e) {\r\n        localSession = null;\r\n    }\r\n    if (localSession != null && localSession.isValid()) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.getRegistrations",
	"Comment": "return the set of dtd url registrations, keyed by public identifier.",
	"Method": "Map<String, String> getRegistrations(){\r\n    return (entityValidator);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorLog.requireRewrite",
	"Comment": "informs the coordinatorlog object that it must rewrite its entire statethe next time it writes a log record.if the coordinatorlog has state that has previously been written, it recordsthe requirement to rewrite, otherwise it does not record the requirement.",
	"Method": "boolean requireRewrite(){\r\n    boolean result = true;\r\n    if (writeDone)\r\n        rewriteRequired = true;\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.getReader",
	"Comment": "by setting the reader in the constructor, you can bypass jaxp andbe able to use digester in weblogic 6.0.",
	"Method": "XMLReader getReader(){\r\n    try {\r\n        return (getXMLReader());\r\n    } catch (SAXException e) {\r\n        log.log(Level.SEVERE, LogFacade.CANNOT_GET_XML_READER_EXCEPTION, e);\r\n        return (null);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.PersistentManagerBase.addToInvalidatedSessions",
	"Comment": "add this session id to the set of invalidated session ids for thismanager.",
	"Method": "void addToInvalidatedSessions(String sessionId){\r\n    invalidatedSessions.put(sessionId, Long.valueOf(System.currentTimeMillis()));\r\n}"
}, {
	"Path": "org.glassfish.internal.deployment.GenericHandler.expand",
	"Comment": "prepares the jar file to a format the applicationcontainer isexpecting. this could be just a pure unzipping of the jar ornothing at all.",
	"Method": "void expand(ReadableArchive source,WritableArchive target,DeploymentContext context){\r\n    Enumeration<String> e = source.entries();\r\n    while (e.hasMoreElements()) {\r\n        String entryName = e.nextElement();\r\n        InputStream entry = source.getEntry(entryName);\r\n        if (entry != null) {\r\n            InputStream is = new BufferedInputStream(entry);\r\n            OutputStream os = null;\r\n            try {\r\n                os = target.putNextEntry(entryName);\r\n                FileUtils.copy(is, os, source.getEntrySize(entryName));\r\n            } finally {\r\n                if (os != null) {\r\n                    target.closeEntry();\r\n                }\r\n                is.close();\r\n            }\r\n        }\r\n    }\r\n    Manifest m = source.getManifest();\r\n    if (m != null) {\r\n        OutputStream os = target.putNextEntry(JarFile.MANIFEST_NAME);\r\n        m.write(os);\r\n        target.closeEntry();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.ServletClassDeclared.check",
	"Comment": "all servlet class of an war bundle should be declared in the deployment",
	"Method": "Result check(WebBundleDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    if (getVerifierContext().getJavaEEVersion().compareTo(SpecVersionMapper.JavaEEVersion_5) >= 0) {\r\n        result.setStatus(Result.NOT_APPLICABLE);\r\n        return result;\r\n    }\r\n    boolean oneWarning = false;\r\n    boolean foundOne = false;\r\n    result = loadWarFile(descriptor);\r\n    FileArchive arch = null;\r\n    Enumeration entries = null;\r\n    Object entry;\r\n    try {\r\n        String uri = getAbstractArchiveUri(descriptor);\r\n        try {\r\n            arch = new FileArchive();\r\n            arch.open(uri);\r\n            entries = arch.entries();\r\n        } catch (Exception e) {\r\n            throw e;\r\n        }\r\n    } catch (Exception e) {\r\n        e.printStackTrace();\r\n        result.failed(smh.getLocalString(getClass().getName() + \".exception\", \"IOException while loading the war file [ {0} ]\", new Object[] { descriptor.getName() }));\r\n        return result;\r\n    }\r\n    while (entries.hasMoreElements()) {\r\n        entry = entries.nextElement();\r\n        String name = (String) entry;\r\n        if (name.startsWith(servletClassPath)) {\r\n            if (name.endsWith(\".class\")) {\r\n                String classEntryName = name.substring(0, name.length() - \".class\".length());\r\n                classEntryName = classEntryName.substring(servletClassPath.length() + 1, classEntryName.length());\r\n                String className = classEntryName.replace('/', '.');\r\n                Class servletClass = loadClass(result, className);\r\n                if (!Modifier.isAbstract(servletClass.getModifiers()) && isImplementorOf(servletClass, \"javax.servlet.Servlet\")) {\r\n                    foundOne = true;\r\n                    Set servlets = descriptor.getServletDescriptors();\r\n                    boolean foundDD = false;\r\n                    for (Iterator itr = servlets.iterator(); itr.hasNext(); ) {\r\n                        WebComponentDescriptor servlet = (WebComponentDescriptor) itr.next();\r\n                        String servletClassName = servlet.getWebComponentImplementation();\r\n                        if (servletClassName.equals(className)) {\r\n                            foundDD = true;\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (foundDD) {\r\n                        result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"Servlet class [ {0} ] found in war file is defined in the Deployement Descriptors\", new Object[] { className }));\r\n                    } else {\r\n                        oneWarning = true;\r\n                        result.addWarningDetails(smh.getLocalString(getClass().getName() + \".warning\", \"Servlet class [ {0} ] found in war file is not defined in the Deployement Descriptors\", new Object[] { className }));\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (!foundOne) {\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"There are no servlet implementation within the web archive [ {0} ]\", new Object[] { descriptor.getName() }));\r\n    } else {\r\n        if (oneWarning) {\r\n            result.setStatus(Result.WARNING);\r\n        } else {\r\n            result.setStatus(Result.PASSED);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setResources",
	"Comment": "set the resources dircontext object with which this container isassociated.",
	"Method": "void setResources(DirContext resources){\r\n    if (started) {\r\n        throw new IllegalStateException(rb.getString(LogFacade.RESOURCES_STARTED));\r\n    }\r\n    DirContext oldResources = this.webappResources;\r\n    if (oldResources == resources)\r\n        return;\r\n    if (resources instanceof BaseDirContext) {\r\n        BaseDirContext baseDirContext = (BaseDirContext) resources;\r\n        baseDirContext.setCached(isCachingAllowed());\r\n        baseDirContext.setCacheTTL(getCacheTTL());\r\n        baseDirContext.setCacheMaxSize(getCacheMaxSize());\r\n    }\r\n    if (resources instanceof FileDirContext) {\r\n        filesystemBased = true;\r\n        FileDirContext fileDirContext = (FileDirContext) resources;\r\n        fileDirContext.setCaseSensitive(isCaseSensitive());\r\n        fileDirContext.setAllowLinking(isAllowLinking());\r\n    }\r\n    this.webappResources = resources;\r\n    this.resources = null;\r\n    support.firePropertyChange(\"resources\", oldResources, this.webappResources);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.GlobalTID.isNullTID",
	"Comment": "determines whether the global identifier represents the null transactionidentifier.",
	"Method": "boolean isNullTID(){\r\n    return realTID.formatID == -1;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.session.PersistenceType.parseType",
	"Comment": "parse the specified string and return the corresponding instanceof this class that represents the persistence type specifiedin the string.",
	"Method": "PersistenceType parseType(String type,PersistenceType parseType,String type,PersistenceType defaultType){\r\n    PersistenceType pType = defaultType;\r\n    if (type != null) {\r\n        if (type.equalsIgnoreCase(MEMORY.getType()))\r\n            pType = MEMORY;\r\n        else if (type.equalsIgnoreCase(FILE.getType()))\r\n            pType = FILE;\r\n        else if (type.equalsIgnoreCase(COOKIE.getType()))\r\n            pType = COOKIE;\r\n        else if (type.equalsIgnoreCase(CUSTOM.getType()))\r\n            pType = CUSTOM;\r\n        else if (type.equalsIgnoreCase(S1WS60.getType()))\r\n            pType = S1WS60;\r\n        else if (type.equalsIgnoreCase(MMAP.getType()))\r\n            pType = MMAP;\r\n        else if (type.equalsIgnoreCase(JDBC.getType()))\r\n            pType = JDBC;\r\n        else if (type.equalsIgnoreCase(HA.getType()))\r\n            pType = HA;\r\n        else if (type.equalsIgnoreCase(REPLICATED.getType()))\r\n            pType = REPLICATED;\r\n        else if (type.equalsIgnoreCase(COHERENCE_WEB.getType()))\r\n            pType = COHERENCE_WEB;\r\n    }\r\n    return pType;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.pkmultiplefield.PrimaryKeyClassModifier.check",
	"Comment": "enterprise java bean primary key class modifier test.the class must be defined as public",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (descriptor instanceof EjbEntityDescriptor) {\r\n        String persistence = ((EjbEntityDescriptor) descriptor).getPersistenceType();\r\n        if (EjbEntityDescriptor.CONTAINER_PERSISTENCE.equals(persistence)) {\r\n            try {\r\n                FieldDescriptor fd = ((EjbCMPEntityDescriptor) descriptor).getPrimaryKeyFieldDesc();\r\n                if (fd != null) {\r\n                    String pkf = fd.getName();\r\n                    if (pkf.length() > 0) {\r\n                        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable2\", \"Entity Bean [ {0} ] with primekey-field non-blank, test not applicable.\", new Object[] { descriptor.getEjbClassName() }));\r\n                    }\r\n                } else {\r\n                    try {\r\n                        VerifierTestContext context = getVerifierContext();\r\n                        ClassLoader jcl = context.getClassLoader();\r\n                        Class c = Class.forName(((EjbEntityDescriptor) descriptor).getPrimaryKeyClassName(), false, getVerifierContext().getClassLoader());\r\n                        boolean isPublic = false;\r\n                        int modifiers = c.getModifiers();\r\n                        if (Modifier.isPublic(modifiers)) {\r\n                            isPublic = true;\r\n                        }\r\n                        if (isPublic) {\r\n                            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                            result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"[ {0} ] properly declares public class modifier.\", new Object[] { ((EjbEntityDescriptor) descriptor).getPrimaryKeyClassName() }));\r\n                        } else if (!isPublic) {\r\n                            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                            result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Ejb primary key class [ {0} ] was found, but was not declared as public.  The primary key class  [ {1} ] must be defined as public.\", new Object[] { ((EjbEntityDescriptor) descriptor).getPrimaryKeyClassName(), ((EjbEntityDescriptor) descriptor).getPrimaryKeyClassName() }));\r\n                        }\r\n                    } catch (ClassNotFoundException e) {\r\n                        Verifier.debug(e);\r\n                        result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.failed(smh.getLocalString(getClass().getName() + \".failedException\", \"Error: [ {0} ] class not found.\", new Object[] { ((EjbEntityDescriptor) descriptor).getPrimaryKeyClassName() }));\r\n                    }\r\n                }\r\n            } catch (NullPointerException e) {\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.failed(smh.getLocalString(getClass().getName() + \".failedException2\", \"Error: Primkey field not defined within [ {0} ] bean.\", new Object[] { descriptor.getName() }));\r\n            }\r\n            return result;\r\n        } else {\r\n            result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable1\", \"Expected [ {0} ] managed persistence, but [ {1} ] bean has [ {2} ] managed persistence.\", new Object[] { EjbEntityDescriptor.CONTAINER_PERSISTENCE, descriptor.getName(), persistence }));\r\n            return result;\r\n        }\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"{0} expected {1} bean, but called with {2}.\", new Object[] { getClass(), \"Entity\", \"Session\" }));\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.logger.LoggerBase.setContainer",
	"Comment": "set the container with which this logger has been associated.",
	"Method": "void setContainer(Container container){\r\n    Container oldContainer = this.container;\r\n    this.container = container;\r\n    support.firePropertyChange(\"container\", oldContainer, this.container);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.FileValidator.isValidConstraints",
	"Comment": "checks if the given constraint set is a subset of valid constraint set.",
	"Method": "boolean isValidConstraints(String constraints){\r\n    if (constraints == null) {\r\n        return false;\r\n    }\r\n    final int length = constraints.length();\r\n    if ((length == 0) || (length > 4)) {\r\n        return false;\r\n    }\r\n    boolean isValid = true;\r\n    for (int i = 0; i < length; i++) {\r\n        char ch = constraints.charAt(i);\r\n        switch(ch) {\r\n            case 'r':\r\n            case 'w':\r\n            case 'x':\r\n            case 'd':\r\n                continue;\r\n            default:\r\n                isValid = false;\r\n                break;\r\n        }\r\n    }\r\n    return isValid;\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardManager.file",
	"Comment": "return a file object representing the pathname to ourpersistence file, if any.",
	"Method": "File file(){\r\n    if (absPathName != null) {\r\n        return new File(absPathName);\r\n    }\r\n    if ((pathname == null) || (pathname.length() == 0))\r\n        return (null);\r\n    File file = new File(pathname);\r\n    if (!file.isAbsolute()) {\r\n        if (container instanceof Context) {\r\n            ServletContext servletContext = ((Context) container).getServletContext();\r\n            File tempdir = (File) servletContext.getAttribute(ServletContext.TEMPDIR);\r\n            if (tempdir != null)\r\n                file = new File(tempdir, pathname);\r\n        }\r\n    }\r\n    if (file != null) {\r\n        absPathName = file.getAbsolutePath();\r\n    }\r\n    return (file);\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.getPublicId",
	"Comment": "return the public identifier of the dtd we are currentlyparsing under, if any.",
	"Method": "String getPublicId(){\r\n    return (this.publicId);\r\n}"
}, {
	"Path": "org.glassfish.web.loader.ServletContainerInitializerUtil.isFragmentMissingFromAbsoluteOrdering",
	"Comment": "checks if a given jar file is to be excluded while searching for servletcontainerinitializer implementations",
	"Method": "boolean isFragmentMissingFromAbsoluteOrdering(String jarName,Map<String, String> webFragmentMap,List<Object> absoluteOrderingList){\r\n    return (webFragmentMap != null && absoluteOrderingList != null && !absoluteOrderingList.contains(webFragmentMap.get(jarName)));\r\n}"
}, {
	"Path": "org.apache.catalina.valves.AccessLogValve.log",
	"Comment": "log the specified message to the log file, switching files if the datehas changed since the previous log call.",
	"Method": "void log(String message,Date date){\r\n    if (rotatable) {\r\n        long systime = System.currentTimeMillis();\r\n        if ((systime - rotationLastChecked) > 1000) {\r\n            currentDate = new Date(systime);\r\n            rotationLastChecked = systime;\r\n            String tsDate = dateFormatter.get().format(currentDate);\r\n            if (!dateStamp.equals(tsDate)) {\r\n                synchronized (this) {\r\n                    if (!dateStamp.equals(tsDate)) {\r\n                        close();\r\n                        dateStamp = tsDate;\r\n                        open();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (writer != null) {\r\n        writer.println(message);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.trace.TraceRecordFormatter.createTraceRecord",
	"Comment": "returns the formatted record, by accepting the simple string message, tid and originator, which can be written to outputstream",
	"Method": "String createTraceRecord(Object tid,Object origin,String message){\r\n    StringBuffer strBuf = new StringBuffer(TraceUtil.getTraceRecordTag());\r\n    strBuf.append(TraceUtil.getCurrentTraceLevel()).append(TraceUtil.getFieldDelimiter());\r\n    if (tid == null) {\r\n        strBuf.append(\"<unknown-tid>\");\r\n    } else {\r\n        if (tid instanceof String) {\r\n            strBuf.append(tid);\r\n        } else if (tid instanceof otid_t) {\r\n            strBuf.append(convertToString(((otid_t) tid).tid));\r\n        }\r\n    }\r\n    strBuf.append(TraceUtil.getFieldDelimiter()).append(System.currentTimeMillis()).append(TraceUtil.getFieldDelimiter());\r\n    if (origin == null) {\r\n        strBuf.append(\"<unknown-origin>\");\r\n    } else {\r\n        strBuf.append(origin);\r\n    }\r\n    strBuf.append(TraceUtil.getFieldDelimiter()).append(message).append(\"\\n\");\r\n    return strBuf.toString();\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.resources.admin.CommandResource.fixActionReporterSpecialCases",
	"Comment": "some actionreporters has special logic which must be reflected here",
	"Method": "void fixActionReporterSpecialCases(ActionReporter ar){\r\n    if (ar == null) {\r\n        return;\r\n    }\r\n    if (ar instanceof PlainTextActionReporter) {\r\n        PlainTextActionReporter par = (PlainTextActionReporter) ar;\r\n        StringBuilder finalOutput = new StringBuilder();\r\n        par.getCombinedMessages(par, finalOutput);\r\n        String outs = finalOutput.toString();\r\n        if (!StringUtils.ok(outs)) {\r\n            par.getTopMessagePart().setMessage(strings.getLocalString(\"get.mon.no.data\", \"No monitoring data to report.\") + \"\\n\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.jmx.JMXUtil.queryNames",
	"Comment": "the sole purpose of this method is to move compiler warnings here, thuseliminating them from other call sites.may be removed when jmx becomesgenerified.",
	"Method": "Set<ObjectName> queryNames(MBeanServerConnection conn,ObjectName pattern,QueryExp exp,Set<ObjectName> queryNames,MBeanServer server,ObjectName pattern,QueryExp exp){\r\n    try {\r\n        return queryNames((MBeanServerConnection) server, pattern, exp);\r\n    } catch (final IOException e) {\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.web.TagLibFactory.createDocument",
	"Comment": "helper method to create the document object from the tld files specifiedby the location in web.xml of the war archive.",
	"Method": "Document createDocument(String location,WebBundleDescriptor webd){\r\n    Document document = null;\r\n    InputSource source = null;\r\n    if (location.startsWith(\"/\"))\r\n        location = location.substring(1);\r\n    else\r\n        location = \"WEB-INF/\" + location;\r\n    ModuleDescriptor moduleDesc = webd.getModuleDescriptor();\r\n    String archBase = context.getAbstractArchive().getURI().getPath();\r\n    String uri = null;\r\n    if (moduleDesc.isStandalone()) {\r\n        uri = archBase;\r\n    } else {\r\n        uri = archBase + File.separator + FileUtils.makeFriendlyFilename(moduleDesc.getArchiveUri());\r\n    }\r\n    FileArchive arch = new FileArchive();\r\n    arch.open(uri);\r\n    InputStream is = arch.getEntry(location);\r\n    try {\r\n        if (is == null)\r\n            throw new IOException(// NOI18N\r\n            smh.getLocalString(getClass().getName() + \".exception1\", \"Wrong tld [ {0} ] specified in the web.xml of [ {1} ]\", new Object[] { location, moduleDesc.getArchiveUri() }));\r\n        source = new InputSource(is);\r\n        document = builder.parse(source);\r\n    } finally {\r\n        try {\r\n            if (is != null)\r\n                is.close();\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return document;\r\n}"
}, {
	"Path": "org.apache.catalina.servlets.InvokerHttpRequest.getInfo",
	"Comment": "return descriptive information about this implementation.",
	"Method": "String getInfo(){\r\n    return (this.info);\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.config.AMXConfigImpl.checkForConflicts",
	"Comment": "to make error messages more friendly and quick sanity check,verify that no conflicting children already exist.",
	"Method": "void checkForConflicts(List<CreateParams> children){\r\n    final Map<String, Map<String, AMXProxy>> existingChildren = getSelf().childrenMaps();\r\n    for (final CreateParams params : children) {\r\n        final String type = params.type();\r\n        final Map<String, AMXProxy> childrenOfType = existingChildren.get(type);\r\n        if (childrenOfType != null) {\r\n            final AMXProxy firstChild = childrenOfType.values().iterator().next();\r\n            if (firstChild.extra().singleton()) {\r\n                throw new IllegalArgumentException(\"Singleton child of type \" + type + \" already exists.\");\r\n            }\r\n            if (childrenOfType.get(params.name()) != null) {\r\n                throw new IllegalArgumentException(\"Child of type \" + type + \" named \" + params.name() + \" already exists.\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteAdminCommand.checkConnect",
	"Comment": "check that the connection was successful and handle any error responses,turning them into exceptions.",
	"Method": "String checkConnect(HttpURLConnection urlConnection){\r\n    int code = urlConnection.getResponseCode();\r\n    if (logger.isLoggable(Level.FINER)) {\r\n        logger.log(Level.FINER, \"Response code: \" + code);\r\n    }\r\n    if (code == -1) {\r\n        URL url = urlConnection.getURL();\r\n        throw new CommandException(strings.get(\"NotHttpResponse\", url.getHost(), url.getPort()));\r\n    }\r\n    if (code == HttpURLConnection.HTTP_UNAUTHORIZED) {\r\n        throw new AuthenticationException(reportAuthenticationException());\r\n    }\r\n    if (code == HttpURLConnection.HTTP_PRECON_FAILED) {\r\n        throw new CommandValidationException(\"Code: \" + HttpURLConnection.HTTP_PRECON_FAILED + \": Cached CommandModel is invalid.\");\r\n    }\r\n    if (isStatusRedirection(code)) {\r\n        return urlConnection.getHeaderField(\"Location\");\r\n    }\r\n    if (code != HttpURLConnection.HTTP_OK) {\r\n        throw new CommandException(strings.get(\"BadResponse\", \"\" + code, urlConnection.getResponseMessage()));\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.mbean.AMXImplBase.unimplementedOperation",
	"Comment": "an operation has not been implemented. deal with appropriately.",
	"Method": "void unimplementedOperation(String operation){\r\n    final String msg = \"UNIMPLEMENTED OPERATION: \" + operation + \" in \" + getObjectName();\r\n    logInfo(msg);\r\n    throw new UnsupportedOperationException(operation);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.DefaultAccessLogFormatterImpl.appendLogEntry",
	"Comment": "appends an access log entry line, with info obtained from the givenrequest and response objects, to the given charbuffer.",
	"Method": "void appendLogEntry(Request request,Response response,CharBuffer charBuffer){\r\n    HttpServletRequest hreq = (HttpServletRequest) request.getRequest();\r\n    HttpServletResponse hres = (HttpServletResponse) response.getResponse();\r\n    for (int i = 0; i < patternComponents.size(); i++) {\r\n        String pc = patternComponents.get(i);\r\n        if (pc.startsWith(ATTRIBUTE_BY_NAME_PREFIX)) {\r\n            appendAttributeByName(charBuffer, pc.substring(ATTRIBUTE_BY_NAME_PREFIX_LEN), hreq);\r\n        } else if (pc.startsWith(SESSION_ATTRIBUTE_BY_NAME_PREFIX)) {\r\n            appendSessionAttributeByName(charBuffer, pc.substring(SESSION_ATTRIBUTE_BY_NAME_PREFIX_LEN), hreq);\r\n        } else if (AUTH_USER_NAME.equals(pc)) {\r\n            appendAuthUserName(charBuffer, hreq);\r\n        } else if (CLIENT_DNS.equals(pc)) {\r\n            appendClientDNS(charBuffer, hreq);\r\n        } else if (CLIENT_NAME.equals(pc)) {\r\n            appendClientName(charBuffer, hreq);\r\n        } else if (COOKIE.equals(pc)) {\r\n            appendCookie(charBuffer, hreq);\r\n        } else if (COOKIES.equals(pc)) {\r\n            appendCookies(charBuffer, hreq);\r\n        } else if (COOKIE_VALUE.equals(pc)) {\r\n            appendCookieValue(charBuffer, hreq);\r\n        } else if (pc.startsWith(COOKIE_BY_NAME_PREFIX)) {\r\n            appendCookieByName(charBuffer, pc.substring(COOKIE_BY_NAME_PREFIX_LEN), hreq);\r\n        } else if (pc.startsWith(COOKIES_BY_NAME_PREFIX)) {\r\n            appendCookiesByName(charBuffer, pc.substring(COOKIES_BY_NAME_PREFIX_LEN), hreq);\r\n        } else if (DATE_TIME.equals(pc)) {\r\n            appendCurrentDate(charBuffer);\r\n        } else if (HEADER_ACCEPT.equals(pc)) {\r\n            appendHeaderAccept(charBuffer, hreq);\r\n        } else if (HEADER_AUTH.equals(pc)) {\r\n            appendHeaderAuth(charBuffer, hreq);\r\n        } else if (HEADER_DATE.equals(pc)) {\r\n            appendHeaderDate(charBuffer, hreq);\r\n        } else if (HEADER_IF_MOD_SINCE.equals(pc)) {\r\n            appendHeaderIfModSince(charBuffer, hreq);\r\n        } else if (HEADER_USER_AGENT.equals(pc)) {\r\n            appendUserAgent(charBuffer, hreq);\r\n        } else if (HEADER_REFERER.equals(pc)) {\r\n            appendReferer(charBuffer, hreq);\r\n        } else if (HTTP_METHOD.equals(pc)) {\r\n            appendHTTPMethod(charBuffer, hreq);\r\n        } else if (HTTP_URI.equals(pc)) {\r\n            appendHTTPUri(charBuffer, hreq);\r\n        } else if (HTTP_VERSION.equals(pc)) {\r\n            appendHTTPVersion(charBuffer, hreq);\r\n        } else if (QUERY_STR.equals(pc)) {\r\n            appendQueryString(charBuffer, hreq);\r\n        } else if (REFERER.equals(pc)) {\r\n            appendReferer(charBuffer, hreq);\r\n        } else if (REQUEST.equals(pc)) {\r\n            appendRequestInfo(charBuffer, hreq);\r\n        } else if (RESPONSE_LENGTH.equals(pc)) {\r\n            appendResponseLength(charBuffer, response);\r\n        } else if (RESPONSE_CONTENT_TYPE.equals(pc)) {\r\n            appendResponseContentType(charBuffer, response);\r\n        } else if (STATUS.equals(pc)) {\r\n            appendResponseStatus(charBuffer, response);\r\n        } else if (TIME_TAKEN.equals(pc)) {\r\n            appendTimeTaken(charBuffer, request);\r\n        } else if (USER_AGENT.equals(pc)) {\r\n            appendUserAgent(charBuffer, hreq);\r\n        } else if (VS_ID.equals(pc)) {\r\n            appendVirtualServerId(charBuffer);\r\n        } else if (pc.startsWith(HEADER_BY_NAME_PREFIX)) {\r\n            appendHeaderByName(charBuffer, pc.substring(HEADER_BY_NAME_PREFIX_LEN), hreq);\r\n        } else if (pc.startsWith(HEADERS_BY_NAME_PREFIX)) {\r\n            appendHeadersByName(charBuffer, pc.substring(HEADERS_BY_NAME_PREFIX_LEN), hreq);\r\n        } else if (pc.startsWith(RESPONSE_HEADER_BY_NAME_PREFIX)) {\r\n            appendResponseHeaderByName(charBuffer, pc.substring(RESPONSE_HEADER_BY_NAME_PREFIX_LEN), hres, response);\r\n        } else if (pc.startsWith(RESPONSE_HEADERS_BY_NAME_PREFIX)) {\r\n            appendResponseHeadersByName(charBuffer, pc.substring(RESPONSE_HEADERS_BY_NAME_PREFIX_LEN), hres, response);\r\n        }\r\n        charBuffer.put(SPACE);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogExtent.modExtent",
	"Comment": "modulates the extent number using the maximum extent number.",
	"Method": "int modExtent(int ext){\r\n    return (ext % MAX_NO_OF_EXTENTS);\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionManagerImpl.getTransaction",
	"Comment": "get the transaction object that represents the transactioncontext of the calling thread",
	"Method": "Transaction getTransaction(){\r\n    try {\r\n        Control control = current.get_control();\r\n        if (control == null) {\r\n            return null;\r\n        } else {\r\n            return createTransactionImpl(control);\r\n        }\r\n    } catch (Unavailable uex) {\r\n        throw new SystemException(uex.toString());\r\n    } catch (Exception ex) {\r\n        throw new SystemException(ex.toString());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteAdminCommand.getFromEnvironment",
	"Comment": "subclasses can override to supply parameter values from environment.the implementation in this class returns null, indicating that thename is not available in the environment.",
	"Method": "String getFromEnvironment(String name){\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.CommonAccessLogFormatterImpl.appendLogEntry",
	"Comment": "appends an access log entry line, with info obtained from the givenrequest and response objects, to the given charbuffer.",
	"Method": "void appendLogEntry(Request request,Response response,CharBuffer charBuffer){\r\n    ServletRequest req = request.getRequest();\r\n    HttpServletRequest hreq = (HttpServletRequest) req;\r\n    appendClientName(charBuffer, req);\r\n    charBuffer.put(SPACE);\r\n    appendClientId(charBuffer, req);\r\n    charBuffer.put(SPACE);\r\n    appendAuthUserName(charBuffer, hreq);\r\n    charBuffer.put(SPACE);\r\n    appendCurrentDate(charBuffer);\r\n    charBuffer.put(SPACE);\r\n    appendRequestInfo(charBuffer, hreq);\r\n    charBuffer.put(SPACE);\r\n    appendResponseStatus(charBuffer, response);\r\n    charBuffer.put(SPACE);\r\n    appendResponseLength(charBuffer, response);\r\n    charBuffer.put(SPACE);\r\n}"
}, {
	"Path": "org.glassfish.internal.data.ModuleInfo.getSniffers",
	"Comment": "returns the list of sniffers that participated in loaded thisapplication",
	"Method": "Collection<Sniffer> getSniffers(){\r\n    List<Sniffer> sniffers = new ArrayList<Sniffer>();\r\n    for (EngineRef engine : _getEngineRefs()) {\r\n        sniffers.add(engine.getContainerInfo().getSniffer());\r\n    }\r\n    return sniffers;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.web.WebVerifier.createClosureCompiler",
	"Comment": "creates the closurecompiler for the web module and sets it to theverifier context. this is used to compute the closure on the classes usedin the web archive.",
	"Method": "void createClosureCompiler(){\r\n    String specVer = SpecVersionMapper.getWebAppVersion(verifierFrameworkContext.getJavaEEVersion());\r\n    Object arg = (isASMode) ? context.getClassLoader() : (Object) getClassPath();\r\n    WebClosureCompiler cc = new WebClosureCompiler(specVer, ClassFileLoaderFactory.newInstance(new Object[] { arg }));\r\n    context.setClosureCompiler(cc);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ContainerBase.setBackgroundProcessorDelay",
	"Comment": "set the delay between the invocation of the execute method on thiscontainer and its children.",
	"Method": "void setBackgroundProcessorDelay(int delay){\r\n    backgroundProcessorDelay = delay;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentImpl.get_transaction_name",
	"Comment": "returns a printable string representing the current transaction.",
	"Method": "String get_transaction_name(){\r\n    String result = null;\r\n    try {\r\n        Coordinator coord = CurrentTransaction.getCurrentCoordinator();\r\n        if (coord != null)\r\n            result = coord.get_transaction_name();\r\n    } catch (Unavailable exc) {\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.ChangeNodeMasterPasswordCommand.verifyInstancePassword",
	"Comment": "this will load and verify the keystore for each of the instancesin a node",
	"Method": "boolean verifyInstancePassword(File instanceDir){\r\n    File mp = new File(new File(instanceDir, \"config\"), \"cacerts.jks\");\r\n    return loadAndVerifyKeystore(mp, oldPassword);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.commit",
	"Comment": "directs the subcoordinator to commit the transaction.the subcoordinator directs all registered resources to commit.",
	"Method": "void commit(){\r\n    Coordinator parent = null;\r\n    synchronized (this) {\r\n        if (!tranState.setState(TransactionState.STATE_COMMITTING)) {\r\n            _logger.log(Level.SEVERE, \"jts.transaction_wrong_state\", \"commit\");\r\n            String msg = LogFormatter.getLocalizedMessage(_logger, \"jts.transaction_wrong_state\", new java.lang.Object[] { \"commit\" });\r\n            throw new org.omg.CORBA.INTERNAL(msg);\r\n        }\r\n        parent = nestingInfo.getParent(false).object();\r\n    }\r\n    if (participants != null) {\r\n        try {\r\n            participants.distributeSubcommit(parent);\r\n        } catch (Throwable exc) {\r\n            _logger.log(Level.SEVERE, \"jts.exception_on_resource_operation\", new java.lang.Object[] { exc.toString(), \"commit\" });\r\n            String msg = LogFormatter.getLocalizedMessage(_logger, \"jts.exception_on_resource_operation\", new java.lang.Object[] { exc.toString(), \"commit\" });\r\n            throw new org.omg.CORBA.INTERNAL(msg);\r\n        }\r\n    }\r\n    synchronized (this) {\r\n        if (!tranState.setState(TransactionState.STATE_COMMITTED)) {\r\n            _logger.log(Level.SEVERE, \"jts.transaction_wrong_state\", \"commit\");\r\n            String msg = LogFormatter.getLocalizedMessage(_logger, \"jts.transaction_wrong_state\", new java.lang.Object[] { \"commit\" });\r\n            throw new org.omg.CORBA.INTERNAL(msg);\r\n        }\r\n        nestingInfo.removeFromParent(this);\r\n        if (terminator != null) {\r\n            terminator.setCompleted(false, false);\r\n        }\r\n        RecoveryManager.removeCoordinator(superInfo.globalTID, superInfo.localTID, false);\r\n        destroy();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.AdminAdapter.getUserPassword",
	"Comment": "a convenience method to extract user name from a request. it assumes the http basic auth.",
	"Method": "String[] getUserPassword(Request req){\r\n    String authHeader = req.getHeader(\"Authorization\");\r\n    if (authHeader == null) {\r\n        return new String[] { \"\", \"\" };\r\n    }\r\n    String enc = authHeader.substring(BASIC.length());\r\n    String dec = new String(decoder.decodeBuffer(enc));\r\n    int i = dec.indexOf(':');\r\n    if (i < 0)\r\n        return new String[] { \"\", \"\" };\r\n    return new String[] { dec.substring(0, i), dec.substring(i + 1) };\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.setContainer",
	"Comment": "set the container used for processing requests received by thisconnector.",
	"Method": "void setContainer(Container container){\r\n    this.container = container;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityConstraint.addCollection",
	"Comment": "add a new web resource collection to those protected by thissecurity constraint.",
	"Method": "void addCollection(SecurityCollection collection){\r\n    if (collection == null)\r\n        return;\r\n    SecurityCollection[] results = new SecurityCollection[collections.length + 1];\r\n    for (int i = 0; i < collections.length; i++) results[i] = collections[i];\r\n    results[collections.length] = collection;\r\n    collections = results;\r\n}"
}, {
	"Path": "com.sun.enterprise.glassfish.bootstrap.osgi.BundleProvisioner.installBundles",
	"Comment": "this method goes collects list of bundles that have been installedfrom the watched directory in previous run of the program,compares them with the current set of jar files,uninstalls old bundles, updates modified bundles, installs new bundles.it returns list of bundle ids provisioned by this provisoner.",
	"Method": "List<Long> installBundles(){\r\n    initCurrentManagedBundles();\r\n    final Collection<Jar> current = getBundleJars();\r\n    List<Jar> discovered = discoverJars();\r\n    List<Jar> newBundles = new ArrayList<Jar>(discovered);\r\n    newBundles.removeAll(current);\r\n    List<Jar> deletedBundles = new ArrayList<Jar>(current);\r\n    deletedBundles.removeAll(discovered);\r\n    List<Jar> existingBundles = new ArrayList<Jar>(discovered);\r\n    existingBundles.retainAll(current);\r\n    uninstall(deletedBundles);\r\n    update(existingBundles);\r\n    install(newBundles);\r\n    List<Long> ids = new ArrayList<Long>();\r\n    for (Jar j : currentManagedBundles.values()) {\r\n        ids.add(j.getBundleId());\r\n    }\r\n    return ids;\r\n}"
}, {
	"Path": "components.components.ChartComponent.placeChartDataInScope",
	"Comment": "place the appropriate data for chart in session scope, so thatit will be there when the separate request for the image isprocessed by the chart servlet. this servlet is responsible for writing out the chart as an image into the respone stream.",
	"Method": "void placeChartDataInScope(FacesContext context){\r\n    int i = 0;\r\n    ChartItem[] chartItems = null;\r\n    chartItems = (ChartItem[]) getValue();\r\n    if (chartItems == null || chartItems.length == 0) {\r\n        chartItems = new ChartItem[getChildCount()];\r\n        Iterator kids = this.getChildren().iterator();\r\n        while (kids.hasNext()) {\r\n            UIComponent kid = (UIComponent) kids.next();\r\n            if (kid instanceof ChartItemComponent) {\r\n                ChartItemComponent ci = (ChartItemComponent) kid;\r\n                ChartItem item = (ChartItem) ci.getValue();\r\n                if (item == null) {\r\n                    int itemVal = (new Integer((String) ci.getItemValue())).intValue();\r\n                    item = new ChartItem(ci.getItemLabel(), itemVal, ci.getItemColor());\r\n                }\r\n                chartItems[i] = item;\r\n                ++i;\r\n            }\r\n        }\r\n    }\r\n    Map sessionMap = getFacesContext().getExternalContext().getSessionMap();\r\n    sessionMap.put(getClientId(context), chartItems);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.OutputBuffer.addSessionCookieWithJReplica",
	"Comment": "adds jsessionid cookie whose value includes jvmroute if necessary.",
	"Method": "void addSessionCookieWithJReplica(Request request,StandardContext ctx,Session sess){\r\n    String replicaLocation = null;\r\n    if (sess != null) {\r\n        replicaLocation = (String) sess.getNote(Globals.JREPLICA_SESSION_NOTE);\r\n        sess.removeNote(Globals.JREPLICA_SESSION_NOTE);\r\n    }\r\n    if (replicaLocation != null) {\r\n        Cookie cookie = getSafeCookie(Globals.JREPLICA_COOKIE_NAME, replicaLocation);\r\n        request.configureSessionCookie(cookie);\r\n        if (request.isRequestedSessionIdFromCookie()) {\r\n            cookie.setSecure(request.isRequestedSessionIdFromSecureCookie());\r\n        }\r\n        grizzlyResponse.addHeader(SET_COOKIE_HEADER, response.getCookieString(cookie));\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.addChild",
	"Comment": "refuse to add a child container, because wrappers are the lowest levelof the container hierarchy.",
	"Method": "void addChild(Container child){\r\n    throw new IllegalStateException(rb.getString(LogFacade.WRAPPER_CONTAINER_NO_CHILD_EXCEPTION));\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.JavaEETransactionManagerSimplified.recreate",
	"Comment": "recreate a transaction based on the xid. this call causes the callingthread to be associated with the specified transaction. this is used by importing transactions via the connector contract.",
	"Method": "void recreate(Xid xid,long timeout){\r\n    getDelegate().recreate(xid, timeout);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.ServerSynchronizer.getApps",
	"Comment": "get the applications that should beavailable to the specified server instance.",
	"Method": "Map<String, Application> getApps(Server server){\r\n    Map<String, Application> apps = new HashMap<String, Application>();\r\n    if (applications == null)\r\n        return apps;\r\n    for (ApplicationRef ref : server.getApplicationRef()) {\r\n        Application app = applications.getApplication(ref.getRef());\r\n        if (app != null) {\r\n            if (logger.isLoggable(Level.FINEST))\r\n                logger.finest(\"ServerSynchronizer: got app \" + app.getName());\r\n            if (Boolean.parseBoolean(app.getDirectoryDeployed())) {\r\n                if (logger.isLoggable(Level.FINEST))\r\n                    logger.finest(\"ServerSynchronizer: \" + \"skipping directory deployed app: \" + app.getName());\r\n            } else\r\n                apps.put(VersioningUtils.getRepositoryName(app.getName()), app);\r\n        }\r\n    }\r\n    return apps;\r\n}"
}, {
	"Path": "org.glassfish.admin.mbeanserver.RMIConnectorStarter.convertToSSLParams",
	"Comment": "utility method to convert the sslconfiguration to lightweight structurewhich can be used without depending upon glassfish.",
	"Method": "SSLParams convertToSSLParams(Ssl sslConfig){\r\n    String trustStoreType = sslConfig.getTrustStoreType() == null ? System.getProperty(\"javax.net.ssl.trustStoreType\", \"JKS\") : sslConfig.getTrustStoreType();\r\n    String trustStorePwd = sslConfig.getTrustStorePassword() == null ? masterPassword : sslConfig.getTrustStorePassword();\r\n    File trustStore = sslConfig.getTrustStore() == null ? new File(System.getProperty(\"javax.net.ssl.trustStore\")) : new File(sslConfig.getTrustStore());\r\n    String keyStoreType = sslConfig.getTrustStoreType() == null ? System.getProperty(\"javax.net.ssl.keyStoreType\", \"JKS\") : sslConfig.getKeyStoreType();\r\n    String keyStorePwd = sslConfig.getTrustStorePassword() == null ? masterPassword : sslConfig.getKeyStorePassword();\r\n    File keyStore = sslConfig.getTrustStore() == null ? new File(System.getProperty(\"javax.net.ssl.keyStore\")) : new File(sslConfig.getKeyStore());\r\n    SSLParams sslParams = new SSLParams(trustStore, trustStorePwd, trustStoreType);\r\n    sslParams.setTrustAlgorithm(sslConfig.getTrustAlgorithm());\r\n    sslParams.setCertNickname(sslConfig.getCertNickname());\r\n    sslParams.setCrlFile(sslConfig.getCrlFile());\r\n    sslParams.setClientAuthEnabled(sslConfig.getClientAuthEnabled());\r\n    sslParams.setClientAuth(sslConfig.getClientAuth());\r\n    sslParams.setKeyAlgorithm(sslConfig.getKeyAlgorithm());\r\n    sslParams.setKeyStore(keyStore.getAbsolutePath());\r\n    sslParams.setKeyStorePassword(keyStorePwd);\r\n    sslParams.setKeyStoreType(keyStoreType);\r\n    sslParams.setSsl2Ciphers(sslConfig.getSsl2Ciphers());\r\n    sslParams.setSsl2Enabled(sslConfig.getSsl2Enabled());\r\n    sslParams.setSsl3Enabled(sslConfig.getSsl3Enabled());\r\n    sslParams.setSsl3TlsCiphers(sslConfig.getSsl3TlsCiphers());\r\n    sslParams.setTlsEnabled(sslConfig.getTlsEnabled());\r\n    sslParams.setTlsRollbackEnabled(sslConfig.getTlsRollbackEnabled());\r\n    return sslParams;\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.openJARs",
	"Comment": "used to periodically signal to the classloader to release jar resources.",
	"Method": "boolean openJARs(){\r\n    if (started && (jarFiles.length > 0)) {\r\n        synchronized (jarFilesLock) {\r\n            lastJarAccessed = System.currentTimeMillis();\r\n            if (jarFiles[0] == null) {\r\n                for (int i = 0; i < jarFiles.length; i++) {\r\n                    try {\r\n                        jarFiles[i] = new JarFile(jarRealFiles[i]);\r\n                    } catch (IOException e) {\r\n                        if (logger.isLoggable(Level.FINE)) {\r\n                            logger.log(Level.FINE, \"Failed to open JAR\", e);\r\n                        }\r\n                        for (int j = 0; j < i; j++) {\r\n                            try {\r\n                                jarFiles[j].close();\r\n                            } catch (Throwable t) {\r\n                            }\r\n                        }\r\n                        return false;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentTransaction.getCurrentCoordinator",
	"Comment": "returns a reference to the current coordinator.that is, the coordinator object that corresponds to thethread under which the operation was invoked.if there is no such association the null value is returned.note that this operation can be optimised so that the coordinator reference isstored along with the control reference when the thread association is set up.",
	"Method": "Coordinator getCurrentCoordinator(){\r\n    ControlImpl control = (ControlImpl) m_tid.get();\r\n    Coordinator result = null;\r\n    if (control != null) {\r\n        if (Configuration.isLocalFactory()) {\r\n            result = (Coordinator) ((ControlImpl) control).get_localCoordinator();\r\n        } else {\r\n            result = control.get_coordinator();\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getFilterRegistrations",
	"Comment": "gets a map of the filterregistration objects corresponding to allcurrently registered filters.",
	"Method": "Map<String, ? extends FilterRegistration> getFilterRegistrations(){\r\n    if (isRestricted) {\r\n        throw new UnsupportedOperationException(rb.getString(LogFacade.UNSUPPORTED_OPERATION_EXCEPTION));\r\n    }\r\n    return context.getFilterRegistrations();\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.ParameterParser.getToken",
	"Comment": "a helper method to process the parsed token. this method removesleading and trailing blanks as well as enclosing quotation marks,when necessary.",
	"Method": "String getToken(boolean quoted){\r\n    while ((i1 < i2) && (Character.isWhitespace(chars[i1]))) {\r\n        i1++;\r\n    }\r\n    while ((i2 > i1) && (Character.isWhitespace(chars[i2 - 1]))) {\r\n        i2--;\r\n    }\r\n    if (quoted) {\r\n        if (((i2 - i1) >= 2) && (chars[i1] == '\"') && (chars[i2 - 1] == '\"')) {\r\n            i1++;\r\n            i2--;\r\n        }\r\n    }\r\n    String result = null;\r\n    if (i2 > i1) {\r\n        result = new String(chars, i1, i2 - i1);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getParameterMap",
	"Comment": "returns a map of the parameters of this request.request parameters are extra information sent with the request.for http servlets, parameters are contained in the query stringor posted form data.",
	"Method": "Map<String, String[]> getParameterMap(){\r\n    if (parameterMap.isLocked()) {\r\n        return parameterMap;\r\n    }\r\n    Enumeration<String> e = getParameterNames();\r\n    while (e.hasMoreElements()) {\r\n        String name = e.nextElement();\r\n        String[] values = getParameterValues(name);\r\n        parameterMap.put(name, values);\r\n    }\r\n    parameterMap.setLocked(true);\r\n    return parameterMap;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.CallMethodRule.setUseExactMatch",
	"Comment": "set whether methodutils.invokeexactmethodshould be used for the reflection.",
	"Method": "void setUseExactMatch(boolean useExactMatch){\r\n    this.useExactMatch = useExactMatch;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RecoveryManager.getUniqueRMSet",
	"Comment": "reduce the set of xaresource objects into a unique set such that there is at most one xaresource object per rm.",
	"Method": "Enumeration getUniqueRMSet(Enumeration xaResourceList){\r\n    Vector uniqueRMList = new Vector();\r\n    while (xaResourceList.hasMoreElements()) {\r\n        XAResource xaRes = (XAResource) xaResourceList.nextElement();\r\n        int size = uniqueRMList.size();\r\n        boolean match = false;\r\n        for (int i = 0; i < size; i++) {\r\n            XAResource uniqueXaRes = (XAResource) uniqueRMList.elementAt(i);\r\n            try {\r\n                if (xaRes.isSameRM(uniqueXaRes)) {\r\n                    match = true;\r\n                    break;\r\n                }\r\n            } catch (XAException xe) {\r\n            }\r\n        }\r\n        if (!match) {\r\n            uniqueRMList.add(xaRes);\r\n        }\r\n    }\r\n    return uniqueRMList.elements();\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.removeServletFilterMapping",
	"Comment": "removes the given servlet filter mapping from this web component.",
	"Method": "void removeServletFilterMapping(ServletFilterMapping ref){\r\n    removeVectorItem(getServletFilterMappings(), ref);\r\n}"
}, {
	"Path": "com.sun.enterprise.loader.ASURLClassLoader.clearNotFoundCaches",
	"Comment": "erases the memory of classes and resources that have been searched for but not found.",
	"Method": "void clearNotFoundCaches(){\r\n    this.notFoundResources.clear();\r\n    this.notFoundClasses.clear();\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.core.Util.getAMXNotificationData",
	"Comment": "all notifications emitted by amx mbeans which are notstandard types defined by jmx place a mapinto the userdata field of the notification.this callretrieves that map, which may be null if no additionaldata is included.",
	"Method": "Map<String, Serializable> getAMXNotificationData(Notification notif){\r\n    return Collections.unmodifiableMap(JMXUtil.getUserDataMapString_Serializable(notif));\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.getTerminator",
	"Comment": "gets the object normally responsible for terminating this coordinator.",
	"Method": "CompletionHandler getTerminator(){\r\n    CompletionHandler result = terminator;\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.loadStandaloneWebModule",
	"Comment": "load the specified web module as a standalone module on the specifiedvirtual server.",
	"Method": "void loadStandaloneWebModule(VirtualServer vs,WebModuleConfig wmInfo){\r\n    try {\r\n        loadWebModule(vs, wmInfo, \"null\", null);\r\n    } catch (Throwable t) {\r\n        String msg = rb.getString(LogFacade.LOAD_WEB_MODULE_ERROR);\r\n        msg = MessageFormat.format(msg, wmInfo.getName());\r\n        logger.log(Level.SEVERE, msg, t);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.jts.recovery.OracleXAResource.toHexString",
	"Comment": "converts xids into string that can be used in sql statements for oracle.",
	"Method": "String toHexString(byte abyte0){\r\n    StringBuffer stringbuffer = new StringBuffer();\r\n    if (null != abyte0 && 0 < abyte0.length) {\r\n        for (int i = 0; i < abyte0.length; i++) {\r\n            stringbuffer.append(HEX_DIGITS[(abyte0[i] & 0xf0) >> 4]);\r\n            stringbuffer.append(HEX_DIGITS[abyte0[i] & 0xf]);\r\n        }\r\n        return stringbuffer.toString();\r\n    } else {\r\n        return \"\";\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.RulesBase.setDigester",
	"Comment": "set the digester instance with which this rules instance is associated.",
	"Method": "void setDigester(Digester digester){\r\n    this.digester = digester;\r\n    Iterator<Rule> items = rules.iterator();\r\n    while (items.hasNext()) {\r\n        Rule item = items.next();\r\n        item.setDigester(digester);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.startup.HostConfig.setXmlValidation",
	"Comment": "set the validation feature of the xml parser used whenparsing xml instances.",
	"Method": "void setXmlValidation(boolean xmlValidation){\r\n    this.xmlValidation = xmlValidation;\r\n}"
}, {
	"Path": "com.sun.jts.jtsxa.Utility.getXID",
	"Comment": "obtain the global transaction identifier for the current transaction.",
	"Method": "XID getXID(Coordinator coordinator,XID getXID){\r\n    Control control = null;\r\n    Coordinator coordinator = null;\r\n    control = getControl();\r\n    coordinator = getCoordinator(control);\r\n    XID xid = getXID(coordinator);\r\n    return xid;\r\n}"
}, {
	"Path": "components.renderkit.ChartServlet.getColor",
	"Comment": "returns the color instance corresponding the color passed in.",
	"Method": "Color getColor(String colorStr){\r\n    Color color = null;\r\n    if (colorStr == null) {\r\n        color = Color.gray;\r\n    }\r\n    if (colorStr.equals(\"red\")) {\r\n        color = Color.red;\r\n    } else if (colorStr.equals(\"green\")) {\r\n        color = Color.green;\r\n    } else if (colorStr.equals(\"blue\")) {\r\n        color = Color.blue;\r\n    } else if (colorStr.equals(\"pink\")) {\r\n        color = Color.pink;\r\n    } else if (colorStr.equals(\"orange\")) {\r\n        color = Color.orange;\r\n    } else if (colorStr.equals(\"magenta\")) {\r\n        color = Color.magenta;\r\n    } else if (colorStr.equals(\"cyan\")) {\r\n        color = Color.cyan;\r\n    } else if (colorStr.equals(\"white\")) {\r\n        color = Color.white;\r\n    } else if (colorStr.equals(\"yellow\")) {\r\n        color = Color.yellow;\r\n    } else if (colorStr.equals(\"gray\")) {\r\n        color = Color.gray;\r\n    } else if (colorStr.equals(\"darkGray\")) {\r\n        color = Color.darkGray;\r\n    } else {\r\n        color = Color.gray;\r\n    }\r\n    return color;\r\n}"
}, {
	"Path": "org.apache.catalina.util.StringParser.skipWhite",
	"Comment": "advance the current parsing position while it is pointing at awhitespace character, or until it moves past the end of the string.return the final value.",
	"Method": "int skipWhite(){\r\n    while ((index < length) && isWhite(chars[index])) index++;\r\n    return (index);\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.SecurityConstraintImpl.removeWebResourceCollection",
	"Comment": "removes the given web resource collection from this constraint.",
	"Method": "void removeWebResourceCollection(WebResourceCollection webResourceCollection){\r\n    this.getWebResourceCollections().remove(webResourceCollection);\r\n}"
}, {
	"Path": "org.glassfish.internal.data.ApplicationInfo.getSource",
	"Comment": "returns the directory where the application bits are located",
	"Method": "ReadableArchive getSource(){\r\n    return source;\r\n}"
}, {
	"Path": "org.glassfish.common.util.admin.AsadminInput.reader",
	"Comment": "returns a reader that can consume the specified version of asadmin input",
	"Method": "InputReader reader(String inputPath,InputReader reader,InputStream is){\r\n    final BufferedReader reader = new BufferedReader(new InputStreamReader(is));\r\n    final String version = readVersionFromFirstLine(reader);\r\n    return newReader(reader, version);\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionManagerImpl.mapStatus",
	"Comment": "given a costransactions status, returnthe equivalent jta status",
	"Method": "int mapStatus(Status status){\r\n    int statusVal = status.value();\r\n    if (statusVal < 0 || statusVal > maxStatus) {\r\n        return javax.transaction.Status.STATUS_UNKNOWN;\r\n    } else {\r\n        return directLookup[statusVal];\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.appclient.AppClientVerifier.getClassPath",
	"Comment": "creates and returns the class path associated with the client jar.uses the exploded location of the archive for generating the classpath.",
	"Method": "String getClassPath(){\r\n    if (classPath != null)\r\n        return classPath;\r\n    if (isASMode)\r\n        return (classPath = getClassPath(verifierFrameworkContext.getClassPath()));\r\n    String cp;\r\n    if (!appclientd.getModuleDescriptor().isStandalone()) {\r\n        String ear_uri = verifierFrameworkContext.getExplodedArchivePath();\r\n        File ear = new File(ear_uri);\r\n        assert (ear.isDirectory());\r\n        String earCP = ClassPathBuilder.buildClassPathForEar(ear);\r\n        String libdir = appclientd.getApplication().getLibraryDirectory();\r\n        if (libdir != null) {\r\n            earCP = getLibdirClasspath(ear_uri, libdir) + earCP;\r\n        }\r\n        String module_uri = appclientd.getModuleDescriptor().getArchiveUri();\r\n        File module = new File(module_uri);\r\n        assert (module.isFile() && !module.isAbsolute());\r\n        File explodedModuleDir = new File(ear_uri, FileUtils.makeFriendlyFilename(module_uri));\r\n        String moduleCP = ClassPathBuilder.buildClassPathForJar(explodedModuleDir);\r\n        cp = moduleCP + File.pathSeparator + earCP;\r\n    } else {\r\n        String module_uri = verifierFrameworkContext.getExplodedArchivePath();\r\n        File module = new File(module_uri);\r\n        assert (module.isDirectory() && module.isAbsolute());\r\n        cp = ClassPathBuilder.buildClassPathForJar(module);\r\n    }\r\n    return (classPath = cp);\r\n}"
}, {
	"Path": "org.glassfish.cluster.ssh.launcher.SSHLauncher.runCommand",
	"Comment": "warning! this method does not handle paths with spaces in them.to use this method you must make sure all paths in the command stringare quoted correctly.otherwise use the methods that take command asa list instead.",
	"Method": "int runCommand(List<String> command,OutputStream os,List<String> stdinLines,int runCommand,List<String> command,OutputStream os,int runCommand,String command,OutputStream os,int runCommand,String command,OutputStream os,List<String> stdinLines){\r\n    command = SFTPClient.normalizePath(command);\r\n    return runCommandAsIs(command, os, stdinLines);\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ModifiedAttributeHASession.setAttributeStateDirty",
	"Comment": "set the sessionattributestate for attributenamebased on dirty value",
	"Method": "void setAttributeStateDirty(String attributeName,boolean dirty){\r\n    SessionAttributeState attrState = _attributeStates.get(attributeName);\r\n    if (attrState == null) {\r\n        attrState = new SessionAttributeState();\r\n        attrState.setDirty(dirty);\r\n        _attributeStates.put(attributeName, attrState);\r\n    } else {\r\n        attrState.setDirty(dirty);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.cli.DomainXmlVerifier.invokeConfigValidator",
	"Comment": "returns true if there is an error in the domain.xml or some other problem.",
	"Method": "boolean invokeConfigValidator(){\r\n    boolean failed = false;\r\n    try {\r\n        failed = validate();\r\n    } catch (Exception e) {\r\n        failed = true;\r\n        e.printStackTrace();\r\n    }\r\n    return failed;\r\n}"
}, {
	"Path": "com.sun.enterprise.universal.process.ProcessStreamDrainer.waitFor",
	"Comment": "wait for the drain threads to die.this is guaranteed to occur after theexternal process dies.note that this may, of course, block indefinitely.",
	"Method": "void waitFor(){\r\n    errThread.join();\r\n    outThread.join();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.afterCompletion",
	"Comment": "informs the topcoordinator that the transaction has completed.the topcoordinator informs all synchronization objects registered withit that the transaction has completed. it does not need to wait for allresponses before returning.",
	"Method": "void afterCompletion(Status status){\r\n    if (tranState.state == TransactionState.STATE_ACTIVE) {\r\n        tranState.setState(TransactionState.STATE_PREPARING);\r\n        tranState.setState(TransactionState.STATE_PREPARED_READONLY);\r\n    }\r\n    if (synchronizations != null) {\r\n        synchronizations.distributeAfter(status);\r\n    }\r\n    boolean aborted = true;\r\n    if (status == Status.StatusCommitted) {\r\n        aborted = false;\r\n    }\r\n    if (!delegated) {\r\n        RecoveryManager.removeCoordinator(superInfo.globalTID, superInfo.localTID, aborted);\r\n    } else {\r\n        DelegatedRecoveryManager.removeCoordinator(superInfo.globalTID, superInfo.localTID, aborted, logPath);\r\n    }\r\n    if (recoveryCoordinatorList != null) {\r\n        for (int i = 0; i < recoveryCoordinatorList.size(); i++) {\r\n            RecoveryCoordinatorImpl rcImpl = (RecoveryCoordinatorImpl) recoveryCoordinatorList.elementAt(i);\r\n            rcImpl.destroy();\r\n        }\r\n        recoveryCoordinatorList = null;\r\n    }\r\n    if (this.coordSyncImpl != null) {\r\n        this.coordSyncImpl.destroy();\r\n    }\r\n    this.synchronizations = null;\r\n    destroy();\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getMinorVersion",
	"Comment": "return the minor version of the java servlet api that we implement.",
	"Method": "int getMinorVersion(){\r\n    return (Constants.MINOR_VERSION);\r\n}"
}, {
	"Path": "org.apache.catalina.util.ManifestResource.requiresExtensions",
	"Comment": "convenience method to check if this manifestresourcehas an requires extensions.",
	"Method": "boolean requiresExtensions(){\r\n    return (requiredExtensions != null) ? true : false;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.RequestFacade.getServletContext",
	"Comment": "gets the servlet context to which this servlet request was lastdispatched.",
	"Method": "ServletContext getServletContext(){\r\n    return request.getServletContext();\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.getProperty",
	"Comment": "return the current value of the specified property for the underlyingxmlreader implementation.see for information about the standard sax2 properties.",
	"Method": "String getProperty(String key,Object getProperty,String property){\r\n    return (getParser().getProperty(property));\r\n}"
}, {
	"Path": "org.glassfish.common.util.ObjectInputStreamWithLoader.resolveClass",
	"Comment": "use the given classloader rather than using the system class",
	"Method": "Class resolveClass(ObjectStreamClass classDesc){\r\n    try {\r\n        String cname = classDesc.getName();\r\n        if (cname.startsWith(\"[\")) {\r\n            Class component;\r\n            int dcount;\r\n            for (dcount = 1; cname.charAt(dcount) == '['; dcount++) ;\r\n            if (cname.charAt(dcount) == 'L') {\r\n                component = loader.loadClass(cname.substring(dcount + 1, cname.length() - 1));\r\n            } else {\r\n                if (cname.length() != dcount + 1) {\r\n                    throw new ClassNotFoundException(cname);\r\n                }\r\n                component = primitiveType(cname.charAt(dcount));\r\n            }\r\n            int[] dim = new int[dcount];\r\n            for (int i = 0; i < dcount; i++) {\r\n                dim[i] = 0;\r\n            }\r\n            return Array.newInstance(component, dim).getClass();\r\n        } else {\r\n            return loader.loadClass(cname);\r\n        }\r\n    } catch (ClassNotFoundException e) {\r\n        return super.resolveClass(classDesc);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardService.setContainer",
	"Comment": "set the container that handles requests for allconnectors associated with this service.",
	"Method": "void setContainer(Container container){\r\n    Container oldContainer = this.container;\r\n    if ((oldContainer != null) && (oldContainer instanceof Engine))\r\n        ((Engine) oldContainer).setService(null);\r\n    this.container = container;\r\n    if (this.container instanceof Engine)\r\n        ((Engine) this.container).setService(this);\r\n    if (started && (this.container != null) && (this.container instanceof Lifecycle)) {\r\n        try {\r\n            ((Lifecycle) this.container).start();\r\n        } catch (LifecycleException e) {\r\n        }\r\n    }\r\n    synchronized (connectorsMonitor) {\r\n        for (int i = 0; i < connectors.length; i++) connectors[i].setContainer(this.container);\r\n    }\r\n    if (started && (oldContainer != null) && (oldContainer instanceof Lifecycle)) {\r\n        try {\r\n            ((Lifecycle) oldContainer).stop();\r\n        } catch (LifecycleException e) {\r\n        }\r\n    }\r\n    support.firePropertyChange(\"container\", oldContainer, this.container);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.logger.CatalinaLogger.setLevel",
	"Comment": "set the verbosity level of this logger.messages logged with ahigher verbosity than this level will be silently ignored.",
	"Method": "void setLevel(String logLevel){\r\n    if (\"SEVERE\".equalsIgnoreCase(logLevel)) {\r\n        logger.setLevel(Level.SEVERE);\r\n    } else if (\"WARNING\".equalsIgnoreCase(logLevel)) {\r\n        logger.setLevel(Level.WARNING);\r\n    } else if (\"INFO\".equalsIgnoreCase(logLevel)) {\r\n        logger.setLevel(Level.INFO);\r\n    } else if (\"CONFIG\".equalsIgnoreCase(logLevel)) {\r\n        logger.setLevel(Level.CONFIG);\r\n    } else if (\"FINE\".equalsIgnoreCase(logLevel)) {\r\n        logger.setLevel(Level.FINE);\r\n    } else if (\"FINER\".equalsIgnoreCase(logLevel)) {\r\n        logger.setLevel(Level.FINER);\r\n    } else if (\"FINEST\".equalsIgnoreCase(logLevel)) {\r\n        logger.setLevel(Level.FINEST);\r\n    } else {\r\n        logger.setLevel(Level.INFO);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.server.logging.LogFormatHelper.isODLFormatLogHeader",
	"Comment": "determines whether the given line is the beginning of a odl log record.",
	"Method": "boolean isODLFormatLogHeader(String line){\r\n    if (line.length() > ODL_SUBSTRING_LEN && PatternHolder.ODL_PATTERN.matcher(line.substring(0, ODL_SUBSTRING_LEN)).matches() && countOccurrences(line, '[') > 4) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.FactoryCreateRule.getFactory",
	"Comment": "return an instance of our associated object creation factory,creating one if necessary.",
	"Method": "ObjectCreationFactory getFactory(Attributes attributes){\r\n    if (creationFactory == null) {\r\n        String realClassName = className;\r\n        if (attributeName != null) {\r\n            String value = attributes.getValue(attributeName);\r\n            if (value != null) {\r\n                realClassName = value;\r\n            }\r\n        }\r\n        if (digester.log.isLoggable(Level.FINE)) {\r\n            digester.log.log(Level.FINE, \"[FactoryCreateRule]{\" + digester.match + \"} New factory \" + realClassName);\r\n        }\r\n        Class<?> clazz = digester.getClassLoader().loadClass(realClassName);\r\n        creationFactory = (ObjectCreationFactory) clazz.newInstance();\r\n        creationFactory.setDigester(digester);\r\n    }\r\n    return (creationFactory);\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.jts.recovery.GMSCallBack.finishDelegatedRecovery",
	"Comment": "find records of not finished delegated recovery in the recovery lock file onthis path and recorded before specified timestamp, and do delegated recovery if such record exists",
	"Method": "String finishDelegatedRecovery(String logdir,String finishDelegatedRecovery,String logdir,long timestamp){\r\n    String delegatedLogDir = null;\r\n    String instance = fence.getInstanceRecoveredFor(logdir, timestamp);\r\n    if (_logger.isLoggable(Level.INFO)) {\r\n        _logger.log(Level.INFO, \"[GMSCallBack] Instance \" + instance + \" need to finish delegated recovering\");\r\n    }\r\n    if (instance != null) {\r\n        DistributedStateCache dsc = gms.getGroupHandle().getDistributedStateCache();\r\n        Map<Serializable, Serializable> memberDetails = dsc.getFromCacheForPattern(MEMBER_DETAILS, instance);\r\n        delegatedLogDir = (String) memberDetails.get(TXLOGLOCATION);\r\n        if (_logger.isLoggable(Level.INFO)) {\r\n            _logger.log(Level.INFO, \"[GMSCallBack] Tx log dir for instance \" + instance + \" is \" + delegatedLogDir);\r\n        }\r\n        doRecovery(delegatedLogDir, instance, timestamp);\r\n    }\r\n    return delegatedLogDir;\r\n}"
}, {
	"Path": "org.apache.naming.NamingContext.removeFromEnvironment",
	"Comment": "removes an environment property from the environment of this context.",
	"Method": "Object removeFromEnvironment(String propName){\r\n    return env.remove(propName);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.backgroundProcess",
	"Comment": "execute a periodic task, such as reloading, etc. this method will beinvoked inside the classloading context of this container. unexpectedthrowables will be caught and logged.",
	"Method": "void backgroundProcess(){\r\n    if (!started)\r\n        return;\r\n    count = (count + 1) % managerChecksFrequency;\r\n    if ((getManager() != null) && (count == 0)) {\r\n        if (getManager() instanceof StandardManager) {\r\n            ((StandardManager) getManager()).processExpires();\r\n        } else if (getManager() instanceof PersistentManagerBase) {\r\n            PersistentManagerBase pManager = (PersistentManagerBase) getManager();\r\n            pManager.backgroundProcess();\r\n        }\r\n    }\r\n    if (isReload()) {\r\n        if (getLoader() != null) {\r\n            if (reloadable && (getLoader().modified())) {\r\n                try {\r\n                    Thread.currentThread().setContextClassLoader(standardContextClassLoader);\r\n                    reload();\r\n                } finally {\r\n                    if (getLoader() != null) {\r\n                        Thread.currentThread().setContextClassLoader(getClassLoader());\r\n                    }\r\n                }\r\n            }\r\n            if (getLoader() instanceof WebappLoader) {\r\n                ((WebappLoader) getLoader()).closeJARs(false);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.SingleSignOnEntry.addSession",
	"Comment": "adds the given session to this singlesignonentry if it does notalready exist.",
	"Method": "boolean addSession(SingleSignOn sso,Session session){\r\n    boolean result = sessions.add(session);\r\n    if (result) {\r\n        session.addSessionListener(sso);\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.domain.DomainSecurity.createSSLCertificateDatabase",
	"Comment": "create the default ssl key store using keytool to generate a self signedcertificate.",
	"Method": "void createSSLCertificateDatabase(File configDir,DomainConfig config,String masterPassword){\r\n    createKeyStore(new File(configDir, DomainConstants.KEYSTORE_FILE), config, masterPassword);\r\n    changeKeystorePassword(DEFAULT_MASTER_PASSWORD, masterPassword, new File(configDir, DomainConstants.TRUSTSTORE_FILE));\r\n    copyCertificates(configDir, config, masterPassword);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.StopLocalInstanceCommand.instanceNotRunning",
	"Comment": "print message and return exit code whenwe detect that the das is not running.",
	"Method": "int instanceNotRunning(){\r\n    if (kill)\r\n        return kill();\r\n    logger.warning(Strings.get(\"StopInstance.instanceNotRunning\"));\r\n    return 0;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.hasWatchedResources",
	"Comment": "checks whether this web application has any watched resourcesdefined.",
	"Method": "boolean hasWatchedResources(){\r\n    return !watchedResources.isEmpty();\r\n}"
}, {
	"Path": "org.apache.catalina.valves.JDBCAccessLogValve.setMethodField",
	"Comment": "sets the name of the field containing the http request method.",
	"Method": "void setMethodField(String methodField){\r\n    this.methodField = methodField;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.TagLibDescriptor.getFunctionDescriptors",
	"Comment": "for each functions in tag lib descriptor creates a function descritor andreturn the array of functiondescriptors",
	"Method": "FunctionDescriptor[] getFunctionDescriptors(){\r\n    NodeList nl = doc.getElementsByTagName(FUNCTION);\r\n    List<FunctionDescriptor> list = new ArrayList<FunctionDescriptor>();\r\n    if (nl != null) {\r\n        int size = nl.getLength();\r\n        for (int i = 0; i < size; i++) {\r\n            list.add(new FunctionDescriptor(nl.item(i)));\r\n        }\r\n    }\r\n    return list.toArray(new FunctionDescriptor[0]);\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.SingleSignOnEntry.expireSessions",
	"Comment": "expires all sessions associated with this singlesignonentry",
	"Method": "void expireSessions(){\r\n    for (Session session : sessions) {\r\n        if (log.isLoggable(Level.FINE)) {\r\n            log.log(Level.FINE, \" Invalidating session \" + session);\r\n        }\r\n        if ((session).getIsValid()) {\r\n            session.expire();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.is_descendant_transaction",
	"Comment": "determines whether the target subcoordinator is a descendantof the given coordinator.this operation references no instance variables and so can beimplemented locally in a proxy class.",
	"Method": "boolean is_descendant_transaction(Coordinator other){\r\n    boolean result = false;\r\n    if (tranState != null) {\r\n        if (is_same_transaction(other)) {\r\n            result = true;\r\n        } else {\r\n            result = nestingInfo.isDescendant(other);\r\n        }\r\n    } else {\r\n        INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.Completed, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.filters.CsrfPreventionFilter.setNonceCacheSize",
	"Comment": "sets the number of previously issued nonces that will be cached on a lrubasis to support parallel requests, limited use of the refresh and backin the browser and similar behaviors that may result in the submissionof a previous nonce rather than the current one. if not set, the defaultvalue of 5 will be used.",
	"Method": "void setNonceCacheSize(int nonceCacheSize){\r\n    this.nonceCacheSize = nonceCacheSize;\r\n}"
}, {
	"Path": "org.glassfish.contextpropagation.spi.ContextMapHelper.registerContextFactoryForPrefixNamed",
	"Comment": "viewcapable objects are created by the context propagation framework when needed using the contextviewfactory registered against thespecified context name",
	"Method": "void registerContextFactoryForPrefixNamed(String prefixName,ContextViewFactory factory){\r\n    Utils.registerContextFactoryForPrefixNamed(prefixName, factory);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmrFieldsAccessorExposition.runIndividualCmrTest",
	"Comment": "run an individual verifier test of a declated cmr field of the class",
	"Method": "boolean runIndividualCmrTest(Descriptor descriptor,RelationRoleDescriptor rrd,Class c,Result result){\r\n    boolean pass = true;\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (((EjbDescriptor) descriptor).getRemoteClassName() != null && !((((EjbDescriptor) descriptor).getRemoteClassName()).equals(\"\"))) {\r\n        String interfaceType = ((EjbDescriptor) descriptor).getRemoteClassName();\r\n        try {\r\n            CMRFieldInfo info = rrd.getCMRFieldInfo();\r\n            Class remoteInterface = Class.forName(interfaceType, false, getVerifierContext().getClassLoader());\r\n            String getMethodName = \"get\" + Character.toUpperCase(info.name.charAt(0)) + info.name.substring(1);\r\n            String setMethodName = \"set\" + Character.toUpperCase(info.name.charAt(0)) + info.name.substring(1);\r\n            Method getMethod = getMethod(remoteInterface, getMethodName, null);\r\n            if (getMethod != null) {\r\n                addErrorDetails(result, compName);\r\n                result.addErrorDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmrFieldsAccessorExposition.failed\", \"Error : CMR field {0} accessor method [ {1} ] is exposed through the component interface [ {2} ]\", new Object[] { \"get\", info.name, interfaceType }));\r\n                pass = false;\r\n            } else {\r\n                result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.addGoodDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmrFieldsAccessorExposition.passed\", \"CMR field {0} accessor method [ {1} ] is not exposed through the component interface [ {2} ]\", new Object[] { \"get\", info.name, interfaceType }));\r\n                pass = true;\r\n            }\r\n            Class[] parms = { info.type };\r\n            Method setMethod = getMethod(remoteInterface, setMethodName, parms);\r\n            if (setMethod != null) {\r\n                addErrorDetails(result, compName);\r\n                result.addErrorDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmrFieldsAccessorExposition.failed\", \"Error : CMR field {0} accessor method [ {1} ] is exposed through the component interface [ {2} ]\", new Object[] { \"set\", info.name, interfaceType }));\r\n                pass = false;\r\n            } else {\r\n                result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.addGoodDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmrFieldsAccessorExposition.passed\", \"CMR field [{0}] accessor method [ {1} ] is not exposed through the component interface [ {2} ]\", new Object[] { \"set\", info.name, interfaceType }));\r\n            }\r\n        } catch (Exception e) {\r\n            Verifier.debug(e);\r\n            addErrorDetails(result, compName);\r\n            result.addErrorDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmrFieldsAccessorExposition.failedException\", \"Error:  [{0}] class not found or local interface not defined\", new Object[] { interfaceType }));\r\n            pass = false;\r\n        }\r\n    }\r\n    return pass;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.OutputBuffer.realWriteBytes",
	"Comment": "sends the buffer data to the client output, checking thestate of response and calling the right interceptors.",
	"Method": "void realWriteBytes(byte buf,int off,int cnt){\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \"realWrite(b, \" + off + \", \" + cnt + \") \" + grizzlyResponse);\r\n    if (grizzlyResponse == null)\r\n        return;\r\n    if (grizzlyOutputBuffer.isClosed())\r\n        return;\r\n    if (cnt > 0) {\r\n        try {\r\n            grizzlyOutputBuffer.write(buf, off, cnt);\r\n        } catch (IOException e) {\r\n            throw new ClientAbortException(e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.services.impl.DynamicConfigListener.acquirePortLock",
	"Comment": "lock tcp ports, which will take part in the reconfiguration to avoid collisions",
	"Method": "Lock acquirePortLock(NetworkListener listener){\r\n    final boolean isLoggingFinest = logger.isLoggable(Level.FINEST);\r\n    final int port = getPort(listener);\r\n    try {\r\n        while (true) {\r\n            logger.finest(\"Aquire reconfig lock\");\r\n            if (reconfigLock.tryLock(RECONFIG_LOCK_TIMEOUT_SEC, TimeUnit.SECONDS)) {\r\n                Future lock = reconfigByPortLock.get(port);\r\n                if (isLoggingFinest) {\r\n                    logger.log(Level.FINEST, \"Reconfig lock for port: {0} is {1}\", new Object[] { port, lock });\r\n                }\r\n                int proxyPort = -1;\r\n                if (lock == null) {\r\n                    final NetworkProxy runningProxy = grizzlyService.lookupNetworkProxy(listener);\r\n                    if (runningProxy != null) {\r\n                        proxyPort = runningProxy.getPort();\r\n                        if (port != proxyPort) {\r\n                            lock = reconfigByPortLock.get(proxyPort);\r\n                            if (isLoggingFinest) {\r\n                                logger.log(Level.FINEST, \"Reconfig lock for proxyport: {0} is {1}\", new Object[] { proxyPort, lock });\r\n                            }\r\n                        } else {\r\n                            proxyPort = -1;\r\n                        }\r\n                    }\r\n                }\r\n                if (lock != null) {\r\n                    reconfigLock.unlock();\r\n                    try {\r\n                        logger.finest(\"Waiting on reconfig lock\");\r\n                        lock.get(RECONFIG_LOCK_TIMEOUT_SEC, TimeUnit.SECONDS);\r\n                    } catch (ExecutionException e) {\r\n                        throw new IllegalStateException(e);\r\n                    }\r\n                } else {\r\n                    final FutureImpl future = SafeFutureImpl.create();\r\n                    if (isLoggingFinest) {\r\n                        logger.log(Level.FINEST, \"Set reconfig lock for ports: {0} and {1}: {2}\", new Object[] { port, proxyPort, future });\r\n                    }\r\n                    reconfigByPortLock.put(port, future);\r\n                    if (proxyPort != -1) {\r\n                        reconfigByPortLock.put(proxyPort, future);\r\n                    }\r\n                    return new Lock(port, proxyPort);\r\n                }\r\n            } else {\r\n                throw new TimeoutException(\"Lock timeout\");\r\n            }\r\n        }\r\n    } finally {\r\n        if (reconfigLock.isHeldByCurrentThread()) {\r\n            reconfigLock.unlock();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "components.taglib.GraphMenuTreeTag.setActionListener",
	"Comment": "method reference to handle menu expansion and contraction events",
	"Method": "void setActionListener(String actionListener){\r\n    this.actionListener = actionListener;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.DefaultAccessLogFormatterImpl.appendVirtualServerId",
	"Comment": "appends the id of the virtual server with which this access log valvehas been associated to the given char buffer.",
	"Method": "void appendVirtualServerId(CharBuffer cb){\r\n    String vsId = \"NULL-VIRTUAL-SERVER\";\r\n    if (container != null) {\r\n        vsId = container.getName();\r\n    }\r\n    cb.put(vsId);\r\n}"
}, {
	"Path": "org.apache.catalina.valves.RequestFilterValve.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (info);\r\n}"
}, {
	"Path": "org.glassfish.webservices.ServiceInvocationHandler.init",
	"Comment": "convert invocation method to a constant for easier processing.",
	"Method": "void init(){\r\n    serviceMethodTypes = new HashMap();\r\n    fullWsdlIllegalMethods = new HashSet();\r\n    noWsdlIllegalMethods = new HashSet();\r\n    try {\r\n        Class[] noParams = new Class[0];\r\n        String createCall = \"createCall\";\r\n        Class serviceClass = javax.xml.rpc.Service.class;\r\n        Method createCallNoArgs = serviceClass.getDeclaredMethod(createCall, noParams);\r\n        serviceMethodTypes.put(createCallNoArgs, Integer.valueOf(CREATE_CALL_NO_ARGS));\r\n        Method createCallPort = serviceClass.getDeclaredMethod(createCall, new Class[] { QName.class });\r\n        serviceMethodTypes.put(createCallPort, Integer.valueOf(CREATE_CALL_PORT));\r\n        Method createCallOperationQName = serviceClass.getDeclaredMethod(createCall, new Class[] { QName.class, QName.class });\r\n        serviceMethodTypes.put(createCallOperationQName, Integer.valueOf(CREATE_CALL_OPERATION_QNAME));\r\n        Method createCallOperationString = serviceClass.getDeclaredMethod(createCall, new Class[] { QName.class, String.class });\r\n        serviceMethodTypes.put(createCallOperationString, Integer.valueOf(CREATE_CALL_OPERATION_STRING));\r\n        Method getCalls = serviceClass.getDeclaredMethod(\"getCalls\", new Class[] { QName.class });\r\n        serviceMethodTypes.put(getCalls, Integer.valueOf(GET_CALLS));\r\n        Method getHandlerRegistry = serviceClass.getDeclaredMethod(\"getHandlerRegistry\", noParams);\r\n        serviceMethodTypes.put(getHandlerRegistry, Integer.valueOf(GET_HANDLER_REGISTRY));\r\n        Method getPortContainerManaged = serviceClass.getDeclaredMethod(\"getPort\", new Class[] { Class.class });\r\n        serviceMethodTypes.put(getPortContainerManaged, Integer.valueOf(GET_PORT_CONTAINER_MANAGED));\r\n        Method getPortClientManaged = serviceClass.getDeclaredMethod(\"getPort\", new Class[] { QName.class, Class.class });\r\n        serviceMethodTypes.put(getPortClientManaged, Integer.valueOf(GET_PORT_CLIENT_MANAGED));\r\n        Method getPorts = serviceClass.getDeclaredMethod(\"getPorts\", noParams);\r\n        serviceMethodTypes.put(getPorts, Integer.valueOf(GET_PORTS));\r\n        Method getServiceName = serviceClass.getDeclaredMethod(\"getServiceName\", noParams);\r\n        serviceMethodTypes.put(getServiceName, Integer.valueOf(GET_SERVICE_NAME));\r\n        Method getTypeMappingRegistry = serviceClass.getDeclaredMethod(\"getTypeMappingRegistry\", noParams);\r\n        serviceMethodTypes.put(getTypeMappingRegistry, Integer.valueOf(GET_TYPE_MAPPING_REGISTRY));\r\n        Method getWsdlLocation = serviceClass.getDeclaredMethod(\"getWSDLDocumentLocation\", noParams);\r\n        serviceMethodTypes.put(getWsdlLocation, Integer.valueOf(GET_WSDL_LOCATION));\r\n    } catch (NoSuchMethodException nsme) {\r\n    }\r\n    fullWsdlIllegalMethods.add(GET_HANDLER_REGISTRY);\r\n    fullWsdlIllegalMethods.add(GET_TYPE_MAPPING_REGISTRY);\r\n    noWsdlIllegalMethods.add(CREATE_CALL_PORT);\r\n    noWsdlIllegalMethods.add(CREATE_CALL_OPERATION_QNAME);\r\n    noWsdlIllegalMethods.add(CREATE_CALL_OPERATION_STRING);\r\n    noWsdlIllegalMethods.add(GET_CALLS);\r\n    noWsdlIllegalMethods.add(GET_HANDLER_REGISTRY);\r\n    noWsdlIllegalMethods.add(GET_PORT_CONTAINER_MANAGED);\r\n    noWsdlIllegalMethods.add(GET_PORT_CLIENT_MANAGED);\r\n    noWsdlIllegalMethods.add(GET_PORTS);\r\n    noWsdlIllegalMethods.add(GET_SERVICE_NAME);\r\n    noWsdlIllegalMethods.add(GET_TYPE_MAPPING_REGISTRY);\r\n    noWsdlIllegalMethods.add(GET_WSDL_LOCATION);\r\n    noWsdlIllegalMethods.add(Integer.valueOf(GENERATED_SERVICE_METHOD));\r\n}"
}, {
	"Path": "com.sun.enterprise.deploy.shared.FileArchive.entries",
	"Comment": "returns an enumeration of the module file entries with thespecified prefix.all elements in the enumeration are of type string.each string represents a file name relative to the root of the module.",
	"Method": "Enumeration entries(Enumeration entries,Enumeration embeddedArchives,Enumeration<String> entries,String prefix){\r\n    prefix = prefix.replace('/', File.separatorChar);\r\n    File file = new File(archive, prefix);\r\n    List<String> namesList = new ArrayList<String>();\r\n    getListOfFiles(file, namesList, null);\r\n    return Collections.enumeration(namesList);\r\n}"
}, {
	"Path": "org.apache.catalina.util.MIME2Java.convert",
	"Comment": "convert a mime charset name, also known as an xml encoding name, to a java encoding name.",
	"Method": "String convert(String mimeCharsetName){\r\n    return s_enchash.get(mimeCharsetName.toUpperCase(Locale.ENGLISH));\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.SimpleDeployer.prepare",
	"Comment": "prepares the application bits for running in the application server.for certain cases, this is generating non portableartifacts and other application specific tasks.failure to prepare should throw an exception which will cause the overalldeployment to fail.",
	"Method": "boolean prepare(DeploymentContext dc){\r\n    try {\r\n        if (!dc.getCommandParameters(OpsParams.class).origin.isArtifactsPresent()) {\r\n            generateArtifacts(dc);\r\n        }\r\n        return true;\r\n    } catch (Exception ex) {\r\n        RuntimeException re = new RuntimeException(ex.getMessage());\r\n        re.initCause(ex);\r\n        throw re;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationRequest.isSpecial",
	"Comment": "is this attribute name one of the special ones that is added only forincluded servlets?",
	"Method": "boolean isSpecial(String name){\r\n    return specials.contains(name);\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.getUseContextClassLoader",
	"Comment": "return the boolean as to whether the context classloader should be used.",
	"Method": "boolean getUseContextClassLoader(){\r\n    return useContextClassLoader;\r\n}"
}, {
	"Path": "com.sun.jts.jtsxa.OTSResourceImpl.forget",
	"Comment": "the resource manager can forget all knowledge of the transaction.",
	"Method": "void forget(){\r\n    try {\r\n        xaRes.forget(xid);\r\n    } catch (XAException e) {\r\n        if (_logger.isLoggable(Level.FINE))\r\n            _logger.log(Level.FINE, \"An XAException occurred in forget\", e);\r\n    }\r\n    destroy();\r\n    return;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.managed.ManagedConnectionFactoryImplementation.check",
	"Comment": "all connector tests should implement this method. it run an individualtest against the resource adapter deployment descriptor.",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!descriptor.getOutBoundDefined()) {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.managed.notApplicableForInboundRA\", \"Resource Adapter does not provide outbound communication\"));\r\n        return result;\r\n    }\r\n    testImplementationOf(descriptor, \"javax.resource.spi.ManagedConnectionFactory\", result);\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.JavaEETransactionManagerSimplified.unfreeze",
	"Comment": "called by admin framework to freeze the transactions. these undoes the work done by the freeze.",
	"Method": "void unfreeze(){\r\n    getDelegate().releaseWriteLock();\r\n    monitor.freezeEvent(false);\r\n}"
}, {
	"Path": "org.apache.catalina.servlets.DefaultServlet.renderHtml",
	"Comment": "return an inputstream to an html representation of the contentsof this directory.",
	"Method": "InputStream renderHtml(String contextPath,CacheEntry cacheEntry,InputStream renderHtml,String contextPath,CacheEntry cacheEntry,ProxyDirContext proxyDirContext){\r\n    String name = cacheEntry.name;\r\n    ByteArrayOutputStream stream = new ByteArrayOutputStream();\r\n    OutputStreamWriter osWriter = null;\r\n    try {\r\n        osWriter = new OutputStreamWriter(stream, \"UTF8\");\r\n    } catch (Exception e) {\r\n        osWriter = new OutputStreamWriter(stream);\r\n    }\r\n    PrintWriter writer = new PrintWriter(osWriter);\r\n    StringBuilder sb = new StringBuilder();\r\n    String rewrittenContextPath = rewriteUrl(contextPath);\r\n    String dirTitle = MessageFormat.format(rb.getString(LogFacade.DIR_TITLE_INFO), name);\r\n    sb.append(\"<html>\\r\\n\");\r\n    sb.append(\"<head>\\r\\n\");\r\n    sb.append(\"<title>\");\r\n    sb.append(dirTitle);\r\n    sb.append(\"<\/title>\\r\\n\");\r\n    sb.append(\"<STYLE><!--\");\r\n    sb.append(org.apache.catalina.util.TomcatCSS.TOMCAT_CSS);\r\n    sb.append(\"--><\/STYLE> \");\r\n    sb.append(\"<\/head>\\r\\n\");\r\n    sb.append(\"<body>\");\r\n    sb.append(\"<h1>\");\r\n    sb.append(dirTitle);\r\n    String parentDirectory = name;\r\n    if (parentDirectory.endsWith(\"/\")) {\r\n        parentDirectory = parentDirectory.substring(0, parentDirectory.length() - 1);\r\n    }\r\n    int slash = parentDirectory.lastIndexOf('/');\r\n    if (slash >= 0) {\r\n        String parent = name.substring(0, slash);\r\n        String dirParent = MessageFormat.format(rb.getString(LogFacade.DIR_PARENT_INFO), parent);\r\n        sb.append(\" - <a href=\\\"\");\r\n        sb.append(rewrittenContextPath);\r\n        if (parent.equals(\"\"))\r\n            parent = \"/\";\r\n        sb.append(rewriteUrl(parent));\r\n        if (!parent.endsWith(\"/\"))\r\n            sb.append(\"/\");\r\n        sb.append(\"\\\">\");\r\n        sb.append(\"<b>\");\r\n        sb.append(dirParent);\r\n        sb.append(\"<\/b>\");\r\n        sb.append(\"<\/a>\");\r\n    }\r\n    sb.append(\"<\/h1>\");\r\n    sb.append(\"<HR size=\\\"1\\\" noshade=\\\"noshade\\\">\");\r\n    sb.append(\"<table width=\\\"100%\\\" cellspacing=\\\"0\\\"\" + \" cellpadding=\\\"5\\\" align=\\\"center\\\">\\r\\n\");\r\n    sb.append(\"<tr>\\r\\n\");\r\n    sb.append(\"<td align=\\\"left\\\"><font size=\\\"+1\\\"><strong>\");\r\n    sb.append(rb.getString(LogFacade.DIR_FILENAME_INFO));\r\n    sb.append(\"<\/strong><\/font><\/td>\\r\\n\");\r\n    sb.append(\"<td align=\\\"center\\\"><font size=\\\"+1\\\"><strong>\");\r\n    sb.append(rb.getString(LogFacade.DIR_SIZE_INFO));\r\n    sb.append(\"<\/strong><\/font><\/td>\\r\\n\");\r\n    sb.append(\"<td align=\\\"right\\\"><font size=\\\"+1\\\"><strong>\");\r\n    sb.append(rb.getString(LogFacade.DIR_LAST_MODIFIED_INFO));\r\n    sb.append(\"<\/strong><\/font><\/td>\\r\\n\");\r\n    sb.append(\"<\/tr>\");\r\n    try {\r\n        Enumeration<NameClassPair> enumeration = proxyDirContext.list(cacheEntry.name);\r\n        if (sortedBy.equals(SortedBy.LAST_MODIFIED)) {\r\n            ArrayList<NameClassPair> list = Collections.list(enumeration);\r\n            Comparator<NameClassPair> c = new LastModifiedComparator(proxyDirContext, cacheEntry.name);\r\n            Collections.sort(list, c);\r\n            enumeration = Collections.enumeration(list);\r\n        } else if (sortedBy.equals(SortedBy.SIZE)) {\r\n            ArrayList<NameClassPair> list = Collections.list(enumeration);\r\n            Comparator<NameClassPair> c = new SizeComparator(proxyDirContext, cacheEntry.name);\r\n            Collections.sort(list, c);\r\n            enumeration = Collections.enumeration(list);\r\n        }\r\n        boolean shade = false;\r\n        while (enumeration.hasMoreElements()) {\r\n            NameClassPair ncPair = enumeration.nextElement();\r\n            String resourceName = ncPair.getName();\r\n            String trimmed = resourceName;\r\n            if (trimmed.equalsIgnoreCase(\"WEB-INF\") || trimmed.equalsIgnoreCase(\"META-INF\"))\r\n                continue;\r\n            CacheEntry childCacheEntry = proxyDirContext.lookupCache(cacheEntry.name + resourceName);\r\n            if (!childCacheEntry.exists) {\r\n                continue;\r\n            }\r\n            sb.append(\"<tr\");\r\n            if (shade)\r\n                sb.append(\" bgcolor=\\\"#eeeeee\\\"\");\r\n            sb.append(\">\\r\\n\");\r\n            shade = !shade;\r\n            sb.append(\"<td align=\\\"left\\\">&nbsp;&nbsp;\\r\\n\");\r\n            sb.append(\"<a href=\\\"\");\r\n            sb.append(rewrittenContextPath);\r\n            resourceName = rewriteUrl(name + resourceName);\r\n            sb.append(resourceName);\r\n            if (childCacheEntry.context != null)\r\n                sb.append(\"/\");\r\n            sb.append(\"\\\"><tt>\");\r\n            sb.append(HtmlEntityEncoder.encodeXSS(trimmed));\r\n            if (childCacheEntry.context != null)\r\n                sb.append(\"/\");\r\n            sb.append(\"<\/tt><\/a><\/td>\\r\\n\");\r\n            sb.append(\"<td align=\\\"right\\\"><tt>\");\r\n            if (childCacheEntry.context != null)\r\n                sb.append(\"&nbsp;\");\r\n            else\r\n                sb.append(renderSize(childCacheEntry.attributes.getContentLength()));\r\n            sb.append(\"<\/tt><\/td>\\r\\n\");\r\n            sb.append(\"<td align=\\\"right\\\"><tt>\");\r\n            sb.append(childCacheEntry.attributes.getLastModifiedHttp());\r\n            sb.append(\"<\/tt><\/td>\\r\\n\");\r\n            sb.append(\"<\/tr>\\r\\n\");\r\n        }\r\n    } catch (NamingException e) {\r\n        throw new ServletException(\"Error accessing resource\", e);\r\n    }\r\n    sb.append(\"<\/table>\\r\\n\");\r\n    sb.append(\"<HR size=\\\"1\\\" noshade=\\\"noshade\\\">\");\r\n    String readme = getReadme(cacheEntry.context);\r\n    if (readme != null) {\r\n        sb.append(readme);\r\n        sb.append(\"<HR size=\\\"1\\\" noshade=\\\"noshade\\\">\");\r\n    }\r\n    String serverInfo = ServerInfo.getPublicServerInfo();\r\n    if (serverInfo != null && !serverInfo.isEmpty()) {\r\n        sb.append(\"<h3>\").append(serverInfo).append(\"<\/h3>\");\r\n    }\r\n    sb.append(\"<\/body>\\r\\n\");\r\n    sb.append(\"<\/html>\\r\\n\");\r\n    writer.write(sb.toString());\r\n    writer.flush();\r\n    return (new ByteArrayInputStream(stream.toByteArray()));\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteAdminCommand.chooseRequestMethod",
	"Comment": "decide what request method to use in building the http request.",
	"Method": "String chooseRequestMethod(){\r\n    if (doUpload) {\r\n        return \"POST\";\r\n    } else {\r\n        return \"GET\";\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.NodeUtils.pingRemoteConnection",
	"Comment": "make sure we can make an ssh connection using an existing node.",
	"Method": "void pingRemoteConnection(Node node){\r\n    RemoteType type = RemoteType.valueOf(node.getType());\r\n    validateHostName(node.getNodeHost());\r\n    switch(type) {\r\n        case SSH:\r\n            pingSSHConnection(node);\r\n            break;\r\n        default:\r\n            throw new CommandValidationException(\"Internal Error: unknown type\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.UpdateNodeCommand.allowableChange",
	"Comment": "if the node is in use, is it ok to change currentvalue to newvalue?",
	"Method": "boolean allowableChange(String newvalue,String currentvalue){\r\n    if (newvalue == null) {\r\n        return true;\r\n    }\r\n    if (!StringUtils.ok(currentvalue)) {\r\n        return true;\r\n    }\r\n    if (newvalue.equals(currentvalue)) {\r\n        return true;\r\n    }\r\n    if (newvalue.contains(\"$\") || currentvalue.contains(\"$\")) {\r\n        Map<String, String> systemPropsMap = new HashMap<String, String>((Map) (System.getProperties()));\r\n        TokenResolver resolver = new TokenResolver(systemPropsMap);\r\n        newvalue = resolver.resolve(newvalue);\r\n        currentvalue = resolver.resolve(currentvalue);\r\n        return newvalue.equals(currentvalue);\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.SecurityConstraint.setWebResourceCollection",
	"Comment": "sets the web resource collection associated with thissecurity constrint",
	"Method": "void setWebResourceCollection(Set<WebResourceCollection> webResourceCollection){\r\n    this.webResourceCollection = webResourceCollection;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TransactionState.inDoubt",
	"Comment": "returns a flag indicating whether any transactions may be in doubt.",
	"Method": "boolean inDoubt(){\r\n    return inDoubt;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.OrderingDescriptor.topologicalSort",
	"Comment": "note that this processing will modify the graph.it is not intended for public.",
	"Method": "List<Node> topologicalSort(List<Node> graph,boolean hasRemaining){\r\n    List<Node> sortedNodes = new ArrayList<Node>();\r\n    if (graph.size() == 0) {\r\n        return sortedNodes;\r\n    }\r\n    Stack<Node> roots = new Stack<Node>();\r\n    Stack<Node> rootsBefore = new Stack<Node>();\r\n    Stack<Node> rootsAfter = new Stack<Node>();\r\n    for (Node node : graph) {\r\n        if (node.getInEdges().size() == 0) {\r\n            if (node.isBeforeOthers()) {\r\n                rootsBefore.add(node);\r\n            } else if (node.isAfterOthers() || node.isOthers()) {\r\n                rootsAfter.add(node);\r\n            } else {\r\n                roots.add(node);\r\n            }\r\n        }\r\n    }\r\n    if (roots.empty() && rootsBefore.empty() && rootsAfter.empty()) {\r\n        if (isCircleWithOthersAndNoRemaining(graph, hasRemaining, sortedNodes)) {\r\n            return sortedNodes;\r\n        } else {\r\n            throw new IllegalStateException(localStrings.getLocalString(\"web.deployment.exceptioninvalidwebfragmentordering\", \"The web fragment ordering is not valid and possibly has cycling conflicts.\"));\r\n        }\r\n    }\r\n    while (!(roots.empty() && rootsBefore.empty() && rootsAfter.empty())) {\r\n        Node node = null;\r\n        if (!rootsBefore.empty()) {\r\n            node = rootsBefore.pop();\r\n        } else if (!roots.empty()) {\r\n            node = roots.pop();\r\n        } else {\r\n            node = rootsAfter.pop();\r\n        }\r\n        sortedNodes.add(node);\r\n        Iterator<Edge> outEdgesIter = node.getOutEdges().iterator();\r\n        while (outEdgesIter.hasNext()) {\r\n            Edge outEdge = outEdgesIter.next();\r\n            Node outNode = outEdge.getToNode();\r\n            outEdgesIter.remove();\r\n            outNode.getInEdges().remove(outEdge);\r\n            if (outNode.getInEdges().size() == 0) {\r\n                if (node.isBeforeOthers()) {\r\n                    rootsBefore.add(outNode);\r\n                } else if (node.isAfterOthers() || node.isOthers()) {\r\n                    rootsAfter.add(outNode);\r\n                } else {\r\n                    roots.add(outNode);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    boolean hasEdges = false;\r\n    for (Node node : graph) {\r\n        if (node.getInEdges().size() > 0 || node.getOutEdges().size() > 0) {\r\n            hasEdges = true;\r\n            break;\r\n        }\r\n    }\r\n    if (hasEdges) {\r\n        throw new IllegalStateException(localStrings.getLocalString(\"web.deployment.exceptioninvalidwebfragmentordering\", \"The web fragment ordering is not valid and possibly has cycling conflicts.\"));\r\n    }\r\n    return sortedNodes;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.getKeyAlias",
	"Comment": "gets the alias name of the keypair and supporting certificate chainused by this connector to authenticate itself to ssl clients.",
	"Method": "String getKeyAlias(){\r\n    String ret = getProperty(\"keyAlias\");\r\n    if (ret == null) {\r\n        ServerSocketFactory factory = getFactory();\r\n        if (factory instanceof CoyoteServerSocketFactory) {\r\n            ret = ((CoyoteServerSocketFactory) factory).getKeyAlias();\r\n        }\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.CallMethodRule.setDigester",
	"Comment": "set the associated digester.if needed, this class loads the parameter classes from their names.",
	"Method": "void setDigester(Digester digester){\r\n    super.setDigester(digester);\r\n    if (this.paramClassNames != null) {\r\n        this.paramTypes = new Class[paramClassNames.length];\r\n        for (int i = 0; i < this.paramClassNames.length; i++) {\r\n            try {\r\n                this.paramTypes[i] = digester.getClassLoader().loadClass(this.paramClassNames[i]);\r\n            } catch (ClassNotFoundException e) {\r\n                digester.getLogger().log(Level.SEVERE, \"(CallMethodRule) Cannot load class \" + this.paramClassNames[i], e);\r\n                this.paramTypes[i] = null;\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.startup.Embedded.removeEngine",
	"Comment": "remove the specified engine from the set of defined engines, along withall of its related hosts and contexts.all associated connectors arealso removed.",
	"Method": "void removeEngine(Engine engine){\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \"Removing engine (\" + engine.getInfo() + \")\");\r\n    int j = -1;\r\n    for (int i = 0; i < engines.length; i++) {\r\n        if (engine == engines[i]) {\r\n            j = i;\r\n            break;\r\n        }\r\n    }\r\n    if (j < 0)\r\n        return;\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \" Removing related Containers\");\r\n    while (true) {\r\n        int n = -1;\r\n        for (int i = 0; i < connectors.length; i++) {\r\n            if (connectors[i].getContainer() == (Container) engine) {\r\n                n = i;\r\n                break;\r\n            }\r\n        }\r\n        if (n < 0)\r\n            break;\r\n        try {\r\n            removeConnector(connectors[n]);\r\n        } catch (Exception ex) {\r\n            log.log(Level.SEVERE, LogFacade.CONNECTOR_STOP_EXCEPTION, ex);\r\n        }\r\n    }\r\n    if (engine instanceof Lifecycle) {\r\n        if (log.isLoggable(Level.FINE))\r\n            log.log(Level.FINE, \" Stopping this Engine\");\r\n        try {\r\n            ((Lifecycle) engine).stop();\r\n        } catch (LifecycleException e) {\r\n            log.log(Level.SEVERE, LogFacade.ENGINE_STOP_EXCEPTION, e);\r\n        }\r\n    }\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \" Removing this Engine\");\r\n    int k = 0;\r\n    Engine[] results = new Engine[engines.length - 1];\r\n    for (int i = 0; i < engines.length; i++) {\r\n        if (i != j)\r\n            results[k++] = engines[i];\r\n    }\r\n    engines = results;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.ejbfindbyprimarykey.EjbFindByPrimaryKeyStatic.check",
	"Comment": "define ejbfindbyprimarykey method static test.every entity enterprise bean class must define the ejbfindbyprimarykey method. the method must not be declared as static.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (descriptor instanceof EjbEntityDescriptor) {\r\n        String persistentType = ((EjbEntityDescriptor) descriptor).getPersistenceType();\r\n        if (EjbEntityDescriptor.BEAN_PERSISTENCE.equals(persistentType)) {\r\n            boolean ejbFindByPrimaryKeyMethodFound = false;\r\n            boolean isStatic = false;\r\n            boolean oneFailed = false;\r\n            int findMethodModifiers = 0;\r\n            try {\r\n                VerifierTestContext context = getVerifierContext();\r\n                ClassLoader jcl = context.getClassLoader();\r\n                Class EJBClass = Class.forName(descriptor.getEjbClassName(), false, getVerifierContext().getClassLoader());\r\n                do {\r\n                    Method[] ejbFinderMethods = EJBClass.getDeclaredMethods();\r\n                    for (int j = 0; j < ejbFinderMethods.length; ++j) {\r\n                        if (ejbFinderMethods[j].getName().equals(\"ejbFindByPrimaryKey\")) {\r\n                            ejbFindByPrimaryKeyMethodFound = true;\r\n                            findMethodModifiers = ejbFinderMethods[j].getModifiers();\r\n                            if (Modifier.isStatic(findMethodModifiers)) {\r\n                                isStatic = true;\r\n                            }\r\n                            if (ejbFindByPrimaryKeyMethodFound && !isStatic) {\r\n                                result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                                result.addGoodDetails(smh.getLocalString(getClass().getName() + \".debug1\", \"For EJB Class [ {0} ] Finder Method [ {1} ]\", new Object[] { EJBClass.getName(), ejbFinderMethods[j].getName() }));\r\n                                result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"A non-static [ {0} ] method was found.\", new Object[] { ejbFinderMethods[j].getName() }));\r\n                            } else if (ejbFindByPrimaryKeyMethodFound && isStatic) {\r\n                                oneFailed = true;\r\n                                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                                result.addErrorDetails(smh.getLocalString(getClass().getName() + \".debug1\", \"For EJB Class [ {0} ] Finder Method [ {1} ]\", new Object[] { EJBClass.getName(), ejbFinderMethods[j].getName() }));\r\n                                result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: A static [ {0} ] method was found, but [ {1} ] cannot be declared as static.\", new Object[] { ejbFinderMethods[j].getName(), ejbFinderMethods[j].getName() }));\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                } while (((EJBClass = EJBClass.getSuperclass()) != null) && (!ejbFindByPrimaryKeyMethodFound));\r\n                if (!ejbFindByPrimaryKeyMethodFound) {\r\n                    oneFailed = true;\r\n                    result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                    result.addErrorDetails(smh.getLocalString(getClass().getName() + \".debug3\", \"For EJB Class [ {0} ]\", new Object[] { descriptor.getEjbClassName() }));\r\n                    result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed1\", \"Error: No ejbFindByPrimaryKey method was found in bean class.\"));\r\n                }\r\n            } catch (ClassNotFoundException e) {\r\n                Verifier.debug(e);\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.failed(smh.getLocalString(getClass().getName() + \".failedException\", \"Error: EJB Class [ {0} ] does not exist or is not loadable.\", new Object[] { descriptor.getEjbClassName() }));\r\n                oneFailed = true;\r\n            }\r\n            if (oneFailed) {\r\n                result.setStatus(result.FAILED);\r\n            } else {\r\n                result.setStatus(result.PASSED);\r\n            }\r\n        } else {\r\n            result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable2\", \"Expected persistence type [ {0} ], but bean [ {1} ] has persistence type [ {2} ]\", new Object[] { EjbEntityDescriptor.BEAN_PERSISTENCE, descriptor.getName(), persistentType }));\r\n        }\r\n        return result;\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"[ {0} ] expected {1} bean, but called with {2} bean.\", new Object[] { getClass(), \"Entity\", \"Session\" }));\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.cci.ResourceAdapterMetaDataExistence.check",
	"Comment": "test if a javax.resource.cci.connectionmetadata implementation has been provided in the rar file",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (isCCIImplemented(descriptor, result)) {\r\n        findImplementorOf(descriptor, \"javax.resource.cci.ResourceAdapterMetaData\", result);\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.InteractionExistence.notapp\", \"NotApplicable : The CCI interfaces do not seem to be implemented by this resource adapter\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ReplicationStore.valveSave",
	"Comment": "save the specified session into this store.any previously savedinformation for the associated session identifier is replaced.",
	"Method": "void valveSave(Session session){\r\n    if (!(session instanceof HASession)) {\r\n        return;\r\n    }\r\n    HASession haSess = (HASession) session;\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.fine(\"ReplicationStore>>valveSave id=\" + haSess.getIdInternal() + \" isPersistent=\" + haSess.isPersistent() + \" isDirty=\" + haSess.isDirty());\r\n    }\r\n    if (haSess.isPersistent() && !haSess.isDirty()) {\r\n        this.updateLastAccessTime(session);\r\n    } else {\r\n        this.doValveSave(session);\r\n        haSess.setPersistent(true);\r\n    }\r\n    haSess.setDirty(false);\r\n    this.doValveSave(session);\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.FormAuthenticator.forwardToErrorPage",
	"Comment": "called to forward to the error page. may redirect current request to https",
	"Method": "void forwardToErrorPage(HttpRequest request,HttpResponse response,LoginConfig config){\r\n    ServletContext sc = context.getServletContext();\r\n    try {\r\n        String errorPage = config.getErrorPage();\r\n        if (!request.getRequest().isSecure()) {\r\n            Realm realm = context.getRealm();\r\n            if (realm != null) {\r\n                SecurityConstraint[] secConstraints = realm.findSecurityConstraints(errorPage, \"GET\", context);\r\n                if (secConstraints != null && !realm.hasUserDataPermission(request, response, secConstraints, errorPage, \"GET\")) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        RequestDispatcher disp = sc.getRequestDispatcher(errorPage);\r\n        disp.forward(request.getRequest(), response.getResponse());\r\n    } catch (Throwable t) {\r\n        log.log(Level.WARNING, LogFacade.UNEXPECTED_ERROR_FORWARDING_TO_LOGIN_PAGE, t);\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.resources.ResourceAttributes.getCanonicalPath",
	"Comment": "return the canonical path of the resource, to possibly be used for direct file serving. implementations which support this should overrideit to return the file path.",
	"Method": "String getCanonicalPath(){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setPublicId",
	"Comment": "set the public identifier of the deployment descriptor dtd that iscurrently being parsed.",
	"Method": "void setPublicId(String publicId){\r\n    if (log.isLoggable(Level.FINEST))\r\n        log.log(Level.FINEST, \"Setting deployment descriptor public ID to '\" + publicId + \"'\");\r\n    String oldPublicId = this.publicId;\r\n    this.publicId = publicId;\r\n    support.firePropertyChange(\"publicId\", oldPublicId, publicId);\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.VirtualServerConfig.getContextXmlDefault",
	"Comment": "gets the location of the default context.xml configuration file.",
	"Method": "String getContextXmlDefault(){\r\n    return contextXmlDefault;\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.InstalledLibrariesResolver.getExtDirFilesAsClasspath",
	"Comment": "adds all the jar files in all of the ext dirs into a single stringin classpath format.returns the empty string if there are nojar files in any ext dirs.",
	"Method": "String getExtDirFilesAsClasspath(){\r\n    StringBuffer classpath = new StringBuffer();\r\n    for (Iterator iter = extDirJars.iterator(); iter.hasNext(); ) {\r\n        String next = (String) iter.next();\r\n        if (classpath.length() > 0) {\r\n            classpath.append(File.pathSeparator);\r\n        }\r\n        classpath.append(next);\r\n    }\r\n    return classpath.toString();\r\n}"
}, {
	"Path": "org.glassfish.web.util.ExceptionUtils.handleThrowable",
	"Comment": "checks whether the supplied throwable is one that needs to berethrown and swallows all others.",
	"Method": "void handleThrowable(Throwable t){\r\n    if (t instanceof ThreadDeath) {\r\n        throw (ThreadDeath) t;\r\n    }\r\n    if (t instanceof VirtualMachineError) {\r\n        throw (VirtualMachineError) t;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebResourceCollectionImpl.getHttpMethodsAsArray",
	"Comment": "returns the httpmethods this collection has in an array of stringsthis is added to speed up processing while creating webresource permissions",
	"Method": "String[] getHttpMethodsAsArray(){\r\n    if (httpMethods == null) {\r\n        return (String[]) null;\r\n    }\r\n    return httpMethods.toArray(new String[httpMethods.size()]);\r\n}"
}, {
	"Path": "org.glassfish.api.admin.CommandModel.unknownOptionsAreOperands",
	"Comment": "should an unknown option be considered an operand by asadmin?",
	"Method": "boolean unknownOptionsAreOperands(){\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getMajorVersion",
	"Comment": "return the major version of the java servlet api that we implement.",
	"Method": "int getMajorVersion(){\r\n    return (Constants.MAJOR_VERSION);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.findWrapperListeners",
	"Comment": "return the list of containerlistener classes that will be added tonewly created wrappers automatically.",
	"Method": "List<String> findWrapperListeners(){\r\n    return wrapperListeners;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.CompositeUtil.executeDeleteCommandManaged",
	"Comment": "execute a delete admincommand with the specified parameters.",
	"Method": "ActionReporter executeDeleteCommandManaged(Subject subject,String command,ParameterMap parameters){\r\n    return executeCommand(subject, command, parameters, Status.BAD_REQUEST, true, true, true);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.UniqueAbstractSchemaName.check",
	"Comment": "the abstract schema name for every cmp bean within a jar file should be unique.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    boolean oneFailed = false;\r\n    String abstractSchema = null;\r\n    if (descriptor instanceof EjbEntityDescriptor) {\r\n        if (((EjbEntityDescriptor) descriptor).getPersistenceType().equals(EjbEntityDescriptor.CONTAINER_PERSISTENCE)) {\r\n            if (((EjbCMPEntityDescriptor) descriptor).getCMPVersion() == EjbCMPEntityDescriptor.CMP_2_x) {\r\n                abstractSchema = ((EjbCMPEntityDescriptor) descriptor).getAbstractSchemaName();\r\n                if (abstractSchema == null) {\r\n                    result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                    result.failed(smh.getLocalString(getClass().getName() + \".failed2\", \"No Abstract Schema Name specified for a CMP 2.0 Entity Bean {0} \", new Object[] { descriptor.getName() }));\r\n                    return result;\r\n                }\r\n            }\r\n        }\r\n        if (abstractSchema == null) {\r\n            result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"This test is only for CMP 2.0 beans. Abstract Schema Names should be unique within an ejb JAR file.\"));\r\n            return result;\r\n        }\r\n        EjbBundleDescriptorImpl bundle = descriptor.getEjbBundleDescriptor();\r\n        Iterator iterator = (bundle.getEjbs()).iterator();\r\n        Vector<String> schemaNames = new Vector<String>();\r\n        while (iterator.hasNext()) {\r\n            EjbDescriptor entity = (EjbDescriptor) iterator.next();\r\n            if (entity instanceof EjbEntityDescriptor) {\r\n                if (!entity.equals(descriptor)) {\r\n                    if (((EjbEntityDescriptor) entity).getPersistenceType().equals(EjbEntityDescriptor.CONTAINER_PERSISTENCE)) {\r\n                        schemaNames.addElement(((EjbCMPEntityDescriptor) entity).getAbstractSchemaName());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        for (int i = 0; i < schemaNames.size(); i++) {\r\n            if (abstractSchema.equals(schemaNames.elementAt(i))) {\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Abstract Schema Names should be unique within an ejb JAR file. Abstract Schema Name [ {0} ] is not unique.\", new Object[] { abstractSchema }));\r\n                oneFailed = true;\r\n            }\r\n        }\r\n        if (oneFailed == false) {\r\n            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"PASSED : Abstract Schema Names for all beans within the ejb JAR file are unique.\"));\r\n        } else\r\n            result.setStatus(Result.FAILED);\r\n    } else {\r\n        addNaDetails(result, compName);\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"This test is only for CMP 2.0 beans. Abstract Schema Names should be unique within an ejb JAR file.\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.unavailable",
	"Comment": "process an unavailableexception, marking this servlet as unavailablefor the specified amount of time.",
	"Method": "void unavailable(UnavailableException unavailable){\r\n    String msg = MessageFormat.format(rb.getString(LogFacade.MARK_SERVLET_UNAVAILABLE), neutralizeForLog(getName()));\r\n    getServletContext().log(msg);\r\n    if (unavailable == null)\r\n        setAvailable(Long.MAX_VALUE);\r\n    else if (unavailable.isPermanent())\r\n        setAvailable(Long.MAX_VALUE);\r\n    else {\r\n        int unavailableSeconds = unavailable.getUnavailableSeconds();\r\n        if (unavailableSeconds <= 0)\r\n            unavailableSeconds = 60;\r\n        setAvailable(System.currentTimeMillis() + (unavailableSeconds * 1000L));\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModuleContextConfig.authenticatorConfig",
	"Comment": "always sets up an authenticator regardless of any security constraints.",
	"Method": "void authenticatorConfig(){\r\n    LoginConfig loginConfig = context.getLoginConfig();\r\n    if (loginConfig == null) {\r\n        loginConfig = new LoginConfig(\"NONE\", null, null, null);\r\n        context.setLoginConfig(loginConfig);\r\n    }\r\n    if (context instanceof Authenticator) {\r\n        return;\r\n    }\r\n    if (context instanceof ContainerBase) {\r\n        Pipeline pipeline = ((ContainerBase) context).getPipeline();\r\n        if (pipeline != null) {\r\n            GlassFishValve basic = pipeline.getBasic();\r\n            if ((basic != null) && (basic instanceof Authenticator))\r\n                return;\r\n            GlassFishValve[] valves = pipeline.getValves();\r\n            for (int i = 0; i < valves.length; i++) {\r\n                if (valves[i] instanceof Authenticator)\r\n                    return;\r\n            }\r\n        }\r\n    } else {\r\n        return;\r\n    }\r\n    Realm rlm = context.getRealm();\r\n    if (rlm == null) {\r\n        String realmName = (context.getLoginConfig() != null) ? context.getLoginConfig().getRealmName() : null;\r\n        if (realmName != null && !realmName.isEmpty()) {\r\n            String msg = rb.getString(LogFacade.MISSING_REALM);\r\n            throw new LifecycleException(MessageFormat.format(msg, realmName));\r\n        }\r\n        return;\r\n    }\r\n    rlm.setRealmName(loginConfig.getRealmName(), loginConfig.getAuthMethod());\r\n    GlassFishValve authenticator = null;\r\n    if (customAuthenticators != null) {\r\n        authenticator = (GlassFishValve) customAuthenticators.get(loginConfig.getAuthMethod());\r\n    }\r\n    if (authenticator == null) {\r\n        String authenticatorName = null;\r\n        String authMethod = loginConfig.getAuthMethod();\r\n        if (authMethod == null) {\r\n            authMethod = \"NONE\";\r\n        }\r\n        authenticatorName = authenticators.getProperty(authMethod);\r\n        if (authenticatorName == null) {\r\n            String msg = rb.getString(LogFacade.AUTHENTICATOR_MISSING);\r\n            throw new LifecycleException(MessageFormat.format(msg, loginConfig.getAuthMethod()));\r\n        }\r\n        try {\r\n            Class authenticatorClass = Class.forName(authenticatorName);\r\n            authenticator = (GlassFishValve) authenticatorClass.newInstance();\r\n        } catch (Exception e) {\r\n            String msg = rb.getString(LogFacade.AUTHENTICATOR_INSTANTIATE_ERROR);\r\n            throw new LifecycleException(MessageFormat.format(msg, authenticatorName), e);\r\n        }\r\n    }\r\n    if (authenticator != null && context instanceof ContainerBase) {\r\n        Pipeline pipeline = ((ContainerBase) context).getPipeline();\r\n        if (pipeline != null) {\r\n            ((ContainerBase) context).addValve(authenticator);\r\n            if (logger.isLoggable(Level.FINEST)) {\r\n                logger.log(Level.FINEST, LogFacade.AUTHENTICATOR_CONFIGURED, loginConfig.getAuthMethod());\r\n            }\r\n        }\r\n    }\r\n    if (authenticator instanceof DigestAuthenticator) {\r\n        Config config = services.getService(Config.class, ServerEnvironment.DEFAULT_INSTANCE_NAME);\r\n        SecurityService securityService = config.getSecurityService();\r\n        String digestAlgorithm = null;\r\n        if (securityService != null) {\r\n            digestAlgorithm = securityService.getPropertyValue(DEFAULT_DIGEST_ALGORITHM);\r\n        }\r\n        if (digestAlgorithm != null) {\r\n            ((DigestAuthenticator) authenticator).setAlgorithm(digestAlgorithm);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.PartItem.getHeaderNames",
	"Comment": "returns a collection of all the header names this part contains.",
	"Method": "Collection<String> getHeaderNames(){\r\n    return headers.getHeaderNames();\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Response.finishResponse",
	"Comment": "perform whatever actions are required to flush and close the outputstream or writer, in a single operation.",
	"Method": "void finishResponse(){\r\n    try {\r\n        outputBuffer.close();\r\n    } catch (IOException e) {\r\n        ;\r\n    } catch (Throwable t) {\r\n        log(rb.getString(LogFacade.ERROR_DURING_FINISH_RESPONSE), t);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.resources.custom.SystemPropertiesCliResource.deleteRemovedProperties",
	"Comment": "returns null if successful or the response which contains the error msg.",
	"Method": "Response deleteRemovedProperties(Map<String, String> newProps){\r\n    List<String> existingList = new ArrayList();\r\n    Dom parent = getEntity();\r\n    for (Dom existingProp : parent.nodeElements(TAG_SYSTEM_PROPERTY)) {\r\n        existingList.add(existingProp.attribute(\"name\"));\r\n    }\r\n    if (existingList.isEmpty()) {\r\n        return null;\r\n    }\r\n    for (String onePropName : existingList) {\r\n        if (!newProps.containsKey(onePropName)) {\r\n            Response resp = deleteProperty(null, onePropName);\r\n            if (resp.getStatus() != HttpURLConnection.HTTP_OK) {\r\n                return resp;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.admin.mbeanserver.RMIConnectorStarter._startRegistry",
	"Comment": "delegate method to start the registry based on security is enabled or not.",
	"Method": "Registry _startRegistry(int port){\r\n    System.setProperty(\"java.rmi.server.randomIDs\", \"true\");\r\n    try {\r\n        if (isSecurityEnabled()) {\r\n            return LocateRegistry.createRegistry(port, sslCsf, sslServerSocketFactory);\r\n        } else {\r\n            return LocateRegistry.createRegistry(port, null, mServerSocketFactory);\r\n        }\r\n    } catch (final Exception e) {\r\n        throw new RuntimeException(\"Port \" + port + \" is not available for the internal rmi registry. \" + \"This means that a call was made with the same port, without closing earlier \" + \"registry instance. This has to do with the system jmx connector configuration \" + \"in admin-service element of the configuration associated with this instance\");\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getEffectiveSessionTrackingModes",
	"Comment": "gets the session tracking modes that are in effect for thisservletcontext.",
	"Method": "Set<SessionTrackingMode> getEffectiveSessionTrackingModes(){\r\n    if (isRestricted) {\r\n        throw new UnsupportedOperationException(rb.getString(LogFacade.UNSUPPORTED_OPERATION_EXCEPTION));\r\n    }\r\n    return context.getEffectiveSessionTrackingModes();\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.getContainer",
	"Comment": "return the container used for processing requests received by thisconnector.",
	"Method": "Container getContainer(){\r\n    return container;\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.Descriptor.setBoundsChecking",
	"Comment": "sets a global flag to enable or disable boudsn checkingof deployment information",
	"Method": "void setBoundsChecking(boolean b){\r\n    boundsChecking = b;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.commands.DeleteSsl.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    ActionReport report = context.getActionReport();\r\n    Target targetUtil = habitat.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    if (!type.equals(\"iiop-service\")) {\r\n        if (listenerId == null) {\r\n            report.setMessage(localStrings.getLocalString(\"create.ssl.listenerid.missing\", \"Listener id needs to be specified\"));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    try {\r\n        SslConfigHandler sslConfigHandler = habitat.getService(SslConfigHandler.class, type);\r\n        if (sslConfigHandler != null) {\r\n            sslConfigHandler.delete(this, report);\r\n        } else if (\"jmx-connector\".equals(type)) {\r\n            JmxConnector jmxConnector = null;\r\n            for (JmxConnector listener : config.getAdminService().getJmxConnector()) {\r\n                if (listener.getName().equals(listenerId)) {\r\n                    jmxConnector = listener;\r\n                }\r\n            }\r\n            if (jmxConnector == null) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.ssl.jmx.connector.notfound\", \"Iiop Listener named {0} not found\", listenerId));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n            if (jmxConnector.getSsl() == null) {\r\n                report.setMessage(localStrings.getLocalString(\"delete.ssl.element.doesnotexist\", \"Ssl element does \" + \"not exist for Listener named {0}\", listenerId));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n            ConfigSupport.apply(new SingleConfigCode<JmxConnector>() {\r\n                public Object run(JmxConnector param) throws PropertyVetoException {\r\n                    param.setSsl(null);\r\n                    return null;\r\n                }\r\n            }, jmxConnector);\r\n            report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n        }\r\n    } catch (TransactionFailure e) {\r\n        reportError(report, e);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.commands.DeleteSsl.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    param.setSsl(null);\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.api.jdbc.SQLTraceRecord.getParams",
	"Comment": "gets the parameters of the method that executed the sql query. includes information like sql query, arguments and so on.",
	"Method": "Object[] getParams(){\r\n    return params;\r\n}"
}, {
	"Path": "org.glassfish.loader.util.ASClassLoaderUtil.getAppLibDirLibraries",
	"Comment": "add all the libraries packaged in the application library directory",
	"Method": "URL[] getAppLibDirLibraries(File appRoot,String appLibDir,String compatibilityProp){\r\n    return convertURLListToArray(getAppLibDirLibrariesAsList(appRoot, appLibDir, compatibilityProp));\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.intf.InterfaceMethodTest.check",
	"Comment": "run the verifier test against the local or remote interface, get all methodsand delegate actual testing for individual methods to the runindividualmethodtest",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!(descriptor instanceof EjbSessionDescriptor) && !(descriptor instanceof EjbEntityDescriptor)) {\r\n        addNaDetails(result, compName);\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.homeintf.HomeMethodTest.notApplicable1\", \"Test apply only to session or entity beans.\"));\r\n        return result;\r\n    }\r\n    if (getInterfaceName(descriptor) == null || \"\".equals(getInterfaceName(descriptor))) {\r\n        addNaDetails(result, compName);\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.intf.InterfaceTest.notApplicable\", \"Not Applicable because, EJB [ {0} ] does not have {1} Interface.\", new Object[] { descriptor.getEjbClassName(), getInterfaceType() }));\r\n        return result;\r\n    }\r\n    try {\r\n        Arrays.sort(EJBObjectMethods);\r\n        ClassLoader jcl = getVerifierContext().getClassLoader();\r\n        Class interfaceClass = Class.forName(getClassName(descriptor), false, jcl);\r\n        if (studyInterface(descriptor, interfaceClass, result)) {\r\n            result.setStatus(Result.PASSED);\r\n        } else {\r\n            result.setStatus(Result.FAILED);\r\n        }\r\n    } catch (ClassNotFoundException e) {\r\n        Verifier.debug(e);\r\n        addErrorDetails(result, compName);\r\n        result.failed(smh.getLocalString(getClass().getName() + \".failedException\", \"Error: \" + getInterfaceType() + \"interface [ {0} ] does not \" + \"exist or is not loadable within bean [ {1} ]\", new Object[] { getClassName(descriptor), descriptor.getName() }));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.ByteArrayOutputStream.toString",
	"Comment": "gets the curent contents of this byte stream as a stringusing the specified encoding.",
	"Method": "String toString(String toString,String enc){\r\n    return new String(toByteArray(), RequestUtil.lookupCharset(enc));\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.MultipartStream.setBoundary",
	"Comment": "changes the boundary token used for partitioning the stream.this method allows single pass processing of nested multipartstreams.the boundary token of the nested stream is requiredto be of the same length as the boundary token in parent stream.restoring the parent stream boundary token after processing of anested stream is left to the application.",
	"Method": "void setBoundary(byte[] boundary){\r\n    if (boundary.length != boundaryLength - BOUNDARY_PREFIX.length) {\r\n        throw new IllegalBoundaryException(\"The length of a boundary token can not be changed\");\r\n    }\r\n    System.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length, boundary.length);\r\n}"
}, {
	"Path": "org.glassfish.config.support.GenericListCommand.isOutputOptsValid",
	"Comment": "validate that all specified output options are valid column names",
	"Method": "boolean isOutputOptsValid(List<ColumnInfo> cols,String[] outputOpts){\r\n    if (outputOpts == null) {\r\n        return true;\r\n    }\r\n    for (int i = 0; i < outputOpts.length; i++) {\r\n        boolean found = false;\r\n        for (ColumnInfo ci : cols) {\r\n            if (!ci.isExcluded() && ci.heading.equalsIgnoreCase(outputOpts[i])) {\r\n                found = true;\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.appserv.util.cache.BaseCache.notifyRefresh",
	"Comment": "notify threads waiting for a refresh on the object associated with the key",
	"Method": "void notifyRefresh(int index){\r\n    synchronized (bucketLocks[index]) {\r\n        refreshFlags[index] = false;\r\n        bucketLocks[index].notifyAll();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.ArgumentTokenizer.scanToken",
	"Comment": "return the next token starting at the current position,assuming whitespace has already been skipped.",
	"Method": "String scanToken(){\r\n    while (currentPosition < maxPosition) {\r\n        char c = str.charAt(currentPosition++);\r\n        if (c == '\"' || c == '\\'') {\r\n            char quote = c;\r\n            while (currentPosition < maxPosition) {\r\n                c = str.charAt(currentPosition++);\r\n                if (c == '\\\\' && quote == '\"') {\r\n                    if (currentPosition >= maxPosition)\r\n                        throw new ArgumentTokenizer.ArgumentException(strings.get(\"token.escapeAtEOL\"));\r\n                    c = str.charAt(currentPosition++);\r\n                    if (!(c == '\\\\' || c == '\"' || c == '\\''))\r\n                        token.append('\\\\');\r\n                } else if (c == quote) {\r\n                    break;\r\n                }\r\n                token.append(c);\r\n            }\r\n            if (c != quote)\r\n                throw new ArgumentTokenizer.ArgumentException(strings.get(\"token.unbalancedQuotes\"));\r\n        } else if (c == '\\\\') {\r\n            if (currentPosition >= maxPosition)\r\n                throw new ArgumentTokenizer.ArgumentException(strings.get(\"token.escapeAtEOL\"));\r\n            c = str.charAt(currentPosition++);\r\n            token.append(c);\r\n        } else if (Character.isWhitespace(c)) {\r\n            break;\r\n        } else {\r\n            token.append(c);\r\n        }\r\n    }\r\n    String s = token.toString();\r\n    token.setLength(0);\r\n    return s;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.AdminUtil.getRecoveryAbortedTransactionCount",
	"Comment": "return the number of transactions that were rolled back as part of therecovery process.",
	"Method": "long getRecoveryAbortedTransactionCount(){\r\n    return iRecAborts;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.Log.checkFileExists",
	"Comment": "determines whether a log file exists for the given server.this method may be used without initialising the log object to determinewhether recovery should be performed, without initialising the log or the ots.",
	"Method": "boolean checkFileExists(String serverName){\r\n    boolean exists = false;\r\n    if (serverName != null) {\r\n        String logPath = LogControl.getLogPath();\r\n        exists = LogControl.checkFileExists(serverName, logPath);\r\n    }\r\n    return exists;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.setNote",
	"Comment": "bind an object to a specified name in the internal notes associatedwith this request, replacing any existing binding for this name.",
	"Method": "void setNote(String name,Object value){\r\n    notes.put(name, value);\r\n}"
}, {
	"Path": "org.apache.catalina.valves.RequestDumperValve.invoke",
	"Comment": "log the interesting request parameters, invoke the next valve in thesequence, and log the interesting response parameters.",
	"Method": "int invoke(Request request,Response response){\r\n    if (!(request instanceof HttpRequest) || !(response instanceof HttpResponse)) {\r\n        return INVOKE_NEXT;\r\n    }\r\n    HttpRequest hrequest = (HttpRequest) request;\r\n    HttpServletRequest hreq = (HttpServletRequest) hrequest.getRequest();\r\n    log(\"REQUEST URI       =\" + hreq.getRequestURI());\r\n    log(\"          authType=\" + hreq.getAuthType());\r\n    log(\" characterEncoding=\" + hreq.getCharacterEncoding());\r\n    log(\"     contentLength=\" + hreq.getContentLength());\r\n    log(\"       contentType=\" + hreq.getContentType());\r\n    log(\"       contextPath=\" + hreq.getContextPath());\r\n    Cookie[] cookies = hreq.getCookies();\r\n    if (cookies != null) {\r\n        for (int i = 0; i < cookies.length; i++) log(\"            cookie=\" + cookies[i].getName() + \"=\" + cookies[i].getValue());\r\n    }\r\n    Enumeration<String> hnames = hreq.getHeaderNames();\r\n    while (hnames.hasMoreElements()) {\r\n        String hname = hnames.nextElement();\r\n        Enumeration<String> hvalues = hreq.getHeaders(hname);\r\n        while (hvalues.hasMoreElements()) {\r\n            String hvalue = hvalues.nextElement();\r\n            log(\"            header=\" + hname + \"=\" + hvalue);\r\n        }\r\n    }\r\n    log(\"            locale=\" + hreq.getLocale());\r\n    log(\"            method=\" + hreq.getMethod());\r\n    Enumeration<String> pnames = hreq.getParameterNames();\r\n    while (pnames.hasMoreElements()) {\r\n        String pname = pnames.nextElement();\r\n        String[] pvalues = hreq.getParameterValues(pname);\r\n        StringBuilder result = new StringBuilder(pname);\r\n        result.append('=');\r\n        for (int i = 0; i < pvalues.length; i++) {\r\n            if (i > 0)\r\n                result.append(\", \");\r\n            result.append(pvalues[i]);\r\n        }\r\n        log(\"         parameter=\" + result.toString());\r\n    }\r\n    log(\"          pathInfo=\" + hreq.getPathInfo());\r\n    log(\"          protocol=\" + hreq.getProtocol());\r\n    log(\"       queryString=\" + hreq.getQueryString());\r\n    log(\"        remoteAddr=\" + hreq.getRemoteAddr());\r\n    log(\"        remoteHost=\" + hreq.getRemoteHost());\r\n    log(\"        remoteUser=\" + hreq.getRemoteUser());\r\n    log(\"requestedSessionId=\" + hreq.getRequestedSessionId());\r\n    log(\"            scheme=\" + hreq.getScheme());\r\n    log(\"        serverName=\" + hreq.getServerName());\r\n    log(\"        serverPort=\" + hreq.getServerPort());\r\n    log(\"       servletPath=\" + hreq.getServletPath());\r\n    log(\"          isSecure=\" + hreq.isSecure());\r\n    log(\"---------------------------------------------------------------\");\r\n    return INVOKE_NEXT;\r\n}"
}, {
	"Path": "org.glassfish.web.embed.impl.WebContainerImpl.removeWebListener",
	"Comment": "stops the given weblistener and removes it from thiswebcontainer.",
	"Method": "void removeWebListener(WebListener webListener){\r\n    if (listeners.contains(webListener)) {\r\n        listeners.remove(webListener);\r\n    } else {\r\n        throw new GlassFishException(new ConfigException(\"Connector with name '\" + webListener.getId() + \"' does not exsits\"));\r\n    }\r\n    removeListener(webListener.getId());\r\n    if (log.isLoggable(Level.INFO)) {\r\n        log.info(\"Removed connector \" + webListener.getId());\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.CompositeUtil.executeDeleteCommand",
	"Comment": "execute a delete admincommand with the specified parameters.",
	"Method": "ActionReporter executeDeleteCommand(Subject subject,String command,ActionReporter executeDeleteCommand,Subject subject,String command,ParameterMap parameters){\r\n    return executeCommand(subject, command, parameters, Status.BAD_REQUEST, true, true, false);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.ServerSynchronizer.removeApp",
	"Comment": "send requests to the client to remove the specified app directoryand all the generated directories.",
	"Method": "void removeApp(Application app,File base,ModTime mt,Payload.Outbound payload){\r\n    if (logger.isLoggable(Level.FINE))\r\n        logger.fine(\"ServerSynchronizer: removing files for application \" + mt.name + \" because it is no longer deployed to this instance\");\r\n    try {\r\n        File dir = fileOf(base, mt.name);\r\n        removeDir(dir, payload);\r\n        dir = env.getApplicationCompileJspPath();\r\n        removeDir(fileOf(dir, mt.name), payload);\r\n        dir = env.getApplicationGeneratedXMLPath();\r\n        removeDir(fileOf(dir, mt.name), payload);\r\n        dir = env.getApplicationEJBStubPath();\r\n        removeDir(fileOf(dir, mt.name), payload);\r\n        dir = new File(env.getApplicationStubPath(), \"policy\");\r\n        removeDir(fileOf(dir, mt.name), payload);\r\n    } catch (IOException ioex) {\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.fine(\"ServerSynchronizer: IOException removing app \" + mt.name);\r\n            logger.fine(ioex.toString());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.endDocument",
	"Comment": "process notification of the end of the document being reached.",
	"Method": "void endDocument(){\r\n    if (saxLog.isLoggable(Level.FINE)) {\r\n        if (getCount() > 1) {\r\n            saxLog.log(Level.FINE, \"endDocument():  \" + getCount() + \" elements left\");\r\n        } else {\r\n            saxLog.log(Level.FINE, \"endDocument()\");\r\n        }\r\n    }\r\n    while (getCount() > 1) {\r\n        pop();\r\n    }\r\n    Iterator<Rule> rules = getRules().rules().iterator();\r\n    while (rules.hasNext()) {\r\n        Rule rule = rules.next();\r\n        try {\r\n            rule.finish();\r\n        } catch (Exception e) {\r\n            log.log(Level.SEVERE, LogFacade.FINISH_EVENT_EXCEPTION, e);\r\n            throw createSAXException(e);\r\n        } catch (Error e) {\r\n            log.log(Level.SEVERE, LogFacade.FINISH_EVENT_ERROR, e);\r\n            throw e;\r\n        }\r\n    }\r\n    clear();\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionManagerImpl.setTransactionTimeout",
	"Comment": "modify the timeout value that is associated with transactions startedby subsequent invocations of the begin method. if an application has not called this method, the transactionservice uses some default value for the transaction timeout.",
	"Method": "void setTransactionTimeout(int seconds){\r\n    try {\r\n        if (seconds < 0) {\r\n            String msg = LogFormatter.getLocalizedMessage(_logger, \"jts.invalid_timeout\");\r\n            throw new SystemException(msg);\r\n        }\r\n        current.set_timeout(seconds);\r\n    } catch (Exception ex) {\r\n        throw new SystemException(ex.toString());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.domain.DomainInfoManager.process",
	"Comment": "parses template information file and uses its information to create domain info file.",
	"Method": "void process(DomainTemplate domainTemplate,File domainDir){\r\n    FileOutputStream outputStream = null;\r\n    try {\r\n        TemplateInfo templateInfo = domainTemplate.getInfo();\r\n        File infoDir = new File(domainDir, DomainConstants.INFO_DIRECTORY);\r\n        if (!infoDir.exists() && !infoDir.mkdirs()) {\r\n            _logger.log(Level.INFO, SLogger.DIR_CREATION_ERROR, infoDir.getAbsolutePath());\r\n            return;\r\n        }\r\n        File domainInfoXML = new File(infoDir, DomainConstants.DOMAIN_INFO_XML);\r\n        outputStream = new FileOutputStream(domainInfoXML);\r\n        ObjectFactory objFactory = new ObjectFactory();\r\n        DomainInfo domainInfo = objFactory.createDomainInfo();\r\n        String javaHome = System.getenv(JAVA_HOME);\r\n        if (javaHome == null || javaHome.isEmpty()) {\r\n            javaHome = System.getProperty(\"java.home\");\r\n        }\r\n        domainInfo.setJavahome(javaHome);\r\n        domainInfo.setMwhome(System.getProperty(SystemPropertyConstants.PRODUCT_ROOT_PROPERTY));\r\n        TemplateRef templateRef = new TemplateRef();\r\n        templateRef.setName(templateInfo.getName());\r\n        templateRef.setVersion(templateInfo.getVersion());\r\n        templateRef.setLocation(domainTemplate.getLocation());\r\n        domainInfo.setDomainTemplateRef(templateRef);\r\n        JAXBContext context = JAXBContext.newInstance(ObjectFactory.class.getPackage().getName());\r\n        Marshaller marshaller = context.createMarshaller();\r\n        marshaller.setProperty(javax.xml.bind.Marshaller.JAXB_ENCODING, \"UTF-8\");\r\n        marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\r\n        marshaller.marshal(objFactory.createDomainInfo(domainInfo), outputStream);\r\n    } catch (Exception e) {\r\n        LogHelper.log(_logger, Level.WARNING, SLogger.DOMAIN_INFO_CREATION_ERROR, e, DomainConstants.DOMAIN_INFO_XML);\r\n    } finally {\r\n        if (outputStream != null) {\r\n            try {\r\n                outputStream.close();\r\n            } catch (Exception io) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.ManagerBase.createEmptySession",
	"Comment": "get a session from the recycled ones or create a new empty one.the persistentmanager manager does not need to create session databecause it reads it from the store.",
	"Method": "Session createEmptySession(){\r\n    return (getNewSession());\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.AdminUtil.getRecoveryCommitedTransactionCount",
	"Comment": "return the count of transactions that were commited as part of the recovery process.",
	"Method": "long getRecoveryCommitedTransactionCount(){\r\n    return iRecCommits;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.app.ApplicationTest.check",
	"Comment": "all connector tests should implement this method. it run an individualtest against the resource adapter deployment descriptor.",
	"Method": "Result check(Descriptor descriptor,Result check,Application descriptor){\r\n    return check((Application) descriptor);\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.NamingResources.removeResourceEnvRef",
	"Comment": "remove any resource environment reference with the specified name.",
	"Method": "void removeResourceEnvRef(String name){\r\n    entries.remove(name);\r\n    String type = null;\r\n    synchronized (resourceEnvRefs) {\r\n        type = resourceEnvRefs.remove(name);\r\n    }\r\n    if (type != null) {\r\n        support.firePropertyChange(\"resourceEnvRef\", name + \":\" + type, null);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationDispatcher.getCombinedPath",
	"Comment": "combines the servletpath and the pathinfo.if pathinfo is null, it is ignored. if servletpathis null, then null is returned.",
	"Method": "String getCombinedPath(){\r\n    if (servletPath == null) {\r\n        return null;\r\n    }\r\n    if (pathInfo == null) {\r\n        return servletPath;\r\n    }\r\n    return servletPath + pathInfo;\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.ClientArtifactsManager.get",
	"Comment": "retrieves the client artifacts store from the provided deployment context, creating one and storing it back into the dc if none is there yet.",
	"Method": "ClientArtifactsManager get(DeploymentContext dc){\r\n    synchronized (dc) {\r\n        ClientArtifactsManager result = dc.getTransientAppMetaData(CLIENT_ARTIFACTS_KEY, ClientArtifactsManager.class);\r\n        if (result == null) {\r\n            result = new ClientArtifactsManager();\r\n            dc.addTransientAppMetaData(CLIENT_ARTIFACTS_KEY, result);\r\n        }\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.hasConstraints",
	"Comment": "checks whether this web application has any security constraintsdefined.",
	"Method": "boolean hasConstraints(){\r\n    return !constraints.isEmpty();\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.UpdateNodeRemoteCommand.initFromConfig",
	"Comment": "initialize any parameters not provided by the user from theconfiguration.",
	"Method": "void initFromConfig(Node node){\r\n    if (nodehost == null) {\r\n        nodehost = node.getNodeHost();\r\n    }\r\n    if (installdir == null) {\r\n        installdir = node.getInstallDir();\r\n    }\r\n    if (nodedir == null) {\r\n        nodedir = node.getNodeDir();\r\n    }\r\n    if (windowsdomain == null) {\r\n        windowsdomain = node.getWindowsDomain();\r\n        if (windowsdomain == null) {\r\n            windowsdomain = node.getNodeHost();\r\n        }\r\n    }\r\n    SshConnector sshc = node.getSshConnector();\r\n    if (sshc == null) {\r\n        return;\r\n    }\r\n    if (remotePort == null) {\r\n        remotePort = sshc.getSshPort();\r\n    }\r\n    SshAuth ssha = sshc.getSshAuth();\r\n    if (ssha == null) {\r\n        return;\r\n    }\r\n    if (remoteUser == null) {\r\n        remoteUser = ssha.getUserName();\r\n    }\r\n    if (sshkeyfile == null) {\r\n        sshkeyfile = ssha.getKeyfile();\r\n    }\r\n    if (remotepassword == null) {\r\n        remotepassword = ssha.getPassword();\r\n    }\r\n    if (sshkeypassphrase == null) {\r\n        sshkeypassphrase = ssha.getPassword();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.ThresholdingOutputStream.getThreshold",
	"Comment": "returns the threshold, in bytes, at which an event will be triggered.",
	"Method": "int getThreshold(){\r\n    return threshold;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmrFields.runIndividualCmrTest",
	"Comment": "run an individual verifier test of a declated cmr field of the class",
	"Method": "boolean runIndividualCmrTest(Descriptor descriptor,RelationRoleDescriptor role,Class c,Result result){\r\n    boolean foundIt = false;\r\n    CMRFieldInfo info = null;\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    try {\r\n        info = role.getCMRFieldInfo();\r\n    } catch (Exception e) {\r\n        addErrorDetails(result, compName);\r\n        result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed1\", \"Error: No Local interfaces defined for EJB [ {0} ]\", new Object[] { descriptor.getName() }));\r\n        return false;\r\n    }\r\n    if (role.getPartner().getIsMany()) {\r\n        if (info.type.getName().equals(\"java.util.Collection\") || info.type.getName().equals(\"java.util.Set\")) {\r\n            foundIt = true;\r\n        }\r\n    } else {\r\n        EjbBundleDescriptorImpl bundle = ((EjbDescriptor) descriptor).getEjbBundleDescriptor();\r\n        if (((EjbDescriptor) descriptor).getLocalClassName() != null && !\"\".equals(((EjbDescriptor) descriptor).getLocalClassName())) {\r\n            if (isValidInterface(info.type, bundle.getEjbs())) {\r\n                foundIt = true;\r\n            }\r\n        } else {\r\n            if ((role.getRelationshipDescriptor()).getIsBidirectional()) {\r\n                result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Invalid type assigned for container managed relationship [ {0} ] in bean [ {1} ]\", new Object[] { info.name, descriptor.getName() }));\r\n                return false;\r\n            } else\r\n                foundIt = true;\r\n        }\r\n    }\r\n    if (foundIt) {\r\n        result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"Valid type assigned for container managed relationship [ {0} ] in bean [ {1} ]\", new Object[] { info.name, descriptor.getName() }));\r\n    } else {\r\n        result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Invalid type assigned for container managed relationship [ {0} ] in bean [ {1} ]\", new Object[] { info.name, descriptor.getName() }));\r\n    }\r\n    return foundIt;\r\n}"
}, {
	"Path": "org.glassfish.common.locator.SimpleInjectee.callIt",
	"Comment": "used by the test code to ensure we can call a proxied servicefrom a perlookup object",
	"Method": "void callIt(){\r\n    simpleService.callMe();\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.WebListenerBase.setConfig",
	"Comment": "reconfigures this weblistener with the givenconfiguration.",
	"Method": "void setConfig(WebListenerConfig config){\r\n    this.config = config;\r\n    setId(config.getId());\r\n    setPort(config.getPort());\r\n    setProtocol(config.getProtocol());\r\n    if (webContainer != null) {\r\n        webContainer.removeWebListener(this);\r\n        webContainer.addWebListener(this);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.remote.RemoteCommand.executeAndReturnOutput",
	"Comment": "execute the command and return the output as a stringinstead of writing it out.",
	"Method": "String executeAndReturnOutput(String args){\r\n    returnOutput = true;\r\n    execute(args);\r\n    returnOutput = false;\r\n    return output;\r\n}"
}, {
	"Path": "org.glassfish.api.admin.AdminCommandLock.queueTake",
	"Comment": "convenience method that takes an object from a blockingqueueas well as deals with interruptedexceptions.",
	"Method": "SuspendStatus queueTake(BlockingQueue<SuspendStatus> itmQ){\r\n    SuspendStatus status = SuspendStatus.SUCCESS;\r\n    boolean itemTake = false;\r\n    while (!itemTake) {\r\n        try {\r\n            status = itmQ.take();\r\n            itemTake = true;\r\n        } catch (java.lang.InterruptedException e) {\r\n            logger.log(Level.FINE, \"Interrupted getting status from a suspend queue\", e);\r\n        }\r\n    }\r\n    return status;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.getMaxPostSize",
	"Comment": "return the maximum size of a post which will be automaticallyparsed by the container.",
	"Method": "int getMaxPostSize(){\r\n    return maxPostSize;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.getSchema",
	"Comment": "return the xml schema uri used for validating an xml instance.",
	"Method": "String getSchema(){\r\n    return (this.schemaLocation);\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.jts.recovery.RecoveryLockFile.isRecovering",
	"Comment": "returns true if recovery file on the specified path contains information that the specified instance started recovery after specified timestampeither for itself or by another instance.",
	"Method": "boolean isRecovering(boolean isRecovering,String logDir,String instance,long timestamp,String prefix){\r\n    BufferedReader reader = null;\r\n    File recoveryLockFile = LogControl.recoveryLockFile(\".\", logDir);\r\n    if (!recoveryLockFile.exists()) {\r\n        _logger.log(Level.INFO, \"Lock File not found \" + recoveryLockFile);\r\n        return false;\r\n    }\r\n    boolean result = false;\r\n    try {\r\n        _logger.log(Level.INFO, \"Checking Lock File \" + recoveryLockFile);\r\n        RandomAccessFile raf = new RandomAccessFile(recoveryLockFile, \"rw\");\r\n        FileLock lock = raf.getChannel().lock();\r\n        try {\r\n            reader = new BufferedReader(new FileReader(recoveryLockFile));\r\n            String line = null;\r\n            while ((line = reader.readLine()) != null) {\r\n                _logger.log(Level.INFO, \"Testing line: \" + line);\r\n                String[] parts = line.split(SEPARATOR);\r\n                if (parts.length != 3) {\r\n                    throw new IllegalStateException();\r\n                } else if ((parts[0].equals(OWN) && parts[1].equals(instance)) || (instance == null && parts[0].equals(prefix))) {\r\n                    result = (Long.parseLong(parts[2]) > timestamp);\r\n                    break;\r\n                } else {\r\n                    continue;\r\n                }\r\n            }\r\n        } finally {\r\n            lock.release();\r\n        }\r\n    } catch (Exception ex) {\r\n        _logger.log(Level.WARNING, \"jts.exception_in_recovery_file_handling\", ex);\r\n    } finally {\r\n        if (reader != null) {\r\n            try {\r\n                reader.close();\r\n            } catch (Exception ex) {\r\n                _logger.log(Level.WARNING, \"jts.exception_in_recovery_file_handling\", ex);\r\n            }\r\n        }\r\n    }\r\n    _logger.log(Level.INFO, \"Recovering? \" + result);\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.util.JDK.initialize",
	"Comment": "silently fall back to ridiculous defaults if something is crazily wrong...",
	"Method": "void initialize(){\r\n    major = 1;\r\n    minor = subminor = update = 0;\r\n    try {\r\n        String jv = System.getProperty(\"java.version\");\r\n        String javaSpecificationVersion = System.getProperty(\"java.specification.version\");\r\n        String[] jsvSplit = javaSpecificationVersion.split(\"\\\\.\");\r\n        if (jsvSplit.length == 1) {\r\n            String[] jvSplit = jv.split(\"-\");\r\n            String jvReal = jvSplit[0];\r\n            String[] split = jvReal.split(\"[\\\\.]+\");\r\n            if (split.length > 0) {\r\n                if (split.length > 0) {\r\n                    major = Integer.parseInt(split[0]);\r\n                }\r\n                if (split.length > 1) {\r\n                    minor = Integer.parseInt(split[1]);\r\n                }\r\n                if (split.length > 2) {\r\n                    subminor = Integer.parseInt(split[2]);\r\n                }\r\n                if (split.length > 3) {\r\n                    update = Integer.parseInt(split[3]);\r\n                }\r\n            }\r\n        } else {\r\n            if (!StringUtils.ok(jv))\r\n                return;\r\n            String[] ss = jv.split(\"\\\\.\");\r\n            if (ss.length < 3 || !ss[0].equals(\"1\"))\r\n                return;\r\n            major = Integer.parseInt(ss[0]);\r\n            minor = Integer.parseInt(ss[1]);\r\n            ss = ss[2].split(\"_\");\r\n            if (ss.length < 1)\r\n                return;\r\n            subminor = Integer.parseInt(ss[0]);\r\n            if (ss.length > 1)\r\n                update = Integer.parseInt(ss[1]);\r\n        }\r\n    } catch (Exception e) {\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.CheckMgr.check",
	"Comment": "entry point for executing all tests pertinent to this architecture",
	"Method": "void check(Descriptor descriptor){\r\n    logger.log(Level.FINE, \"com.sun.enterprise.tools.verifier.CheckMgr.check\", new Object[] { getClass().getName(), descriptor.getName() });\r\n    setRuntimeDDPresent(getAbstractArchiveUri(descriptor));\r\n    loadTestInformationFromPropsFile();\r\n    logger.log(Level.FINE, \"com.sun.enterprise.tools.verifier.CheckMgr.RunAllTests\", new Object[] { descriptor.getName() });\r\n    String schemaVersion = getSchemaVersion(descriptor);\r\n    context.setSchemaVersion(schemaVersion);\r\n    context.setJavaEEVersion(verifierFrameworkContext.getJavaEEVersion());\r\n    context.setComponentNameConstructor(getComponentNameConstructor(descriptor));\r\n    FileArchive moduleArchive = new FileArchive();\r\n    moduleArchive.open(getAbstractArchiveUri(descriptor));\r\n    context.setModuleArchive(moduleArchive);\r\n    ResultManager resultManager = verifierFrameworkContext.getResultManager();\r\n    for (int i = 0; i < test.size(); i++) {\r\n        TestInformation ti = (TestInformation) test.elementAt(i);\r\n        String minVersion = ti.getMinimumVersion();\r\n        String maxVersion = ti.getMaximumVersion();\r\n        if (schemaVersion != null && minVersion != null && schemaVersion.compareTo(minVersion) < 0) {\r\n            logger.log(Level.FINE, \"com.sun.enterprise.tools.verifier.CheckMgr.version.NOT_APPLICABLE\", new Object[] { ti.getClassName() });\r\n            continue;\r\n        }\r\n        if (schemaVersion != null && maxVersion != null && schemaVersion.compareTo(maxVersion) > 0) {\r\n            logger.log(Level.FINE, \"com.sun.enterprise.tools.verifier.CheckMgr.version.NOT_APPLICABLE\", new Object[] { ti.getClassName() });\r\n            continue;\r\n        }\r\n        if (!isApplicable(ti, descriptor)) {\r\n            logger.log(Level.FINE, \"com.sun.enterprise.tools.verifier.CheckMgr.version.NOT_APPLICABLE\", new Object[] { ti.getClassName() });\r\n            continue;\r\n        }\r\n        try {\r\n            Class c = Class.forName(ti.getClassName());\r\n            VerifierCheck t = (VerifierCheck) c.newInstance();\r\n            t.setVerifierContext(context);\r\n            Result r = t.check(descriptor);\r\n            setModuleName(r);\r\n            resultManager.add(r);\r\n            fireTestFinishedEvent(r);\r\n        } catch (Throwable e) {\r\n            LogRecord logRecord = new LogRecord(Level.SEVERE, ti.getClassName());\r\n            logRecord.setThrown(e);\r\n            resultManager.log(logRecord);\r\n        }\r\n    }\r\n    fireAllTestsFinishedEvent();\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.ServerSynchronizer.fileOf",
	"Comment": "return a file representing the uri relative to the base directory.",
	"Method": "File fileOf(File base,String uri){\r\n    return new File(new URI(base.toURI().toString() + \"/\" + uri));\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.jmx.NotificationListenerBase.getNotificationFilter",
	"Comment": "get the filter originally specified when constructing this object.",
	"Method": "NotificationFilter getNotificationFilter(ObjectName objectName){\r\n    return mFilter;\r\n}"
}, {
	"Path": "org.glassfish.common.util.timer.TimerSchedule.processDayOfMonth",
	"Comment": "process a single value that represents a day of the month.input data can be a positive or a negative number, an order,or a case insensitive abbreviated name.",
	"Method": "void processDayOfMonth(String s){\r\n    String s0 = s.toLowerCase(Locale.ENGLISH);\r\n    if (positivePattern.matcher(s0).matches()) {\r\n        int i = parseInt(s0, DAY_OF_MONTH);\r\n        if (i < 1 || i > 31) {\r\n            throw new IllegalArgumentException(\"Invalid dayOfMonth value: \" + s0);\r\n        }\r\n        daysOfMonth.set(i);\r\n    } else if (negativePattern.matcher(s0).matches()) {\r\n        dayBeforeEndOfMonth = parseInt(s0.substring(1), DAY_OF_MONTH);\r\n    } else if (s0.equals(\"last\")) {\r\n        lastDayOfMonth = true;\r\n    } else {\r\n        daysOfWeekOrRangesOfDaysInMonth.add(s0);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.Streams.asString",
	"Comment": "this convenience method allows to read a streamcontent into a string, using the given character encoding.",
	"Method": "String asString(InputStream pStream,String asString,InputStream pStream,String pEncoding){\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    copy(pStream, baos, true);\r\n    return baos.toString(pEncoding);\r\n}"
}, {
	"Path": "com.sun.enterprise.glassfish.bootstrap.Util.getPropertyOrSystemProperty",
	"Comment": "gets a property value from the supplied properties object, if not defined there from system properties.",
	"Method": "String getPropertyOrSystemProperty(Properties properties,String propertyName,String defaultValue,String getPropertyOrSystemProperty,Properties properties,String propertyName){\r\n    return getPropertyOrSystemProperty(properties, propertyName, null);\r\n}"
}, {
	"Path": "org.apache.naming.resources.ProxyDirContext.createSubcontext",
	"Comment": "creates and binds a new context, along with associated attributes.",
	"Method": "Context createSubcontext(Name name,Context createSubcontext,String name,DirContext createSubcontext,Name name,Attributes attrs,DirContext createSubcontext,String name,Attributes attrs){\r\n    DirContext context = dirContext.createSubcontext(parseName(name), attrs);\r\n    cacheUnload(name);\r\n    return context;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.createServlet",
	"Comment": "instantiates the given servlet class and performs any requiredresource injection into the new servlet instance before returningit.",
	"Method": "T createServlet(Class<T> clazz){\r\n    if (isRestricted) {\r\n        throw new UnsupportedOperationException(rb.getString(LogFacade.UNSUPPORTED_OPERATION_EXCEPTION));\r\n    }\r\n    return context.createServlet(clazz);\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionManagerImpl.recover",
	"Comment": "the application server passes in the list of xaresource objectsto be recovered.",
	"Method": "void recover(Enumeration xaResourceList){\r\n    RecoveryManager.recoverXAResources(xaResourceList);\r\n}"
}, {
	"Path": "org.apache.catalina.util.ServerInfo.getServerInfo",
	"Comment": "return the server identification for this version of tomcat.",
	"Method": "String getServerInfo(){\r\n    return (serverInfo);\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.SingleSignOn.isVersioningSupported",
	"Comment": "return a boolean to indicate whether the sso id version issupported or not.",
	"Method": "boolean isVersioningSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "org.apache.catalina.realm.RealmBase.invokeAuthenticateDelegate",
	"Comment": "authenticates the user making this request, based on the specifiedlogin configuration.return true if any specifiedrequirements have been satisfied, or false if we havecreated a response challenge already.",
	"Method": "boolean invokeAuthenticateDelegate(HttpRequest request,HttpResponse response,Context context,Authenticator authenticator,boolean calledFromAuthenticate){\r\n    LoginConfig config = context.getLoginConfig();\r\n    return ((AuthenticatorBase) authenticator).authenticate(request, response, config);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.get_txcontext",
	"Comment": "creates a propagationcontext which contains the information which wouldnormally be passed implicitly via the costspropagation interfaces.",
	"Method": "PropagationContext get_txcontext(){\r\n    if (tranState == null || tranState.state != TransactionState.STATE_ACTIVE || rollbackOnly) {\r\n        Unavailable exc = new Unavailable();\r\n        throw exc;\r\n    }\r\n    long timeLeft = TimeoutManager.timeLeft(superInfo.localTID);\r\n    int timeout = 0;\r\n    if (timeLeft > 0) {\r\n        timeout = (int) timeLeft / 1000;\r\n    } else if (timeLeft == 0) {\r\n        TimeoutManager.timeoutCoordinator(superInfo.localTID, TimeoutManager.ACTIVE_TIMEOUT);\r\n        TRANSACTION_ROLLEDBACK exc = new TRANSACTION_ROLLEDBACK(0, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    TransIdentity current = new TransIdentity(this.object(), null, superInfo.globalTID.realTID);\r\n    if (emptyData == null) {\r\n        emptyData = Configuration.getORB().create_any();\r\n        emptyData.insert_boolean(false);\r\n    }\r\n    PropagationContext result = new PropagationContext(timeout, current, new TransIdentity[0], emptyData);\r\n    if (_logger.isLoggable(Level.FINEST)) {\r\n        _logger.logp(Level.FINEST, \"TopCoordinator\", \"get_txcontext()\", \"Obtained PropagationContext\" + \"GTID is: \" + superInfo.globalTID.toString());\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.startup.Embedded.removeContext",
	"Comment": "remove the specified context from the set of defined contexts for itsassociated host.if this is the last context for this host, the hostwill also be removed.",
	"Method": "void removeContext(Context context){\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \"Removing context[\" + context.getPath() + \"]\");\r\n    boolean found = false;\r\n    for (int i = 0; i < engines.length; i++) {\r\n        Container[] hosts = engines[i].findChildren();\r\n        for (int j = 0; j < hosts.length; j++) {\r\n            Container[] contexts = hosts[j].findChildren();\r\n            for (int k = 0; k < contexts.length; k++) {\r\n                if (context == (Context) contexts[k]) {\r\n                    found = true;\r\n                    break;\r\n                }\r\n            }\r\n            if (found)\r\n                break;\r\n        }\r\n        if (found)\r\n            break;\r\n    }\r\n    if (!found)\r\n        return;\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \" Removing this Context\");\r\n    context.getParent().removeChild(context);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getAuthorization",
	"Comment": "return the authorization credentials sent with this request.",
	"Method": "String getAuthorization(){\r\n    return coyoteRequest.getHeader(Constants.AUTHORIZATION_HEADER);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ContainerBase.threadStart",
	"Comment": "start the background thread that will periodically check forsession timeouts.",
	"Method": "void threadStart(){\r\n    if (thread != null)\r\n        return;\r\n    if (backgroundProcessorDelay <= 0)\r\n        return;\r\n    threadDone = false;\r\n    String threadName = \"ContainerBackgroundProcessor[\" + toString() + \"]\";\r\n    thread = new Thread(new ContainerBackgroundProcessor(), threadName);\r\n    thread.setDaemon(true);\r\n    thread.start();\r\n}"
}, {
	"Path": "org.apache.catalina.startup.Catalina.setCatalinaHome",
	"Comment": "set the catalina.home system property to the currentworking directory if it has not been set.",
	"Method": "void setCatalinaHome(){\r\n    initDirs();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentImpl.commit",
	"Comment": "completes the current transaction.this operation can only be called if there is a terminator object available.",
	"Method": "void commit(boolean reportHeuristics){\r\n    ControlImpl controlImpl = CurrentTransaction.getCurrent();\r\n    if (controlImpl == null) {\r\n        NoTransaction exc = new NoTransaction();\r\n        throw exc;\r\n    }\r\n    int active = 1;\r\n    if (!controlImpl.representsRemoteControl()) {\r\n        StatusHolder status = new StatusHolder();\r\n        controlImpl.getLocalTID(status);\r\n        if (status.value != Status.StatusActive) {\r\n            CurrentTransaction.endCurrent(true);\r\n            if (status.value == Status.StatusRolledBack) {\r\n                TRANSACTION_ROLLEDBACK exc = new TRANSACTION_ROLLEDBACK(0, CompletionStatus.COMPLETED_NO);\r\n                throw exc;\r\n            }\r\n            INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.Completed, CompletionStatus.COMPLETED_NO);\r\n            throw exc;\r\n        }\r\n        active = controlImpl.numAssociated();\r\n    }\r\n    if ((active != 1) || (controlImpl.isOutgoing())) {\r\n        INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.DeferredActivities, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    } else {\r\n        Terminator term = null;\r\n        if (Configuration.isLocalFactory()) {\r\n            try {\r\n                term = controlImpl.get_localTerminator();\r\n            } catch (Throwable exc) {\r\n                NO_PERMISSION ex2 = new NO_PERMISSION(0, CompletionStatus.COMPLETED_NO);\r\n                throw ex2;\r\n            }\r\n        } else {\r\n            try {\r\n                term = controlImpl.get_terminator();\r\n            } catch (Throwable exc) {\r\n                NO_PERMISSION ex2 = new NO_PERMISSION(0, CompletionStatus.COMPLETED_NO);\r\n                throw ex2;\r\n            }\r\n            try {\r\n                if (Configuration.getProxyChecker().isProxy(term))\r\n                    CurrentTransaction.endCurrent(true);\r\n            } catch (Throwable exc) {\r\n            }\r\n        }\r\n        try {\r\n            term.commit(reportHeuristics);\r\n        } catch (TRANSACTION_ROLLEDBACK e) {\r\n            CurrentTransaction.endCurrent(true);\r\n            throw e;\r\n        }\r\n        controlImpl.destroy();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.VirtualServerConfig.getHostNames",
	"Comment": "gets the host names assigned to any virtualserver configuredvia this virtualserverconfig.",
	"Method": "String getHostNames(){\r\n    return hostNames;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.AsyncContextImpl.reinitialize",
	"Comment": "reinitializes this asynccontext with the given request and response.",
	"Method": "void reinitialize(ServletRequest servletRequest,ServletResponse servletResponse,boolean isStartAsyncWithZeroArg){\r\n    init(servletRequest, servletResponse, isStartAsyncWithZeroArg);\r\n    isDispatchInProgress.set(false);\r\n    setOkToConfigure(true);\r\n    startAsyncCounter.incrementAndGet();\r\n    notifyAsyncListeners(AsyncEventType.START_ASYNC, null);\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.access",
	"Comment": "update the accessed time information for this session.this methodshould be called by the context when a request comes in for a particularsession, even if the application does not reference it.",
	"Method": "void access(){\r\n    this.lastAccessedTime = this.thisAccessedTime;\r\n    this.thisAccessedTime = System.currentTimeMillis();\r\n    evaluateIfValid();\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.Environment.getDebugVar",
	"Comment": "get the name of the environment variable used to set debugging on",
	"Method": "String getDebugVar(){\r\n    return SHORT_PREFIX + \"DEBUG\";\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getServletRegistrations",
	"Comment": "gets a map of the servletregistration objects corresponding to allcurrently registered servlets.",
	"Method": "Map<String, ? extends ServletRegistration> getServletRegistrations(){\r\n    if (isRestricted) {\r\n        throw new UnsupportedOperationException(rb.getString(LogFacade.UNSUPPORTED_OPERATION_EXCEPTION));\r\n    }\r\n    return context.getServletRegistrations();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.is_ancestor_transaction",
	"Comment": "determines whether the target subcoordinator is an ancestorof the given coordinator.this operation references no instance variables and so can beimplemented locally in a proxy class.",
	"Method": "boolean is_ancestor_transaction(Coordinator other){\r\n    boolean result = false;\r\n    if (tranState != null) {\r\n        result = other.is_descendant_transaction(this.object());\r\n    } else {\r\n        INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.Completed, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.CommonAccessLogFormatterImpl.appendRequestInfo",
	"Comment": "appends info about the given request to the given char buffer.",
	"Method": "void appendRequestInfo(CharBuffer cb,HttpServletRequest hreq){\r\n    cb.put(\"\\\"\");\r\n    cb.put(hreq.getMethod());\r\n    cb.put(SPACE);\r\n    String uri = hreq.getRequestURI();\r\n    if (uri == null) {\r\n        uri = \"NULL-HTTP-URI\";\r\n    }\r\n    cb.put(uri);\r\n    if (hreq.getQueryString() != null) {\r\n        cb.put('?');\r\n        cb.put(hreq.getQueryString());\r\n    }\r\n    cb.put(SPACE);\r\n    cb.put(hreq.getProtocol());\r\n    cb.put(\"\\\"\");\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.fireSessionEvent",
	"Comment": "notify all session event listeners that a particular event hasoccurred for this session.the default implementation performsthis notification synchronously using the calling thread.",
	"Method": "void fireSessionEvent(String type,Object data){\r\n    if (Session.SESSION_CREATED_EVENT.equals(type)) {\r\n        context.sessionCreatedEvent(this);\r\n    } else {\r\n        context.sessionDestroyedEvent(this);\r\n    }\r\n    if (listeners.size() < 1)\r\n        return;\r\n    SessionEvent event = new SessionEvent(this, type, data);\r\n    SessionListener[] list = new SessionListener[0];\r\n    synchronized (listeners) {\r\n        list = listeners.toArray(list);\r\n    }\r\n    for (int i = 0; i < list.length; i++) {\r\n        (list[i]).sessionEvent(event);\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.resources.ProxyDirContext.getAttributes",
	"Comment": "retrieves selected attributes associated with a named object.",
	"Method": "Attributes getAttributes(Name name,Attributes getAttributes,String name,Attributes getAttributes,Name name,String[] attrIds,Attributes getAttributes,String name,String[] attrIds){\r\n    Attributes attributes = dirContext.getAttributes(parseName(name), attrIds);\r\n    if (!(attributes instanceof ResourceAttributes)) {\r\n        attributes = new ResourceAttributes(attributes);\r\n    }\r\n    return attributes;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.Location.check",
	"Comment": "location element contains the location of the resource in the web application",
	"Method": "Result check(WebBundleDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (((WebBundleDescriptorImpl) descriptor).getErrorPageDescriptors().hasMoreElements()) {\r\n        boolean oneFailed = false;\r\n        boolean foundIt = false;\r\n        FileArchive arch = null;\r\n        for (Enumeration e = ((WebBundleDescriptorImpl) descriptor).getErrorPageDescriptors(); e.hasMoreElements(); ) {\r\n            foundIt = false;\r\n            ErrorPageDescriptor errorpage = (ErrorPageDescriptor) e.nextElement();\r\n            String location = errorpage.getLocation();\r\n            String uri = null;\r\n            try {\r\n                uri = getAbstractArchiveUri(descriptor);\r\n                try {\r\n                    arch = new FileArchive();\r\n                    arch.open(uri);\r\n                } catch (IOException ioe) {\r\n                    throw ioe;\r\n                }\r\n                if (location.startsWith(\"/\"))\r\n                    location = location.substring(1);\r\n                File loc = new File(new File(arch.getURI()), location);\r\n                if (loc.exists())\r\n                    foundIt = true;\r\n                loc = null;\r\n            } catch (Exception ex) {\r\n                if (!oneFailed) {\r\n                    oneFailed = true;\r\n                }\r\n            }\r\n            if (foundIt) {\r\n                result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"Location [ {0} ] contains the location of the resource within web application [ {1} ]\", new Object[] { location, descriptor.getName() }));\r\n            } else {\r\n                if (!oneFailed) {\r\n                    oneFailed = true;\r\n                }\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Location [ {0} ] is not found within [ {1} ] or does not contain the location of the resource within web application [ {2} ]\", new Object[] { location, uri, descriptor.getName() }));\r\n            }\r\n        }\r\n        if (oneFailed) {\r\n            result.setStatus(Result.FAILED);\r\n        } else {\r\n            result.setStatus(Result.PASSED);\r\n        }\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"There are no location elements within the web archive [ {0} ]\", new Object[] { descriptor.getName() }));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.readers.InputObject.verify",
	"Comment": "throw an exception if the object is an nan or infinite number.",
	"Method": "void verify(Object o){\r\n    if (o != null) {\r\n        if (o instanceof Double) {\r\n            if (((Double) o).isInfinite() || ((Double) o).isNaN()) {\r\n                throw new InputException(\"Non-finite numbers not allowed\");\r\n            }\r\n        } else if (o instanceof Float) {\r\n            if (((Float) o).isInfinite() || ((Float) o).isNaN()) {\r\n                throw new InputException(\"Non-finite numbers not allowed\");\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutoDeployedFilesManager.loadStatus",
	"Comment": "create an instance from the persisted file in the specified directory.",
	"Method": "AutoDeployedFilesManager loadStatus(File statusDir,AutoDeployedFilesManager loadStatus,String autoDeploymentDir){\r\n    String statusDir = autoDeploymentDir + File.separator + STATUS_DIR_NAME;\r\n    AutoDeployedFilesManager adfm = new AutoDeployedFilesManager(statusDir);\r\n    return adfm;\r\n}"
}, {
	"Path": "org.glassfish.internal.deployment.GenericSniffer.getURLPatterns",
	"Comment": "returns the pattern to apply against the request urlif the pattern matches the url, the service method of the associatedcontainer will be invoked",
	"Method": "String[] getURLPatterns(){\r\n    if (urlPattern != null) {\r\n        return new String[] { urlPattern };\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.universal.xml.MiniXmlParser.getListenerNamesForVS",
	"Comment": "get http listener names for virtual server.returns null or empty array if not found.",
	"Method": "String[] getListenerNamesForVS(String vsid,List<Map<String, String>> vsAttributes){\r\n    String listeners = null;\r\n    String[] listenerArray = null;\r\n    for (Map<String, String> atts : vsAttributes) {\r\n        String id = atts.get(\"id\");\r\n        if (id != null && id.equals(vsid)) {\r\n            listeners = atts.get(\"network-listeners\");\r\n            if (listeners == null) {\r\n                listeners = atts.get(\"http-listeners\");\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    if (GFLauncherUtils.ok(listeners)) {\r\n        listenerArray = listeners.split(\",\");\r\n        if (listenerArray.length == 0) {\r\n            listenerArray = null;\r\n        }\r\n    }\r\n    return listenerArray;\r\n}"
}, {
	"Path": "org.apache.catalina.core.NamingContextListener.removeEnvironment",
	"Comment": "set the specified environment entries in the naming context.",
	"Method": "void removeEnvironment(String name){\r\n    try {\r\n        envCtx.unbind(name);\r\n    } catch (NamingException e) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.BIND_OBJECT_FAILED), e);\r\n        log(msg);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.elements.MethodsExist.contains",
	"Comment": "checks if method1 is present in the given list of methods. for style 2 methods only method names are compared and for style 3 method parameters are also compared.",
	"Method": "boolean contains(MethodDescriptor method1,List<Method> methods,boolean isStyle2){\r\n    for (Method method : methods) {\r\n        if (isStyle2) {\r\n            if (method.getName().equals(method1.getName()))\r\n                return true;\r\n        } else if (method.getName().equals(method1.getName()) && Arrays.equals(new MethodDescriptor().getParameterClassNamesFor(method, method.getParameterTypes()), method1.getParameterClassNames()))\r\n            return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.appclient.AppClientTest.check",
	"Comment": "all connector tests should implement this method. it run an individualtest against the resource adapter deployment descriptor.",
	"Method": "Result check(Descriptor descriptor,Result check,ApplicationClientDescriptor descriptor){\r\n    return check((ApplicationClientDescriptor) descriptor);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getSessionCookieConfig",
	"Comment": "gets the session tracking cookie configuration of thisservletcontext.",
	"Method": "SessionCookieConfig getSessionCookieConfig(){\r\n    if (sessionCookieConfig == null) {\r\n        sessionCookieConfig = new SessionCookieConfigImpl(this);\r\n    }\r\n    return sessionCookieConfig;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.getProtocolHandler",
	"Comment": "return the protocol handler associated with the connector.",
	"Method": "ProtocolHandler getProtocolHandler(){\r\n    return protocolHandler;\r\n}"
}, {
	"Path": "org.apache.naming.NamingContext.list",
	"Comment": "enumerates the names bound in the named context, along with the class names of objects bound to them.",
	"Method": "NamingEnumeration<NameClassPair> list(Name name,NamingEnumeration<NameClassPair> list,String name){\r\n    return list(new CompositeName(name));\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.loadWebModule",
	"Comment": "creates and configures a web module and adds it to the specifiedvirtual server.",
	"Method": "List<Result<WebModule>> loadWebModule(WebModuleConfig wmInfo,String j2eeApplication,Properties deploymentProperties,WebModule loadWebModule,VirtualServer vs,WebModuleConfig wmInfo,String j2eeApplication,Properties deploymentProperties){\r\n    String wmName = wmInfo.getName();\r\n    String wmContextPath = wmInfo.getContextPath();\r\n    if (wmContextPath.indexOf('%') != -1) {\r\n        try {\r\n            RequestUtil.urlDecode(wmContextPath, \"UTF-8\");\r\n        } catch (Exception e) {\r\n            String msg = rb.getString(LogFacade.INVALID_ENCODED_CONTEXT_ROOT);\r\n            msg = MessageFormat.format(msg, wmName, wmContextPath);\r\n            throw new Exception(msg);\r\n        }\r\n    }\r\n    if (wmContextPath.length() == 0 && vs.getDefaultWebModuleID() != null) {\r\n        String msg = rb.getString(LogFacade.DEFAULT_WEB_MODULE_CONFLICT);\r\n        msg = MessageFormat.format(msg, new Object[] { wmName, vs.getID() });\r\n        throw new Exception(msg);\r\n    }\r\n    wmInfo.setWorkDirBase(_appsWorkRoot);\r\n    wmInfo.setStubBaseDir(appsStubRoot);\r\n    String displayContextPath = null;\r\n    if (wmContextPath.length() == 0)\r\n        displayContextPath = \"/\";\r\n    else\r\n        displayContextPath = wmContextPath;\r\n    Map<String, AdHocServletInfo> adHocPaths = null;\r\n    Map<String, AdHocServletInfo> adHocSubtrees = null;\r\n    WebModule ctx = (WebModule) vs.findChild(wmContextPath);\r\n    if (ctx != null) {\r\n        if (ctx instanceof AdHocWebModule) {\r\n            if (ctx.hasAdHocPaths()) {\r\n                adHocPaths = ctx.getAdHocPaths();\r\n            }\r\n            if (ctx.hasAdHocSubtrees()) {\r\n                adHocSubtrees = ctx.getAdHocSubtrees();\r\n            }\r\n            vs.removeChild(ctx);\r\n        } else if (Constants.DEFAULT_WEB_MODULE_NAME.equals(ctx.getModuleName())) {\r\n            unloadWebModule(wmContextPath, ctx.getWebBundleDescriptor().getApplication().getRegistrationName(), vs.getName(), true, null);\r\n        } else if (!ctx.getAvailable()) {\r\n            ctx.setAvailable(true);\r\n            return ctx;\r\n        } else {\r\n            String msg = rb.getString(LogFacade.DUPLICATE_CONTEXT_ROOT);\r\n            throw new Exception(MessageFormat.format(msg, vs.getID(), ctx.getModuleName(), displayContextPath, wmName));\r\n        }\r\n    }\r\n    if (logger.isLoggable(Level.FINEST)) {\r\n        Object[] params = { wmName, vs.getID(), displayContextPath };\r\n        logger.log(Level.FINEST, LogFacade.WEB_MODULE_LOADING, params);\r\n    }\r\n    File docBase = null;\r\n    if (JWS_APPCLIENT_MODULE_NAME.equals(wmName)) {\r\n        docBase = new File(System.getProperty(\"com.sun.aas.installRoot\"));\r\n    } else {\r\n        docBase = wmInfo.getLocation();\r\n    }\r\n    ctx = (WebModule) _embedded.createContext(wmName, wmContextPath, docBase, vs.getDefaultContextXmlLocation(), vs.getDefaultWebXmlLocation(), useDOLforDeployment, wmInfo);\r\n    ctx.setUseNaming(false);\r\n    Engine engine = (Engine) vs.getParent();\r\n    if (engine != null) {\r\n        ctx.setEngineName(engine.getName());\r\n        ctx.setJvmRoute(engine.getJvmRoute());\r\n    }\r\n    String j2eeServer = _serverContext.getInstanceName();\r\n    String domain = _serverContext.getDefaultDomainName();\r\n    ctx.setDomain(domain);\r\n    ctx.setJ2EEServer(j2eeServer);\r\n    ctx.setJ2EEApplication(j2eeApplication);\r\n    ctx.setCacheControls(vs.getCacheControls());\r\n    ctx.setBean(wmInfo.getBean());\r\n    if (adHocPaths != null) {\r\n        ctx.addAdHocPaths(adHocPaths);\r\n    }\r\n    if (adHocSubtrees != null) {\r\n        ctx.addAdHocSubtrees(adHocSubtrees);\r\n    }\r\n    WebBundleDescriptor wbd = wmInfo.getDescriptor();\r\n    if (wbd != null) {\r\n        ctx.setContextRoot(wbd.getContextRoot());\r\n    } else {\r\n        logger.log(Level.WARNING, LogFacade.UNABLE_TO_SET_CONTEXT_ROOT, wmInfo);\r\n    }\r\n    String wmInfoWorkDir = wmInfo.getWorkDir();\r\n    if (wmInfoWorkDir != null) {\r\n        StringBuilder workDir = new StringBuilder(wmInfo.getWorkDir());\r\n        if (wmName.equals(Constants.DEFAULT_WEB_MODULE_NAME)) {\r\n            workDir.append(\"-\");\r\n            workDir.append(FileUtils.makeFriendlyFilename(vs.getID()));\r\n        }\r\n        ctx.setWorkDir(workDir.toString());\r\n    }\r\n    ClassLoader parentLoader = wmInfo.getParentLoader();\r\n    if (parentLoader == null) {\r\n        parentLoader = _serverContext.getSharedClassLoader();\r\n    }\r\n    ctx.setParentClassLoader(parentLoader);\r\n    if (wbd != null) {\r\n        ctx.configureAlternateDD(wbd);\r\n        ctx.configureWebServices(wbd);\r\n    }\r\n    SunWebAppImpl iasBean = null;\r\n    if (wbd != null) {\r\n        iasBean = (SunWebAppImpl) wbd.getSunDescriptor();\r\n    }\r\n    ctx.setIasWebAppConfigBean(iasBean);\r\n    ctx.configureMiscSettings(iasBean, vs, displayContextPath);\r\n    if (ctx.getID().startsWith(Constants.DEFAULT_WEB_MODULE_NAME)) {\r\n        ctx.setAlternateDocBases(vs.getProperties());\r\n    }\r\n    Loader loader = ctx.configureLoader(iasBean);\r\n    if (wbd != null && wbd.hasWebServices()) {\r\n        wbd.addExtraAttribute(\"WEBLOADER\", loader);\r\n    }\r\n    for (LifecycleListener listener : ctx.findLifecycleListeners()) {\r\n        if (listener instanceof ContextConfig) {\r\n            ((ContextConfig) listener).setClassLoader(wmInfo.getAppClassLoader());\r\n        }\r\n    }\r\n    ctx.configureSessionSettings(wbd, wmInfo);\r\n    ctx.setI18nInfo();\r\n    if (wbd != null) {\r\n        String resourceType = wmInfo.getObjectType();\r\n        boolean isSystem = resourceType != null && resourceType.startsWith(\"system-\");\r\n        if (!wmName.startsWith(Constants.DEFAULT_WEB_MODULE_NAME)) {\r\n            Realm realm = habitat.getService(Realm.class);\r\n            if (\"null\".equals(j2eeApplication)) {\r\n                if (realm != null && realm instanceof RealmInitializer) {\r\n                    ((RealmInitializer) realm).initializeRealm(wbd, isSystem, vs.getAuthRealmName());\r\n                    ctx.setRealm(realm);\r\n                }\r\n            } else {\r\n                if (realm != null && realm instanceof RealmInitializer) {\r\n                    ((RealmInitializer) realm).initializeRealm(wbd, isSystem, null);\r\n                    ctx.setRealm(realm);\r\n                }\r\n            }\r\n        }\r\n        if (wbd.getApplication() != null && wbd.getApplication().isVirtual()) {\r\n            wbd.visit(new WebValidatorWithoutCL());\r\n        }\r\n    }\r\n    addMimeMappings(ctx, vs.getMimeMap());\r\n    String moduleName = Constants.DEFAULT_WEB_MODULE_NAME;\r\n    String monitoringNodeName = moduleName;\r\n    if (wbd != null && wbd.getApplication() != null) {\r\n        com.sun.enterprise.deployment.Application app = wbd.getApplication();\r\n        ctx.setStandalone(app.isVirtual());\r\n        if (app.isVirtual()) {\r\n            moduleName = app.getRegistrationName();\r\n            monitoringNodeName = wbd.getModuleID();\r\n        } else {\r\n            moduleName = wbd.getModuleDescriptor().getArchiveUri();\r\n            StringBuilder sb = new StringBuilder();\r\n            sb.append(app.getRegistrationName()).append(MONITORING_NODE_SEPARATOR).append(moduleName);\r\n            monitoringNodeName = sb.toString().replaceAll(\"\\\\.\", \"\\\\\\\\.\").replaceAll(\"_war\", \"\\\\\\\\.war\");\r\n        }\r\n    }\r\n    ctx.setModuleName(moduleName);\r\n    ctx.setMonitoringNodeName(monitoringNodeName);\r\n    List<String> servletNames = new ArrayList<String>();\r\n    if (wbd != null) {\r\n        for (WebComponentDescriptor webCompDesc : wbd.getWebComponentDescriptors()) {\r\n            if (webCompDesc.isServlet()) {\r\n                servletNames.add(webCompDesc.getCanonicalName());\r\n            }\r\n        }\r\n    }\r\n    webStatsProviderBootstrap.registerApplicationStatsProviders(monitoringNodeName, vs.getName(), servletNames);\r\n    vs.addChild(ctx);\r\n    ctx.loadSessions(deploymentProperties);\r\n    return ctx;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.logger.LoggerBase.getContainer",
	"Comment": "return the container with which this logger has been associated.",
	"Method": "Container getContainer(){\r\n    return (container);\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ExtendedAccessLogValve.setCondition",
	"Comment": "set the servletrequest.attribute to look for to performconditional logging. set to null to log everything.",
	"Method": "void setCondition(String condition){\r\n    this.condition = condition;\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.deploy.shared.MemoryMappedArchive.getSubArchive",
	"Comment": "create or obtain an embedded archive within this abstraction.",
	"Method": "ReadableArchive getSubArchive(String name){\r\n    InputStream is = getEntry(name);\r\n    if (is != null) {\r\n        ReadableArchive archive = new MemoryMappedArchive(is);\r\n        is.close();\r\n        return archive;\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.DeleteHttp.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    ActionReport report = context.getActionReport();\r\n    NetworkConfig networkConfig = config.getNetworkConfig();\r\n    Protocols protocols = networkConfig.getProtocols();\r\n    try {\r\n        for (Protocol protocol : protocols.getProtocol()) {\r\n            if (protocolName.equalsIgnoreCase(protocol.getName())) {\r\n                protocolToBeRemoved = protocol;\r\n            }\r\n        }\r\n        if (protocolToBeRemoved == null) {\r\n            report.setMessage(MessageFormat.format(rb.getString(LogFacade.DELETE_HTTP_NOTEXISTS), protocolName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n        List<NetworkListener> nwlsnrList = protocolToBeRemoved.findNetworkListeners();\r\n        for (NetworkListener nwlsnr : nwlsnrList) {\r\n            if (protocolToBeRemoved.getName().equals(nwlsnr.getProtocol())) {\r\n                report.setMessage(MessageFormat.format(rb.getString(LogFacade.DELETE_PROTOCOL_BEING_USED), protocolName, nwlsnr.getName()));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n        ConfigSupport.apply(new SingleConfigCode<Protocol>() {\r\n            public Object run(Protocol param) {\r\n                param.setHttp(null);\r\n                return null;\r\n            }\r\n        }, protocolToBeRemoved);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.DELETE_HTTP_REDIRECT_FAIL), protocolName) + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.DeleteHttp.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    param.setHttp(null);\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.NativeRemoteCommandsBase.isRemoteDirectoryEmpty",
	"Comment": "method to check if specified remote directory contains files",
	"Method": "boolean isRemoteDirectoryEmpty(SFTPClient sftp,String file){\r\n    List<ChannelSftp.LsEntry> l = (List<ChannelSftp.LsEntry>) sftp.getSftpChannel().ls(file);\r\n    if (l.size() > 2)\r\n        return false;\r\n    return true;\r\n}"
}, {
	"Path": "org.apache.catalina.session.FileStore.load",
	"Comment": "load and return the session associated with the specified sessionidentifier from this store, without removing it.if there is nosuch stored session, return null.",
	"Method": "Session load(String id){\r\n    Session sess = sessions.get(id);\r\n    if (sess != null) {\r\n        return sess;\r\n    }\r\n    File file = file(id);\r\n    if (file == null) {\r\n        return (null);\r\n    }\r\n    if (!file.exists()) {\r\n        return (null);\r\n    }\r\n    if (debug >= 1) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.LOADING_SESSION_FROM_FILE), new Object[] { id, file.getAbsolutePath() });\r\n        log(msg);\r\n    }\r\n    FileInputStream fis = null;\r\n    BufferedInputStream bis = null;\r\n    ObjectInputStream ois = null;\r\n    Loader loader = null;\r\n    ClassLoader classLoader = null;\r\n    try {\r\n        fis = new FileInputStream(file.getAbsolutePath());\r\n        bis = new BufferedInputStream(fis);\r\n        Container container = manager.getContainer();\r\n        if (container != null) {\r\n            ois = ((StandardContext) container).createObjectInputStream(bis);\r\n        } else {\r\n            ois = new ObjectInputStream(bis);\r\n        }\r\n    } catch (FileNotFoundException e) {\r\n        if (debug >= 1)\r\n            log(\"No persisted data file found\");\r\n        return (null);\r\n    } catch (IOException e) {\r\n        if (bis != null) {\r\n            try {\r\n                bis.close();\r\n            } catch (IOException f) {\r\n            }\r\n        }\r\n        if (fis != null) {\r\n            try {\r\n                fis.close();\r\n            } catch (IOException f) {\r\n            }\r\n        }\r\n        throw e;\r\n    }\r\n    try {\r\n        StandardSession session = StandardSession.deserialize(ois, manager);\r\n        session.setManager(manager);\r\n        sessions.put(session.getIdInternal(), session);\r\n        return (session);\r\n    } finally {\r\n        if (ois != null) {\r\n            try {\r\n                ois.close();\r\n            } catch (IOException f) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.ContainerTransactionStyle3.isMethodContained",
	"Comment": "returns true if methoddescriptor is contained in the set methods",
	"Method": "boolean isMethodContained(Set<Method> methods,MethodDescriptor methodDescriptor){\r\n    boolean foundIt = false;\r\n    for (Method method : methods) {\r\n        if (method.getName().equals(methodDescriptor.getName()) && MethodUtils.stringArrayEquals(methodDescriptor.getParameterClassNames(), (new MethodDescriptor(method)).getParameterClassNames())) {\r\n            foundIt = true;\r\n            break;\r\n        }\r\n    }\r\n    return foundIt;\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.AuthenticatorBase.stop",
	"Comment": "gracefully terminate the active use of the public methods of thiscomponent.this method should be the last one called on a giveninstance of this component.",
	"Method": "void stop(){\r\n    if (!started)\r\n        return;\r\n    sso = null;\r\n    super.stop();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorLog.reconstruct",
	"Comment": "requests that the object reconstructs its state from the given stream.there may be more than one if the coordinatorlog elects to write to thelog before it is asked to force the transaction state.this operation is invoked when there are log records that need tobe recovered. the coordinatorlog should reconstruct the sequences ofobjects and data from each of the sections so that they can be queried bythe callers that set them up.",
	"Method": "boolean reconstruct(DataInputStream dataInput){\r\n    boolean result = true;\r\n    int numSections = dataInput.readUnsignedShort();\r\n    while (--numSections >= 0) {\r\n        int length = dataInput.readUnsignedShort();\r\n        if (length > 0) {\r\n            int numObjects = dataInput.readUnsignedShort();\r\n            int numData = dataInput.readUnsignedShort();\r\n            byte[] stringData = new byte[length];\r\n            dataInput.read(stringData);\r\n            String sectionName = new String(stringData);\r\n            CoordinatorLogSection section = (CoordinatorLogSection) createSection(sectionName);\r\n            if (numObjects > 0 && section.writtenObjects == null) {\r\n                section.writtenObjects = new Vector(numObjects, 10);\r\n            }\r\n            for (int i = 0; i < numObjects; i++) {\r\n                length = dataInput.readUnsignedShort();\r\n                stringData = new byte[length];\r\n                dataInput.read(stringData);\r\n                String objRefStr = new String(stringData);\r\n                section.writtenObjects.addElement(objRefStr);\r\n            }\r\n            if (numData > 0 && section.writtenData == null) {\r\n                section.writtenData = new Vector(numData, 4);\r\n            }\r\n            for (int i = 0; i < numData; i++) {\r\n                length = dataInput.readUnsignedShort();\r\n                byte[] dataItem = new byte[length];\r\n                dataInput.read(dataItem);\r\n                section.writtenData.addElement(dataItem);\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.utils.ResourceUtil.authenticateViaAdminRealm",
	"Comment": "authenticate the given req as originated from given remotehost againstadmin realm.",
	"Method": "Subject authenticateViaAdminRealm(ServiceLocator habitat,Request req,String remoteHost){\r\n    Subject subject = null;\r\n    final AdminAccessController authenticator = habitat.getService(AdminAccessController.class);\r\n    if (authenticator != null) {\r\n        subject = authenticator.loginAsAdmin(req, remoteHost);\r\n    }\r\n    return subject;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteRestAdminCommand.getUsage",
	"Comment": "get the usage text.if we got usage information from the server, use it.",
	"Method": "String getUsage(){\r\n    return usage;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationDispatcher.forward",
	"Comment": "forwards the given request and response to the resourcefor which this dispatcher was acquired.any runtime exceptions, ioexception, or servletexception thrownby the target will be propagated to the caller.",
	"Method": "void forward(ServletRequest request,ServletResponse response){\r\n    dispatch(request, response, DispatcherType.FORWARD);\r\n}"
}, {
	"Path": "org.apache.naming.resources.BaseDirContext.addToEnvironment",
	"Comment": "adds a new environment property to the environment of this context. if the property already exists, its value is overwritten.",
	"Method": "Object addToEnvironment(String propName,Object propVal){\r\n    return env.put(propName, propVal);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmrFieldAccessor.runIndividualCmrTest",
	"Comment": "run an individual verifier test of a declated cmr field of the class",
	"Method": "boolean runIndividualCmrTest(Descriptor entity,RelationRoleDescriptor rrd,Class c,Result result){\r\n    boolean oneFailed = false;\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    CMRFieldInfo info = rrd.getCMRFieldInfo();\r\n    if (info == null) {\r\n        addErrorDetails(result, compName);\r\n        result.addErrorDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CMPTest.isAccessorDeclared.failed1\", \"Error : no CMR Field  declared \", new Object[] {}));\r\n        return false;\r\n    }\r\n    oneFailed = isAccessorDeclared(info.name, info.type, c, result);\r\n    if (oneFailed == false) {\r\n    } else {\r\n        result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.addGoodDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CMPTest.isAccessorDeclared.passed\", \"CMR Field is properly declared \", new Object[] {}));\r\n    }\r\n    return oneFailed;\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.TransactionSynchronizationRegistryImpl.getRollbackOnly",
	"Comment": "get the rollbackonly status of the transaction bound to thecurrent thread.",
	"Method": "boolean getRollbackOnly(){\r\n    {\r\n        int status = getTransactionStatus();\r\n        if (status == Status.STATUS_NO_TRANSACTION) {\r\n            throw new IllegalStateException(sm.getString(\"enterprise_distributedtx.no_transaction\"));\r\n        }\r\n        if (status == Status.STATUS_MARKED_ROLLBACK || status == Status.STATUS_ROLLING_BACK)\r\n            return true;\r\n        else\r\n            return false;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.util.CharsetMapper.getCharset",
	"Comment": "calculate the name of a character set to be assumed, given the specifiedlocale and the absence of a character set specified as part of thecontent type header.",
	"Method": "String getCharset(Locale locale){\r\n    String charset = null;\r\n    charset = map.getProperty(locale.toString());\r\n    if (charset != null)\r\n        return (charset);\r\n    charset = map.getProperty(locale.getLanguage());\r\n    return (charset);\r\n}"
}, {
	"Path": "org.apache.naming.SelectorContext.listBindings",
	"Comment": "enumerates the names bound in the named context, along with the objects bound to them.",
	"Method": "NamingEnumeration<Binding> listBindings(Name name,NamingEnumeration<Binding> listBindings,String name){\r\n    return getBoundContext().listBindings(parseName(name));\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.apiscan.classfile.ASMMethod.visitTypeInsn",
	"Comment": "things like instanceof, checkcast, new, newarray and anewarray",
	"Method": "void visitTypeInsn(int opcode,String desc){\r\n    switch(opcode) {\r\n        case Opcodes.INSTANCEOF:\r\n        case Opcodes.CHECKCAST:\r\n        case Opcodes.ANEWARRAY:\r\n            addClass(desc);\r\n            break;\r\n        case Opcodes.NEW:\r\n            break;\r\n        case Opcodes.NEWARRAY:\r\n            break;\r\n        default:\r\n            break;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.ssi.SSIConditional.evaluateArguments",
	"Comment": "retrieves the expression from the specified arguments and peforms thenecessary evaluation steps.",
	"Method": "boolean evaluateArguments(String[] names,String[] values,SSIMediator ssiMediator){\r\n    String expr = getExpression(names, values);\r\n    if (expr == null) {\r\n        throw new SSIStopProcessingException();\r\n    }\r\n    try {\r\n        ExpressionParseTree tree = new ExpressionParseTree(expr, ssiMediator);\r\n        return tree.evaluateTree();\r\n    } catch (ParseException e) {\r\n        throw new SSIStopProcessingException();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.JspFile.check",
	"Comment": "jsp file element contains the full path to jsp file within web applicationtest.",
	"Method": "Result check(WebBundleDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!descriptor.getJspDescriptors().isEmpty()) {\r\n        boolean oneFailed = false;\r\n        boolean foundIt = false;\r\n        FileArchive arch = null;\r\n        Set jsps = descriptor.getJspDescriptors();\r\n        Iterator itr = jsps.iterator();\r\n        while (itr.hasNext()) {\r\n            foundIt = false;\r\n            WebComponentDescriptor jsp = (WebComponentDescriptor) itr.next();\r\n            String jspFilename = jsp.getWebComponentImplementation();\r\n            String uri = null;\r\n            try {\r\n                uri = getAbstractArchiveUri(descriptor);\r\n                try {\r\n                    arch = new FileArchive();\r\n                    arch.open(uri);\r\n                } catch (IOException e) {\r\n                    throw e;\r\n                }\r\n                if (jspFilename.startsWith(\"/\"))\r\n                    jspFilename = jspFilename.substring(1);\r\n                File jspf = new File(new File(arch.getURI()), jspFilename);\r\n                if (jspf.exists())\r\n                    foundIt = true;\r\n                jspf = null;\r\n            } catch (Exception e) {\r\n                if (!oneFailed) {\r\n                    oneFailed = true;\r\n                }\r\n            }\r\n            if (foundIt) {\r\n                result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"Jsp file [ {0} ] contains the full path to Jsp file within web application [ {1} ]\", new Object[] { jspFilename, descriptor.getName() }));\r\n            } else {\r\n                if (!oneFailed) {\r\n                    oneFailed = true;\r\n                }\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Jsp file [ {0} ] is not found within [ {1} ] or does not contain the full path to Jsp file within web application [ {2} ]\", new Object[] { jspFilename, uri, descriptor.getName() }));\r\n            }\r\n        }\r\n        if (oneFailed) {\r\n            result.setStatus(Result.FAILED);\r\n        } else {\r\n            result.setStatus(Result.PASSED);\r\n        }\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"There are no Jsp components within the web archive [ {0} ]\", new Object[] { descriptor.getName() }));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.naming.resources.WARDirContext.search",
	"Comment": "searches in the named context or object for entries that satisfy the given search filter. performs the search as specified by the search controls.",
	"Method": "NamingEnumeration<SearchResult> search(String name,Attributes matchingAttributes,String[] attributesToReturn,NamingEnumeration<SearchResult> search,String name,Attributes matchingAttributes,NamingEnumeration<SearchResult> search,String name,String filter,SearchControls cons,NamingEnumeration<SearchResult> search,String name,String filterExpr,Object[] filterArgs,SearchControls cons){\r\n    throw new OperationNotSupportedException();\r\n}"
}, {
	"Path": "org.glassfish.common.util.timer.TimerSchedule.populateCurrentMonthBits",
	"Comment": "use preprocessed values to create a bitset that represents set days of this month.",
	"Method": "BitSet populateCurrentMonthBits(Calendar date){\r\n    if (dayOfMonth_.equals(\"*\")) {\r\n        return daysOfMonth;\r\n    }\r\n    BitSet bits = (BitSet) daysOfMonth.clone();\r\n    if (lastDayOfMonth) {\r\n        bits.set(date.getActualMaximum(Calendar.DAY_OF_MONTH));\r\n    }\r\n    if (dayBeforeEndOfMonth > 0) {\r\n        bits.set(date.getActualMaximum(Calendar.DAY_OF_MONTH) - dayBeforeEndOfMonth);\r\n    }\r\n    int size = daysOfWeekOrRangesOfDaysInMonth.size();\r\n    for (int i = 0; i < size; i++) {\r\n        setDaysOfWeek(bits, date, daysOfWeekOrRangesOfDaysInMonth.get(i));\r\n    }\r\n    return bits;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.FilterDef.setInitParameter",
	"Comment": "sets the init parameter with the given name and valueon this filter.",
	"Method": "boolean setInitParameter(String name,String value,boolean override){\r\n    if (null == name || null == value) {\r\n        throw new IllegalArgumentException(\"Null filter init parameter name or value\");\r\n    }\r\n    synchronized (parameters) {\r\n        if (override || !parameters.containsKey(name)) {\r\n            parameters.put(name, value);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.NestingInfo.removeChild",
	"Comment": "removes the given subcoordinator as a child.if the reference is not in the set, the operation returns false.",
	"Method": "boolean removeChild(CoordinatorImpl child){\r\n    boolean result = childSet.removeElement(child);\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ExtendedAccessLogValve.decodePattern",
	"Comment": "decode the given pattern. is public so a pattern mayallows to be validated.",
	"Method": "FieldInfo[] decodePattern(String fields){\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \"decodePattern, fields=\" + fields);\r\n    LinkedList<FieldInfo> list = new LinkedList<FieldInfo>();\r\n    int i = 0;\r\n    for (; i < fields.length() && Character.isWhitespace(fields.charAt(i)); i++) ;\r\n    if (i >= fields.length()) {\r\n        log.log(Level.INFO, LogFacade.FIELD_EMPTY_INFO);\r\n        return null;\r\n    }\r\n    int j;\r\n    while (i < fields.length()) {\r\n        if (log.isLoggable(Level.FINE))\r\n            log.log(Level.FINE, \"fields.substring(i)=\" + fields.substring(i));\r\n        FieldInfo currentFieldInfo = new FieldInfo();\r\n        if (fields.startsWith(\"date\", i)) {\r\n            currentFieldInfo.type = FieldInfo.DATA_SPECIAL;\r\n            currentFieldInfo.location = FieldInfo.SPECIAL_DATE;\r\n            i += \"date\".length();\r\n        } else if (fields.startsWith(\"time-taken\", i)) {\r\n            currentFieldInfo.type = FieldInfo.DATA_SPECIAL;\r\n            currentFieldInfo.location = FieldInfo.SPECIAL_TIME_TAKEN;\r\n            i += \"time-taken\".length();\r\n        } else if (fields.startsWith(\"time\", i)) {\r\n            currentFieldInfo.type = FieldInfo.DATA_SPECIAL;\r\n            currentFieldInfo.location = FieldInfo.SPECIAL_TIME;\r\n            i += \"time\".length();\r\n        } else if (fields.startsWith(\"bytes\", i)) {\r\n            currentFieldInfo.type = FieldInfo.DATA_SPECIAL;\r\n            currentFieldInfo.location = FieldInfo.SPECIAL_BYTES;\r\n            i += \"bytes\".length();\r\n        } else if (fields.startsWith(\"cached\", i)) {\r\n            currentFieldInfo.type = FieldInfo.DATA_SPECIAL;\r\n            currentFieldInfo.location = FieldInfo.SPECIAL_CACHED;\r\n            i += \"cached\".length();\r\n        } else if (fields.startsWith(\"c-ip\", i)) {\r\n            currentFieldInfo.type = FieldInfo.DATA_CLIENT;\r\n            currentFieldInfo.location = FieldInfo.FIELD_IP;\r\n            i += \"c-ip\".length();\r\n        } else if (fields.startsWith(\"c-dns\", i)) {\r\n            currentFieldInfo.type = FieldInfo.DATA_CLIENT;\r\n            currentFieldInfo.location = FieldInfo.FIELD_DNS;\r\n            i += \"c-dns\".length();\r\n        } else if (fields.startsWith(\"s-ip\", i)) {\r\n            currentFieldInfo.type = FieldInfo.DATA_SERVER;\r\n            currentFieldInfo.location = FieldInfo.FIELD_IP;\r\n            i += \"s-ip\".length();\r\n        } else if (fields.startsWith(\"s-dns\", i)) {\r\n            currentFieldInfo.type = FieldInfo.DATA_SERVER;\r\n            currentFieldInfo.location = FieldInfo.FIELD_DNS;\r\n            i += \"s-dns\".length();\r\n        } else if (fields.startsWith(\"cs\", i)) {\r\n            i = decode(fields, i + 2, currentFieldInfo, FieldInfo.DATA_CLIENT_TO_SERVER);\r\n            if (i < 0)\r\n                return null;\r\n        } else if (fields.startsWith(\"sc\", i)) {\r\n            i = decode(fields, i + 2, currentFieldInfo, FieldInfo.DATA_SERVER_TO_CLIENT);\r\n            if (i < 0)\r\n                return null;\r\n        } else if (fields.startsWith(\"sr\", i)) {\r\n            i = decode(fields, i + 2, currentFieldInfo, FieldInfo.DATA_SERVER_TO_RSERVER);\r\n            if (i < 0)\r\n                return null;\r\n        } else if (fields.startsWith(\"rs\", i)) {\r\n            i = decode(fields, i + 2, currentFieldInfo, FieldInfo.DATA_RSERVER_TO_SERVER);\r\n            if (i < 0)\r\n                return null;\r\n        } else if (fields.startsWith(\"x\", i)) {\r\n            i = decodeAppSpecific(fields, i, currentFieldInfo);\r\n        } else {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.UNABLE_DECODE_REST_CHARS), fields.substring(i));\r\n            log.log(Level.SEVERE, msg);\r\n            return null;\r\n        }\r\n        j = i;\r\n        for (; j < fields.length() && Character.isWhitespace(fields.charAt(j)); j++) ;\r\n        if (j >= fields.length()) {\r\n            if (j == i) {\r\n                currentFieldInfo.postWhiteSpace = \"\";\r\n            } else {\r\n                currentFieldInfo.postWhiteSpace = fields.substring(i);\r\n                i = j;\r\n            }\r\n        } else {\r\n            currentFieldInfo.postWhiteSpace = fields.substring(i, j);\r\n            i = j;\r\n        }\r\n        list.add(currentFieldInfo);\r\n    }\r\n    i = 0;\r\n    FieldInfo[] f = new FieldInfo[list.size()];\r\n    for (Iterator<FieldInfo> k = list.iterator(); k.hasNext(); ) f[i++] = k.next();\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \"finished decoding with length of: \" + i);\r\n    return f;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.wsclient.WebServiceClientCheckMgrImpl.getSchemaVersion",
	"Comment": "a webservices client can be an application client or an ejb or a web componentfor a j2ee1.4 specific webservices client the version of client descriptoris 1.1. for jee 5.0 this version is 1.0",
	"Method": "String getSchemaVersion(Descriptor descriptor){\r\n    String wsclientVersion = null;\r\n    String version = ((ServiceReferenceDescriptor) descriptor).getBundleDescriptor().getSpecVersion();\r\n    if (moduleName.equals(Result.EJB)) {\r\n        if (\"2.1\".equals(version))\r\n            wsclientVersion = \"1.1\";\r\n        else if (\"3.0\".equals(version))\r\n            wsclientVersion = \"1.2\";\r\n    } else if (moduleName.equals(Result.WEB)) {\r\n        if (\"2.4\".equals(version))\r\n            wsclientVersion = \"1.1\";\r\n        else if (\"2.5\".equals(version))\r\n            wsclientVersion = \"1.2\";\r\n    } else if (moduleName.equals(Result.APPCLIENT)) {\r\n        if (\"1.4\".equals(version))\r\n            wsclientVersion = \"1.1\";\r\n        else if (\"5\".equals(version))\r\n            wsclientVersion = \"1.2\";\r\n    }\r\n    if (wsclientVersion == null) {\r\n        wsclientVersion = \"\";\r\n    }\r\n    return wsclientVersion;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.provider.ProviderUtil.quote",
	"Comment": "produce a string in double quotes with backslash sequences in all theright places.",
	"Method": "String quote(String string){\r\n    if (string == null || string.length() == 0) {\r\n        return \"\\\"\\\"\";\r\n    }\r\n    char b;\r\n    char c = 0;\r\n    int i;\r\n    int len = string.length();\r\n    StringBuilder sb = new StringBuilder(len + 4);\r\n    String t;\r\n    sb.append('\"');\r\n    for (i = 0; i < len; i += 1) {\r\n        b = c;\r\n        c = string.charAt(i);\r\n        switch(c) {\r\n            case '\\\\':\r\n            case '\"':\r\n                sb.append('\\\\');\r\n                sb.append(c);\r\n                break;\r\n            case '/':\r\n                if (b == '<') {\r\n                    sb.append('\\\\');\r\n                }\r\n                sb.append(c);\r\n                break;\r\n            case '\\b':\r\n                sb.append(\"\\\\b\");\r\n                break;\r\n            case '\\t':\r\n                sb.append(\"\\\\t\");\r\n                break;\r\n            case '\\n':\r\n                sb.append(\"\\\\n\");\r\n                break;\r\n            case '\\f':\r\n                sb.append(\"\\\\f\");\r\n                break;\r\n            case '\\r':\r\n                sb.append(\"\\\\r\");\r\n                break;\r\n            default:\r\n                if (c < ' ') {\r\n                    t = \"000\" + Integer.toHexString(c);\r\n                    sb.append(\"\\\%u\").append(t.substring(t.length() - 4));\r\n                } else {\r\n                    sb.append(c);\r\n                }\r\n        }\r\n    }\r\n    sb.append('\"');\r\n    return sb.toString();\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getPathTranslated",
	"Comment": "return the extra path information for this request, translatedto a real path.",
	"Method": "String getPathTranslated(){\r\n    if (servletContext == null) {\r\n        return null;\r\n    }\r\n    if (getPathInfo() == null) {\r\n        return null;\r\n    } else {\r\n        return servletContext.getRealPath(getPathInfo());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.MimeMap.getExtensions",
	"Comment": "returns an iterator over the mime extensions that were parsed",
	"Method": "Iterator<String> getExtensions(){\r\n    Iterator<String> ret = null;\r\n    if (mimeMappings != null) {\r\n        ret = mimeMappings.keySet().iterator();\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.RepositoryManager.validateMasterPassword",
	"Comment": "we validate the master password by trying to open the password aliaskeystore. this means that the keystore must already exist.",
	"Method": "void validateMasterPassword(RepositoryConfig config,String password){\r\n    final PEFileLayout layout = getFileLayout(config);\r\n    final File passwordAliases = layout.getPasswordAliasKeystore();\r\n    try {\r\n        new PasswordAdapter(passwordAliases.getAbsolutePath(), password.toCharArray());\r\n    } catch (IOException ex) {\r\n        throw new RepositoryException(_strMgr.getString(\"masterPasswordInvalid\"));\r\n    } catch (Exception ex) {\r\n        throw new RepositoryException(_strMgr.getString(\"couldNotValidateMasterPassword\", passwordAliases), ex);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmpFieldReturnType.runIndividualCmpFieldTest",
	"Comment": "run an individual verifier test of a declated cmp field of the class",
	"Method": "boolean runIndividualCmpFieldTest(Descriptor entity,Descriptor persistentField,Class c,Result result){\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    String fieldName = persistentField.getName();\r\n    String getMethodName = \"get\" + Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);\r\n    String setMethodName = \"set\" + Character.toUpperCase(fieldName.charAt(0)) + fieldName.substring(1);\r\n    Method getMethod = getMethod(c, getMethodName, null);\r\n    if (getMethod != null) {\r\n        if (((EjbDescriptor) entity).getLocalClassName() != null) {\r\n            if ((((EjbDescriptor) entity).getLocalClassName()).equals(getMethod.getReturnType().getName())) {\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.addErrorDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmpFieldReturnType.failed\", \"Error : cmp-field accessor method [{0}] cannot return local interface [{1}] \", new Object[] { getMethod.toString(), ((EjbDescriptor) entity).getLocalClassName() }));\r\n                return false;\r\n            } else {\r\n                result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.addGoodDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmpFieldReturnType.passed\", \"cmp-field accessor method [{0}] does not return local interface [{1}]. Test passed.\", new Object[] { getMethod.toString(), ((EjbDescriptor) entity).getLocalClassName() }));\r\n                return true;\r\n            }\r\n        } else {\r\n            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.addGoodDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmpFieldReturnType.failed2\", \"Not Applicable :  no local interface found.\", new Object[] {}));\r\n            return true;\r\n        }\r\n    } else {\r\n        result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.addErrorDetails(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmpFieldReturnType.failed1\", \"Error : cmp-field accessor method [{0}] not found.\", new Object[] { getMethodName }));\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.StoreBase.stop",
	"Comment": "gracefully terminate the active use of the public methods of thiscomponent.this method should be the last one called on a giveninstance of this component.",
	"Method": "void stop(){\r\n    if (!started)\r\n        throw new LifecycleException(rb.getString(LogFacade.STORE_BASE_NOT_STARTED_EXCEPTION));\r\n    lifecycle.fireLifecycleEvent(STOP_EVENT, null);\r\n    started = false;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.SetPropertiesRule.addAlias",
	"Comment": "add an additional attribute name to property name mapping.this is intended to be used from the xml rules.",
	"Method": "void addAlias(String attributeName,String propertyName){\r\n    if (attributeNames == null) {\r\n        attributeNames = new String[1];\r\n        attributeNames[0] = attributeName;\r\n        propertyNames = new String[1];\r\n        propertyNames[0] = propertyName;\r\n    } else {\r\n        int length = attributeNames.length;\r\n        String[] tempAttributes = new String[length + 1];\r\n        for (int i = 0; i < length; i++) {\r\n            tempAttributes[i] = attributeNames[i];\r\n        }\r\n        tempAttributes[length] = attributeName;\r\n        String[] tempProperties = new String[length + 1];\r\n        for (int i = 0; i < length && i < propertyNames.length; i++) {\r\n            tempProperties[i] = propertyNames[i];\r\n        }\r\n        tempProperties[length] = propertyName;\r\n        propertyNames = tempProperties;\r\n        attributeNames = tempAttributes;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.startup.HomesUserDatabase.getHome",
	"Comment": "return an absolute pathname to the home directory for the specified user.",
	"Method": "String getHome(String user){\r\n    return homes.get(user);\r\n}"
}, {
	"Path": "org.apache.catalina.filters.FilterBase.isConfigProblemFatal",
	"Comment": "determines if an exception when calling a setter or an unknownconfiguration attribute triggers the failure of the this filter which inturn will prevent the web application from starting.",
	"Method": "boolean isConfigProblemFatal(){\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.glassfish.bootstrap.Util.copyFile",
	"Comment": "this method is used to copy a given file to another fileusing the buffer sixe specified",
	"Method": "void copyFile(File fin,File fout){\r\n    InputStream inStream = new BufferedInputStream(new FileInputStream(fin));\r\n    FileOutputStream fos = new FileOutputStream(fout);\r\n    copy(inStream, fos, fin.length());\r\n}"
}, {
	"Path": "org.glassfish.flashlight.statistics.impl.AverageImpl.getSampleTime",
	"Comment": "tbdthis is an inefficient implementation. should schedule a timer taskthat gets a timeout event every 30s or so and updates this value",
	"Method": "long getSampleTime(){\r\n    return System.currentTimeMillis();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RecoveryManager.validLocalTID",
	"Comment": "determines whether the local transaction identifier represents a validtransaction.",
	"Method": "boolean validLocalTID(Long localTID){\r\n    boolean result = coordsByLocalTID.containsKey(localTID);\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.session.SessionLock.unlockBackground",
	"Comment": "unlock the lock for the background locked casethe lock will be unlocked",
	"Method": "void unlockBackground(){\r\n    if (!isLocked())\r\n        return;\r\n    if (isBackgroundLocked()) {\r\n        this.setLockType(null);\r\n        this.setForegroundRefCount(0);\r\n        return;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogHandle.freeCushion",
	"Comment": "frees the cushion file.this internal method does not need to be synchronized.",
	"Method": "void freeCushion(){\r\n    if (cushionExists) {\r\n        java.security.AccessController.doPrivileged(new java.security.PrivilegedAction() {\r\n            public Object run() {\r\n                return logControl.cushionFile.delete();\r\n            }\r\n        });\r\n        cushionExists = false;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogHandle.freeCushion",
	"Comment": "frees the cushion file.this internal method does not need to be synchronized.",
	"Method": "void freeCushion(){\r\n    return logControl.cushionFile.delete();\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.jts.recovery.OracleXAResource.recover",
	"Comment": "recovers list of xids in transaction table. recover on oracle ignores flags sent to it, this methodtakes care of flags in addition to calling recoverlist for xid list.",
	"Method": "Xid[] recover(int flag){\r\n    if (flag == XAResource.TMNOFLAGS)\r\n        return null;\r\n    return recoverList(flag);\r\n}"
}, {
	"Path": "org.glassfish.web.loader.StringManager.getResourceBundleLocale",
	"Comment": "returns the locale of the resource bundle for the given request locale.",
	"Method": "Locale getResourceBundleLocale(Locale requestLocale){\r\n    ResourceBundle bundle = bundles.get(requestLocale);\r\n    if (bundle == null) {\r\n        synchronized (bundles) {\r\n            bundle = bundles.get(requestLocale);\r\n            if (bundle == null) {\r\n                bundle = ResourceBundle.getBundle(this.bundleName, requestLocale);\r\n                bundles.put(requestLocale, bundle);\r\n            }\r\n        }\r\n    }\r\n    return bundle.getLocale();\r\n}"
}, {
	"Path": "org.glassfish.webservices.transport.tcp.AppServRegistry.getWebModule",
	"Comment": "this function is called once for every endpoint registration.and the webmodule corresponding to that endpoint is stored.",
	"Method": "WebModule getWebModule(WebServiceEndpoint wsep){\r\n    ApplicationRegistry appRegistry = org.glassfish.internal.api.Globals.getDefaultHabitat().getService(ApplicationRegistry.class);\r\n    String appName = wsep.getBundleDescriptor().getApplication().getAppName();\r\n    ApplicationInfo appInfo = appRegistry.get(appName);\r\n    WebApplication webApp = null;\r\n    if (appInfo != null) {\r\n        Collection<ModuleInfo> moduleInfos = appInfo.getModuleInfos();\r\n        Set<EngineRef> engineRefs = null;\r\n        WebBundleDescriptor requiredWbd = (WebBundleDescriptor) wsep.getBundleDescriptor();\r\n        for (ModuleInfo moduleInfo : moduleInfos) {\r\n            engineRefs = moduleInfo.getEngineRefs();\r\n            for (EngineRef engineRef : engineRefs) {\r\n                if (engineRef.getApplicationContainer() instanceof WebApplication) {\r\n                    webApp = (WebApplication) engineRef.getApplicationContainer();\r\n                    WebBundleDescriptor wbd = webApp.getDescriptor();\r\n                    if (wbd.equals(requiredWbd)) {\r\n                        break;\r\n                    } else {\r\n                        webApp = null;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (webApp != null) {\r\n        String requiredModule = ((WebBundleDescriptor) wsep.getBundleDescriptor()).getModuleName();\r\n        Set<WebModule> webModules = webApp.getWebModules();\r\n        for (WebModule wm : webModules) {\r\n            if (wm.getModuleName().equalsIgnoreCase(requiredModule)) {\r\n                return wm;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.readers.XmlInputReader.nextMeta",
	"Comment": "returns the next xml meta token. this is used for skipping over andstructures.",
	"Method": "Object nextMeta(){\r\n    char c;\r\n    char q;\r\n    do {\r\n        c = next();\r\n    } while (Character.isWhitespace(c));\r\n    switch(c) {\r\n        case 0:\r\n            throw error(\"Misshaped meta tag\");\r\n        case '<':\r\n            return XmlInputObject.LT;\r\n        case '>':\r\n            return XmlInputObject.GT;\r\n        case '/':\r\n            return XmlInputObject.SLASH;\r\n        case '=':\r\n            return XmlInputObject.EQ;\r\n        case '!':\r\n            return XmlInputObject.BANG;\r\n        case '?':\r\n            return XmlInputObject.QUEST;\r\n        case '\"':\r\n        case '\\'':\r\n            q = c;\r\n            for (; ; ) {\r\n                c = next();\r\n                if (c == 0) {\r\n                    throw error(\"Unterminated string\");\r\n                }\r\n                if (c == q) {\r\n                    return Boolean.TRUE;\r\n                }\r\n            }\r\n        default:\r\n            for (; ; ) {\r\n                c = next();\r\n                if (Character.isWhitespace(c)) {\r\n                    return Boolean.TRUE;\r\n                }\r\n                switch(c) {\r\n                    case 0:\r\n                    case '<':\r\n                    case '>':\r\n                    case '/':\r\n                    case '=':\r\n                    case '!':\r\n                    case '?':\r\n                    case '\"':\r\n                    case '\\'':\r\n                        back();\r\n                        return Boolean.TRUE;\r\n                }\r\n            }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogHandle.cleanUpExtents",
	"Comment": "removes all extent information from the log file.this internal method does not need to be synchronized.",
	"Method": "void cleanUpExtents(){\r\n    Enumeration extents = extentTable.elements();\r\n    while (extents.hasMoreElements()) {\r\n        LogExtent logEDP = (LogExtent) extents.nextElement();\r\n        extentTable.remove(logEDP.extentNumber);\r\n        logEDP.doFinalize();\r\n    }\r\n    extentTable = null;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.SupplementalCommandExecutorImpl.getSupplementalCommandsList",
	"Comment": "get list of all supplemental commands, map it to various commands and cache this list",
	"Method": "Map<String, List<ServiceHandle<?>>> getSupplementalCommandsList(){\r\n    if (supplementalCommandsMap != null)\r\n        return supplementalCommandsMap;\r\n    supplementalCommandsMap = new ConcurrentHashMap<String, List<ServiceHandle<?>>>();\r\n    List<ServiceHandle<Supplemental>> supplementals = habitat.getAllServiceHandles(Supplemental.class);\r\n    for (ServiceHandle<Supplemental> handle : supplementals) {\r\n        ActiveDescriptor<Supplemental> inh = handle.getActiveDescriptor();\r\n        String commandName = getOne(\"target\", inh.getMetadata());\r\n        if (supplementalCommandsMap.containsKey(commandName)) {\r\n            supplementalCommandsMap.get(commandName).add(handle);\r\n        } else {\r\n            ArrayList<ServiceHandle<?>> inhList = new ArrayList<ServiceHandle<?>>();\r\n            inhList.add(handle);\r\n            supplementalCommandsMap.put(commandName, inhList);\r\n        }\r\n    }\r\n    return supplementalCommandsMap;\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.CreateProtocol.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    final ActionReport report = context.getActionReport();\r\n    NetworkConfig networkConfig = config.getNetworkConfig();\r\n    Protocols protocols = networkConfig.getProtocols();\r\n    for (Protocol protocol : protocols.getProtocol()) {\r\n        if (protocolName != null && protocolName.equalsIgnoreCase(protocol.getName())) {\r\n            report.setMessage(MessageFormat.format(rb.getString(LogFacade.CREATE_PROTOCOL_FAIL_DUPLICATE), protocolName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    try {\r\n        create(protocols, protocolName, securityEnabled);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.CREATE_PROTOCOL_FAIL), protocolName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    } catch (Exception e) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.CREATE_PROTOCOL_FAIL), protocolName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.OutputBuffer.close",
	"Comment": "close the output buffer. this tries to calculate the response size if the response has not been committed yet.",
	"Method": "void close(){\r\n    if (suspended)\r\n        return;\r\n    grizzlyOutputBuffer.close();\r\n}"
}, {
	"Path": "org.glassfish.cluster.ssh.sftp.SFTPClient.mkdirs",
	"Comment": "makes sure that the directory exists, by creating it if necessary.",
	"Method": "void mkdirs(String path,int posixPermission){\r\n    if (path.endsWith(\"/\")) {\r\n        path = path.substring(0, path.length() - 1);\r\n    }\r\n    path = normalizePath(path);\r\n    SftpATTRS attrs = _stat(path);\r\n    if (attrs != null && attrs.isDir())\r\n        return;\r\n    int idx = path.lastIndexOf(\"/\");\r\n    if (idx > 0)\r\n        mkdirs(path.substring(0, idx), posixPermission);\r\n    sftpChannel.mkdir(path);\r\n    sftpChannel.chmod(posixPermission, path);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogRecordHeader.toString",
	"Comment": "this method is called to direct the object to format its stateto a string.",
	"Method": "String toString(){\r\n    return \"LRH(type=\" + recordType + \",curr=\" + currentLSN + \",prev=\" + previousLSN + \",next=\" + nextLSN + \",len=\" + recordLength + \")\";\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationHttpRequest.mergeValues",
	"Comment": "merge the two sets of parameter values into a single string array.",
	"Method": "String[] mergeValues(Object values1,Object values2){\r\n    ArrayList<String> results = new ArrayList<String>();\r\n    if (values1 == null)\r\n        ;\r\n    else if (values1 instanceof String)\r\n        results.add((String) values1);\r\n    else if (values1 instanceof String[]) {\r\n        String[] values = (String[]) values1;\r\n        for (int i = 0; i < values.length; i++) results.add(values[i]);\r\n    } else\r\n        results.add(values1.toString());\r\n    if (values2 == null)\r\n        ;\r\n    else if (values2 instanceof String)\r\n        results.add((String) values2);\r\n    else if (values2 instanceof String[]) {\r\n        String[] values = (String[]) values2;\r\n        for (int i = 0; i < values.length; i++) results.add(values[i]);\r\n    } else\r\n        results.add(values2.toString());\r\n    String[] values = new String[results.size()];\r\n    return results.toArray(values);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogLSN.lessThan",
	"Comment": "determines whether the target lsn is less than the parameter.",
	"Method": "boolean lessThan(LogLSN other){\r\n    return ((offset < other.offset && extent == other.extent) || extent < other.extent);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.remote.RemoteCLICommand.getManHabitat",
	"Comment": "return a servicelocator used just for reading man pages from the modulesin the modules directory.",
	"Method": "ServiceLocator getManHabitat(){\r\n    if (manServiceLocator != null)\r\n        return manServiceLocator;\r\n    ModulesRegistry registry = new StaticModulesRegistry(getModuleClassLoader());\r\n    manServiceLocator = registry.createServiceLocator(\"default\");\r\n    return manServiceLocator;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardEngineValve.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (info);\r\n}"
}, {
	"Path": "org.glassfish.internal.embedded.admin.CommandParameters.setOption",
	"Comment": "sets a command option as the user would specify it using thecli command for instance",
	"Method": "void setOption(String optionName,String optionValue){\r\n    params.set(optionName, optionValue);\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.SecurityConstraint.getAuthConstraint",
	"Comment": "gets the roles authorized to access the url patterns and http methods",
	"Method": "String[] getAuthConstraint(){\r\n    return this.roleNames;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.ServerConfigLookup.getInstanceSessionProperties",
	"Comment": "get the session properties bean from server.xmlreturn null if not defined or other problem",
	"Method": "SessionProperties getInstanceSessionProperties(){\r\n    if (configBean == null) {\r\n        return null;\r\n    }\r\n    WebContainer webContainerBean = configBean.getExtensionByType(WebContainer.class);\r\n    if (webContainerBean == null) {\r\n        return null;\r\n    }\r\n    SessionConfig sessionConfigBean = webContainerBean.getSessionConfig();\r\n    if (sessionConfigBean == null) {\r\n        return null;\r\n    }\r\n    return sessionConfigBean.getSessionProperties();\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteRestAdminCommand.refetchInvalidModel",
	"Comment": "if admin model is invalid, will be automatically refetched?",
	"Method": "boolean refetchInvalidModel(){\r\n    return true;\r\n}"
}, {
	"Path": "org.glassfish.api.admin.AdminCommandLock.resumeCommands",
	"Comment": "release the lock allowing the das to accept commands.this methodmay return before the lock is released.when the thread exits thelock will have been released.",
	"Method": "Thread resumeCommands(){\r\n    if (suspendCommandsLockThread == null || suspendCommandsLockThread.isAlive() == false || suspendCommandsLockThread.resumeCommandsSemaphore == null) {\r\n        return null;\r\n    }\r\n    suspendCommandsLockThread.resumeCommandsSemaphore.release();\r\n    return suspendCommandsLockThread;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RWLock.releaseWriteLock",
	"Comment": "this method is used to release a write lock. it also notifies any pendingreaders that they could now acquire the read lock. if there are no readerthreads then it will try to notify any waiting writer thread that it could nowacquire a write lock.",
	"Method": "void releaseWriteLock(){\r\n    --currentWriters;\r\n    if (pendingReaders > 0)\r\n        notifyReaders();\r\n    else\r\n        notifyWriters();\r\n}"
}, {
	"Path": "org.apache.catalina.realm.RealmBase.hasUserDataPermission",
	"Comment": "enforce any user data constraint required by the security constraintguarding this request uri.",
	"Method": "boolean hasUserDataPermission(HttpRequest request,HttpResponse response,SecurityConstraint[] constraints,boolean hasUserDataPermission,HttpRequest request,HttpResponse response,SecurityConstraint[] constraints,String uri,String method){\r\n    if (constraints == null || constraints.length == 0) {\r\n        if (log.isLoggable(Level.FINE))\r\n            log.log(Level.FINE, \"  No applicable security constraint defined\");\r\n        return (true);\r\n    }\r\n    for (int i = 0; i < constraints.length; i++) {\r\n        SecurityConstraint constraint = constraints[i];\r\n        String userConstraint = constraint.getUserConstraint();\r\n        if (userConstraint == null) {\r\n            if (log.isLoggable(Level.FINE))\r\n                log.log(Level.FINE, \"  No applicable user data constraint defined\");\r\n            return (true);\r\n        }\r\n        if (userConstraint.equals(Constants.NONE_TRANSPORT)) {\r\n            if (log.isLoggable(Level.FINE))\r\n                log.log(Level.FINE, \"  User data constraint has no restrictions\");\r\n            return (true);\r\n        }\r\n    }\r\n    if (request.getRequest().isSecure()) {\r\n        if (log.isLoggable(Level.FINE))\r\n            log.log(Level.FINE, \"  User data constraint already satisfied\");\r\n        return (true);\r\n    }\r\n    HttpServletRequest hrequest = (HttpServletRequest) request.getRequest();\r\n    HttpServletResponse hresponse = (HttpServletResponse) response.getResponse();\r\n    int redirectPort = request.getConnector().getRedirectPort();\r\n    if (redirectPort <= 0) {\r\n        if (log.isLoggable(Level.FINE))\r\n            log.log(Level.FINE, \"  SSL redirect is disabled\");\r\n        hresponse.sendError(HttpServletResponse.SC_FORBIDDEN);\r\n        response.setDetailMessage(hrequest.getRequestURI());\r\n        return (false);\r\n    }\r\n    StringBuilder file = new StringBuilder();\r\n    String protocol = \"https\";\r\n    String host = hrequest.getServerName();\r\n    file.append(protocol).append(\"://\").append(host);\r\n    if (redirectPort != 443) {\r\n        file.append(\":\").append(redirectPort);\r\n    }\r\n    file.append(hrequest.getRequestURI());\r\n    String requestedSessionId = hrequest.getRequestedSessionId();\r\n    if ((requestedSessionId != null) && hrequest.isRequestedSessionIdFromURL()) {\r\n        String sessionParameterName = ((request.getContext() != null) ? request.getContext().getSessionParameterName() : Globals.SESSION_PARAMETER_NAME);\r\n        file.append(\";\" + sessionParameterName + \"=\");\r\n        file.append(requestedSessionId);\r\n    }\r\n    String queryString = hrequest.getQueryString();\r\n    if (queryString != null) {\r\n        file.append('?');\r\n        file.append(queryString);\r\n    }\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \"Redirecting to \" + file.toString());\r\n    hresponse.sendRedirect(file.toString());\r\n    return (false);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.web.WebCheckMgrImpl.createTaglibDescriptors",
	"Comment": "create array of taglibdescriptors for all the jsp tag lib files definedin the war. set the array in the verifier context",
	"Method": "void createTaglibDescriptors(Descriptor descriptor){\r\n    TagLibFactory tlf = new TagLibFactory(context, verifierFrameworkContext);\r\n    tlds = tlf.getTagLibDescriptors((WebBundleDescriptor) descriptor);\r\n    if (tlds != null) {\r\n        context.setTagLibDescriptors(tlds);\r\n        setVerifierContext(context);\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.resources.WARDirContext.listBindings",
	"Comment": "enumerates the names bound in the named context, along with the objects bound to them. the contents of any subcontexts are not included.if a binding is added to or removed from this context, its effect on an enumeration previously returned is undefined.",
	"Method": "NamingEnumeration<Binding> listBindings(String name,NamingEnumeration<Binding> listBindings,Name name){\r\n    if (name.isEmpty())\r\n        return new NamingContextBindingsEnumeration(list(entries).iterator(), this);\r\n    Entry entry = treeLookup(name);\r\n    if (entry == null)\r\n        throw new NamingException(MessageFormat.format(rb.getString(LogFacade.RESOURCES_NOT_FOUND), name));\r\n    return new NamingContextBindingsEnumeration(list(entry).iterator(), this);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.ControlImpl.popControl",
	"Comment": "returns a reference to the stacked controlimpl if there is one, otherwisereturns a null reference.a value is returned that indicates the state of the transaction.if the transaction represented by the control object has been completed,the reference is still returned if possible.the stacked control object is removed from the stack.",
	"Method": "ControlImpl popControl(StatusHolder status){\r\n    ControlImpl result = null;\r\n    if (status != null)\r\n        status.value = tranState;\r\n    result = stacked;\r\n    stacked = null;\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityConstraint.getAuthConstraint",
	"Comment": "return the authorization constraint present flag for this securityconstraint.",
	"Method": "boolean getAuthConstraint(){\r\n    return (this.authConstraint);\r\n}"
}, {
	"Path": "org.glassfish.api.admin.AdminCommandLock.getLockTimeOfAcquisition",
	"Comment": "get the time the exclusive lock was acquired.this does notimply the lock is still held.",
	"Method": "Date getLockTimeOfAcquisition(){\r\n    return lockTimeOfAcquisition;\r\n}"
}, {
	"Path": "org.apache.catalina.loader.WebappLoader.stop",
	"Comment": "stop this component, finalizing our associated class loader.",
	"Method": "void stop(){\r\n    if (!started)\r\n        throw new LifecycleException(rb.getString(LogFacade.LOADER_NOT_STARTED_EXCEPTION));\r\n    if (log.isLoggable(Level.FINEST))\r\n        log.log(Level.FINEST, \"Stopping this Loader\");\r\n    lifecycle.fireLifecycleEvent(STOP_EVENT, null);\r\n    started = false;\r\n    if (container instanceof Context) {\r\n        ServletContext servletContext = ((Context) container).getServletContext();\r\n        servletContext.removeAttribute(Globals.CLASS_PATH_ATTR);\r\n    }\r\n    stopNestedClassLoader();\r\n    DirContextURLStreamHandler.unbind(classLoader);\r\n    classLoader = null;\r\n    destroy();\r\n}"
}, {
	"Path": "org.apache.catalina.startup.PasswdUserDatabase.getUserConfig",
	"Comment": "return the userconfig listener with which we are associated.",
	"Method": "UserConfig getUserConfig(){\r\n    return (this.userConfig);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.DefaultAccessLogFormatterImpl.appendQueryString",
	"Comment": "appends the query string of the given request to the given char buffer.",
	"Method": "void appendQueryString(CharBuffer cb,HttpServletRequest hreq){\r\n    cb.put(QUOTE);\r\n    String query = hreq.getQueryString();\r\n    if (query == null) {\r\n        query = \"NULL-QUERY\";\r\n    }\r\n    cb.put(query);\r\n    cb.put(QUOTE);\r\n}"
}, {
	"Path": "org.apache.naming.SelectorContext.removeFromEnvironment",
	"Comment": "removes an environment property from the environment of this context.",
	"Method": "Object removeFromEnvironment(String propName){\r\n    return getBoundContext().removeFromEnvironment(propName);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.elements.MethodPermissionSecurityRoleExists.check",
	"Comment": "security role used in method permission element must be defined in the roles element of the deployment descriptor.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    Map permissionedMethods = descriptor.getPermissionedMethodsByPermission();\r\n    boolean oneFailed = false;\r\n    if (permissionedMethods.size() > 0) {\r\n        for (Iterator e = permissionedMethods.keySet().iterator(); e.hasNext(); ) {\r\n            MethodPermission nextPermission = (MethodPermission) e.next();\r\n            if (nextPermission.isRoleBased()) {\r\n                if (!descriptor.getEjbBundleDescriptor().getRoles().contains(nextPermission.getRole())) {\r\n                    oneFailed = true;\r\n                    result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                    result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Method permissions role [ {0} ] must be one of the roles defined in bean [ {1} ]\", new Object[] { nextPermission.getRole().getName(), descriptor.getName() }));\r\n                } else {\r\n                    result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                    result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"Valid: Method permissions role [ {0} ] is defined as one of the roles defined in bean [ {1} ]\", new Object[] { nextPermission.getRole().getName(), descriptor.getName() }));\r\n                }\r\n            } else {\r\n                addNaDetails(result, compName);\r\n                result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable1\", \"There are no role based method-permissions within this bean [ {0} ]\", new Object[] { descriptor.getName() }));\r\n            }\r\n        }\r\n        if (oneFailed) {\r\n            result.setStatus(Result.FAILED);\r\n        } else {\r\n            if (result.getStatus() != Result.NOT_APPLICABLE)\r\n                result.setStatus(Result.PASSED);\r\n        }\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"There are no <method-permission> elements within this bean [ {0} ]\", new Object[] { descriptor.getName() }));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.core.proxy.ProxyFactory.toProxySet",
	"Comment": "convert a set of objectname to a set of amx. the resulting set may besmaller than the original if, for example, some mbeans are no longerregistered.",
	"Method": "Set<AMXProxy> toProxySet(Set<ObjectName> objectNames,Set<AMXProxy> toProxySet,ObjectName[] objectNames,Class<? extends AMXProxy> intf){\r\n    final Set<AMXProxy> result = new HashSet<AMXProxy>();\r\n    for (final ObjectName objectName : objectNames) {\r\n        final AMXProxy proxy = getProxy(objectName, intf);\r\n        if (proxy != null) {\r\n            result.add(proxy);\r\n        }\r\n    }\r\n    return (result);\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.NonLoginAuthenticator.authenticate",
	"Comment": "authenticate the user making this request, based on the specifiedlogin configuration.return true if any specifiedconstraint has been satisfied, or false if we havecreated a response challenge already.",
	"Method": "boolean authenticate(HttpRequest request,HttpResponse response,LoginConfig config){\r\n    if (debug >= 1)\r\n        log(\"User authentication is not required\");\r\n    HttpServletRequest hreq = (HttpServletRequest) request.getRequest();\r\n    if (hreq.getUserPrincipal() == null) {\r\n        request.setUserPrincipal(NONLOGIN_PRINCIPAL);\r\n    }\r\n    return (true);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.stringsubs.impl.algorithm.TestRadixTreeSubstitution.testLastWordExactlyMatched",
	"Comment": "test if the last word in the input string matched completely.",
	"Method": "void testLastWordExactlyMatched(){\r\n    assertEquals(callSubstitution(\"  aci so abet ... &&& soft\"), \"  aci so abetVal ... &&& softVal\");\r\n}"
}, {
	"Path": "com.sun.enterprise.universal.glassfish.ASenvPropertyReader.getProps",
	"Comment": "returns the properties that were processed.this includes going to a bit oftrouble setting up the hostname and java root.",
	"Method": "Map<String, String> getProps(){\r\n    return props;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorLog.formatLogRecords",
	"Comment": "formats the information in all sections of the coordinatorlog.the formatted information is written to the log.this internal method does not need to be synchronized.if the rewrite flag is not set, only information that has not already beenwritten is formatted, otherwise all information is formatted.",
	"Method": "boolean formatLogRecords(boolean forced){\r\n    if (logPath == null)\r\n        openLog();\r\n    else\r\n        openLog(logPath);\r\n    if (logStateHolder.logFile == null) {\r\n        return false;\r\n    }\r\n    boolean result = false;\r\n    try {\r\n        logStateHolder.keypointLock.acquireReadLock();\r\n        synchronized (this) {\r\n            byteOutput.reset();\r\n            dataOutput.writeLong(localTID.longValue());\r\n            dataOutput.writeShort(sectionMapping.size());\r\n            Enumeration sections = sectionMapping.elements();\r\n            int sz = sectionMapping.size();\r\n            while (sz-- > 0) {\r\n                formatSection((CoordinatorLogSection) sections.nextElement(), rewriteRequired, dataOutput);\r\n            }\r\n            result = logStateHolder.logFile.write(forced ? LogFile.FORCED : LogFile.UNFORCED, byteOutput.toByteArray(), rewriteRequired ? LogFile.REWRITE : LogFile.NORMAL, null);\r\n            rewriteRequired = false;\r\n            writeDone = true;\r\n        }\r\n    } finally {\r\n        logStateHolder.keypointLock.releaseReadLock();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.DefaultAccessLogFormatterImpl.appendResponseContentType",
	"Comment": "appends the content type of the given response to the given charbuffer.",
	"Method": "void appendResponseContentType(CharBuffer cb,Response response){\r\n    cb.put(response.getContentType());\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.getTerminator",
	"Comment": "gets the object normally responsible for terminating this coordinator.",
	"Method": "CompletionHandler getTerminator(){\r\n    CompletionHandler result = terminator;\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.LocalInterfaceExposed.check",
	"Comment": "bean interface type test.the bean provider must provide either local or remote or both interfaces",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!(descriptor instanceof EjbSessionDescriptor) && !(descriptor instanceof EjbEntityDescriptor)) {\r\n        addNaDetails(result, compName);\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable1\", \"Test apply only to session or entity beans.\"));\r\n        return result;\r\n    }\r\n    EjbBundleDescriptorImpl bundle = descriptor.getEjbBundleDescriptor();\r\n    Iterator<EjbDescriptor> iterator = (bundle.getEjbs()).iterator();\r\n    Set<String> localInterfaces = new HashSet<String>();\r\n    while (iterator.hasNext()) {\r\n        EjbDescriptor entity = iterator.next();\r\n        if (entity.getLocalClassName() != null)\r\n            localInterfaces.add(entity.getLocalClassName());\r\n        localInterfaces.addAll(entity.getLocalBusinessClassNames());\r\n    }\r\n    ClassLoader jcl = getVerifierContext().getClassLoader();\r\n    try {\r\n        Set<String> remoteInterfaces = new HashSet<String>();\r\n        if (descriptor.getRemoteClassName() != null)\r\n            remoteInterfaces.add(descriptor.getRemoteClassName());\r\n        remoteInterfaces.addAll(descriptor.getRemoteBusinessClassNames());\r\n        for (String intf : remoteInterfaces) {\r\n            Class c = Class.forName(intf, false, getVerifierContext().getClassLoader());\r\n            Method[] methods = c.getDeclaredMethods();\r\n            for (int i = 0; i < methods.length; i++) {\r\n                for (Iterator itr = localInterfaces.iterator(); itr.hasNext(); ) {\r\n                    String localIntf = (String) itr.next();\r\n                    Class returnType = methods[i].getReturnType();\r\n                    if ((getBaseComponentType(returnType).getName()).equals(localIntf) || (contains(methods[i].getParameterTypes(), localIntf))) {\r\n                        addErrorDetails(result, compName);\r\n                        result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error : Local Interface [ {0} ] has been \" + \"exposed in remote interface [ {1} ]\", new Object[] { localIntf, c.getName() }));\r\n                        return result;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        addGoodDetails(result, compName);\r\n        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"Valid Remote interface.\"));\r\n    } catch (ClassNotFoundException e) {\r\n        Verifier.debug(e);\r\n        addErrorDetails(result, compName);\r\n        result.failed(smh.getLocalString(getClass().getName() + \".failedException\", \"Error: [ {0} ] class not found.\", new Object[] { descriptor.getRemoteClassName() }));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.parseSessionVersionString",
	"Comment": "parses the given session version string into its components. eachcomponent is stored as an entry in a hashmap, which maps a contextpath to its session version number. the hashmap is stored as a request attribute, to make it available to any target contexts to whichthis request may be dispatched.this method also sets the session version number for the context withwhich this request has been associated.",
	"Method": "void parseSessionVersionString(String sessionVersionString){\r\n    if (sessionVersionString == null || !isSessionVersioningSupported()) {\r\n        return;\r\n    }\r\n    HashMap<String, String> sessionVersions = RequestUtil.parseSessionVersionString(sessionVersionString);\r\n    if (sessionVersions != null) {\r\n        attributes.put(Globals.SESSION_VERSIONS_REQUEST_ATTRIBUTE, sessionVersions);\r\n        if (context != null) {\r\n            String path = context.getPath();\r\n            if (\"\".equals(path)) {\r\n                path = \"/\";\r\n            }\r\n            this.requestedSessionVersion = sessionVersions.get(path);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.launcher.GFLauncher.needsAutoUpgrade",
	"Comment": "does this domain need to be automatically upgraded before it can bestarted?",
	"Method": "boolean needsAutoUpgrade(){\r\n    return needsAutoUpgrade;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardService.findConnectors",
	"Comment": "find and return the set of connectors associated with this service.",
	"Method": "Connector[] findConnectors(){\r\n    return (connectors);\r\n}"
}, {
	"Path": "org.glassfish.weld.connector.WeldSniffer.handles",
	"Comment": "returns true if the archive contains beans.xml as defined by packaging rules of weld",
	"Method": "boolean handles(DeploymentContext context){\r\n    ArchiveType archiveType = habitat.getService(ArchiveType.class, context.getArchiveHandler().getArchiveType());\r\n    if (archiveType != null && !supportsArchiveType(archiveType)) {\r\n        return false;\r\n    }\r\n    ReadableArchive archive = context.getSource();\r\n    boolean isWeldArchive = false;\r\n    if (isEntryPresent(archive, WeldUtils.WEB_INF)) {\r\n        isWeldArchive = isArchiveCDIEnabled(context, archive, WeldUtils.WEB_INF_BEANS_XML) || isArchiveCDIEnabled(context, archive, WeldUtils.WEB_INF_CLASSES_META_INF_BEANS_XML);\r\n        if (!isWeldArchive) {\r\n            if (isEntryPresent(archive, WeldUtils.WEB_INF_LIB)) {\r\n                isWeldArchive = scanLibDir(context, archive, WeldUtils.WEB_INF_LIB);\r\n            }\r\n        }\r\n    }\r\n    String archiveName = archive.getName();\r\n    if (!isWeldArchive && archiveName != null && archiveName.endsWith(WeldUtils.EXPANDED_JAR_SUFFIX)) {\r\n        isWeldArchive = isArchiveCDIEnabled(context, archive, WeldUtils.META_INF_BEANS_XML);\r\n    }\r\n    if (!isWeldArchive && isArchiveCDIEnabled(context, archive, WeldUtils.META_INF_BEANS_XML)) {\r\n        isWeldArchive = true;\r\n    }\r\n    if (!isWeldArchive && archiveName != null && archiveName.endsWith(WeldUtils.EXPANDED_RAR_SUFFIX)) {\r\n        isWeldArchive = isArchiveCDIEnabled(context, archive, WeldUtils.META_INF_BEANS_XML);\r\n        if (!isWeldArchive) {\r\n            isWeldArchive = scanLibDir(context, archive, \"\");\r\n        }\r\n    }\r\n    return isWeldArchive;\r\n}"
}, {
	"Path": "com.sun.enterprise.config.modularity.ConfigModularityUtils.getMatchingGetterMethod",
	"Comment": "find a suitable getter method in the given class. the returned method represent a method that will return back a type ofmethodreturntype.",
	"Method": "Method getMatchingGetterMethod(Class classToQuery,Class methodReturnType){\r\n    Method[] methods = classToQuery.getMethods();\r\n    for (Method method : methods) {\r\n        Class<?> rt = method.getReturnType();\r\n        if (rt != null && methodReturnType != null) {\r\n            if (rt.getSimpleName().equals(methodReturnType.getSimpleName())) {\r\n                return method;\r\n            }\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.flashlight.impl.core.ProviderSubClassImplGenerator.createSubClassLoader",
	"Comment": "byron nevins feb 2012 findbugs fixhide this ugly access control code in this method",
	"Method": "SubClassLoader createSubClassLoader(Class theClass){\r\n    try {\r\n        return AccessController.doPrivileged(new PrivilegedExceptionAction<SubClassLoader>() {\r\n            @Override\r\n            public SubClassLoader run() throws Exception {\r\n                return new SubClassLoader(theClass.getClassLoader());\r\n            }\r\n        });\r\n    } catch (Exception e) {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.flashlight.impl.core.ProviderSubClassImplGenerator.createSubClassLoader",
	"Comment": "byron nevins feb 2012 findbugs fixhide this ugly access control code in this method",
	"Method": "SubClassLoader createSubClassLoader(Class theClass){\r\n    return new SubClassLoader(theClass.getClassLoader());\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutoDeployer.cancel",
	"Comment": "set cancel flag, whichwill ensure that only if there is any current deployment is in process,it will be completed but the deployer will not do any more deployment.",
	"Method": "void cancel(boolean value){\r\n    cancelDeployment = value;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityConstraint.findAuthRole",
	"Comment": "return true if the specified role is permitted access tothe resources protected by this security constraint.",
	"Method": "boolean findAuthRole(String role){\r\n    if (role == null)\r\n        return (false);\r\n    for (int i = 0; i < authRoles.length; i++) {\r\n        if (role.equals(authRoles[i]))\r\n            return (true);\r\n    }\r\n    return (false);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.intf.InterfaceClassExist.check",
	"Comment": "local interface test.verify that the bean remote or local interface class exist and is loadable.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!(descriptor instanceof EjbSessionDescriptor) && !(descriptor instanceof EjbEntityDescriptor)) {\r\n        addNaDetails(result, compName);\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.intf.InterfaceClassExist.notApplicable1\", \"Test apply only to session or entity beans.\"));\r\n        return result;\r\n    }\r\n    if (getInterfaceName(descriptor) == null || \"\".equals(getInterfaceName(descriptor))) {\r\n        addNaDetails(result, compName);\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.intf.InterfaceClassExist.notApplicable2\", \"Not Applicable because, EJB [ {0} ] does not have {1} Interface.\", new Object[] { descriptor.getEjbClassName(), getInterfaceType() }));\r\n        return result;\r\n    }\r\n    try {\r\n        ClassLoader jcl = getVerifierContext().getClassLoader();\r\n        Class c = Class.forName(getClassName(descriptor), false, jcl);\r\n        if (!c.isInterface()) {\r\n            addErrorDetails(result, compName);\r\n            result.failed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.intf.InterfaceClassExist.failed\", \"[ {0} ] is defined as a class. It should be an interface.\", new Object[] { getClassName(descriptor) }));\r\n        }\r\n    } catch (ClassNotFoundException e) {\r\n        Verifier.debug(e);\r\n        addErrorDetails(result, compName);\r\n        result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: \" + getInterfaceType() + \" interface [ {0} ] does not exist or is not loadable.\", new Object[] { getClassName(descriptor) }));\r\n    }\r\n    if (result.getStatus() != Result.FAILED) {\r\n        addGoodDetails(result, compName);\r\n        result.passed(smh.getLocalString(getClass().getName() + \".passed\", getInterfaceType() + \" interface [ {0} ] exist and is loadable.\", new Object[] { getClassName(descriptor) }));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentImpl.suspend",
	"Comment": "disassociates the current controlimpl from the calling thread.",
	"Method": "Control suspend(){\r\n    Control result = null;\r\n    ControlImpl cImpl = CurrentTransaction.endCurrent(false);\r\n    if (_logger.isLoggable(Level.FINEST)) {\r\n        _logger.logp(Level.FINEST, \"CurrentImpl\", \"suspend()\", \"Current thread has been disassociated from control :\" + cImpl);\r\n    }\r\n    if (Configuration.isLocalFactory()) {\r\n        result = (Control) cImpl;\r\n    } else {\r\n        if (cImpl != null) {\r\n            result = cImpl.object();\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.NestingInfo.isDescendant",
	"Comment": "determines whether the coordinator containing the nestinginfo object isa descendant of the other coordinator.this is true if the other coordinator is the sameas one of the ancestors.",
	"Method": "boolean isDescendant(Coordinator other){\r\n    boolean result = false;\r\n    try {\r\n        for (int i = 0; i < ancestorSeq.length && !result; i++) {\r\n            result = ancestorSeq[i].is_same_transaction(other);\r\n        }\r\n    } catch (SystemException exc) {\r\n        result = false;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.DeploymentUtils.generatedArtifacts",
	"Comment": "returns the generated artifacts object derived from the propertiessaved with the specified application",
	"Method": "Artifacts generatedArtifacts(DeploymentContext dc,Artifacts generatedArtifacts,Application app){\r\n    return Artifacts.get(app.getDeployProperties(), GENERATED_ARTIFACTS_KEY_PREFIX);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.PEAccessLogValve.getInfo",
	"Comment": "return descriptive information about this implementation.",
	"Method": "String getInfo(){\r\n    return info;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.rollback_only",
	"Comment": "ensures that the transaction represented by the target topcoordinatorcannot be committed.",
	"Method": "void rollback_only(){\r\n    if (tranState == null || tranState.state != TransactionState.STATE_ACTIVE) {\r\n        Inactive exc = new Inactive();\r\n        throw exc;\r\n    } else {\r\n        rollbackOnly = true;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.glassfish.bootstrap.osgi.OSGiFrameworkLauncher.isOSGiEnv",
	"Comment": "determine if we we are operating in osgi env. we do this by checking what class loader is used tothis class.",
	"Method": "boolean isOSGiEnv(){\r\n    return (getClass().getClassLoader() instanceof BundleReference);\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.ParameterParser.parseToken",
	"Comment": "parses out a token until any of the given terminatorsis encountered.",
	"Method": "String parseToken(char[] terminators){\r\n    char ch;\r\n    i1 = pos;\r\n    i2 = pos;\r\n    while (hasChar()) {\r\n        ch = chars[pos];\r\n        if (isOneOf(ch, terminators)) {\r\n            break;\r\n        }\r\n        i2++;\r\n        pos++;\r\n    }\r\n    return getToken(false);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.ejb.EjbCheckMgrImpl.getTestsListFileName",
	"Comment": "return the configuration file name for the list of tests pertinent to theconnector architecture",
	"Method": "String getTestsListFileName(){\r\n    return testsListFileName;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.beanclass.EjbClassModifiersPublic.check",
	"Comment": "enterprise java bean class modifiers test.the class must be defined as public.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    Class c = loadEjbClass(descriptor, result);\r\n    if (c != null) {\r\n        boolean isPublic = false;\r\n        int modifiers = c.getModifiers();\r\n        if (Modifier.isPublic(modifiers)) {\r\n            isPublic = true;\r\n        }\r\n        if (isPublic) {\r\n            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"[ {0} ] properly declares public class modifier.\", new Object[] { descriptor.getEjbClassName() }));\r\n        } else if (!isPublic) {\r\n            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Ejb Class [ {0} ] was found, but was not declared as public.  The class  [ {1} ] must be defined as public.\", new Object[] { descriptor.getEjbClassName(), descriptor.getEjbClassName() }));\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.XATerminatorImpl.recover",
	"Comment": "obtains a list of prepared transaction branches from a resourcemanager. the transaction manager calls this method during recoveryto obtain the list of transaction branches that are currently inprepared or heuristically completed states.",
	"Method": "Xid[] recover(int flag){\r\n    RecoveryManager.waitForResync();\r\n    return (Xid[]) TimeoutManager.getInDoubtXids();\r\n}"
}, {
	"Path": "org.apache.catalina.session.PersistentManagerBase.removeFromInvalidatedSessions",
	"Comment": "removes the given session id from the map of invalidated session ids.",
	"Method": "void removeFromInvalidatedSessions(String sessionId){\r\n    invalidatedSessions.remove(sessionId);\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.annotation.impl.WarScanner.scanXmlDefinedClassesIfNecessary",
	"Comment": "in web.xml additionally if those classes are not resided in the wars.",
	"Method": "void scanXmlDefinedClassesIfNecessary(WebBundleDescriptor webBundleDesc){\r\n    ClassLoader commonCL = clh.getCommonClassLoader();\r\n    for (Iterator webComponents = webBundleDesc.getWebComponentDescriptors().iterator(); webComponents.hasNext(); ) {\r\n        WebComponentDescriptor webCompDesc = (WebComponentDescriptor) webComponents.next();\r\n        if (webCompDesc.isServlet()) {\r\n            String servletName = webCompDesc.getWebComponentImplementation();\r\n            if (isScan(servletName, commonCL)) {\r\n                addScanClassName(servletName);\r\n            }\r\n        }\r\n    }\r\n    Vector servletFilters = webBundleDesc.getServletFilters();\r\n    for (int i = 0; i < servletFilters.size(); i++) {\r\n        ServletFilter filter = (ServletFilter) servletFilters.elementAt(i);\r\n        String filterName = filter.getClassName();\r\n        if (isScan(filterName, commonCL)) {\r\n            addScanClassName(filter.getClassName());\r\n        }\r\n    }\r\n    Vector listeners = webBundleDesc.getAppListenerDescriptors();\r\n    for (int j = 0; j < listeners.size(); j++) {\r\n        AppListenerDescriptor listenerDesc = (AppListenerDescriptor) listeners.elementAt(j);\r\n        String listenerName = listenerDesc.getListener();\r\n        if (isScan(listenerName, commonCL)) {\r\n            addScanClassName(listenerDesc.getListener());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.JavaEETransactionImpl.getRemainingTimeout",
	"Comment": "return duration in seconds before transaction would timeout.returns zero if this transaction has no timeout set.returns negative value if already timed out.",
	"Method": "int getRemainingTimeout(){\r\n    if (timeout == 0) {\r\n        return timeout;\r\n    } else if (timedOut) {\r\n        return -1;\r\n    } else {\r\n        return timeout - (int) ((System.currentTimeMillis() - startTime) / 1000L);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.valves.JDBCAccessLogValve.stop",
	"Comment": "invoked by tomcat on shutdown. the database connection is closed here.",
	"Method": "void stop(){\r\n    if (!started)\r\n        return;\r\n    try {\r\n        if (ps != null)\r\n            ps.close();\r\n        if (conn != null)\r\n            conn.close();\r\n    } catch (SQLException e) {\r\n        throw new LifecycleException(e);\r\n    }\r\n    super.stop();\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.messagebean.ImplementsMessageDrivenBean.check",
	"Comment": "run a verifier test against an individual declared messagedrive bean component",
	"Method": "Result check(EjbMessageBeanDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    Class mbc = loadMessageBeanClass(descriptor, result);\r\n    testImplementationOf(mbc, \"javax.ejb.MessageDrivenBean\", result);\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.appserv.web.taglibs.cache.CacheTag.setRefresh",
	"Comment": "this attribute is used to programmatically refresh the cachedresponse.if refresh is true, the cached response is not sent, instead thetag body is evaluated and sent and the cache is refreshed with thenew response.",
	"Method": "void setRefresh(boolean refresh){\r\n    _refreshCache = refresh;\r\n}"
}, {
	"Path": "org.apache.naming.resources.DirContextURLStreamHandler.openConnection",
	"Comment": "opens a connection to the object referenced by the url argument.",
	"Method": "URLConnection openConnection(URL u){\r\n    DirContext currentContext = this.context;\r\n    if (currentContext == null)\r\n        currentContext = get();\r\n    return new DirContextURLConnection(currentContext, u);\r\n}"
}, {
	"Path": "org.apache.catalina.util.StringParser.setString",
	"Comment": "set the string we are currently parsing.the parser state is also resetto begin at the start of this string.",
	"Method": "void setString(String string){\r\n    this.string = string;\r\n    if (string != null) {\r\n        this.length = string.length();\r\n        chars = this.string.toCharArray();\r\n    } else {\r\n        this.length = 0;\r\n        chars = new char[0];\r\n    }\r\n    reset();\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.remote.DASUtils.pingDASQuietly",
	"Comment": "see if das is alive.do not print out the results of the version command from the server.",
	"Method": "boolean pingDASQuietly(ProgramOptions programOpts,Environment env){\r\n    try {\r\n        RemoteCLICommand cmd = new RemoteCLICommand(\"version\", programOpts, env);\r\n        cmd.executeAndReturnOutput(new String[] { \"version\" });\r\n        return true;\r\n    } catch (AuthenticationException aex) {\r\n        return true;\r\n    } catch (Exception ex) {\r\n        ExceptionAnalyzer ea = new ExceptionAnalyzer(ex);\r\n        if (ea.getFirstInstanceOf(ConnectException.class) != null) {\r\n            logger.finer(\"Got java.net.ConnectException\");\r\n            return false;\r\n        } else if (ea.getFirstInstanceOf(IOException.class) != null) {\r\n            if (logger.isLoggable(Level.FINER))\r\n                logger.finer(\"It appears that server has started, but for\" + \" some reason this exception was thrown: \" + ex.getMessage());\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.ThresholdingOutputStream.getByteCount",
	"Comment": "returns the number of bytes that have been written to this output stream.",
	"Method": "long getByteCount(){\r\n    return written;\r\n}"
}, {
	"Path": "components.model.Graph.removeNode",
	"Comment": "deregister the specified node, as well as all child nodes of thisnode, from our registry of the complete tree.if this node is notpresent, no action is taken.",
	"Method": "void removeNode(Node node){\r\n    synchronized (registry) {\r\n        Iterator nodeItr = node.getChildren();\r\n        while (nodeItr.hasNext()) {\r\n            removeNode((Node) nodeItr.next());\r\n        }\r\n        node.setParent(null);\r\n        node.setGraph(null);\r\n        if (node == this.root) {\r\n            this.root = null;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.util.Utility.convertByteArrayToCharArray",
	"Comment": "convert the byte array to char array with respect to given charset.",
	"Method": "char[] convertByteArrayToCharArray(byte[] byteArray,String charset){\r\n    if (byteArray == null) {\r\n        return null;\r\n    }\r\n    byte[] bArray = (byte[]) byteArray.clone();\r\n    ByteBuffer byteBuffer = ByteBuffer.wrap(bArray);\r\n    Charset charSet;\r\n    if (charset == null || \"\".equals(charset)) {\r\n        charSet = Charset.defaultCharset();\r\n    } else if (Charset.isSupported(charset)) {\r\n        charSet = Charset.forName(charset);\r\n    } else {\r\n        CharacterCodingException e = new CharacterCodingException();\r\n        e.initCause(new UnsupportedCharsetException(charset));\r\n        throw e;\r\n    }\r\n    CharsetDecoder decoder = charSet.newDecoder();\r\n    CharBuffer charBuffer = null;\r\n    try {\r\n        charBuffer = decoder.decode(byteBuffer);\r\n    } catch (CharacterCodingException cce) {\r\n        throw cce;\r\n    } catch (Throwable t) {\r\n        CharacterCodingException e = new CharacterCodingException();\r\n        e.initCause(t);\r\n        throw e;\r\n    }\r\n    char[] result = toCharArray(charBuffer);\r\n    clear(byteBuffer);\r\n    clear(charBuffer);\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.web.embed.impl.EmbeddedWebEntityResolver.__resolveEntity",
	"Comment": "try to fetch dtd from installroot. copied from org.glassfish.web.webentityresolver",
	"Method": "InputSource __resolveEntity(String publicId,String systemId){\r\n    String fileName = knownDTDs.get(publicId);\r\n    if (fileName != null && dtdDir != null) {\r\n        File dtd = new File(dtdDir, fileName);\r\n        if (dtd.exists()) {\r\n            return new InputSource(dtd.toURI().toString());\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.CreateNodeSshCommand.checkDefaults",
	"Comment": "sometimes the console passes an empty string for a parameter. thismakes sure those are defaulted correctly.",
	"Method": "void checkDefaults(){\r\n    super.checkDefaults();\r\n    if (!StringUtils.ok(remotePort)) {\r\n        remotePort = NodeUtils.NODE_DEFAULT_SSH_PORT;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.jta.UserTransactionImpl.getStatus",
	"Comment": "obtain the status of the transaction associated with the current thread.",
	"Method": "int getStatus(){\r\n    if (transactionManager == null)\r\n        init();\r\n    return this.transactionManager.getStatus();\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.Descriptor.getDescriptorExtension",
	"Comment": "get child descriptor extension for a given type.it is a convenience api to get the single child extension descriptor if the xml element it represents can only occur once.returns that single descriptor if the xml element that the given type represents can only occur once.returns the first element of the list of descriptors if the xml element that the given type represents can occur multiple times.",
	"Method": "T getDescriptorExtension(Class<T> c){\r\n    List<T> descriptorList = (List<T>) descriptorExtensions.get(c);\r\n    if (descriptorList == null || descriptorList.isEmpty()) {\r\n        return null;\r\n    } else {\r\n        return descriptorList.get(0);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.removeSecurityReference",
	"Comment": "remove any security role reference for the specified role name.",
	"Method": "void removeSecurityReference(String name){\r\n    synchronized (references) {\r\n        references.remove(name);\r\n    }\r\n    if (notifyContainerListeners) {\r\n        fireContainerEvent(\"removeSecurityReference\", name);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.util.LocalStringManagerImpl.getLocalString",
	"Comment": "get a local string from the package of the default class andformat the arguments accordingly.",
	"Method": "String getLocalString(Class callerClass,String key,String defaultValue,String getLocalString,String key,String defaultValue,String getLocalString,Class callerClass,String key,String defaultFormat,Object arguments,String getLocalString,String key,String defaultFormat,Object arguments){\r\n    return getLocalString(null, key, defaultFormat, arguments);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.ServerRemoteRestAdminCommand.addAdditionalHeaders",
	"Comment": "adds the admin indicator header to the request so. do this whether secure admin is enabled or not, because the indicator is unique amongdomains to help make sure only processes in the same domain talk to each other.",
	"Method": "void addAdditionalHeaders(URLConnection urlConnection){\r\n    final String indicatorValue = SecureAdmin.Util.configuredAdminIndicator(secureAdmin);\r\n    if (indicatorValue != null) {\r\n        urlConnection.setRequestProperty(SecureAdmin.Util.ADMIN_INDICATOR_HEADER_NAME, indicatorValue);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ReplicationAttributeStore.valveSave",
	"Comment": "save the specified session into this store.any previously savedinformation for the associated session identifier is replaced.",
	"Method": "void valveSave(Session session){\r\n    if (!(session instanceof HASession)) {\r\n        return;\r\n    }\r\n    HASession haSess = (HASession) session;\r\n    if (haSess.isPersistent() && !haSess.isDirty()) {\r\n        this.updateLastAccessTime(session);\r\n    } else {\r\n        this.doValveSave(session);\r\n        haSess.setPersistent(true);\r\n    }\r\n    haSess.setDirty(false);\r\n}"
}, {
	"Path": "org.glassfish.flashlight.statistics.impl.CounterImpl.getSampleTime",
	"Comment": "tbdthis is an inefficient implementation. should schedule a timer taskthat gets a timeout event every 30s or so and updates this value",
	"Method": "long getSampleTime(){\r\n    return System.currentTimeMillis();\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.addWatchedResource",
	"Comment": "add a new watched resource to the set recognized by this context.",
	"Method": "void addWatchedResource(String name){\r\n    watchedResources.add(name);\r\n    fireContainerEvent(\"addWatchedResource\", name);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getAttributeNames",
	"Comment": "return the names of all request attributes for this request, or anempty enumeration if there are none.",
	"Method": "Enumeration<String> getAttributeNames(){\r\n    if (isSecure()) {\r\n        populateSSLAttributes();\r\n    }\r\n    return new Enumerator<String>(attributes.keySet(), true);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getSessionCookieConfig",
	"Comment": "gets the sessioncookieconfig object through which variousproperties of the session tracking cookies created on behalf of thisservletcontext may be configured.",
	"Method": "SessionCookieConfig getSessionCookieConfig(){\r\n    if (isRestricted) {\r\n        throw new UnsupportedOperationException(rb.getString(LogFacade.UNSUPPORTED_OPERATION_EXCEPTION));\r\n    }\r\n    return context.getSessionCookieConfig();\r\n}"
}, {
	"Path": "org.apache.naming.ResourceEnvRef.getFactoryClassName",
	"Comment": "retrieves the class name of the factory of the object to which this reference refers.",
	"Method": "String getFactoryClassName(){\r\n    String factory = super.getFactoryClassName();\r\n    if (factory != null) {\r\n        return factory;\r\n    } else {\r\n        factory = System.getProperty(Context.OBJECT_FACTORIES);\r\n        if (factory != null) {\r\n            return null;\r\n        } else {\r\n            return DEFAULT_FACTORY;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModuleConfig.getContextPath",
	"Comment": "return the context path at which the web application is deployed.",
	"Method": "String getContextPath(){\r\n    String ctxPath = null;\r\n    if (_wbd != null) {\r\n        ctxPath = _wbd.getContextRoot().trim();\r\n        if ((ctxPath.length() > 0) && !ctxPath.startsWith(\"/\")) {\r\n            ctxPath = \"/\" + ctxPath;\r\n        } else if (ctxPath.equals(\"/\")) {\r\n            ctxPath = \"\";\r\n        }\r\n    }\r\n    return ctxPath;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.launcher.GFLauncher.getProcessStreamDrainer",
	"Comment": "a processstreamdrainer is always attached to every process created here.it is handy for getting the stdin and stdout as a nice string.",
	"Method": "ProcessStreamDrainer getProcessStreamDrainer(){\r\n    if (psd == null)\r\n        throw new GFLauncherException(\"invalid_psd\");\r\n    return psd;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.ControlImpl.isAssociated",
	"Comment": "this operation returns a value which indicates that this controlimpl instanceis associated with one or more threads.",
	"Method": "boolean isAssociated(){\r\n    boolean result = (association != 0);\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.server.logging.GFFileHandler.rotate",
	"Comment": "a simple rotate method to close the old file and start the new onewhen the limit is reached.",
	"Method": "void rotate(){\r\n    final GFFileHandler thisInstance = this;\r\n    java.security.AccessController.doPrivileged(new java.security.PrivilegedAction() {\r\n        public Object run() {\r\n            synchronized (thisInstance.rotationLock) {\r\n                if (thisInstance.meter != null && thisInstance.meter.written <= 0) {\r\n                    return null;\r\n                }\r\n                thisInstance.flush();\r\n                thisInstance.close();\r\n                try {\r\n                    if (!absoluteFile.exists()) {\r\n                        File creatingDeletedLogFile = new File(absoluteFile.getAbsolutePath());\r\n                        if (creatingDeletedLogFile.createNewFile()) {\r\n                            absoluteFile = creatingDeletedLogFile;\r\n                        }\r\n                    } else {\r\n                        File oldFile = absoluteFile;\r\n                        StringBuffer renamedFileName = new StringBuffer(absoluteFile + \"_\");\r\n                        logRotateDateFormatter.format(new Date(), renamedFileName, new FieldPosition(0));\r\n                        File rotatedFile = new File(renamedFileName.toString());\r\n                        boolean renameSuccess = oldFile.renameTo(rotatedFile);\r\n                        if (!renameSuccess) {\r\n                            FileUtils.copy(absoluteFile, rotatedFile);\r\n                            File freshServerLogFile = getLogFileName();\r\n                            FileOutputStream fo = new FileOutputStream(freshServerLogFile);\r\n                            fo.close();\r\n                        }\r\n                        FileOutputStream oldFileFO = new FileOutputStream(oldFile);\r\n                        oldFileFO.close();\r\n                        openFile(getLogFileName());\r\n                        absoluteFile = getLogFileName();\r\n                        if (dayBasedFileRotation) {\r\n                            LogRotationTimer.getInstance().restartTimerForDayBasedRotation();\r\n                        } else {\r\n                            LogRotationTimer.getInstance().restartTimer();\r\n                        }\r\n                        cleanUpHistoryLogFiles();\r\n                    }\r\n                } catch (IOException ix) {\r\n                    new ErrorManager().error(\"Error, could not rotate log file\", ix, ErrorManager.GENERIC_FAILURE);\r\n                }\r\n                return null;\r\n            }\r\n        }\r\n    });\r\n}"
}, {
	"Path": "com.sun.enterprise.server.logging.GFFileHandler.rotate",
	"Comment": "a simple rotate method to close the old file and start the new onewhen the limit is reached.",
	"Method": "void rotate(){\r\n    synchronized (thisInstance.rotationLock) {\r\n        if (thisInstance.meter != null && thisInstance.meter.written <= 0) {\r\n            return null;\r\n        }\r\n        thisInstance.flush();\r\n        thisInstance.close();\r\n        try {\r\n            if (!absoluteFile.exists()) {\r\n                File creatingDeletedLogFile = new File(absoluteFile.getAbsolutePath());\r\n                if (creatingDeletedLogFile.createNewFile()) {\r\n                    absoluteFile = creatingDeletedLogFile;\r\n                }\r\n            } else {\r\n                File oldFile = absoluteFile;\r\n                StringBuffer renamedFileName = new StringBuffer(absoluteFile + \"_\");\r\n                logRotateDateFormatter.format(new Date(), renamedFileName, new FieldPosition(0));\r\n                File rotatedFile = new File(renamedFileName.toString());\r\n                boolean renameSuccess = oldFile.renameTo(rotatedFile);\r\n                if (!renameSuccess) {\r\n                    FileUtils.copy(absoluteFile, rotatedFile);\r\n                    File freshServerLogFile = getLogFileName();\r\n                    FileOutputStream fo = new FileOutputStream(freshServerLogFile);\r\n                    fo.close();\r\n                }\r\n                FileOutputStream oldFileFO = new FileOutputStream(oldFile);\r\n                oldFileFO.close();\r\n                openFile(getLogFileName());\r\n                absoluteFile = getLogFileName();\r\n                if (dayBasedFileRotation) {\r\n                    LogRotationTimer.getInstance().restartTimerForDayBasedRotation();\r\n                } else {\r\n                    LogRotationTimer.getInstance().restartTimer();\r\n                }\r\n                cleanUpHistoryLogFiles();\r\n            }\r\n        } catch (IOException ix) {\r\n            new ErrorManager().error(\"Error, could not rotate log file\", ix, ErrorManager.GENERIC_FAILURE);\r\n        }\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.resources.FileDirContext.lookupLink",
	"Comment": "retrieves the named object, following links except for the terminal atomic component of the name. if the object bound to name is not a link, returns the object itself.",
	"Method": "Object lookupLink(String name){\r\n    return lookup(name);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentTransaction.setCurrent",
	"Comment": "sets up the thread association for a control object.if the thread association already exists for the thread under which theoperation was invoked and the stacking flag is set, the existing controlis stacked behind the given one, which is made the current one.if the association already exists and the stacking flag is not set, noassociation is changed and the operation returns false.for xa support, when an association is started or ended, allregistered staticresource objects are informed of the association change.",
	"Method": "boolean setCurrent(ControlImpl control,boolean stack){\r\n    boolean result = false;\r\n    ControlImpl current = (ControlImpl) m_tid.get();\r\n    if (current != null) {\r\n        if (stack) {\r\n            if (statics != null)\r\n                statics.distributeEnd(current, false);\r\n            StatusHolder outStatus = new StatusHolder();\r\n            control.pushControl(current, outStatus);\r\n            if (statsOn) {\r\n                Thread thread = Thread.currentThread();\r\n                result = (threadContexts.remove(thread) != null);\r\n            } else\r\n                result = true;\r\n            m_tid.set(null);\r\n            if (statsOn)\r\n                suspended.addElement(current);\r\n        }\r\n    } else\r\n        result = true;\r\n    if (result) {\r\n        if (statics != null)\r\n            statics.distributeStart(control, stack);\r\n        if (statsOn) {\r\n            Thread thread = Thread.currentThread();\r\n            threadContexts.put(thread, control);\r\n        }\r\n        m_tid.set(control);\r\n        if (statsOn)\r\n            suspended.removeElement(control);\r\n        control.incrementAssociation();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.AbsoluteOrderingDescriptor.order",
	"Comment": "this method return the webfragmentdescriptor in absolute order.note that the number of element return may be less than that of the original list.",
	"Method": "List<WebFragmentDescriptor> order(List<WebFragmentDescriptor> wfs){\r\n    List<WebFragmentDescriptor> wfList = new ArrayList<WebFragmentDescriptor>();\r\n    if (wfs != null && wfs.size() > 0) {\r\n        Map<String, WebFragmentDescriptor> map = new HashMap<String, WebFragmentDescriptor>();\r\n        List<WebFragmentDescriptor> othersList = new ArrayList<WebFragmentDescriptor>();\r\n        for (WebFragmentDescriptor wf : wfs) {\r\n            String name = wf.getName();\r\n            if (name != null && name.length() > 0 && absOrder.contains(name)) {\r\n                map.put(name, wf);\r\n            } else {\r\n                othersList.add(wf);\r\n            }\r\n        }\r\n        for (Object obj : absOrder) {\r\n            if (obj instanceof String) {\r\n                WebFragmentDescriptor wf = map.get((String) obj);\r\n                if (wf != null) {\r\n                    wfList.add(wf);\r\n                }\r\n            } else {\r\n                for (WebFragmentDescriptor wf : othersList) {\r\n                    wfList.add(wf);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return wfList;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.intf.remoteintf.RemoteInterfaceRmiIIOPException.runIndividualMethodTest",
	"Comment": "run an individual verifier test against a declared method of the remote interface.",
	"Method": "boolean runIndividualMethodTest(EjbDescriptor descriptor,Method method,Result result){\r\n    Class[] methodExceptionTypes = method.getExceptionTypes();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (RmiIIOPUtils.isValidRmiIIOPException(methodExceptionTypes)) {\r\n        addGoodDetails(result, compName);\r\n        result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"[ {0} ] method properly throws java.rmi.RemoteException.\", new Object[] { method.getName() }));\r\n        return true;\r\n    } else {\r\n        addErrorDetails(result, compName);\r\n        result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: [ {0} ] method was found, but does not properly \" + \"throw java.rmi.RemoteException.\", new Object[] { method.getName() }));\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.embed.impl.WebContainerImpl.addContext",
	"Comment": "registers the given context with all virtualserverat the given context root.if virtualserver has already been started, thegiven context will be started as well.",
	"Method": "void addContext(Context context,String contextRoot){\r\n    if (contextRoot == null) {\r\n        throw new ConfigException(\"Context root cannot be NULL\");\r\n    }\r\n    for (VirtualServer vs : getVirtualServers()) {\r\n        if (vs.getContext(contextRoot) != null) {\r\n            throw new ConfigException(\"Context with contextRoot \" + contextRoot + \" is already registered\");\r\n        }\r\n        if (!org.glassfish.api.web.Constants.ADMIN_VS.equals(vs.getID())) {\r\n            vs.addContext(context, contextRoot);\r\n            if (log.isLoggable(Level.INFO)) {\r\n                log.info(\"Added context with path \" + contextRoot + \" from virtual server \" + vs.getID());\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.deploy.shared.FileArchive.getSubArchive",
	"Comment": "create or obtain an embedded archive within this abstraction.",
	"Method": "ReadableArchive getSubArchive(String name){\r\n    String subEntryName = getFileSubArchivePath(name);\r\n    File subEntry = new File(subEntryName);\r\n    if (subEntry.exists() && isEntryValid(subEntry)) {\r\n        deplLogger.log(DEBUG_LEVEL, \"FileArchive.getSubArchive for {0} found that it is valid\", subEntry.getAbsolutePath());\r\n        ReadableArchive result = archiveFactory.openArchive(subEntry);\r\n        if (result instanceof AbstractReadableArchive) {\r\n            ((AbstractReadableArchive) result).setParentArchive(this);\r\n        }\r\n        return result;\r\n    } else if (subEntry.exists()) {\r\n        deplLogger.log(DEBUG_LEVEL, \"FileArchive.getSubArchive for {0} found that it is not a valid entry; it is stale\", subEntry.getAbsolutePath());\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogLSN.greaterThan",
	"Comment": "determines whether the target lsn is greater than the parameter.",
	"Method": "boolean greaterThan(LogLSN other){\r\n    return ((offset > other.offset && extent == other.extent) || extent > other.extent);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.pwc.PwcWebModule.setEndpointAddresses",
	"Comment": "sets the url addresses corresponding to the web services endpoints ofthis web module.",
	"Method": "void setEndpointAddresses(String[] endpointAddresses){\r\n    this.endpointAddresses = (String[]) endpointAddresses.clone();\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.findLoadedResource",
	"Comment": "finds the resource with the given name if it has previously beenloaded and cached by this class loader, and return an input streamto the resource data.if this resource has not been cached, returnnull.",
	"Method": "InputStream findLoadedResource(String name){\r\n    ResourceEntry entry = resourceEntries.get(name);\r\n    if (entry != null) {\r\n        if (entry.binaryContent != null)\r\n            return new ByteArrayInputStream(entry.binaryContent);\r\n    }\r\n    return (null);\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.AbstractRulesImpl.setNamespaceURI",
	"Comment": "set the namespace uri that will be applied to all subsequentlyadded rule objects.",
	"Method": "void setNamespaceURI(String namespaceURI){\r\n    this.namespaceURI = namespaceURI;\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.FormAuthenticator.authenticate",
	"Comment": "authenticate the user making this request, based on the specifiedlogin configuration.return true if any specifiedconstraint has been satisfied, or false if we havecreated a response challenge already.",
	"Method": "boolean authenticate(HttpRequest request,HttpResponse response,LoginConfig config){\r\n    HttpServletRequest hreq = (HttpServletRequest) request.getRequest();\r\n    HttpServletResponse hres = (HttpServletResponse) response.getResponse();\r\n    Session session = null;\r\n    String contextPath = hreq.getContextPath();\r\n    String requestURI = request.getDecodedRequestURI();\r\n    boolean loginAction = requestURI.startsWith(contextPath) && requestURI.endsWith(Constants.FORM_ACTION);\r\n    Principal principal = hreq.getUserPrincipal();\r\n    if (principal != null && !loginAction) {\r\n        if (log.isLoggable(Level.FINE))\r\n            log.log(Level.FINE, neutralizeForLog(\"Already authenticated '\" + principal.getName() + \"'\"));\r\n        String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);\r\n        if (ssoId != null) {\r\n            getSession(request, true);\r\n        }\r\n        return (true);\r\n    }\r\n    if (!cache && !loginAction) {\r\n        session = getSession(request, true);\r\n        String username = (String) session.getNote(Constants.SESS_USERNAME_NOTE);\r\n        char[] password = (char[]) session.getNote(Constants.SESS_PASSWORD_NOTE);\r\n        if ((username != null) && (password != null)) {\r\n            if (log.isLoggable(Level.FINE))\r\n                log.log(Level.FINE, neutralizeForLog(\"Reauthenticating username '\" + username + \"'\"));\r\n            principal = context.getRealm().authenticate(username, password);\r\n            if (principal != null) {\r\n                session.setNote(Constants.FORM_PRINCIPAL_NOTE, principal);\r\n                if (!matchRequest(request)) {\r\n                    register(request, response, principal, Constants.FORM_METHOD, username, password);\r\n                    return (true);\r\n                }\r\n            }\r\n            if (log.isLoggable(Level.FINE))\r\n                log.log(Level.FINE, \"Reauthentication failed, proceed normally\");\r\n        }\r\n    }\r\n    if (matchRequest(request)) {\r\n        session = getSession(request, true);\r\n        principal = (Principal) session.getNote(Constants.FORM_PRINCIPAL_NOTE);\r\n        register(request, response, principal, Constants.FORM_METHOD, (String) session.getNote(Constants.SESS_USERNAME_NOTE), (char[]) session.getNote(Constants.SESS_PASSWORD_NOTE));\r\n        String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);\r\n        if (ssoId != null) {\r\n            associate(ssoId, getSsoVersion(request), session);\r\n        }\r\n        if (restoreRequest(request, session)) {\r\n            if (log.isLoggable(Level.FINE))\r\n                log.log(Level.FINE, \"Proceed to restored request\");\r\n            return (true);\r\n        } else {\r\n            if (log.isLoggable(Level.FINE))\r\n                log.log(Level.FINE, \"Restore of original request failed\");\r\n            hres.sendError(HttpServletResponse.SC_BAD_REQUEST);\r\n            return (false);\r\n        }\r\n    }\r\n    MessageBytes uriMB = MessageBytes.newInstance();\r\n    CharChunk uriCC = uriMB.getCharChunk();\r\n    uriCC.setLimit(-1);\r\n    response.setContext(request.getContext());\r\n    if (!loginAction) {\r\n        session = getSession(request, true);\r\n        saveRequest(request, session);\r\n        forwardToLoginPage(request, response, config);\r\n        return (false);\r\n    }\r\n    Realm realm = context.getRealm();\r\n    String username = hreq.getParameter(Constants.FORM_USERNAME);\r\n    String pwd = hreq.getParameter(Constants.FORM_PASSWORD);\r\n    char[] password = ((pwd != null) ? pwd.toCharArray() : null);\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, neutralizeForLog(\"Authenticating username '\" + username + \"'\"));\r\n    principal = realm.authenticate(username, password);\r\n    if (principal == null) {\r\n        forwardToErrorPage(request, response, config);\r\n        return (false);\r\n    }\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, neutralizeForLog(\"Authentication of '\" + username + \"' was successful\"));\r\n    if (session == null)\r\n        session = getSession(request, true);\r\n    session.setNote(Constants.FORM_PRINCIPAL_NOTE, principal);\r\n    if (!cache) {\r\n        session.setNote(Constants.SESS_USERNAME_NOTE, username);\r\n        session.setNote(Constants.SESS_PASSWORD_NOTE, password);\r\n    }\r\n    requestURI = savedRequestURL(session);\r\n    if (requestURI == null) {\r\n        requestURI = hreq.getContextPath() + \"/\";\r\n        register(request, response, principal, Constants.FORM_METHOD, (String) session.getNote(Constants.SESS_USERNAME_NOTE), (char[]) session.getNote(Constants.SESS_PASSWORD_NOTE));\r\n        String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);\r\n        if (ssoId != null) {\r\n            associate(ssoId, getSsoVersion(request), session);\r\n        }\r\n    }\r\n    if (log.isLoggable(Level.FINE)) {\r\n        log.log(Level.FINE, neutralizeForLog(\"Redirecting to original '\" + requestURI + \"'\"));\r\n    }\r\n    hres.sendRedirect(hres.encodeRedirectURL(requestURI));\r\n    return (false);\r\n}"
}, {
	"Path": "org.apache.catalina.session.PersistentManagerBase.stop",
	"Comment": "gracefully terminate the active use of the public methods of thiscomponent.this method should be the last one called on a giveninstance of this component.",
	"Method": "void stop(){\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \"Stopping\");\r\n    if (!isStarted()) {\r\n        if (log.isLoggable(Level.INFO)) {\r\n            log.log(Level.INFO, LogFacade.MANAGER_NOT_STARTED_INFO);\r\n        }\r\n        return;\r\n    }\r\n    lifecycle.fireLifecycleEvent(STOP_EVENT, null);\r\n    setStarted(false);\r\n    if (getStore() != null && saveOnRestart) {\r\n        unload();\r\n    } else {\r\n        Session[] sessions = findSessions();\r\n        for (int i = 0; i < sessions.length; i++) {\r\n            StandardSession session = (StandardSession) sessions[i];\r\n            if (!session.isValid())\r\n                continue;\r\n            session.expire();\r\n        }\r\n    }\r\n    if (getStore() != null && getStore() instanceof Lifecycle)\r\n        ((Lifecycle) getStore()).stop();\r\n    resetRandom();\r\n    if (initialized)\r\n        destroy();\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationDispatcher.getInfo",
	"Comment": "return the descriptive information about this implementation.",
	"Method": "String getInfo(){\r\n    return (this.info);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.webservices.OnlyOneServletMappingCheck.getSize",
	"Comment": "this is a hack, since descriptors from backend containan extra url pattern.",
	"Method": "int getSize(Set urlPatterns){\r\n    int size = urlPatterns.size();\r\n    if (getVerifierContext().isAppserverMode())\r\n        for (Object url : urlPatterns) {\r\n            String urlPattern = (String) url;\r\n            if (urlPattern.indexOf(\"__container\") != -1)\r\n                size--;\r\n        }\r\n    return size;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.web.WebCheckMgrImpl.getTestFromExcludeList",
	"Comment": "if the call is from deployment backend and precompilejsp option is set then there is no need to run the alljspsmustbecompilable test.",
	"Method": "Vector<TestInformation> getTestFromExcludeList(){\r\n    Vector<TestInformation> tests = super.getTestFromExcludeList();\r\n    if (verifierFrameworkContext.getJspOutDir() != null) {\r\n        TestInformation ti = new TestInformation();\r\n        ti.setClassName(\"com.sun.enterprise.tools.verifier.tests.web.AllJSPsMustBeCompilable\");\r\n        tests.addElement(ti);\r\n    }\r\n    return tests;\r\n}"
}, {
	"Path": "org.glassfish.diagnostics.context.impl.ContextImplUnitTest.testDelegationOfPut",
	"Comment": "test that the put operations on an instance of contextimpl delegate as expected to the view object used in construction.",
	"Method": "void testDelegationOfPut(Location mockedLocation,View mockedView){\r\n    ContextImpl contextImpl = new ContextImpl(mockedView, mockedLocation);\r\n    contextImpl.put(\"KeyForString-Value1-true\", \"Value1\", true);\r\n    contextImpl.put(\"KeyForString-Value2-false\", \"Value2\", false);\r\n    contextImpl.put(\"KeyForNumber-5-true\", 5, true);\r\n    contextImpl.put(\"KeyForNumber-7-false\", 7, false);\r\n    new Verifications() {\r\n        {\r\n            mockedView.put(\"KeyForString-Value1-true\", \"Value1\", EnumSet.of(PropagationMode.THREAD, PropagationMode.RMI, PropagationMode.JMS_QUEUE, PropagationMode.SOAP, PropagationMode.MIME_HEADER, PropagationMode.ONEWAY));\r\n            mockedView.put(\"KeyForString-Value2-false\", \"Value2\", EnumSet.of(PropagationMode.LOCAL));\r\n            mockedView.put(\"KeyForNumber-5-true\", 5, EnumSet.of(PropagationMode.THREAD, PropagationMode.RMI, PropagationMode.JMS_QUEUE, PropagationMode.SOAP, PropagationMode.MIME_HEADER, PropagationMode.ONEWAY));\r\n            mockedView.put(\"KeyForNumber-7-false\", 7, EnumSet.of(PropagationMode.LOCAL));\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentImpl.deactivate",
	"Comment": "prevents any further transactional activity in the process.",
	"Method": "void deactivate(){\r\n    active = false;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebResourceCollectionImpl.addHttpMethod",
	"Comment": "adds the given http method to the collection of http methods thiscollection has.",
	"Method": "void addHttpMethod(String httpMethod){\r\n    this.getHttpMethods().add(httpMethod);\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.CompositeUtil.unmarshallClass",
	"Comment": "convert the given restmodel encoded as json to a live java object.",
	"Method": "T unmarshallClass(Locale locale,Class<T> modelClass,JSONObject json){\r\n    T model = getModel(modelClass);\r\n    for (Method setter : getSetters(modelClass)) {\r\n        String name = setter.getName();\r\n        String attribute = name.substring(3, 4).toLowerCase(Locale.getDefault()) + name.substring(4);\r\n        Type param0 = setter.getGenericParameterTypes()[0];\r\n        Class class0 = setter.getParameterTypes()[0];\r\n        if (json.has(attribute)) {\r\n            java.lang.Object o = json.get(attribute);\r\n            if (JSONArray.class.isAssignableFrom(o.getClass())) {\r\n                Object values = processJsonArray(locale, param0, (JSONArray) o);\r\n                invoke(locale, setter, attribute, model, values);\r\n            } else if (JSONObject.class.isAssignableFrom(o.getClass())) {\r\n                invoke(locale, setter, attribute, model, unmarshallClass(locale, class0, (JSONObject) o));\r\n            } else {\r\n                if (\"null\".equals(o.toString())) {\r\n                    o = null;\r\n                }\r\n                if (!isUnmodifiedConfidentialProperty(modelClass, name, o)) {\r\n                    invoke(locale, setter, attribute, model, o);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return model;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.LineTokenReplacer.getReader",
	"Comment": "get a reader that substitutes the tokens in the content that it returns.",
	"Method": "Reader getReader(Reader in){\r\n    return new Reader() {\r\n        BufferedReader reader = new BufferedReader(in);\r\n        String line = null;\r\n        final String eol = System.getProperty(\"line.separator\");\r\n        @Override\r\n        public int read(char[] cbuf, int off, int len) throws IOException {\r\n            if (line == null || line.isEmpty()) {\r\n                line = reader.readLine();\r\n                if (line == null) {\r\n                    return -1;\r\n                }\r\n                line = replaceLine(line) + eol;\r\n            }\r\n            int copySize = len - off;\r\n            if (copySize > line.length()) {\r\n                copySize = line.length();\r\n            }\r\n            line.getChars(0, copySize, cbuf, off);\r\n            line = line.substring(copySize);\r\n            return copySize;\r\n        }\r\n        @Override\r\n        public void close() throws IOException {\r\n            reader.close();\r\n        }\r\n    };\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.LineTokenReplacer.getReader",
	"Comment": "get a reader that substitutes the tokens in the content that it returns.",
	"Method": "Reader getReader(Reader in){\r\n    if (line == null || line.isEmpty()) {\r\n        line = reader.readLine();\r\n        if (line == null) {\r\n            return -1;\r\n        }\r\n        line = replaceLine(line) + eol;\r\n    }\r\n    int copySize = len - off;\r\n    if (copySize > line.length()) {\r\n        copySize = line.length();\r\n    }\r\n    line.getChars(0, copySize, cbuf, off);\r\n    line = line.substring(copySize);\r\n    return copySize;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.LineTokenReplacer.getReader",
	"Comment": "get a reader that substitutes the tokens in the content that it returns.",
	"Method": "Reader getReader(Reader in){\r\n    reader.close();\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.timer.ImplementsTimedObjectTest.check",
	"Comment": "checks if the ejb class implements the timedobject interface",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    boolean isEjb30 = descriptor.getEjbBundleDescriptor().getSpecVersion().equalsIgnoreCase(\"3.0\");\r\n    if (descriptor.isTimedObject()) {\r\n        if (((descriptor instanceof EjbEntityDescriptor) && isEjb30) || ((descriptor instanceof EjbSessionDescriptor) && ((((EjbSessionDescriptor) descriptor).getSessionType()).equals(EjbSessionDescriptor.STATEFUL)))) {\r\n            addErrorDetails(result, compName);\r\n            result.failed(smh.getLocalString(getClass().getName() + \".failed1\", \"[ {0} ] must not implement the TimedObject interface.\" + \"Only 2.1 entity beans or stateless session beans may \" + \"implement the TimedObject interface\", new Object[] { descriptor.getEjbClassName() }));\r\n        }\r\n    }\r\n    if (result.getStatus() != Result.FAILED) {\r\n        addGoodDetails(result, compName);\r\n        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"[ {0} ] properly implements the TimedObject interface\", new Object[] { descriptor.getEjbClassName() }));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.ParameterParser.isOneOf",
	"Comment": "tests if the given character is present in the array of characters.",
	"Method": "boolean isOneOf(char ch,char[] charray){\r\n    boolean result = false;\r\n    for (int i = 0; i < charray.length; i++) {\r\n        if (ch == charray[i]) {\r\n            result = true;\r\n            break;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.ServerDirsSelector.validateDomainOrInstance",
	"Comment": "make sure the parameters make sense for either an instance or a domain.",
	"Method": "void validateDomainOrInstance(){\r\n    if (userSpecifiedDomainDirParent != null) {\r\n        domainDirs = new DomainDirs(userSpecifiedDomainDirParent, userSpecifiedServerName);\r\n    } else if (userSpecifiedNode != null || userSpecifiedNodeDir != null) {\r\n        instanceDirs = new InstanceDirs(userSpecifiedNodeDir, userSpecifiedNode, userSpecifiedServerName);\r\n    } else if (userSpecifiedServerName == null) {\r\n        domainDirs = new DomainDirs(userSpecifiedDomainDirParent, userSpecifiedServerName);\r\n    } else {\r\n        try {\r\n            domainDirs = new DomainDirs(userSpecifiedDomainDirParent, userSpecifiedServerName);\r\n            return;\r\n        } catch (IOException e) {\r\n        }\r\n        instanceDirs = new InstanceDirs(userSpecifiedNodeDir, userSpecifiedNode, userSpecifiedServerName);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.api.admin.CommandModel.getParamName",
	"Comment": "get the param name.first it checks if the annotated paramincludes a name, if not then it gets the name from the field.if the parameter is a password, add the prefix and change thename to upper case.",
	"Method": "String getParamName(Param param,AnnotatedElement annotated){\r\n    String name = param.name();\r\n    if (name.equals(\"\")) {\r\n        if (annotated instanceof Field) {\r\n            name = ((Field) annotated).getName();\r\n        }\r\n        if (annotated instanceof Method) {\r\n            if (((Method) annotated).getName().startsWith(\"is\")) {\r\n                name = ((Method) annotated).getName().substring(2);\r\n            } else {\r\n                name = ((Method) annotated).getName().substring(3);\r\n            }\r\n            name = Introspector.decapitalize(name);\r\n        }\r\n    }\r\n    return name;\r\n}"
}, {
	"Path": "org.apache.catalina.util.StringParser.advance",
	"Comment": "advance the current parsing position by one, if we are not alreadypast the end of the string.",
	"Method": "void advance(){\r\n    if (index < length)\r\n        index++;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getInitParameter",
	"Comment": "return the value of the specified initialization parameter, ornull if this parameter does not exist.",
	"Method": "String getInitParameter(String name){\r\n    return context.getInitParameter(name);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardServer.await",
	"Comment": "wait until a proper shutdown command is received, then return.",
	"Method": "void await(){\r\n    ServerSocket serverSocket = null;\r\n    try {\r\n        serverSocket = new ServerSocket(port, 1, InetAddress.getByName(\"127.0.0.1\"));\r\n    } catch (IOException e) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.STANDARD_SERVER_AWAIT_CREATE_EXCEPTION), port);\r\n        log.log(Level.SEVERE, msg, e);\r\n        System.exit(1);\r\n    }\r\n    while (true) {\r\n        Socket socket = null;\r\n        InputStream stream = null;\r\n        try {\r\n            socket = serverSocket.accept();\r\n            socket.setSoTimeout(10 * 1000);\r\n            stream = socket.getInputStream();\r\n        } catch (AccessControlException ace) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.STANDARD_SERVER_ACCEPT_SECURITY_EXCEPTION), ace.getMessage());\r\n            log.log(Level.WARNING, msg, ace);\r\n            continue;\r\n        } catch (IOException e) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.STANDARD_SERVER_AWAIT_ACCEPT_EXCEPTION), e.toString());\r\n            log.log(Level.SEVERE, msg, e);\r\n            System.exit(1);\r\n        }\r\n        StringBuilder command = new StringBuilder();\r\n        int expected = 1024;\r\n        while (expected < shutdown.length()) {\r\n            if (random == null)\r\n                random = new SecureRandom();\r\n            expected += random.nextInt(1024);\r\n        }\r\n        while (expected > 0) {\r\n            int ch = -1;\r\n            try {\r\n                ch = stream.read();\r\n            } catch (IOException e) {\r\n                String msg = MessageFormat.format(rb.getString(LogFacade.STANDARD_SERVER_AWAIT_READ_EXCEPTION), e.toString());\r\n                log.log(Level.WARNING, msg, e);\r\n                ch = -1;\r\n            }\r\n            if (ch < 32)\r\n                break;\r\n            command.append((char) ch);\r\n            expected--;\r\n        }\r\n        try {\r\n            socket.close();\r\n        } catch (IOException e) {\r\n        }\r\n        boolean match = command.toString().equals(shutdown);\r\n        if (match) {\r\n            break;\r\n        } else {\r\n            log.log(Level.WARNING, LogFacade.STANDARD_SERVER_AWAIT_INVALID_COMMAND_RECEIVED_EXCEPTION, neutralizeForLog(command.toString()));\r\n        }\r\n    }\r\n    try {\r\n        serverSocket.close();\r\n    } catch (IOException e) {\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.recycle",
	"Comment": "release all object references, and initialize instance variables, inpreparation for reuse of this object.",
	"Method": "void recycle(){\r\n    attributes.clear();\r\n    setAuthType(null);\r\n    creationTime = 0L;\r\n    expiring = false;\r\n    id = null;\r\n    lastAccessedTime = 0L;\r\n    maxInactiveInterval = -1;\r\n    notes.clear();\r\n    setPrincipal(null);\r\n    isNew = false;\r\n    isValid = false;\r\n    listeners.clear();\r\n    manager = null;\r\n}"
}, {
	"Path": "org.glassfish.web.embed.impl.WebContainerImpl.createVirtualServer",
	"Comment": "creates a virtualserver with the given id and docroot, andmaps it to all weblistener instances.",
	"Method": "VirtualServer createVirtualServer(String id,File docRoot,WebListener webListeners,VirtualServer createVirtualServer,String id,File docRoot){\r\n    return new VirtualServerFacade(id, docRoot, (WebListener[]) null);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.PEAccessLogValve.log",
	"Comment": "log the specified message to the log file, switching files if the datehas changed since the previous log call.",
	"Method": "void log(){\r\n    if (rotatable) {\r\n        long systime = System.currentTimeMillis();\r\n        long rotationIntervalLong = rotationInterval * 1000L;\r\n        if (systime - lastAccessLogCreationTime > rotationIntervalLong) {\r\n            synchronized (this) {\r\n                systime = System.currentTimeMillis();\r\n                if (systime - lastAccessLogCreationTime > rotationIntervalLong) {\r\n                    String lastDateStamp = dateFormatter.get().format(new Date(lastAccessLogCreationTime));\r\n                    String newDateStamp = dateFormatter.get().format(new Date(systime));\r\n                    lastAccessLogCreationTime = systime;\r\n                    if (!lastDateStamp.equals(newDateStamp)) {\r\n                        close();\r\n                        open(newDateStamp, false);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    synchronized (lock) {\r\n        try {\r\n            charBuffer.flip();\r\n            ByteBuffer byteBuffer = ByteBuffer.wrap(charBuffer.toString().getBytes(Charset.defaultCharset()));\r\n            while (byteBuffer.hasRemaining()) {\r\n                fileChannel.write(byteBuffer);\r\n            }\r\n        } catch (IOException ex) {\r\n            ;\r\n        } finally {\r\n            charBuffer.clear();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.setServletClass",
	"Comment": "sets the class object from which this servlet will be instantiated.",
	"Method": "void setServletClass(Class<? extends Servlet> clazz){\r\n    if (clazz == null) {\r\n        throw new NullPointerException(\"Null servlet class\");\r\n    }\r\n    if ((servletClass != null) || servletClassName != null && !servletClassName.equals(clazz.getName())) {\r\n        throw new IllegalStateException(\"Wrapper already initialized with servlet instance, \" + \"class, or name\");\r\n    }\r\n    servletClass = clazz;\r\n    servletClassName = clazz.getName();\r\n    if (Constants.JSP_SERVLET_CLASS.equals(servletClassName)) {\r\n        isJspServlet = true;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.LocalInterfaceExposed.getBaseComponentType",
	"Comment": "this api recursively looks for class.getcomponenttype. this handlescases where array of arrays are used.",
	"Method": "Class getBaseComponentType(Class cls){\r\n    if (!cls.isArray())\r\n        return cls;\r\n    return getBaseComponentType(cls.getComponentType());\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.NamingResources.removeLocalEjb",
	"Comment": "remove any local ejb resource reference with the specified name.",
	"Method": "void removeLocalEjb(String name){\r\n    entries.remove(name);\r\n    ContextLocalEjb localEjb = null;\r\n    synchronized (localEjbs) {\r\n        localEjb = localEjbs.remove(name);\r\n    }\r\n    if (localEjb != null) {\r\n        support.firePropertyChange(\"localEjb\", localEjb, null);\r\n        localEjb.setNamingResources(null);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.launcher.GFLauncher.needsManualUpgrade",
	"Comment": "does this domain need to be manually upgraded before it can be started?",
	"Method": "boolean needsManualUpgrade(){\r\n    return needsManualUpgrade;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.moveServletFilterMapping",
	"Comment": "moves the given servlet filter mapping to a new relative location inthe list",
	"Method": "void moveServletFilterMapping(ServletFilterMapping ref,int relPos){\r\n    moveVectorItem(getServletFilterMappings(), ref, relPos);\r\n}"
}, {
	"Path": "org.glassfish.deployment.admin.ListComponentsCommand.getSnifferEngines",
	"Comment": "return all user visible sniffer engines in an application.the return format is",
	"Method": "String getSnifferEngines(Module module,boolean format){\r\n    return getSniffers(module.getEngines(), format);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getConstraints",
	"Comment": "gets the security constraints defined for this web application.",
	"Method": "List<SecurityConstraint> getConstraints(){\r\n    return constraints;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.CommandSecurityChecker.initOptypeMap",
	"Comment": "maps restendpoint http methods to the corresponding security action.",
	"Method": "EnumMap<RestEndpoint.OpType, String> initOptypeMap(){\r\n    final EnumMap<RestEndpoint.OpType, String> result = new EnumMap(RestEndpoint.OpType.class);\r\n    result.put(RestEndpoint.OpType.DELETE, \"delete\");\r\n    result.put(RestEndpoint.OpType.GET, \"read\");\r\n    result.put(RestEndpoint.OpType.POST, \"update\");\r\n    result.put(RestEndpoint.OpType.PUT, \"create\");\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.removeResourceEnvRef",
	"Comment": "remove any resource environment reference with the specified name.",
	"Method": "void removeResourceEnvRef(String name){\r\n    namingResources.removeResourceEnvRef(name);\r\n    if (notifyContainerListeners) {\r\n        fireContainerEvent(\"removeResourceEnvRef\", name);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.ErrorPageDescriptor.setErrorSignifierAsString",
	"Comment": "sets the error code if the argument is parsable as an int, or the exception type else.",
	"Method": "void setErrorSignifierAsString(String errorSignifier){\r\n    try {\r\n        int errorCode = Integer.parseInt(errorSignifier);\r\n        this.setErrorCode(errorCode);\r\n        this.setExceptionType(null);\r\n        return;\r\n    } catch (NumberFormatException nfe) {\r\n    }\r\n    this.setExceptionType(errorSignifier);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RecoveryManager.removeFromTxMap",
	"Comment": "remove the specified transaction id from the transaction id map.",
	"Method": "Thread removeFromTxMap(GlobalTID tid){\r\n    return (Thread) transactionIds.remove(tid);\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.CompositeUtil.getModel",
	"Comment": "this method will return a generated concrete class that implements the interface requested, as well as anyinterfaces intended to extend the base model interface.model extensions must be annotated with",
	"Method": "T getModel(Class<T> modelIface){\r\n    String className = modelIface.getName() + \"Impl\";\r\n    if (!generatedClasses.containsKey(className)) {\r\n        Map<String, Map<String, Object>> properties = new HashMap<String, Map<String, Object>>();\r\n        Set<Class<?>> interfaces = getModelExtensions(modelIface);\r\n        interfaces.add(modelIface);\r\n        for (Class<?> iface : interfaces) {\r\n            analyzeInterface(iface, properties);\r\n        }\r\n        ClassWriter classWriter = new ClassWriter(ClassWriter.COMPUTE_MAXS);\r\n        visitClass(classWriter, className, interfaces, properties);\r\n        for (Map.Entry<String, Map<String, Object>> entry : properties.entrySet()) {\r\n            String name = entry.getKey();\r\n            final Map<String, Object> property = entry.getValue();\r\n            Class<?> type = (Class<?>) property.get(\"type\");\r\n            createField(classWriter, name, type);\r\n            createGettersAndSetters(classWriter, modelIface, className, name, property);\r\n        }\r\n        createConstructor(classWriter, className, properties);\r\n        classWriter.visitEnd();\r\n        Class<?> newClass;\r\n        try {\r\n            newClass = defineClass(modelIface, className, classWriter.toByteArray());\r\n        } catch (Exception ex) {\r\n            throw new RuntimeException(ex);\r\n        }\r\n        generatedClasses.put(className, newClass);\r\n    }\r\n    try {\r\n        return (T) generatedClasses.get(className).newInstance();\r\n    } catch (Exception ex) {\r\n        throw new RuntimeException(ex);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationDispatcher.include",
	"Comment": "include the response from another resource in the current response.any runtime exception, ioexception, or servletexception thrown by thecalled servlet will be propagated to the caller.",
	"Method": "void include(ServletRequest request,ServletResponse response){\r\n    if (Globals.IS_SECURITY_ENABLED) {\r\n        try {\r\n            PrivilegedInclude dp = new PrivilegedInclude(request, response);\r\n            AccessController.doPrivileged(dp);\r\n        } catch (PrivilegedActionException pe) {\r\n            Exception e = pe.getException();\r\n            if (e instanceof ServletException)\r\n                throw (ServletException) e;\r\n            throw (IOException) e;\r\n        }\r\n    } else {\r\n        doInclude(request, response);\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.GlobalTID.copy",
	"Comment": "creates a new global identifier which is a copy of the target object.",
	"Method": "GlobalTID copy(){\r\n    GlobalTID result = new GlobalTID(realTID);\r\n    result.hashed = hashed;\r\n    result.hashCode = hashCode;\r\n    result.stringForm = stringForm;\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.admin.mbeanserver.RMIConnectorStarter.start",
	"Comment": "the start method which configures the sslsockets needed and then starts thejmxconnecterserver.",
	"Method": "JMXConnectorServer start(){\r\n    final String name = \"jmxrmi\";\r\n    final String hostname = hostname();\r\n    final Map<String, Object> env = new HashMap<String, Object>();\r\n    env.put(\"jmx.remote.jndi.rebind\", \"true\");\r\n    env.put(RMIConnectorServer.RMI_CLIENT_SOCKET_FACTORY_ATTRIBUTE, sslCsf);\r\n    env.put(RMIConnectorServer.RMI_SERVER_SOCKET_FACTORY_ATTRIBUTE, sslServerSocketFactory);\r\n    env.put(\"com.sun.jndi.rmi.factory.socket\", sslCsf);\r\n    JMXAuthenticator authenticator = getAccessController();\r\n    if (authenticator != null) {\r\n        env.put(\"jmx.remote.authenticator\", authenticator);\r\n    }\r\n    final String jmxHostPort = hostname + \":\" + mPort;\r\n    final String registryHostPort = hostname + \":\" + mPort;\r\n    final String urlStr = \"service:jmx:rmi://\" + jmxHostPort + \"/jndi/rmi://\" + registryHostPort + \"/\" + name;\r\n    mJMXServiceURL = new JMXServiceURL(urlStr);\r\n    if (mBindToSingleIP) {\r\n        RMIServerSocketFactory rmiSSF = isSecurityEnabled() ? sslServerSocketFactory : mServerSocketFactory;\r\n        mMyServer = new MyRMIJRMPServerImpl(mPort, env, rmiSSF, hostname);\r\n        mConnectorServer = new RMIConnectorServer(mJMXServiceURL, env, mMyServer, mMBeanServer);\r\n    } else {\r\n        mConnectorServer = JMXConnectorServerFactory.newJMXConnectorServer(mJMXServiceURL, env, mMBeanServer);\r\n    }\r\n    if (mBootListener != null) {\r\n        mConnectorServer.addNotificationListener(mBootListener, null, mJMXServiceURL.toString());\r\n    }\r\n    mConnectorServer.start();\r\n    return mConnectorServer;\r\n}"
}, {
	"Path": "org.apache.catalina.ssi.SSIProcessor.parseParamNames",
	"Comment": "parse a stringbuilder and take out the param type token. called fromrequesthandler",
	"Method": "String[] parseParamNames(StringBuilder cmd,int start){\r\n    int bIdx = start;\r\n    int i = 0;\r\n    int quotes = 0;\r\n    boolean inside = false;\r\n    StringBuilder retBuf = new StringBuilder();\r\n    while (bIdx < cmd.length()) {\r\n        if (!inside) {\r\n            while (bIdx < cmd.length() && isSpace(cmd.charAt(bIdx))) bIdx++;\r\n            if (bIdx >= cmd.length())\r\n                break;\r\n            inside = !inside;\r\n        } else {\r\n            while (bIdx < cmd.length() && cmd.charAt(bIdx) != '=') {\r\n                retBuf.append(cmd.charAt(bIdx));\r\n                bIdx++;\r\n            }\r\n            retBuf.append('=');\r\n            inside = !inside;\r\n            quotes = 0;\r\n            boolean escaped = false;\r\n            for (; bIdx < cmd.length() && quotes != 2; bIdx++) {\r\n                char c = cmd.charAt(bIdx);\r\n                if (c == '\\\\' && !escaped) {\r\n                    escaped = true;\r\n                    continue;\r\n                }\r\n                if (c == '\"' && !escaped)\r\n                    quotes++;\r\n                escaped = false;\r\n            }\r\n        }\r\n    }\r\n    StringTokenizer str = new StringTokenizer(retBuf.toString(), \"=\");\r\n    String[] retString = new String[str.countTokens()];\r\n    while (str.hasMoreTokens()) {\r\n        retString[i++] = str.nextToken().trim();\r\n    }\r\n    return retString;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TransactionState.getSequenceNumber",
	"Comment": "returns the current transaction sequence number and increments it.",
	"Method": "long getSequenceNumber(){\r\n    return ++sequenceNumber;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.setConfigClass",
	"Comment": "set the java class name of the context configuration classfor new web applications.",
	"Method": "void setConfigClass(String configClass){\r\n    String oldConfigClass = this.configClass;\r\n    this.configClass = configClass;\r\n    support.firePropertyChange(\"configClass\", oldConfigClass, this.configClass);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationFilterConfig.release",
	"Comment": "release the filter instance associated with this filterconfig,if there is one.",
	"Method": "void release(){\r\n    if (this.filter != null) {\r\n        if (context != null) {\r\n            context.fireContainerEvent(ContainerEvent.BEFORE_FILTER_DESTROYED, filter);\r\n        }\r\n        if (SecurityUtil.executeUnderSubjectDoAs()) {\r\n            try {\r\n                SecurityUtil.doAsPrivilege(\"destroy\", filter);\r\n                SecurityUtil.remove(filter);\r\n            } catch (java.lang.Exception ex) {\r\n                String msg = rb.getString(LogFacade.DO_AS_PRIVILEGE);\r\n                log.log(Level.SEVERE, msg, ex);\r\n            }\r\n        } else {\r\n            filter.destroy();\r\n        }\r\n        if (context != null) {\r\n            context.fireContainerEvent(ContainerEvent.AFTER_FILTER_DESTROYED, filter);\r\n            context = null;\r\n        }\r\n    }\r\n    this.filter = null;\r\n    needInitialize = true;\r\n}"
}, {
	"Path": "org.glassfish.cluster.ssh.util.SSHUtil.unregister",
	"Comment": "unregisters a connection for cleanup when the plugin is stopped.",
	"Method": "void unregister(Session session){\r\n    session.disconnect();\r\n    activeConnections.remove(session);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.CommonAccessLogFormatterImpl.appendClientName",
	"Comment": "appends the client host name of the given request to the given charbuffer.",
	"Method": "void appendClientName(CharBuffer cb,ServletRequest req){\r\n    String value = req.getRemoteHost();\r\n    if (value == null) {\r\n        value = NULL_VALUE;\r\n    }\r\n    cb.put(value);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RecoveryManager.readAndUpdateTxMap",
	"Comment": "read and update the transaction id map atomically with the current thread, if and only if there is no concurrent activity for the specified transaction id.",
	"Method": "boolean readAndUpdateTxMap(GlobalTID tid){\r\n    synchronized (transactionIds) {\r\n        Thread thread = (Thread) transactionIds.get(tid);\r\n        if (thread != null) {\r\n            return false;\r\n        }\r\n        transactionIds.put(tid, Thread.currentThread());\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.NamingContext.composeName",
	"Comment": "composes the name of this context with a name relative to this context.",
	"Method": "Name composeName(Name name,Name prefix,String composeName,String name,String prefix){\r\n    return prefix + \"/\" + name;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.clearCookies",
	"Comment": "clear the collection of cookies associated with this request.",
	"Method": "void clearCookies(){\r\n    cookiesParsed = true;\r\n    cookies.clear();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.NestingInfo.numChildren",
	"Comment": "returns a count of the number of children that have been defined.if no nesting information has been defined, the operation returns 0.",
	"Method": "int numChildren(){\r\n    return childSet.size();\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Response.addCookie",
	"Comment": "add the specified cookie to those that will be included withthis response.",
	"Method": "void addCookie(Cookie cookie){\r\n    if (isCommitted())\r\n        return;\r\n    if (included)\r\n        return;\r\n    String cookieValue = getCookieString(cookie);\r\n    addHeader(\"Set-Cookie\", cookieValue);\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.node.WebFragmentNode.registerBundle",
	"Comment": "register this node as a root node capable of loading entire dd files",
	"Method": "String registerBundle(Map publicIDToDTD){\r\n    return tag.getQName();\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setCharsetMapperClass",
	"Comment": "set the locale to character set mapper class for this context.",
	"Method": "void setCharsetMapperClass(String mapper){\r\n    String oldCharsetMapperClass = this.charsetMapperClass;\r\n    this.charsetMapperClass = mapper;\r\n    support.firePropertyChange(\"charsetMapperClass\", oldCharsetMapperClass, this.charsetMapperClass);\r\n}"
}, {
	"Path": "org.apache.catalina.logger.SystemOutLogger.log",
	"Comment": "writes the specified message to a servlet log file, usually an eventlog.the name and type of the servlet log is specific to theservlet container.",
	"Method": "void log(String msg){\r\n    System.out.println(msg);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.DefaultAccessLogFormatterImpl.appendRequestInfo",
	"Comment": "appends info about the given request to the given char buffer.",
	"Method": "void appendRequestInfo(CharBuffer cb,HttpServletRequest hreq){\r\n    cb.put(QUOTE);\r\n    cb.put(hreq.getMethod());\r\n    cb.put(SPACE);\r\n    String uri = hreq.getRequestURI();\r\n    if (uri == null) {\r\n        uri = \"NULL-HTTP-URI\";\r\n    }\r\n    cb.put(uri);\r\n    if (hreq.getQueryString() != null) {\r\n        cb.put('?');\r\n        cb.put(hreq.getQueryString());\r\n    }\r\n    cb.put(SPACE);\r\n    cb.put(hreq.getProtocol());\r\n    cb.put(QUOTE);\r\n}"
}, {
	"Path": "org.apache.catalina.util.ManifestResource.getRequiredExtensions",
	"Comment": "return the set of extension objects representing optionalpackages that are required by the application associated with thespecified manifest.",
	"Method": "ArrayList<Extension> getRequiredExtensions(ArrayList<Extension> getRequiredExtensions,Manifest manifest){\r\n    Attributes attributes = manifest.getMainAttributes();\r\n    String names = attributes.getValue(\"Extension-List\");\r\n    if (names == null)\r\n        return null;\r\n    ArrayList<Extension> extensionList = new ArrayList<Extension>();\r\n    names += \" \";\r\n    while (true) {\r\n        int space = names.indexOf(' ');\r\n        if (space < 0)\r\n            break;\r\n        String name = names.substring(0, space).trim();\r\n        names = names.substring(space + 1);\r\n        String value = attributes.getValue(name + \"-Extension-Name\");\r\n        if (value == null)\r\n            continue;\r\n        Extension extension = new Extension();\r\n        extension.setExtensionName(value);\r\n        extension.setImplementationURL(attributes.getValue(name + \"-Implementation-URL\"));\r\n        extension.setImplementationVendorId(attributes.getValue(name + \"-Implementation-Vendor-Id\"));\r\n        String version = attributes.getValue(name + \"-Implementation-Version\");\r\n        extension.setImplementationVersion(version);\r\n        extension.setSpecificationVersion(attributes.getValue(name + \"-Specification-Version\"));\r\n        extensionList.add(extension);\r\n    }\r\n    return extensionList;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.LoginConfigurationImpl.setRealmName",
	"Comment": "set the realm the server should use for basic authentication.",
	"Method": "void setRealmName(String realmName){\r\n    this.realmName = realmName;\r\n}"
}, {
	"Path": "com.sun.enterprise.universal.collections.CollectionUtils.toString",
	"Comment": "tired of dumping a string representation of a map?then call me!",
	"Method": "String toString(Map<String, String> map,String toString,String[] arr,String toString,List<String> list){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (String s : list) {\r\n        sb.append(s);\r\n        sb.append(' ');\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.sun.enterprise.web.connector.coyote.PECoyoteConnector.setProxyHandler",
	"Comment": "loads and instantiates the proxyhandler implementationclass with the specified name, and sets the instantiated proxyhandler on this connector.",
	"Method": "void setProxyHandler(String className){\r\n    Object handler = null;\r\n    try {\r\n        Class handlerClass = webContainer.loadCommonClass(className);\r\n        handler = handlerClass.newInstance();\r\n    } catch (Exception e) {\r\n        String msg = MessageFormat.format(_rb.getString(LogFacade.PROXY_HANDLER_CLASS_LOAD_ERROR), className);\r\n        _logger.log(Level.SEVERE, msg, e);\r\n    }\r\n    if (handler != null) {\r\n        if (!(handler instanceof ProxyHandler)) {\r\n            _logger.log(Level.SEVERE, LogFacade.PROXY_HANDLER_CLASS_INVALID, className);\r\n        } else {\r\n            setProxyHandler((ProxyHandler) handler);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.resources.FileDirContext.search",
	"Comment": "searches in the named context or object for entries that satisfy the given search filter. performs the search as specified by the search controls.",
	"Method": "NamingEnumeration<SearchResult> search(String name,Attributes matchingAttributes,String[] attributesToReturn,NamingEnumeration<SearchResult> search,String name,Attributes matchingAttributes,NamingEnumeration<SearchResult> search,String name,String filter,SearchControls cons,NamingEnumeration<SearchResult> search,String name,String filterExpr,Object[] filterArgs,SearchControls cons){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.catalina.realm.RealmBase.findSecurityConstraints",
	"Comment": "gets the security constraints configured by the given contextfor the given request uri and method.",
	"Method": "SecurityConstraint[] findSecurityConstraints(HttpRequest request,Context context,SecurityConstraint[] findSecurityConstraints,String uri,String method,Context context){\r\n    ArrayList<SecurityConstraint> results = null;\r\n    if (!context.hasConstraints()) {\r\n        if (log.isLoggable(Level.FINE))\r\n            log.log(Level.FINE, \"  No applicable constraints defined\");\r\n        return (null);\r\n    }\r\n    String origUri = uri;\r\n    boolean caseSensitiveMapping = ((StandardContext) context).isCaseSensitiveMapping();\r\n    if (uri != null && !caseSensitiveMapping) {\r\n        uri = uri.toLowerCase(Locale.ENGLISH);\r\n    }\r\n    boolean found = false;\r\n    List<SecurityConstraint> constraints = context.getConstraints();\r\n    Iterator<SecurityConstraint> i = constraints.iterator();\r\n    while (i.hasNext()) {\r\n        SecurityConstraint constraint = i.next();\r\n        SecurityCollection[] collection = constraint.findCollections();\r\n        if (collection == null) {\r\n            continue;\r\n        }\r\n        if (log.isLoggable(Level.FINEST)) {\r\n            String msg = \"Checking constraint '\" + constraint + \"' against \" + method + \" \" + origUri + \" --> \" + constraint.included(uri, method, caseSensitiveMapping);\r\n            log.log(Level.FINEST, msg);\r\n        }\r\n        if (log.isLoggable(Level.FINE) && constraint.included(uri, method, caseSensitiveMapping)) {\r\n            log.log(Level.FINE, \"  Matched constraint '\" + constraint + \"' against \" + method + \" \" + origUri);\r\n        }\r\n        for (int j = 0; j < collection.length; j++) {\r\n            String[] patterns = collection[j].findPatterns();\r\n            if (patterns == null) {\r\n                continue;\r\n            }\r\n            for (int k = 0; k < patterns.length; k++) {\r\n                String pattern = caseSensitiveMapping ? patterns[k] : patterns[k].toLowerCase(Locale.ENGLISH);\r\n                if (uri != null && uri.equals(pattern)) {\r\n                    found = true;\r\n                    if (collection[j].findMethod(method)) {\r\n                        if (results == null) {\r\n                            results = new ArrayList<SecurityConstraint>();\r\n                        }\r\n                        results.add(constraint);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (found) {\r\n        return resultsToArray(results);\r\n    }\r\n    int longest = -1;\r\n    i = constraints.iterator();\r\n    while (i.hasNext()) {\r\n        SecurityConstraint constraint = i.next();\r\n        SecurityCollection[] collection = constraint.findCollections();\r\n        if (collection == null) {\r\n            continue;\r\n        }\r\n        if (log.isLoggable(Level.FINEST)) {\r\n            String msg = \"  Checking constraint '\" + constraint + \"' against \" + method + \" \" + origUri + \" --> \" + constraint.included(uri, method, caseSensitiveMapping);\r\n            log.log(Level.FINE, msg);\r\n        }\r\n        if (log.isLoggable(Level.FINE) && constraint.included(uri, method, caseSensitiveMapping)) {\r\n            log.log(Level.FINE, \"  Matched constraint '\" + constraint + \"' against \" + method + \" \" + origUri);\r\n        }\r\n        for (int j = 0; j < collection.length; j++) {\r\n            String[] patterns = collection[j].findPatterns();\r\n            if (patterns == null) {\r\n                continue;\r\n            }\r\n            boolean matched = false;\r\n            int length = -1;\r\n            for (int k = 0; k < patterns.length; k++) {\r\n                String pattern = caseSensitiveMapping ? patterns[k] : patterns[k].toLowerCase(Locale.ENGLISH);\r\n                if (pattern.startsWith(\"/\") && pattern.endsWith(\"/*\") && pattern.length() >= longest) {\r\n                    if (pattern.length() == 2) {\r\n                        matched = true;\r\n                        length = pattern.length();\r\n                    } else if (uri != null && (pattern.regionMatches(0, uri, 0, pattern.length() - 1) || (pattern.length() - 2 == uri.length() && pattern.regionMatches(0, uri, 0, pattern.length() - 2)))) {\r\n                        matched = true;\r\n                        length = pattern.length();\r\n                    }\r\n                }\r\n            }\r\n            if (matched) {\r\n                found = true;\r\n                if (length > longest) {\r\n                    if (results != null) {\r\n                        results.clear();\r\n                    }\r\n                    longest = length;\r\n                }\r\n                if (collection[j].findMethod(method)) {\r\n                    if (results == null) {\r\n                        results = new ArrayList<SecurityConstraint>();\r\n                    }\r\n                    results.add(constraint);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (found) {\r\n        return resultsToArray(results);\r\n    }\r\n    i = constraints.iterator();\r\n    while (i.hasNext()) {\r\n        SecurityConstraint constraint = i.next();\r\n        SecurityCollection[] collection = constraint.findCollections();\r\n        if (collection == null) {\r\n            continue;\r\n        }\r\n        if (log.isLoggable(Level.FINEST)) {\r\n            String msg = \"  Checking constraint '\" + constraint + \"' against \" + method + \" \" + origUri + \" --> \" + constraint.included(uri, method, caseSensitiveMapping);\r\n            log.log(Level.FINEST, msg);\r\n        }\r\n        if (log.isLoggable(Level.FINE) && constraint.included(uri, method, caseSensitiveMapping)) {\r\n            log.log(Level.FINE, \"  Matched constraint '\" + constraint + \"' against \" + method + \" \" + origUri);\r\n        }\r\n        boolean matched = false;\r\n        int pos = -1;\r\n        for (int j = 0; j < collection.length; j++) {\r\n            String[] patterns = collection[j].findPatterns();\r\n            if (patterns == null) {\r\n                continue;\r\n            }\r\n            for (int k = 0; k < patterns.length && !matched; k++) {\r\n                String pattern = caseSensitiveMapping ? patterns[k] : patterns[k].toLowerCase(Locale.ENGLISH);\r\n                if (uri != null && pattern.startsWith(\"*.\")) {\r\n                    int slash = uri.lastIndexOf(\"/\");\r\n                    int dot = uri.lastIndexOf(\".\");\r\n                    if (slash >= 0 && dot > slash && dot != uri.length() - 1 && uri.length() - dot == pattern.length() - 1) {\r\n                        if (pattern.regionMatches(1, uri, dot, uri.length() - dot)) {\r\n                            matched = true;\r\n                            pos = j;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        if (matched) {\r\n            found = true;\r\n            if (collection[pos].findMethod(method)) {\r\n                if (results == null) {\r\n                    results = new ArrayList<SecurityConstraint>();\r\n                }\r\n                results.add(constraint);\r\n            }\r\n        }\r\n    }\r\n    if (found) {\r\n        return resultsToArray(results);\r\n    }\r\n    i = constraints.iterator();\r\n    while (i.hasNext()) {\r\n        SecurityConstraint constraint = i.next();\r\n        SecurityCollection[] collection = constraint.findCollections();\r\n        if (collection == null) {\r\n            continue;\r\n        }\r\n        if (log.isLoggable(Level.FINEST)) {\r\n            String msg = \"  Checking constraint '\" + constraint + \"' against \" + method + \" \" + origUri + \" --> \" + constraint.included(uri, method, caseSensitiveMapping);\r\n            log.log(Level.FINEST, msg);\r\n        }\r\n        if (log.isLoggable(Level.FINE) && constraint.included(uri, method, caseSensitiveMapping)) {\r\n            log.log(Level.FINE, \"  Matched constraint '\" + constraint + \"' against \" + method + \" \" + origUri);\r\n        }\r\n        for (int j = 0; j < collection.length; j++) {\r\n            String[] patterns = collection[j].findPatterns();\r\n            if (patterns == null) {\r\n                continue;\r\n            }\r\n            boolean matched = false;\r\n            for (int k = 0; k < patterns.length && !matched; k++) {\r\n                String pattern = caseSensitiveMapping ? patterns[k] : patterns[k].toLowerCase(Locale.ENGLISH);\r\n                if (pattern.equals(\"/\")) {\r\n                    matched = true;\r\n                }\r\n            }\r\n            if (matched) {\r\n                if (results == null) {\r\n                    results = new ArrayList<SecurityConstraint>();\r\n                }\r\n                results.add(constraint);\r\n            }\r\n        }\r\n    }\r\n    if (results == null) {\r\n        if (log.isLoggable(Level.FINE))\r\n            log.log(Level.FINE, \"  No applicable constraint located\");\r\n    }\r\n    return resultsToArray(results);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.CoyoteServerSocketFactory.getKeyAlias",
	"Comment": "gets the alias name of the keypair and supporting certificate chainused by the server to authenticate itself to ssl clients.",
	"Method": "String getKeyAlias(){\r\n    return this.keyAlias;\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ModifiedHASession.setAttribute",
	"Comment": "set the attribute name to the value valueand update the dirty flag to true",
	"Method": "void setAttribute(String name,Object value){\r\n    super.setAttribute(name, value);\r\n    this.setDirty(true);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.ClassPathBuilder.addAll",
	"Comment": "adds all the files in the given directory that match the given filter.",
	"Method": "ClassPathBuilder addAll(File dir,FileFilter filter,ClassPathBuilder addAll,File files){\r\n    for (File f : files) add(f);\r\n    return this;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.RulesBase.getNamespaceURI",
	"Comment": "return the namespace uri that will be applied to all subsequentlyadded rule objects.",
	"Method": "String getNamespaceURI(){\r\n    return (this.namespaceURI);\r\n}"
}, {
	"Path": "com.sun.enterprise.server.logging.LogFormatHelper.isUniformFormatLogHeader",
	"Comment": "determines whether the given line is the beginning of a uniformlogformat log record.",
	"Method": "boolean isUniformFormatLogHeader(String line){\r\n    if (line.startsWith(\"[#|\") && countOccurrences(line, '|') > 4) {\r\n        return true;\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.setAttribute",
	"Comment": "set the specified request attribute to the specified value.",
	"Method": "void setAttribute(String name,Object value){\r\n    if (name == null) {\r\n        throw new IllegalArgumentException(rb.getString(LogFacade.NULL_ATTRIBUTE_NAME_EXCEPTION));\r\n    }\r\n    if (value == null) {\r\n        removeAttribute(name);\r\n        return;\r\n    }\r\n    if (name.equals(Globals.DISPATCHER_TYPE_ATTR)) {\r\n        dispatcherTypeAttr = value;\r\n        return;\r\n    } else if (name.equals(Globals.DISPATCHER_REQUEST_PATH_ATTR)) {\r\n        requestDispatcherPath = value;\r\n        return;\r\n    }\r\n    boolean replaced = false;\r\n    if (Globals.IS_SECURITY_ENABLED && name.equals(\"org.apache.tomcat.sendfile.filename\")) {\r\n        String canonicalPath;\r\n        try {\r\n            canonicalPath = new File(value.toString()).getCanonicalPath();\r\n        } catch (IOException e) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.UNABLE_DETERMINE_CANONICAL_NAME), value);\r\n            throw new SecurityException(msg, e);\r\n        }\r\n        System.getSecurityManager().checkRead(canonicalPath);\r\n        value = canonicalPath;\r\n    }\r\n    Object oldValue = attributes.put(name, value);\r\n    if (oldValue != null) {\r\n        replaced = true;\r\n    }\r\n    if (name.startsWith(\"grizzly.\")) {\r\n        coyoteRequest.setAttribute(name, value);\r\n    }\r\n    List<EventListener> listeners = context.getApplicationEventListeners();\r\n    if (listeners.isEmpty()) {\r\n        return;\r\n    }\r\n    ServletRequestAttributeEvent event = null;\r\n    if (replaced) {\r\n        event = new ServletRequestAttributeEvent(servletContext, getRequest(), name, oldValue);\r\n    } else {\r\n        event = new ServletRequestAttributeEvent(servletContext, getRequest(), name, value);\r\n    }\r\n    Iterator<EventListener> iter = listeners.iterator();\r\n    while (iter.hasNext()) {\r\n        EventListener eventListener = iter.next();\r\n        if (!(eventListener instanceof ServletRequestAttributeListener)) {\r\n            continue;\r\n        }\r\n        ServletRequestAttributeListener listener = (ServletRequestAttributeListener) eventListener;\r\n        try {\r\n            if (replaced) {\r\n                listener.attributeReplaced(event);\r\n            } else {\r\n                listener.attributeAdded(event);\r\n            }\r\n        } catch (Throwable t) {\r\n            log(rb.getString(LogFacade.ATTRIBUTE_EVENT_LISTENER_EXCEPTION), t);\r\n            attributes.put(RequestDispatcher.ERROR_EXCEPTION, t);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ExtendedAccessLogValve.getInfo",
	"Comment": "return descriptive information about this implementation.",
	"Method": "String getInfo(){\r\n    return (this.info);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationFilterConfig.getInitParameterNames",
	"Comment": "return an enumeration of the names of the initializationparameters for this filter.",
	"Method": "Enumeration<String> getInitParameterNames(){\r\n    return filterDef.getInitParameterNames();\r\n}"
}, {
	"Path": "org.glassfish.admin.mbeanserver.ssl.SSLClientConfigurator.getParameters",
	"Comment": "return the initialization parameters for the trustmanager.currently, only the default pkix is supported.",
	"Method": "CertPathParameters getParameters(String algorithm,String crlf,KeyStore trustStore){\r\n    CertPathParameters params = null;\r\n    if (\"PKIX\".equalsIgnoreCase(algorithm)) {\r\n        PKIXBuilderParameters xparams = new PKIXBuilderParameters(trustStore, new X509CertSelector());\r\n        Collection crls = getCRLs(crlf);\r\n        CertStoreParameters csp = new CollectionCertStoreParameters(crls);\r\n        CertStore store = CertStore.getInstance(\"Collection\", csp);\r\n        xparams.addCertStore(store);\r\n        xparams.setRevocationEnabled(true);\r\n        String trustLength = sslParams.getTrustMaxCertLength();\r\n        if (trustLength != null) {\r\n            try {\r\n                xparams.setMaxPathLength(Integer.parseInt(trustLength));\r\n            } catch (Exception ex) {\r\n                _logger.log(Level.WARNING, badMaxCertLength, trustLength);\r\n            }\r\n        }\r\n        params = xparams;\r\n    } else {\r\n        throw new CRLException(\"CRLs not supported for type: \" + algorithm);\r\n    }\r\n    return params;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModule.saveSessions",
	"Comment": "saves all active sessions to the given deployment context, so theycan be restored following a redeployment.",
	"Method": "void saveSessions(Properties props){\r\n    if (props == null) {\r\n        return;\r\n    }\r\n    StandardManager manager = (StandardManager) getManager();\r\n    if (manager == null) {\r\n        return;\r\n    }\r\n    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n    try {\r\n        manager.writeSessions(baos, false);\r\n        props.setProperty(getObjectName(), gfEncoder.encode(baos.toByteArray()));\r\n    } catch (Exception ex) {\r\n        String msg = rb.getString(LogFacade.UNABLE_TO_SAVE_SESSIONS_DURING_REDEPLOY);\r\n        msg = MessageFormat.format(msg, getName());\r\n        logger.log(Level.WARNING, msg, ex);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutoDeployer.setHabitat",
	"Comment": "sets the habitat for use in creating deploycommand and undeploycommandinstances.",
	"Method": "void setHabitat(ServiceLocator habitat){\r\n    this.habitat = habitat;\r\n}"
}, {
	"Path": "org.glassfish.diagnostics.context.impl.ContextImplUnitTest.testDelegationOfGet",
	"Comment": "test that the get operation on an instance of contextimpl delegates as expected to the view object used in construction.",
	"Method": "void testDelegationOfGet(Location mockedLocation,View mockedView){\r\n    final String key = \"testDelegationOfGet-Key1\";\r\n    final String expectedValueOfKey1 = \"testDelegationOfGet-Value1\";\r\n    ContextImpl contextImpl = new ContextImpl(mockedView, mockedLocation);\r\n    new Expectations() {\r\n        View expectationsRefViewVariable = mockedView;\r\n        {\r\n            expectationsRefViewVariable.get(key);\r\n            returns(expectedValueOfKey1, null, null);\r\n        }\r\n    };\r\n    String value = contextImpl.get(key);\r\n    Assert.assertEquals(\"Value returned from contextImpl.get(\\\"\" + key + \"\\\") is not the value expected.\", expectedValueOfKey1, value);\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.JavaEETransactionManagerSimplifiedDelegate.rollbackDistributedTransaction",
	"Comment": "throws an exception if called as it means that there is no active local transaction to rollback.",
	"Method": "void rollbackDistributedTransaction(){\r\n    throw new IllegalStateException(sm.getString(\"enterprise_distributedtx.transaction_notactive\"));\r\n}"
}, {
	"Path": "org.apache.catalina.ssi.ResponseIncludeWrapper.getWriter",
	"Comment": "return a printwriter, throws and exception if a outputstream alreadybeen returned.",
	"Method": "PrintWriter getWriter(){\r\n    if (servletOutputStream == null) {\r\n        if (printWriter == null) {\r\n            setCharacterEncoding(getCharacterEncoding());\r\n            printWriter = new PrintWriter(new OutputStreamWriter(captureServletOutputStream, getCharacterEncoding()));\r\n        }\r\n        return printWriter;\r\n    }\r\n    throw new IllegalStateException();\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.removeNote",
	"Comment": "remove any object bound to the specified name in the internal notesfor this session.",
	"Method": "void removeNote(String name){\r\n    notes.remove(name);\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutoDeployDirectoryScanner.hasNewDeployableEntity",
	"Comment": "return true if any new deployable entity ispresent in autodeploydir",
	"Method": "boolean hasNewDeployableEntity(File autodeployDir){\r\n    boolean newFilesExist = false;\r\n    try {\r\n        AutoDeployedFilesManager adfm = AutoDeployedFilesManager.loadStatus(autodeployDir);\r\n        if (adfm.getFilesForDeployment(getListOfFiles(autodeployDir)).length > 0) {\r\n            newFilesExist = true;\r\n        }\r\n    } catch (Exception e) {\r\n        printException(e);\r\n        return false;\r\n    }\r\n    return newFilesExist;\r\n}"
}, {
	"Path": "com.sun.jts.jtsxa.Utility.getCoordinator",
	"Comment": "obtain the coordinator object from the supplied control.if a null control is supplied, an null coordinator will be returned.",
	"Method": "Coordinator getCoordinator(Control control){\r\n    Coordinator coordinator = null;\r\n    if (control == null) {\r\n        return null;\r\n    }\r\n    try {\r\n        coordinator = control.get_coordinator();\r\n    } catch (Exception e) {\r\n        coordinator = null;\r\n    }\r\n    return coordinator;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.createServletInstance",
	"Comment": "instantiates and injects the given servlet class for the givenwebmodule",
	"Method": "T createServletInstance(WebModule module,Class<T> clazz){\r\n    validateJSR299Scope(clazz);\r\n    WebComponentInvocation inv = new WebComponentInvocation(module);\r\n    try {\r\n        invocationMgr.preInvoke(inv);\r\n        return injectionMgr.createManagedObject(clazz);\r\n    } finally {\r\n        invocationMgr.postInvoke(inv);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.CommandRunnerImpl.getMetadata",
	"Comment": "return the metadata for the command.we translate the parameterand operand information to parts and properties of the actionreport,which will be translated to xml elements and attributes by thexmlcontentactionreporter.",
	"Method": "void getMetadata(AdminCommand command,CommandModel model,ActionReport report){\r\n    ActionReport.MessagePart top = report.getTopMessagePart();\r\n    ActionReport.MessagePart cmd = top.addChild();\r\n    cmd.setChildrenType(\"command\");\r\n    cmd.addProperty(\"name\", model.getCommandName());\r\n    if (model.unknownOptionsAreOperands()) {\r\n        cmd.addProperty(\"unknown-options-are-operands\", \"true\");\r\n    }\r\n    String usage = model.getUsageText();\r\n    if (ok(usage)) {\r\n        cmd.addProperty(\"usage\", usage);\r\n    }\r\n    CommandModel.ParamModel primary = null;\r\n    for (CommandModel.ParamModel p : model.getParameters()) {\r\n        Param param = p.getParam();\r\n        if (param.primary()) {\r\n            primary = p;\r\n            continue;\r\n        }\r\n        ActionReport.MessagePart ppart = cmd.addChild();\r\n        ppart.setChildrenType(\"option\");\r\n        ppart.addProperty(\"name\", p.getName());\r\n        ppart.addProperty(\"type\", typeOf(p));\r\n        ppart.addProperty(\"optional\", Boolean.toString(param.optional()));\r\n        if (param.obsolete()) {\r\n            ppart.addProperty(\"obsolete\", \"true\");\r\n        }\r\n        String paramDesc = p.getLocalizedDescription();\r\n        if (ok(paramDesc)) {\r\n            ppart.addProperty(\"description\", paramDesc);\r\n        }\r\n        if (ok(param.shortName())) {\r\n            ppart.addProperty(\"short\", param.shortName());\r\n        }\r\n        if (ok(param.defaultValue())) {\r\n            ppart.addProperty(\"default\", param.defaultValue());\r\n        }\r\n        if (ok(param.acceptableValues())) {\r\n            ppart.addProperty(\"acceptable-values\", param.acceptableValues());\r\n        }\r\n        if (ok(param.alias())) {\r\n            ppart.addProperty(\"alias\", param.alias());\r\n        }\r\n    }\r\n    if (primary != null) {\r\n        ActionReport.MessagePart primpart = cmd.addChild();\r\n        primpart.setChildrenType(\"operand\");\r\n        primpart.addProperty(\"name\", primary.getName());\r\n        primpart.addProperty(\"type\", typeOf(primary));\r\n        primpart.addProperty(\"min\", primary.getParam().optional() ? \"0\" : \"1\");\r\n        primpart.addProperty(\"max\", primary.getParam().multiple() ? \"unlimited\" : \"1\");\r\n        String desc = primary.getLocalizedDescription();\r\n        if (ok(desc)) {\r\n            primpart.addProperty(\"description\", desc);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.ModuleDescriptor.writeObject",
	"Comment": "implementation of the serializable interface since moduletype is notserializable",
	"Method": "void writeObject(java.io.ObjectOutputStream out){\r\n    out.writeObject(path);\r\n    out.writeObject(altDD);\r\n    out.writeObject(contextRoot);\r\n    out.writeObject(descriptor);\r\n    out.writeBoolean(standalone);\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityConstraint.removeAuthRole",
	"Comment": "remove the specified role from the set of roles permitted to accessthe resources protected by this security constraint.",
	"Method": "void removeAuthRole(String authRole){\r\n    if (authRole == null)\r\n        return;\r\n    int n = -1;\r\n    for (int i = 0; i < authRoles.length; i++) {\r\n        if (authRoles[i].equals(authRole)) {\r\n            n = i;\r\n            break;\r\n        }\r\n    }\r\n    if (n >= 0) {\r\n        int j = 0;\r\n        String[] results = new String[authRoles.length - 1];\r\n        for (int i = 0; i < authRoles.length; i++) {\r\n            if (i != n)\r\n                results[j++] = authRoles[i];\r\n        }\r\n        authRoles = results;\r\n    }\r\n}"
}, {
	"Path": "com.sun.appserv.web.taglibs.cache.FlushTag.doEndTag",
	"Comment": "doendtag just resets all the valiables in case the tag is reused",
	"Method": "int doEndTag(){\r\n    _key = null;\r\n    _scope = PageContext.APPLICATION_SCOPE;\r\n    return EVAL_PAGE;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.PEAccessLogValve.threadStop",
	"Comment": "stop the background writerthread that is periodically write logs",
	"Method": "void threadStop(){\r\n    if (writerThread == null || writeInterval == 0)\r\n        return;\r\n    threadDone = true;\r\n    writerThread.interrupt();\r\n    try {\r\n        writerThread.join();\r\n    } catch (InterruptedException e) {\r\n        ;\r\n    }\r\n    writerThread = null;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.V2ToV3ConfigUpgrade.getJavaConfigs",
	"Comment": "report the javaconfig beans for each config.lets the caller commandprepare access checks for security authorization.",
	"Method": "Collection<JavaConfig> getJavaConfigs(){\r\n    final Collection<JavaConfig> result = new ArrayList<JavaConfig>();\r\n    for (Config c : configs.getConfig()) {\r\n        if (c.getJavaConfig() != null) {\r\n            result.add(c.getJavaConfig());\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorLog.formatSection",
	"Comment": "formats the information in a single section of the coordinatorlog into astream.this internal method does not need to be synchronized.if the rewrite flag is not set, only information that has not already beenwritten is formatted, otherwise all information is formatted.",
	"Method": "void formatSection(CoordinatorLogSection section,boolean rewrite,DataOutputStream dataOutput){\r\n    if (section.unwrittenEmpty && (!rewrite || section.writtenEmpty)) {\r\n        dataOutput.writeShort(0);\r\n        return;\r\n    }\r\n    dataOutput.writeShort(section.sectionName.length());\r\n    int unwrittenObjectsSize = 0;\r\n    int writtenObjectsSize = 0;\r\n    if (section.unwrittenObjects != null)\r\n        unwrittenObjectsSize = section.unwrittenObjects.size();\r\n    if (rewrite && section.writtenObjects != null)\r\n        writtenObjectsSize = section.writtenObjects.size();\r\n    dataOutput.writeShort(unwrittenObjectsSize + writtenObjectsSize);\r\n    int unwrittenDataSize = 0;\r\n    int writtenDataSize = 0;\r\n    if (section.unwrittenData != null)\r\n        unwrittenDataSize = section.unwrittenData.size();\r\n    if (rewrite && section.writtenData != null)\r\n        writtenDataSize = section.writtenData.size();\r\n    dataOutput.writeShort(unwrittenDataSize + writtenDataSize);\r\n    dataOutput.writeBytes(section.sectionName);\r\n    for (int i = 0; i < writtenObjectsSize; i++) {\r\n        String objRefStr = (String) section.writtenObjects.elementAt(i);\r\n        dataOutput.writeShort(objRefStr.length());\r\n        dataOutput.writeBytes(objRefStr);\r\n    }\r\n    for (int i = 0; i < unwrittenObjectsSize; i++) {\r\n        String objRefStr = (String) section.unwrittenObjects.elementAt(i);\r\n        dataOutput.writeShort(objRefStr.length());\r\n        dataOutput.writeBytes(objRefStr);\r\n        if (section.writtenObjects == null)\r\n            section.writtenObjects = new Vector(unwrittenObjectsSize, 10);\r\n        section.writtenObjects.addElement(objRefStr);\r\n    }\r\n    if (unwrittenObjectsSize > 0)\r\n        section.unwrittenObjects.removeAllElements();\r\n    for (int i = 0; i < writtenDataSize; i++) {\r\n        byte[] dataItem = (byte[]) section.writtenData.elementAt(i);\r\n        dataOutput.writeShort(dataItem.length);\r\n        dataOutput.write(dataItem);\r\n    }\r\n    for (int i = 0; i < unwrittenDataSize; i++) {\r\n        byte[] dataItem = (byte[]) section.unwrittenData.elementAt(i);\r\n        dataOutput.writeShort(dataItem.length);\r\n        dataOutput.write(dataItem);\r\n        if (section.writtenData == null)\r\n            section.writtenData = new Vector(unwrittenDataSize, 4);\r\n        section.writtenData.addElement(dataItem);\r\n    }\r\n    if (unwrittenDataSize > 0)\r\n        section.unwrittenData.removeAllElements();\r\n    section.unwrittenEmpty = true;\r\n    section.writtenEmpty = false;\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.DeferredFileOutputStream.isInMemory",
	"Comment": "determines whether or not the data for this output stream has beenretained in memory.",
	"Method": "boolean isInMemory(){\r\n    return (!isThresholdExceeded());\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.afterServletContextInitializedEvent",
	"Comment": "notifies any interested listeners that all servletcontextlistenersof the web module represented by the given webbundledescriptorhave been invoked at their contextinitialized method",
	"Method": "void afterServletContextInitializedEvent(WebBundleDescriptor wbd){\r\n    events.send(new Event<WebBundleDescriptor>(WebBundleDescriptor.AFTER_SERVLET_CONTEXT_INITIALIZED_EVENT, wbd), false);\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.node.runtime.gf.GFWebBundleRuntimeNode.registerBundle",
	"Comment": "register this node as a root node capable of loading entire dd files",
	"Method": "String registerBundle(Map<String, String> publicIDToDTD,Map<String, List<Class>> versionUpgrades){\r\n    publicIDToDTD.put(DTDRegistry.GF_WEBAPP_301_DTD_PUBLIC_ID, DTDRegistry.GF_WEBAPP_301_DTD_SYSTEM_ID);\r\n    return RuntimeTagNames.GF_WEB_RUNTIME_TAG;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.MonitoringReporter.prepareReporter",
	"Comment": "the stock actionreport we get is too inefficient. replace it withplaintext note that we might be called with html or xml or json orothers!",
	"Method": "void prepareReporter(){\r\n    reporter = (ActionReporter) context.getActionReport();\r\n    if (reporter instanceof PlainTextActionReporter) {\r\n        plainReporter = (PlainTextActionReporter) reporter;\r\n    } else if (reporter instanceof PropsFileActionReporter) {\r\n        plainReporter = new PlainTextActionReporter();\r\n        reporter = plainReporter;\r\n        context.setActionReport(plainReporter);\r\n    } else {\r\n        plainReporter = null;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorResourceImpl.setCompleted",
	"Comment": "informs the coordinatorresourceimpl object that the transaction itrepresents has completed.flags indicate whether the transaction aborted, and whether there washeuristic damage.",
	"Method": "void setCompleted(boolean aborted,boolean heuristicDamage){\r\n    completed = true;\r\n    this.aborted = aborted;\r\n    this.heuristicDamage = heuristicDamage;\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.addOverridablePackage",
	"Comment": "adds the given package name to the list of packages that may always beoverriden, regardless of whether they belong to a protected namespace",
	"Method": "void addOverridablePackage(String packageName){\r\n    if (overridablePackages == null) {\r\n        overridablePackages = new ConcurrentLinkedQueue<String>();\r\n    }\r\n    overridablePackages.add(packageName);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.setScheme",
	"Comment": "set the scheme that will be assigned to requests received throughthis connector.",
	"Method": "void setScheme(String scheme){\r\n    this.scheme = scheme;\r\n    setProperty(\"scheme\", scheme);\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.RulesBase.add",
	"Comment": "register a new rule instance matching the specified pattern.",
	"Method": "void add(String pattern,Rule rule){\r\n    int patternLength = pattern.length();\r\n    if (patternLength > 1 && pattern.endsWith(\"/\")) {\r\n        pattern = pattern.substring(0, patternLength - 1);\r\n    }\r\n    List<Rule> list = cache.get(pattern);\r\n    if (list == null) {\r\n        list = new ArrayList<Rule>();\r\n        cache.put(pattern, list);\r\n    }\r\n    list.add(rule);\r\n    rules.add(rule);\r\n    if (this.digester != null) {\r\n        rule.setDigester(this.digester);\r\n    }\r\n    if (this.namespaceURI != null) {\r\n        rule.setNamespaceURI(this.namespaceURI);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.CompositeResource.executeWriteCommand",
	"Comment": "execute a writing admincommand with the specified parameters.",
	"Method": "ActionReporter executeWriteCommand(String command,ActionReporter executeWriteCommand,String command,ParameterMap parameters){\r\n    return getCompositeUtil().executeWriteCommand(getSubject(), command, parameters);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.updateMapper",
	"Comment": "method gets called, when grizzlyservice changes http mapper, associatedwith specific port.",
	"Method": "void updateMapper(HttpService httpService,NetworkListener httpListener,Mapper mapper){\r\n    synchronized (mapperUpdateSync) {\r\n        WebConnector connector = connectorMap.get(httpListener.getName());\r\n        if (connector != null && connector.getMapper() != mapper) {\r\n            try {\r\n                updateConnector(httpListener, httpService);\r\n            } catch (LifecycleException le) {\r\n                logger.log(Level.SEVERE, LogFacade.EXCEPTION_CONFIG_HTTP_SERVICE, le);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.addCommonWebBundleDescriptor",
	"Comment": "this method combines all except welcome file set for two webbundledescriptors.",
	"Method": "void addCommonWebBundleDescriptor(WebBundleDescriptor wbd,boolean defaultDescriptor){\r\n    super.addBundleDescriptor(wbd);\r\n    WebBundleDescriptorImpl webBundleDescriptor = (WebBundleDescriptorImpl) wbd;\r\n    for (WebComponentDescriptor webComponentDesc : webBundleDescriptor.getWebComponentDescriptors()) {\r\n        WebComponentDescriptorImpl webComponentDescriptor = new WebComponentDescriptorImpl(webComponentDesc);\r\n        webComponentDescriptor.setWebBundleDescriptor(null);\r\n        List<String> removeUrlPatterns = null;\r\n        for (String urlPattern : webComponentDescriptor.getUrlPatternsSet()) {\r\n            String servletName = null;\r\n            if (urlPattern2ServletName != null) {\r\n                servletName = urlPattern2ServletName.get(urlPattern);\r\n            }\r\n            if (servletName != null && (!servletName.equals(webComponentDescriptor.getCanonicalName()))) {\r\n                if (removeUrlPatterns == null) {\r\n                    removeUrlPatterns = new ArrayList<String>();\r\n                }\r\n                removeUrlPatterns.add(urlPattern);\r\n            }\r\n        }\r\n        if (removeUrlPatterns != null) {\r\n            webComponentDescriptor.getUrlPatternsSet().removeAll(removeUrlPatterns);\r\n        }\r\n        addWebComponentDescriptor(webComponentDescriptor);\r\n    }\r\n    getContextParametersSet().addAll(webBundleDescriptor.getContextParametersSet());\r\n    if (conflictedMimeMappingExtensions == null) {\r\n        conflictedMimeMappingExtensions = webBundleDescriptor.getConflictedMimeMappingExtensions();\r\n    } else {\r\n        conflictedMimeMappingExtensions.addAll(webBundleDescriptor.getConflictedMimeMappingExtensions());\r\n    }\r\n    combineMimeMappings(webBundleDescriptor.getMimeMappingsSet());\r\n    for (ErrorPageDescriptor errPageDesc : webBundleDescriptor.getErrorPageDescriptorsSet()) {\r\n        addErrorPageDescriptor(errPageDesc);\r\n    }\r\n    getAppListeners().addAll(webBundleDescriptor.getAppListeners());\r\n    if (webBundleDescriptor.isDenyUncoveredHttpMethods()) {\r\n        setDenyUncoveredHttpMethods(true);\r\n    }\r\n    combineSecurityConstraints(getSecurityConstraintsSet(), webBundleDescriptor.getSecurityConstraintsSet());\r\n    combineServletFilters(webBundleDescriptor);\r\n    combineServletFilterMappings(webBundleDescriptor);\r\n    if (getLocaleEncodingMappingListDescriptor() == null) {\r\n        setLocaleEncodingMappingListDescriptor(webBundleDescriptor.getLocaleEncodingMappingListDescriptor());\r\n    }\r\n    if (webBundleDescriptor.getJspConfigDescriptor() != null) {\r\n        JspConfigDescriptorImpl jspConfigDesc = getJspConfigDescriptor();\r\n        if (jspConfigDesc == null) {\r\n            jspConfigDesc = new JspConfigDescriptorImpl();\r\n            setJspConfigDescriptor(jspConfigDesc);\r\n        }\r\n        jspConfigDescriptor.add(webBundleDescriptor.getJspConfigDescriptor());\r\n    }\r\n    WebServicesDescriptor thisWebServices = this.getWebServices();\r\n    WebServicesDescriptor otherWebServices = webBundleDescriptor.getWebServices();\r\n    for (WebService ws : otherWebServices.getWebServices()) {\r\n        thisWebServices.addWebService(new WebService(ws));\r\n    }\r\n    if (getSessionConfig() == null) {\r\n        setSessionConfig(webBundleDescriptor.getSessionConfig());\r\n    }\r\n    combineLoginConfiguration(webBundleDescriptor);\r\n    if (!defaultDescriptor) {\r\n        boolean otherDistributable = webBundleDescriptor.isDistributable();\r\n        setDistributable(distributable && otherDistributable);\r\n    }\r\n    combinePostConstructDescriptors(webBundleDescriptor);\r\n    combinePreDestroyDescriptors(webBundleDescriptor);\r\n    addJndiNameEnvironment(webBundleDescriptor);\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardManager.load",
	"Comment": "loads any currently active sessions that were previously unloadedto the appropriate persistence mechanism, if any.if persistence is notsupported, this method returns without doing anything.",
	"Method": "void load(){\r\n    if (SecurityUtil.isPackageProtectionEnabled()) {\r\n        try {\r\n            AccessController.doPrivileged(new PrivilegedDoLoadFromFile());\r\n        } catch (PrivilegedActionException ex) {\r\n            Exception exception = ex.getException();\r\n            if (exception instanceof ClassNotFoundException) {\r\n                throw (ClassNotFoundException) exception;\r\n            } else if (exception instanceof IOException) {\r\n                throw (IOException) exception;\r\n            }\r\n            if (log.isLoggable(Level.FINE)) {\r\n                log.log(Level.FINE, \"Unreported exception in load() \" + exception);\r\n            }\r\n        }\r\n    } else {\r\n        doLoadFromFile();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.setParent",
	"Comment": "set the parent container of this wrapper, but only if it is a context.",
	"Method": "void setParent(Container container){\r\n    if ((container != null) && !(container instanceof Context))\r\n        throw new IllegalArgumentException(rb.getString(LogFacade.PARENT_CONTAINER_MUST_BE_CONTEXT_EXCEPTION));\r\n    if (container instanceof StandardContext) {\r\n        unloadDelay = ((StandardContext) container).getUnloadDelay();\r\n        notifyContainerListeners = ((StandardContext) container).isNotifyContainerListeners();\r\n    }\r\n    super.setParent(container);\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.ServerSynchronizer.syncFile",
	"Comment": "sync an individual file.return true if the file changed.the file is named by mt.name, relative to base.the nameused in the response will be relative to root.in case thefile is a directory, tell the payload to include it recursively,and replace the entire contents of the directory in case anyfiles were removed.",
	"Method": "boolean syncFile(URI root,File base,ModTime mt,Payload.Outbound payload){\r\n    File f = fileOf(base, mt.name);\r\n    if (!f.exists())\r\n        return false;\r\n    if (mt.time != 0 && f.lastModified() == mt.time)\r\n        return false;\r\n    if (logger.isLoggable(Level.FINEST))\r\n        logger.finest(\"ServerSynchronizer: file \" + mt.name + \" out of date, time \" + f.lastModified());\r\n    try {\r\n        if (logger.isLoggable(Level.FINE))\r\n            logger.fine(\"ServerSynchronizer: sending file \" + f + (mt.time == 0 ? \" because it doesn't exist on the instance\" : \" because it was out of date\"));\r\n        payload.requestFileReplacement(\"application/octet-stream\", root.relativize(f.toURI()), \"configChange\", null, f, true);\r\n    } catch (IOException ioex) {\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.fine(\"ServerSynchronizer: IOException attaching file: \" + f);\r\n            logger.fine(ioex.toString());\r\n        }\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.createTagHandlerInstance",
	"Comment": "instantiates and injects the given tag handler class for the givenwebmodule",
	"Method": "T createTagHandlerInstance(WebModule module,Class<T> clazz){\r\n    WebComponentInvocation inv = new WebComponentInvocation(module);\r\n    try {\r\n        invocationMgr.preInvoke(inv);\r\n        return injectionMgr.createManagedObject(clazz);\r\n    } finally {\r\n        invocationMgr.postInvoke(inv);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.FileStore.directory",
	"Comment": "return a file object representing the pathname to oursession persistence directory, if any.the directory will becreated if it does not already exist.",
	"Method": "File directory(){\r\n    if (this.directory == null) {\r\n        return (null);\r\n    }\r\n    if (this.directoryFile != null) {\r\n        return (this.directoryFile);\r\n    }\r\n    File file = new File(this.directory);\r\n    if (!file.isAbsolute()) {\r\n        Container container = manager.getContainer();\r\n        if (container instanceof Context) {\r\n            ServletContext servletContext = ((Context) container).getServletContext();\r\n            File work = (File) servletContext.getAttribute(ServletContext.TEMPDIR);\r\n            file = new File(work, this.directory);\r\n        } else {\r\n            throw new IllegalArgumentException(\"Parent Container is not a Context\");\r\n        }\r\n    }\r\n    if (!file.exists() || !file.isDirectory()) {\r\n        if (!file.delete() && file.exists()) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.UNABLE_DELETE_FILE_EXCEPTION), file);\r\n            throw new IOException(msg);\r\n        }\r\n        if (!file.mkdirs() && !file.isDirectory()) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.UNABLE_CREATE_DIR_EXCEPTION), file);\r\n            throw new IOException(msg);\r\n        }\r\n    }\r\n    this.directoryFile = file;\r\n    return (file);\r\n}"
}, {
	"Path": "com.sun.enterprise.server.logging.logviewer.backend.LogFile.getLogFileReader",
	"Comment": "this method opens the server.log file and moves the stream tothe specified fileposition.",
	"Method": "BufferedReader getLogFileReader(long fromFilePosition){\r\n    FileInputStream file = null;\r\n    try {\r\n        file = new FileInputStream(getLogFileName());\r\n        long bytesToSkip = fromFilePosition - 1;\r\n        if (bytesToSkip > 0) {\r\n            long bytesSkipped = file.skip(bytesToSkip);\r\n            if (bytesSkipped != fromFilePosition) {\r\n                if (LogFacade.LOGGING_LOGGER.isLoggable(Level.FINE)) {\r\n                    LogFacade.LOGGING_LOGGER.log(Level.FINE, \"Did not skip exact bytes while positioning reader in \" + getLogFileName());\r\n                }\r\n            }\r\n        }\r\n        BufferedReader reader = new BufferedReader(new InputStreamReader(file));\r\n        return reader;\r\n    } catch (Exception ex) {\r\n        if (LogFacade.LOGGING_LOGGER.isLoggable(Level.FINE)) {\r\n            LogFacade.LOGGING_LOGGER.log(Level.FINE, \"Error reading from file: \" + getLogFileName(), ex);\r\n        }\r\n        if (file != null)\r\n            try {\r\n                file.close();\r\n            } catch (Exception ex2) {\r\n                if (LogFacade.LOGGING_LOGGER.isLoggable(Level.FINE)) {\r\n                    LogFacade.LOGGING_LOGGER.log(Level.FINE, \"Error closing file: \" + getLogFileName(), ex2);\r\n                }\r\n            }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.glassfish.bootstrap.Util.overrideBySystemProps",
	"Comment": "override property values in the given properties object by values set in corresponding property names insystem properties object.",
	"Method": "void overrideBySystemProps(Properties platformConf,Collection<String> excluding){\r\n    Properties sysProps = System.getProperties();\r\n    for (Map.Entry<Object, Object> entry : platformConf.entrySet()) {\r\n        if (excluding.contains(entry.getKey())) {\r\n            continue;\r\n        }\r\n        Object systemPropValue = sysProps.get(entry.getKey());\r\n        if (systemPropValue != null && !systemPropValue.equals(entry.getValue())) {\r\n            platformConf.put(entry.getKey(), systemPropValue);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "components.renderkit.RepeaterRenderer.getColumnHeaderCount",
	"Comment": "return the number of child components of type uicolumnare registered with the specified uidata componentand have a facet named header.",
	"Method": "int getColumnHeaderCount(UIData data){\r\n    int n = 0;\r\n    Iterator kids = data.getChildren().iterator();\r\n    while (kids.hasNext()) {\r\n        UIComponent kid = (UIComponent) kids.next();\r\n        if ((kid instanceof UIColumn) && (kid.getFacet(\"header\") != null)) {\r\n            n++;\r\n        }\r\n    }\r\n    return (n);\r\n}"
}, {
	"Path": "org.apache.catalina.ssi.ExpressionParseTree.pushOpp",
	"Comment": "pushes a new operator onto the opp stack, resolving existing opps asneeded.",
	"Method": "void pushOpp(OppNode node){\r\n    if (node == null) {\r\n        oppStack.add(0, null);\r\n        return;\r\n    }\r\n    while (true) {\r\n        if (oppStack.size() == 0)\r\n            break;\r\n        OppNode top = oppStack.get(0);\r\n        if (top == null)\r\n            break;\r\n        if (top.getPrecedence() < node.getPrecedence())\r\n            break;\r\n        oppStack.remove(0);\r\n        top.popValues(nodeStack);\r\n        nodeStack.add(0, top);\r\n    }\r\n    oppStack.add(0, node);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SuperiorInfo.reconstruct",
	"Comment": "directs the superiorinfo to recover its state after a failure, based onthe given coordinatorlog object.the superiorinfo then adds the given coordinator to therecoverymanager mappings.if the superiorinfo has already been definedor reconstructed, the operation does nothing. if the state cannot be reconstructed, thecoordinator is not added.the global identifier, local id, recoverycoordinatorand coordinatorresource object references are restored.",
	"Method": "void reconstruct(CoordinatorLog log,CoordinatorImpl coord){\r\n    superior = null;\r\n    logSection = log.createSection(LOG_SECTION_NAME);\r\n    byte[][] logData = log.getData(logSection);\r\n    globalTID = new GlobalTID(logData[0]);\r\n    localTID = log.localTID;\r\n    logRecord = log;\r\n    resyncRetries = 0;\r\n    RecoveryManager.addCoordinator(globalTID, localTID, coord, 0);\r\n    java.lang.Object[] logObjects = log.getObjects(logSection);\r\n    try {\r\n        if (logObjects.length > 1) {\r\n            if (((org.omg.CORBA.Object) logObjects[0])._is_a(RecoveryCoordinatorHelper.id())) {\r\n                java.lang.Object rcimpl = logObjects[0];\r\n                java.lang.Object crimpl = logObjects[1];\r\n                recovery = RecoveryCoordinatorHelper.narrow((org.omg.CORBA.Object) logObjects[0]);\r\n                resource = SubtransactionAwareResourceHelper.narrow((org.omg.CORBA.Object) logObjects[1]);\r\n            } else {\r\n                recovery = RecoveryCoordinatorHelper.narrow((org.omg.CORBA.Object) logObjects[1]);\r\n                resource = SubtransactionAwareResourceHelper.narrow((org.omg.CORBA.Object) logObjects[0]);\r\n            }\r\n        } else {\r\n            recovery = null;\r\n            resource = null;\r\n        }\r\n    } catch (Throwable exc) {\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.Configuration.getDirectory",
	"Comment": "returns a valid directory for a particular purpose.if the requireddirectory is not valid, then a default subdirectory of the current directoryis tried.if that is not valid either, then the current directory is used.",
	"Method": "String getDirectory(String envDir,String defaultSubdirectory,int[] result){\r\n    String envValue = null;\r\n    if (prop != null)\r\n        envValue = prop.getProperty(envDir);\r\n    result[0] = DIRECTORY_OK;\r\n    if (envValue == null || envValue.length() == 0 || (new File(envValue).exists() && !new File(envValue).isDirectory())) {\r\n        result[0] = DEFAULT_USED;\r\n        envValue = \".\" + File.separator + defaultSubdirectory;\r\n        if (new File(envValue).exists() && !new File(envValue).isDirectory()) {\r\n            result[0] = DEFAULT_INVALID;\r\n        }\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        String dirType = \"\";\r\n        switch(result[0]) {\r\n            case DEFAULT_INVALID:\r\n                dirType = \"used default, but is invalid\";\r\n                break;\r\n            case DEFAULT_USED:\r\n                dirType = \"used default\";\r\n                break;\r\n            case DIRECTORY_OK:\r\n                dirType = \"provided in configuration\";\r\n                break;\r\n            default:\r\n                dirType = \"invalid type\";\r\n                break;\r\n        }\r\n        _logger.logp(Level.FINE, \"Configuration\", \"getDirectory()\", \"Using directory = \" + envValue + \" : \" + dirType);\r\n    }\r\n    return envValue;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.ListUtil.reverse",
	"Comment": "return a new list in reverse order. because the list is new,it works on any list, modifiable or not.",
	"Method": "List<T> reverse(List<T> list){\r\n    final int numItems = list.size();\r\n    final List<T> result = new ArrayList<T>(numItems);\r\n    for (int i = 0; i < numItems; ++i) {\r\n        result.add(list.get(numItems - i - 1));\r\n    }\r\n    return (result);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.createFilter",
	"Comment": "instantiates the given filter class and performs any requiredresource injection into the new filter instance before returningit.",
	"Method": "T createFilter(Class<T> clazz){\r\n    if (isRestricted) {\r\n        throw new UnsupportedOperationException(rb.getString(LogFacade.UNSUPPORTED_OPERATION_EXCEPTION));\r\n    }\r\n    return context.createFilter(clazz);\r\n}"
}, {
	"Path": "org.glassfish.internal.data.EngineRef.save",
	"Comment": "saves its state to the configuration. this method must be called within a transactionto the configured engine instance.",
	"Method": "void save(Engine engine){\r\n    engine.setSniffer(getContainerInfo().getSniffer().getModuleType());\r\n    if (appConfig != null) {\r\n        engine.setApplicationConfig(appConfig);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.server.logging.logviewer.backend.LogFile.getFilePosition",
	"Comment": "this method returns the file position given the record number.",
	"Method": "BufferedReader getFilePosition(long recordNumber){\r\n    int index = (int) (recordNumber / getIndexSize());\r\n    if (index > _recordIdx.size() - 1) {\r\n        return null;\r\n    }\r\n    Long filePosition = (Long) _recordIdx.get(index);\r\n    return getLogFileReader(filePosition);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationHttpRequest.isRequestedSessionIdValid",
	"Comment": "returns true if the request specifies a jsessionid that is valid withinthe context of this applicationhttprequest, false otherwise.",
	"Method": "boolean isRequestedSessionIdValid(){\r\n    if (crossContext) {\r\n        String requestedSessionId = getRequestedSessionId();\r\n        if (requestedSessionId == null)\r\n            return (false);\r\n        if (context == null)\r\n            return (false);\r\n        if (session != null && requestedSessionId.equals(session.getIdInternal())) {\r\n            return session.isValid();\r\n        }\r\n        Manager manager = context.getManager();\r\n        if (manager == null)\r\n            return (false);\r\n        Session localSession = null;\r\n        try {\r\n            if (isSessionVersioningSupported) {\r\n                localSession = manager.findSession(requestedSessionId, requestedSessionVersion);\r\n            } else {\r\n                localSession = manager.findSession(requestedSessionId);\r\n            }\r\n        } catch (IOException e) {\r\n            localSession = null;\r\n        }\r\n        if ((localSession != null) && localSession.isValid()) {\r\n            return (true);\r\n        } else {\r\n            return (false);\r\n        }\r\n    } else {\r\n        return super.isRequestedSessionIdValid();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.contextListenerStart",
	"Comment": "notifies all servletcontextlisteners at their contextinitializedmethod.",
	"Method": "void contextListenerStart(){\r\n    ServletContextEvent event = new ServletContextEvent(getServletContext());\r\n    for (ServletContextListener listener : contextListeners) {\r\n        if (listener instanceof RestrictedServletContextListener) {\r\n            listener = ((RestrictedServletContextListener) listener).getNestedListener();\r\n            context.setRestricted(true);\r\n        }\r\n        try {\r\n            fireContainerEvent(ContainerEvent.BEFORE_CONTEXT_INITIALIZED, listener);\r\n            listener.contextInitialized(event);\r\n        } finally {\r\n            context.setRestricted(false);\r\n            fireContainerEvent(ContainerEvent.AFTER_CONTEXT_INITIALIZED, listener);\r\n        }\r\n    }\r\n    Collection<ServletRegistrationImpl> servletRegistrations = servletRegisMap.values();\r\n    for (ServletRegistrationImpl regis : servletRegistrations) {\r\n        if (null == regis.getClassName() && null == regis.getJspFile()) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.SERVLET_WITHOUT_ANY_CLASS_OR_JSP), regis.getName());\r\n            throw new IllegalStateException(msg);\r\n        }\r\n    }\r\n    Collection<FilterRegistrationImpl> filterRegistrations = filterRegisMap.values();\r\n    for (FilterRegistrationImpl regis : filterRegistrations) {\r\n        if (null == regis.getClassName()) {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.FILTER_WITHOUT_ANY_CLASS), regis.getName());\r\n            throw new IllegalStateException(msg);\r\n        }\r\n    }\r\n    isContextInitializedCalled = true;\r\n}"
}, {
	"Path": "org.glassfish.weld.services.EjbServicesImpl.methodOverridden",
	"Comment": "because it will have already been processed to see if it should be intercepted.",
	"Method": "boolean methodOverridden(Class beanClass,Method methodOfCurrentClass){\r\n    String methodName = methodOfCurrentClass.getName();\r\n    Class[] methodParams = methodOfCurrentClass.getParameterTypes();\r\n    Class declaringClass = methodOfCurrentClass.getDeclaringClass();\r\n    try {\r\n        Method method = beanClass.getMethod(methodName, methodParams);\r\n        return !method.getDeclaringClass().equals(declaringClass);\r\n    } catch (NoSuchMethodException ignored) {\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.StartLocalInstanceCommand.respawnArgs",
	"Comment": "return the asadmin command line arguments necessary tostart this server instance.",
	"Method": "String[] respawnArgs(){\r\n    List<String> args = new ArrayList<String>(15);\r\n    args.addAll(Arrays.asList(programOpts.getProgramArguments()));\r\n    args.add(getName());\r\n    args.add(\"--verbose=\" + String.valueOf(verbose));\r\n    args.add(\"--watchdog=\" + String.valueOf(watchdog));\r\n    args.add(\"--debug=\" + String.valueOf(debug));\r\n    if (ok(nodeDir)) {\r\n        args.add(\"--nodedir\");\r\n        args.add(nodeDir);\r\n    }\r\n    if (ok(node)) {\r\n        args.add(\"--node\");\r\n        args.add(node);\r\n    }\r\n    if (ok(instanceName))\r\n        args.add(instanceName);\r\n    if (logger.isLoggable(Level.FINER))\r\n        logger.finer(\"Respawn args: \" + args.toString());\r\n    String[] a = new String[args.size()];\r\n    args.toArray(a);\r\n    return a;\r\n}"
}, {
	"Path": "org.apache.catalina.loader.WebappLoader.start",
	"Comment": "start this component, initializing our associated class loader.",
	"Method": "void start(){\r\n    if (!initialized)\r\n        init();\r\n    if (started)\r\n        throw new LifecycleException(rb.getString(LogFacade.LOADER_ALREADY_STARTED_EXCEPTION));\r\n    if (log.isLoggable(Level.FINEST))\r\n        log.log(Level.FINEST, \"Starting this Loader\");\r\n    lifecycle.fireLifecycleEvent(START_EVENT, null);\r\n    started = true;\r\n    if (container.getResources() == null) {\r\n        if (log.isLoggable(Level.INFO)) {\r\n            log.log(Level.INFO, LogFacade.NO_RESOURCE_INFO, container);\r\n        }\r\n        return;\r\n    }\r\n    initStreamHandlerFactory();\r\n    try {\r\n        final ClassLoader cl = createClassLoader();\r\n        if (cl instanceof WebappClassLoader) {\r\n            classLoader = (WebappClassLoader) cl;\r\n        } else {\r\n            classLoader = AccessController.doPrivileged(new PrivilegedAction<WebappClassLoader>() {\r\n                @Override\r\n                public WebappClassLoader run() {\r\n                    return new WebappClassLoader(cl);\r\n                }\r\n            });\r\n        }\r\n        classLoader.setResources(container.getResources());\r\n        classLoader.setDebug(this.debug);\r\n        classLoader.setDelegate(this.delegate);\r\n        for (int i = 0; i < repositories.length; i++) {\r\n            classLoader.addRepository(repositories[i]);\r\n        }\r\n        if (overridablePackages != null) {\r\n            for (int i = 0; i < overridablePackages.size(); i++) {\r\n                classLoader.addOverridablePackage(overridablePackages.get(i));\r\n            }\r\n            overridablePackages = null;\r\n        }\r\n        setRepositories();\r\n        setClassPath();\r\n        setPermissions();\r\n        DirContextURLStreamHandler.bind(classLoader, this.container.getResources());\r\n    } catch (Throwable t) {\r\n        log.log(Level.SEVERE, LogFacade.LIFECYCLE_EXCEPTION, t);\r\n        throw new LifecycleException(\"start: \", t);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.loader.WebappLoader.start",
	"Comment": "start this component, initializing our associated class loader.",
	"Method": "void start(){\r\n    return new WebappClassLoader(cl);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.filterStop",
	"Comment": "finalize and release the set of filters for this context.return true if all filter finalization completedsuccessfully, or false otherwise.",
	"Method": "boolean filterStop(){\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \"Stopping filters\");\r\n    synchronized (filterConfigs) {\r\n        for (String filterName : filterConfigs.keySet()) {\r\n            String safeFilterName = neutralizeForLog(filterName);\r\n            if (log.isLoggable(Level.FINE)) {\r\n                log.log(Level.FINE, \" Stopping filter '\" + safeFilterName + \"'\");\r\n            }\r\n            ApplicationFilterConfig filterConfig = (ApplicationFilterConfig) filterConfigs.get(filterName);\r\n            filterConfig.release();\r\n        }\r\n        filterConfigs.clear();\r\n    }\r\n    return (true);\r\n}"
}, {
	"Path": "org.apache.naming.NamingContext.lookupLink",
	"Comment": "retrieves the named object, following links except for the terminal atomic component of the name.",
	"Method": "Object lookupLink(Name name,Object lookupLink,String name){\r\n    return lookup(new CompositeName(name), false);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.Environment.setPrefix",
	"Comment": "set the prefix for environment variables referenced from the system environment by environment objects.",
	"Method": "void setPrefix(String p){\r\n    PREFIX = p;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getCharsetMapperClass",
	"Comment": "return the locale to character set mapper class for this context.",
	"Method": "String getCharsetMapperClass(){\r\n    return (this.charsetMapperClass);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.intf.InterfaceMethodTest.studyInterface",
	"Comment": "study an interface by running an individual test on each method of theinteface then recursively study all the interfaces this interface extends",
	"Method": "boolean studyInterface(EjbDescriptor descriptor,Class clazz,Result result){\r\n    boolean allGood = true;\r\n    Method[] interfaceMethods = clazz.getDeclaredMethods();\r\n    for (Method interfaceMethod : interfaceMethods) {\r\n        if (Arrays.binarySearch(EJBObjectMethods, interfaceMethod.getName()) < 0) {\r\n            if (!runIndividualMethodTest(descriptor, interfaceMethod, result))\r\n                allGood = false;\r\n        }\r\n    }\r\n    for (Class intf : clazz.getInterfaces()) {\r\n        if (!studyInterface(descriptor, intf, result))\r\n            allGood = false;\r\n    }\r\n    return allGood;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.session.stateless.StatelessCreateOnlyOne.check",
	"Comment": "stateless session beans home interface create method test.the home interface of a stateless session bean must have a create method.the home interface must not have any other create methods.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    result = getInitializedResult();\r\n    compName = getVerifierContext().getComponentNameConstructor();\r\n    if (descriptor instanceof EjbSessionDescriptor) {\r\n        String stateType = ((EjbSessionDescriptor) descriptor).getSessionType();\r\n        if (EjbSessionDescriptor.STATELESS.equals(stateType)) {\r\n            if (descriptor.getHomeClassName() != null && !\"\".equals(descriptor.getHomeClassName()))\r\n                commonToBothInterfaces(descriptor.getHomeClassName(), (EjbSessionDescriptor) descriptor);\r\n            if (descriptor.getLocalHomeClassName() != null && !\"\".equals(descriptor.getLocalHomeClassName()))\r\n                commonToBothInterfaces(descriptor.getLocalHomeClassName(), (EjbSessionDescriptor) descriptor);\r\n        }\r\n    }\r\n    if (result.getStatus() != Result.FAILED) {\r\n        addGoodDetails(result, compName);\r\n        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"The bean's Home Interface has exactly one create Method defined\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.DigestAuthenticator.authenticate",
	"Comment": "authenticate the user making this request, based on the specifiedlogin configuration.return true if any specifiedconstraint has been satisfied, or false if we havecreated a response challenge already.",
	"Method": "boolean authenticate(HttpRequest request,HttpResponse response,LoginConfig config){\r\n    Principal principal = ((HttpServletRequest) request.getRequest()).getUserPrincipal();\r\n    if (principal != null)\r\n        return (true);\r\n    HttpServletRequest hreq = (HttpServletRequest) request.getRequest();\r\n    HttpServletResponse hres = (HttpServletResponse) response.getResponse();\r\n    String authorization = request.getAuthorization();\r\n    DigestInfo digestInfo = new DigestInfo(getOpaque(), getNonceValidity(), getKey(), isValidateUri());\r\n    if (authorization != null) {\r\n        boolean validRequest = digestInfo.validate(hreq, authorization, config);\r\n        if (validRequest) {\r\n            principal = context.getRealm().authenticate(hreq);\r\n            if (principal != null) {\r\n                String username = parseUsername(authorization);\r\n                register(request, response, principal, Constants.DIGEST_METHOD, username, null);\r\n                String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);\r\n                if (ssoId != null) {\r\n                    getSession(request, true);\r\n                }\r\n                return (true);\r\n            }\r\n        }\r\n    }\r\n    String nonce = generateNonce(hreq);\r\n    setAuthenticateHeader(hreq, hres, config, nonce, digestInfo.isNonceStale());\r\n    hres.sendError(HttpServletResponse.SC_UNAUTHORIZED);\r\n    return (false);\r\n}"
}, {
	"Path": "org.apache.catalina.valves.JDBCAccessLogValve.setStatusField",
	"Comment": "sets the name of the field containing the http response status code.",
	"Method": "void setStatusField(String statusField){\r\n    this.statusField = statusField;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.getFactory",
	"Comment": "return the saxparserfactory we will use, creating one if necessary.",
	"Method": "SAXParserFactory getFactory(){\r\n    if (factory == null) {\r\n        factory = SAXParserFactory.newInstance();\r\n        factory.setNamespaceAware(namespaceAware);\r\n        factory.setValidating(validating);\r\n    }\r\n    return (factory);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.runtime.ASEjbIORSecurityConfig.testMsgs1",
	"Comment": "this method will check for values that should be either none or supported",
	"Method": "void testMsgs1(String tCase,Result result,String parentElement,String testElement,ComponentNameConstructor compName){\r\n    if (tCase.length() == 0) {\r\n        oneFailed = true;\r\n        addErrorDetails(result, compName);\r\n        result.failed(smh.getLocalString(getClass().getName() + \".failedTestMsg\", \"FAILED [AS-EJB {1}] : {2} cannot be an empty String\", new Object[] { tCase, parentElement, testElement }));\r\n    } else {\r\n        if (!tCase.equals(\"NONE\") && !tCase.equals(\"SUPPORTED\")) {\r\n            oneFailed = true;\r\n            addErrorDetails(result, compName);\r\n            result.failed(smh.getLocalString(getClass().getName() + \".failedTestMsg2\", \"FAILED [AS-EJB {1}] : {2} cannot be {0}. It can be either NONE or SUPPORTED.\", new Object[] { tCase, parentElement, testElement }));\r\n        } else {\r\n            addGoodDetails(result, compName);\r\n            result.passed(smh.getLocalString(getClass().getName() + \".passedTestMsg\", \"PASSED [AS-EJB \" + parentElement + \"] : \" + testElement + \" is {0}\", new Object[] { tCase }));\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.logger.LoggerBase.setLevel",
	"Comment": "set the verbosity level of this logger.messages logged with ahigher verbosity than this level will be silently ignored.",
	"Method": "void setLevel(String logLevel){\r\n    if (\"SEVERE\".equalsIgnoreCase(logLevel)) {\r\n        log.setLevel(Level.SEVERE);\r\n    } else if (\"WARNING\".equalsIgnoreCase(logLevel)) {\r\n        log.setLevel(Level.WARNING);\r\n    } else if (\"INFO\".equalsIgnoreCase(logLevel)) {\r\n        log.setLevel(Level.INFO);\r\n    } else if (\"CONFIG\".equalsIgnoreCase(logLevel)) {\r\n        log.setLevel(Level.CONFIG);\r\n    } else if (\"FINE\".equalsIgnoreCase(logLevel)) {\r\n        log.setLevel(Level.FINE);\r\n    } else if (\"FINER\".equalsIgnoreCase(logLevel)) {\r\n        log.setLevel(Level.FINER);\r\n    } else if (\"FINEST\".equalsIgnoreCase(logLevel)) {\r\n        log.setLevel(Level.FINEST);\r\n    } else {\r\n        log.setLevel(Level.INFO);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.setMaxInstances",
	"Comment": "set the maximum number of instances that will be allocated when a singlethread model servlet is used.",
	"Method": "void setMaxInstances(int maxInstances){\r\n    int oldMaxInstances = this.maxInstances;\r\n    this.maxInstances = maxInstances;\r\n    support.firePropertyChange(\"maxInstances\", oldMaxInstances, this.maxInstances);\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.getSessionContext",
	"Comment": "return the session context with which this session is associated.",
	"Method": "HttpSessionContext getSessionContext(){\r\n    if (sessionContext == null)\r\n        sessionContext = new StandardSessionContext();\r\n    return (sessionContext);\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.FormAuthenticator.forwardToLoginPage",
	"Comment": "called to forward to the login page. may redirect current request to https",
	"Method": "void forwardToLoginPage(HttpRequest request,HttpResponse response,LoginConfig config){\r\n    if (isChangeSessionIdOnAuthentication() && getSession(request, false) != null) {\r\n        request.changeSessionId();\r\n    }\r\n    ServletContext sc = context.getServletContext();\r\n    try {\r\n        String loginPage = config.getLoginPage();\r\n        if (!request.getRequest().isSecure()) {\r\n            Realm realm = context.getRealm();\r\n            if (realm != null) {\r\n                SecurityConstraint[] secConstraints = realm.findSecurityConstraints(loginPage, \"GET\", context);\r\n                if (secConstraints != null && !realm.hasUserDataPermission(request, response, secConstraints, loginPage, \"GET\")) {\r\n                    return;\r\n                }\r\n            }\r\n        }\r\n        RequestDispatcher disp = sc.getRequestDispatcher(loginPage);\r\n        disp.forward(request.getRequest(), response.getResponse());\r\n        response.finishResponse();\r\n    } catch (Throwable t) {\r\n        log.log(Level.WARNING, LogFacade.UNEXPECTED_ERROR_FORWARDING_TO_LOGIN_PAGE, t);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getEffectiveMinorVersion",
	"Comment": "gets the minor version of the servlet specification that theapplication represented by this servletcontext is based on.",
	"Method": "int getEffectiveMinorVersion(){\r\n    if (isRestricted) {\r\n        throw new UnsupportedOperationException(rb.getString(LogFacade.UNSUPPORTED_OPERATION_EXCEPTION));\r\n    }\r\n    return context.getEffectiveMinorVersion();\r\n}"
}, {
	"Path": "org.apache.naming.SelectorContext.addToEnvironment",
	"Comment": "adds a new environment property to the environment of this context. if the property already exists, its value is overwritten.",
	"Method": "Object addToEnvironment(String propName,Object propVal){\r\n    return getBoundContext().addToEnvironment(propName, propVal);\r\n}"
}, {
	"Path": "org.glassfish.internal.data.ApplicationInfo.getAppClassLoader",
	"Comment": "returns the application classloader for this application.",
	"Method": "ClassLoader getAppClassLoader(){\r\n    return appClassLoader;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getSession",
	"Comment": "return the session associated with this request, creating oneif necessary and requested.",
	"Method": "HttpSession getSession(HttpSession getSession,boolean create){\r\n    Session session = doGetSession(create);\r\n    if (session != null) {\r\n        return session.getSession();\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getAttributeNames",
	"Comment": "return an enumeration of the names of the context attributesassociated with this context.",
	"Method": "Enumeration<String> getAttributeNames(){\r\n    return context.getAttributeNames();\r\n}"
}, {
	"Path": "org.apache.catalina.startup.Embedded.stop",
	"Comment": "gracefully terminate the active use of the public methods of thiscomponent.this method should be the last one called on a giveninstance of this component.",
	"Method": "void stop(){\r\n    if (log.isLoggable(Level.FINE))\r\n        log.log(Level.FINE, \"Stopping embedded server\");\r\n    if (!started)\r\n        throw new LifecycleException(rb.getString(LogFacade.SERVICE_NOT_BEEN_STARTED_EXCEPTION));\r\n    lifecycle.fireLifecycleEvent(STOP_EVENT, null);\r\n    started = false;\r\n    for (int i = 0; i < connectors.length; i++) {\r\n        if (connectors[i] instanceof Lifecycle)\r\n            ((Lifecycle) connectors[i]).stop();\r\n    }\r\n    for (int i = 0; i < engines.length; i++) {\r\n        if (engines[i] instanceof Lifecycle)\r\n            ((Lifecycle) engines[i]).stop();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.DefaultAccessLogFormatterImpl.appendClientDNS",
	"Comment": "appends the client dns of the given request to the given charbuffer.",
	"Method": "void appendClientDNS(CharBuffer cb,ServletRequest req){\r\n    cb.put(QUOTE);\r\n    String value = req.getRemoteAddr();\r\n    if (value == null) {\r\n        value = \"NULL-CLIENT-DNS\";\r\n    }\r\n    cb.put(value);\r\n    cb.put(QUOTE);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.DefaultAccessLogFormatterImpl.appendHeaderDate",
	"Comment": "appends the date header of the given request to the given char buffer.",
	"Method": "void appendHeaderDate(CharBuffer cb,HttpServletRequest hreq){\r\n    cb.put(QUOTE);\r\n    String date = hreq.getHeader(HTTP_HEADER_DATE);\r\n    if (date == null) {\r\n        date = \"NULL-HEADER-DATE\";\r\n    }\r\n    cb.put(date);\r\n    cb.put(QUOTE);\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.Descriptor.uniquifyString",
	"Comment": "returns string based on the trial name that is guaramteed to be differentfrom any of the strings in the vector of string names.",
	"Method": "String uniquifyString(String trialName,Vector<String> v,int index){\r\n    for (String next : v) {\r\n        if (next.equals(trialName)) {\r\n            index++;\r\n            return uniquifyString(stripIntegerEndingFrom(trialName) + index, v, index);\r\n        }\r\n    }\r\n    return trialName;\r\n}"
}, {
	"Path": "org.glassfish.diagnostics.context.impl.ContextManagerImplUnitTest.testGetContextUseOfContextMap_new",
	"Comment": "verify the expected delegation to contextmap by contextmanagerimpl on invocation of getcontext.",
	"Method": "void testGetContextUseOfContextMap_new(ContextMap mockedContextMap){\r\n    new Expectations() {\r\n        ContextMapHelper expectationsRefContextMapHelper;\r\n        {\r\n            expectationsRefContextMapHelper.getScopeAwareContextMap();\r\n            returns(mockedContextMap, null, null);\r\n        }\r\n        ContextMap expectationsRefContextMap = mockedContextMap;\r\n        {\r\n            expectationsRefContextMap.get(ContextManager.WORK_CONTEXT_KEY);\r\n            returns(null, null, null);\r\n            expectationsRefContextMap.createViewCapable(ContextManager.WORK_CONTEXT_KEY);\r\n            returns(null, null, null);\r\n        }\r\n    };\r\n    ContextManagerImpl cmi = new ContextManagerImpl();\r\n    Context ci = cmi.getContext();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.hash_transaction",
	"Comment": "returns a hash value based on the transaction associated with the targetobject.",
	"Method": "int hash_transaction(){\r\n    int result = hash;\r\n    if (tranState == null) {\r\n        INVALID_TRANSACTION exc = new INVALID_TRANSACTION(MinorCode.Completed, CompletionStatus.COMPLETED_NO);\r\n        throw exc;\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.common.util.timer.TimerSchedule.parseInt",
	"Comment": "convert a string to an int. throws illegalargumentexception instead ofthe numberformatexception.",
	"Method": "int parseInt(String s,String field){\r\n    try {\r\n        return Integer.parseInt(s);\r\n    } catch (NumberFormatException e) {\r\n        throw new IllegalArgumentException(\"Invalid \" + field + \" value: \" + s);\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.SetTopRule.isExactMatch",
	"Comment": "is exact matching being used.this rule uses org.apache.commons.beanutils.methodutils to introspect the relevent objects so that the right method can be called.originally, methodutils.invokeexactmethod was used.this matches methods very strictly and so may not find a matching method when one exists.this is still the behaviour when exact matching is enabled.when exact matching is disabled, methodutils.invokemethod is used.this method finds more methods but is less precise when there are several methods with correct signatures.so, if you want to choose an exact signature you might need to enable this property.the default setting is to disable exact matches.",
	"Method": "boolean isExactMatch(){\r\n    return useExactMatch;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationHttpRequest.incrementSessionVersion",
	"Comment": "increments the version of the given session, and stores it as arequest attribute, so it can later be included in a response cookie.",
	"Method": "void incrementSessionVersion(StandardSession ss,Context context){\r\n    if (ss == null || context == null) {\r\n        return;\r\n    }\r\n    String versionString = Long.toString(ss.incrementVersion());\r\n    Map<String, String> sessionVersions = getSessionVersions();\r\n    if (sessionVersions == null) {\r\n        sessionVersions = new HashMap<String, String>();\r\n        setAttribute(Globals.SESSION_VERSIONS_REQUEST_ATTRIBUTE, sessionVersions);\r\n    }\r\n    String path = context.getPath();\r\n    if (\"\".equals(path)) {\r\n        path = \"/\";\r\n    }\r\n    sessionVersions.put(path, versionString);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getServletRegistrations",
	"Comment": "gets a map of the servletregistration objects corresponding to allcurrently registered servlets.",
	"Method": "Map<String, ? extends ServletRegistration> getServletRegistrations(){\r\n    return Collections.unmodifiableMap(servletRegisMap);\r\n}"
}, {
	"Path": "org.apache.catalina.session.FileStore.save",
	"Comment": "save the specified session into this store.any previously savedinformation for the associated session identifier is replaced.",
	"Method": "void save(Session session){\r\n    File file = file(session.getIdInternal());\r\n    if (file == null) {\r\n        return;\r\n    }\r\n    if (debug >= 1) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.SAVING_SESSION_TO_FILE), new Object[] { session.getIdInternal(), file.getAbsolutePath() });\r\n        log(msg);\r\n    }\r\n    ObjectOutputStream oos = null;\r\n    try (FileOutputStream fos = new FileOutputStream(file.getAbsolutePath());\r\n        BufferedOutputStream bos = new BufferedOutputStream(fos)) {\r\n        Container container = manager.getContainer();\r\n        if (container != null) {\r\n            oos = ((StandardContext) container).createObjectOutputStream(bos);\r\n        } else {\r\n            oos = new ObjectOutputStream(bos);\r\n        }\r\n        oos.writeObject(session);\r\n    } catch (IOException e) {\r\n        throw e;\r\n    } finally {\r\n        if (oos != null) {\r\n            try {\r\n                oos.close();\r\n            } catch (IOException ioe) {\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.api.admin.AdminCommandLock.suspendCommands",
	"Comment": "lock the das from accepting any commands annotated with a sharedor exclusive commandlock.this method will result in the acquisitionof an exclusive lock.this method will not return until the lockis acquired, it times out or an error occurs.",
	"Method": "SuspendStatus suspendCommands(long timeout,String lockOwner,SuspendStatus suspendCommands,long timeout,String lockOwner,String message){\r\n    BlockingQueue<AdminCommandLock.SuspendStatus> suspendStatusQ = new ArrayBlockingQueue<AdminCommandLock.SuspendStatus>(1);\r\n    if (suspendCommandsLockThread != null && suspendCommandsLockThread.isAlive()) {\r\n        return SuspendStatus.ILLEGALSTATE;\r\n    }\r\n    suspendCommandsLockThread = new SuspendCommandsLockThread(timeout, suspendStatusQ, lockOwner, message);\r\n    try {\r\n        suspendCommandsLockThread.setName(\"DAS Suspended Command Lock Thread\");\r\n        suspendCommandsLockThread.setDaemon(true);\r\n    } catch (IllegalThreadStateException e) {\r\n        return SuspendStatus.ERROR;\r\n    } catch (SecurityException e) {\r\n        return SuspendStatus.ERROR;\r\n    }\r\n    suspendCommandsLockThread.start();\r\n    SuspendStatus suspendStatus = queueTake(suspendStatusQ);\r\n    return suspendStatus;\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionManagerImpl.rollback",
	"Comment": "roll back the transaction associated with the current thread. when thismethod completes, the thread becomes associated with no transaction.",
	"Method": "void rollback(){\r\n    try {\r\n        current.rollback();\r\n    } catch (NoTransaction ex) {\r\n        throw new IllegalStateException();\r\n    } catch (NO_PERMISSION ex) {\r\n        throw new SecurityException();\r\n    } catch (Exception ex) {\r\n        throw new SystemException(ex.toString());\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.FilterClassHasValidConstructor.runIndividualFilterTest",
	"Comment": "run the verifier test against a declared individual filter class",
	"Method": "boolean runIndividualFilterTest(Result result,Class filterClass){\r\n    boolean validConstructor = false;\r\n    boolean foundIt = false;\r\n    Class clazz = filterClass;\r\n    if (filterClass == null)\r\n        return false;\r\n    do {\r\n        Constructor[] constructors = filterClass.getDeclaredConstructors();\r\n        for (int i = 0; i < constructors.length; i++) {\r\n            logger.log(Level.FINE, getClass().getName() + \".debug\", new Object[] { constructors[i].toString() });\r\n            Class[] parameters = constructors[i].getParameterTypes();\r\n            if (parameters.length == 0) {\r\n                if (Modifier.isPublic(constructors[i].getModifiers())) {\r\n                    validConstructor = true;\r\n                } else {\r\n                    validConstructor = false;\r\n                }\r\n                foundIt = true;\r\n                ;\r\n            }\r\n        }\r\n    } while ((!foundIt) && ((filterClass = filterClass.getSuperclass()) != null));\r\n    if (validConstructor) {\r\n        result.addGoodDetails(smh.getLocalString(getClass().getName() + \".passed\", \"Listener class [ {0} ] implements a valid constructor.\", new Object[] { filterClass.getName() }));\r\n    } else {\r\n        result.addErrorDetails(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Listener class [ {0} ] does not implement a valid constructor.\", new Object[] { clazz.getName() }));\r\n    }\r\n    return validConstructor;\r\n}"
}, {
	"Path": "com.sun.appserv.web.taglibs.cache.CacheTag.setNocache",
	"Comment": "this attribute is used to programmatically enable or disable the useof the cached response.if nocache is true, then the cached response is not sent, insteadthe tag body is evaluated and sent out, the cache is not refreshedeither.",
	"Method": "void setNocache(boolean noCache){\r\n    if (noCache)\r\n        _useCachedResponse = false;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.server.ApplicationLifecycle.getArchive",
	"Comment": "cannot put it on the builder itself since the builder is an official api.",
	"Method": "ReadableArchive getArchive(DeploymentContextBuilder builder){\r\n    ReadableArchive archive = builder.sourceAsArchive();\r\n    if (archive == null && builder.sourceAsFile() == null) {\r\n        throw new IOException(\"Source archive or file not provided to builder\");\r\n    }\r\n    if (archive == null && builder.sourceAsFile() != null) {\r\n        archive = habitat.<ArchiveFactory>getService(ArchiveFactory.class).openArchive(builder.sourceAsFile());\r\n        if (archive == null) {\r\n            throw new IOException(\"Invalid archive type : \" + builder.sourceAsFile().getAbsolutePath());\r\n        }\r\n    }\r\n    return archive;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityCollection.removeMethod",
	"Comment": "remove the specified http request method from those that are partof this web resource collection.",
	"Method": "void removeMethod(String method){\r\n    if (method == null)\r\n        return;\r\n    int n = -1;\r\n    for (int i = 0; i < methods.length; i++) {\r\n        if (methods[i].equals(method)) {\r\n            n = i;\r\n            break;\r\n        }\r\n    }\r\n    if (n >= 0) {\r\n        int j = 0;\r\n        String[] results = new String[methods.length - 1];\r\n        for (int i = 0; i < methods.length; i++) {\r\n            if (i != n)\r\n                results[j++] = methods[i];\r\n        }\r\n        methods = results;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.appclient.AppClientVerifier.createClosureCompiler",
	"Comment": "creates the closurecompiler for the client jar and sets it to theverifier context. this is used to compute the closure on the classes usedin the client jar.",
	"Method": "void createClosureCompiler(){\r\n    String specVer = SpecVersionMapper.getAppClientVersion(verifierFrameworkContext.getJavaEEVersion());\r\n    Object arg = (isASMode) ? appclientd.getClassLoader() : (Object) getClassPath();\r\n    AppClientClosureCompiler cc = new AppClientClosureCompiler(specVer, ClassFileLoaderFactory.newInstance(new Object[] { arg }));\r\n    context.setClosureCompiler(cc);\r\n}"
}, {
	"Path": "org.glassfish.gms.bootstrap.GMSAdapterService.loadModule",
	"Comment": "initial support for multiple clusters in das. a clustered instance can only belong to one cluster.",
	"Method": "GMSAdapter loadModule(Cluster cluster){\r\n    GMSAdapter result = null;\r\n    synchronized (lock) {\r\n        result = getGMSAdapterByName(cluster.getName());\r\n        if (GMSBS_LOGGER.isLoggable(TRACE_LEVEL)) {\r\n            GMSBS_LOGGER.log(TRACE_LEVEL, \"lookup GMSAdapter by clusterName=\" + cluster.getName() + \" returned \" + result);\r\n        }\r\n        if (result == null) {\r\n            if (GMSBS_LOGGER.isLoggable(TRACE_LEVEL)) {\r\n                GMSBS_LOGGER.log(TRACE_LEVEL, \"creating gms-adapter for clustername \" + cluster.getName() + \" since no gms adapter found for clustername \" + cluster.getName());\r\n            }\r\n            result = gmsAdapterProvider.get();\r\n            if (result == null) {\r\n                GMSBS_LOGGER.log(LogLevel.WARNING, GMSBS_GMSADAPTER_NOT_AVAILABLE);\r\n                return null;\r\n            }\r\n            boolean initResult = result.initialize(cluster.getName());\r\n            if (initResult == false) {\r\n                return null;\r\n            }\r\n            ServiceLocatorUtilities.addOneConstant(habitat, result, cluster.getName(), GMSAdapter.class);\r\n            if (GMSBS_LOGGER.isLoggable(TRACE_LEVEL)) {\r\n                GMSBS_LOGGER.log(TRACE_LEVEL, \"loadModule: registered created gmsadapter for cluster \" + cluster.getName() + \" initialized result=\" + initResult);\r\n            }\r\n            gmsAdapters.add(result);\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.session.PersistentManager.getName",
	"Comment": "return the descriptive short name of this manager implementation.",
	"Method": "String getName(){\r\n    return (name);\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionManagerImpl.release",
	"Comment": "release a transaction. this call causes the calling thread to be dissociated from the specified transaction.",
	"Method": "void release(Xid xid){\r\n    GlobalTID tid = new GlobalTID(xid);\r\n    try {\r\n        CurrentTransaction.release(tid);\r\n    } catch (Throwable exc) {\r\n        String errorCode = WorkException.UNDEFINED;\r\n        if (exc instanceof INTERNAL) {\r\n            errorCode = WorkException.INTERNAL;\r\n        }\r\n        WorkException workExc = new WorkCompletedException(exc);\r\n        workExc.setErrorCode(errorCode);\r\n        throw workExc;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.server.ClassLoaderHierarchyImpl.createApplicationParentCL",
	"Comment": "sets up the parent class loader for the application class loader.application class loader are under the control of the archivehandler sincea special archive file format will require a specific class loader.however glassfish needs to be able to add capabilities to the applicationlike adding apis accessibility, this is done through its parent class loaderwhich we create and maintain.",
	"Method": "ClassLoader createApplicationParentCL(ClassLoader parent,DeploymentContext context){\r\n    final ReadableArchive source = context.getSource();\r\n    List<ModuleDefinition> defs = new ArrayList<ModuleDefinition>();\r\n    Manifest m = null;\r\n    try {\r\n        m = source.getManifest();\r\n    } catch (IOException e) {\r\n        logger.log(Level.SEVERE, \"Cannot load application's manifest file :\", e.getMessage());\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.log(Level.FINE, e.getMessage(), e);\r\n        }\r\n    }\r\n    if (m != null) {\r\n        String importedBundles = m.getMainAttributes().getValue(ManifestConstants.BUNDLE_IMPORT_NAME);\r\n        if (importedBundles != null) {\r\n            for (String token : new Tokenizer(importedBundles, \",\")) {\r\n                Collection<Module> modules = modulesRegistry.getModules(token);\r\n                if (modules.size() == 1) {\r\n                    defs.add(modules.iterator().next().getModuleDefinition());\r\n                } else {\r\n                    throw new ResolveError(\"Not able to locate a unique module by name \" + token);\r\n                }\r\n            }\r\n        }\r\n        String additionalRepo = m.getMainAttributes().getValue(org.glassfish.api.ManifestConstants.GLASSFISH_REQUIRE_REPOSITORY);\r\n        if (additionalRepo != null) {\r\n            for (String token : new Tokenizer(additionalRepo, \",\")) {\r\n                int equals = token.indexOf('=');\r\n                if (equals == -1) {\r\n                    throw new IllegalArgumentException(\"\\\"\" + org.glassfish.api.ManifestConstants.GLASSFISH_REQUIRE_REPOSITORY + \": \" + additionalRepo + \"\\\" is missing an '='.  \" + \"It must be in the format: name=path[,name=path]...\");\r\n                }\r\n                String name = token.substring(0, equals);\r\n                String path = token.substring(++equals);\r\n                addRepository(name, resolver.translate(path));\r\n            }\r\n        }\r\n        String requestedWiring = m.getMainAttributes().getValue(org.glassfish.api.ManifestConstants.GLASSFISH_REQUIRE_SERVICES);\r\n        if (requestedWiring != null) {\r\n            for (String token : new Tokenizer(requestedWiring, \",\")) {\r\n                for (Object impl : habitat.getAllServices(BuilderHelper.createContractFilter(token))) {\r\n                    Module wiredBundle = modulesRegistry.find(impl.getClass());\r\n                    if (wiredBundle != null) {\r\n                        defs.add(wiredBundle.getModuleDefinition());\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (defs.isEmpty()) {\r\n        return parent;\r\n    } else {\r\n        return modulesRegistry.getModulesClassLoader(parent, defs);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.cdi.hk2.HK2IntegrationExtension.afterDiscoveryObserver",
	"Comment": "called by cdi after going through all of the injection points. for eachservice known to hk2, adds a cdi bean.",
	"Method": "void afterDiscoveryObserver(AfterBeanDiscovery abd){\r\n    if (locator == null)\r\n        return;\r\n    HashSet<Class<? extends Annotation>> customScopes = new HashSet<Class<? extends Annotation>>();\r\n    for (ActiveDescriptor<?> descriptor : foundWithHK2.values()) {\r\n        abd.addBean(new HK2CDIBean(locator, descriptor));\r\n        customScopes.add(descriptor.getScopeAnnotation());\r\n    }\r\n    customScopes.remove(PerLookup.class);\r\n    customScopes.remove(Singleton.class);\r\n    List<org.glassfish.hk2.api.Context> hk2Contexts = locator.getAllServices(org.glassfish.hk2.api.Context.class);\r\n    for (org.glassfish.hk2.api.Context hk2Context : hk2Contexts) {\r\n        if (!customScopes.contains(hk2Context.getScope())) {\r\n            continue;\r\n        }\r\n        abd.addContext(new HK2ContextBridge(hk2Context));\r\n    }\r\n    foundWithHK2.clear();\r\n}"
}, {
	"Path": "org.apache.catalina.valves.RemoteHostValve.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (info);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorLog.openLog",
	"Comment": "opens the log file for all coordinatorlogs in this process.if the log has already been opened, the operation uses the opened logfile.",
	"Method": "boolean openLog(boolean openLog,String logPath){\r\n    boolean result = false;\r\n    String logName;\r\n    CoordinatorLogStateHolder logStateHolder = getStateHolder(logPath);\r\n    if (logStateHolder.log == null) {\r\n        logStateHolder.log = new Log(logPath);\r\n        if (!logStateHolder.log.initialise()) {\r\n            logStateHolder.log = null;\r\n            _logger.log(Level.SEVERE, \"jts.cannot_initialise_log\");\r\n            String msg = LogFormatter.getLocalizedMessage(_logger, \"jts.cannot_initialise_log\");\r\n            throw new org.omg.CORBA.INTERNAL(msg);\r\n        }\r\n    }\r\n    String serverName = null;\r\n    if (logStateHolder.log != null && (serverName = Configuration.getServerName(logPath)) != null) {\r\n        logStateHolder.logFile = logStateHolder.log.open(serverName, CoordinatorLogPool.getCoordinatorLog(logPath));\r\n        Configuration.setLogFile(logPath, logStateHolder.logFile);\r\n    }\r\n    result = (logStateHolder.logFile != null);\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.services.SMFService.setTimeoutSeconds",
	"Comment": "sets timeout in seconds before the master boot restarter shouldgive up starting this service.",
	"Method": "void setTimeoutSeconds(int number){\r\n    Integer to = Integer.valueOf(number);\r\n    if (to < 0) {\r\n        final String msg = sm.getString(\"invalidTO\", number);\r\n        throw new IllegalArgumentException(msg);\r\n    }\r\n    getTokenMap().put(TIMEOUT_SECONDS_TN, to.toString());\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.setProxyHandler",
	"Comment": "sets the proxyhandler implementation for this coyoteconnector to use.",
	"Method": "void setProxyHandler(ProxyHandler proxyHandler){\r\n    this.proxyHandler = proxyHandler;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.cmp2.CmpFieldsAbstract.runIndividualCmpFieldTest",
	"Comment": "run an individual verifier test of a declated cmp field of the class",
	"Method": "boolean runIndividualCmpFieldTest(Descriptor entity,Descriptor persistentField,Class c,Result result){\r\n    return isFieldAbstract(persistentField.getName(), c, result);\r\n}"
}, {
	"Path": "org.apache.catalina.session.PersistentManagerBase.setSaveOnRestart",
	"Comment": "set the option to save sessions to the store when the manager isshut down, then loaded when the manager starts again. if set tofalse, any sessions found in the store may still be picked up whenthe manager is started again.",
	"Method": "void setSaveOnRestart(boolean saveOnRestart){\r\n    if (saveOnRestart == this.saveOnRestart)\r\n        return;\r\n    boolean oldSaveOnRestart = this.saveOnRestart;\r\n    this.saveOnRestart = saveOnRestart;\r\n    support.firePropertyChange(\"saveOnRestart\", Boolean.valueOf(oldSaveOnRestart), Boolean.valueOf(this.saveOnRestart));\r\n}"
}, {
	"Path": "org.apache.catalina.realm.JAASRealm.createPrincipal",
	"Comment": "construct and return a java.security.principal instancerepresenting the authenticated user for the specified subject.if nosuch principal can be constructed, return null.",
	"Method": "Principal createPrincipal(String username,Subject subject){\r\n    ArrayList<String> roles = new ArrayList<String>();\r\n    Iterator principals = subject.getPrincipals().iterator();\r\n    while (principals.hasNext()) {\r\n        Principal principal = (Principal) principals.next();\r\n        if (principal instanceof GenericPrincipal) {\r\n            if (log.isLoggable(Level.FINE))\r\n                log.log(Level.FINE, \"Found old GenericPrincipal \" + principal);\r\n            return principal;\r\n        }\r\n        String principalClass = principal.getClass().getName();\r\n        if (log.isLoggable(Level.FINE))\r\n            log.log(Level.FINE, \"Principal: \" + principalClass + \" \" + principal);\r\n        if (userClasses.contains(principalClass)) {\r\n            username = principal.getName();\r\n        }\r\n        if (roleClasses.contains(principalClass)) {\r\n            roles.add(principal.getName());\r\n        }\r\n        if ((principal instanceof Group) && \"Roles\".equals(principal.getName())) {\r\n            Group grp = (Group) principal;\r\n            Enumeration en = grp.members();\r\n            while (en.hasMoreElements()) {\r\n                Principal roleP = (Principal) en.nextElement();\r\n                roles.add(roleP.getName());\r\n            }\r\n        }\r\n    }\r\n    if (username != null) {\r\n        return (new GenericPrincipal(this, username, null, roles));\r\n    } else {\r\n        return (null);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.generator.ASMClassWriter.debug",
	"Comment": "dump bytecode in class files so that we candecompile them to check the real content",
	"Method": "void debug(String clsName,byte[] classData){\r\n    clsName = clsName.replace('.', '/');\r\n    clsName = clsName.replace('\\\\', '/');\r\n    int index = clsName.lastIndexOf(\"/\");\r\n    if (index >= 0) {\r\n        clsName = clsName.substring(index + 1);\r\n    }\r\n    FileOutputStream fos = null;\r\n    try {\r\n        String rootPath = System.getProperty(SystemPropertyConstants.INSTALL_ROOT_PROPERTY) + File.separator + \"lib\" + File.separator + \"rest\" + File.separator;\r\n        File parentDir = new File(rootPath);\r\n        if (!parentDir.exists()) {\r\n            if (!parentDir.mkdirs()) {\r\n                throw new RuntimeException(\"Unable to create parent directory for generated class file logging\");\r\n            }\r\n        }\r\n        fos = new FileOutputStream(new File(parentDir, clsName + \".class\"));\r\n        fos.write(classData);\r\n        fos.flush();\r\n    } catch (Exception ex) {\r\n        ex.printStackTrace();\r\n    } finally {\r\n        if (fos != null) {\r\n            try {\r\n                fos.close();\r\n            } catch (IOException ex) {\r\n                RestLogging.restLogger.log(Level.SEVERE, null, ex);\r\n            }\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.setSsl3SessionTimeout",
	"Comment": "sets the number of seconds after which ssl3 sessions expire and areremoved from the ssl sessions cache.",
	"Method": "void setSsl3SessionTimeout(String timeout){\r\n    setProperty(\"ssl3SessionTimeout\", timeout);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.DelegatedRecoveryManager.getUniqueRMSet",
	"Comment": "reduce the set of xaresource objects into a unique set such that thereis at most one xaresource object per rm.",
	"Method": "Enumeration getUniqueRMSet(Enumeration xaResourceList){\r\n    Vector uniqueRMList = new Vector();\r\n    while (xaResourceList.hasMoreElements()) {\r\n        XAResource xaRes = (XAResource) xaResourceList.nextElement();\r\n        int size = uniqueRMList.size();\r\n        boolean match = false;\r\n        for (int i = 0; i < size; i++) {\r\n            XAResource uniqueXaRes = (XAResource) uniqueRMList.elementAt(i);\r\n            try {\r\n                if (xaRes.isSameRM(uniqueXaRes)) {\r\n                    match = true;\r\n                    break;\r\n                }\r\n            } catch (XAException xe) {\r\n            }\r\n        }\r\n        if (!match) {\r\n            uniqueRMList.add(xaRes);\r\n        }\r\n    }\r\n    return uniqueRMList.elements();\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.removeContext",
	"Comment": "stops the given context and removes it from thisvirtualserver.",
	"Method": "void removeContext(Context context){\r\n    ActionReport report = services.getService(ActionReport.class, \"plain\");\r\n    Deployment deployment = services.getService(Deployment.class);\r\n    String name;\r\n    if (context instanceof ContextFacade) {\r\n        name = ((ContextFacade) context).getAppName();\r\n    } else {\r\n        name = context.getPath();\r\n    }\r\n    ApplicationInfo appInfo = deployment.get(name);\r\n    if (appInfo == null) {\r\n        report.setMessage(\"Cannot find deployed application of name \" + name);\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        throw new GlassFishException(\"Cannot find deployed application of name \" + name);\r\n    }\r\n    ReadableArchive source = appInfo.getSource();\r\n    if (source == null) {\r\n        report.setMessage(\"Cannot get source archive for undeployment\");\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        throw new GlassFishException(\"Cannot get source archive for undeployment\");\r\n    }\r\n    UndeployCommandParameters params = new UndeployCommandParameters(name);\r\n    params.origin = UndeployCommandParameters.Origin.undeploy;\r\n    params.target = \"server\";\r\n    ExtendedDeploymentContext deploymentContext = null;\r\n    try {\r\n        deploymentContext = deployment.getBuilder(_logger, params, report).source(source).build();\r\n        deployment.undeploy(name, deploymentContext);\r\n        deployment.unregisterAppFromDomainXML(name, \"server\");\r\n    } catch (IOException e) {\r\n        _logger.log(Level.SEVERE, LogFacade.REMOVE_CONTEXT_ERROR, e);\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        throw new GlassFishException(\"Cannot create context for undeployment \", e);\r\n    } catch (TransactionFailure e) {\r\n        throw new GlassFishException(e);\r\n    } finally {\r\n        if (deploymentContext != null) {\r\n            deploymentContext.clean();\r\n        }\r\n    }\r\n    if (_logger.isLoggable(Level.FINE)) {\r\n        _logger.log(Level.FINE, LogFacade.REMOVED_CONTEXT, name);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.server.APIClassLoaderServiceImplTest.testBlackList",
	"Comment": "this test ensures that the apiclassloaderservice will not attempt to load a class or find a resource after \tan initial negative result until a module is installed or update.",
	"Method": "void testBlackList(){\r\n    APIClassLoaderServiceImpl apiClassLoaderService = new APIClassLoaderServiceImpl();\r\n    FakeClassLoader classLoader = new FakeClassLoader(getClass().getClassLoader());\r\n    FakeModulesRegistry mr = new FakeModulesRegistry(classLoader);\r\n    apiClassLoaderService.mr = mr;\r\n    assertEquals(0, mr.getLifecycleListeners().size());\r\n    apiClassLoaderService.postConstruct();\r\n    List<ModuleLifecycleListener> lifecycleListeners = mr.getLifecycleListeners();\r\n    assertEquals(\"apiClassLoaderService should have registered a lifecycle listener\", 1, mr.getLifecycleListeners().size());\r\n    ModuleLifecycleListener lifecycleListener = lifecycleListeners.iterator().next();\r\n    assertEquals(0, loadClassCalls);\r\n    final String BAD_CLASSNAME = \"BADCLASS\";\r\n    try {\r\n        apiClassLoaderService.getAPIClassLoader().loadClass(BAD_CLASSNAME);\r\n    } catch (ClassNotFoundException e) {\r\n    }\r\n    assertEquals(\"Classloader.loadClass not called at all\", 1, loadClassCalls);\r\n    try {\r\n        apiClassLoaderService.getAPIClassLoader().loadClass(BAD_CLASSNAME);\r\n    } catch (ClassNotFoundException e) {\r\n    }\r\n    assertEquals(\"blacklist not honored, excessive call to classloader.load\", 1, loadClassCalls);\r\n    assertEquals(0, getResourceCalls);\r\n    final String BAD_RESOURCE = \"BADRESOURCE\";\r\n    apiClassLoaderService.getAPIClassLoader().getResource(BAD_RESOURCE);\r\n    assertEquals(\"Classloader.findResource not called at all\", 1, getResourceCalls);\r\n    apiClassLoaderService.getAPIClassLoader().getResource(BAD_RESOURCE);\r\n    assertEquals(\"blacklist not honored, excessive call to classloader.getResource\", 1, getResourceCalls);\r\n    lifecycleListener.moduleInstalled(null);\r\n    apiClassLoaderService.getAPIClassLoader().getResource(BAD_RESOURCE);\r\n    assertEquals(\"blacklist did not clear after a module was installed\", 2, getResourceCalls);\r\n    try {\r\n        apiClassLoaderService.getAPIClassLoader().loadClass(BAD_CLASSNAME);\r\n    } catch (ClassNotFoundException e) {\r\n    }\r\n    assertEquals(\"blacklist did not clear after a module was installed\", 2, loadClassCalls);\r\n    lifecycleListener.moduleUpdated(null);\r\n    apiClassLoaderService.getAPIClassLoader().getResource(BAD_RESOURCE);\r\n    assertEquals(\"blacklist did not clear after a module was updated\", 3, getResourceCalls);\r\n    try {\r\n        apiClassLoaderService.getAPIClassLoader().loadClass(BAD_CLASSNAME);\r\n    } catch (ClassNotFoundException e) {\r\n    }\r\n    assertEquals(\"blacklist did not clear after a module was updated\", 3, loadClassCalls);\r\n}"
}, {
	"Path": "com.sun.enterprise.deploy.shared.FileArchive.isEntryValid",
	"Comment": "reports whether the entry is valid, in the sense that the entry ismore recent than the archive itself.",
	"Method": "boolean isEntryValid(File entry,boolean isEntryValid,File entry,boolean isLogging,boolean isEntryValid,File entry,boolean isLogging,Logger logger,boolean isEntryValid,String entryName,Logger logger,boolean isEntryValid,File f,boolean isLogging,boolean isEntryValid,File f,boolean isLogging,Logger logger,boolean isEntryValid,File f,boolean isLogging,boolean isEntryValid,File f,boolean isLogging,Logger logger,boolean isEntryValid,File f,boolean isLogging,boolean isEntryValid,File f,boolean isLogging,Logger logger){\r\n    return isEntryValid(getEntryFile(entryName), true, logger);\r\n}"
}, {
	"Path": "org.apache.catalina.valves.RequestDumperValve.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (info);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.CommandSecurityChecker.authorize",
	"Comment": "reports whether the subject is allowed to perform the specified admin command.",
	"Method": "boolean authorize(Subject subject,Map<String, Object> env,AdminCommand command,AdminCommandContext adminCommandContext){\r\n    if (subject == null) {\r\n        ADMSEC_AUTHZ_LOGGER.log(Level.WARNING, command.getClass().getName(), new IllegalArgumentException(\"subject\"));\r\n        subject = new Subject();\r\n    }\r\n    boolean result;\r\n    try {\r\n        if (command instanceof AdminCommandSecurity.Preauthorization) {\r\n            result = Subject.doAs(subject, new PrivilegedAction<Boolean>() {\r\n                @Override\r\n                public Boolean run() {\r\n                    return ((AdminCommandSecurity.Preauthorization) command).preAuthorization(adminCommandContext);\r\n                }\r\n            });\r\n            if (!result) {\r\n                return false;\r\n            }\r\n        }\r\n        final List<AccessCheckWork> accessChecks = assembleAccessCheckWork(command, subject);\r\n        result = (embeddedSystemAdministrator.matches(subject)) || checkAccessRequired(subject, env, command, accessChecks);\r\n    } catch (Exception ex) {\r\n        ADMSEC_AUTHZ_LOGGER.log(Level.SEVERE, AdminLoggerInfo.mUnexpectedException, ex);\r\n        throw new RuntimeException(ex);\r\n    }\r\n    if (!result) {\r\n        throw new SecurityException();\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.CommandSecurityChecker.authorize",
	"Comment": "reports whether the subject is allowed to perform the specified admin command.",
	"Method": "boolean authorize(Subject subject,Map<String, Object> env,AdminCommand command,AdminCommandContext adminCommandContext){\r\n    return ((AdminCommandSecurity.Preauthorization) command).preAuthorization(adminCommandContext);\r\n}"
}, {
	"Path": "org.apache.catalina.session.ManagerBase.getDistributable",
	"Comment": "return the distributable flag for the sessions supported bythis manager.",
	"Method": "boolean getDistributable(){\r\n    return distributable;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.clearLocales",
	"Comment": "clear the collection of locales associated with this request.",
	"Method": "void clearLocales(){\r\n    locales.clear();\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.services.impl.GrizzlyProxy.initialize",
	"Comment": "create a grizzlyservicelistener based on a networklistenerconfiguration object.",
	"Method": "void initialize(){\r\n    String port = networkListener.getPort();\r\n    portNumber = 8080;\r\n    if (port == null) {\r\n        logger.severe(KernelLoggerInfo.noPort);\r\n        throw new RuntimeException(\"Cannot find port information from domain configuration\");\r\n    }\r\n    try {\r\n        portNumber = Integer.parseInt(port);\r\n    } catch (NumberFormatException e) {\r\n        logger.log(Level.SEVERE, KernelLoggerInfo.badPort, port);\r\n    }\r\n    try {\r\n        address = InetAddress.getByName(networkListener.getAddress());\r\n    } catch (UnknownHostException ex) {\r\n        LogHelper.log(logger, Level.SEVERE, KernelLoggerInfo.badAddress, ex, address);\r\n    }\r\n    grizzlyListener = createGrizzlyListener(networkListener);\r\n    grizzlyListener.configure(grizzlyService.getHabitat(), networkListener);\r\n}"
}, {
	"Path": "org.glassfish.webservices.metroglue.MetroContainer.getHostName",
	"Comment": "lookup the canonical host name of the system this server instance is running on.",
	"Method": "String getHostName(){\r\n    return System.getProperty(SystemPropertyConstants.HOST_NAME_PROPERTY);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getUserPrincipal",
	"Comment": "return the principal that has been authenticated for this request.",
	"Method": "Principal getUserPrincipal(){\r\n    return userPrincipal;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardPipeline.getContainer",
	"Comment": "return the container with which this pipeline is associated.",
	"Method": "Container getContainer(){\r\n    return (this.container);\r\n}"
}, {
	"Path": "org.apache.catalina.servlets.WebdavServlet.generateLockDiscovery",
	"Comment": "print the lock discovery information associated with a path.",
	"Method": "boolean generateLockDiscovery(String path,XMLWriter generatedXML){\r\n    LockInfo resourceLock = resourceLocks.get(path);\r\n    Enumeration<LockInfo> collectionLocksList = collectionLocks.elements();\r\n    boolean wroteStart = false;\r\n    if (resourceLock != null) {\r\n        wroteStart = true;\r\n        generatedXML.writeElement(null, \"lockdiscovery\", XMLWriter.OPENING);\r\n        resourceLock.toXML(generatedXML);\r\n    }\r\n    while (collectionLocksList.hasMoreElements()) {\r\n        LockInfo currentLock = collectionLocksList.nextElement();\r\n        if (path.startsWith(currentLock.path)) {\r\n            if (!wroteStart) {\r\n                wroteStart = true;\r\n                generatedXML.writeElement(null, \"lockdiscovery\", XMLWriter.OPENING);\r\n            }\r\n            currentLock.toXML(generatedXML);\r\n        }\r\n    }\r\n    if (wroteStart) {\r\n        generatedXML.writeElement(null, \"lockdiscovery\", XMLWriter.CLOSING);\r\n    } else {\r\n        return false;\r\n    }\r\n    return true;\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.findResources",
	"Comment": "return an enumeration of urls representing all of theresources with the given name.if no resources with this name arefound, return an empty enumeration.",
	"Method": "Enumeration<URL> findResources(String name){\r\n    if (logger.isLoggable(Level.FINER))\r\n        logger.log(Level.FINER, \"    findResources(\" + name + \")\");\r\n    Vector<URL> result = new Vector<URL>();\r\n    if (repositories != null) {\r\n        int repositoriesLength = repositories.length;\r\n        int i;\r\n        for (i = 0; i < repositoriesLength; i++) {\r\n            try {\r\n                String fullPath = repositories[i] + name;\r\n                resources.lookup(fullPath);\r\n                try {\r\n                    result.addElement(getURI(new File(files[i], name)));\r\n                } catch (MalformedURLException e) {\r\n                }\r\n            } catch (NamingException e) {\r\n            }\r\n        }\r\n    }\r\n    Enumeration<URL> otherResourcePaths = super.findResources(name);\r\n    while (otherResourcePaths.hasMoreElements()) {\r\n        result.addElement(otherResourcePaths.nextElement());\r\n    }\r\n    return result.elements();\r\n}"
}, {
	"Path": "org.apache.catalina.util.ParameterMap.putAll",
	"Comment": "copy all of the mappings from the specified map to this one.thesemappings replace any mappings that this map had for any of the keyscurrently in the specified map.",
	"Method": "void putAll(Map<? extends K, ? extends V> map){\r\n    if (locked)\r\n        throw new IllegalStateException(rb.getString(LogFacade.MAP_IS_LOCKED_EXCEPTION));\r\n    super.putAll(map);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteRestAdminCommand.setInteractive",
	"Comment": "set the interactive mode for the command.by default, the command isinteractive.",
	"Method": "void setInteractive(boolean state){\r\n    this.interactive = state;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.jmx.OpenMBeanUtil.getThrowableOpenType",
	"Comment": "get a compositetype describing a compositedata which has no elements.",
	"Method": "OpenType getThrowableOpenType(Throwable t){\r\n    final String[] itemNames = new String[] { \"Message\", \"Cause\", \"StackTrace\" };\r\n    final String[] descriptions = new String[] { \"The message from the Throwable\", \"The cause (if any) from the Throwable\", \"The stack trace from the Throwable\" };\r\n    final OpenType[] openTypes = new OpenType[itemNames.length];\r\n    openTypes[0] = SimpleType.STRING;\r\n    openTypes[1] = t.getCause() == null ? SimpleType.VOID : getThrowableOpenType(t.getCause());\r\n    openTypes[2] = newArrayType(t.getStackTrace().length, getStackTraceElementOpenType());\r\n    return (new CompositeType(t.getClass().getName(), \"Throwable composite type\", itemNames, descriptions, openTypes));\r\n}"
}, {
	"Path": "com.sun.appserv.web.cache.mapping.ConstraintField.setCacheOnMatchFailure",
	"Comment": "set whether to cache should there be a failure forcing the constraint",
	"Method": "void setCacheOnMatchFailure(boolean cacheOnMatchFailure){\r\n    this.cacheOnMatchFailure = cacheOnMatchFailure;\r\n}"
}, {
	"Path": "examples.sfsb.TraderBean.ejbPassivate",
	"Comment": "this method is required by the ejb specification,but is not used by this example.",
	"Method": "void ejbPassivate(){\r\n    log(\"ejbPassivate called\");\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.findAliases",
	"Comment": "return the set of alias names for this host.if none are defined,a zero length array is returned.",
	"Method": "String[] findAliases(){\r\n    return (this.aliases);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.findInitParameters",
	"Comment": "return the names of all defined initialization parameters for thisservlet.",
	"Method": "String[] findInitParameters(){\r\n    synchronized (parameters) {\r\n        String[] results = new String[parameters.size()];\r\n        return parameters.keySet().toArray(results);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServerFacade.getWebListeners",
	"Comment": "gets the collection of weblistener instances from whichthis virtualserver receives requests.",
	"Method": "Collection<WebListener> getWebListeners(){\r\n    return webListeners;\r\n}"
}, {
	"Path": "components.taglib.ScrollerTag.setFor",
	"Comment": "the data grid component for which this acts as a scroller.this can be value or a value binding reference expression.",
	"Method": "void setFor(String newForValue){\r\n    forValue = newForValue;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.setTcpNoDelay",
	"Comment": "set the tcp no delay flag which will be set on the socket afteraccepting a connection.",
	"Method": "void setTcpNoDelay(boolean tcpNoDelay){\r\n    this.tcpNoDelay = tcpNoDelay;\r\n    setProperty(\"tcpNoDelay\", String.valueOf(tcpNoDelay));\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.setContextClass",
	"Comment": "set the java class name of the context implementation classfor new web applications.",
	"Method": "void setContextClass(String contextClass){\r\n    String oldContextClass = this.contextClass;\r\n    this.contextClass = contextClass;\r\n    support.firePropertyChange(\"contextClass\", oldContextClass, this.contextClass);\r\n}"
}, {
	"Path": "org.apache.naming.NamingContextEnumeration.hasMore",
	"Comment": "determines whether there are any more elements in the enumeration.",
	"Method": "boolean hasMore(){\r\n    return iterator.hasNext();\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.getServletRegistrations",
	"Comment": "gets a map of the servletregistration objects corresponding to allcurrently registered servlets.",
	"Method": "Map<String, ? extends ServletRegistration> getServletRegistrations(){\r\n    if (SecurityUtil.isPackageProtectionEnabled()) {\r\n        return (Map<String, ServletRegistration>) doPrivileged(\"getServletRegistrations\", null);\r\n    } else {\r\n        return context.getServletRegistrations();\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.webservices.JAXWSServiceDelegate.init",
	"Comment": "convert invocation method to a constant for easier processing.",
	"Method": "void init(){\r\n    serviceMethodTypes = new HashMap();\r\n    fullWsdlIllegalMethods = new HashSet();\r\n    noWsdlIllegalMethods = new HashSet();\r\n    try {\r\n        Class[] noParams = new Class[0];\r\n        Class serviceClass = javax.xml.ws.Service.class;\r\n        Method addPort = serviceClass.getDeclaredMethod(\"addPort\", new Class[] { QName.class, URI.class, String.class });\r\n        serviceMethodTypes.put(addPort, Integer.valueOf(ADD_PORT));\r\n        Method createDispatchClass = serviceClass.getDeclaredMethod(\"createDispatch\", new Class[] { QName.class, Class.class, Service.Mode.class });\r\n        serviceMethodTypes.put(createDispatchClass, Integer.valueOf(CREATE_DISPATCH_CLASS));\r\n        Method createDispatchContext = serviceClass.getDeclaredMethod(\"createDispatch\", new Class[] { QName.class, JAXBContext.class, Service.Mode.class });\r\n        serviceMethodTypes.put(createDispatchContext, Integer.valueOf(CREATE_DISPATCH_CONTEXT));\r\n        Method getExecutor = serviceClass.getDeclaredMethod(\"getExecutor\", noParams);\r\n        serviceMethodTypes.put(getExecutor, Integer.valueOf(GET_EXECUTOR));\r\n        Method setExecutor = serviceClass.getDeclaredMethod(\"setExecutor\", new Class[] { Executor.class });\r\n        serviceMethodTypes.put(setExecutor, Integer.valueOf(SET_EXECUTOR));\r\n        Method getHandlerResolver = serviceClass.getDeclaredMethod(\"getHandlerResolver\", noParams);\r\n        serviceMethodTypes.put(getHandlerResolver, Integer.valueOf(GET_HANDLER_RESOLVER));\r\n        Method getPortContainerManaged = serviceClass.getDeclaredMethod(\"getPort\", new Class[] { Class.class });\r\n        serviceMethodTypes.put(getPortContainerManaged, Integer.valueOf(GET_PORT_CONTAINER_MANAGED));\r\n        Method getPortClientManaged = serviceClass.getDeclaredMethod(\"getPort\", new Class[] { QName.class, Class.class });\r\n        serviceMethodTypes.put(getPortClientManaged, Integer.valueOf(GET_PORT_CLIENT_MANAGED));\r\n        Method getPorts = serviceClass.getDeclaredMethod(\"getPorts\", noParams);\r\n        serviceMethodTypes.put(getPorts, Integer.valueOf(GET_PORTS));\r\n        Method getServiceName = serviceClass.getDeclaredMethod(\"getServiceName\", noParams);\r\n        serviceMethodTypes.put(getServiceName, Integer.valueOf(GET_SERVICE_NAME));\r\n        Method setHandlerResolver = serviceClass.getDeclaredMethod(\"setHandlerResolver\", new Class[] { HandlerResolver.class });\r\n        serviceMethodTypes.put(setHandlerResolver, Integer.valueOf(SET_HANDLER_RESOLVER));\r\n        Method getWsdlLocation = serviceClass.getDeclaredMethod(\"getWSDLDocumentLocation\", noParams);\r\n        serviceMethodTypes.put(getWsdlLocation, Integer.valueOf(GET_WSDL_LOCATION));\r\n    } catch (NoSuchMethodException nsme) {\r\n    }\r\n    noWsdlIllegalMethods.add(Integer.valueOf(GET_PORT_CONTAINER_MANAGED));\r\n    noWsdlIllegalMethods.add(Integer.valueOf(GET_PORT_CLIENT_MANAGED));\r\n    noWsdlIllegalMethods.add(Integer.valueOf(GET_PORTS));\r\n    noWsdlIllegalMethods.add(Integer.valueOf(GET_SERVICE_NAME));\r\n    noWsdlIllegalMethods.add(Integer.valueOf(GET_WSDL_LOCATION));\r\n    noWsdlIllegalMethods.add(Integer.valueOf(GENERATED_SERVICE_METHOD));\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.AuthenticatorBase.getSession",
	"Comment": "return the internal session that is associated with this httprequest,possibly creating a new one if necessary, or null ifthere is no such session and we did not create one.",
	"Method": "Session getSession(HttpRequest request,Session getSession,HttpRequest request,boolean create){\r\n    return request.getSessionInternal(create);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getWatchedResources",
	"Comment": "gets the watched resources defined for this web application.",
	"Method": "List<String> getWatchedResources(){\r\n    return watchedResources;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ContainerBase.threadStop",
	"Comment": "stop the background thread that is periodically checking forsession timeouts.",
	"Method": "void threadStop(){\r\n    if (thread == null)\r\n        return;\r\n    threadDone = true;\r\n    thread.interrupt();\r\n    try {\r\n        thread.join();\r\n    } catch (InterruptedException e) {\r\n    }\r\n    thread = null;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.getLogger",
	"Comment": "return the current logger associated with this instance of the digester",
	"Method": "Logger getLogger(){\r\n    return log;\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.Descriptor.recursiveStripIntegerEndingFrom",
	"Comment": "returns the largest substring of the given string thatdoes not have an integer at the end.",
	"Method": "String recursiveStripIntegerEndingFrom(String s){\r\n    if (s.length() > 1) {\r\n        String shorterByOne = s.substring(0, s.length() - 1);\r\n        String lastBit = s.substring(s.length() - 1, s.length());\r\n        try {\r\n            Integer.parseInt(lastBit);\r\n            return recursiveStripIntegerEndingFrom(shorterByOne);\r\n        } catch (NumberFormatException nfe) {\r\n            return s;\r\n        }\r\n    }\r\n    return s;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServerFacade.setConfig",
	"Comment": "reconfigures this virtualserver with the givenconfiguration.in order for the given configuration to take effect, thisvirtualserver may be stopped and restarted.",
	"Method": "void setConfig(VirtualServerConfig config){\r\n    this.config = config;\r\n    if (vs != null) {\r\n        vs.setConfig(config);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.pwc.PwcWebModule.createWrapper",
	"Comment": "factory method to create and return a new wrapper instance, ofthe java implementation class appropriate for this contextimplementation.the constructor of the instantiated wrapperwill have been called, but no properties will have been set.",
	"Method": "Wrapper createWrapper(){\r\n    Wrapper wrapper = super.createWrapper();\r\n    ((StandardWrapper) wrapper).setMaxInstances(stmPoolSize);\r\n    return wrapper;\r\n}"
}, {
	"Path": "org.glassfish.admin.cli.resources.DeleteResourceRef.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    try {\r\n        if (refName.equals(\"jdbc/__default\")) {\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            report.setMessage(localStrings.getLocalString(\"delete.resource.ref.jdbc.default\", \"Default JDBC resource ref cannot be deleted.\"));\r\n            return;\r\n        }\r\n        if (refName.equals(\"jms/__defaultConnectionFactory\")) {\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            report.setMessage(localStrings.getLocalString(\"delete.resource.ref.jms.default\", \"Default JMS connection factory ref cannot be deleted.\"));\r\n            return;\r\n        }\r\n        deleteResourceRef();\r\n        if (refContainer instanceof Cluster) {\r\n            Target tgt = habitat.getService(Target.class);\r\n            List<Server> instances = tgt.getInstances(target);\r\n            for (Server svr : instances) {\r\n                svr.deleteResourceRef(refName);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        setFailureMessage(report, e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    report.setMessage(localStrings.getLocalString(\"delete.resource.ref.success\", \"resource-ref {0} deleted successfully from target {1}.\", refName, target));\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.stringsubs.impl.algorithm.TestRadixTreeSubstitution.testInputWithoutSpace",
	"Comment": "test substitution for continuous input i.e input without any space.",
	"Method": "void testInputWithoutSpace(){\r\n    assertEquals(callSubstitution(\"acidysonacidyso\"), \"acidValysonValacidValyso\");\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.ChangeNodeMasterPasswordCommand.createMasterPasswordFile",
	"Comment": "create the master password keystore. this routine can also modify the master passwordif the keystore already exists",
	"Method": "void createMasterPasswordFile(){\r\n    final File pwdFile = new File(this.getServerDirs().getAgentDir(), MASTER_PASSWORD_ALIAS);\r\n    try {\r\n        PasswordAdapter p = new PasswordAdapter(pwdFile.getAbsolutePath(), MASTER_PASSWORD_ALIAS.toCharArray());\r\n        p.setPasswordForAlias(MASTER_PASSWORD_ALIAS, newPassword.getBytes());\r\n        pwdFile.setReadable(true);\r\n        pwdFile.setWritable(true);\r\n    } catch (Exception ex) {\r\n        throw new CommandException(strings.get(\"masterPasswordFileNotCreated\", pwdFile), ex);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.common.util.timer.TimerSchedule.processRange",
	"Comment": "process a range of values for that represents values other than days of the month.",
	"Method": "void processRange(String s,BitSet bits,int start,int size,String field){\r\n    String[] arr = splitBy(s, rangeChar);\r\n    int begin = getNumericValue(arr[0], start, size, field);\r\n    int end = getNumericValue(arr[1], start, size, field);\r\n    if (begin < 0) {\r\n        throw new IllegalArgumentException(\"Negative range start for \" + field + \" : \" + s);\r\n    }\r\n    boolean b = isDayOfWeek(field);\r\n    if (b && (arr[0].equals(Integer.toString(start)) && arr[1].equals(Integer.toString(size)))) {\r\n        for (int i = start; i <= size; i++) {\r\n            bits.set(conversionTable.get(i));\r\n        }\r\n    } else {\r\n        if (b) {\r\n            setBitsRange(bits, begin, end, 1, 8);\r\n        } else {\r\n            setBitsRange(bits, begin, end, 0, size);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.adapter.AdminConsoleAdapter.setRegistered",
	"Comment": "marks this adapter as having been registered or unregistered as anetwork endpoint",
	"Method": "void setRegistered(boolean isRegistered){\r\n    this.isRegistered = isRegistered;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebModule.addCatalinaListener",
	"Comment": "adds the catalina listener with the given class name to thiswebmodule.",
	"Method": "void addCatalinaListener(String listenerName){\r\n    Object listener = loadInstance(listenerName);\r\n    if (listener == null)\r\n        return;\r\n    if (listener instanceof ContainerListener) {\r\n        addContainerListener((ContainerListener) listener);\r\n    } else if (listener instanceof LifecycleListener) {\r\n        addLifecycleListener((LifecycleListener) listener);\r\n    } else if (listener instanceof InstanceListener) {\r\n        addInstanceListener(listenerName);\r\n    } else {\r\n        logger.log(Level.SEVERE, LogFacade.INVALID_LISTENER, new Object[] { listenerName, getName() });\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.common.util.timer.TimerSchedule.configure",
	"Comment": "populate all internale structures to be used for the next timeoutcalculations",
	"Method": "void configure(){\r\n    parseNumbersOrNames(second_, seconds, 0, 60, true, SECOND);\r\n    parseNumbersOrNames(minute_, minutes, 0, 60, true, MINUTE);\r\n    parseNumbersOrNames(hour_, hours, 0, 24, true, HOUR);\r\n    parseNumbersOrNames(dayOfWeek_, daysOfWeek, 0, 7, false, DAY_OF_WEEK);\r\n    parseNumbersOrNames(month_, months, 1, 12, false, MONTH);\r\n    parseDaysOfMonth();\r\n    parseYears();\r\n    if (timezone_ != null) {\r\n        tz_ = TimeZone.getTimeZone(timezone_);\r\n    }\r\n    configured = true;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.LegacyCompositeResource.options",
	"Comment": "this method will handle any options requests for composite resources.",
	"Method": "String options(){\r\n    RestResourceMetadata rrmd = new RestResourceMetadata(this);\r\n    return rrmd.toJson().toString(Util.getFormattingIndentLevel());\r\n}"
}, {
	"Path": "com.sun.enterprise.config.modularity.ConfigModularityUtils.getMatchingSetterMethod",
	"Comment": "finds and return the setter method matching the class identified by typetoset",
	"Method": "Method getMatchingSetterMethod(Class classToQuery,Class typeToSet){\r\n    String className = typeToSet.getName().substring(typeToSet.getName().lastIndexOf(\".\") + 1, typeToSet.getName().length());\r\n    String setterName = \"set\" + className;\r\n    Method[] methods = classToQuery.getClass().getMethods();\r\n    for (Method method : methods) {\r\n        if (method.getName().equalsIgnoreCase(setterName)) {\r\n            return method;\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "org.glassfish.config.support.XMLStreamReaderFilter.skipTree",
	"Comment": "skips a whole subtree, and return with the cursor pointing to the end elementof the skipped subtree.",
	"Method": "void skipTree(){\r\n    int depth = 1;\r\n    while (depth > 0) {\r\n        int r = super.next();\r\n        if (r == START_ELEMENT) {\r\n            depth++;\r\n        } else if (r == END_ELEMENT) {\r\n            depth--;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.loader.ServletContainerInitializerUtil.scanDirectory",
	"Comment": "given a directory, scan all sub directories looking for classes andbuild the interest list",
	"Method": "void scanDirectory(File dir,ClassDependencyBuilder classInfo){\r\n    File[] files = dir.listFiles();\r\n    for (File file : files) {\r\n        if (file.isFile()) {\r\n            String fileName = file.getPath();\r\n            if (fileName.endsWith(\".class\")) {\r\n                try {\r\n                    InputStream is = null;\r\n                    ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n                    try {\r\n                        is = new BufferedInputStream(new FileInputStream(fileName));\r\n                        byte[] bs = new byte[2048];\r\n                        int size = -1;\r\n                        while ((size = is.read(bs)) >= 0) {\r\n                            baos.write(bs, 0, size);\r\n                        }\r\n                        classInfo.loadClassData(baos.toByteArray());\r\n                    } finally {\r\n                        if (is != null) {\r\n                            is.close();\r\n                        }\r\n                        baos.close();\r\n                    }\r\n                } catch (Throwable t) {\r\n                    if (log.isLoggable(Level.WARNING)) {\r\n                        log.log(Level.WARNING, LogFacade.CLASS_LOADING_ERROR, new Object[] { fileName, t.toString() });\r\n                    }\r\n                    continue;\r\n                }\r\n            }\r\n        } else {\r\n            scanDirectory(file, classInfo);\r\n        }\r\n    }\r\n    return;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setTldNamespaceAware",
	"Comment": "set the namespace aware feature of the xml parser used whenparsing xml instances.",
	"Method": "void setTldNamespaceAware(boolean tldNamespaceAware){\r\n    this.tldNamespaceAware = tldNamespaceAware;\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.WebListenerBase.setWebContainer",
	"Comment": "sets the webcontainer which will be used by this weblistener.",
	"Method": "void setWebContainer(WebContainer webContainer){\r\n    this.webContainer = webContainer;\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.VirtualServerConfig.setAllowLinking",
	"Comment": "enables or disables the serving of resources that are symbolic links.",
	"Method": "void setAllowLinking(boolean allowLinking){\r\n    this.allowLinking = allowLinking;\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.DeleteVirtualServer.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    ActionReport report = context.getActionReport();\r\n    httpService = config.getHttpService();\r\n    networkConfig = config.getNetworkConfig();\r\n    if (!exists()) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.DELETE_VIRTUAL_SERVER_NOT_EXISTS), vsid));\r\n        report.setActionExitCode(ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    String referencedBy = getReferencingListener();\r\n    if (referencedBy != null && referencedBy.length() != 0) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.DELETE_VIRTUAL_SERVER_REFERENCED), vsid, referencedBy));\r\n        report.setActionExitCode(ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        List<ApplicationRef> appRefs = new ArrayList<ApplicationRef>();\r\n        for (ApplicationRef appRef : server.getApplicationRef()) {\r\n            if (appRef.getVirtualServers() != null && appRef.getVirtualServers().contains(vsid)) {\r\n                appRefs.add(appRef);\r\n            }\r\n        }\r\n        ConfigBeanProxy[] proxies = new ConfigBeanProxy[appRefs.size() + 1];\r\n        proxies[0] = httpService;\r\n        for (int i = 0; i < appRefs.size(); i++) {\r\n            proxies[i + 1] = appRefs.get(i);\r\n        }\r\n        ConfigSupport.apply(new ConfigUpdate(vsid), proxies);\r\n        report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.DELETE_VIRTUAL_SERVER_FAIL), vsid));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.LoginConfig.setFormLoginConfig",
	"Comment": "set the form login configuration, if the authenticationmethod is form based authentication",
	"Method": "void setFormLoginConfig(FormLoginConfig flc){\r\n    formLoginConfig = flc;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.setSessionTrackingModes",
	"Comment": "sets the session tracking modes that are to become effective for thisservletcontext.",
	"Method": "void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes){\r\n    if (SecurityUtil.isPackageProtectionEnabled()) {\r\n        doPrivileged(\"setSessionTrackingModes\", new Object[] { sessionTrackingModes });\r\n    } else {\r\n        context.setSessionTrackingModes(sessionTrackingModes);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.JobCreatorService.createJob",
	"Comment": "this will create a new job with the name of command and a new unused id for the job",
	"Method": "Job createJob(String id,String scope,String name,Subject subject,boolean isManagedJob,ParameterMap parameters){\r\n    AdminCommandInstanceImpl job = null;\r\n    if (isManagedJob) {\r\n        job = new AdminCommandInstanceImpl(id, name, scope, subject, true, parameters);\r\n        job.setJobsFile(jobManagerService.jobsFile);\r\n    } else {\r\n        job = new AdminCommandInstanceImpl(name, scope, subject, false, parameters);\r\n    }\r\n    return job;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.metadata.ParamMetadata.getDefaultValue",
	"Comment": "this method will process the annotations for a field to try to determine the default value, if one has been specified.",
	"Method": "Object getDefaultValue(Object getDefaultValue,Annotation[] annos){\r\n    Object defval = null;\r\n    if (annos != null) {\r\n        for (Annotation annotation : annos) {\r\n            if (Default.class.isAssignableFrom(annotation.getClass())) {\r\n                try {\r\n                    Default def = (Default) annotation;\r\n                    Class clazz = def.generator();\r\n                    if (def.useContext()) {\r\n                        defval = ((DefaultsGenerator) context).getDefaultValue(name);\r\n                    } else if (clazz != null && clazz != Void.class) {\r\n                        if (DefaultsGenerator.class.isAssignableFrom(clazz)) {\r\n                            defval = ((DefaultsGenerator) clazz.newInstance()).getDefaultValue(name);\r\n                        } else {\r\n                            RestLogging.restLogger.log(Level.SEVERE, RestLogging.DOESNT_IMPLEMENT_DEFAULTS_GENERATOR);\r\n                        }\r\n                    } else {\r\n                        defval = parseValue(def.value());\r\n                    }\r\n                    break;\r\n                } catch (Exception ex) {\r\n                    RestLogging.restLogger.log(Level.SEVERE, null, ex);\r\n                }\r\n            } else if (Attribute.class.isAssignableFrom(annotation.getClass())) {\r\n                Attribute attr = (Attribute) annotation;\r\n                defval = attr.defaultValue();\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return defval;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.ejb.EjbVerifier.getClassPath",
	"Comment": "creates and returns the class path associated with the ejb archive.uses the exploded location of the archive for generating the classpath.",
	"Method": "String getClassPath(){\r\n    if (classPath != null)\r\n        return classPath;\r\n    if (isASMode)\r\n        return (classPath = getClassPath(verifierFrameworkContext.getClassPath()));\r\n    String cp;\r\n    if (!ejbd.getModuleDescriptor().isStandalone()) {\r\n        String ear_uri = verifierFrameworkContext.getExplodedArchivePath();\r\n        File ear = new File(ear_uri);\r\n        assert (ear.isDirectory());\r\n        String earCP = ClassPathBuilder.buildClassPathForEar(ear);\r\n        String libdir = ejbd.getApplication().getLibraryDirectory();\r\n        if (libdir != null) {\r\n            earCP = getLibdirClasspath(ear_uri, libdir) + earCP;\r\n        }\r\n        String module_uri = ejbd.getModuleDescriptor().getArchiveUri();\r\n        File module = new File(module_uri);\r\n        assert (module.isFile() && !module.isAbsolute());\r\n        File explodedModuleDir = new File(ear_uri, FileUtils.makeFriendlyFilename(module_uri));\r\n        String moduleCP = ClassPathBuilder.buildClassPathForJar(explodedModuleDir);\r\n        cp = moduleCP + File.pathSeparator + earCP;\r\n    } else {\r\n        String module_uri = verifierFrameworkContext.getExplodedArchivePath();\r\n        File module = new File(module_uri);\r\n        assert (module.isDirectory() && module.isAbsolute());\r\n        cp = ClassPathBuilder.buildClassPathForJar(module);\r\n    }\r\n    return (classPath = cp);\r\n}"
}, {
	"Path": "org.apache.catalina.loader.StandardClassLoader.findResources",
	"Comment": "return an enumeration of urls representing all of theresources with the given name.if no resources with this name arefound, return an empty enumeration.",
	"Method": "Enumeration<URL> findResources(String name){\r\n    if (debug >= 3)\r\n        log(\"    findResources(\" + name + \")\");\r\n    return (super.findResources(name));\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.services.impl.GrizzlyService.postConstruct",
	"Comment": "the component has been injected with any dependency andwill be placed into commission by the subsystem.",
	"Method": "void postConstruct(){\r\n    events.register(this);\r\n    final NetworkConfig networkConfig = config.getNetworkConfig();\r\n    configListener = new DynamicConfigListener(config, LOGGER);\r\n    ObservableBean bean = (ObservableBean) ConfigSupport.getImpl(networkConfig.getNetworkListeners());\r\n    bean.addListener(configListener);\r\n    bean = (ObservableBean) ConfigSupport.getImpl(config.getHttpService());\r\n    bean.addListener(configListener);\r\n    transactions.addListenerForType(SystemProperty.class, configListener);\r\n    configListener.setGrizzlyService(this);\r\n    try {\r\n        boolean isAtLeastOneProxyStarted = false;\r\n        futures = new ArrayList<Future<Result<Thread>>>();\r\n        for (NetworkListener listener : networkConfig.getNetworkListeners().getNetworkListener()) {\r\n            isAtLeastOneProxyStarted |= (createNetworkProxy(listener) != null);\r\n        }\r\n        if (isAtLeastOneProxyStarted) {\r\n            registerContainerAdapters();\r\n        }\r\n    } catch (RuntimeException e) {\r\n        LOGGER.log(Level.SEVERE, KernelLoggerInfo.grizzlyCantStart, e);\r\n        for (NetworkProxy proxy : proxies) {\r\n            try {\r\n                proxy.stop();\r\n            } catch (Exception proxyStopException) {\r\n                LOGGER.log(Level.SEVERE, KernelLoggerInfo.grizzlyCloseException, new Object[] { proxy.getPort(), proxyStopException });\r\n            }\r\n        }\r\n        throw e;\r\n    }\r\n    registerMonitoringStatsProviders();\r\n}"
}, {
	"Path": "com.sun.enterprise.web.ProxyHandlerImpl.getSSLClientCertificateChain",
	"Comment": "gets the ssl client certificate chain with which the clienthad authenticated itself to the ssl offloader, and which thessl offloader has added as a custom request header on thegiven request.",
	"Method": "X509Certificate[] getSSLClientCertificateChain(HttpServletRequest request){\r\n    X509Certificate[] certs = null;\r\n    String clientCert = request.getHeader(Constants.PROXY_AUTH_CERT);\r\n    if (clientCert != null) {\r\n        clientCert = clientCert.replaceAll(\"% d% a\", \"\\n\");\r\n        clientCert = \"-----BEGIN CERTIFICATE-----\\n\" + clientCert + \"\\n-----END CERTIFICATE-----\";\r\n        byte[] certBytes = clientCert.getBytes(Charset.defaultCharset());\r\n        ByteArrayInputStream bais = new ByteArrayInputStream(certBytes);\r\n        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\r\n        certs = new X509Certificate[1];\r\n        certs[0] = (X509Certificate) cf.generateCertificate(bais);\r\n    }\r\n    return certs;\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.BasicAuthenticator.parseUsername",
	"Comment": "parse the username from the specified authorization credentials.if none can be found, return null.",
	"Method": "String parseUsername(String authorization){\r\n    if (authorization == null)\r\n        return (null);\r\n    if (!authorization.toLowerCase(Locale.ENGLISH).startsWith(\"basic \"))\r\n        return (null);\r\n    authorization = authorization.substring(6).trim();\r\n    String unencoded = new String(Base64.decode(authorization.getBytes(Charset.defaultCharset())));\r\n    int colon = unencoded.indexOf(':');\r\n    if (colon < 0)\r\n        return (null);\r\n    String username = unencoded.substring(0, colon);\r\n    return (username);\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.CreateVirtualServer.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    final ActionReport report = context.getActionReport();\r\n    if (networkListeners != null && httpListeners != null) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.CREATE_VIRTUAL_SERVER_BOTH_HTTP_NETWORK), virtualServerId));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (networkListeners == null) {\r\n        networkListeners = httpListeners;\r\n    }\r\n    HttpService httpService = config.getHttpService();\r\n    for (VirtualServer virtualServer : httpService.getVirtualServer()) {\r\n        if (virtualServer.getId().equals(virtualServerId)) {\r\n            report.setMessage(MessageFormat.format(rb.getString(LogFacade.CREATE_VIRTUAL_SERVER_DUPLICATE), virtualServerId));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new SingleConfigCode<HttpService>() {\r\n            public Object run(HttpService param) throws PropertyVetoException, TransactionFailure {\r\n                String docroot = \"${com.sun.aas.instanceRoot}/docroot\";\r\n                String accessLog = \"${com.sun.aas.instanceRoot}/logs/access\";\r\n                VirtualServer newVirtualServer = param.createChild(VirtualServer.class);\r\n                newVirtualServer.setId(virtualServerId);\r\n                newVirtualServer.setHosts(hosts);\r\n                newVirtualServer.setNetworkListeners(networkListeners);\r\n                newVirtualServer.setDefaultWebModule(defaultWebModule);\r\n                newVirtualServer.setState(state);\r\n                newVirtualServer.setLogFile(logFile);\r\n                if (properties != null) {\r\n                    for (Map.Entry entry : properties.entrySet()) {\r\n                        String pn = (String) entry.getKey();\r\n                        String pv = (String) entry.getValue();\r\n                        if (\"docroot\".equals(pn)) {\r\n                            docroot = pv;\r\n                        } else if (\"accesslog\".equals(pn)) {\r\n                            accessLog = pv;\r\n                        } else {\r\n                            Property property = newVirtualServer.createChild(Property.class);\r\n                            property.setName(pn);\r\n                            property.setValue(pv);\r\n                            newVirtualServer.getProperty().add(property);\r\n                        }\r\n                    }\r\n                }\r\n                newVirtualServer.setDocroot(docroot);\r\n                newVirtualServer.setAccessLog(accessLog);\r\n                param.getVirtualServer().add(newVirtualServer);\r\n                return newVirtualServer;\r\n            }\r\n        }, httpService);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.CREATE_VIRTUAL_SERVER_FAIL), virtualServerId));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.CreateVirtualServer.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    String docroot = \"${com.sun.aas.instanceRoot}/docroot\";\r\n    String accessLog = \"${com.sun.aas.instanceRoot}/logs/access\";\r\n    VirtualServer newVirtualServer = param.createChild(VirtualServer.class);\r\n    newVirtualServer.setId(virtualServerId);\r\n    newVirtualServer.setHosts(hosts);\r\n    newVirtualServer.setNetworkListeners(networkListeners);\r\n    newVirtualServer.setDefaultWebModule(defaultWebModule);\r\n    newVirtualServer.setState(state);\r\n    newVirtualServer.setLogFile(logFile);\r\n    if (properties != null) {\r\n        for (Map.Entry entry : properties.entrySet()) {\r\n            String pn = (String) entry.getKey();\r\n            String pv = (String) entry.getValue();\r\n            if (\"docroot\".equals(pn)) {\r\n                docroot = pv;\r\n            } else if (\"accesslog\".equals(pn)) {\r\n                accessLog = pv;\r\n            } else {\r\n                Property property = newVirtualServer.createChild(Property.class);\r\n                property.setName(pn);\r\n                property.setValue(pv);\r\n                newVirtualServer.getProperty().add(property);\r\n            }\r\n        }\r\n    }\r\n    newVirtualServer.setDocroot(docroot);\r\n    newVirtualServer.setAccessLog(accessLog);\r\n    param.getVirtualServer().add(newVirtualServer);\r\n    return newVirtualServer;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardEngine.addChild",
	"Comment": "add a child container, only if the proposed child is an implementationof host.",
	"Method": "void addChild(Container child){\r\n    if (!(child instanceof Host))\r\n        throw new IllegalArgumentException(rb.getString(LogFacade.CHILD_OF_ENGINE_MUST_BE_HOST_EXCEPTION));\r\n    super.addChild(child);\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.DeploymentContextImpl.createApplicationClassLoader",
	"Comment": "this classloader will used to load and start the application",
	"Method": "void createApplicationClassLoader(ClassLoaderHierarchy clh,ArchiveHandler handler){\r\n    this.addTransientAppMetaData(ExtendedDeploymentContext.IS_TEMP_CLASSLOADER, Boolean.FALSE);\r\n    if (this.cloader == null) {\r\n        this.cloader = createClassLoader(clh, handler, parameters.name());\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.AuthenticatorBase.getInfo",
	"Comment": "return descriptive information about this valve implementation.",
	"Method": "String getInfo(){\r\n    return (this.info);\r\n}"
}, {
	"Path": "components.renderkit.AreaRenderer.getURI",
	"Comment": "return the path to be passed into javascript for the specifiedvalue.",
	"Method": "String getURI(FacesContext context,String value){\r\n    if (value.startsWith(\"/\")) {\r\n        return (context.getExternalContext().getRequestContextPath() + value);\r\n    } else {\r\n        return (value);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.More.wantsToContinue",
	"Comment": "return false iff the line read from the user starts with thequit character. this is a blocking call, waiting on inputfrom the user",
	"Method": "boolean wantsToContinue(){\r\n    out.write(prompt);\r\n    out.newLine();\r\n    out.flush();\r\n    String line = in.readLine();\r\n    return line != null && !line.startsWith(quit);\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebResourceCollectionImpl.removeHttpMethodOmission",
	"Comment": "removes the given http method omission from the collection of http methods.",
	"Method": "void removeHttpMethodOmission(String httpMethodOmission){\r\n    this.getHttpMethodOmissions().remove(httpMethodOmission);\r\n}"
}, {
	"Path": "com.sun.jts.trace.TraceUtil.setTraceWriter",
	"Comment": "sets the output writer. by default the output writer is set to stdout.",
	"Method": "void setTraceWriter(PrintWriter traceWriter){\r\n    m_traceWriter = traceWriter;\r\n}"
}, {
	"Path": "com.sun.appserv.web.cache.filter.HttpCacheEntry.computeExpireTime",
	"Comment": "compute when this entry to be expired based on timeout relative to current time.",
	"Method": "void computeExpireTime(int timeout){\r\n    this.expireTime = (timeout == -1) ? timeout : System.currentTimeMillis() + (timeout * 1000L);\r\n}"
}, {
	"Path": "org.apache.catalina.realm.GenericPrincipal.hasRole",
	"Comment": "does the user represented by this principal possess the specified role?",
	"Method": "boolean hasRole(String role){\r\n    if (\"*\".equals(role))\r\n        return true;\r\n    if (role == null)\r\n        return (false);\r\n    return (Arrays.binarySearch(roles, role) >= 0);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardPipeline.getInfo",
	"Comment": "return descriptive information about this implementation class.",
	"Method": "String getInfo(){\r\n    return info;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityCollection.findMethodOmissions",
	"Comment": "return the set of http request method omissions that are part of this webresource collection.",
	"Method": "String[] findMethodOmissions(){\r\n    return (methodOmissions);\r\n}"
}, {
	"Path": "org.glassfish.jspcaching.integration.GlassFishTldProvider.getTldListenerMap",
	"Comment": "gets a mapping from jar files to their tld resourcesthat are known to contain listener declarations",
	"Method": "Map<URI, List<String>> getTldListenerMap(){\r\n    return getTldMap();\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getPublicId",
	"Comment": "return the public identifier of the deployment descriptor dtd that iscurrently being parsed.",
	"Method": "String getPublicId(){\r\n    return publicId;\r\n}"
}, {
	"Path": "org.glassfish.weld.services.JCDIServiceImpl.injectManagedObject",
	"Comment": "perform 299 style injection on the managedobject argument.",
	"Method": "void injectManagedObject(Object managedObject,BundleDescriptor bundle){\r\n    BundleDescriptor topLevelBundleDesc = (BundleDescriptor) bundle.getModuleDescriptor().getDescriptor();\r\n    BeanDeploymentArchive bda = weldDeployer.getBeanDeploymentArchiveForBundle(topLevelBundleDesc);\r\n    WeldBootstrap bootstrap = weldDeployer.getBootstrapForApp(bundle.getApplication());\r\n    BeanManager beanManager = bootstrap.getManager(bda);\r\n    AnnotatedType annotatedType = beanManager.createAnnotatedType(managedObject.getClass());\r\n    InjectionTarget it = beanManager.createInjectionTarget(annotatedType);\r\n    CreationalContext cc = beanManager.createCreationalContext(null);\r\n    it.inject(managedObject, cc);\r\n}"
}, {
	"Path": "org.apache.catalina.session.ManagerBase.isSessionVersioningSupported",
	"Comment": "returns true if this session manager supports session versioning, falseotherwise.",
	"Method": "boolean isSessionVersioningSupported(){\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.deployment.versioning.VersioningUtils.checkIdentifier",
	"Comment": "check a versionned application name.this method is used to provide consistant error messages for identifieraware operations.",
	"Method": "void checkIdentifier(String appName){\r\n    String identifier = getExpression(appName);\r\n    if (identifier != null && identifier.contains(EXPRESSION_WILDCARD)) {\r\n        throw new VersioningWildcardException(LOCALSTRINGS.getLocalString(\"versioning.deployment.wildcard.not.allowed\", \"Wildcard character(s) are not allowed in a version identifier.\"));\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.remote.RemoteCLICommand.getCommandClass",
	"Comment": "given a command name, return the name of the class that implements thatcommand in the server.",
	"Method": "String getCommandClass(String cmdName){\r\n    ServiceLocator h = getManHabitat();\r\n    String cname = \"org.glassfish.api.admin.AdminCommand\";\r\n    ActiveDescriptor<?> ad = h.getBestDescriptor(BuilderHelper.createNameAndContractFilter(cname, cmdName));\r\n    if (ad == null)\r\n        return null;\r\n    return ad.getImplementation();\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ReplicationStore.save",
	"Comment": "save the specified session into this store.any previously savedinformation for the associated session identifier is replaced.",
	"Method": "void save(Session session){\r\n    if (!(session instanceof HASession)) {\r\n        return;\r\n    }\r\n    HASession haSess = (HASession) session;\r\n    if (haSess.isPersistent() && !haSess.isDirty()) {\r\n        this.updateLastAccessTime(session);\r\n    } else {\r\n        this.doSave(session);\r\n        haSess.setPersistent(true);\r\n    }\r\n    haSess.setDirty(false);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.setKeyAlias",
	"Comment": "sets the alias name of the keypair and supporting certificate chainused by this connector to authenticate itself to ssl clients.",
	"Method": "void setKeyAlias(String alias){\r\n    setProperty(\"keyAlias\", alias);\r\n    ServerSocketFactory factory = getFactory();\r\n    if (factory instanceof CoyoteServerSocketFactory) {\r\n        ((CoyoteServerSocketFactory) factory).setKeyAlias(alias);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.addChild",
	"Comment": "add a child container, only if the proposed child is an implementationof context.",
	"Method": "void addChild(Container child){\r\n    if (!(child instanceof Context))\r\n        throw new IllegalArgumentException(rb.getString(LogFacade.CHILD_MUST_BE_CONTEXT_EXCEPTION));\r\n    super.addChild(child);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.deploy.shared.DeploymentPlanArchive.open",
	"Comment": "open an existing deploymentplan archive and return a abstraction for reading from it.",
	"Method": "void open(URI uri){\r\n    this.uri = uri;\r\n    File f = new File(uri);\r\n    if (f.exists()) {\r\n        jarFile = new JarFile(f);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.core.proxy.ProxyFactory.toProxy",
	"Comment": "array entries for mbeans that are no longer registered will contain nullvalues.",
	"Method": "AMXProxy[] toProxy(ObjectName[] objectNames){\r\n    final AMXProxy[] result = new AMXProxy[objectNames.length];\r\n    for (int i = 0; i < objectNames.length; ++i) {\r\n        result[i] = getProxy(objectNames[i]);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jts.jta.TransactionManagerImpl.recreate",
	"Comment": "recreate a transaction based on the xid. this call causes the callingthread to be associated with the specified transaction.",
	"Method": "void recreate(Xid xid,long timeout){\r\n    if (xid == null || xid.getFormatId() == 0 || xid.getBranchQualifier() == null || xid.getGlobalTransactionId() == null) {\r\n        WorkException workExc = new WorkCompletedException(\"Invalid Xid\");\r\n        workExc.setErrorCode(WorkException.TX_RECREATE_FAILED);\r\n        throw workExc;\r\n    }\r\n    if (!DefaultTransactionService.isActive()) {\r\n        WorkException workExc = new WorkCompletedException(\"Transaction Manager unavailable\");\r\n        workExc.setErrorCode(WorkException.TX_RECREATE_FAILED);\r\n        throw workExc;\r\n    }\r\n    GlobalTID tid = new GlobalTID(xid);\r\n    try {\r\n        CurrentTransaction.recreate(tid, (int) ((timeout <= 0) ? 0 : timeout));\r\n    } catch (Throwable exc) {\r\n        String errorCode = WorkException.TX_RECREATE_FAILED;\r\n        if (exc instanceof INVALID_TRANSACTION && (((INVALID_TRANSACTION) exc).minor == MinorCode.TX_CONCURRENT_WORK_DISALLOWED)) {\r\n            errorCode = WorkException.TX_CONCURRENT_WORK_DISALLOWED;\r\n        }\r\n        WorkException workExc = new WorkCompletedException(exc);\r\n        workExc.setErrorCode(errorCode);\r\n        throw workExc;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.remote.RemoteCLICommand.executeAndReturnOutput",
	"Comment": "execute the command and return the output as a string instead of writingit out.",
	"Method": "String executeAndReturnOutput(String args){\r\n    returnOutput = true;\r\n    execute(args);\r\n    returnOutput = false;\r\n    return output;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.connector.coyote.PECoyoteConnector.configureKeysAndCerts",
	"Comment": "configures this connector with its keystore and truststore.",
	"Method": "void configureKeysAndCerts(){\r\n    String prop = System.getProperty(\"javax.net.ssl.keyStore\");\r\n    String keyStoreType = System.getProperty(\"javax.net.ssl.keyStoreType\", DEFAULT_KEYSTORE_TYPE);\r\n    if (prop != null) {\r\n        setKeystoreFile(prop);\r\n        setKeystoreType(keyStoreType);\r\n    }\r\n    prop = System.getProperty(\"javax.net.ssl.trustStore\");\r\n    if (prop != null) {\r\n        setTruststore(prop);\r\n        setTruststoreType(DEFAULT_TRUSTSTORE_TYPE);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.setHost",
	"Comment": "set the host within which this request is being processed.thismust be called as soon as the appropriate host is identified, andbefore the request is passed to a context.",
	"Method": "void setHost(Host host){\r\n    mappingData.host = host;\r\n}"
}, {
	"Path": "org.glassfish.admin.monitor.StatsProviderManagerDelegateImpl.tryToRegister",
	"Comment": "throws runtimeexception maybenote the default visibility so that monitoringbootstrap can call it.",
	"Method": "void tryToRegister(StatsProviderInfo spInfo){\r\n    final String configElement = spInfo.getConfigElement();\r\n    Object statsProvider = spInfo.getStatsProvider();\r\n    if (logger.isLoggable(Level.FINE))\r\n        logger.fine(\"registering a statsProvider\");\r\n    StatsProviderRegistryElement spre;\r\n    if (monitoringService != null && monitoringService.getContainerMonitoring(configElement) == null && monitoringService.getMonitoringLevel(configElement) == null) {\r\n        createConfigElement(configElement);\r\n    }\r\n    if (getMonitoringEnabled() && getEnabledValue(configElement)) {\r\n        if (logger.isLoggable(Level.FINE))\r\n            logger.fine(\" enabled is true \");\r\n        spre = statsProviderRegistry.getStatsProviderRegistryElement(statsProvider);\r\n        if (spre == null) {\r\n            statsProviderRegistry.registerStatsProvider(spInfo);\r\n            spre = statsProviderRegistry.getStatsProviderRegistryElement(statsProvider);\r\n        }\r\n        if (spre.isEnableAllowed(getMonitoringLevel(configElement))) {\r\n            enableStatsProvider(spre);\r\n        }\r\n    } else {\r\n        if (logger.isLoggable(Level.FINE))\r\n            logger.fine(\" enabled is false \");\r\n        statsProviderRegistry.registerStatsProvider(spInfo);\r\n        spre = statsProviderRegistry.getStatsProviderRegistryElement(statsProvider);\r\n    }\r\n    if (logger.isLoggable(Level.FINE)) {\r\n        logger.fine(spre.toString());\r\n        logger.fine(\"=========================================================\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorImpl.servant",
	"Comment": "returns the coordinatorimpl which serves the given object.",
	"Method": "CoordinatorImpl servant(Coordinator coord){\r\n    CoordinatorImpl result = null;\r\n    if (coord instanceof CoordinatorImpl)\r\n        result = (CoordinatorImpl) coord;\r\n    else if (poa != null) {\r\n        JCoordinator jcoord = JCoordinatorHelper.narrow(coord);\r\n        if (jcoord != null)\r\n            try {\r\n                result = (CoordinatorImpl) poa.reference_to_servant(jcoord);\r\n                if (result.thisRef == null)\r\n                    result.thisRef = jcoord;\r\n            } catch (Exception exc) {\r\n                _logger.log(Level.WARNING, \"jts.cannot_locate_servant\", \"Coordinator\");\r\n            }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.glassfish.admin.mbeanserver.RMIConnectorStarter.getClientSocketFactory",
	"Comment": "this method sets up an environment based on passed in ssl configuration",
	"Method": "SslRMIClientSocketFactory getClientSocketFactory(Ssl sslConfig){\r\n    SSLParams sslParams = convertToSSLParams(sslConfig);\r\n    SSLClientConfigurator sslCC = SSLClientConfigurator.getInstance();\r\n    sslCC.setSSLParams(sslParams);\r\n    SSLContext sslContext = sslCC.configure(sslParams);\r\n    Security.setProperty(\"ssl.SocketFactory.provider\", sslContext.getClass().getName());\r\n    String enabledProtocols = sslCC.getEnabledProtocolsAsString();\r\n    if (enabledProtocols != null) {\r\n        System.setProperty(\"javax.rmi.ssl.client.enabledProtocols\", enabledProtocols);\r\n    }\r\n    String enabledCipherSuites = sslCC.getEnabledCipherSuitesAsString();\r\n    if (enabledCipherSuites != null) {\r\n        System.setProperty(\"javax.rmi.ssl.client.enabledCipherSuites\", enabledCipherSuites);\r\n    }\r\n    System.setProperty(\"javax.net.ssl.keyStorePassword\", sslParams.getKeyStorePassword() == null ? \"changeit\" : sslParams.getKeyStorePassword());\r\n    System.setProperty(\"javax.net.ssl.trustStorePassword\", sslParams.getTrustStorePassword() == null ? \"changeit\" : sslParams.getTrustStorePassword());\r\n    SslRMIClientSocketFactory sslRMICsf = new SslRMIClientSocketFactory();\r\n    return sslRMICsf;\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.SslConfig.getHandshakeTimeout",
	"Comment": "gets the timeout within which there must be activity from the client",
	"Method": "int getHandshakeTimeout(){\r\n    return this.timeoutMilliSeconds;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.removeApplicationParameter",
	"Comment": "remove the application parameter with the specified name fromthe set for this application.",
	"Method": "void removeApplicationParameter(String name){\r\n    ApplicationParameter match = null;\r\n    Iterator<ApplicationParameter> i = applicationParameters.iterator();\r\n    while (i.hasNext()) {\r\n        ApplicationParameter applicationParameter = i.next();\r\n        if (name.equals(applicationParameter.getName())) {\r\n            match = applicationParameter;\r\n            break;\r\n        }\r\n    }\r\n    if (match != null) {\r\n        applicationParameters.remove(match);\r\n        if (notifyContainerListeners) {\r\n            fireContainerEvent(\"removeApplicationParameter\", name);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteRestAdminCommand.getOption",
	"Comment": "get an option value, that might come from the command lineor from the environment.return the default value for theoption if not otherwise specified.",
	"Method": "String getOption(String name){\r\n    String val = options.getOne(name);\r\n    if (val == null) {\r\n        val = getFromEnvironment(name);\r\n    }\r\n    if (val == null) {\r\n        ParamModel opt = commandModel.getModelFor(name);\r\n        if (opt != null) {\r\n            String def = opt.getParam().defaultValue();\r\n            if (ok(def)) {\r\n                val = def;\r\n            }\r\n        }\r\n    }\r\n    return val;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.pkmultiplefield.PrimaryKeyClassFieldsPublic.check",
	"Comment": "enterprise java bean primary key class public fields test.the primary key class must declare all fields within the class as public.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (descriptor instanceof EjbEntityDescriptor) {\r\n        String persistence = ((EjbEntityDescriptor) descriptor).getPersistenceType();\r\n        if (EjbEntityDescriptor.CONTAINER_PERSISTENCE.equals(persistence)) {\r\n            try {\r\n                FieldDescriptor fd = ((EjbCMPEntityDescriptor) descriptor).getPrimaryKeyFieldDesc();\r\n                if (fd != null) {\r\n                    String pkf = fd.getName();\r\n                    if (pkf.length() > 0) {\r\n                        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable2\", \"Entity Bean [ {0} ] with primekey-field non-blank, test not applicable.\", new Object[] { descriptor.getEjbClassName() }));\r\n                    }\r\n                } else {\r\n                    try {\r\n                        VerifierTestContext context = getVerifierContext();\r\n                        ClassLoader jcl = context.getClassLoader();\r\n                        Class c = Class.forName(((EjbEntityDescriptor) descriptor).getPrimaryKeyClassName(), false, getVerifierContext().getClassLoader());\r\n                        boolean oneFailed = false;\r\n                        boolean badField = false;\r\n                        Field[] fields = c.getDeclaredFields();\r\n                        for (int i = 0; i < fields.length; i++) {\r\n                            badField = false;\r\n                            int modifiers = fields[i].getModifiers();\r\n                            if (Modifier.isPublic(modifiers)) {\r\n                                continue;\r\n                            } else {\r\n                                if (!oneFailed) {\r\n                                    oneFailed = true;\r\n                                }\r\n                                badField = true;\r\n                            }\r\n                            if (badField) {\r\n                                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                                result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: Field [ {0} ] defined within primary key class [ {1} ] is not defined as public.\", new Object[] { fields[i].getName(), ((EjbEntityDescriptor) descriptor).getPrimaryKeyClassName() }));\r\n                            }\r\n                        }\r\n                        if (!oneFailed) {\r\n                            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                            result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"This primary key class [ {0} ] has defined all fields as public.\", new Object[] { ((EjbEntityDescriptor) descriptor).getPrimaryKeyClassName() }));\r\n                        }\r\n                    } catch (ClassNotFoundException e) {\r\n                        Verifier.debug(e);\r\n                        result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.failed(smh.getLocalString(getClass().getName() + \".failedException\", \"Error: [ {0} ] class not found.\", new Object[] { ((EjbEntityDescriptor) descriptor).getPrimaryKeyClassName() }));\r\n                    } catch (Throwable t) {\r\n                        result.addWarningDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.warning(smh.getLocalString(getClass().getName() + \".warningException\", \"Warning: [ {0} ] class encountered [ {1} ]. Cannot access fields of class [ {2} ] which is external to [ {3} ].\", new Object[] { (descriptor).getEjbClassName(), t.toString(), t.getMessage(), descriptor.getEjbBundleDescriptor().getModuleDescriptor().getArchiveUri() }));\r\n                    }\r\n                }\r\n            } catch (NullPointerException e) {\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.failed(smh.getLocalString(getClass().getName() + \".failedException2\", \"Error: Primkey field not defined within [ {0} ] bean.\", new Object[] { descriptor.getName() }));\r\n            }\r\n            return result;\r\n        } else {\r\n            result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable1\", \"Expected [ {0} ] managed persistence, but [ {1} ] bean has [ {2} ] managed persistence.\", new Object[] { EjbEntityDescriptor.CONTAINER_PERSISTENCE, descriptor.getName(), persistence }));\r\n            return result;\r\n        }\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"{0} expected {1} bean, but called with {2}.\", new Object[] { getClass(), \"Entity\", \"Session\" }));\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SuperiorInfo.resyncRetries",
	"Comment": "returns the number of retries so far, and increments the count.",
	"Method": "int resyncRetries(){\r\n    int result = resyncRetries++;\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityCollection.findMethodOmission",
	"Comment": "return true if the specified http request method omission ispart of this web resource collection.",
	"Method": "boolean findMethodOmission(String methodOmission){\r\n    if (methodOmissions.length == 0)\r\n        return (false);\r\n    for (int i = 0; i < methodOmissions.length; i++) {\r\n        if (methodOmissions[i].equals(methodOmission))\r\n            return (true);\r\n    }\r\n    return (false);\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.getMessageDestinationReferenceByName",
	"Comment": "looks up an message destination reference with the given name.throws an illegalargumentexception if it is not found.",
	"Method": "MessageDestinationReferenceDescriptor getMessageDestinationReferenceByName(String name){\r\n    MessageDestinationReferenceDescriptor mdr = _getMessageDestinationReferenceByName(name);\r\n    if (mdr != null) {\r\n        return mdr;\r\n    }\r\n    throw new IllegalArgumentException(localStrings.getLocalString(\"web.deployment.exceptionwebapphasnomsgdestrefbyname\", \"This web app [{0}] has no message destination reference by the name of [{1}]\", new Object[] { getName(), name }));\r\n}"
}, {
	"Path": "org.apache.catalina.valves.AccessLogValve.setPattern",
	"Comment": "set the format pattern, first translating any recognized alias.",
	"Method": "void setPattern(String pattern){\r\n    if (pattern == null)\r\n        pattern = \"\";\r\n    if (pattern.equals(Constants.AccessLog.COMMON_ALIAS))\r\n        pattern = Constants.AccessLog.COMMON_PATTERN;\r\n    if (pattern.equals(Constants.AccessLog.COMBINED_ALIAS))\r\n        pattern = Constants.AccessLog.COMBINED_PATTERN;\r\n    this.pattern = pattern;\r\n    if (this.pattern.equals(Constants.AccessLog.COMMON_PATTERN))\r\n        common = true;\r\n    else\r\n        common = false;\r\n    if (this.pattern.equals(Constants.AccessLog.COMBINED_PATTERN))\r\n        combined = true;\r\n    else\r\n        combined = false;\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.PartItem.delete",
	"Comment": "deletes the underlying storage for a file item, including deleting anyassociated temporary disk file. although this storage will be deletedautomatically when the fileitem instance is garbagecollected, this method can be used to ensure that this is done at anearlier time, thus preserving system resources.",
	"Method": "void delete(){\r\n    cachedContent = null;\r\n    File outputFile = getStoreLocation();\r\n    if (outputFile != null && outputFile.exists()) {\r\n        deleteFile(outputFile);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.stringsubs.impl.ArchiveEntryWrapperImpl.getAllArchiveMemberList",
	"Comment": "gets the list which stores all the substitutable entries of an archive.",
	"Method": "List<ArchiveMember> getAllArchiveMemberList(){\r\n    ArchiveEntryWrapperImpl current = this;\r\n    while (current._parent != null) {\r\n        current = current._parent;\r\n    }\r\n    if (current._allArchiveMembers == null) {\r\n        current._allArchiveMembers = new ArrayList<ArchiveMember>();\r\n    }\r\n    return current._allArchiveMembers;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.setMaxPostSize",
	"Comment": "set the maximum size of a post which will be automaticallyparsed by the container.",
	"Method": "void setMaxPostSize(int maxPostSize){\r\n    this.maxPostSize = maxPostSize;\r\n    setProperty(\"maxPostSize\", String.valueOf(maxPostSize));\r\n}"
}, {
	"Path": "org.glassfish.deployment.common.DeploymentUtils.downloadableArtifacts",
	"Comment": "returns the downloadable artifacts object derived from the propertiessaved with the specified application",
	"Method": "Artifacts downloadableArtifacts(DeploymentContext dc,Artifacts downloadableArtifacts,Application app){\r\n    return Artifacts.get(app.getDeployProperties(), DOWNLOADABLE_ARTIFACTS_KEY_PREFIX);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RWLock.acquireReadLock",
	"Comment": "this method is used to acquire a read lock. if there is already a writer threadaccessing the object using the rwlock then the reader thread will wait untilthe writer completes its operation",
	"Method": "void acquireReadLock(){\r\n    if (currentWriters == 0 && writerQueue.size() == 0) {\r\n        ++currentReaders;\r\n    } else {\r\n        ++pendingReaders;\r\n        try {\r\n            wait();\r\n        } catch (InterruptedException ie) {\r\n            _logger.log(Level.FINE, \"Error in acquireReadLock\", ie);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.utils.RecoveryHooks.FailureInducer.setWaitPoint",
	"Comment": "setting a wait point will cause the tm to wait at thefailure point, for the stipulated wait duration.",
	"Method": "void setWaitPoint(Integer waitPoint,int waitDuration){\r\n    if (waitPoint == null) {\r\n        _logger.log(Level.SEVERE, \"jts.invalid_wait_point\");\r\n        return;\r\n    }\r\n    GlobalTID gtid = getGlobalTID();\r\n    if (gtid != null) {\r\n        waitList.put(gtid, waitPoint);\r\n        waitTime.put(gtid, waitDuration);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.grizzly.config.ContextRootInfo.getContainer",
	"Comment": "gets the application container, associated with the context.",
	"Method": "Object getContainer(Object getContainer,Object getContainer){\r\n    return holder.getContainer();\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.BasicAuthenticator.authenticate",
	"Comment": "authenticate the user making this request, based on the specifiedlogin configuration.return true if any specifiedconstraint has been satisfied, or false if we havecreated a response challenge already.",
	"Method": "boolean authenticate(HttpRequest request,HttpResponse response,LoginConfig config){\r\n    Principal principal = ((HttpServletRequest) request.getRequest()).getUserPrincipal();\r\n    if (principal != null) {\r\n        if (log.isLoggable(Level.FINE))\r\n            log.log(Level.FINE, \"Already authenticated '\" + principal.getName() + \"'\");\r\n        return (true);\r\n    }\r\n    HttpServletResponse hres = (HttpServletResponse) response.getResponse();\r\n    String authorization = request.getAuthorization();\r\n    if (authorization != null) {\r\n        String username = parseUsername(authorization);\r\n        char[] password = parsePassword(authorization);\r\n        principal = context.getRealm().authenticate(username, password);\r\n        if (principal != null) {\r\n            register(request, response, principal, Constants.BASIC_METHOD, username, password);\r\n            String ssoId = (String) request.getNote(Constants.REQ_SSOID_NOTE);\r\n            if (ssoId != null) {\r\n                getSession(request, true);\r\n            }\r\n            return (true);\r\n        }\r\n    }\r\n    String realmName = config.getRealmName();\r\n    if (realmName == null)\r\n        realmName = REALM_NAME;\r\n    hres.setHeader(AUTH_HEADER_NAME, \"Basic realm=\\\"\" + realmName + \"\\\"\");\r\n    hres.sendError(HttpServletResponse.SC_UNAUTHORIZED);\r\n    return (false);\r\n}"
}, {
	"Path": "testmbeans.ObjectNameSelfProviderDynamicSupport.setAttributes",
	"Comment": "sets the values of several attributes of the dynamic mbean and returns the list of attributes that have been set.",
	"Method": "AttributeList setAttributes(AttributeList attributes){\r\n    AttributeList resultList = new AttributeList();\r\n    for (Iterator i = attributes.iterator(); i.hasNext(); ) {\r\n        Attribute attr = (Attribute) i.next();\r\n        try {\r\n            setAttribute(attr);\r\n            String name = attr.getName();\r\n            Object value = getAttribute(name);\r\n            resultList.add(new Attribute(name, value));\r\n        } catch (Exception e) {\r\n        }\r\n    }\r\n    return resultList;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.CLICommand.getCommandUsage",
	"Comment": "get the usage text for the command.this usage text shows the detailsof the command options but does not show the details for the subcommandoptions. the subcommand argument is used to fill in the subcommand namein the usage text.",
	"Method": "String getCommandUsage(){\r\n    return strings.get(\"Usage.full\", programOpts.getCommandName());\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getOriginalDocBase",
	"Comment": "gets the original document root for this context, which can be anabsolute pathname, a relative pathname, or a url.is only set as deployment has change docroot!",
	"Method": "String getOriginalDocBase(){\r\n    return (this.originalDocBase);\r\n}"
}, {
	"Path": "com.sun.enterprise.util.StringUtils.getProperty",
	"Comment": "get a system propety given a property name, possibly trying all combinationof upercase, name mangling to get a value.",
	"Method": "String getProperty(String propName){\r\n    String value = System.getProperty(propName);\r\n    if (value != null) {\r\n        return value;\r\n    }\r\n    value = System.getProperty(propName.toUpperCase(Locale.getDefault()));\r\n    if (value != null) {\r\n        System.setProperty(propName, value);\r\n        return value;\r\n    }\r\n    value = System.getProperty(propName.replace('.', '_'));\r\n    if (value != null) {\r\n        System.setProperty(propName, value);\r\n        return value;\r\n    }\r\n    value = System.getProperty(propName.toUpperCase(Locale.getDefault()).replace('.', '_'));\r\n    if (value != null) {\r\n        System.setProperty(propName, value);\r\n    }\r\n    return value;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.composite.CompositeUtil.getHelpText",
	"Comment": "if the helptext annotation is in the list of annotations, return the value from thespecified bundle for the given key.",
	"Method": "String getHelpText(Annotation[] annos){\r\n    String helpText = null;\r\n    if (annos != null) {\r\n        for (Annotation annotation : annos) {\r\n            if (HelpText.class.isAssignableFrom(annotation.getClass())) {\r\n                HelpText ht = (HelpText) annotation;\r\n                ResourceBundle bundle = ResourceBundle.getBundle(ht.bundle(), Locale.getDefault());\r\n                helpText = bundle.getString(ht.key());\r\n            }\r\n        }\r\n    }\r\n    return helpText;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.managed.ManagedConnectionExistence.check",
	"Comment": "test the implementation of the javax.resource.spi.managedconnection interface in the rar file",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!descriptor.getOutBoundDefined()) {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.managed.notApplicableForInboundRA\", \"Resource Adapter does not provide outbound communication\"));\r\n        return result;\r\n    }\r\n    findImplementorOf(descriptor, \"javax.resource.spi.ManagedConnection\", result);\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setOrderedLibs",
	"Comment": "sets the list of ordered libs, which will be used as the value of theservletcontext attribute with name javax.servlet.context.orderedlibs",
	"Method": "void setOrderedLibs(List<String> orderedLibs){\r\n    this.orderedLibs = orderedLibs;\r\n}"
}, {
	"Path": "com.sun.appserv.web.cache.filter.CachingFilter.waitForRefresh",
	"Comment": "call cache.waitrefresh only when the cache processing is not started.see it 17377.",
	"Method": "boolean waitForRefresh(HttpServletRequest req,String key,int index){\r\n    Object obj = req.getAttribute(PROCESSING_SET);\r\n    HashSet<String> processingSet = null;\r\n    if (obj == null) {\r\n        processingSet = new HashSet<String>();\r\n        req.setAttribute(PROCESSING_SET, processingSet);\r\n    } else if (obj instanceof HashSet) {\r\n        @SuppressWarnings(\"unchecked\")\r\n        final HashSet<String> set = (HashSet<String>) obj;\r\n        processingSet = set;\r\n    } else {\r\n        throw new IllegalStateException();\r\n    }\r\n    if (processingSet.add(key)) {\r\n        return cache.waitRefresh(index);\r\n    } else {\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "components.taglib.GraphMenuBarTag.setStyleClass",
	"Comment": "the css style class to be applied to the entire menu.this can be value or a value binding reference expression.",
	"Method": "void setStyleClass(String style){\r\n    this.styleClass = style;\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardManager.doLoadFromFile",
	"Comment": "loads any currently active sessions that were previously unloadedto file",
	"Method": "void doLoadFromFile(){\r\n    if (log.isLoggable(Level.FINE)) {\r\n        log.log(Level.FINE, \"Start: Loading persisted sessions\");\r\n    }\r\n    File file = file();\r\n    if (file == null || !file.exists() || file.length() == 0) {\r\n        return;\r\n    }\r\n    if (log.isLoggable(Level.FINE)) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.LOADING_PERSISTED_SESSION), pathname);\r\n        log.log(Level.FINE, msg);\r\n    }\r\n    FileInputStream fis = null;\r\n    try {\r\n        fis = new FileInputStream(file.getAbsolutePath());\r\n        readSessions(fis);\r\n        if (log.isLoggable(Level.FINE)) {\r\n            log.log(Level.FINE, \"Finish: Loading persisted sessions\");\r\n        }\r\n    } catch (FileNotFoundException e) {\r\n        if (log.isLoggable(Level.FINE)) {\r\n            log.log(Level.FINE, \"No persisted data file found\");\r\n        }\r\n    } finally {\r\n        try {\r\n            if (fis != null) {\r\n                fis.close();\r\n            }\r\n        } catch (IOException f) {\r\n        }\r\n        deleteFile(file);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.addServlet",
	"Comment": "adds the servlet with the given name and class type to thisservlet context.",
	"Method": "ServletRegistration.Dynamic addServlet(String servletName,String className,ServletRegistration.Dynamic addServlet,String servletName,Servlet servlet,ServletRegistration.Dynamic addServlet,String servletName,Class<? extends Servlet> servletClass){\r\n    if (SecurityUtil.isPackageProtectionEnabled()) {\r\n        return (ServletRegistration.Dynamic) doPrivileged(\"addServlet\", new Class[] { String.class, Class.class }, new Object[] { servletName, servletClass });\r\n    } else {\r\n        return context.addServlet(servletName, servletClass);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.mbeanapi.config.RemoteInstanceTest.getOptionalParameters",
	"Comment": "that number here for each value provided through properties system prop",
	"Method": "Map getOptionalParameters(int instanceNum){\r\n    final Map properties = new HashMap();\r\n    final String props = System.getProperty(\"PROPERTIES\");\r\n    if (props == null)\r\n        return null;\r\n    final String[] specs = props.split(\":\");\r\n    String key, value;\r\n    for (int i = 0; i < specs.length; i++) {\r\n        key = specs[i].substring(0, specs[i].indexOf(\"=\", 0));\r\n        value = specs[i].substring(specs[i].indexOf(\"=\") + 1, specs[i].length());\r\n        key = getLegalKey(key);\r\n        if (key != null) {\r\n            properties.put(key, \"\" + (Integer.parseInt(value) + instanceNum));\r\n        } else {\r\n            throw new Exception(\"PROPERTIES:property key did not match legal key\");\r\n        }\r\n    }\r\n    System.out.println(properties.toString());\r\n    return properties;\r\n}"
}, {
	"Path": "myapp.Hello.doGet",
	"Comment": "respond to a get request for the content produced bythis servlet.",
	"Method": "void doGet(HttpServletRequest request,HttpServletResponse response){\r\n    response.setContentType(\"text/html\");\r\n    PrintWriter writer = response.getWriter();\r\n    writer.println(\"<html>\");\r\n    writer.println(\"<head>\");\r\n    writer.println(\"<title>Sample Application Servlet Page<\/title>\");\r\n    writer.println(\"<\/head>\");\r\n    writer.println(\"<body bgcolor=white>\");\r\n    writer.println(\"<table border=\\\"0\\\">\");\r\n    writer.println(\"<tr>\");\r\n    writer.println(\"<td>\");\r\n    writer.println(\"<\/td>\");\r\n    writer.println(\"<td>\");\r\n    writer.println(\"<h1>Sample Application Servlet<\/h1>\");\r\n    writer.println(\"This is the output of a servlet that is part of\");\r\n    writer.println(\"the Hello, World application.  It displays the\");\r\n    writer.println(\"request headers from the request we are currently\");\r\n    writer.println(\"processing.\");\r\n    writer.println(\"<\/td>\");\r\n    writer.println(\"<\/tr>\");\r\n    writer.println(\"<\/table>\");\r\n    writer.println(\"<table border=\\\"0\\\" width=\\\"100%\\\">\");\r\n    Enumeration names = request.getHeaderNames();\r\n    while (names.hasMoreElements()) {\r\n        String name = (String) names.nextElement();\r\n        writer.println(\"<tr>\");\r\n        writer.println(\"  <th align=\\\"right\\\">\" + name + \":<\/th>\");\r\n        writer.println(\"  <td>\" + request.getHeader(name) + \"<\/td>\");\r\n        writer.println(\"<\/tr>\");\r\n    }\r\n    writer.println(\"<\/table>\");\r\n    writer.println(\"<\/body>\");\r\n    writer.println(\"<\/html>\");\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.ReportHandler.writeStackTraceToFile",
	"Comment": "returns the error description for writing to the final report.",
	"Method": "String writeStackTraceToFile(Throwable e){\r\n    StringWriter sw = new StringWriter();\r\n    e.printStackTrace(new PrintWriter(sw));\r\n    return sw.toString();\r\n}"
}, {
	"Path": "org.glassfish.internal.embedded.Server.getFileSystem",
	"Comment": "returns the embedded file system used to run this embedded instance.",
	"Method": "EmbeddedFileSystem getFileSystem(){\r\n    return fileSystem.getService();\r\n}"
}, {
	"Path": "com.sun.appserv.util.cache.mbeans.JmxBaseCache.getThreshold",
	"Comment": "returns threshold. this when reached, an overflow will occur",
	"Method": "Integer getThreshold(){\r\n    return (Integer) baseCache.getStatByName(Constants.STAT_BASECACHE_THRESHOLD);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationHttpRequest.copyMap",
	"Comment": "perform a shallow copy of the specified map, and return the result.",
	"Method": "void copyMap(Map<String, String[]> orig,Map<String, String[]> dest){\r\n    if (orig == null)\r\n        return;\r\n    synchronized (orig) {\r\n        for (Map.Entry<String, String[]> entry : orig.entrySet()) {\r\n            dest.put(entry.getKey(), entry.getValue());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.webservices.monitoring.LogAuthenticationListener.authFailure",
	"Comment": "notification that a user authentication attempt has failed.",
	"Method": "void authFailure(BundleDescriptor bundleDesc,Endpoint endpoint,Principal principal){\r\n    if (DOLUtils.ejbType().equals(bundleDesc.getModuleType())) {\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.log(Level.FINE, LogUtils.AUTHENTICATION_FAILURE, new Object[] { endpoint.getEndpointSelector(), bundleDesc.getModuleID(), \"ejb module\" });\r\n        }\r\n    } else {\r\n        if (logger.isLoggable(Level.FINE)) {\r\n            logger.log(Level.FINE, LogUtils.AUTHENTICATION_FAILURE, new Object[] { endpoint.getEndpointSelector(), bundleDesc.getModuleID(), \"web app\" });\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.ignorableWhitespace",
	"Comment": "process notification of ignorable whitespace received from the body ofan xml element.",
	"Method": "void ignorableWhitespace(char buffer,int start,int len){\r\n    if (saxLog.isLoggable(Level.FINE)) {\r\n        saxLog.log(Level.FINE, \"ignorableWhitespace(\" + new String(buffer, start, len) + \")\");\r\n    }\r\n    ;\r\n}"
}, {
	"Path": "com.sun.enterprise.deploy.shared.FileArchive.createSubArchive",
	"Comment": "create or obtain an embedded archive within this abstraction.",
	"Method": "WritableArchive createSubArchive(String name){\r\n    String subEntryName = getFileSubArchivePath(name);\r\n    File subEntry = new File(subEntryName);\r\n    if (!subEntry.exists()) {\r\n        if (!subEntry.exists() && !subEntry.mkdirs()) {\r\n            throw new IOException(\"Unable to create directory for \" + subEntry.getAbsolutePath());\r\n        }\r\n        deplLogger.log(DEBUG_LEVEL, \"FileArchive.createSubArchive created dirs for {0}\", subEntry.getAbsolutePath());\r\n    } else {\r\n        deplLogger.log(DEBUG_LEVEL, \"FileArchive.createSubArchive found existing dir for {0}\", subEntry.getAbsolutePath());\r\n        staleFileManager().recordValidEntry(subEntry);\r\n    }\r\n    final WritableArchive result = archiveFactory.createArchive(subEntry);\r\n    if (result instanceof AbstractReadableArchive) {\r\n        ((AbstractReadableArchive) result).setParentArchive(this);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TransactionFactoryImpl.servant",
	"Comment": "returns the transactionfactoryimpl which serves the given object.",
	"Method": "TransactionFactoryImpl servant(TransactionFactory factory){\r\n    TransactionFactoryImpl result = null;\r\n    if (factory != null && Configuration.getProxyChecker().isProxy(factory)) {\r\n        return result;\r\n    }\r\n    if (factory instanceof TransactionFactoryImpl) {\r\n        result = (TransactionFactoryImpl) factory;\r\n    } else if (poa != null) {\r\n        try {\r\n            result = (TransactionFactoryImpl) poa.reference_to_servant(factory);\r\n            if (result.thisRef == null)\r\n                result.thisRef = factory;\r\n        } catch (Exception exc) {\r\n            _logger.log(Level.WARNING, \"jts.cannot_locate_servant\", \"TransactionFactory\");\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.addCookie",
	"Comment": "add a cookie to the set of cookies associated with this request.",
	"Method": "void addCookie(Cookie cookie){\r\n    if (!cookiesParsed) {\r\n        parseCookies();\r\n    }\r\n    cookies.add(cookie);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getServletRegistration",
	"Comment": "gets the servletregistration corresponding to the servlet with thegiven servletname.",
	"Method": "ServletRegistration getServletRegistration(String servletName){\r\n    if (isRestricted) {\r\n        throw new UnsupportedOperationException(rb.getString(LogFacade.UNSUPPORTED_OPERATION_EXCEPTION));\r\n    }\r\n    return context.getServletRegistration(servletName);\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.readers.InputObject.getLong",
	"Comment": "get the long value associated with a key. if the number value is toolong for a long, it will be clipped.",
	"Method": "long getLong(String key){\r\n    Object o = getValue(key);\r\n    return o instanceof Number ? ((Number) o).longValue() : (long) getDouble(key);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TerminatorImpl.commit",
	"Comment": "requests that the transaction controlled by the terminator object becommitted.the commit is passed on the the coordinatorterm object. if the heuristicreport flag is set, any heuristic exception raised by theroot coordinator is returned to the caller,otherwise any heuristic exception is discarded.this operation is part of the omg interface and must not returnany exceptions other than those defined in the omg interface.",
	"Method": "void commit(boolean reportHeuristics){\r\n    preCompletionCheck();\r\n    try {\r\n        coordTerm.commit(!reportHeuristics);\r\n    } catch (HeuristicMixed exc) {\r\n        if (reportHeuristics) {\r\n            control.destroy();\r\n            throw exc;\r\n        }\r\n    } catch (HeuristicHazard exc) {\r\n        if (reportHeuristics) {\r\n            control.destroy();\r\n            throw exc;\r\n        }\r\n    } catch (TRANSACTION_ROLLEDBACK exc) {\r\n        control.destroy();\r\n        throw exc;\r\n    } catch (LogicErrorException exc) {\r\n        control.destroy();\r\n        INTERNAL ex2 = new INTERNAL(MinorCode.LogicError, CompletionStatus.COMPLETED_NO);\r\n        throw ex2;\r\n    } catch (INTERNAL exc) {\r\n        control.destroy();\r\n        throw (INTERNAL) exc;\r\n    }\r\n    control.destroy();\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.jmx.MBeanInterfaceGenerator.getAttributeNameComment",
	"Comment": "return a comment regarding the attribute name if it was mapped to a differentjava name.",
	"Method": "String getAttributeNameComment(String attributeName,String javaName){\r\n    String comment = \"\";\r\n    if (!attributeName.equals(javaName)) {\r\n        comment = attributeName + \" => \" + javaName;\r\n    }\r\n    return comment;\r\n}"
}, {
	"Path": "org.glassfish.api.admin.CommandModel.getParameters",
	"Comment": "returns a collection of parameter model for all the parameters supportedby this command.",
	"Method": "Collection<ParamModel> getParameters(){\r\n    ArrayList<ParamModel> copy = new ArrayList<ParamModel>();\r\n    for (String name : getParametersNames()) {\r\n        copy.add(getModelFor(name));\r\n    }\r\n    return copy;\r\n}"
}, {
	"Path": "org.glassfish.admin.mbeanserver.AdminAuthorizedMBeanServer.newInstance",
	"Comment": "returns an mbeanserver that will check security and then forward requeststo the real mbeanserver.",
	"Method": "MBeanServerForwarder newInstance(MBeanServer mbs,boolean isInstance,BootAMX bootAMX){\r\n    final AdminAuthorizedMBeanServer.Handler handler = new AdminAuthorizedMBeanServer.Handler(mbs, isInstance);\r\n    return (MBeanServerForwarder) Proxy.newProxyInstance(MBeanServerForwarder.class.getClassLoader(), new Class[] { MBeanServerForwarder.class }, handler);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TimeoutManager.checkTimeouts",
	"Comment": "periodically checks the existing timeouts.this is done to discover if any transactions have overrun their allottedtime.those which have are returned as an enumeration.note that this method should not do anything that will cause asynchronized method in the recoverymanager to be called, as this couldcause a deadlock when recoverymanager methods on other threads callsettimeout.",
	"Method": "Enumeration checkTimeouts(){\r\n    if (!isSetTimeout)\r\n        return null;\r\n    Enumeration result = null;\r\n    if (timeoutActive && ((pendingTimeouts.size() != 0) || (indoubtTimeouts.size() != 0))) {\r\n        Vector timedOut = null;\r\n        Enumeration timeouts = null;\r\n        synchronized (pendingTimeouts) {\r\n            timeouts = pendingTimeouts.elements();\r\n            while (timeouts.hasMoreElements()) {\r\n                TimeoutInfo timeoutInfo = (TimeoutInfo) timeouts.nextElement();\r\n                if (new Date().getTime() > timeoutInfo.expireTime) {\r\n                    if (timedOut == null) {\r\n                        timedOut = new Vector();\r\n                    }\r\n                    timedOut.addElement(timeoutInfo);\r\n                }\r\n            }\r\n        }\r\n        synchronized (indoubtTimeouts) {\r\n            timeouts = indoubtTimeouts.elements();\r\n            while (timeouts.hasMoreElements()) {\r\n                TimeoutInfo timeoutInfo = (TimeoutInfo) timeouts.nextElement();\r\n                if (new Date().getTime() > timeoutInfo.expireTime) {\r\n                    if (timedOut == null) {\r\n                        timedOut = new Vector();\r\n                    }\r\n                    timedOut.addElement(timeoutInfo);\r\n                }\r\n            }\r\n        }\r\n        if (timedOut != null) {\r\n            result = timedOut.elements();\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.realm.RealmBase.digest",
	"Comment": "digest the password using the specified algorithm andconvert the result to a corresponding hexadecimal string.if exception, the plain credentials string is returned.",
	"Method": "char[] digest(char[] credentials){\r\n    if (hasMessageDigest() == false)\r\n        return (credentials);\r\n    synchronized (this) {\r\n        try {\r\n            md.reset();\r\n            byte[] bytes = null;\r\n            try {\r\n                bytes = Utility.convertCharArrayToByteArray(credentials, getDigestEncoding());\r\n            } catch (CharacterCodingException cce) {\r\n                String msg = MessageFormat.format(rb.getString(LogFacade.ILLEGAL_DIGEST_ENCODING_EXCEPTION), getDigestEncoding());\r\n                log.log(Level.SEVERE, msg, cce);\r\n                throw new IllegalArgumentException(cce.getMessage());\r\n            }\r\n            md.update(bytes);\r\n            return (HexUtils.convert(md.digest()));\r\n        } catch (Exception e) {\r\n            log.log(Level.SEVERE, LogFacade.ERROR_DIGESTING_USER_CREDENTIAL_EXCEPTION, e);\r\n            return (credentials);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.launcher.GFLauncher.launch",
	"Comment": "launches the server. any fatal error results in a gflauncherexception nounchecked throwables of any kind will be thrown.",
	"Method": "void launch(){\r\n    try {\r\n        startTime = System.currentTimeMillis();\r\n        if (!setupCalledByClients)\r\n            setup();\r\n        internalLaunch();\r\n    } catch (GFLauncherException gfe) {\r\n        throw gfe;\r\n    } catch (Throwable t) {\r\n        throw new GFLauncherException(strings.get(\"unknownError\", t.getMessage()), t);\r\n    } finally {\r\n        GFLauncherLogger.removeLogFileHandler();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.server.AppServerStartupTest.afterTest",
	"Comment": "ensure that things are stopped after the test... if not then call stop.",
	"Method": "void afterTest(){\r\n    if (as != null) {\r\n        if (as.runLevelController.getCurrentRunLevel() > 0) {\r\n            as.env.setStatus(ServerEnvironment.Status.started);\r\n            as.stop();\r\n        }\r\n        as.events.unregister(results);\r\n    }\r\n    results = null;\r\n    listFutures = null;\r\n    mapPostConstructExceptions = null;\r\n    ServiceLocatorFactory.getInstance().destroy(testLocator);\r\n    testLocator = null;\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.resources.AbstractResource.getSubject",
	"Comment": "this method will return the subject associated with the current request.",
	"Method": "Subject getSubject(){\r\n    return subjectRef.get();\r\n}"
}, {
	"Path": "components.taglib.GraphMenuTreeTag.setSelectedClass",
	"Comment": "the css style class to be applied to the textof selected nodes. this can be value or a value binding referenceexpression.",
	"Method": "void setSelectedClass(String styleSelected){\r\n    this.selectedClass = styleSelected;\r\n}"
}, {
	"Path": "com.sun.enterprise.glassfish.bootstrap.MainHelper.addRawStartupInfo",
	"Comment": "need the raw unprocessed args for restartdomaincommand in case we were not startedby cli",
	"Method": "void addRawStartupInfo(String[] args,Properties p){\r\n    StringBuilder sb = new StringBuilder();\r\n    for (int i = 0; i < args.length; i++) {\r\n        if (i > 0)\r\n            sb.append(Constants.ARG_SEP);\r\n        sb.append(args[i]);\r\n    }\r\n    if (!wasStartedByCLI(p)) {\r\n        p.put(Constants.ORIGINAL_CP, System.getProperty(\"java.class.path\"));\r\n        p.put(Constants.ORIGINAL_CN, ASMain.class.getName());\r\n        p.put(Constants.ORIGINAL_ARGS, sb.toString());\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.gms.bootstrap.HealthHistory.getInstancesByState",
	"Comment": "the returned list may be modified without affectingthe information in the healthhistory object.",
	"Method": "List<String> getInstancesByState(STATE targetState){\r\n    List<String> retVal = new ArrayList<String>(healthMap.size());\r\n    for (String name : healthMap.keySet()) {\r\n        if (healthMap.get(name).state == targetState) {\r\n            retVal.add(name);\r\n        }\r\n    }\r\n    return retVal;\r\n}"
}, {
	"Path": "com.sun.appserv.web.cache.filter.CachingOutputStreamWrapper.isReady",
	"Comment": "this method can be used to determine if data can be written without blocking.",
	"Method": "boolean isReady(){\r\n    return true;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.CLICommand.getCommandScope",
	"Comment": "return the command scope for this command.the command scope is a name space in which commands are defined. command clients can specify a scopeto use in looking up a command. currently this is only used for remotecommands. by default, the context is null.",
	"Method": "String getCommandScope(){\r\n    return commandScope;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.Initializer.usage",
	"Comment": "display usage message to user upon encountering invalid option",
	"Method": "void usage(){\r\n    if (!verifierFrameworkContext.isUsingGui()) {\r\n        logger.log(Level.INFO, getUsageString());\r\n        System.exit(1);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.universal.process.ProcessManagerTest.test1",
	"Comment": "temporary test of processmanagerthis stuff is platform dependent.",
	"Method": "void test1(){\r\n    ProcessManager pm;\r\n    System.out.println(\"If it is FROZEN RIGHT NOW -- then Houston, we have a problem!\");\r\n    System.out.println(\"ProcessManager must have the write to stdin before the reader threads have started!\");\r\n    if (OS.isWindows())\r\n        pm = new ProcessManager(\"cmd\", \"/c\", \"type\", textfile);\r\n    else\r\n        pm = new ProcessManager(\"cat\", textfile);\r\n    pm.setStdinLines(hugeInput());\r\n    pm.setEcho(false);\r\n    pm.execute();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.removeChild",
	"Comment": "removes the given coordinator from the set of children of the targetsubcoordinator.if the subcoordinator is a temporary ancestor, and has norecoverable state after the child is removed, it destroys itself.",
	"Method": "boolean removeChild(CoordinatorImpl child){\r\n    boolean result = false;\r\n    if (nestingInfo != null) {\r\n        result = nestingInfo.removeChild(child);\r\n    }\r\n    if (temporary && !registered && !(participants != null && participants.involved()) && !(nestingInfo != null && nestingInfo.numChildren() > 0)) {\r\n        CoordinatorImpl parent = nestingInfo.getParent(true);\r\n        cleanUpEmpty(parent);\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.stringsubs.impl.algorithm.TestRadixTreeSubstitution.callSubstitution",
	"Comment": "calls the algorithm and return the replacement for thegiven input string.",
	"Method": "String callSubstitution(String input){\r\n    StringBuffer outputBuffer = new StringBuffer();\r\n    String substitution = null;\r\n    for (char c : input.toCharArray()) {\r\n        substitution = _substitution.substitute(c);\r\n        if (substitution != null) {\r\n            outputBuffer.append(substitution);\r\n        }\r\n    }\r\n    substitution = _substitution.substitute(null);\r\n    if (substitution != null) {\r\n        outputBuffer.append(substitution);\r\n    }\r\n    return outputBuffer.toString();\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.addHeader",
	"Comment": "add a header to the set of headers associated with this request.",
	"Method": "void addHeader(String name,String value){\r\n    coyoteRequest.getRequest().getHeaders().addValue(name).setString(value);\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.SingleSignOn.register",
	"Comment": "register the specified principal as being associated with the specifiedvalue for the single sign on identifier.",
	"Method": "void register(String ssoId,Principal principal,String authType,String username,char[] password,String realmName){\r\n    if (debug >= 1) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.REGISTERING_SSO_INFO), new Object[] { ssoId, principal.getName(), authType });\r\n        log(msg);\r\n    }\r\n    synchronized (cache) {\r\n        cache.put(ssoId, new SingleSignOnEntry(ssoId, 0L, principal, authType, username, realmName));\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.DeleteTransport.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    ActionReport report = context.getActionReport();\r\n    NetworkConfig networkConfig = config.getNetworkConfig();\r\n    Transports transports = networkConfig.getTransports();\r\n    try {\r\n        for (Transport transport : transports.getTransport()) {\r\n            if (transportName.equalsIgnoreCase(transport.getName())) {\r\n                transportToBeRemoved = transport;\r\n            }\r\n        }\r\n        if (transportToBeRemoved == null) {\r\n            report.setMessage(MessageFormat.format(rb.getString(LogFacade.DELETE_TRANSPORT_NOT_EXISTS), transportName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n        List<NetworkListener> nwlsnrList = transportToBeRemoved.findNetworkListeners();\r\n        for (NetworkListener nwlsnr : nwlsnrList) {\r\n            if (transportToBeRemoved.getName().equals(nwlsnr.getTransport())) {\r\n                report.setMessage(MessageFormat.format(rb.getString(LogFacade.DELETE_TRANSPORT_BEINGUSED), transportName, nwlsnr.getName()));\r\n                report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n                return;\r\n            }\r\n        }\r\n        ConfigSupport.apply(new SingleConfigCode<Transports>() {\r\n            public Object run(Transports param) {\r\n                param.getTransport().remove(transportToBeRemoved);\r\n                return transportToBeRemoved;\r\n            }\r\n        }, transports);\r\n    } catch (TransactionFailure e) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.DELETE_TRANSPORT_FAIL), transportName) + \"  \" + e.getLocalizedMessage());\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.DeleteTransport.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the paramter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    param.getTransport().remove(transportToBeRemoved);\r\n    return transportToBeRemoved;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.web.FilterClass.check",
	"Comment": "iterates over all declared filter in the archive file and delegates actual test on individual filter class to runindividualfiltertest",
	"Method": "Result check(WebBundleDescriptor descriptor){\r\n    Result result;\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    Enumeration filterEnum = descriptor.getServletFilterDescriptors().elements();\r\n    if (filterEnum.hasMoreElements()) {\r\n        boolean oneFailed = false;\r\n        result = loadWarFile(descriptor);\r\n        while (filterEnum.hasMoreElements()) {\r\n            ServletFilterDescriptor filter = (ServletFilterDescriptor) filterEnum.nextElement();\r\n            Class filterClass = loadClass(result, filter.getClassName());\r\n            if (!runIndividualFilterTest(result, filterClass))\r\n                oneFailed = true;\r\n        }\r\n        if (oneFailed) {\r\n            result.setStatus(Result.FAILED);\r\n        } else {\r\n            result.setStatus(Result.PASSED);\r\n        }\r\n    } else {\r\n        result = getInitializedResult();\r\n        result.setStatus(Result.NOT_APPLICABLE);\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.web.FilterClass\" + \".notApplicable\", \"There are no filter components within the web archive [ {0} ]\", new Object[] { descriptor.getName() }));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.NamingResources.removeMessageDestinationRef",
	"Comment": "remove any message destination reference with the specified name.",
	"Method": "void removeMessageDestinationRef(String name){\r\n    entries.remove(name);\r\n    MessageDestinationRef mdr = null;\r\n    synchronized (mdrs) {\r\n        mdr = mdrs.remove(name);\r\n    }\r\n    if (mdr != null) {\r\n        support.firePropertyChange(\"messageDestinationRef\", mdr, null);\r\n        mdr.setNamingResources(null);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.api.admin.progress.ProgressStatusBase.getSpinnerStatus",
	"Comment": "returns spinner status or null if status was not possible to check.",
	"Method": "boolean getSpinnerStatus(){\r\n    if (parent == null) {\r\n        return false;\r\n    }\r\n    if (parent instanceof CommandProgress) {\r\n        return ((CommandProgress) parent).isSpinnerActive();\r\n    }\r\n    return ((ProgressStatusBase) parent).getSpinnerStatus();\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.JavaEETransactionImpl.getAllParticipatingPools",
	"Comment": "return all pools registered in the resourcetable. thiswill cut down the scope of pools on which transactioncompltedis called by the poolmanagerimpl. this method will returnonly those pools that have ever participated in a tx",
	"Method": "Set getAllParticipatingPools(){\r\n    return (Set) resourceTable.keySet();\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.modified",
	"Comment": "have one or more classes or resources been modified so that a reloadis appropriate?",
	"Method": "boolean modified(){\r\n    if (logger.isLoggable(Level.FINER))\r\n        logger.log(Level.FINER, \"modified()\");\r\n    int length = paths.length;\r\n    int length2 = lastModifiedDates.length;\r\n    if (length > length2)\r\n        length = length2;\r\n    for (int i = 0; i < length; i++) {\r\n        try {\r\n            long lastModified = ((ResourceAttributes) resources.getAttributes(paths[i])).getLastModified();\r\n            if (lastModified != lastModifiedDates[i]) {\r\n                if (logger.isLoggable(Level.FINER))\r\n                    logger.log(Level.FINER, \"  Resource '\" + paths[i] + \"' was modified; Date is now: \" + new java.util.Date(lastModified) + \" Was: \" + new java.util.Date(lastModifiedDates[i]));\r\n                return (true);\r\n            }\r\n        } catch (NamingException e) {\r\n            logger.log(Level.SEVERE, LogFacade.MISSING_RESOURCE, paths[i]);\r\n            return (true);\r\n        }\r\n    }\r\n    length = jarNames.size();\r\n    if (getJarPath() != null) {\r\n        try {\r\n            NamingEnumeration<Binding> enumeration = resources.listBindings(getJarPath());\r\n            int i = 0;\r\n            while (enumeration.hasMoreElements() && (i < length)) {\r\n                NameClassPair ncPair = enumeration.nextElement();\r\n                String name = ncPair.getName();\r\n                if (!name.endsWith(\".jar\") && !name.endsWith(\".zip\"))\r\n                    continue;\r\n                if (!name.equals(jarNames.get(i))) {\r\n                    logger.log(Level.FINER, \"    Additional JARs have been added : '\" + name + \"'\");\r\n                    return (true);\r\n                }\r\n                i++;\r\n            }\r\n            if (enumeration.hasMoreElements()) {\r\n                while (enumeration.hasMoreElements()) {\r\n                    NameClassPair ncPair = enumeration.nextElement();\r\n                    String name = ncPair.getName();\r\n                    if (name.endsWith(\".jar\") || name.endsWith(\".zip\")) {\r\n                        logger.log(Level.FINER, \"    Additional JARs have been added\");\r\n                        return (true);\r\n                    }\r\n                }\r\n            } else if (i < jarNames.size()) {\r\n                logger.log(Level.FINER, \"    Additional JARs have been added\");\r\n                return (true);\r\n            }\r\n        } catch (NamingException e) {\r\n            if (logger.isLoggable(Level.FINER))\r\n                logger.log(Level.FINER, \"    Failed tracking modifications of '\" + getJarPath() + \"'\");\r\n        } catch (ClassCastException e) {\r\n            logger.log(Level.SEVERE, LogFacade.FAILED_TRACKING_MODIFICATIONS, new Object[] { getJarPath(), e.getMessage() });\r\n        }\r\n    }\r\n    return (false);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationHttpRequest.getSession",
	"Comment": "return the session associated with this request, creating oneif necessary and requested.",
	"Method": "HttpSession getSession(HttpSession getSession,boolean create){\r\n    if (crossContext) {\r\n        if (context == null)\r\n            return (null);\r\n        if (session != null && session.isValid()) {\r\n            return (session.getSession());\r\n        }\r\n        HttpSession other = super.getSession(false);\r\n        if (create && (other == null)) {\r\n            other = super.getSession(true);\r\n        }\r\n        if (other != null) {\r\n            Session localSession = null;\r\n            try {\r\n                if (isSessionVersioningSupported) {\r\n                    localSession = context.getManager().findSession(other.getId(), requestedSessionVersion);\r\n                    if (localSession instanceof StandardSession) {\r\n                        incrementSessionVersion((StandardSession) localSession, context);\r\n                    }\r\n                } else {\r\n                    localSession = context.getManager().findSession(other.getId());\r\n                }\r\n            } catch (IOException e) {\r\n            }\r\n            if ((localSession != null) && !localSession.isValid()) {\r\n                localSession = null;\r\n            } else if (localSession == null && create) {\r\n                localSession = context.getManager().createSession(other.getId());\r\n                if (isSessionVersioningSupported && localSession instanceof StandardSession) {\r\n                    incrementSessionVersion((StandardSession) localSession, context);\r\n                }\r\n                RequestFacadeHelper reqFacHelper = RequestFacadeHelper.getInstance(getRequest());\r\n                if (reqFacHelper != null) {\r\n                    reqFacHelper.track(localSession);\r\n                }\r\n            }\r\n            if (localSession != null) {\r\n                localSession.access();\r\n                session = localSession;\r\n                return session.getSession();\r\n            }\r\n        }\r\n        return null;\r\n    } else {\r\n        return super.getSession(create);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.cli.StartDomainCommand.respawnArgs",
	"Comment": "return the asadmin command line arguments necessary to startthis domain admin server.",
	"Method": "String[] respawnArgs(){\r\n    List<String> args = new ArrayList<String>(15);\r\n    args.addAll(Arrays.asList(programOpts.getProgramArguments()));\r\n    args.add(getName());\r\n    args.add(\"--verbose=\" + String.valueOf(verbose));\r\n    args.add(\"--watchdog=\" + String.valueOf(watchdog));\r\n    args.add(\"--debug=\" + String.valueOf(debug));\r\n    args.add(\"--domaindir\");\r\n    args.add(getDomainsDir().toString());\r\n    if (ok(getDomainName()))\r\n        args.add(getDomainName());\r\n    if (logger.isLoggable(Level.FINER))\r\n        logger.log(Level.FINER, \"Respawn args: {0}\", args.toString());\r\n    String[] a = new String[args.size()];\r\n    args.toArray(a);\r\n    return a;\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.PartItem.getCharSet",
	"Comment": "returns the content charset passed by the agent or null ifnot defined.",
	"Method": "String getCharSet(){\r\n    ParameterParser parser = new ParameterParser();\r\n    parser.setLowerCaseNames(true);\r\n    Map<String, String> params = parser.parse(getContentType(), ';');\r\n    return params.get(\"charset\");\r\n}"
}, {
	"Path": "org.glassfish.server.ServerEnvironmentImpl.getApplicationPolicyFilePath",
	"Comment": "returns the path for policy files for applicationsdeployed on this instance.",
	"Method": "File getApplicationPolicyFilePath(){\r\n    return new File(getApplicationStubPath(), kPolicyFileDirName);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.KeystoreManager.createKeyStore",
	"Comment": "create the default ssl key store using keytool to generate a self signedcertificate.",
	"Method": "void createKeyStore(File keystore,RepositoryConfig config,String masterPassword){\r\n    final String dasCertDN = getDASCertDN(config);\r\n    System.out.println(_strMgr.getString(\"CertificateDN\", dasCertDN));\r\n    addSelfSignedCertToKeyStore(keystore, CERTIFICATE_ALIAS, masterPassword, dasCertDN);\r\n    final String instanceCertDN = getInstanceCertDN(config);\r\n    System.out.println(_strMgr.getString(\"CertificateDN\", instanceCertDN));\r\n    addSelfSignedCertToKeyStore(keystore, INSTANCE_SECURE_ADMIN_ALIAS, masterPassword, instanceCertDN);\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityConstraint.removeCollection",
	"Comment": "remove the specified web resource collection from those protected bythis security constraint.",
	"Method": "void removeCollection(SecurityCollection collection){\r\n    if (collection == null)\r\n        return;\r\n    int n = -1;\r\n    for (int i = 0; i < collections.length; i++) {\r\n        if (collections[i].equals(collection)) {\r\n            n = i;\r\n            break;\r\n        }\r\n    }\r\n    if (n >= 0) {\r\n        int j = 0;\r\n        SecurityCollection[] results = new SecurityCollection[collections.length - 1];\r\n        for (int i = 0; i < collections.length; i++) {\r\n            if (i != n)\r\n                results[j++] = collections[i];\r\n        }\r\n        collections = results;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.web.EmbeddedWebContainer.getConnectors",
	"Comment": "returns the list of connector objects associated with this embeddedwebcontainer.",
	"Method": "Connector[] getConnectors(){\r\n    return connectors;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.accesslog.DefaultAccessLogFormatterImpl.appendHTTPUri",
	"Comment": "appends the uri of the given request to the given char buffer.",
	"Method": "void appendHTTPUri(CharBuffer cb,HttpServletRequest hreq){\r\n    cb.put(QUOTE);\r\n    String uri = hreq.getRequestURI();\r\n    if (uri == null) {\r\n        uri = \"NULL-HTTP-URI\";\r\n    }\r\n    cb.put(uri);\r\n    cb.put(QUOTE);\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.utils.Util.getParentName",
	"Comment": "returns just the parent name of the resource from the resource url.",
	"Method": "String getParentName(UriInfo uriInfo,String getParentName,String url){\r\n    if ((url == null) || (\"\".equals(url))) {\r\n        return url;\r\n    }\r\n    String name = getName(url, '/');\r\n    int nameIndex = url.indexOf(name, url.indexOf(\":\") + 1);\r\n    return getName(url.substring(0, nameIndex - 1), '/');\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getInitParameter",
	"Comment": "return the value of the specified initialization parameter, ornull if this parameter does not exist.",
	"Method": "String getInitParameter(String name){\r\n    return parameters.get(name);\r\n}"
}, {
	"Path": "com.sun.enterprise.config.modularity.ConfigModularityUtils.convertConfigElementNameToClassName",
	"Comment": "convert a configuration element name to representing class name",
	"Method": "String convertConfigElementNameToClassName(String name){\r\n    StringTokenizer tokenizer = new StringTokenizer(name, \"-\", false);\r\n    StringBuilder className = new StringBuilder();\r\n    while (tokenizer.hasMoreTokens()) {\r\n        String part = tokenizer.nextToken();\r\n        Locale loc = Locale.getDefault();\r\n        part = part.replaceFirst(part.substring(0, 1), part.substring(0, 1).toUpperCase(loc));\r\n        className.append(part);\r\n    }\r\n    return className.toString();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RWLock.isWriteLocked",
	"Comment": "iswritelockedreturns true if the rwlock is in a write locked state.",
	"Method": "boolean isWriteLocked(){\r\n    return currentWriters > 0;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.DefaultTransactionService.get_current",
	"Comment": "obtain the implementation of the current interface providedby the transaction service implementation.",
	"Method": "org.omg.CosTransactions.Current get_current(){\r\n    org.omg.CosTransactions.Current result = null;\r\n    result = (org.omg.CosTransactions.Current) currentInstance;\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.RegisteredResources.distributeSubcommit",
	"Comment": "distributes commitsubtransaction messages to all registeredsubtransactionawareresources.",
	"Method": "void distributeSubcommit(Coordinator parent){\r\n    boolean exceptionRaised = false;\r\n    for (int i = 0; i < nRes; i++) {\r\n        boolean isProxy = false;\r\n        SubtransactionAwareResource currResource = (SubtransactionAwareResource) resourceObjects.get(i);\r\n        if (!(currResource instanceof com.sun.jts.jtsxa.OTSResourceImpl)) {\r\n            ProxyChecker checkProxy = Configuration.getProxyChecker();\r\n            isProxy = checkProxy.isProxy(currResource);\r\n        }\r\n        try {\r\n            currResource.commit_subtransaction(parent);\r\n        } catch (Throwable exc) {\r\n            if (exc instanceof TRANSACTION_ROLLEDBACK) {\r\n                exceptionRaised = true;\r\n            }\r\n        }\r\n        resourceStates.set(i, ResourceStatus.Completed);\r\n        if (isProxy) {\r\n            currResource._release();\r\n        }\r\n    }\r\n    if (exceptionRaised) {\r\n        throw new TRANSACTION_ROLLEDBACK(0, CompletionStatus.COMPLETED_YES);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.SynchronizeInstanceCommand.getFileModTimes",
	"Comment": "get the mod times for the entries in dir and add them to thesyncrequest, using names relative to basedir.if level isrecursive, check subdirectories and only include times for files,not directories.",
	"Method": "void getFileModTimes(File dir,File baseDir,SyncRequest sr,SyncLevel level){\r\n    if (level == SyncLevel.TOP) {\r\n        long time = dir.lastModified();\r\n        SyncRequest.ModTime mt = new SyncRequest.ModTime(\".\", time);\r\n        sr.files.add(mt);\r\n        return;\r\n    }\r\n    for (String file : dir.list()) {\r\n        File f = new File(dir, file);\r\n        long time = f.lastModified();\r\n        if (time == 0)\r\n            continue;\r\n        if (f.isDirectory()) {\r\n            if (level == SyncLevel.RECURSIVE) {\r\n                getFileModTimes(f, baseDir, sr, level);\r\n                continue;\r\n            } else if (level == SyncLevel.FILES)\r\n                continue;\r\n        }\r\n        String name = baseDir.toURI().relativize(f.toURI()).getPath();\r\n        if (name.endsWith(\"/\"))\r\n            name = name.substring(0, name.length() - 1);\r\n        SyncRequest.ModTime mt = new SyncRequest.ModTime(name, time);\r\n        sr.files.add(mt);\r\n        if (logger.isLoggable(Level.FINER))\r\n            logger.finer(f + \": mod time \" + mt.time);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.EjbHasLocalorRemoteorBothInterfaces.check",
	"Comment": "bean interface type test.the bean provider must provide either local or remote or both interfaces",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!(descriptor instanceof EjbSessionDescriptor) && !(descriptor instanceof EjbEntityDescriptor)) {\r\n        addNaDetails(result, compName);\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.intf.InterfaceClassExist.notApplicable1\", \"Test apply only to session or entity beans.\"));\r\n        return result;\r\n    }\r\n    if ((descriptor.getRemoteClassName() == null || \"\".equals(descriptor.getRemoteClassName())) && (descriptor.getLocalClassName() == null || \"\".equals(descriptor.getLocalClassName()))) {\r\n        if (implementsEndpoints(descriptor)) {\r\n            addNaDetails(result, compName);\r\n            result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.webservice.notapp\", \"Not Applicable because, EJB [ {0} ] implements a Service Endpoint Interface.\", new Object[] { compName.toString() }));\r\n            return result;\r\n        } else {\r\n            addErrorDetails(result, compName);\r\n            result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Ejb [ {0} ] does not have local or remote interfaces\", new Object[] { descriptor.getEjbClassName() }));\r\n            return result;\r\n        }\r\n    } else {\r\n        addGoodDetails(result, compName);\r\n        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"Ejb [ {0} ] does have valid local and/or remote interfaces\", new Object[] { descriptor.getEjbClassName() }));\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.weld.WeldContextListener.contextInitialized",
	"Comment": "stash the weld el resolver and weld el context listener so it is recognized by jsp.",
	"Method": "void contextInitialized(ServletContextEvent servletContextEvent){\r\n    if (null != beanManager) {\r\n        JspApplicationContext jspAppContext = getJspApplicationContext(servletContextEvent);\r\n        jspAppContext.addELResolver(beanManager.getELResolver());\r\n        try {\r\n            Class weldClass = Class.forName(\"org.jboss.weld.module.web.el.WeldELContextListener\");\r\n            WeldELContextListener welcl = (WeldELContextListener) weldClass.newInstance();\r\n            jspAppContext.addELContextListener(welcl);\r\n        } catch (Exception e) {\r\n            logger.log(Level.WARNING, CDILoggerInfo.CDI_COULD_NOT_CREATE_WELDELCONTEXTlISTENER, new Object[] { e });\r\n        }\r\n        ((JspApplicationContextImpl) jspAppContext).setExpressionFactory(beanManager.wrapExpressionFactory(jspAppContext.getExpressionFactory()));\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.admin.payload.PayloadFilesManager.processPartsExtended",
	"Comment": "returns all files extracted from the payload, treating each part as aseparate file, via a map from each file to its associated properties.",
	"Method": "Map<File, Properties> processPartsExtended(Payload.Inbound inboundPayload){\r\n    if (inboundPayload == null) {\r\n        return Collections.EMPTY_MAP;\r\n    }\r\n    final Map<File, Properties> result = new LinkedHashMap<File, Properties>();\r\n    boolean isReportProcessed = false;\r\n    Part possibleUnrecognizedReportPart = null;\r\n    StringBuilder uploadedEntryNames = new StringBuilder();\r\n    for (Iterator<Payload.Part> partIt = inboundPayload.parts(); partIt.hasNext(); ) {\r\n        Payload.Part part = partIt.next();\r\n        DataRequestType drt = DataRequestType.getType(part);\r\n        if (drt != null) {\r\n            result.put(drt.processPart(this, part, part.getName()), part.getProperties());\r\n            isReportProcessed |= (drt == DataRequestType.REPORT);\r\n            uploadedEntryNames.append(part.getName()).append(\" \");\r\n        } else {\r\n            if ((!isReportProcessed) && possibleUnrecognizedReportPart == null) {\r\n                possibleUnrecognizedReportPart = part;\r\n            }\r\n        }\r\n    }\r\n    if ((!isReportProcessed) && possibleUnrecognizedReportPart != null) {\r\n        DataRequestType.REPORT.processPart(this, possibleUnrecognizedReportPart, possibleUnrecognizedReportPart.getName());\r\n        isReportProcessed = true;\r\n    }\r\n    postProcessParts();\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.ControlImpl.popAborted",
	"Comment": "locates the first stacked ancestor which has not aborted.if there is nosuch ancestor the operation returns null.",
	"Method": "ControlImpl popAborted(){\r\n    ControlImpl result = stacked;\r\n    boolean validTID = false;\r\n    StatusHolder outStatus = new StatusHolder();\r\n    while (result != null && !validTID) {\r\n        Long localTID = null;\r\n        try {\r\n            localTID = result.getLocalTID(outStatus);\r\n            validTID = RecoveryManager.validLocalTID(localTID);\r\n        } catch (Throwable exc) {\r\n        }\r\n        if (!validTID) {\r\n            ControlImpl stacked = result.popControl(outStatus);\r\n            result.destroy();\r\n            result = stacked;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.adapter.AdminConsoleAdapter.isRegistered",
	"Comment": "checks whether this adapter has been registered as a network endpoint.",
	"Method": "boolean isRegistered(){\r\n    return isRegistered;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.getEffectiveMajorVersion",
	"Comment": "gets the major version of the servlet specification that theapplication represented by this servletcontext is based on.",
	"Method": "int getEffectiveMajorVersion(){\r\n    return context.getEffectiveMajorVersion();\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.cci.ConnectionMetaDataExistence.check",
	"Comment": "test if a javax.resource.cci.connectionmetadata implementation has been provided in the rar file",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (isCCIImplemented(descriptor, result)) {\r\n        findImplementorOf(descriptor, \"javax.resource.cci.ConnectionMetaData\", result);\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.cci.InteractionExistence.notapp\", \"NotApplicable : The CCI interfaces do not seem to be implemented by this resource adapter\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ContainerBase.fireContainerEvent",
	"Comment": "notify all container event listeners that a particular event hasoccurred for this container.the default implementation performsthis notification synchronously using the calling thread.",
	"Method": "void fireContainerEvent(String type,Object data){\r\n    ContainerListener[] list = null;\r\n    synchronized (listeners) {\r\n        if (listeners.isEmpty()) {\r\n            return;\r\n        }\r\n        list = listenersArray;\r\n    }\r\n    ContainerEvent event = new ContainerEvent(this, type, data);\r\n    for (int i = 0; i < list.length; i++) {\r\n        list[i].containerEvent(event);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHostDeployer.getParentClassLoader",
	"Comment": "delegate a request for the parent class loader to our associated host.",
	"Method": "ClassLoader getParentClassLoader(){\r\n    return (host.getParentClassLoader());\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.Environment.getPrefix",
	"Comment": "get the prefix for environment variables referenced from the system environment by environment objects.",
	"Method": "String getPrefix(){\r\n    return PREFIX;\r\n}"
}, {
	"Path": "org.glassfish.web.sniffer.WebSniffer.handles",
	"Comment": "returns true if the passed file or directory is recognized by thisinstance.",
	"Method": "boolean handles(DeploymentContext context,boolean handles,ReadableArchive location){\r\n    return DeploymentUtils.isArchiveOfType(location, warType, locator);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.remote.DASUtils.pingDASWithAuth",
	"Comment": "see if das is alive, but insist that athentication is correct.do not print out the results of the version command from the server.",
	"Method": "Error pingDASWithAuth(ProgramOptions programOpts,Environment env){\r\n    try {\r\n        RemoteCLICommand cmd = new RemoteCLICommand(\"version\", programOpts, env);\r\n        cmd.executeAndReturnOutput(new String[] { \"version\" });\r\n    } catch (AuthenticationException aex) {\r\n        return Error.AUTHENTICATION;\r\n    } catch (Exception ex) {\r\n        ExceptionAnalyzer ea = new ExceptionAnalyzer(ex);\r\n        if (ea.getFirstInstanceOf(ConnectException.class) != null) {\r\n            logger.finer(\"Got java.net.ConnectException\");\r\n            return Error.CONNECTION;\r\n        } else if (ea.getFirstInstanceOf(IOException.class) != null) {\r\n            if (logger.isLoggable(Level.FINER))\r\n                logger.finer(\"It appears that server has started, but for\" + \" some reason this exception was thrown: \" + ex.getMessage());\r\n            return Error.IO;\r\n        } else {\r\n            return Error.UNKNOWN;\r\n        }\r\n    }\r\n    return Error.NONE;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.validateJSR299Scope",
	"Comment": "according to srv 15.5.15, servlets, filters, listeners can only bewithout any scope annotation or are annotated with",
	"Method": "void validateJSR299Scope(Class<?> clazz){\r\n    if (jcdiService != null && jcdiService.isCDIScoped(clazz)) {\r\n        String msg = rb.getString(LogFacade.INVALID_ANNOTATION_SCOPE);\r\n        msg = MessageFormat.format(msg, clazz.getName());\r\n        throw new IllegalArgumentException(msg);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.common.util.timer.TimerSchedule.getNextTimeout",
	"Comment": "returns the date of the next possible timeout for a specificyear value and starting date. if year is 0, any year will be correct.",
	"Method": "Calendar getNextTimeout(Calendar getNextTimeout,Date date,Calendar getNextTimeout,Calendar next,Calendar getNextTimeout,Calendar next,int year){\r\n    int i = 0;\r\n    while (end_ == null || !next.getTime().after(end_)) {\r\n        if (year != 0 && next.get(Calendar.YEAR) > year) {\r\n            break;\r\n        }\r\n        if (skipToNextValue(next, months, Calendar.MONTH, Calendar.YEAR)) {\r\n            if (++i > MAX_YEAR_TRY) {\r\n                isValid = false;\r\n                break;\r\n            }\r\n            next.set(Calendar.DAY_OF_MONTH, 1);\r\n            next.set(Calendar.HOUR_OF_DAY, 0);\r\n            next.set(Calendar.MINUTE, 0);\r\n            next.set(Calendar.SECOND, 0);\r\n            continue;\r\n        }\r\n        if (dayOfWeek_.equals(\"*\")) {\r\n            if (skipToNextValue(next, daysOfMonth, Calendar.DAY_OF_MONTH, Calendar.MONTH)) {\r\n                next.set(Calendar.HOUR_OF_DAY, 0);\r\n                next.set(Calendar.MINUTE, 0);\r\n                next.set(Calendar.SECOND, 0);\r\n                continue;\r\n            }\r\n        } else if (dayOfMonth_.equals(\"*\")) {\r\n            if (skipToNextValue(next, daysOfWeek, Calendar.DAY_OF_WEEK, Calendar.WEEK_OF_MONTH)) {\r\n                next.set(Calendar.HOUR_OF_DAY, 0);\r\n                next.set(Calendar.MINUTE, 0);\r\n                next.set(Calendar.SECOND, 0);\r\n                continue;\r\n            }\r\n        } else {\r\n            Calendar date1 = (Calendar) next.clone();\r\n            Calendar date2 = (Calendar) next.clone();\r\n            boolean changed = false;\r\n            if (skipToNextValue(date1, daysOfMonth, Calendar.DAY_OF_MONTH, Calendar.MONTH)) {\r\n                date1.set(Calendar.HOUR_OF_DAY, 0);\r\n                date1.set(Calendar.MINUTE, 0);\r\n                date1.set(Calendar.SECOND, 0);\r\n            }\r\n            if (skipToNextValue(date2, daysOfWeek, Calendar.DAY_OF_WEEK, Calendar.WEEK_OF_MONTH)) {\r\n                date2.set(Calendar.HOUR_OF_DAY, 0);\r\n                date2.set(Calendar.MINUTE, 0);\r\n                date2.set(Calendar.SECOND, 0);\r\n            }\r\n            Calendar date0 = (date1.before(date2)) ? date1 : date2;\r\n            if (!next.equals(date0)) {\r\n                next = date0;\r\n                continue;\r\n            }\r\n        }\r\n        if (skipToNextValue(next, hours, Calendar.HOUR_OF_DAY, Calendar.DAY_OF_MONTH)) {\r\n            next.set(Calendar.MINUTE, 0);\r\n            next.set(Calendar.SECOND, 0);\r\n            continue;\r\n        }\r\n        if (skipToNextValue(next, minutes, Calendar.MINUTE, Calendar.HOUR_OF_DAY)) {\r\n            next.set(Calendar.SECOND, 0);\r\n            continue;\r\n        }\r\n        if (skipToNextValue(next, seconds, Calendar.SECOND, Calendar.MINUTE)) {\r\n            continue;\r\n        }\r\n        break;\r\n    }\r\n    return next;\r\n}"
}, {
	"Path": "org.apache.catalina.session.StoreBase.processExpires",
	"Comment": "called by our background reaper thread to check if sessionssaved in our store are subject of being expired. if so expirethe session and remove it from the store.",
	"Method": "void processExpires(){\r\n    long timeNow = System.currentTimeMillis();\r\n    String[] keys = null;\r\n    if (!started) {\r\n        return;\r\n    }\r\n    try {\r\n        keys = keys();\r\n    } catch (IOException e) {\r\n        log(\"Error during processExpires\", e);\r\n        return;\r\n    }\r\n    for (int i = 0; i < keys.length; i++) {\r\n        try {\r\n            StandardSession session = (StandardSession) load(keys[i]);\r\n            if (session == null) {\r\n                continue;\r\n            }\r\n            int timeIdle = (int) ((timeNow - session.thisAccessedTime) / 1000L);\r\n            if (timeIdle < session.getMaxInactiveInterval()) {\r\n                continue;\r\n            }\r\n            if (((PersistentManagerBase) manager).isLoaded(keys[i])) {\r\n                session.recycle();\r\n            } else {\r\n                session.expire();\r\n            }\r\n            remove(keys[i]);\r\n        } catch (IOException e) {\r\n            log(\"Error during processExpires\", e);\r\n        } catch (ClassNotFoundException e) {\r\n            log(\"Error during processExpires\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.services.SMFService.setServiceProperties",
	"Comment": "sets the additional service properties that are specific to it.",
	"Method": "void setServiceProperties(String cds){\r\n    if (cds != null) {\r\n        final Set<String> props = ps2Pairs(cds);\r\n        if (props.contains(NETADDR_PRIV_VAL)) {\r\n            getTokenMap().put(PRIVILEGES_TN, BASIC_NETADDR_PRIV_VAL);\r\n        }\r\n        if (props.contains(NO_START_INSTANCES_PROPERTY)) {\r\n            getTokenMap().put(START_INSTANCES_TN, Boolean.FALSE.toString());\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getMajorVersion",
	"Comment": "return the major version of the java servlet api that we implement.",
	"Method": "int getMajorVersion(){\r\n    return context.getMajorVersion();\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.generator.ResourcesGeneratorBase.generateCommandResourceClass",
	"Comment": "generate code for resource class corresponding to given parentbeanname and command",
	"Method": "void generateCommandResourceClass(String parentBeanName,CommandResourceMetaData metaData){\r\n    String commandResourceClassName = getClassName(parentBeanName + getBeanName(metaData.resourcePath));\r\n    if (alreadyGenerated(commandResourceClassName)) {\r\n        return;\r\n    }\r\n    String commandName = metaData.command;\r\n    String commandDisplayName = metaData.resourcePath;\r\n    String httpMethod = metaData.httpMethod;\r\n    String commandAction = metaData.displayName;\r\n    String baseClassName;\r\n    if (\"GET\".equals(httpMethod)) {\r\n        baseClassName = \"org.glassfish.admin.rest.resources.TemplateCommandGetResource\";\r\n    } else if (\"DELETE\".equals(httpMethod)) {\r\n        baseClassName = \"org.glassfish.admin.rest.resources.TemplateCommandDeleteResource\";\r\n    } else if (\"POST\".equals(httpMethod)) {\r\n        baseClassName = \"org.glassfish.admin.rest.resources.TemplateCommandPostResource\";\r\n    } else {\r\n        throw new GeneratorException(\"Invalid httpMethod specified: \" + httpMethod);\r\n    }\r\n    ClassWriter classWriter = getClassWriter(commandResourceClassName, baseClassName, null);\r\n    if (classWriter != null) {\r\n        boolean isLinkedToParent = false;\r\n        if (metaData.commandParams != null) {\r\n            for (CommandResourceMetaData.ParameterMetaData parameterMetaData : metaData.commandParams) {\r\n                if (Constants.VAR_PARENT.equals(parameterMetaData.value)) {\r\n                    isLinkedToParent = true;\r\n                }\r\n            }\r\n        }\r\n        classWriter.createCommandResourceConstructor(commandResourceClassName, commandName, httpMethod, isLinkedToParent, metaData.commandParams, commandDisplayName, commandAction);\r\n        classWriter.done();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.util.SecureAdminClientManager.isEnabled",
	"Comment": "reports whether the secure admin is enabled, according to the currentconfiguration.",
	"Method": "boolean isEnabled(){\r\n    return isEnabled;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.ConnectorTest.isClassLoadable",
	"Comment": "check if a class or interface can be loaded from the archive file",
	"Method": "boolean isClassLoadable(String className,Result result){\r\n    ClassLoader jcl = getVerifierContext().getClassLoader();\r\n    try {\r\n        Class.forName(className, false, jcl);\r\n        result.passed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.ConnectorTest.isClassLoadable.passed\", \"The class [ {0} ] is contained in the archive file\", new Object[] { className }));\r\n        return true;\r\n    } catch (ClassNotFoundException cnfe) {\r\n        result.failed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.ConnectorTest.isClassLoadable.failed\", \"The class [ {0} ] is not contained in the archive file\", new Object[] { className }));\r\n        return true;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getMimeType",
	"Comment": "return the mime type of the specified file, or null ifthe mime type cannot be determined.",
	"Method": "String getMimeType(String file){\r\n    return context.getMimeType(file);\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.messagebean.HasValidMessageSelector.check",
	"Comment": "run a verifier test against an individual declared messagedrive bean component",
	"Method": "Result check(EjbMessageBeanDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    String messageSelector = descriptor.getJmsMessageSelector();\r\n    if (messageSelector != null) {\r\n        try {\r\n        } catch (Exception e) {\r\n            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.failed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.messagebean.HasValidMessageSelector.failed\", \"Error : Message-driven bean [ {0} ] defines an invalid message selector\", new Object[] { descriptor.getName() }));\r\n        }\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.ejb.messagebean.HasValidMessageSelector.notApplicable\", \"Message-driven bean [ {0} ] does not define a message selector\", new Object[] { descriptor.getName() }));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "corba.framework.TimerUtils.writeHtmlTable",
	"Comment": "write the timer data in the map to the named file with the giventitle.",
	"Method": "void writeHtmlTable(Map<Timer, Statistics> data,String fname,String title){\r\n    PrintWriter pw = null;\r\n    try {\r\n        pw = new PrintWriter(fname);\r\n        pw.println(\"<html>\" + \"<head>\" + \"  <title>\" + title + \"<\/title>\" + \"<\/head>\" + \"<body>\" + \"<h1>\" + title + \"<\/h1>\" + \"<table border=1 cellpadding=2 cellspacing=2>\" + \"    <tr>\" + \"      <td>name<\/td>\" + \"      <td>count<\/td>\" + \"      <td>min<\/td>\" + \"      <td>max<\/td>\" + \"      <td>average<\/td>\" + \"      <td>std deviation<\/td>\" + \"    <\/tr>\");\r\n        for (Timer timer : data.keySet()) {\r\n            Statistics stats = data.get(timer);\r\n            pw.println(\"    <tr>\" + \"      <td>\" + timer.name() + \"<\/td>\" + \"      <td>\" + stats.count() + \"<\/td>\" + \"      <td>\" + stats.min() + \"<\/td>\" + \"      <td>\" + stats.max() + \"<\/td>\" + \"      <td>\" + stats.average() + \"<\/td>\" + \"      <td>\" + stats.standardDeviation() + \"<\/td>\" + \"    <\/tr>\");\r\n        }\r\n        pw.println(\"<\/table>\" + \"<\/body>\" + \"<\/html>\");\r\n    } catch (Exception exc) {\r\n        throw new RuntimeException(exc);\r\n    } finally {\r\n        if (pw != null)\r\n            pw.close();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.initServlet",
	"Comment": "initializes the given servlet instance, by calling its init method.",
	"Method": "void initServlet(Servlet servlet){\r\n    if (instanceInitialized && !singleThreadModel) {\r\n        return;\r\n    }\r\n    try {\r\n        instanceSupport.fireInstanceEvent(BEFORE_INIT_EVENT, servlet);\r\n        if (SecurityUtil.executeUnderSubjectDoAs()) {\r\n            Object[] initType = new Object[1];\r\n            initType[0] = facade;\r\n            SecurityUtil.doAsPrivilege(\"init\", servlet, classType, initType);\r\n            initType = null;\r\n        } else {\r\n            servlet.init(facade);\r\n        }\r\n        instanceInitialized = true;\r\n        if ((loadOnStartup >= 0) && (jspFile != null)) {\r\n            DummyRequest req = new DummyRequest();\r\n            req.setServletPath(jspFile);\r\n            req.setQueryString(\"jsp_precompile=true\");\r\n            String allowedMethods = (String) parameters.get(\"httpMethods\");\r\n            if (allowedMethods != null && allowedMethods.length() > 0) {\r\n                String[] s = allowedMethods.split(\",\");\r\n                if (s.length > 0) {\r\n                    req.setMethod(s[0].trim());\r\n                }\r\n            }\r\n            DummyResponse res = new DummyResponse();\r\n            if (SecurityUtil.executeUnderSubjectDoAs()) {\r\n                Object[] serviceType = new Object[2];\r\n                serviceType[0] = req;\r\n                serviceType[1] = res;\r\n                SecurityUtil.doAsPrivilege(\"service\", servlet, classTypeUsedInService, serviceType);\r\n            } else {\r\n                servlet.service(req, res);\r\n            }\r\n        }\r\n        instanceSupport.fireInstanceEvent(AFTER_INIT_EVENT, servlet);\r\n    } catch (UnavailableException f) {\r\n        instanceSupport.fireInstanceEvent(AFTER_INIT_EVENT, servlet, f);\r\n        unavailable(f);\r\n        throw f;\r\n    } catch (ServletException f) {\r\n        instanceSupport.fireInstanceEvent(AFTER_INIT_EVENT, servlet, f);\r\n        throw f;\r\n    } catch (Throwable f) {\r\n        getServletContext().log(\"StandardWrapper.Throwable\", f);\r\n        instanceSupport.fireInstanceEvent(AFTER_INIT_EVENT, servlet, f);\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.SERVLET_INIT_EXCEPTION), getName());\r\n        throw new ServletException(msg, f);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.universal.xml.MiniXmlParser.getLogFilename",
	"Comment": "loggingconfig will return an ioexception if there is nologging properties file.",
	"Method": "String getLogFilename(){\r\n    String logFilename = null;\r\n    try {\r\n        Map<String, String> map = loggingConfig.getLoggingProperties();\r\n        String logFileContains = \"${com.sun.aas.instanceName}\";\r\n        logFilename = map.get(LoggingPropertyNames.file);\r\n        if (logFilename != null && logFilename.contains(logFileContains)) {\r\n            logFilename = replaceOld(logFilename, logFileContains, this.serverName);\r\n        }\r\n    } catch (Exception e) {\r\n    }\r\n    return logFilename;\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.JavaEETransactionManagerSimplifiedDelegate.commitDistributedTransaction",
	"Comment": "throws an exception if called as it means that there is no active local transaction to commit.",
	"Method": "void commitDistributedTransaction(){\r\n    throw new IllegalStateException(sm.getString(\"enterprise_distributedtx.transaction_notactive\"));\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getRequestedSessionId",
	"Comment": "return the session identifier included in this request, if any.",
	"Method": "String getRequestedSessionId(){\r\n    return requestedSessionId;\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.AuthenticatorBase.generateSessionId",
	"Comment": "generate and return a new session identifier for the cookie thatidentifies an sso principal.",
	"Method": "String generateSessionId(){\r\n    byte[] bytes = new byte[SESSION_ID_BYTES];\r\n    getRandom().nextBytes(bytes);\r\n    StringBuilder result = new StringBuilder();\r\n    for (int i = 0; i < bytes.length; i++) {\r\n        byte b1 = (byte) ((bytes[i] & 0xf0) >> 4);\r\n        byte b2 = (byte) (bytes[i] & 0x0f);\r\n        if (b1 < 10)\r\n            result.append((char) ('0' + b1));\r\n        else\r\n            result.append((char) ('A' + (b1 - 10)));\r\n        if (b2 < 10)\r\n            result.append((char) ('0' + b2));\r\n        else\r\n            result.append((char) ('A' + (b2 - 10)));\r\n    }\r\n    return (result.toString());\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.LoginConfigurationImpl.getRealmName",
	"Comment": "obtain the realm the server should use for basic authentication.",
	"Method": "String getRealmName(){\r\n    if (this.realmName == null) {\r\n        this.realmName = \"\";\r\n    }\r\n    return this.realmName;\r\n}"
}, {
	"Path": "org.glassfish.admin.payload.PayloadFilesManager.createTempFolder",
	"Comment": "creates a unique temporary directory within the specified parent.",
	"Method": "File createTempFolder(File parent,String prefix,Logger logger,File createTempFolder,File parent,Logger logger){\r\n    return createTempFolder(parent, XFER_DIR_PREFIX, logger);\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.jts.ResourceRecoveryManagerImpl.afterRecovery",
	"Comment": "notifies the event listeners that all recovery operations are completed",
	"Method": "void afterRecovery(boolean success,boolean delegated,String instance){\r\n    Set<RecoveryEventListener> listeners = recoveryListenersRegistry.getEventListeners();\r\n    for (RecoveryEventListener erl : listeners) {\r\n        try {\r\n            erl.afterRecovery(success, delegated, instance);\r\n        } catch (Throwable e) {\r\n            _logger.log(Level.WARNING, \"\", e);\r\n            _logger.log(Level.WARNING, \"jts.after_recovery_excep\", e);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContextFacade.doPrivileged",
	"Comment": "use reflection to invoke the requested method. cache the method object to speed up the process",
	"Method": "Object doPrivileged(String methodName,Object[] params,Object doPrivileged,String methodName,Class<?>[] clazz,Object[] params){\r\n    try {\r\n        Method method = context.getClass().getMethod(methodName, clazz);\r\n        return executeMethod(method, context, params);\r\n    } catch (Exception ex) {\r\n        try {\r\n            handleException(ex, methodName);\r\n        } catch (Throwable t) {\r\n            throw new RuntimeException(t.getMessage());\r\n        }\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.api.ParamDefaultCalculator.defaultValue",
	"Comment": "this method is called if the user has notprovided a value for it via the client. this object is given a chance to determine the default value for parameter. this method may return null if no default value can be computed.",
	"Method": "String defaultValue(ExecutionContext context){\r\n    return null;\r\n}"
}, {
	"Path": "org.apache.naming.resources.ProxyDirContext.listBindings",
	"Comment": "enumerates the names bound in the named context, along with the objects bound to them.",
	"Method": "NamingEnumeration<Binding> listBindings(Name name,NamingEnumeration<Binding> listBindings,String name){\r\n    return dirContext.listBindings(parseName(name));\r\n}"
}, {
	"Path": "components.components.ScrollerComponent.writeNavWidgetMarkup",
	"Comment": "write the markup to render a navigation widget.override this toreplace the default navigation widget of link with somethingelse.",
	"Method": "void writeNavWidgetMarkup(FacesContext context,String clientId,int navActionType,boolean enabled){\r\n    ResponseWriter writer = context.getResponseWriter();\r\n    String facetOrientation = NORTH;\r\n    String facetName = null;\r\n    String linkText = null;\r\n    String localLinkText = null;\r\n    UIComponent facet = null;\r\n    boolean isCurrentPage = false;\r\n    boolean isPageNumber = false;\r\n    switch(navActionType) {\r\n        case ACTION_NEXT:\r\n            facetName = \"next\";\r\n            linkText = \"Next\";\r\n            break;\r\n        case ACTION_PREVIOUS:\r\n            facetName = \"previous\";\r\n            linkText = \"Previous\";\r\n            break;\r\n        default:\r\n            facetName = \"number\";\r\n            linkText = \"\" + navActionType;\r\n            isPageNumber = true;\r\n            if (!enabled) {\r\n                facetName = \"current\";\r\n                isCurrentPage = true;\r\n            }\r\n            break;\r\n    }\r\n    writer.write(\"\\n&nbsp;\");\r\n    if (enabled) {\r\n        writer.write(\"<a \" + getAnchorAttrs(context, clientId, navActionType) + \">\");\r\n    }\r\n    facet = getFacet(facetName);\r\n    if (facet != null) {\r\n        if (isPageNumber) {\r\n            String facetO = (String) getAttributes().get(FACET_MARKUP_ORIENTATION_ATTR);\r\n            if (facet != null) {\r\n                facetOrientation = facetO;\r\n                if (!(facetOrientation.equalsIgnoreCase(NORTH) || facetOrientation.equalsIgnoreCase(SOUTH) || facetOrientation.equalsIgnoreCase(EAST) || facetOrientation.equalsIgnoreCase(WEST))) {\r\n                    facetOrientation = NORTH;\r\n                }\r\n            }\r\n        }\r\n        if (facetOrientation.equalsIgnoreCase(NORTH) || facetOrientation.equalsIgnoreCase(EAST)) {\r\n            facet.encodeBegin(context);\r\n            if (facet.getRendersChildren()) {\r\n                facet.encodeChildren(context);\r\n            }\r\n            facet.encodeEnd(context);\r\n        }\r\n        if (facetOrientation.equalsIgnoreCase(NORTH)) {\r\n            writer.startElement(\"br\", null);\r\n            writer.endElement(\"br\");\r\n        }\r\n    }\r\n    if (null != facet) {\r\n        if (navActionType != ACTION_NEXT && navActionType != ACTION_PREVIOUS) {\r\n            writer.write(linkText);\r\n        }\r\n    } else {\r\n        writer.write(linkText);\r\n    }\r\n    if (null != facet) {\r\n        if (facetOrientation.equalsIgnoreCase(SOUTH)) {\r\n            writer.startElement(\"br\", null);\r\n            writer.endElement(\"br\");\r\n        }\r\n        if (facetOrientation.equalsIgnoreCase(SOUTH) || facetOrientation.equalsIgnoreCase(WEST)) {\r\n            facet.encodeBegin(context);\r\n            if (facet.getRendersChildren()) {\r\n                facet.encodeChildren(context);\r\n            }\r\n            facet.encodeEnd(context);\r\n        }\r\n    }\r\n    if (enabled) {\r\n        writer.write(\"<\/a>\");\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.MultimodeCommand.validate",
	"Comment": "the validate method validates that the type and quantity of parametersand operands matches the requirements for this command. the validatemethod supplies missing options from the environment.",
	"Method": "void validate(){\r\n    if (printPromptOpt != null)\r\n        printPrompt = printPromptOpt.booleanValue();\r\n    else\r\n        printPrompt = programOpts.isInteractive();\r\n    echo = programOpts.isEcho();\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.getServletPath",
	"Comment": "return the portion of the request uri used to select the servletthat will process this request.",
	"Method": "String getServletPath(){\r\n    return servletPath;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.MasterPasswordFileManager.readMasterPasswordFile",
	"Comment": "return the master password stored in the master password keystore.",
	"Method": "String readMasterPasswordFile(RepositoryConfig config){\r\n    final PEFileLayout layout = getFileLayout(config);\r\n    final File pwdFile = layout.getMasterPasswordFile();\r\n    if (pwdFile.exists()) {\r\n        try {\r\n            PasswordAdapter p = new PasswordAdapter(pwdFile.getAbsolutePath(), getMasterPasswordPassword());\r\n            return p.getPasswordForAlias(MASTER_PASSWORD_ALIAS);\r\n        } catch (Exception ex) {\r\n            throw new RepositoryException(_strMgr.getString(\"masterPasswordFileNotRead\", pwdFile), ex);\r\n        }\r\n    } else {\r\n        return null;\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityCollection.removeMethodOmission",
	"Comment": "remove the specified http request method omission from those that are partof this web resource collection.",
	"Method": "void removeMethodOmission(String methodOmission){\r\n    if (methodOmission == null)\r\n        return;\r\n    int n = -1;\r\n    for (int i = 0; i < methodOmissions.length; i++) {\r\n        if (methodOmissions[i].equals(methodOmission)) {\r\n            n = i;\r\n            break;\r\n        }\r\n    }\r\n    if (n >= 0) {\r\n        int j = 0;\r\n        String[] results = new String[methodOmissions.length - 1];\r\n        for (int i = 0; i < methodOmissions.length; i++) {\r\n            if (i != n)\r\n                results[j++] = methodOmissions[i];\r\n        }\r\n        methodOmissions = results;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.CreateNetworkListener.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    Target targetUtil = services.getService(Target.class);\r\n    Config newConfig = targetUtil.getConfig(target);\r\n    if (newConfig != null) {\r\n        config = newConfig;\r\n    }\r\n    final ActionReport report = context.getActionReport();\r\n    NetworkConfig networkConfig = config.getNetworkConfig();\r\n    NetworkListeners nls = networkConfig.getNetworkListeners();\r\n    for (NetworkListener networkListener : nls.getNetworkListener()) {\r\n        if (networkListener.getName().equals(listenerName)) {\r\n            report.setMessage(MessageFormat.format(rb.getString(LogFacade.CREATE_NETWORK_LISTENER_FAIL_DUPLICATE), listenerName));\r\n            report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n            return;\r\n        }\r\n    }\r\n    if (!verifyUniquePort(networkConfig)) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.PORT_IN_USE), port, address));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    Protocol prot = networkConfig.findProtocol(protocol);\r\n    if (prot == null) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.CREATE_HTTP_FAIL_PROTOCOL_NOT_FOUND), protocol));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    if (prot.getHttp() == null && prot.getPortUnification() == null) {\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.CREATE_NETWORK_LISTENER_FAIL_BAD_PROTOCOL), protocol));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        ConfigSupport.apply(new ConfigCode() {\r\n            public Object run(ConfigBeanProxy... params) throws TransactionFailure, PropertyVetoException {\r\n                NetworkListeners listeners = (NetworkListeners) params[0];\r\n                NetworkListener newNetworkListener = listeners.createChild(NetworkListener.class);\r\n                newNetworkListener.setProtocol(protocol);\r\n                newNetworkListener.setTransport(transport);\r\n                newNetworkListener.setEnabled(enabled.toString());\r\n                newNetworkListener.setJkEnabled(jkEnabled.toString());\r\n                newNetworkListener.setPort(port);\r\n                newNetworkListener.setThreadPool(threadPool);\r\n                newNetworkListener.setName(listenerName);\r\n                newNetworkListener.setAddress(address);\r\n                listeners.getNetworkListener().add(newNetworkListener);\r\n                ((VirtualServer) params[1]).addNetworkListener(listenerName);\r\n                return newNetworkListener;\r\n            }\r\n        }, nls, findVirtualServer(prot));\r\n    } catch (TransactionFailure e) {\r\n        e.printStackTrace();\r\n        report.setMessage(MessageFormat.format(rb.getString(LogFacade.CREATE_NETWORK_LISTENER_FAIL), listenerName) + (e.getMessage() == null ? \"No reason given\" : e.getMessage()));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(e);\r\n        return;\r\n    }\r\n    report.setActionExitCode(ActionReport.ExitCode.SUCCESS);\r\n}"
}, {
	"Path": "org.glassfish.web.admin.cli.CreateNetworkListener.execute",
	"Comment": "executes the command with the command parameters passed as properties where the keys are the paramter names andthe values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    NetworkListeners listeners = (NetworkListeners) params[0];\r\n    NetworkListener newNetworkListener = listeners.createChild(NetworkListener.class);\r\n    newNetworkListener.setProtocol(protocol);\r\n    newNetworkListener.setTransport(transport);\r\n    newNetworkListener.setEnabled(enabled.toString());\r\n    newNetworkListener.setJkEnabled(jkEnabled.toString());\r\n    newNetworkListener.setPort(port);\r\n    newNetworkListener.setThreadPool(threadPool);\r\n    newNetworkListener.setName(listenerName);\r\n    newNetworkListener.setAddress(address);\r\n    listeners.getNetworkListener().add(newNetworkListener);\r\n    ((VirtualServer) params[1]).addNetworkListener(listenerName);\r\n    return newNetworkListener;\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.DeferredFileOutputStream.writeTo",
	"Comment": "writes the data from this output stream to the specified output stream,after it has been closed.",
	"Method": "void writeTo(OutputStream out){\r\n    if (!closed) {\r\n        throw new IOException(\"Stream not closed\");\r\n    }\r\n    if (isInMemory()) {\r\n        memoryOutputStream.writeTo(out);\r\n    } else {\r\n        FileInputStream fis = new FileInputStream(outputFile);\r\n        Streams.copy(fis, out, false);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.webservices.connector.WebServicesSniffer.supportsArchiveType",
	"Comment": "this api is used to help determine if the sniffer should recognizethe current archive.if the sniffer does not support the archive type associated withthe current deployment, the sniffer should not recognize the archive.",
	"Method": "boolean supportsArchiveType(ArchiveType archiveType){\r\n    if (archiveType.toString().equals(ModuleType.WAR.toString()) || archiveType.toString().equals(ModuleType.EJB.toString())) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.AuthMechType.check",
	"Comment": "all authorization mechanism type should be of an allowed type",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    boolean oneFailed = false;\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (!descriptor.getOutBoundDefined()) {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.managed.notApplicableForInboundRA\", \"Resource Adapter does not provide outbound communication\"));\r\n        return result;\r\n    }\r\n    Set mechanisms = descriptor.getOutboundResourceAdapter().getAuthMechanisms();\r\n    if (mechanisms.isEmpty()) {\r\n        result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.passed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.AuthMechType.nonexist\", \"No authentication mechanism defined for this resource adapater\"));\r\n        return result;\r\n    }\r\n    Iterator mechIterator = mechanisms.iterator();\r\n    while (mechIterator.hasNext()) {\r\n        AuthMechanism am = (AuthMechanism) mechIterator.next();\r\n        String authMechType = am.getAuthMechType();\r\n        boolean allowedMech = false;\r\n        if (authMechType != null) {\r\n            for (int i = 0; i < allowedMechs.length; i++) {\r\n                if (authMechType.equals(allowedMechs[i])) {\r\n                    allowedMech = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        if (!allowedMech || authMechType == null) {\r\n            oneFailed = true;\r\n            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.failed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.AuthMechType.failed\", \"Authentication mechanism type [ {0} ] is not allowed\"));\r\n        }\r\n    }\r\n    if (!oneFailed) {\r\n        result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.passed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.AuthMechType.passed\", \"All defined authentication mechanism types are allowed\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getFilterRegistration",
	"Comment": "gets the filterregistration corresponding to the filter with thegiven filtername.",
	"Method": "FilterRegistration getFilterRegistration(String filterName){\r\n    if (isRestricted) {\r\n        throw new UnsupportedOperationException(rb.getString(LogFacade.UNSUPPORTED_OPERATION_EXCEPTION));\r\n    }\r\n    return context.getFilterRegistration(filterName);\r\n}"
}, {
	"Path": "org.apache.naming.NamingContext.listBindings",
	"Comment": "enumerates the names bound in the named context, along with the objects bound to them.",
	"Method": "NamingEnumeration<Binding> listBindings(Name name,NamingEnumeration<Binding> listBindings,String name){\r\n    return listBindings(new CompositeName(name));\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorLogPool.getCoordinatorLog",
	"Comment": "get a coordinatorlog object from the cache. instantiate anew coordinatorlog object if the cache is empty.",
	"Method": "CoordinatorLog getCoordinatorLog(CoordinatorLog getCoordinatorLog,String logPath){\r\n    CoordinatorLogPool clpool = (CoordinatorLogPool) CLPooltable.get(logPath);\r\n    if (clpool == null) {\r\n        clpool = new CoordinatorLogPool();\r\n        CLPooltable.put(logPath, clpool);\r\n    }\r\n    if (clpool.pool.empty()) {\r\n        return new CoordinatorLog(logPath);\r\n    } else {\r\n        return (CoordinatorLog) clpool.pool.pop();\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.pkmultiplefield.PrimaryKeyClassConstructor.check",
	"Comment": "enterprise java bean primary key class constuctor test.the primary key class must have a public constructor that takes no parameters.",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (descriptor instanceof EjbEntityDescriptor) {\r\n        String persistence = ((EjbEntityDescriptor) descriptor).getPersistenceType();\r\n        if (EjbEntityDescriptor.CONTAINER_PERSISTENCE.equals(persistence)) {\r\n            try {\r\n                FieldDescriptor fd = ((EjbCMPEntityDescriptor) descriptor).getPrimaryKeyFieldDesc();\r\n                if (fd != null) {\r\n                    String pkf = fd.getName();\r\n                    if (pkf.length() > 0) {\r\n                        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable2\", \"Entity Bean [ {0} ] with primekey-field non-blank, test not applicable.\", new Object[] { descriptor.getEjbClassName() }));\r\n                    }\r\n                } else {\r\n                    try {\r\n                        VerifierTestContext context = getVerifierContext();\r\n                        ClassLoader jcl = context.getClassLoader();\r\n                        Class c = Class.forName(((EjbEntityDescriptor) descriptor).getPrimaryKeyClassName(), false, getVerifierContext().getClassLoader());\r\n                        boolean foundOne = false;\r\n                        Constructor[] constructors = c.getConstructors();\r\n                        for (int i = 0; i < constructors.length; i++) {\r\n                            int modifiers = constructors[i].getModifiers();\r\n                            if (Modifier.isPublic(modifiers)) {\r\n                                Class[] constructorParameterTypes;\r\n                                constructorParameterTypes = constructors[i].getParameterTypes();\r\n                                if (constructorParameterTypes.length > 0) {\r\n                                    continue;\r\n                                } else {\r\n                                    foundOne = true;\r\n                                    break;\r\n                                }\r\n                            }\r\n                        }\r\n                        if (foundOne) {\r\n                            result.addGoodDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                            result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"This primary key class [ {0} ] has a public constructor method with no parameters.\", new Object[] { ((EjbEntityDescriptor) descriptor).getPrimaryKeyClassName() }));\r\n                        } else {\r\n                            result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                            result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: A public constructor method with no parameters was not found in the primary key class [ {0} ].\", new Object[] { ((EjbEntityDescriptor) descriptor).getPrimaryKeyClassName() }));\r\n                        }\r\n                    } catch (ClassNotFoundException e) {\r\n                        Verifier.debug(e);\r\n                        result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                        result.failed(smh.getLocalString(getClass().getName() + \".failedException\", \"Error: [ {0} ] class not found.\", new Object[] { ((EjbEntityDescriptor) descriptor).getPrimaryKeyClassName() }));\r\n                    }\r\n                }\r\n            } catch (NullPointerException e) {\r\n                result.addErrorDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n                result.failed(smh.getLocalString(getClass().getName() + \".failedException2\", \"Error: Primkey field not defined within [ {0} ] bean.\", new Object[] { descriptor.getName() }));\r\n            }\r\n            return result;\r\n        } else {\r\n            result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n            result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable1\", \"Expected [ {0} ] managed persistence, but [ {1} ] bean has [ {2} ] managed persistence.\", new Object[] { EjbEntityDescriptor.CONTAINER_PERSISTENCE, descriptor.getName(), persistence }));\r\n            return result;\r\n        }\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"{0} expected {1} bean, but called with {2}.\", new Object[] { getClass(), \"Entity\", \"Session\" }));\r\n        return result;\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.CallMethodRule.getUseExactMatch",
	"Comment": "should methodutils.invokeexactmethodbe used for the reflection.",
	"Method": "boolean getUseExactMatch(){\r\n    return useExactMatch;\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.JavaEETransactionManagerSimplified.getXATerminator",
	"Comment": "this is used by importing transactions via the connector contract.should not be called",
	"Method": "XATerminator getXATerminator(){\r\n    return getDelegate().getXATerminator();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.hashCode",
	"Comment": "returns a hash code for the object.this very basic method is used by the trace facility andshould not call any method which is traced.",
	"Method": "int hashCode(){\r\n    if (hash == 0 && superInfo != null && superInfo.globalTID != null) {\r\n        hash = superInfo.globalTID.hashCode();\r\n    }\r\n    return hash;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.getStaticResources",
	"Comment": "return the naming resources associated with this web application.",
	"Method": "DirContext getStaticResources(){\r\n    return getResources();\r\n}"
}, {
	"Path": "org.glassfish.embeddable.web.config.SecurityConfig.setLoginConfig",
	"Comment": "configures the login related configuration for the context",
	"Method": "void setLoginConfig(LoginConfig lc){\r\n    this.lc = lc;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.getMaxProcessors",
	"Comment": "return the maximum number of processors allowed, or 0 for unlimited.",
	"Method": "int getMaxProcessors(){\r\n    return maxProcessors;\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.getCreationTime",
	"Comment": "return the time when this session was created, in milliseconds sincemidnight, january 1, 1970 gmt.",
	"Method": "long getCreationTime(){\r\n    if (!isValid())\r\n        throw new IllegalStateException(\"getCreationTime: \" + rb.getString(LogFacade.SESSION_INVALIDATED_EXCEPTION));\r\n    return (this.creationTime);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogHandle.openExtent",
	"Comment": "opens the given extent.this internal method does not need to be synchronized.",
	"Method": "LogExtent openExtent(int extent){\r\n    File extentFile = logControl.extentFile(logFileName, LogExtent.modExtent(extent));\r\n    int openOptions = LogFileHandle.OPEN_RDWR | LogFileHandle.OPEN_CREAT;\r\n    if (logControl.logReadOnly)\r\n        openOptions = LogFileHandle.OPEN_RDONLY;\r\n    LogFileHandle extentFH = new LogFileHandle(extentFile, openOptions);\r\n    LogExtent logEDP = new LogExtent(extent, extentFH, extentFile);\r\n    extentTable.put(extent, logEDP);\r\n    logEDP.blockValid = logEDP;\r\n    return logEDP;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.SessionTracker.track",
	"Comment": "tracks the given session, by registering this sessiontracker as alistener with the given session, and by incrementing the counter ofcurrently tracked sessions.",
	"Method": "void track(Session session){\r\n    if (trackedSessionId == null) {\r\n        trackedSessionId = session.getIdInternal();\r\n    } else if (!trackedSessionId.equals(session.getIdInternal())) {\r\n        throw new IllegalArgumentException(\"Should never reach here\");\r\n    }\r\n    count++;\r\n    if (session.getManager() != null && session.getManager().getContainer() != null && session.getManager().getContainer().getName() != null) {\r\n        contextNames.add(session.getManager().getContainer().getName());\r\n    }\r\n    session.addSessionListener(this);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.cli.LocalServerCommand.getAdminAddress",
	"Comment": "returns the admin address of a particular server. note that this methodshould be called only when you own the server that is available onan accessible file system.",
	"Method": "HostAndPort getAdminAddress(HostAndPort getAdminAddress,String serverName){\r\n    try {\r\n        MiniXmlParser parser = new MiniXmlParser(getDomainXml(), serverName);\r\n        List<HostAndPort> addrSet = parser.getAdminAddresses();\r\n        if (addrSet.size() > 0)\r\n            return addrSet.get(0);\r\n        else\r\n            throw new CommandException(strings.get(\"NoAdminPort\"));\r\n    } catch (MiniXmlParserException ex) {\r\n        throw new CommandException(strings.get(\"NoAdminPortEx\", ex), ex);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHostDeployer.addChild",
	"Comment": "delegate a request to add a child context to our associated host.",
	"Method": "void addChild(Container child){\r\n    Context context = null;\r\n    String contextPath = null;\r\n    if (child instanceof Context) {\r\n        context = (Context) child;\r\n        contextPath = context.getPath();\r\n    }\r\n    if (contextPath == null)\r\n        throw new IllegalArgumentException(rb.getString(LogFacade.CONTEXT_PATH_REQUIRED_EXCEPTION));\r\n    else if (!contextPath.equals(\"\") && !contextPath.startsWith(\"/\")) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.INVALID_CONTEXT_PATH_EXCEPTION), contextPath);\r\n        throw new IllegalArgumentException(msg);\r\n    }\r\n    if (host.findChild(contextPath) != null) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.CONTEXT_PATH_ALREADY_USED_EXCEPTION), contextPath);\r\n        throw new IllegalStateException(msg);\r\n    }\r\n    if (this.overrideDocBase != null)\r\n        context.setDocBase(this.overrideDocBase);\r\n    if (this.overrideConfigFile != null)\r\n        context.setConfigFile(this.overrideConfigFile);\r\n    host.fireContainerEvent(PRE_INSTALL_EVENT, context);\r\n    host.addChild(child);\r\n    host.fireContainerEvent(INSTALL_EVENT, context);\r\n}"
}, {
	"Path": "org.glassfish.deployment.versioning.VersioningService.getEnabledVersionsInReferencedTargets",
	"Comment": "search the enabled versions on the referenced targets of the given version.this method is designed to be used with domain target. as differentversions maybe enabled on different targets, the return type used is a map.",
	"Method": "Map<String, Set<String>> getEnabledVersionsInReferencedTargets(String versionIdentifier){\r\n    Map<String, Set<String>> enabledVersionsInTargets = new HashMap<String, Set<String>>();\r\n    List<String> allTargets = domain.getAllReferencedTargetsForApplication(versionIdentifier);\r\n    Iterator it = allTargets.iterator();\r\n    while (it.hasNext()) {\r\n        String target = (String) it.next();\r\n        String enabledVersion = getEnabledVersion(versionIdentifier, target);\r\n        if (enabledVersion != null) {\r\n            if (enabledVersionsInTargets.containsKey(enabledVersion)) {\r\n                enabledVersionsInTargets.get(enabledVersion).add(target);\r\n            } else {\r\n                Set<String> setTargets = new HashSet<String>();\r\n                setTargets.add(target);\r\n                enabledVersionsInTargets.put(enabledVersion, setTargets);\r\n            }\r\n        }\r\n    }\r\n    return enabledVersionsInTargets;\r\n}"
}, {
	"Path": "org.apache.naming.resources.BaseDirContext.listBindings",
	"Comment": "enumerates the names bound in the named context, along with the objects bound to them.",
	"Method": "NamingEnumeration<Binding> listBindings(Name name,NamingEnumeration<Binding> listBindings,String name){\r\n    return listBindings(name.toString());\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.AdminUtil.stopSampling",
	"Comment": "stopsamplingstop sampling the statitics values. this is used to indicate end of sampling window.",
	"Method": "void stopSampling(){\r\n    try {\r\n        statisticsLock.acquireWriteLock();\r\n        lSampleEndTime = System.currentTimeMillis();\r\n        bSampling = false;\r\n    } finally {\r\n        statisticsLock.releaseWriteLock();\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.AdminUtil.incrementRecoveryCommitedTransactionCount",
	"Comment": "increments the number of transactions that were commited as part ofthe recovery process.",
	"Method": "void incrementRecoveryCommitedTransactionCount(){\r\n    try {\r\n        statisticsLock.acquireReadLock();\r\n        synchronized (lkRecCommits) {\r\n            iRecCommits++;\r\n        }\r\n    } finally {\r\n        statisticsLock.releaseReadLock();\r\n    }\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Rule.finish",
	"Comment": "this method is called after all parsing methods have beencalled, to allow rules to remove temporary data.",
	"Method": "void finish(){\r\n    ;\r\n}"
}, {
	"Path": "com.sun.appserv.management.sample.Samples.demoJMXMonitor",
	"Comment": "demonstrates the use of a javax.management.monitor mbean\t\tto be notified of changes in the value of an attribute.",
	"Method": "void demoJMXMonitor(){\r\n    final JMXMonitorMgr mgr = getDomainRoot().getJMXMonitorMgr();\r\n    final String attrName = \"SampleString\";\r\n    final String attrValue = \"hello\";\r\n    final SampleListener sampleListener = new SampleListener();\r\n    final MBeanServerConnection conn = Util.getExtra(mgr).getConnectionSource().getExistingMBeanServerConnection();\r\n    conn.addNotificationListener(getMBeanServerDelegateObjectName(), sampleListener, null, null);\r\n    final Sample sample = (Sample) getDomainRoot().getContainee(XTypes.SAMPLE);\r\n    final String monitorName = \"SampleStringMonitor\";\r\n    AMXStringMonitor mon = null;\r\n    try {\r\n        try {\r\n            mgr.remove(monitorName);\r\n        } catch (Exception e) {\r\n        }\r\n        mon = mgr.createStringMonitor(monitorName);\r\n        waitMBeanServerNotification(sampleListener, MBeanServerNotification.REGISTRATION_NOTIFICATION, Util.getObjectName(mon));\r\n        sample.addAttribute(attrName, attrValue);\r\n        mon.addNotificationListener(sampleListener, null, null);\r\n        mon.setObservedAttribute(attrName);\r\n        mon.setStringToCompare(attrValue);\r\n        mon.setNotifyDiffer(true);\r\n        mon.setNotifyMatch(true);\r\n        mon.addObservedObject(Util.getObjectName(sample));\r\n        final StdAttributesAccess attrs = Util.getExtra(sample);\r\n        attrs.setAttribute(new Attribute(attrName, \"goodbye\"));\r\n        attrs.setAttribute(new Attribute(attrName, attrValue));\r\n        sample.removeAttribute(attrName);\r\n        final Map notifs = sampleListener.getNotifsReceived();\r\n        waitNumNotifs(notifs, AttributeChangeNotification.ATTRIBUTE_CHANGE, 4);\r\n    } catch (Throwable t) {\r\n        t.printStackTrace();\r\n    } finally {\r\n        try {\r\n            mon.removeNotificationListener(sampleListener);\r\n            if (mon != null) {\r\n                mgr.remove(mon.getName());\r\n                waitMBeanServerNotification(sampleListener, MBeanServerNotification.UNREGISTRATION_NOTIFICATION, Util.getObjectName(mon));\r\n            }\r\n            conn.removeNotificationListener(getMBeanServerDelegateObjectName(), sampleListener);\r\n        } catch (ListenerNotFoundException e) {\r\n        }\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentTransaction.registerStatic",
	"Comment": "registers the given staticresource object.the staticresource object will be informed whenever any association ofa transaction with a thread is started or ended.",
	"Method": "void registerStatic(StaticResource obj){\r\n    if (statics == null)\r\n        statics = new RegisteredStatics();\r\n    statics.addStatic(obj);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.contextListenerStop",
	"Comment": "notifies all servletcontextlisteners at their contextdestroyedmethod.",
	"Method": "boolean contextListenerStop(){\r\n    boolean ok = true;\r\n    if (contextListeners.isEmpty()) {\r\n        return ok;\r\n    }\r\n    ServletContextEvent event = new ServletContextEvent(getServletContext());\r\n    int len = contextListeners.size();\r\n    for (int i = 0; i < len; i++) {\r\n        ServletContextListener listener = contextListeners.get((len - 1) - i);\r\n        if (listener instanceof RestrictedServletContextListener) {\r\n            listener = ((RestrictedServletContextListener) listener).getNestedListener();\r\n            context.setRestricted(true);\r\n        }\r\n        try {\r\n            fireContainerEvent(ContainerEvent.BEFORE_CONTEXT_DESTROYED, listener);\r\n            listener.contextDestroyed(event);\r\n            fireContainerEvent(ContainerEvent.AFTER_CONTEXT_DESTROYED, listener);\r\n        } catch (Throwable t) {\r\n            context.setRestricted(false);\r\n            fireContainerEvent(ContainerEvent.AFTER_CONTEXT_DESTROYED, listener);\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.LISTENER_STOP_EXCEPTION), listener.getClass().getName());\r\n            getServletContext().log(msg, t);\r\n            ok = false;\r\n        }\r\n    }\r\n    contextListeners.clear();\r\n    return ok;\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ExtendedAccessLogValve.log",
	"Comment": "log the specified message to the log file, switching files if the datehas changed since the previous log call.",
	"Method": "void log(String message,Date date){\r\n    if (rotatable) {\r\n        long systime = System.currentTimeMillis();\r\n        if ((systime - rotationLastChecked) > 1000) {\r\n            currentDate = new Date(systime);\r\n            rotationLastChecked = systime;\r\n            String tsDate = fileDateFormatter.get().format(currentDate);\r\n            if (!dateStamp.equals(tsDate)) {\r\n                synchronized (this) {\r\n                    if (!dateStamp.equals(tsDate)) {\r\n                        close();\r\n                        dateStamp = tsDate;\r\n                        open();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    if (checkExists) {\r\n        synchronized (this) {\r\n            if (currentLogFile != null && !currentLogFile.exists()) {\r\n                try {\r\n                    close();\r\n                } catch (Throwable e) {\r\n                    log.log(Level.INFO, LogFacade.NOT_SWALLOWED_INFO, e);\r\n                }\r\n                currentDate = new Date(System.currentTimeMillis());\r\n                fileDateFormatter = new ThreadLocal<SimpleDateFormat>() {\r\n                    @Override\r\n                    protected SimpleDateFormat initialValue() {\r\n                        return new SimpleDateFormat(\"yyyy-MM-dd\");\r\n                    }\r\n                };\r\n                dateStamp = dateFormatter.get().format(currentDate);\r\n                open();\r\n            }\r\n        }\r\n    }\r\n    if (writer != null) {\r\n        writer.println(message);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ExtendedAccessLogValve.log",
	"Comment": "log the specified message to the log file, switching files if the datehas changed since the previous log call.",
	"Method": "void log(String message,Date date){\r\n    return new SimpleDateFormat(\"yyyy-MM-dd\");\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.setSchemaLanguage",
	"Comment": "set the xml schema language used when parsing. by default, we use w3c.",
	"Method": "void setSchemaLanguage(String schemaLanguage){\r\n    this.schemaLanguage = schemaLanguage;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.entity.CMPFieldExistence.check",
	"Comment": "any cmp entity bean should have at least one cmp field defined in the dds",
	"Method": "Result check(EjbDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    if (descriptor instanceof EjbEntityDescriptor) {\r\n        String persistentType = ((EjbEntityDescriptor) descriptor).getPersistenceType();\r\n        if (EjbEntityDescriptor.CONTAINER_PERSISTENCE.equals(persistentType)) {\r\n            EjbCMPEntityDescriptor cmpDesc = (EjbCMPEntityDescriptor) descriptor;\r\n            PersistenceDescriptor persDesc = cmpDesc.getPersistenceDescriptor();\r\n            if (persDesc.getCMPFields().size() == 0) {\r\n                result.failed(smh.getLocalString(getClass().getName() + \"failed\", \"For CMP entity bean [ {0} ], no cmp field are defined\", new Object[] { descriptor.getName() }));\r\n            } else {\r\n                result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"For CMP entity bean [ {0} ], some cmp fields are defined\", new Object[] { descriptor.getName() }));\r\n            }\r\n            return result;\r\n        }\r\n    }\r\n    result.notApplicable(smh.getLocalString(getClass().getName() + \".notApplicable\", \"The EJB [ {0} ] is not an CMP entity bean\", new Object[] { descriptor.getName() }));\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.connector.coyote.PECoyoteConnector.configureSSL",
	"Comment": "configures the ssl properties on this pecoyoteconnector from thessl config of the given http listener.",
	"Method": "void configureSSL(NetworkListener listener){\r\n    Ssl sslConfig = listener.findHttpProtocol().getSsl();\r\n    if (sslConfig == null) {\r\n        return;\r\n    }\r\n    if (Boolean.valueOf(sslConfig.getClientAuthEnabled())) {\r\n        setClientAuth(true);\r\n    }\r\n    StringBuilder sslProtocolsBuf = new StringBuilder();\r\n    boolean needComma = false;\r\n    if (Boolean.valueOf(sslConfig.getSsl2Enabled())) {\r\n        sslProtocolsBuf.append(\"SSLv2\");\r\n        needComma = true;\r\n    }\r\n    if (Boolean.valueOf(sslConfig.getSsl3Enabled())) {\r\n        if (needComma) {\r\n            sslProtocolsBuf.append(\", \");\r\n        } else {\r\n            needComma = true;\r\n        }\r\n        sslProtocolsBuf.append(\"SSLv3\");\r\n    }\r\n    if (Boolean.valueOf(sslConfig.getTlsEnabled())) {\r\n        if (needComma) {\r\n            sslProtocolsBuf.append(\", \");\r\n        } else {\r\n            needComma = true;\r\n        }\r\n        sslProtocolsBuf.append(\"TLSv1\");\r\n    }\r\n    if (Boolean.valueOf(sslConfig.getTls11Enabled())) {\r\n        if (needComma) {\r\n            sslProtocolsBuf.append(\", \");\r\n        } else {\r\n            needComma = true;\r\n        }\r\n        sslProtocolsBuf.append(\"TLSv1.1\");\r\n    }\r\n    if (Boolean.valueOf(sslConfig.getTls12Enabled())) {\r\n        if (needComma) {\r\n            sslProtocolsBuf.append(\", \");\r\n        }\r\n        sslProtocolsBuf.append(\"TLSv1.2\");\r\n    }\r\n    if (Boolean.valueOf(sslConfig.getSsl3Enabled()) || Boolean.valueOf(sslConfig.getTlsEnabled())) {\r\n        sslProtocolsBuf.append(\", SSLv2Hello\");\r\n    }\r\n    if (sslProtocolsBuf.length() == 0) {\r\n        _logger.log(Level.WARNING, LogFacade.ALL_SSL_PROTOCOLS_DISABLED, listener.getName());\r\n    } else {\r\n        setSslProtocols(sslProtocolsBuf.toString());\r\n    }\r\n    String certNickname = sslConfig.getCertNickname();\r\n    if (certNickname != null && certNickname.length() > 0) {\r\n        setKeyAlias(sslConfig.getCertNickname());\r\n    }\r\n    String ciphers = sslConfig.getSsl3TlsCiphers();\r\n    if (ciphers != null) {\r\n        String jsseCiphers = getJSSECiphers(ciphers);\r\n        if (jsseCiphers == null) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, LogFacade.ALL_CIPHERS_DISABLED, listener.getName());\r\n            }\r\n        } else {\r\n            setCiphers(jsseCiphers);\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setOverride",
	"Comment": "set the defaultcontext override flag for this web application.",
	"Method": "void setOverride(boolean override){\r\n    boolean oldOverride = this.override;\r\n    this.override = override;\r\n    support.firePropertyChange(\"override\", Boolean.valueOf(oldOverride), Boolean.valueOf(this.override));\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CoordinatorLog.getObjects",
	"Comment": "returns a sequence containing all of the objects in the given section.",
	"Method": "java.lang.Object[] getObjects(java.lang.Object sectionObj){\r\n    java.lang.Object[] result = null;\r\n    if (sectionObj != null) {\r\n        CoordinatorLogSection section = (CoordinatorLogSection) sectionObj;\r\n        int unwrittenSize = 0;\r\n        if (section.unwrittenObjects != null)\r\n            unwrittenSize = section.unwrittenObjects.size();\r\n        int writtenSize = 0;\r\n        if (section.writtenObjects != null)\r\n            writtenSize = section.writtenObjects.size();\r\n        result = new java.lang.Object[unwrittenSize + writtenSize];\r\n        int currObject = 0;\r\n        ORB orb = Configuration.getORB();\r\n        for (int i = 0; i < writtenSize; i++) {\r\n            org.omg.CORBA.Object obj = null;\r\n            String refStr = (String) section.writtenObjects.elementAt(i);\r\n            int retries = STRING_TO_REF_RETRIES;\r\n            boolean discard = false;\r\n            while (obj == null && retries-- > 0 && !discard) {\r\n                try {\r\n                    obj = orb.string_to_object(refStr);\r\n                } catch (MARSHAL exc) {\r\n                    try {\r\n                        Thread.sleep(2000);\r\n                    } catch (InterruptedException ex2) {\r\n                        _logger.log(Level.WARNING, \"jts.wait_for_resync_complete_interrupted\");\r\n                        String msg = LogFormatter.getLocalizedMessage(_logger, \"jts.wait_for_resync_complete_interrupted\");\r\n                        throw new org.omg.CORBA.INTERNAL(msg);\r\n                    }\r\n                } catch (Throwable exc) {\r\n                    discard = true;\r\n                }\r\n            }\r\n            if (!discard) {\r\n                if (obj != null) {\r\n                    result[currObject++] = obj;\r\n                } else {\r\n                    _logger.log(Level.SEVERE, \"jts.unable_to_convert_object_reference_to_string_in_recovery\");\r\n                    String msg = LogFormatter.getLocalizedMessage(_logger, \"jts.unable_to_convert_object_reference_to_string_in_recovery\");\r\n                    throw new org.omg.CORBA.INTERNAL(msg);\r\n                }\r\n            }\r\n        }\r\n        for (int i = 0; i < unwrittenSize; i++) {\r\n            try {\r\n                org.omg.CORBA.Object obj = orb.string_to_object((String) section.unwrittenObjects.elementAt(i));\r\n                result[currObject++] = obj;\r\n            } catch (Throwable exc) {\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.getWebListeners",
	"Comment": "gets the collection of weblistener instances from whichthis virtualserver receives requests.",
	"Method": "Collection<WebListener> getWebListeners(){\r\n    return listeners;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.PEAccessLogValve.stop",
	"Comment": "gracefully terminate the active use of the public methods of thiscomponent.this method should be the last one called on a giveninstance of this component.",
	"Method": "void stop(){\r\n    if (!started) {\r\n        throw new LifecycleException(_rb.getString(LogFacade.ACCESS_LOG_NOT_STARTED));\r\n    }\r\n    lifecycle.fireLifecycleEvent(STOP_EVENT, null);\r\n    started = false;\r\n    if (!flushRealTime) {\r\n        threadStop();\r\n    }\r\n    close();\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.Digester.startElement",
	"Comment": "process notification of the start of an xml element being reached.",
	"Method": "void startElement(String namespaceURI,String localName,String qName,Attributes list){\r\n    boolean debug = log.isLoggable(Level.FINE);\r\n    if (saxLog.isLoggable(Level.FINE)) {\r\n        saxLog.log(Level.FINE, \"startElement(\" + namespaceURI + \",\" + localName + \",\" + qName + \")\");\r\n    }\r\n    list = updateAttributes(list);\r\n    bodyTexts.push(bodyText);\r\n    if (debug) {\r\n        log.log(Level.FINE, \"  Pushing body text '\" + bodyText.toString() + \"'\");\r\n    }\r\n    bodyText = new StringBuilder();\r\n    String name = localName;\r\n    if ((name == null) || (name.length() < 1)) {\r\n        name = qName;\r\n    }\r\n    StringBuilder sb = new StringBuilder(match);\r\n    if (match.length() > 0) {\r\n        sb.append('/');\r\n    }\r\n    sb.append(name);\r\n    match = sb.toString();\r\n    if (debug) {\r\n        log.log(Level.FINE, \"  New match='\" + match + \"'\");\r\n    }\r\n    List<Rule> rules = getRules().match(namespaceURI, match);\r\n    matches.push(rules);\r\n    if ((rules != null) && (rules.size() > 0)) {\r\n        for (int i = 0; i < rules.size(); i++) {\r\n            try {\r\n                Rule rule = rules.get(i);\r\n                if (debug) {\r\n                    log.log(Level.FINE, \"  Fire begin() for \" + rule);\r\n                }\r\n                rule.begin(namespaceURI, name, list);\r\n            } catch (Exception e) {\r\n                log.log(Level.SEVERE, LogFacade.BEGIN_EVENT_EXCEPTION, e);\r\n                throw createSAXException(e);\r\n            } catch (Error e) {\r\n                log.log(Level.SEVERE, LogFacade.BEGIN_EVENT_ERROR, e);\r\n                throw e;\r\n            }\r\n        }\r\n    } else {\r\n        if (debug) {\r\n            log.log(Level.FINE, \"  No rules found matching '\" + match + \"'.\");\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.PartItem.setFormField",
	"Comment": "specifies whether or not a fileitem instance representsa simple form field.",
	"Method": "void setFormField(boolean state){\r\n    isFormField = state;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Response.getResponse",
	"Comment": "return the servletresponse for which this objectis the facade.",
	"Method": "HttpServletResponse getResponse(){\r\n    if (facade == null) {\r\n        facade = new ResponseFacade(this);\r\n    }\r\n    return facade;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.node.runtime.gf.WebBundleRuntimeNode.registerBundle",
	"Comment": "register this node as a root node capable of loading entire dd files",
	"Method": "String registerBundle(Map<String, String> publicIDToDTD,Map<String, List<Class>> versionUpgrades){\r\n    publicIDToDTD.put(DTDRegistry.SUN_WEBAPP_230_DTD_PUBLIC_ID, DTDRegistry.SUN_WEBAPP_230_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_WEBAPP_231_DTD_PUBLIC_ID, DTDRegistry.SUN_WEBAPP_231_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_WEBAPP_240_DTD_PUBLIC_ID, DTDRegistry.SUN_WEBAPP_240_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_WEBAPP_241_DTD_PUBLIC_ID, DTDRegistry.SUN_WEBAPP_241_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_WEBAPP_250_DTD_PUBLIC_ID, DTDRegistry.SUN_WEBAPP_250_DTD_SYSTEM_ID);\r\n    publicIDToDTD.put(DTDRegistry.SUN_WEBAPP_300_DTD_PUBLIC_ID, DTDRegistry.SUN_WEBAPP_300_DTD_SYSTEM_ID);\r\n    if (!restrictDTDDeclarations()) {\r\n        publicIDToDTD.put(DTDRegistry.SUN_WEBAPP_240beta_DTD_PUBLIC_ID, DTDRegistry.SUN_WEBAPP_240beta_DTD_SYSTEM_ID);\r\n    }\r\n    return RuntimeTagNames.S1AS_WEB_RUNTIME_TAG;\r\n}"
}, {
	"Path": "com.sun.appserv.web.cache.filter.CachingResponseWrapper.setLocale",
	"Comment": "set the locale that is appropriate for this response, includingsetting the appropriate character encoding.",
	"Method": "void setLocale(Locale locale){\r\n    super.setLocale(locale);\r\n    this.locale = locale;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.CLICommand.echoCommand",
	"Comment": "return a string representing the command line used with this command.",
	"Method": "String echoCommand(){\r\n    StringBuilder sb = new StringBuilder();\r\n    sb.append(programOpts.getCommandName());\r\n    sb.append(' ');\r\n    sb.append(programOpts.toString()).append(' ');\r\n    sb.append(name).append(' ');\r\n    if (options != null && operands != null) {\r\n        for (ParamModel opt : commandModel.getParameters()) {\r\n            if (opt.getParam().password())\r\n                continue;\r\n            if (opt.getParam().primary())\r\n                continue;\r\n            if (opt.getParam().multiple()) {\r\n                List<String> paramValues = getOptions(opt.getName());\r\n                for (String v : paramValues) {\r\n                    appendEchoOption(sb, opt, v);\r\n                }\r\n            } else {\r\n                String value = getOption(opt.getName());\r\n                if (value != null) {\r\n                    appendEchoOption(sb, opt, value);\r\n                }\r\n            }\r\n        }\r\n        for (String o : operands) sb.append(quote(o)).append(' ');\r\n    } else if (argv != null) {\r\n        for (String arg : argv) sb.append(quote(arg)).append(' ');\r\n    }\r\n    sb.setLength(sb.length() - 1);\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogHandle.restoreCushion",
	"Comment": "restores the cushion filethis internal method does not need to be synchronized.",
	"Method": "void restoreCushion(boolean callUpcall){\r\n    if (CUSHION_SIZE > 0) {\r\n        if (!logControl.cushionFile.exists()) {\r\n            LogFileHandle cushionFH;\r\n            int openOptions = LogFileHandle.OPEN_RDWR | LogFileHandle.OPEN_CREAT | LogFileHandle.OPEN_SYNC;\r\n            try {\r\n                cushionFH = new LogFileHandle(logControl.cushionFile, openOptions);\r\n            } catch (LogException le) {\r\n                if (callUpcall && !upcallInProgress) {\r\n                    upcallInProgress = true;\r\n                    upcallTarget.upcall(CALLBACK_REASON_SOS);\r\n                    upcallInProgress = false;\r\n                }\r\n                throw new LogException(LogException.LOG_OPEN_FAILURE, 3, null, le);\r\n            }\r\n            try {\r\n                cushionFH.allocFileStorage(CUSHION_SIZE);\r\n            } catch (LogException le) {\r\n                cushionFH.destroy();\r\n                java.security.AccessController.doPrivileged(new java.security.PrivilegedAction() {\r\n                    public Object run() {\r\n                        return logControl.cushionFile.delete();\r\n                    }\r\n                });\r\n                if (callUpcall && !upcallInProgress) {\r\n                    upcallInProgress = true;\r\n                    upcallTarget.upcall(CALLBACK_REASON_SOS);\r\n                    upcallInProgress = false;\r\n                }\r\n                cushionExists = false;\r\n                throw new LogException(LogException.LOG_OPEN_FAILURE, 4, null, le);\r\n            }\r\n            cushionFH.destroy();\r\n        }\r\n        cushionExists = true;\r\n    }\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogHandle.restoreCushion",
	"Comment": "restores the cushion filethis internal method does not need to be synchronized.",
	"Method": "void restoreCushion(boolean callUpcall){\r\n    return logControl.cushionFile.delete();\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.deploy.shared.OutputJarArchive.getURI",
	"Comment": "returns the path used to create or open the underlyong archive",
	"Method": "URI getURI(){\r\n    return uri;\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.AuthenticatorBase.getDisableProxyCaching",
	"Comment": "return the flag that states if we add headers to disable caching byproxies.",
	"Method": "boolean getDisableProxyCaching(){\r\n    return disableProxyCaching;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHost.getNetworkListenerNames",
	"Comment": "gets the network listener names with which this standardhost is associated.",
	"Method": "String[] getNetworkListenerNames(){\r\n    return this.networkListenerNames.clone();\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.postResources",
	"Comment": "stores the resources of this application as servletcontextattributes.",
	"Method": "void postResources(){\r\n    getServletContext().setAttribute(Globals.RESOURCES_ATTR, getResources());\r\n    context.setAttributeReadOnly(Globals.RESOURCES_ATTR);\r\n    getServletContext().setAttribute(Globals.ALTERNATE_RESOURCES_ATTR, getAlternateDocBases());\r\n    context.setAttributeReadOnly(Globals.ALTERNATE_RESOURCES_ATTR);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.rollback_only",
	"Comment": "ensures that the transaction represented by the target subcoordinatorcannot be committed.",
	"Method": "void rollback_only(){\r\n    if (tranState.state != TransactionState.STATE_ACTIVE) {\r\n        Inactive exc = new Inactive();\r\n        throw exc;\r\n    } else {\r\n        rollbackOnly = true;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.security.common.FileRealmHelper.hasAuthenticatableUser",
	"Comment": "test whether their is a user in the filerealm that has a password that has been set, i.e., something other than the resetkey.",
	"Method": "boolean hasAuthenticatableUser(){\r\n    for (User ud : userTable.values()) {\r\n        if (!resetKey.equals(ud.getAlgo())) {\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.util.PrintMillis.println",
	"Comment": "print out the milliseconds that have elapsed since the last call.",
	"Method": "void println(String msg){\r\n    final long elapsed = System.currentTimeMillis() - mLast;\r\n    System.out.println((msg == null ? \"\" : msg) + \": \" + elapsed);\r\n    mLast = System.currentTimeMillis();\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.RepositoryManager.isNSSSupportAvailable",
	"Comment": "determines if the nss support is available in this installation. thecheck involves availability of the certutilexecutable.",
	"Method": "boolean isNSSSupportAvailable(){\r\n    File certUtilFile = null;\r\n    if (OS.isWindows()) {\r\n        certUtilFile = new File(CERTUTIL_CMD + \".exe\");\r\n    } else {\r\n        certUtilFile = new File(CERTUTIL_CMD);\r\n    }\r\n    if (certUtilFile.exists()) {\r\n        return (true);\r\n    }\r\n    return (false);\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.utils.ResourceUtil.getResponse",
	"Comment": "constructs and returns the appropriate response object based on theclient.",
	"Method": "Response getResponse(int status,String message,HttpHeaders requestHeaders,UriInfo uriInfo){\r\n    if (isBrowser(requestHeaders)) {\r\n        message = getHtml(message, uriInfo, false);\r\n    }\r\n    return Response.status(status).entity(message).build();\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogHandle.writeControlFile",
	"Comment": "writes the control file.this internal method does not need to be synchronized.",
	"Method": "void writeControlFile(){\r\n    Enumeration extents = extentTable.elements();\r\n    while (extents.hasMoreElements()) {\r\n        LogExtent nextEDP = (LogExtent) extents.nextElement();\r\n        if (nextEDP.writtenSinceLastForce) {\r\n            try {\r\n                nextEDP.fileHandle.fileSync();\r\n                nextEDP.writtenSinceLastForce = false;\r\n            } catch (LogException le) {\r\n                throw new LogException(LogException.LOG_ERROR_FORCING_LOG, 14, null, le);\r\n            }\r\n        }\r\n    }\r\n    logFileHandle.fileSeek(0, LogFileHandle.SEEK_ABSOLUTE);\r\n    byte[] controlBytes = new byte[LogControlDescriptor.SIZEOF];\r\n    logControlDescriptor.toBytes(controlBytes, 0);\r\n    logFileHandle.fileWrite(controlBytes);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.PEAccessLogValve.invoke",
	"Comment": "log a message summarizing the specified request and response, accordingto the format specified by the pattern property.",
	"Method": "int invoke(Request request,Response response){\r\n    if (formatter != null && formatter.needTimeTaken()) {\r\n        request.setNote(Constants.REQUEST_START_TIME_NOTE, System.currentTimeMillis());\r\n    }\r\n    return INVOKE_NEXT;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.CurrentTransaction.getAllTransactions",
	"Comment": "returns all the transactions in the system that are currently runningor suspended in the form of a sequence of control objects.",
	"Method": "Control[] getAllTransactions(){\r\n    if (!statsOn) {\r\n        throw new NO_IMPLEMENT(\"statistics not on\");\r\n    }\r\n    Control[] result = null;\r\n    int allNum = threadContexts != null ? threadContexts.size() + suspended.size() : 0;\r\n    if (allNum > 0) {\r\n        result = new Control[allNum];\r\n        Enumeration controls = suspended.elements();\r\n        int pos = 0;\r\n        while (controls.hasMoreElements()) result[pos++] = ((ControlImpl) controls.nextElement()).object();\r\n        controls = threadContexts.elements();\r\n        while (controls.hasMoreElements()) result[pos++] = ((ControlImpl) controls.nextElement()).object();\r\n    } else\r\n        result = new Control[0];\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Response.getConnector",
	"Comment": "return the connector through which this request was received.",
	"Method": "Connector getConnector(){\r\n    return this.connector;\r\n}"
}, {
	"Path": "com.sun.jts.utils.RecoveryHooks.FailureInducer.deactivateFailureInducer",
	"Comment": "this deactivates the failureinducer. an application deactivate thefailure inducer, to temporarily stop failure inducement. the failor wait points are not forgotten during the dormant state.",
	"Method": "void deactivateFailureInducer(){\r\n    failureInducerIsActive = false;\r\n}"
}, {
	"Path": "com.sun.appserv.util.cache.BaseCache._put",
	"Comment": "cache the given value at the specified key and return previous value",
	"Method": "Object _put(int hashCode,Object key,Object value,int size,boolean addValue){\r\n    int index = getIndex(hashCode);\r\n    CacheItem item, newItem = null, oldItem = null, overflow = null;\r\n    Object oldValue;\r\n    int oldSize = 0;\r\n    synchronized (bucketLocks[index]) {\r\n        for (item = buckets[index]; item != null; item = item.next) {\r\n            if ((hashCode == item.hashCode) && eq(key, item.key)) {\r\n                oldItem = item;\r\n                break;\r\n            }\r\n        }\r\n        if (addValue || oldItem == null) {\r\n            newItem = createItem(hashCode, key, value, size);\r\n            newItem.next = buckets[index];\r\n            buckets[index] = newItem;\r\n            oldValue = null;\r\n            overflow = itemAdded(newItem);\r\n        } else {\r\n            oldSize = oldItem.getSize();\r\n            oldValue = oldItem.refreshValue(value, size);\r\n            itemRefreshed(oldItem, oldSize);\r\n        }\r\n    }\r\n    if (newItem != null) {\r\n        incrementEntryCount();\r\n        incrementAddCount();\r\n        if (overflow != null)\r\n            trimItem(overflow);\r\n    } else\r\n        incrementRefreshCount();\r\n    return oldValue;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.ConnectorTest.findImplementorOf",
	"Comment": "look for an implementation of an interface in all the classes present in a jar file, setting the result object with the look up result",
	"Method": "Class findImplementorOf(ConnectorDescriptor desc,String interfaceName,boolean findImplementorOf,ConnectorDescriptor desc,String interfaceName,Result result){\r\n    Class c = findImplementorOf(desc, interfaceName);\r\n    if (c != null) {\r\n        result.passed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.ConnectorTest.findImplementor.passed\", \"The class [ {0} ] implements the [ {1} ] interface\", new Object[] { c.getName(), interfaceName }));\r\n        return true;\r\n    } else {\r\n        result.failed(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.ConnectorTest.findImplementor.failed\", \"Error: There is no implementation of the [ {0} ] provided\", new Object[] { interfaceName }));\r\n        return false;\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.admin.DeploymentCommandUtils.getAccessChecksForExistingApp",
	"Comment": "prepares accesschecks for an application already deployed to one ormore targets, returning an access check for the application itself andaccess checks for each matching version on whatever targets to whichit is assigned.",
	"Method": "Collection<? extends AccessRequired.AccessCheck> getAccessChecksForExistingApp(Domain domain,Applications applications,String target,Collection<String> matchedVersions,String appAction,String appRefAction){\r\n    final List<AccessRequired.AccessCheck> accessChecks = new ArrayList<AccessRequired.AccessCheck>();\r\n    final List<String> targets = domain.getTargets(target);\r\n    for (String mv : matchedVersions) {\r\n        final Application app = applications.getApplication(mv);\r\n        if (app == null) {\r\n            continue;\r\n        }\r\n        accessChecks.add(new AccessRequired.AccessCheck(getResourceNameForExistingApp(domain, mv), appAction));\r\n        for (String t : targets) {\r\n            final ApplicationRef ar = domain.getApplicationRefInTarget(mv, t);\r\n            if (ar != null) {\r\n                accessChecks.add(new AccessRequired.AccessCheck(getTargetResourceNameForExistingAppRef(domain, t, mv), appRefAction));\r\n            }\r\n        }\r\n    }\r\n    return accessChecks;\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ModifiedAttributeHASession.setAttributeStatePersistent",
	"Comment": "set the sessionattributestate for attributenamebased on persistent value",
	"Method": "void setAttributeStatePersistent(String attributeName,boolean persistent){\r\n    SessionAttributeState attrState = _attributeStates.get(attributeName);\r\n    if (attrState == null) {\r\n        attrState = new SessionAttributeState();\r\n        attrState.setPersistent(persistent);\r\n        _attributeStates.put(attributeName, attrState);\r\n    } else {\r\n        attrState.setPersistent(persistent);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.ha.session.management.ReplicationAttributeStore.save",
	"Comment": "save the specified session into this store.any previously savedinformation for the associated session identifier is replaced.",
	"Method": "void save(Session session){\r\n    if (!(session instanceof HASession)) {\r\n        return;\r\n    }\r\n    HASession haSess = (HASession) session;\r\n    if (haSess.isPersistent() && !haSess.isDirty()) {\r\n        this.updateLastAccessTime(session);\r\n    } else {\r\n        this.doSave(session);\r\n        haSess.setPersistent(true);\r\n    }\r\n    haSess.setDirty(false);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Response.createOutputStream",
	"Comment": "create and return a servletoutputstream to write the contentassociated with this response.",
	"Method": "ServletOutputStream createOutputStream(){\r\n    if (outputStream == null) {\r\n        outputStream = new CoyoteOutputStream(outputBuffer);\r\n    }\r\n    return outputStream;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.remote.RemoteCommand.getCommandClass",
	"Comment": "given a command name, return the name of the class that implementsthat command in the server.",
	"Method": "String getCommandClass(String cmdName){\r\n    ServiceLocator h = getManHabitat();\r\n    String cname = \"org.glassfish.api.admin.AdminCommand\";\r\n    for (ActiveDescriptor<?> ad : h.getDescriptors(BuilderHelper.createContractFilter(cname))) {\r\n        if (ad.getName() != null && ad.getName().equals(cmdName)) {\r\n            return ad.getImplementation();\r\n        }\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.server.logging.GFFileHandler.requestRotation",
	"Comment": "request rotation called from rotation timer task or logmbean",
	"Method": "void requestRotation(){\r\n    rotationRequested.set(true);\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getAttributeNames",
	"Comment": "return an enumeration of the names of the context attributesassociated with this context.",
	"Method": "Enumeration<String> getAttributeNames(){\r\n    return new Enumerator<String>(attributes.keySet(), true);\r\n}"
}, {
	"Path": "com.sun.enterprise.util.SystemPropertyConstants.getPropertyAsValue",
	"Comment": "a method that returns the passed string as a property that canbe replaced at run time.",
	"Method": "String getPropertyAsValue(String name){\r\n    if (name == null) {\r\n        final String pn = \"spc.null_name\";\r\n        final String pv = \"property\";\r\n        throw new IllegalArgumentException(sm.getString(pn, pv));\r\n    }\r\n    final StringBuffer sb = new StringBuffer();\r\n    sb.append(OPEN).append(name).append(CLOSE);\r\n    return (sb.toString());\r\n}"
}, {
	"Path": "com.sun.appserv.web.taglibs.cache.CacheTag.doStartTag",
	"Comment": "dostarttag is called every time the cache tag is encountered. bythe time this is called, the tag attributes are already set, butthe tag body has not been evaluated.the cache key is generated here and the cache is obtained as well",
	"Method": "int doStartTag(){\r\n    int ret = EVAL_BODY_BUFFERED;\r\n    _key = CacheUtil.generateKey(_keyExpr, pageContext);\r\n    if (_logger.isLoggable(Level.FINE))\r\n        _logger.log(Level.FINE, LogFacade.CACHETAG_TIMEOUT, new Object[] { _key, _timeout });\r\n    if (_useCachedResponse) {\r\n        _cache = CacheUtil.getCache(pageContext, _scope);\r\n        if (_cache == null)\r\n            throw new JspException(_rb.getString(LogFacade.TAGLIBS_CACHE_NO_CACHE));\r\n        if (_refreshCache == false) {\r\n            CacheEntry entry = (CacheEntry) _cache.get(_key);\r\n            if (entry != null && entry.isValid()) {\r\n                String content = entry.getContent();\r\n                try {\r\n                    pageContext.getOut().write(content);\r\n                } catch (java.io.IOException ex) {\r\n                    throw new JspException(ex);\r\n                }\r\n                ret = SKIP_BODY;\r\n            }\r\n        }\r\n    } else {\r\n        ret = EVAL_BODY_INCLUDE;\r\n    }\r\n    return ret;\r\n}"
}, {
	"Path": "org.glassfish.admin.cli.resources.CreateResourceRef.execute",
	"Comment": "executes the command with the command parameters passed as propertieswhere the keys are the parameter names and the values the parameter values",
	"Method": "void execute(AdminCommandContext context){\r\n    final ActionReport report = context.getActionReport();\r\n    if (isResourceRefAlreadyPresent()) {\r\n        report.setMessage(localStrings.getLocalString(\"create.resource.ref.existsAlready\", \"Resource ref {0} already exists for target {1}\", refName, target));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        return;\r\n    }\r\n    try {\r\n        createResourceRef();\r\n        if (refContainer instanceof Cluster && isElegibleResource(refName)) {\r\n            Target tgt = locator.getService(Target.class);\r\n            List<Server> instances = tgt.getInstances(target);\r\n            for (Server svr : instances) {\r\n                svr.createResourceRef(enabled.toString(), refName);\r\n            }\r\n        }\r\n        ActionReport.ExitCode ec = ActionReport.ExitCode.SUCCESS;\r\n        report.setMessage(localStrings.getLocalString(\"create.resource.ref.success\", \"resource-ref {0} created successfully.\", refName));\r\n        report.setActionExitCode(ec);\r\n    } catch (TransactionFailure tfe) {\r\n        report.setMessage(localStrings.getLocalString(\"create.resource.ref.failed\", \"Resource ref {0} creation failed\", refName));\r\n        report.setActionExitCode(ActionReport.ExitCode.FAILURE);\r\n        report.setFailureCause(tfe);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.versioning.VersioningService.getEnabledVersionInReferencedTargetsForExpression",
	"Comment": "search the enabled versions on the referenced targets of each versionmatched by the expression.this method is designed to be used with domain target. as differentversions maybe enabled on different targets, the return type used is a map.",
	"Method": "Map<String, Set<String>> getEnabledVersionInReferencedTargetsForExpression(String versionExpression){\r\n    Map<String, Set<String>> enabledVersionsInTargets = Collections.EMPTY_MAP;\r\n    List<String> matchedVersions = getMatchedVersions(versionExpression, \"domain\");\r\n    Iterator it = matchedVersions.iterator();\r\n    while (it.hasNext()) {\r\n        String matchedVersion = (String) it.next();\r\n        Map<String, Set<String>> tempMap = getEnabledVersionsInReferencedTargets(matchedVersion);\r\n        if (enabledVersionsInTargets != Collections.EMPTY_MAP) {\r\n            for (Map.Entry<String, Set<String>> entry : tempMap.entrySet()) {\r\n                String tempKey = entry.getKey();\r\n                Set<String> tempList = entry.getValue();\r\n                if (enabledVersionsInTargets.containsKey(tempKey)) {\r\n                    enabledVersionsInTargets.get(tempKey).addAll(tempList);\r\n                } else {\r\n                    enabledVersionsInTargets.put(tempKey, tempList);\r\n                }\r\n            }\r\n        } else {\r\n            enabledVersionsInTargets = tempMap;\r\n        }\r\n    }\r\n    return enabledVersionsInTargets;\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityCollection.removePattern",
	"Comment": "remove the specified url pattern from those that are part of thisweb resource collection.",
	"Method": "void removePattern(String pattern){\r\n    if (pattern == null)\r\n        return;\r\n    int n = -1;\r\n    for (int i = 0; i < patterns.length; i++) {\r\n        if (patterns[i].equals(pattern)) {\r\n            n = i;\r\n            break;\r\n        }\r\n    }\r\n    if (n >= 0) {\r\n        int j = 0;\r\n        String[] results = new String[patterns.length - 1];\r\n        for (int i = 0; i < patterns.length; i++) {\r\n            if (i != n)\r\n                results[j++] = patterns[i];\r\n        }\r\n        patterns = results;\r\n    }\r\n}"
}, {
	"Path": "testmbeans.ObjectNameSelfProvider.getAttribute",
	"Comment": "gets the value of the specified attribute of the dynamicmbean.",
	"Method": "Object getAttribute(String attributeName){\r\n    throw new AttributeNotFoundException(\"Unknown Attribute \" + attributeName);\r\n}"
}, {
	"Path": "com.sun.appserv.management.sample.SampleListener.getNotifsReceived",
	"Comment": "return a map, keyed by notification type, of all notifications received so far.",
	"Method": "Map getNotifsReceived(List getNotifsReceived,String type){\r\n    return ((List) mNotifs.get(type));\r\n}"
}, {
	"Path": "org.glassfish.weld.services.EjbServicesImpl.resolveEjb",
	"Comment": "request a reference to an ejb session object from the container. if the ejb being resolved is a stateful session bean, the container should ensure the session bean is created before this method returns.",
	"Method": "SessionObjectReference resolveEjb(EjbDescriptor<?> ejbDescriptor){\r\n    SessionObjectReference sessionObj = null;\r\n    String globalJndiName = getDefaultGlobalJndiName(ejbDescriptor);\r\n    if (globalJndiName != null) {\r\n        try {\r\n            InitialContext ic = new InitialContext();\r\n            Object ejbRef = ic.lookup(globalJndiName);\r\n            EjbContainerServices containerServices = services.getService(EjbContainerServices.class);\r\n            sessionObj = new SessionObjectReferenceImpl(containerServices, ejbRef);\r\n        } catch (NamingException ne) {\r\n            throw new IllegalStateException(\"Error resolving session object reference for ejb name \" + ejbDescriptor.getBeanClass() + \" and jndi name \" + globalJndiName, ne);\r\n        }\r\n    } else {\r\n        throw new IllegalArgumentException(\"Not enough type information to resolve ejb for \" + \" ejb name \" + ejbDescriptor.getBeanClass());\r\n    }\r\n    return sessionObj;\r\n}"
}, {
	"Path": "components.model.Node.findChild",
	"Comment": "returns the node with the specified name by looking upby child list. if node is not found returns null",
	"Method": "Node findChild(String name){\r\n    int n = children.size();\r\n    for (int i = 0; i < n; i++) {\r\n        Node kid = (Node) children.get(i);\r\n        if (name.equals(kid.getName())) {\r\n            return (kid);\r\n        }\r\n    }\r\n    return (null);\r\n}"
}, {
	"Path": "sqetests.ejb.stateful.passivate.util.EJBRecorderHome.getInstance",
	"Comment": "creates a new instance of ejbrecorderhome with beanstatus as parameter",
	"Method": "EJBRecorderHome getInstance(EJBRecorderHome getInstance,HashMap beanmap){\r\n    if (recorderInstance == null) {\r\n        recorderInstance = new EJBRecorderHome(beanmap);\r\n    }\r\n    return recorderInstance;\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationFilterChain.addFilter",
	"Comment": "add a filter to the set of filters that will be executed in this chain.",
	"Method": "void addFilter(ApplicationFilterConfig filterConfig){\r\n    if (n == filters.length) {\r\n        ApplicationFilterConfig[] newFilters = new ApplicationFilterConfig[n + INCREMENT];\r\n        System.arraycopy(filters, 0, newFilters, 0, n);\r\n        filters = newFilters;\r\n    }\r\n    filters[n++] = filterConfig;\r\n}"
}, {
	"Path": "com.sun.enterprise.glassfish.bootstrap.osgi.GlassFishMainActivator.guessInstallRoot",
	"Comment": "this method tries to guess install root based on location of the bundle. please note, because location of abundle is free form string, this method can come to very wrong conclusion if user wants to fool us.",
	"Method": "String guessInstallRoot(BundleContext context){\r\n    String location = context.getBundle().getLocation();\r\n    try {\r\n        final URI uri = URI.create(location);\r\n        File f = new File(uri);\r\n        if (f.exists() && f.isFile() && f.getParentFile().getCanonicalPath().endsWith(\"modules\")) {\r\n            return f.getParentFile().getParentFile().getAbsolutePath();\r\n        }\r\n    } catch (Exception e) {\r\n    }\r\n    return null;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.remote.RemoteCLICommand.getUsage",
	"Comment": "get the usage text. if we got usage information from the server, use it.",
	"Method": "String getUsage(){\r\n    if (usage == null) {\r\n        if (rac == null) {\r\n            return getCommandUsage();\r\n        }\r\n        usage = rac.getUsage();\r\n    }\r\n    if (usage == null)\r\n        return super.getUsage();\r\n    StringBuilder usageText = new StringBuilder();\r\n    usageText.append(strings.get(\"Usage\", getBriefCommandUsage()));\r\n    usageText.append(\" \");\r\n    usageText.append(usage);\r\n    return usageText.toString();\r\n}"
}, {
	"Path": "org.glassfish.security.common.FileRealmHelper.setPassword",
	"Comment": "sets the password in a user object. of course the password is notreally stored so a salt is generated, hash computed, and these twovalues are stored in the user object provided.",
	"Method": "void setPassword(User user,char[] pwd){\r\n    assert (user != null);\r\n    byte[] pwdBytes = null;\r\n    try {\r\n        pwdBytes = Utility.convertCharArrayToByteArray(pwd, Charset.defaultCharset().displayName());\r\n    } catch (Exception ex) {\r\n        throw new IllegalArgumentException(ex);\r\n    }\r\n    SecureRandom rng = SharedSecureRandomImpl.get();\r\n    byte[] salt = new byte[SALT_SIZE];\r\n    rng.nextBytes(salt);\r\n    user.setSalt(salt);\r\n    String algo = user.getAlgo();\r\n    if (algo == null) {\r\n        algo = algoSHA256;\r\n    }\r\n    byte[] hash = SSHA.compute(salt, pwdBytes, algo);\r\n    user.setHash(hash);\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.TopCoordinator.commit",
	"Comment": "directs the topcoordinator to commit the transaction.the topcoordinator directs all registered resources to commit. if anyresources raise heuristic exceptions, the information is recorded,and the resources are directed to forget the transaction before thecoordinator returns a heuristic exception to its caller.",
	"Method": "void commit(){\r\n    synchronized (this) {\r\n        if (_logger.isLoggable(Level.FINE)) {\r\n            _logger.logp(Level.FINE, \"TopCoordinator\", \"commit()\", \"Within TopCoordinator.commit()\" + \"GTID is :\" + superInfo.globalTID.toString());\r\n        }\r\n        if (tranState.state == TransactionState.STATE_PREPARED_READONLY) {\r\n            return;\r\n        }\r\n        if (tranState.state == TransactionState.STATE_COMMITTED) {\r\n            return;\r\n        }\r\n        if (!tranState.setState(TransactionState.STATE_COMMITTING)) {\r\n            _logger.log(Level.SEVERE, \"jts.transaction_wrong_state\", \"commit\");\r\n            String msg = LogFormatter.getLocalizedMessage(_logger, \"jts.transaction_wrong_state\", new java.lang.Object[] { \"commit\" });\r\n            throw new org.omg.CORBA.INTERNAL(msg);\r\n        }\r\n    }\r\n    Throwable heuristicExc = null;\r\n    Throwable internalExc = null;\r\n    if (participants != null) {\r\n        try {\r\n            participants.distributeCommit();\r\n        } catch (Throwable exc) {\r\n            if (exc instanceof HeuristicMixed || exc instanceof HeuristicHazard) {\r\n                heuristicExc = exc;\r\n            } else if (exc instanceof INTERNAL) {\r\n                internalExc = exc;\r\n            } else {\r\n                _logger.log(Level.WARNING, \"\", exc);\r\n            }\r\n        }\r\n    }\r\n    synchronized (this) {\r\n        if (!tranState.setState(TransactionState.STATE_COMMITTED)) {\r\n            _logger.log(Level.SEVERE, \"jts.transaction_wrong_state\", \"commit\");\r\n            String msg = LogFormatter.getLocalizedMessage(_logger, \"jts.transaction_wrong_state\", new java.lang.Object[] { \"commit\" });\r\n            throw new org.omg.CORBA.INTERNAL(msg);\r\n        }\r\n        if (terminator != null) {\r\n            terminator.setCompleted(false, (heuristicExc != null || internalExc != null));\r\n        }\r\n        if (!root) {\r\n            afterCompletion(Status.StatusCommitted);\r\n        }\r\n        if (heuristicExc != null) {\r\n            if (heuristicExc instanceof HeuristicMixed) {\r\n                throw (HeuristicMixed) heuristicExc;\r\n            } else {\r\n                throw (HeuristicHazard) heuristicExc;\r\n            }\r\n        } else if (internalExc != null) {\r\n            throw (INTERNAL) internalExc;\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.deploy.SecurityConstraint.getUserConstraint",
	"Comment": "return the user data constraint for this security constraint.",
	"Method": "String getUserConstraint(){\r\n    return (userConstraint);\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.isResourceDelegate",
	"Comment": "to determine whether one should delegate to parent for loadingresource of the given resource name.",
	"Method": "boolean isResourceDelegate(String name){\r\n    return (delegate || (name.startsWith(\"javax\") && (!name.startsWith(\"javax.faces\") || !useMyFaces)) || name.startsWith(\"sun\") || (name.startsWith(\"com/sun/faces\") && !name.startsWith(\"com/sun/faces/extensions\") && !useMyFaces) || name.startsWith(\"org/apache/taglibs/standard\"));\r\n}"
}, {
	"Path": "org.apache.catalina.authenticator.SingleSignOnEntry.getUsername",
	"Comment": "gets the username provided by the user as part of the authenticationprocess.",
	"Method": "String getUsername(){\r\n    return username;\r\n}"
}, {
	"Path": "org.glassfish.common.util.admin.AsadminInput.versionSpecifier",
	"Comment": "returns a string containing a specifier for the current version, suitablefor use as the first line to write to the asadmin system.in stream.",
	"Method": "String versionSpecifier(){\r\n    return VERSION_INTRODUCER + CURRENT_VERSION;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.cli.StartDomainCommand.createLauncher",
	"Comment": "create a launcher for the domain specified by arguments tothis command.the launcher is for a server of the specified type.sets the launcher and info fields.it has to be public because it is part of an interface",
	"Method": "void createLauncher(){\r\n    launcher = GFLauncherFactory.getInstance(getType());\r\n    info = launcher.getInfo();\r\n    info.setDomainName(getDomainName());\r\n    info.setDomainParentDir(getDomainsDir().getPath());\r\n    info.setVerbose(verbose || upgrade);\r\n    info.setDebug(debug);\r\n    info.setUpgrade(upgrade);\r\n    info.setWatchdog(watchdog);\r\n    info.setDropInterruptedCommands(drop_interrupted_commands);\r\n    info.setRespawnInfo(programOpts.getClassName(), programOpts.getClassPath(), respawnArgs());\r\n    launcher.setup();\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.NativeRemoteCommandsBase.expandPasswordAlias",
	"Comment": "obtains the real password from the domain specific keystore given an alias",
	"Method": "String expandPasswordAlias(String host,String alias,boolean verifyConn){\r\n    String expandedPassword = null;\r\n    boolean connStatus = false;\r\n    try {\r\n        File domainsDirFile = DomainDirs.getDefaultDomainsDir();\r\n        File[] files = domainsDirFile.listFiles(new FileFilter() {\r\n            public boolean accept(File f) {\r\n                return f.isDirectory();\r\n            }\r\n        });\r\n        for (File f : files) {\r\n            System.setProperty(SystemPropertyConstants.INSTANCE_ROOT_PROPERTY, f.getAbsolutePath());\r\n            try {\r\n                final PasswordAdapter pa = new PasswordAdapter(null);\r\n                final boolean exists = pa.aliasExists(alias);\r\n                if (exists) {\r\n                    String mPass = getMasterPassword(f.getName());\r\n                    expandedPassword = new PasswordAdapter(mPass.toCharArray()).getPasswordForAlias(alias);\r\n                }\r\n            } catch (Exception e) {\r\n                if (logger.isLoggable(Level.FINER)) {\r\n                    logger.finer(StringUtils.cat(\": \", alias, e.getMessage()));\r\n                }\r\n                logger.warning(Strings.get(\"GetPasswordFailure\", f.getName()));\r\n                continue;\r\n            }\r\n            if (expandedPassword != null) {\r\n                SSHLauncher sshL = new SSHLauncher();\r\n                if (host != null) {\r\n                    sshpassword = expandedPassword;\r\n                    sshL.init(getRemoteUser(), host, getRemotePort(), sshpassword, null, null, logger);\r\n                    connStatus = sshL.checkPasswordAuth();\r\n                    if (!connStatus) {\r\n                        logger.warning(Strings.get(\"PasswordAuthFailure\", f.getName()));\r\n                    }\r\n                } else {\r\n                    sshkeypassphrase = expandedPassword;\r\n                    if (verifyConn) {\r\n                        sshL.init(getRemoteUser(), hosts[0], getRemotePort(), sshpassword, getSshKeyFile(), sshkeypassphrase, logger);\r\n                        connStatus = sshL.checkConnection();\r\n                        if (!connStatus) {\r\n                            logger.warning(Strings.get(\"PasswordAuthFailure\", f.getName()));\r\n                        }\r\n                    }\r\n                }\r\n                if (connStatus) {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    } catch (IOException ioe) {\r\n        if (logger.isLoggable(Level.FINER)) {\r\n            logger.finer(ioe.getMessage());\r\n        }\r\n    }\r\n    return expandedPassword;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.NativeRemoteCommandsBase.expandPasswordAlias",
	"Comment": "obtains the real password from the domain specific keystore given an alias",
	"Method": "String expandPasswordAlias(String host,String alias,boolean verifyConn){\r\n    return f.isDirectory();\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.isForegroundLocked",
	"Comment": "return whether this session is currently foreground locked",
	"Method": "boolean isForegroundLocked(){\r\n    if (_sessionLock == null)\r\n        return false;\r\n    synchronized (sessionLockMonitor) {\r\n        return _sessionLock.isForegroundLocked();\r\n    }\r\n}"
}, {
	"Path": "com.sun.appserver.sqe.security.ssl.util.KeyTool.writeJksKeyStore",
	"Comment": "write the jks keystore that is populated with values from the pkcs12 keystore to the outputfile.",
	"Method": "void writeJksKeyStore(){\r\n    FileOutputStream fos = null;\r\n    try {\r\n        fos = new FileOutputStream(outputFile);\r\n    } catch (Exception e) {\r\n    } finally {\r\n        try {\r\n            jksKeyStore.store(fos, jksKeyStorePass);\r\n        } catch (Exception ce) {\r\n            ce.printStackTrace();\r\n        }\r\n        if (fos != null)\r\n            fos.close();\r\n    }\r\n}"
}, {
	"Path": "org.apache.naming.resources.WebDirContext.list",
	"Comment": "enumerates the names bound in the named context, along with the class names of objects bound to them. the contents of any subcontexts are not included.if a binding is added to or removed from this context, its effect on an enumeration previously returned is undefined.",
	"Method": "NamingEnumeration<NameClassPair> list(String name,List<NamingEntry> list,JarFileEntry jfeEntry){\r\n    List<NamingEntry> entries = new ArrayList<NamingEntry>();\r\n    JarFile jarFile = jfeEntry.jarFile;\r\n    JarEntry jarEntry = jfeEntry.jarEntry;\r\n    if (!jarEntry.isDirectory()) {\r\n        return entries;\r\n    }\r\n    String prefix = jarEntry.getName();\r\n    int prefixLength = prefix.length();\r\n    Enumeration<JarEntry> e = jarFile.entries();\r\n    while (e.hasMoreElements()) {\r\n        JarEntry je = e.nextElement();\r\n        String name = je.getName();\r\n        if (name.length() > prefixLength && name.startsWith(prefix)) {\r\n            int endIndex = name.indexOf('/', prefixLength);\r\n            if (endIndex != -1 && endIndex != name.length() - 1) {\r\n                continue;\r\n            }\r\n            String subName = ((endIndex != -1) ? name.substring(prefixLength, endIndex) : name.substring(prefixLength));\r\n            Object object = null;\r\n            if (je.isDirectory()) {\r\n                WebDirContext tempContext = new WebDirContext(env);\r\n                tempContext.docBase = name;\r\n                tempContext.setAllowLinking(getAllowLinking());\r\n                tempContext.setCaseSensitive(isCaseSensitive());\r\n                tempContext.setJarFileResourcesProvider(jarFileResourcesProvider);\r\n                tempContext.setJarResourceBase(name);\r\n                object = tempContext;\r\n            } else {\r\n                object = new JarResource(jarFile, je);\r\n            }\r\n            entries.add(new NamingEntry(subName, object, NamingEntry.ENTRY));\r\n        }\r\n    }\r\n    return entries;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.AuthorizationConstraintImpl.removeSecurityRole",
	"Comment": "removes the given role from the autrhorization constraint.",
	"Method": "void removeSecurityRole(SecurityRole securityRole){\r\n    this.getSecurityRoleSet().remove(securityRole);\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.setMaxInactiveInterval",
	"Comment": "set the maximum time interval, in seconds, between client requestsbefore the servlet container will invalidate the session.a negativetime indicates that the session should never time out.",
	"Method": "void setMaxInactiveInterval(int interval){\r\n    this.maxInactiveInterval = interval;\r\n    if (isValid && interval == 0) {\r\n        expire();\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.ApplicationContext.getDefaultSessionTrackingModes",
	"Comment": "gets the session tracking modes that are supported by default for thisservletcontext.",
	"Method": "Set<SessionTrackingMode> getDefaultSessionTrackingModes(){\r\n    if (isRestricted) {\r\n        throw new UnsupportedOperationException(rb.getString(LogFacade.UNSUPPORTED_OPERATION_EXCEPTION));\r\n    }\r\n    return context.getDefaultSessionTrackingModes();\r\n}"
}, {
	"Path": "org.glassfish.admin.amx.impl.config.ConfigBeanJMXSupportRegistry.getConfigBeanProxyClassFor",
	"Comment": "recursively attempt to find default values for a descendant of specified type",
	"Method": "Class<? extends ConfigBeanProxy> getConfigBeanProxyClassFor(ConfigBeanJMXSupport start,String type){\r\n    Class<? extends ConfigBeanProxy> result = start.childTypes().get(type);\r\n    if (result == null) {\r\n        for (final String sub : start.childTypes().keySet()) {\r\n            final Class<? extends ConfigBeanProxy> intf = start.childTypes().get(sub);\r\n            final ConfigBeanJMXSupport spt = getInstance(intf);\r\n            result = getConfigBeanProxyClassFor(spt, type);\r\n            if (result != null) {\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.tomcat.util.digester.AbstractRulesImpl.setDigester",
	"Comment": "set the digester instance with which this rules instance is associated.",
	"Method": "void setDigester(Digester digester){\r\n    this.digester = digester;\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.mergeParameters",
	"Comment": "merge the context initialization parameters specified in the applicationdeployment descriptor with the application parameters described in theserver configuration, respecting the override property ofthe application parameters appropriately.",
	"Method": "void mergeParameters(){\r\n    Map<String, String> mergedParams = new HashMap();\r\n    for (String name : findParameters()) {\r\n        mergedParams.put(name, findParameter(name));\r\n    }\r\n    for (ApplicationParameter param : findApplicationParameters()) {\r\n        if (param.getOverride()) {\r\n            if (mergedParams.get(param.getName()) == null)\r\n                mergedParams.put(param.getName(), param.getValue());\r\n        } else {\r\n            mergedParams.put(param.getName(), param.getValue());\r\n        }\r\n    }\r\n    ServletContext sc = getServletContext();\r\n    for (Map.Entry<String, String> entry : mergedParams.entrySet()) {\r\n        sc.setInitParameter(entry.getKey(), entry.getValue());\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.getAuthType",
	"Comment": "return the authentication type used to authenticate our cachedprincipal, if any.",
	"Method": "String getAuthType(){\r\n    return (this.authType);\r\n}"
}, {
	"Path": "org.glassfish.admin.rest.results.Result.isError",
	"Comment": "returns true in case of error. enables provider to generateerror message or otherwise.",
	"Method": "boolean isError(){\r\n    return __isError;\r\n}"
}, {
	"Path": "org.apache.catalina.session.PersistentManagerBase.processPersistenceChecks",
	"Comment": "called by the background thread after active sessions havebeen checked for expiration, to allow sessions to beswapped out, backed up, etc.",
	"Method": "void processPersistenceChecks(){\r\n    processMaxIdleSwaps();\r\n    processMaxActiveSwaps();\r\n    processMaxIdleBackups();\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.archivist.WebArchivist.validate",
	"Comment": "validates the dol objects associated with this archivist, usuallyit requires that a class loader being set on this archivist or passedas a parameter",
	"Method": "void validate(ClassLoader aClassLoader){\r\n    ClassLoader cl = aClassLoader;\r\n    if (cl == null) {\r\n        cl = classLoader;\r\n    }\r\n    if (cl == null) {\r\n        return;\r\n    }\r\n    descriptor.setClassLoader(cl);\r\n    descriptor.visit(new WebBundleValidator());\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.remote.RemoteAdminCommand.headers",
	"Comment": "return a modifiable list of headers to be added to the request.",
	"Method": "List<Header> headers(){\r\n    return requestHeaders;\r\n}"
}, {
	"Path": "org.glassfish.security.common.SSHA.verify",
	"Comment": "verifies a password.the given password is verified against the provided salt and hashbuffers.",
	"Method": "boolean verify(String encoded,byte[] password,boolean verify,byte[] salt,byte[] hash,byte[] password,String algo){\r\n    byte[] newHash = compute(salt, password, algo);\r\n    return Arrays.equals(hash, newHash);\r\n}"
}, {
	"Path": "org.apache.catalina.ssi.SSIMediator.substituteVariables",
	"Comment": "applies variable substitution to the specified string and returns thenew resolved string.",
	"Method": "String substituteVariables(String val){\r\n    if (val.indexOf('$') < 0 && val.indexOf('&') < 0)\r\n        return val;\r\n    val = val.replace(\"&lt;\", \"<\");\r\n    val = val.replace(\"&gt;\", \">\");\r\n    val = val.replace(\"&quot;\", \"\\\"\");\r\n    val = val.replace(\"&amp;\", \"&\");\r\n    StringBuilder sb = new StringBuilder(val);\r\n    int charStart = sb.indexOf(\"&#\");\r\n    while (charStart > -1) {\r\n        int charEnd = sb.indexOf(\";\", charStart);\r\n        if (charEnd > -1) {\r\n            char c = (char) Integer.parseInt(sb.substring(charStart + 2, charEnd));\r\n            sb.delete(charStart, charEnd + 1);\r\n            sb.insert(charStart, c);\r\n            charStart = sb.indexOf(\"&#\");\r\n        } else {\r\n            break;\r\n        }\r\n    }\r\n    for (int i = 0; i < sb.length(); ) {\r\n        for (; i < sb.length(); i++) {\r\n            if (sb.charAt(i) == '$') {\r\n                i++;\r\n                break;\r\n            }\r\n        }\r\n        if (i == sb.length())\r\n            break;\r\n        if (i > 1 && sb.charAt(i - 2) == '\\\\') {\r\n            sb.deleteCharAt(i - 2);\r\n            i--;\r\n            continue;\r\n        }\r\n        int nameStart = i;\r\n        int start = i - 1;\r\n        int end = -1;\r\n        int nameEnd = -1;\r\n        char endChar = ' ';\r\n        if (sb.charAt(i) == '{') {\r\n            nameStart++;\r\n            endChar = '}';\r\n        }\r\n        for (; i < sb.length(); i++) {\r\n            if (sb.charAt(i) == endChar)\r\n                break;\r\n        }\r\n        end = i;\r\n        nameEnd = end;\r\n        if (endChar == '}')\r\n            end++;\r\n        String varName = sb.substring(nameStart, nameEnd);\r\n        String value = getVariableValue(varName);\r\n        if (value == null)\r\n            value = \"\";\r\n        sb.replace(start, end, value);\r\n        i = start + value.length();\r\n    }\r\n    return sb.toString();\r\n}"
}, {
	"Path": "com.sun.enterprise.web.VirtualServer.addListener",
	"Comment": "adds the catalina listener with the given class name to thisvirtualserver.",
	"Method": "void addListener(String listenerName){\r\n    Object listener = safeLoadInstance(listenerName);\r\n    if (listener == null)\r\n        return;\r\n    if (listener instanceof ContainerListener) {\r\n        addContainerListener((ContainerListener) listener);\r\n    } else if (listener instanceof LifecycleListener) {\r\n        addLifecycleListener((LifecycleListener) listener);\r\n    } else {\r\n        _logger.log(Level.SEVERE, LogFacade.INVALID_LISTENER_VIRTUAL_SERVER, new Object[] { listenerName, getID() });\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.deployment.autodeploy.AutoDeployedFilesManager.isUndeployRequested",
	"Comment": "returns whether there is a request to undeploy the specified file.",
	"Method": "boolean isUndeployRequested(File autodeployDir,File f){\r\n    return appToUndeployRequestFile(autodeployDir, f).exists();\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.connector.cci.RecordFactoryExistence.check",
	"Comment": "test if a javax.resource.cci.recordfactory implementation has been provided in the rar file",
	"Method": "Result check(ConnectorDescriptor descriptor){\r\n    Result result = getInitializedResult();\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    if (isCCIImplemented(descriptor, result)) {\r\n        findImplementorOf(descriptor, \"javax.resource.cci.RecordFactory\", result);\r\n    } else {\r\n        result.addNaDetails(smh.getLocalString(\"tests.componentNameConstructor\", \"For [ {0} ]\", new Object[] { compName.toString() }));\r\n        result.notApplicable(smh.getLocalString(\"com.sun.enterprise.tools.verifier.tests.connector.cci.InteractionExistence.notapp\", \"NotApplicable : The CCI interfaces do not seem to be implemented by this resource adapter\"));\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.naming.resources.FileDirContext.list",
	"Comment": "enumerates the names bound in the named context, along with the class names of objects bound to them. the contents of any subcontexts are not included.if a binding is added to or removed from this context, its effect on an enumeration previously returned is undefined.",
	"Method": "NamingEnumeration<NameClassPair> list(String name,ArrayList<NamingEntry> list,File file){\r\n    ArrayList<NamingEntry> entries = new ArrayList<NamingEntry>();\r\n    if (!file.isDirectory())\r\n        return entries;\r\n    String[] names = file.list();\r\n    if (names == null) {\r\n        logger.log(Level.WARNING, LogFacade.FILE_RESOURCES_LISTING_NULL, file.getAbsolutePath());\r\n        return entries;\r\n    }\r\n    Arrays.sort(names);\r\n    NamingEntry entry = null;\r\n    for (int i = 0; i < names.length; i++) {\r\n        String keyName = file.getPath() + '/' + names[i];\r\n        File currentFile = file(file, names[i], keyName, listFileCache);\r\n        Object object = null;\r\n        if (currentFile != null && currentFile.isDirectory()) {\r\n            FileDirContext tempContext = new FileDirContext(env);\r\n            tempContext.setDocBase(file.getPath());\r\n            tempContext.setAllowLinking(getAllowLinking());\r\n            tempContext.setCaseSensitive(isCaseSensitive());\r\n            object = tempContext;\r\n        } else {\r\n            object = new FileResource(currentFile);\r\n        }\r\n        entry = new NamingEntry(names[i], object, NamingEntry.ENTRY);\r\n        entries.add(entry);\r\n    }\r\n    return entries;\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.setBlocking",
	"Comment": "set the blocking connection flag that will be assigned to requestsreceived through this connector.",
	"Method": "void setBlocking(boolean blocking){\r\n    this.blocking = blocking;\r\n    setProperty(\"blocking\", String.valueOf(blocking));\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogHandle.positionFilePointer",
	"Comment": "positions the file pointer to the given position in the log.this internal method does not need to be synchronized.",
	"Method": "LogExtent positionFilePointer(LogLSN currentLSN,int extra,int accessType){\r\n    boolean extentJustOpened = false;\r\n    LogExtent extent = (LogExtent) extentTable.get(currentLSN.extent);\r\n    if (extent == null) {\r\n        extent = openExtent(currentLSN.extent);\r\n        extentJustOpened = true;\r\n    }\r\n    if (extent.cursorPosition != currentLSN.offset + extra || extent.lastAccess != accessType) {\r\n        int seekDist = ((currentLSN.offset + extra) > extent.cursorPosition) ? (currentLSN.offset + extra - extent.cursorPosition) : (extent.cursorPosition - currentLSN.offset - extra);\r\n        try {\r\n            if (extent.lastAccess == LogExtent.ACCESSTYPE_UNKNOWN || currentLSN.offset + extra < seekDist)\r\n                extent.fileHandle.fileSeek(currentLSN.offset + extra, LogFileHandle.SEEK_ABSOLUTE);\r\n            else\r\n                extent.fileHandle.fileSeek(currentLSN.offset + extra - extent.cursorPosition, LogFileHandle.SEEK_RELATIVE);\r\n        } catch (LogException le) {\r\n            if (extentJustOpened) {\r\n                extentTable.remove(currentLSN.extent);\r\n                extent.doFinalize();\r\n            }\r\n            throw new LogException(LogException.LOG_READ_FAILURE, 3, null, le);\r\n        }\r\n        extent.cursorPosition = currentLSN.offset + extra;\r\n        extent.lastAccess = accessType;\r\n    }\r\n    return extent;\r\n}"
}, {
	"Path": "com.sun.enterprise.transaction.JavaEETransactionManagerSimplified.setTransactionTimeout",
	"Comment": "modify the value of the timeout value that is associated with thetransactions started by the current thread with the begin method. if an application has not called this method, the transactionservice uses some default value for the transaction timeout.",
	"Method": "void setTransactionTimeout(int seconds){\r\n    if (seconds < 0) {\r\n        throw new SystemException(sm.getString(\"enterprise_distributedtx.invalid_timeout\"));\r\n    }\r\n    txnTmout.set(seconds);\r\n}"
}, {
	"Path": "components.renderkit.RepeaterRenderer.getRendersChildren",
	"Comment": "return true to indicate that we do indeed wish to beresponsible for rendering the children of the associated component.",
	"Method": "boolean getRendersChildren(){\r\n    return (true);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.setQueryString",
	"Comment": "sets the query string for this request.used by fbl when the original request is restored aftersuccessful authentication.",
	"Method": "void setQueryString(String query){\r\n    coyoteRequest.setQueryString(query);\r\n}"
}, {
	"Path": "com.sun.enterprise.web.WebContainer.updateAccessLog",
	"Comment": "reconfigures the access log valve of each virtual server with theupdated attributes of theelement from domain.xml.",
	"Method": "void updateAccessLog(HttpService httpService){\r\n    Container[] virtualServers = getEngine().findChildren();\r\n    for (Container virtualServer : virtualServers) {\r\n        ((VirtualServer) virtualServer).reconfigureAccessLog(httpService, webContainerFeatureFactory);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.wsclients.WSClientTest.check",
	"Comment": "run an individual test against the deployment descriptor for the archive the verifier is performing compliance tests against.",
	"Method": "Result check(Descriptor descriptor,Result check,ServiceReferenceDescriptor descriptor){\r\n    return check((ServiceReferenceDescriptor) descriptor);\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.refreshPolicy",
	"Comment": "refresh the system policy file, to pick up eventual changes.",
	"Method": "void refreshPolicy(){\r\n    try {\r\n        Policy policy = Policy.getPolicy();\r\n        policy.refresh();\r\n    } catch (AccessControlException e) {\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.sniffer.WebSniffer.supportsArchiveType",
	"Comment": "this api is used to help determine if the sniffer should recognizethe current archive.if the sniffer does not support the archive type associated withthe current deployment, the sniffer should not recognize the archive.",
	"Method": "boolean supportsArchiveType(ArchiveType archiveType){\r\n    if (archiveType.equals(warType)) {\r\n        return true;\r\n    }\r\n    return false;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogLSN.toString",
	"Comment": "this method is called to direct the object to format its state to a string.",
	"Method": "String toString(){\r\n    return \"LSN(ext=\" + extent + \",off=\" + offset + \")\";\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHostDeployer.stop",
	"Comment": "stop an existing web application, attached to the specified contextpath.only stops a web application if it is running.",
	"Method": "void stop(String contextPath){\r\n    if (contextPath == null)\r\n        throw new IllegalArgumentException(rb.getString(LogFacade.CONTEXT_PATH_REQUIRED_EXCEPTION));\r\n    if (!contextPath.equals(\"\") && !contextPath.startsWith(\"/\")) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.INVALID_CONTEXT_PATH_EXCEPTION), contextPath);\r\n        throw new IllegalArgumentException(msg);\r\n    }\r\n    Context context = findDeployedApp(contextPath);\r\n    if (context == null) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.CONTEXT_PATH_NOT_IN_USE), contextPath);\r\n        throw new IllegalArgumentException(msg);\r\n    }\r\n    if (log.isLoggable(Level.INFO)) {\r\n        log.log(Level.INFO, LogFacade.STOPPING_WEB_APP_INFO, contextPath);\r\n    }\r\n    try {\r\n        ((Lifecycle) context).stop();\r\n    } catch (LifecycleException e) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.STOPPING_WEB_APP_FAILED_EXCEPTION), contextPath);\r\n        log.log(Level.SEVERE, msg, e);\r\n        throw new IllegalStateException(msg, e);\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.loader.WebappClassLoader.findLoadedClass0",
	"Comment": "finds the class with the given name if it has previously beenloaded and cached by this class loader, and return the class object.if this class has not been cached, return null.",
	"Method": "Class<?> findLoadedClass0(String name){\r\n    ResourceEntry entry = resourceEntries.get(name);\r\n    if (entry != null) {\r\n        synchronized (this) {\r\n            return entry.loadedClass;\r\n        }\r\n    }\r\n    return (null);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.deploy.shared.Util.toURI",
	"Comment": "returns uri for the specified url.this method will take care ofthe space in url.",
	"Method": "URI toURI(URL url){\r\n    return new URI(url.toString().replaceAll(SPACE, ENCODED_SPACE));\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.NestingInfo.getParent",
	"Comment": "returns a reference to the parent coordinator.if there is none, returns null.the parent coordinator is the first in the sequence of ancestors.if the forgetting flag is set, the nestinginfo must not call the parentwhen the child calls removefromparent.",
	"Method": "CoordinatorImpl getParent(boolean forgetting){\r\n    CoordinatorImpl result = null;\r\n    if (ancestorSeq.length != 0)\r\n        result = ancestorSeq[0];\r\n    if (forgetting)\r\n        removed = true;\r\n    return result;\r\n}"
}, {
	"Path": "org.apache.catalina.session.StandardSession.getSipApplicationSessionId",
	"Comment": "gets the id of the sipapplicationsession that is the parent of thisstandardsession.",
	"Method": "String getSipApplicationSessionId(){\r\n    return sipAppSessionId;\r\n}"
}, {
	"Path": "org.apache.catalina.valves.ValveBase.getNext",
	"Comment": "return the next valve in this pipeline, or null if thisis the last valve in the pipeline.",
	"Method": "Valve getNext(){\r\n    return next;\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.getSunDescriptor",
	"Comment": "this returns the extra web sun specific info not in the ri did.",
	"Method": "SunWebApp getSunDescriptor(){\r\n    if (sunWebApp == null) {\r\n        sunWebApp = new SunWebAppImpl();\r\n    }\r\n    return sunWebApp;\r\n}"
}, {
	"Path": "org.apache.catalina.fileupload.MultipartStream.setHeaderEncoding",
	"Comment": "specifies the character encoding to be used when reading the headers ofindividual parts. when not specified, or null, the platformdefault encoding is used.",
	"Method": "void setHeaderEncoding(String encoding){\r\n    headerEncoding = encoding;\r\n}"
}, {
	"Path": "com.sun.enterprise.web.PEAccessLogValve.threadSleep",
	"Comment": "sleep for the duration specified by the writeintervalproperty.",
	"Method": "void threadSleep(){\r\n    if (writerThread == null || writeInterval == 0)\r\n        return;\r\n    try {\r\n        writerThread.sleep(writeInterval * 1000L);\r\n    } catch (InterruptedException e) {\r\n        ;\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.cluster.CommandRunnable.getCommandInvocation",
	"Comment": "returns the commandinvocation that was passed on the constructor",
	"Method": "CommandInvocation getCommandInvocation(){\r\n    return ci;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.SubCoordinator.rollback",
	"Comment": "directs the subcoordinator to roll back the transaction.the subcoordinator directs all registered resources to rollback.",
	"Method": "void rollback(boolean force){\r\n    synchronized (this) {\r\n        if (tranState == null) {\r\n            return;\r\n        }\r\n        if (!force && ((tranState.state == TransactionState.STATE_PREPARED_SUCCESS) || (!tranState.setState(TransactionState.STATE_ROLLING_BACK)))) {\r\n            return;\r\n        }\r\n        if (!temporary && !tranState.setState(TransactionState.STATE_ROLLING_BACK)) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"SubCoordinator - setState(TransactionState.STATE_ROLLED_BACK) returned false\");\r\n            }\r\n        }\r\n        if (nestingInfo != null) {\r\n            nestingInfo.rollbackFamily();\r\n        }\r\n    }\r\n    if (participants != null) {\r\n        participants.distributeSubrollback();\r\n    }\r\n    synchronized (this) {\r\n        if (!temporary && !tranState.setState(TransactionState.STATE_ROLLED_BACK)) {\r\n            if (_logger.isLoggable(Level.FINE)) {\r\n                _logger.log(Level.FINE, \"SubCoordinator - setState(TransactionState.STATE_ROLLED_BACK) returned false\");\r\n            }\r\n        }\r\n        nestingInfo.removeFromParent(this);\r\n        if (terminator != null) {\r\n            terminator.setCompleted(true, false);\r\n        }\r\n        RecoveryManager.removeCoordinator(superInfo.globalTID, superInfo.localTID, false);\r\n        if (!dying) {\r\n            destroy();\r\n        }\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.setLoginConfig",
	"Comment": "set the login configuration descriptor for this web application.",
	"Method": "void setLoginConfig(LoginConfig config){\r\n    if (config == null)\r\n        throw new IllegalArgumentException(rb.getString(LogFacade.LOGIN_CONFIG_REQUIRED_EXCEPTION));\r\n    String loginPage = config.getLoginPage();\r\n    if ((loginPage != null) && !loginPage.startsWith(\"/\")) {\r\n        if (isServlet22()) {\r\n            if (log.isLoggable(Level.FINE)) {\r\n                log.log(Level.FINE, LogFacade.FORM_LOGIN_PAGE_FINE, loginPage);\r\n            }\r\n            config.setLoginPage(\"/\" + loginPage);\r\n        } else {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.LOGIN_CONFIG_LOGIN_PAGE_EXCEPTION), loginPage);\r\n            throw new IllegalArgumentException(msg);\r\n        }\r\n    }\r\n    String errorPage = config.getErrorPage();\r\n    if ((errorPage != null) && !errorPage.startsWith(\"/\")) {\r\n        if (isServlet22()) {\r\n            if (log.isLoggable(Level.FINE)) {\r\n                log.log(Level.FINE, LogFacade.FORM_ERROR_PAGE_FINE, errorPage);\r\n            }\r\n            config.setErrorPage(\"/\" + errorPage);\r\n        } else {\r\n            String msg = MessageFormat.format(rb.getString(LogFacade.LOGIN_CONFIG_ERROR_PAGE_EXCEPTION), errorPage);\r\n            throw new IllegalArgumentException(msg);\r\n        }\r\n    }\r\n    LoginConfig oldLoginConfig = this.loginConfig;\r\n    this.loginConfig = config;\r\n    support.firePropertyChange(\"loginConfig\", oldLoginConfig, this.loginConfig);\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.addSecurityReference",
	"Comment": "add a new security role reference record to the set of records forthis servlet.",
	"Method": "void addSecurityReference(String name,String link){\r\n    synchronized (references) {\r\n        references.put(name, link);\r\n    }\r\n    if (notifyContainerListeners) {\r\n        fireContainerEvent(\"addSecurityReference\", name);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardWrapper.stop",
	"Comment": "stop this component, gracefully shutting down the servlet if it hasbeen initialized.",
	"Method": "void stop(){\r\n    setAvailable(Long.MAX_VALUE);\r\n    if (this.getObjectName() != null) {\r\n        Notification notification = new Notification(\"j2ee.state.stopping\", this, sequenceNumber++);\r\n        sendNotification(notification);\r\n    }\r\n    try {\r\n        unload();\r\n    } catch (ServletException e) {\r\n        String msg = MessageFormat.format(rb.getString(LogFacade.SERVLET_UNLOAD_EXCEPTION), neutralizeForLog(getName()));\r\n        getServletContext().log(msg, e);\r\n    }\r\n    super.stop();\r\n    if (this.getObjectName() != null) {\r\n        Notification notification = new Notification(\"j2ee.state.stopped\", this, sequenceNumber++);\r\n        sendNotification(notification);\r\n    }\r\n    if (oname != null) {\r\n        Notification notification = new Notification(\"j2ee.object.deleted\", this, sequenceNumber++);\r\n        sendNotification(notification);\r\n    }\r\n}"
}, {
	"Path": "com.sun.enterprise.v3.admin.AdminAdapter.isRegistered",
	"Comment": "checks whether this adapter has been registered as a network endpoint.",
	"Method": "boolean isRegistered(){\r\n    return isRegistered;\r\n}"
}, {
	"Path": "org.glassfish.webservices.node.WebServiceNode.addDescriptor",
	"Comment": "addsa new dol descriptor instance to the descriptor instance associated with this xmlnode",
	"Method": "void addDescriptor(Object descriptor){\r\n    WebServiceEndpoint endpoint = (WebServiceEndpoint) descriptor;\r\n    WebService webService = (WebService) getDescriptor();\r\n    webService.addEndpoint(endpoint);\r\n}"
}, {
	"Path": "com.sun.enterprise.deployment.deploy.shared.Util.resolve",
	"Comment": "constructs a new uri by parsing the given string and then resolving it against the base uri.this method will take care of the space in string.",
	"Method": "URI resolve(URI baseUri,String uriString){\r\n    return baseUri.resolve(uriString.replaceAll(SPACE, ENCODED_SPACE));\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.createFilter",
	"Comment": "instantiates the given filter class and performs any requiredresource injection into the new filter instance before returningit.",
	"Method": "T createFilter(Class<T> clazz){\r\n    try {\r\n        return createFilterInstance(clazz);\r\n    } catch (Throwable t) {\r\n        throw new ServletException(\"Unable to create Filter from \" + \"class \" + clazz.getName(), t);\r\n    }\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardContext.findInstanceListeners",
	"Comment": "return the list of instancelistener classes that will be added tonewly created wrappers automatically.",
	"Method": "List<String> findInstanceListeners(){\r\n    return instanceListeners;\r\n}"
}, {
	"Path": "org.apache.catalina.ssi.ExpressionTokenizer.nextToken",
	"Comment": "returns the next token type and initializes any state variablesaccordingly.",
	"Method": "int nextToken(){\r\n    while (index < length && Character.isWhitespace(expr[index])) index++;\r\n    tokenVal = null;\r\n    if (index == length)\r\n        return TOKEN_END;\r\n    int start = index;\r\n    char currentChar = expr[index];\r\n    char nextChar = (char) 0;\r\n    index++;\r\n    if (index < length)\r\n        nextChar = expr[index];\r\n    switch(currentChar) {\r\n        case '(':\r\n            return TOKEN_LBRACE;\r\n        case ')':\r\n            return TOKEN_RBRACE;\r\n        case '=':\r\n            return TOKEN_EQ;\r\n        case '!':\r\n            if (nextChar == '=') {\r\n                index++;\r\n                return TOKEN_NOT_EQ;\r\n            } else {\r\n                return TOKEN_NOT;\r\n            }\r\n        case '|':\r\n            if (nextChar == '|') {\r\n                index++;\r\n                return TOKEN_OR;\r\n            }\r\n            break;\r\n        case '&':\r\n            if (nextChar == '&') {\r\n                index++;\r\n                return TOKEN_AND;\r\n            }\r\n            break;\r\n        case '>':\r\n            if (nextChar == '=') {\r\n                index++;\r\n                return TOKEN_GE;\r\n            } else {\r\n                return TOKEN_GT;\r\n            }\r\n        case '<':\r\n            if (nextChar == '=') {\r\n                index++;\r\n                return TOKEN_LE;\r\n            } else {\r\n                return TOKEN_LT;\r\n            }\r\n        default:\r\n            break;\r\n    }\r\n    int end = index;\r\n    if (currentChar == '\"' || currentChar == '\\'') {\r\n        char endChar = currentChar;\r\n        boolean escaped = false;\r\n        start++;\r\n        for (; index < length; index++) {\r\n            if (expr[index] == '\\\\' && !escaped) {\r\n                escaped = true;\r\n                continue;\r\n            }\r\n            if (expr[index] == endChar && !escaped)\r\n                break;\r\n            escaped = false;\r\n        }\r\n        end = index;\r\n        index++;\r\n    } else {\r\n        for (; index < length; index++) {\r\n            if (isMetaChar(expr[index]))\r\n                break;\r\n        }\r\n        end = index;\r\n    }\r\n    this.tokenVal = new String(expr, start, end - start);\r\n    return TOKEN_STRING;\r\n}"
}, {
	"Path": "org.apache.catalina.startup.UserConfig.getHomeBase",
	"Comment": "return the base directory containing user home directories.",
	"Method": "String getHomeBase(){\r\n    return (this.homeBase);\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Request.isAsyncStarted",
	"Comment": "checks whether async processing has started on this request.",
	"Method": "boolean isAsyncStarted(){\r\n    return asyncStarted.get();\r\n}"
}, {
	"Path": "org.apache.catalina.core.StandardHostDeployer.deleteDir",
	"Comment": "delete the specified directory, including all of its contents andsubdirectories recursively.",
	"Method": "void deleteDir(File dir){\r\n    String[] files = dir.list();\r\n    if (files == null) {\r\n        files = new String[0];\r\n    }\r\n    for (int i = 0; i < files.length; i++) {\r\n        File file = new File(dir, files[i]);\r\n        if (file.isDirectory()) {\r\n            deleteDir(file);\r\n        } else {\r\n            deleteFile(file);\r\n        }\r\n    }\r\n    deleteFile(dir);\r\n}"
}, {
	"Path": "org.glassfish.weld.connector.WeldUtils.hasValidAnnotation",
	"Comment": "determine whether the specified class is annotated with one of the annotations in the specifiedvalidscopes collection, but not with any of the annotations in the specified exclusion set.",
	"Method": "boolean hasValidAnnotation(Class annotatedClass,Collection<String> validScopes,Collection<String> excludedScopes){\r\n    boolean result = false;\r\n    for (Annotation annotation : annotatedClass.getAnnotations()) {\r\n        if (WeldUtils.isValidAnnotation(annotation.annotationType(), validScopes, excludedScopes)) {\r\n            result = true;\r\n            break;\r\n        }\r\n    }\r\n    return result;\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.servermgmt.stringsubs.impl.ArchiveEntryWrapperImpl.extract",
	"Comment": "extract all the substitutable entries for an archive.it also takes care of extracting substitutable entriesfrom nested archives.",
	"Method": "void extract(){\r\n    for (Object object : _archive.getArchiveOrMemberEntry()) {\r\n        String extratFilePath = _extractDir.getAbsolutePath() + File.separator;\r\n        if (object instanceof Archive) {\r\n            Archive archive = (Archive) object;\r\n            File file = new File(extratFilePath + archive.getName());\r\n            try {\r\n                extractEntry(archive.getName(), file);\r\n            } catch (IllegalArgumentException e) {\r\n                continue;\r\n            }\r\n            _extractedEntries.put(archive.getName(), file);\r\n            new ArchiveEntryWrapperImpl(archive, extratFilePath, this);\r\n            _noOfExtractedEntries.incrementAndGet();\r\n        } else if (object instanceof MemberEntry) {\r\n            MemberEntry entry = (MemberEntry) object;\r\n            File file = new File(extratFilePath + entry.getName());\r\n            try {\r\n                extractEntry(entry.getName(), file);\r\n            } catch (IllegalArgumentException e) {\r\n                continue;\r\n            }\r\n            _extractedEntries.put(entry.getName(), file);\r\n            getAllArchiveMemberList().add(new ArchiveMemberHandler(file, this));\r\n            _noOfExtractedEntries.incrementAndGet();\r\n        } else {\r\n            _logger.log(Level.WARNING, SLogger.INVALID_ARCHIVE_ENTRY, new Object[] { object, _archive.getName() });\r\n        }\r\n    }\r\n}"
}, {
	"Path": "components.taglib.GraphMenuTreeTag.setValue",
	"Comment": "value binding reference expression that points to a graph in scopednamespace.",
	"Method": "void setValue(String newValue){\r\n    value = newValue;\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.VerifierTest.getDeclaredMethod",
	"Comment": "utility method to return a method if it is implemented by a class or oneof its superclass irrespective of the method being public, private or protected",
	"Method": "Method getDeclaredMethod(Class clazz,String methodName,Class[] parmTypes){\r\n    Method m = null;\r\n    Class c = clazz;\r\n    do {\r\n        try {\r\n            m = clazz.getDeclaredMethod(methodName, parmTypes);\r\n        } catch (NoSuchMethodException nsme) {\r\n        } catch (SecurityException se) {\r\n        }\r\n        c = c.getSuperclass();\r\n    } while (m != null && c != null);\r\n    return m;\r\n}"
}, {
	"Path": "com.sun.enterprise.universal.glassfish.GFSystemTest.threadTest",
	"Comment": "test of gfsystem for the case where there are multiple instances in a jvm",
	"Method": "void threadTest(){\r\n    try {\r\n        Thread t1 = new ParentThread(\"xxx\");\r\n        Thread t2 = new ParentThread(\"yyy\");\r\n        Thread t3 = new ParentThread(\"zzz\");\r\n        t1.start();\r\n        t2.start();\r\n        t3.start();\r\n        t1.join();\r\n        t2.join();\r\n        t3.join();\r\n    } catch (InterruptedException ex) {\r\n        Logger.getLogger(GFSystemTest.class.getName()).log(Level.SEVERE, null, ex);\r\n    }\r\n    assertFalse(failed);\r\n}"
}, {
	"Path": "com.sun.enterprise.admin.cli.cluster.StopLocalInstanceCommand.noSuchInstance",
	"Comment": "print message and return exit code whenwe detect that there is no such instance",
	"Method": "int noSuchInstance(){\r\n    logger.warning(Strings.get(\"Instance.noSuchInstance\"));\r\n    return 0;\r\n}"
}, {
	"Path": "com.sun.jts.CosTransactions.LogHandle.freeFileStorage",
	"Comment": "frees file storage for the file.this internal method does not need to be synchronized.",
	"Method": "void freeFileStorage(LogLSN tailLSN){\r\n    int bytesToClear = tailLSN.offset;\r\n    if (bytesToClear == 0) {\r\n        return;\r\n    }\r\n    LogLSN startOfExtent = new LogLSN(tailLSN.extent, 0);\r\n    LogExtent logEDP = positionFilePointer(startOfExtent, 0, LogExtent.ACCESSTYPE_UNKNOWN);\r\n    logEDP.fileHandle.fileSync();\r\n}"
}, {
	"Path": "org.apache.catalina.connector.Connector.setAllowTrace",
	"Comment": "set the allowtrace flag, to disable or enable the trace http method.",
	"Method": "void setAllowTrace(boolean allowTrace){\r\n    this.allowTrace = allowTrace;\r\n    setProperty(\"allowTrace\", String.valueOf(allowTrace));\r\n}"
}, {
	"Path": "org.apache.catalina.realm.RealmBase.setContainer",
	"Comment": "set the container with which this realm has been associated.",
	"Method": "void setContainer(Container container){\r\n    Container oldContainer = this.container;\r\n    this.container = container;\r\n    this.checkIfRequestIsSecure = container.isCheckIfRequestIsSecure();\r\n    support.firePropertyChange(\"container\", oldContainer, this.container);\r\n}"
}, {
	"Path": "org.glassfish.common.util.timer.TimerSchedule.parseYears",
	"Comment": "preprocess data that represents years.input data can be one or more positive number, or a range of them.",
	"Method": "void parseYears(){\r\n    if (year_.equals(\"*\")) {\r\n        return;\r\n    }\r\n    if (year_.indexOf(',') > 0) {\r\n        String[] arr = splitList(year_);\r\n        for (int i = 0; i < arr.length; i++) {\r\n            if (arr[i].indexOf(rangeChar, 1) > 0) {\r\n                processRangeAsList(years, arr[i], YEAR, yearPattern);\r\n            } else {\r\n                years.add(assertValidYear(parseInt(arr[i], YEAR)));\r\n            }\r\n        }\r\n        Collections.sort(years);\r\n        return;\r\n    }\r\n    if (year_.indexOf(rangeChar, 1) > 0) {\r\n        processRangeAsList(years, year_, YEAR, yearPattern);\r\n        return;\r\n    }\r\n    years.add(assertValidYear(parseInt(year_, YEAR)));\r\n}"
}, {
	"Path": "com.sun.enterprise.tools.verifier.tests.ejb.homeintf.remotehomeintf.RemoteHomeInterfaceRmiIIOPReturn.runIndividualHomeMethodTest",
	"Comment": "run an individual verifier test against a declared method of the remote interface.",
	"Method": "void runIndividualHomeMethodTest(Method method,EjbDescriptor descriptor,Result result){\r\n    ComponentNameConstructor compName = getVerifierContext().getComponentNameConstructor();\r\n    Class methodReturnType = method.getReturnType();\r\n    if (RmiIIOPUtils.isValidRmiIIOPReturnType(methodReturnType)) {\r\n        addGoodDetails(result, compName);\r\n        result.passed(smh.getLocalString(getClass().getName() + \".passed\", \"[ {0} ] properly declares method with valid RMI-IIOP return type.\", new Object[] { method.getDeclaringClass().getName() }));\r\n    } else {\r\n        addErrorDetails(result, compName);\r\n        result.failed(smh.getLocalString(getClass().getName() + \".failed\", \"Error: [ {0} ] method was found, but does not have valid \" + \"RMI-IIOP return type.\", new Object[] { method.getName() }));\r\n    }\r\n}"
}, {
	"Path": "org.glassfish.web.deployment.descriptor.WebBundleDescriptorImpl.getResourceReferences",
	"Comment": "return an enumeration of references to resources that i have.",
	"Method": "Enumeration<ResourceReferenceDescriptor> getResourceReferences(){\r\n    return (new Vector<ResourceReferenceDescriptor>(getResourceReferenceDescriptors())).elements();\r\n}"
}]