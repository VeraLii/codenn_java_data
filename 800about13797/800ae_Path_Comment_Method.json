[{"Path":"io.helidon.common.reactive.valve.Tank.put","Comment":"inserts the specified element at the tail of this queue, waitingfor space to become available if the queue is full.","Method":"void put(T t){\r\n    checkClosed();\r\n    queue.put(t);\r\n    tryProcess();\r\n}"}, {"Path":"io.helidon.microprofile.metrics.cdi.MetricsCdiExtension.registerProducers","Comment":"registers metrics for all field and method producers defined by the application.","Method":"void registerProducers(AfterDeploymentValidation adv,BeanManager bm){\r\n    LOGGER.log(Level.FINE, () -> \"### registerProducers\");\r\n    MetricRegistry registry = getMetricRegistry();\r\n    producers.entrySet().forEach(entry -> {\r\n        Metric metric = entry.getValue().getAnnotation(Metric.class);\r\n        if (metric != null) {\r\n            String metricName = getMetricName(new AnnotatedElementWrapper(entry.getValue()), entry.getValue().getDeclaringType().getJavaClass(), MetricUtil.MatchingType.METHOD, metric.name(), metric.absolute());\r\n            registry.register(metricName, getReference(bm, entry.getValue().getBaseType(), entry.getKey()));\r\n        }\r\n    });\r\n    producers.clear();\r\n}"}, {"Path":"io.helidon.security.examples.jersey.JerseyProgrammaticMain.main","Comment":"main method of example. no arguments required, no configuration required.","Method":"void main(String[] args){\r\n    Routing.Builder routing = Routing.builder().register(\"/rest\", buildJersey());\r\n    server = JerseyUtil.startIt(routing);\r\n    JerseyResources.setPort(server.port());\r\n}"}, {"Path":"io.helidon.common.GenericType.create","Comment":"constructs a new generic type, using the provided generic type information andderiving the class.","Method":"GenericType<N> create(Type genericType){\r\n    Objects.requireNonNull(genericType);\r\n    return new GenericType(genericType, GenericTypeUtil.rawClass(genericType));\r\n}"}, {"Path":"org.hl7.fhir.utilities.IniFile.getPropertyNames","Comment":"returns a string array containing names of all the properties under specified section.","Method":"String[] getPropertyNames(String pstrSection){\r\n    String[] arrRet = null;\r\n    INISection objSec = null;\r\n    objSec = (INISection) this.mhmapSections.get(pstrSection);\r\n    if (objSec != null) {\r\n        arrRet = objSec.getPropNames();\r\n        objSec = null;\r\n    }\r\n    return arrRet;\r\n}"}, {"Path":"io.helidon.metrics.EWMA.oneMinuteEWMA","Comment":"creates a new ewma which is equivalent to the unix one minute load average and which expectsto be ticked every 5 seconds.","Method":"EWMA oneMinuteEWMA(){\r\n    return new EWMA(M1_ALPHA, INTERVAL, TimeUnit.SECONDS);\r\n}"}, {"Path":"org.hl7.fhir.dstu3.hapi.validation.FhirInstanceValidatorDstu3Test.testInvalidLocalReference","Comment":"an invalid local reference should not cause a serviceexception.","Method":"void testInvalidLocalReference(){\r\n    Questionnaire resource = new Questionnaire();\r\n    resource.setStatus(PublicationStatus.ACTIVE);\r\n    QuestionnaireItemComponent item = new QuestionnaireItemComponent();\r\n    item.setLinkId(\"linkId-1\");\r\n    item.setType(QuestionnaireItemType.CHOICE);\r\n    item.setOptions(new Reference(\"#invalid-ref\"));\r\n    resource.addItem(item);\r\n    ValidationResult output = myVal.validateWithResult(resource);\r\n    List<SingleValidationMessage> nonInfo = logResultsAndReturnNonInformationalOnes(output);\r\n    assertThat(nonInfo, hasSize(2));\r\n}"}, {"Path":"io.helidon.common.configurable.ThreadPoolSupplier.builder","Comment":"create a new fluent api builder to build thread pool supplier.","Method":"Builder builder(){\r\n    return new Builder();\r\n}"}, {"Path":"io.helidon.metrics.MetricsSupport.create","Comment":"create an instance to be registered with web server maybe overriding default values withconfigured values.","Method":"MetricsSupport create(MetricsSupport create,Config config){\r\n    if (metricsSupport == null) {\r\n        metricsSupport = builder().config(config).build();\r\n    }\r\n    return metricsSupport;\r\n}"}, {"Path":"io.helidon.microprofile.faulttolerance.CommandInterceptor.interceptCommand","Comment":"intercepts a call to bean method annotated by any of the fault toleranceannotations.","Method":"Object interceptCommand(InvocationContext context){\r\n    try {\r\n        LOGGER.fine(\"Interceptor called for '\" + context.getTarget().getClass() + \"::\" + context.getMethod().getName() + \"'\");\r\n        final MethodIntrospector introspector = new MethodIntrospector(context.getMethod());\r\n        final CommandRetrier retrier = new CommandRetrier(context, introspector);\r\n        return retrier.execute();\r\n    } catch (Throwable t) {\r\n        LOGGER.fine(\"Throwable caught by interceptor '\" + t.getMessage() + \"'\");\r\n        throw t;\r\n    }\r\n}"}, {"Path":"io.helidon.security.examples.webserver.digest.DigestExampleBuilderMain.main","Comment":"starts this example. programmatical configuration. see standard output for instructions.","Method":"void main(String[] args){\r\n    LogManager.getLogManager().readConfiguration(DigestExampleConfigMain.class.getResourceAsStream(\"/logging.properties\"));\r\n    Routing routing = // audit is not enabled for GET methods by default\r\n    Routing.builder().register(buildWebSecurity().securityDefaults(WebSecurity.authenticate())).get(\"/noRoles\", WebSecurity.enforce()).get(\"/user[/{*}]\", WebSecurity.rolesAllowed(\"user\")).get(\"/admin\", WebSecurity.rolesAllowed(\"admin\")).get(\"/deny\", // roles allowed imply authn and authz\r\n    WebSecurity.rolesAllowed(\"deny\").audit()).any(\"/noAuthn\", WebSecurity.rolesAllowed(\"admin\").authenticationOptional().audit()).get(\"/{*}\", (req, res) -> {\r\n        Optional<SecurityContext> securityContext = req.context().get(SecurityContext.class);\r\n        res.headers().contentType(MediaType.TEXT_PLAIN.withCharset(\"UTF-8\"));\r\n        res.send(\"Hello, you are: \\n\" + securityContext.map(ctx -> ctx.getUser().orElse(SecurityContext.ANONYMOUS).toString()).orElse(\"Security context is null\"));\r\n    }).build();\r\n    server = DigestExampleUtil.startServer(routing);\r\n}"}, {"Path":"org.hl7.fhir.utilities.cache.NpmPackage.load","Comment":"get a stream that contains the contents of one of the files in a folder","Method":"InputStream load(String folder,String file){\r\n    if (content.containsKey(folder + \"/\" + file))\r\n        return new ByteArrayInputStream(content.get(folder + \"/\" + file));\r\n    else {\r\n        File f = new File(Utilities.path(path, folder, file));\r\n        if (f.exists())\r\n            return new FileInputStream(f);\r\n        throw new IOException(\"Unable to find the file \" + folder + \"/\" + file + \" in the package \" + name());\r\n    }\r\n}"}, {"Path":"io.helidon.config.internal.FileSourceHelper.digest","Comment":"returns an md5 digest of the specified file or null if the file cannot be read.","Method":"byte[] digest(Path path){\r\n    MessageDigest md;\r\n    try {\r\n        md = MessageDigest.getInstance(\"MD5\");\r\n    } catch (NoSuchAlgorithmException e) {\r\n        throw new ConfigException(\"Cannot get MD5 algorithm.\", e);\r\n    }\r\n    try {\r\n        try (InputStream is = Files.newInputStream(path);\r\n            DigestInputStream dis = new DigestInputStream(is, md)) {\r\n            byte[] buffer = new byte[4096];\r\n            while (dis.read(buffer) != -1) {\r\n            }\r\n        }\r\n    } catch (IOException e) {\r\n        LOGGER.log(Level.FINEST, \"Cannot get a digest.\", e);\r\n        return null;\r\n    }\r\n    return md.digest();\r\n}"}, {"Path":"com.twitter.hbc.common.DelimitedStreamReader.read","Comment":"reads numbytes bytes, and returns the corresponding string","Method":"String read(int numBytes){\r\n    Preconditions.checkArgument(numBytes >= 0);\r\n    Preconditions.checkArgument(numBytes <= MAX_ALLOWABLE_BUFFER_SIZE);\r\n    int numBytesRemaining = numBytes;\r\n    if (!isReadBufferEmpty()) {\r\n        int length = Math.min(end - offset, numBytesRemaining);\r\n        copyToStrBuffer(buffer, offset, length);\r\n        offset += length;\r\n        numBytesRemaining -= length;\r\n    }\r\n    if (numBytesRemaining > 0) {\r\n        readAmountToStrBuffer(numBytesRemaining);\r\n    }\r\n    if (strBufferIndex > 0 && strBuffer[strBufferIndex - 1] != LF) {\r\n        return readLine(false);\r\n    }\r\n    int strBufferLength = strBufferIndex;\r\n    strBufferIndex = 0;\r\n    return new String(strBuffer, 0, strBufferLength, charset);\r\n}"}, {"Path":"io.helidon.security.examples.jersey.JerseyBuilderMain.main","Comment":"main method of example. no arguments required, no configuration required.","Method":"void main(String[] args){\r\n    Routing.Builder routing = Routing.builder().register(\"/rest\", buildJersey());\r\n    server = JerseyUtil.startIt(routing);\r\n    JerseyResources.setPort(server.port());\r\n}"}, {"Path":"io.helidon.config.internal.ValueNodeImpl.initDescription","Comment":"initialize diagnostics description of source of node instance.","Method":"ValueNodeImpl initDescription(String description){\r\n    this.description = description;\r\n    return this;\r\n}"}, {"Path":"org.hl7.fhir.r4.utils.FHIRPathEngine.evaluateDefinition","Comment":"given an element definition in a profile, what element contains the differentiating fixed for the element, given the differentiating expresssion. the expression is only allowed to use a subset of fhirpath","Method":"ElementDefinition evaluateDefinition(ExpressionNode expr,StructureDefinition profile,ElementDefinition element){\r\n    StructureDefinition sd = profile;\r\n    ElementDefinition focus = null;\r\n    if (expr.getKind() == Kind.Name) {\r\n        List<ElementDefinition> childDefinitions;\r\n        childDefinitions = ProfileUtilities.getChildMap(sd, element);\r\n        if (childDefinitions.isEmpty()) {\r\n            sd = fetchStructureByType(element);\r\n            if (sd == null)\r\n                throw new DefinitionException(\"Problem with use of resolve() - profile '\" + element.getType().get(0).getProfile() + \"' on \" + element.getId() + \" could not be resolved\");\r\n            childDefinitions = ProfileUtilities.getChildMap(sd, sd.getSnapshot().getElementFirstRep());\r\n        }\r\n        for (ElementDefinition t : childDefinitions) {\r\n            if (tailMatches(t, expr.getName())) {\r\n                focus = t;\r\n                break;\r\n            }\r\n        }\r\n    } else if (expr.getKind() == Kind.Function) {\r\n        if (\"resolve\".equals(expr.getName())) {\r\n            if (!element.hasType())\r\n                throw new DefinitionException(\"illegal use of resolve() in discriminator - no type on element \" + element.getId());\r\n            if (element.getType().size() > 1)\r\n                throw new DefinitionException(\"illegal use of resolve() in discriminator - Multiple possible types on \" + element.getId());\r\n            if (!element.getType().get(0).hasTarget())\r\n                throw new DefinitionException(\"illegal use of resolve() in discriminator - type on \" + element.getId() + \" is not Reference (\" + element.getType().get(0).getCode() + \")\");\r\n            if (element.getType().get(0).getTargetProfile().size() > 1)\r\n                throw new DefinitionException(\"illegal use of resolve() in discriminator - Multiple possible target type profiles on \" + element.getId());\r\n            sd = worker.fetchResource(StructureDefinition.class, element.getType().get(0).getTargetProfile().get(0).getValue());\r\n            if (sd == null)\r\n                throw new DefinitionException(\"Problem with use of resolve() - profile '\" + element.getType().get(0).getTargetProfile() + \"' on \" + element.getId() + \" could not be resolved\");\r\n            focus = sd.getSnapshot().getElementFirstRep();\r\n        } else if (\"extension\".equals(expr.getName())) {\r\n            String targetUrl = expr.getParameters().get(0).getConstant().primitiveValue();\r\n            List<ElementDefinition> childDefinitions = ProfileUtilities.getChildMap(sd, element);\r\n            for (ElementDefinition t : childDefinitions) {\r\n                if (t.getPath().endsWith(\".extension\") && t.hasSliceName()) {\r\n                    sd = worker.fetchResource(StructureDefinition.class, t.getType().get(0).getProfile().get(0).getValue());\r\n                    while (sd != null && !sd.getBaseDefinition().equals(\"http://hl7.org/fhir/StructureDefinition/Extension\")) sd = worker.fetchResource(StructureDefinition.class, sd.getBaseDefinition());\r\n                    if (sd.getUrl().equals(targetUrl)) {\r\n                        focus = t;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        } else\r\n            throw new DefinitionException(\"illegal function name \" + expr.getName() + \"() in discriminator\");\r\n    } else if (expr.getKind() == Kind.Group) {\r\n        throw new DefinitionException(\"illegal expression syntax in discriminator (group)\");\r\n    } else if (expr.getKind() == Kind.Constant) {\r\n        throw new DefinitionException(\"illegal expression syntax in discriminator (const)\");\r\n    }\r\n    if (focus == null)\r\n        throw new DefinitionException(\"Unable to resolve discriminator\");\r\n    else if (expr.getInner() == null)\r\n        return focus;\r\n    else\r\n        return evaluateDefinition(expr.getInner(), sd, focus);\r\n}"}, {"Path":"org.hl7.fhir.r4.validation.InstanceValidator.start","Comment":"the instance validator had no issues against the base resource profile","Method":"void start(ValidatorHostContext hostContext,List<ValidationMessage> errors,Element resource,Element element,StructureDefinition defn,NodeStack stack){\r\n    ResourceProfiles resourceProfiles = getResourceProfiles(element, stack);\r\n    if (!resourceProfiles.isProcessed())\r\n        checkDeclaredProfiles(resourceProfiles, errors, resource, element, stack);\r\n    if (!resourceProfiles.isProcessed()) {\r\n        resourceProfiles.setProcessed();\r\n        if (!resourceProfiles.hasProfiles() && (rule(errors, IssueType.STRUCTURE, element.line(), element.col(), stack.getLiteralPath(), defn.hasSnapshot(), \"StructureDefinition has no snapshot - validation is against the snapshot, so it must be provided\"))) {\r\n            validateElement(hostContext, errors, defn, defn.getSnapshot().getElement().get(0), null, null, resource, element, element.getName(), stack, false);\r\n        }\r\n        if (element.getType().equals(\"Bundle\"))\r\n            validateBundle(errors, element, stack);\r\n        else if (element.getType().equals(\"Observation\"))\r\n            validateObservation(errors, element, stack);\r\n        else if (element.getType().equals(\"QuestionnaireResponse\"))\r\n            validateQuestionannaireResponse(errors, element, stack);\r\n        else if (element.getType().equals(\"CodeSystem\"))\r\n            validateCodeSystem(errors, element, stack);\r\n    }\r\n    for (ProfileUsage profileUsage : resourceProfiles.uncheckedProfiles()) {\r\n        profileUsage.setChecked();\r\n        validateElement(hostContext, errors, profileUsage.getProfile(), profileUsage.getProfile().getSnapshot().getElement().get(0), null, null, resource, element, element.getName(), stack, false);\r\n    }\r\n}"}, {"Path":"io.helidon.config.AbstractConfigImpl.waitForSubscription","Comment":"we should wait for a subscription, otherwise, we might miss some changes.","Method":"void waitForSubscription(long timeout,TimeUnit unit){\r\n    CountDownLatch subscribeLatch = new CountDownLatch(1);\r\n    subscriber = new Flow.Subscriber<ConfigDiff>() {\r\n        @Override\r\n        public void onSubscribe(Flow.Subscription subscription) {\r\n            subscription.request(Long.MAX_VALUE);\r\n            subscribeLatch.countDown();\r\n        }\r\n        @Override\r\n        public void onNext(ConfigDiff item) {\r\n        }\r\n        @Override\r\n        public void onError(Throwable throwable) {\r\n            LOGGER.log(Level.CONFIG, \"Error while subscribing a supplier to the changes.\", throwable);\r\n        }\r\n        @Override\r\n        public void onComplete() {\r\n            LOGGER.log(Level.CONFIG, \"The config suppliers will no longer receive any change.\");\r\n        }\r\n    };\r\n    factory.getProvider().changes().subscribe(subscriber);\r\n    try {\r\n        subscribeLatch.await(timeout, unit);\r\n    } catch (InterruptedException e) {\r\n        LOGGER.log(Level.CONFIG, \"Waiting for a supplier subscription has been interrupted.\", e);\r\n        Thread.currentThread().interrupt();\r\n    }\r\n}"}, {"Path":"io.helidon.config.AbstractConfigImpl.waitForSubscription","Comment":"we should wait for a subscription, otherwise, we might miss some changes.","Method":"void waitForSubscription(long timeout,TimeUnit unit){\r\n    subscription.request(Long.MAX_VALUE);\r\n    subscribeLatch.countDown();\r\n}"}, {"Path":"io.helidon.config.AbstractConfigImpl.waitForSubscription","Comment":"we should wait for a subscription, otherwise, we might miss some changes.","Method":"void waitForSubscription(long timeout,TimeUnit unit){\r\n}"}, {"Path":"io.helidon.config.AbstractConfigImpl.waitForSubscription","Comment":"we should wait for a subscription, otherwise, we might miss some changes.","Method":"void waitForSubscription(long timeout,TimeUnit unit){\r\n    LOGGER.log(Level.CONFIG, \"Error while subscribing a supplier to the changes.\", throwable);\r\n}"}, {"Path":"io.helidon.config.AbstractConfigImpl.waitForSubscription","Comment":"we should wait for a subscription, otherwise, we might miss some changes.","Method":"void waitForSubscription(long timeout,TimeUnit unit){\r\n    LOGGER.log(Level.CONFIG, \"The config suppliers will no longer receive any change.\");\r\n}"}, {"Path":"io.helidon.config.Config.mapList","Comment":"returns typed list of type provided by specified config hierarchymapper.","Method":"List<T> mapList(ConfigMapper<? extends T> mapper,List<T> mapList,ConfigMapper<? extends T> mapper,List<T> defaultValue,List<T> mapList,Function<String, ? extends T> mapper,List<T> mapList,Function<String, ? extends T> mapper,List<T> defaultValue){\r\n    return this.<T>mapOptionalList(mapper).orElse(defaultValue);\r\n}"}, {"Path":"org.hl7.fhir.utilities.IniFile.getIntegerProperty","Comment":"returns the specified integer property from the specified section.","Method":"Integer getIntegerProperty(String pstrSection,String pstrProp){\r\n    Integer intRet = null;\r\n    String strVal = null;\r\n    INIProperty objProp = null;\r\n    INISection objSec = null;\r\n    objSec = (INISection) this.mhmapSections.get(pstrSection);\r\n    if (objSec != null) {\r\n        objProp = objSec.getProperty(pstrProp);\r\n        try {\r\n            if (objProp != null) {\r\n                strVal = objProp.getPropValue();\r\n                if (strVal != null)\r\n                    intRet = new Integer(strVal);\r\n            }\r\n        } catch (NumberFormatException NFExIgnore) {\r\n        } finally {\r\n            if (objProp != null)\r\n                objProp = null;\r\n        }\r\n        objSec = null;\r\n    }\r\n    return intRet;\r\n}"}, {"Path":"org.hl7.fhir.r4.utils.client.EFhirClientException.hasServerErrors","Comment":"method returns true if exception contains server operationoutcome errors in payload.","Method":"boolean hasServerErrors(){\r\n    return errors.size() > 0;\r\n}"}, {"Path":"io.helidon.config.PollingStrategies.regular","Comment":"provides a scheduled polling strategy with a specified constant interval.","Method":"ScheduledBuilder regular(Duration interval){\r\n    return new ScheduledBuilder(new RegularRecurringPolicy(interval));\r\n}"}, {"Path":"io.helidon.config.etcd.internal.client.EtcdClientException.isHttpError","Comment":"checks if the exception reason was unexpected http response code.","Method":"boolean isHttpError(){\r\n    return httpStatusCode != -1;\r\n}"}, {"Path":"io.helidon.microprofile.faulttolerance.CommandRetrier.retryExecute","Comment":"creates a new command for each retry since hystrix commands can only beexecuted once. fallback method is not overridden here to ensure allretries are executed.","Method":"Object retryExecute(){\r\n    final String commandKey = createCommandKey();\r\n    command = new FaultToleranceCommand(commandKey, introspector, context);\r\n    Object result;\r\n    try {\r\n        LOGGER.info(\"About to execute command with key \" + command.getCommandKey());\r\n        updateMetricsBefore();\r\n        result = command.execute();\r\n        updateMetricsAfter(null);\r\n    } catch (HystrixRuntimeException e) {\r\n        Throwable cause = e.getCause();\r\n        updateMetricsAfter(cause);\r\n        if (cause instanceof TimeoutException) {\r\n            throw new org.eclipse.microprofile.faulttolerance.exceptions.TimeoutException(cause);\r\n        }\r\n        if (cause instanceof RejectedExecutionException) {\r\n            throw new BulkheadException(cause);\r\n        }\r\n        if (!(cause instanceof RuntimeException)) {\r\n            cause = new RuntimeException(cause);\r\n        }\r\n        if (command.isCircuitBreakerOpen()) {\r\n            throw new CircuitBreakerOpenException(cause);\r\n        }\r\n        throw (RuntimeException) cause;\r\n    }\r\n    return result;\r\n}"}, {"Path":"io.helidon.metrics.EWMA.tick","Comment":"mark the passage of time and decay the current rate accordingly.","Method":"void tick(){\r\n    final long count = uncounted.sumThenReset();\r\n    final double instantRate = count / interval;\r\n    if (initialized) {\r\n        double currentRate = rate;\r\n        currentRate += (alpha * (instantRate - currentRate));\r\n        rate = currentRate;\r\n    } else {\r\n        rate = instantRate;\r\n        initialized = true;\r\n    }\r\n}"}, {"Path":"io.helidon.microprofile.metrics.cdi.InterceptorBase.getClass","Comment":"returns class for this context. there is no target for constructors.","Method":"Class<?> getClass(InvocationContext context,E element){\r\n    return context.getTarget() != null ? MetricsCdiExtension.getRealClass(context.getTarget()) : element.getDeclaringClass();\r\n}"}, {"Path":"io.helidon.config.etcd.internal.client.EtcdUtils.getClientClass","Comment":"returns an implementation class of etcd client for given etcd api version.","Method":"Class<? extends EtcdClient> getClientClass(EtcdApi etcdApiVersion){\r\n    return ETCD_API_VERSION_CLASS_MAP.get(etcdApiVersion);\r\n}"}, {"Path":"ca.uhn.example.provider.PatientResourceProvider.addNewVersion","Comment":"stores a new version of the patient in memory so that it can be retrieved later.","Method":"void addNewVersion(Patient thePatient,Long theId){\r\n    InstantDt publishedDate;\r\n    if (!myIdToPatientVersions.containsKey(theId)) {\r\n        myIdToPatientVersions.put(theId, new LinkedList<Patient>());\r\n        publishedDate = InstantDt.withCurrentTime();\r\n    } else {\r\n        Patient currentPatitne = myIdToPatientVersions.get(theId).getLast();\r\n        Map<ResourceMetadataKeyEnum<?>, Object> resourceMetadata = currentPatitne.getResourceMetadata();\r\n        publishedDate = (InstantDt) resourceMetadata.get(ResourceMetadataKeyEnum.PUBLISHED);\r\n    }\r\n    thePatient.getResourceMetadata().put(ResourceMetadataKeyEnum.PUBLISHED, publishedDate);\r\n    thePatient.getResourceMetadata().put(ResourceMetadataKeyEnum.UPDATED, InstantDt.withCurrentTime());\r\n    Deque<Patient> existingVersions = myIdToPatientVersions.get(theId);\r\n    String newVersion = Integer.toString(existingVersions.size());\r\n    IdDt newId = new IdDt(\"Patient\", Long.toString(theId), newVersion);\r\n    thePatient.setId(newId);\r\n    existingVersions.add(thePatient);\r\n}"}, {"Path":"io.helidon.common.configurable.ScheduledThreadPoolSupplier.builder","Comment":"create a new fluent api builder to build thread pool supplier.","Method":"Builder builder(){\r\n    return new Builder();\r\n}"}, {"Path":"io.helidon.demo.todos.backend.DbService.startSpan","Comment":"utility method to create and start a child span of the given span.","Method":"Span startSpan(SpanContext span,String operation){\r\n    return GlobalTracer.get().buildSpan(operation).asChildOf(span).start();\r\n}"}, {"Path":"io.helidon.microprofile.health.HealthEndpoint.toJson","Comment":"converts an outcome and list of responses into a properly formed json document.","Method":"JsonObject toJson(HealthCheckResponse.State outcome,List<HealthCheckResponse> responses){\r\n    if (outcome == null || responses == null) {\r\n        throw new NullPointerException();\r\n    }\r\n    final JsonObjectBuilder jsonBuilder = Json.createObjectBuilder().add(\"outcome\", outcome.toString());\r\n    final JsonArrayBuilder checkArrayBuilder = Json.createArrayBuilder();\r\n    if (!responses.isEmpty()) {\r\n        for (HealthCheckResponse r : responses) {\r\n            final JsonObjectBuilder checkBuilder = Json.createObjectBuilder();\r\n            checkBuilder.add(\"name\", r.getName());\r\n            checkBuilder.add(\"state\", r.getState().toString());\r\n            Optional<Map<String, Object>> data = r.getData();\r\n            data.ifPresent(m -> checkBuilder.add(\"data\", Json.createObjectBuilder(m)));\r\n            checkArrayBuilder.add(checkBuilder);\r\n        }\r\n    }\r\n    jsonBuilder.add(\"checks\", checkArrayBuilder);\r\n    return jsonBuilder.build();\r\n}"}, {"Path":"org.hl7.fhir.utilities.Inflector.getUncountables","Comment":"get the set of words that are not processed by the inflector. the resulting map is directly modifiable.","Method":"Set<String> getUncountables(){\r\n    return uncountables;\r\n}"}, {"Path":"ca.uhn.example.provider.PatientResourceProvider.validateResource","Comment":"this method just provides simple business validation for resources we are storing.","Method":"void validateResource(Patient thePatient){\r\n    if (thePatient.getNameFirstRep().getFamilyFirstRep().isEmpty()) {\r\n        OperationOutcome outcome = new OperationOutcome();\r\n        outcome.addIssue().setSeverity(IssueSeverityEnum.FATAL).setDetails(\"No family name provided, Patient resources must have at least one family name.\");\r\n        throw new UnprocessableEntityException(outcome);\r\n    }\r\n}"}, {"Path":"io.helidon.security.abac.time.TimeValidator.create","Comment":"return a new instance of this validator with default configuration.","Method":"TimeValidator create(){\r\n    return new TimeValidator();\r\n}"}, {"Path":"io.helidon.microprofile.example.idcs.IdcsResource.login","Comment":"a login flow example to use from a html frontend. a login button would call this method with aquery parameter with redirect to the first page.","Method":"String login(SecurityContext context,Response login,SecurityContext context,String redirectTo){\r\n    return Response.status(Response.Status.TEMPORARY_REDIRECT).header(\"Location\", redirectTo).build();\r\n}"}, {"Path":"io.helidon.microprofile.faulttolerance.MethodAntn.lookupAnnotation","Comment":"returns underlying annotation and info as to how it was found.","Method":"LookupResult<A> lookupAnnotation(Class<A> clazz,LookupResult<A> lookupAnnotation,Method method,Class<A> clazz){\r\n    A annotation = method.getAnnotation(clazz);\r\n    if (annotation != null) {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.fine(\"Found annotation '\" + clazz.getName() + \"' method '\" + method.getName() + \"'\");\r\n        }\r\n        return new LookupResult(MatchingType.METHOD, annotation);\r\n    }\r\n    annotation = method.getDeclaringClass().getAnnotation(clazz);\r\n    if (annotation != null) {\r\n        if (LOGGER.isLoggable(Level.FINE)) {\r\n            LOGGER.fine(\"Found annotation '\" + clazz.getName() + \"' class '\" + method.getDeclaringClass().getName() + \"'\");\r\n        }\r\n        return new LookupResult(MatchingType.CLASS, annotation);\r\n    }\r\n    return null;\r\n}"}, {"Path":"ca.uhn.fhir.rest.server.SearchSearchServerDstu1Test.testGetPagesWithPost","Comment":"try loading the page as a post just to make sure we get the right error","Method":"void testGetPagesWithPost(){\r\n    HttpPost httpPost = new HttpPost(\"http://localhost:\" + ourPort);\r\n    List<? extends NameValuePair> parameters = Collections.singletonList(new BasicNameValuePair(\"_getpages\", \"AAA\"));\r\n    httpPost.setEntity(new UrlEncodedFormEntity(parameters));\r\n    CloseableHttpResponse status = ourClient.execute(httpPost);\r\n    String responseContent = IOUtils.toString(status.getEntity().getContent());\r\n    IOUtils.closeQuietly(status.getEntity().getContent());\r\n    ourLog.info(responseContent);\r\n    assertEquals(400, status.getStatusLine().getStatusCode());\r\n}"}, {"Path":"org.hl7.fhir.r4.utils.client.EFhirClientException.getServerErrors","Comment":"method returns all operationoutcome server errors that are \tassociated with this exception.","Method":"List<OperationOutcome> getServerErrors(){\r\n    return errors;\r\n}"}, {"Path":"org.hl7.fhir.dstu3.hapi.validation.StructureMapTest.setUp","Comment":"sets up the resource paths as well as create the contexts using a defalut validator to start with.","Method":"void setUp(){\r\n    if (this.context == null) {\r\n        this.context = FhirContext.forDstu3();\r\n    }\r\n}"}, {"Path":"io.helidon.config.spi.AbstractParsableConfigSource.parse","Comment":"parser config source content into internal config structure.","Method":"ObjectNode parse(ConfigContext context,ConfigParser.Content<S> content){\r\n    return OptionalHelper.from(Optional.ofNullable(getParser())).or(() -> context.findParser(Optional.ofNullable(content.getMediaType()).orElseThrow(() -> new ConfigException(\"Unknown media type.\")))).asOptional().map(parser -> parser.parse(content)).orElseThrow(() -> new ConfigException(\"Cannot find suitable parser for '\" + content.getMediaType() + \"' media type.\"));\r\n}"}, {"Path":"org.hl7.fhir.utilities.validation.ValidationMessage.toString","Comment":"returns a representation of this validationmessage suitable for logging. the values ofmost of the internal fields are included, so this may not be suitable for display to an end user.","Method":"String toString(){\r\n    ToStringBuilder b = new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE);\r\n    b.append(\"level\", level);\r\n    b.append(\"type\", type);\r\n    b.append(\"location\", location);\r\n    b.append(\"message\", message);\r\n    return b.build();\r\n}"}, {"Path":"io.helidon.metrics.WeightedSnapshot.getStdDev","Comment":"returns the weighted standard deviation of the values in the snapshot.","Method":"double getStdDev(){\r\n    if (values.length <= 1) {\r\n        return 0;\r\n    }\r\n    final double mean = getMean();\r\n    double variance = 0;\r\n    for (int i = 0; i < values.length; i++) {\r\n        final double diff = values[i] - mean;\r\n        variance += normWeights[i] * diff * diff;\r\n    }\r\n    return Math.sqrt(variance);\r\n}"}, {"Path":"io.helidon.config.etcd.EtcdConfigSourceBuilder.from","Comment":"create new instance of builder with specified mandatory etcd endpoint remote descriptor.","Method":"EtcdConfigSourceBuilder from(URI uri,String key,EtcdApi api,EtcdConfigSourceBuilder from,Config metaConfig){\r\n    return EtcdConfigSourceBuilder.from(metaConfig.get(URI_KEY).as(URI.class), metaConfig.get(KEY_KEY).asString(), metaConfig.get(API_KEY).as(EtcdApi.class)).init(metaConfig);\r\n}"}, {"Path":"io.helidon.config.Config.mapOptionalSupplier","Comment":"returns a supplier of an optional value, typed using a specified type mapper.","Method":"Supplier<Optional<T>> mapOptionalSupplier(Function<String, ? extends T> mapper,Supplier<Optional<T>> mapOptionalSupplier,ConfigMapper<? extends T> mapper){\r\n    return () -> context().last().mapOptional(mapper);\r\n}"}, {"Path":"com.twitter.hbc.twitter4j.BaseTwitter4jClient.process","Comment":"forks off a runnable with the executor provided. multiple calls are allowed, but the listeners must bethreadsafe.","Method":"void process(){\r\n    if (client.isDone() || executorService.isTerminated()) {\r\n        throw new IllegalStateException(\"Client is already stopped\");\r\n    }\r\n    Runnable runner = new Runnable() {\r\n        @Override\r\n        public void run() {\r\n            try {\r\n                while (!client.isDone()) {\r\n                    String msg = messageQueue.take();\r\n                    try {\r\n                        parseMessage(msg);\r\n                    } catch (Exception e) {\r\n                        logger.warn(\"Exception thrown during parsing msg \" + msg, e);\r\n                        onException(e);\r\n                    }\r\n                }\r\n            } catch (Exception e) {\r\n                onException(e);\r\n            }\r\n        }\r\n    };\r\n    executorService.execute(runner);\r\n}"}, {"Path":"com.twitter.hbc.twitter4j.BaseTwitter4jClient.process","Comment":"forks off a runnable with the executor provided. multiple calls are allowed, but the listeners must bethreadsafe.","Method":"void process(){\r\n    try {\r\n        while (!client.isDone()) {\r\n            String msg = messageQueue.take();\r\n            try {\r\n                parseMessage(msg);\r\n            } catch (Exception e) {\r\n                logger.warn(\"Exception thrown during parsing msg \" + msg, e);\r\n                onException(e);\r\n            }\r\n        }\r\n    } catch (Exception e) {\r\n        onException(e);\r\n    }\r\n}"}, {"Path":"io.helidon.common.InputStreamHelper.readAllBytes","Comment":"reads all remaining bytes from the input stream.this method blocks untilall remaining bytes have been read and end of stream is detected, or anexception is thrown.","Method":"byte[] readAllBytes(InputStream is){\r\n    byte[] buf = new byte[DEFAULT_BUFFER_SIZE];\r\n    int capacity = buf.length;\r\n    int nread = 0;\r\n    int n;\r\n    for (; ; ) {\r\n        while ((n = is.read(buf, nread, capacity - nread)) > 0) {\r\n            nread += n;\r\n        }\r\n        if (n < 0) {\r\n            break;\r\n        }\r\n        if (capacity <= MAX_BUFFER_SIZE - capacity) {\r\n            capacity = capacity << 1;\r\n        } else {\r\n            if (capacity == MAX_BUFFER_SIZE) {\r\n                throw new OutOfMemoryError(\"Required array size too large\");\r\n            }\r\n            capacity = MAX_BUFFER_SIZE;\r\n        }\r\n        buf = Arrays.copyOf(buf, capacity);\r\n    }\r\n    return (capacity == nread) ? buf : Arrays.copyOf(buf, nread);\r\n}"}, {"Path":"io.helidon.microprofile.faulttolerance.CommandRetrier.updateMetricsAfter","Comment":"update metrics after method is called and depending on outcome.","Method":"void updateMetricsAfter(Throwable cause){\r\n    FaultToleranceMetrics.getCounter(method, cause == null ? FaultToleranceMetrics.INVOCATIONS_TOTAL : FaultToleranceMetrics.INVOCATIONS_FAILED_TOTAL).inc();\r\n    if (introspector.hasRetry()) {\r\n        if (cause == null) {\r\n            FaultToleranceMetrics.getCounter(method, firstInvocation ? FaultToleranceMetrics.RETRY_CALLS_SUCCEEDED_NOT_RETRIED_TOTAL : FaultToleranceMetrics.RETRY_CALLS_SUCCEEDED_RETRIED_TOTAL).inc();\r\n        } else if (!firstInvocation) {\r\n            FaultToleranceMetrics.getCounter(method, FaultToleranceMetrics.RETRY_CALLS_FAILED_TOTAL).inc();\r\n        }\r\n    }\r\n    if (introspector.hasTimeout()) {\r\n        FaultToleranceMetrics.getHistogram(method, FaultToleranceMetrics.TIMEOUT_EXECUTION_DURATION).update(command.getExecutionTime());\r\n        FaultToleranceMetrics.getCounter(method, cause instanceof TimeoutException ? FaultToleranceMetrics.TIMEOUT_CALLS_TIMED_OUT_TOTAL : FaultToleranceMetrics.TIMEOUT_CALLS_NOT_TIMED_OUT_TOTAL).inc();\r\n    }\r\n    if (introspector.hasBulkhead()) {\r\n        FaultToleranceMetrics.getHistogram(method, FaultToleranceMetrics.BULKHEAD_EXECUTION_DURATION).update(command.getExecutionTime());\r\n        FaultToleranceMetrics.getCounter(method, cause instanceof RejectedExecutionException ? FaultToleranceMetrics.BULKHEAD_CALLS_REJECTED_TOTAL : FaultToleranceMetrics.BULKHEAD_CALLS_ACCEPTED_TOTAL).inc();\r\n    }\r\n    firstInvocation = false;\r\n}"}, {"Path":"io.helidon.config.internal.ObjectNodeBuilderImpl.from","Comment":"creates new instance of the builder initialized from original map of members.","Method":"ObjectNodeBuilderImpl from(Map<String, ConfigNode> members,ObjectNodeBuilderImpl from,Map<String, ConfigNode> members,Function<String, String> resolveTokenFunction){\r\n    return new ObjectNodeBuilderImpl(resolveTokenFunction).fromMap(members);\r\n}"}, {"Path":"org.hl7.fhir.instance.validation.InstanceValidator.start","Comment":"the instance validator had no issues against the base resource profile","Method":"void start(List<ValidationMessage> errors,WrapperElement resource,WrapperElement element,StructureDefinition profile,NodeStack stack){\r\n    if (rule(errors, IssueType.STRUCTURE, element.line(), element.col(), stack.getLiteralPath(), profile.hasSnapshot(), \"StructureDefinition has no snapshot - validation is against the snapshot, so it must be provided\")) {\r\n        validateElement(errors, profile, profile.getSnapshot().getElement().get(0), null, null, resource, element, element.getName(), stack, false);\r\n        checkDeclaredProfiles(errors, resource, element, stack);\r\n        if (element.getResourceType().equals(\"Bundle\"))\r\n            validateBundle(errors, element, stack);\r\n        if (element.getResourceType().equals(\"Observation\"))\r\n            validateObservation(errors, element, stack);\r\n    }\r\n}"}, {"Path":"io.helidon.config.internal.FileSourceHelper.lastModifiedTime","Comment":"returns the last modified time of the given file or directory.","Method":"Instant lastModifiedTime(Path path){\r\n    try {\r\n        return Files.getLastModifiedTime(path.toRealPath()).toInstant();\r\n    } catch (IOException e) {\r\n        LOGGER.log(Level.FINE, e, () -> \"Cannot obtain the last modified time of '\" + path + \"'.\");\r\n    }\r\n    Instant timestamp = Instant.MAX;\r\n    LOGGER.finer(\"Cannot obtain the last modified time. Used time '\" + timestamp + \"' as a content timestamp.\");\r\n    return timestamp;\r\n}"}, {"Path":"io.helidon.config.internal.ListNodeImpl.initDescription","Comment":"initialize diagnostics description of source of node instance.","Method":"ListNodeImpl initDescription(String description){\r\n    this.description = description;\r\n    elements.forEach(node -> ObjectNodeImpl.initDescription(node, description));\r\n    return this;\r\n}"}, {"Path":"org.hl7.fhir.utilities.IniFile.timeToStr","Comment":"converts the given sql timestamp object to a string representation. the formatto be used is to be obtained from the configuration file.","Method":"String timeToStr(Timestamp pobjTS,String pstrFmt){\r\n    String strRet = null;\r\n    SimpleDateFormat dtFmt = null;\r\n    try {\r\n        dtFmt = new SimpleDateFormat(pstrFmt);\r\n        strRet = dtFmt.format(pobjTS);\r\n    } catch (IllegalArgumentException iae) {\r\n        strRet = \"\";\r\n    } catch (NullPointerException npe) {\r\n        strRet = \"\";\r\n    } finally {\r\n        if (dtFmt != null)\r\n            dtFmt = null;\r\n    }\r\n    return strRet;\r\n}"}, {"Path":"io.helidon.common.http.Utils.write","Comment":"appends the content of the given byte buffer into the given output stream.","Method":"void write(ByteBuffer byteBuffer,OutputStream out){\r\n    if (byteBuffer.hasArray()) {\r\n        out.write(byteBuffer.array(), byteBuffer.arrayOffset() + byteBuffer.position(), byteBuffer.remaining());\r\n    } else {\r\n        byte[] buff = new byte[byteBuffer.remaining()];\r\n        byteBuffer.get(buff);\r\n        out.write(buff);\r\n    }\r\n}"}, {"Path":"io.helidon.common.reactive.Flow.defaultBufferSize","Comment":"returns a default value for publisher or subscriber buffering,that may be used in the absence of other constraints.","Method":"int defaultBufferSize(){\r\n    return DEFAULT_BUFFER_SIZE;\r\n}"}, {"Path":"org.fhir.ucum.UcumEssenceService.analyse","Comment":"given a unit, return a formal description of what the units stand for using\tfull names","Method":"String analyse(String unit){\r\n    if (Utilities.noString(unit))\r\n        return \"(unity)\";\r\n    assert checkStringParam(unit) : paramError(\"analyse\", \"unit\", \"must not be null or empty\");\r\n    Term term = new ExpressionParser(model).parse(unit);\r\n    return new FormalStructureComposer().compose(term);\r\n}"}, {"Path":"io.helidon.microprofile.faulttolerance.MethodIntrospector.getHystrixProperties","Comment":"returns a collection of hystrix properties needed to configurecommands. these properties are derived from the set of annotationsfound on a method or its class.","Method":"Map<String, Object> getHystrixProperties(){\r\n    final HashMap<String, Object> result = new HashMap();\r\n    result.put(\"execution.isolation.strategy\", HystrixCommandProperties.ExecutionIsolationStrategy.THREAD);\r\n    result.put(\"circuitBreaker.enabled\", hasCircuitBreaker());\r\n    if (hasCircuitBreaker()) {\r\n        final CircuitBreaker circuitBreaker = getCircuitBreaker();\r\n        result.put(\"circuitBreaker.requestVolumeThreshold\", circuitBreaker.requestVolumeThreshold());\r\n        result.put(\"circuitBreaker.errorThresholdPercentage\", (int) (circuitBreaker.failureRatio() * 100));\r\n        result.put(\"circuitBreaker.sleepWindowInMilliseconds\", TimeUtil.convertToMillis(circuitBreaker.delay(), circuitBreaker.delayUnit()));\r\n    }\r\n    result.put(\"execution.timeout.enabled\", hasTimeout());\r\n    if (hasTimeout()) {\r\n        final Timeout timeout = getTimeout();\r\n        result.put(\"execution.isolation.thread.timeoutInMilliseconds\", TimeUtil.convertToMillis(timeout.value(), timeout.unit()));\r\n    }\r\n    return result;\r\n}"}, {"Path":"io.helidon.common.CollectionsHelper.listOf","Comment":"returns an unmodifiable list containing the given elements.","Method":"List<T> listOf(List<T> listOf,T elts){\r\n    List<T> list = new ArrayList();\r\n    list.addAll(Arrays.asList(elts));\r\n    return Collections.unmodifiableList(list);\r\n}"}, {"Path":"io.helidon.microprofile.metrics.cdi.RegistryProducer.clearApplicationRegistry","Comment":"clears application registry. this is required for the metric tcks as theyall run on the same vm and must not interfere with each other.","Method":"void clearApplicationRegistry(){\r\n    MetricRegistry applicationRegistry = getApplicationRegistry();\r\n    applicationRegistry.getNames().forEach(applicationRegistry::remove);\r\n}"}, {"Path":"io.helidon.security.examples.jersey.JerseyConfigMain.main","Comment":"main method of example. no arguments required, no configuration required.","Method":"void main(String[] args){\r\n    Routing.Builder routing = Routing.builder().register(\"/rest\", buildJersey());\r\n    server = JerseyUtil.startIt(routing);\r\n    JerseyResources.setPort(server.port());\r\n}"}, {"Path":"io.helidon.metrics.EWMA.fifteenMinuteEWMA","Comment":"creates a new ewma which is equivalent to the unix fifteen minute load average and whichexpects to be ticked every 5 seconds.","Method":"EWMA fifteenMinuteEWMA(){\r\n    return new EWMA(M15_ALPHA, INTERVAL, TimeUnit.SECONDS);\r\n}"}, {"Path":"org.hl7.fhir.utilities.IniFile.loadFile","Comment":"reads the ini file and load its contentens into a section collection after parsing the file line by line.","Method":"void loadFile(){\r\n    int iPos = -1;\r\n    String strLine = null;\r\n    String strSection = null;\r\n    String strRemarks = null;\r\n    BufferedReader objBRdr = null;\r\n    FileReader objFRdr = null;\r\n    INISection objSec = null;\r\n    try {\r\n        objFRdr = new FileReader(this.mstrFile);\r\n        if (objFRdr != null) {\r\n            objBRdr = new BufferedReader(objFRdr);\r\n            if (objBRdr != null) {\r\n                while (objBRdr.ready()) {\r\n                    iPos = -1;\r\n                    strLine = null;\r\n                    strLine = objBRdr.readLine().trim();\r\n                    if (strLine == null) {\r\n                    } else if (strLine.length() == 0) {\r\n                    } else if (strLine.substring(0, 1).equals(\";\")) {\r\n                        if (strRemarks == null)\r\n                            strRemarks = strLine.substring(1);\r\n                        else if (strRemarks.length() == 0)\r\n                            strRemarks = strLine.substring(1);\r\n                        else\r\n                            strRemarks = strRemarks + \"\\r\\n\" + strLine.substring(1);\r\n                    } else if (strLine.startsWith(\"[\") && strLine.endsWith(\"]\")) {\r\n                        if (objSec != null)\r\n                            this.mhmapSections.put(strSection.trim(), objSec);\r\n                        objSec = null;\r\n                        strSection = strLine.substring(1, strLine.length() - 1);\r\n                        objSec = new INISection(strSection.trim(), strRemarks);\r\n                        strRemarks = null;\r\n                    } else if ((iPos = strLine.indexOf(\"=\")) > 0 && objSec != null) {\r\n                        objSec.setProperty(strLine.substring(0, iPos).trim(), strLine.substring(iPos + 1).trim(), strRemarks);\r\n                        strRemarks = null;\r\n                    } else {\r\n                        objSec.setProperty(strLine, \"\", strRemarks);\r\n                    }\r\n                }\r\n                if (objSec != null)\r\n                    this.mhmapSections.put(strSection.trim(), objSec);\r\n                this.mblnLoaded = true;\r\n            }\r\n        }\r\n    } catch (FileNotFoundException FNFExIgnore) {\r\n        this.mhmapSections.clear();\r\n    } catch (IOException IOExIgnore) {\r\n        this.mhmapSections.clear();\r\n    } catch (NullPointerException NPExIgnore) {\r\n        this.mhmapSections.clear();\r\n    } finally {\r\n        if (objBRdr != null) {\r\n            closeReader(objBRdr);\r\n            objBRdr = null;\r\n        }\r\n        if (objFRdr != null) {\r\n            closeReader(objFRdr);\r\n            objFRdr = null;\r\n        }\r\n        if (objSec != null)\r\n            objSec = null;\r\n    }\r\n}"}, {"Path":"org.hl7.fhir.r4.utils.FHIRPathEngine.check","Comment":"check that paths referred to in the expressionnode are validxpathstartswithvalueref is a hack work around for the fact that fhir path sometimes needs a different starting point than the xpathreturns a list of the possible types that might be returned by executing the expressionnode against a particular context","Method":"TypeDetails check(Object appContext,String resourceType,String context,ExpressionNode expr,TypeDetails check,Object appContext,StructureDefinition sd,String context,ExpressionNode expr,TypeDetails check,Object appContext,StructureDefinition sd,ExpressionNode expr,TypeDetails check,Object appContext,String resourceType,String context,String expr){\r\n    return check(appContext, resourceType, context, parse(expr));\r\n}"}, {"Path":"io.helidon.config.OverrideSources.url","Comment":"creates new instance of the url overridesource builder to be used to bootstrap an url overridesource instance.","Method":"AbstractOverrideSource.Builder<? extends AbstractOverrideSource.Builder<?, URL>, URL> url(URL url){\r\n    return new UrlOverrideSource.UrlBuilder(url);\r\n}"}, {"Path":"io.helidon.config.spi.AbstractSource.reload","Comment":"reloads the source and fires an event if the data was changed.","Method":"void reload(){\r\n    LOGGER.log(Level.FINEST, \"reload\");\r\n    boolean hasChanged = false;\r\n    Optional<Data<T, S>> newData = loadDataChangedSinceLastLoad();\r\n    if (newData.isPresent()) {\r\n        Optional<T> newObjectNode = newData.get().data();\r\n        if (lastData.isPresent()) {\r\n            Optional<T> lastObjectNode = lastData.get().data();\r\n            hasChanged = hasChanged(lastObjectNode, newObjectNode);\r\n        } else {\r\n            hasChanged = true;\r\n        }\r\n        lastData = newData;\r\n    }\r\n    if (hasChanged) {\r\n        fireChangeEvent();\r\n    } else {\r\n        LOGGER.log(Level.FINE, String.format(\"Source data %s has not changed.\", description()));\r\n    }\r\n}"}, {"Path":"io.helidon.config.Config.asListSupplier","Comment":"returns a supplier of a list of a specified type or a default value.","Method":"Supplier<List<T>> asListSupplier(Class<? extends T> type,Supplier<List<T>> asListSupplier,Class<? extends T> type,List<T> defaultValue){\r\n    return () -> context().last().asList(type, defaultValue);\r\n}"}, {"Path":"org.hl7.fhir.r4.utils.client.FHIRToolingClient.handleException","Comment":"helper method to prevent nesting of previously thrown efhirclientexceptions","Method":"void handleException(String message,Exception e){\r\n    if (e instanceof EFhirClientException) {\r\n        throw (EFhirClientException) e;\r\n    } else {\r\n        throw new EFhirClientException(message, e);\r\n    }\r\n}"}, {"Path":"io.helidon.config.internal.ObjectNodeBuilderImpl.fromMap","Comment":"creates new instance of the builder initialized from original map of members.","Method":"ObjectNodeBuilderImpl fromMap(Map<String, ConfigNode> members){\r\n    members.forEach(this::addNode);\r\n    return this;\r\n}"}, {"Path":"io.helidon.common.configurable.ScheduledThreadPoolSupplier.create","Comment":"create a new thread pool supplier with default configuration.","Method":"ScheduledThreadPoolSupplier create(Config config,ScheduledThreadPoolSupplier create){\r\n    return builder().build();\r\n}"}, {"Path":"io.helidon.config.PollingStrategies.nop","Comment":"provides a default polling strategy that does not fire an event at all.","Method":"PollingStrategy nop(){\r\n    return NopPollingStrategyHolder.NOP;\r\n}"}, {"Path":"io.helidon.demo.todos.backend.DbService.get","Comment":"get the todo entry identified by the given id from the database.","Method":"Optional<Todo> get(SpanContext tracingSpan,String id,String userId){\r\n    return execute(tracingSpan, \"cassandra::get\", () -> getNoContext(id, userId));\r\n}"}, {"Path":"io.helidon.microprofile.faulttolerance.FaultToleranceCommand.execute","Comment":"executes this command returning a result or throwing an exception.","Method":"Object execute(){\r\n    introspector.getHystrixProperties().entrySet().forEach(entry -> setProperty(entry.getKey(), entry.getValue()));\r\n    if (introspector.hasCircuitBreaker()) {\r\n        breakerHelper.ensureConsistentState();\r\n        LOGGER.info(\"Circuit breaker for \" + getCommandKey() + \" in state \" + breakerHelper.getState());\r\n    }\r\n    boolean wasBreakerOpen = isCircuitBreakerOpen();\r\n    if (introspector.hasBulkhead()) {\r\n        bulkheadHelper.trackInvocation(this);\r\n    }\r\n    Object result = null;\r\n    Throwable throwable = null;\r\n    long startNanos = System.nanoTime();\r\n    try {\r\n        result = super.execute();\r\n    } catch (Throwable t) {\r\n        throwable = t;\r\n    }\r\n    executionTime = System.nanoTime() - startNanos;\r\n    boolean hasFailed = (throwable != null);\r\n    if (introspector.hasCircuitBreaker()) {\r\n        breakerHelper.pushResult(throwable == null);\r\n        boolean breakerWillOpen = false;\r\n        boolean isClosedNow = !isCircuitBreakerOpen();\r\n        if (hasFailed) {\r\n            final Throwable throwableFinal = throwable;\r\n            Class<? extends Throwable>[] throwableClasses = introspector.getCircuitBreaker().failOn();\r\n            boolean failOn = Arrays.asList(throwableClasses).stream().anyMatch(c -> c.isAssignableFrom(throwableFinal.getClass()));\r\n            if (!failOn) {\r\n                restoreBreaker();\r\n                updateMetricsAfter(throwable, wasBreakerOpen, breakerWillOpen);\r\n                throw ExceptionUtil.wrapThrowable(throwable);\r\n            }\r\n        }\r\n        synchronized (breakerHelper.getSyncObject()) {\r\n            if (hasFailed) {\r\n                if (breakerHelper.getState() == CircuitBreakerHelper.State.HALF_OPEN_MP) {\r\n                    runTripBreaker();\r\n                    breakerHelper.setState(CircuitBreakerHelper.State.OPEN_MP);\r\n                } else if (breakerHelper.getState() == CircuitBreakerHelper.State.CLOSED_MP) {\r\n                    double failureRatio = breakerHelper.getFailureRatio();\r\n                    if (failureRatio >= introspector.getCircuitBreaker().failureRatio()) {\r\n                        breakerWillOpen = true;\r\n                        breakerHelper.setState(CircuitBreakerHelper.State.OPEN_MP);\r\n                    }\r\n                }\r\n                updateMetricsAfter(throwable, wasBreakerOpen, breakerWillOpen);\r\n                throw ExceptionUtil.wrapThrowable(throwable);\r\n            }\r\n            if (wasBreakerOpen && isClosedNow) {\r\n                breakerHelper.incSuccessCount();\r\n                if (breakerHelper.getSuccessCount() < introspector.getCircuitBreaker().successThreshold()) {\r\n                    breakerHelper.setState(CircuitBreakerHelper.State.HALF_OPEN_MP);\r\n                } else {\r\n                    breakerHelper.setState(CircuitBreakerHelper.State.CLOSED_MP);\r\n                    breakerHelper.resetCommandData();\r\n                }\r\n            }\r\n        }\r\n        updateMetricsAfter(throwable, wasBreakerOpen, breakerWillOpen);\r\n    }\r\n    if (introspector.hasBulkhead()) {\r\n        bulkheadHelper.untrackInvocation(this);\r\n    }\r\n    if (throwable != null) {\r\n        throw ExceptionUtil.wrapThrowable(throwable);\r\n    } else {\r\n        return result;\r\n    }\r\n}"}, {"Path":"io.helidon.demo.todos.backend.DbService.delete","Comment":"delete the todo entry identified by the given id in from the database.","Method":"Optional<Todo> delete(SpanContext tracingSpan,String id,String userId){\r\n    return execute(tracingSpan, \"cassandra::delete\", () -> getNoContext(id, userId).map(todo -> {\r\n        BoundStatement bs = deleteStatement.bind(id);\r\n        ResultSet rs = session.execute(bs);\r\n        if (!rs.wasApplied()) {\r\n            throw new RuntimeException(\"Failed to delete todo: \" + todo);\r\n        }\r\n        return todo;\r\n    }));\r\n}"}, {"Path":"org.hl7.fhir.utilities.IniFile.getDateProperty","Comment":"returns the specified date property from the specified section.","Method":"Date getDateProperty(String pstrSection,String pstrProp){\r\n    Date dtRet = null;\r\n    String strVal = null;\r\n    DateFormat dtFmt = null;\r\n    INIProperty objProp = null;\r\n    INISection objSec = null;\r\n    objSec = (INISection) this.mhmapSections.get(pstrSection);\r\n    if (objSec != null) {\r\n        objProp = objSec.getProperty(pstrProp);\r\n        try {\r\n            if (objProp != null)\r\n                strVal = objProp.getPropValue();\r\n            if (strVal != null) {\r\n                dtFmt = new SimpleDateFormat(this.mstrDateFmt);\r\n                dtRet = dtFmt.parse(strVal);\r\n            }\r\n        } catch (ParseException PExIgnore) {\r\n        } catch (IllegalArgumentException IAEx) {\r\n        } finally {\r\n            if (objProp != null)\r\n                objProp = null;\r\n        }\r\n        objSec = null;\r\n    }\r\n    return dtRet;\r\n}"}, {"Path":"io.helidon.microprofile.faulttolerance.MethodIntrospector.isAnnotationPresent","Comment":"determines if annotation type is present on the method or its class.","Method":"boolean isAnnotationPresent(Class<? extends Annotation> clazz){\r\n    return getAnnotation(clazz) != null;\r\n}"}, {"Path":"org.hl7.fhir.r4.validation.FhirInstanceValidatorR4Test.testInvalidLocalReference","Comment":"an invalid local reference should not cause a serviceexception.","Method":"void testInvalidLocalReference(){\r\n    QuestionnaireResponse resource = new QuestionnaireResponse();\r\n    resource.setStatus(QuestionnaireResponse.QuestionnaireResponseStatus.COMPLETED);\r\n    resource.getText().setDiv(new XhtmlNode().setValue(\"<div>AA<\/div>\")).setStatus(Narrative.NarrativeStatus.GENERATED);\r\n    resource.setSubject(new Reference(\"#invalid-ref\"));\r\n    ValidationResult output = myVal.validateWithResult(resource);\r\n    List<SingleValidationMessage> nonInfo = logResultsAndReturnNonInformationalOnes(output);\r\n    assertThat(nonInfo, hasSize(2));\r\n}"}, {"Path":"org.hl7.fhir.utilities.IniFile.getProperties","Comment":"returns a map containing all the properties under specified section.","Method":"Map<String, INIProperty> getProperties(String pstrSection,Map<String, INIProperty> getProperties){\r\n    Map<String, INIProperty> hmRet = null;\r\n    INISection objSec = null;\r\n    objSec = (INISection) this.mhmapSections.get(pstrSection);\r\n    if (objSec != null) {\r\n        hmRet = objSec.getProperties();\r\n        objSec = null;\r\n    }\r\n    return hmRet;\r\n}"}, {"Path":"ca.uhn.fhir.rest.client.ClientR4Test.testUpdateWithEmptyResponse","Comment":"return a fhir content type, but no content and make sure we handle this without crashing","Method":"void testUpdateWithEmptyResponse(){\r\n    Patient patient = new Patient();\r\n    patient.addIdentifier().setSystem(\"urn:foo\").setValue(\"123\");\r\n    ArgumentCaptor<HttpUriRequest> capt = ArgumentCaptor.forClass(HttpUriRequest.class);\r\n    when(myHttpClient.execute(capt.capture())).thenReturn(myHttpResponse);\r\n    when(myHttpResponse.getStatusLine()).thenReturn(new BasicStatusLine(new ProtocolVersion(\"HTTP\", 1, 1), 201, \"OK\"));\r\n    when(myHttpResponse.getEntity().getContentType()).thenReturn(new BasicHeader(\"content-type\", Constants.CT_FHIR_XML + \"; charset=UTF-8\"));\r\n    when(myHttpResponse.getEntity().getContent()).thenReturn(new ReaderInputStream(new StringReader(\"\"), Charset.forName(\"UTF-8\")));\r\n    when(myHttpResponse.getAllHeaders()).thenReturn(toHeaderArray(Constants.HEADER_LOCATION, \"http://example.com/fhir/Patient/100/_history/200\"));\r\n    ITestClient client = ourCtx.newRestfulClient(ITestClient.class, \"http://foo\");\r\n    MethodOutcome resp = client.updatePatient(new IdType(\"Patient/100/_history/200\"), patient);\r\n    assertNull(resp.getResource());\r\n    assertNull(resp.getOperationOutcome());\r\n    assertEquals(HttpPut.class, capt.getValue().getClass());\r\n    HttpPut post = (HttpPut) capt.getValue();\r\n    assertEquals(\"http://foo/Patient/100\", post.getURI().toASCIIString());\r\n}"}, {"Path":"com.twitter.hbc.ReconnectionManagerTest.testBackoffSwitching","Comment":"backoff manager backs off correctly when switching from one to the other","Method":"void testBackoffSwitching(){\r\n    BasicReconnectionManager b = new BasicReconnectionManager(10);\r\n    assertEquals(BasicReconnectionManager.INITIAL_LINEAR_BACKOFF_MILLIS, b.incrAndGetLinearBackoff());\r\n    assertEquals(BasicReconnectionManager.INITIAL_LINEAR_BACKOFF_MILLIS * 2, b.incrAndGetLinearBackoff());\r\n    assertEquals(BasicReconnectionManager.INITIAL_LINEAR_BACKOFF_MILLIS * 3, b.incrAndGetLinearBackoff());\r\n    assertEquals(BasicReconnectionManager.INITIAL_LINEAR_BACKOFF_MILLIS * 4, b.incrAndGetLinearBackoff());\r\n    assertEquals(BasicReconnectionManager.INITIAL_EXPONENTIAL_BACKOFF_MILLIS, b.incrAndGetExponentialBackoff());\r\n    assertEquals(BasicReconnectionManager.INITIAL_EXPONENTIAL_BACKOFF_MILLIS * 2, b.incrAndGetExponentialBackoff());\r\n    assertEquals(BasicReconnectionManager.INITIAL_EXPONENTIAL_BACKOFF_MILLIS * 4, b.incrAndGetExponentialBackoff());\r\n    assertEquals(BasicReconnectionManager.INITIAL_EXPONENTIAL_BACKOFF_MILLIS * 8, b.incrAndGetExponentialBackoff());\r\n    assertEquals(BasicReconnectionManager.INITIAL_LINEAR_BACKOFF_MILLIS, b.incrAndGetLinearBackoff());\r\n    assertEquals(BasicReconnectionManager.INITIAL_LINEAR_BACKOFF_MILLIS * 2, b.incrAndGetLinearBackoff());\r\n}"}, {"Path":"org.hl7.fhir.utilities.IniFile.loadStream","Comment":"reads the ini file and load its contentens into a section collection after parsing the file line by line.","Method":"void loadStream(InputStream stream){\r\n    int iPos = -1;\r\n    String strLine = null;\r\n    String strSection = null;\r\n    String strRemarks = null;\r\n    BufferedReader objBRdr = null;\r\n    InputStreamReader objFRdr = null;\r\n    INISection objSec = null;\r\n    try {\r\n        objFRdr = new InputStreamReader(stream);\r\n        if (objFRdr != null) {\r\n            objBRdr = new BufferedReader(objFRdr);\r\n            if (objBRdr != null) {\r\n                while (objBRdr.ready()) {\r\n                    iPos = -1;\r\n                    strLine = null;\r\n                    strLine = objBRdr.readLine().trim();\r\n                    if (strLine == null) {\r\n                    } else if (strLine.length() == 0) {\r\n                    } else if (strLine.substring(0, 1).equals(\";\")) {\r\n                        if (strRemarks == null)\r\n                            strRemarks = strLine.substring(1);\r\n                        else if (strRemarks.length() == 0)\r\n                            strRemarks = strLine.substring(1);\r\n                        else\r\n                            strRemarks = strRemarks + \"\\r\\n\" + strLine.substring(1);\r\n                    } else if (strLine.startsWith(\"[\") && strLine.endsWith(\"]\")) {\r\n                        if (objSec != null)\r\n                            this.mhmapSections.put(strSection.trim(), objSec);\r\n                        objSec = null;\r\n                        strSection = strLine.substring(1, strLine.length() - 1);\r\n                        objSec = new INISection(strSection.trim(), strRemarks);\r\n                        strRemarks = null;\r\n                    } else if ((iPos = strLine.indexOf(\"=\")) > 0 && objSec != null) {\r\n                        objSec.setProperty(strLine.substring(0, iPos).trim(), strLine.substring(iPos + 1).trim(), strRemarks);\r\n                        strRemarks = null;\r\n                    } else {\r\n                        objSec.setProperty(strLine, \"\", strRemarks);\r\n                    }\r\n                }\r\n                if (objSec != null)\r\n                    this.mhmapSections.put(strSection.trim(), objSec);\r\n                this.mblnLoaded = true;\r\n            }\r\n        }\r\n    } catch (FileNotFoundException FNFExIgnore) {\r\n        this.mhmapSections.clear();\r\n    } catch (IOException IOExIgnore) {\r\n        this.mhmapSections.clear();\r\n    } catch (NullPointerException NPExIgnore) {\r\n        this.mhmapSections.clear();\r\n    } finally {\r\n        if (objBRdr != null) {\r\n            closeReader(objBRdr);\r\n            objBRdr = null;\r\n        }\r\n        if (objFRdr != null) {\r\n            closeReader(objFRdr);\r\n            objFRdr = null;\r\n        }\r\n        if (objSec != null)\r\n            objSec = null;\r\n    }\r\n}"}, {"Path":"org.hl7.fhir.utilities.IniFile.removeSection","Comment":"removes the specified section if one exists, otherwise does nothing.","Method":"void removeSection(String pstrSection){\r\n    if (this.mhmapSections.containsKey(pstrSection))\r\n        this.mhmapSections.remove(pstrSection);\r\n}"}, {"Path":"com.twitter.hbc.common.DelimitedStreamReader.copyToStrBuffer","Comment":"copies from buffer to our internal strbufferindex, expanding the internal buffer if necessary","Method":"void copyToStrBuffer(byte[] buffer,int offset,int length){\r\n    Preconditions.checkArgument(length >= 0);\r\n    if (strBuffer.length - strBufferIndex < length) {\r\n        expandStrBuffer(length);\r\n    }\r\n    System.arraycopy(buffer, offset, strBuffer, strBufferIndex, Math.min(length, MAX_ALLOWABLE_BUFFER_SIZE - strBufferIndex));\r\n    strBufferIndex += length;\r\n}"}, {"Path":"io.helidon.config.internal.ListNodeBuilderImpl.from","Comment":"creates new instance of the builder initialized from original list of elements.","Method":"ListNodeBuilderImpl from(List<ConfigNode> elements,ListNodeBuilderImpl from,List<ConfigNode> elements,Function<String, String> resolveTokenFunction){\r\n    ListNodeBuilderImpl builder = new ListNodeBuilderImpl(resolveTokenFunction);\r\n    elements.forEach(builder::addNode);\r\n    return builder;\r\n}"}, {"Path":"io.helidon.config.Config.mapListSupplier","Comment":"returns a supplier of a list of a type provided by a specified type mapper or a default value.","Method":"Supplier<List<T>> mapListSupplier(ConfigMapper<? extends T> mapper,Supplier<List<T>> mapListSupplier,ConfigMapper<? extends T> mapper,List<T> defaultValue,Supplier<List<T>> mapListSupplier,Function<String, ? extends T> mapper,Supplier<List<T>> mapListSupplier,Function<String, ? extends T> mapper,List<T> defaultValue){\r\n    return () -> context().last().mapList(mapper, defaultValue);\r\n}"}, {"Path":"io.helidon.security.abac.scope.ScopeValidator.create","Comment":"create an instance of scope validator with default configuration.","Method":"ScopeValidator create(){\r\n    return ScopeValidator.builder().build();\r\n}"}, {"Path":"org.hl7.fhir.utilities.IniFile.getTimestampProperty","Comment":"returns the specified date property from the specified section.","Method":"Date getTimestampProperty(String pstrSection,String pstrProp){\r\n    Timestamp tsRet = null;\r\n    Date dtTmp = null;\r\n    String strVal = null;\r\n    DateFormat dtFmt = null;\r\n    INIProperty objProp = null;\r\n    INISection objSec = null;\r\n    objSec = (INISection) this.mhmapSections.get(pstrSection);\r\n    if (objSec != null) {\r\n        objProp = objSec.getProperty(pstrProp);\r\n        try {\r\n            if (objProp != null)\r\n                strVal = objProp.getPropValue();\r\n            if (strVal != null) {\r\n                dtFmt = new SimpleDateFormat(this.mstrDateFmt);\r\n                dtTmp = dtFmt.parse(strVal);\r\n                tsRet = new Timestamp(dtTmp.getTime());\r\n            }\r\n        } catch (ParseException PExIgnore) {\r\n        } catch (IllegalArgumentException IAEx) {\r\n        } finally {\r\n            if (objProp != null)\r\n                objProp = null;\r\n        }\r\n        objSec = null;\r\n    }\r\n    return tsRet;\r\n}"}, {"Path":"org.hl7.fhir.utilities.IniFile.getAllSectionNames","Comment":"returns a string array containing names of all sections in ini file.","Method":"String[] getAllSectionNames(){\r\n    int iCntr = 0;\r\n    Iterator<String> iter = null;\r\n    String[] arrRet = null;\r\n    try {\r\n        if (this.mhmapSections.size() > 0) {\r\n            arrRet = new String[this.mhmapSections.size()];\r\n            for (iter = this.mhmapSections.keySet().iterator(); ; iter.hasNext()) {\r\n                arrRet[iCntr] = (String) iter.next();\r\n                iCntr++;\r\n            }\r\n        }\r\n    } catch (NoSuchElementException NSEExIgnore) {\r\n    } finally {\r\n        if (iter != null)\r\n            iter = null;\r\n    }\r\n    return arrRet;\r\n}"}, {"Path":"io.helidon.config.PollingStrategies.watch","Comment":"provides a filesystem watch polling strategy with a specified watched path.","Method":"FilesystemWatchBuilder watch(Path watchedPath){\r\n    return new FilesystemWatchBuilder(watchedPath);\r\n}"}, {"Path":"io.helidon.common.configurable.ThreadPoolSupplier.create","Comment":"create a new thread pool supplier with default configuration.","Method":"ThreadPoolSupplier create(Config config,ThreadPoolSupplier create){\r\n    return builder().build();\r\n}"}, {"Path":"io.helidon.common.reactive.valve.Tank.whenDrain","Comment":"provided handler is called a single time when internal capacity is maximally half full and instance is not closed.","Method":"void whenDrain(Runnable drainHandler){\r\n    Objects.requireNonNull(drainHandler, \"Parameter 'drainHandler' is null!\");\r\n    checkClosed();\r\n    if (!inDrainHandler.get() && remainingCapacity() >= (capacity / 2)) {\r\n        inDrainHandler.set(true);\r\n        try {\r\n            drainHandler.run();\r\n        } finally {\r\n            inDrainHandler.set(false);\r\n        }\r\n    } else {\r\n        drainHandlers.add(drainHandler);\r\n    }\r\n}"}, {"Path":"io.helidon.config.internal.ObjectNodeImpl.initDescription","Comment":"initialize diagnostics description of source of node instance.","Method":"void initDescription(ConfigNode node,String description,ObjectNodeImpl initDescription,String description){\r\n    this.description = description;\r\n    members.values().forEach(node -> initDescription(node, description));\r\n    return this;\r\n}"}, {"Path":"org.hl7.fhir.r4.utils.FHIRPathEngine.convertToString","Comment":"worker routine for converting a set of objects to a string representation","Method":"String convertToString(List<Base> items,String convertToString,Base item){\r\n    if (item.isPrimitive())\r\n        return item.primitiveValue();\r\n    else if (item instanceof Quantity) {\r\n        Quantity q = (Quantity) item;\r\n        if (q.getSystem().equals(\"http://unitsofmeasure.org\")) {\r\n            String u = \"'\" + q.getCode() + \"'\";\r\n            boolean plural = !q.getValue().toPlainString().equals(\"1\");\r\n            if (\"a\".equals(q.getCode()))\r\n                u = plural ? \"years\" : \"year\";\r\n            else if (\"mo\".equals(q.getCode()))\r\n                u = plural ? \"months\" : \"month\";\r\n            else if (\"wk\".equals(q.getCode()))\r\n                u = plural ? \"weeks\" : \"week\";\r\n            else if (\"d\".equals(q.getCode()))\r\n                u = plural ? \"days\" : \"day\";\r\n            else if (\"h\".equals(q.getCode()))\r\n                u = plural ? \"hours\" : \"hour\";\r\n            else if (\"min\".equals(q.getCode()))\r\n                u = plural ? \"minutes\" : \"minute\";\r\n            else if (\"s\".equals(q.getCode()))\r\n                u = plural ? \"seconds\" : \"seconds\";\r\n            else if (\"ms\".equals(q.getCode()))\r\n                u = plural ? \"milliseconds\" : \"milliseconds\";\r\n            return q.getValue().toPlainString() + \" \" + u;\r\n        } else\r\n            return item.toString();\r\n    } else\r\n        return item.toString();\r\n}"}, {"Path":"io.helidon.common.Errors.checkValid","Comment":"check if these messages are a valid result, throws exception if not.","Method":"void checkValid(){\r\n    if (hasFatal) {\r\n        throw new ErrorMessagesException(this);\r\n    }\r\n}"}, {"Path":"io.helidon.config.git.GitConfigSourceBuilder.directory","Comment":"sets a directory where the repository is cloned or should be cloned.","Method":"GitConfigSourceBuilder directory(Path directory){\r\n    this.directory = directory;\r\n    return this;\r\n}"}, {"Path":"io.helidon.microprofile.health.HealthEndpoint.getHealth","Comment":"gets an http response in the form of json to a request for health.","Method":"Response getHealth(){\r\n    final AtomicBoolean incomplete = new AtomicBoolean();\r\n    final List<HealthCheckResponse> responses = healthChecks.stream().map(hc -> {\r\n        try {\r\n            return hc.call();\r\n        } catch (Exception e) {\r\n            incomplete.set(true);\r\n            LOGGER.log(Level.SEVERE, \"Failed to compute health check for \" + hc.getClass().getName(), e);\r\n            return HealthCheckResponse.named(hc.getClass().getName()).withData(\"message\", \"Failed to compute health. Check logs.\").down().build();\r\n        }\r\n    }).filter(response -> includeAll || includedHealthChecks.contains(response.getName())).filter(response -> !excludedHealthChecks.contains(response.getName())).sorted(Comparator.comparing(HealthCheckResponse::getName)).collect(Collectors.toList());\r\n    final HealthCheckResponse.State outcome = responses.stream().anyMatch(response -> response.getState() == HealthCheckResponse.State.DOWN) ? HealthCheckResponse.State.DOWN : HealthCheckResponse.State.UP;\r\n    final JsonObject result = toJson(outcome, responses);\r\n    if (incomplete.get()) {\r\n        return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(result).build();\r\n    }\r\n    switch(outcome) {\r\n        case UP:\r\n            return Response.status(Response.Status.OK).entity(result).build();\r\n        case DOWN:\r\n            return Response.status(Response.Status.SERVICE_UNAVAILABLE).entity(result).build();\r\n        default:\r\n            LOGGER.severe(\"Unexpected outcome: \" + outcome);\r\n            return Response.status(Response.Status.INTERNAL_SERVER_ERROR).entity(result).build();\r\n    }\r\n}"}, {"Path":"io.helidon.config.ConfigMappers.safeMap","Comment":"utility method wrapping an arbitrary mapping function and ensuring proper exceptions are produced if needed.","Method":"T safeMap(Config.Key key,String value,Function<String, T> mapper){\r\n    try {\r\n        return mapper.apply(value);\r\n    } catch (ConfigMappingException ex) {\r\n        throw ex;\r\n    } catch (RuntimeException ex) {\r\n        throw new ConfigMappingException(key, value, \"Invocation of mapper '\" + mapper + \"' has failed with an exception.\", ex);\r\n    }\r\n}"}, {"Path":"org.hl7.fhir.utilities.IniFile.getLongProperty","Comment":"returns the specified long property from the specified section.","Method":"Long getLongProperty(String pstrSection,String pstrProp){\r\n    Long lngRet = null;\r\n    String strVal = null;\r\n    INIProperty objProp = null;\r\n    INISection objSec = null;\r\n    objSec = (INISection) this.mhmapSections.get(pstrSection);\r\n    if (objSec != null) {\r\n        objProp = objSec.getProperty(pstrProp);\r\n        try {\r\n            if (objProp != null) {\r\n                strVal = objProp.getPropValue();\r\n                if (strVal != null)\r\n                    lngRet = new Long(strVal);\r\n            }\r\n        } catch (NumberFormatException NFExIgnore) {\r\n        } finally {\r\n            if (objProp != null)\r\n                objProp = null;\r\n        }\r\n        objSec = null;\r\n    }\r\n    return lngRet;\r\n}"}, {"Path":"ca.uhn.example.servlet.ExampleRestfulServlet.initialize","Comment":"this method is called automatically when the\tservlet is initializing.","Method":"void initialize(){\r\n    List<IResourceProvider> providers = new ArrayList<IResourceProvider>();\r\n    providers.add(new PatientResourceProvider());\r\n    providers.add(new OrganizationResourceProvider());\r\n    setResourceProviders(providers);\r\n    INarrativeGenerator narrativeGen = new DefaultThymeleafNarrativeGenerator();\r\n    getFhirContext().setNarrativeGenerator(narrativeGen);\r\n    CorsConfiguration config = new CorsConfiguration();\r\n    CorsInterceptor corsInterceptor = new CorsInterceptor(config);\r\n    config.addAllowedHeader(\"Accept\");\r\n    config.addAllowedHeader(\"Content-Type\");\r\n    config.addAllowedOrigin(\"*\");\r\n    config.addExposedHeader(\"Location\");\r\n    config.addExposedHeader(\"Content-Location\");\r\n    config.setAllowedMethods(Arrays.asList(\"GET\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\"));\r\n    registerInterceptor(corsInterceptor);\r\n    registerInterceptor(new ResponseHighlighterInterceptor());\r\n    setDefaultPrettyPrint(true);\r\n}"}, {"Path":"io.helidon.microprofile.faulttolerance.CommandScheduler.create","Comment":"if no command scheduler exists, creates one using default values.","Method":"CommandScheduler create(Config config,CommandScheduler create){\r\n    if (instance == null) {\r\n        instance = new CommandScheduler(ScheduledThreadPoolSupplier.create());\r\n    }\r\n    return instance;\r\n}"}, {"Path":"io.helidon.common.reactive.SingleSubscriberHolder.get","Comment":"get the stored subscriber.this method blocks indefinitely until a subscriber is registered or the holder has been closed.","Method":"Flow.Subscriber<? super T> get(){\r\n    return subscriber.get();\r\n}"}]